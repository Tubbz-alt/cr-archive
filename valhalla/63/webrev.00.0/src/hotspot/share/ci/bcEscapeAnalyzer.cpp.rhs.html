<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/bcEscapeAnalyzer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  27 #include &quot;ci/ciConstant.hpp&quot;
  28 #include &quot;ci/ciField.hpp&quot;
  29 #include &quot;ci/ciMethodBlocks.hpp&quot;
  30 #include &quot;ci/ciStreams.hpp&quot;
  31 #include &quot;interpreter/bytecode.hpp&quot;
  32 #include &quot;oops/oop.inline.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 #include &quot;utilities/bitMap.inline.hpp&quot;
  35 #include &quot;utilities/copy.hpp&quot;
  36 
  37 #ifndef PRODUCT
  38   #define TRACE_BCEA(level, code)                                            \
  39     if (EstimateArgEscape &amp;&amp; BCEATraceLevel &gt;= level) {                        \
  40       code;                                                                  \
  41     }
  42 #else
  43   #define TRACE_BCEA(level, code)
  44 #endif
  45 
  46 // Maintain a map of which arguments a local variable or
  47 // stack slot may contain.  In addition to tracking
  48 // arguments, it tracks two special values, &quot;allocated&quot;
  49 // which represents any object allocated in the current
  50 // method, and &quot;unknown&quot; which is any other object.
  51 // Up to 30 arguments are handled, with the last one
  52 // representing summary information for any extra arguments
  53 class BCEscapeAnalyzer::ArgumentMap {
  54   uint  _bits;
  55   enum {MAXBIT = 29,
  56         ALLOCATED = 1,
  57         UNKNOWN = 2};
  58 
  59   uint int_to_bit(uint e) const {
  60     if (e &gt; MAXBIT)
  61       e = MAXBIT;
  62     return (1 &lt;&lt; (e + 2));
  63   }
  64 
  65 public:
  66   ArgumentMap()                         { _bits = 0;}
  67   void set_bits(uint bits)              { _bits = bits;}
  68   uint get_bits() const                 { return _bits;}
  69   void clear()                          { _bits = 0;}
  70   void set_all()                        { _bits = ~0u; }
  71   bool is_empty() const                 { return _bits == 0; }
  72   bool contains(uint var) const         { return (_bits &amp; int_to_bit(var)) != 0; }
  73   bool is_singleton(uint var) const     { return (_bits == int_to_bit(var)); }
  74   bool contains_unknown() const         { return (_bits &amp; UNKNOWN) != 0; }
  75   bool contains_allocated() const       { return (_bits &amp; ALLOCATED) != 0; }
  76   bool contains_vars() const            { return (_bits &amp; (((1 &lt;&lt; MAXBIT) -1) &lt;&lt; 2)) != 0; }
  77   void set(uint var)                    { _bits = int_to_bit(var); }
  78   void add(uint var)                    { _bits |= int_to_bit(var); }
  79   void add_unknown()                    { _bits = UNKNOWN; }
  80   void add_allocated()                  { _bits = ALLOCATED; }
  81   void set_union(const ArgumentMap &amp;am)     { _bits |= am._bits; }
  82   void set_difference(const ArgumentMap &amp;am) { _bits &amp;=  ~am._bits; }
<a name="2" id="anc2"></a>
  83   bool operator==(const ArgumentMap &amp;am) { return _bits == am._bits; }
  84   bool operator!=(const ArgumentMap &amp;am) { return _bits != am._bits; }
  85 };
  86 
  87 class BCEscapeAnalyzer::StateInfo {
  88 public:
  89   ArgumentMap *_vars;
  90   ArgumentMap *_stack;
  91   int _stack_height;
  92   int _max_stack;
  93   bool _initialized;
  94   ArgumentMap empty_map;
  95 
  96   StateInfo() {
  97     empty_map.clear();
  98   }
  99 
 100   ArgumentMap raw_pop()  { guarantee(_stack_height &gt; 0, &quot;stack underflow&quot;); return _stack[--_stack_height]; }
 101   ArgumentMap  apop()    { return raw_pop(); }
 102   void spop()            { raw_pop(); }
 103   void lpop()            { spop(); spop(); }
 104   void raw_push(ArgumentMap i)   { guarantee(_stack_height &lt; _max_stack, &quot;stack overflow&quot;); _stack[_stack_height++] = i; }
 105   void apush(ArgumentMap i)      { raw_push(i); }
 106   void spush()           { raw_push(empty_map); }
 107   void lpush()           { spush(); spush(); }
 108 
 109 };
 110 
 111 void BCEscapeAnalyzer::set_returned(ArgumentMap vars) {
 112   for (int i = 0; i &lt; _arg_size; i++) {
 113     if (vars.contains(i))
 114       _arg_returned.set(i);
 115   }
 116   _return_local = _return_local &amp;&amp; !(vars.contains_unknown() || vars.contains_allocated());
 117   _return_allocated = _return_allocated &amp;&amp; vars.contains_allocated() &amp;&amp; !(vars.contains_unknown() || vars.contains_vars());
 118 }
 119 
 120 // return true if any element of vars is an argument
 121 bool BCEscapeAnalyzer::is_argument(ArgumentMap vars) {
 122   for (int i = 0; i &lt; _arg_size; i++) {
 123     if (vars.contains(i))
 124       return true;
 125   }
 126   return false;
 127 }
 128 
 129 // return true if any element of vars is an arg_stack argument
 130 bool BCEscapeAnalyzer::is_arg_stack(ArgumentMap vars){
 131   if (_conservative)
 132     return true;
 133   for (int i = 0; i &lt; _arg_size; i++) {
 134     if (vars.contains(i) &amp;&amp; _arg_stack.test(i))
 135       return true;
 136   }
 137   return false;
 138 }
 139 
 140 // return true if all argument elements of vars are returned
 141 bool BCEscapeAnalyzer::returns_all(ArgumentMap vars) {
 142   for (int i = 0; i &lt; _arg_size; i++) {
 143     if (vars.contains(i) &amp;&amp; !_arg_returned.test(i)) {
 144       return false;
 145     }
 146   }
 147   return true;
 148 }
 149 
 150 void BCEscapeAnalyzer::clear_bits(ArgumentMap vars, VectorSet &amp;bm) {
 151   for (int i = 0; i &lt; _arg_size; i++) {
 152     if (vars.contains(i)) {
 153       bm.remove(i);
 154     }
 155   }
 156 }
 157 
 158 void BCEscapeAnalyzer::set_method_escape(ArgumentMap vars) {
 159   clear_bits(vars, _arg_local);
 160   if (vars.contains_allocated()) {
 161     _allocated_escapes = true;
 162   }
 163 }
 164 
 165 void BCEscapeAnalyzer::set_global_escape(ArgumentMap vars, bool merge) {
 166   clear_bits(vars, _arg_local);
 167   clear_bits(vars, _arg_stack);
 168   if (vars.contains_allocated())
 169     _allocated_escapes = true;
 170 
 171   if (merge &amp;&amp; !vars.is_empty()) {
 172     // Merge new state into already processed block.
 173     // New state is not taken into account and
 174     // it may invalidate set_returned() result.
 175     if (vars.contains_unknown() || vars.contains_allocated()) {
 176       _return_local = false;
 177     }
 178     if (vars.contains_unknown() || vars.contains_vars()) {
 179       _return_allocated = false;
 180     }
 181     if (_return_local &amp;&amp; vars.contains_vars() &amp;&amp; !returns_all(vars)) {
 182       // Return result should be invalidated if args in new
 183       // state are not recorded in return state.
 184       _return_local = false;
 185     }
 186   }
 187 }
 188 
 189 void BCEscapeAnalyzer::set_dirty(ArgumentMap vars) {
 190   clear_bits(vars, _dirty);
 191 }
 192 
 193 void BCEscapeAnalyzer::set_modified(ArgumentMap vars, int offs, int size) {
 194 
 195   for (int i = 0; i &lt; _arg_size; i++) {
 196     if (vars.contains(i)) {
 197       set_arg_modified(i, offs, size);
 198     }
 199   }
 200   if (vars.contains_unknown())
 201     _unknown_modified = true;
 202 }
 203 
 204 bool BCEscapeAnalyzer::is_recursive_call(ciMethod* callee) {
 205   for (BCEscapeAnalyzer* scope = this; scope != NULL; scope = scope-&gt;_parent) {
 206     if (scope-&gt;method() == callee) {
 207       return true;
 208     }
 209   }
 210   return false;
 211 }
 212 
 213 bool BCEscapeAnalyzer::is_arg_modified(int arg, int offset, int size_in_bytes) {
 214   if (offset == OFFSET_ANY)
 215     return _arg_modified[arg] != 0;
 216   assert(arg &gt;= 0 &amp;&amp; arg &lt; _arg_size, &quot;must be an argument.&quot;);
 217   bool modified = false;
 218   int l = offset / HeapWordSize;
 219   int h = align_up(offset + size_in_bytes, HeapWordSize) / HeapWordSize;
 220   if (l &gt; ARG_OFFSET_MAX)
 221     l = ARG_OFFSET_MAX;
 222   if (h &gt; ARG_OFFSET_MAX+1)
 223     h = ARG_OFFSET_MAX + 1;
 224   for (int i = l; i &lt; h; i++) {
 225     modified = modified || (_arg_modified[arg] &amp; (1 &lt;&lt; i)) != 0;
 226   }
 227   return modified;
 228 }
 229 
 230 void BCEscapeAnalyzer::set_arg_modified(int arg, int offset, int size_in_bytes) {
 231   if (offset == OFFSET_ANY) {
 232     _arg_modified[arg] =  (uint) -1;
 233     return;
 234   }
 235   assert(arg &gt;= 0 &amp;&amp; arg &lt; _arg_size, &quot;must be an argument.&quot;);
 236   int l = offset / HeapWordSize;
 237   int h = align_up(offset + size_in_bytes, HeapWordSize) / HeapWordSize;
 238   if (l &gt; ARG_OFFSET_MAX)
 239     l = ARG_OFFSET_MAX;
 240   if (h &gt; ARG_OFFSET_MAX+1)
 241     h = ARG_OFFSET_MAX + 1;
 242   for (int i = l; i &lt; h; i++) {
 243     _arg_modified[arg] |= (1 &lt;&lt; i);
 244   }
 245 }
 246 
 247 void BCEscapeAnalyzer::invoke(StateInfo &amp;state, Bytecodes::Code code, ciMethod* target, ciKlass* holder) {
 248   int i;
 249 
 250   // retrieve information about the callee
 251   ciInstanceKlass* klass = target-&gt;holder();
 252   ciInstanceKlass* calling_klass = method()-&gt;holder();
 253   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
 254   ciInstanceKlass* actual_recv = callee_holder;
 255 
 256   // Some methods are obviously bindable without any type checks so
 257   // convert them directly to an invokespecial or invokestatic.
 258   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
 259     switch (code) {
 260     case Bytecodes::_invokevirtual:
 261       code = Bytecodes::_invokespecial;
 262       break;
 263     case Bytecodes::_invokehandle:
 264       code = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokespecial;
 265       break;
 266     default:
 267       break;
 268     }
 269   }
 270 
 271   // compute size of arguments
 272   int arg_size = target-&gt;invoke_arg_size(code);
 273   int arg_base = MAX2(state._stack_height - arg_size, 0);
 274 
 275   // direct recursive calls are skipped if they can be bound statically without introducing
 276   // dependencies and if parameters are passed at the same position as in the current method
 277   // other calls are skipped if there are no unescaped arguments passed to them
 278   bool directly_recursive = (method() == target) &amp;&amp;
 279                (code != Bytecodes::_invokevirtual || target-&gt;is_final_method() || state._stack[arg_base] .is_empty());
 280 
 281   // check if analysis of callee can safely be skipped
 282   bool skip_callee = true;
 283   for (i = state._stack_height - 1; i &gt;= arg_base &amp;&amp; skip_callee; i--) {
 284     ArgumentMap arg = state._stack[i];
 285     skip_callee = !is_argument(arg) || !is_arg_stack(arg) || (directly_recursive &amp;&amp; arg.is_singleton(i - arg_base));
 286   }
 287   // For now we conservatively skip invokedynamic.
 288   if (code == Bytecodes::_invokedynamic) {
 289     skip_callee = true;
 290   }
 291   if (skip_callee) {
 292     TRACE_BCEA(3, tty-&gt;print_cr(&quot;[EA] skipping method %s::%s&quot;, holder-&gt;name()-&gt;as_utf8(), target-&gt;name()-&gt;as_utf8()));
 293     for (i = 0; i &lt; arg_size; i++) {
 294       set_method_escape(state.raw_pop());
 295     }
 296     _unknown_modified = true;  // assume the worst since we don&#39;t analyze the called method
 297     return;
 298   }
 299 
 300   // determine actual method (use CHA if necessary)
 301   ciMethod* inline_target = NULL;
 302   if (target-&gt;is_loaded() &amp;&amp; klass-&gt;is_loaded()
 303       &amp;&amp; (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
 304       &amp;&amp; target-&gt;is_loaded()) {
 305     if (code == Bytecodes::_invokestatic
 306         || code == Bytecodes::_invokespecial
 307         || (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method())) {
 308       inline_target = target;
 309     } else {
 310       inline_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
 311     }
 312   }
 313 
 314   if (inline_target != NULL &amp;&amp; !is_recursive_call(inline_target)) {
 315     // analyze callee
 316     BCEscapeAnalyzer analyzer(inline_target, this);
 317 
 318     // adjust escape state of actual parameters
 319     bool must_record_dependencies = false;
 320     for (i = arg_size - 1; i &gt;= 0; i--) {
 321       ArgumentMap arg = state.raw_pop();
 322       // Check if callee arg is a caller arg or an allocated object
 323       bool allocated = arg.contains_allocated();
 324       if (!(is_argument(arg) || allocated))
 325         continue;
 326       for (int j = 0; j &lt; _arg_size; j++) {
 327         if (arg.contains(j)) {
 328           _arg_modified[j] |= analyzer._arg_modified[i];
 329         }
 330       }
 331       if (!(is_arg_stack(arg) || allocated)) {
 332         // arguments have already been recognized as escaping
 333       } else if (analyzer.is_arg_stack(i) &amp;&amp; !analyzer.is_arg_returned(i)) {
 334         set_method_escape(arg);
 335         must_record_dependencies = true;
 336       } else {
 337         set_global_escape(arg);
 338       }
 339     }
 340     _unknown_modified = _unknown_modified || analyzer.has_non_arg_side_affects();
 341 
 342     // record dependencies if at least one parameter retained stack-allocatable
 343     if (must_record_dependencies) {
 344       if (code == Bytecodes::_invokeinterface ||
 345           (code == Bytecodes::_invokevirtual &amp;&amp; !target-&gt;is_final_method())) {
 346         _dependencies.append(actual_recv);
 347         _dependencies.append(inline_target);
 348       }
 349       _dependencies.appendAll(analyzer.dependencies());
 350     }
 351   } else {
 352     TRACE_BCEA(1, tty-&gt;print_cr(&quot;[EA] virtual method %s is not monomorphic.&quot;,
 353                                 target-&gt;name()-&gt;as_utf8()));
 354     // conservatively mark all actual parameters as escaping globally
 355     for (i = 0; i &lt; arg_size; i++) {
 356       ArgumentMap arg = state.raw_pop();
 357       if (!is_argument(arg))
 358         continue;
 359       set_modified(arg, OFFSET_ANY, type2size[T_INT]*HeapWordSize);
 360       set_global_escape(arg);
 361     }
 362     _unknown_modified = true;  // assume the worst since we don&#39;t know the called method
 363   }
 364 }
 365 
 366 bool BCEscapeAnalyzer::contains(uint arg_set1, uint arg_set2) {
 367   return ((~arg_set1) | arg_set2) == 0;
 368 }
 369 
 370 
 371 void BCEscapeAnalyzer::iterate_one_block(ciBlock *blk, StateInfo &amp;state, GrowableArray&lt;ciBlock *&gt; &amp;successors) {
 372 
 373   blk-&gt;set_processed();
 374   ciBytecodeStream s(method());
 375   int limit_bci = blk-&gt;limit_bci();
 376   bool fall_through = false;
 377   ArgumentMap allocated_obj;
 378   allocated_obj.add_allocated();
 379   ArgumentMap unknown_obj;
 380   unknown_obj.add_unknown();
 381   ArgumentMap empty_map;
 382 
 383   s.reset_to_bci(blk-&gt;start_bci());
 384   while (s.next() != ciBytecodeStream::EOBC() &amp;&amp; s.cur_bci() &lt; limit_bci) {
 385     fall_through = true;
 386     switch (s.cur_bc()) {
 387       case Bytecodes::_nop:
 388         break;
 389       case Bytecodes::_aconst_null:
 390         state.apush(unknown_obj);
 391         break;
 392       case Bytecodes::_iconst_m1:
 393       case Bytecodes::_iconst_0:
 394       case Bytecodes::_iconst_1:
 395       case Bytecodes::_iconst_2:
 396       case Bytecodes::_iconst_3:
 397       case Bytecodes::_iconst_4:
 398       case Bytecodes::_iconst_5:
 399       case Bytecodes::_fconst_0:
 400       case Bytecodes::_fconst_1:
 401       case Bytecodes::_fconst_2:
 402       case Bytecodes::_bipush:
 403       case Bytecodes::_sipush:
 404         state.spush();
 405         break;
 406       case Bytecodes::_lconst_0:
 407       case Bytecodes::_lconst_1:
 408       case Bytecodes::_dconst_0:
 409       case Bytecodes::_dconst_1:
 410         state.lpush();
 411         break;
 412       case Bytecodes::_ldc:
 413       case Bytecodes::_ldc_w:
 414       case Bytecodes::_ldc2_w:
 415       {
 416         // Avoid calling get_constant() which will try to allocate
 417         // unloaded constant. We need only constant&#39;s type.
 418         int index = s.get_constant_pool_index();
 419         constantTag tag = s.get_constant_pool_tag(index);
 420         if (tag.is_long() || tag.is_double()) {
 421           // Only longs and doubles use 2 stack slots.
 422           state.lpush();
 423         } else if (tag.basic_type() == T_OBJECT) {
 424           state.apush(unknown_obj);
 425         } else {
 426           state.spush();
 427         }
 428         break;
 429       }
 430       case Bytecodes::_aload:
 431         state.apush(state._vars[s.get_index()]);
 432         break;
 433       case Bytecodes::_iload:
 434       case Bytecodes::_fload:
 435       case Bytecodes::_iload_0:
 436       case Bytecodes::_iload_1:
 437       case Bytecodes::_iload_2:
 438       case Bytecodes::_iload_3:
 439       case Bytecodes::_fload_0:
 440       case Bytecodes::_fload_1:
 441       case Bytecodes::_fload_2:
 442       case Bytecodes::_fload_3:
 443         state.spush();
 444         break;
 445       case Bytecodes::_lload:
 446       case Bytecodes::_dload:
 447       case Bytecodes::_lload_0:
 448       case Bytecodes::_lload_1:
 449       case Bytecodes::_lload_2:
 450       case Bytecodes::_lload_3:
 451       case Bytecodes::_dload_0:
 452       case Bytecodes::_dload_1:
 453       case Bytecodes::_dload_2:
 454       case Bytecodes::_dload_3:
 455         state.lpush();
 456         break;
 457       case Bytecodes::_aload_0:
 458         state.apush(state._vars[0]);
 459         break;
 460       case Bytecodes::_aload_1:
 461         state.apush(state._vars[1]);
 462         break;
 463       case Bytecodes::_aload_2:
 464         state.apush(state._vars[2]);
 465         break;
 466       case Bytecodes::_aload_3:
 467         state.apush(state._vars[3]);
 468         break;
 469       case Bytecodes::_iaload:
 470       case Bytecodes::_faload:
 471       case Bytecodes::_baload:
 472       case Bytecodes::_caload:
 473       case Bytecodes::_saload:
 474         state.spop();
 475         set_method_escape(state.apop());
 476         state.spush();
 477         break;
 478       case Bytecodes::_laload:
 479       case Bytecodes::_daload:
 480         state.spop();
 481         set_method_escape(state.apop());
 482         state.lpush();
 483         break;
 484       case Bytecodes::_aaload:
 485         { state.spop();
 486           ArgumentMap array = state.apop();
 487           set_method_escape(array);
 488           state.apush(unknown_obj);
 489           set_dirty(array);
 490         }
 491         break;
 492       case Bytecodes::_istore:
 493       case Bytecodes::_fstore:
 494       case Bytecodes::_istore_0:
 495       case Bytecodes::_istore_1:
 496       case Bytecodes::_istore_2:
 497       case Bytecodes::_istore_3:
 498       case Bytecodes::_fstore_0:
 499       case Bytecodes::_fstore_1:
 500       case Bytecodes::_fstore_2:
 501       case Bytecodes::_fstore_3:
 502         state.spop();
 503         break;
 504       case Bytecodes::_lstore:
 505       case Bytecodes::_dstore:
 506       case Bytecodes::_lstore_0:
 507       case Bytecodes::_lstore_1:
 508       case Bytecodes::_lstore_2:
 509       case Bytecodes::_lstore_3:
 510       case Bytecodes::_dstore_0:
 511       case Bytecodes::_dstore_1:
 512       case Bytecodes::_dstore_2:
 513       case Bytecodes::_dstore_3:
 514         state.lpop();
 515         break;
 516       case Bytecodes::_astore:
 517         state._vars[s.get_index()] = state.apop();
 518         break;
 519       case Bytecodes::_astore_0:
 520         state._vars[0] = state.apop();
 521         break;
 522       case Bytecodes::_astore_1:
 523         state._vars[1] = state.apop();
 524         break;
 525       case Bytecodes::_astore_2:
 526         state._vars[2] = state.apop();
 527         break;
 528       case Bytecodes::_astore_3:
 529         state._vars[3] = state.apop();
 530         break;
 531       case Bytecodes::_iastore:
 532       case Bytecodes::_fastore:
 533       case Bytecodes::_bastore:
 534       case Bytecodes::_castore:
 535       case Bytecodes::_sastore:
 536       {
 537         state.spop();
 538         state.spop();
 539         ArgumentMap arr = state.apop();
 540         set_method_escape(arr);
 541         set_modified(arr, OFFSET_ANY, type2size[T_INT]*HeapWordSize);
 542         break;
 543       }
 544       case Bytecodes::_lastore:
 545       case Bytecodes::_dastore:
 546       {
 547         state.lpop();
 548         state.spop();
 549         ArgumentMap arr = state.apop();
 550         set_method_escape(arr);
 551         set_modified(arr, OFFSET_ANY, type2size[T_LONG]*HeapWordSize);
 552         break;
 553       }
 554       case Bytecodes::_aastore:
 555       {
 556         set_global_escape(state.apop());
 557         state.spop();
 558         ArgumentMap arr = state.apop();
 559         // If the array is flattened, a larger part of it is modified than
 560         // the size of a reference. However, if OFFSET_ANY is given as
 561         // parameter to set_modified(), size is not taken into account.
 562         set_modified(arr, OFFSET_ANY, type2size[T_OBJECT]*HeapWordSize);
 563         break;
 564       }
 565       case Bytecodes::_pop:
 566         state.raw_pop();
 567         break;
 568       case Bytecodes::_pop2:
 569         state.raw_pop();
 570         state.raw_pop();
 571         break;
 572       case Bytecodes::_dup:
 573         { ArgumentMap w1 = state.raw_pop();
 574           state.raw_push(w1);
 575           state.raw_push(w1);
 576         }
 577         break;
 578       case Bytecodes::_dup_x1:
 579         { ArgumentMap w1 = state.raw_pop();
 580           ArgumentMap w2 = state.raw_pop();
 581           state.raw_push(w1);
 582           state.raw_push(w2);
 583           state.raw_push(w1);
 584         }
 585         break;
 586       case Bytecodes::_dup_x2:
 587         { ArgumentMap w1 = state.raw_pop();
 588           ArgumentMap w2 = state.raw_pop();
 589           ArgumentMap w3 = state.raw_pop();
 590           state.raw_push(w1);
 591           state.raw_push(w3);
 592           state.raw_push(w2);
 593           state.raw_push(w1);
 594         }
 595         break;
 596       case Bytecodes::_dup2:
 597         { ArgumentMap w1 = state.raw_pop();
 598           ArgumentMap w2 = state.raw_pop();
 599           state.raw_push(w2);
 600           state.raw_push(w1);
 601           state.raw_push(w2);
 602           state.raw_push(w1);
 603         }
 604         break;
 605       case Bytecodes::_dup2_x1:
 606         { ArgumentMap w1 = state.raw_pop();
 607           ArgumentMap w2 = state.raw_pop();
 608           ArgumentMap w3 = state.raw_pop();
 609           state.raw_push(w2);
 610           state.raw_push(w1);
 611           state.raw_push(w3);
 612           state.raw_push(w2);
 613           state.raw_push(w1);
 614         }
 615         break;
 616       case Bytecodes::_dup2_x2:
 617         { ArgumentMap w1 = state.raw_pop();
 618           ArgumentMap w2 = state.raw_pop();
 619           ArgumentMap w3 = state.raw_pop();
 620           ArgumentMap w4 = state.raw_pop();
 621           state.raw_push(w2);
 622           state.raw_push(w1);
 623           state.raw_push(w4);
 624           state.raw_push(w3);
 625           state.raw_push(w2);
 626           state.raw_push(w1);
 627         }
 628         break;
 629       case Bytecodes::_swap:
 630         { ArgumentMap w1 = state.raw_pop();
 631           ArgumentMap w2 = state.raw_pop();
 632           state.raw_push(w1);
 633           state.raw_push(w2);
 634         }
 635         break;
 636       case Bytecodes::_iadd:
 637       case Bytecodes::_fadd:
 638       case Bytecodes::_isub:
 639       case Bytecodes::_fsub:
 640       case Bytecodes::_imul:
 641       case Bytecodes::_fmul:
 642       case Bytecodes::_idiv:
 643       case Bytecodes::_fdiv:
 644       case Bytecodes::_irem:
 645       case Bytecodes::_frem:
 646       case Bytecodes::_iand:
 647       case Bytecodes::_ior:
 648       case Bytecodes::_ixor:
 649         state.spop();
 650         state.spop();
 651         state.spush();
 652         break;
 653       case Bytecodes::_ladd:
 654       case Bytecodes::_dadd:
 655       case Bytecodes::_lsub:
 656       case Bytecodes::_dsub:
 657       case Bytecodes::_lmul:
 658       case Bytecodes::_dmul:
 659       case Bytecodes::_ldiv:
 660       case Bytecodes::_ddiv:
 661       case Bytecodes::_lrem:
 662       case Bytecodes::_drem:
 663       case Bytecodes::_land:
 664       case Bytecodes::_lor:
 665       case Bytecodes::_lxor:
 666         state.lpop();
 667         state.lpop();
 668         state.lpush();
 669         break;
 670       case Bytecodes::_ishl:
 671       case Bytecodes::_ishr:
 672       case Bytecodes::_iushr:
 673         state.spop();
 674         state.spop();
 675         state.spush();
 676         break;
 677       case Bytecodes::_lshl:
 678       case Bytecodes::_lshr:
 679       case Bytecodes::_lushr:
 680         state.spop();
 681         state.lpop();
 682         state.lpush();
 683         break;
 684       case Bytecodes::_ineg:
 685       case Bytecodes::_fneg:
 686         state.spop();
 687         state.spush();
 688         break;
 689       case Bytecodes::_lneg:
 690       case Bytecodes::_dneg:
 691         state.lpop();
 692         state.lpush();
 693         break;
 694       case Bytecodes::_iinc:
 695         break;
 696       case Bytecodes::_i2l:
 697       case Bytecodes::_i2d:
 698       case Bytecodes::_f2l:
 699       case Bytecodes::_f2d:
 700         state.spop();
 701         state.lpush();
 702         break;
 703       case Bytecodes::_i2f:
 704       case Bytecodes::_f2i:
 705         state.spop();
 706         state.spush();
 707         break;
 708       case Bytecodes::_l2i:
 709       case Bytecodes::_l2f:
 710       case Bytecodes::_d2i:
 711       case Bytecodes::_d2f:
 712         state.lpop();
 713         state.spush();
 714         break;
 715       case Bytecodes::_l2d:
 716       case Bytecodes::_d2l:
 717         state.lpop();
 718         state.lpush();
 719         break;
 720       case Bytecodes::_i2b:
 721       case Bytecodes::_i2c:
 722       case Bytecodes::_i2s:
 723         state.spop();
 724         state.spush();
 725         break;
 726       case Bytecodes::_lcmp:
 727       case Bytecodes::_dcmpl:
 728       case Bytecodes::_dcmpg:
 729         state.lpop();
 730         state.lpop();
 731         state.spush();
 732         break;
 733       case Bytecodes::_fcmpl:
 734       case Bytecodes::_fcmpg:
 735         state.spop();
 736         state.spop();
 737         state.spush();
 738         break;
 739       case Bytecodes::_ifeq:
 740       case Bytecodes::_ifne:
 741       case Bytecodes::_iflt:
 742       case Bytecodes::_ifge:
 743       case Bytecodes::_ifgt:
 744       case Bytecodes::_ifle:
 745       {
 746         state.spop();
 747         int dest_bci = s.get_dest();
 748         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 749         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 750         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 751         break;
 752       }
 753       case Bytecodes::_if_icmpeq:
 754       case Bytecodes::_if_icmpne:
 755       case Bytecodes::_if_icmplt:
 756       case Bytecodes::_if_icmpge:
 757       case Bytecodes::_if_icmpgt:
 758       case Bytecodes::_if_icmple:
 759       {
 760         state.spop();
 761         state.spop();
 762         int dest_bci = s.get_dest();
 763         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 764         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 765         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 766         break;
 767       }
 768       case Bytecodes::_if_acmpeq:
 769       case Bytecodes::_if_acmpne:
 770       {
 771         set_method_escape(state.apop());
 772         set_method_escape(state.apop());
 773         int dest_bci = s.get_dest();
 774         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 775         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 776         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 777         break;
 778       }
 779       case Bytecodes::_goto:
 780       {
 781         int dest_bci = s.get_dest();
 782         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 783         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 784         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 785         fall_through = false;
 786         break;
 787       }
 788       case Bytecodes::_jsr:
 789       {
 790         int dest_bci = s.get_dest();
 791         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 792         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 793         state.apush(empty_map);
 794         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 795         fall_through = false;
 796         break;
 797       }
 798       case Bytecodes::_ret:
 799         // we don&#39;t track  the destination of a &quot;ret&quot; instruction
 800         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 801         fall_through = false;
 802         break;
 803       case Bytecodes::_return:
 804         assert(s.next_bci() == limit_bci, &quot;return must end block&quot;);
 805         fall_through = false;
 806         break;
 807       case Bytecodes::_tableswitch:
 808         {
 809           state.spop();
 810           Bytecode_tableswitch sw(&amp;s);
 811           int len = sw.length();
 812           int dest_bci;
 813           for (int i = 0; i &lt; len; i++) {
 814             dest_bci = s.cur_bci() + sw.dest_offset_at(i);
 815             assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 816             successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 817           }
 818           dest_bci = s.cur_bci() + sw.default_offset();
 819           assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 820           successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 821           assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 822           fall_through = false;
 823           break;
 824         }
 825       case Bytecodes::_lookupswitch:
 826         {
 827           state.spop();
 828           Bytecode_lookupswitch sw(&amp;s);
 829           int len = sw.number_of_pairs();
 830           int dest_bci;
 831           for (int i = 0; i &lt; len; i++) {
 832             dest_bci = s.cur_bci() + sw.pair_at(i).offset();
 833             assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 834             successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 835           }
 836           dest_bci = s.cur_bci() + sw.default_offset();
 837           assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 838           successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 839           fall_through = false;
 840           break;
 841         }
 842       case Bytecodes::_ireturn:
 843       case Bytecodes::_freturn:
 844         state.spop();
 845         fall_through = false;
 846         break;
 847       case Bytecodes::_lreturn:
 848       case Bytecodes::_dreturn:
 849         state.lpop();
 850         fall_through = false;
 851         break;
 852       case Bytecodes::_areturn:
 853         set_returned(state.apop());
 854         fall_through = false;
 855         break;
 856       case Bytecodes::_getstatic:
 857       case Bytecodes::_getfield:
 858         { bool ignored_will_link;
 859           ciField* field = s.get_field(ignored_will_link);
 860           BasicType field_type = field-&gt;type()-&gt;basic_type();
 861           if (s.cur_bc() != Bytecodes::_getstatic) {
 862             set_method_escape(state.apop());
 863           }
 864           if (is_reference_type(field_type)) {
 865             state.apush(unknown_obj);
 866           } else if (type2size[field_type] == 1) {
 867             state.spush();
 868           } else {
 869             state.lpush();
 870           }
 871         }
 872         break;
 873       case Bytecodes::_putstatic:
 874       case Bytecodes::_putfield:
 875         { bool will_link;
 876           ciField* field = s.get_field(will_link);
 877           BasicType field_type = field-&gt;type()-&gt;basic_type();
 878           if (is_reference_type(field_type)) {
 879             set_global_escape(state.apop());
 880           } else if (type2size[field_type] == 1) {
 881             state.spop();
 882           } else {
 883             state.lpop();
 884           }
 885           if (s.cur_bc() != Bytecodes::_putstatic) {
 886             ArgumentMap p = state.apop();
 887             set_method_escape(p);
 888             set_modified(p, will_link ? field-&gt;offset() : OFFSET_ANY, type2size[field_type]*HeapWordSize);
 889           }
 890         }
 891         break;
 892       case Bytecodes::_invokevirtual:
 893       case Bytecodes::_invokespecial:
 894       case Bytecodes::_invokestatic:
 895       case Bytecodes::_invokedynamic:
 896       case Bytecodes::_invokeinterface:
 897         { bool ignored_will_link;
 898           ciSignature* declared_signature = NULL;
 899           ciMethod* target = s.get_method(ignored_will_link, &amp;declared_signature);
 900           ciKlass*  holder = s.get_declared_method_holder();
 901           assert(declared_signature != NULL, &quot;cannot be null&quot;);
 902           // If the current bytecode has an attached appendix argument,
 903           // push an unknown object to represent that argument. (Analysis
 904           // of dynamic call sites, especially invokehandle calls, needs
 905           // the appendix argument on the stack, in addition to &quot;regular&quot; arguments
 906           // pushed onto the stack by bytecode instructions preceding the call.)
 907           //
 908           // The escape analyzer does _not_ use the ciBytecodeStream::has_appendix(s)
 909           // method to determine whether the current bytecode has an appendix argument.
 910           // The has_appendix() method obtains the appendix from the
 911           // ConstantPoolCacheEntry::_f1 field, which can happen concurrently with
 912           // resolution of dynamic call sites. Callees in the
 913           // ciBytecodeStream::get_method() call above also access the _f1 field;
 914           // interleaving the get_method() and has_appendix() calls in the current
 915           // method with call site resolution can lead to an inconsistent view of
 916           // the current method&#39;s argument count. In particular, some interleaving(s)
 917           // can cause the method&#39;s argument count to not include the appendix, which
 918           // then leads to stack over-/underflow in the escape analyzer.
 919           //
 920           // Instead of pushing the argument if has_appendix() is true, the escape analyzer
 921           // pushes an appendix for all call sites targeted by invokedynamic and invokehandle
 922           // instructions, except if the call site is the _invokeBasic intrinsic
 923           // (that intrinsic is always targeted by an invokehandle instruction but does
 924           // not have an appendix argument).
 925           if (target-&gt;is_loaded() &amp;&amp;
 926               Bytecodes::has_optional_appendix(s.cur_bc_raw()) &amp;&amp;
 927               target-&gt;intrinsic_id() != vmIntrinsics::_invokeBasic) {
 928             state.apush(unknown_obj);
 929           }
 930           // Pass in raw bytecode because we need to see invokehandle instructions.
 931           invoke(state, s.cur_bc_raw(), target, holder);
 932           // We are using the return type of the declared signature here because
 933           // it might be a more concrete type than the one from the target (for
 934           // e.g. invokedynamic and invokehandle).
 935           ciType* return_type = declared_signature-&gt;return_type();
 936           if (!return_type-&gt;is_primitive_type()) {
 937             state.apush(unknown_obj);
 938           } else if (return_type-&gt;is_one_word()) {
 939             state.spush();
 940           } else if (return_type-&gt;is_two_word()) {
 941             state.lpush();
 942           }
 943         }
 944         break;
 945       case Bytecodes::_new:
 946       case Bytecodes::_defaultvalue:
 947         state.apush(allocated_obj);
 948         break;
 949       case Bytecodes::_withfield: {
 950         bool will_link;
 951         ciField* field = s.get_field(will_link);
 952         BasicType field_type = field-&gt;type()-&gt;basic_type();
 953         if (field_type == T_OBJECT || field_type == T_ARRAY) {
 954           set_global_escape(state.apop());
 955         } else if (type2size[field_type] == 1) {
 956           state.spop();
 957         } else {
 958           state.lpop();
 959         }
 960         set_method_escape(state.apop());
 961         state.apush(allocated_obj);
 962         break;
 963       }
 964       case Bytecodes::_newarray:
 965       case Bytecodes::_anewarray:
 966         state.spop();
 967         state.apush(allocated_obj);
 968         break;
 969       case Bytecodes::_multianewarray:
 970         { int i = s.cur_bcp()[3];
 971           while (i-- &gt; 0) state.spop();
 972           state.apush(allocated_obj);
 973         }
 974         break;
 975       case Bytecodes::_arraylength:
 976         set_method_escape(state.apop());
 977         state.spush();
 978         break;
 979       case Bytecodes::_athrow:
 980         set_global_escape(state.apop());
 981         fall_through = false;
 982         break;
 983       case Bytecodes::_checkcast:
 984         { ArgumentMap obj = state.apop();
 985           set_method_escape(obj);
 986           state.apush(obj);
 987         }
 988         break;
 989       case Bytecodes::_instanceof:
 990         set_method_escape(state.apop());
 991         state.spush();
 992         break;
 993       case Bytecodes::_monitorenter:
 994       case Bytecodes::_monitorexit:
 995         state.apop();
 996         break;
 997       case Bytecodes::_wide:
 998         ShouldNotReachHere();
 999         break;
1000       case Bytecodes::_ifnull:
1001       case Bytecodes::_ifnonnull:
1002       {
1003         set_method_escape(state.apop());
1004         int dest_bci = s.get_dest();
1005         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
1006         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
1007         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
1008         break;
1009       }
1010       case Bytecodes::_goto_w:
1011       {
1012         int dest_bci = s.get_far_dest();
1013         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
1014         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
1015         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
1016         fall_through = false;
1017         break;
1018       }
1019       case Bytecodes::_jsr_w:
1020       {
1021         int dest_bci = s.get_far_dest();
1022         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
1023         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
1024         state.apush(empty_map);
1025         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
1026         fall_through = false;
1027         break;
1028       }
1029       case Bytecodes::_breakpoint:
1030         break;
1031       default:
1032         ShouldNotReachHere();
1033         break;
1034     }
1035 
1036   }
1037   if (fall_through) {
1038     int fall_through_bci = s.cur_bci();
1039     if (fall_through_bci &lt; _method-&gt;code_size()) {
1040       assert(_methodBlocks-&gt;is_block_start(fall_through_bci), &quot;must fall through to block start.&quot;);
1041       successors.push(_methodBlocks-&gt;block_containing(fall_through_bci));
1042     }
1043   }
1044 }
1045 
1046 void BCEscapeAnalyzer::merge_block_states(StateInfo *blockstates, ciBlock *dest, StateInfo *s_state) {
1047   StateInfo *d_state = blockstates + dest-&gt;index();
1048   int nlocals = _method-&gt;max_locals();
1049 
1050   // exceptions may cause transfer of control to handlers in the middle of a
1051   // block, so we don&#39;t merge the incoming state of exception handlers
1052   if (dest-&gt;is_handler())
1053     return;
1054   if (!d_state-&gt;_initialized ) {
1055     // destination not initialized, just copy
1056     for (int i = 0; i &lt; nlocals; i++) {
1057       d_state-&gt;_vars[i] = s_state-&gt;_vars[i];
1058     }
1059     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1060       d_state-&gt;_stack[i] = s_state-&gt;_stack[i];
1061     }
1062     d_state-&gt;_stack_height = s_state-&gt;_stack_height;
1063     d_state-&gt;_max_stack = s_state-&gt;_max_stack;
1064     d_state-&gt;_initialized = true;
1065   } else if (!dest-&gt;processed()) {
1066     // we have not yet walked the bytecodes of dest, we can merge
1067     // the states
1068     assert(d_state-&gt;_stack_height == s_state-&gt;_stack_height, &quot;computed stack heights must match&quot;);
1069     for (int i = 0; i &lt; nlocals; i++) {
1070       d_state-&gt;_vars[i].set_union(s_state-&gt;_vars[i]);
1071     }
1072     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1073       d_state-&gt;_stack[i].set_union(s_state-&gt;_stack[i]);
1074     }
1075   } else {
1076     // the bytecodes of dest have already been processed, mark any
1077     // arguments in the source state which are not in the dest state
1078     // as global escape.
1079     // Future refinement:  we only need to mark these variable to the
1080     // maximum escape of any variables in dest state
1081     assert(d_state-&gt;_stack_height == s_state-&gt;_stack_height, &quot;computed stack heights must match&quot;);
1082     ArgumentMap extra_vars;
1083     for (int i = 0; i &lt; nlocals; i++) {
1084       ArgumentMap t;
1085       t = s_state-&gt;_vars[i];
1086       t.set_difference(d_state-&gt;_vars[i]);
1087       extra_vars.set_union(t);
1088     }
1089     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1090       ArgumentMap t;
1091       //extra_vars |= !d_state-&gt;_vars[i] &amp; s_state-&gt;_vars[i];
1092       t.clear();
1093       t = s_state-&gt;_stack[i];
1094       t.set_difference(d_state-&gt;_stack[i]);
1095       extra_vars.set_union(t);
1096     }
1097     set_global_escape(extra_vars, true);
1098   }
1099 }
1100 
1101 void BCEscapeAnalyzer::iterate_blocks(Arena *arena) {
1102   int numblocks = _methodBlocks-&gt;num_blocks();
1103   int stkSize   = _method-&gt;max_stack();
1104   int numLocals = _method-&gt;max_locals();
1105   StateInfo state;
1106 
1107   int datacount = (numblocks + 1) * (stkSize + numLocals);
1108   int datasize = datacount * sizeof(ArgumentMap);
1109   StateInfo *blockstates = (StateInfo *) arena-&gt;Amalloc(numblocks * sizeof(StateInfo));
1110   ArgumentMap *statedata  = (ArgumentMap *) arena-&gt;Amalloc(datasize);
1111   for (int i = 0; i &lt; datacount; i++) ::new ((void*)&amp;statedata[i]) ArgumentMap();
1112   ArgumentMap *dp = statedata;
1113   state._vars = dp;
1114   dp += numLocals;
1115   state._stack = dp;
1116   dp += stkSize;
1117   state._initialized = false;
1118   state._max_stack = stkSize;
1119   for (int i = 0; i &lt; numblocks; i++) {
1120     blockstates[i]._vars = dp;
1121     dp += numLocals;
1122     blockstates[i]._stack = dp;
1123     dp += stkSize;
1124     blockstates[i]._initialized = false;
1125     blockstates[i]._stack_height = 0;
1126     blockstates[i]._max_stack  = stkSize;
1127   }
1128   GrowableArray&lt;ciBlock *&gt; worklist(arena, numblocks / 4, 0, NULL);
1129   GrowableArray&lt;ciBlock *&gt; successors(arena, 4, 0, NULL);
1130 
1131   _methodBlocks-&gt;clear_processed();
1132 
1133   // initialize block 0 state from method signature
1134   ArgumentMap allVars;   // all oop arguments to method
1135   ciSignature* sig = method()-&gt;signature();
1136   int j = 0;
1137   ciBlock* first_blk = _methodBlocks-&gt;block_containing(0);
1138   int fb_i = first_blk-&gt;index();
1139   if (!method()-&gt;is_static()) {
1140     // record information for &quot;this&quot;
1141     blockstates[fb_i]._vars[j].set(j);
1142     allVars.add(j);
1143     j++;
1144   }
1145   for (int i = 0; i &lt; sig-&gt;count(); i++) {
1146     ciType* t = sig-&gt;type_at(i);
1147     if (!t-&gt;is_primitive_type()) {
1148       blockstates[fb_i]._vars[j].set(j);
1149       allVars.add(j);
1150     }
1151     j += t-&gt;size();
1152   }
1153   blockstates[fb_i]._initialized = true;
1154   assert(j == _arg_size, &quot;just checking&quot;);
1155 
1156   ArgumentMap unknown_map;
1157   unknown_map.add_unknown();
1158 
1159   worklist.push(first_blk);
1160   while(worklist.length() &gt; 0) {
1161     ciBlock *blk = worklist.pop();
1162     StateInfo *blkState = blockstates + blk-&gt;index();
1163     if (blk-&gt;is_handler() || blk-&gt;is_ret_target()) {
1164       // for an exception handler or a target of a ret instruction, we assume the worst case,
1165       // that any variable could contain any argument
1166       for (int i = 0; i &lt; numLocals; i++) {
1167         state._vars[i] = allVars;
1168       }
1169       if (blk-&gt;is_handler()) {
1170         state._stack_height = 1;
1171       } else {
1172         state._stack_height = blkState-&gt;_stack_height;
1173       }
1174       for (int i = 0; i &lt; state._stack_height; i++) {
1175 // ??? should this be unknown_map ???
1176         state._stack[i] = allVars;
1177       }
1178     } else {
1179       for (int i = 0; i &lt; numLocals; i++) {
1180         state._vars[i] = blkState-&gt;_vars[i];
1181       }
1182       for (int i = 0; i &lt; blkState-&gt;_stack_height; i++) {
1183         state._stack[i] = blkState-&gt;_stack[i];
1184       }
1185       state._stack_height = blkState-&gt;_stack_height;
1186     }
1187     iterate_one_block(blk, state, successors);
1188     // if this block has any exception handlers, push them
1189     // onto successor list
1190     if (blk-&gt;has_handler()) {
1191       DEBUG_ONLY(int handler_count = 0;)
1192       int blk_start = blk-&gt;start_bci();
1193       int blk_end = blk-&gt;limit_bci();
1194       for (int i = 0; i &lt; numblocks; i++) {
1195         ciBlock *b = _methodBlocks-&gt;block(i);
1196         if (b-&gt;is_handler()) {
1197           int ex_start = b-&gt;ex_start_bci();
1198           int ex_end = b-&gt;ex_limit_bci();
1199           if ((ex_start &gt;= blk_start &amp;&amp; ex_start &lt; blk_end) ||
1200               (ex_end &gt; blk_start &amp;&amp; ex_end &lt;= blk_end)) {
1201             successors.push(b);
1202           }
1203           DEBUG_ONLY(handler_count++;)
1204         }
1205       }
1206       assert(handler_count &gt; 0, &quot;must find at least one handler&quot;);
1207     }
1208     // merge computed variable state with successors
1209     while(successors.length() &gt; 0) {
1210       ciBlock *succ = successors.pop();
1211       merge_block_states(blockstates, succ, &amp;state);
1212       if (!succ-&gt;processed())
1213         worklist.push(succ);
1214     }
1215   }
1216 }
1217 
1218 void BCEscapeAnalyzer::do_analysis() {
1219   Arena* arena = CURRENT_ENV-&gt;arena();
1220   // identify basic blocks
1221   _methodBlocks = _method-&gt;get_method_blocks();
1222 
1223   iterate_blocks(arena);
1224 }
1225 
1226 vmIntrinsics::ID BCEscapeAnalyzer::known_intrinsic() {
1227   vmIntrinsics::ID iid = method()-&gt;intrinsic_id();
1228   if (iid == vmIntrinsics::_getClass ||
1229       iid == vmIntrinsics::_hashCode) {
1230     return iid;
1231   } else {
1232     return vmIntrinsics::_none;
1233   }
1234 }
1235 
1236 void BCEscapeAnalyzer::compute_escape_for_intrinsic(vmIntrinsics::ID iid) {
1237   switch (iid) {
1238     case vmIntrinsics::_getClass:
1239       _return_local = false;
1240       _return_allocated = false;
1241       break;
1242     case vmIntrinsics::_hashCode:
1243       // initialized state is correct
1244       break;
1245   default:
1246     assert(false, &quot;unexpected intrinsic&quot;);
1247   }
1248 }
1249 
1250 void BCEscapeAnalyzer::initialize() {
1251   int i;
1252 
1253   // clear escape information (method may have been deoptimized)
1254   methodData()-&gt;clear_escape_info();
1255 
1256   // initialize escape state of object parameters
1257   ciSignature* sig = method()-&gt;signature();
1258   int j = 0;
1259   if (!method()-&gt;is_static()) {
1260     _arg_local.set(0);
1261     _arg_stack.set(0);
1262     j++;
1263   }
1264   for (i = 0; i &lt; sig-&gt;count(); i++) {
1265     ciType* t = sig-&gt;type_at(i);
1266     if (!t-&gt;is_primitive_type()) {
1267       _arg_local.set(j);
1268       _arg_stack.set(j);
1269     }
1270     j += t-&gt;size();
1271   }
1272   assert(j == _arg_size, &quot;just checking&quot;);
1273 
1274   // start with optimistic assumption
1275   ciType *rt = _method-&gt;return_type();
1276   if (rt-&gt;is_primitive_type()) {
1277     _return_local = false;
1278     _return_allocated = false;
1279   } else {
1280     _return_local = true;
1281     _return_allocated = true;
1282   }
1283   _allocated_escapes = false;
1284   _unknown_modified = false;
1285 }
1286 
1287 void BCEscapeAnalyzer::clear_escape_info() {
1288   ciSignature* sig = method()-&gt;signature();
1289   int arg_count = sig-&gt;count();
1290   ArgumentMap var;
1291   if (!method()-&gt;is_static()) {
1292     arg_count++;  // allow for &quot;this&quot;
1293   }
1294   for (int i = 0; i &lt; arg_count; i++) {
1295     set_arg_modified(i, OFFSET_ANY, 4);
1296     var.clear();
1297     var.set(i);
1298     set_modified(var, OFFSET_ANY, 4);
1299     set_global_escape(var);
1300   }
1301   _arg_local.clear();
1302   _arg_stack.clear();
1303   _arg_returned.clear();
1304   _return_local = false;
1305   _return_allocated = false;
1306   _allocated_escapes = true;
1307   _unknown_modified = true;
1308 }
1309 
1310 
1311 void BCEscapeAnalyzer::compute_escape_info() {
1312   int i;
1313   assert(!methodData()-&gt;has_escape_info(), &quot;do not overwrite escape info&quot;);
1314 
1315   vmIntrinsics::ID iid = known_intrinsic();
1316 
1317   // check if method can be analyzed
1318   if (iid == vmIntrinsics::_none &amp;&amp; (method()-&gt;is_abstract() || method()-&gt;is_native() || !method()-&gt;holder()-&gt;is_initialized()
1319       || _level &gt; MaxBCEAEstimateLevel
1320       || method()-&gt;code_size() &gt; MaxBCEAEstimateSize)) {
1321     if (BCEATraceLevel &gt;= 1) {
1322       tty-&gt;print(&quot;Skipping method because: &quot;);
1323       if (method()-&gt;is_abstract())
1324         tty-&gt;print_cr(&quot;method is abstract.&quot;);
1325       else if (method()-&gt;is_native())
1326         tty-&gt;print_cr(&quot;method is native.&quot;);
1327       else if (!method()-&gt;holder()-&gt;is_initialized())
1328         tty-&gt;print_cr(&quot;class of method is not initialized.&quot;);
1329       else if (_level &gt; MaxBCEAEstimateLevel)
1330         tty-&gt;print_cr(&quot;level (%d) exceeds MaxBCEAEstimateLevel (%d).&quot;,
1331                       _level, (int) MaxBCEAEstimateLevel);
1332       else if (method()-&gt;code_size() &gt; MaxBCEAEstimateSize)
1333         tty-&gt;print_cr(&quot;code size (%d) exceeds MaxBCEAEstimateSize (%d).&quot;,
1334                       method()-&gt;code_size(), (int) MaxBCEAEstimateSize);
1335       else
1336         ShouldNotReachHere();
1337     }
1338     clear_escape_info();
1339 
1340     return;
1341   }
1342 
1343   if (BCEATraceLevel &gt;= 1) {
1344     tty-&gt;print(&quot;[EA] estimating escape information for&quot;);
1345     if (iid != vmIntrinsics::_none)
1346       tty-&gt;print(&quot; intrinsic&quot;);
1347     method()-&gt;print_short_name();
1348     tty-&gt;print_cr(&quot; (%d bytes)&quot;, method()-&gt;code_size());
1349   }
1350 
1351   initialize();
1352 
1353   // Do not scan method if it has no object parameters and
1354   // does not returns an object (_return_allocated is set in initialize()).
1355   if (_arg_local.is_empty() &amp;&amp; !_return_allocated) {
1356     // Clear all info since method&#39;s bytecode was not analysed and
1357     // set pessimistic escape information.
1358     clear_escape_info();
1359     methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1360     methodData()-&gt;set_eflag(MethodData::unknown_modified);
1361     methodData()-&gt;set_eflag(MethodData::estimated);
1362     return;
1363   }
1364 
1365   if (iid != vmIntrinsics::_none)
1366     compute_escape_for_intrinsic(iid);
1367   else {
1368     do_analysis();
1369   }
1370 
1371   // don&#39;t store interprocedural escape information if it introduces
1372   // dependencies or if method data is empty
1373   //
1374   if (!has_dependencies() &amp;&amp; !methodData()-&gt;is_empty()) {
1375     for (i = 0; i &lt; _arg_size; i++) {
1376       if (_arg_local.test(i)) {
1377         assert(_arg_stack.test(i), &quot;inconsistent escape info&quot;);
1378         methodData()-&gt;set_arg_local(i);
1379         methodData()-&gt;set_arg_stack(i);
1380       } else if (_arg_stack.test(i)) {
1381         methodData()-&gt;set_arg_stack(i);
1382       }
1383       if (_arg_returned.test(i)) {
1384         methodData()-&gt;set_arg_returned(i);
1385       }
1386       methodData()-&gt;set_arg_modified(i, _arg_modified[i]);
1387     }
1388     if (_return_local) {
1389       methodData()-&gt;set_eflag(MethodData::return_local);
1390     }
1391     if (_return_allocated) {
1392       methodData()-&gt;set_eflag(MethodData::return_allocated);
1393     }
1394     if (_allocated_escapes) {
1395       methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1396     }
1397     if (_unknown_modified) {
1398       methodData()-&gt;set_eflag(MethodData::unknown_modified);
1399     }
1400     methodData()-&gt;set_eflag(MethodData::estimated);
1401   }
1402 }
1403 
1404 void BCEscapeAnalyzer::read_escape_info() {
1405   assert(methodData()-&gt;has_escape_info(), &quot;no escape info available&quot;);
1406 
1407   // read escape information from method descriptor
1408   for (int i = 0; i &lt; _arg_size; i++) {
1409     if (methodData()-&gt;is_arg_local(i))
1410       _arg_local.set(i);
1411     if (methodData()-&gt;is_arg_stack(i))
1412       _arg_stack.set(i);
1413     if (methodData()-&gt;is_arg_returned(i))
1414       _arg_returned.set(i);
1415     _arg_modified[i] = methodData()-&gt;arg_modified(i);
1416   }
1417   _return_local = methodData()-&gt;eflag_set(MethodData::return_local);
1418   _return_allocated = methodData()-&gt;eflag_set(MethodData::return_allocated);
1419   _allocated_escapes = methodData()-&gt;eflag_set(MethodData::allocated_escapes);
1420   _unknown_modified = methodData()-&gt;eflag_set(MethodData::unknown_modified);
1421 
1422 }
1423 
1424 #ifndef PRODUCT
1425 void BCEscapeAnalyzer::dump() {
1426   tty-&gt;print(&quot;[EA] estimated escape information for&quot;);
1427   method()-&gt;print_short_name();
1428   tty-&gt;print_cr(has_dependencies() ? &quot; (not stored)&quot; : &quot;&quot;);
1429   tty-&gt;print(&quot;     non-escaping args:      &quot;);
1430   _arg_local.print();
1431   tty-&gt;print(&quot;     stack-allocatable args: &quot;);
1432   _arg_stack.print();
1433   if (_return_local) {
1434     tty-&gt;print(&quot;     returned args:          &quot;);
1435     _arg_returned.print();
1436   } else if (is_return_allocated()) {
1437     tty-&gt;print_cr(&quot;     return allocated value&quot;);
1438   } else {
1439     tty-&gt;print_cr(&quot;     return non-local value&quot;);
1440   }
1441   tty-&gt;print(&quot;     modified args: &quot;);
1442   for (int i = 0; i &lt; _arg_size; i++) {
1443     if (_arg_modified[i] == 0)
1444       tty-&gt;print(&quot;    0&quot;);
1445     else
1446       tty-&gt;print(&quot;    0x%x&quot;, _arg_modified[i]);
1447   }
1448   tty-&gt;cr();
1449   tty-&gt;print(&quot;     flags: &quot;);
1450   if (_return_allocated)
1451     tty-&gt;print(&quot; return_allocated&quot;);
1452   if (_allocated_escapes)
1453     tty-&gt;print(&quot; allocated_escapes&quot;);
1454   if (_unknown_modified)
1455     tty-&gt;print(&quot; unknown_modified&quot;);
1456   tty-&gt;cr();
1457 }
1458 #endif
1459 
1460 BCEscapeAnalyzer::BCEscapeAnalyzer(ciMethod* method, BCEscapeAnalyzer* parent)
1461     : _arena(CURRENT_ENV-&gt;arena())
1462     , _conservative(method == NULL || !EstimateArgEscape)
1463     , _method(method)
1464     , _methodData(method ? method-&gt;method_data() : NULL)
1465     , _arg_size(method ? method-&gt;arg_size() : 0)
1466     , _arg_local(_arena)
1467     , _arg_stack(_arena)
1468     , _arg_returned(_arena)
1469     , _dirty(_arena)
1470     , _return_local(false)
1471     , _return_allocated(false)
1472     , _allocated_escapes(false)
1473     , _unknown_modified(false)
1474     , _dependencies(_arena, 4, 0, NULL)
1475     , _parent(parent)
1476     , _level(parent == NULL ? 0 : parent-&gt;level() + 1) {
1477   if (!_conservative) {
1478     _arg_local.clear();
1479     _arg_stack.clear();
1480     _arg_returned.clear();
1481     _dirty.clear();
1482     Arena* arena = CURRENT_ENV-&gt;arena();
1483     _arg_modified = (uint *) arena-&gt;Amalloc(_arg_size * sizeof(uint));
1484     Copy::zero_to_bytes(_arg_modified, _arg_size * sizeof(uint));
1485 
1486     if (methodData() == NULL)
1487       return;
1488     if (methodData()-&gt;has_escape_info()) {
1489       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] Reading previous results for %s.%s&quot;,
1490                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1491                                   method-&gt;name()-&gt;as_utf8()));
1492       read_escape_info();
1493     } else {
1494       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] computing results for %s.%s&quot;,
1495                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1496                                   method-&gt;name()-&gt;as_utf8()));
1497 
1498       compute_escape_info();
1499       methodData()-&gt;update_escape_info();
1500     }
1501 #ifndef PRODUCT
1502     if (BCEATraceLevel &gt;= 3) {
1503       // dump escape information
1504       dump();
1505     }
1506 #endif
1507   }
1508 }
1509 
1510 void BCEscapeAnalyzer::copy_dependencies(Dependencies *deps) {
1511   if (ciEnv::current()-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
1512     // Also record evol dependencies so redefinition of the
1513     // callee will trigger recompilation.
1514     deps-&gt;assert_evol_method(method());
1515   }
1516   for (int i = 0; i &lt; _dependencies.length(); i+=2) {
1517     ciKlass *k = _dependencies.at(i)-&gt;as_klass();
1518     ciMethod *m = _dependencies.at(i+1)-&gt;as_method();
1519     deps-&gt;assert_unique_concrete_method(k, m);
1520   }
1521 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
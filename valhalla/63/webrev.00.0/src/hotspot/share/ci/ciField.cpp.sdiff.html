<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciField.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bcEscapeAnalyzer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciField.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
232   _is_constant = field-&gt;_is_constant;
233   _known_to_link_with_put = field-&gt;_known_to_link_with_put;
234   _known_to_link_with_get = field-&gt;_known_to_link_with_get;
235   _constant_value = field-&gt;_constant_value;
236   assert(!field-&gt;is_flattened(), &quot;field must not be flattened&quot;);
237   _is_flattened = false;
238   _is_flattenable = field-&gt;is_flattenable();
239 }
240 
241 static bool trust_final_non_static_fields(ciInstanceKlass* holder) {
242   if (holder == NULL)
243     return false;
244   if (holder-&gt;name() == ciSymbol::java_lang_System())
245     // Never trust strangely unstable finals:  System.out, etc.
246     return false;
247   // Even if general trusting is disabled, trust system-built closures in these packages.
248   if (holder-&gt;is_in_package(&quot;java/lang/invoke&quot;) || holder-&gt;is_in_package(&quot;sun/invoke&quot;) ||
249       holder-&gt;is_in_package(&quot;jdk/internal/foreign&quot;) || holder-&gt;is_in_package(&quot;jdk/incubator/foreign&quot;) ||
250       holder-&gt;is_in_package(&quot;java/lang&quot;))
251     return true;
<span class="line-modified">252   // Trust VM unsafe anonymous classes. They are private API (jdk.internal.misc.Unsafe)</span>
<span class="line-modified">253   // and can&#39;t be serialized, so there is no hacking of finals going on with them.</span>
<span class="line-modified">254   if (holder-&gt;is_unsafe_anonymous())</span>

255     return true;
256   // Trust final fields in all boxed classes
257   if (holder-&gt;is_box_klass())
258     return true;
259   // Trust final fields in String
260   if (holder-&gt;name() == ciSymbol::java_lang_String())
261     return true;
262   // Trust Atomic*FieldUpdaters: they are very important for performance, and make up one
263   // more reason not to use Unsafe, if their final fields are trusted. See more in JDK-8140483.
264   if (holder-&gt;name() == ciSymbol::java_util_concurrent_atomic_AtomicIntegerFieldUpdater_Impl() ||
265       holder-&gt;name() == ciSymbol::java_util_concurrent_atomic_AtomicLongFieldUpdater_CASUpdater() ||
266       holder-&gt;name() == ciSymbol::java_util_concurrent_atomic_AtomicLongFieldUpdater_LockedUpdater() ||
267       holder-&gt;name() == ciSymbol::java_util_concurrent_atomic_AtomicReferenceFieldUpdater_Impl()) {
268     return true;
269   }
270   return TrustFinalNonStaticFields;
271 }
272 
273 void ciField::initialize_from(fieldDescriptor* fd) {
274   // Get the flags, offset, and canonical holder of the field.
</pre>
</td>
<td>
<hr />
<pre>
232   _is_constant = field-&gt;_is_constant;
233   _known_to_link_with_put = field-&gt;_known_to_link_with_put;
234   _known_to_link_with_get = field-&gt;_known_to_link_with_get;
235   _constant_value = field-&gt;_constant_value;
236   assert(!field-&gt;is_flattened(), &quot;field must not be flattened&quot;);
237   _is_flattened = false;
238   _is_flattenable = field-&gt;is_flattenable();
239 }
240 
241 static bool trust_final_non_static_fields(ciInstanceKlass* holder) {
242   if (holder == NULL)
243     return false;
244   if (holder-&gt;name() == ciSymbol::java_lang_System())
245     // Never trust strangely unstable finals:  System.out, etc.
246     return false;
247   // Even if general trusting is disabled, trust system-built closures in these packages.
248   if (holder-&gt;is_in_package(&quot;java/lang/invoke&quot;) || holder-&gt;is_in_package(&quot;sun/invoke&quot;) ||
249       holder-&gt;is_in_package(&quot;jdk/internal/foreign&quot;) || holder-&gt;is_in_package(&quot;jdk/incubator/foreign&quot;) ||
250       holder-&gt;is_in_package(&quot;java/lang&quot;))
251     return true;
<span class="line-modified">252   // Trust hidden classes and VM unsafe anonymous classes. They are created via</span>
<span class="line-modified">253   // Lookup.defineHiddenClass or the private jdk.internal.misc.Unsafe API and</span>
<span class="line-modified">254   // can&#39;t be serialized, so there is no hacking of finals going on with them.</span>
<span class="line-added">255   if (holder-&gt;is_hidden() || holder-&gt;is_unsafe_anonymous())</span>
256     return true;
257   // Trust final fields in all boxed classes
258   if (holder-&gt;is_box_klass())
259     return true;
260   // Trust final fields in String
261   if (holder-&gt;name() == ciSymbol::java_lang_String())
262     return true;
263   // Trust Atomic*FieldUpdaters: they are very important for performance, and make up one
264   // more reason not to use Unsafe, if their final fields are trusted. See more in JDK-8140483.
265   if (holder-&gt;name() == ciSymbol::java_util_concurrent_atomic_AtomicIntegerFieldUpdater_Impl() ||
266       holder-&gt;name() == ciSymbol::java_util_concurrent_atomic_AtomicLongFieldUpdater_CASUpdater() ||
267       holder-&gt;name() == ciSymbol::java_util_concurrent_atomic_AtomicLongFieldUpdater_LockedUpdater() ||
268       holder-&gt;name() == ciSymbol::java_util_concurrent_atomic_AtomicReferenceFieldUpdater_Impl()) {
269     return true;
270   }
271   return TrustFinalNonStaticFields;
272 }
273 
274 void ciField::initialize_from(fieldDescriptor* fd) {
275   // Get the flags, offset, and canonical holder of the field.
</pre>
</td>
</tr>
</table>
<center><a href="bcEscapeAnalyzer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
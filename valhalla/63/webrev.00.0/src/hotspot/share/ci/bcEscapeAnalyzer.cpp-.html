<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/ci/bcEscapeAnalyzer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  27 #include &quot;ci/ciConstant.hpp&quot;
  28 #include &quot;ci/ciField.hpp&quot;
  29 #include &quot;ci/ciMethodBlocks.hpp&quot;
  30 #include &quot;ci/ciStreams.hpp&quot;
  31 #include &quot;interpreter/bytecode.hpp&quot;
  32 #include &quot;oops/oop.inline.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 #include &quot;utilities/bitMap.inline.hpp&quot;
  35 #include &quot;utilities/copy.hpp&quot;
  36 
  37 #ifndef PRODUCT
  38   #define TRACE_BCEA(level, code)                                            \
  39     if (EstimateArgEscape &amp;&amp; BCEATraceLevel &gt;= level) {                        \
  40       code;                                                                  \
  41     }
  42 #else
  43   #define TRACE_BCEA(level, code)
  44 #endif
  45 
  46 // Maintain a map of which arguments a local variable or
  47 // stack slot may contain.  In addition to tracking
  48 // arguments, it tracks two special values, &quot;allocated&quot;
  49 // which represents any object allocated in the current
  50 // method, and &quot;unknown&quot; which is any other object.
  51 // Up to 30 arguments are handled, with the last one
  52 // representing summary information for any extra arguments
  53 class BCEscapeAnalyzer::ArgumentMap {
  54   uint  _bits;
  55   enum {MAXBIT = 29,
  56         ALLOCATED = 1,
  57         UNKNOWN = 2};
  58 
  59   uint int_to_bit(uint e) const {
  60     if (e &gt; MAXBIT)
  61       e = MAXBIT;
  62     return (1 &lt;&lt; (e + 2));
  63   }
  64 
  65 public:
  66   ArgumentMap()                         { _bits = 0;}
  67   void set_bits(uint bits)              { _bits = bits;}
  68   uint get_bits() const                 { return _bits;}
  69   void clear()                          { _bits = 0;}
  70   void set_all()                        { _bits = ~0u; }
  71   bool is_empty() const                 { return _bits == 0; }
  72   bool contains(uint var) const         { return (_bits &amp; int_to_bit(var)) != 0; }
  73   bool is_singleton(uint var) const     { return (_bits == int_to_bit(var)); }
  74   bool contains_unknown() const         { return (_bits &amp; UNKNOWN) != 0; }
  75   bool contains_allocated() const       { return (_bits &amp; ALLOCATED) != 0; }
  76   bool contains_vars() const            { return (_bits &amp; (((1 &lt;&lt; MAXBIT) -1) &lt;&lt; 2)) != 0; }
  77   void set(uint var)                    { _bits = int_to_bit(var); }
  78   void add(uint var)                    { _bits |= int_to_bit(var); }
  79   void add_unknown()                    { _bits = UNKNOWN; }
  80   void add_allocated()                  { _bits = ALLOCATED; }
  81   void set_union(const ArgumentMap &amp;am)     { _bits |= am._bits; }
  82   void set_difference(const ArgumentMap &amp;am) { _bits &amp;=  ~am._bits; }
  83   void operator=(const ArgumentMap &amp;am) { _bits = am._bits; }
  84   bool operator==(const ArgumentMap &amp;am) { return _bits == am._bits; }
  85   bool operator!=(const ArgumentMap &amp;am) { return _bits != am._bits; }
  86 };
  87 
  88 class BCEscapeAnalyzer::StateInfo {
  89 public:
  90   ArgumentMap *_vars;
  91   ArgumentMap *_stack;
  92   int _stack_height;
  93   int _max_stack;
  94   bool _initialized;
  95   ArgumentMap empty_map;
  96 
  97   StateInfo() {
  98     empty_map.clear();
  99   }
 100 
 101   ArgumentMap raw_pop()  { guarantee(_stack_height &gt; 0, &quot;stack underflow&quot;); return _stack[--_stack_height]; }
 102   ArgumentMap  apop()    { return raw_pop(); }
 103   void spop()            { raw_pop(); }
 104   void lpop()            { spop(); spop(); }
 105   void raw_push(ArgumentMap i)   { guarantee(_stack_height &lt; _max_stack, &quot;stack overflow&quot;); _stack[_stack_height++] = i; }
 106   void apush(ArgumentMap i)      { raw_push(i); }
 107   void spush()           { raw_push(empty_map); }
 108   void lpush()           { spush(); spush(); }
 109 
 110 };
 111 
 112 void BCEscapeAnalyzer::set_returned(ArgumentMap vars) {
 113   for (int i = 0; i &lt; _arg_size; i++) {
 114     if (vars.contains(i))
 115       _arg_returned.set(i);
 116   }
 117   _return_local = _return_local &amp;&amp; !(vars.contains_unknown() || vars.contains_allocated());
 118   _return_allocated = _return_allocated &amp;&amp; vars.contains_allocated() &amp;&amp; !(vars.contains_unknown() || vars.contains_vars());
 119 }
 120 
 121 // return true if any element of vars is an argument
 122 bool BCEscapeAnalyzer::is_argument(ArgumentMap vars) {
 123   for (int i = 0; i &lt; _arg_size; i++) {
 124     if (vars.contains(i))
 125       return true;
 126   }
 127   return false;
 128 }
 129 
 130 // return true if any element of vars is an arg_stack argument
 131 bool BCEscapeAnalyzer::is_arg_stack(ArgumentMap vars){
 132   if (_conservative)
 133     return true;
 134   for (int i = 0; i &lt; _arg_size; i++) {
 135     if (vars.contains(i) &amp;&amp; _arg_stack.test(i))
 136       return true;
 137   }
 138   return false;
 139 }
 140 
 141 // return true if all argument elements of vars are returned
 142 bool BCEscapeAnalyzer::returns_all(ArgumentMap vars) {
 143   for (int i = 0; i &lt; _arg_size; i++) {
 144     if (vars.contains(i) &amp;&amp; !_arg_returned.test(i)) {
 145       return false;
 146     }
 147   }
 148   return true;
 149 }
 150 
 151 void BCEscapeAnalyzer::clear_bits(ArgumentMap vars, VectorSet &amp;bm) {
 152   for (int i = 0; i &lt; _arg_size; i++) {
 153     if (vars.contains(i)) {
 154       bm.remove(i);
 155     }
 156   }
 157 }
 158 
 159 void BCEscapeAnalyzer::set_method_escape(ArgumentMap vars) {
 160   clear_bits(vars, _arg_local);
 161   if (vars.contains_allocated()) {
 162     _allocated_escapes = true;
 163   }
 164 }
 165 
 166 void BCEscapeAnalyzer::set_global_escape(ArgumentMap vars, bool merge) {
 167   clear_bits(vars, _arg_local);
 168   clear_bits(vars, _arg_stack);
 169   if (vars.contains_allocated())
 170     _allocated_escapes = true;
 171 
 172   if (merge &amp;&amp; !vars.is_empty()) {
 173     // Merge new state into already processed block.
 174     // New state is not taken into account and
 175     // it may invalidate set_returned() result.
 176     if (vars.contains_unknown() || vars.contains_allocated()) {
 177       _return_local = false;
 178     }
 179     if (vars.contains_unknown() || vars.contains_vars()) {
 180       _return_allocated = false;
 181     }
 182     if (_return_local &amp;&amp; vars.contains_vars() &amp;&amp; !returns_all(vars)) {
 183       // Return result should be invalidated if args in new
 184       // state are not recorded in return state.
 185       _return_local = false;
 186     }
 187   }
 188 }
 189 
 190 void BCEscapeAnalyzer::set_dirty(ArgumentMap vars) {
 191   clear_bits(vars, _dirty);
 192 }
 193 
 194 void BCEscapeAnalyzer::set_modified(ArgumentMap vars, int offs, int size) {
 195 
 196   for (int i = 0; i &lt; _arg_size; i++) {
 197     if (vars.contains(i)) {
 198       set_arg_modified(i, offs, size);
 199     }
 200   }
 201   if (vars.contains_unknown())
 202     _unknown_modified = true;
 203 }
 204 
 205 bool BCEscapeAnalyzer::is_recursive_call(ciMethod* callee) {
 206   for (BCEscapeAnalyzer* scope = this; scope != NULL; scope = scope-&gt;_parent) {
 207     if (scope-&gt;method() == callee) {
 208       return true;
 209     }
 210   }
 211   return false;
 212 }
 213 
 214 bool BCEscapeAnalyzer::is_arg_modified(int arg, int offset, int size_in_bytes) {
 215   if (offset == OFFSET_ANY)
 216     return _arg_modified[arg] != 0;
 217   assert(arg &gt;= 0 &amp;&amp; arg &lt; _arg_size, &quot;must be an argument.&quot;);
 218   bool modified = false;
 219   int l = offset / HeapWordSize;
 220   int h = align_up(offset + size_in_bytes, HeapWordSize) / HeapWordSize;
 221   if (l &gt; ARG_OFFSET_MAX)
 222     l = ARG_OFFSET_MAX;
 223   if (h &gt; ARG_OFFSET_MAX+1)
 224     h = ARG_OFFSET_MAX + 1;
 225   for (int i = l; i &lt; h; i++) {
 226     modified = modified || (_arg_modified[arg] &amp; (1 &lt;&lt; i)) != 0;
 227   }
 228   return modified;
 229 }
 230 
 231 void BCEscapeAnalyzer::set_arg_modified(int arg, int offset, int size_in_bytes) {
 232   if (offset == OFFSET_ANY) {
 233     _arg_modified[arg] =  (uint) -1;
 234     return;
 235   }
 236   assert(arg &gt;= 0 &amp;&amp; arg &lt; _arg_size, &quot;must be an argument.&quot;);
 237   int l = offset / HeapWordSize;
 238   int h = align_up(offset + size_in_bytes, HeapWordSize) / HeapWordSize;
 239   if (l &gt; ARG_OFFSET_MAX)
 240     l = ARG_OFFSET_MAX;
 241   if (h &gt; ARG_OFFSET_MAX+1)
 242     h = ARG_OFFSET_MAX + 1;
 243   for (int i = l; i &lt; h; i++) {
 244     _arg_modified[arg] |= (1 &lt;&lt; i);
 245   }
 246 }
 247 
 248 void BCEscapeAnalyzer::invoke(StateInfo &amp;state, Bytecodes::Code code, ciMethod* target, ciKlass* holder) {
 249   int i;
 250 
 251   // retrieve information about the callee
 252   ciInstanceKlass* klass = target-&gt;holder();
 253   ciInstanceKlass* calling_klass = method()-&gt;holder();
 254   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
 255   ciInstanceKlass* actual_recv = callee_holder;
 256 
 257   // Some methods are obviously bindable without any type checks so
 258   // convert them directly to an invokespecial or invokestatic.
 259   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
 260     switch (code) {
 261     case Bytecodes::_invokevirtual:
 262       code = Bytecodes::_invokespecial;
 263       break;
 264     case Bytecodes::_invokehandle:
 265       code = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokespecial;
 266       break;
 267     default:
 268       break;
 269     }
 270   }
 271 
 272   // compute size of arguments
 273   int arg_size = target-&gt;invoke_arg_size(code);
 274   int arg_base = MAX2(state._stack_height - arg_size, 0);
 275 
 276   // direct recursive calls are skipped if they can be bound statically without introducing
 277   // dependencies and if parameters are passed at the same position as in the current method
 278   // other calls are skipped if there are no unescaped arguments passed to them
 279   bool directly_recursive = (method() == target) &amp;&amp;
 280                (code != Bytecodes::_invokevirtual || target-&gt;is_final_method() || state._stack[arg_base] .is_empty());
 281 
 282   // check if analysis of callee can safely be skipped
 283   bool skip_callee = true;
 284   for (i = state._stack_height - 1; i &gt;= arg_base &amp;&amp; skip_callee; i--) {
 285     ArgumentMap arg = state._stack[i];
 286     skip_callee = !is_argument(arg) || !is_arg_stack(arg) || (directly_recursive &amp;&amp; arg.is_singleton(i - arg_base));
 287   }
 288   // For now we conservatively skip invokedynamic.
 289   if (code == Bytecodes::_invokedynamic) {
 290     skip_callee = true;
 291   }
 292   if (skip_callee) {
 293     TRACE_BCEA(3, tty-&gt;print_cr(&quot;[EA] skipping method %s::%s&quot;, holder-&gt;name()-&gt;as_utf8(), target-&gt;name()-&gt;as_utf8()));
 294     for (i = 0; i &lt; arg_size; i++) {
 295       set_method_escape(state.raw_pop());
 296     }
 297     _unknown_modified = true;  // assume the worst since we don&#39;t analyze the called method
 298     return;
 299   }
 300 
 301   // determine actual method (use CHA if necessary)
 302   ciMethod* inline_target = NULL;
 303   if (target-&gt;is_loaded() &amp;&amp; klass-&gt;is_loaded()
 304       &amp;&amp; (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
 305       &amp;&amp; target-&gt;is_loaded()) {
 306     if (code == Bytecodes::_invokestatic
 307         || code == Bytecodes::_invokespecial
 308         || (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method())) {
 309       inline_target = target;
 310     } else {
 311       inline_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
 312     }
 313   }
 314 
 315   if (inline_target != NULL &amp;&amp; !is_recursive_call(inline_target)) {
 316     // analyze callee
 317     BCEscapeAnalyzer analyzer(inline_target, this);
 318 
 319     // adjust escape state of actual parameters
 320     bool must_record_dependencies = false;
 321     for (i = arg_size - 1; i &gt;= 0; i--) {
 322       ArgumentMap arg = state.raw_pop();
 323       // Check if callee arg is a caller arg or an allocated object
 324       bool allocated = arg.contains_allocated();
 325       if (!(is_argument(arg) || allocated))
 326         continue;
 327       for (int j = 0; j &lt; _arg_size; j++) {
 328         if (arg.contains(j)) {
 329           _arg_modified[j] |= analyzer._arg_modified[i];
 330         }
 331       }
 332       if (!(is_arg_stack(arg) || allocated)) {
 333         // arguments have already been recognized as escaping
 334       } else if (analyzer.is_arg_stack(i) &amp;&amp; !analyzer.is_arg_returned(i)) {
 335         set_method_escape(arg);
 336         must_record_dependencies = true;
 337       } else {
 338         set_global_escape(arg);
 339       }
 340     }
 341     _unknown_modified = _unknown_modified || analyzer.has_non_arg_side_affects();
 342 
 343     // record dependencies if at least one parameter retained stack-allocatable
 344     if (must_record_dependencies) {
 345       if (code == Bytecodes::_invokeinterface ||
 346           (code == Bytecodes::_invokevirtual &amp;&amp; !target-&gt;is_final_method())) {
 347         _dependencies.append(actual_recv);
 348         _dependencies.append(inline_target);
 349       }
 350       _dependencies.appendAll(analyzer.dependencies());
 351     }
 352   } else {
 353     TRACE_BCEA(1, tty-&gt;print_cr(&quot;[EA] virtual method %s is not monomorphic.&quot;,
 354                                 target-&gt;name()-&gt;as_utf8()));
 355     // conservatively mark all actual parameters as escaping globally
 356     for (i = 0; i &lt; arg_size; i++) {
 357       ArgumentMap arg = state.raw_pop();
 358       if (!is_argument(arg))
 359         continue;
 360       set_modified(arg, OFFSET_ANY, type2size[T_INT]*HeapWordSize);
 361       set_global_escape(arg);
 362     }
 363     _unknown_modified = true;  // assume the worst since we don&#39;t know the called method
 364   }
 365 }
 366 
 367 bool BCEscapeAnalyzer::contains(uint arg_set1, uint arg_set2) {
 368   return ((~arg_set1) | arg_set2) == 0;
 369 }
 370 
 371 
 372 void BCEscapeAnalyzer::iterate_one_block(ciBlock *blk, StateInfo &amp;state, GrowableArray&lt;ciBlock *&gt; &amp;successors) {
 373 
 374   blk-&gt;set_processed();
 375   ciBytecodeStream s(method());
 376   int limit_bci = blk-&gt;limit_bci();
 377   bool fall_through = false;
 378   ArgumentMap allocated_obj;
 379   allocated_obj.add_allocated();
 380   ArgumentMap unknown_obj;
 381   unknown_obj.add_unknown();
 382   ArgumentMap empty_map;
 383 
 384   s.reset_to_bci(blk-&gt;start_bci());
 385   while (s.next() != ciBytecodeStream::EOBC() &amp;&amp; s.cur_bci() &lt; limit_bci) {
 386     fall_through = true;
 387     switch (s.cur_bc()) {
 388       case Bytecodes::_nop:
 389         break;
 390       case Bytecodes::_aconst_null:
 391         state.apush(unknown_obj);
 392         break;
 393       case Bytecodes::_iconst_m1:
 394       case Bytecodes::_iconst_0:
 395       case Bytecodes::_iconst_1:
 396       case Bytecodes::_iconst_2:
 397       case Bytecodes::_iconst_3:
 398       case Bytecodes::_iconst_4:
 399       case Bytecodes::_iconst_5:
 400       case Bytecodes::_fconst_0:
 401       case Bytecodes::_fconst_1:
 402       case Bytecodes::_fconst_2:
 403       case Bytecodes::_bipush:
 404       case Bytecodes::_sipush:
 405         state.spush();
 406         break;
 407       case Bytecodes::_lconst_0:
 408       case Bytecodes::_lconst_1:
 409       case Bytecodes::_dconst_0:
 410       case Bytecodes::_dconst_1:
 411         state.lpush();
 412         break;
 413       case Bytecodes::_ldc:
 414       case Bytecodes::_ldc_w:
 415       case Bytecodes::_ldc2_w:
 416       {
 417         // Avoid calling get_constant() which will try to allocate
 418         // unloaded constant. We need only constant&#39;s type.
 419         int index = s.get_constant_pool_index();
 420         constantTag tag = s.get_constant_pool_tag(index);
 421         if (tag.is_long() || tag.is_double()) {
 422           // Only longs and doubles use 2 stack slots.
 423           state.lpush();
 424         } else if (tag.basic_type() == T_OBJECT) {
 425           state.apush(unknown_obj);
 426         } else {
 427           state.spush();
 428         }
 429         break;
 430       }
 431       case Bytecodes::_aload:
 432         state.apush(state._vars[s.get_index()]);
 433         break;
 434       case Bytecodes::_iload:
 435       case Bytecodes::_fload:
 436       case Bytecodes::_iload_0:
 437       case Bytecodes::_iload_1:
 438       case Bytecodes::_iload_2:
 439       case Bytecodes::_iload_3:
 440       case Bytecodes::_fload_0:
 441       case Bytecodes::_fload_1:
 442       case Bytecodes::_fload_2:
 443       case Bytecodes::_fload_3:
 444         state.spush();
 445         break;
 446       case Bytecodes::_lload:
 447       case Bytecodes::_dload:
 448       case Bytecodes::_lload_0:
 449       case Bytecodes::_lload_1:
 450       case Bytecodes::_lload_2:
 451       case Bytecodes::_lload_3:
 452       case Bytecodes::_dload_0:
 453       case Bytecodes::_dload_1:
 454       case Bytecodes::_dload_2:
 455       case Bytecodes::_dload_3:
 456         state.lpush();
 457         break;
 458       case Bytecodes::_aload_0:
 459         state.apush(state._vars[0]);
 460         break;
 461       case Bytecodes::_aload_1:
 462         state.apush(state._vars[1]);
 463         break;
 464       case Bytecodes::_aload_2:
 465         state.apush(state._vars[2]);
 466         break;
 467       case Bytecodes::_aload_3:
 468         state.apush(state._vars[3]);
 469         break;
 470       case Bytecodes::_iaload:
 471       case Bytecodes::_faload:
 472       case Bytecodes::_baload:
 473       case Bytecodes::_caload:
 474       case Bytecodes::_saload:
 475         state.spop();
 476         set_method_escape(state.apop());
 477         state.spush();
 478         break;
 479       case Bytecodes::_laload:
 480       case Bytecodes::_daload:
 481         state.spop();
 482         set_method_escape(state.apop());
 483         state.lpush();
 484         break;
 485       case Bytecodes::_aaload:
 486         { state.spop();
 487           ArgumentMap array = state.apop();
 488           set_method_escape(array);
 489           state.apush(unknown_obj);
 490           set_dirty(array);
 491         }
 492         break;
 493       case Bytecodes::_istore:
 494       case Bytecodes::_fstore:
 495       case Bytecodes::_istore_0:
 496       case Bytecodes::_istore_1:
 497       case Bytecodes::_istore_2:
 498       case Bytecodes::_istore_3:
 499       case Bytecodes::_fstore_0:
 500       case Bytecodes::_fstore_1:
 501       case Bytecodes::_fstore_2:
 502       case Bytecodes::_fstore_3:
 503         state.spop();
 504         break;
 505       case Bytecodes::_lstore:
 506       case Bytecodes::_dstore:
 507       case Bytecodes::_lstore_0:
 508       case Bytecodes::_lstore_1:
 509       case Bytecodes::_lstore_2:
 510       case Bytecodes::_lstore_3:
 511       case Bytecodes::_dstore_0:
 512       case Bytecodes::_dstore_1:
 513       case Bytecodes::_dstore_2:
 514       case Bytecodes::_dstore_3:
 515         state.lpop();
 516         break;
 517       case Bytecodes::_astore:
 518         state._vars[s.get_index()] = state.apop();
 519         break;
 520       case Bytecodes::_astore_0:
 521         state._vars[0] = state.apop();
 522         break;
 523       case Bytecodes::_astore_1:
 524         state._vars[1] = state.apop();
 525         break;
 526       case Bytecodes::_astore_2:
 527         state._vars[2] = state.apop();
 528         break;
 529       case Bytecodes::_astore_3:
 530         state._vars[3] = state.apop();
 531         break;
 532       case Bytecodes::_iastore:
 533       case Bytecodes::_fastore:
 534       case Bytecodes::_bastore:
 535       case Bytecodes::_castore:
 536       case Bytecodes::_sastore:
 537       {
 538         state.spop();
 539         state.spop();
 540         ArgumentMap arr = state.apop();
 541         set_method_escape(arr);
 542         set_modified(arr, OFFSET_ANY, type2size[T_INT]*HeapWordSize);
 543         break;
 544       }
 545       case Bytecodes::_lastore:
 546       case Bytecodes::_dastore:
 547       {
 548         state.lpop();
 549         state.spop();
 550         ArgumentMap arr = state.apop();
 551         set_method_escape(arr);
 552         set_modified(arr, OFFSET_ANY, type2size[T_LONG]*HeapWordSize);
 553         break;
 554       }
 555       case Bytecodes::_aastore:
 556       {
 557         set_global_escape(state.apop());
 558         state.spop();
 559         ArgumentMap arr = state.apop();
 560         // If the array is flattened, a larger part of it is modified than
 561         // the size of a reference. However, if OFFSET_ANY is given as
 562         // parameter to set_modified(), size is not taken into account.
 563         set_modified(arr, OFFSET_ANY, type2size[T_OBJECT]*HeapWordSize);
 564         break;
 565       }
 566       case Bytecodes::_pop:
 567         state.raw_pop();
 568         break;
 569       case Bytecodes::_pop2:
 570         state.raw_pop();
 571         state.raw_pop();
 572         break;
 573       case Bytecodes::_dup:
 574         { ArgumentMap w1 = state.raw_pop();
 575           state.raw_push(w1);
 576           state.raw_push(w1);
 577         }
 578         break;
 579       case Bytecodes::_dup_x1:
 580         { ArgumentMap w1 = state.raw_pop();
 581           ArgumentMap w2 = state.raw_pop();
 582           state.raw_push(w1);
 583           state.raw_push(w2);
 584           state.raw_push(w1);
 585         }
 586         break;
 587       case Bytecodes::_dup_x2:
 588         { ArgumentMap w1 = state.raw_pop();
 589           ArgumentMap w2 = state.raw_pop();
 590           ArgumentMap w3 = state.raw_pop();
 591           state.raw_push(w1);
 592           state.raw_push(w3);
 593           state.raw_push(w2);
 594           state.raw_push(w1);
 595         }
 596         break;
 597       case Bytecodes::_dup2:
 598         { ArgumentMap w1 = state.raw_pop();
 599           ArgumentMap w2 = state.raw_pop();
 600           state.raw_push(w2);
 601           state.raw_push(w1);
 602           state.raw_push(w2);
 603           state.raw_push(w1);
 604         }
 605         break;
 606       case Bytecodes::_dup2_x1:
 607         { ArgumentMap w1 = state.raw_pop();
 608           ArgumentMap w2 = state.raw_pop();
 609           ArgumentMap w3 = state.raw_pop();
 610           state.raw_push(w2);
 611           state.raw_push(w1);
 612           state.raw_push(w3);
 613           state.raw_push(w2);
 614           state.raw_push(w1);
 615         }
 616         break;
 617       case Bytecodes::_dup2_x2:
 618         { ArgumentMap w1 = state.raw_pop();
 619           ArgumentMap w2 = state.raw_pop();
 620           ArgumentMap w3 = state.raw_pop();
 621           ArgumentMap w4 = state.raw_pop();
 622           state.raw_push(w2);
 623           state.raw_push(w1);
 624           state.raw_push(w4);
 625           state.raw_push(w3);
 626           state.raw_push(w2);
 627           state.raw_push(w1);
 628         }
 629         break;
 630       case Bytecodes::_swap:
 631         { ArgumentMap w1 = state.raw_pop();
 632           ArgumentMap w2 = state.raw_pop();
 633           state.raw_push(w1);
 634           state.raw_push(w2);
 635         }
 636         break;
 637       case Bytecodes::_iadd:
 638       case Bytecodes::_fadd:
 639       case Bytecodes::_isub:
 640       case Bytecodes::_fsub:
 641       case Bytecodes::_imul:
 642       case Bytecodes::_fmul:
 643       case Bytecodes::_idiv:
 644       case Bytecodes::_fdiv:
 645       case Bytecodes::_irem:
 646       case Bytecodes::_frem:
 647       case Bytecodes::_iand:
 648       case Bytecodes::_ior:
 649       case Bytecodes::_ixor:
 650         state.spop();
 651         state.spop();
 652         state.spush();
 653         break;
 654       case Bytecodes::_ladd:
 655       case Bytecodes::_dadd:
 656       case Bytecodes::_lsub:
 657       case Bytecodes::_dsub:
 658       case Bytecodes::_lmul:
 659       case Bytecodes::_dmul:
 660       case Bytecodes::_ldiv:
 661       case Bytecodes::_ddiv:
 662       case Bytecodes::_lrem:
 663       case Bytecodes::_drem:
 664       case Bytecodes::_land:
 665       case Bytecodes::_lor:
 666       case Bytecodes::_lxor:
 667         state.lpop();
 668         state.lpop();
 669         state.lpush();
 670         break;
 671       case Bytecodes::_ishl:
 672       case Bytecodes::_ishr:
 673       case Bytecodes::_iushr:
 674         state.spop();
 675         state.spop();
 676         state.spush();
 677         break;
 678       case Bytecodes::_lshl:
 679       case Bytecodes::_lshr:
 680       case Bytecodes::_lushr:
 681         state.spop();
 682         state.lpop();
 683         state.lpush();
 684         break;
 685       case Bytecodes::_ineg:
 686       case Bytecodes::_fneg:
 687         state.spop();
 688         state.spush();
 689         break;
 690       case Bytecodes::_lneg:
 691       case Bytecodes::_dneg:
 692         state.lpop();
 693         state.lpush();
 694         break;
 695       case Bytecodes::_iinc:
 696         break;
 697       case Bytecodes::_i2l:
 698       case Bytecodes::_i2d:
 699       case Bytecodes::_f2l:
 700       case Bytecodes::_f2d:
 701         state.spop();
 702         state.lpush();
 703         break;
 704       case Bytecodes::_i2f:
 705       case Bytecodes::_f2i:
 706         state.spop();
 707         state.spush();
 708         break;
 709       case Bytecodes::_l2i:
 710       case Bytecodes::_l2f:
 711       case Bytecodes::_d2i:
 712       case Bytecodes::_d2f:
 713         state.lpop();
 714         state.spush();
 715         break;
 716       case Bytecodes::_l2d:
 717       case Bytecodes::_d2l:
 718         state.lpop();
 719         state.lpush();
 720         break;
 721       case Bytecodes::_i2b:
 722       case Bytecodes::_i2c:
 723       case Bytecodes::_i2s:
 724         state.spop();
 725         state.spush();
 726         break;
 727       case Bytecodes::_lcmp:
 728       case Bytecodes::_dcmpl:
 729       case Bytecodes::_dcmpg:
 730         state.lpop();
 731         state.lpop();
 732         state.spush();
 733         break;
 734       case Bytecodes::_fcmpl:
 735       case Bytecodes::_fcmpg:
 736         state.spop();
 737         state.spop();
 738         state.spush();
 739         break;
 740       case Bytecodes::_ifeq:
 741       case Bytecodes::_ifne:
 742       case Bytecodes::_iflt:
 743       case Bytecodes::_ifge:
 744       case Bytecodes::_ifgt:
 745       case Bytecodes::_ifle:
 746       {
 747         state.spop();
 748         int dest_bci = s.get_dest();
 749         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 750         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 751         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 752         break;
 753       }
 754       case Bytecodes::_if_icmpeq:
 755       case Bytecodes::_if_icmpne:
 756       case Bytecodes::_if_icmplt:
 757       case Bytecodes::_if_icmpge:
 758       case Bytecodes::_if_icmpgt:
 759       case Bytecodes::_if_icmple:
 760       {
 761         state.spop();
 762         state.spop();
 763         int dest_bci = s.get_dest();
 764         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 765         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 766         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 767         break;
 768       }
 769       case Bytecodes::_if_acmpeq:
 770       case Bytecodes::_if_acmpne:
 771       {
 772         set_method_escape(state.apop());
 773         set_method_escape(state.apop());
 774         int dest_bci = s.get_dest();
 775         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 776         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 777         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 778         break;
 779       }
 780       case Bytecodes::_goto:
 781       {
 782         int dest_bci = s.get_dest();
 783         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 784         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 785         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 786         fall_through = false;
 787         break;
 788       }
 789       case Bytecodes::_jsr:
 790       {
 791         int dest_bci = s.get_dest();
 792         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 793         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 794         state.apush(empty_map);
 795         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 796         fall_through = false;
 797         break;
 798       }
 799       case Bytecodes::_ret:
 800         // we don&#39;t track  the destination of a &quot;ret&quot; instruction
 801         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 802         fall_through = false;
 803         break;
 804       case Bytecodes::_return:
 805         assert(s.next_bci() == limit_bci, &quot;return must end block&quot;);
 806         fall_through = false;
 807         break;
 808       case Bytecodes::_tableswitch:
 809         {
 810           state.spop();
 811           Bytecode_tableswitch sw(&amp;s);
 812           int len = sw.length();
 813           int dest_bci;
 814           for (int i = 0; i &lt; len; i++) {
 815             dest_bci = s.cur_bci() + sw.dest_offset_at(i);
 816             assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 817             successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 818           }
 819           dest_bci = s.cur_bci() + sw.default_offset();
 820           assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 821           successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 822           assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
 823           fall_through = false;
 824           break;
 825         }
 826       case Bytecodes::_lookupswitch:
 827         {
 828           state.spop();
 829           Bytecode_lookupswitch sw(&amp;s);
 830           int len = sw.number_of_pairs();
 831           int dest_bci;
 832           for (int i = 0; i &lt; len; i++) {
 833             dest_bci = s.cur_bci() + sw.pair_at(i).offset();
 834             assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 835             successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 836           }
 837           dest_bci = s.cur_bci() + sw.default_offset();
 838           assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
 839           successors.push(_methodBlocks-&gt;block_containing(dest_bci));
 840           fall_through = false;
 841           break;
 842         }
 843       case Bytecodes::_ireturn:
 844       case Bytecodes::_freturn:
 845         state.spop();
 846         fall_through = false;
 847         break;
 848       case Bytecodes::_lreturn:
 849       case Bytecodes::_dreturn:
 850         state.lpop();
 851         fall_through = false;
 852         break;
 853       case Bytecodes::_areturn:
 854         set_returned(state.apop());
 855         fall_through = false;
 856         break;
 857       case Bytecodes::_getstatic:
 858       case Bytecodes::_getfield:
 859         { bool ignored_will_link;
 860           ciField* field = s.get_field(ignored_will_link);
 861           BasicType field_type = field-&gt;type()-&gt;basic_type();
 862           if (s.cur_bc() != Bytecodes::_getstatic) {
 863             set_method_escape(state.apop());
 864           }
 865           if (is_reference_type(field_type)) {
 866             state.apush(unknown_obj);
 867           } else if (type2size[field_type] == 1) {
 868             state.spush();
 869           } else {
 870             state.lpush();
 871           }
 872         }
 873         break;
 874       case Bytecodes::_putstatic:
 875       case Bytecodes::_putfield:
 876         { bool will_link;
 877           ciField* field = s.get_field(will_link);
 878           BasicType field_type = field-&gt;type()-&gt;basic_type();
 879           if (is_reference_type(field_type)) {
 880             set_global_escape(state.apop());
 881           } else if (type2size[field_type] == 1) {
 882             state.spop();
 883           } else {
 884             state.lpop();
 885           }
 886           if (s.cur_bc() != Bytecodes::_putstatic) {
 887             ArgumentMap p = state.apop();
 888             set_method_escape(p);
 889             set_modified(p, will_link ? field-&gt;offset() : OFFSET_ANY, type2size[field_type]*HeapWordSize);
 890           }
 891         }
 892         break;
 893       case Bytecodes::_invokevirtual:
 894       case Bytecodes::_invokespecial:
 895       case Bytecodes::_invokestatic:
 896       case Bytecodes::_invokedynamic:
 897       case Bytecodes::_invokeinterface:
 898         { bool ignored_will_link;
 899           ciSignature* declared_signature = NULL;
 900           ciMethod* target = s.get_method(ignored_will_link, &amp;declared_signature);
 901           ciKlass*  holder = s.get_declared_method_holder();
 902           assert(declared_signature != NULL, &quot;cannot be null&quot;);
 903           // If the current bytecode has an attached appendix argument,
 904           // push an unknown object to represent that argument. (Analysis
 905           // of dynamic call sites, especially invokehandle calls, needs
 906           // the appendix argument on the stack, in addition to &quot;regular&quot; arguments
 907           // pushed onto the stack by bytecode instructions preceding the call.)
 908           //
 909           // The escape analyzer does _not_ use the ciBytecodeStream::has_appendix(s)
 910           // method to determine whether the current bytecode has an appendix argument.
 911           // The has_appendix() method obtains the appendix from the
 912           // ConstantPoolCacheEntry::_f1 field, which can happen concurrently with
 913           // resolution of dynamic call sites. Callees in the
 914           // ciBytecodeStream::get_method() call above also access the _f1 field;
 915           // interleaving the get_method() and has_appendix() calls in the current
 916           // method with call site resolution can lead to an inconsistent view of
 917           // the current method&#39;s argument count. In particular, some interleaving(s)
 918           // can cause the method&#39;s argument count to not include the appendix, which
 919           // then leads to stack over-/underflow in the escape analyzer.
 920           //
 921           // Instead of pushing the argument if has_appendix() is true, the escape analyzer
 922           // pushes an appendix for all call sites targeted by invokedynamic and invokehandle
 923           // instructions, except if the call site is the _invokeBasic intrinsic
 924           // (that intrinsic is always targeted by an invokehandle instruction but does
 925           // not have an appendix argument).
 926           if (target-&gt;is_loaded() &amp;&amp;
 927               Bytecodes::has_optional_appendix(s.cur_bc_raw()) &amp;&amp;
 928               target-&gt;intrinsic_id() != vmIntrinsics::_invokeBasic) {
 929             state.apush(unknown_obj);
 930           }
 931           // Pass in raw bytecode because we need to see invokehandle instructions.
 932           invoke(state, s.cur_bc_raw(), target, holder);
 933           // We are using the return type of the declared signature here because
 934           // it might be a more concrete type than the one from the target (for
 935           // e.g. invokedynamic and invokehandle).
 936           ciType* return_type = declared_signature-&gt;return_type();
 937           if (!return_type-&gt;is_primitive_type()) {
 938             state.apush(unknown_obj);
 939           } else if (return_type-&gt;is_one_word()) {
 940             state.spush();
 941           } else if (return_type-&gt;is_two_word()) {
 942             state.lpush();
 943           }
 944         }
 945         break;
 946       case Bytecodes::_new:
 947       case Bytecodes::_defaultvalue:
 948         state.apush(allocated_obj);
 949         break;
 950       case Bytecodes::_withfield: {
 951         bool will_link;
 952         ciField* field = s.get_field(will_link);
 953         BasicType field_type = field-&gt;type()-&gt;basic_type();
 954         if (field_type == T_OBJECT || field_type == T_ARRAY) {
 955           set_global_escape(state.apop());
 956         } else if (type2size[field_type] == 1) {
 957           state.spop();
 958         } else {
 959           state.lpop();
 960         }
 961         set_method_escape(state.apop());
 962         state.apush(allocated_obj);
 963         break;
 964       }
 965       case Bytecodes::_newarray:
 966       case Bytecodes::_anewarray:
 967         state.spop();
 968         state.apush(allocated_obj);
 969         break;
 970       case Bytecodes::_multianewarray:
 971         { int i = s.cur_bcp()[3];
 972           while (i-- &gt; 0) state.spop();
 973           state.apush(allocated_obj);
 974         }
 975         break;
 976       case Bytecodes::_arraylength:
 977         set_method_escape(state.apop());
 978         state.spush();
 979         break;
 980       case Bytecodes::_athrow:
 981         set_global_escape(state.apop());
 982         fall_through = false;
 983         break;
 984       case Bytecodes::_checkcast:
 985         { ArgumentMap obj = state.apop();
 986           set_method_escape(obj);
 987           state.apush(obj);
 988         }
 989         break;
 990       case Bytecodes::_instanceof:
 991         set_method_escape(state.apop());
 992         state.spush();
 993         break;
 994       case Bytecodes::_monitorenter:
 995       case Bytecodes::_monitorexit:
 996         state.apop();
 997         break;
 998       case Bytecodes::_wide:
 999         ShouldNotReachHere();
1000         break;
1001       case Bytecodes::_ifnull:
1002       case Bytecodes::_ifnonnull:
1003       {
1004         set_method_escape(state.apop());
1005         int dest_bci = s.get_dest();
1006         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
1007         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
1008         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
1009         break;
1010       }
1011       case Bytecodes::_goto_w:
1012       {
1013         int dest_bci = s.get_far_dest();
1014         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
1015         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
1016         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
1017         fall_through = false;
1018         break;
1019       }
1020       case Bytecodes::_jsr_w:
1021       {
1022         int dest_bci = s.get_far_dest();
1023         assert(_methodBlocks-&gt;is_block_start(dest_bci), &quot;branch destination must start a block&quot;);
1024         assert(s.next_bci() == limit_bci, &quot;branch must end block&quot;);
1025         state.apush(empty_map);
1026         successors.push(_methodBlocks-&gt;block_containing(dest_bci));
1027         fall_through = false;
1028         break;
1029       }
1030       case Bytecodes::_breakpoint:
1031         break;
1032       default:
1033         ShouldNotReachHere();
1034         break;
1035     }
1036 
1037   }
1038   if (fall_through) {
1039     int fall_through_bci = s.cur_bci();
1040     if (fall_through_bci &lt; _method-&gt;code_size()) {
1041       assert(_methodBlocks-&gt;is_block_start(fall_through_bci), &quot;must fall through to block start.&quot;);
1042       successors.push(_methodBlocks-&gt;block_containing(fall_through_bci));
1043     }
1044   }
1045 }
1046 
1047 void BCEscapeAnalyzer::merge_block_states(StateInfo *blockstates, ciBlock *dest, StateInfo *s_state) {
1048   StateInfo *d_state = blockstates + dest-&gt;index();
1049   int nlocals = _method-&gt;max_locals();
1050 
1051   // exceptions may cause transfer of control to handlers in the middle of a
1052   // block, so we don&#39;t merge the incoming state of exception handlers
1053   if (dest-&gt;is_handler())
1054     return;
1055   if (!d_state-&gt;_initialized ) {
1056     // destination not initialized, just copy
1057     for (int i = 0; i &lt; nlocals; i++) {
1058       d_state-&gt;_vars[i] = s_state-&gt;_vars[i];
1059     }
1060     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1061       d_state-&gt;_stack[i] = s_state-&gt;_stack[i];
1062     }
1063     d_state-&gt;_stack_height = s_state-&gt;_stack_height;
1064     d_state-&gt;_max_stack = s_state-&gt;_max_stack;
1065     d_state-&gt;_initialized = true;
1066   } else if (!dest-&gt;processed()) {
1067     // we have not yet walked the bytecodes of dest, we can merge
1068     // the states
1069     assert(d_state-&gt;_stack_height == s_state-&gt;_stack_height, &quot;computed stack heights must match&quot;);
1070     for (int i = 0; i &lt; nlocals; i++) {
1071       d_state-&gt;_vars[i].set_union(s_state-&gt;_vars[i]);
1072     }
1073     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1074       d_state-&gt;_stack[i].set_union(s_state-&gt;_stack[i]);
1075     }
1076   } else {
1077     // the bytecodes of dest have already been processed, mark any
1078     // arguments in the source state which are not in the dest state
1079     // as global escape.
1080     // Future refinement:  we only need to mark these variable to the
1081     // maximum escape of any variables in dest state
1082     assert(d_state-&gt;_stack_height == s_state-&gt;_stack_height, &quot;computed stack heights must match&quot;);
1083     ArgumentMap extra_vars;
1084     for (int i = 0; i &lt; nlocals; i++) {
1085       ArgumentMap t;
1086       t = s_state-&gt;_vars[i];
1087       t.set_difference(d_state-&gt;_vars[i]);
1088       extra_vars.set_union(t);
1089     }
1090     for (int i = 0; i &lt; s_state-&gt;_stack_height; i++) {
1091       ArgumentMap t;
1092       //extra_vars |= !d_state-&gt;_vars[i] &amp; s_state-&gt;_vars[i];
1093       t.clear();
1094       t = s_state-&gt;_stack[i];
1095       t.set_difference(d_state-&gt;_stack[i]);
1096       extra_vars.set_union(t);
1097     }
1098     set_global_escape(extra_vars, true);
1099   }
1100 }
1101 
1102 void BCEscapeAnalyzer::iterate_blocks(Arena *arena) {
1103   int numblocks = _methodBlocks-&gt;num_blocks();
1104   int stkSize   = _method-&gt;max_stack();
1105   int numLocals = _method-&gt;max_locals();
1106   StateInfo state;
1107 
1108   int datacount = (numblocks + 1) * (stkSize + numLocals);
1109   int datasize = datacount * sizeof(ArgumentMap);
1110   StateInfo *blockstates = (StateInfo *) arena-&gt;Amalloc(numblocks * sizeof(StateInfo));
1111   ArgumentMap *statedata  = (ArgumentMap *) arena-&gt;Amalloc(datasize);
1112   for (int i = 0; i &lt; datacount; i++) ::new ((void*)&amp;statedata[i]) ArgumentMap();
1113   ArgumentMap *dp = statedata;
1114   state._vars = dp;
1115   dp += numLocals;
1116   state._stack = dp;
1117   dp += stkSize;
1118   state._initialized = false;
1119   state._max_stack = stkSize;
1120   for (int i = 0; i &lt; numblocks; i++) {
1121     blockstates[i]._vars = dp;
1122     dp += numLocals;
1123     blockstates[i]._stack = dp;
1124     dp += stkSize;
1125     blockstates[i]._initialized = false;
1126     blockstates[i]._stack_height = 0;
1127     blockstates[i]._max_stack  = stkSize;
1128   }
1129   GrowableArray&lt;ciBlock *&gt; worklist(arena, numblocks / 4, 0, NULL);
1130   GrowableArray&lt;ciBlock *&gt; successors(arena, 4, 0, NULL);
1131 
1132   _methodBlocks-&gt;clear_processed();
1133 
1134   // initialize block 0 state from method signature
1135   ArgumentMap allVars;   // all oop arguments to method
1136   ciSignature* sig = method()-&gt;signature();
1137   int j = 0;
1138   ciBlock* first_blk = _methodBlocks-&gt;block_containing(0);
1139   int fb_i = first_blk-&gt;index();
1140   if (!method()-&gt;is_static()) {
1141     // record information for &quot;this&quot;
1142     blockstates[fb_i]._vars[j].set(j);
1143     allVars.add(j);
1144     j++;
1145   }
1146   for (int i = 0; i &lt; sig-&gt;count(); i++) {
1147     ciType* t = sig-&gt;type_at(i);
1148     if (!t-&gt;is_primitive_type()) {
1149       blockstates[fb_i]._vars[j].set(j);
1150       allVars.add(j);
1151     }
1152     j += t-&gt;size();
1153   }
1154   blockstates[fb_i]._initialized = true;
1155   assert(j == _arg_size, &quot;just checking&quot;);
1156 
1157   ArgumentMap unknown_map;
1158   unknown_map.add_unknown();
1159 
1160   worklist.push(first_blk);
1161   while(worklist.length() &gt; 0) {
1162     ciBlock *blk = worklist.pop();
1163     StateInfo *blkState = blockstates + blk-&gt;index();
1164     if (blk-&gt;is_handler() || blk-&gt;is_ret_target()) {
1165       // for an exception handler or a target of a ret instruction, we assume the worst case,
1166       // that any variable could contain any argument
1167       for (int i = 0; i &lt; numLocals; i++) {
1168         state._vars[i] = allVars;
1169       }
1170       if (blk-&gt;is_handler()) {
1171         state._stack_height = 1;
1172       } else {
1173         state._stack_height = blkState-&gt;_stack_height;
1174       }
1175       for (int i = 0; i &lt; state._stack_height; i++) {
1176 // ??? should this be unknown_map ???
1177         state._stack[i] = allVars;
1178       }
1179     } else {
1180       for (int i = 0; i &lt; numLocals; i++) {
1181         state._vars[i] = blkState-&gt;_vars[i];
1182       }
1183       for (int i = 0; i &lt; blkState-&gt;_stack_height; i++) {
1184         state._stack[i] = blkState-&gt;_stack[i];
1185       }
1186       state._stack_height = blkState-&gt;_stack_height;
1187     }
1188     iterate_one_block(blk, state, successors);
1189     // if this block has any exception handlers, push them
1190     // onto successor list
1191     if (blk-&gt;has_handler()) {
1192       DEBUG_ONLY(int handler_count = 0;)
1193       int blk_start = blk-&gt;start_bci();
1194       int blk_end = blk-&gt;limit_bci();
1195       for (int i = 0; i &lt; numblocks; i++) {
1196         ciBlock *b = _methodBlocks-&gt;block(i);
1197         if (b-&gt;is_handler()) {
1198           int ex_start = b-&gt;ex_start_bci();
1199           int ex_end = b-&gt;ex_limit_bci();
1200           if ((ex_start &gt;= blk_start &amp;&amp; ex_start &lt; blk_end) ||
1201               (ex_end &gt; blk_start &amp;&amp; ex_end &lt;= blk_end)) {
1202             successors.push(b);
1203           }
1204           DEBUG_ONLY(handler_count++;)
1205         }
1206       }
1207       assert(handler_count &gt; 0, &quot;must find at least one handler&quot;);
1208     }
1209     // merge computed variable state with successors
1210     while(successors.length() &gt; 0) {
1211       ciBlock *succ = successors.pop();
1212       merge_block_states(blockstates, succ, &amp;state);
1213       if (!succ-&gt;processed())
1214         worklist.push(succ);
1215     }
1216   }
1217 }
1218 
1219 void BCEscapeAnalyzer::do_analysis() {
1220   Arena* arena = CURRENT_ENV-&gt;arena();
1221   // identify basic blocks
1222   _methodBlocks = _method-&gt;get_method_blocks();
1223 
1224   iterate_blocks(arena);
1225 }
1226 
1227 vmIntrinsics::ID BCEscapeAnalyzer::known_intrinsic() {
1228   vmIntrinsics::ID iid = method()-&gt;intrinsic_id();
1229   if (iid == vmIntrinsics::_getClass ||
1230       iid == vmIntrinsics::_hashCode) {
1231     return iid;
1232   } else {
1233     return vmIntrinsics::_none;
1234   }
1235 }
1236 
1237 void BCEscapeAnalyzer::compute_escape_for_intrinsic(vmIntrinsics::ID iid) {
1238   switch (iid) {
1239     case vmIntrinsics::_getClass:
1240       _return_local = false;
1241       _return_allocated = false;
1242       break;
1243     case vmIntrinsics::_hashCode:
1244       // initialized state is correct
1245       break;
1246   default:
1247     assert(false, &quot;unexpected intrinsic&quot;);
1248   }
1249 }
1250 
1251 void BCEscapeAnalyzer::initialize() {
1252   int i;
1253 
1254   // clear escape information (method may have been deoptimized)
1255   methodData()-&gt;clear_escape_info();
1256 
1257   // initialize escape state of object parameters
1258   ciSignature* sig = method()-&gt;signature();
1259   int j = 0;
1260   if (!method()-&gt;is_static()) {
1261     _arg_local.set(0);
1262     _arg_stack.set(0);
1263     j++;
1264   }
1265   for (i = 0; i &lt; sig-&gt;count(); i++) {
1266     ciType* t = sig-&gt;type_at(i);
1267     if (!t-&gt;is_primitive_type()) {
1268       _arg_local.set(j);
1269       _arg_stack.set(j);
1270     }
1271     j += t-&gt;size();
1272   }
1273   assert(j == _arg_size, &quot;just checking&quot;);
1274 
1275   // start with optimistic assumption
1276   ciType *rt = _method-&gt;return_type();
1277   if (rt-&gt;is_primitive_type()) {
1278     _return_local = false;
1279     _return_allocated = false;
1280   } else {
1281     _return_local = true;
1282     _return_allocated = true;
1283   }
1284   _allocated_escapes = false;
1285   _unknown_modified = false;
1286 }
1287 
1288 void BCEscapeAnalyzer::clear_escape_info() {
1289   ciSignature* sig = method()-&gt;signature();
1290   int arg_count = sig-&gt;count();
1291   ArgumentMap var;
1292   if (!method()-&gt;is_static()) {
1293     arg_count++;  // allow for &quot;this&quot;
1294   }
1295   for (int i = 0; i &lt; arg_count; i++) {
1296     set_arg_modified(i, OFFSET_ANY, 4);
1297     var.clear();
1298     var.set(i);
1299     set_modified(var, OFFSET_ANY, 4);
1300     set_global_escape(var);
1301   }
1302   _arg_local.clear();
1303   _arg_stack.clear();
1304   _arg_returned.clear();
1305   _return_local = false;
1306   _return_allocated = false;
1307   _allocated_escapes = true;
1308   _unknown_modified = true;
1309 }
1310 
1311 
1312 void BCEscapeAnalyzer::compute_escape_info() {
1313   int i;
1314   assert(!methodData()-&gt;has_escape_info(), &quot;do not overwrite escape info&quot;);
1315 
1316   vmIntrinsics::ID iid = known_intrinsic();
1317 
1318   // check if method can be analyzed
1319   if (iid == vmIntrinsics::_none &amp;&amp; (method()-&gt;is_abstract() || method()-&gt;is_native() || !method()-&gt;holder()-&gt;is_initialized()
1320       || _level &gt; MaxBCEAEstimateLevel
1321       || method()-&gt;code_size() &gt; MaxBCEAEstimateSize)) {
1322     if (BCEATraceLevel &gt;= 1) {
1323       tty-&gt;print(&quot;Skipping method because: &quot;);
1324       if (method()-&gt;is_abstract())
1325         tty-&gt;print_cr(&quot;method is abstract.&quot;);
1326       else if (method()-&gt;is_native())
1327         tty-&gt;print_cr(&quot;method is native.&quot;);
1328       else if (!method()-&gt;holder()-&gt;is_initialized())
1329         tty-&gt;print_cr(&quot;class of method is not initialized.&quot;);
1330       else if (_level &gt; MaxBCEAEstimateLevel)
1331         tty-&gt;print_cr(&quot;level (%d) exceeds MaxBCEAEstimateLevel (%d).&quot;,
1332                       _level, (int) MaxBCEAEstimateLevel);
1333       else if (method()-&gt;code_size() &gt; MaxBCEAEstimateSize)
1334         tty-&gt;print_cr(&quot;code size (%d) exceeds MaxBCEAEstimateSize (%d).&quot;,
1335                       method()-&gt;code_size(), (int) MaxBCEAEstimateSize);
1336       else
1337         ShouldNotReachHere();
1338     }
1339     clear_escape_info();
1340 
1341     return;
1342   }
1343 
1344   if (BCEATraceLevel &gt;= 1) {
1345     tty-&gt;print(&quot;[EA] estimating escape information for&quot;);
1346     if (iid != vmIntrinsics::_none)
1347       tty-&gt;print(&quot; intrinsic&quot;);
1348     method()-&gt;print_short_name();
1349     tty-&gt;print_cr(&quot; (%d bytes)&quot;, method()-&gt;code_size());
1350   }
1351 
1352   initialize();
1353 
1354   // Do not scan method if it has no object parameters and
1355   // does not returns an object (_return_allocated is set in initialize()).
1356   if (_arg_local.is_empty() &amp;&amp; !_return_allocated) {
1357     // Clear all info since method&#39;s bytecode was not analysed and
1358     // set pessimistic escape information.
1359     clear_escape_info();
1360     methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1361     methodData()-&gt;set_eflag(MethodData::unknown_modified);
1362     methodData()-&gt;set_eflag(MethodData::estimated);
1363     return;
1364   }
1365 
1366   if (iid != vmIntrinsics::_none)
1367     compute_escape_for_intrinsic(iid);
1368   else {
1369     do_analysis();
1370   }
1371 
1372   // don&#39;t store interprocedural escape information if it introduces
1373   // dependencies or if method data is empty
1374   //
1375   if (!has_dependencies() &amp;&amp; !methodData()-&gt;is_empty()) {
1376     for (i = 0; i &lt; _arg_size; i++) {
1377       if (_arg_local.test(i)) {
1378         assert(_arg_stack.test(i), &quot;inconsistent escape info&quot;);
1379         methodData()-&gt;set_arg_local(i);
1380         methodData()-&gt;set_arg_stack(i);
1381       } else if (_arg_stack.test(i)) {
1382         methodData()-&gt;set_arg_stack(i);
1383       }
1384       if (_arg_returned.test(i)) {
1385         methodData()-&gt;set_arg_returned(i);
1386       }
1387       methodData()-&gt;set_arg_modified(i, _arg_modified[i]);
1388     }
1389     if (_return_local) {
1390       methodData()-&gt;set_eflag(MethodData::return_local);
1391     }
1392     if (_return_allocated) {
1393       methodData()-&gt;set_eflag(MethodData::return_allocated);
1394     }
1395     if (_allocated_escapes) {
1396       methodData()-&gt;set_eflag(MethodData::allocated_escapes);
1397     }
1398     if (_unknown_modified) {
1399       methodData()-&gt;set_eflag(MethodData::unknown_modified);
1400     }
1401     methodData()-&gt;set_eflag(MethodData::estimated);
1402   }
1403 }
1404 
1405 void BCEscapeAnalyzer::read_escape_info() {
1406   assert(methodData()-&gt;has_escape_info(), &quot;no escape info available&quot;);
1407 
1408   // read escape information from method descriptor
1409   for (int i = 0; i &lt; _arg_size; i++) {
1410     if (methodData()-&gt;is_arg_local(i))
1411       _arg_local.set(i);
1412     if (methodData()-&gt;is_arg_stack(i))
1413       _arg_stack.set(i);
1414     if (methodData()-&gt;is_arg_returned(i))
1415       _arg_returned.set(i);
1416     _arg_modified[i] = methodData()-&gt;arg_modified(i);
1417   }
1418   _return_local = methodData()-&gt;eflag_set(MethodData::return_local);
1419   _return_allocated = methodData()-&gt;eflag_set(MethodData::return_allocated);
1420   _allocated_escapes = methodData()-&gt;eflag_set(MethodData::allocated_escapes);
1421   _unknown_modified = methodData()-&gt;eflag_set(MethodData::unknown_modified);
1422 
1423 }
1424 
1425 #ifndef PRODUCT
1426 void BCEscapeAnalyzer::dump() {
1427   tty-&gt;print(&quot;[EA] estimated escape information for&quot;);
1428   method()-&gt;print_short_name();
1429   tty-&gt;print_cr(has_dependencies() ? &quot; (not stored)&quot; : &quot;&quot;);
1430   tty-&gt;print(&quot;     non-escaping args:      &quot;);
1431   _arg_local.print();
1432   tty-&gt;print(&quot;     stack-allocatable args: &quot;);
1433   _arg_stack.print();
1434   if (_return_local) {
1435     tty-&gt;print(&quot;     returned args:          &quot;);
1436     _arg_returned.print();
1437   } else if (is_return_allocated()) {
1438     tty-&gt;print_cr(&quot;     return allocated value&quot;);
1439   } else {
1440     tty-&gt;print_cr(&quot;     return non-local value&quot;);
1441   }
1442   tty-&gt;print(&quot;     modified args: &quot;);
1443   for (int i = 0; i &lt; _arg_size; i++) {
1444     if (_arg_modified[i] == 0)
1445       tty-&gt;print(&quot;    0&quot;);
1446     else
1447       tty-&gt;print(&quot;    0x%x&quot;, _arg_modified[i]);
1448   }
1449   tty-&gt;cr();
1450   tty-&gt;print(&quot;     flags: &quot;);
1451   if (_return_allocated)
1452     tty-&gt;print(&quot; return_allocated&quot;);
1453   if (_allocated_escapes)
1454     tty-&gt;print(&quot; allocated_escapes&quot;);
1455   if (_unknown_modified)
1456     tty-&gt;print(&quot; unknown_modified&quot;);
1457   tty-&gt;cr();
1458 }
1459 #endif
1460 
1461 BCEscapeAnalyzer::BCEscapeAnalyzer(ciMethod* method, BCEscapeAnalyzer* parent)
1462     : _arena(CURRENT_ENV-&gt;arena())
1463     , _conservative(method == NULL || !EstimateArgEscape)
1464     , _method(method)
1465     , _methodData(method ? method-&gt;method_data() : NULL)
1466     , _arg_size(method ? method-&gt;arg_size() : 0)
1467     , _arg_local(_arena)
1468     , _arg_stack(_arena)
1469     , _arg_returned(_arena)
1470     , _dirty(_arena)
1471     , _return_local(false)
1472     , _return_allocated(false)
1473     , _allocated_escapes(false)
1474     , _unknown_modified(false)
1475     , _dependencies(_arena, 4, 0, NULL)
1476     , _parent(parent)
1477     , _level(parent == NULL ? 0 : parent-&gt;level() + 1) {
1478   if (!_conservative) {
1479     _arg_local.clear();
1480     _arg_stack.clear();
1481     _arg_returned.clear();
1482     _dirty.clear();
1483     Arena* arena = CURRENT_ENV-&gt;arena();
1484     _arg_modified = (uint *) arena-&gt;Amalloc(_arg_size * sizeof(uint));
1485     Copy::zero_to_bytes(_arg_modified, _arg_size * sizeof(uint));
1486 
1487     if (methodData() == NULL)
1488       return;
1489     if (methodData()-&gt;has_escape_info()) {
1490       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] Reading previous results for %s.%s&quot;,
1491                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1492                                   method-&gt;name()-&gt;as_utf8()));
1493       read_escape_info();
1494     } else {
1495       TRACE_BCEA(2, tty-&gt;print_cr(&quot;[EA] computing results for %s.%s&quot;,
1496                                   method-&gt;holder()-&gt;name()-&gt;as_utf8(),
1497                                   method-&gt;name()-&gt;as_utf8()));
1498 
1499       compute_escape_info();
1500       methodData()-&gt;update_escape_info();
1501     }
1502 #ifndef PRODUCT
1503     if (BCEATraceLevel &gt;= 3) {
1504       // dump escape information
1505       dump();
1506     }
1507 #endif
1508   }
1509 }
1510 
1511 void BCEscapeAnalyzer::copy_dependencies(Dependencies *deps) {
1512   if (ciEnv::current()-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
1513     // Also record evol dependencies so redefinition of the
1514     // callee will trigger recompilation.
1515     deps-&gt;assert_evol_method(method());
1516   }
1517   for (int i = 0; i &lt; _dependencies.length(); i+=2) {
1518     ciKlass *k = _dependencies.at(i)-&gt;as_klass();
1519     ciMethod *m = _dependencies.at(i+1)-&gt;as_method();
1520     deps-&gt;assert_unique_concrete_method(k, m);
1521   }
1522 }
    </pre>
  </body>
</html>
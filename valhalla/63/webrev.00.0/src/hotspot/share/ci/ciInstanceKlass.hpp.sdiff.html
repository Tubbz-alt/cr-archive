<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciInstanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciInstanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classFileParser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciInstanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39   CI_PACKAGE_ACCESS
 40   friend class ciBytecodeStream;
 41   friend class ciEnv;
 42   friend class ciExceptionHandler;
 43   friend class ciMethod;
 44   friend class ciField;
 45 
 46 private:
 47   enum SubklassValue { subklass_unknown, subklass_false, subklass_true };
 48 
 49   jobject                _loader;
 50   jobject                _protection_domain;
 51 
 52   InstanceKlass::ClassState _init_state;           // state of class
 53   bool                   _is_shared;
 54   bool                   _has_finalizer;
 55   SubklassValue          _has_subklass;
 56   bool                   _has_nonstatic_fields;
 57   bool                   _has_nonstatic_concrete_methods;
 58   bool                   _is_unsafe_anonymous;

 59 
 60   ciFlags                _flags;
 61   jint                   _nonstatic_field_size;
 62   jint                   _nonstatic_oop_map_size;
 63 
 64   // Lazy fields get filled in only upon request.
 65   ciInstanceKlass*       _super;
 66   ciInstance*            _java_mirror;
 67 
 68   ciConstantPoolCache*   _field_cache;  // cached map index-&gt;field
 69   GrowableArray&lt;ciField*&gt;* _nonstatic_fields;
 70 
 71   int                    _has_injected_fields; // any non static injected fields? lazily initialized.
 72 
 73   // The possible values of the _implementor fall into following three cases:
 74   //   NULL: no implementor.
 75   //   A ciInstanceKlass that&#39;s not itself: one implementor.
 76   //   Itself: more than one implementor.
 77   ciInstanceKlass*       _implementor;
 78 
</pre>
<hr />
<pre>
175     assert(is_loaded(), &quot;must be loaded&quot;);
176     return _nonstatic_oop_map_size; }
177   ciInstanceKlass*       super();
178   jint                   nof_implementors() {
179     ciInstanceKlass* impl;
180     assert(is_loaded(), &quot;must be loaded&quot;);
181     impl = implementor();
182     if (impl == NULL) {
183       return 0;
184     } else if (impl != this) {
185       return 1;
186     } else {
187       return 2;
188     }
189   }
190   bool has_nonstatic_concrete_methods()  {
191     assert(is_loaded(), &quot;must be loaded&quot;);
192     return _has_nonstatic_concrete_methods;
193   }
194 
<span class="line-modified">195   bool is_unsafe_anonymous() {</span>
196     return _is_unsafe_anonymous;
197   }
198 




199   ciInstanceKlass* get_canonical_holder(int offset);
200   ciField* get_field_by_offset(int field_offset, bool is_static);
201   ciField* get_field_by_name(ciSymbol* name, ciSymbol* signature, bool is_static);
202   // get field descriptor at field_offset ignoring flattening
203   ciField* get_non_flattened_field_by_offset(int field_offset);
204 
205   // total number of nonstatic fields (including inherited):
206   int nof_nonstatic_fields() {
207     if (_nonstatic_fields == NULL) {
208       return compute_nonstatic_fields();
209     } else {
210       return _nonstatic_fields-&gt;length();
211     }
212   }
213 
214   bool has_injected_fields() {
215     if (_has_injected_fields == -1) {
216       compute_injected_fields();
217     }
218     return _has_injected_fields &gt; 0 ? true : false;
</pre>
</td>
<td>
<hr />
<pre>
 39   CI_PACKAGE_ACCESS
 40   friend class ciBytecodeStream;
 41   friend class ciEnv;
 42   friend class ciExceptionHandler;
 43   friend class ciMethod;
 44   friend class ciField;
 45 
 46 private:
 47   enum SubklassValue { subklass_unknown, subklass_false, subklass_true };
 48 
 49   jobject                _loader;
 50   jobject                _protection_domain;
 51 
 52   InstanceKlass::ClassState _init_state;           // state of class
 53   bool                   _is_shared;
 54   bool                   _has_finalizer;
 55   SubklassValue          _has_subklass;
 56   bool                   _has_nonstatic_fields;
 57   bool                   _has_nonstatic_concrete_methods;
 58   bool                   _is_unsafe_anonymous;
<span class="line-added"> 59   bool                   _is_hidden;</span>
 60 
 61   ciFlags                _flags;
 62   jint                   _nonstatic_field_size;
 63   jint                   _nonstatic_oop_map_size;
 64 
 65   // Lazy fields get filled in only upon request.
 66   ciInstanceKlass*       _super;
 67   ciInstance*            _java_mirror;
 68 
 69   ciConstantPoolCache*   _field_cache;  // cached map index-&gt;field
 70   GrowableArray&lt;ciField*&gt;* _nonstatic_fields;
 71 
 72   int                    _has_injected_fields; // any non static injected fields? lazily initialized.
 73 
 74   // The possible values of the _implementor fall into following three cases:
 75   //   NULL: no implementor.
 76   //   A ciInstanceKlass that&#39;s not itself: one implementor.
 77   //   Itself: more than one implementor.
 78   ciInstanceKlass*       _implementor;
 79 
</pre>
<hr />
<pre>
176     assert(is_loaded(), &quot;must be loaded&quot;);
177     return _nonstatic_oop_map_size; }
178   ciInstanceKlass*       super();
179   jint                   nof_implementors() {
180     ciInstanceKlass* impl;
181     assert(is_loaded(), &quot;must be loaded&quot;);
182     impl = implementor();
183     if (impl == NULL) {
184       return 0;
185     } else if (impl != this) {
186       return 1;
187     } else {
188       return 2;
189     }
190   }
191   bool has_nonstatic_concrete_methods()  {
192     assert(is_loaded(), &quot;must be loaded&quot;);
193     return _has_nonstatic_concrete_methods;
194   }
195 
<span class="line-modified">196   bool is_unsafe_anonymous() const {</span>
197     return _is_unsafe_anonymous;
198   }
199 
<span class="line-added">200   bool is_hidden() const {</span>
<span class="line-added">201     return _is_hidden;</span>
<span class="line-added">202   }</span>
<span class="line-added">203 </span>
204   ciInstanceKlass* get_canonical_holder(int offset);
205   ciField* get_field_by_offset(int field_offset, bool is_static);
206   ciField* get_field_by_name(ciSymbol* name, ciSymbol* signature, bool is_static);
207   // get field descriptor at field_offset ignoring flattening
208   ciField* get_non_flattened_field_by_offset(int field_offset);
209 
210   // total number of nonstatic fields (including inherited):
211   int nof_nonstatic_fields() {
212     if (_nonstatic_fields == NULL) {
213       return compute_nonstatic_fields();
214     } else {
215       return _nonstatic_fields-&gt;length();
216     }
217   }
218 
219   bool has_injected_fields() {
220     if (_has_injected_fields == -1) {
221       compute_injected_fields();
222     }
223     return _has_injected_fields &gt; 0 ? true : false;
</pre>
</td>
</tr>
</table>
<center><a href="ciInstanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classFileParser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 994   void* handle = NULL;
 995   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
 996     handle = os::dll_load(path, ebuf, sizeof ebuf);
 997   }
 998   if (handle == NULL) {
 999     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1000   }
1001 
1002   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1003   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1004   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1005   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1006   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1007   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1008 }
1009 
1010 int ClassLoader::crc32(int crc, const char* buf, int len) {
1011   return (*Crc32)(crc, (const jbyte*)buf, len);
1012 }
1013 
<span class="line-removed">1014 // Function add_package checks if the package of the InstanceKlass is in the</span>
<span class="line-removed">1015 // boot loader&#39;s package entry table.  If so, then it sets the classpath_index</span>
<span class="line-removed">1016 // in the package entry record.</span>
<span class="line-removed">1017 //</span>
<span class="line-removed">1018 // The classpath_index field is used to find the entry on the boot loader class</span>
<span class="line-removed">1019 // path for packages with classes loaded by the boot loader from -Xbootclasspath/a</span>
<span class="line-removed">1020 // in an unnamed module.  It is also used to indicate (for all packages whose</span>
<span class="line-removed">1021 // classes are loaded by the boot loader) that at least one of the package&#39;s</span>
<span class="line-removed">1022 // classes has been loaded.</span>
<span class="line-removed">1023 bool ClassLoader::add_package(const InstanceKlass* ik, s2 classpath_index, TRAPS) {</span>
<span class="line-removed">1024   assert(ik != NULL, &quot;just checking&quot;);</span>
<span class="line-removed">1025 </span>
<span class="line-removed">1026   PackageEntry* ik_pkg = ik-&gt;package();</span>
<span class="line-removed">1027   if (ik_pkg != NULL) {</span>
<span class="line-removed">1028     PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();</span>
<span class="line-removed">1029     PackageEntry* pkg_entry = pkg_entry_tbl-&gt;lookup_only(ik_pkg-&gt;name());</span>
<span class="line-removed">1030     if (pkg_entry != NULL) {</span>
<span class="line-removed">1031       assert(classpath_index != -1, &quot;Unexpected classpath_index&quot;);</span>
<span class="line-removed">1032       pkg_entry-&gt;set_classpath_index(classpath_index);</span>
<span class="line-removed">1033     } else {</span>
<span class="line-removed">1034       return false;</span>
<span class="line-removed">1035     }</span>
<span class="line-removed">1036   }</span>
<span class="line-removed">1037   return true;</span>
<span class="line-removed">1038 }</span>
<span class="line-removed">1039 </span>
1040 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1041   // Look up the name in the boot loader&#39;s package entry table.
1042   if (name != NULL) {
1043     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1044     // Look for the package entry in the boot loader&#39;s package entry table.
1045     PackageEntry* package =
1046       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1047 
1048     // Return NULL if package does not exist or if no classes in that package
1049     // have been loaded.
1050     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1051       ModuleEntry* module = package-&gt;module();
1052       if (module-&gt;location() != NULL) {
1053         ResourceMark rm(THREAD);
1054         Handle ml = java_lang_String::create_from_str(
1055           module-&gt;location()-&gt;as_C_string(), THREAD);
1056         return ml();
1057       }
1058       // Return entry on boot loader class path.
1059       Handle cph = java_lang_String::create_from_str(
</pre>
<hr />
<pre>
1266 
1267     e = _first_append_entry;
1268     while (e != NULL) {
1269       stream = e-&gt;open_stream(file_name, CHECK_NULL);
1270       if (NULL != stream) {
1271         break;
1272       }
1273       e = e-&gt;next();
1274       ++classpath_index;
1275     }
1276   }
1277 
1278   if (NULL == stream) {
1279     return NULL;
1280   }
1281 
1282   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1283 
1284   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1285   Handle protection_domain;

1286 
1287   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1288                                                            name,
1289                                                            loader_data,
<span class="line-modified">1290                                                            protection_domain,</span>
<span class="line-removed">1291                                                            NULL, // unsafe_anonymous_host</span>
<span class="line-removed">1292                                                            NULL, // cp_patches</span>
1293                                                            THREAD);
1294   if (HAS_PENDING_EXCEPTION) {
1295     if (DumpSharedSpaces) {
1296       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);
1297     }
1298     return NULL;
1299   }
1300 
<span class="line-modified">1301   if (!add_package(result, classpath_index, THREAD)) {</span>
<span class="line-removed">1302     return NULL;</span>
<span class="line-removed">1303   }</span>
<span class="line-removed">1304 </span>
1305   return result;
1306 }
1307 
1308 #if INCLUDE_CDS
1309 char* ClassLoader::skip_uri_protocol(char* source) {
1310   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1311     // file: protocol path could start with file:/ or file:///
1312     // locate the char after all the forward slashes
1313     int offset = 5;
1314     while (*(source + offset) == &#39;/&#39;) {
1315         offset++;
1316     }
1317     source += offset;
1318   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1319 #ifndef _WINDOWS
1320     source -= 1;
1321 #endif
1322   } else if (strncmp(source, &quot;jrt:/&quot;, 5) == 0) {
1323     source += 5;
1324   }
1325   return source;
1326 }
1327 
1328 // Record the shared classpath index and loader type for classes loaded
1329 // by the builtin loaders at dump time.
1330 void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
1331   Arguments::assert_is_dumping_archive();
1332   assert(stream != NULL, &quot;sanity&quot;);
1333 
<span class="line-modified">1334   if (ik-&gt;is_unsafe_anonymous()) {</span>
<span class="line-modified">1335     // We do not archive unsafe anonymous classes.</span>
1336     return;
1337   }
1338 
1339   oop loader = ik-&gt;class_loader();
1340   char* src = (char*)stream-&gt;source();
1341   if (src == NULL) {
1342     if (loader == NULL) {
1343       // JFR classes
1344       ik-&gt;set_shared_classpath_index(0);
1345       ik-&gt;set_shared_class_loader_type(ClassLoader::BOOT_LOADER);
1346     }
1347     return;
1348   }
1349 
1350   assert(has_jrt_entry(), &quot;CDS dumping does not support exploded JDK build&quot;);
1351 
1352   ResourceMark rm(THREAD);
1353   int classpath_index = -1;
1354   PackageEntry* pkg_entry = ik-&gt;package();
1355 
</pre>
</td>
<td>
<hr />
<pre>
 994   void* handle = NULL;
 995   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
 996     handle = os::dll_load(path, ebuf, sizeof ebuf);
 997   }
 998   if (handle == NULL) {
 999     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1000   }
1001 
1002   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1003   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1004   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1005   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1006   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1007   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1008 }
1009 
1010 int ClassLoader::crc32(int crc, const char* buf, int len) {
1011   return (*Crc32)(crc, (const jbyte*)buf, len);
1012 }
1013 


























1014 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1015   // Look up the name in the boot loader&#39;s package entry table.
1016   if (name != NULL) {
1017     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1018     // Look for the package entry in the boot loader&#39;s package entry table.
1019     PackageEntry* package =
1020       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1021 
1022     // Return NULL if package does not exist or if no classes in that package
1023     // have been loaded.
1024     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1025       ModuleEntry* module = package-&gt;module();
1026       if (module-&gt;location() != NULL) {
1027         ResourceMark rm(THREAD);
1028         Handle ml = java_lang_String::create_from_str(
1029           module-&gt;location()-&gt;as_C_string(), THREAD);
1030         return ml();
1031       }
1032       // Return entry on boot loader class path.
1033       Handle cph = java_lang_String::create_from_str(
</pre>
<hr />
<pre>
1240 
1241     e = _first_append_entry;
1242     while (e != NULL) {
1243       stream = e-&gt;open_stream(file_name, CHECK_NULL);
1244       if (NULL != stream) {
1245         break;
1246       }
1247       e = e-&gt;next();
1248       ++classpath_index;
1249     }
1250   }
1251 
1252   if (NULL == stream) {
1253     return NULL;
1254   }
1255 
1256   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1257 
1258   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1259   Handle protection_domain;
<span class="line-added">1260   ClassLoadInfo cl_info(protection_domain);</span>
1261 
1262   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1263                                                            name,
1264                                                            loader_data,
<span class="line-modified">1265                                                            cl_info,</span>


1266                                                            THREAD);
1267   if (HAS_PENDING_EXCEPTION) {
1268     if (DumpSharedSpaces) {
1269       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);
1270     }
1271     return NULL;
1272   }
1273 
<span class="line-modified">1274   result-&gt;set_classpath_index(classpath_index, THREAD);</span>



1275   return result;
1276 }
1277 
1278 #if INCLUDE_CDS
1279 char* ClassLoader::skip_uri_protocol(char* source) {
1280   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1281     // file: protocol path could start with file:/ or file:///
1282     // locate the char after all the forward slashes
1283     int offset = 5;
1284     while (*(source + offset) == &#39;/&#39;) {
1285         offset++;
1286     }
1287     source += offset;
1288   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1289 #ifndef _WINDOWS
1290     source -= 1;
1291 #endif
1292   } else if (strncmp(source, &quot;jrt:/&quot;, 5) == 0) {
1293     source += 5;
1294   }
1295   return source;
1296 }
1297 
1298 // Record the shared classpath index and loader type for classes loaded
1299 // by the builtin loaders at dump time.
1300 void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
1301   Arguments::assert_is_dumping_archive();
1302   assert(stream != NULL, &quot;sanity&quot;);
1303 
<span class="line-modified">1304   if (ik-&gt;is_hidden() || ik-&gt;is_unsafe_anonymous()) {</span>
<span class="line-modified">1305     // We do not archive hidden or unsafe anonymous classes.</span>
1306     return;
1307   }
1308 
1309   oop loader = ik-&gt;class_loader();
1310   char* src = (char*)stream-&gt;source();
1311   if (src == NULL) {
1312     if (loader == NULL) {
1313       // JFR classes
1314       ik-&gt;set_shared_classpath_index(0);
1315       ik-&gt;set_shared_class_loader_type(ClassLoader::BOOT_LOADER);
1316     }
1317     return;
1318   }
1319 
1320   assert(has_jrt_entry(), &quot;CDS dumping does not support exploded JDK build&quot;);
1321 
1322   ResourceMark rm(THREAD);
1323   int classpath_index = -1;
1324   PackageEntry* pkg_entry = ik-&gt;package();
1325 
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
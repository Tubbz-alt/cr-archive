<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSFILEPARSER_HPP
 26 #define SHARE_CLASSFILE_CLASSFILEPARSER_HPP
 27 
 28 #include &quot;memory/referenceType.hpp&quot;
 29 #include &quot;oops/annotations.hpp&quot;
 30 #include &quot;oops/constantPool.hpp&quot;
 31 #include &quot;oops/instanceKlass.hpp&quot;
 32 #include &quot;oops/typeArrayOop.hpp&quot;
 33 #include &quot;utilities/accessFlags.hpp&quot;
 34 
 35 class Annotations;
 36 template &lt;typename T&gt;
 37 class Array;
 38 class ClassFileStream;
 39 class ClassLoaderData;


 40 class CompressedLineNumberWriteStream;
 41 class ConstMethod;
 42 class FieldInfo;
 43 template &lt;typename T&gt;
 44 class GrowableArray;
 45 class InstanceKlass;
 46 class RecordComponent;
 47 class Symbol;
 48 class TempNewSymbol;
 49 class FieldLayoutBuilder;
 50 
 51 // Utility to collect and compact oop maps during layout
 52 class OopMapBlocksBuilder : public ResourceObj {
 53  public:
 54   OopMapBlock* _nonstatic_oop_maps;
 55   unsigned int _nonstatic_oop_map_count;
 56   unsigned int _max_nonstatic_oop_maps;
 57 
 58   OopMapBlocksBuilder(unsigned int  max_blocks);
 59   OopMapBlock* last_oop_map() const;
</pre>
<hr />
<pre>
 93   // It is used to control which subsystems (if any)
 94   // will observe the parsing (logging, events, tracing).
 95   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 96   // a &quot;public&quot; parsing attempt.
 97   //
 98   // &quot;INTERNAL&quot; level should be entirely private to the
 99   // caller - this allows for internal reuse of ClassFileParser
100   //
101   enum Publicity {
102     INTERNAL,
103     BROADCAST
104   };
105 
106   enum { LegalClass, LegalField, LegalMethod }; // used to verify unqualified names
107 
108  private:
109   // Potentially unaligned pointer to various 16-bit entries in the class file
110   typedef void unsafe_u2;
111 
112   const ClassFileStream* _stream; // Actual input stream
<span class="line-removed">113   const Symbol* _requested_name;</span>
114   Symbol* _class_name;
115   mutable ClassLoaderData* _loader_data;
116   const InstanceKlass* _unsafe_anonymous_host;
117   GrowableArray&lt;Handle&gt;* _cp_patches; // overrides for CP entries


118   int _num_patched_klasses;
119   int _max_num_patched_klasses;
120   int _orig_cp_size;
121   int _first_patched_klass_resolved_index;
122 
123   // Metadata created before the instance klass is created.  Must be deallocated
124   // if not transferred to the InstanceKlass upon successful class loading
125   // in which case these pointers have been set to NULL.
126   const InstanceKlass* _super_klass;
127   ConstantPool* _cp;
128   Array&lt;u2&gt;* _fields;
129   Array&lt;Method*&gt;* _methods;
130   Array&lt;u2&gt;* _inner_classes;
131   Array&lt;u2&gt;* _nest_members;
132   u2 _nest_host;
133   Array&lt;RecordComponent*&gt;* _record_components;
134   GrowableArray&lt;InstanceKlass*&gt;* _temp_local_interfaces;
135   Array&lt;InstanceKlass*&gt;* _local_interfaces;
136   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
137   Annotations* _combined_annotations;
</pre>
<hr />
<pre>
200   bool _has_contended_fields;
201 
202   bool _has_flattenable_fields;
203   bool _has_nonstatic_fields;
204   bool _is_empty_inline_type;
205   bool _is_naturally_atomic;
206   bool _is_declared_atomic;
207   bool _invalid_inline_super;   // if true, invalid super type for an inline type.
208   bool _invalid_identity_super; // if true, invalid super type for an identity type.
209   bool _implements_identityObject;
210   bool _has_injected_identityObject;
211 
212   // precomputed flags
213   bool _has_finalizer;
214   bool _has_empty_finalizer;
215   bool _has_vanilla_constructor;
216   int _max_bootstrap_specifier_index;  // detects BSS values
217 
218   void parse_stream(const ClassFileStream* const stream, TRAPS);
219 


220   void post_process_parsed_stream(const ClassFileStream* const stream,
221                                   ConstantPool* cp,
222                                   TRAPS);
223 
224   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
225   void fix_unsafe_anonymous_class_name(TRAPS);
226 
<span class="line-modified">227   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);</span>


228   void set_klass(InstanceKlass* instance);
229 
230   void set_class_bad_constant_seen(short bad_constant);
231   short class_bad_constant_seen() { return  _bad_constant_seen; }
232   void set_class_synthetic_flag(bool x)        { _synthetic_flag = x; }
233   void set_class_sourcefile_index(u2 x)        { _sourcefile_index = x; }
234   void set_class_generic_signature_index(u2 x) { _generic_signature_index = x; }
235   void set_class_sde_buffer(const char* x, int len)  { _sde_buffer = x; _sde_length = len; }
236 
237   void create_combined_annotations(TRAPS);
238   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
239   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
240   void clear_class_metadata();
241 
242   // Constant pool parsing
243   void parse_constant_pool_entries(const ClassFileStream* const stream,
244                                    ConstantPool* cp,
245                                    const int length,
246                                    TRAPS);
247 
</pre>
<hr />
<pre>
540                                int runtime_invisible_annotations_length,
541                                const u1* runtime_visible_parameter_annotations,
542                                int runtime_visible_parameter_annotations_length,
543                                const u1* runtime_invisible_parameter_annotations,
544                                int runtime_invisible_parameter_annotations_length,
545                                const u1* runtime_visible_type_annotations,
546                                int runtime_visible_type_annotations_length,
547                                const u1* runtime_invisible_type_annotations,
548                                int runtime_invisible_type_annotations_length,
549                                const u1* annotation_default,
550                                int annotation_default_length,
551                                TRAPS);
552 
553   // lays out fields in class and returns the total oopmap count
554   void layout_fields(ConstantPool* cp,
555                      const FieldAllocationCount* fac,
556                      const ClassAnnotationCollector* parsed_annotations,
557                      FieldLayoutInfo* info,
558                      TRAPS);
559 
<span class="line-modified">560    void update_class_name(Symbol* new_name);</span>
561 
562   // Check if the class file supports inline types
563   bool supports_inline_types() const;
564 
565  public:
566   ClassFileParser(ClassFileStream* stream,
567                   Symbol* name,
568                   ClassLoaderData* loader_data,
<span class="line-modified">569                   Handle protection_domain,</span>
<span class="line-removed">570                   const InstanceKlass* unsafe_anonymous_host,</span>
<span class="line-removed">571                   GrowableArray&lt;Handle&gt;* cp_patches,</span>
572                   Publicity pub_level,
573                   TRAPS);
574 
575   ~ClassFileParser();
576 
<span class="line-modified">577   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);</span>
578 
579   const ClassFileStream* clone_stream() const;
580 
581   void set_klass_to_deallocate(InstanceKlass* klass);
582 
583   int static_field_size() const;
584   int total_oop_map_count() const;
585   jint layout_size() const;
586 
587   int vtable_size() const { return _vtable_size; }
588   int itable_size() const { return _itable_size; }
589 
590   u2 this_class_index() const { return _this_class_index; }
591 
592   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }

593   bool is_interface() const { return _access_flags.is_interface(); }
594   bool is_inline_type() const { return _access_flags.is_inline_type(); }
595   bool is_value_capable_class() const;
596   bool has_flattenable_fields() const { return _has_flattenable_fields; }
597   bool invalid_inline_super() const { return _invalid_inline_super; }
598   void set_invalid_inline_super() { _invalid_inline_super = true; }
599   bool invalid_identity_super() const { return _invalid_identity_super; }
600   void set_invalid_identity_super() { _invalid_identity_super = true; }
601   bool is_invalid_super_for_inline_type();
602 
603   u2 java_fields_count() const { return _java_fields_count; }
604 
605   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
606   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
607   ClassLoaderData* loader_data() const { return _loader_data; }
608   const Symbol* class_name() const { return _class_name; }
609   const InstanceKlass* super_klass() const { return _super_klass; }
610 
611   ReferenceType reference_type() const { return _rt; }
612   AccessFlags access_flags() const { return _access_flags; }
</pre>
</td>
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSFILEPARSER_HPP
 26 #define SHARE_CLASSFILE_CLASSFILEPARSER_HPP
 27 
 28 #include &quot;memory/referenceType.hpp&quot;
 29 #include &quot;oops/annotations.hpp&quot;
 30 #include &quot;oops/constantPool.hpp&quot;
 31 #include &quot;oops/instanceKlass.hpp&quot;
 32 #include &quot;oops/typeArrayOop.hpp&quot;
 33 #include &quot;utilities/accessFlags.hpp&quot;
 34 
 35 class Annotations;
 36 template &lt;typename T&gt;
 37 class Array;
 38 class ClassFileStream;
 39 class ClassLoaderData;
<span class="line-added"> 40 class ClassLoadInfo;</span>
<span class="line-added"> 41 class ClassInstanceInfo;</span>
 42 class CompressedLineNumberWriteStream;
 43 class ConstMethod;
 44 class FieldInfo;
 45 template &lt;typename T&gt;
 46 class GrowableArray;
 47 class InstanceKlass;
 48 class RecordComponent;
 49 class Symbol;
 50 class TempNewSymbol;
 51 class FieldLayoutBuilder;
 52 
 53 // Utility to collect and compact oop maps during layout
 54 class OopMapBlocksBuilder : public ResourceObj {
 55  public:
 56   OopMapBlock* _nonstatic_oop_maps;
 57   unsigned int _nonstatic_oop_map_count;
 58   unsigned int _max_nonstatic_oop_maps;
 59 
 60   OopMapBlocksBuilder(unsigned int  max_blocks);
 61   OopMapBlock* last_oop_map() const;
</pre>
<hr />
<pre>
 95   // It is used to control which subsystems (if any)
 96   // will observe the parsing (logging, events, tracing).
 97   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 98   // a &quot;public&quot; parsing attempt.
 99   //
100   // &quot;INTERNAL&quot; level should be entirely private to the
101   // caller - this allows for internal reuse of ClassFileParser
102   //
103   enum Publicity {
104     INTERNAL,
105     BROADCAST
106   };
107 
108   enum { LegalClass, LegalField, LegalMethod }; // used to verify unqualified names
109 
110  private:
111   // Potentially unaligned pointer to various 16-bit entries in the class file
112   typedef void unsafe_u2;
113 
114   const ClassFileStream* _stream; // Actual input stream

115   Symbol* _class_name;
116   mutable ClassLoaderData* _loader_data;
117   const InstanceKlass* _unsafe_anonymous_host;
118   GrowableArray&lt;Handle&gt;* _cp_patches; // overrides for CP entries
<span class="line-added">119   const bool _is_hidden;</span>
<span class="line-added">120   const bool _can_access_vm_annotations;</span>
121   int _num_patched_klasses;
122   int _max_num_patched_klasses;
123   int _orig_cp_size;
124   int _first_patched_klass_resolved_index;
125 
126   // Metadata created before the instance klass is created.  Must be deallocated
127   // if not transferred to the InstanceKlass upon successful class loading
128   // in which case these pointers have been set to NULL.
129   const InstanceKlass* _super_klass;
130   ConstantPool* _cp;
131   Array&lt;u2&gt;* _fields;
132   Array&lt;Method*&gt;* _methods;
133   Array&lt;u2&gt;* _inner_classes;
134   Array&lt;u2&gt;* _nest_members;
135   u2 _nest_host;
136   Array&lt;RecordComponent*&gt;* _record_components;
137   GrowableArray&lt;InstanceKlass*&gt;* _temp_local_interfaces;
138   Array&lt;InstanceKlass*&gt;* _local_interfaces;
139   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
140   Annotations* _combined_annotations;
</pre>
<hr />
<pre>
203   bool _has_contended_fields;
204 
205   bool _has_flattenable_fields;
206   bool _has_nonstatic_fields;
207   bool _is_empty_inline_type;
208   bool _is_naturally_atomic;
209   bool _is_declared_atomic;
210   bool _invalid_inline_super;   // if true, invalid super type for an inline type.
211   bool _invalid_identity_super; // if true, invalid super type for an identity type.
212   bool _implements_identityObject;
213   bool _has_injected_identityObject;
214 
215   // precomputed flags
216   bool _has_finalizer;
217   bool _has_empty_finalizer;
218   bool _has_vanilla_constructor;
219   int _max_bootstrap_specifier_index;  // detects BSS values
220 
221   void parse_stream(const ClassFileStream* const stream, TRAPS);
222 
<span class="line-added">223   void mangle_hidden_class_name(InstanceKlass* const ik);</span>
<span class="line-added">224 </span>
225   void post_process_parsed_stream(const ClassFileStream* const stream,
226                                   ConstantPool* cp,
227                                   TRAPS);
228 
229   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
230   void fix_unsafe_anonymous_class_name(TRAPS);
231 
<span class="line-modified">232   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH,</span>
<span class="line-added">233                            const ClassInstanceInfo&amp; cl_inst_info, TRAPS);</span>
<span class="line-added">234 </span>
235   void set_klass(InstanceKlass* instance);
236 
237   void set_class_bad_constant_seen(short bad_constant);
238   short class_bad_constant_seen() { return  _bad_constant_seen; }
239   void set_class_synthetic_flag(bool x)        { _synthetic_flag = x; }
240   void set_class_sourcefile_index(u2 x)        { _sourcefile_index = x; }
241   void set_class_generic_signature_index(u2 x) { _generic_signature_index = x; }
242   void set_class_sde_buffer(const char* x, int len)  { _sde_buffer = x; _sde_length = len; }
243 
244   void create_combined_annotations(TRAPS);
245   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
246   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
247   void clear_class_metadata();
248 
249   // Constant pool parsing
250   void parse_constant_pool_entries(const ClassFileStream* const stream,
251                                    ConstantPool* cp,
252                                    const int length,
253                                    TRAPS);
254 
</pre>
<hr />
<pre>
547                                int runtime_invisible_annotations_length,
548                                const u1* runtime_visible_parameter_annotations,
549                                int runtime_visible_parameter_annotations_length,
550                                const u1* runtime_invisible_parameter_annotations,
551                                int runtime_invisible_parameter_annotations_length,
552                                const u1* runtime_visible_type_annotations,
553                                int runtime_visible_type_annotations_length,
554                                const u1* runtime_invisible_type_annotations,
555                                int runtime_invisible_type_annotations_length,
556                                const u1* annotation_default,
557                                int annotation_default_length,
558                                TRAPS);
559 
560   // lays out fields in class and returns the total oopmap count
561   void layout_fields(ConstantPool* cp,
562                      const FieldAllocationCount* fac,
563                      const ClassAnnotationCollector* parsed_annotations,
564                      FieldLayoutInfo* info,
565                      TRAPS);
566 
<span class="line-modified">567   void update_class_name(Symbol* new_name);</span>
568 
569   // Check if the class file supports inline types
570   bool supports_inline_types() const;
571 
572  public:
573   ClassFileParser(ClassFileStream* stream,
574                   Symbol* name,
575                   ClassLoaderData* loader_data,
<span class="line-modified">576                   const ClassLoadInfo* cl_info,</span>


577                   Publicity pub_level,
578                   TRAPS);
579 
580   ~ClassFileParser();
581 
<span class="line-modified">582   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, const ClassInstanceInfo&amp; cl_inst_info, TRAPS);</span>
583 
584   const ClassFileStream* clone_stream() const;
585 
586   void set_klass_to_deallocate(InstanceKlass* klass);
587 
588   int static_field_size() const;
589   int total_oop_map_count() const;
590   jint layout_size() const;
591 
592   int vtable_size() const { return _vtable_size; }
593   int itable_size() const { return _itable_size; }
594 
595   u2 this_class_index() const { return _this_class_index; }
596 
597   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
<span class="line-added">598   bool is_hidden() const { return _is_hidden; }</span>
599   bool is_interface() const { return _access_flags.is_interface(); }
600   bool is_inline_type() const { return _access_flags.is_inline_type(); }
601   bool is_value_capable_class() const;
602   bool has_flattenable_fields() const { return _has_flattenable_fields; }
603   bool invalid_inline_super() const { return _invalid_inline_super; }
604   void set_invalid_inline_super() { _invalid_inline_super = true; }
605   bool invalid_identity_super() const { return _invalid_identity_super; }
606   void set_invalid_identity_super() { _invalid_identity_super = true; }
607   bool is_invalid_super_for_inline_type();
608 
609   u2 java_fields_count() const { return _java_fields_count; }
610 
611   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
612   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
613   ClassLoaderData* loader_data() const { return _loader_data; }
614   const Symbol* class_name() const { return _class_name; }
615   const InstanceKlass* super_klass() const { return _super_klass; }
616 
617   ReferenceType reference_type() const { return _rt; }
618   AccessFlags access_flags() const { return _access_flags; }
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
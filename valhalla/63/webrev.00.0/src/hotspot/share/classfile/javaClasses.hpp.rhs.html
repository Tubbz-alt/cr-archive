<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.
  36 //
  37 // All dependencies on layout of actual Java classes should be kept here.
  38 // If the layout of any of the classes above changes the offsets must be adjusted.
  39 //
  40 // For most classes we hardwire the offsets for performance reasons. In certain
  41 // cases (e.g. java.security.AccessControlContext) we compute the offsets at
  42 // startup since the layout here differs between JDK1.2 and JDK1.3.
  43 //
  44 // Note that fields (static and non-static) are arranged with oops before non-oops
  45 // on a per class basis. The offsets below have to reflect this ordering.
  46 //
  47 // When editing the layouts please update the check_offset verification code
  48 // correspondingly. The names in the enums must be identical to the actual field
  49 // names in order for the verification code to work.
  50 
  51 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  52   f(java_lang_Class) \
  53   f(java_lang_String) \
  54   //end
  55 
  56 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  57   f(java_lang_System) \
  58   f(java_lang_ClassLoader) \
  59   f(java_lang_Throwable) \
  60   f(java_lang_Thread) \
  61   f(java_lang_ThreadGroup) \
  62   f(java_lang_AssertionStatusDirectives) \
  63   f(java_lang_ref_SoftReference) \
  64   f(java_lang_invoke_MethodHandle) \
  65   f(java_lang_invoke_DirectMethodHandle) \
  66   f(java_lang_invoke_MemberName) \
  67   f(java_lang_invoke_ResolvedMethodName) \
  68   f(java_lang_invoke_LambdaForm) \
  69   f(java_lang_invoke_MethodType) \
  70   f(java_lang_invoke_CallSite) \
  71   f(java_lang_invoke_ConstantCallSite) \
  72   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  73   f(java_security_AccessControlContext) \
  74   f(java_lang_reflect_AccessibleObject) \
  75   f(java_lang_reflect_Method) \
  76   f(java_lang_reflect_Constructor) \
  77   f(java_lang_reflect_Field) \
  78   f(java_lang_reflect_RecordComponent) \
  79   f(java_nio_Buffer) \
  80   f(reflect_ConstantPool) \
  81   f(reflect_UnsafeStaticFieldAccessorImpl) \
  82   f(java_lang_reflect_Parameter) \
  83   f(java_lang_Module) \
  84   f(java_lang_StackTraceElement) \
  85   f(java_lang_StackFrameInfo) \
  86   f(java_lang_LiveStackFrameInfo) \
  87   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  88   f(jdk_internal_misc_UnsafeConstants) \
  89   f(jdk_internal_vm_jni_SubElementSelector) \
  90   //end
  91 
  92 #define BASIC_JAVA_CLASSES_DO(f) \
  93         BASIC_JAVA_CLASSES_DO_PART1(f) \
  94         BASIC_JAVA_CLASSES_DO_PART2(f)
  95 
  96 // Interface to java.lang.Object objects
  97 
  98 class java_lang_Object : AllStatic {
  99  public:
 100   static void register_natives(TRAPS);
 101 };
 102 
 103 // Interface to java.lang.String objects
 104 
 105 class java_lang_String : AllStatic {
 106  private:
 107   static int value_offset;
 108   static int hash_offset;
 109   static int hashIsZero_offset;
 110   static int coder_offset;
 111 
 112   static bool initialized;
 113 
 114   static Handle basic_create(int length, bool byte_arr, TRAPS);
 115 
 116   static inline void set_coder(oop string, jbyte coder);
 117 
 118  public:
 119 
 120   // Coders
 121   enum Coder {
 122     CODER_LATIN1 =  0,
 123     CODER_UTF16  =  1
 124   };
 125 
 126   static void compute_offsets();
 127   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 128 
 129   // Instance creation
 130   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 131   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 132   static Handle create_from_str(const char* utf8_str, TRAPS);
 133   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 134   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 135   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 136   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 137 
 138   static void set_compact_strings(bool value);
 139 
 140   static int value_offset_in_bytes()  {
 141     assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 142     return value_offset;
 143   }
 144   static int hash_offset_in_bytes()   {
 145     assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 146     return hash_offset;
 147   }
 148   static int hashIsZero_offset_in_bytes()   {
 149     assert(initialized &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 150     return hashIsZero_offset;
 151   }
 152   static int coder_offset_in_bytes()   {
 153     assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 154     return coder_offset;
 155   }
 156 
 157   static inline void set_value_raw(oop string, typeArrayOop buffer);
 158   static inline void set_value(oop string, typeArrayOop buffer);
 159 
 160   // Accessors
 161   static inline typeArrayOop value(oop java_string);
 162   static inline typeArrayOop value_no_keepalive(oop java_string);
 163   static inline bool hash_is_set(oop string);
 164   static inline bool is_latin1(oop java_string);
 165   static inline int length(oop java_string);
 166   static inline int length(oop java_string, typeArrayOop string_value);
 167   static int utf8_length(oop java_string);
 168   static int utf8_length(oop java_string, typeArrayOop string_value);
 169 
 170   // String converters
 171   static char*  as_utf8_string(oop java_string);
<a name="2" id="anc2"></a><span class="line-added"> 172   static char*  as_utf8_string(oop java_string, int&amp; length);</span>
<span class="line-added"> 173   static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; length);</span>
 174   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 175   static char*  as_utf8_string(oop java_string, int start, int len);
 176   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 177   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 178   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 179   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 180   // produce an ascii string with all other values quoted using \u####
 181   static char*  as_quoted_ascii(oop java_string);
 182 
 183   // Compute the hash value for a java.lang.String object which would
 184   // contain the characters passed in.
 185   //
 186   // As the hash value used by the String object itself, in
 187   // String.hashCode().  This value is normally calculated in Java code
 188   // in the String.hashCode method(), but is precomputed for String
 189   // objects in the shared archive file.
 190   // hash P(31) from Kernighan &amp; Ritchie
 191   //
 192   // For this reason, THIS ALGORITHM MUST MATCH String.hashCode().
 193   static unsigned int hash_code(const jchar* s, int len) {
 194     unsigned int h = 0;
 195     while (len-- &gt; 0) {
 196       h = 31*h + (unsigned int) *s;
 197       s++;
 198     }
 199     return h;
 200   }
 201 
 202   static unsigned int hash_code(const jbyte* s, int len) {
 203     unsigned int h = 0;
 204     while (len-- &gt; 0) {
 205       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 206       s++;
 207     }
 208     return h;
 209   }
 210 
 211   static unsigned int hash_code(oop java_string);
 212 
 213   static bool equals(oop java_string, const jchar* chars, int len);
 214   static bool equals(oop str1, oop str2);
 215   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 216 
 217   // Conversion between &#39;.&#39; and &#39;/&#39; formats
 218   static Handle externalize_classname(Handle java_string, TRAPS) {
 219     return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);
 220   }
 221 
 222   // Conversion
 223   static Symbol* as_symbol(oop java_string);
 224   static Symbol* as_symbol_or_null(oop java_string);
 225 
 226   // Testers
 227   static bool is_instance(oop obj);
 228   static inline bool is_instance_inlined(oop obj);
 229 
 230   // Debugging
 231   static void print(oop java_string, outputStream* st);
 232   friend class JavaClasses;
 233   friend class StringTable;
 234 };
 235 
 236 
 237 // Interface to java.lang.Class objects
 238 
 239 #define CLASS_INJECTED_FIELDS(macro)                                       \
 240   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 241   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 242   macro(java_lang_Class, oop_size,               int_signature,     false) \
 243   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 244   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 245   macro(java_lang_Class, signers,                object_signature,  false) \
 246   macro(java_lang_Class, source_file,            object_signature,  false) \
 247 
 248 class java_lang_Class : AllStatic {
 249   friend class VMStructs;
 250   friend class JVMCIVMStructs;
 251 
 252  private:
 253   // The fake offsets are added by the class loader when java.lang.Class is loaded
 254 
 255   static int _klass_offset;
 256   static int _array_klass_offset;
 257 
 258   static int _oop_size_offset;
 259   static int _static_oop_field_count_offset;
 260 
 261   static int _protection_domain_offset;
 262   static int _init_lock_offset;
 263   static int _signers_offset;
 264   static int _class_loader_offset;
 265   static int _module_offset;
 266   static int _component_mirror_offset;
 267   static int _name_offset;
 268   static int _source_file_offset;
 269   static int _val_type_mirror_offset;
 270   static int _ref_type_mirror_offset;
<a name="3" id="anc3"></a><span class="line-added"> 271   static int _classData_offset;</span>
 272 
 273   static bool offsets_computed;
 274   static int classRedefinedCount_offset;
 275 
 276   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 277   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 278 
 279   static void set_init_lock(oop java_class, oop init_lock);
 280   static void set_protection_domain(oop java_class, oop protection_domain);
 281   static void set_class_loader(oop java_class, oop class_loader);
 282   static void set_component_mirror(oop java_class, oop comp_mirror);
<a name="4" id="anc4"></a><span class="line-modified"> 283   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,</span>
<span class="line-added"> 284                                        Handle classData, TRAPS);</span>
 285   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 286  public:
 287   static void allocate_fixup_lists();
 288   static void compute_offsets();
 289 
 290   // Instance creation
 291   static void create_mirror(Klass* k, Handle class_loader, Handle module,
<a name="5" id="anc5"></a><span class="line-modified"> 292                             Handle protection_domain, Handle classData, TRAPS);</span>
 293   static void fixup_mirror(Klass* k, TRAPS);
 294   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
 295   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 296   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 297 
 298   // Archiving
 299   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 300   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 301   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 302   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 303                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 304   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 305                                       Handle protection_domain,
 306                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 307 
 308   static void fixup_module_field(Klass* k, Handle module);
 309 
 310   // Conversion
 311   static Klass* as_Klass(oop java_class);
 312   static Klass* as_Klass_raw(oop java_class);
 313   static void set_klass(oop java_class, Klass* klass);
 314   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 315   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 316   static void print_signature(oop java_class, outputStream *st);
 317   static const char* as_external_name(oop java_class);
 318   // Testing
 319   static bool is_instance(oop obj);
 320 
 321   static bool is_primitive(oop java_class);
 322   static BasicType primitive_type(oop java_class);
 323   static oop primitive_mirror(BasicType t);
 324   // JVM_NewArray support
 325   static Klass* array_klass_acquire(oop java_class);
 326   static void release_set_array_klass(oop java_class, Klass* klass);
 327   // compiler support for class operations
 328   static int klass_offset_in_bytes()                { return _klass_offset; }
 329   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }
 330   static int component_mirror_offset_in_bytes()     { return _component_mirror_offset; }
 331   // Support for classRedefinedCount field
 332   static int classRedefinedCount(oop the_class_mirror);
 333   static void set_classRedefinedCount(oop the_class_mirror, int value);
 334 
 335   // Support for embedded per-class oops
 336   static oop  protection_domain(oop java_class);
 337   static oop  init_lock(oop java_class);
 338   static oop  component_mirror(oop java_class);
 339   static objArrayOop  signers(oop java_class);
 340   static void set_signers(oop java_class, objArrayOop signers);
<a name="6" id="anc6"></a><span class="line-added"> 341   static oop  class_data(oop java_class);</span>
<span class="line-added"> 342   static void set_class_data(oop java_class, oop classData);</span>
 343 
 344   static oop class_loader(oop java_class);
 345   static void set_module(oop java_class, oop module);
 346   static oop module(oop java_class);
 347 
 348   static void set_ref_type_mirror(oop java_class, oop mirror);
 349   static oop ref_type_mirror(oop java_class);
 350 
 351   static void set_val_type_mirror(oop java_class, oop mirror);
 352   static oop val_type_mirror(oop java_class);
 353 
 354   static oop name(Handle java_class, TRAPS);
 355 
 356   static oop source_file(oop java_class);
 357   static void set_source_file(oop java_class, oop source_file);
 358 
 359   static int oop_size(oop java_class);
 360   static int oop_size_raw(oop java_class);
 361   static void set_oop_size(HeapWord* java_class, int size);
 362   static int static_oop_field_count(oop java_class);
 363   static int static_oop_field_count_raw(oop java_class);
 364   static void set_static_oop_field_count(oop java_class, int size);
 365 
 366   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 367     return _fixup_mirror_list;
 368   }
 369   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 370     _fixup_mirror_list = v;
 371   }
 372 
 373   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 374     return _fixup_module_field_list;
 375   }
 376   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 377     _fixup_module_field_list = v;
 378   }
 379 
 380   // Debugging
 381   friend class JavaClasses;
 382   friend class InstanceKlass;   // verification code accesses offsets
 383   friend class ClassFileParser; // access to number_of_fake_fields
 384 };
 385 
 386 // Interface to java.lang.Thread objects
 387 
 388 class java_lang_Thread : AllStatic {
 389  private:
 390   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 391   // so we compute the offsets at startup rather than hard-wiring them.
 392   static int _name_offset;
 393   static int _group_offset;
 394   static int _contextClassLoader_offset;
 395   static int _inheritedAccessControlContext_offset;
 396   static int _priority_offset;
 397   static int _eetop_offset;
 398   static int _interrupted_offset;
 399   static int _daemon_offset;
 400   static int _stillborn_offset;
 401   static int _stackSize_offset;
 402   static int _tid_offset;
 403   static int _thread_status_offset;
 404   static int _park_blocker_offset;
 405 
 406   static void compute_offsets();
 407 
 408  public:
 409   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 410 
 411   // Instance creation
 412   static oop create();
 413   // Returns the JavaThread associated with the thread obj
 414   static JavaThread* thread(oop java_thread);
 415   // Set JavaThread for instance
 416   static void set_thread(oop java_thread, JavaThread* thread);
 417   // Interrupted status
 418   static bool interrupted(oop java_thread);
 419   static void set_interrupted(oop java_thread, bool val);
 420   // Name
 421   static oop name(oop java_thread);
 422   static void set_name(oop java_thread, oop name);
 423   // Priority
 424   static ThreadPriority priority(oop java_thread);
 425   static void set_priority(oop java_thread, ThreadPriority priority);
 426   // Thread group
 427   static oop  threadGroup(oop java_thread);
 428   // Stillborn
 429   static bool is_stillborn(oop java_thread);
 430   static void set_stillborn(oop java_thread);
 431   // Alive (NOTE: this is not really a field, but provides the correct
 432   // definition without doing a Java call)
 433   static bool is_alive(oop java_thread);
 434   // Daemon
 435   static bool is_daemon(oop java_thread);
 436   static void set_daemon(oop java_thread);
 437   // Context ClassLoader
 438   static oop context_class_loader(oop java_thread);
 439   // Control context
 440   static oop inherited_access_control_context(oop java_thread);
 441   // Stack size hint
 442   static jlong stackSize(oop java_thread);
 443   // Thread ID
 444   static jlong thread_id(oop java_thread);
 445 
 446   // Blocker object responsible for thread parking
 447   static oop park_blocker(oop java_thread);
 448 
 449   // Java Thread Status for JVMTI and M&amp;M use.
 450   // This thread status info is saved in threadStatus field of
 451   // java.lang.Thread java class.
 452   enum ThreadStatus {
 453     NEW                      = 0,
 454     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 455                                JVMTI_THREAD_STATE_RUNNABLE,
 456     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 457                                JVMTI_THREAD_STATE_WAITING +
 458                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 459                                JVMTI_THREAD_STATE_SLEEPING,
 460     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 461                                JVMTI_THREAD_STATE_WAITING +
 462                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 463                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 464     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 465                                JVMTI_THREAD_STATE_WAITING +
 466                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 467                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 468     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
 469                                JVMTI_THREAD_STATE_WAITING +
 470                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 471                                JVMTI_THREAD_STATE_PARKED,
 472     PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
 473                                JVMTI_THREAD_STATE_WAITING +
 474                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 475                                JVMTI_THREAD_STATE_PARKED,
 476     BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
 477                                JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
 478     TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
 479   };
 480   // Write thread status info to threadStatus field of java.lang.Thread.
 481   static void set_thread_status(oop java_thread_oop, ThreadStatus status);
 482   // Read thread status info from threadStatus field of java.lang.Thread.
 483   static ThreadStatus get_thread_status(oop java_thread_oop);
 484 
 485   static const char*  thread_status_name(oop java_thread_oop);
 486 
 487   // Debugging
 488   friend class JavaClasses;
 489 };
 490 
 491 // Interface to java.lang.ThreadGroup objects
 492 
 493 class java_lang_ThreadGroup : AllStatic {
 494  private:
 495   static int _parent_offset;
 496   static int _name_offset;
 497   static int _threads_offset;
 498   static int _groups_offset;
 499   static int _maxPriority_offset;
 500   static int _destroyed_offset;
 501   static int _daemon_offset;
 502   static int _nthreads_offset;
 503   static int _ngroups_offset;
 504 
 505   static void compute_offsets();
 506 
 507  public:
 508   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 509 
 510   // parent ThreadGroup
 511   static oop  parent(oop java_thread_group);
 512   // name
 513   static const char* name(oop java_thread_group);
 514   // (&quot;name as oop&quot; accessor is not necessary)
 515   // Number of threads in group
 516   static int nthreads(oop java_thread_group);
 517   // threads
 518   static objArrayOop threads(oop java_thread_group);
 519   // Number of threads in group
 520   static int ngroups(oop java_thread_group);
 521   // groups
 522   static objArrayOop groups(oop java_thread_group);
 523   // maxPriority in group
 524   static ThreadPriority maxPriority(oop java_thread_group);
 525   // Destroyed
 526   static bool is_destroyed(oop java_thread_group);
 527   // Daemon
 528   static bool is_daemon(oop java_thread_group);
 529   // Debugging
 530   friend class JavaClasses;
 531 };
 532 
 533 
 534 
 535 // Interface to java.lang.Throwable objects
 536 
 537 class java_lang_Throwable: AllStatic {
 538   friend class BacktraceBuilder;
 539   friend class BacktraceIterator;
 540 
 541  private:
 542   // Offsets
 543   enum {
 544     hc_backtrace_offset     =  0,
 545     hc_detailMessage_offset =  1,
 546     hc_cause_offset         =  2,  // New since 1.4
 547     hc_stackTrace_offset    =  3   // New since 1.4
 548   };
 549   // Trace constants
 550   enum {
 551     trace_methods_offset = 0,
 552     trace_bcis_offset    = 1,
 553     trace_mirrors_offset = 2,
 554     trace_names_offset   = 3,
 555     trace_next_offset    = 4,
 556     trace_hidden_offset  = 5,
 557     trace_size           = 6,
 558     trace_chunk_size     = 32
 559   };
 560 
 561   static int backtrace_offset;
 562   static int detailMessage_offset;
 563   static int stackTrace_offset;
 564   static int depth_offset;
 565   static int static_unassigned_stacktrace_offset;
 566 
 567   // StackTrace (programmatic access, new since 1.4)
 568   static void clear_stacktrace(oop throwable);
 569   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 570   static void set_stacktrace(oop throwable, oop st_element_array);
 571   static oop unassigned_stacktrace();
 572 
 573  public:
 574   // Backtrace
 575   static oop backtrace(oop throwable);
 576   static void set_backtrace(oop throwable, oop value);
 577   static int depth(oop throwable);
 578   static void set_depth(oop throwable, int value);
 579   // Needed by JVMTI to filter out this internal field.
 580   static int get_backtrace_offset() { return backtrace_offset;}
 581   static int get_detailMessage_offset() { return detailMessage_offset;}
 582   // Message
 583   static oop message(oop throwable);
 584   static void set_message(oop throwable, oop value);
 585   static Symbol* detail_message(oop throwable);
 586   static void print_stack_element(outputStream *st, Method* method, int bci);
 587   static void print_stack_usage(Handle stream);
 588 
 589   static void compute_offsets();
 590   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 591 
 592   // Allocate space for backtrace (created but stack trace not filled in)
 593   static void allocate_backtrace(Handle throwable, TRAPS);
 594   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 595   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 596   // Fill in current stack trace, can cause GC
 597   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 598   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 599   // Programmatic access to stack trace
 600   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 601   // Printing
 602   static void print(oop throwable, outputStream* st);
 603   static void print_stack_trace(Handle throwable, outputStream* st);
 604   static void java_printStackTrace(Handle throwable, TRAPS);
 605   // Debugging
 606   friend class JavaClasses;
 607   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 608   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 609 };
 610 
 611 
 612 // Interface to java.lang.reflect.AccessibleObject objects
 613 
 614 class java_lang_reflect_AccessibleObject: AllStatic {
 615  private:
 616   // Note that to reduce dependencies on the JDK we compute these
 617   // offsets at run-time.
 618   static int override_offset;
 619 
 620   static void compute_offsets();
 621 
 622  public:
 623   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 624 
 625   // Accessors
 626   static jboolean override(oop reflect);
 627   static void set_override(oop reflect, jboolean value);
 628 
 629   // Debugging
 630   friend class JavaClasses;
 631 };
 632 
 633 
 634 // Interface to java.lang.reflect.Method objects
 635 
 636 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 637  private:
 638   // Note that to reduce dependencies on the JDK we compute these
 639   // offsets at run-time.
 640   static int clazz_offset;
 641   static int name_offset;
 642   static int returnType_offset;
 643   static int parameterTypes_offset;
 644   static int exceptionTypes_offset;
 645   static int slot_offset;
 646   static int modifiers_offset;
 647   static int signature_offset;
 648   static int annotations_offset;
 649   static int parameter_annotations_offset;
 650   static int annotation_default_offset;
 651 
 652   static void compute_offsets();
 653  public:
 654   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 655 
 656   // Allocation
 657   static Handle create(TRAPS);
 658 
 659   // Accessors
 660   static oop clazz(oop reflect);
 661   static void set_clazz(oop reflect, oop value);
 662 
 663   static void set_name(oop method, oop value);
 664 
 665   static oop return_type(oop method);
 666   static void set_return_type(oop method, oop value);
 667 
 668   static oop parameter_types(oop method);
 669   static void set_parameter_types(oop method, oop value);
 670 
 671   static int slot(oop reflect);
 672   static void set_slot(oop reflect, int value);
 673 
 674   static void set_exception_types(oop method, oop value);
 675   static void set_modifiers(oop method, int value);
 676   static void set_signature(oop method, oop value);
 677   static void set_annotations(oop method, oop value);
 678   static void set_parameter_annotations(oop method, oop value);
 679   static void set_annotation_default(oop method, oop value);
 680 
 681   // Debugging
 682   friend class JavaClasses;
 683 };
 684 
 685 
 686 // Interface to java.lang.reflect.Constructor objects
 687 
 688 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 689  private:
 690   // Note that to reduce dependencies on the JDK we compute these
 691   // offsets at run-time.
 692   static int clazz_offset;
 693   static int parameterTypes_offset;
 694   static int exceptionTypes_offset;
 695   static int slot_offset;
 696   static int modifiers_offset;
 697   static int signature_offset;
 698   static int annotations_offset;
 699   static int parameter_annotations_offset;
 700 
 701   static void compute_offsets();
 702  public:
 703   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 704 
 705   // Allocation
 706   static Handle create(TRAPS);
 707 
 708   // Accessors
 709   static oop clazz(oop reflect);
 710   static void set_clazz(oop reflect, oop value);
 711 
 712   static oop parameter_types(oop constructor);
 713   static void set_parameter_types(oop constructor, oop value);
 714 
 715   static int slot(oop reflect);
 716   static void set_slot(oop reflect, int value);
 717 
 718   static void set_exception_types(oop constructor, oop value);
 719   static void set_modifiers(oop constructor, int value);
 720   static void set_signature(oop constructor, oop value);
 721   static void set_annotations(oop constructor, oop value);
 722   static void set_parameter_annotations(oop method, oop value);
 723 
 724   // Debugging
 725   friend class JavaClasses;
 726 };
 727 
 728 
 729 // Interface to java.lang.reflect.Field objects
 730 
 731 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 732  private:
 733   // Note that to reduce dependencies on the JDK we compute these
 734   // offsets at run-time.
 735   static int clazz_offset;
 736   static int name_offset;
 737   static int type_offset;
 738   static int slot_offset;
 739   static int modifiers_offset;
 740   static int signature_offset;
 741   static int annotations_offset;
 742 
 743   static void compute_offsets();
 744 
 745  public:
 746   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 747 
 748   // Allocation
 749   static Handle create(TRAPS);
 750 
 751   // Accessors
 752   static oop clazz(oop reflect);
 753   static void set_clazz(oop reflect, oop value);
 754 
 755   static oop name(oop field);
 756   static void set_name(oop field, oop value);
 757 
 758   static oop type(oop field);
 759   static void set_type(oop field, oop value);
 760 
 761   static int slot(oop reflect);
 762   static void set_slot(oop reflect, int value);
 763 
 764   static int modifiers(oop field);
 765   static void set_modifiers(oop field, int value);
 766 
 767   static void set_signature(oop constructor, oop value);
 768   static void set_annotations(oop constructor, oop value);
 769   static void set_parameter_annotations(oop method, oop value);
 770   static void set_annotation_default(oop method, oop value);
 771 
 772   // Debugging
 773   friend class JavaClasses;
 774 };
 775 
 776 class java_lang_reflect_Parameter {
 777  private:
 778   // Note that to reduce dependencies on the JDK we compute these
 779   // offsets at run-time.
 780   static int name_offset;
 781   static int modifiers_offset;
 782   static int index_offset;
 783   static int executable_offset;
 784 
 785   static void compute_offsets();
 786 
 787  public:
 788   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 789 
 790   // Allocation
 791   static Handle create(TRAPS);
 792 
 793   // Accessors
 794   static oop name(oop field);
 795   static void set_name(oop field, oop value);
 796 
 797   static int index(oop reflect);
 798   static void set_index(oop reflect, int value);
 799 
 800   static int modifiers(oop reflect);
 801   static void set_modifiers(oop reflect, int value);
 802 
 803   static oop executable(oop constructor);
 804   static void set_executable(oop constructor, oop value);
 805 
 806   friend class JavaClasses;
 807 };
 808 
 809 #define MODULE_INJECTED_FIELDS(macro)                            \
 810   macro(java_lang_Module, module_entry, intptr_signature, false)
 811 
 812 class java_lang_Module {
 813   private:
 814     static int loader_offset;
 815     static int name_offset;
 816     static int _module_entry_offset;
 817     static void compute_offsets();
 818 
 819   public:
 820     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 821 
 822     // Allocation
 823     static Handle create(Handle loader, Handle module_name, TRAPS);
 824 
 825     // Testers
 826     static bool is_instance(oop obj);
 827 
 828     // Accessors
 829     static oop loader(oop module);
 830     static void set_loader(oop module, oop value);
 831 
 832     static oop name(oop module);
 833     static void set_name(oop module, oop value);
 834 
 835     static ModuleEntry* module_entry(oop module);
 836     static void set_module_entry(oop module, ModuleEntry* module_entry);
 837 
 838   friend class JavaClasses;
 839 };
 840 
 841 // Interface to jdk.internal.reflect.ConstantPool objects
 842 class reflect_ConstantPool {
 843  private:
 844   // Note that to reduce dependencies on the JDK we compute these
 845   // offsets at run-time.
 846   static int _oop_offset;
 847 
 848   static void compute_offsets();
 849 
 850  public:
 851   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 852 
 853   // Allocation
 854   static Handle create(TRAPS);
 855 
 856   // Accessors
 857   static void set_cp(oop reflect, ConstantPool* value);
 858   static int oop_offset() {
 859     return _oop_offset;
 860   }
 861 
 862   static ConstantPool* get_cp(oop reflect);
 863 
 864   // Debugging
 865   friend class JavaClasses;
 866 };
 867 
 868 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 869 class reflect_UnsafeStaticFieldAccessorImpl {
 870  private:
 871   static int _base_offset;
 872   static void compute_offsets();
 873 
 874  public:
 875   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 876 
 877   static int base_offset() {
 878     return _base_offset;
 879   }
 880 
 881   // Debugging
 882   friend class JavaClasses;
 883 };
 884 
 885 // Interface to java.lang primitive type boxing objects:
 886 //  - java.lang.Boolean
 887 //  - java.lang.Character
 888 //  - java.lang.Float
 889 //  - java.lang.Double
 890 //  - java.lang.Byte
 891 //  - java.lang.Short
 892 //  - java.lang.Integer
 893 //  - java.lang.Long
 894 
 895 // This could be separated out into 8 individual classes.
 896 
 897 class java_lang_boxing_object: AllStatic {
 898  private:
 899   enum {
 900    hc_value_offset = 0
 901   };
 902   static int value_offset;
 903   static int long_value_offset;
 904 
 905   static oop initialize_and_allocate(BasicType type, TRAPS);
 906  public:
 907   // Allocation. Returns a boxed value, or NULL for invalid type.
 908   static oop create(BasicType type, jvalue* value, TRAPS);
 909   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 910   static BasicType get_value(oop box, jvalue* value);
 911   static BasicType set_value(oop box, jvalue* value);
 912   static BasicType basic_type(oop box);
 913   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 914   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 915   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 916   static void print(BasicType type, jvalue* value, outputStream* st);
 917 
 918   static int value_offset_in_bytes(BasicType type) {
 919     return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :
 920                                                     value_offset;
 921   }
 922 
 923   // Debugging
 924   friend class JavaClasses;
 925 };
 926 
 927 
 928 
 929 // Interface to java.lang.ref.Reference objects
 930 
 931 class java_lang_ref_Reference: AllStatic {
 932  public:
 933   enum {
 934    hc_referent_offset   = 0,
 935    hc_queue_offset      = 1,
 936    hc_next_offset       = 2,
 937    hc_discovered_offset = 3  // Is not last, see SoftRefs.
 938   };
 939 
 940   static int referent_offset;
 941   static int queue_offset;
 942   static int next_offset;
 943   static int discovered_offset;
 944 
 945   // Accessors
 946   static inline oop referent(oop ref);
 947   static inline void set_referent(oop ref, oop value);
 948   static inline void set_referent_raw(oop ref, oop value);
 949   static inline HeapWord* referent_addr_raw(oop ref);
 950   static inline oop next(oop ref);
 951   static inline void set_next(oop ref, oop value);
 952   static inline void set_next_raw(oop ref, oop value);
 953   static inline HeapWord* next_addr_raw(oop ref);
 954   static inline oop discovered(oop ref);
 955   static inline void set_discovered(oop ref, oop value);
 956   static inline void set_discovered_raw(oop ref, oop value);
 957   static inline HeapWord* discovered_addr_raw(oop ref);
 958   static inline oop queue(oop ref);
 959   static inline void set_queue(oop ref, oop value);
 960   static bool is_referent_field(oop obj, ptrdiff_t offset);
 961   static inline bool is_final(oop ref);
 962   static inline bool is_phantom(oop ref);
 963 };
 964 
 965 
 966 // Interface to java.lang.ref.SoftReference objects
 967 
 968 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 969  public:
 970   static int timestamp_offset;
 971   static int static_clock_offset;
 972 
 973   // Accessors
 974   static jlong timestamp(oop ref);
 975 
 976   // Accessors for statics
 977   static jlong clock();
 978   static void set_clock(jlong value);
 979 
 980   static void compute_offsets();
 981   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 982 };
 983 
 984 // Interface to java.lang.invoke.MethodHandle objects
 985 
 986 class MethodHandleEntry;
 987 
 988 class java_lang_invoke_MethodHandle: AllStatic {
 989   friend class JavaClasses;
 990 
 991  private:
 992   static int _type_offset;               // the MethodType of this MH
 993   static int _form_offset;               // the LambdaForm of this MH
 994 
 995   static void compute_offsets();
 996 
 997  public:
 998   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 999 
1000   // Accessors
1001   static oop            type(oop mh);
1002   static void       set_type(oop mh, oop mtype);
1003 
1004   static oop            form(oop mh);
1005   static void       set_form(oop mh, oop lform);
1006 
1007   // Testers
1008   static bool is_subclass(Klass* klass) {
1009     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
1010   }
1011   static bool is_instance(oop obj);
1012 
1013   // Accessors for code generation:
1014   static int type_offset_in_bytes()             { return _type_offset; }
1015   static int form_offset_in_bytes()             { return _form_offset; }
1016 };
1017 
1018 // Interface to java.lang.invoke.DirectMethodHandle objects
1019 
1020 class java_lang_invoke_DirectMethodHandle: AllStatic {
1021   friend class JavaClasses;
1022 
1023  private:
1024   static int _member_offset;               // the MemberName of this DMH
1025 
1026   static void compute_offsets();
1027 
1028  public:
1029   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1030 
1031   // Accessors
1032   static oop  member(oop mh);
1033 
1034   // Testers
1035   static bool is_subclass(Klass* klass) {
1036     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
1037   }
1038   static bool is_instance(oop obj);
1039 
1040   // Accessors for code generation:
1041   static int member_offset_in_bytes()           { return _member_offset; }
1042 };
1043 
1044 // Interface to java.lang.invoke.LambdaForm objects
1045 // (These are a private interface for managing adapter code generation.)
1046 
1047 class java_lang_invoke_LambdaForm: AllStatic {
1048   friend class JavaClasses;
1049 
1050  private:
1051   static int _vmentry_offset;  // type is MemberName
1052 
1053   static void compute_offsets();
1054 
1055  public:
1056   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1057 
1058   // Accessors
1059   static oop            vmentry(oop lform);
1060   static void       set_vmentry(oop lform, oop invoker);
1061 
1062   // Testers
1063   static bool is_subclass(Klass* klass) {
1064     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1065       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1066   }
1067   static bool is_instance(oop obj);
1068 
1069   // Accessors for code generation:
1070   static int vmentry_offset_in_bytes()          { return _vmentry_offset; }
1071 };
1072 
1073 
1074 // Interface to java.lang.invoke.MemberName objects
1075 // (These are a private interface for Java code to query the class hierarchy.)
1076 
1077 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1078   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1079   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1080 
1081 class java_lang_invoke_ResolvedMethodName : AllStatic {
1082   friend class JavaClasses;
1083 
1084   static int _vmtarget_offset;
1085   static int _vmholder_offset;
1086 
1087   static void compute_offsets();
1088  public:
1089   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1090 
1091   static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }
1092 
1093   static Method* vmtarget(oop resolved_method);
1094   static void set_vmtarget(oop resolved_method, Method* method);
1095 
1096   static void set_vmholder(oop resolved_method, oop holder);
1097 
1098   // find or create resolved member name
1099   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1100 
1101   static bool is_instance(oop resolved_method);
1102 };
1103 
1104 
1105 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1106   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1107 
1108 
1109 class java_lang_invoke_MemberName: AllStatic {
1110   friend class JavaClasses;
1111 
1112  private:
1113   // From java.lang.invoke.MemberName:
1114   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1115   //    private String     name;        // may be null if not yet materialized
1116   //    private Object     type;        // may be null if not yet materialized
1117   //    private int        flags;       // modifier bits; see reflect.Modifier
1118   //    private ResolvedMethodName method;    // holds VM-specific target value
1119   //    private intptr_t   vmindex;     // member index within class or interface
1120   static int _clazz_offset;
1121   static int _name_offset;
1122   static int _type_offset;
1123   static int _flags_offset;
1124   static int _method_offset;
1125   static int _vmindex_offset;
1126 
1127   static void compute_offsets();
1128 
1129  public:
1130   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1131   // Accessors
1132   static oop            clazz(oop mname);
1133   static void       set_clazz(oop mname, oop clazz);
1134 
1135   static oop            type(oop mname);
1136   static void       set_type(oop mname, oop type);
1137 
1138   static oop            name(oop mname);
1139   static void       set_name(oop mname, oop name);
1140 
1141   static int            flags(oop mname);
1142   static void       set_flags(oop mname, int flags);
1143 
1144   // Link through ResolvedMethodName field to get Method*
1145   static Method*        vmtarget(oop mname);
1146   static void       set_method(oop mname, oop method);
1147 
1148   static intptr_t       vmindex(oop mname);
1149   static void       set_vmindex(oop mname, intptr_t index);
1150 
1151   // Testers
1152   static bool is_subclass(Klass* klass) {
1153     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1154   }
1155   static bool is_instance(oop obj);
1156 
1157   static bool is_method(oop obj);
1158 
1159   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1160   enum {
<a name="7" id="anc7"></a><span class="line-modified">1161     MN_IS_METHOD             = 0x00010000, // method (not constructor)</span>
<span class="line-modified">1162     MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, // constructor</span>
1163     MN_IS_FIELD              = 0x00040000, // field
1164     MN_IS_TYPE               = 0x00080000, // nested type
1165     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1166     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1167     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1168     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1169     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
<a name="8" id="anc8"></a><span class="line-modified">1170     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces</span>
<span class="line-added">1171     MN_NESTMATE_CLASS        = 0x00000001,</span>
<span class="line-added">1172     MN_HIDDEN_CLASS          = 0x00000002,</span>
<span class="line-added">1173     MN_STRONG_LOADER_LINK    = 0x00000004,</span>
<span class="line-added">1174     MN_ACCESS_VM_ANNOTATIONS = 0x00000008</span>
1175   };
1176 
1177   // Accessors for code generation:
1178   static int clazz_offset_in_bytes()            { return _clazz_offset; }
1179   static int type_offset_in_bytes()             { return _type_offset; }
1180   static int name_offset_in_bytes()             { return _name_offset; }
1181   static int flags_offset_in_bytes()            { return _flags_offset; }
1182   static int method_offset_in_bytes()           { return _method_offset; }
1183   static int vmindex_offset_in_bytes()          { return _vmindex_offset; }
1184 };
1185 
1186 
1187 // Interface to java.lang.invoke.MethodType objects
1188 
1189 class java_lang_invoke_MethodType: AllStatic {
1190   friend class JavaClasses;
1191 
1192  private:
1193   static int _rtype_offset;
1194   static int _ptypes_offset;
1195 
1196   static void compute_offsets();
1197 
1198  public:
1199   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1200   // Accessors
1201   static oop            rtype(oop mt);
1202   static objArrayOop    ptypes(oop mt);
1203 
1204   static oop            ptype(oop mt, int index);
1205   static int            ptype_count(oop mt);
1206 
1207   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1208   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1209 
1210   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1211   static void           print_signature(oop mt, outputStream* st);
1212 
1213   static bool is_instance(oop obj);
1214 
1215   static bool equals(oop mt1, oop mt2);
1216 
1217   // Accessors for code generation:
1218   static int rtype_offset_in_bytes()            { return _rtype_offset; }
1219   static int ptypes_offset_in_bytes()           { return _ptypes_offset; }
1220 };
1221 
1222 
1223 // Interface to java.lang.invoke.CallSite objects
1224 
1225 class java_lang_invoke_CallSite: AllStatic {
1226   friend class JavaClasses;
1227 
1228 private:
1229   static int _target_offset;
1230   static int _context_offset;
1231 
1232   static void compute_offsets();
1233 
1234 public:
1235   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1236   // Accessors
1237   static oop              target(          oop site);
1238   static void         set_target(          oop site, oop target);
1239   static void         set_target_volatile( oop site, oop target);
1240 
1241   static oop context_no_keepalive(oop site);
1242 
1243   // Testers
1244   static bool is_subclass(Klass* klass) {
1245     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1246   }
1247   static bool is_instance(oop obj);
1248 
1249   // Accessors for code generation:
1250   static int target_offset_in_bytes()           { return _target_offset; }
1251 };
1252 
1253 // Interface to java.lang.invoke.ConstantCallSite objects
1254 
1255 class java_lang_invoke_ConstantCallSite: AllStatic {
1256   friend class JavaClasses;
1257 
1258 private:
1259   static int _is_frozen_offset;
1260 
1261   static void compute_offsets();
1262 
1263 public:
1264   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1265   // Accessors
1266   static jboolean is_frozen(oop site);
1267 
1268   // Testers
1269   static bool is_subclass(Klass* klass) {
1270     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
1271   }
1272   static bool is_instance(oop obj);
1273 };
1274 
1275 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1276 
1277 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1278   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1279   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1280 
1281 class DependencyContext;
1282 
1283 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1284   friend class JavaClasses;
1285 
1286 private:
1287   static int _vmdependencies_offset;
1288   static int _last_cleanup_offset;
1289 
1290   static void compute_offsets();
1291 
1292 public:
1293   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1294   // Accessors
1295   static DependencyContext vmdependencies(oop context);
1296 
1297   // Testers
1298   static bool is_subclass(Klass* klass) {
1299     return klass-&gt;is_subclass_of(SystemDictionary::Context_klass());
1300   }
1301   static bool is_instance(oop obj);
1302 };
1303 
1304 // Interface to java.security.AccessControlContext objects
1305 
1306 class java_security_AccessControlContext: AllStatic {
1307  private:
1308   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
1309   // so we compute the offsets at startup rather than hard-wiring them.
1310   static int _context_offset;
1311   static int _privilegedContext_offset;
1312   static int _isPrivileged_offset;
1313   static int _isAuthorized_offset;
1314 
1315   static void compute_offsets();
1316  public:
1317   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1318   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1319 
1320   // Debugging/initialization
1321   friend class JavaClasses;
1322 };
1323 
1324 
1325 // Interface to java.lang.ClassLoader objects
1326 
1327 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1328   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1329 
1330 class java_lang_ClassLoader : AllStatic {
1331  private:
1332   static int _loader_data_offset;
1333   static bool offsets_computed;
1334   static int parent_offset;
1335   static int parallelCapable_offset;
1336   static int name_offset;
1337   static int nameAndId_offset;
1338   static int unnamedModule_offset;
1339 
1340  public:
1341   static void compute_offsets();
1342   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1343 
1344   static ClassLoaderData* loader_data_acquire(oop loader);
1345   static ClassLoaderData* loader_data_raw(oop loader);
1346   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1347 
1348   static oop parent(oop loader);
1349   static oop name(oop loader);
1350   static oop nameAndId(oop loader);
1351   static bool isAncestor(oop loader, oop cl);
1352 
1353   // Support for parallelCapable field
1354   static bool parallelCapable(oop the_class_mirror);
1355 
1356   static bool is_trusted_loader(oop loader);
1357 
1358   // Return true if this is one of the class loaders associated with
1359   // the generated bytecodes for reflection.
1360   static bool is_reflection_class_loader(oop loader);
1361 
1362   // Fix for 4474172
1363   static oop  non_reflection_class_loader(oop loader);
1364 
1365   // Testers
1366   static bool is_subclass(Klass* klass) {
1367     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1368   }
1369   static bool is_instance(oop obj);
1370 
1371   static oop unnamedModule(oop loader);
1372 
1373   // Debugging
1374   friend class JavaClasses;
1375   friend class ClassFileParser; // access to number_of_fake_fields
1376 };
1377 
1378 
1379 // Interface to java.lang.System objects
1380 
1381 class java_lang_System : AllStatic {
1382  private:
1383   static int  static_in_offset;
1384   static int static_out_offset;
1385   static int static_err_offset;
1386   static int static_security_offset;
1387 
1388  public:
1389   static int  in_offset_in_bytes();
1390   static int out_offset_in_bytes();
1391   static int err_offset_in_bytes();
1392 
1393   static void compute_offsets();
1394   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1395 
1396   // Debugging
1397   friend class JavaClasses;
1398 };
1399 
1400 
1401 // Interface to java.lang.StackTraceElement objects
1402 
1403 class java_lang_StackTraceElement: AllStatic {
1404  private:
1405   static int declaringClassObject_offset;
1406   static int classLoaderName_offset;
1407   static int moduleName_offset;
1408   static int moduleVersion_offset;
1409   static int declaringClass_offset;
1410   static int methodName_offset;
1411   static int fileName_offset;
1412   static int lineNumber_offset;
1413 
1414   // Setters
1415   static void set_classLoaderName(oop element, oop value);
1416   static void set_moduleName(oop element, oop value);
1417   static void set_moduleVersion(oop element, oop value);
1418   static void set_declaringClass(oop element, oop value);
1419   static void set_methodName(oop element, oop value);
1420   static void set_fileName(oop element, oop value);
1421   static void set_lineNumber(oop element, int value);
1422   static void set_declaringClassObject(oop element, oop value);
1423 
1424   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1425                                    const methodHandle&amp; method, int bci,
1426                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1427 
1428  public:
1429   // Create an instance of StackTraceElement
1430   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1431 
1432   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1433                       int version, int bci, Symbol* name, TRAPS);
1434 
1435   static void compute_offsets();
1436   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1437 
1438 #if INCLUDE_JVMCI
1439   static void decode(const methodHandle&amp; method, int bci, Symbol*&amp; fileName, int&amp; lineNumber, TRAPS);
1440 #endif
1441 
1442   // Debugging
1443   friend class JavaClasses;
1444 };
1445 
1446 
1447 class Backtrace: AllStatic {
1448  public:
1449   // Helper backtrace functions to store bci|version together.
1450   static int merge_bci_and_version(int bci, int version);
1451   static int merge_mid_and_cpref(int mid, int cpref);
1452   static int bci_at(unsigned int merged);
1453   static int version_at(unsigned int merged);
1454   static int mid_at(unsigned int merged);
1455   static int cpref_at(unsigned int merged);
1456   static int get_line_number(Method* method, int bci);
1457   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1458 
1459   // Debugging
1460   friend class JavaClasses;
1461 };
1462 
1463 // Interface to java.lang.StackFrameInfo objects
1464 
1465 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1466   macro(java_lang_StackFrameInfo, version, short_signature, false)
1467 
1468 class java_lang_StackFrameInfo: AllStatic {
1469 private:
1470   static int _memberName_offset;
1471   static int _bci_offset;
1472   static int _version_offset;
1473 
1474   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1475 
1476 public:
1477   // Setters
1478   static void set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS);
1479   static void set_bci(oop info, int value);
1480 
1481   static void set_version(oop info, short value);
1482 
1483   static void compute_offsets();
1484   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1485 
1486   static void to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS);
1487 
1488   // Debugging
1489   friend class JavaClasses;
1490 };
1491 
1492 class java_lang_LiveStackFrameInfo: AllStatic {
1493  private:
1494   static int _monitors_offset;
1495   static int _locals_offset;
1496   static int _operands_offset;
1497   static int _mode_offset;
1498 
1499  public:
1500   static void set_monitors(oop info, oop value);
1501   static void set_locals(oop info, oop value);
1502   static void set_operands(oop info, oop value);
1503   static void set_mode(oop info, int value);
1504 
1505   static void compute_offsets();
1506   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1507 
1508   // Debugging
1509   friend class JavaClasses;
1510 };
1511 
1512 // Interface to java.lang.reflect.RecordComponent objects
1513 
1514 class java_lang_reflect_RecordComponent: AllStatic {
1515  private:
1516   static int clazz_offset;
1517   static int name_offset;
1518   static int type_offset;
1519   static int accessor_offset;
1520   static int signature_offset;
1521   static int annotations_offset;
1522   static int typeAnnotations_offset;
1523 
1524   // Setters
1525   static void set_clazz(oop element, oop value);
1526   static void set_name(oop element, oop value);
1527   static void set_type(oop element, oop value);
1528   static void set_accessor(oop element, oop value);
1529   static void set_signature(oop element, oop value);
1530   static void set_annotations(oop element, oop value);
1531   static void set_typeAnnotations(oop element, oop value);
1532 
1533  public:
1534   // Create an instance of RecordComponent
1535   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1536 
1537   static void compute_offsets();
1538   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1539 
1540   // Debugging
1541   friend class JavaClasses;
1542 };
1543 
1544 
1545 // Interface to java.lang.AssertionStatusDirectives objects
1546 
1547 class java_lang_AssertionStatusDirectives: AllStatic {
1548  private:
1549   static int classes_offset;
1550   static int classEnabled_offset;
1551   static int packages_offset;
1552   static int packageEnabled_offset;
1553   static int deflt_offset;
1554 
1555  public:
1556   // Setters
1557   static void set_classes(oop obj, oop val);
1558   static void set_classEnabled(oop obj, oop val);
1559   static void set_packages(oop obj, oop val);
1560   static void set_packageEnabled(oop obj, oop val);
1561   static void set_deflt(oop obj, bool val);
1562 
1563   static void compute_offsets();
1564   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1565 
1566   // Debugging
1567   friend class JavaClasses;
1568 };
1569 
1570 
1571 class java_nio_Buffer: AllStatic {
1572  private:
1573   static int _limit_offset;
1574 
1575  public:
1576   static int  limit_offset();
1577   static void compute_offsets();
1578   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1579 };
1580 
1581 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1582  private:
1583   static int  _owner_offset;
1584  public:
1585   static void compute_offsets();
1586   static oop  get_owner_threadObj(oop obj);
1587   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1588 };
1589 
1590  // Interface to jdk.internal.misc.UnsafeConsants
1591 
1592 class jdk_internal_misc_UnsafeConstants : AllStatic {
1593  public:
1594   static void set_unsafe_constants();
1595   static void compute_offsets() { }
1596   static void serialize_offsets(SerializeClosure* f) { }
1597 };
1598 
1599 class java_lang_Integer : AllStatic {
1600 public:
1601   static jint value(oop obj);
1602 };
1603 
1604 class java_lang_Long : AllStatic {
1605 public:
1606   static jlong value(oop obj);
1607 };
1608 
1609 class java_lang_Character : AllStatic {
1610 public:
1611   static jchar value(oop obj);
1612 };
1613 
1614 class java_lang_Short : AllStatic {
1615 public:
1616   static jshort value(oop obj);
1617 };
1618 
1619 class java_lang_Byte : AllStatic {
1620 public:
1621   static jbyte value(oop obj);
1622 };
1623 
1624 class java_lang_Boolean : AllStatic {
1625  private:
1626   static int _static_TRUE_offset;
1627   static int _static_FALSE_offset;
1628  public:
1629   static Symbol* symbol();
1630   static void compute_offsets(InstanceKlass* k);
1631   static oop  get_TRUE(InstanceKlass *k);
1632   static oop  get_FALSE(InstanceKlass *k);
1633   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1634   static jboolean value(oop obj);
1635 };
1636 
1637 class java_lang_Integer_IntegerCache : AllStatic {
1638  private:
1639   static int _static_cache_offset;
1640  public:
1641   static Symbol* symbol();
1642   static void compute_offsets(InstanceKlass* k);
1643   static objArrayOop  cache(InstanceKlass *k);
1644   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1645 };
1646 
1647 class java_lang_Long_LongCache : AllStatic {
1648  private:
1649   static int _static_cache_offset;
1650  public:
1651   static Symbol* symbol();
1652   static void compute_offsets(InstanceKlass* k);
1653   static objArrayOop  cache(InstanceKlass *k);
1654   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1655 };
1656 
1657 class java_lang_Character_CharacterCache : AllStatic {
1658  private:
1659   static int _static_cache_offset;
1660  public:
1661   static Symbol* symbol();
1662   static void compute_offsets(InstanceKlass* k);
1663   static objArrayOop  cache(InstanceKlass *k);
1664   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1665 };
1666 
1667 class java_lang_Short_ShortCache : AllStatic {
1668  private:
1669   static int _static_cache_offset;
1670  public:
1671   static Symbol* symbol();
1672   static void compute_offsets(InstanceKlass* k);
1673   static objArrayOop  cache(InstanceKlass *k);
1674   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1675 };
1676 
1677 class java_lang_Byte_ByteCache : AllStatic {
1678  private:
1679   static int _static_cache_offset;
1680  public:
1681   static Symbol* symbol();
1682   static void compute_offsets(InstanceKlass* k);
1683   static objArrayOop  cache(InstanceKlass *k);
1684   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1685 };
1686 
1687 class jdk_internal_vm_jni_SubElementSelector : AllStatic {
1688  private:
1689   static int _arrayElementType_offset;
1690   static int _subElementType_offset;
1691   static int _offset_offset;
1692   static int _isFlattened_offset;
1693   static int _isFlattenable_offset;
1694  public:
1695   static Symbol* symbol();
1696   static void compute_offsets();
1697   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1698 
1699   static oop getArrayElementType(oop obj);
1700   static void setArrayElementType(oop obj, oop type);
1701   static oop getSubElementType(oop obj);
1702   static void setSubElementType(oop obj, oop type);
1703   static int getOffset(oop obj);
1704   static void setOffset(oop obj, int offset);
1705   static bool getIsFlattened(oop obj);
1706   static void setIsFlattened(oop obj, bool b);
1707   static bool getIsFlattenable(oop obj);
1708   static void setIsFlattenable(oop obj, bool b);
1709 };
1710 
1711 // Use to declare fields that need to be injected into Java classes
1712 // for the JVM to use.  The name_index and signature_index are
1713 // declared in vmSymbols.  The may_be_java flag is used to declare
1714 // fields that might already exist in Java but should be injected if
1715 // they don&#39;t.  Otherwise the field is unconditionally injected and
1716 // the JVM uses the injected one.  This is to ensure that name
1717 // collisions don&#39;t occur.  In general may_be_java should be false
1718 // unless there&#39;s a good reason.
1719 
1720 class InjectedField {
1721  public:
1722   const SystemDictionary::WKID klass_id;
1723   const vmSymbols::SID name_index;
1724   const vmSymbols::SID signature_index;
1725   const bool           may_be_java;
1726 
1727 
1728   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1729   Symbol* name() const      { return lookup_symbol(name_index); }
1730   Symbol* signature() const { return lookup_symbol(signature_index); }
1731 
1732   int compute_offset();
1733 
1734   // Find the Symbol for this index
1735   static Symbol* lookup_symbol(int symbol_index) {
1736     return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);
1737   }
1738 };
1739 
1740 #define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \
1741   klass##_##name##_enum,
1742 
1743 #define ALL_INJECTED_FIELDS(macro)          \
1744   CLASS_INJECTED_FIELDS(macro)              \
1745   CLASSLOADER_INJECTED_FIELDS(macro)        \
1746   RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \
1747   MEMBERNAME_INJECTED_FIELDS(macro)         \
1748   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1749   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1750   MODULE_INJECTED_FIELDS(macro)
1751 
1752 // Interface to hard-coded offset checking
1753 
1754 class JavaClasses : AllStatic {
1755  private:
1756 
1757   static InjectedField _injected_fields[];
1758 
1759   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1760  public:
1761   enum InjectedFieldID {
1762     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1763     MAX_enum
1764   };
1765 
1766   static int compute_injected_offset(InjectedFieldID id);
1767 
1768   static void compute_hard_coded_offsets();
1769   static void compute_offsets();
1770   static void check_offsets() PRODUCT_RETURN;
1771   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1772   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1773   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1774 };
1775 
1776 #undef DECLARE_INJECTED_FIELD_ENUM
1777 
1778 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1  /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
110     if (cl_instance_name != NULL &amp;&amp; cl_instance_name[0] != &#39;\0&#39;) {
111       _name = SymbolTable::new_symbol(cl_instance_name);
112     }
113   }
114 
115   // Obtain the class loader&#39;s name and identity hash.  If the class loader&#39;s
116   // name was not explicitly set during construction, the class loader&#39;s name and id
117   // will be set to the qualified class name of the class loader along with its
118   // identity hash.
119   // If for some reason the ClassLoader&#39;s constructor has not been run, instead of
120   // leaving the _name_and_id field null, fall back to the external qualified class
121   // name.  Thus CLD&#39;s _name_and_id field should never have a null value.
122   oop cl_name_and_id = java_lang_ClassLoader::nameAndId(class_loader());
123   const char* cl_instance_name_and_id =
124                   (cl_name_and_id == NULL) ? _class_loader_klass-&gt;external_name() :
125                                              java_lang_String::as_utf8_string(cl_name_and_id);
126   assert(cl_instance_name_and_id != NULL &amp;&amp; cl_instance_name_and_id[0] != &#39;\0&#39;, &quot;class loader has no name and id&quot;);
127   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id);
128 }
129 
<span class="line-modified">130 ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous) :</span>
131   _metaspace(NULL),
132   _metaspace_lock(new Mutex(Mutex::leaf+1, &quot;Metaspace allocation lock&quot;, true,
133                             Mutex::_safepoint_check_never)),
<span class="line-modified">134   _unloading(false), _is_unsafe_anonymous(is_unsafe_anonymous),</span>
135   _modified_oops(true), _accumulated_modified_oops(false),
136   // An unsafe anonymous class loader data doesn&#39;t have anything to keep
137   // it from being unloaded during parsing of the unsafe anonymous class.
138   // The null-class-loader should always be kept alive.
<span class="line-modified">139   _keep_alive((is_unsafe_anonymous || h_class_loader.is_null()) ? 1 : 0),</span>
140   _claim(0),
141   _handles(),
142   _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),
143   _jmethod_ids(NULL),
144   _deallocate_list(NULL),
145   _next(NULL),
146   _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {
147 
148   if (!h_class_loader.is_null()) {
149     _class_loader = _handles.add(h_class_loader());
150     _class_loader_klass = h_class_loader-&gt;klass();
151     initialize_name(h_class_loader);
152   }
153 
<span class="line-modified">154   if (!is_unsafe_anonymous) {</span>
<span class="line-modified">155     // The holder is initialized later for unsafe anonymous classes, and before calling anything</span>
<span class="line-modified">156     // that call class_loader().</span>
157     initialize_holder(h_class_loader);
158 
<span class="line-modified">159     // A ClassLoaderData created solely for an unsafe anonymous class should never have a</span>
<span class="line-modified">160     // ModuleEntryTable or PackageEntryTable created for it. The defining package</span>
161     // and module for an unsafe anonymous class will be found in its host class.
162     _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);
163     if (h_class_loader.is_null()) {
164       // Create unnamed module for boot loader
165       _unnamed_module = ModuleEntry::create_boot_unnamed_module(this);
166     } else {
167       // Create unnamed module for all other loaders
168       _unnamed_module = ModuleEntry::create_unnamed_module(this);
169     }
170     _dictionary = create_dictionary();
171   }
172 
173   NOT_PRODUCT(_dependency_count = 0); // number of class loader dependencies
174 
175   JFR_ONLY(INIT_ID(this);)
176 }
177 
178 ClassLoaderData::ChunkedHandleList::~ChunkedHandleList() {
179   Chunk* c = _head;
180   while (c != NULL) {
</pre>
<hr />
<pre>
275     int new_claim = old_claim &amp; ~claim;
276     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
277       return;
278     }
279   }
280 }
281 
282 bool ClassLoaderData::try_claim(int claim) {
283   for (;;) {
284     int old_claim = Atomic::load(&amp;_claim);
285     if ((old_claim &amp; claim) == claim) {
286       return false;
287     }
288     int new_claim = old_claim | claim;
289     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
290       return true;
291     }
292   }
293 }
294 
<span class="line-modified">295 // Unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive</span>
296 // while the class is being parsed, and if the class appears on the module fixup list.
<span class="line-modified">297 // Due to the uniqueness that no other class shares the unsafe anonymous class&#39; name or</span>
<span class="line-modified">298 // ClassLoaderData, no other non-GC thread has knowledge of the unsafe anonymous class while</span>
299 // it is being defined, therefore _keep_alive is not volatile or atomic.
300 void ClassLoaderData::inc_keep_alive() {
<span class="line-modified">301   if (is_unsafe_anonymous()) {</span>
302     assert(_keep_alive &gt; 0, &quot;Invalid keep alive increment count&quot;);
303     _keep_alive++;
304   }
305 }
306 
307 void ClassLoaderData::dec_keep_alive() {
<span class="line-modified">308   if (is_unsafe_anonymous()) {</span>
309     assert(_keep_alive &gt; 0, &quot;Invalid keep alive decrement count&quot;);
310     _keep_alive--;
311   }
312 }
313 
314 void ClassLoaderData::oops_do(OopClosure* f, int claim_value, bool clear_mod_oops) {
315   if (claim_value != ClassLoaderData::_claim_none &amp;&amp; !try_claim(claim_value)) {
316     return;
317   }
318 
319   // Only clear modified_oops after the ClassLoaderData is claimed.
320   if (clear_mod_oops) {
321     clear_modified_oops();
322   }
323 
324   _handles.oops_do(f);
325 }
326 
327 void ClassLoaderData::classes_do(KlassClosure* klass_closure) {
328   // Lock-free access requires load_acquire
</pre>
<hr />
<pre>
404   assert_locked_or_safepoint(Module_lock);
405   if (_packages != NULL) {
406     for (int i = 0; i &lt; _packages-&gt;table_size(); i++) {
407       for (PackageEntry* entry = _packages-&gt;bucket(i);
408            entry != NULL;
409            entry = entry-&gt;next()) {
410         f(entry);
411       }
412     }
413   }
414 }
415 
416 void ClassLoaderData::record_dependency(const Klass* k) {
417   assert(k != NULL, &quot;invariant&quot;);
418 
419   ClassLoaderData * const from_cld = this;
420   ClassLoaderData * const to_cld = k-&gt;class_loader_data();
421 
422   // Do not need to record dependency if the dependency is to a class whose
423   // class loader data is never freed.  (i.e. the dependency&#39;s class loader
<span class="line-modified">424   // is one of the three builtin class loaders and the dependency is not</span>
<span class="line-modified">425   // unsafe anonymous.)</span>
426   if (to_cld-&gt;is_permanent_class_loader_data()) {
427     return;
428   }
429 
430   oop to;
<span class="line-modified">431   if (to_cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-modified">432     // Just return if an unsafe anonymous class is attempting to record a dependency</span>
<span class="line-modified">433     // to itself.  (Note that every unsafe anonymous class has its own unique class</span>
434     // loader data.)
435     if (to_cld == from_cld) {
436       return;
437     }
<span class="line-modified">438     // Unsafe anonymous class dependencies are through the mirror.</span>
439     to = k-&gt;java_mirror();
440   } else {
441     to = to_cld-&gt;class_loader();
442     oop from = from_cld-&gt;class_loader();
443 
444     // Just return if this dependency is to a class with the same or a parent
445     // class_loader.
446     if (from == to || java_lang_ClassLoader::isAncestor(from, to)) {
447       return; // this class loader is in the parent list, no need to add it.
448     }
449   }
450 
451   // It&#39;s a dependency we won&#39;t find through GC, add it.
452   if (!_handles.contains(to)) {
453     NOT_PRODUCT(Atomic::inc(&amp;_dependency_count));
454     LogTarget(Trace, class, loader, data) lt;
455     if (lt.is_enabled()) {
456       ResourceMark rm;
457       LogStream ls(lt);
458       ls.print(&quot;adding dependency from &quot;);
</pre>
<hr />
<pre>
568   if (modules == NULL) {
569     MutexLocker m1(Module_lock);
570     // Check if _modules got allocated while we were waiting for this lock.
571     if ((modules = _modules) == NULL) {
572       modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);
573 
574       {
575         MutexLocker m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);
576         // Ensure _modules is stable, since it is examined without a lock
577         Atomic::release_store(&amp;_modules, modules);
578       }
579     }
580   }
581   return modules;
582 }
583 
584 const int _boot_loader_dictionary_size    = 1009;
585 const int _default_loader_dictionary_size = 107;
586 
587 Dictionary* ClassLoaderData::create_dictionary() {
<span class="line-modified">588   assert(!is_unsafe_anonymous(), &quot;unsafe anonymous class loader data do not have a dictionary&quot;);</span>
589   int size;
590   bool resizable = false;
591   if (_the_null_class_loader_data == NULL) {
592     size = _boot_loader_dictionary_size;
593     resizable = true;
594   } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
595     size = 1;  // there&#39;s only one class in relection class loader and no initiated classes
596   } else if (is_system_class_loader_data()) {
597     size = _boot_loader_dictionary_size;
598     resizable = true;
599   } else {
600     size = _default_loader_dictionary_size;
601     resizable = true;
602   }
603   if (!DynamicallyResizeSystemDictionaries || DumpSharedSpaces) {
604     resizable = false;
605   }
606   return new Dictionary(this, size, resizable);
607 }
608 
</pre>
<hr />
<pre>
614   // to get notified about this potential resurrection, otherwise the marking
615   // might not find the object.
616   if (!_holder.is_null()) {  // NULL class_loader
617     return _holder.resolve();
618   } else {
619     return NULL;
620   }
621 }
622 
623 // Let the GC read the holder without keeping it alive.
624 oop ClassLoaderData::holder_no_keepalive() const {
625   if (!_holder.is_null()) {  // NULL class_loader
626     return _holder.peek();
627   } else {
628     return NULL;
629   }
630 }
631 
632 // Unloading support
633 bool ClassLoaderData::is_alive() const {
<span class="line-modified">634   bool alive = keep_alive()         // null class loader and incomplete unsafe anonymous klasses.</span>
635       || (_holder.peek() != NULL);  // and not cleaned by the GC weak handle processing.
636 
637   return alive;
638 }
639 
640 class ReleaseKlassClosure: public KlassClosure {
641 private:
642   size_t  _instance_class_released;
643   size_t  _array_class_released;
644 public:
645   ReleaseKlassClosure() : _instance_class_released(0), _array_class_released(0) { }
646 
647   size_t instance_class_released() const { return _instance_class_released; }
648   size_t array_class_released()    const { return _array_class_released;    }
649 
650   void do_klass(Klass* k) {
651     if (k-&gt;is_array_klass()) {
652       _array_class_released ++;
653     } else {
654       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
</pre>
<hr />
<pre>
712   }
713   // Delete lock
714   delete _metaspace_lock;
715 
716   // Delete free list
717   if (_deallocate_list != NULL) {
718     delete _deallocate_list;
719   }
720 
721   // Decrement refcounts of Symbols if created.
722   if (_name != NULL) {
723     _name-&gt;decrement_refcount();
724   }
725   if (_name_and_id != NULL) {
726     _name_and_id-&gt;decrement_refcount();
727   }
728 }
729 
730 // Returns true if this class loader data is for the app class loader
731 // or a user defined system class loader.  (Note that the class loader
<span class="line-modified">732 // data may be unsafe anonymous.)</span>
733 bool ClassLoaderData::is_system_class_loader_data() const {
734   return SystemDictionary::is_system_class_loader(class_loader());
735 }
736 
737 // Returns true if this class loader data is for the platform class loader.
<span class="line-modified">738 // (Note that the class loader data may be unsafe anonymous.)</span>
739 bool ClassLoaderData::is_platform_class_loader_data() const {
740   return SystemDictionary::is_platform_class_loader(class_loader());
741 }
742 
743 // Returns true if the class loader for this class loader data is one of
744 // the 3 builtin (boot application/system or platform) class loaders,
745 // including a user-defined system class loader.  Note that if the class
<span class="line-modified">746 // loader data is for an unsafe anonymous class then it may get freed by a GC</span>
<span class="line-modified">747 // even if its class loader is one of these loaders.</span>
748 bool ClassLoaderData::is_builtin_class_loader_data() const {
749   return (is_boot_class_loader_data() ||
750           SystemDictionary::is_system_class_loader(class_loader()) ||
751           SystemDictionary::is_platform_class_loader(class_loader()));
752 }
753 
754 // Returns true if this class loader data is a class loader data
755 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
<span class="line-modified">756 // class loaders and not the CLD for an unsafe anonymous class.</span>
757 bool ClassLoaderData::is_permanent_class_loader_data() const {
<span class="line-modified">758   return is_builtin_class_loader_data() &amp;&amp; !is_unsafe_anonymous();</span>
759 }
760 
761 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
762   // If the metaspace has not been allocated, create a new one.  Might want
763   // to create smaller arena for Reflection class loaders also.
764   // The reason for the delayed allocation is because some class loaders are
765   // simply for delegating with no metadata of their own.
766   // Lock-free access requires load_acquire.
767   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);
768   if (metaspace == NULL) {
769     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);
770     // Check if _metaspace got allocated while we were waiting for this lock.
771     if ((metaspace = _metaspace) == NULL) {
772       if (this == the_null_class_loader_data()) {
773         assert (class_loader() == NULL, &quot;Must be&quot;);
774         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
<span class="line-modified">775       } else if (is_unsafe_anonymous()) {</span>
<span class="line-modified">776         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::UnsafeAnonymousMetaspaceType);</span>
777       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
778         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
779       } else {
780         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
781       }
782       // Ensure _metaspace is stable, since it is examined without a lock
783       Atomic::release_store(&amp;_metaspace, metaspace);
784     }
785   }
786   return metaspace;
787 }
788 
789 OopHandle ClassLoaderData::add_handle(Handle h) {
790   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
791   record_modified_oops();
792   return OopHandle(_handles.add(h()));
793 }
794 
795 void ClassLoaderData::remove_handle(OopHandle h) {
796   assert(!is_unloading(), &quot;Do not remove a handle for a CLD that is unloading&quot;);
</pre>
<hr />
<pre>
877   if (_deallocate_list == NULL) {
878     return;
879   }
880   // Go backwards because this removes entries that are freed.
881   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
882     Metadata* m = _deallocate_list-&gt;at(i);
883     _deallocate_list-&gt;remove_at(i);
884     if (m-&gt;is_constantPool()) {
885       ((ConstantPool*)m)-&gt;release_C_heap_structures();
886     } else if (m-&gt;is_klass()) {
887       InstanceKlass* ik = (InstanceKlass*)m;
888       // also releases ik-&gt;constants() C heap memory
889       InstanceKlass::release_C_heap_structures(ik);
890       // Remove the class so unloading events aren&#39;t triggered for
891       // this class (scratch or error class) in do_unloading().
892       remove_class(ik);
893     }
894   }
895 }
896 
<span class="line-modified">897 // These CLDs are to contain unsafe anonymous classes used for JSR292</span>
<span class="line-modified">898 ClassLoaderData* ClassLoaderData::unsafe_anonymous_class_loader_data(Handle loader) {</span>
899   // Add a new class loader data to the graph.
900   return ClassLoaderDataGraph::add(loader, true);
901 }
902 
903 // Caller needs ResourceMark
904 // If the class loader&#39;s _name has not been explicitly set, the class loader&#39;s
905 // qualified class name is returned.
906 const char* ClassLoaderData::loader_name() const {
907    if (_class_loader_klass == NULL) {
908      return BOOTSTRAP_LOADER_NAME;
909    } else if (_name != NULL) {
910      return _name-&gt;as_C_string();
911    } else {
912      return _class_loader_klass-&gt;external_name();
913    }
914 }
915 
916 // Caller needs ResourceMark
917 // Format of the _name_and_id is as follows:
918 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
</pre>
<hr />
<pre>
920 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
921 const char* ClassLoaderData::loader_name_and_id() const {
922   if (_class_loader_klass == NULL) {
923     return &quot;&#39;&quot; BOOTSTRAP_LOADER_NAME &quot;&#39;&quot;;
924   } else if (_name_and_id != NULL) {
925     return _name_and_id-&gt;as_C_string();
926   } else {
927     // May be called in a race before _name_and_id is initialized.
928     return _class_loader_klass-&gt;external_name();
929   }
930 }
931 
932 void ClassLoaderData::print_value_on(outputStream* out) const {
933   if (!is_unloading() &amp;&amp; class_loader() != NULL) {
934     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; for instance &quot;, p2i(this));
935     class_loader()-&gt;print_value_on(out);  // includes loader_name_and_id() and address of class loader instance
936   } else {
937     // loader data: 0xsomeaddr of &#39;bootstrap&#39;
938     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; of %s&quot;, p2i(this), loader_name_and_id());
939   }
<span class="line-modified">940   if (is_unsafe_anonymous()) {</span>
<span class="line-modified">941     out-&gt;print(&quot; unsafe anonymous&quot;);</span>
942   }
943 }
944 
945 void ClassLoaderData::print_value() const { print_value_on(tty); }
946 
947 #ifndef PRODUCT
948 void ClassLoaderData::print_on(outputStream* out) const {
949   out-&gt;print(&quot;ClassLoaderData CLD: &quot; PTR_FORMAT &quot;, loader: &quot; PTR_FORMAT &quot;, loader_klass: %s {&quot;,
950               p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
<span class="line-modified">951   if (is_unsafe_anonymous()) out-&gt;print(&quot; unsafe anonymous&quot;);</span>
952   if (claimed()) out-&gt;print(&quot; claimed&quot;);
953   if (is_unloading()) out-&gt;print(&quot; unloading&quot;);
954   out-&gt;print(&quot; metaspace: &quot; INTPTR_FORMAT, p2i(metaspace_or_null()));
955 
956   if (_jmethod_ids != NULL) {
957     Method::print_jmethod_ids(this, out);
958   }
959   out-&gt;print(&quot; handles count %d&quot;, _handles.count());
960   out-&gt;print(&quot; dependencies %d&quot;, _dependency_count);
961   out-&gt;print_cr(&quot;}&quot;);
962 }
963 #endif // PRODUCT
964 
965 void ClassLoaderData::print() const { print_on(tty); }
966 
967 void ClassLoaderData::verify() {
968   assert_locked_or_safepoint(_metaspace_lock);
969   oop cl = class_loader();
970 
<span class="line-modified">971   guarantee(this == class_loader_data(cl) || is_unsafe_anonymous(), &quot;Must be the same&quot;);</span>
<span class="line-modified">972   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || is_unsafe_anonymous(), &quot;must be&quot;);</span>
973 
974   // Verify the integrity of the allocated space.
975   if (metaspace_or_null() != NULL) {
976     metaspace_or_null()-&gt;verify();
977   }
978 
979   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
980     guarantee(k-&gt;class_loader_data() == this, &quot;Must be the same&quot;);
981     k-&gt;verify();
982     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
983   }
984 }
985 
986 bool ClassLoaderData::contains_klass(Klass* klass) {
987   // Lock-free access requires load_acquire
988   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
989     if (k == klass) return true;
990   }
991   return false;
992 }
</pre>
</td>
<td>
<hr />
<pre>
  1  /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
110     if (cl_instance_name != NULL &amp;&amp; cl_instance_name[0] != &#39;\0&#39;) {
111       _name = SymbolTable::new_symbol(cl_instance_name);
112     }
113   }
114 
115   // Obtain the class loader&#39;s name and identity hash.  If the class loader&#39;s
116   // name was not explicitly set during construction, the class loader&#39;s name and id
117   // will be set to the qualified class name of the class loader along with its
118   // identity hash.
119   // If for some reason the ClassLoader&#39;s constructor has not been run, instead of
120   // leaving the _name_and_id field null, fall back to the external qualified class
121   // name.  Thus CLD&#39;s _name_and_id field should never have a null value.
122   oop cl_name_and_id = java_lang_ClassLoader::nameAndId(class_loader());
123   const char* cl_instance_name_and_id =
124                   (cl_name_and_id == NULL) ? _class_loader_klass-&gt;external_name() :
125                                              java_lang_String::as_utf8_string(cl_name_and_id);
126   assert(cl_instance_name_and_id != NULL &amp;&amp; cl_instance_name_and_id[0] != &#39;\0&#39;, &quot;class loader has no name and id&quot;);
127   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id);
128 }
129 
<span class="line-modified">130 ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool has_class_mirror_holder) :</span>
131   _metaspace(NULL),
132   _metaspace_lock(new Mutex(Mutex::leaf+1, &quot;Metaspace allocation lock&quot;, true,
133                             Mutex::_safepoint_check_never)),
<span class="line-modified">134   _unloading(false), _has_class_mirror_holder(has_class_mirror_holder),</span>
135   _modified_oops(true), _accumulated_modified_oops(false),
136   // An unsafe anonymous class loader data doesn&#39;t have anything to keep
137   // it from being unloaded during parsing of the unsafe anonymous class.
138   // The null-class-loader should always be kept alive.
<span class="line-modified">139   _keep_alive((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),</span>
140   _claim(0),
141   _handles(),
142   _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),
143   _jmethod_ids(NULL),
144   _deallocate_list(NULL),
145   _next(NULL),
146   _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {
147 
148   if (!h_class_loader.is_null()) {
149     _class_loader = _handles.add(h_class_loader());
150     _class_loader_klass = h_class_loader-&gt;klass();
151     initialize_name(h_class_loader);
152   }
153 
<span class="line-modified">154   if (!has_class_mirror_holder) {</span>
<span class="line-modified">155     // The holder is initialized later for non-strong hidden classes and unsafe anonymous classes,</span>
<span class="line-modified">156     // and before calling anything that call class_loader().</span>
157     initialize_holder(h_class_loader);
158 
<span class="line-modified">159     // A ClassLoaderData created solely for a non-strong hidden class or unsafe anonymous class should</span>
<span class="line-modified">160     // never have a ModuleEntryTable or PackageEntryTable created for it. The defining package</span>
161     // and module for an unsafe anonymous class will be found in its host class.
162     _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);
163     if (h_class_loader.is_null()) {
164       // Create unnamed module for boot loader
165       _unnamed_module = ModuleEntry::create_boot_unnamed_module(this);
166     } else {
167       // Create unnamed module for all other loaders
168       _unnamed_module = ModuleEntry::create_unnamed_module(this);
169     }
170     _dictionary = create_dictionary();
171   }
172 
173   NOT_PRODUCT(_dependency_count = 0); // number of class loader dependencies
174 
175   JFR_ONLY(INIT_ID(this);)
176 }
177 
178 ClassLoaderData::ChunkedHandleList::~ChunkedHandleList() {
179   Chunk* c = _head;
180   while (c != NULL) {
</pre>
<hr />
<pre>
275     int new_claim = old_claim &amp; ~claim;
276     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
277       return;
278     }
279   }
280 }
281 
282 bool ClassLoaderData::try_claim(int claim) {
283   for (;;) {
284     int old_claim = Atomic::load(&amp;_claim);
285     if ((old_claim &amp; claim) == claim) {
286       return false;
287     }
288     int new_claim = old_claim | claim;
289     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
290       return true;
291     }
292   }
293 }
294 
<span class="line-modified">295 // Weak hidden and unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive</span>
296 // while the class is being parsed, and if the class appears on the module fixup list.
<span class="line-modified">297 // Due to the uniqueness that no other class shares the hidden or unsafe anonymous class&#39; name or</span>
<span class="line-modified">298 // ClassLoaderData, no other non-GC thread has knowledge of the hidden or unsafe anonymous class while</span>
299 // it is being defined, therefore _keep_alive is not volatile or atomic.
300 void ClassLoaderData::inc_keep_alive() {
<span class="line-modified">301   if (has_class_mirror_holder()) {</span>
302     assert(_keep_alive &gt; 0, &quot;Invalid keep alive increment count&quot;);
303     _keep_alive++;
304   }
305 }
306 
307 void ClassLoaderData::dec_keep_alive() {
<span class="line-modified">308   if (has_class_mirror_holder()) {</span>
309     assert(_keep_alive &gt; 0, &quot;Invalid keep alive decrement count&quot;);
310     _keep_alive--;
311   }
312 }
313 
314 void ClassLoaderData::oops_do(OopClosure* f, int claim_value, bool clear_mod_oops) {
315   if (claim_value != ClassLoaderData::_claim_none &amp;&amp; !try_claim(claim_value)) {
316     return;
317   }
318 
319   // Only clear modified_oops after the ClassLoaderData is claimed.
320   if (clear_mod_oops) {
321     clear_modified_oops();
322   }
323 
324   _handles.oops_do(f);
325 }
326 
327 void ClassLoaderData::classes_do(KlassClosure* klass_closure) {
328   // Lock-free access requires load_acquire
</pre>
<hr />
<pre>
404   assert_locked_or_safepoint(Module_lock);
405   if (_packages != NULL) {
406     for (int i = 0; i &lt; _packages-&gt;table_size(); i++) {
407       for (PackageEntry* entry = _packages-&gt;bucket(i);
408            entry != NULL;
409            entry = entry-&gt;next()) {
410         f(entry);
411       }
412     }
413   }
414 }
415 
416 void ClassLoaderData::record_dependency(const Klass* k) {
417   assert(k != NULL, &quot;invariant&quot;);
418 
419   ClassLoaderData * const from_cld = this;
420   ClassLoaderData * const to_cld = k-&gt;class_loader_data();
421 
422   // Do not need to record dependency if the dependency is to a class whose
423   // class loader data is never freed.  (i.e. the dependency&#39;s class loader
<span class="line-modified">424   // is one of the three builtin class loaders and the dependency&#39;s class</span>
<span class="line-modified">425   // loader data has a ClassLoader holder, not a Class holder.)</span>
426   if (to_cld-&gt;is_permanent_class_loader_data()) {
427     return;
428   }
429 
430   oop to;
<span class="line-modified">431   if (to_cld-&gt;has_class_mirror_holder()) {</span>
<span class="line-modified">432     // Just return if a non-strong hidden class or unsafe anonymous class is attempting to record a dependency</span>
<span class="line-modified">433     // to itself.  (Note that every non-strong hidden class or unsafe anonymous class has its own unique class</span>
434     // loader data.)
435     if (to_cld == from_cld) {
436       return;
437     }
<span class="line-modified">438     // Hidden and unsafe anonymous class dependencies are through the mirror.</span>
439     to = k-&gt;java_mirror();
440   } else {
441     to = to_cld-&gt;class_loader();
442     oop from = from_cld-&gt;class_loader();
443 
444     // Just return if this dependency is to a class with the same or a parent
445     // class_loader.
446     if (from == to || java_lang_ClassLoader::isAncestor(from, to)) {
447       return; // this class loader is in the parent list, no need to add it.
448     }
449   }
450 
451   // It&#39;s a dependency we won&#39;t find through GC, add it.
452   if (!_handles.contains(to)) {
453     NOT_PRODUCT(Atomic::inc(&amp;_dependency_count));
454     LogTarget(Trace, class, loader, data) lt;
455     if (lt.is_enabled()) {
456       ResourceMark rm;
457       LogStream ls(lt);
458       ls.print(&quot;adding dependency from &quot;);
</pre>
<hr />
<pre>
568   if (modules == NULL) {
569     MutexLocker m1(Module_lock);
570     // Check if _modules got allocated while we were waiting for this lock.
571     if ((modules = _modules) == NULL) {
572       modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);
573 
574       {
575         MutexLocker m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);
576         // Ensure _modules is stable, since it is examined without a lock
577         Atomic::release_store(&amp;_modules, modules);
578       }
579     }
580   }
581   return modules;
582 }
583 
584 const int _boot_loader_dictionary_size    = 1009;
585 const int _default_loader_dictionary_size = 107;
586 
587 Dictionary* ClassLoaderData::create_dictionary() {
<span class="line-modified">588   assert(!has_class_mirror_holder(), &quot;class mirror holder cld does not have a dictionary&quot;);</span>
589   int size;
590   bool resizable = false;
591   if (_the_null_class_loader_data == NULL) {
592     size = _boot_loader_dictionary_size;
593     resizable = true;
594   } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
595     size = 1;  // there&#39;s only one class in relection class loader and no initiated classes
596   } else if (is_system_class_loader_data()) {
597     size = _boot_loader_dictionary_size;
598     resizable = true;
599   } else {
600     size = _default_loader_dictionary_size;
601     resizable = true;
602   }
603   if (!DynamicallyResizeSystemDictionaries || DumpSharedSpaces) {
604     resizable = false;
605   }
606   return new Dictionary(this, size, resizable);
607 }
608 
</pre>
<hr />
<pre>
614   // to get notified about this potential resurrection, otherwise the marking
615   // might not find the object.
616   if (!_holder.is_null()) {  // NULL class_loader
617     return _holder.resolve();
618   } else {
619     return NULL;
620   }
621 }
622 
623 // Let the GC read the holder without keeping it alive.
624 oop ClassLoaderData::holder_no_keepalive() const {
625   if (!_holder.is_null()) {  // NULL class_loader
626     return _holder.peek();
627   } else {
628     return NULL;
629   }
630 }
631 
632 // Unloading support
633 bool ClassLoaderData::is_alive() const {
<span class="line-modified">634   bool alive = keep_alive()         // null class loader and incomplete non-strong hidden class or unsafe anonymous class.</span>
635       || (_holder.peek() != NULL);  // and not cleaned by the GC weak handle processing.
636 
637   return alive;
638 }
639 
640 class ReleaseKlassClosure: public KlassClosure {
641 private:
642   size_t  _instance_class_released;
643   size_t  _array_class_released;
644 public:
645   ReleaseKlassClosure() : _instance_class_released(0), _array_class_released(0) { }
646 
647   size_t instance_class_released() const { return _instance_class_released; }
648   size_t array_class_released()    const { return _array_class_released;    }
649 
650   void do_klass(Klass* k) {
651     if (k-&gt;is_array_klass()) {
652       _array_class_released ++;
653     } else {
654       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
</pre>
<hr />
<pre>
712   }
713   // Delete lock
714   delete _metaspace_lock;
715 
716   // Delete free list
717   if (_deallocate_list != NULL) {
718     delete _deallocate_list;
719   }
720 
721   // Decrement refcounts of Symbols if created.
722   if (_name != NULL) {
723     _name-&gt;decrement_refcount();
724   }
725   if (_name_and_id != NULL) {
726     _name_and_id-&gt;decrement_refcount();
727   }
728 }
729 
730 // Returns true if this class loader data is for the app class loader
731 // or a user defined system class loader.  (Note that the class loader
<span class="line-modified">732 // data may have a Class holder.)</span>
733 bool ClassLoaderData::is_system_class_loader_data() const {
734   return SystemDictionary::is_system_class_loader(class_loader());
735 }
736 
737 // Returns true if this class loader data is for the platform class loader.
<span class="line-modified">738 // (Note that the class loader data may have a Class holder.)</span>
739 bool ClassLoaderData::is_platform_class_loader_data() const {
740   return SystemDictionary::is_platform_class_loader(class_loader());
741 }
742 
743 // Returns true if the class loader for this class loader data is one of
744 // the 3 builtin (boot application/system or platform) class loaders,
745 // including a user-defined system class loader.  Note that if the class
<span class="line-modified">746 // loader data is for a non-strong hidden class or unsafe anonymous class then it may</span>
<span class="line-modified">747 // get freed by a GC even if its class loader is one of these loaders.</span>
748 bool ClassLoaderData::is_builtin_class_loader_data() const {
749   return (is_boot_class_loader_data() ||
750           SystemDictionary::is_system_class_loader(class_loader()) ||
751           SystemDictionary::is_platform_class_loader(class_loader()));
752 }
753 
754 // Returns true if this class loader data is a class loader data
755 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
<span class="line-modified">756 // class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.</span>
757 bool ClassLoaderData::is_permanent_class_loader_data() const {
<span class="line-modified">758   return is_builtin_class_loader_data() &amp;&amp; !has_class_mirror_holder();</span>
759 }
760 
761 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
762   // If the metaspace has not been allocated, create a new one.  Might want
763   // to create smaller arena for Reflection class loaders also.
764   // The reason for the delayed allocation is because some class loaders are
765   // simply for delegating with no metadata of their own.
766   // Lock-free access requires load_acquire.
767   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);
768   if (metaspace == NULL) {
769     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);
770     // Check if _metaspace got allocated while we were waiting for this lock.
771     if ((metaspace = _metaspace) == NULL) {
772       if (this == the_null_class_loader_data()) {
773         assert (class_loader() == NULL, &quot;Must be&quot;);
774         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
<span class="line-modified">775       } else if (has_class_mirror_holder()) {</span>
<span class="line-modified">776         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ClassMirrorHolderMetaspaceType);</span>
777       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
778         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
779       } else {
780         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
781       }
782       // Ensure _metaspace is stable, since it is examined without a lock
783       Atomic::release_store(&amp;_metaspace, metaspace);
784     }
785   }
786   return metaspace;
787 }
788 
789 OopHandle ClassLoaderData::add_handle(Handle h) {
790   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
791   record_modified_oops();
792   return OopHandle(_handles.add(h()));
793 }
794 
795 void ClassLoaderData::remove_handle(OopHandle h) {
796   assert(!is_unloading(), &quot;Do not remove a handle for a CLD that is unloading&quot;);
</pre>
<hr />
<pre>
877   if (_deallocate_list == NULL) {
878     return;
879   }
880   // Go backwards because this removes entries that are freed.
881   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
882     Metadata* m = _deallocate_list-&gt;at(i);
883     _deallocate_list-&gt;remove_at(i);
884     if (m-&gt;is_constantPool()) {
885       ((ConstantPool*)m)-&gt;release_C_heap_structures();
886     } else if (m-&gt;is_klass()) {
887       InstanceKlass* ik = (InstanceKlass*)m;
888       // also releases ik-&gt;constants() C heap memory
889       InstanceKlass::release_C_heap_structures(ik);
890       // Remove the class so unloading events aren&#39;t triggered for
891       // this class (scratch or error class) in do_unloading().
892       remove_class(ik);
893     }
894   }
895 }
896 
<span class="line-modified">897 // These CLDs are to contain non-strong hidden classes or unsafe anonymous classes used for JSR292</span>
<span class="line-modified">898 ClassLoaderData* ClassLoaderData::has_class_mirror_holder_cld(Handle loader) {</span>
899   // Add a new class loader data to the graph.
900   return ClassLoaderDataGraph::add(loader, true);
901 }
902 
903 // Caller needs ResourceMark
904 // If the class loader&#39;s _name has not been explicitly set, the class loader&#39;s
905 // qualified class name is returned.
906 const char* ClassLoaderData::loader_name() const {
907    if (_class_loader_klass == NULL) {
908      return BOOTSTRAP_LOADER_NAME;
909    } else if (_name != NULL) {
910      return _name-&gt;as_C_string();
911    } else {
912      return _class_loader_klass-&gt;external_name();
913    }
914 }
915 
916 // Caller needs ResourceMark
917 // Format of the _name_and_id is as follows:
918 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
</pre>
<hr />
<pre>
920 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
921 const char* ClassLoaderData::loader_name_and_id() const {
922   if (_class_loader_klass == NULL) {
923     return &quot;&#39;&quot; BOOTSTRAP_LOADER_NAME &quot;&#39;&quot;;
924   } else if (_name_and_id != NULL) {
925     return _name_and_id-&gt;as_C_string();
926   } else {
927     // May be called in a race before _name_and_id is initialized.
928     return _class_loader_klass-&gt;external_name();
929   }
930 }
931 
932 void ClassLoaderData::print_value_on(outputStream* out) const {
933   if (!is_unloading() &amp;&amp; class_loader() != NULL) {
934     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; for instance &quot;, p2i(this));
935     class_loader()-&gt;print_value_on(out);  // includes loader_name_and_id() and address of class loader instance
936   } else {
937     // loader data: 0xsomeaddr of &#39;bootstrap&#39;
938     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; of %s&quot;, p2i(this), loader_name_and_id());
939   }
<span class="line-modified">940   if (_has_class_mirror_holder) {</span>
<span class="line-modified">941     out-&gt;print(&quot; has a class holder&quot;);</span>
942   }
943 }
944 
945 void ClassLoaderData::print_value() const { print_value_on(tty); }
946 
947 #ifndef PRODUCT
948 void ClassLoaderData::print_on(outputStream* out) const {
949   out-&gt;print(&quot;ClassLoaderData CLD: &quot; PTR_FORMAT &quot;, loader: &quot; PTR_FORMAT &quot;, loader_klass: %s {&quot;,
950               p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
<span class="line-modified">951   if (has_class_mirror_holder()) out-&gt;print(&quot; has a class holder&quot;);</span>
952   if (claimed()) out-&gt;print(&quot; claimed&quot;);
953   if (is_unloading()) out-&gt;print(&quot; unloading&quot;);
954   out-&gt;print(&quot; metaspace: &quot; INTPTR_FORMAT, p2i(metaspace_or_null()));
955 
956   if (_jmethod_ids != NULL) {
957     Method::print_jmethod_ids(this, out);
958   }
959   out-&gt;print(&quot; handles count %d&quot;, _handles.count());
960   out-&gt;print(&quot; dependencies %d&quot;, _dependency_count);
961   out-&gt;print_cr(&quot;}&quot;);
962 }
963 #endif // PRODUCT
964 
965 void ClassLoaderData::print() const { print_on(tty); }
966 
967 void ClassLoaderData::verify() {
968   assert_locked_or_safepoint(_metaspace_lock);
969   oop cl = class_loader();
970 
<span class="line-modified">971   guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), &quot;Must be the same&quot;);</span>
<span class="line-modified">972   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), &quot;must be&quot;);</span>
973 
974   // Verify the integrity of the allocated space.
975   if (metaspace_or_null() != NULL) {
976     metaspace_or_null()-&gt;verify();
977   }
978 
979   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
980     guarantee(k-&gt;class_loader_data() == this, &quot;Must be the same&quot;);
981     k-&gt;verify();
982     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
983   }
984 }
985 
986 bool ClassLoaderData::contains_klass(Klass* klass) {
987   // Lock-free access requires load_acquire
988   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
989     if (k == klass) return true;
990   }
991   return false;
992 }
</pre>
</td>
</tr>
</table>
<center><a href="classLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  97 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  98 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  99 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 100 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 101 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 102 
 103 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 104 
 105 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 106                                                           =  { NULL /*, NULL...*/ };
 107 
 108 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 109 
 110 oop         SystemDictionary::_java_system_loader         =  NULL;
 111 oop         SystemDictionary::_java_platform_loader       =  NULL;
 112 
 113 // Default ProtectionDomainCacheSize value
 114 
 115 const int defaultProtectionDomainCacheSize = 1009;
 116 








































 117 // ----------------------------------------------------------------------------
 118 // Java-level SystemLoader and PlatformLoader
 119 
 120 oop SystemDictionary::java_system_loader() {
 121   return _java_system_loader;
 122 }
 123 
 124 oop SystemDictionary::java_platform_loader() {
 125   return _java_platform_loader;
 126 }
 127 
 128 void SystemDictionary::compute_java_loaders(TRAPS) {
 129   JavaValue result(T_OBJECT);
 130   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 131   JavaCalls::call_static(&amp;result,
 132                          class_loader_klass,
 133                          vmSymbols::getSystemClassLoader_name(),
 134                          vmSymbols::void_classloader_signature(),
 135                          CHECK);
 136 
</pre>
<hr />
<pre>
 852               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 853             }
 854           }
 855         }
 856       }
 857       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 858       // case 4: parallelCapable: allow competing threads to try
 859       // LOAD_INSTANCE in parallel
 860 
 861       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 862         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 863         load_instance_added = true;
 864         // For class loaders that do not acquire the classloader object lock,
 865         // if they did not catch another thread holding LOAD_INSTANCE,
 866         // need a check analogous to the acquire ObjectLocker/find_class
 867         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 868         // one final check if the load has already completed
 869         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 870         InstanceKlass* check = find_class(d_hash, name, dictionary);
 871         if (check != NULL) {
<span class="line-modified"> 872         // Klass is already loaded, so return it after checking/adding protection domain</span>
 873           k = check;
 874           class_has_been_loaded = true;
 875         }
 876       }
 877     }
 878 
 879     // must throw error outside of owning lock
 880     if (throw_circularity_error) {
 881       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 882       ResourceMark rm(THREAD);
 883       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 884     }
 885 
 886     if (!class_has_been_loaded) {
 887 
 888       // Do actual loading
 889       k = load_instance_class(name, class_loader, THREAD);
 890 
 891       // If everything was OK (no exceptions, no null return value), and
 892       // class_loader is NOT the defining loader, do a little more bookkeeping.
</pre>
<hr />
<pre>
1012     // side-effect of this call
1013     SignatureStream ss(class_name, false);
1014     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1015     BasicType t = ss.type();
1016     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
1017       k = Universe::typeArrayKlassObj(t);
1018     } else {
1019       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1020     }
1021     if (k != NULL) {
1022       k = k-&gt;array_klass_or_null(ndims);
1023     }
1024   } else {
1025     k = find(class_name, class_loader, protection_domain, THREAD);
1026   }
1027   return k;
1028 }
1029 
1030 // Note: this method is much like resolve_from_stream, but
1031 // does not publish the classes via the SystemDictionary.
<span class="line-modified">1032 // Handles unsafe_DefineAnonymousClass and redefineclasses</span>
<span class="line-modified">1033 // RedefinedClasses do not add to the class hierarchy</span>
1034 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1035                                               Handle class_loader,
<span class="line-modified">1036                                               Handle protection_domain,</span>
<span class="line-removed">1037                                               ClassFileStream* st,</span>
<span class="line-removed">1038                                               const InstanceKlass* unsafe_anonymous_host,</span>
1039                                               GrowableArray&lt;Handle&gt;* cp_patches,
1040                                               TRAPS) {
1041 
1042   EventClassLoad class_load_start_event;
1043 
1044   ClassLoaderData* loader_data;
<span class="line-modified">1045   if (unsafe_anonymous_host != NULL) {</span>
<span class="line-modified">1046     // Create a new CLD for an unsafe anonymous class, that uses the same class loader</span>
<span class="line-modified">1047     // as the unsafe_anonymous_host</span>
<span class="line-modified">1048     guarantee(unsafe_anonymous_host-&gt;class_loader() == class_loader(), &quot;should be the same&quot;);</span>
<span class="line-modified">1049     loader_data = ClassLoaderData::unsafe_anonymous_class_loader_data(class_loader);</span>














1050   } else {
1051     loader_data = ClassLoaderData::class_loader_data(class_loader());
1052   }
1053 
1054   assert(st != NULL, &quot;invariant&quot;);
1055   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1056 
1057   // Parse stream and create a klass.
1058   // Note that we do this even though this klass might
1059   // already be present in the SystemDictionary, otherwise we would not
1060   // throw potential ClassFormatErrors.
1061 
1062   InstanceKlass* k = KlassFactory::create_from_stream(st,
1063                                                       class_name,
1064                                                       loader_data,
<span class="line-modified">1065                                                       protection_domain,</span>
<span class="line-removed">1066                                                       unsafe_anonymous_host,</span>
<span class="line-removed">1067                                                       cp_patches,</span>
1068                                                       CHECK_NULL);
1069 
<span class="line-modified">1070   if (unsafe_anonymous_host != NULL &amp;&amp; k != NULL) {</span>
<span class="line-modified">1071     // Unsafe anonymous classes must update ClassLoaderData holder (was unsafe_anonymous_host loader)</span>
<span class="line-modified">1072     // so that they can be unloaded when the mirror is no longer referenced.</span>
<span class="line-modified">1073     k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));</span>



1074 
1075     {
1076       MutexLocker mu_r(THREAD, Compile_lock);
1077 
1078       // Add to class hierarchy, initialize vtables, and do possible
1079       // deoptimizations.
1080       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1081       // But, do not add to dictionary.
1082     }
1083 
1084     // Rewrite and patch constant pool here.
1085     k-&gt;link_class(CHECK_NULL);
<span class="line-modified">1086     if (cp_patches != NULL) {</span>
<span class="line-modified">1087       k-&gt;constants()-&gt;patch_resolved_references(cp_patches);</span>
1088     }
1089 
1090     // If it&#39;s anonymous, initialize it now, since nobody else will.
<span class="line-modified">1091     k-&gt;eager_initialize(CHECK_NULL);</span>


1092 
1093     // notify jvmti
1094     if (JvmtiExport::should_post_class_load()) {
1095         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1096         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1097     }
1098     if (class_load_start_event.should_commit()) {
1099       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1100     }
1101   }
<span class="line-modified">1102   assert(unsafe_anonymous_host != NULL || NULL == cp_patches,</span>
1103          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1104 
1105   return k;
1106 }
1107 
1108 // Add a klass to the system from a stream (called by jni_DefineClass and
1109 // JVM_DefineClass).
1110 // Note: class_name can be NULL. In that case we do not know the name of
1111 // the class until we have parsed the stream.
1112 
1113 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1114                                                      Handle class_loader,
1115                                                      Handle protection_domain,
1116                                                      ClassFileStream* st,
1117                                                      TRAPS) {
1118 
1119   HandleMark hm(THREAD);
1120 
1121   // Classloaders that support parallelism, e.g. bootstrap classloader,
1122   // do not acquire lock here
</pre>
<hr />
<pre>
1137   // Parse the stream and create a klass.
1138   // Note that we do this even though this klass might
1139   // already be present in the SystemDictionary, otherwise we would not
1140   // throw potential ClassFormatErrors.
1141  InstanceKlass* k = NULL;
1142 
1143 #if INCLUDE_CDS
1144   if (!DumpSharedSpaces) {
1145     k = SystemDictionaryShared::lookup_from_stream(class_name,
1146                                                    class_loader,
1147                                                    protection_domain,
1148                                                    st,
1149                                                    CHECK_NULL);
1150   }
1151 #endif
1152 
1153   if (k == NULL) {
1154     if (st-&gt;buffer() == NULL) {
1155       return NULL;
1156     }
<span class="line-modified">1157     k = KlassFactory::create_from_stream(st,</span>
<span class="line-modified">1158                                          class_name,</span>
<span class="line-removed">1159                                          loader_data,</span>
<span class="line-removed">1160                                          protection_domain,</span>
<span class="line-removed">1161                                          NULL, // unsafe_anonymous_host</span>
<span class="line-removed">1162                                          NULL, // cp_patches</span>
<span class="line-removed">1163                                          CHECK_NULL);</span>
1164   }
1165 
1166   assert(k != NULL, &quot;no klass created&quot;);
1167   Symbol* h_name = k-&gt;name();
1168   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1169 
1170   // Add class just loaded
1171   // If a class loader supports parallel classloading handle parallel define requests
1172   // find_or_define_instance_class may return a different InstanceKlass
1173   if (is_parallelCapable(class_loader)) {
1174     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1175     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1176       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1177       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1178       loader_data-&gt;add_to_deallocate_list(k);
1179       k = defined_k;
1180     }
1181   } else {
1182     define_instance_class(k, THREAD);
1183   }
</pre>
<hr />
<pre>
1387     HandleMark hm(THREAD);
1388     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1389     check_loader_lock_contention(lockObject, THREAD);
1390     ObjectLocker ol(lockObject, THREAD, true);
1391     // prohibited package check assumes all classes loaded from archive call
1392     // restore_unshareable_info which calls ik-&gt;set_package()
1393     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1394   }
1395 
1396   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1397   return ik;
1398 }
1399 
1400 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1401   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1402 
1403   // For boot loader, ensure that GetSystemPackage knows that a class in this
1404   // package was loaded.
1405   if (loader_data-&gt;is_the_null_class_loader_data()) {
1406     int path_index = ik-&gt;shared_classpath_index();
<span class="line-modified">1407     ClassLoader::add_package(ik, path_index, THREAD);</span>
1408   }
1409 
1410   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1411     // Only dump the classes that can be stored into CDS archive
1412     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1413       ResourceMark rm(THREAD);
1414       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1415       classlist_file-&gt;flush();
1416     }
1417   }
1418 
1419   // notify a class loaded from shared object
1420   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1421 
1422   ik-&gt;set_has_passed_fingerprint_check(false);
1423   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1424     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1425     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1426     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1427       // This class matches with a class saved in an AOT library
</pre>
<hr />
<pre>
2357   resolution_errors()-&gt;delete_entry(pool);
2358 }
2359 
2360 // Lookup resolution error table. Returns error if found, otherwise NULL.
2361 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2362                                                 Symbol** message) {
2363   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2364   int index = resolution_errors()-&gt;hash_to_index(hash);
2365   {
2366     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2367     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2368     if (entry != NULL) {
2369       *message = entry-&gt;message();
2370       return entry-&gt;error();
2371     } else {
2372       return NULL;
2373     }
2374   }
2375 }
2376 




































2377 
2378 // Signature constraints ensure that callers and callees agree about
2379 // the meaning of type names in their signatures.  This routine is the
2380 // intake for constraints.  It collects them from several places:
2381 //
2382 //  * LinkResolver::resolve_method (if check_access is true) requires
2383 //    that the resolving class (the caller) and the defining class of
2384 //    the resolved method (the callee) agree on each type in the
2385 //    method&#39;s signature.
2386 //
2387 //  * LinkResolver::resolve_interface_method performs exactly the same
2388 //    checks.
2389 //
2390 //  * LinkResolver::resolve_field requires that the constant pool
2391 //    attempting to link to a field agree with the field&#39;s defining
2392 //    class about the type of the field signature.
2393 //
2394 //  * klassVtable::initialize_vtable requires that, when a class
2395 //    overrides a vtable entry allocated by a superclass, that the
2396 //    overriding method (i.e., the callee) agree with the superclass
</pre>
<hr />
<pre>
2486     }
2487   }
2488 
2489   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2490   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2491          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2492          &quot;MH intrinsic invariant&quot;);
2493   return spe-&gt;method();
2494 }
2495 
2496 // Helper for unpacking the return value from linkMethod and linkCallSite.
2497 static Method* unpack_method_and_appendix(Handle mname,
2498                                           Klass* accessing_klass,
2499                                           objArrayHandle appendix_box,
2500                                           Handle* appendix_result,
2501                                           TRAPS) {
2502   if (mname.not_null()) {
2503     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2504     if (m != NULL) {
2505       oop appendix = appendix_box-&gt;obj_at(0);
<span class="line-modified">2506       if (TraceMethodHandles) {</span>
<span class="line-modified">2507     #ifndef PRODUCT</span>
<span class="line-modified">2508         ttyLocker ttyl;</span>
<span class="line-modified">2509         tty-&gt;print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));</span>
<span class="line-modified">2510         m-&gt;print();</span>
<span class="line-modified">2511         if (appendix != NULL) { tty-&gt;print(&quot;appendix = &quot;); appendix-&gt;print(); }</span>
<span class="line-modified">2512         tty-&gt;cr();</span>
<span class="line-modified">2513     #endif //PRODUCT</span>
2514       }

2515       (*appendix_result) = Handle(THREAD, appendix);
2516       // the target is stored in the cpCache and if a reference to this
2517       // MemberName is dropped we need a way to make sure the
2518       // class_loader containing this method is kept alive.
2519       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2520       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2521       this_key-&gt;record_dependency(m-&gt;method_holder());
2522       return mh();
2523     }
2524   }
2525   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2526 }
2527 
2528 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2529                                                      Symbol* name,
2530                                                      Symbol* signature,
2531                                                           Klass* accessing_klass,
2532                                                           Handle *appendix_result,
2533                                                           TRAPS) {
2534   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  97 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  98 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  99 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 100 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 101 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 102 
 103 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 104 
 105 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 106                                                           =  { NULL /*, NULL...*/ };
 107 
 108 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 109 
 110 oop         SystemDictionary::_java_system_loader         =  NULL;
 111 oop         SystemDictionary::_java_platform_loader       =  NULL;
 112 
 113 // Default ProtectionDomainCacheSize value
 114 
 115 const int defaultProtectionDomainCacheSize = 1009;
 116 
<span class="line-added"> 117 ClassLoadInfo::ClassLoadInfo() {</span>
<span class="line-added"> 118   _protection_domain = Handle();</span>
<span class="line-added"> 119   _unsafe_anonymous_host = NULL;</span>
<span class="line-added"> 120   _cp_patches = NULL;</span>
<span class="line-added"> 121   _class_hidden_info._dynamic_nest_host = NULL;</span>
<span class="line-added"> 122   _class_hidden_info._class_data = Handle();</span>
<span class="line-added"> 123   _is_hidden = false;</span>
<span class="line-added"> 124   _is_strong_hidden = false;</span>
<span class="line-added"> 125   _can_access_vm_annotations = false;</span>
<span class="line-added"> 126 }</span>
<span class="line-added"> 127 </span>
<span class="line-added"> 128 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {</span>
<span class="line-added"> 129   _protection_domain = protection_domain;</span>
<span class="line-added"> 130   _unsafe_anonymous_host = NULL;</span>
<span class="line-added"> 131   _cp_patches = NULL;</span>
<span class="line-added"> 132   _class_hidden_info._dynamic_nest_host = NULL;</span>
<span class="line-added"> 133   _class_hidden_info._class_data = Handle();</span>
<span class="line-added"> 134   _is_hidden = false;</span>
<span class="line-added"> 135   _is_strong_hidden = false;</span>
<span class="line-added"> 136   _can_access_vm_annotations = false;</span>
<span class="line-added"> 137 }</span>
<span class="line-added"> 138 </span>
<span class="line-added"> 139 ClassLoadInfo::ClassLoadInfo(Handle protection_domain,</span>
<span class="line-added"> 140                              const InstanceKlass* unsafe_anonymous_host,</span>
<span class="line-added"> 141                              GrowableArray&lt;Handle&gt;* cp_patches,</span>
<span class="line-added"> 142                              InstanceKlass* dynamic_nest_host,</span>
<span class="line-added"> 143                              Handle class_data,</span>
<span class="line-added"> 144                              bool is_hidden,</span>
<span class="line-added"> 145                              bool is_strong_hidden,</span>
<span class="line-added"> 146                              bool can_access_vm_annotations) {</span>
<span class="line-added"> 147   _protection_domain = protection_domain;</span>
<span class="line-added"> 148   _unsafe_anonymous_host = unsafe_anonymous_host;</span>
<span class="line-added"> 149   _cp_patches = cp_patches;</span>
<span class="line-added"> 150   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;</span>
<span class="line-added"> 151   _class_hidden_info._class_data = class_data;</span>
<span class="line-added"> 152   _is_hidden = is_hidden;</span>
<span class="line-added"> 153   _is_strong_hidden = is_strong_hidden;</span>
<span class="line-added"> 154   _can_access_vm_annotations = can_access_vm_annotations;</span>
<span class="line-added"> 155 }</span>
<span class="line-added"> 156 </span>
 157 // ----------------------------------------------------------------------------
 158 // Java-level SystemLoader and PlatformLoader
 159 
 160 oop SystemDictionary::java_system_loader() {
 161   return _java_system_loader;
 162 }
 163 
 164 oop SystemDictionary::java_platform_loader() {
 165   return _java_platform_loader;
 166 }
 167 
 168 void SystemDictionary::compute_java_loaders(TRAPS) {
 169   JavaValue result(T_OBJECT);
 170   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 171   JavaCalls::call_static(&amp;result,
 172                          class_loader_klass,
 173                          vmSymbols::getSystemClassLoader_name(),
 174                          vmSymbols::void_classloader_signature(),
 175                          CHECK);
 176 
</pre>
<hr />
<pre>
 892               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 893             }
 894           }
 895         }
 896       }
 897       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 898       // case 4: parallelCapable: allow competing threads to try
 899       // LOAD_INSTANCE in parallel
 900 
 901       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 902         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 903         load_instance_added = true;
 904         // For class loaders that do not acquire the classloader object lock,
 905         // if they did not catch another thread holding LOAD_INSTANCE,
 906         // need a check analogous to the acquire ObjectLocker/find_class
 907         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 908         // one final check if the load has already completed
 909         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 910         InstanceKlass* check = find_class(d_hash, name, dictionary);
 911         if (check != NULL) {
<span class="line-modified"> 912           // Klass is already loaded, so return it after checking/adding protection domain</span>
 913           k = check;
 914           class_has_been_loaded = true;
 915         }
 916       }
 917     }
 918 
 919     // must throw error outside of owning lock
 920     if (throw_circularity_error) {
 921       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 922       ResourceMark rm(THREAD);
 923       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 924     }
 925 
 926     if (!class_has_been_loaded) {
 927 
 928       // Do actual loading
 929       k = load_instance_class(name, class_loader, THREAD);
 930 
 931       // If everything was OK (no exceptions, no null return value), and
 932       // class_loader is NOT the defining loader, do a little more bookkeeping.
</pre>
<hr />
<pre>
1052     // side-effect of this call
1053     SignatureStream ss(class_name, false);
1054     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1055     BasicType t = ss.type();
1056     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
1057       k = Universe::typeArrayKlassObj(t);
1058     } else {
1059       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1060     }
1061     if (k != NULL) {
1062       k = k-&gt;array_klass_or_null(ndims);
1063     }
1064   } else {
1065     k = find(class_name, class_loader, protection_domain, THREAD);
1066   }
1067   return k;
1068 }
1069 
1070 // Note: this method is much like resolve_from_stream, but
1071 // does not publish the classes via the SystemDictionary.
<span class="line-modified">1072 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass</span>
<span class="line-modified">1073 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.</span>
1074 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1075                                               Handle class_loader,
<span class="line-modified">1076                                               ClassFileStream* st,</span>


1077                                               const ClassLoadInfo&amp; cl_info,
1078                                               TRAPS) {
1079 
1080   EventClassLoad class_load_start_event;
1081 
1082   ClassLoaderData* loader_data;
<span class="line-modified">1083 </span>
<span class="line-modified">1084   bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;</span>
<span class="line-modified">1085 </span>
<span class="line-modified">1086   if (is_unsafe_anon_class) {</span>
<span class="line-modified">1087     // - for unsafe anonymous class: create a new CLD whith a class holder that uses</span>
<span class="line-added">1088     //                               the same class loader as the unsafe_anonymous_host.</span>
<span class="line-added">1089     guarantee(cl_info.unsafe_anonymous_host()-&gt;class_loader() == class_loader(),</span>
<span class="line-added">1090               &quot;should be the same&quot;);</span>
<span class="line-added">1091     loader_data = ClassLoaderData::has_class_mirror_holder_cld(class_loader);</span>
<span class="line-added">1092   } else if (cl_info.is_hidden()) {</span>
<span class="line-added">1093     // - for hidden classes that are not strong: create a new CLD that has a class holder and</span>
<span class="line-added">1094     //                                           whose loader is the Lookup class&#39; loader.</span>
<span class="line-added">1095     // - for hidden class: add the class to the Lookup class&#39; loader&#39;s CLD.</span>
<span class="line-added">1096     if (!cl_info.is_strong_hidden()) {</span>
<span class="line-added">1097       loader_data = ClassLoaderData::has_class_mirror_holder_cld(class_loader);</span>
<span class="line-added">1098     } else {</span>
<span class="line-added">1099       // This hidden class goes into the regular CLD pool for this loader.</span>
<span class="line-added">1100       loader_data = register_loader(class_loader);</span>
<span class="line-added">1101     }</span>
1102   } else {
1103     loader_data = ClassLoaderData::class_loader_data(class_loader());
1104   }
1105 
1106   assert(st != NULL, &quot;invariant&quot;);
1107   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1108 
1109   // Parse stream and create a klass.
1110   // Note that we do this even though this klass might
1111   // already be present in the SystemDictionary, otherwise we would not
1112   // throw potential ClassFormatErrors.
1113 
1114   InstanceKlass* k = KlassFactory::create_from_stream(st,
1115                                                       class_name,
1116                                                       loader_data,
<span class="line-modified">1117                                                       cl_info,</span>


1118                                                       CHECK_NULL);
1119 
<span class="line-modified">1120   if ((cl_info.is_hidden() || is_unsafe_anon_class) &amp;&amp; k != NULL) {</span>
<span class="line-modified">1121     // Hidden classes that are not strong and unsafe anonymous classes must update</span>
<span class="line-modified">1122     // ClassLoaderData holder so that they can be unloaded when the mirror is no</span>
<span class="line-modified">1123     // longer referenced.</span>
<span class="line-added">1124     if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {</span>
<span class="line-added">1125       k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));</span>
<span class="line-added">1126     }</span>
1127 
1128     {
1129       MutexLocker mu_r(THREAD, Compile_lock);
1130 
1131       // Add to class hierarchy, initialize vtables, and do possible
1132       // deoptimizations.
1133       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1134       // But, do not add to dictionary.
1135     }
1136 
1137     // Rewrite and patch constant pool here.
1138     k-&gt;link_class(CHECK_NULL);
<span class="line-modified">1139     if (cl_info.cp_patches() != NULL) {</span>
<span class="line-modified">1140       k-&gt;constants()-&gt;patch_resolved_references(cl_info.cp_patches());</span>
1141     }
1142 
1143     // If it&#39;s anonymous, initialize it now, since nobody else will.
<span class="line-modified">1144     if (is_unsafe_anon_class) {</span>
<span class="line-added">1145       k-&gt;eager_initialize(CHECK_NULL);</span>
<span class="line-added">1146     }</span>
1147 
1148     // notify jvmti
1149     if (JvmtiExport::should_post_class_load()) {
1150         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1151         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1152     }
1153     if (class_load_start_event.should_commit()) {
1154       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1155     }
1156   }
<span class="line-modified">1157   assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),</span>
1158          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1159 
1160   return k;
1161 }
1162 
1163 // Add a klass to the system from a stream (called by jni_DefineClass and
1164 // JVM_DefineClass).
1165 // Note: class_name can be NULL. In that case we do not know the name of
1166 // the class until we have parsed the stream.
1167 
1168 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1169                                                      Handle class_loader,
1170                                                      Handle protection_domain,
1171                                                      ClassFileStream* st,
1172                                                      TRAPS) {
1173 
1174   HandleMark hm(THREAD);
1175 
1176   // Classloaders that support parallelism, e.g. bootstrap classloader,
1177   // do not acquire lock here
</pre>
<hr />
<pre>
1192   // Parse the stream and create a klass.
1193   // Note that we do this even though this klass might
1194   // already be present in the SystemDictionary, otherwise we would not
1195   // throw potential ClassFormatErrors.
1196  InstanceKlass* k = NULL;
1197 
1198 #if INCLUDE_CDS
1199   if (!DumpSharedSpaces) {
1200     k = SystemDictionaryShared::lookup_from_stream(class_name,
1201                                                    class_loader,
1202                                                    protection_domain,
1203                                                    st,
1204                                                    CHECK_NULL);
1205   }
1206 #endif
1207 
1208   if (k == NULL) {
1209     if (st-&gt;buffer() == NULL) {
1210       return NULL;
1211     }
<span class="line-modified">1212     ClassLoadInfo cl_info(protection_domain);</span>
<span class="line-modified">1213     k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);</span>





1214   }
1215 
1216   assert(k != NULL, &quot;no klass created&quot;);
1217   Symbol* h_name = k-&gt;name();
1218   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1219 
1220   // Add class just loaded
1221   // If a class loader supports parallel classloading handle parallel define requests
1222   // find_or_define_instance_class may return a different InstanceKlass
1223   if (is_parallelCapable(class_loader)) {
1224     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1225     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1226       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1227       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1228       loader_data-&gt;add_to_deallocate_list(k);
1229       k = defined_k;
1230     }
1231   } else {
1232     define_instance_class(k, THREAD);
1233   }
</pre>
<hr />
<pre>
1437     HandleMark hm(THREAD);
1438     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1439     check_loader_lock_contention(lockObject, THREAD);
1440     ObjectLocker ol(lockObject, THREAD, true);
1441     // prohibited package check assumes all classes loaded from archive call
1442     // restore_unshareable_info which calls ik-&gt;set_package()
1443     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1444   }
1445 
1446   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1447   return ik;
1448 }
1449 
1450 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1451   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1452 
1453   // For boot loader, ensure that GetSystemPackage knows that a class in this
1454   // package was loaded.
1455   if (loader_data-&gt;is_the_null_class_loader_data()) {
1456     int path_index = ik-&gt;shared_classpath_index();
<span class="line-modified">1457     ik-&gt;set_classpath_index(path_index, THREAD);</span>
1458   }
1459 
1460   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1461     // Only dump the classes that can be stored into CDS archive
1462     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1463       ResourceMark rm(THREAD);
1464       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1465       classlist_file-&gt;flush();
1466     }
1467   }
1468 
1469   // notify a class loaded from shared object
1470   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1471 
1472   ik-&gt;set_has_passed_fingerprint_check(false);
1473   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1474     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1475     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1476     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1477       // This class matches with a class saved in an AOT library
</pre>
<hr />
<pre>
2407   resolution_errors()-&gt;delete_entry(pool);
2408 }
2409 
2410 // Lookup resolution error table. Returns error if found, otherwise NULL.
2411 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2412                                                 Symbol** message) {
2413   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2414   int index = resolution_errors()-&gt;hash_to_index(hash);
2415   {
2416     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2417     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2418     if (entry != NULL) {
2419       *message = entry-&gt;message();
2420       return entry-&gt;error();
2421     } else {
2422       return NULL;
2423     }
2424   }
2425 }
2426 
<span class="line-added">2427 // Add an entry to resolution error table to record an error in resolving or</span>
<span class="line-added">2428 // validating a nest host. This is used to construct informative error</span>
<span class="line-added">2429 // messages when IllegalAccessError&#39;s occur. If an entry already exists it will</span>
<span class="line-added">2430 // be updated with the nest host error message.</span>
<span class="line-added">2431 void SystemDictionary::add_nest_host_error(const constantPoolHandle&amp; pool,</span>
<span class="line-added">2432                                            int which,</span>
<span class="line-added">2433                                            const char* message) {</span>
<span class="line-added">2434   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);</span>
<span class="line-added">2435   int index = resolution_errors()-&gt;hash_to_index(hash);</span>
<span class="line-added">2436   {</span>
<span class="line-added">2437     MutexLocker ml(Thread::current(), SystemDictionary_lock);</span>
<span class="line-added">2438     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);</span>
<span class="line-added">2439     if (entry != NULL) {</span>
<span class="line-added">2440       assert(entry-&gt;nest_host_error() == NULL, &quot;Nest host error message already set!&quot;);</span>
<span class="line-added">2441       entry-&gt;set_nest_host_error(message);</span>
<span class="line-added">2442     } else {</span>
<span class="line-added">2443       resolution_errors()-&gt;add_entry(index, hash, pool, which, message);</span>
<span class="line-added">2444     }</span>
<span class="line-added">2445   }</span>
<span class="line-added">2446 }</span>
<span class="line-added">2447 </span>
<span class="line-added">2448 // Lookup any nest host error</span>
<span class="line-added">2449 const char* SystemDictionary::find_nest_host_error(const constantPoolHandle&amp; pool, int which) {</span>
<span class="line-added">2450   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);</span>
<span class="line-added">2451   int index = resolution_errors()-&gt;hash_to_index(hash);</span>
<span class="line-added">2452   {</span>
<span class="line-added">2453     MutexLocker ml(Thread::current(), SystemDictionary_lock);</span>
<span class="line-added">2454     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);</span>
<span class="line-added">2455     if (entry != NULL) {</span>
<span class="line-added">2456       return entry-&gt;nest_host_error();</span>
<span class="line-added">2457     } else {</span>
<span class="line-added">2458       return NULL;</span>
<span class="line-added">2459     }</span>
<span class="line-added">2460   }</span>
<span class="line-added">2461 }</span>
<span class="line-added">2462 </span>
2463 
2464 // Signature constraints ensure that callers and callees agree about
2465 // the meaning of type names in their signatures.  This routine is the
2466 // intake for constraints.  It collects them from several places:
2467 //
2468 //  * LinkResolver::resolve_method (if check_access is true) requires
2469 //    that the resolving class (the caller) and the defining class of
2470 //    the resolved method (the callee) agree on each type in the
2471 //    method&#39;s signature.
2472 //
2473 //  * LinkResolver::resolve_interface_method performs exactly the same
2474 //    checks.
2475 //
2476 //  * LinkResolver::resolve_field requires that the constant pool
2477 //    attempting to link to a field agree with the field&#39;s defining
2478 //    class about the type of the field signature.
2479 //
2480 //  * klassVtable::initialize_vtable requires that, when a class
2481 //    overrides a vtable entry allocated by a superclass, that the
2482 //    overriding method (i.e., the callee) agree with the superclass
</pre>
<hr />
<pre>
2572     }
2573   }
2574 
2575   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2576   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2577          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2578          &quot;MH intrinsic invariant&quot;);
2579   return spe-&gt;method();
2580 }
2581 
2582 // Helper for unpacking the return value from linkMethod and linkCallSite.
2583 static Method* unpack_method_and_appendix(Handle mname,
2584                                           Klass* accessing_klass,
2585                                           objArrayHandle appendix_box,
2586                                           Handle* appendix_result,
2587                                           TRAPS) {
2588   if (mname.not_null()) {
2589     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2590     if (m != NULL) {
2591       oop appendix = appendix_box-&gt;obj_at(0);
<span class="line-modified">2592       LogTarget(Info, methodhandles) lt;</span>
<span class="line-modified">2593       if (lt.develop_is_enabled()) {</span>
<span class="line-modified">2594         ResourceMark rm(THREAD);</span>
<span class="line-modified">2595         LogStream ls(lt);</span>
<span class="line-modified">2596         ls.print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));</span>
<span class="line-modified">2597         m-&gt;print_on(&amp;ls);</span>
<span class="line-modified">2598         if (appendix != NULL) { ls.print(&quot;appendix = &quot;); appendix-&gt;print_on(&amp;ls); }</span>
<span class="line-modified">2599         ls.cr();</span>
2600       }
<span class="line-added">2601 </span>
2602       (*appendix_result) = Handle(THREAD, appendix);
2603       // the target is stored in the cpCache and if a reference to this
2604       // MemberName is dropped we need a way to make sure the
2605       // class_loader containing this method is kept alive.
2606       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2607       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2608       this_key-&gt;record_dependency(m-&gt;method_holder());
2609       return mh();
2610     }
2611   }
2612   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2613 }
2614 
2615 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2616                                                      Symbol* name,
2617                                                      Symbol* signature,
2618                                                           Klass* accessing_klass,
2619                                                           Handle *appendix_result,
2620                                                           TRAPS) {
2621   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verificationType.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
 26 #define SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;oops/objArrayOop.hpp&quot;
 30 #include &quot;oops/symbol.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/mutexLocker.hpp&quot;
 33 #include &quot;runtime/reflectionUtils.hpp&quot;
 34 #include &quot;runtime/signature.hpp&quot;
 35 #include &quot;utilities/hashtable.hpp&quot;
 36 















































 37 // The dictionary in each ClassLoaderData stores all loaded classes, either
 38 // initiatied by its class loader or defined by its class loader:
 39 //
 40 //   class loader -&gt; ClassLoaderData -&gt; [class, protection domain set]
 41 //
 42 // Classes are loaded lazily. The default VM class loader is
 43 // represented as NULL.
 44 
 45 // The underlying data structure is an open hash table (Dictionary) per
 46 // ClassLoaderData with a fixed number of buckets. During loading the
 47 // class loader object is locked, (for the VM loader a private lock object is used).
 48 // The global SystemDictionary_lock is held for all additions into the ClassLoaderData
 49 // dictionaries.  TODO: fix lock granularity so that class loading can
 50 // be done concurrently, but only by different loaders.
 51 //
 52 // During loading a placeholder (name, loader) is temporarily placed in
 53 // a side data structure, and is used to detect ClassCircularityErrors
 54 // and to perform verification during GC.  A GC can occur in the midst
 55 // of class loading, as we call out to Java, have to take locks, etc.
 56 //
</pre>
<hr />
<pre>
264   static Klass* resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
265   // Version with null loader and protection domain
266   static Klass* resolve_or_null(Symbol* class_name, TRAPS);
267 
268   // Resolve a superclass or superinterface. Called from ClassFileParser,
269   // parse_interfaces, resolve_instance_class_or_null, load_shared_class
270   // &quot;child_name&quot; is the class whose super class or interface is being resolved.
271   static InstanceKlass* resolve_super_or_fail(Symbol* child_name,
272                                               Symbol* class_name,
273                                               Handle class_loader,
274                                               Handle protection_domain,
275                                               bool is_superclass,
276                                               TRAPS);
277 
278   static Klass* resolve_flattenable_field_or_fail(AllFieldStream* fs,
279                                                   Handle class_loader,
280                                                   Handle protection_domain,
281                                                   bool throw_error,
282                                                   TRAPS);
283 
<span class="line-modified">284   // Parse new stream. This won&#39;t update the dictionary or</span>
<span class="line-modified">285   // class hierarchy, simply parse the stream. Used by JVMTI RedefineClasses.</span>
<span class="line-modified">286   // Also used by Unsafe_DefineAnonymousClass</span>
<span class="line-removed">287   static InstanceKlass* parse_stream(Symbol* class_name,</span>
<span class="line-removed">288                                      Handle class_loader,</span>
<span class="line-removed">289                                      Handle protection_domain,</span>
<span class="line-removed">290                                      ClassFileStream* st,</span>
<span class="line-removed">291                                      TRAPS) {</span>
<span class="line-removed">292     return parse_stream(class_name,</span>
<span class="line-removed">293                         class_loader,</span>
<span class="line-removed">294                         protection_domain,</span>
<span class="line-removed">295                         st,</span>
<span class="line-removed">296                         NULL, // unsafe_anonymous_host</span>
<span class="line-removed">297                         NULL, // cp_patches</span>
<span class="line-removed">298                         THREAD);</span>
<span class="line-removed">299   }</span>
300   static InstanceKlass* parse_stream(Symbol* class_name,
301                                      Handle class_loader,
<span class="line-modified">302                                      Handle protection_domain,</span>
<span class="line-removed">303                                      ClassFileStream* st,</span>
<span class="line-removed">304                                      const InstanceKlass* unsafe_anonymous_host,</span>
305                                      GrowableArray&lt;Handle&gt;* cp_patches,
306                                      TRAPS);
307 
308   // Resolve from stream (called by jni_DefineClass and JVM_DefineClass)
309   static InstanceKlass* resolve_from_stream(Symbol* class_name,
310                                             Handle class_loader,
311                                             Handle protection_domain,
312                                             ClassFileStream* st,
313                                             TRAPS);
314 
315   // Lookup an already loaded class. If not found NULL is returned.
316   static Klass* find(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
317 
318   // Lookup an already loaded instance or array class.
319   // Do not make any queries to class loaders; consult only the cache.
320   // If not found NULL is returned.
321   static Klass* find_instance_or_array_klass(Symbol* class_name,
322                                                Handle class_loader,
323                                                Handle protection_domain,
324                                                TRAPS);
</pre>
<hr />
<pre>
524   // ask Java to compute a java.lang.invoke.MethodHandle object for a given CP entry
525   static Handle    link_method_handle_constant(Klass* caller,
526                                                int ref_kind, //e.g., JVM_REF_invokeVirtual
527                                                Klass* callee,
528                                                Symbol* name,
529                                                Symbol* signature,
530                                                TRAPS);
531 
532   // ask Java to compute a constant by invoking a BSM given a Dynamic_info CP entry
533   static void      invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS);
534 
535   // Record the error when the first attempt to resolve a reference from a constant
536   // pool entry to a class fails.
537   static void add_resolution_error(const constantPoolHandle&amp; pool, int which, Symbol* error,
538                                    Symbol* message);
539   static void delete_resolution_error(ConstantPool* pool);
540   static Symbol* find_resolution_error(const constantPoolHandle&amp; pool, int which,
541                                        Symbol** message);
542 
543 





544   static ProtectionDomainCacheEntry* cache_get(Handle protection_domain);
545 
546  protected:
547 
548   enum Constants {
549     _loader_constraint_size = 107,                     // number of entries in constraint table
550     _resolution_error_size  = 107,                     // number of entries in resolution error table
551     _invoke_method_size     = 139,                     // number of entries in invoke method table
552     _placeholder_table_size = 1009                     // number of entries in hash table for placeholders
553   };
554 
555 
556   // Static tables owned by the SystemDictionary
557 
558   // Hashtable holding placeholders for classes being loaded.
559   static PlaceholderTable*       _placeholders;
560 
561   // Lock object for system class loader
562   static oop                     _system_loader_lock_obj;
563 
</pre>
</td>
<td>
<hr />
<pre>
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
 26 #define SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;oops/objArrayOop.hpp&quot;
 30 #include &quot;oops/symbol.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/mutexLocker.hpp&quot;
 33 #include &quot;runtime/reflectionUtils.hpp&quot;
 34 #include &quot;runtime/signature.hpp&quot;
 35 #include &quot;utilities/hashtable.hpp&quot;
 36 
<span class="line-added"> 37 class ClassInstanceInfo : public StackObj {</span>
<span class="line-added"> 38  private:</span>
<span class="line-added"> 39   InstanceKlass* _dynamic_nest_host;</span>
<span class="line-added"> 40   Handle _class_data;</span>
<span class="line-added"> 41 </span>
<span class="line-added"> 42  public:</span>
<span class="line-added"> 43   ClassInstanceInfo() {</span>
<span class="line-added"> 44     _dynamic_nest_host = NULL;</span>
<span class="line-added"> 45     _class_data = Handle();</span>
<span class="line-added"> 46   }</span>
<span class="line-added"> 47   ClassInstanceInfo(InstanceKlass* dynamic_nest_host, Handle class_data) {</span>
<span class="line-added"> 48     _dynamic_nest_host = dynamic_nest_host;</span>
<span class="line-added"> 49     _class_data = class_data;</span>
<span class="line-added"> 50   }</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52   InstanceKlass* dynamic_nest_host() const { return _dynamic_nest_host; }</span>
<span class="line-added"> 53   Handle class_data() const { return _class_data; }</span>
<span class="line-added"> 54   friend class ClassLoadInfo;</span>
<span class="line-added"> 55 };</span>
<span class="line-added"> 56 </span>
<span class="line-added"> 57 class ClassLoadInfo : public StackObj {</span>
<span class="line-added"> 58  private:</span>
<span class="line-added"> 59   Handle                 _protection_domain;</span>
<span class="line-added"> 60   const InstanceKlass*   _unsafe_anonymous_host;</span>
<span class="line-added"> 61   GrowableArray&lt;Handle&gt;* _cp_patches;</span>
<span class="line-added"> 62   ClassInstanceInfo      _class_hidden_info;</span>
<span class="line-added"> 63   bool                   _is_hidden;</span>
<span class="line-added"> 64   bool                   _is_strong_hidden;</span>
<span class="line-added"> 65   bool                   _can_access_vm_annotations;</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67  public:</span>
<span class="line-added"> 68   ClassLoadInfo();</span>
<span class="line-added"> 69   ClassLoadInfo(Handle protection_domain);</span>
<span class="line-added"> 70   ClassLoadInfo(Handle protection_domain, const InstanceKlass* unsafe_anonymous_host,</span>
<span class="line-added"> 71                 GrowableArray&lt;Handle&gt;* cp_patches, InstanceKlass* dynamic_nest_host,</span>
<span class="line-added"> 72                 Handle class_data, bool is_hidden, bool is_strong_hidden,</span>
<span class="line-added"> 73                 bool can_access_vm_annotations);</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75   Handle protection_domain()             const { return _protection_domain; }</span>
<span class="line-added"> 76   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }</span>
<span class="line-added"> 77   GrowableArray&lt;Handle&gt;* cp_patches()    const { return _cp_patches; }</span>
<span class="line-added"> 78   const ClassInstanceInfo* class_hidden_info_ptr() const { return &amp;_class_hidden_info; }</span>
<span class="line-added"> 79   bool is_hidden()                       const { return _is_hidden; }</span>
<span class="line-added"> 80   bool is_strong_hidden()                const { return _is_strong_hidden; }</span>
<span class="line-added"> 81   bool can_access_vm_annotations()       const { return _can_access_vm_annotations; }</span>
<span class="line-added"> 82 };</span>
<span class="line-added"> 83 </span>
 84 // The dictionary in each ClassLoaderData stores all loaded classes, either
 85 // initiatied by its class loader or defined by its class loader:
 86 //
 87 //   class loader -&gt; ClassLoaderData -&gt; [class, protection domain set]
 88 //
 89 // Classes are loaded lazily. The default VM class loader is
 90 // represented as NULL.
 91 
 92 // The underlying data structure is an open hash table (Dictionary) per
 93 // ClassLoaderData with a fixed number of buckets. During loading the
 94 // class loader object is locked, (for the VM loader a private lock object is used).
 95 // The global SystemDictionary_lock is held for all additions into the ClassLoaderData
 96 // dictionaries.  TODO: fix lock granularity so that class loading can
 97 // be done concurrently, but only by different loaders.
 98 //
 99 // During loading a placeholder (name, loader) is temporarily placed in
100 // a side data structure, and is used to detect ClassCircularityErrors
101 // and to perform verification during GC.  A GC can occur in the midst
102 // of class loading, as we call out to Java, have to take locks, etc.
103 //
</pre>
<hr />
<pre>
311   static Klass* resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
312   // Version with null loader and protection domain
313   static Klass* resolve_or_null(Symbol* class_name, TRAPS);
314 
315   // Resolve a superclass or superinterface. Called from ClassFileParser,
316   // parse_interfaces, resolve_instance_class_or_null, load_shared_class
317   // &quot;child_name&quot; is the class whose super class or interface is being resolved.
318   static InstanceKlass* resolve_super_or_fail(Symbol* child_name,
319                                               Symbol* class_name,
320                                               Handle class_loader,
321                                               Handle protection_domain,
322                                               bool is_superclass,
323                                               TRAPS);
324 
325   static Klass* resolve_flattenable_field_or_fail(AllFieldStream* fs,
326                                                   Handle class_loader,
327                                                   Handle protection_domain,
328                                                   bool throw_error,
329                                                   TRAPS);
330 
<span class="line-modified">331   // Parse new stream. This won&#39;t update the dictionary or class</span>
<span class="line-modified">332   // hierarchy, simply parse the stream. Used by JVMTI RedefineClasses</span>
<span class="line-modified">333   // and by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.</span>













334   static InstanceKlass* parse_stream(Symbol* class_name,
335                                      Handle class_loader,
<span class="line-modified">336                                      ClassFileStream* st,</span>


337                                      const ClassLoadInfo&amp; cl_info,
338                                      TRAPS);
339 
340   // Resolve from stream (called by jni_DefineClass and JVM_DefineClass)
341   static InstanceKlass* resolve_from_stream(Symbol* class_name,
342                                             Handle class_loader,
343                                             Handle protection_domain,
344                                             ClassFileStream* st,
345                                             TRAPS);
346 
347   // Lookup an already loaded class. If not found NULL is returned.
348   static Klass* find(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
349 
350   // Lookup an already loaded instance or array class.
351   // Do not make any queries to class loaders; consult only the cache.
352   // If not found NULL is returned.
353   static Klass* find_instance_or_array_klass(Symbol* class_name,
354                                                Handle class_loader,
355                                                Handle protection_domain,
356                                                TRAPS);
</pre>
<hr />
<pre>
556   // ask Java to compute a java.lang.invoke.MethodHandle object for a given CP entry
557   static Handle    link_method_handle_constant(Klass* caller,
558                                                int ref_kind, //e.g., JVM_REF_invokeVirtual
559                                                Klass* callee,
560                                                Symbol* name,
561                                                Symbol* signature,
562                                                TRAPS);
563 
564   // ask Java to compute a constant by invoking a BSM given a Dynamic_info CP entry
565   static void      invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS);
566 
567   // Record the error when the first attempt to resolve a reference from a constant
568   // pool entry to a class fails.
569   static void add_resolution_error(const constantPoolHandle&amp; pool, int which, Symbol* error,
570                                    Symbol* message);
571   static void delete_resolution_error(ConstantPool* pool);
572   static Symbol* find_resolution_error(const constantPoolHandle&amp; pool, int which,
573                                        Symbol** message);
574 
575 
<span class="line-added">576   // Record a nest host resolution/validation error</span>
<span class="line-added">577   static void add_nest_host_error(const constantPoolHandle&amp; pool, int which,</span>
<span class="line-added">578                                   const char* message);</span>
<span class="line-added">579   static const char* find_nest_host_error(const constantPoolHandle&amp; pool, int which);</span>
<span class="line-added">580 </span>
581   static ProtectionDomainCacheEntry* cache_get(Handle protection_domain);
582 
583  protected:
584 
585   enum Constants {
586     _loader_constraint_size = 107,                     // number of entries in constraint table
587     _resolution_error_size  = 107,                     // number of entries in resolution error table
588     _invoke_method_size     = 139,                     // number of entries in invoke method table
589     _placeholder_table_size = 1009                     // number of entries in hash table for placeholders
590   };
591 
592 
593   // Static tables owned by the SystemDictionary
594 
595   // Hashtable holding placeholders for classes being loaded.
596   static PlaceholderTable*       _placeholders;
597 
598   // Lock object for system class loader
599   static oop                     _system_loader_lock_obj;
600 
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verificationType.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
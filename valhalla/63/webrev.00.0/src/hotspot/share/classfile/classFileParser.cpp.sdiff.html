<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciInstanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1124     _method_DontInline,
1125     _method_InjectedProfile,
1126     _method_LambdaForm_Compiled,
1127     _method_Hidden,
1128     _method_HotSpotIntrinsicCandidate,
1129     _jdk_internal_vm_annotation_Contended,
1130     _field_Stable,
1131     _jdk_internal_vm_annotation_ReservedStackAccess,
1132     _annotation_LIMIT
1133   };
1134   const Location _location;
1135   int _annotations_present;
1136   u2 _contended_group;
1137 
1138   AnnotationCollector(Location location)
1139     : _location(location), _annotations_present(0)
1140   {
1141     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1142   }
1143   // If this annotation name has an ID, report it (or _none).
<span class="line-modified">1144   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name);</span>
1145   // Set the annotation name:
1146   void set_annotation(ID id) {
1147     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1148     _annotations_present |= nth_bit((int)id);
1149   }
1150 
1151   void remove_annotation(ID id) {
1152     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1153     _annotations_present &amp;= ~nth_bit((int)id);
1154   }
1155 
1156   // Report if the annotation is present.
1157   bool has_any_annotations() const { return _annotations_present != 0; }
1158   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1159 
1160   void set_contended_group(u2 group) { _contended_group = group; }
1161   u2 contended_group() const { return _contended_group; }
1162 
1163   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1164 
</pre>
<hr />
<pre>
1257       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1258       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1259         index = skip_annotation_value(buffer, limit, index);
1260       }
1261     }
1262     break;
1263     case &#39;@&#39;:
1264       index = skip_annotation(buffer, limit, index);
1265       break;
1266     default:
1267       return limit;  //  bad tag byte
1268   }
1269   return index;
1270 }
1271 
1272 // Sift through annotations, looking for those significant to the VM:
1273 static void parse_annotations(const ConstantPool* const cp,
1274                               const u1* buffer, int limit,
1275                               AnnotationCollector* coll,
1276                               ClassLoaderData* loader_data,

1277                               TRAPS) {
1278 
1279   assert(cp != NULL, &quot;invariant&quot;);
1280   assert(buffer != NULL, &quot;invariant&quot;);
1281   assert(coll != NULL, &quot;invariant&quot;);
1282   assert(loader_data != NULL, &quot;invariant&quot;);
1283 
1284   // annotations := do(nann:u2) {annotation}
1285   int index = 2; // read nann
1286   if (index &gt;= limit)  return;
1287   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1288   enum {  // initial annotation layout
1289     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1290     count_off = 2,      // u2   such as 1 (one value)
1291     member_off = 4,     // utf8 such as &#39;value&#39;
1292     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1293     e_tag_val = &#39;e&#39;,
1294     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1295     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1296     e_size = 11,     // end of &#39;e&#39; annotation
</pre>
<hr />
<pre>
1302     s_size = 9,
1303     min_size = 6        // smallest possible size (zero members)
1304   };
1305   // Cannot add min_size to index in case of overflow MAX_INT
1306   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1307     int index0 = index;
1308     index = skip_annotation(buffer, limit, index);
1309     const u1* const abase = buffer + index0;
1310     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1311     const int count = Bytes::get_Java_u2((address)abase + count_off);
1312     const Symbol* const aname = check_symbol_at(cp, atype);
1313     if (aname == NULL)  break;  // invalid annotation name
1314     const Symbol* member = NULL;
1315     if (count &gt;= 1) {
1316       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1317       member = check_symbol_at(cp, member_index);
1318       if (member == NULL)  break;  // invalid member name
1319     }
1320 
1321     // Here is where parsing particular annotations will take place.
<span class="line-modified">1322     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname);</span>
1323     if (AnnotationCollector::_unknown == id)  continue;
1324     coll-&gt;set_annotation(id);
1325 
1326     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1327       // @Contended can optionally specify the contention group.
1328       //
1329       // Contended group defines the equivalence class over the fields:
1330       // the fields within the same contended group are not treated distinct.
1331       // The only exception is default group, which does not incur the
1332       // equivalence. Naturally, contention group for classes is meaningless.
1333       //
1334       // While the contention group is specified as String, annotation
1335       // values are already interned, and we might as well use the constant
1336       // pool index as the group tag.
1337       //
1338       u2 group_index = 0; // default contended group
1339       if (count == 1
1340         &amp;&amp; s_size == (index - index0)  // match size
1341         &amp;&amp; s_tag_val == *(abase + tag_off)
1342         &amp;&amp; member == vmSymbols::value_name()) {
</pre>
<hr />
<pre>
1428         if (attribute_length != 2) {
1429           classfile_parse_error(
1430             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1431             attribute_length, CHECK);
1432         }
1433         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1434       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1435         if (runtime_visible_annotations != NULL) {
1436           classfile_parse_error(
1437             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1438         }
1439         runtime_visible_annotations_length = attribute_length;
1440         runtime_visible_annotations = cfs-&gt;current();
1441         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1442         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1443         parse_annotations(cp,
1444                           runtime_visible_annotations,
1445                           runtime_visible_annotations_length,
1446                           parsed_annotations,
1447                           _loader_data,

1448                           CHECK);
1449         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1450       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1451         if (runtime_invisible_annotations_exists) {
1452           classfile_parse_error(
1453             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1454         }
1455         runtime_invisible_annotations_exists = true;
1456         if (PreserveAllAnnotations) {
1457           runtime_invisible_annotations_length = attribute_length;
1458           runtime_invisible_annotations = cfs-&gt;current();
1459           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1460         }
1461         cfs-&gt;skip_u1(attribute_length, CHECK);
1462       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1463         if (runtime_visible_type_annotations != NULL) {
1464           classfile_parse_error(
1465             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1466         }
1467         runtime_visible_type_annotations_length = attribute_length;
</pre>
<hr />
<pre>
2157                                             const Symbol* name,
2158                                             const Symbol* sig,
2159                                             TRAPS) const {
2160   assert(name != NULL, &quot;invariant&quot;);
2161   assert(sig != NULL, &quot;invariant&quot;);
2162 
2163   const char* class_note = &quot;&quot;;
2164   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {
2165     class_note = &quot; (an inline class)&quot;;
2166   }
2167 
2168   ResourceMark rm(THREAD);
2169   Exceptions::fthrow(THREAD_AND_LOCATION,
2170       vmSymbols::java_lang_ClassFormatError(),
2171       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,
2172       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());
2173 }
2174 
2175 AnnotationCollector::ID
2176 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
<span class="line-modified">2177                                       const Symbol* name) {</span>

2178   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2179   // Privileged code can use all annotations.  Other code silently drops some.
<span class="line-modified">2180   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||</span>
2181                           loader_data-&gt;is_platform_class_loader_data() ||
<span class="line-modified">2182                           loader_data-&gt;is_unsafe_anonymous();</span>
2183   switch (sid) {
2184     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2185       if (_location != _in_method)  break;  // only allow for methods
2186       if (!privileged)              break;  // only allow in privileged code
2187       return _method_CallerSensitive;
2188     }
2189     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2190       if (_location != _in_method)  break;  // only allow for methods
2191       if (!privileged)              break;  // only allow in privileged code
2192       return _method_ForceInline;
2193     }
2194     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2195       if (_location != _in_method)  break;  // only allow for methods
2196       if (!privileged)              break;  // only allow in privileged code
2197       return _method_DontInline;
2198     }
2199     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2200       if (_location != _in_method)  break;  // only allow for methods
2201       if (!privileged)              break;  // only allow in privileged code
2202       return _method_InjectedProfile;
</pre>
<hr />
<pre>
2812           classfile_parse_error(
2813             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2814             method_attribute_length, CHECK_NULL);
2815         }
2816         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2817       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2818         if (runtime_visible_annotations != NULL) {
2819           classfile_parse_error(
2820             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2821             CHECK_NULL);
2822         }
2823         runtime_visible_annotations_length = method_attribute_length;
2824         runtime_visible_annotations = cfs-&gt;current();
2825         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2826         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2827         parse_annotations(cp,
2828                           runtime_visible_annotations,
2829                           runtime_visible_annotations_length,
2830                           &amp;parsed_annotations,
2831                           _loader_data,

2832                           CHECK_NULL);
2833         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2834       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2835         if (runtime_invisible_annotations_exists) {
2836           classfile_parse_error(
2837             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2838             CHECK_NULL);
2839         }
2840         runtime_invisible_annotations_exists = true;
2841         if (PreserveAllAnnotations) {
2842           runtime_invisible_annotations_length = method_attribute_length;
2843           runtime_invisible_annotations = cfs-&gt;current();
2844           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2845         }
2846         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2847       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2848         if (runtime_visible_parameter_annotations != NULL) {
2849           classfile_parse_error(
2850             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2851             CHECK_NULL);
</pre>
<hr />
<pre>
3006                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
3007                                                 sizeof(u2));
3008   }
3009 
3010   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
3011   if (total_lvt_length &gt; 0) {
3012     promoted_flags-&gt;set_has_localvariable_table();
3013     copy_localvariable_table(m-&gt;constMethod(),
3014                              lvt_cnt,
3015                              localvariable_table_length,
3016                              localvariable_table_start,
3017                              lvtt_cnt,
3018                              localvariable_type_table_length,
3019                              localvariable_type_table_start,
3020                              CHECK_NULL);
3021   }
3022 
3023   if (parsed_annotations.has_any_annotations())
3024     parsed_annotations.apply_to(methodHandle(THREAD, m));
3025 




3026   // Copy annotations
3027   copy_method_annotations(m-&gt;constMethod(),
3028                           runtime_visible_annotations,
3029                           runtime_visible_annotations_length,
3030                           runtime_invisible_annotations,
3031                           runtime_invisible_annotations_length,
3032                           runtime_visible_parameter_annotations,
3033                           runtime_visible_parameter_annotations_length,
3034                           runtime_invisible_parameter_annotations,
3035                           runtime_invisible_parameter_annotations_length,
3036                           runtime_visible_type_annotations,
3037                           runtime_visible_type_annotations_length,
3038                           runtime_invisible_type_annotations,
3039                           runtime_invisible_type_annotations_length,
3040                           annotation_default,
3041                           annotation_default_length,
3042                           CHECK_NULL);
3043 
3044   if (name == vmSymbols::finalize_method_name() &amp;&amp;
3045       signature == vmSymbols::void_method_signature()) {
</pre>
<hr />
<pre>
3745         if (attribute_length != 2) {
3746           classfile_parse_error(
3747             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3748             attribute_length, CHECK);
3749         }
3750         parse_classfile_signature_attribute(cfs, CHECK);
3751       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3752         if (runtime_visible_annotations != NULL) {
3753           classfile_parse_error(
3754             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3755         }
3756         runtime_visible_annotations_length = attribute_length;
3757         runtime_visible_annotations = cfs-&gt;current();
3758         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3759         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3760         parse_annotations(cp,
3761                           runtime_visible_annotations,
3762                           runtime_visible_annotations_length,
3763                           parsed_annotations,
3764                           _loader_data,

3765                           CHECK);
3766         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3767       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3768         if (runtime_invisible_annotations_exists) {
3769           classfile_parse_error(
3770             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3771         }
3772         runtime_invisible_annotations_exists = true;
3773         if (PreserveAllAnnotations) {
3774           runtime_invisible_annotations_length = attribute_length;
3775           runtime_invisible_annotations = cfs-&gt;current();
3776           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3777         }
3778         cfs-&gt;skip_u1(attribute_length, CHECK);
3779       } else if (tag == vmSymbols::tag_enclosing_method()) {
3780         if (parsed_enclosingmethod_attribute) {
3781           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3782         } else {
3783           parsed_enclosingmethod_attribute = true;
3784         }
</pre>
<hr />
<pre>
6027 
6028           if (!match) {
6029             char buf[1000];
6030             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
6031                        &quot;but the method is not available in class [%s].%s&quot;,
6032                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
6033                                                              buf, sizeof(buf)),
6034                         ik-&gt;name()-&gt;as_C_string(),
6035                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6036             );
6037             tty-&gt;cr();
6038             DEBUG_ONLY(vm_exit(1));
6039           }
6040         }
6041       } // end for
6042     } // CheckIntrinsics
6043 #endif // ASSERT
6044   }
6045 }
6046 
<span class="line-modified">6047 // Called from a factory method in KlassFactory, not from this file.</span>
<span class="line-modified">6048 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {</span>

6049   if (_klass != NULL) {
6050     return _klass;
6051   }
6052 
6053   InstanceKlass* const ik =
6054     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
6055 
<span class="line-modified">6056   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);</span>





6057   assert(_klass == ik, &quot;invariant&quot;);
6058 
6059 
6060   if (ik-&gt;should_store_fingerprint()) {
6061     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6062   }
6063 
6064   ik-&gt;set_has_passed_fingerprint_check(false);
6065   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6066     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6067     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6068     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6069       // This class matches with a class saved in an AOT library
6070       ik-&gt;set_has_passed_fingerprint_check(true);
6071     } else {
6072       ResourceMark rm;
6073       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6074                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6075     }
6076   }
</pre>
<hr />
<pre>
6101   if (!access_flags().is_abstract() || _has_nonstatic_fields) {
6102     return true;
6103   } else {
6104     // Look at each method
6105     for (int x = 0; x &lt; _methods-&gt;length(); x++) {
6106       const Method* const method = _methods-&gt;at(x);
6107       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {
6108         return true;
6109 
6110       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {
6111         if (method-&gt;signature() != vmSymbols::void_method_signature() ||
6112             !method-&gt;is_vanilla_constructor()) {
6113           return true;
6114         }
6115       }
6116     }
6117   }
6118   return false;
6119 }
6120 
<span class="line-modified">6121 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {</span>



6122   assert(ik != NULL, &quot;invariant&quot;);
6123 
6124   // Set name and CLD before adding to CLD
6125   ik-&gt;set_class_loader_data(_loader_data);
6126   ik-&gt;set_name(_class_name);
6127 
6128   // Add all classes to our internal class loader list here,
6129   // including classes in the bootstrap (NULL) class loader.
6130   const bool publicize = !is_internal();
6131 
6132   _loader_data-&gt;add_class(ik, publicize);
6133 
6134   set_klass_to_deallocate(ik);
6135 
6136   assert(_field_info != NULL, &quot;invariant&quot;);
6137   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6138   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6139          &quot;sanity&quot;);
6140 
6141   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
</pre>
<hr />
<pre>
6152   }
6153   if (_is_empty_inline_type) {
6154     ik-&gt;set_is_empty_inline_type();
6155   }
6156 
6157   if (this-&gt;_invalid_inline_super) {
6158     ik-&gt;set_invalid_inline_super();
6159   }
6160 
6161   if (_has_injected_identityObject) {
6162     ik-&gt;set_has_injected_identityObject();
6163   }
6164 
6165   assert(_fac != NULL, &quot;invariant&quot;);
6166   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6167 
6168   // this transfers ownership of a lot of arrays from
6169   // the parser onto the InstanceKlass*
6170   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6171 





6172   // note that is not safe to use the fields in the parser from this point on
6173   assert(NULL == _cp, &quot;invariant&quot;);
6174   assert(NULL == _fields, &quot;invariant&quot;);
6175   assert(NULL == _methods, &quot;invariant&quot;);
6176   assert(NULL == _inner_classes, &quot;invariant&quot;);
6177   assert(NULL == _nest_members, &quot;invariant&quot;);
6178   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6179   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6180   assert(NULL == _record_components, &quot;invariant&quot;);
6181 
6182   if (_has_final_method) {
6183     ik-&gt;set_has_final_method();
6184   }
6185 
6186   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6187   // The InstanceKlass::_methods_jmethod_ids cache
6188   // is managed on the assumption that the initial cache
6189   // size is equal to the number of methods in the class. If
6190   // that changes, then InstanceKlass::idnum_can_increment()
6191   // has to be changed accordingly.
6192   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6193 
6194   ik-&gt;set_this_class_index(_this_class_index);
6195 
<span class="line-modified">6196   if (is_unsafe_anonymous()) {</span>
6197     // _this_class_index is a CONSTANT_Class entry that refers to this
<span class="line-modified">6198     // anonymous class itself. If this class needs to refer to its own methods or</span>
<span class="line-modified">6199     // fields, it would use a CONSTANT_MethodRef, etc, which would reference</span>
<span class="line-modified">6200     // _this_class_index. However, because this class is anonymous (it&#39;s</span>
6201     // not stored in SystemDictionary), _this_class_index cannot be resolved
6202     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6203     // Therefore, we must eagerly resolve _this_class_index now.
6204     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6205   }
6206 
6207   ik-&gt;set_minor_version(_minor_version);
6208   ik-&gt;set_major_version(_major_version);
6209   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6210   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
6211   if (_is_declared_atomic) {
6212     ik-&gt;set_is_declared_atomic();
6213   }
6214 
6215   if (_unsafe_anonymous_host != NULL) {
6216     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6217     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6218   }



6219 
6220   // Set PackageEntry for this_klass
6221   oop cl = ik-&gt;class_loader();
6222   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6223   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6224   ik-&gt;set_package(cld, NULL, CHECK);
6225 
6226   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6227   assert(methods != NULL, &quot;invariant&quot;);
6228   const int methods_len = methods-&gt;length();
6229 
6230   check_methods_for_intrinsics(ik, methods);
6231 
6232   // Fill in field values obtained by parse_classfile_attributes
6233   if (_parsed_annotations-&gt;has_any_annotations()) {
6234     _parsed_annotations-&gt;apply_to(ik);
6235   }
6236 
6237   apply_parsed_class_attributes(ik);
6238 
</pre>
<hr />
<pre>
6278   check_final_method_override(ik, CHECK);
6279 
6280   // reject static interface methods prior to Java 8
6281   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
6282     check_illegal_static_method(ik, CHECK);
6283   }
6284 
6285   // Obtain this_klass&#39; module entry
6286   ModuleEntry* module_entry = ik-&gt;module();
6287   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
6288 
6289   // Obtain java.lang.Module
6290   Handle module_handle(THREAD, module_entry-&gt;module());
6291 
6292   // Allocate mirror and initialize static fields
6293   // The create_mirror() call will also call compute_modifiers()
6294   java_lang_Class::create_mirror(ik,
6295                                  Handle(THREAD, _loader_data-&gt;class_loader()),
6296                                  module_handle,
6297                                  _protection_domain,

6298                                  CHECK);
6299 
6300   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6301 
6302   // Generate any default methods - default methods are public interface methods
6303   // that have a default implementation.  This is new with Java 8.
6304   if (_has_nonstatic_concrete_methods) {
6305     DefaultMethods::generate_default_methods(ik,
6306                                              _all_mirandas,
6307                                              CHECK);
6308   }
6309 
6310   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6311   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6312       !module_entry-&gt;has_default_read_edges()) {
6313     if (!module_entry-&gt;set_has_default_read_edges()) {
6314       // We won a potential race
6315       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6316     }
6317   }
</pre>
<hr />
<pre>
6400   set_klass(ik);
6401 
6402   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {
6403     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);
6404   }
6405 
6406   debug_only(ik-&gt;verify();)
6407 }
6408 
6409 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6410   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6411   _class_name-&gt;decrement_refcount();
6412 
6413   _class_name = new_class_name;
6414   // Increment the refcount of the new name.
6415   // Now the ClassFileParser owns this name and will decrement in
6416   // the destructor.
6417   _class_name-&gt;increment_refcount();
6418 }
6419 
<span class="line-removed">6420 </span>
6421 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6422 // package by prepending its host class&#39;s package name to its class name and setting
6423 // its _class_name field.
6424 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6425   ResourceMark rm(THREAD);
6426   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
6427          &quot;Unsafe anonymous class should not be in a package&quot;);
6428   TempNewSymbol host_pkg_name =
6429     ClassLoader::package_from_class_name(unsafe_anonymous_host-&gt;name());
6430 
6431   if (host_pkg_name != NULL) {
6432     int host_pkg_len = host_pkg_name-&gt;utf8_length();
6433     int class_name_len = _class_name-&gt;utf8_length();
6434     int symbol_len = host_pkg_len + 1 + class_name_len;
6435     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
6436     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%.*s/%.*s&quot;,
6437                          host_pkg_len, host_pkg_name-&gt;base(), class_name_len, _class_name-&gt;base());
6438     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
6439 
6440     // Decrement old _class_name to avoid leaking.
</pre>
<hr />
<pre>
6453 // host&#39;s package.  If the classes are in different packages then throw an IAE
6454 // exception.
6455 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
6456   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
6457 
6458   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
6459                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
6460   if (anon_last_slash == NULL) {  // Unnamed package
6461     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
6462   } else {
6463     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
6464       ResourceMark rm(THREAD);
6465       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
6466         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
6467         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
6468     }
6469   }
6470 }
6471 
6472 static bool relax_format_check_for(ClassLoaderData* loader_data) {
<span class="line-modified">6473   bool trusted = (loader_data-&gt;is_the_null_class_loader_data() ||</span>
<span class="line-modified">6474                   SystemDictionary::is_platform_class_loader(loader_data-&gt;class_loader()));</span>
6475   bool need_verify =
6476     // verifyAll
6477     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
6478     // verifyRemote
6479     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
6480   return !need_verify;
6481 }
6482 
6483 ClassFileParser::ClassFileParser(ClassFileStream* stream,
6484                                  Symbol* name,
6485                                  ClassLoaderData* loader_data,
<span class="line-modified">6486                                  Handle protection_domain,</span>
<span class="line-removed">6487                                  const InstanceKlass* unsafe_anonymous_host,</span>
<span class="line-removed">6488                                  GrowableArray&lt;Handle&gt;* cp_patches,</span>
6489                                  Publicity pub_level,
6490                                  TRAPS) :
6491   _stream(stream),
<span class="line-removed">6492   _requested_name(name),</span>
6493   _class_name(NULL),
6494   _loader_data(loader_data),
<span class="line-modified">6495   _unsafe_anonymous_host(unsafe_anonymous_host),</span>
<span class="line-modified">6496   _cp_patches(cp_patches),</span>


6497   _num_patched_klasses(0),
6498   _max_num_patched_klasses(0),
6499   _orig_cp_size(0),
6500   _first_patched_klass_resolved_index(0),
6501   _super_klass(),
6502   _cp(NULL),
6503   _fields(NULL),
6504   _methods(NULL),
6505   _inner_classes(NULL),
6506   _nest_members(NULL),
6507   _nest_host(0),
6508   _record_components(NULL),
6509   _temp_local_interfaces(NULL),
6510   _local_interfaces(NULL),
6511   _transitive_interfaces(NULL),
6512   _combined_annotations(NULL),
6513   _class_annotations(NULL),
6514   _class_type_annotations(NULL),
6515   _fields_annotations(NULL),
6516   _fields_type_annotations(NULL),
6517   _klass(NULL),
6518   _klass_to_deallocate(NULL),
6519   _parsed_annotations(NULL),
6520   _fac(NULL),
6521   _field_info(NULL),
6522   _method_ordering(NULL),
6523   _all_mirandas(NULL),
6524   _vtable_size(0),
6525   _itable_size(0),
6526   _num_miranda_methods(0),
6527   _rt(REF_NONE),
<span class="line-modified">6528   _protection_domain(protection_domain),</span>
6529   _access_flags(),
6530   _pub_level(pub_level),
6531   _bad_constant_seen(0),
6532   _synthetic_flag(false),
6533   _sde_length(false),
6534   _sde_buffer(NULL),
6535   _sourcefile_index(0),
6536   _generic_signature_index(0),
6537   _major_version(0),
6538   _minor_version(0),
6539   _this_class_index(0),
6540   _super_class_index(0),
6541   _itfs_len(0),
6542   _java_fields_count(0),
6543   _need_verify(false),
6544   _relax_verify(false),
6545   _has_nonstatic_concrete_methods(false),
6546   _declares_nonstatic_concrete_methods(false),
6547   _has_final_method(false),
6548   _has_contended_fields(false),
</pre>
<hr />
<pre>
6720             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6721     Exceptions::fthrow(
6722       THREAD_AND_LOCATION,
6723       vmSymbols::java_lang_UnsupportedClassVersionError(),
6724       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6725       _major_version,
6726       _minor_version);
6727   }
6728 
6729   // Check version numbers - we check this even with verifier off
6730   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6731 
6732   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6733   u2 cp_size = stream-&gt;get_u2_fast();
6734 
6735   guarantee_property(
6736     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6737     cp_size, CHECK);
6738 
6739   _orig_cp_size = cp_size;
<span class="line-modified">6740   if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {</span>
<span class="line-modified">6741     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);</span>






6742   }
<span class="line-removed">6743   cp_size += _max_num_patched_klasses;</span>
6744 
6745   _cp = ConstantPool::allocate(_loader_data,
6746                                cp_size,
6747                                CHECK);
6748 
6749   ConstantPool* const cp = _cp;
6750 
6751   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6752 
6753   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6754 
6755   // ACCESS FLAGS
6756   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6757 
6758   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;
6759   // JVM_ACC_MODULE is defined in JDK-9 and later.
6760   if (_major_version &gt;= JAVA_9_VERSION) {
6761     recognized_modifiers |= JVM_ACC_MODULE;
6762   }
6763   // JVM_ACC_VALUE is defined for class file version 55 and later
</pre>
<hr />
<pre>
6778   short bad_constant = class_bad_constant_seen();
6779   if (bad_constant != 0) {
6780     // Do not throw CFE until after the access_flags are checked because if
6781     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6782     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6783   }
6784 
6785   _access_flags.set_flags(flags);
6786 
6787   // This class and superclass
6788   _this_class_index = stream-&gt;get_u2_fast();
6789   check_property(
6790     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6791       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6792     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6793     _this_class_index, CHECK);
6794 
6795   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6796   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6797 
<span class="line-removed">6798   // Update _class_name to reflect the name in the constant pool</span>
<span class="line-removed">6799   update_class_name(class_name_in_cp);</span>
<span class="line-removed">6800 </span>
6801   // Don&#39;t need to check whether this class name is legal or not.
6802   // It has been checked when constant pool is parsed.
6803   // However, make sure it is not an array type.
6804   if (_need_verify) {
<span class="line-modified">6805     guarantee_property(_class_name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,</span>
6806                        &quot;Bad class name in class file %s&quot;,
6807                        CHECK);
6808   }
6809 
<span class="line-modified">6810   // Checks if name in class file matches requested name</span>
<span class="line-modified">6811   if (_requested_name != NULL &amp;&amp; _requested_name != _class_name) {</span>
<span class="line-modified">6812     ResourceMark rm(THREAD);</span>
<span class="line-modified">6813     Exceptions::fthrow(</span>
<span class="line-modified">6814       THREAD_AND_LOCATION,</span>
<span class="line-modified">6815       vmSymbols::java_lang_NoClassDefFoundError(),</span>
<span class="line-modified">6816       &quot;%s (wrong name: %s)&quot;,</span>
<span class="line-modified">6817       _class_name-&gt;as_C_string(),</span>
<span class="line-modified">6818       _requested_name != NULL ? _requested_name-&gt;as_C_string() : &quot;NoName&quot;</span>
<span class="line-removed">6819     );</span>
<span class="line-removed">6820     return;</span>
6821   }















6822 
<span class="line-modified">6823   // if this is an anonymous class fix up its name if it&#39;s in the unnamed</span>
6824   // package.  Otherwise, throw IAE if it is in a different package than
6825   // its host class.
<span class="line-modified">6826   if (_unsafe_anonymous_host != NULL) {</span>

6827     fix_unsafe_anonymous_class_name(CHECK);




















6828   }
6829 
6830   // Verification prevents us from creating names with dots in them, this
6831   // asserts that that&#39;s the case.
6832   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6833 
6834   if (!is_internal()) {
6835     LogTarget(Debug, class, preorder) lt;
6836     if (lt.is_enabled()){
6837       ResourceMark rm(THREAD);
6838       LogStream ls(lt);
6839       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
6840       if (stream-&gt;source() != NULL) {
6841         ls.print(&quot; source: %s&quot;, stream-&gt;source());
6842       }
6843       ls.cr();
6844     }
6845 
6846 #if INCLUDE_CDS
6847     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6848       if (!ClassLoader::has_jrt_entry()) {
6849         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6850         DumpLoadedClassList = NULL;
6851       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;

6852                  _unsafe_anonymous_host == NULL) {
6853         // Only dump the classes that can be stored into CDS archive.
<span class="line-modified">6854         // Unsafe anonymous classes such as generated LambdaForm classes are also not included.</span>
6855         oop class_loader = _loader_data-&gt;class_loader();
6856         ResourceMark rm(THREAD);
6857         bool skip = false;
6858         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6859           // For the boot and platform class loaders, skip classes that are not found in the
6860           // java runtime image, such as those found in the --patch-module entries.
6861           // These classes can&#39;t be loaded from the archive during runtime.
6862           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
6863             skip = true;
6864           }
6865 
6866           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6867             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6868             // as they can be loaded from the archive during runtime.
6869             skip = false;
6870           }
6871         }
6872         if (skip) {
6873           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6874             _class_name-&gt;as_C_string(), stream-&gt;source());
</pre>
<hr />
<pre>
6933   }
6934 
6935   // Additional attributes/annotations
6936   _parsed_annotations = new ClassAnnotationCollector();
6937   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6938 
6939   assert(_inner_classes != NULL, &quot;invariant&quot;);
6940 
6941   // Finalize the Annotations metadata object,
6942   // now that all annotation arrays have been created.
6943   create_combined_annotations(CHECK);
6944 
6945   // Make sure this is the end of class file stream
6946   guarantee_property(stream-&gt;at_eos(),
6947                      &quot;Extra bytes at the end of class file %s&quot;,
6948                      CHECK);
6949 
6950   // all bytes in stream read and parsed
6951 }
6952 





























6953 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6954                                                  ConstantPool* cp,
6955                                                  TRAPS) {
6956   assert(stream != NULL, &quot;invariant&quot;);
6957   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6958   assert(cp != NULL, &quot;invariant&quot;);
6959   assert(_loader_data != NULL, &quot;invariant&quot;);
6960 
6961   if (_class_name == vmSymbols::java_lang_Object()) {
6962     check_property(_temp_local_interfaces-&gt;length() == 0,
6963         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6964         CHECK);
6965   }
6966   // We check super class after class file is parsed and format is checked
6967   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6968     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6969     if (is_interface()) {
6970       // Before attempting to resolve the superclass, check for class format
6971       // errors not checked yet.
6972       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
</pre>
</td>
<td>
<hr />
<pre>
1124     _method_DontInline,
1125     _method_InjectedProfile,
1126     _method_LambdaForm_Compiled,
1127     _method_Hidden,
1128     _method_HotSpotIntrinsicCandidate,
1129     _jdk_internal_vm_annotation_Contended,
1130     _field_Stable,
1131     _jdk_internal_vm_annotation_ReservedStackAccess,
1132     _annotation_LIMIT
1133   };
1134   const Location _location;
1135   int _annotations_present;
1136   u2 _contended_group;
1137 
1138   AnnotationCollector(Location location)
1139     : _location(location), _annotations_present(0)
1140   {
1141     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1142   }
1143   // If this annotation name has an ID, report it (or _none).
<span class="line-modified">1144   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name, bool can_access_vm_annotations);</span>
1145   // Set the annotation name:
1146   void set_annotation(ID id) {
1147     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1148     _annotations_present |= nth_bit((int)id);
1149   }
1150 
1151   void remove_annotation(ID id) {
1152     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1153     _annotations_present &amp;= ~nth_bit((int)id);
1154   }
1155 
1156   // Report if the annotation is present.
1157   bool has_any_annotations() const { return _annotations_present != 0; }
1158   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1159 
1160   void set_contended_group(u2 group) { _contended_group = group; }
1161   u2 contended_group() const { return _contended_group; }
1162 
1163   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1164 
</pre>
<hr />
<pre>
1257       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1258       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1259         index = skip_annotation_value(buffer, limit, index);
1260       }
1261     }
1262     break;
1263     case &#39;@&#39;:
1264       index = skip_annotation(buffer, limit, index);
1265       break;
1266     default:
1267       return limit;  //  bad tag byte
1268   }
1269   return index;
1270 }
1271 
1272 // Sift through annotations, looking for those significant to the VM:
1273 static void parse_annotations(const ConstantPool* const cp,
1274                               const u1* buffer, int limit,
1275                               AnnotationCollector* coll,
1276                               ClassLoaderData* loader_data,
<span class="line-added">1277                               const bool can_access_vm_annotations,</span>
1278                               TRAPS) {
1279 
1280   assert(cp != NULL, &quot;invariant&quot;);
1281   assert(buffer != NULL, &quot;invariant&quot;);
1282   assert(coll != NULL, &quot;invariant&quot;);
1283   assert(loader_data != NULL, &quot;invariant&quot;);
1284 
1285   // annotations := do(nann:u2) {annotation}
1286   int index = 2; // read nann
1287   if (index &gt;= limit)  return;
1288   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1289   enum {  // initial annotation layout
1290     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1291     count_off = 2,      // u2   such as 1 (one value)
1292     member_off = 4,     // utf8 such as &#39;value&#39;
1293     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1294     e_tag_val = &#39;e&#39;,
1295     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1296     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1297     e_size = 11,     // end of &#39;e&#39; annotation
</pre>
<hr />
<pre>
1303     s_size = 9,
1304     min_size = 6        // smallest possible size (zero members)
1305   };
1306   // Cannot add min_size to index in case of overflow MAX_INT
1307   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1308     int index0 = index;
1309     index = skip_annotation(buffer, limit, index);
1310     const u1* const abase = buffer + index0;
1311     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1312     const int count = Bytes::get_Java_u2((address)abase + count_off);
1313     const Symbol* const aname = check_symbol_at(cp, atype);
1314     if (aname == NULL)  break;  // invalid annotation name
1315     const Symbol* member = NULL;
1316     if (count &gt;= 1) {
1317       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1318       member = check_symbol_at(cp, member_index);
1319       if (member == NULL)  break;  // invalid member name
1320     }
1321 
1322     // Here is where parsing particular annotations will take place.
<span class="line-modified">1323     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname, can_access_vm_annotations);</span>
1324     if (AnnotationCollector::_unknown == id)  continue;
1325     coll-&gt;set_annotation(id);
1326 
1327     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1328       // @Contended can optionally specify the contention group.
1329       //
1330       // Contended group defines the equivalence class over the fields:
1331       // the fields within the same contended group are not treated distinct.
1332       // The only exception is default group, which does not incur the
1333       // equivalence. Naturally, contention group for classes is meaningless.
1334       //
1335       // While the contention group is specified as String, annotation
1336       // values are already interned, and we might as well use the constant
1337       // pool index as the group tag.
1338       //
1339       u2 group_index = 0; // default contended group
1340       if (count == 1
1341         &amp;&amp; s_size == (index - index0)  // match size
1342         &amp;&amp; s_tag_val == *(abase + tag_off)
1343         &amp;&amp; member == vmSymbols::value_name()) {
</pre>
<hr />
<pre>
1429         if (attribute_length != 2) {
1430           classfile_parse_error(
1431             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1432             attribute_length, CHECK);
1433         }
1434         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1435       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1436         if (runtime_visible_annotations != NULL) {
1437           classfile_parse_error(
1438             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1439         }
1440         runtime_visible_annotations_length = attribute_length;
1441         runtime_visible_annotations = cfs-&gt;current();
1442         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1443         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1444         parse_annotations(cp,
1445                           runtime_visible_annotations,
1446                           runtime_visible_annotations_length,
1447                           parsed_annotations,
1448                           _loader_data,
<span class="line-added">1449                           _can_access_vm_annotations,</span>
1450                           CHECK);
1451         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1452       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1453         if (runtime_invisible_annotations_exists) {
1454           classfile_parse_error(
1455             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1456         }
1457         runtime_invisible_annotations_exists = true;
1458         if (PreserveAllAnnotations) {
1459           runtime_invisible_annotations_length = attribute_length;
1460           runtime_invisible_annotations = cfs-&gt;current();
1461           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1462         }
1463         cfs-&gt;skip_u1(attribute_length, CHECK);
1464       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1465         if (runtime_visible_type_annotations != NULL) {
1466           classfile_parse_error(
1467             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1468         }
1469         runtime_visible_type_annotations_length = attribute_length;
</pre>
<hr />
<pre>
2159                                             const Symbol* name,
2160                                             const Symbol* sig,
2161                                             TRAPS) const {
2162   assert(name != NULL, &quot;invariant&quot;);
2163   assert(sig != NULL, &quot;invariant&quot;);
2164 
2165   const char* class_note = &quot;&quot;;
2166   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {
2167     class_note = &quot; (an inline class)&quot;;
2168   }
2169 
2170   ResourceMark rm(THREAD);
2171   Exceptions::fthrow(THREAD_AND_LOCATION,
2172       vmSymbols::java_lang_ClassFormatError(),
2173       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,
2174       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());
2175 }
2176 
2177 AnnotationCollector::ID
2178 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
<span class="line-modified">2179                                       const Symbol* name,</span>
<span class="line-added">2180                                       const bool can_access_vm_annotations) {</span>
2181   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2182   // Privileged code can use all annotations.  Other code silently drops some.
<span class="line-modified">2183   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||</span>
2184                           loader_data-&gt;is_platform_class_loader_data() ||
<span class="line-modified">2185                           can_access_vm_annotations;</span>
2186   switch (sid) {
2187     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2188       if (_location != _in_method)  break;  // only allow for methods
2189       if (!privileged)              break;  // only allow in privileged code
2190       return _method_CallerSensitive;
2191     }
2192     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2193       if (_location != _in_method)  break;  // only allow for methods
2194       if (!privileged)              break;  // only allow in privileged code
2195       return _method_ForceInline;
2196     }
2197     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2198       if (_location != _in_method)  break;  // only allow for methods
2199       if (!privileged)              break;  // only allow in privileged code
2200       return _method_DontInline;
2201     }
2202     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2203       if (_location != _in_method)  break;  // only allow for methods
2204       if (!privileged)              break;  // only allow in privileged code
2205       return _method_InjectedProfile;
</pre>
<hr />
<pre>
2815           classfile_parse_error(
2816             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2817             method_attribute_length, CHECK_NULL);
2818         }
2819         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2820       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2821         if (runtime_visible_annotations != NULL) {
2822           classfile_parse_error(
2823             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2824             CHECK_NULL);
2825         }
2826         runtime_visible_annotations_length = method_attribute_length;
2827         runtime_visible_annotations = cfs-&gt;current();
2828         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2829         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2830         parse_annotations(cp,
2831                           runtime_visible_annotations,
2832                           runtime_visible_annotations_length,
2833                           &amp;parsed_annotations,
2834                           _loader_data,
<span class="line-added">2835                           _can_access_vm_annotations,</span>
2836                           CHECK_NULL);
2837         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2838       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2839         if (runtime_invisible_annotations_exists) {
2840           classfile_parse_error(
2841             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2842             CHECK_NULL);
2843         }
2844         runtime_invisible_annotations_exists = true;
2845         if (PreserveAllAnnotations) {
2846           runtime_invisible_annotations_length = method_attribute_length;
2847           runtime_invisible_annotations = cfs-&gt;current();
2848           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2849         }
2850         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2851       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2852         if (runtime_visible_parameter_annotations != NULL) {
2853           classfile_parse_error(
2854             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2855             CHECK_NULL);
</pre>
<hr />
<pre>
3010                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
3011                                                 sizeof(u2));
3012   }
3013 
3014   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
3015   if (total_lvt_length &gt; 0) {
3016     promoted_flags-&gt;set_has_localvariable_table();
3017     copy_localvariable_table(m-&gt;constMethod(),
3018                              lvt_cnt,
3019                              localvariable_table_length,
3020                              localvariable_table_start,
3021                              lvtt_cnt,
3022                              localvariable_type_table_length,
3023                              localvariable_type_table_start,
3024                              CHECK_NULL);
3025   }
3026 
3027   if (parsed_annotations.has_any_annotations())
3028     parsed_annotations.apply_to(methodHandle(THREAD, m));
3029 
<span class="line-added">3030   if (is_hidden()) { // Mark methods in hidden classes as &#39;hidden&#39;.</span>
<span class="line-added">3031     m-&gt;set_hidden(true);</span>
<span class="line-added">3032   }</span>
<span class="line-added">3033 </span>
3034   // Copy annotations
3035   copy_method_annotations(m-&gt;constMethod(),
3036                           runtime_visible_annotations,
3037                           runtime_visible_annotations_length,
3038                           runtime_invisible_annotations,
3039                           runtime_invisible_annotations_length,
3040                           runtime_visible_parameter_annotations,
3041                           runtime_visible_parameter_annotations_length,
3042                           runtime_invisible_parameter_annotations,
3043                           runtime_invisible_parameter_annotations_length,
3044                           runtime_visible_type_annotations,
3045                           runtime_visible_type_annotations_length,
3046                           runtime_invisible_type_annotations,
3047                           runtime_invisible_type_annotations_length,
3048                           annotation_default,
3049                           annotation_default_length,
3050                           CHECK_NULL);
3051 
3052   if (name == vmSymbols::finalize_method_name() &amp;&amp;
3053       signature == vmSymbols::void_method_signature()) {
</pre>
<hr />
<pre>
3753         if (attribute_length != 2) {
3754           classfile_parse_error(
3755             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3756             attribute_length, CHECK);
3757         }
3758         parse_classfile_signature_attribute(cfs, CHECK);
3759       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3760         if (runtime_visible_annotations != NULL) {
3761           classfile_parse_error(
3762             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3763         }
3764         runtime_visible_annotations_length = attribute_length;
3765         runtime_visible_annotations = cfs-&gt;current();
3766         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3767         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3768         parse_annotations(cp,
3769                           runtime_visible_annotations,
3770                           runtime_visible_annotations_length,
3771                           parsed_annotations,
3772                           _loader_data,
<span class="line-added">3773                           _can_access_vm_annotations,</span>
3774                           CHECK);
3775         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3776       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3777         if (runtime_invisible_annotations_exists) {
3778           classfile_parse_error(
3779             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3780         }
3781         runtime_invisible_annotations_exists = true;
3782         if (PreserveAllAnnotations) {
3783           runtime_invisible_annotations_length = attribute_length;
3784           runtime_invisible_annotations = cfs-&gt;current();
3785           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3786         }
3787         cfs-&gt;skip_u1(attribute_length, CHECK);
3788       } else if (tag == vmSymbols::tag_enclosing_method()) {
3789         if (parsed_enclosingmethod_attribute) {
3790           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3791         } else {
3792           parsed_enclosingmethod_attribute = true;
3793         }
</pre>
<hr />
<pre>
6036 
6037           if (!match) {
6038             char buf[1000];
6039             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
6040                        &quot;but the method is not available in class [%s].%s&quot;,
6041                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
6042                                                              buf, sizeof(buf)),
6043                         ik-&gt;name()-&gt;as_C_string(),
6044                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6045             );
6046             tty-&gt;cr();
6047             DEBUG_ONLY(vm_exit(1));
6048           }
6049         }
6050       } // end for
6051     } // CheckIntrinsics
6052 #endif // ASSERT
6053   }
6054 }
6055 
<span class="line-modified">6056 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook,</span>
<span class="line-modified">6057                                                       const ClassInstanceInfo&amp; cl_inst_info,</span>
<span class="line-added">6058                                                       TRAPS) {</span>
6059   if (_klass != NULL) {
6060     return _klass;
6061   }
6062 
6063   InstanceKlass* const ik =
6064     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
6065 
<span class="line-modified">6066   if (is_hidden()) {</span>
<span class="line-added">6067     mangle_hidden_class_name(ik);</span>
<span class="line-added">6068   }</span>
<span class="line-added">6069 </span>
<span class="line-added">6070   fill_instance_klass(ik, changed_by_loadhook, cl_inst_info, CHECK_NULL);</span>
<span class="line-added">6071 </span>
6072   assert(_klass == ik, &quot;invariant&quot;);
6073 
6074 
6075   if (ik-&gt;should_store_fingerprint()) {
6076     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6077   }
6078 
6079   ik-&gt;set_has_passed_fingerprint_check(false);
6080   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6081     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6082     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6083     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6084       // This class matches with a class saved in an AOT library
6085       ik-&gt;set_has_passed_fingerprint_check(true);
6086     } else {
6087       ResourceMark rm;
6088       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6089                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6090     }
6091   }
</pre>
<hr />
<pre>
6116   if (!access_flags().is_abstract() || _has_nonstatic_fields) {
6117     return true;
6118   } else {
6119     // Look at each method
6120     for (int x = 0; x &lt; _methods-&gt;length(); x++) {
6121       const Method* const method = _methods-&gt;at(x);
6122       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {
6123         return true;
6124 
6125       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {
6126         if (method-&gt;signature() != vmSymbols::void_method_signature() ||
6127             !method-&gt;is_vanilla_constructor()) {
6128           return true;
6129         }
6130       }
6131     }
6132   }
6133   return false;
6134 }
6135 
<span class="line-modified">6136 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,</span>
<span class="line-added">6137                                           bool changed_by_loadhook,</span>
<span class="line-added">6138                                           const ClassInstanceInfo&amp; cl_inst_info,</span>
<span class="line-added">6139                                           TRAPS) {</span>
6140   assert(ik != NULL, &quot;invariant&quot;);
6141 
6142   // Set name and CLD before adding to CLD
6143   ik-&gt;set_class_loader_data(_loader_data);
6144   ik-&gt;set_name(_class_name);
6145 
6146   // Add all classes to our internal class loader list here,
6147   // including classes in the bootstrap (NULL) class loader.
6148   const bool publicize = !is_internal();
6149 
6150   _loader_data-&gt;add_class(ik, publicize);
6151 
6152   set_klass_to_deallocate(ik);
6153 
6154   assert(_field_info != NULL, &quot;invariant&quot;);
6155   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6156   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6157          &quot;sanity&quot;);
6158 
6159   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
</pre>
<hr />
<pre>
6170   }
6171   if (_is_empty_inline_type) {
6172     ik-&gt;set_is_empty_inline_type();
6173   }
6174 
6175   if (this-&gt;_invalid_inline_super) {
6176     ik-&gt;set_invalid_inline_super();
6177   }
6178 
6179   if (_has_injected_identityObject) {
6180     ik-&gt;set_has_injected_identityObject();
6181   }
6182 
6183   assert(_fac != NULL, &quot;invariant&quot;);
6184   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6185 
6186   // this transfers ownership of a lot of arrays from
6187   // the parser onto the InstanceKlass*
6188   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6189 
<span class="line-added">6190   // can only set dynamic nest-host after static nest information is set</span>
<span class="line-added">6191   if (cl_inst_info.dynamic_nest_host() != NULL) {</span>
<span class="line-added">6192     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);</span>
<span class="line-added">6193   }</span>
<span class="line-added">6194 </span>
6195   // note that is not safe to use the fields in the parser from this point on
6196   assert(NULL == _cp, &quot;invariant&quot;);
6197   assert(NULL == _fields, &quot;invariant&quot;);
6198   assert(NULL == _methods, &quot;invariant&quot;);
6199   assert(NULL == _inner_classes, &quot;invariant&quot;);
6200   assert(NULL == _nest_members, &quot;invariant&quot;);
6201   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6202   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6203   assert(NULL == _record_components, &quot;invariant&quot;);
6204 
6205   if (_has_final_method) {
6206     ik-&gt;set_has_final_method();
6207   }
6208 
6209   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6210   // The InstanceKlass::_methods_jmethod_ids cache
6211   // is managed on the assumption that the initial cache
6212   // size is equal to the number of methods in the class. If
6213   // that changes, then InstanceKlass::idnum_can_increment()
6214   // has to be changed accordingly.
6215   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6216 
6217   ik-&gt;set_this_class_index(_this_class_index);
6218 
<span class="line-modified">6219   if (_is_hidden || is_unsafe_anonymous()) {</span>
6220     // _this_class_index is a CONSTANT_Class entry that refers to this
<span class="line-modified">6221     // hidden or anonymous class itself. If this class needs to refer to its own</span>
<span class="line-modified">6222     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference</span>
<span class="line-modified">6223     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s</span>
6224     // not stored in SystemDictionary), _this_class_index cannot be resolved
6225     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6226     // Therefore, we must eagerly resolve _this_class_index now.
6227     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6228   }
6229 
6230   ik-&gt;set_minor_version(_minor_version);
6231   ik-&gt;set_major_version(_major_version);
6232   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6233   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
6234   if (_is_declared_atomic) {
6235     ik-&gt;set_is_declared_atomic();
6236   }
6237 
6238   if (_unsafe_anonymous_host != NULL) {
6239     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6240     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6241   }
<span class="line-added">6242   if (_is_hidden) {</span>
<span class="line-added">6243     ik-&gt;set_is_hidden();</span>
<span class="line-added">6244   }</span>
6245 
6246   // Set PackageEntry for this_klass
6247   oop cl = ik-&gt;class_loader();
6248   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6249   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6250   ik-&gt;set_package(cld, NULL, CHECK);
6251 
6252   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6253   assert(methods != NULL, &quot;invariant&quot;);
6254   const int methods_len = methods-&gt;length();
6255 
6256   check_methods_for_intrinsics(ik, methods);
6257 
6258   // Fill in field values obtained by parse_classfile_attributes
6259   if (_parsed_annotations-&gt;has_any_annotations()) {
6260     _parsed_annotations-&gt;apply_to(ik);
6261   }
6262 
6263   apply_parsed_class_attributes(ik);
6264 
</pre>
<hr />
<pre>
6304   check_final_method_override(ik, CHECK);
6305 
6306   // reject static interface methods prior to Java 8
6307   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
6308     check_illegal_static_method(ik, CHECK);
6309   }
6310 
6311   // Obtain this_klass&#39; module entry
6312   ModuleEntry* module_entry = ik-&gt;module();
6313   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
6314 
6315   // Obtain java.lang.Module
6316   Handle module_handle(THREAD, module_entry-&gt;module());
6317 
6318   // Allocate mirror and initialize static fields
6319   // The create_mirror() call will also call compute_modifiers()
6320   java_lang_Class::create_mirror(ik,
6321                                  Handle(THREAD, _loader_data-&gt;class_loader()),
6322                                  module_handle,
6323                                  _protection_domain,
<span class="line-added">6324                                  cl_inst_info.class_data(),</span>
6325                                  CHECK);
6326 
6327   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6328 
6329   // Generate any default methods - default methods are public interface methods
6330   // that have a default implementation.  This is new with Java 8.
6331   if (_has_nonstatic_concrete_methods) {
6332     DefaultMethods::generate_default_methods(ik,
6333                                              _all_mirandas,
6334                                              CHECK);
6335   }
6336 
6337   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6338   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6339       !module_entry-&gt;has_default_read_edges()) {
6340     if (!module_entry-&gt;set_has_default_read_edges()) {
6341       // We won a potential race
6342       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6343     }
6344   }
</pre>
<hr />
<pre>
6427   set_klass(ik);
6428 
6429   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {
6430     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);
6431   }
6432 
6433   debug_only(ik-&gt;verify();)
6434 }
6435 
6436 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6437   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6438   _class_name-&gt;decrement_refcount();
6439 
6440   _class_name = new_class_name;
6441   // Increment the refcount of the new name.
6442   // Now the ClassFileParser owns this name and will decrement in
6443   // the destructor.
6444   _class_name-&gt;increment_refcount();
6445 }
6446 

6447 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6448 // package by prepending its host class&#39;s package name to its class name and setting
6449 // its _class_name field.
6450 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6451   ResourceMark rm(THREAD);
6452   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
6453          &quot;Unsafe anonymous class should not be in a package&quot;);
6454   TempNewSymbol host_pkg_name =
6455     ClassLoader::package_from_class_name(unsafe_anonymous_host-&gt;name());
6456 
6457   if (host_pkg_name != NULL) {
6458     int host_pkg_len = host_pkg_name-&gt;utf8_length();
6459     int class_name_len = _class_name-&gt;utf8_length();
6460     int symbol_len = host_pkg_len + 1 + class_name_len;
6461     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
6462     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%.*s/%.*s&quot;,
6463                          host_pkg_len, host_pkg_name-&gt;base(), class_name_len, _class_name-&gt;base());
6464     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
6465 
6466     // Decrement old _class_name to avoid leaking.
</pre>
<hr />
<pre>
6479 // host&#39;s package.  If the classes are in different packages then throw an IAE
6480 // exception.
6481 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
6482   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
6483 
6484   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
6485                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
6486   if (anon_last_slash == NULL) {  // Unnamed package
6487     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
6488   } else {
6489     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
6490       ResourceMark rm(THREAD);
6491       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
6492         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
6493         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
6494     }
6495   }
6496 }
6497 
6498 static bool relax_format_check_for(ClassLoaderData* loader_data) {
<span class="line-modified">6499   bool trusted = loader_data-&gt;is_boot_class_loader_data() ||</span>
<span class="line-modified">6500                  loader_data-&gt;is_platform_class_loader_data();</span>
6501   bool need_verify =
6502     // verifyAll
6503     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
6504     // verifyRemote
6505     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
6506   return !need_verify;
6507 }
6508 
6509 ClassFileParser::ClassFileParser(ClassFileStream* stream,
6510                                  Symbol* name,
6511                                  ClassLoaderData* loader_data,
<span class="line-modified">6512                                  const ClassLoadInfo* cl_info,</span>


6513                                  Publicity pub_level,
6514                                  TRAPS) :
6515   _stream(stream),

6516   _class_name(NULL),
6517   _loader_data(loader_data),
<span class="line-modified">6518   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),</span>
<span class="line-modified">6519   _cp_patches(cl_info-&gt;cp_patches()),</span>
<span class="line-added">6520   _is_hidden(cl_info-&gt;is_hidden()),</span>
<span class="line-added">6521   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),</span>
6522   _num_patched_klasses(0),
6523   _max_num_patched_klasses(0),
6524   _orig_cp_size(0),
6525   _first_patched_klass_resolved_index(0),
6526   _super_klass(),
6527   _cp(NULL),
6528   _fields(NULL),
6529   _methods(NULL),
6530   _inner_classes(NULL),
6531   _nest_members(NULL),
6532   _nest_host(0),
6533   _record_components(NULL),
6534   _temp_local_interfaces(NULL),
6535   _local_interfaces(NULL),
6536   _transitive_interfaces(NULL),
6537   _combined_annotations(NULL),
6538   _class_annotations(NULL),
6539   _class_type_annotations(NULL),
6540   _fields_annotations(NULL),
6541   _fields_type_annotations(NULL),
6542   _klass(NULL),
6543   _klass_to_deallocate(NULL),
6544   _parsed_annotations(NULL),
6545   _fac(NULL),
6546   _field_info(NULL),
6547   _method_ordering(NULL),
6548   _all_mirandas(NULL),
6549   _vtable_size(0),
6550   _itable_size(0),
6551   _num_miranda_methods(0),
6552   _rt(REF_NONE),
<span class="line-modified">6553   _protection_domain(cl_info-&gt;protection_domain()),</span>
6554   _access_flags(),
6555   _pub_level(pub_level),
6556   _bad_constant_seen(0),
6557   _synthetic_flag(false),
6558   _sde_length(false),
6559   _sde_buffer(NULL),
6560   _sourcefile_index(0),
6561   _generic_signature_index(0),
6562   _major_version(0),
6563   _minor_version(0),
6564   _this_class_index(0),
6565   _super_class_index(0),
6566   _itfs_len(0),
6567   _java_fields_count(0),
6568   _need_verify(false),
6569   _relax_verify(false),
6570   _has_nonstatic_concrete_methods(false),
6571   _declares_nonstatic_concrete_methods(false),
6572   _has_final_method(false),
6573   _has_contended_fields(false),
</pre>
<hr />
<pre>
6745             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6746     Exceptions::fthrow(
6747       THREAD_AND_LOCATION,
6748       vmSymbols::java_lang_UnsupportedClassVersionError(),
6749       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6750       _major_version,
6751       _minor_version);
6752   }
6753 
6754   // Check version numbers - we check this even with verifier off
6755   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6756 
6757   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6758   u2 cp_size = stream-&gt;get_u2_fast();
6759 
6760   guarantee_property(
6761     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6762     cp_size, CHECK);
6763 
6764   _orig_cp_size = cp_size;
<span class="line-modified">6765   if (is_hidden()) { // Add a slot for hidden class name.</span>
<span class="line-modified">6766     assert(_max_num_patched_klasses == 0, &quot;Sanity check&quot;);</span>
<span class="line-added">6767     cp_size++;</span>
<span class="line-added">6768   } else {</span>
<span class="line-added">6769     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {</span>
<span class="line-added">6770       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);</span>
<span class="line-added">6771     }</span>
<span class="line-added">6772     cp_size += _max_num_patched_klasses;</span>
6773   }

6774 
6775   _cp = ConstantPool::allocate(_loader_data,
6776                                cp_size,
6777                                CHECK);
6778 
6779   ConstantPool* const cp = _cp;
6780 
6781   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6782 
6783   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6784 
6785   // ACCESS FLAGS
6786   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6787 
6788   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;
6789   // JVM_ACC_MODULE is defined in JDK-9 and later.
6790   if (_major_version &gt;= JAVA_9_VERSION) {
6791     recognized_modifiers |= JVM_ACC_MODULE;
6792   }
6793   // JVM_ACC_VALUE is defined for class file version 55 and later
</pre>
<hr />
<pre>
6808   short bad_constant = class_bad_constant_seen();
6809   if (bad_constant != 0) {
6810     // Do not throw CFE until after the access_flags are checked because if
6811     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6812     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6813   }
6814 
6815   _access_flags.set_flags(flags);
6816 
6817   // This class and superclass
6818   _this_class_index = stream-&gt;get_u2_fast();
6819   check_property(
6820     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6821       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6822     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6823     _this_class_index, CHECK);
6824 
6825   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6826   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6827 



6828   // Don&#39;t need to check whether this class name is legal or not.
6829   // It has been checked when constant pool is parsed.
6830   // However, make sure it is not an array type.
6831   if (_need_verify) {
<span class="line-modified">6832     guarantee_property(class_name_in_cp-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,</span>
6833                        &quot;Bad class name in class file %s&quot;,
6834                        CHECK);
6835   }
6836 
<span class="line-modified">6837 #ifdef ASSERT</span>
<span class="line-modified">6838   // Basic sanity checks</span>
<span class="line-modified">6839   assert(!(_is_hidden &amp;&amp; (_unsafe_anonymous_host != NULL)), &quot;mutually exclusive variants&quot;);</span>
<span class="line-modified">6840 </span>
<span class="line-modified">6841   if (_unsafe_anonymous_host != NULL) {</span>
<span class="line-modified">6842     assert(_class_name == vmSymbols::unknown_class_name(), &quot;A named anonymous class???&quot;);</span>
<span class="line-modified">6843   }</span>
<span class="line-modified">6844   if (_is_hidden) {</span>
<span class="line-modified">6845     assert(_class_name != vmSymbols::unknown_class_name(), &quot;hidden classes should have a special name&quot;);</span>


6846   }
<span class="line-added">6847 #endif</span>
<span class="line-added">6848 </span>
<span class="line-added">6849   // Update the _class_name as needed depending on whether this is a named,</span>
<span class="line-added">6850   // un-named, hidden or unsafe-anonymous class.</span>
<span class="line-added">6851 </span>
<span class="line-added">6852   if (_is_hidden) {</span>
<span class="line-added">6853     assert(_class_name != NULL, &quot;Unexpected null _class_name&quot;);</span>
<span class="line-added">6854 #ifdef ASSERT</span>
<span class="line-added">6855     if (_need_verify) {</span>
<span class="line-added">6856       verify_legal_class_name(_class_name, CHECK);</span>
<span class="line-added">6857     }</span>
<span class="line-added">6858 #endif</span>
<span class="line-added">6859 </span>
<span class="line-added">6860   // NOTE: !_is_hidden does not imply &quot;findable&quot; as it could be an old-style</span>
<span class="line-added">6861   //       &quot;hidden&quot; unsafe-anonymous class</span>
6862 
<span class="line-modified">6863   // If this is an anonymous class fix up its name if it is in the unnamed</span>
6864   // package.  Otherwise, throw IAE if it is in a different package than
6865   // its host class.
<span class="line-modified">6866   } else if (_unsafe_anonymous_host != NULL) {</span>
<span class="line-added">6867     update_class_name(class_name_in_cp);</span>
6868     fix_unsafe_anonymous_class_name(CHECK);
<span class="line-added">6869 </span>
<span class="line-added">6870   } else {</span>
<span class="line-added">6871     // Check if name in class file matches given name</span>
<span class="line-added">6872     if (_class_name != class_name_in_cp) {</span>
<span class="line-added">6873       if (_class_name != vmSymbols::unknown_class_name()) {</span>
<span class="line-added">6874         ResourceMark rm(THREAD);</span>
<span class="line-added">6875         Exceptions::fthrow(THREAD_AND_LOCATION,</span>
<span class="line-added">6876                            vmSymbols::java_lang_NoClassDefFoundError(),</span>
<span class="line-added">6877                            &quot;%s (wrong name: %s)&quot;,</span>
<span class="line-added">6878                            class_name_in_cp-&gt;as_C_string(),</span>
<span class="line-added">6879                            _class_name-&gt;as_C_string()</span>
<span class="line-added">6880                            );</span>
<span class="line-added">6881         return;</span>
<span class="line-added">6882       } else {</span>
<span class="line-added">6883         // The class name was not known by the caller so we set it from</span>
<span class="line-added">6884         // the value in the CP.</span>
<span class="line-added">6885         update_class_name(class_name_in_cp);</span>
<span class="line-added">6886       }</span>
<span class="line-added">6887       // else nothing to do: the expected class name matches what is in the CP</span>
<span class="line-added">6888     }</span>
6889   }
6890 
6891   // Verification prevents us from creating names with dots in them, this
6892   // asserts that that&#39;s the case.
6893   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6894 
6895   if (!is_internal()) {
6896     LogTarget(Debug, class, preorder) lt;
6897     if (lt.is_enabled()){
6898       ResourceMark rm(THREAD);
6899       LogStream ls(lt);
6900       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
6901       if (stream-&gt;source() != NULL) {
6902         ls.print(&quot; source: %s&quot;, stream-&gt;source());
6903       }
6904       ls.cr();
6905     }
6906 
6907 #if INCLUDE_CDS
6908     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6909       if (!ClassLoader::has_jrt_entry()) {
6910         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6911         DumpLoadedClassList = NULL;
6912       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
<span class="line-added">6913                  !_is_hidden &amp;&amp;</span>
6914                  _unsafe_anonymous_host == NULL) {
6915         // Only dump the classes that can be stored into CDS archive.
<span class="line-modified">6916         // Hidden and unsafe anonymous classes such as generated LambdaForm classes are also not included.</span>
6917         oop class_loader = _loader_data-&gt;class_loader();
6918         ResourceMark rm(THREAD);
6919         bool skip = false;
6920         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6921           // For the boot and platform class loaders, skip classes that are not found in the
6922           // java runtime image, such as those found in the --patch-module entries.
6923           // These classes can&#39;t be loaded from the archive during runtime.
6924           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
6925             skip = true;
6926           }
6927 
6928           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6929             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6930             // as they can be loaded from the archive during runtime.
6931             skip = false;
6932           }
6933         }
6934         if (skip) {
6935           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6936             _class_name-&gt;as_C_string(), stream-&gt;source());
</pre>
<hr />
<pre>
6995   }
6996 
6997   // Additional attributes/annotations
6998   _parsed_annotations = new ClassAnnotationCollector();
6999   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
7000 
7001   assert(_inner_classes != NULL, &quot;invariant&quot;);
7002 
7003   // Finalize the Annotations metadata object,
7004   // now that all annotation arrays have been created.
7005   create_combined_annotations(CHECK);
7006 
7007   // Make sure this is the end of class file stream
7008   guarantee_property(stream-&gt;at_eos(),
7009                      &quot;Extra bytes at the end of class file %s&quot;,
7010                      CHECK);
7011 
7012   // all bytes in stream read and parsed
7013 }
7014 
<span class="line-added">7015 void ClassFileParser::mangle_hidden_class_name(InstanceKlass* const ik) {</span>
<span class="line-added">7016   ResourceMark rm;</span>
<span class="line-added">7017   // Construct hidden name from _class_name, &quot;+&quot;, and &amp;ik. Note that we can&#39;t</span>
<span class="line-added">7018   // use a &#39;/&#39; because that confuses finding the class&#39;s package.  Also, can&#39;t</span>
<span class="line-added">7019   // use an illegal char such as &#39;;&#39; because that causes serialization issues</span>
<span class="line-added">7020   // and issues with hidden classes that create their own hidden classes.</span>
<span class="line-added">7021   char addr_buf[20];</span>
<span class="line-added">7022   jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));</span>
<span class="line-added">7023   size_t new_name_len = _class_name-&gt;utf8_length() + 2 + strlen(addr_buf);</span>
<span class="line-added">7024   char* new_name = NEW_RESOURCE_ARRAY(char, new_name_len);</span>
<span class="line-added">7025   jio_snprintf(new_name, new_name_len, &quot;%s+%s&quot;,</span>
<span class="line-added">7026                _class_name-&gt;as_C_string(), addr_buf);</span>
<span class="line-added">7027   update_class_name(SymbolTable::new_symbol(new_name));</span>
<span class="line-added">7028 </span>
<span class="line-added">7029   // Add a Utf8 entry containing the hidden name.</span>
<span class="line-added">7030   assert(_class_name != NULL, &quot;Unexpected null _class_name&quot;);</span>
<span class="line-added">7031   int hidden_index = _orig_cp_size; // this is an extra slot we added</span>
<span class="line-added">7032   _cp-&gt;symbol_at_put(hidden_index, _class_name);</span>
<span class="line-added">7033 </span>
<span class="line-added">7034   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.</span>
<span class="line-added">7035   // We have to update the resolved_klass_index and the name_index together</span>
<span class="line-added">7036   // so extract the existing resolved_klass_index first.</span>
<span class="line-added">7037   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);</span>
<span class="line-added">7038   int resolved_klass_index = cp_klass_slot.resolved_klass_index();</span>
<span class="line-added">7039   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);</span>
<span class="line-added">7040   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,</span>
<span class="line-added">7041          &quot;Bad name_index&quot;);</span>
<span class="line-added">7042 }</span>
<span class="line-added">7043 </span>
7044 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
7045                                                  ConstantPool* cp,
7046                                                  TRAPS) {
7047   assert(stream != NULL, &quot;invariant&quot;);
7048   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
7049   assert(cp != NULL, &quot;invariant&quot;);
7050   assert(_loader_data != NULL, &quot;invariant&quot;);
7051 
7052   if (_class_name == vmSymbols::java_lang_Object()) {
7053     check_property(_temp_local_interfaces-&gt;length() == 0,
7054         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
7055         CHECK);
7056   }
7057   // We check super class after class file is parsed and format is checked
7058   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
7059     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
7060     if (is_interface()) {
7061       // Before attempting to resolve the superclass, check for class format
7062       // errors not checked yet.
7063       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciInstanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
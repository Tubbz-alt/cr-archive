<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 634 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 635   assert(value_equals(value, java_lang_String::value(java_string)),
 636          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 637   int length = java_lang_String::length(java_string, value);
 638   if (length == 0) {
 639     return 0;
 640   }
 641   if (!java_lang_String::is_latin1(java_string)) {
 642     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 643   } else {
 644     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 645   }
 646 }
 647 
 648 int java_lang_String::utf8_length(oop java_string) {
 649   typeArrayOop value = java_lang_String::value(java_string);
 650   return utf8_length(java_string, value);
 651 }
 652 
 653 char* java_lang_String::as_utf8_string(oop java_string) {
<span class="line-modified"> 654   typeArrayOop value  = java_lang_String::value(java_string);</span>
<span class="line-modified"> 655   int          length = java_lang_String::length(java_string, value);</span>
<span class="line-modified"> 656   bool      is_latin1 = java_lang_String::is_latin1(java_string);</span>





 657   if (!is_latin1) {
 658     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 659     return UNICODE::as_utf8(position, length);
 660   } else {
 661     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 662     return UNICODE::as_utf8(position, length);
 663   }
 664 }
 665 























 666 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 667   assert(value_equals(value, java_lang_String::value(java_string)),
 668          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 669   int     length = java_lang_String::length(java_string, value);
 670   bool is_latin1 = java_lang_String::is_latin1(java_string);
 671   if (!is_latin1) {
 672     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 673     return UNICODE::as_utf8(position, length, buf, buflen);
 674   } else {
 675     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 676     return UNICODE::as_utf8(position, length, buf, buflen);
 677   }
 678 }
 679 
 680 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 681   typeArrayOop value = java_lang_String::value(java_string);
 682   return as_utf8_string(java_string, value, buf, buflen);
 683 }
 684 
 685 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
</pre>
<hr />
<pre>
 837       // update all the static field offsets to included the size.
 838       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 839         if (fs.access_flags().is_static()) {
 840           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 841           fs.set_offset(real_offset);
 842         }
 843       }
 844     }
 845   }
 846 
 847   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 848     if (HeapShared::open_archive_heap_region_mapped()) {
 849       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 850       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 851       return;
 852     } else {
 853       k-&gt;set_java_mirror_handle(NULL);
 854       k-&gt;clear_has_raw_archived_mirror();
 855     }
 856   }
<span class="line-modified"> 857   create_mirror(k, Handle(), Handle(), Handle(), CHECK);</span>
 858 }
 859 
 860 void java_lang_Class::initialize_mirror_fields(Klass* k,
 861                                                Handle mirror,
 862                                                Handle protection_domain,

 863                                                TRAPS) {
 864   // Allocate a simple java object for a lock.
 865   // This needs to be a java object because during class initialization
 866   // it can be held across a java call.
 867   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 868   set_init_lock(mirror(), r);
 869 
 870   // Set protection domain also
 871   set_protection_domain(mirror(), protection_domain());
 872 
 873   // Initialize static fields
 874   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);



 875 }
 876 
 877 // Set the java.lang.Module module field in the java_lang_Class mirror
 878 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 879   if (module.is_null()) {
 880     // During startup, the module may be NULL only if java.base has not been defined yet.
 881     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 882     // for java.base is known. But note that since we captured the NULL module another
 883     // thread may have completed that initialization.
 884 
 885     bool javabase_was_defined = false;
 886     {
 887       MutexLocker m1(THREAD, Module_lock);
 888       // Keep list of classes needing java.base module fixup
 889       if (!ModuleEntryTable::javabase_defined()) {
 890         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 891         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 892         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 893         fixup_module_field_list()-&gt;push(k);
 894       } else {
</pre>
<hr />
<pre>
 908     assert(Universe::is_module_initialized() ||
 909            (ModuleEntryTable::javabase_defined() &amp;&amp;
 910             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 911            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 912     set_module(mirror(), module());
 913   }
 914 }
 915 
 916 // Statically allocate fixup lists because they always get created.
 917 void java_lang_Class::allocate_fixup_lists() {
 918   GrowableArray&lt;Klass*&gt;* mirror_list =
 919     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 920   set_fixup_mirror_list(mirror_list);
 921 
 922   GrowableArray&lt;Klass*&gt;* module_list =
 923     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 924   set_fixup_module_field_list(module_list);
 925 }
 926 
 927 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
<span class="line-modified"> 928                                     Handle module, Handle protection_domain, TRAPS) {</span>

 929   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 930   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 931 
 932   // Use this moment of initialization to cache modifier_flags also,
 933   // to support Class.getModifiers().  Instance classes recalculate
 934   // the cached flags after the class file is parsed, but before the
 935   // class is put into the system dictionary.
 936   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 937   k-&gt;set_modifier_flags(computed_modifiers);
 938   // Class_klass has to be loaded because it is used to allocate
 939   // the mirror.
 940   if (SystemDictionary::Class_klass_loaded()) {
 941     // Allocate mirror (java.lang.Class instance)
 942     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 943     Handle mirror(THREAD, mirror_oop);
 944     Handle comp_mirror;
 945 
 946     // Setup indirection from mirror-&gt;klass
 947     java_lang_Class::set_klass(mirror(), k);
 948 
</pre>
<hr />
<pre>
 960         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());
 961       } else if (k-&gt;is_typeArray_klass()) {
 962         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 963         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 964       } else {
 965         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 966         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 967         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 968         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 969       }
 970       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 971 
 972       // Two-way link between the array klass and its component mirror:
 973       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 974       set_component_mirror(mirror(), comp_mirror());
 975       // See below for ordering dependencies between field array_klass in component mirror
 976       // and java_mirror in this klass.
 977     } else {
 978       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
 979 
<span class="line-modified"> 980       initialize_mirror_fields(k, mirror, protection_domain, THREAD);</span>
 981       if (HAS_PENDING_EXCEPTION) {
 982         // If any of the fields throws an exception like OOM remove the klass field
 983         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
 984         // This mirror looks like a primitive type, which logically it is because it
 985         // it represents no class.
 986         java_lang_Class::set_klass(mirror(), NULL);
 987         return;
 988       }
 989     }
 990 
 991     // set the classLoader field in the java_lang_Class instance
 992     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
 993     set_class_loader(mirror(), class_loader());
 994 
 995     // Setup indirection from klass-&gt;mirror
 996     // after any exceptions can happen during allocations.
 997     k-&gt;set_java_mirror(mirror);
 998 
 999     // Set the module field in the java_lang_Class instance.  This must be done
1000     // after the mirror is set.
</pre>
<hr />
<pre>
1268       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1269       p2i(arr), p2i(reloc_arr));
1270     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1271   }
1272   return archived_mirror;
1273 }
1274 
1275 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1276   if (MetaspaceShared::relocation_delta() != 0) {
1277     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1278 
1279     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1280     if (ak != NULL) {
1281       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1282           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1283     }
1284   }
1285 }
1286 
1287 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
<span class="line-modified">1288   if (MetaspaceShared::relocation_delta() != 0) {</span>
<span class="line-removed">1289     Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));</span>
<span class="line-removed">1290     archived_mirror-&gt;metadata_field_put(_klass_offset,</span>
<span class="line-removed">1291         (Klass*)(address(k) + MetaspaceShared::relocation_delta()));</span>
1292 
<span class="line-modified">1293     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));</span>
<span class="line-modified">1294     if (ak != NULL) {</span>
<span class="line-modified">1295       archived_mirror-&gt;metadata_field_put(_array_klass_offset,</span>
<span class="line-modified">1296           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));</span>
<span class="line-modified">1297     }</span>



1298   }
1299 }
1300 
1301 
1302 // Returns true if the mirror is updated, false if no archived mirror
1303 // data is present. After the archived mirror object is restored, the
1304 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1305 bool java_lang_Class::restore_archived_mirror(Klass *k,
1306                                               Handle class_loader, Handle module,
1307                                               Handle protection_domain, TRAPS) {
1308   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1309   // see more details in SystemDictionary::resolve_well_known_classes().
1310   if (!SystemDictionary::Class_klass_loaded()) {
1311     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1312     fixup_mirror_list()-&gt;push(k);
1313     return true;
1314   }
1315 
1316   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1317   if (m == NULL) {
1318     return false;
1319   }
1320 
1321   // mirror is archived, restore
1322   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1323   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
<span class="line-removed">1324   update_archived_mirror_native_pointers(m);</span>
1325   assert(as_Klass(m) == k, &quot;must be&quot;);
1326   Handle mirror(THREAD, m);
1327 
1328   if (!k-&gt;is_array_klass()) {
1329     // - local static final fields with initial values were initialized at dump time
1330 
1331     // create the init_lock
1332     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1333     set_init_lock(mirror(), r);
1334 
1335     if (protection_domain.not_null()) {
1336       set_protection_domain(mirror(), protection_domain());
1337     }
1338   }
1339 
1340   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1341   if (class_loader.not_null()) {
1342     set_class_loader(mirror(), class_loader());
1343   }
1344 
</pre>
<hr />
<pre>
1410 }
1411 
1412 oop java_lang_Class::init_lock(oop java_class) {
1413   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1414   return java_class-&gt;obj_field(_init_lock_offset);
1415 }
1416 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1417   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1418   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1419 }
1420 
1421 objArrayOop java_lang_Class::signers(oop java_class) {
1422   assert(_signers_offset != 0, &quot;must be set&quot;);
1423   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1424 }
1425 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1426   assert(_signers_offset != 0, &quot;must be set&quot;);
1427   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1428 }
1429 








1430 
1431 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1432   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1433   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1434 }
1435 
1436 oop java_lang_Class::class_loader(oop java_class) {
1437   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1438   return java_class-&gt;obj_field(_class_loader_offset);
1439 }
1440 
1441 oop java_lang_Class::module(oop java_class) {
1442   assert(_module_offset != 0, &quot;must be set&quot;);
1443   return java_class-&gt;obj_field(_module_offset);
1444 }
1445 
1446 void java_lang_Class::set_module(oop java_class, oop module) {
1447   assert(_module_offset != 0, &quot;must be set&quot;);
1448   java_class-&gt;obj_field_put(_module_offset, module);
1449 }
</pre>
<hr />
<pre>
1643 
1644 
1645 oop java_lang_Class::primitive_mirror(BasicType t) {
1646   oop mirror = Universe::java_mirror(t);
1647   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1648   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1649   return mirror;
1650 }
1651 
1652 bool java_lang_Class::offsets_computed = false;
1653 int  java_lang_Class::classRedefinedCount_offset = -1;
1654 
1655 #define CLASS_FIELDS_DO(macro) \
1656   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1657   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1658   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1659   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1660   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
1661   macro(_val_type_mirror_offset,    k, &quot;valType&quot;,             class_signature,       false); \
1662   macro(_ref_type_mirror_offset,    k, &quot;refType&quot;,             class_signature,       false); \

1663 
1664 void java_lang_Class::compute_offsets() {
1665   if (offsets_computed) {
1666     return;
1667   }
1668 
1669   offsets_computed = true;
1670 
1671   InstanceKlass* k = SystemDictionary::Class_klass();
1672   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1673 
1674   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1675   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1676   // GC treats them the same.
1677   _init_lock_offset = _component_mirror_offset;
1678 
1679   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1680 }
1681 
1682 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4313 
4314 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4315   UnsafeConstantsFixup fixup;
4316   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4317 }
4318 
4319 int java_lang_Class::_klass_offset;
4320 int java_lang_Class::_array_klass_offset;
4321 int java_lang_Class::_oop_size_offset;
4322 int java_lang_Class::_static_oop_field_count_offset;
4323 int java_lang_Class::_class_loader_offset;
4324 int java_lang_Class::_module_offset;
4325 int java_lang_Class::_protection_domain_offset;
4326 int java_lang_Class::_component_mirror_offset;
4327 int java_lang_Class::_val_type_mirror_offset;
4328 int java_lang_Class::_ref_type_mirror_offset;
4329 int java_lang_Class::_init_lock_offset;
4330 int java_lang_Class::_signers_offset;
4331 int java_lang_Class::_name_offset;
4332 int java_lang_Class::_source_file_offset;

4333 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4334 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4335 int java_lang_Throwable::backtrace_offset;
4336 int java_lang_Throwable::detailMessage_offset;
4337 int java_lang_Throwable::stackTrace_offset;
4338 int java_lang_Throwable::depth_offset;
4339 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4340 int java_lang_reflect_AccessibleObject::override_offset;
4341 int java_lang_reflect_Method::clazz_offset;
4342 int java_lang_reflect_Method::name_offset;
4343 int java_lang_reflect_Method::returnType_offset;
4344 int java_lang_reflect_Method::parameterTypes_offset;
4345 int java_lang_reflect_Method::exceptionTypes_offset;
4346 int java_lang_reflect_Method::slot_offset;
4347 int java_lang_reflect_Method::modifiers_offset;
4348 int java_lang_reflect_Method::signature_offset;
4349 int java_lang_reflect_Method::annotations_offset;
4350 int java_lang_reflect_Method::parameter_annotations_offset;
4351 int java_lang_reflect_Method::annotation_default_offset;
4352 int java_lang_reflect_Constructor::clazz_offset;
</pre>
</td>
<td>
<hr />
<pre>
 634 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 635   assert(value_equals(value, java_lang_String::value(java_string)),
 636          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 637   int length = java_lang_String::length(java_string, value);
 638   if (length == 0) {
 639     return 0;
 640   }
 641   if (!java_lang_String::is_latin1(java_string)) {
 642     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 643   } else {
 644     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 645   }
 646 }
 647 
 648 int java_lang_String::utf8_length(oop java_string) {
 649   typeArrayOop value = java_lang_String::value(java_string);
 650   return utf8_length(java_string, value);
 651 }
 652 
 653 char* java_lang_String::as_utf8_string(oop java_string) {
<span class="line-modified"> 654   int length;</span>
<span class="line-modified"> 655   return as_utf8_string(java_string, length);</span>
<span class="line-modified"> 656 }</span>
<span class="line-added"> 657 </span>
<span class="line-added"> 658 char* java_lang_String::as_utf8_string(oop java_string, int&amp; length) {</span>
<span class="line-added"> 659   typeArrayOop value = java_lang_String::value(java_string);</span>
<span class="line-added"> 660   length             = java_lang_String::length(java_string, value);</span>
<span class="line-added"> 661   bool     is_latin1 = java_lang_String::is_latin1(java_string);</span>
 662   if (!is_latin1) {
 663     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 664     return UNICODE::as_utf8(position, length);
 665   } else {
 666     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 667     return UNICODE::as_utf8(position, length);
 668   }
 669 }
 670 
<span class="line-added"> 671 // Uses a provided buffer if it&#39;s sufficiently large, otherwise allocates</span>
<span class="line-added"> 672 // a resource array to fit</span>
<span class="line-added"> 673 char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; utf8_len) {</span>
<span class="line-added"> 674   typeArrayOop value = java_lang_String::value(java_string);</span>
<span class="line-added"> 675   int            len = java_lang_String::length(java_string, value);</span>
<span class="line-added"> 676   bool     is_latin1 = java_lang_String::is_latin1(java_string);</span>
<span class="line-added"> 677   if (!is_latin1) {</span>
<span class="line-added"> 678     jchar *position = (len == 0) ? NULL : value-&gt;char_at_addr(0);</span>
<span class="line-added"> 679     utf8_len = UNICODE::utf8_length(position, len);</span>
<span class="line-added"> 680     if (utf8_len &gt;= buflen) {</span>
<span class="line-added"> 681       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);</span>
<span class="line-added"> 682     }</span>
<span class="line-added"> 683     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);</span>
<span class="line-added"> 684   } else {</span>
<span class="line-added"> 685     jbyte *position = (len == 0) ? NULL : value-&gt;byte_at_addr(0);</span>
<span class="line-added"> 686     utf8_len = UNICODE::utf8_length(position, len);</span>
<span class="line-added"> 687     if (utf8_len &gt;= buflen) {</span>
<span class="line-added"> 688       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);</span>
<span class="line-added"> 689     }</span>
<span class="line-added"> 690     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);</span>
<span class="line-added"> 691   }</span>
<span class="line-added"> 692 }</span>
<span class="line-added"> 693 </span>
 694 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 695   assert(value_equals(value, java_lang_String::value(java_string)),
 696          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 697   int     length = java_lang_String::length(java_string, value);
 698   bool is_latin1 = java_lang_String::is_latin1(java_string);
 699   if (!is_latin1) {
 700     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 701     return UNICODE::as_utf8(position, length, buf, buflen);
 702   } else {
 703     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 704     return UNICODE::as_utf8(position, length, buf, buflen);
 705   }
 706 }
 707 
 708 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 709   typeArrayOop value = java_lang_String::value(java_string);
 710   return as_utf8_string(java_string, value, buf, buflen);
 711 }
 712 
 713 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
</pre>
<hr />
<pre>
 865       // update all the static field offsets to included the size.
 866       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 867         if (fs.access_flags().is_static()) {
 868           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 869           fs.set_offset(real_offset);
 870         }
 871       }
 872     }
 873   }
 874 
 875   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 876     if (HeapShared::open_archive_heap_region_mapped()) {
 877       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 878       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 879       return;
 880     } else {
 881       k-&gt;set_java_mirror_handle(NULL);
 882       k-&gt;clear_has_raw_archived_mirror();
 883     }
 884   }
<span class="line-modified"> 885   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);</span>
 886 }
 887 
 888 void java_lang_Class::initialize_mirror_fields(Klass* k,
 889                                                Handle mirror,
 890                                                Handle protection_domain,
<span class="line-added"> 891                                                Handle classData,</span>
 892                                                TRAPS) {
 893   // Allocate a simple java object for a lock.
 894   // This needs to be a java object because during class initialization
 895   // it can be held across a java call.
 896   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 897   set_init_lock(mirror(), r);
 898 
 899   // Set protection domain also
 900   set_protection_domain(mirror(), protection_domain());
 901 
 902   // Initialize static fields
 903   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
<span class="line-added"> 904 </span>
<span class="line-added"> 905  // Set classData</span>
<span class="line-added"> 906   set_class_data(mirror(), classData());</span>
 907 }
 908 
 909 // Set the java.lang.Module module field in the java_lang_Class mirror
 910 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 911   if (module.is_null()) {
 912     // During startup, the module may be NULL only if java.base has not been defined yet.
 913     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 914     // for java.base is known. But note that since we captured the NULL module another
 915     // thread may have completed that initialization.
 916 
 917     bool javabase_was_defined = false;
 918     {
 919       MutexLocker m1(THREAD, Module_lock);
 920       // Keep list of classes needing java.base module fixup
 921       if (!ModuleEntryTable::javabase_defined()) {
 922         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 923         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 924         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 925         fixup_module_field_list()-&gt;push(k);
 926       } else {
</pre>
<hr />
<pre>
 940     assert(Universe::is_module_initialized() ||
 941            (ModuleEntryTable::javabase_defined() &amp;&amp;
 942             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 943            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 944     set_module(mirror(), module());
 945   }
 946 }
 947 
 948 // Statically allocate fixup lists because they always get created.
 949 void java_lang_Class::allocate_fixup_lists() {
 950   GrowableArray&lt;Klass*&gt;* mirror_list =
 951     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 952   set_fixup_mirror_list(mirror_list);
 953 
 954   GrowableArray&lt;Klass*&gt;* module_list =
 955     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 956   set_fixup_module_field_list(module_list);
 957 }
 958 
 959 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
<span class="line-modified"> 960                                     Handle module, Handle protection_domain,</span>
<span class="line-added"> 961                                     Handle classData, TRAPS) {</span>
 962   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 963   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 964 
 965   // Use this moment of initialization to cache modifier_flags also,
 966   // to support Class.getModifiers().  Instance classes recalculate
 967   // the cached flags after the class file is parsed, but before the
 968   // class is put into the system dictionary.
 969   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 970   k-&gt;set_modifier_flags(computed_modifiers);
 971   // Class_klass has to be loaded because it is used to allocate
 972   // the mirror.
 973   if (SystemDictionary::Class_klass_loaded()) {
 974     // Allocate mirror (java.lang.Class instance)
 975     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 976     Handle mirror(THREAD, mirror_oop);
 977     Handle comp_mirror;
 978 
 979     // Setup indirection from mirror-&gt;klass
 980     java_lang_Class::set_klass(mirror(), k);
 981 
</pre>
<hr />
<pre>
 993         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());
 994       } else if (k-&gt;is_typeArray_klass()) {
 995         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 996         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 997       } else {
 998         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 999         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1000         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1001         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1002       }
1003       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1004 
1005       // Two-way link between the array klass and its component mirror:
1006       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1007       set_component_mirror(mirror(), comp_mirror());
1008       // See below for ordering dependencies between field array_klass in component mirror
1009       // and java_mirror in this klass.
1010     } else {
1011       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1012 
<span class="line-modified">1013       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);</span>
1014       if (HAS_PENDING_EXCEPTION) {
1015         // If any of the fields throws an exception like OOM remove the klass field
1016         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
1017         // This mirror looks like a primitive type, which logically it is because it
1018         // it represents no class.
1019         java_lang_Class::set_klass(mirror(), NULL);
1020         return;
1021       }
1022     }
1023 
1024     // set the classLoader field in the java_lang_Class instance
1025     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1026     set_class_loader(mirror(), class_loader());
1027 
1028     // Setup indirection from klass-&gt;mirror
1029     // after any exceptions can happen during allocations.
1030     k-&gt;set_java_mirror(mirror);
1031 
1032     // Set the module field in the java_lang_Class instance.  This must be done
1033     // after the mirror is set.
</pre>
<hr />
<pre>
1301       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1302       p2i(arr), p2i(reloc_arr));
1303     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1304   }
1305   return archived_mirror;
1306 }
1307 
1308 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1309   if (MetaspaceShared::relocation_delta() != 0) {
1310     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1311 
1312     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1313     if (ak != NULL) {
1314       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1315           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1316     }
1317   }
1318 }
1319 
1320 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
<span class="line-modified">1321   assert(MetaspaceShared::relocation_delta() != 0, &quot;must be&quot;);</span>



1322 
<span class="line-modified">1323   Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));</span>
<span class="line-modified">1324   archived_mirror-&gt;metadata_field_put(_klass_offset,</span>
<span class="line-modified">1325       (Klass*)(address(k) + MetaspaceShared::relocation_delta()));</span>
<span class="line-modified">1326 </span>
<span class="line-modified">1327   Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));</span>
<span class="line-added">1328   if (ak != NULL) {</span>
<span class="line-added">1329     archived_mirror-&gt;metadata_field_put(_array_klass_offset,</span>
<span class="line-added">1330         (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));</span>
1331   }
1332 }
1333 
1334 
1335 // Returns true if the mirror is updated, false if no archived mirror
1336 // data is present. After the archived mirror object is restored, the
1337 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1338 bool java_lang_Class::restore_archived_mirror(Klass *k,
1339                                               Handle class_loader, Handle module,
1340                                               Handle protection_domain, TRAPS) {
1341   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1342   // see more details in SystemDictionary::resolve_well_known_classes().
1343   if (!SystemDictionary::Class_klass_loaded()) {
1344     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1345     fixup_mirror_list()-&gt;push(k);
1346     return true;
1347   }
1348 
1349   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1350   if (m == NULL) {
1351     return false;
1352   }
1353 
1354   // mirror is archived, restore
1355   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1356   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);

1357   assert(as_Klass(m) == k, &quot;must be&quot;);
1358   Handle mirror(THREAD, m);
1359 
1360   if (!k-&gt;is_array_klass()) {
1361     // - local static final fields with initial values were initialized at dump time
1362 
1363     // create the init_lock
1364     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1365     set_init_lock(mirror(), r);
1366 
1367     if (protection_domain.not_null()) {
1368       set_protection_domain(mirror(), protection_domain());
1369     }
1370   }
1371 
1372   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1373   if (class_loader.not_null()) {
1374     set_class_loader(mirror(), class_loader());
1375   }
1376 
</pre>
<hr />
<pre>
1442 }
1443 
1444 oop java_lang_Class::init_lock(oop java_class) {
1445   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1446   return java_class-&gt;obj_field(_init_lock_offset);
1447 }
1448 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1449   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1450   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1451 }
1452 
1453 objArrayOop java_lang_Class::signers(oop java_class) {
1454   assert(_signers_offset != 0, &quot;must be set&quot;);
1455   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1456 }
1457 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1458   assert(_signers_offset != 0, &quot;must be set&quot;);
1459   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1460 }
1461 
<span class="line-added">1462 oop java_lang_Class::class_data(oop java_class) {</span>
<span class="line-added">1463   assert(_classData_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1464   return java_class-&gt;obj_field(_classData_offset);</span>
<span class="line-added">1465 }</span>
<span class="line-added">1466 void java_lang_Class::set_class_data(oop java_class, oop class_data) {</span>
<span class="line-added">1467   assert(_classData_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1468   java_class-&gt;obj_field_put(_classData_offset, class_data);</span>
<span class="line-added">1469 }</span>
1470 
1471 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1472   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1473   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1474 }
1475 
1476 oop java_lang_Class::class_loader(oop java_class) {
1477   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1478   return java_class-&gt;obj_field(_class_loader_offset);
1479 }
1480 
1481 oop java_lang_Class::module(oop java_class) {
1482   assert(_module_offset != 0, &quot;must be set&quot;);
1483   return java_class-&gt;obj_field(_module_offset);
1484 }
1485 
1486 void java_lang_Class::set_module(oop java_class, oop module) {
1487   assert(_module_offset != 0, &quot;must be set&quot;);
1488   java_class-&gt;obj_field_put(_module_offset, module);
1489 }
</pre>
<hr />
<pre>
1683 
1684 
1685 oop java_lang_Class::primitive_mirror(BasicType t) {
1686   oop mirror = Universe::java_mirror(t);
1687   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1688   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1689   return mirror;
1690 }
1691 
1692 bool java_lang_Class::offsets_computed = false;
1693 int  java_lang_Class::classRedefinedCount_offset = -1;
1694 
1695 #define CLASS_FIELDS_DO(macro) \
1696   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1697   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1698   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1699   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1700   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
1701   macro(_val_type_mirror_offset,    k, &quot;valType&quot;,             class_signature,       false); \
1702   macro(_ref_type_mirror_offset,    k, &quot;refType&quot;,             class_signature,       false); \
<span class="line-added">1703   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);</span>
1704 
1705 void java_lang_Class::compute_offsets() {
1706   if (offsets_computed) {
1707     return;
1708   }
1709 
1710   offsets_computed = true;
1711 
1712   InstanceKlass* k = SystemDictionary::Class_klass();
1713   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1714 
1715   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1716   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1717   // GC treats them the same.
1718   _init_lock_offset = _component_mirror_offset;
1719 
1720   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1721 }
1722 
1723 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4354 
4355 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4356   UnsafeConstantsFixup fixup;
4357   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4358 }
4359 
4360 int java_lang_Class::_klass_offset;
4361 int java_lang_Class::_array_klass_offset;
4362 int java_lang_Class::_oop_size_offset;
4363 int java_lang_Class::_static_oop_field_count_offset;
4364 int java_lang_Class::_class_loader_offset;
4365 int java_lang_Class::_module_offset;
4366 int java_lang_Class::_protection_domain_offset;
4367 int java_lang_Class::_component_mirror_offset;
4368 int java_lang_Class::_val_type_mirror_offset;
4369 int java_lang_Class::_ref_type_mirror_offset;
4370 int java_lang_Class::_init_lock_offset;
4371 int java_lang_Class::_signers_offset;
4372 int java_lang_Class::_name_offset;
4373 int java_lang_Class::_source_file_offset;
<span class="line-added">4374 int java_lang_Class::_classData_offset;</span>
4375 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4376 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4377 int java_lang_Throwable::backtrace_offset;
4378 int java_lang_Throwable::detailMessage_offset;
4379 int java_lang_Throwable::stackTrace_offset;
4380 int java_lang_Throwable::depth_offset;
4381 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4382 int java_lang_reflect_AccessibleObject::override_offset;
4383 int java_lang_reflect_Method::clazz_offset;
4384 int java_lang_reflect_Method::name_offset;
4385 int java_lang_reflect_Method::returnType_offset;
4386 int java_lang_reflect_Method::parameterTypes_offset;
4387 int java_lang_reflect_Method::exceptionTypes_offset;
4388 int java_lang_reflect_Method::slot_offset;
4389 int java_lang_reflect_Method::modifiers_offset;
4390 int java_lang_reflect_Method::signature_offset;
4391 int java_lang_reflect_Method::annotations_offset;
4392 int java_lang_reflect_Method::parameter_annotations_offset;
4393 int java_lang_reflect_Method::annotation_default_offset;
4394 int java_lang_reflect_Constructor::clazz_offset;
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
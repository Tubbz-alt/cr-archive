<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/test/BuildMicrobenchmark.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 1080     // We derive below RegMask(s) from the ones which are auto-generated from
 1081     // adlc register classes to make AArch64 rheapbase (r27) and rfp (r29)
 1082     // registers conditionally reserved.
 1083 
 1084     _ANY_REG32_mask = _ALL_REG32_mask;
 1085     _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp-&gt;as_VMReg()));
 1086 
 1087     _ANY_REG_mask = _ALL_REG_mask;
 1088 
 1089     _PTR_REG_mask = _ALL_REG_mask;
 1090 
 1091     _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;
 1092     _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);
 1093 
 1094     _NO_SPECIAL_REG_mask = _ALL_REG_mask;
 1095     _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
 1096 
 1097     _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;
 1098     _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
 1099 
<span class="line-modified"> 1100     // r27 is not allocatable when compressed oops is on, compressed klass</span>
<span class="line-modified"> 1101     // pointers doesn&#39;t use r27 after JDK-8234794</span>
<span class="line-modified"> 1102     if (UseCompressedOops) {</span>
 1103       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27-&gt;as_VMReg()));
 1104       _NO_SPECIAL_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
 1105       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
 1106     }
 1107 
 1108     // r29 is not allocatable when PreserveFramePointer is on
 1109     if (PreserveFramePointer) {
 1110       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r29-&gt;as_VMReg()));
 1111       _NO_SPECIAL_REG_mask.SUBTRACT(_FP_REG_mask);
 1112       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_FP_REG_mask);
 1113     }
 1114   }
 1115 
 1116   // Optimizaton of volatile gets and puts
 1117   // -------------------------------------
 1118   //
 1119   // AArch64 has ldar&lt;x&gt; and stlr&lt;x&gt; instructions which we can safely
 1120   // use to implement volatile reads and writes. For a volatile read
 1121   // we simply need
 1122   //
</pre>
<hr />
<pre>
 2167 const int Matcher::max_vector_size(const BasicType bt) {
 2168   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 2169 }
 2170 const int Matcher::min_vector_size(const BasicType bt) {
 2171 //  For the moment limit the vector size to 8 bytes
 2172     int size = 8 / type2aelembytes(bt);
 2173     if (size &lt; 2) size = 2;
 2174     return size;
 2175 }
 2176 
 2177 // Vector ideal reg.
 2178 const uint Matcher::vector_ideal_reg(int len) {
 2179   switch(len) {
 2180     case  8: return Op_VecD;
 2181     case 16: return Op_VecX;
 2182   }
 2183   ShouldNotReachHere();
 2184   return 0;
 2185 }
 2186 
<span class="line-removed"> 2187 const uint Matcher::vector_shift_count_ideal_reg(int size) {</span>
<span class="line-removed"> 2188   switch(size) {</span>
<span class="line-removed"> 2189     case  8: return Op_VecD;</span>
<span class="line-removed"> 2190     case 16: return Op_VecX;</span>
<span class="line-removed"> 2191   }</span>
<span class="line-removed"> 2192   ShouldNotReachHere();</span>
<span class="line-removed"> 2193   return 0;</span>
<span class="line-removed"> 2194 }</span>
<span class="line-removed"> 2195 </span>
 2196 // AES support not yet implemented
 2197 const bool Matcher::pass_original_key_for_aes() {
 2198   return false;
 2199 }
 2200 
 2201 // aarch64 supports misaligned vectors store/load.
 2202 const bool Matcher::misaligned_vectors_ok() {
 2203   return true;
 2204 }
 2205 
 2206 // false =&gt; size gets scaled to BytesPerLong, ok.
 2207 const bool Matcher::init_array_count_is_in_bytes = false;
 2208 
 2209 // Use conditional move (CMOVL)
 2210 const int Matcher::long_cmove_cost() {
 2211   // long cmoves are no more expensive than int cmoves
 2212   return 0;
 2213 }
 2214 
 2215 const int Matcher::float_cmove_cost() {
 2216   // float cmoves are no more expensive than int cmoves
 2217   return 0;
 2218 }
 2219 
 2220 // Does the CPU require late expand (see block.cpp for description of late expand)?
 2221 const bool Matcher::require_postalloc_expand = false;
 2222 
 2223 // Do we need to mask the count passed to shift instructions or does
 2224 // the cpu only look at the lower 5/6 bits anyway?
 2225 const bool Matcher::need_masked_shift_count = false;
 2226 
 2227 // No support for generic vector operands.
 2228 const bool Matcher::supports_generic_vector_operands  = false;
 2229 
<span class="line-modified"> 2230 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
 2231   ShouldNotReachHere(); // generic vector operands not supported
 2232   return NULL;
 2233 }
 2234 
 2235 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 2236   ShouldNotReachHere();  // generic vector operands not supported
 2237   return false;
 2238 }
 2239 
 2240 bool Matcher::is_generic_vector(MachOper* opnd)  {
 2241   ShouldNotReachHere();  // generic vector operands not supported
 2242   return false;
 2243 }
 2244 
 2245 // This affects two different things:
 2246 //  - how Decode nodes are matched
 2247 //  - how ImplicitNullCheck opportunities are recognized
 2248 // If true, the matcher will try to remove all Decodes and match them
 2249 // (as operands) into nodes. NullChecks are not prepared to deal with
 2250 // Decodes by final_graph_reshaping().
</pre>
<hr />
<pre>
 7482 
 7483   ins_encode(aarch64_enc_str0(mem));
 7484 
 7485   ins_pipe(istore_mem);
 7486 %}
 7487 
 7488 // Store Compressed Pointer
 7489 instruct storeN(iRegN src, memory4 mem)
 7490 %{
 7491   match(Set mem (StoreN mem src));
 7492   predicate(!needs_releasing_store(n));
 7493 
 7494   ins_cost(INSN_COST);
 7495   format %{ &quot;strw  $src, $mem\t# compressed ptr&quot; %}
 7496 
 7497   ins_encode(aarch64_enc_strw(src, mem));
 7498 
 7499   ins_pipe(istore_reg_mem);
 7500 %}
 7501 
<span class="line-modified"> 7502 instruct storeImmN0(iRegIHeapbase heapbase, immN0 zero, memory4 mem)</span>
 7503 %{
 7504   match(Set mem (StoreN mem zero));
<span class="line-modified"> 7505   predicate(CompressedOops::base() == NULL &amp;&amp;</span>
<span class="line-removed"> 7506             CompressedKlassPointers::base() == NULL &amp;&amp;</span>
<span class="line-removed"> 7507             (!needs_releasing_store(n)));</span>
 7508 
 7509   ins_cost(INSN_COST);
<span class="line-modified"> 7510   format %{ &quot;strw  rheapbase, $mem\t# compressed ptr (rheapbase==0)&quot; %}</span>
 7511 
<span class="line-modified"> 7512   ins_encode(aarch64_enc_strw(heapbase, mem));</span>
 7513 
<span class="line-modified"> 7514   ins_pipe(istore_reg_mem);</span>
 7515 %}
 7516 
 7517 // Store Float
 7518 instruct storeF(vRegF src, memory4 mem)
 7519 %{
 7520   match(Set mem (StoreF mem src));
 7521   predicate(!needs_releasing_store(n));
 7522 
 7523   ins_cost(INSN_COST);
 7524   format %{ &quot;strs  $src, $mem\t# float&quot; %}
 7525 
 7526   ins_encode( aarch64_enc_strs(src, mem) );
 7527 
 7528   ins_pipe(pipe_class_memory);
 7529 %}
 7530 
 7531 // TODO
 7532 // implement storeImmF0 and storeFImmPacked
 7533 
 7534 // Store Double
</pre>
<hr />
<pre>
 8492 %{
 8493   match(Set dst (CastPP dst));
 8494 
 8495   size(0);
 8496   format %{ &quot;# castPP of $dst&quot; %}
 8497   ins_encode(/* empty encoding */);
 8498   ins_pipe(pipe_class_empty);
 8499 %}
 8500 
 8501 instruct castII(iRegI dst)
 8502 %{
 8503   match(Set dst (CastII dst));
 8504 
 8505   size(0);
 8506   format %{ &quot;# castII of $dst&quot; %}
 8507   ins_encode(/* empty encoding */);
 8508   ins_cost(0);
 8509   ins_pipe(pipe_class_empty);
 8510 %}
 8511 
<span class="line-removed"> 8512 instruct castLL(iRegL dst)</span>
<span class="line-removed"> 8513 %{</span>
<span class="line-removed"> 8514   match(Set dst (CastLL dst));</span>
<span class="line-removed"> 8515 </span>
<span class="line-removed"> 8516   size(0);</span>
<span class="line-removed"> 8517   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="line-removed"> 8518   ins_encode(/* empty encoding */);</span>
<span class="line-removed"> 8519   ins_cost(0);</span>
<span class="line-removed"> 8520   ins_pipe(pipe_class_empty);</span>
<span class="line-removed"> 8521 %}</span>
<span class="line-removed"> 8522 </span>
 8523 // ============================================================================
 8524 // Atomic operation instructions
 8525 //
 8526 // Intel and SPARC both implement Ideal Node LoadPLocked and
 8527 // Store{PIL}Conditional instructions using a normal load for the
 8528 // LoadPLocked and a CAS for the Store{PIL}Conditional.
 8529 //
 8530 // The ideal code appears only to use LoadPLocked/StorePLocked as a
 8531 // pair to lock object allocations from Eden space when not using
 8532 // TLABs.
 8533 //
 8534 // There does not appear to be a Load{IL}Locked Ideal Node and the
 8535 // Ideal code appears to use Store{IL}Conditional as an alias for CAS
 8536 // and to use StoreIConditional only for 32-bit and StoreLConditional
 8537 // only for 64-bit.
 8538 //
 8539 // We implement LoadPLocked and StorePLocked instructions using,
 8540 // respectively the AArch64 hw load-exclusive and store-conditional
 8541 // instructions. Whereas we must implement each of
 8542 // Store{IL}Conditional using a CAS which employs a pair of
</pre>
<hr />
<pre>
16058            as_FloatRegister($src$$reg));
16059   %}
16060   ins_pipe(vdup_reg_freg128);
16061 %}
16062 
16063 instruct replicate2D(vecX dst, vRegD src)
16064 %{
16065   predicate(n-&gt;as_Vector()-&gt;length() == 2);
16066   match(Set dst (ReplicateD src));
16067   ins_cost(INSN_COST);
16068   format %{ &quot;dup  $dst, $src\t# vector (2D)&quot; %}
16069   ins_encode %{
16070     __ dup(as_FloatRegister($dst$$reg), __ T2D,
16071            as_FloatRegister($src$$reg));
16072   %}
16073   ins_pipe(vdup_reg_dreg128);
16074 %}
16075 
16076 // ====================REDUCTION ARITHMETIC====================================
16077 
<span class="line-modified">16078 instruct reduce_add2I(iRegINoSp dst, iRegIorL2I src1, vecD src2, iRegINoSp tmp, iRegINoSp tmp2)</span>
16079 %{
<span class="line-modified">16080   match(Set dst (AddReductionVI src1 src2));</span>
16081   ins_cost(INSN_COST);
16082   effect(TEMP tmp, TEMP tmp2);
<span class="line-modified">16083   format %{ &quot;umov  $tmp, $src2, S, 0\n\t&quot;</span>
<span class="line-modified">16084             &quot;umov  $tmp2, $src2, S, 1\n\t&quot;</span>
<span class="line-modified">16085             &quot;addw  $tmp, $src1, $tmp\n\t&quot;</span>
16086             &quot;addw  $dst, $tmp, $tmp2\t# add reduction2I&quot;
16087   %}
16088   ins_encode %{
<span class="line-modified">16089     __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);</span>
<span class="line-modified">16090     __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ S, 1);</span>
<span class="line-modified">16091     __ addw($tmp$$Register, $src1$$Register, $tmp$$Register);</span>
16092     __ addw($dst$$Register, $tmp$$Register, $tmp2$$Register);
16093   %}
16094   ins_pipe(pipe_class_default);
16095 %}
16096 
<span class="line-modified">16097 instruct reduce_add4I(iRegINoSp dst, iRegIorL2I src1, vecX src2, vecX tmp, iRegINoSp tmp2)</span>
16098 %{
<span class="line-modified">16099   match(Set dst (AddReductionVI src1 src2));</span>
16100   ins_cost(INSN_COST);
<span class="line-modified">16101   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">16102   format %{ &quot;addv  $tmp, T4S, $src2\n\t&quot;</span>
<span class="line-modified">16103             &quot;umov  $tmp2, $tmp, S, 0\n\t&quot;</span>
<span class="line-modified">16104             &quot;addw  $dst, $tmp2, $src1\t# add reduction4I&quot;</span>
16105   %}
16106   ins_encode %{
<span class="line-modified">16107     __ addv(as_FloatRegister($tmp$$reg), __ T4S,</span>
<span class="line-modified">16108             as_FloatRegister($src2$$reg));</span>
<span class="line-modified">16109     __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 0);</span>
<span class="line-modified">16110     __ addw($dst$$Register, $tmp2$$Register, $src1$$Register);</span>
16111   %}
16112   ins_pipe(pipe_class_default);
16113 %}
16114 
<span class="line-modified">16115 instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I src1, vecD src2, iRegINoSp tmp)</span>
16116 %{
<span class="line-modified">16117   match(Set dst (MulReductionVI src1 src2));</span>
16118   ins_cost(INSN_COST);
16119   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16120   format %{ &quot;umov  $tmp, $src2, S, 0\n\t&quot;</span>
<span class="line-modified">16121             &quot;mul   $dst, $tmp, $src1\n\t&quot;</span>
<span class="line-modified">16122             &quot;umov  $tmp, $src2, S, 1\n\t&quot;</span>
16123             &quot;mul   $dst, $tmp, $dst\t# mul reduction2I&quot;
16124   %}
16125   ins_encode %{
<span class="line-modified">16126     __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);</span>
<span class="line-modified">16127     __ mul($dst$$Register, $tmp$$Register, $src1$$Register);</span>
<span class="line-modified">16128     __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 1);</span>
16129     __ mul($dst$$Register, $tmp$$Register, $dst$$Register);
16130   %}
16131   ins_pipe(pipe_class_default);
16132 %}
16133 
<span class="line-modified">16134 instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I src1, vecX src2, vecX tmp, iRegINoSp tmp2)</span>
16135 %{
<span class="line-modified">16136   match(Set dst (MulReductionVI src1 src2));</span>
16137   ins_cost(INSN_COST);
<span class="line-modified">16138   effect(TEMP tmp, TEMP tmp2, TEMP dst);</span>
<span class="line-modified">16139   format %{ &quot;ins   $tmp, $src2, 0, 1\n\t&quot;</span>
<span class="line-modified">16140             &quot;mul   $tmp, $tmp, $src2\n\t&quot;</span>
<span class="line-modified">16141             &quot;umov  $tmp2, $tmp, S, 0\n\t&quot;</span>
<span class="line-modified">16142             &quot;mul   $dst, $tmp2, $src1\n\t&quot;</span>
<span class="line-modified">16143             &quot;umov  $tmp2, $tmp, S, 1\n\t&quot;</span>
<span class="line-modified">16144             &quot;mul   $dst, $tmp2, $dst\t# mul reduction4I&quot;</span>
16145   %}
16146   ins_encode %{
<span class="line-modified">16147     __ ins(as_FloatRegister($tmp$$reg), __ D,</span>
<span class="line-modified">16148            as_FloatRegister($src2$$reg), 0, 1);</span>
<span class="line-modified">16149     __ mulv(as_FloatRegister($tmp$$reg), __ T2S,</span>
<span class="line-modified">16150            as_FloatRegister($tmp$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">16151     __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 0);</span>
<span class="line-modified">16152     __ mul($dst$$Register, $tmp2$$Register, $src1$$Register);</span>
<span class="line-modified">16153     __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 1);</span>
<span class="line-modified">16154     __ mul($dst$$Register, $tmp2$$Register, $dst$$Register);</span>
16155   %}
16156   ins_pipe(pipe_class_default);
16157 %}
16158 
<span class="line-modified">16159 instruct reduce_add2F(vRegF dst, vRegF src1, vecD src2, vecD tmp)</span>
16160 %{
<span class="line-modified">16161   match(Set dst (AddReductionVF src1 src2));</span>
16162   ins_cost(INSN_COST);
16163   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16164   format %{ &quot;fadds $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16165             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
16166             &quot;fadds $dst, $dst, $tmp\t# add reduction2F&quot;
16167   %}
16168   ins_encode %{
16169     __ fadds(as_FloatRegister($dst$$reg),
<span class="line-modified">16170              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
16171     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16172            as_FloatRegister($src2$$reg), 0, 1);</span>
16173     __ fadds(as_FloatRegister($dst$$reg),
16174              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16175   %}
16176   ins_pipe(pipe_class_default);
16177 %}
16178 
<span class="line-modified">16179 instruct reduce_add4F(vRegF dst, vRegF src1, vecX src2, vecX tmp)</span>
16180 %{
<span class="line-modified">16181   match(Set dst (AddReductionVF src1 src2));</span>
16182   ins_cost(INSN_COST);
16183   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16184   format %{ &quot;fadds $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16185             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
16186             &quot;fadds $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">16187             &quot;ins   $tmp, S, $src2, 0, 2\n\t&quot;</span>
16188             &quot;fadds $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">16189             &quot;ins   $tmp, S, $src2, 0, 3\n\t&quot;</span>
16190             &quot;fadds $dst, $dst, $tmp\t# add reduction4F&quot;
16191   %}
16192   ins_encode %{
16193     __ fadds(as_FloatRegister($dst$$reg),
<span class="line-modified">16194              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
16195     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16196            as_FloatRegister($src2$$reg), 0, 1);</span>
16197     __ fadds(as_FloatRegister($dst$$reg),
16198              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16199     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16200            as_FloatRegister($src2$$reg), 0, 2);</span>
16201     __ fadds(as_FloatRegister($dst$$reg),
16202              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16203     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16204            as_FloatRegister($src2$$reg), 0, 3);</span>
16205     __ fadds(as_FloatRegister($dst$$reg),
16206              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16207   %}
16208   ins_pipe(pipe_class_default);
16209 %}
16210 
<span class="line-modified">16211 instruct reduce_mul2F(vRegF dst, vRegF src1, vecD src2, vecD tmp)</span>
16212 %{
<span class="line-modified">16213   match(Set dst (MulReductionVF src1 src2));</span>
16214   ins_cost(INSN_COST);
16215   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16216   format %{ &quot;fmuls $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16217             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
16218             &quot;fmuls $dst, $dst, $tmp\t# mul reduction2F&quot;
16219   %}
16220   ins_encode %{
16221     __ fmuls(as_FloatRegister($dst$$reg),
<span class="line-modified">16222              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
16223     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16224            as_FloatRegister($src2$$reg), 0, 1);</span>
16225     __ fmuls(as_FloatRegister($dst$$reg),
16226              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16227   %}
16228   ins_pipe(pipe_class_default);
16229 %}
16230 
<span class="line-modified">16231 instruct reduce_mul4F(vRegF dst, vRegF src1, vecX src2, vecX tmp)</span>
16232 %{
<span class="line-modified">16233   match(Set dst (MulReductionVF src1 src2));</span>
16234   ins_cost(INSN_COST);
16235   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16236   format %{ &quot;fmuls $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16237             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
16238             &quot;fmuls $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">16239             &quot;ins   $tmp, S, $src2, 0, 2\n\t&quot;</span>
16240             &quot;fmuls $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">16241             &quot;ins   $tmp, S, $src2, 0, 3\n\t&quot;</span>
16242             &quot;fmuls $dst, $dst, $tmp\t# mul reduction4F&quot;
16243   %}
16244   ins_encode %{
16245     __ fmuls(as_FloatRegister($dst$$reg),
<span class="line-modified">16246              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
16247     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16248            as_FloatRegister($src2$$reg), 0, 1);</span>
16249     __ fmuls(as_FloatRegister($dst$$reg),
16250              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16251     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16252            as_FloatRegister($src2$$reg), 0, 2);</span>
16253     __ fmuls(as_FloatRegister($dst$$reg),
16254              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16255     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16256            as_FloatRegister($src2$$reg), 0, 3);</span>
16257     __ fmuls(as_FloatRegister($dst$$reg),
16258              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16259   %}
16260   ins_pipe(pipe_class_default);
16261 %}
16262 
<span class="line-modified">16263 instruct reduce_add2D(vRegD dst, vRegD src1, vecX src2, vecX tmp)</span>
16264 %{
<span class="line-modified">16265   match(Set dst (AddReductionVD src1 src2));</span>
16266   ins_cost(INSN_COST);
16267   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16268   format %{ &quot;faddd $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16269             &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;</span>
16270             &quot;faddd $dst, $dst, $tmp\t# add reduction2D&quot;
16271   %}
16272   ins_encode %{
16273     __ faddd(as_FloatRegister($dst$$reg),
<span class="line-modified">16274              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
16275     __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-modified">16276            as_FloatRegister($src2$$reg), 0, 1);</span>
16277     __ faddd(as_FloatRegister($dst$$reg),
16278              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16279   %}
16280   ins_pipe(pipe_class_default);
16281 %}
16282 
<span class="line-modified">16283 instruct reduce_mul2D(vRegD dst, vRegD src1, vecX src2, vecX tmp)</span>
16284 %{
<span class="line-modified">16285   match(Set dst (MulReductionVD src1 src2));</span>
16286   ins_cost(INSN_COST);
16287   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16288   format %{ &quot;fmuld $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16289             &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;</span>
16290             &quot;fmuld $dst, $dst, $tmp\t# mul reduction2D&quot;
16291   %}
16292   ins_encode %{
16293     __ fmuld(as_FloatRegister($dst$$reg),
<span class="line-modified">16294              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
16295     __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-modified">16296            as_FloatRegister($src2$$reg), 0, 1);</span>
16297     __ fmuld(as_FloatRegister($dst$$reg),
16298              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16299   %}
16300   ins_pipe(pipe_class_default);
16301 %}
16302 
<span class="line-modified">16303 instruct reduce_max2F(vRegF dst, vRegF src1, vecD src2, vecD tmp) %{</span>
16304   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">16305   match(Set dst (MaxReductionV src1 src2));</span>
16306   ins_cost(INSN_COST);
16307   effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">16308   format %{ &quot;fmaxs $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16309             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
16310             &quot;fmaxs $dst, $dst, $tmp\t# max reduction2F&quot; %}
16311   ins_encode %{
<span class="line-modified">16312     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">16313     __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);</span>
16314     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16315   %}
16316   ins_pipe(pipe_class_default);
16317 %}
16318 
<span class="line-modified">16319 instruct reduce_max4F(vRegF dst, vRegF src1, vecX src2) %{</span>
16320   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">16321   match(Set dst (MaxReductionV src1 src2));</span>
16322   ins_cost(INSN_COST);
16323   effect(TEMP_DEF dst);
<span class="line-modified">16324   format %{ &quot;fmaxv $dst, T4S, $src2\n\t&quot;</span>
<span class="line-modified">16325             &quot;fmaxs $dst, $dst, $src1\t# max reduction4F&quot; %}</span>
16326   ins_encode %{
<span class="line-modified">16327     __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));</span>
<span class="line-modified">16328     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));</span>
16329   %}
16330   ins_pipe(pipe_class_default);
16331 %}
16332 
<span class="line-modified">16333 instruct reduce_max2D(vRegD dst, vRegD src1, vecX src2, vecX tmp) %{</span>
16334   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
<span class="line-modified">16335   match(Set dst (MaxReductionV src1 src2));</span>
16336   ins_cost(INSN_COST);
16337   effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">16338   format %{ &quot;fmaxd $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16339             &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;</span>
16340             &quot;fmaxd $dst, $dst, $tmp\t# max reduction2D&quot; %}
16341   ins_encode %{
<span class="line-modified">16342     __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">16343     __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);</span>
16344     __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16345   %}
16346   ins_pipe(pipe_class_default);
16347 %}
16348 
<span class="line-modified">16349 instruct reduce_min2F(vRegF dst, vRegF src1, vecD src2, vecD tmp) %{</span>
16350   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">16351   match(Set dst (MinReductionV src1 src2));</span>
16352   ins_cost(INSN_COST);
16353   effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">16354   format %{ &quot;fmins $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16355             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
16356             &quot;fmins $dst, $dst, $tmp\t# min reduction2F&quot; %}
16357   ins_encode %{
<span class="line-modified">16358     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">16359     __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);</span>
16360     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16361   %}
16362   ins_pipe(pipe_class_default);
16363 %}
16364 
<span class="line-modified">16365 instruct reduce_min4F(vRegF dst, vRegF src1, vecX src2) %{</span>
16366   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">16367   match(Set dst (MinReductionV src1 src2));</span>
16368   ins_cost(INSN_COST);
16369   effect(TEMP_DEF dst);
<span class="line-modified">16370   format %{ &quot;fminv $dst, T4S, $src2\n\t&quot;</span>
<span class="line-modified">16371             &quot;fmins $dst, $dst, $src1\t# min reduction4F&quot; %}</span>
16372   ins_encode %{
<span class="line-modified">16373     __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));</span>
<span class="line-modified">16374     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));</span>
16375   %}
16376   ins_pipe(pipe_class_default);
16377 %}
16378 
<span class="line-modified">16379 instruct reduce_min2D(vRegD dst, vRegD src1, vecX src2, vecX tmp) %{</span>
16380   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
<span class="line-modified">16381   match(Set dst (MinReductionV src1 src2));</span>
16382   ins_cost(INSN_COST);
16383   effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">16384   format %{ &quot;fmind $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">16385             &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;</span>
16386             &quot;fmind $dst, $dst, $tmp\t# min reduction2D&quot; %}
16387   ins_encode %{
<span class="line-modified">16388     __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">16389     __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);</span>
16390     __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16391   %}
16392   ins_pipe(pipe_class_default);
16393 %}
16394 
16395 // ====================VECTOR ARITHMETIC=======================================
16396 
16397 // --------------------------------- ADD --------------------------------------
16398 
16399 instruct vadd8B(vecD dst, vecD src1, vecD src2)
16400 %{
16401   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
16402             n-&gt;as_Vector()-&gt;length() == 8);
16403   match(Set dst (AddVB src1 src2));
16404   ins_cost(INSN_COST);
16405   format %{ &quot;addv  $dst,$src1,$src2\t# vector (8B)&quot; %}
16406   ins_encode %{
16407     __ addv(as_FloatRegister($dst$$reg), __ T8B,
16408             as_FloatRegister($src1$$reg),
16409             as_FloatRegister($src2$$reg));
</pre>
<hr />
<pre>
17614   match(Set dst (LShiftVS src (LShiftCntV shift)));
17615   ins_cost(INSN_COST);
17616   format %{ &quot;shl    $dst, $src, $shift\t# vector (8H)&quot; %}
17617   ins_encode %{
17618     int sh = (int)$shift$$constant;
17619     if (sh &gt;= 16) {
17620       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17621              as_FloatRegister($src$$reg),
17622              as_FloatRegister($src$$reg));
17623     } else {
17624       __ shl(as_FloatRegister($dst$$reg), __ T8H,
17625              as_FloatRegister($src$$reg), sh);
17626     }
17627   %}
17628   ins_pipe(vshift128_imm);
17629 %}
17630 
17631 instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
17632   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17633             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17634   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
17635   ins_cost(INSN_COST);
17636   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
17637   ins_encode %{
17638     int sh = (int)$shift$$constant;
17639     if (sh &gt;= 16) sh = 15;
17640     __ sshr(as_FloatRegister($dst$$reg), __ T4H,
17641            as_FloatRegister($src$$reg), sh);
17642   %}
17643   ins_pipe(vshift64_imm);
17644 %}
17645 
17646 instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
17647   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17648   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
17649   ins_cost(INSN_COST);
17650   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
17651   ins_encode %{
17652     int sh = (int)$shift$$constant;
17653     if (sh &gt;= 16) sh = 15;
17654     __ sshr(as_FloatRegister($dst$$reg), __ T8H,
17655            as_FloatRegister($src$$reg), sh);
17656   %}
17657   ins_pipe(vshift128_imm);
17658 %}
17659 
17660 instruct vsrl4S_imm(vecD dst, vecD src, immI shift) %{
17661   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17662             n-&gt;as_Vector()-&gt;length() == 4);
17663   match(Set dst (URShiftVS src (RShiftCntV shift)));
17664   ins_cost(INSN_COST);
17665   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4H)&quot; %}
17666   ins_encode %{
17667     int sh = (int)$shift$$constant;
17668     if (sh &gt;= 16) {
</pre>
</td>
<td>
<hr />
<pre>
 1080     // We derive below RegMask(s) from the ones which are auto-generated from
 1081     // adlc register classes to make AArch64 rheapbase (r27) and rfp (r29)
 1082     // registers conditionally reserved.
 1083 
 1084     _ANY_REG32_mask = _ALL_REG32_mask;
 1085     _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp-&gt;as_VMReg()));
 1086 
 1087     _ANY_REG_mask = _ALL_REG_mask;
 1088 
 1089     _PTR_REG_mask = _ALL_REG_mask;
 1090 
 1091     _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;
 1092     _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);
 1093 
 1094     _NO_SPECIAL_REG_mask = _ALL_REG_mask;
 1095     _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
 1096 
 1097     _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;
 1098     _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
 1099 
<span class="line-modified"> 1100     // r27 is not allocatable when compressed oops is on and heapbase is not</span>
<span class="line-modified"> 1101     // zero, compressed klass pointers doesn&#39;t use r27 after JDK-8234794</span>
<span class="line-modified"> 1102     if (UseCompressedOops &amp;&amp; CompressedOops::ptrs_base() != NULL) {</span>
 1103       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27-&gt;as_VMReg()));
 1104       _NO_SPECIAL_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
 1105       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
 1106     }
 1107 
 1108     // r29 is not allocatable when PreserveFramePointer is on
 1109     if (PreserveFramePointer) {
 1110       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r29-&gt;as_VMReg()));
 1111       _NO_SPECIAL_REG_mask.SUBTRACT(_FP_REG_mask);
 1112       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_FP_REG_mask);
 1113     }
 1114   }
 1115 
 1116   // Optimizaton of volatile gets and puts
 1117   // -------------------------------------
 1118   //
 1119   // AArch64 has ldar&lt;x&gt; and stlr&lt;x&gt; instructions which we can safely
 1120   // use to implement volatile reads and writes. For a volatile read
 1121   // we simply need
 1122   //
</pre>
<hr />
<pre>
 2167 const int Matcher::max_vector_size(const BasicType bt) {
 2168   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 2169 }
 2170 const int Matcher::min_vector_size(const BasicType bt) {
 2171 //  For the moment limit the vector size to 8 bytes
 2172     int size = 8 / type2aelembytes(bt);
 2173     if (size &lt; 2) size = 2;
 2174     return size;
 2175 }
 2176 
 2177 // Vector ideal reg.
 2178 const uint Matcher::vector_ideal_reg(int len) {
 2179   switch(len) {
 2180     case  8: return Op_VecD;
 2181     case 16: return Op_VecX;
 2182   }
 2183   ShouldNotReachHere();
 2184   return 0;
 2185 }
 2186 









 2187 // AES support not yet implemented
 2188 const bool Matcher::pass_original_key_for_aes() {
 2189   return false;
 2190 }
 2191 
 2192 // aarch64 supports misaligned vectors store/load.
 2193 const bool Matcher::misaligned_vectors_ok() {
 2194   return true;
 2195 }
 2196 
 2197 // false =&gt; size gets scaled to BytesPerLong, ok.
 2198 const bool Matcher::init_array_count_is_in_bytes = false;
 2199 
 2200 // Use conditional move (CMOVL)
 2201 const int Matcher::long_cmove_cost() {
 2202   // long cmoves are no more expensive than int cmoves
 2203   return 0;
 2204 }
 2205 
 2206 const int Matcher::float_cmove_cost() {
 2207   // float cmoves are no more expensive than int cmoves
 2208   return 0;
 2209 }
 2210 
 2211 // Does the CPU require late expand (see block.cpp for description of late expand)?
 2212 const bool Matcher::require_postalloc_expand = false;
 2213 
 2214 // Do we need to mask the count passed to shift instructions or does
 2215 // the cpu only look at the lower 5/6 bits anyway?
 2216 const bool Matcher::need_masked_shift_count = false;
 2217 
 2218 // No support for generic vector operands.
 2219 const bool Matcher::supports_generic_vector_operands  = false;
 2220 
<span class="line-modified"> 2221 MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
 2222   ShouldNotReachHere(); // generic vector operands not supported
 2223   return NULL;
 2224 }
 2225 
 2226 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 2227   ShouldNotReachHere();  // generic vector operands not supported
 2228   return false;
 2229 }
 2230 
 2231 bool Matcher::is_generic_vector(MachOper* opnd)  {
 2232   ShouldNotReachHere();  // generic vector operands not supported
 2233   return false;
 2234 }
 2235 
 2236 // This affects two different things:
 2237 //  - how Decode nodes are matched
 2238 //  - how ImplicitNullCheck opportunities are recognized
 2239 // If true, the matcher will try to remove all Decodes and match them
 2240 // (as operands) into nodes. NullChecks are not prepared to deal with
 2241 // Decodes by final_graph_reshaping().
</pre>
<hr />
<pre>
 7473 
 7474   ins_encode(aarch64_enc_str0(mem));
 7475 
 7476   ins_pipe(istore_mem);
 7477 %}
 7478 
 7479 // Store Compressed Pointer
 7480 instruct storeN(iRegN src, memory4 mem)
 7481 %{
 7482   match(Set mem (StoreN mem src));
 7483   predicate(!needs_releasing_store(n));
 7484 
 7485   ins_cost(INSN_COST);
 7486   format %{ &quot;strw  $src, $mem\t# compressed ptr&quot; %}
 7487 
 7488   ins_encode(aarch64_enc_strw(src, mem));
 7489 
 7490   ins_pipe(istore_reg_mem);
 7491 %}
 7492 
<span class="line-modified"> 7493 instruct storeImmN0(immN0 zero, memory4 mem)</span>
 7494 %{
 7495   match(Set mem (StoreN mem zero));
<span class="line-modified"> 7496   predicate(!needs_releasing_store(n));</span>


 7497 
 7498   ins_cost(INSN_COST);
<span class="line-modified"> 7499   format %{ &quot;strw  zr, $mem\t# compressed ptr&quot; %}</span>
 7500 
<span class="line-modified"> 7501   ins_encode(aarch64_enc_strw0(mem));</span>
 7502 
<span class="line-modified"> 7503   ins_pipe(istore_mem);</span>
 7504 %}
 7505 
 7506 // Store Float
 7507 instruct storeF(vRegF src, memory4 mem)
 7508 %{
 7509   match(Set mem (StoreF mem src));
 7510   predicate(!needs_releasing_store(n));
 7511 
 7512   ins_cost(INSN_COST);
 7513   format %{ &quot;strs  $src, $mem\t# float&quot; %}
 7514 
 7515   ins_encode( aarch64_enc_strs(src, mem) );
 7516 
 7517   ins_pipe(pipe_class_memory);
 7518 %}
 7519 
 7520 // TODO
 7521 // implement storeImmF0 and storeFImmPacked
 7522 
 7523 // Store Double
</pre>
<hr />
<pre>
 8481 %{
 8482   match(Set dst (CastPP dst));
 8483 
 8484   size(0);
 8485   format %{ &quot;# castPP of $dst&quot; %}
 8486   ins_encode(/* empty encoding */);
 8487   ins_pipe(pipe_class_empty);
 8488 %}
 8489 
 8490 instruct castII(iRegI dst)
 8491 %{
 8492   match(Set dst (CastII dst));
 8493 
 8494   size(0);
 8495   format %{ &quot;# castII of $dst&quot; %}
 8496   ins_encode(/* empty encoding */);
 8497   ins_cost(0);
 8498   ins_pipe(pipe_class_empty);
 8499 %}
 8500 











 8501 // ============================================================================
 8502 // Atomic operation instructions
 8503 //
 8504 // Intel and SPARC both implement Ideal Node LoadPLocked and
 8505 // Store{PIL}Conditional instructions using a normal load for the
 8506 // LoadPLocked and a CAS for the Store{PIL}Conditional.
 8507 //
 8508 // The ideal code appears only to use LoadPLocked/StorePLocked as a
 8509 // pair to lock object allocations from Eden space when not using
 8510 // TLABs.
 8511 //
 8512 // There does not appear to be a Load{IL}Locked Ideal Node and the
 8513 // Ideal code appears to use Store{IL}Conditional as an alias for CAS
 8514 // and to use StoreIConditional only for 32-bit and StoreLConditional
 8515 // only for 64-bit.
 8516 //
 8517 // We implement LoadPLocked and StorePLocked instructions using,
 8518 // respectively the AArch64 hw load-exclusive and store-conditional
 8519 // instructions. Whereas we must implement each of
 8520 // Store{IL}Conditional using a CAS which employs a pair of
</pre>
<hr />
<pre>
16036            as_FloatRegister($src$$reg));
16037   %}
16038   ins_pipe(vdup_reg_freg128);
16039 %}
16040 
16041 instruct replicate2D(vecX dst, vRegD src)
16042 %{
16043   predicate(n-&gt;as_Vector()-&gt;length() == 2);
16044   match(Set dst (ReplicateD src));
16045   ins_cost(INSN_COST);
16046   format %{ &quot;dup  $dst, $src\t# vector (2D)&quot; %}
16047   ins_encode %{
16048     __ dup(as_FloatRegister($dst$$reg), __ T2D,
16049            as_FloatRegister($src$$reg));
16050   %}
16051   ins_pipe(vdup_reg_dreg128);
16052 %}
16053 
16054 // ====================REDUCTION ARITHMETIC====================================
16055 
<span class="line-modified">16056 instruct reduce_add2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp, iRegINoSp tmp2)</span>
16057 %{
<span class="line-modified">16058   match(Set dst (AddReductionVI isrc vsrc));</span>
16059   ins_cost(INSN_COST);
16060   effect(TEMP tmp, TEMP tmp2);
<span class="line-modified">16061   format %{ &quot;umov  $tmp, $vsrc, S, 0\n\t&quot;</span>
<span class="line-modified">16062             &quot;umov  $tmp2, $vsrc, S, 1\n\t&quot;</span>
<span class="line-modified">16063             &quot;addw  $tmp, $isrc, $tmp\n\t&quot;</span>
16064             &quot;addw  $dst, $tmp, $tmp2\t# add reduction2I&quot;
16065   %}
16066   ins_encode %{
<span class="line-modified">16067     __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);</span>
<span class="line-modified">16068     __ umov($tmp2$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);</span>
<span class="line-modified">16069     __ addw($tmp$$Register, $isrc$$Register, $tmp$$Register);</span>
16070     __ addw($dst$$Register, $tmp$$Register, $tmp2$$Register);
16071   %}
16072   ins_pipe(pipe_class_default);
16073 %}
16074 
<span class="line-modified">16075 instruct reduce_add4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)</span>
16076 %{
<span class="line-modified">16077   match(Set dst (AddReductionVI isrc vsrc));</span>
16078   ins_cost(INSN_COST);
<span class="line-modified">16079   effect(TEMP vtmp, TEMP itmp);</span>
<span class="line-modified">16080   format %{ &quot;addv  $vtmp, T4S, $vsrc\n\t&quot;</span>
<span class="line-modified">16081             &quot;umov  $itmp, $vtmp, S, 0\n\t&quot;</span>
<span class="line-modified">16082             &quot;addw  $dst, $itmp, $isrc\t# add reduction4I&quot;</span>
16083   %}
16084   ins_encode %{
<span class="line-modified">16085     __ addv(as_FloatRegister($vtmp$$reg), __ T4S,</span>
<span class="line-modified">16086             as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">16087     __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);</span>
<span class="line-modified">16088     __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);</span>
16089   %}
16090   ins_pipe(pipe_class_default);
16091 %}
16092 
<span class="line-modified">16093 instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)</span>
16094 %{
<span class="line-modified">16095   match(Set dst (MulReductionVI isrc vsrc));</span>
16096   ins_cost(INSN_COST);
16097   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16098   format %{ &quot;umov  $tmp, $vsrc, S, 0\n\t&quot;</span>
<span class="line-modified">16099             &quot;mul   $dst, $tmp, $isrc\n\t&quot;</span>
<span class="line-modified">16100             &quot;umov  $tmp, $vsrc, S, 1\n\t&quot;</span>
16101             &quot;mul   $dst, $tmp, $dst\t# mul reduction2I&quot;
16102   %}
16103   ins_encode %{
<span class="line-modified">16104     __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);</span>
<span class="line-modified">16105     __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);</span>
<span class="line-modified">16106     __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);</span>
16107     __ mul($dst$$Register, $tmp$$Register, $dst$$Register);
16108   %}
16109   ins_pipe(pipe_class_default);
16110 %}
16111 
<span class="line-modified">16112 instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)</span>
16113 %{
<span class="line-modified">16114   match(Set dst (MulReductionVI isrc vsrc));</span>
16115   ins_cost(INSN_COST);
<span class="line-modified">16116   effect(TEMP vtmp, TEMP itmp, TEMP dst);</span>
<span class="line-modified">16117   format %{ &quot;ins   $vtmp, D, $vsrc, 0, 1\n\t&quot;</span>
<span class="line-modified">16118             &quot;mulv  $vtmp, T2S, $vtmp, $vsrc\n\t&quot;</span>
<span class="line-modified">16119             &quot;umov  $itmp, $vtmp, S, 0\n\t&quot;</span>
<span class="line-modified">16120             &quot;mul   $dst, $itmp, $isrc\n\t&quot;</span>
<span class="line-modified">16121             &quot;umov  $itmp, $vtmp, S, 1\n\t&quot;</span>
<span class="line-modified">16122             &quot;mul   $dst, $itmp, $dst\t# mul reduction4I&quot;</span>
16123   %}
16124   ins_encode %{
<span class="line-modified">16125     __ ins(as_FloatRegister($vtmp$$reg), __ D,</span>
<span class="line-modified">16126            as_FloatRegister($vsrc$$reg), 0, 1);</span>
<span class="line-modified">16127     __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,</span>
<span class="line-modified">16128             as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">16129     __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);</span>
<span class="line-modified">16130     __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);</span>
<span class="line-modified">16131     __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);</span>
<span class="line-modified">16132     __ mul($dst$$Register, $itmp$$Register, $dst$$Register);</span>
16133   %}
16134   ins_pipe(pipe_class_default);
16135 %}
16136 
<span class="line-modified">16137 instruct reduce_add2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)</span>
16138 %{
<span class="line-modified">16139   match(Set dst (AddReductionVF fsrc vsrc));</span>
16140   ins_cost(INSN_COST);
16141   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16142   format %{ &quot;fadds $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16143             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
16144             &quot;fadds $dst, $dst, $tmp\t# add reduction2F&quot;
16145   %}
16146   ins_encode %{
16147     __ fadds(as_FloatRegister($dst$$reg),
<span class="line-modified">16148              as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
16149     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16150            as_FloatRegister($vsrc$$reg), 0, 1);</span>
16151     __ fadds(as_FloatRegister($dst$$reg),
16152              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16153   %}
16154   ins_pipe(pipe_class_default);
16155 %}
16156 
<span class="line-modified">16157 instruct reduce_add4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)</span>
16158 %{
<span class="line-modified">16159   match(Set dst (AddReductionVF fsrc vsrc));</span>
16160   ins_cost(INSN_COST);
16161   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16162   format %{ &quot;fadds $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16163             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
16164             &quot;fadds $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">16165             &quot;ins   $tmp, S, $vsrc, 0, 2\n\t&quot;</span>
16166             &quot;fadds $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">16167             &quot;ins   $tmp, S, $vsrc, 0, 3\n\t&quot;</span>
16168             &quot;fadds $dst, $dst, $tmp\t# add reduction4F&quot;
16169   %}
16170   ins_encode %{
16171     __ fadds(as_FloatRegister($dst$$reg),
<span class="line-modified">16172              as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
16173     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16174            as_FloatRegister($vsrc$$reg), 0, 1);</span>
16175     __ fadds(as_FloatRegister($dst$$reg),
16176              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16177     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16178            as_FloatRegister($vsrc$$reg), 0, 2);</span>
16179     __ fadds(as_FloatRegister($dst$$reg),
16180              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16181     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16182            as_FloatRegister($vsrc$$reg), 0, 3);</span>
16183     __ fadds(as_FloatRegister($dst$$reg),
16184              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16185   %}
16186   ins_pipe(pipe_class_default);
16187 %}
16188 
<span class="line-modified">16189 instruct reduce_mul2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)</span>
16190 %{
<span class="line-modified">16191   match(Set dst (MulReductionVF fsrc vsrc));</span>
16192   ins_cost(INSN_COST);
16193   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16194   format %{ &quot;fmuls $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16195             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
16196             &quot;fmuls $dst, $dst, $tmp\t# mul reduction2F&quot;
16197   %}
16198   ins_encode %{
16199     __ fmuls(as_FloatRegister($dst$$reg),
<span class="line-modified">16200              as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
16201     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16202            as_FloatRegister($vsrc$$reg), 0, 1);</span>
16203     __ fmuls(as_FloatRegister($dst$$reg),
16204              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16205   %}
16206   ins_pipe(pipe_class_default);
16207 %}
16208 
<span class="line-modified">16209 instruct reduce_mul4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)</span>
16210 %{
<span class="line-modified">16211   match(Set dst (MulReductionVF fsrc vsrc));</span>
16212   ins_cost(INSN_COST);
16213   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16214   format %{ &quot;fmuls $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16215             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
16216             &quot;fmuls $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">16217             &quot;ins   $tmp, S, $vsrc, 0, 2\n\t&quot;</span>
16218             &quot;fmuls $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">16219             &quot;ins   $tmp, S, $vsrc, 0, 3\n\t&quot;</span>
16220             &quot;fmuls $dst, $dst, $tmp\t# mul reduction4F&quot;
16221   %}
16222   ins_encode %{
16223     __ fmuls(as_FloatRegister($dst$$reg),
<span class="line-modified">16224              as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
16225     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16226            as_FloatRegister($vsrc$$reg), 0, 1);</span>
16227     __ fmuls(as_FloatRegister($dst$$reg),
16228              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16229     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16230            as_FloatRegister($vsrc$$reg), 0, 2);</span>
16231     __ fmuls(as_FloatRegister($dst$$reg),
16232              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16233     __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">16234            as_FloatRegister($vsrc$$reg), 0, 3);</span>
16235     __ fmuls(as_FloatRegister($dst$$reg),
16236              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16237   %}
16238   ins_pipe(pipe_class_default);
16239 %}
16240 
<span class="line-modified">16241 instruct reduce_add2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)</span>
16242 %{
<span class="line-modified">16243   match(Set dst (AddReductionVD dsrc vsrc));</span>
16244   ins_cost(INSN_COST);
16245   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16246   format %{ &quot;faddd $dst, $dsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16247             &quot;ins   $tmp, D, $vsrc, 0, 1\n\t&quot;</span>
16248             &quot;faddd $dst, $dst, $tmp\t# add reduction2D&quot;
16249   %}
16250   ins_encode %{
16251     __ faddd(as_FloatRegister($dst$$reg),
<span class="line-modified">16252              as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
16253     __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-modified">16254            as_FloatRegister($vsrc$$reg), 0, 1);</span>
16255     __ faddd(as_FloatRegister($dst$$reg),
16256              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16257   %}
16258   ins_pipe(pipe_class_default);
16259 %}
16260 
<span class="line-modified">16261 instruct reduce_mul2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)</span>
16262 %{
<span class="line-modified">16263   match(Set dst (MulReductionVD dsrc vsrc));</span>
16264   ins_cost(INSN_COST);
16265   effect(TEMP tmp, TEMP dst);
<span class="line-modified">16266   format %{ &quot;fmuld $dst, $dsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16267             &quot;ins   $tmp, D, $vsrc, 0, 1\n\t&quot;</span>
16268             &quot;fmuld $dst, $dst, $tmp\t# mul reduction2D&quot;
16269   %}
16270   ins_encode %{
16271     __ fmuld(as_FloatRegister($dst$$reg),
<span class="line-modified">16272              as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
16273     __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-modified">16274            as_FloatRegister($vsrc$$reg), 0, 1);</span>
16275     __ fmuld(as_FloatRegister($dst$$reg),
16276              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16277   %}
16278   ins_pipe(pipe_class_default);
16279 %}
16280 
<span class="line-modified">16281 instruct reduce_max2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp) %{</span>
16282   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">16283   match(Set dst (MaxReductionV fsrc vsrc));</span>
16284   ins_cost(INSN_COST);
16285   effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">16286   format %{ &quot;fmaxs $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16287             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
16288             &quot;fmaxs $dst, $dst, $tmp\t# max reduction2F&quot; %}
16289   ins_encode %{
<span class="line-modified">16290     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">16291     __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($vsrc$$reg), 0, 1);</span>
16292     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16293   %}
16294   ins_pipe(pipe_class_default);
16295 %}
16296 
<span class="line-modified">16297 instruct reduce_max4F(vRegF dst, vRegF fsrc, vecX vsrc) %{</span>
16298   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">16299   match(Set dst (MaxReductionV fsrc vsrc));</span>
16300   ins_cost(INSN_COST);
16301   effect(TEMP_DEF dst);
<span class="line-modified">16302   format %{ &quot;fmaxv $dst, T4S, $vsrc\n\t&quot;</span>
<span class="line-modified">16303             &quot;fmaxs $dst, $dst, $fsrc\t# max reduction4F&quot; %}</span>
16304   ins_encode %{
<span class="line-modified">16305     __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">16306     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));</span>
16307   %}
16308   ins_pipe(pipe_class_default);
16309 %}
16310 
<span class="line-modified">16311 instruct reduce_max2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp) %{</span>
16312   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
<span class="line-modified">16313   match(Set dst (MaxReductionV dsrc vsrc));</span>
16314   ins_cost(INSN_COST);
16315   effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">16316   format %{ &quot;fmaxd $dst, $dsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16317             &quot;ins   $tmp, D, $vsrc, 0, 1\n\t&quot;</span>
16318             &quot;fmaxd $dst, $dst, $tmp\t# max reduction2D&quot; %}
16319   ins_encode %{
<span class="line-modified">16320     __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">16321     __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($vsrc$$reg), 0, 1);</span>
16322     __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16323   %}
16324   ins_pipe(pipe_class_default);
16325 %}
16326 
<span class="line-modified">16327 instruct reduce_min2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp) %{</span>
16328   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">16329   match(Set dst (MinReductionV fsrc vsrc));</span>
16330   ins_cost(INSN_COST);
16331   effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">16332   format %{ &quot;fmins $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16333             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
16334             &quot;fmins $dst, $dst, $tmp\t# min reduction2F&quot; %}
16335   ins_encode %{
<span class="line-modified">16336     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">16337     __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($vsrc$$reg), 0, 1);</span>
16338     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16339   %}
16340   ins_pipe(pipe_class_default);
16341 %}
16342 
<span class="line-modified">16343 instruct reduce_min4F(vRegF dst, vRegF fsrc, vecX vsrc) %{</span>
16344   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">16345   match(Set dst (MinReductionV fsrc vsrc));</span>
16346   ins_cost(INSN_COST);
16347   effect(TEMP_DEF dst);
<span class="line-modified">16348   format %{ &quot;fminv $dst, T4S, $vsrc\n\t&quot;</span>
<span class="line-modified">16349             &quot;fmins $dst, $dst, $fsrc\t# min reduction4F&quot; %}</span>
16350   ins_encode %{
<span class="line-modified">16351     __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">16352     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));</span>
16353   %}
16354   ins_pipe(pipe_class_default);
16355 %}
16356 
<span class="line-modified">16357 instruct reduce_min2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp) %{</span>
16358   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
<span class="line-modified">16359   match(Set dst (MinReductionV dsrc vsrc));</span>
16360   ins_cost(INSN_COST);
16361   effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">16362   format %{ &quot;fmind $dst, $dsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">16363             &quot;ins   $tmp, D, $vsrc, 0, 1\n\t&quot;</span>
16364             &quot;fmind $dst, $dst, $tmp\t# min reduction2D&quot; %}
16365   ins_encode %{
<span class="line-modified">16366     __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">16367     __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($vsrc$$reg), 0, 1);</span>
16368     __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
16369   %}
16370   ins_pipe(pipe_class_default);
16371 %}
16372 
16373 // ====================VECTOR ARITHMETIC=======================================
16374 
16375 // --------------------------------- ADD --------------------------------------
16376 
16377 instruct vadd8B(vecD dst, vecD src1, vecD src2)
16378 %{
16379   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
16380             n-&gt;as_Vector()-&gt;length() == 8);
16381   match(Set dst (AddVB src1 src2));
16382   ins_cost(INSN_COST);
16383   format %{ &quot;addv  $dst,$src1,$src2\t# vector (8B)&quot; %}
16384   ins_encode %{
16385     __ addv(as_FloatRegister($dst$$reg), __ T8B,
16386             as_FloatRegister($src1$$reg),
16387             as_FloatRegister($src2$$reg));
</pre>
<hr />
<pre>
17592   match(Set dst (LShiftVS src (LShiftCntV shift)));
17593   ins_cost(INSN_COST);
17594   format %{ &quot;shl    $dst, $src, $shift\t# vector (8H)&quot; %}
17595   ins_encode %{
17596     int sh = (int)$shift$$constant;
17597     if (sh &gt;= 16) {
17598       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17599              as_FloatRegister($src$$reg),
17600              as_FloatRegister($src$$reg));
17601     } else {
17602       __ shl(as_FloatRegister($dst$$reg), __ T8H,
17603              as_FloatRegister($src$$reg), sh);
17604     }
17605   %}
17606   ins_pipe(vshift128_imm);
17607 %}
17608 
17609 instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
17610   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17611             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17612   match(Set dst (RShiftVS src (RShiftCntV shift)));</span>
17613   ins_cost(INSN_COST);
17614   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
17615   ins_encode %{
17616     int sh = (int)$shift$$constant;
17617     if (sh &gt;= 16) sh = 15;
17618     __ sshr(as_FloatRegister($dst$$reg), __ T4H,
17619            as_FloatRegister($src$$reg), sh);
17620   %}
17621   ins_pipe(vshift64_imm);
17622 %}
17623 
17624 instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
17625   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17626   match(Set dst (RShiftVS src (RShiftCntV shift)));</span>
17627   ins_cost(INSN_COST);
17628   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
17629   ins_encode %{
17630     int sh = (int)$shift$$constant;
17631     if (sh &gt;= 16) sh = 15;
17632     __ sshr(as_FloatRegister($dst$$reg), __ T8H,
17633            as_FloatRegister($src$$reg), sh);
17634   %}
17635   ins_pipe(vshift128_imm);
17636 %}
17637 
17638 instruct vsrl4S_imm(vecD dst, vecD src, immI shift) %{
17639   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17640             n-&gt;as_Vector()-&gt;length() == 4);
17641   match(Set dst (URShiftVS src (RShiftCntV shift)));
17642   ins_cost(INSN_COST);
17643   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4H)&quot; %}
17644   ins_encode %{
17645     int sh = (int)$shift$$constant;
17646     if (sh &gt;= 16) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/test/BuildMicrobenchmark.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/test/BuildMicrobenchmark.gmk.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1095,13 ***</span>
      _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
  
      _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;
      _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
  
<span class="line-modified">!     // r27 is not allocatable when compressed oops is on, compressed klass</span>
<span class="line-modified">!     // pointers doesn&#39;t use r27 after JDK-8234794</span>
<span class="line-modified">!     if (UseCompressedOops) {</span>
        _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27-&gt;as_VMReg()));
        _NO_SPECIAL_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
        _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
      }
  
<span class="line-new-header">--- 1095,13 ---</span>
      _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
  
      _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;
      _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
  
<span class="line-modified">!     // r27 is not allocatable when compressed oops is on and heapbase is not</span>
<span class="line-modified">!     // zero, compressed klass pointers doesn&#39;t use r27 after JDK-8234794</span>
<span class="line-modified">!     if (UseCompressedOops &amp;&amp; CompressedOops::ptrs_base() != NULL) {</span>
        _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27-&gt;as_VMReg()));
        _NO_SPECIAL_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
        _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2182,19 ***</span>
    }
    ShouldNotReachHere();
    return 0;
  }
  
<span class="line-removed">- const uint Matcher::vector_shift_count_ideal_reg(int size) {</span>
<span class="line-removed">-   switch(size) {</span>
<span class="line-removed">-     case  8: return Op_VecD;</span>
<span class="line-removed">-     case 16: return Op_VecX;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   ShouldNotReachHere();</span>
<span class="line-removed">-   return 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // AES support not yet implemented
  const bool Matcher::pass_original_key_for_aes() {
    return false;
  }
  
<span class="line-new-header">--- 2182,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2225,11 ***</span>
  const bool Matcher::need_masked_shift_count = false;
  
  // No support for generic vector operands.
  const bool Matcher::supports_generic_vector_operands  = false;
  
<span class="line-modified">! MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
    ShouldNotReachHere(); // generic vector operands not supported
    return NULL;
  }
  
  bool Matcher::is_generic_reg2reg_move(MachNode* m) {
<span class="line-new-header">--- 2216,11 ---</span>
  const bool Matcher::need_masked_shift_count = false;
  
  // No support for generic vector operands.
  const bool Matcher::supports_generic_vector_operands  = false;
  
<span class="line-modified">! MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
    ShouldNotReachHere(); // generic vector operands not supported
    return NULL;
  }
  
  bool Matcher::is_generic_reg2reg_move(MachNode* m) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7497,23 ***</span>
    ins_encode(aarch64_enc_strw(src, mem));
  
    ins_pipe(istore_reg_mem);
  %}
  
<span class="line-modified">! instruct storeImmN0(iRegIHeapbase heapbase, immN0 zero, memory4 mem)</span>
  %{
    match(Set mem (StoreN mem zero));
<span class="line-modified">!   predicate(CompressedOops::base() == NULL &amp;&amp;</span>
<span class="line-removed">-             CompressedKlassPointers::base() == NULL &amp;&amp;</span>
<span class="line-removed">-             (!needs_releasing_store(n)));</span>
  
    ins_cost(INSN_COST);
<span class="line-modified">!   format %{ &quot;strw  rheapbase, $mem\t# compressed ptr (rheapbase==0)&quot; %}</span>
  
<span class="line-modified">!   ins_encode(aarch64_enc_strw(heapbase, mem));</span>
  
<span class="line-modified">!   ins_pipe(istore_reg_mem);</span>
  %}
  
  // Store Float
  instruct storeF(vRegF src, memory4 mem)
  %{
<span class="line-new-header">--- 7488,21 ---</span>
    ins_encode(aarch64_enc_strw(src, mem));
  
    ins_pipe(istore_reg_mem);
  %}
  
<span class="line-modified">! instruct storeImmN0(immN0 zero, memory4 mem)</span>
  %{
    match(Set mem (StoreN mem zero));
<span class="line-modified">!   predicate(!needs_releasing_store(n));</span>
  
    ins_cost(INSN_COST);
<span class="line-modified">!   format %{ &quot;strw  zr, $mem\t# compressed ptr&quot; %}</span>
  
<span class="line-modified">!   ins_encode(aarch64_enc_strw0(mem));</span>
  
<span class="line-modified">!   ins_pipe(istore_mem);</span>
  %}
  
  // Store Float
  instruct storeF(vRegF src, memory4 mem)
  %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8507,21 ***</span>
    ins_encode(/* empty encoding */);
    ins_cost(0);
    ins_pipe(pipe_class_empty);
  %}
  
<span class="line-removed">- instruct castLL(iRegL dst)</span>
<span class="line-removed">- %{</span>
<span class="line-removed">-   match(Set dst (CastLL dst));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   size(0);</span>
<span class="line-removed">-   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="line-removed">-   ins_encode(/* empty encoding */);</span>
<span class="line-removed">-   ins_cost(0);</span>
<span class="line-removed">-   ins_pipe(pipe_class_empty);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  // ============================================================================
  // Atomic operation instructions
  //
  // Intel and SPARC both implement Ideal Node LoadPLocked and
  // Store{PIL}Conditional instructions using a normal load for the
<span class="line-new-header">--- 8496,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16073,322 ***</span>
    ins_pipe(vdup_reg_dreg128);
  %}
  
  // ====================REDUCTION ARITHMETIC====================================
  
<span class="line-modified">! instruct reduce_add2I(iRegINoSp dst, iRegIorL2I src1, vecD src2, iRegINoSp tmp, iRegINoSp tmp2)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVI src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP tmp2);
<span class="line-modified">!   format %{ &quot;umov  $tmp, $src2, S, 0\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $tmp2, $src2, S, 1\n\t&quot;</span>
<span class="line-modified">!             &quot;addw  $tmp, $src1, $tmp\n\t&quot;</span>
              &quot;addw  $dst, $tmp, $tmp2\t# add reduction2I&quot;
    %}
    ins_encode %{
<span class="line-modified">!     __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);</span>
<span class="line-modified">!     __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ S, 1);</span>
<span class="line-modified">!     __ addw($tmp$$Register, $src1$$Register, $tmp$$Register);</span>
      __ addw($dst$$Register, $tmp$$Register, $tmp2$$Register);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_add4I(iRegINoSp dst, iRegIorL2I src1, vecX src2, vecX tmp, iRegINoSp tmp2)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVI src1 src2));</span>
    ins_cost(INSN_COST);
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;addv  $tmp, T4S, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $tmp2, $tmp, S, 0\n\t&quot;</span>
<span class="line-modified">!             &quot;addw  $dst, $tmp2, $src1\t# add reduction4I&quot;</span>
    %}
    ins_encode %{
<span class="line-modified">!     __ addv(as_FloatRegister($tmp$$reg), __ T4S,</span>
<span class="line-modified">!             as_FloatRegister($src2$$reg));</span>
<span class="line-modified">!     __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 0);</span>
<span class="line-modified">!     __ addw($dst$$Register, $tmp2$$Register, $src1$$Register);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I src1, vecD src2, iRegINoSp tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVI src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;umov  $tmp, $src2, S, 0\n\t&quot;</span>
<span class="line-modified">!             &quot;mul   $dst, $tmp, $src1\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $tmp, $src2, S, 1\n\t&quot;</span>
              &quot;mul   $dst, $tmp, $dst\t# mul reduction2I&quot;
    %}
    ins_encode %{
<span class="line-modified">!     __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);</span>
<span class="line-modified">!     __ mul($dst$$Register, $tmp$$Register, $src1$$Register);</span>
<span class="line-modified">!     __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 1);</span>
      __ mul($dst$$Register, $tmp$$Register, $dst$$Register);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I src1, vecX src2, vecX tmp, iRegINoSp tmp2)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVI src1 src2));</span>
    ins_cost(INSN_COST);
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2, TEMP dst);</span>
<span class="line-modified">!   format %{ &quot;ins   $tmp, $src2, 0, 1\n\t&quot;</span>
<span class="line-modified">!             &quot;mul   $tmp, $tmp, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $tmp2, $tmp, S, 0\n\t&quot;</span>
<span class="line-modified">!             &quot;mul   $dst, $tmp2, $src1\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $tmp2, $tmp, S, 1\n\t&quot;</span>
<span class="line-modified">!             &quot;mul   $dst, $tmp2, $dst\t# mul reduction4I&quot;</span>
    %}
    ins_encode %{
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ D,</span>
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 1);</span>
<span class="line-modified">!     __ mulv(as_FloatRegister($tmp$$reg), __ T2S,</span>
<span class="line-modified">!            as_FloatRegister($tmp$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">!     __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 0);</span>
<span class="line-modified">!     __ mul($dst$$Register, $tmp2$$Register, $src1$$Register);</span>
<span class="line-modified">!     __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 1);</span>
<span class="line-modified">!     __ mul($dst$$Register, $tmp2$$Register, $dst$$Register);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_add2F(vRegF dst, vRegF src1, vecD src2, vecD tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVF src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fadds $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
              &quot;fadds $dst, $dst, $tmp\t# add reduction2F&quot;
    %}
    ins_encode %{
      __ fadds(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_add4F(vRegF dst, vRegF src1, vecX src2, vecX tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVF src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fadds $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
              &quot;fadds $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 2\n\t&quot;</span>
              &quot;fadds $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 3\n\t&quot;</span>
              &quot;fadds $dst, $dst, $tmp\t# add reduction4F&quot;
    %}
    ins_encode %{
      __ fadds(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 2);</span>
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 3);</span>
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul2F(vRegF dst, vRegF src1, vecD src2, vecD tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVF src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fmuls $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
              &quot;fmuls $dst, $dst, $tmp\t# mul reduction2F&quot;
    %}
    ins_encode %{
      __ fmuls(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul4F(vRegF dst, vRegF src1, vecX src2, vecX tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVF src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fmuls $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
              &quot;fmuls $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 2\n\t&quot;</span>
              &quot;fmuls $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 3\n\t&quot;</span>
              &quot;fmuls $dst, $dst, $tmp\t# mul reduction4F&quot;
    %}
    ins_encode %{
      __ fmuls(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 2);</span>
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 3);</span>
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_add2D(vRegD dst, vRegD src1, vecX src2, vecX tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVD src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;faddd $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;</span>
              &quot;faddd $dst, $dst, $tmp\t# add reduction2D&quot;
    %}
    ins_encode %{
      __ faddd(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 1);</span>
      __ faddd(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul2D(vRegD dst, vRegD src1, vecX src2, vecX tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVD src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fmuld $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;</span>
              &quot;fmuld $dst, $dst, $tmp\t# mul reduction2D&quot;
    %}
    ins_encode %{
      __ fmuld(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-modified">!            as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fmuld(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_max2F(vRegF dst, vRegF src1, vecD src2, vecD tmp) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">!   match(Set dst (MaxReductionV src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">!   format %{ &quot;fmaxs $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
              &quot;fmaxs $dst, $dst, $tmp\t# max reduction2F&quot; %}
    ins_encode %{
<span class="line-modified">!     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_max4F(vRegF dst, vRegF src1, vecX src2) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">!   match(Set dst (MaxReductionV src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst);
<span class="line-modified">!   format %{ &quot;fmaxv $dst, T4S, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;fmaxs $dst, $dst, $src1\t# max reduction4F&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));</span>
<span class="line-modified">!     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_max2D(vRegD dst, vRegD src1, vecX src2, vecX tmp) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
<span class="line-modified">!   match(Set dst (MaxReductionV src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">!   format %{ &quot;fmaxd $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;</span>
              &quot;fmaxd $dst, $dst, $tmp\t# max reduction2D&quot; %}
    ins_encode %{
<span class="line-modified">!     __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_min2F(vRegF dst, vRegF src1, vecD src2, vecD tmp) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">!   match(Set dst (MinReductionV src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">!   format %{ &quot;fmins $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;</span>
              &quot;fmins $dst, $dst, $tmp\t# min reduction2F&quot; %}
    ins_encode %{
<span class="line-modified">!     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_min4F(vRegF dst, vRegF src1, vecX src2) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">!   match(Set dst (MinReductionV src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst);
<span class="line-modified">!   format %{ &quot;fminv $dst, T4S, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;fmins $dst, $dst, $src1\t# min reduction4F&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));</span>
<span class="line-modified">!     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_min2D(vRegD dst, vRegD src1, vecX src2, vecX tmp) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
<span class="line-modified">!   match(Set dst (MinReductionV src1 src2));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">!   format %{ &quot;fmind $dst, $src1, $src2\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;</span>
              &quot;fmind $dst, $dst, $tmp\t# min reduction2D&quot; %}
    ins_encode %{
<span class="line-modified">!     __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));</span>
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);</span>
      __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-new-header">--- 16051,322 ---</span>
    ins_pipe(vdup_reg_dreg128);
  %}
  
  // ====================REDUCTION ARITHMETIC====================================
  
<span class="line-modified">! instruct reduce_add2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp, iRegINoSp tmp2)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVI isrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP tmp2);
<span class="line-modified">!   format %{ &quot;umov  $tmp, $vsrc, S, 0\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $tmp2, $vsrc, S, 1\n\t&quot;</span>
<span class="line-modified">!             &quot;addw  $tmp, $isrc, $tmp\n\t&quot;</span>
              &quot;addw  $dst, $tmp, $tmp2\t# add reduction2I&quot;
    %}
    ins_encode %{
<span class="line-modified">!     __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);</span>
<span class="line-modified">!     __ umov($tmp2$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);</span>
<span class="line-modified">!     __ addw($tmp$$Register, $isrc$$Register, $tmp$$Register);</span>
      __ addw($dst$$Register, $tmp$$Register, $tmp2$$Register);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_add4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVI isrc vsrc));</span>
    ins_cost(INSN_COST);
<span class="line-modified">!   effect(TEMP vtmp, TEMP itmp);</span>
<span class="line-modified">!   format %{ &quot;addv  $vtmp, T4S, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $itmp, $vtmp, S, 0\n\t&quot;</span>
<span class="line-modified">!             &quot;addw  $dst, $itmp, $isrc\t# add reduction4I&quot;</span>
    %}
    ins_encode %{
<span class="line-modified">!     __ addv(as_FloatRegister($vtmp$$reg), __ T4S,</span>
<span class="line-modified">!             as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">!     __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);</span>
<span class="line-modified">!     __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVI isrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;umov  $tmp, $vsrc, S, 0\n\t&quot;</span>
<span class="line-modified">!             &quot;mul   $dst, $tmp, $isrc\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $tmp, $vsrc, S, 1\n\t&quot;</span>
              &quot;mul   $dst, $tmp, $dst\t# mul reduction2I&quot;
    %}
    ins_encode %{
<span class="line-modified">!     __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);</span>
<span class="line-modified">!     __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);</span>
<span class="line-modified">!     __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);</span>
      __ mul($dst$$Register, $tmp$$Register, $dst$$Register);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVI isrc vsrc));</span>
    ins_cost(INSN_COST);
<span class="line-modified">!   effect(TEMP vtmp, TEMP itmp, TEMP dst);</span>
<span class="line-modified">!   format %{ &quot;ins   $vtmp, D, $vsrc, 0, 1\n\t&quot;</span>
<span class="line-modified">!             &quot;mulv  $vtmp, T2S, $vtmp, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $itmp, $vtmp, S, 0\n\t&quot;</span>
<span class="line-modified">!             &quot;mul   $dst, $itmp, $isrc\n\t&quot;</span>
<span class="line-modified">!             &quot;umov  $itmp, $vtmp, S, 1\n\t&quot;</span>
<span class="line-modified">!             &quot;mul   $dst, $itmp, $dst\t# mul reduction4I&quot;</span>
    %}
    ins_encode %{
<span class="line-modified">!     __ ins(as_FloatRegister($vtmp$$reg), __ D,</span>
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 1);</span>
<span class="line-modified">!     __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,</span>
<span class="line-modified">!             as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">!     __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);</span>
<span class="line-modified">!     __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);</span>
<span class="line-modified">!     __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);</span>
<span class="line-modified">!     __ mul($dst$$Register, $itmp$$Register, $dst$$Register);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_add2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVF fsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fadds $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fadds $dst, $dst, $tmp\t# add reduction2F&quot;
    %}
    ins_encode %{
      __ fadds(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_add4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVF fsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fadds $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fadds $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 2\n\t&quot;</span>
              &quot;fadds $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 3\n\t&quot;</span>
              &quot;fadds $dst, $dst, $tmp\t# add reduction4F&quot;
    %}
    ins_encode %{
      __ fadds(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 2);</span>
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 3);</span>
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVF fsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fmuls $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fmuls $dst, $dst, $tmp\t# mul reduction2F&quot;
    %}
    ins_encode %{
      __ fmuls(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVF fsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fmuls $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fmuls $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 2\n\t&quot;</span>
              &quot;fmuls $dst, $dst, $tmp\n\t&quot;
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 3\n\t&quot;</span>
              &quot;fmuls $dst, $dst, $tmp\t# mul reduction4F&quot;
    %}
    ins_encode %{
      __ fmuls(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 2);</span>
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 3);</span>
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_add2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (AddReductionVD dsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;faddd $dst, $dsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, D, $vsrc, 0, 1\n\t&quot;</span>
              &quot;faddd $dst, $dst, $tmp\t# add reduction2D&quot;
    %}
    ins_encode %{
      __ faddd(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ faddd(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_mul2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)</span>
  %{
<span class="line-modified">!   match(Set dst (MulReductionVD dsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
<span class="line-modified">!   format %{ &quot;fmuld $dst, $dsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, D, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fmuld $dst, $dst, $tmp\t# mul reduction2D&quot;
    %}
    ins_encode %{
      __ fmuld(as_FloatRegister($dst$$reg),
<span class="line-modified">!              as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
      __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-modified">!            as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fmuld(as_FloatRegister($dst$$reg),
               as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_max2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">!   match(Set dst (MaxReductionV fsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">!   format %{ &quot;fmaxs $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fmaxs $dst, $dst, $tmp\t# max reduction2F&quot; %}
    ins_encode %{
<span class="line-modified">!     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_max4F(vRegF dst, vRegF fsrc, vecX vsrc) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">!   match(Set dst (MaxReductionV fsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst);
<span class="line-modified">!   format %{ &quot;fmaxv $dst, T4S, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;fmaxs $dst, $dst, $fsrc\t# max reduction4F&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">!     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_max2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
<span class="line-modified">!   match(Set dst (MaxReductionV dsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">!   format %{ &quot;fmaxd $dst, $dsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, D, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fmaxd $dst, $dst, $tmp\t# max reduction2D&quot; %}
    ins_encode %{
<span class="line-modified">!     __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_min2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">!   match(Set dst (MinReductionV fsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">!   format %{ &quot;fmins $dst, $fsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, S, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fmins $dst, $dst, $tmp\t# min reduction2F&quot; %}
    ins_encode %{
<span class="line-modified">!     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_min4F(vRegF dst, vRegF fsrc, vecX vsrc) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
<span class="line-modified">!   match(Set dst (MinReductionV fsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst);
<span class="line-modified">!   format %{ &quot;fminv $dst, T4S, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;fmins $dst, $dst, $fsrc\t# min reduction4F&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">!     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct reduce_min2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp) %{</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
<span class="line-modified">!   match(Set dst (MinReductionV dsrc vsrc));</span>
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
<span class="line-modified">!   format %{ &quot;fmind $dst, $dsrc, $vsrc\n\t&quot;</span>
<span class="line-modified">!             &quot;ins   $tmp, D, $vsrc, 0, 1\n\t&quot;</span>
              &quot;fmind $dst, $dst, $tmp\t# min reduction2D&quot; %}
    ins_encode %{
<span class="line-modified">!     __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));</span>
<span class="line-modified">!     __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($vsrc$$reg), 0, 1);</span>
      __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
    ins_pipe(pipe_class_default);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17629,11 ***</span>
  %}
  
  instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
              n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) sh = 15;
<span class="line-new-header">--- 17607,11 ---</span>
  %}
  
  instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
              n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   match(Set dst (RShiftVS src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) sh = 15;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17643,11 ***</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">!   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) sh = 15;
<span class="line-new-header">--- 17621,11 ---</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">!   match(Set dst (RShiftVS src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) sh = 15;
</pre>
<center><a href="../../../../make/test/BuildMicrobenchmark.gmk.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // X86 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // architecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // Previously set EBX, ESI, and EDI as save-on-entry for java code
   64 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   65 // Now that allocator is better, turn on ESI and EDI as SOE registers.
   66 
   67 reg_def EBX(SOC, SOE, Op_RegI, 3, rbx-&gt;as_VMReg());
   68 reg_def ECX(SOC, SOC, Op_RegI, 1, rcx-&gt;as_VMReg());
   69 reg_def ESI(SOC, SOE, Op_RegI, 6, rsi-&gt;as_VMReg());
   70 reg_def EDI(SOC, SOE, Op_RegI, 7, rdi-&gt;as_VMReg());
   71 // now that adapter frames are gone EBP is always saved and restored by the prolog/epilog code
   72 reg_def EBP(NS, SOE, Op_RegI, 5, rbp-&gt;as_VMReg());
   73 reg_def EDX(SOC, SOC, Op_RegI, 2, rdx-&gt;as_VMReg());
   74 reg_def EAX(SOC, SOC, Op_RegI, 0, rax-&gt;as_VMReg());
   75 reg_def ESP( NS,  NS, Op_RegI, 4, rsp-&gt;as_VMReg());
   76 
   77 // Float registers.  We treat TOS/FPR0 special.  It is invisible to the
   78 // allocator, and only shows up in the encodings.
   79 reg_def FPR0L( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   80 reg_def FPR0H( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   81 // Ok so here&#39;s the trick FPR1 is really st(0) except in the midst
   82 // of emission of assembly for a machnode. During the emission the fpu stack
   83 // is pushed making FPR1 == st(1) temporarily. However at any safepoint
   84 // the stack will not have this element so FPR1 == st(0) from the
   85 // oopMap viewpoint. This same weirdness with numbering causes
   86 // instruction encoding to have to play games with the register
   87 // encode to correct for this 0/1 issue. See MachSpillCopyNode::implementation
   88 // where it does flt-&gt;flt moves to see an example
   89 //
   90 reg_def FPR1L( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg());
   91 reg_def FPR1H( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg()-&gt;next());
   92 reg_def FPR2L( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg());
   93 reg_def FPR2H( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg()-&gt;next());
   94 reg_def FPR3L( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg());
   95 reg_def FPR3H( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg()-&gt;next());
   96 reg_def FPR4L( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg());
   97 reg_def FPR4H( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg()-&gt;next());
   98 reg_def FPR5L( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg());
   99 reg_def FPR5H( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg()-&gt;next());
  100 reg_def FPR6L( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg());
  101 reg_def FPR6H( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg()-&gt;next());
  102 reg_def FPR7L( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg());
  103 reg_def FPR7H( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg()-&gt;next());
  104 //
  105 // Empty fill registers, which are never used, but supply alignment to xmm regs
  106 //
  107 reg_def FILL0( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());
  108 reg_def FILL1( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());
  109 reg_def FILL2( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());
  110 reg_def FILL3( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());
  111 reg_def FILL4( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());
  112 reg_def FILL5( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());
  113 reg_def FILL6( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());
  114 reg_def FILL7( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());
  115 
  116 // Specify priority of register selection within phases of register
  117 // allocation.  Highest priority is first.  A useful heuristic is to
  118 // give registers a low priority when they are required by machine
  119 // instructions, like EAX and EDX.  Registers which are used as
  120 // pairs must fall on an even boundary (witness the FPR#L&#39;s in this list).
  121 // For the Intel integer registers, the equivalent Long pairs are
  122 // EDX:EAX, EBX:ECX, and EDI:EBP.
  123 alloc_class chunk0( ECX,   EBX,   EBP,   EDI,   EAX,   EDX,   ESI, ESP,
  124                     FPR0L, FPR0H, FPR1L, FPR1H, FPR2L, FPR2H,
  125                     FPR3L, FPR3H, FPR4L, FPR4H, FPR5L, FPR5H,
  126                     FPR6L, FPR6H, FPR7L, FPR7H,
  127                     FILL0, FILL1, FILL2, FILL3, FILL4, FILL5, FILL6, FILL7);
  128 
  129 
  130 //----------Architecture Description Register Classes--------------------------
  131 // Several register classes are automatically defined based upon information in
  132 // this architecture description.
  133 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  134 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  135 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  136 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  137 //
  138 // Class for no registers (empty set).
  139 reg_class no_reg();
  140 
  141 // Class for all registers
  142 reg_class any_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX, ESP);
  143 // Class for all registers (excluding EBP)
  144 reg_class any_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX, ESP);
  145 // Dynamic register class that selects at runtime between register classes
  146 // any_reg and any_no_ebp_reg (depending on the value of the flag PreserveFramePointer).
  147 // Equivalent to: return PreserveFramePointer ? any_no_ebp_reg : any_reg;
  148 reg_class_dynamic any_reg(any_reg_no_ebp, any_reg_with_ebp, %{ PreserveFramePointer %});
  149 
  150 // Class for general registers
  151 reg_class int_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX);
  152 // Class for general registers (excluding EBP).
  153 // This register class can be used for implicit null checks on win95.
  154 // It is also safe for use by tailjumps (we don&#39;t want to allocate in ebp).
  155 // Used also if the PreserveFramePointer flag is true.
  156 reg_class int_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX);
  157 // Dynamic register class that selects between int_reg and int_reg_no_ebp.
  158 reg_class_dynamic int_reg(int_reg_no_ebp, int_reg_with_ebp, %{ PreserveFramePointer %});
  159 
  160 // Class of &quot;X&quot; registers
  161 reg_class int_x_reg(EBX, ECX, EDX, EAX);
  162 
  163 // Class of registers that can appear in an address with no offset.
  164 // EBP and ESP require an extra instruction byte for zero offset.
  165 // Used in fast-unlock
  166 reg_class p_reg(EDX, EDI, ESI, EBX);
  167 
  168 // Class for general registers excluding ECX
  169 reg_class ncx_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, EBX);
  170 // Class for general registers excluding ECX (and EBP)
  171 reg_class ncx_reg_no_ebp(EAX, EDX, EDI, ESI, EBX);
  172 // Dynamic register class that selects between ncx_reg and ncx_reg_no_ebp.
  173 reg_class_dynamic ncx_reg(ncx_reg_no_ebp, ncx_reg_with_ebp, %{ PreserveFramePointer %});
  174 
  175 // Class for general registers excluding EAX
  176 reg_class nax_reg(EDX, EDI, ESI, ECX, EBX);
  177 
  178 // Class for general registers excluding EAX and EBX.
  179 reg_class nabx_reg_with_ebp(EDX, EDI, ESI, ECX, EBP);
  180 // Class for general registers excluding EAX and EBX (and EBP)
  181 reg_class nabx_reg_no_ebp(EDX, EDI, ESI, ECX);
  182 // Dynamic register class that selects between nabx_reg and nabx_reg_no_ebp.
  183 reg_class_dynamic nabx_reg(nabx_reg_no_ebp, nabx_reg_with_ebp, %{ PreserveFramePointer %});
  184 
  185 // Class of EAX (for multiply and divide operations)
  186 reg_class eax_reg(EAX);
  187 
  188 // Class of EBX (for atomic add)
  189 reg_class ebx_reg(EBX);
  190 
  191 // Class of ECX (for shift and JCXZ operations and cmpLTMask)
  192 reg_class ecx_reg(ECX);
  193 
  194 // Class of EDX (for multiply and divide operations)
  195 reg_class edx_reg(EDX);
  196 
  197 // Class of EDI (for synchronization)
  198 reg_class edi_reg(EDI);
  199 
  200 // Class of ESI (for synchronization)
  201 reg_class esi_reg(ESI);
  202 
  203 // Singleton class for stack pointer
  204 reg_class sp_reg(ESP);
  205 
  206 // Singleton class for instruction pointer
  207 // reg_class ip_reg(EIP);
  208 
  209 // Class of integer register pairs
  210 reg_class long_reg_with_ebp( EAX,EDX, ECX,EBX, EBP,EDI );
  211 // Class of integer register pairs (excluding EBP and EDI);
  212 reg_class long_reg_no_ebp( EAX,EDX, ECX,EBX );
  213 // Dynamic register class that selects between long_reg and long_reg_no_ebp.
  214 reg_class_dynamic long_reg(long_reg_no_ebp, long_reg_with_ebp, %{ PreserveFramePointer %});
  215 
  216 // Class of integer register pairs that aligns with calling convention
  217 reg_class eadx_reg( EAX,EDX );
  218 reg_class ebcx_reg( ECX,EBX );
  219 
  220 // Not AX or DX, used in divides
  221 reg_class nadx_reg_with_ebp(EBX, ECX, ESI, EDI, EBP);
  222 // Not AX or DX (and neither EBP), used in divides
  223 reg_class nadx_reg_no_ebp(EBX, ECX, ESI, EDI);
  224 // Dynamic register class that selects between nadx_reg and nadx_reg_no_ebp.
  225 reg_class_dynamic nadx_reg(nadx_reg_no_ebp, nadx_reg_with_ebp, %{ PreserveFramePointer %});
  226 
  227 // Floating point registers.  Notice FPR0 is not a choice.
  228 // FPR0 is not ever allocated; we use clever encodings to fake
  229 // a 2-address instructions out of Intels FP stack.
  230 reg_class fp_flt_reg( FPR1L,FPR2L,FPR3L,FPR4L,FPR5L,FPR6L,FPR7L );
  231 
  232 reg_class fp_dbl_reg( FPR1L,FPR1H, FPR2L,FPR2H, FPR3L,FPR3H,
  233                       FPR4L,FPR4H, FPR5L,FPR5H, FPR6L,FPR6H,
  234                       FPR7L,FPR7H );
  235 
  236 reg_class fp_flt_reg0( FPR1L );
  237 reg_class fp_dbl_reg0( FPR1L,FPR1H );
  238 reg_class fp_dbl_reg1( FPR2L,FPR2H );
  239 reg_class fp_dbl_notreg0( FPR2L,FPR2H, FPR3L,FPR3H, FPR4L,FPR4H,
  240                           FPR5L,FPR5H, FPR6L,FPR6H, FPR7L,FPR7H );
  241 
  242 %}
  243 
  244 
  245 //----------SOURCE BLOCK-------------------------------------------------------
  246 // This is a block of C++ code which provides values, functions, and
  247 // definitions necessary in the rest of the architecture description
  248 source_hpp %{
  249 // Must be visible to the DFA in dfa_x86_32.cpp
  250 extern bool is_operand_hi32_zero(Node* n);
  251 %}
  252 
  253 source %{
  254 #define   RELOC_IMM32    Assembler::imm_operand
  255 #define   RELOC_DISP32   Assembler::disp32_operand
  256 
  257 #define __ _masm.
  258 
  259 // How to find the high register of a Long pair, given the low register
  260 #define   HIGH_FROM_LOW(x) ((x)+2)
  261 
  262 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  263 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  264 // fast versions of NegF/NegD and AbsF/AbsD.
  265 
  266 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  267 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  268   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  269   // of 128-bits operands for SSE instructions.
  270   jlong *operand = (jlong*)(((uintptr_t)adr)&amp;((uintptr_t)(~0xF)));
  271   // Store the value to a 128-bits operand.
  272   operand[0] = lo;
  273   operand[1] = hi;
  274   return operand;
  275 }
  276 
  277 // Buffer for 128-bits masks used by SSE instructions.
  278 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  279 
  280 // Static initialization during VM startup.
  281 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2], CONST64(0x7FFFFFFF7FFFFFFF), CONST64(0x7FFFFFFF7FFFFFFF));
  282 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2], CONST64(0x7FFFFFFFFFFFFFFF), CONST64(0x7FFFFFFFFFFFFFFF));
  283 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], CONST64(0x8000000080000000), CONST64(0x8000000080000000));
  284 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
  285 
  286 // Offset hacking within calls.
  287 static int pre_call_resets_size() {
  288   int size = 0;
  289   Compile* C = Compile::current();
  290   if (C-&gt;in_24_bit_fp_mode()) {
  291     size += 6; // fldcw
  292   }
  293   if (VM_Version::supports_vzeroupper()) {
  294     size += 3; // vzeroupper
  295   }
  296   return size;
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 
  317 //
  318 // Compute padding required for nodes which need alignment
  319 //
  320 
  321 // The address of the call instruction needs to be 4-byte aligned to
  322 // ensure that it does not span a cache line so that it can be patched.
  323 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  324   current_offset += pre_call_resets_size();  // skip fldcw, if any
  325   current_offset += 1;      // skip call opcode byte
  326   return align_up(current_offset, alignment_required()) - current_offset;
  327 }
  328 
  329 // The address of the call instruction needs to be 4-byte aligned to
  330 // ensure that it does not span a cache line so that it can be patched.
  331 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  332   current_offset += pre_call_resets_size();  // skip fldcw, if any
  333   current_offset += 5;      // skip MOV instruction
  334   current_offset += 1;      // skip call opcode byte
  335   return align_up(current_offset, alignment_required()) - current_offset;
  336 }
  337 
  338 // EMIT_RM()
  339 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  340   unsigned char c = (unsigned char)((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  341   cbuf.insts()-&gt;emit_int8(c);
  342 }
  343 
  344 // EMIT_CC()
  345 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  346   unsigned char c = (unsigned char)( f1 | f2 );
  347   cbuf.insts()-&gt;emit_int8(c);
  348 }
  349 
  350 // EMIT_OPCODE()
  351 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  352   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  353 }
  354 
  355 // EMIT_OPCODE() w/ relocation information
  356 void emit_opcode(CodeBuffer &amp;cbuf, int code, relocInfo::relocType reloc, int offset = 0) {
  357   cbuf.relocate(cbuf.insts_mark() + offset, reloc);
  358   emit_opcode(cbuf, code);
  359 }
  360 
  361 // EMIT_D8()
  362 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  363   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  364 }
  365 
  366 // EMIT_D16()
  367 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  368   cbuf.insts()-&gt;emit_int16(d16);
  369 }
  370 
  371 // EMIT_D32()
  372 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  373   cbuf.insts()-&gt;emit_int32(d32);
  374 }
  375 
  376 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  377 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, relocInfo::relocType reloc,
  378         int format) {
  379   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  380   cbuf.insts()-&gt;emit_int32(d32);
  381 }
  382 
  383 // emit 32 bit value and construct relocation entry from RelocationHolder
  384 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, RelocationHolder const&amp; rspec,
  385         int format) {
  386 #ifdef ASSERT
  387   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp; d32 != 0 &amp;&amp; d32 != (int)Universe::non_oop_word()) {
  388     assert(oopDesc::is_oop(cast_to_oop(d32)), &quot;cannot embed broken oops in code&quot;);
  389   }
  390 #endif
  391   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  392   cbuf.insts()-&gt;emit_int32(d32);
  393 }
  394 
  395 // Access stack slot for load or store
  396 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp) {
  397   emit_opcode( cbuf, opcode );               // (e.g., FILD   [ESP+src])
  398   if( -128 &lt;= disp &amp;&amp; disp &lt;= 127 ) {
  399     emit_rm( cbuf, 0x01, rm_field, ESP_enc );  // R/M byte
  400     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  401     emit_d8 (cbuf, disp);     // Displacement  // R/M byte
  402   } else {
  403     emit_rm( cbuf, 0x02, rm_field, ESP_enc );  // R/M byte
  404     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  405     emit_d32(cbuf, disp);     // Displacement  // R/M byte
  406   }
  407 }
  408 
  409    // rRegI ereg, memory mem) %{    // emit_reg_mem
  410 void encode_RegMem( CodeBuffer &amp;cbuf, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {
  411   // There is no index &amp; no scale, use form without SIB byte
  412   if ((index == 0x4) &amp;&amp;
  413       (scale == 0) &amp;&amp; (base != ESP_enc)) {
  414     // If no displacement, mode is 0x0; unless base is [EBP]
  415     if ( (displace == 0) &amp;&amp; (base != EBP_enc) ) {
  416       emit_rm(cbuf, 0x0, reg_encoding, base);
  417     }
  418     else {                    // If 8-bit displacement, mode 0x1
  419       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  420           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  421         emit_rm(cbuf, 0x1, reg_encoding, base);
  422         emit_d8(cbuf, displace);
  423       }
  424       else {                  // If 32-bit displacement
  425         if (base == -1) { // Special flag for absolute address
  426           emit_rm(cbuf, 0x0, reg_encoding, 0x5);
  427           // (manual lies; no SIB needed here)
  428           if ( disp_reloc != relocInfo::none ) {
  429             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  430           } else {
  431             emit_d32      (cbuf, displace);
  432           }
  433         }
  434         else {                // Normal base + offset
  435           emit_rm(cbuf, 0x2, reg_encoding, base);
  436           if ( disp_reloc != relocInfo::none ) {
  437             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  438           } else {
  439             emit_d32      (cbuf, displace);
  440           }
  441         }
  442       }
  443     }
  444   }
  445   else {                      // Else, encode with the SIB byte
  446     // If no displacement, mode is 0x0; unless base is [EBP]
  447     if (displace == 0 &amp;&amp; (base != EBP_enc)) {  // If no displacement
  448       emit_rm(cbuf, 0x0, reg_encoding, 0x4);
  449       emit_rm(cbuf, scale, index, base);
  450     }
  451     else {                    // If 8-bit displacement, mode 0x1
  452       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  453           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  454         emit_rm(cbuf, 0x1, reg_encoding, 0x4);
  455         emit_rm(cbuf, scale, index, base);
  456         emit_d8(cbuf, displace);
  457       }
  458       else {                  // If 32-bit displacement
  459         if (base == 0x04 ) {
  460           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  461           emit_rm(cbuf, scale, index, 0x04);
  462         } else {
  463           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  464           emit_rm(cbuf, scale, index, base);
  465         }
  466         if ( disp_reloc != relocInfo::none ) {
  467           emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  468         } else {
  469           emit_d32      (cbuf, displace);
  470         }
  471       }
  472     }
  473   }
  474 }
  475 
  476 
  477 void encode_Copy( CodeBuffer &amp;cbuf, int dst_encoding, int src_encoding ) {
  478   if( dst_encoding == src_encoding ) {
  479     // reg-reg copy, use an empty encoding
  480   } else {
  481     emit_opcode( cbuf, 0x8B );
  482     emit_rm(cbuf, 0x3, dst_encoding, src_encoding );
  483   }
  484 }
  485 
  486 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  487   Label exit;
  488   __ jccb(Assembler::noParity, exit);
  489   __ pushf();
  490   //
  491   // comiss/ucomiss instructions set ZF,PF,CF flags and
  492   // zero OF,AF,SF for NaN values.
  493   // Fixup flags by zeroing ZF,PF so that compare of NaN
  494   // values returns &#39;less than&#39; result (CF is set).
  495   // Leave the rest of flags unchanged.
  496   //
  497   //    7 6 5 4 3 2 1 0
  498   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  499   //    0 0 1 0 1 0 1 1   (0x2B)
  500   //
  501   __ andl(Address(rsp, 0), 0xffffff2b);
  502   __ popf();
  503   __ bind(exit);
  504 }
  505 
  506 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  507   Label done;
  508   __ movl(dst, -1);
  509   __ jcc(Assembler::parity, done);
  510   __ jcc(Assembler::below, done);
  511   __ setb(Assembler::notEqual, dst);
  512   __ movzbl(dst, dst);
  513   __ bind(done);
  514 }
  515 
  516 
  517 //=============================================================================
  518 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  519 
  520 int ConstantTable::calculate_table_base_offset() const {
  521   return 0;  // absolute addressing, no offset
  522 }
  523 
  524 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  525 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  526   ShouldNotReachHere();
  527 }
  528 
  529 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  530   // Empty encoding
  531 }
  532 
  533 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  534   return 0;
  535 }
  536 
  537 #ifndef PRODUCT
  538 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  539   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  540 }
  541 #endif
  542 
  543 
  544 //=============================================================================
  545 #ifndef PRODUCT
  546 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  547   Compile* C = ra_-&gt;C;
  548 
  549   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  550   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  551   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  552   // Remove wordSize for return addr which is already pushed.
  553   framesize -= wordSize;
  554 
  555   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  556     framesize -= wordSize;
  557     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  558     st-&gt;print(&quot;\n\t&quot;);
  559     st-&gt;print(&quot;PUSH   EBP\t# Save EBP&quot;);
  560     if (PreserveFramePointer) {
  561       st-&gt;print(&quot;\n\t&quot;);
  562       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  563     }
  564     if (framesize) {
  565       st-&gt;print(&quot;\n\t&quot;);
  566       st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  567     }
  568   } else {
  569     st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  570     st-&gt;print(&quot;\n\t&quot;);
  571     framesize -= wordSize;
  572     st-&gt;print(&quot;MOV    [ESP + #%d], EBP\t# Save EBP&quot;,framesize);
  573     if (PreserveFramePointer) {
  574       st-&gt;print(&quot;\n\t&quot;);
  575       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  576       if (framesize &gt; 0) {
  577         st-&gt;print(&quot;\n\t&quot;);
  578         st-&gt;print(&quot;ADD    EBP, #%d&quot;, framesize);
  579       }
  580     }
  581   }
  582 
  583   if (VerifyStackAtCalls) {
  584     st-&gt;print(&quot;\n\t&quot;);
  585     framesize -= wordSize;
  586     st-&gt;print(&quot;MOV    [ESP + #%d], 0xBADB100D\t# Majik cookie for stack depth check&quot;,framesize);
  587   }
  588 
  589   if( C-&gt;in_24_bit_fp_mode() ) {
  590     st-&gt;print(&quot;\n\t&quot;);
  591     st-&gt;print(&quot;FLDCW  \t# load 24 bit fpu control word&quot;);
  592   }
  593   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
  594     st-&gt;print(&quot;\n\t&quot;);
  595     st-&gt;print(&quot;# verify FPU stack (must be clean on entry)&quot;);
  596   }
  597 
  598 #ifdef ASSERT
  599   if (VerifyStackAtCalls) {
  600     st-&gt;print(&quot;\n\t&quot;);
  601     st-&gt;print(&quot;# stack alignment check&quot;);
  602   }
  603 #endif
  604   st-&gt;cr();
  605 }
  606 #endif
  607 
  608 
  609 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  610   Compile* C = ra_-&gt;C;
  611   MacroAssembler _masm(&amp;cbuf);
  612 
  613   __ verified_entry(C);
  614 
  615   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  616 
  617   if (C-&gt;has_mach_constant_base_node()) {
  618     // NOTE: We set the table base offset here because users might be
  619     // emitted before MachConstantBaseNode.
  620     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  621     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  622   }
  623 }
  624 
  625 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  626   return MachNode::size(ra_); // too many variables; just compute it the hard way
  627 }
  628 
  629 int MachPrologNode::reloc() const {
  630   return 0; // a large enough number
  631 }
  632 
  633 //=============================================================================
  634 #ifndef PRODUCT
  635 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  636   Compile *C = ra_-&gt;C;
  637   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  638   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  639   // Remove two words for return addr and rbp,
  640   framesize -= 2*wordSize;
  641 
  642   if (C-&gt;max_vector_size() &gt; 16) {
  643     st-&gt;print(&quot;VZEROUPPER&quot;);
  644     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  645   }
  646   if (C-&gt;in_24_bit_fp_mode()) {
  647     st-&gt;print(&quot;FLDCW  standard control word&quot;);
  648     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  649   }
  650   if (framesize) {
  651     st-&gt;print(&quot;ADD    ESP,%d\t# Destroy frame&quot;,framesize);
  652     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  653   }
  654   st-&gt;print_cr(&quot;POPL   EBP&quot;); st-&gt;print(&quot;\t&quot;);
  655   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  656     st-&gt;print(&quot;TEST   PollPage,EAX\t! Poll Safepoint&quot;);
  657     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  658   }
  659 }
  660 #endif
  661 
  662 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  663   Compile *C = ra_-&gt;C;
  664   MacroAssembler _masm(&amp;cbuf);
  665 
  666   if (C-&gt;max_vector_size() &gt; 16) {
  667     // Clear upper bits of YMM registers when current compiled code uses
  668     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  669     _masm.vzeroupper();
  670   }
  671   // If method set FPU control word, restore to standard control word
  672   if (C-&gt;in_24_bit_fp_mode()) {
  673     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
  674   }
  675 
  676   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  677   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  678   // Remove two words for return addr and rbp,
  679   framesize -= 2*wordSize;
  680 
  681   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  682 
  683   if (framesize &gt;= 128) {
  684     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  685     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  686     emit_d32(cbuf, framesize);
  687   } else if (framesize) {
  688     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  689     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  690     emit_d8(cbuf, framesize);
  691   }
  692 
  693   emit_opcode(cbuf, 0x58 | EBP_enc);
  694 
  695   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  696     __ reserved_stack_check();
  697   }
  698 
  699   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  700     Register pollReg = as_Register(EBX_enc);
  701     MacroAssembler masm(&amp;cbuf);
  702     masm.get_thread(pollReg);
  703     masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));
  704     masm.relocate(relocInfo::poll_return_type);
  705     masm.testl(rax, Address(pollReg, 0));
  706   }
  707 }
  708 
  709 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  710   return MachNode::size(ra_); // too many variables; just compute it
  711                               // the hard way
  712 }
  713 
  714 int MachEpilogNode::reloc() const {
  715   return 0; // a large enough number
  716 }
  717 
  718 const Pipeline * MachEpilogNode::pipeline() const {
  719   return MachNode::pipeline_class();
  720 }
  721 
  722 //=============================================================================
  723 
  724 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  725 static enum RC rc_class( OptoReg::Name reg ) {
  726 
  727   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  728   if (OptoReg::is_stack(reg)) return rc_stack;
  729 
  730   VMReg r = OptoReg::as_VMReg(reg);
  731   if (r-&gt;is_Register()) return rc_int;
  732   if (r-&gt;is_FloatRegister()) {
  733     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  734     return rc_float;
  735   }
  736   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  737   return rc_xmm;
  738 }
  739 
  740 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  741                         int opcode, const char *op_str, int size, outputStream* st ) {
  742   if( cbuf ) {
  743     emit_opcode  (*cbuf, opcode );
  744     encode_RegMem(*cbuf, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);
  745 #ifndef PRODUCT
  746   } else if( !do_size ) {
  747     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  748     if( opcode == 0x8B || opcode == 0x89 ) { // MOV
  749       if( is_load ) st-&gt;print(&quot;%s   %s,[ESP + #%d]&quot;,op_str,Matcher::regName[reg],offset);
  750       else          st-&gt;print(&quot;%s   [ESP + #%d],%s&quot;,op_str,offset,Matcher::regName[reg]);
  751     } else { // FLD, FST, PUSH, POP
  752       st-&gt;print(&quot;%s [ESP + #%d]&quot;,op_str,offset);
  753     }
  754 #endif
  755   }
  756   int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  757   return size+3+offset_size;
  758 }
  759 
  760 // Helper for XMM registers.  Extra opcode bits, limited syntax.
  761 static int impl_x_helper( CodeBuffer *cbuf, bool do_size, bool is_load,
  762                          int offset, int reg_lo, int reg_hi, int size, outputStream* st ) {
  763   int in_size_in_bits = Assembler::EVEX_32bit;
  764   int evex_encoding = 0;
  765   if (reg_lo+1 == reg_hi) {
  766     in_size_in_bits = Assembler::EVEX_64bit;
  767     evex_encoding = Assembler::VEX_W;
  768   }
  769   if (cbuf) {
  770     MacroAssembler _masm(cbuf);
  771     // EVEX spills remain EVEX: Compressed displacemement is better than AVX on spill mem operations,
  772     //                          it maps more cases to single byte displacement
  773     _masm.set_managed();
  774     if (reg_lo+1 == reg_hi) { // double move?
  775       if (is_load) {
  776         __ movdbl(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  777       } else {
  778         __ movdbl(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  779       }
  780     } else {
  781       if (is_load) {
  782         __ movflt(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  783       } else {
  784         __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  785       }
  786     }
  787 #ifndef PRODUCT
  788   } else if (!do_size) {
  789     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  790     if (reg_lo+1 == reg_hi) { // double move?
  791       if (is_load) st-&gt;print(&quot;%s %s,[ESP + #%d]&quot;,
  792                               UseXmmLoadAndClearUpper ? &quot;MOVSD &quot; : &quot;MOVLPD&quot;,
  793                               Matcher::regName[reg_lo], offset);
  794       else         st-&gt;print(&quot;MOVSD  [ESP + #%d],%s&quot;,
  795                               offset, Matcher::regName[reg_lo]);
  796     } else {
  797       if (is_load) st-&gt;print(&quot;MOVSS  %s,[ESP + #%d]&quot;,
  798                               Matcher::regName[reg_lo], offset);
  799       else         st-&gt;print(&quot;MOVSS  [ESP + #%d],%s&quot;,
  800                               offset, Matcher::regName[reg_lo]);
  801     }
  802 #endif
  803   }
  804   bool is_single_byte = false;
  805   if ((UseAVX &gt; 2) &amp;&amp; (offset != 0)) {
  806     is_single_byte = Assembler::query_compressed_disp_byte(offset, true, 0, Assembler::EVEX_T1S, in_size_in_bits, evex_encoding);
  807   }
  808   int offset_size = 0;
  809   if (UseAVX &gt; 2 ) {
  810     offset_size = (offset == 0) ? 0 : ((is_single_byte) ? 1 : 4);
  811   } else {
  812     offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  813   }
  814   size += (UseAVX &gt; 2) ? 2 : 0; // Need an additional two bytes for EVEX
  815   // VEX_2bytes prefix is used if UseAVX &gt; 0, so it takes the same 2 bytes as SIMD prefix.
  816   return size+5+offset_size;
  817 }
  818 
  819 
  820 static int impl_movx_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  821                             int src_hi, int dst_hi, int size, outputStream* st ) {
  822   if (cbuf) {
  823     MacroAssembler _masm(cbuf);
  824     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  825     _masm.set_managed();
  826     if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  827       __ movdbl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  828                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  829     } else {
  830       __ movflt(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  831                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  832     }
  833 #ifndef PRODUCT
  834   } else if (!do_size) {
  835     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  836     if (UseXmmRegToRegMoveAll) {//Use movaps,movapd to move between xmm registers
  837       if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  838         st-&gt;print(&quot;MOVAPD %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  839       } else {
  840         st-&gt;print(&quot;MOVAPS %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  841       }
  842     } else {
  843       if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double move?
  844         st-&gt;print(&quot;MOVSD  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  845       } else {
  846         st-&gt;print(&quot;MOVSS  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  847       }
  848     }
  849 #endif
  850   }
  851   // VEX_2bytes prefix is used if UseAVX &gt; 0, and it takes the same 2 bytes as SIMD prefix.
  852   // Only MOVAPS SSE prefix uses 1 byte.  EVEX uses an additional 2 bytes.
  853   int sz = (UseAVX &gt; 2) ? 6 : 4;
  854   if (!(src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) &amp;&amp;
  855       UseXmmRegToRegMoveAll &amp;&amp; (UseAVX == 0)) sz = 3;
  856   return size + sz;
  857 }
  858 
  859 static int impl_movgpr2x_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  860                             int src_hi, int dst_hi, int size, outputStream* st ) {
  861   // 32-bit
  862   if (cbuf) {
  863     MacroAssembler _masm(cbuf);
  864     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  865     _masm.set_managed();
  866     __ movdl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  867              as_Register(Matcher::_regEncode[src_lo]));
  868 #ifndef PRODUCT
  869   } else if (!do_size) {
  870     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  871 #endif
  872   }
  873   return (UseAVX&gt; 2) ? 6 : 4;
  874 }
  875 
  876 
  877 static int impl_movx2gpr_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  878                                  int src_hi, int dst_hi, int size, outputStream* st ) {
  879   // 32-bit
  880   if (cbuf) {
  881     MacroAssembler _masm(cbuf);
  882     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  883     _masm.set_managed();
  884     __ movdl(as_Register(Matcher::_regEncode[dst_lo]),
  885              as_XMMRegister(Matcher::_regEncode[src_lo]));
  886 #ifndef PRODUCT
  887   } else if (!do_size) {
  888     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  889 #endif
  890   }
  891   return (UseAVX&gt; 2) ? 6 : 4;
  892 }
  893 
  894 static int impl_mov_helper( CodeBuffer *cbuf, bool do_size, int src, int dst, int size, outputStream* st ) {
  895   if( cbuf ) {
  896     emit_opcode(*cbuf, 0x8B );
  897     emit_rm    (*cbuf, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );
  898 #ifndef PRODUCT
  899   } else if( !do_size ) {
  900     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  901     st-&gt;print(&quot;MOV    %s,%s&quot;,Matcher::regName[dst],Matcher::regName[src]);
  902 #endif
  903   }
  904   return size+2;
  905 }
  906 
  907 static int impl_fp_store_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,
  908                                  int offset, int size, outputStream* st ) {
  909   if( src_lo != FPR1L_num ) {      // Move value to top of FP stack, if not already there
  910     if( cbuf ) {
  911       emit_opcode( *cbuf, 0xD9 );  // FLD (i.e., push it)
  912       emit_d8( *cbuf, 0xC0-1+Matcher::_regEncode[src_lo] );
  913 #ifndef PRODUCT
  914     } else if( !do_size ) {
  915       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  916       st-&gt;print(&quot;FLD    %s&quot;,Matcher::regName[src_lo]);
  917 #endif
  918     }
  919     size += 2;
  920   }
  921 
  922   int st_op = (src_lo != FPR1L_num) ? EBX_num /*store &amp; pop*/ : EDX_num /*store no pop*/;
  923   const char *op_str;
  924   int op;
  925   if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double store?
  926     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_D&quot; : &quot;FST_D &quot;;
  927     op = 0xDD;
  928   } else {                   // 32-bit store
  929     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_S&quot; : &quot;FST_S &quot;;
  930     op = 0xD9;
  931     assert( !OptoReg::is_valid(src_hi) &amp;&amp; !OptoReg::is_valid(dst_hi), &quot;no non-adjacent float-stores&quot; );
  932   }
  933 
  934   return impl_helper(cbuf,do_size,false,offset,st_op,op,op_str,size, st);
  935 }
  936 
  937 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
  938 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  939                           int src_hi, int dst_hi, uint ireg, outputStream* st);
  940 
  941 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
  942                             int stack_offset, int reg, uint ireg, outputStream* st);
  943 
  944 static int vec_stack_to_stack_helper(CodeBuffer *cbuf, bool do_size, int src_offset,
  945                                      int dst_offset, uint ireg, outputStream* st) {
  946   int calc_size = 0;
  947   int src_offset_size = (src_offset == 0) ? 0 : ((src_offset &lt; 0x80) ? 1 : 4);
  948   int dst_offset_size = (dst_offset == 0) ? 0 : ((dst_offset &lt; 0x80) ? 1 : 4);
  949   switch (ireg) {
  950   case Op_VecS:
  951     calc_size = 3+src_offset_size + 3+dst_offset_size;
  952     break;
  953   case Op_VecD: {
  954     calc_size = 3+src_offset_size + 3+dst_offset_size;
  955     int tmp_src_offset = src_offset + 4;
  956     int tmp_dst_offset = dst_offset + 4;
  957     src_offset_size = (tmp_src_offset == 0) ? 0 : ((tmp_src_offset &lt; 0x80) ? 1 : 4);
  958     dst_offset_size = (tmp_dst_offset == 0) ? 0 : ((tmp_dst_offset &lt; 0x80) ? 1 : 4);
  959     calc_size += 3+src_offset_size + 3+dst_offset_size;
  960     break;
  961   }
  962   case Op_VecX:
  963   case Op_VecY:
  964   case Op_VecZ:
  965     calc_size = 6 + 6 + 5+src_offset_size + 5+dst_offset_size;
  966     break;
  967   default:
  968     ShouldNotReachHere();
  969   }
  970   if (cbuf) {
  971     MacroAssembler _masm(cbuf);
  972     int offset = __ offset();
  973     switch (ireg) {
  974     case Op_VecS:
  975       __ pushl(Address(rsp, src_offset));
  976       __ popl (Address(rsp, dst_offset));
  977       break;
  978     case Op_VecD:
  979       __ pushl(Address(rsp, src_offset));
  980       __ popl (Address(rsp, dst_offset));
  981       __ pushl(Address(rsp, src_offset+4));
  982       __ popl (Address(rsp, dst_offset+4));
  983       break;
  984     case Op_VecX:
  985       __ movdqu(Address(rsp, -16), xmm0);
  986       __ movdqu(xmm0, Address(rsp, src_offset));
  987       __ movdqu(Address(rsp, dst_offset), xmm0);
  988       __ movdqu(xmm0, Address(rsp, -16));
  989       break;
  990     case Op_VecY:
  991       __ vmovdqu(Address(rsp, -32), xmm0);
  992       __ vmovdqu(xmm0, Address(rsp, src_offset));
  993       __ vmovdqu(Address(rsp, dst_offset), xmm0);
  994       __ vmovdqu(xmm0, Address(rsp, -32));
  995       break;
  996     case Op_VecZ:
  997       __ evmovdquq(Address(rsp, -64), xmm0, 2);
  998       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
  999       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1000       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1001       break;
 1002     default:
 1003       ShouldNotReachHere();
 1004     }
 1005     int size = __ offset() - offset;
 1006     assert(size == calc_size, &quot;incorrect size calculation&quot;);
 1007     return size;
 1008 #ifndef PRODUCT
 1009   } else if (!do_size) {
 1010     switch (ireg) {
 1011     case Op_VecS:
 1012       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 32-bit mem-mem spill\n\t&quot;
 1013                 &quot;popl    [rsp + #%d]&quot;,
 1014                 src_offset, dst_offset);
 1015       break;
 1016     case Op_VecD:
 1017       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1018                 &quot;popq    [rsp + #%d]\n\t&quot;
 1019                 &quot;pushl   [rsp + #%d]\n\t&quot;
 1020                 &quot;popq    [rsp + #%d]&quot;,
 1021                 src_offset, dst_offset, src_offset+4, dst_offset+4);
 1022       break;
 1023      case Op_VecX:
 1024       st-&gt;print(&quot;movdqu  [rsp - #16], xmm0\t# 128-bit mem-mem spill\n\t&quot;
 1025                 &quot;movdqu  xmm0, [rsp + #%d]\n\t&quot;
 1026                 &quot;movdqu  [rsp + #%d], xmm0\n\t&quot;
 1027                 &quot;movdqu  xmm0, [rsp - #16]&quot;,
 1028                 src_offset, dst_offset);
 1029       break;
 1030     case Op_VecY:
 1031       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1032                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1033                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1034                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1035                 src_offset, dst_offset);
 1036       break;
 1037     case Op_VecZ:
 1038       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1039                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1040                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1041                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1042                 src_offset, dst_offset);
 1043       break;
 1044     default:
 1045       ShouldNotReachHere();
 1046     }
 1047 #endif
 1048   }
 1049   return calc_size;
 1050 }
 1051 
 1052 uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {
 1053   // Get registers to move
 1054   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1055   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1056   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this );
 1057   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this );
 1058 
 1059   enum RC src_second_rc = rc_class(src_second);
 1060   enum RC src_first_rc = rc_class(src_first);
 1061   enum RC dst_second_rc = rc_class(dst_second);
 1062   enum RC dst_first_rc = rc_class(dst_first);
 1063 
 1064   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
 1065 
 1066   // Generate spill code!
 1067   int size = 0;
 1068 
 1069   if( src_first == dst_first &amp;&amp; src_second == dst_second )
 1070     return size;            // Self copy, no move
 1071 
 1072   if (bottom_type()-&gt;isa_vect() != NULL) {
 1073     uint ireg = ideal_reg();
 1074     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1075     assert((src_first_rc != rc_float &amp;&amp; dst_first_rc != rc_float), &quot;sanity&quot;);
 1076     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1077     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1078       // mem -&gt; mem
 1079       int src_offset = ra_-&gt;reg2offset(src_first);
 1080       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1081       return vec_stack_to_stack_helper(cbuf, do_size, src_offset, dst_offset, ireg, st);
 1082     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1083       return vec_mov_helper(cbuf, do_size, src_first, dst_first, src_second, dst_second, ireg, st);
 1084     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1085       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1086       return vec_spill_helper(cbuf, do_size, false, stack_offset, src_first, ireg, st);
 1087     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_xmm ) {
 1088       int stack_offset = ra_-&gt;reg2offset(src_first);
 1089       return vec_spill_helper(cbuf, do_size, true,  stack_offset, dst_first, ireg, st);
 1090     } else {
 1091       ShouldNotReachHere();
 1092     }
 1093   }
 1094 
 1095   // --------------------------------------
 1096   // Check for mem-mem move.  push/pop to move.
 1097   if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1098     if( src_second == dst_first ) { // overlapping stack copy ranges
 1099       assert( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack, &quot;we only expect a stk-stk copy here&quot; );
 1100       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1101       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1102       src_second_rc = dst_second_rc = rc_bad;  // flag as already moved the second bits
 1103     }
 1104     // move low bits
 1105     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1106     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1107     if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) { // mov second bits
 1108       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1109       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1110     }
 1111     return size;
 1112   }
 1113 
 1114   // --------------------------------------
 1115   // Check for integer reg-reg copy
 1116   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int )
 1117     size = impl_mov_helper(cbuf,do_size,src_first,dst_first,size, st);
 1118 
 1119   // Check for integer store
 1120   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack )
 1121     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first,0x89,&quot;MOV &quot;,size, st);
 1122 
 1123   // Check for integer load
 1124   if( dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack )
 1125     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first,0x8B,&quot;MOV &quot;,size, st);
 1126 
 1127   // Check for integer reg-xmm reg copy
 1128   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_xmm ) {
 1129     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1130             &quot;no 64 bit integer-float reg moves&quot; );
 1131     return impl_movgpr2x_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1132   }
 1133   // --------------------------------------
 1134   // Check for float reg-reg copy
 1135   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1136     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1137             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second), &quot;no non-adjacent float-moves&quot; );
 1138     if( cbuf ) {
 1139 
 1140       // Note the mucking with the register encode to compensate for the 0/1
 1141       // indexing issue mentioned in a comment in the reg_def sections
 1142       // for FPR registers many lines above here.
 1143 
 1144       if( src_first != FPR1L_num ) {
 1145         emit_opcode  (*cbuf, 0xD9 );           // FLD    ST(i)
 1146         emit_d8      (*cbuf, 0xC0+Matcher::_regEncode[src_first]-1 );
 1147         emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1148         emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1149      } else {
 1150         emit_opcode  (*cbuf, 0xDD );           // FST    ST(i)
 1151         emit_d8      (*cbuf, 0xD0+Matcher::_regEncode[dst_first]-1 );
 1152      }
 1153 #ifndef PRODUCT
 1154     } else if( !do_size ) {
 1155       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1156       if( src_first != FPR1L_num ) st-&gt;print(&quot;FLD    %s\n\tFSTP   %s&quot;,Matcher::regName[src_first],Matcher::regName[dst_first]);
 1157       else                      st-&gt;print(             &quot;FST    %s&quot;,                            Matcher::regName[dst_first]);
 1158 #endif
 1159     }
 1160     return size + ((src_first != FPR1L_num) ? 2+2 : 2);
 1161   }
 1162 
 1163   // Check for float store
 1164   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1165     return impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,ra_-&gt;reg2offset(dst_first),size, st);
 1166   }
 1167 
 1168   // Check for float load
 1169   if( dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack ) {
 1170     int offset = ra_-&gt;reg2offset(src_first);
 1171     const char *op_str;
 1172     int op;
 1173     if( src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second ) { // double load?
 1174       op_str = &quot;FLD_D&quot;;
 1175       op = 0xDD;
 1176     } else {                   // 32-bit load
 1177       op_str = &quot;FLD_S&quot;;
 1178       op = 0xD9;
 1179       assert( src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad, &quot;no non-adjacent float-loads&quot; );
 1180     }
 1181     if( cbuf ) {
 1182       emit_opcode  (*cbuf, op );
 1183       encode_RegMem(*cbuf, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);
 1184       emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1185       emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1186 #ifndef PRODUCT
 1187     } else if( !do_size ) {
 1188       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1189       st-&gt;print(&quot;%s  ST,[ESP + #%d]\n\tFSTP   %s&quot;,op_str, offset,Matcher::regName[dst_first]);
 1190 #endif
 1191     }
 1192     int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
 1193     return size + 3+offset_size+2;
 1194   }
 1195 
 1196   // Check for xmm reg-reg copy
 1197   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1198     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1199             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second),
 1200             &quot;no non-adjacent float-moves&quot; );
 1201     return impl_movx_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1202   }
 1203 
 1204   // Check for xmm reg-integer reg copy
 1205   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_int ) {
 1206     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1207             &quot;no 64 bit float-integer reg moves&quot; );
 1208     return impl_movx2gpr_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1209   }
 1210 
 1211   // Check for xmm store
 1212   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1213     return impl_x_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first, src_second, size, st);
 1214   }
 1215 
 1216   // Check for float xmm load
 1217   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_stack ) {
 1218     return impl_x_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first, dst_second, size, st);
 1219   }
 1220 
 1221   // Copy from float reg to xmm reg
 1222   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_float ) {
 1223     // copy to the top of stack from floating point reg
 1224     // and use LEA to preserve flags
 1225     if( cbuf ) {
 1226       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP-8]
 1227       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1228       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1229       emit_d8(*cbuf,0xF8);
 1230 #ifndef PRODUCT
 1231     } else if( !do_size ) {
 1232       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1233       st-&gt;print(&quot;LEA    ESP,[ESP-8]&quot;);
 1234 #endif
 1235     }
 1236     size += 4;
 1237 
 1238     size = impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,0,size, st);
 1239 
 1240     // Copy from the temp memory to the xmm reg.
 1241     size = impl_x_helper(cbuf,do_size,true ,0,dst_first, dst_second, size, st);
 1242 
 1243     if( cbuf ) {
 1244       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP+8]
 1245       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1246       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1247       emit_d8(*cbuf,0x08);
 1248 #ifndef PRODUCT
 1249     } else if( !do_size ) {
 1250       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1251       st-&gt;print(&quot;LEA    ESP,[ESP+8]&quot;);
 1252 #endif
 1253     }
 1254     size += 4;
 1255     return size;
 1256   }
 1257 
 1258   assert( size &gt; 0, &quot;missed a case&quot; );
 1259 
 1260   // --------------------------------------------------------------------
 1261   // Check for second bits still needing moving.
 1262   if( src_second == dst_second )
 1263     return size;               // Self copy; no move
 1264   assert( src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot; );
 1265 
 1266   // Check for second word int-int move
 1267   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_int )
 1268     return impl_mov_helper(cbuf,do_size,src_second,dst_second,size, st);
 1269 
 1270   // Check for second word integer store
 1271   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_stack )
 1272     return impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),src_second,0x89,&quot;MOV &quot;,size, st);
 1273 
 1274   // Check for second word integer load
 1275   if( dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack )
 1276     return impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),dst_second,0x8B,&quot;MOV &quot;,size, st);
 1277 
 1278 
 1279   Unimplemented();
 1280   return 0; // Mute compiler
 1281 }
 1282 
 1283 #ifndef PRODUCT
 1284 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1285   implementation( NULL, ra_, false, st );
 1286 }
 1287 #endif
 1288 
 1289 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1290   implementation( &amp;cbuf, ra_, false, NULL );
 1291 }
 1292 
 1293 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1294   return MachNode::size(ra_);
 1295 }
 1296 
 1297 
 1298 //=============================================================================
 1299 #ifndef PRODUCT
 1300 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1301   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1302   int reg = ra_-&gt;get_reg_first(this);
 1303   st-&gt;print(&quot;LEA    %s,[ESP + #%d]&quot;,Matcher::regName[reg],offset);
 1304 }
 1305 #endif
 1306 
 1307 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1308   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1309   int reg = ra_-&gt;get_encode(this);
 1310   if( offset &gt;= 128 ) {
 1311     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1312     emit_rm(cbuf, 0x2, reg, 0x04);
 1313     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1314     emit_d32(cbuf, offset);
 1315   }
 1316   else {
 1317     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1318     emit_rm(cbuf, 0x1, reg, 0x04);
 1319     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1320     emit_d8(cbuf, offset);
 1321   }
 1322 }
 1323 
 1324 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1325   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1326   if( offset &gt;= 128 ) {
 1327     return 7;
 1328   }
 1329   else {
 1330     return 4;
 1331   }
 1332 }
 1333 
 1334 //=============================================================================
 1335 #ifndef PRODUCT
 1336 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1337   st-&gt;print_cr(  &quot;CMP    EAX,[ECX+4]\t# Inline cache check&quot;);
 1338   st-&gt;print_cr(&quot;\tJNE    SharedRuntime::handle_ic_miss_stub&quot;);
 1339   st-&gt;print_cr(&quot;\tNOP&quot;);
 1340   st-&gt;print_cr(&quot;\tNOP&quot;);
 1341   if( !OptoBreakpoint )
 1342     st-&gt;print_cr(&quot;\tNOP&quot;);
 1343 }
 1344 #endif
 1345 
 1346 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1347   MacroAssembler masm(&amp;cbuf);
 1348 #ifdef ASSERT
 1349   uint insts_size = cbuf.insts_size();
 1350 #endif
 1351   masm.cmpptr(rax, Address(rcx, oopDesc::klass_offset_in_bytes()));
 1352   masm.jump_cc(Assembler::notEqual,
 1353                RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1354   /* WARNING these NOPs are critical so that verified entry point is properly
 1355      aligned for patching by NativeJump::patch_verified_entry() */
 1356   int nops_cnt = 2;
 1357   if( !OptoBreakpoint ) // Leave space for int3
 1358      nops_cnt += 1;
 1359   masm.nop(nops_cnt);
 1360 
 1361   assert(cbuf.insts_size() - insts_size == size(ra_), &quot;checking code size of inline cache node&quot;);
 1362 }
 1363 
 1364 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1365   return OptoBreakpoint ? 11 : 12;
 1366 }
 1367 
 1368 
 1369 //=============================================================================
 1370 
 1371 int Matcher::regnum_to_fpu_offset(int regnum) {
 1372   return regnum - 32; // The FP registers are in the second chunk
 1373 }
 1374 
 1375 // This is UltraSparc specific, true just means we have fast l2f conversion
 1376 const bool Matcher::convL2FSupported(void) {
 1377   return true;
 1378 }
 1379 
 1380 // Is this branch offset short enough that a short branch can be used?
 1381 //
 1382 // NOTE: If the platform does not provide any short branch variants, then
 1383 //       this method should return false for offset 0.
 1384 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1385   // The passed offset is relative to address of the branch.
 1386   // On 86 a branch displacement is calculated relative to address
 1387   // of a next instruction.
 1388   offset -= br_size;
 1389 
 1390   // the short version of jmpConUCF2 contains multiple branches,
 1391   // making the reach slightly less
 1392   if (rule == jmpConUCF2_rule)
 1393     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1394   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1395 }
 1396 
 1397 const bool Matcher::isSimpleConstant64(jlong value) {
 1398   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1399   return false;
 1400 }
 1401 
 1402 // The ecx parameter to rep stos for the ClearArray node is in dwords.
 1403 const bool Matcher::init_array_count_is_in_bytes = false;
 1404 
 1405 // Needs 2 CMOV&#39;s for longs.
 1406 const int Matcher::long_cmove_cost() { return 1; }
 1407 
 1408 // No CMOVF/CMOVD with SSE/SSE2
 1409 const int Matcher::float_cmove_cost() { return (UseSSE&gt;=1) ? ConditionalMoveLimit : 0; }
 1410 
 1411 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1412 const bool Matcher::require_postalloc_expand = false;
 1413 
 1414 // Do we need to mask the count passed to shift instructions or does
 1415 // the cpu only look at the lower 5/6 bits anyway?
 1416 const bool Matcher::need_masked_shift_count = false;
 1417 
 1418 bool Matcher::narrow_oop_use_complex_address() {
 1419   ShouldNotCallThis();
 1420   return true;
 1421 }
 1422 
 1423 bool Matcher::narrow_klass_use_complex_address() {
 1424   ShouldNotCallThis();
 1425   return true;
 1426 }
 1427 
 1428 bool Matcher::const_oop_prefer_decode() {
 1429   ShouldNotCallThis();
 1430   return true;
 1431 }
 1432 
 1433 bool Matcher::const_klass_prefer_decode() {
 1434   ShouldNotCallThis();
 1435   return true;
 1436 }
 1437 
 1438 // Is it better to copy float constants, or load them directly from memory?
 1439 // Intel can load a float constant from a direct address, requiring no
 1440 // extra registers.  Most RISCs will have to materialize an address into a
 1441 // register first, so they would do better to copy the constant from stack.
 1442 const bool Matcher::rematerialize_float_constants = true;
 1443 
 1444 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1445 // needed.  Else we split the double into 2 integer pieces and move it
 1446 // piece-by-piece.  Only happens when passing doubles into C code as the
 1447 // Java calling convention forces doubles to be aligned.
 1448 const bool Matcher::misaligned_doubles_ok = true;
 1449 
 1450 
 1451 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1452   // Get the memory operand from the node
 1453   uint numopnds = node-&gt;num_opnds();        // Virtual call for number of operands
 1454   uint skipped  = node-&gt;oper_input_base();  // Sum of leaves skipped so far
 1455   assert( idx &gt;= skipped, &quot;idx too low in pd_implicit_null_fixup&quot; );
 1456   uint opcnt     = 1;                 // First operand
 1457   uint num_edges = node-&gt;_opnds[1]-&gt;num_edges(); // leaves for first operand
 1458   while( idx &gt;= skipped+num_edges ) {
 1459     skipped += num_edges;
 1460     opcnt++;                          // Bump operand count
 1461     assert( opcnt &lt; numopnds, &quot;Accessing non-existent operand&quot; );
 1462     num_edges = node-&gt;_opnds[opcnt]-&gt;num_edges(); // leaves for next operand
 1463   }
 1464 
 1465   MachOper *memory = node-&gt;_opnds[opcnt];
 1466   MachOper *new_memory = NULL;
 1467   switch (memory-&gt;opcode()) {
 1468   case DIRECT:
 1469   case INDOFFSET32X:
 1470     // No transformation necessary.
 1471     return;
 1472   case INDIRECT:
 1473     new_memory = new indirect_win95_safeOper( );
 1474     break;
 1475   case INDOFFSET8:
 1476     new_memory = new indOffset8_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1477     break;
 1478   case INDOFFSET32:
 1479     new_memory = new indOffset32_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1480     break;
 1481   case INDINDEXOFFSET:
 1482     new_memory = new indIndexOffset_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1483     break;
 1484   case INDINDEXSCALE:
 1485     new_memory = new indIndexScale_win95_safeOper(memory-&gt;scale());
 1486     break;
 1487   case INDINDEXSCALEOFFSET:
 1488     new_memory = new indIndexScaleOffset_win95_safeOper(memory-&gt;scale(), memory-&gt;disp(NULL, NULL, 0));
 1489     break;
 1490   case LOAD_LONG_INDIRECT:
 1491   case LOAD_LONG_INDOFFSET32:
 1492     // Does not use EBP as address register, use { EDX, EBX, EDI, ESI}
 1493     return;
 1494   default:
 1495     assert(false, &quot;unexpected memory operand in pd_implicit_null_fixup()&quot;);
 1496     return;
 1497   }
 1498   node-&gt;_opnds[opcnt] = new_memory;
 1499 }
 1500 
 1501 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1502 const bool Matcher::strict_fp_requires_explicit_rounding = true;
 1503 
 1504 // Are floats conerted to double when stored to stack during deoptimization?
 1505 // On x32 it is stored with convertion only when FPU is used for floats.
 1506 bool Matcher::float_in_double() { return (UseSSE == 0); }
 1507 
 1508 // Do ints take an entire long register or just half?
 1509 const bool Matcher::int_in_long = false;
 1510 
 1511 // Return whether or not this register is ever used as an argument.  This
 1512 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1513 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1514 // arguments in those registers not be available to the callee.
 1515 bool Matcher::can_be_java_arg( int reg ) {
 1516   if(  reg == ECX_num   || reg == EDX_num   ) return true;
 1517   if( (reg == XMM0_num  || reg == XMM1_num ) &amp;&amp; UseSSE&gt;=1 ) return true;
 1518   if( (reg == XMM0b_num || reg == XMM1b_num) &amp;&amp; UseSSE&gt;=2 ) return true;
 1519   return false;
 1520 }
 1521 
 1522 bool Matcher::is_spillable_arg( int reg ) {
 1523   return can_be_java_arg(reg);
 1524 }
 1525 
 1526 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1527   // Use hardware integer DIV instruction when
 1528   // it is faster than a code which use multiply.
 1529   // Only when constant divisor fits into 32 bit
 1530   // (min_jint is excluded to get only correct
 1531   // positive 32 bit values from negative).
 1532   return VM_Version::has_fast_idiv() &amp;&amp;
 1533          (divisor == (int)divisor &amp;&amp; divisor != min_jint);
 1534 }
 1535 
 1536 // Register for DIVI projection of divmodI
 1537 RegMask Matcher::divI_proj_mask() {
 1538   return EAX_REG_mask();
 1539 }
 1540 
 1541 // Register for MODI projection of divmodI
 1542 RegMask Matcher::modI_proj_mask() {
 1543   return EDX_REG_mask();
 1544 }
 1545 
 1546 // Register for DIVL projection of divmodL
 1547 RegMask Matcher::divL_proj_mask() {
 1548   ShouldNotReachHere();
 1549   return RegMask();
 1550 }
 1551 
 1552 // Register for MODL projection of divmodL
 1553 RegMask Matcher::modL_proj_mask() {
 1554   ShouldNotReachHere();
 1555   return RegMask();
 1556 }
 1557 
 1558 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1559   return NO_REG_mask();
 1560 }
 1561 
 1562 // Returns true if the high 32 bits of the value is known to be zero.
 1563 bool is_operand_hi32_zero(Node* n) {
 1564   int opc = n-&gt;Opcode();
 1565   if (opc == Op_AndL) {
 1566     Node* o2 = n-&gt;in(2);
 1567     if (o2-&gt;is_Con() &amp;&amp; (o2-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1568       return true;
 1569     }
 1570   }
 1571   if (opc == Op_ConL &amp;&amp; (n-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1572     return true;
 1573   }
 1574   return false;
 1575 }
 1576 
 1577 %}
 1578 
 1579 //----------ENCODING BLOCK-----------------------------------------------------
 1580 // This block specifies the encoding classes used by the compiler to output
 1581 // byte streams.  Encoding classes generate functions which are called by
 1582 // Machine Instruction Nodes in order to generate the bit encoding of the
 1583 // instruction.  Operands specify their base encoding interface with the
 1584 // interface keyword.  There are currently supported four interfaces,
 1585 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1586 // operand to generate a function which returns its register number when
 1587 // queried.   CONST_INTER causes an operand to generate a function which
 1588 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1589 // operand to generate four functions which return the Base Register, the
 1590 // Index Register, the Scale Value, and the Offset Value of the operand when
 1591 // queried.  COND_INTER causes an operand to generate six functions which
 1592 // return the encoding code (ie - encoding bits for the instruction)
 1593 // associated with each basic boolean condition for a conditional instruction.
 1594 // Instructions specify two basic values for encoding.  They use the
 1595 // ins_encode keyword to specify their encoding class (which must be one of
 1596 // the class names specified in the encoding block), and they use the
 1597 // opcode keyword to specify, in order, their primary, secondary, and
 1598 // tertiary opcode.  Only the opcode sections which a particular instruction
 1599 // needs for encoding need to be specified.
 1600 encode %{
 1601   // Build emit functions for each basic byte or larger field in the intel
 1602   // encoding scheme (opcode, rm, sib, immediate), and call them from C++
 1603   // code in the enc_class source block.  Emit functions will live in the
 1604   // main source block for now.  In future, we can generalize this by
 1605   // adding a syntax that specifies the sizes of fields in an order,
 1606   // so that the adlc can build the emit functions automagically
 1607 
 1608   // Emit primary opcode
 1609   enc_class OpcP %{
 1610     emit_opcode(cbuf, $primary);
 1611   %}
 1612 
 1613   // Emit secondary opcode
 1614   enc_class OpcS %{
 1615     emit_opcode(cbuf, $secondary);
 1616   %}
 1617 
 1618   // Emit opcode directly
 1619   enc_class Opcode(immI d8) %{
 1620     emit_opcode(cbuf, $d8$$constant);
 1621   %}
 1622 
 1623   enc_class SizePrefix %{
 1624     emit_opcode(cbuf,0x66);
 1625   %}
 1626 
 1627   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 1628     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1629   %}
 1630 
 1631   enc_class OpcRegReg (immI opcode, rRegI dst, rRegI src) %{    // OpcRegReg(Many)
 1632     emit_opcode(cbuf,$opcode$$constant);
 1633     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1634   %}
 1635 
 1636   enc_class mov_r32_imm0( rRegI dst ) %{
 1637     emit_opcode( cbuf, 0xB8 + $dst$$reg ); // 0xB8+ rd   -- MOV r32  ,imm32
 1638     emit_d32   ( cbuf, 0x0  );             //                         imm32==0x0
 1639   %}
 1640 
 1641   enc_class cdq_enc %{
 1642     // Full implementation of Java idiv and irem; checks for
 1643     // special case as described in JVM spec., p.243 &amp; p.271.
 1644     //
 1645     //         normal case                           special case
 1646     //
 1647     // input : rax,: dividend                         min_int
 1648     //         reg: divisor                          -1
 1649     //
 1650     // output: rax,: quotient  (= rax, idiv reg)       min_int
 1651     //         rdx: remainder (= rax, irem reg)       0
 1652     //
 1653     //  Code sequnce:
 1654     //
 1655     //  81 F8 00 00 00 80    cmp         rax,80000000h
 1656     //  0F 85 0B 00 00 00    jne         normal_case
 1657     //  33 D2                xor         rdx,edx
 1658     //  83 F9 FF             cmp         rcx,0FFh
 1659     //  0F 84 03 00 00 00    je          done
 1660     //                  normal_case:
 1661     //  99                   cdq
 1662     //  F7 F9                idiv        rax,ecx
 1663     //                  done:
 1664     //
 1665     emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);
 1666     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);
 1667     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     // cmp rax,80000000h
 1668     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);
 1669     emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);
 1670     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // jne normal_case
 1671     emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     // xor rdx,edx
 1672     emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); // cmp rcx,0FFh
 1673     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);
 1674     emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);
 1675     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // je done
 1676     // normal_case:
 1677     emit_opcode(cbuf,0x99);                                         // cdq
 1678     // idiv (note: must be emitted by the user of this rule)
 1679     // normal:
 1680   %}
 1681 
 1682   // Dense encoding for older common ops
 1683   enc_class Opc_plus(immI opcode, rRegI reg) %{
 1684     emit_opcode(cbuf, $opcode$$constant + $reg$$reg);
 1685   %}
 1686 
 1687 
 1688   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1689   enc_class OpcSE (immI imm) %{ // Emit primary opcode and set sign-extend bit
 1690     // Check for 8-bit immediate, and set sign extend bit in opcode
 1691     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1692       emit_opcode(cbuf, $primary | 0x02);
 1693     }
 1694     else {                          // If 32-bit immediate
 1695       emit_opcode(cbuf, $primary);
 1696     }
 1697   %}
 1698 
 1699   enc_class OpcSErm (rRegI dst, immI imm) %{    // OpcSEr/m
 1700     // Emit primary opcode and set sign-extend bit
 1701     // Check for 8-bit immediate, and set sign extend bit in opcode
 1702     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1703       emit_opcode(cbuf, $primary | 0x02);    }
 1704     else {                          // If 32-bit immediate
 1705       emit_opcode(cbuf, $primary);
 1706     }
 1707     // Emit r/m byte with secondary opcode, after primary opcode.
 1708     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1709   %}
 1710 
 1711   enc_class Con8or32 (immI imm) %{    // Con8or32(storeImmI), 8 or 32 bits
 1712     // Check for 8-bit immediate, and set sign extend bit in opcode
 1713     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1714       $$$emit8$imm$$constant;
 1715     }
 1716     else {                          // If 32-bit immediate
 1717       // Output immediate
 1718       $$$emit32$imm$$constant;
 1719     }
 1720   %}
 1721 
 1722   enc_class Long_OpcSErm_Lo(eRegL dst, immL imm) %{
 1723     // Emit primary opcode and set sign-extend bit
 1724     // Check for 8-bit immediate, and set sign extend bit in opcode
 1725     int con = (int)$imm$$constant; // Throw away top bits
 1726     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1727     // Emit r/m byte with secondary opcode, after primary opcode.
 1728     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1729     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1730     else                               emit_d32(cbuf,con);
 1731   %}
 1732 
 1733   enc_class Long_OpcSErm_Hi(eRegL dst, immL imm) %{
 1734     // Emit primary opcode and set sign-extend bit
 1735     // Check for 8-bit immediate, and set sign extend bit in opcode
 1736     int con = (int)($imm$$constant &gt;&gt; 32); // Throw away bottom bits
 1737     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1738     // Emit r/m byte with tertiary opcode, after primary opcode.
 1739     emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));
 1740     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1741     else                               emit_d32(cbuf,con);
 1742   %}
 1743 
 1744   enc_class OpcSReg (rRegI dst) %{    // BSWAP
 1745     emit_cc(cbuf, $secondary, $dst$$reg );
 1746   %}
 1747 
 1748   enc_class bswap_long_bytes(eRegL dst) %{ // BSWAP
 1749     int destlo = $dst$$reg;
 1750     int desthi = HIGH_FROM_LOW(destlo);
 1751     // bswap lo
 1752     emit_opcode(cbuf, 0x0F);
 1753     emit_cc(cbuf, 0xC8, destlo);
 1754     // bswap hi
 1755     emit_opcode(cbuf, 0x0F);
 1756     emit_cc(cbuf, 0xC8, desthi);
 1757     // xchg lo and hi
 1758     emit_opcode(cbuf, 0x87);
 1759     emit_rm(cbuf, 0x3, destlo, desthi);
 1760   %}
 1761 
 1762   enc_class RegOpc (rRegI div) %{    // IDIV, IMOD, JMP indirect, ...
 1763     emit_rm(cbuf, 0x3, $secondary, $div$$reg );
 1764   %}
 1765 
 1766   enc_class enc_cmov(cmpOp cop ) %{ // CMOV
 1767     $$$emit8$primary;
 1768     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 1769   %}
 1770 
 1771   enc_class enc_cmov_dpr(cmpOp cop, regDPR src ) %{ // CMOV
 1772     int op = 0xDA00 + $cop$$cmpcode + ($src$$reg-1);
 1773     emit_d8(cbuf, op &gt;&gt; 8 );
 1774     emit_d8(cbuf, op &amp; 255);
 1775   %}
 1776 
 1777   // emulate a CMOV with a conditional branch around a MOV
 1778   enc_class enc_cmov_branch( cmpOp cop, immI brOffs ) %{ // CMOV
 1779     // Invert sense of branch from sense of CMOV
 1780     emit_cc( cbuf, 0x70, ($cop$$cmpcode^1) );
 1781     emit_d8( cbuf, $brOffs$$constant );
 1782   %}
 1783 
 1784   enc_class enc_PartialSubtypeCheck( ) %{
 1785     Register Redi = as_Register(EDI_enc); // result register
 1786     Register Reax = as_Register(EAX_enc); // super class
 1787     Register Recx = as_Register(ECX_enc); // killed
 1788     Register Resi = as_Register(ESI_enc); // sub class
 1789     Label miss;
 1790 
 1791     MacroAssembler _masm(&amp;cbuf);
 1792     __ check_klass_subtype_slow_path(Resi, Reax, Recx, Redi,
 1793                                      NULL, &amp;miss,
 1794                                      /*set_cond_codes:*/ true);
 1795     if ($primary) {
 1796       __ xorptr(Redi, Redi);
 1797     }
 1798     __ bind(miss);
 1799   %}
 1800 
 1801   enc_class FFree_Float_Stack_All %{    // Free_Float_Stack_All
 1802     MacroAssembler masm(&amp;cbuf);
 1803     int start = masm.offset();
 1804     if (UseSSE &gt;= 2) {
 1805       if (VerifyFPU) {
 1806         masm.verify_FPU(0, &quot;must be empty in SSE2+ mode&quot;);
 1807       }
 1808     } else {
 1809       // External c_calling_convention expects the FPU stack to be &#39;clean&#39;.
 1810       // Compiled code leaves it dirty.  Do cleanup now.
 1811       masm.empty_FPU_stack();
 1812     }
 1813     if (sizeof_FFree_Float_Stack_All == -1) {
 1814       sizeof_FFree_Float_Stack_All = masm.offset() - start;
 1815     } else {
 1816       assert(masm.offset() - start == sizeof_FFree_Float_Stack_All, &quot;wrong size&quot;);
 1817     }
 1818   %}
 1819 
 1820   enc_class Verify_FPU_For_Leaf %{
 1821     if( VerifyFPU ) {
 1822       MacroAssembler masm(&amp;cbuf);
 1823       masm.verify_FPU( -3, &quot;Returning from Runtime Leaf call&quot;);
 1824     }
 1825   %}
 1826 
 1827   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime, Java_To_Runtime_Leaf
 1828     // This is the instruction starting address for relocation info.
 1829     cbuf.set_insts_mark();
 1830     $$$emit8$primary;
 1831     // CALL directly to the runtime
 1832     emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1833                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1834 
 1835     if (UseSSE &gt;= 2) {
 1836       MacroAssembler _masm(&amp;cbuf);
 1837       BasicType rt = tf()-&gt;return_type();
 1838 
 1839       if ((rt == T_FLOAT || rt == T_DOUBLE) &amp;&amp; !return_value_is_used()) {
 1840         // A C runtime call where the return value is unused.  In SSE2+
 1841         // mode the result needs to be removed from the FPU stack.  It&#39;s
 1842         // likely that this function call could be removed by the
 1843         // optimizer if the C function is a pure function.
 1844         __ ffree(0);
 1845       } else if (rt == T_FLOAT) {
 1846         __ lea(rsp, Address(rsp, -4));
 1847         __ fstp_s(Address(rsp, 0));
 1848         __ movflt(xmm0, Address(rsp, 0));
 1849         __ lea(rsp, Address(rsp,  4));
 1850       } else if (rt == T_DOUBLE) {
 1851         __ lea(rsp, Address(rsp, -8));
 1852         __ fstp_d(Address(rsp, 0));
 1853         __ movdbl(xmm0, Address(rsp, 0));
 1854         __ lea(rsp, Address(rsp,  8));
 1855       }
 1856     }
 1857   %}
 1858 
 1859   enc_class pre_call_resets %{
 1860     // If method sets FPU control word restore it here
 1861     debug_only(int off0 = cbuf.insts_size());
 1862     if (ra_-&gt;C-&gt;in_24_bit_fp_mode()) {
 1863       MacroAssembler _masm(&amp;cbuf);
 1864       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
 1865     }
 1866     // Clear upper bits of YMM registers when current compiled code uses
 1867     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 1868     MacroAssembler _masm(&amp;cbuf);
 1869     __ vzeroupper();
 1870     debug_only(int off1 = cbuf.insts_size());
 1871     assert(off1 - off0 == pre_call_resets_size(), &quot;correct size prediction&quot;);
 1872   %}
 1873 
 1874   enc_class post_call_FPU %{
 1875     // If method sets FPU control word do it here also
 1876     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
 1877       MacroAssembler masm(&amp;cbuf);
 1878       masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 1879     }
 1880   %}
 1881 
 1882   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 1883     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1884     // who we intended to call.
 1885     cbuf.set_insts_mark();
 1886     $$$emit8$primary;
 1887 
 1888     if (!_method) {
 1889       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1890                      runtime_call_Relocation::spec(),
 1891                      RELOC_IMM32);
 1892     } else {
 1893       int method_index = resolved_method_index(cbuf);
 1894       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1895                                                   : static_call_Relocation::spec(method_index);
 1896       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1897                      rspec, RELOC_DISP32);
 1898       // Emit stubs for static call.
 1899       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1900       if (stub == NULL) {
 1901         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1902         return;
 1903       }
 1904     }
 1905   %}
 1906 
 1907   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 1908     MacroAssembler _masm(&amp;cbuf);
 1909     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 1910   %}
 1911 
 1912   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 1913     int disp = in_bytes(Method::from_compiled_offset());
 1914     assert( -128 &lt;= disp &amp;&amp; disp &lt;= 127, &quot;compiled_code_offset isn&#39;t small&quot;);
 1915 
 1916     // CALL *[EAX+in_bytes(Method::from_compiled_code_entry_point_offset())]
 1917     cbuf.set_insts_mark();
 1918     $$$emit8$primary;
 1919     emit_rm(cbuf, 0x01, $secondary, EAX_enc );  // R/M byte
 1920     emit_d8(cbuf, disp);             // Displacement
 1921 
 1922   %}
 1923 
 1924 //   Following encoding is no longer used, but may be restored if calling
 1925 //   convention changes significantly.
 1926 //   Became: Xor_Reg(EBP), Java_To_Runtime( labl )
 1927 //
 1928 //   enc_class Java_Interpreter_Call (label labl) %{    // JAVA INTERPRETER CALL
 1929 //     // int ic_reg     = Matcher::inline_cache_reg();
 1930 //     // int ic_encode  = Matcher::_regEncode[ic_reg];
 1931 //     // int imo_reg    = Matcher::interpreter_method_oop_reg();
 1932 //     // int imo_encode = Matcher::_regEncode[imo_reg];
 1933 //
 1934 //     // // Interpreter expects method_oop in EBX, currently a callee-saved register,
 1935 //     // // so we load it immediately before the call
 1936 //     // emit_opcode(cbuf, 0x8B);                     // MOV    imo_reg,ic_reg  # method_oop
 1937 //     // emit_rm(cbuf, 0x03, imo_encode, ic_encode ); // R/M byte
 1938 //
 1939 //     // xor rbp,ebp
 1940 //     emit_opcode(cbuf, 0x33);
 1941 //     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);
 1942 //
 1943 //     // CALL to interpreter.
 1944 //     cbuf.set_insts_mark();
 1945 //     $$$emit8$primary;
 1946 //     emit_d32_reloc(cbuf, ($labl$$label - (int)(cbuf.insts_end()) - 4),
 1947 //                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1948 //   %}
 1949 
 1950   enc_class RegOpcImm (rRegI dst, immI8 shift) %{    // SHL, SAR, SHR
 1951     $$$emit8$primary;
 1952     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1953     $$$emit8$shift$$constant;
 1954   %}
 1955 
 1956   enc_class LdImmI (rRegI dst, immI src) %{    // Load Immediate
 1957     // Load immediate does not have a zero or sign extended version
 1958     // for 8-bit immediates
 1959     emit_opcode(cbuf, 0xB8 + $dst$$reg);
 1960     $$$emit32$src$$constant;
 1961   %}
 1962 
 1963   enc_class LdImmP (rRegI dst, immI src) %{    // Load Immediate
 1964     // Load immediate does not have a zero or sign extended version
 1965     // for 8-bit immediates
 1966     emit_opcode(cbuf, $primary + $dst$$reg);
 1967     $$$emit32$src$$constant;
 1968   %}
 1969 
 1970   enc_class LdImmL_Lo( eRegL dst, immL src) %{    // Load Immediate
 1971     // Load immediate does not have a zero or sign extended version
 1972     // for 8-bit immediates
 1973     int dst_enc = $dst$$reg;
 1974     int src_con = $src$$constant &amp; 0x0FFFFFFFFL;
 1975     if (src_con == 0) {
 1976       // xor dst, dst
 1977       emit_opcode(cbuf, 0x33);
 1978       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1979     } else {
 1980       emit_opcode(cbuf, $primary + dst_enc);
 1981       emit_d32(cbuf, src_con);
 1982     }
 1983   %}
 1984 
 1985   enc_class LdImmL_Hi( eRegL dst, immL src) %{    // Load Immediate
 1986     // Load immediate does not have a zero or sign extended version
 1987     // for 8-bit immediates
 1988     int dst_enc = $dst$$reg + 2;
 1989     int src_con = ((julong)($src$$constant)) &gt;&gt; 32;
 1990     if (src_con == 0) {
 1991       // xor dst, dst
 1992       emit_opcode(cbuf, 0x33);
 1993       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1994     } else {
 1995       emit_opcode(cbuf, $primary + dst_enc);
 1996       emit_d32(cbuf, src_con);
 1997     }
 1998   %}
 1999 
 2000 
 2001   // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2002   enc_class enc_Copy( rRegI dst, rRegI src ) %{
 2003     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2004   %}
 2005 
 2006   enc_class enc_CopyL_Lo( rRegI dst, eRegL src ) %{
 2007     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2008   %}
 2009 
 2010   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 2011     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2012   %}
 2013 
 2014   enc_class RegReg_Lo(eRegL dst, eRegL src) %{    // RegReg(Many)
 2015     $$$emit8$primary;
 2016     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2017   %}
 2018 
 2019   enc_class RegReg_Hi(eRegL dst, eRegL src) %{    // RegReg(Many)
 2020     $$$emit8$secondary;
 2021     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2022   %}
 2023 
 2024   enc_class RegReg_Lo2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2025     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2026   %}
 2027 
 2028   enc_class RegReg_Hi2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2029     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2030   %}
 2031 
 2032   enc_class RegReg_HiLo( eRegL src, rRegI dst ) %{
 2033     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));
 2034   %}
 2035 
 2036   enc_class Con32 (immI src) %{    // Con32(storeImmI)
 2037     // Output immediate
 2038     $$$emit32$src$$constant;
 2039   %}
 2040 
 2041   enc_class Con32FPR_as_bits(immFPR src) %{        // storeF_imm
 2042     // Output Float immediate bits
 2043     jfloat jf = $src$$constant;
 2044     int    jf_as_bits = jint_cast( jf );
 2045     emit_d32(cbuf, jf_as_bits);
 2046   %}
 2047 
 2048   enc_class Con32F_as_bits(immF src) %{      // storeX_imm
 2049     // Output Float immediate bits
 2050     jfloat jf = $src$$constant;
 2051     int    jf_as_bits = jint_cast( jf );
 2052     emit_d32(cbuf, jf_as_bits);
 2053   %}
 2054 
 2055   enc_class Con16 (immI src) %{    // Con16(storeImmI)
 2056     // Output immediate
 2057     $$$emit16$src$$constant;
 2058   %}
 2059 
 2060   enc_class Con_d32(immI src) %{
 2061     emit_d32(cbuf,$src$$constant);
 2062   %}
 2063 
 2064   enc_class conmemref (eRegP t1) %{    // Con32(storeImmI)
 2065     // Output immediate memory reference
 2066     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2067     emit_d32(cbuf, 0x00);
 2068   %}
 2069 
 2070   enc_class lock_prefix( ) %{
 2071     emit_opcode(cbuf,0xF0);         // [Lock]
 2072   %}
 2073 
 2074   // Cmp-xchg long value.
 2075   // Note: we need to swap rbx, and rcx before and after the
 2076   //       cmpxchg8 instruction because the instruction uses
 2077   //       rcx as the high order word of the new value to store but
 2078   //       our register encoding uses rbx,.
 2079   enc_class enc_cmpxchg8(eSIRegP mem_ptr) %{
 2080 
 2081     // XCHG  rbx,ecx
 2082     emit_opcode(cbuf,0x87);
 2083     emit_opcode(cbuf,0xD9);
 2084     // [Lock]
 2085     emit_opcode(cbuf,0xF0);
 2086     // CMPXCHG8 [Eptr]
 2087     emit_opcode(cbuf,0x0F);
 2088     emit_opcode(cbuf,0xC7);
 2089     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2090     // XCHG  rbx,ecx
 2091     emit_opcode(cbuf,0x87);
 2092     emit_opcode(cbuf,0xD9);
 2093   %}
 2094 
 2095   enc_class enc_cmpxchg(eSIRegP mem_ptr) %{
 2096     // [Lock]
 2097     emit_opcode(cbuf,0xF0);
 2098 
 2099     // CMPXCHG [Eptr]
 2100     emit_opcode(cbuf,0x0F);
 2101     emit_opcode(cbuf,0xB1);
 2102     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2103   %}
 2104 
 2105   enc_class enc_cmpxchgb(eSIRegP mem_ptr) %{
 2106     // [Lock]
 2107     emit_opcode(cbuf,0xF0);
 2108 
 2109     // CMPXCHGB [Eptr]
 2110     emit_opcode(cbuf,0x0F);
 2111     emit_opcode(cbuf,0xB0);
 2112     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2113   %}
 2114 
 2115   enc_class enc_cmpxchgw(eSIRegP mem_ptr) %{
 2116     // [Lock]
 2117     emit_opcode(cbuf,0xF0);
 2118 
 2119     // 16-bit mode
 2120     emit_opcode(cbuf, 0x66);
 2121 
 2122     // CMPXCHGW [Eptr]
 2123     emit_opcode(cbuf,0x0F);
 2124     emit_opcode(cbuf,0xB1);
 2125     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2126   %}
 2127 
 2128   enc_class enc_flags_ne_to_boolean( iRegI res ) %{
 2129     int res_encoding = $res$$reg;
 2130 
 2131     // MOV  res,0
 2132     emit_opcode( cbuf, 0xB8 + res_encoding);
 2133     emit_d32( cbuf, 0 );
 2134     // JNE,s  fail
 2135     emit_opcode(cbuf,0x75);
 2136     emit_d8(cbuf, 5 );
 2137     // MOV  res,1
 2138     emit_opcode( cbuf, 0xB8 + res_encoding);
 2139     emit_d32( cbuf, 1 );
 2140     // fail:
 2141   %}
 2142 
 2143   enc_class set_instruction_start( ) %{
 2144     cbuf.set_insts_mark();            // Mark start of opcode for reloc info in mem operand
 2145   %}
 2146 
 2147   enc_class RegMem (rRegI ereg, memory mem) %{    // emit_reg_mem
 2148     int reg_encoding = $ereg$$reg;
 2149     int base  = $mem$$base;
 2150     int index = $mem$$index;
 2151     int scale = $mem$$scale;
 2152     int displace = $mem$$disp;
 2153     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2154     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2155   %}
 2156 
 2157   enc_class RegMem_Hi(eRegL ereg, memory mem) %{    // emit_reg_mem
 2158     int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  // Hi register of pair, computed from lo
 2159     int base  = $mem$$base;
 2160     int index = $mem$$index;
 2161     int scale = $mem$$scale;
 2162     int displace = $mem$$disp + 4;      // Offset is 4 further in memory
 2163     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;Cannot add 4 to oop&quot; );
 2164     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, relocInfo::none);
 2165   %}
 2166 
 2167   enc_class move_long_small_shift( eRegL dst, immI_1_31 cnt ) %{
 2168     int r1, r2;
 2169     if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2170     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2171     emit_opcode(cbuf,0x0F);
 2172     emit_opcode(cbuf,$tertiary);
 2173     emit_rm(cbuf, 0x3, r1, r2);
 2174     emit_d8(cbuf,$cnt$$constant);
 2175     emit_d8(cbuf,$primary);
 2176     emit_rm(cbuf, 0x3, $secondary, r1);
 2177     emit_d8(cbuf,$cnt$$constant);
 2178   %}
 2179 
 2180   enc_class move_long_big_shift_sign( eRegL dst, immI_32_63 cnt ) %{
 2181     emit_opcode( cbuf, 0x8B ); // Move
 2182     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2183     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2184       emit_d8(cbuf,$primary);
 2185       emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 2186       emit_d8(cbuf,$cnt$$constant-32);
 2187     }
 2188     emit_d8(cbuf,$primary);
 2189     emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));
 2190     emit_d8(cbuf,31);
 2191   %}
 2192 
 2193   enc_class move_long_big_shift_clr( eRegL dst, immI_32_63 cnt ) %{
 2194     int r1, r2;
 2195     if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2196     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2197 
 2198     emit_opcode( cbuf, 0x8B ); // Move r1,r2
 2199     emit_rm(cbuf, 0x3, r1, r2);
 2200     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2201       emit_opcode(cbuf,$primary);
 2202       emit_rm(cbuf, 0x3, $secondary, r1);
 2203       emit_d8(cbuf,$cnt$$constant-32);
 2204     }
 2205     emit_opcode(cbuf,0x33);  // XOR r2,r2
 2206     emit_rm(cbuf, 0x3, r2, r2);
 2207   %}
 2208 
 2209   // Clone of RegMem but accepts an extra parameter to access each
 2210   // half of a double in memory; it never needs relocation info.
 2211   enc_class Mov_MemD_half_to_Reg (immI opcode, memory mem, immI disp_for_half, rRegI rm_reg) %{
 2212     emit_opcode(cbuf,$opcode$$constant);
 2213     int reg_encoding = $rm_reg$$reg;
 2214     int base     = $mem$$base;
 2215     int index    = $mem$$index;
 2216     int scale    = $mem$$scale;
 2217     int displace = $mem$$disp + $disp_for_half$$constant;
 2218     relocInfo::relocType disp_reloc = relocInfo::none;
 2219     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2220   %}
 2221 
 2222   // !!!!! Special Custom Code used by MemMove, and stack access instructions !!!!!
 2223   //
 2224   // Clone of RegMem except the RM-byte&#39;s reg/opcode field is an ADLC-time constant
 2225   // and it never needs relocation information.
 2226   // Frequently used to move data between FPU&#39;s Stack Top and memory.
 2227   enc_class RMopc_Mem_no_oop (immI rm_opcode, memory mem) %{
 2228     int rm_byte_opcode = $rm_opcode$$constant;
 2229     int base     = $mem$$base;
 2230     int index    = $mem$$index;
 2231     int scale    = $mem$$scale;
 2232     int displace = $mem$$disp;
 2233     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;No oops here because no reloc info allowed&quot; );
 2234     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, relocInfo::none);
 2235   %}
 2236 
 2237   enc_class RMopc_Mem (immI rm_opcode, memory mem) %{
 2238     int rm_byte_opcode = $rm_opcode$$constant;
 2239     int base     = $mem$$base;
 2240     int index    = $mem$$index;
 2241     int scale    = $mem$$scale;
 2242     int displace = $mem$$disp;
 2243     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2244     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 2245   %}
 2246 
 2247   enc_class RegLea (rRegI dst, rRegI src0, immI src1 ) %{    // emit_reg_lea
 2248     int reg_encoding = $dst$$reg;
 2249     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2250     int index        = 0x04;            // 0x04 indicates no index
 2251     int scale        = 0x00;            // 0x00 indicates no scale
 2252     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2253     relocInfo::relocType disp_reloc = relocInfo::none;
 2254     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2255   %}
 2256 
 2257   enc_class min_enc (rRegI dst, rRegI src) %{    // MIN
 2258     // Compare dst,src
 2259     emit_opcode(cbuf,0x3B);
 2260     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2261     // jmp dst &lt; src around move
 2262     emit_opcode(cbuf,0x7C);
 2263     emit_d8(cbuf,2);
 2264     // move dst,src
 2265     emit_opcode(cbuf,0x8B);
 2266     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2267   %}
 2268 
 2269   enc_class max_enc (rRegI dst, rRegI src) %{    // MAX
 2270     // Compare dst,src
 2271     emit_opcode(cbuf,0x3B);
 2272     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2273     // jmp dst &gt; src around move
 2274     emit_opcode(cbuf,0x7F);
 2275     emit_d8(cbuf,2);
 2276     // move dst,src
 2277     emit_opcode(cbuf,0x8B);
 2278     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2279   %}
 2280 
 2281   enc_class enc_FPR_store(memory mem, regDPR src) %{
 2282     // If src is FPR1, we can just FST to store it.
 2283     // Else we need to FLD it to FPR1, then FSTP to store/pop it.
 2284     int reg_encoding = 0x2; // Just store
 2285     int base  = $mem$$base;
 2286     int index = $mem$$index;
 2287     int scale = $mem$$scale;
 2288     int displace = $mem$$disp;
 2289     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2290     if( $src$$reg != FPR1L_enc ) {
 2291       reg_encoding = 0x3;  // Store &amp; pop
 2292       emit_opcode( cbuf, 0xD9 ); // FLD (i.e., push it)
 2293       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2294     }
 2295     cbuf.set_insts_mark();       // Mark start of opcode for reloc info in mem operand
 2296     emit_opcode(cbuf,$primary);
 2297     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2298   %}
 2299 
 2300   enc_class neg_reg(rRegI dst) %{
 2301     // NEG $dst
 2302     emit_opcode(cbuf,0xF7);
 2303     emit_rm(cbuf, 0x3, 0x03, $dst$$reg );
 2304   %}
 2305 
 2306   enc_class setLT_reg(eCXRegI dst) %{
 2307     // SETLT $dst
 2308     emit_opcode(cbuf,0x0F);
 2309     emit_opcode(cbuf,0x9C);
 2310     emit_rm( cbuf, 0x3, 0x4, $dst$$reg );
 2311   %}
 2312 
 2313   enc_class enc_cmpLTP(ncxRegI p, ncxRegI q, ncxRegI y, eCXRegI tmp) %{    // cadd_cmpLT
 2314     int tmpReg = $tmp$$reg;
 2315 
 2316     // SUB $p,$q
 2317     emit_opcode(cbuf,0x2B);
 2318     emit_rm(cbuf, 0x3, $p$$reg, $q$$reg);
 2319     // SBB $tmp,$tmp
 2320     emit_opcode(cbuf,0x1B);
 2321     emit_rm(cbuf, 0x3, tmpReg, tmpReg);
 2322     // AND $tmp,$y
 2323     emit_opcode(cbuf,0x23);
 2324     emit_rm(cbuf, 0x3, tmpReg, $y$$reg);
 2325     // ADD $p,$tmp
 2326     emit_opcode(cbuf,0x03);
 2327     emit_rm(cbuf, 0x3, $p$$reg, tmpReg);
 2328   %}
 2329 
 2330   enc_class shift_left_long( eRegL dst, eCXRegI shift ) %{
 2331     // TEST shift,32
 2332     emit_opcode(cbuf,0xF7);
 2333     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2334     emit_d32(cbuf,0x20);
 2335     // JEQ,s small
 2336     emit_opcode(cbuf, 0x74);
 2337     emit_d8(cbuf, 0x04);
 2338     // MOV    $dst.hi,$dst.lo
 2339     emit_opcode( cbuf, 0x8B );
 2340     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2341     // CLR    $dst.lo
 2342     emit_opcode(cbuf, 0x33);
 2343     emit_rm(cbuf, 0x3, $dst$$reg, $dst$$reg);
 2344 // small:
 2345     // SHLD   $dst.hi,$dst.lo,$shift
 2346     emit_opcode(cbuf,0x0F);
 2347     emit_opcode(cbuf,0xA5);
 2348     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2349     // SHL    $dst.lo,$shift&quot;
 2350     emit_opcode(cbuf,0xD3);
 2351     emit_rm(cbuf, 0x3, 0x4, $dst$$reg );
 2352   %}
 2353 
 2354   enc_class shift_right_long( eRegL dst, eCXRegI shift ) %{
 2355     // TEST shift,32
 2356     emit_opcode(cbuf,0xF7);
 2357     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2358     emit_d32(cbuf,0x20);
 2359     // JEQ,s small
 2360     emit_opcode(cbuf, 0x74);
 2361     emit_d8(cbuf, 0x04);
 2362     // MOV    $dst.lo,$dst.hi
 2363     emit_opcode( cbuf, 0x8B );
 2364     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2365     // CLR    $dst.hi
 2366     emit_opcode(cbuf, 0x33);
 2367     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));
 2368 // small:
 2369     // SHRD   $dst.lo,$dst.hi,$shift
 2370     emit_opcode(cbuf,0x0F);
 2371     emit_opcode(cbuf,0xAD);
 2372     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2373     // SHR    $dst.hi,$shift&quot;
 2374     emit_opcode(cbuf,0xD3);
 2375     emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );
 2376   %}
 2377 
 2378   enc_class shift_right_arith_long( eRegL dst, eCXRegI shift ) %{
 2379     // TEST shift,32
 2380     emit_opcode(cbuf,0xF7);
 2381     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2382     emit_d32(cbuf,0x20);
 2383     // JEQ,s small
 2384     emit_opcode(cbuf, 0x74);
 2385     emit_d8(cbuf, 0x05);
 2386     // MOV    $dst.lo,$dst.hi
 2387     emit_opcode( cbuf, 0x8B );
 2388     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2389     // SAR    $dst.hi,31
 2390     emit_opcode(cbuf, 0xC1);
 2391     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );
 2392     emit_d8(cbuf, 0x1F );
 2393 // small:
 2394     // SHRD   $dst.lo,$dst.hi,$shift
 2395     emit_opcode(cbuf,0x0F);
 2396     emit_opcode(cbuf,0xAD);
 2397     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2398     // SAR    $dst.hi,$shift&quot;
 2399     emit_opcode(cbuf,0xD3);
 2400     emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );
 2401   %}
 2402 
 2403 
 2404   // ----------------- Encodings for floating point unit -----------------
 2405   // May leave result in FPU-TOS or FPU reg depending on opcodes
 2406   enc_class OpcReg_FPR(regFPR src) %{    // FMUL, FDIV
 2407     $$$emit8$primary;
 2408     emit_rm(cbuf, 0x3, $secondary, $src$$reg );
 2409   %}
 2410 
 2411   // Pop argument in FPR0 with FSTP ST(0)
 2412   enc_class PopFPU() %{
 2413     emit_opcode( cbuf, 0xDD );
 2414     emit_d8( cbuf, 0xD8 );
 2415   %}
 2416 
 2417   // !!!!! equivalent to Pop_Reg_F
 2418   enc_class Pop_Reg_DPR( regDPR dst ) %{
 2419     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2420     emit_d8( cbuf, 0xD8+$dst$$reg );
 2421   %}
 2422 
 2423   enc_class Push_Reg_DPR( regDPR dst ) %{
 2424     emit_opcode( cbuf, 0xD9 );
 2425     emit_d8( cbuf, 0xC0-1+$dst$$reg );   // FLD ST(i-1)
 2426   %}
 2427 
 2428   enc_class strictfp_bias1( regDPR dst ) %{
 2429     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2430     emit_opcode( cbuf, 0x2D );
 2431     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias1() );
 2432     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2433     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2434   %}
 2435 
 2436   enc_class strictfp_bias2( regDPR dst ) %{
 2437     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2438     emit_opcode( cbuf, 0x2D );
 2439     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias2() );
 2440     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2441     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2442   %}
 2443 
 2444   // Special case for moving an integer register to a stack slot.
 2445   enc_class OpcPRegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2446     store_to_stackslot( cbuf, $primary, $src$$reg, $dst$$disp );
 2447   %}
 2448 
 2449   // Special case for moving a register to a stack slot.
 2450   enc_class RegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2451     // Opcode already emitted
 2452     emit_rm( cbuf, 0x02, $src$$reg, ESP_enc );   // R/M byte
 2453     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);          // SIB byte
 2454     emit_d32(cbuf, $dst$$disp);   // Displacement
 2455   %}
 2456 
 2457   // Push the integer in stackSlot &#39;src&#39; onto FP-stack
 2458   enc_class Push_Mem_I( memory src ) %{    // FILD   [ESP+src]
 2459     store_to_stackslot( cbuf, $primary, $secondary, $src$$disp );
 2460   %}
 2461 
 2462   // Push FPU&#39;s TOS float to a stack-slot, and pop FPU-stack
 2463   enc_class Pop_Mem_FPR( stackSlotF dst ) %{ // FSTP_S [ESP+dst]
 2464     store_to_stackslot( cbuf, 0xD9, 0x03, $dst$$disp );
 2465   %}
 2466 
 2467   // Same as Pop_Mem_F except for opcode
 2468   // Push FPU&#39;s TOS double to a stack-slot, and pop FPU-stack
 2469   enc_class Pop_Mem_DPR( stackSlotD dst ) %{ // FSTP_D [ESP+dst]
 2470     store_to_stackslot( cbuf, 0xDD, 0x03, $dst$$disp );
 2471   %}
 2472 
 2473   enc_class Pop_Reg_FPR( regFPR dst ) %{
 2474     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2475     emit_d8( cbuf, 0xD8+$dst$$reg );
 2476   %}
 2477 
 2478   enc_class Push_Reg_FPR( regFPR dst ) %{
 2479     emit_opcode( cbuf, 0xD9 );           // FLD    ST(i-1)
 2480     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2481   %}
 2482 
 2483   // Push FPU&#39;s float to a stack-slot, and pop FPU-stack
 2484   enc_class Pop_Mem_Reg_FPR( stackSlotF dst, regFPR src ) %{
 2485     int pop = 0x02;
 2486     if ($src$$reg != FPR1L_enc) {
 2487       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2488       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2489       pop = 0x03;
 2490     }
 2491     store_to_stackslot( cbuf, 0xD9, pop, $dst$$disp ); // FST&lt;P&gt;_S  [ESP+dst]
 2492   %}
 2493 
 2494   // Push FPU&#39;s double to a stack-slot, and pop FPU-stack
 2495   enc_class Pop_Mem_Reg_DPR( stackSlotD dst, regDPR src ) %{
 2496     int pop = 0x02;
 2497     if ($src$$reg != FPR1L_enc) {
 2498       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2499       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2500       pop = 0x03;
 2501     }
 2502     store_to_stackslot( cbuf, 0xDD, pop, $dst$$disp ); // FST&lt;P&gt;_D  [ESP+dst]
 2503   %}
 2504 
 2505   // Push FPU&#39;s double to a FPU-stack-slot, and pop FPU-stack
 2506   enc_class Pop_Reg_Reg_DPR( regDPR dst, regFPR src ) %{
 2507     int pop = 0xD0 - 1; // -1 since we skip FLD
 2508     if ($src$$reg != FPR1L_enc) {
 2509       emit_opcode( cbuf, 0xD9 );         // FLD    ST(src-1)
 2510       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2511       pop = 0xD8;
 2512     }
 2513     emit_opcode( cbuf, 0xDD );
 2514     emit_d8( cbuf, pop+$dst$$reg );      // FST&lt;P&gt; ST(i)
 2515   %}
 2516 
 2517 
 2518   enc_class Push_Reg_Mod_DPR( regDPR dst, regDPR src) %{
 2519     // load dst in FPR0
 2520     emit_opcode( cbuf, 0xD9 );
 2521     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2522     if ($src$$reg != FPR1L_enc) {
 2523       // fincstp
 2524       emit_opcode (cbuf, 0xD9);
 2525       emit_opcode (cbuf, 0xF7);
 2526       // swap src with FPR1:
 2527       // FXCH FPR1 with src
 2528       emit_opcode(cbuf, 0xD9);
 2529       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2530       // fdecstp
 2531       emit_opcode (cbuf, 0xD9);
 2532       emit_opcode (cbuf, 0xF6);
 2533     }
 2534   %}
 2535 
 2536   enc_class Push_ModD_encoding(regD src0, regD src1) %{
 2537     MacroAssembler _masm(&amp;cbuf);
 2538     __ subptr(rsp, 8);
 2539     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
 2540     __ fld_d(Address(rsp, 0));
 2541     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
 2542     __ fld_d(Address(rsp, 0));
 2543   %}
 2544 
 2545   enc_class Push_ModF_encoding(regF src0, regF src1) %{
 2546     MacroAssembler _masm(&amp;cbuf);
 2547     __ subptr(rsp, 4);
 2548     __ movflt(Address(rsp, 0), $src1$$XMMRegister);
 2549     __ fld_s(Address(rsp, 0));
 2550     __ movflt(Address(rsp, 0), $src0$$XMMRegister);
 2551     __ fld_s(Address(rsp, 0));
 2552   %}
 2553 
 2554   enc_class Push_ResultD(regD dst) %{
 2555     MacroAssembler _masm(&amp;cbuf);
 2556     __ fstp_d(Address(rsp, 0));
 2557     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2558     __ addptr(rsp, 8);
 2559   %}
 2560 
 2561   enc_class Push_ResultF(regF dst, immI d8) %{
 2562     MacroAssembler _masm(&amp;cbuf);
 2563     __ fstp_s(Address(rsp, 0));
 2564     __ movflt($dst$$XMMRegister, Address(rsp, 0));
 2565     __ addptr(rsp, $d8$$constant);
 2566   %}
 2567 
 2568   enc_class Push_SrcD(regD src) %{
 2569     MacroAssembler _masm(&amp;cbuf);
 2570     __ subptr(rsp, 8);
 2571     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2572     __ fld_d(Address(rsp, 0));
 2573   %}
 2574 
 2575   enc_class push_stack_temp_qword() %{
 2576     MacroAssembler _masm(&amp;cbuf);
 2577     __ subptr(rsp, 8);
 2578   %}
 2579 
 2580   enc_class pop_stack_temp_qword() %{
 2581     MacroAssembler _masm(&amp;cbuf);
 2582     __ addptr(rsp, 8);
 2583   %}
 2584 
 2585   enc_class push_xmm_to_fpr1(regD src) %{
 2586     MacroAssembler _masm(&amp;cbuf);
 2587     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2588     __ fld_d(Address(rsp, 0));
 2589   %}
 2590 
 2591   enc_class Push_Result_Mod_DPR( regDPR src) %{
 2592     if ($src$$reg != FPR1L_enc) {
 2593       // fincstp
 2594       emit_opcode (cbuf, 0xD9);
 2595       emit_opcode (cbuf, 0xF7);
 2596       // FXCH FPR1 with src
 2597       emit_opcode(cbuf, 0xD9);
 2598       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2599       // fdecstp
 2600       emit_opcode (cbuf, 0xD9);
 2601       emit_opcode (cbuf, 0xF6);
 2602     }
 2603     // // following asm replaced with Pop_Reg_F or Pop_Mem_F
 2604     // // FSTP   FPR$dst$$reg
 2605     // emit_opcode( cbuf, 0xDD );
 2606     // emit_d8( cbuf, 0xD8+$dst$$reg );
 2607   %}
 2608 
 2609   enc_class fnstsw_sahf_skip_parity() %{
 2610     // fnstsw ax
 2611     emit_opcode( cbuf, 0xDF );
 2612     emit_opcode( cbuf, 0xE0 );
 2613     // sahf
 2614     emit_opcode( cbuf, 0x9E );
 2615     // jnp  ::skip
 2616     emit_opcode( cbuf, 0x7B );
 2617     emit_opcode( cbuf, 0x05 );
 2618   %}
 2619 
 2620   enc_class emitModDPR() %{
 2621     // fprem must be iterative
 2622     // :: loop
 2623     // fprem
 2624     emit_opcode( cbuf, 0xD9 );
 2625     emit_opcode( cbuf, 0xF8 );
 2626     // wait
 2627     emit_opcode( cbuf, 0x9b );
 2628     // fnstsw ax
 2629     emit_opcode( cbuf, 0xDF );
 2630     emit_opcode( cbuf, 0xE0 );
 2631     // sahf
 2632     emit_opcode( cbuf, 0x9E );
 2633     // jp  ::loop
 2634     emit_opcode( cbuf, 0x0F );
 2635     emit_opcode( cbuf, 0x8A );
 2636     emit_opcode( cbuf, 0xF4 );
 2637     emit_opcode( cbuf, 0xFF );
 2638     emit_opcode( cbuf, 0xFF );
 2639     emit_opcode( cbuf, 0xFF );
 2640   %}
 2641 
 2642   enc_class fpu_flags() %{
 2643     // fnstsw_ax
 2644     emit_opcode( cbuf, 0xDF);
 2645     emit_opcode( cbuf, 0xE0);
 2646     // test ax,0x0400
 2647     emit_opcode( cbuf, 0x66 );   // operand-size prefix for 16-bit immediate
 2648     emit_opcode( cbuf, 0xA9 );
 2649     emit_d16   ( cbuf, 0x0400 );
 2650     // // // This sequence works, but stalls for 12-16 cycles on PPro
 2651     // // test rax,0x0400
 2652     // emit_opcode( cbuf, 0xA9 );
 2653     // emit_d32   ( cbuf, 0x00000400 );
 2654     //
 2655     // jz exit (no unordered comparison)
 2656     emit_opcode( cbuf, 0x74 );
 2657     emit_d8    ( cbuf, 0x02 );
 2658     // mov ah,1 - treat as LT case (set carry flag)
 2659     emit_opcode( cbuf, 0xB4 );
 2660     emit_d8    ( cbuf, 0x01 );
 2661     // sahf
 2662     emit_opcode( cbuf, 0x9E);
 2663   %}
 2664 
 2665   enc_class cmpF_P6_fixup() %{
 2666     // Fixup the integer flags in case comparison involved a NaN
 2667     //
 2668     // JNP exit (no unordered comparison, P-flag is set by NaN)
 2669     emit_opcode( cbuf, 0x7B );
 2670     emit_d8    ( cbuf, 0x03 );
 2671     // MOV AH,1 - treat as LT case (set carry flag)
 2672     emit_opcode( cbuf, 0xB4 );
 2673     emit_d8    ( cbuf, 0x01 );
 2674     // SAHF
 2675     emit_opcode( cbuf, 0x9E);
 2676     // NOP     // target for branch to avoid branch to branch
 2677     emit_opcode( cbuf, 0x90);
 2678   %}
 2679 
 2680 //     fnstsw_ax();
 2681 //     sahf();
 2682 //     movl(dst, nan_result);
 2683 //     jcc(Assembler::parity, exit);
 2684 //     movl(dst, less_result);
 2685 //     jcc(Assembler::below, exit);
 2686 //     movl(dst, equal_result);
 2687 //     jcc(Assembler::equal, exit);
 2688 //     movl(dst, greater_result);
 2689 
 2690 // less_result     =  1;
 2691 // greater_result  = -1;
 2692 // equal_result    = 0;
 2693 // nan_result      = -1;
 2694 
 2695   enc_class CmpF_Result(rRegI dst) %{
 2696     // fnstsw_ax();
 2697     emit_opcode( cbuf, 0xDF);
 2698     emit_opcode( cbuf, 0xE0);
 2699     // sahf
 2700     emit_opcode( cbuf, 0x9E);
 2701     // movl(dst, nan_result);
 2702     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2703     emit_d32( cbuf, -1 );
 2704     // jcc(Assembler::parity, exit);
 2705     emit_opcode( cbuf, 0x7A );
 2706     emit_d8    ( cbuf, 0x13 );
 2707     // movl(dst, less_result);
 2708     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2709     emit_d32( cbuf, -1 );
 2710     // jcc(Assembler::below, exit);
 2711     emit_opcode( cbuf, 0x72 );
 2712     emit_d8    ( cbuf, 0x0C );
 2713     // movl(dst, equal_result);
 2714     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2715     emit_d32( cbuf, 0 );
 2716     // jcc(Assembler::equal, exit);
 2717     emit_opcode( cbuf, 0x74 );
 2718     emit_d8    ( cbuf, 0x05 );
 2719     // movl(dst, greater_result);
 2720     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2721     emit_d32( cbuf, 1 );
 2722   %}
 2723 
 2724 
 2725   // Compare the longs and set flags
 2726   // BROKEN!  Do Not use as-is
 2727   enc_class cmpl_test( eRegL src1, eRegL src2 ) %{
 2728     // CMP    $src1.hi,$src2.hi
 2729     emit_opcode( cbuf, 0x3B );
 2730     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2731     // JNE,s  done
 2732     emit_opcode(cbuf,0x75);
 2733     emit_d8(cbuf, 2 );
 2734     // CMP    $src1.lo,$src2.lo
 2735     emit_opcode( cbuf, 0x3B );
 2736     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2737 // done:
 2738   %}
 2739 
 2740   enc_class convert_int_long( regL dst, rRegI src ) %{
 2741     // mov $dst.lo,$src
 2742     int dst_encoding = $dst$$reg;
 2743     int src_encoding = $src$$reg;
 2744     encode_Copy( cbuf, dst_encoding  , src_encoding );
 2745     // mov $dst.hi,$src
 2746     encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );
 2747     // sar $dst.hi,31
 2748     emit_opcode( cbuf, 0xC1 );
 2749     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );
 2750     emit_d8(cbuf, 0x1F );
 2751   %}
 2752 
 2753   enc_class convert_long_double( eRegL src ) %{
 2754     // push $src.hi
 2755     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2756     // push $src.lo
 2757     emit_opcode(cbuf, 0x50+$src$$reg  );
 2758     // fild 64-bits at [SP]
 2759     emit_opcode(cbuf,0xdf);
 2760     emit_d8(cbuf, 0x6C);
 2761     emit_d8(cbuf, 0x24);
 2762     emit_d8(cbuf, 0x00);
 2763     // pop stack
 2764     emit_opcode(cbuf, 0x83); // add  SP, #8
 2765     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2766     emit_d8(cbuf, 0x8);
 2767   %}
 2768 
 2769   enc_class multiply_con_and_shift_high( eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr ) %{
 2770     // IMUL   EDX:EAX,$src1
 2771     emit_opcode( cbuf, 0xF7 );
 2772     emit_rm( cbuf, 0x3, 0x5, $src1$$reg );
 2773     // SAR    EDX,$cnt-32
 2774     int shift_count = ((int)$cnt$$constant) - 32;
 2775     if (shift_count &gt; 0) {
 2776       emit_opcode(cbuf, 0xC1);
 2777       emit_rm(cbuf, 0x3, 7, $dst$$reg );
 2778       emit_d8(cbuf, shift_count);
 2779     }
 2780   %}
 2781 
 2782   // this version doesn&#39;t have add sp, 8
 2783   enc_class convert_long_double2( eRegL src ) %{
 2784     // push $src.hi
 2785     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2786     // push $src.lo
 2787     emit_opcode(cbuf, 0x50+$src$$reg  );
 2788     // fild 64-bits at [SP]
 2789     emit_opcode(cbuf,0xdf);
 2790     emit_d8(cbuf, 0x6C);
 2791     emit_d8(cbuf, 0x24);
 2792     emit_d8(cbuf, 0x00);
 2793   %}
 2794 
 2795   enc_class long_int_multiply( eADXRegL dst, nadxRegI src) %{
 2796     // Basic idea: long = (long)int * (long)int
 2797     // IMUL EDX:EAX, src
 2798     emit_opcode( cbuf, 0xF7 );
 2799     emit_rm( cbuf, 0x3, 0x5, $src$$reg);
 2800   %}
 2801 
 2802   enc_class long_uint_multiply( eADXRegL dst, nadxRegI src) %{
 2803     // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 2804     // MUL EDX:EAX, src
 2805     emit_opcode( cbuf, 0xF7 );
 2806     emit_rm( cbuf, 0x3, 0x4, $src$$reg);
 2807   %}
 2808 
 2809   enc_class long_multiply( eADXRegL dst, eRegL src, rRegI tmp ) %{
 2810     // Basic idea: lo(result) = lo(x_lo * y_lo)
 2811     //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 2812     // MOV    $tmp,$src.lo
 2813     encode_Copy( cbuf, $tmp$$reg, $src$$reg );
 2814     // IMUL   $tmp,EDX
 2815     emit_opcode( cbuf, 0x0F );
 2816     emit_opcode( cbuf, 0xAF );
 2817     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2818     // MOV    EDX,$src.hi
 2819     encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );
 2820     // IMUL   EDX,EAX
 2821     emit_opcode( cbuf, 0x0F );
 2822     emit_opcode( cbuf, 0xAF );
 2823     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2824     // ADD    $tmp,EDX
 2825     emit_opcode( cbuf, 0x03 );
 2826     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2827     // MUL   EDX:EAX,$src.lo
 2828     emit_opcode( cbuf, 0xF7 );
 2829     emit_rm( cbuf, 0x3, 0x4, $src$$reg );
 2830     // ADD    EDX,ESI
 2831     emit_opcode( cbuf, 0x03 );
 2832     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );
 2833   %}
 2834 
 2835   enc_class long_multiply_con( eADXRegL dst, immL_127 src, rRegI tmp ) %{
 2836     // Basic idea: lo(result) = lo(src * y_lo)
 2837     //             hi(result) = hi(src * y_lo) + lo(src * y_hi)
 2838     // IMUL   $tmp,EDX,$src
 2839     emit_opcode( cbuf, 0x6B );
 2840     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2841     emit_d8( cbuf, (int)$src$$constant );
 2842     // MOV    EDX,$src
 2843     emit_opcode(cbuf, 0xB8 + EDX_enc);
 2844     emit_d32( cbuf, (int)$src$$constant );
 2845     // MUL   EDX:EAX,EDX
 2846     emit_opcode( cbuf, 0xF7 );
 2847     emit_rm( cbuf, 0x3, 0x4, EDX_enc );
 2848     // ADD    EDX,ESI
 2849     emit_opcode( cbuf, 0x03 );
 2850     emit_rm( cbuf, 0x3, EDX_enc, $tmp$$reg );
 2851   %}
 2852 
 2853   enc_class long_div( eRegL src1, eRegL src2 ) %{
 2854     // PUSH src1.hi
 2855     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2856     // PUSH src1.lo
 2857     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2858     // PUSH src2.hi
 2859     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2860     // PUSH src2.lo
 2861     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2862     // CALL directly to the runtime
 2863     cbuf.set_insts_mark();
 2864     emit_opcode(cbuf,0xE8);       // Call into runtime
 2865     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2866     // Restore stack
 2867     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2868     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2869     emit_d8(cbuf, 4*4);
 2870   %}
 2871 
 2872   enc_class long_mod( eRegL src1, eRegL src2 ) %{
 2873     // PUSH src1.hi
 2874     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2875     // PUSH src1.lo
 2876     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2877     // PUSH src2.hi
 2878     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2879     // PUSH src2.lo
 2880     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2881     // CALL directly to the runtime
 2882     cbuf.set_insts_mark();
 2883     emit_opcode(cbuf,0xE8);       // Call into runtime
 2884     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2885     // Restore stack
 2886     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2887     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2888     emit_d8(cbuf, 4*4);
 2889   %}
 2890 
 2891   enc_class long_cmp_flags0( eRegL src, rRegI tmp ) %{
 2892     // MOV   $tmp,$src.lo
 2893     emit_opcode(cbuf, 0x8B);
 2894     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg);
 2895     // OR    $tmp,$src.hi
 2896     emit_opcode(cbuf, 0x0B);
 2897     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));
 2898   %}
 2899 
 2900   enc_class long_cmp_flags1( eRegL src1, eRegL src2 ) %{
 2901     // CMP    $src1.lo,$src2.lo
 2902     emit_opcode( cbuf, 0x3B );
 2903     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2904     // JNE,s  skip
 2905     emit_cc(cbuf, 0x70, 0x5);
 2906     emit_d8(cbuf,2);
 2907     // CMP    $src1.hi,$src2.hi
 2908     emit_opcode( cbuf, 0x3B );
 2909     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2910   %}
 2911 
 2912   enc_class long_cmp_flags2( eRegL src1, eRegL src2, rRegI tmp ) %{
 2913     // CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits
 2914     emit_opcode( cbuf, 0x3B );
 2915     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2916     // MOV    $tmp,$src1.hi
 2917     emit_opcode( cbuf, 0x8B );
 2918     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );
 2919     // SBB   $tmp,$src2.hi\t! Compute flags for long compare
 2920     emit_opcode( cbuf, 0x1B );
 2921     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );
 2922   %}
 2923 
 2924   enc_class long_cmp_flags3( eRegL src, rRegI tmp ) %{
 2925     // XOR    $tmp,$tmp
 2926     emit_opcode(cbuf,0x33);  // XOR
 2927     emit_rm(cbuf,0x3, $tmp$$reg, $tmp$$reg);
 2928     // CMP    $tmp,$src.lo
 2929     emit_opcode( cbuf, 0x3B );
 2930     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg );
 2931     // SBB    $tmp,$src.hi
 2932     emit_opcode( cbuf, 0x1B );
 2933     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );
 2934   %}
 2935 
 2936  // Sniff, sniff... smells like Gnu Superoptimizer
 2937   enc_class neg_long( eRegL dst ) %{
 2938     emit_opcode(cbuf,0xF7);    // NEG hi
 2939     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2940     emit_opcode(cbuf,0xF7);    // NEG lo
 2941     emit_rm    (cbuf,0x3, 0x3,               $dst$$reg );
 2942     emit_opcode(cbuf,0x83);    // SBB hi,0
 2943     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2944     emit_d8    (cbuf,0 );
 2945   %}
 2946 
 2947   enc_class enc_pop_rdx() %{
 2948     emit_opcode(cbuf,0x5A);
 2949   %}
 2950 
 2951   enc_class enc_rethrow() %{
 2952     cbuf.set_insts_mark();
 2953     emit_opcode(cbuf, 0xE9);        // jmp    entry
 2954     emit_d32_reloc(cbuf, (int)OptoRuntime::rethrow_stub() - ((int)cbuf.insts_end())-4,
 2955                    runtime_call_Relocation::spec(), RELOC_IMM32 );
 2956   %}
 2957 
 2958 
 2959   // Convert a double to an int.  Java semantics require we do complex
 2960   // manglelations in the corner cases.  So we set the rounding mode to
 2961   // &#39;zero&#39;, store the darned double down as an int, and reset the
 2962   // rounding mode to &#39;nearest&#39;.  The hardware throws an exception which
 2963   // patches up the correct value directly to the stack.
 2964   enc_class DPR2I_encoding( regDPR src ) %{
 2965     // Flip to round-to-zero mode.  We attempted to allow invalid-op
 2966     // exceptions here, so that a NAN or other corner-case value will
 2967     // thrown an exception (but normal values get converted at full speed).
 2968     // However, I2C adapters and other float-stack manglers leave pending
 2969     // invalid-op exceptions hanging.  We would have to clear them before
 2970     // enabling them and that is more expensive than just testing for the
 2971     // invalid value Intel stores down in the corner cases.
 2972     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 2973     emit_opcode(cbuf,0x2D);
 2974     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 2975     // Allocate a word
 2976     emit_opcode(cbuf,0x83);            // SUB ESP,4
 2977     emit_opcode(cbuf,0xEC);
 2978     emit_d8(cbuf,0x04);
 2979     // Encoding assumes a double has been pushed into FPR0.
 2980     // Store down the double as an int, popping the FPU stack
 2981     emit_opcode(cbuf,0xDB);            // FISTP [ESP]
 2982     emit_opcode(cbuf,0x1C);
 2983     emit_d8(cbuf,0x24);
 2984     // Restore the rounding mode; mask the exception
 2985     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 2986     emit_opcode(cbuf,0x2D);
 2987     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 2988         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 2989         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 2990 
 2991     // Load the converted int; adjust CPU stack
 2992     emit_opcode(cbuf,0x58);       // POP EAX
 2993     emit_opcode(cbuf,0x3D);       // CMP EAX,imm
 2994     emit_d32   (cbuf,0x80000000); //         0x80000000
 2995     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 2996     emit_d8    (cbuf,0x07);       // Size of slow_call
 2997     // Push src onto stack slow-path
 2998     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 2999     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3000     // CALL directly to the runtime
 3001     cbuf.set_insts_mark();
 3002     emit_opcode(cbuf,0xE8);       // Call into runtime
 3003     emit_d32_reloc(cbuf, (StubRoutines::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3004     // Carry on here...
 3005   %}
 3006 
 3007   enc_class DPR2L_encoding( regDPR src ) %{
 3008     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 3009     emit_opcode(cbuf,0x2D);
 3010     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 3011     // Allocate a word
 3012     emit_opcode(cbuf,0x83);            // SUB ESP,8
 3013     emit_opcode(cbuf,0xEC);
 3014     emit_d8(cbuf,0x08);
 3015     // Encoding assumes a double has been pushed into FPR0.
 3016     // Store down the double as a long, popping the FPU stack
 3017     emit_opcode(cbuf,0xDF);            // FISTP [ESP]
 3018     emit_opcode(cbuf,0x3C);
 3019     emit_d8(cbuf,0x24);
 3020     // Restore the rounding mode; mask the exception
 3021     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3022     emit_opcode(cbuf,0x2D);
 3023     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3024         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3025         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3026 
 3027     // Load the converted int; adjust CPU stack
 3028     emit_opcode(cbuf,0x58);       // POP EAX
 3029     emit_opcode(cbuf,0x5A);       // POP EDX
 3030     emit_opcode(cbuf,0x81);       // CMP EDX,imm
 3031     emit_d8    (cbuf,0xFA);       // rdx
 3032     emit_d32   (cbuf,0x80000000); //         0x80000000
 3033     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3034     emit_d8    (cbuf,0x07+4);     // Size of slow_call
 3035     emit_opcode(cbuf,0x85);       // TEST EAX,EAX
 3036     emit_opcode(cbuf,0xC0);       // 2/rax,/rax,
 3037     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3038     emit_d8    (cbuf,0x07);       // Size of slow_call
 3039     // Push src onto stack slow-path
 3040     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3041     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3042     // CALL directly to the runtime
 3043     cbuf.set_insts_mark();
 3044     emit_opcode(cbuf,0xE8);       // Call into runtime
 3045     emit_d32_reloc(cbuf, (StubRoutines::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3046     // Carry on here...
 3047   %}
 3048 
 3049   enc_class FMul_ST_reg( eRegFPR src1 ) %{
 3050     // Operand was loaded from memory into fp ST (stack top)
 3051     // FMUL   ST,$src  /* D8 C8+i */
 3052     emit_opcode(cbuf, 0xD8);
 3053     emit_opcode(cbuf, 0xC8 + $src1$$reg);
 3054   %}
 3055 
 3056   enc_class FAdd_ST_reg( eRegFPR src2 ) %{
 3057     // FADDP  ST,src2  /* D8 C0+i */
 3058     emit_opcode(cbuf, 0xD8);
 3059     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3060     //could use FADDP  src2,fpST  /* DE C0+i */
 3061   %}
 3062 
 3063   enc_class FAddP_reg_ST( eRegFPR src2 ) %{
 3064     // FADDP  src2,ST  /* DE C0+i */
 3065     emit_opcode(cbuf, 0xDE);
 3066     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3067   %}
 3068 
 3069   enc_class subFPR_divFPR_encode( eRegFPR src1, eRegFPR src2) %{
 3070     // Operand has been loaded into fp ST (stack top)
 3071       // FSUB   ST,$src1
 3072       emit_opcode(cbuf, 0xD8);
 3073       emit_opcode(cbuf, 0xE0 + $src1$$reg);
 3074 
 3075       // FDIV
 3076       emit_opcode(cbuf, 0xD8);
 3077       emit_opcode(cbuf, 0xF0 + $src2$$reg);
 3078   %}
 3079 
 3080   enc_class MulFAddF (eRegFPR src1, eRegFPR src2) %{
 3081     // Operand was loaded from memory into fp ST (stack top)
 3082     // FADD   ST,$src  /* D8 C0+i */
 3083     emit_opcode(cbuf, 0xD8);
 3084     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3085 
 3086     // FMUL  ST,src2  /* D8 C*+i */
 3087     emit_opcode(cbuf, 0xD8);
 3088     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3089   %}
 3090 
 3091 
 3092   enc_class MulFAddFreverse (eRegFPR src1, eRegFPR src2) %{
 3093     // Operand was loaded from memory into fp ST (stack top)
 3094     // FADD   ST,$src  /* D8 C0+i */
 3095     emit_opcode(cbuf, 0xD8);
 3096     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3097 
 3098     // FMULP  src2,ST  /* DE C8+i */
 3099     emit_opcode(cbuf, 0xDE);
 3100     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3101   %}
 3102 
 3103   // Atomically load the volatile long
 3104   enc_class enc_loadL_volatile( memory mem, stackSlotL dst ) %{
 3105     emit_opcode(cbuf,0xDF);
 3106     int rm_byte_opcode = 0x05;
 3107     int base     = $mem$$base;
 3108     int index    = $mem$$index;
 3109     int scale    = $mem$$scale;
 3110     int displace = $mem$$disp;
 3111     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3112     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3113     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3114   %}
 3115 
 3116   // Volatile Store Long.  Must be atomic, so move it into
 3117   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3118   // target address before the store (for null-ptr checks)
 3119   // so the memory operand is used twice in the encoding.
 3120   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3121     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3122     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3123     emit_opcode(cbuf,0xDF);
 3124     int rm_byte_opcode = 0x07;
 3125     int base     = $mem$$base;
 3126     int index    = $mem$$index;
 3127     int scale    = $mem$$scale;
 3128     int displace = $mem$$disp;
 3129     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3130     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3131   %}
 3132 
 3133 %}
 3134 
 3135 
 3136 //----------FRAME--------------------------------------------------------------
 3137 // Definition of frame structure and management information.
 3138 //
 3139 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3140 //                             |   (to get allocators register number
 3141 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3142 //  r   CALLER     |        |
 3143 //  o     |        +--------+      pad to even-align allocators stack-slot
 3144 //  w     V        |  pad0  |        numbers; owned by CALLER
 3145 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3146 //  h     ^        |   in   |  5
 3147 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3148 //  |     |        |        |  3
 3149 //  |     |        +--------+
 3150 //  V     |        | old out|      Empty on Intel, window on Sparc
 3151 //        |    old |preserve|      Must be even aligned.
 3152 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 3153 //        |        |   in   |  3   area for Intel ret address
 3154 //     Owned by    |preserve|      Empty on Sparc.
 3155 //       SELF      +--------+
 3156 //        |        |  pad2  |  2   pad to align old SP
 3157 //        |        +--------+  1
 3158 //        |        | locks  |  0
 3159 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 3160 //        |        |  pad1  | 11   pad to align new SP
 3161 //        |        +--------+
 3162 //        |        |        | 10
 3163 //        |        | spills |  9   spills
 3164 //        V        |        |  8   (pad0 slot for callee)
 3165 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 3166 //        ^        |  out   |  7
 3167 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 3168 //     Owned by    +--------+
 3169 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 3170 //        |    new |preserve|      Must be even-aligned.
 3171 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 3172 //        |        |        |
 3173 //
 3174 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 3175 //         known from SELF&#39;s arguments and the Java calling convention.
 3176 //         Region 6-7 is determined per call site.
 3177 // Note 2: If the calling convention leaves holes in the incoming argument
 3178 //         area, those holes are owned by SELF.  Holes in the outgoing area
 3179 //         are owned by the CALLEE.  Holes should not be nessecary in the
 3180 //         incoming area, as the Java calling convention is completely under
 3181 //         the control of the AD file.  Doubles can be sorted and packed to
 3182 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 3183 //         varargs C calling conventions.
 3184 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 3185 //         even aligned with pad0 as needed.
 3186 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 3187 //         region 6-11 is even aligned; it may be padded out more so that
 3188 //         the region from SP to FP meets the minimum stack alignment.
 3189 
 3190 frame %{
 3191   // What direction does stack grow in (assumed to be same for C &amp; Java)
 3192   stack_direction(TOWARDS_LOW);
 3193 
 3194   // These three registers define part of the calling convention
 3195   // between compiled code and the interpreter.
 3196   inline_cache_reg(EAX);                // Inline Cache Register
 3197   interpreter_method_oop_reg(EBX);      // Method Oop Register when calling interpreter
 3198 
 3199   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 3200   cisc_spilling_operand_name(indOffset32);
 3201 
 3202   // Number of stack slots consumed by locking an object
 3203   sync_stack_slots(1);
 3204 
 3205   // Compiled code&#39;s Frame Pointer
 3206   frame_pointer(ESP);
 3207   // Interpreter stores its frame pointer in a register which is
 3208   // stored to the stack by I2CAdaptors.
 3209   // I2CAdaptors convert from interpreted java to compiled java.
 3210   interpreter_frame_pointer(EBP);
 3211 
 3212   // Stack alignment requirement
 3213   // Alignment size in bytes (128-bit -&gt; 16 bytes)
 3214   stack_alignment(StackAlignmentInBytes);
 3215 
 3216   // Number of stack slots between incoming argument block and the start of
 3217   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3218   // EPILOG must remove this many slots.  Intel needs one slot for
 3219   // return address and one for rbp, (must save rbp)
 3220   in_preserve_stack_slots(2+VerifyStackAtCalls);
 3221 
 3222   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3223   // for calls to C.  Supports the var-args backing area for register parms.
 3224   varargs_C_out_slots_killed(0);
 3225 
 3226   // The after-PROLOG location of the return address.  Location of
 3227   // return address specifies a type (REG or STACK) and a number
 3228   // representing the register number (i.e. - use a register name) or
 3229   // stack slot.
 3230   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 3231   // Otherwise, it is above the locks and verification slot and alignment word
 3232   return_addr(STACK - 1 +
 3233               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 3234                         Compile::current()-&gt;fixed_slots()),
 3235                        stack_alignment_in_slots()));
 3236 
 3237   // Body of function which returns an integer array locating
 3238   // arguments either in registers or in stack slots.  Passed an array
 3239   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3240   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3241   // arguments for a CALLEE.  Incoming stack arguments are
 3242   // automatically biased by the preserve_stack_slots field above.
 3243   calling_convention %{
 3244     // No difference between ingoing/outgoing just pass false
 3245     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 3246   %}
 3247 
 3248 
 3249   // Body of function which returns an integer array locating
 3250   // arguments either in registers or in stack slots.  Passed an array
 3251   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3252   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3253   // arguments for a CALLEE.  Incoming stack arguments are
 3254   // automatically biased by the preserve_stack_slots field above.
 3255   c_calling_convention %{
 3256     // This is obviously always outgoing
 3257     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3258   %}
 3259 
 3260   // Location of C &amp; interpreter return values
 3261   c_return_value %{
 3262     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3263     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3264     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3265 
 3266     // in SSE2+ mode we want to keep the FPU stack clean so pretend
 3267     // that C functions return float and double results in XMM0.
 3268     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3269       return OptoRegPair(XMM0b_num,XMM0_num);
 3270     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=2 )
 3271       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3272 
 3273     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3274   %}
 3275 
 3276   // Location of return values
 3277   return_value %{
 3278     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3279     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3280     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3281     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3282       return OptoRegPair(XMM0b_num,XMM0_num);
 3283     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=1 )
 3284       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3285     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3286   %}
 3287 
 3288 %}
 3289 
 3290 //----------ATTRIBUTES---------------------------------------------------------
 3291 //----------Operand Attributes-------------------------------------------------
 3292 op_attrib op_cost(0);        // Required cost attribute
 3293 
 3294 //----------Instruction Attributes---------------------------------------------
 3295 ins_attrib ins_cost(100);       // Required cost attribute
 3296 ins_attrib ins_size(8);         // Required size attribute (in bits)
 3297 ins_attrib ins_short_branch(0); // Required flag: is this instruction a
 3298                                 // non-matching short branch variant of some
 3299                                                             // long branch?
 3300 ins_attrib ins_alignment(1);    // Required alignment attribute (must be a power of 2)
 3301                                 // specifies the alignment that some part of the instruction (not
 3302                                 // necessarily the start) requires.  If &gt; 1, a compute_padding()
 3303                                 // function must be provided for the instruction
 3304 
 3305 //----------OPERANDS-----------------------------------------------------------
 3306 // Operand definitions must precede instruction definitions for correct parsing
 3307 // in the ADLC because operands constitute user defined types which are used in
 3308 // instruction definitions.
 3309 
 3310 //----------Simple Operands----------------------------------------------------
 3311 // Immediate Operands
 3312 // Integer Immediate
 3313 operand immI() %{
 3314   match(ConI);
 3315 
 3316   op_cost(10);
 3317   format %{ %}
 3318   interface(CONST_INTER);
 3319 %}
 3320 
 3321 // Constant for test vs zero
 3322 operand immI0() %{
 3323   predicate(n-&gt;get_int() == 0);
 3324   match(ConI);
 3325 
 3326   op_cost(0);
 3327   format %{ %}
 3328   interface(CONST_INTER);
 3329 %}
 3330 
 3331 // Constant for increment
 3332 operand immI1() %{
 3333   predicate(n-&gt;get_int() == 1);
 3334   match(ConI);
 3335 
 3336   op_cost(0);
 3337   format %{ %}
 3338   interface(CONST_INTER);
 3339 %}
 3340 
 3341 // Constant for decrement
 3342 operand immI_M1() %{
 3343   predicate(n-&gt;get_int() == -1);
 3344   match(ConI);
 3345 
 3346   op_cost(0);
 3347   format %{ %}
 3348   interface(CONST_INTER);
 3349 %}
 3350 
 3351 // Valid scale values for addressing modes
 3352 operand immI2() %{
 3353   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3354   match(ConI);
 3355 
 3356   format %{ %}
 3357   interface(CONST_INTER);
 3358 %}
 3359 
 3360 operand immI8() %{
 3361   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3362   match(ConI);
 3363 
 3364   op_cost(5);
 3365   format %{ %}
 3366   interface(CONST_INTER);
 3367 %}
 3368 
 3369 operand immU8() %{
 3370   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 3371   match(ConI);
 3372 
 3373   op_cost(5);
 3374   format %{ %}
 3375   interface(CONST_INTER);
 3376 %}
 3377 
 3378 operand immI16() %{
 3379   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3380   match(ConI);
 3381 
 3382   op_cost(10);
 3383   format %{ %}
 3384   interface(CONST_INTER);
 3385 %}
 3386 
 3387 // Int Immediate non-negative
 3388 operand immU31()
 3389 %{
 3390   predicate(n-&gt;get_int() &gt;= 0);
 3391   match(ConI);
 3392 
 3393   op_cost(0);
 3394   format %{ %}
 3395   interface(CONST_INTER);
 3396 %}
 3397 
 3398 // Constant for long shifts
 3399 operand immI_32() %{
 3400   predicate( n-&gt;get_int() == 32 );
 3401   match(ConI);
 3402 
 3403   op_cost(0);
 3404   format %{ %}
 3405   interface(CONST_INTER);
 3406 %}
 3407 
 3408 operand immI_1_31() %{
 3409   predicate( n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31 );
 3410   match(ConI);
 3411 
 3412   op_cost(0);
 3413   format %{ %}
 3414   interface(CONST_INTER);
 3415 %}
 3416 
 3417 operand immI_32_63() %{
 3418   predicate( n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63 );
 3419   match(ConI);
 3420   op_cost(0);
 3421 
 3422   format %{ %}
 3423   interface(CONST_INTER);
 3424 %}
 3425 
 3426 operand immI_1() %{
 3427   predicate( n-&gt;get_int() == 1 );
 3428   match(ConI);
 3429 
 3430   op_cost(0);
 3431   format %{ %}
 3432   interface(CONST_INTER);
 3433 %}
 3434 
 3435 operand immI_2() %{
 3436   predicate( n-&gt;get_int() == 2 );
 3437   match(ConI);
 3438 
 3439   op_cost(0);
 3440   format %{ %}
 3441   interface(CONST_INTER);
 3442 %}
 3443 
 3444 operand immI_3() %{
 3445   predicate( n-&gt;get_int() == 3 );
 3446   match(ConI);
 3447 
 3448   op_cost(0);
 3449   format %{ %}
 3450   interface(CONST_INTER);
 3451 %}
 3452 
 3453 // Pointer Immediate
 3454 operand immP() %{
 3455   match(ConP);
 3456 
 3457   op_cost(10);
 3458   format %{ %}
 3459   interface(CONST_INTER);
 3460 %}
 3461 
 3462 // NULL Pointer Immediate
 3463 operand immP0() %{
 3464   predicate( n-&gt;get_ptr() == 0 );
 3465   match(ConP);
 3466   op_cost(0);
 3467 
 3468   format %{ %}
 3469   interface(CONST_INTER);
 3470 %}
 3471 
 3472 // Long Immediate
 3473 operand immL() %{
 3474   match(ConL);
 3475 
 3476   op_cost(20);
 3477   format %{ %}
 3478   interface(CONST_INTER);
 3479 %}
 3480 
 3481 // Long Immediate zero
 3482 operand immL0() %{
 3483   predicate( n-&gt;get_long() == 0L );
 3484   match(ConL);
 3485   op_cost(0);
 3486 
 3487   format %{ %}
 3488   interface(CONST_INTER);
 3489 %}
 3490 
 3491 // Long Immediate zero
 3492 operand immL_M1() %{
 3493   predicate( n-&gt;get_long() == -1L );
 3494   match(ConL);
 3495   op_cost(0);
 3496 
 3497   format %{ %}
 3498   interface(CONST_INTER);
 3499 %}
 3500 
 3501 // Long immediate from 0 to 127.
 3502 // Used for a shorter form of long mul by 10.
 3503 operand immL_127() %{
 3504   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 127));
 3505   match(ConL);
 3506   op_cost(0);
 3507 
 3508   format %{ %}
 3509   interface(CONST_INTER);
 3510 %}
 3511 
 3512 // Long Immediate: low 32-bit mask
 3513 operand immL_32bits() %{
 3514   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3515   match(ConL);
 3516   op_cost(0);
 3517 
 3518   format %{ %}
 3519   interface(CONST_INTER);
 3520 %}
 3521 
 3522 // Long Immediate: low 32-bit mask
 3523 operand immL32() %{
 3524   predicate(n-&gt;get_long() == (int)(n-&gt;get_long()));
 3525   match(ConL);
 3526   op_cost(20);
 3527 
 3528   format %{ %}
 3529   interface(CONST_INTER);
 3530 %}
 3531 
 3532 //Double Immediate zero
 3533 operand immDPR0() %{
 3534   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3535   // bug that generates code such that NaNs compare equal to 0.0
 3536   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 0.0 &amp;&amp; !g_isnan(n-&gt;getd()) );
 3537   match(ConD);
 3538 
 3539   op_cost(5);
 3540   format %{ %}
 3541   interface(CONST_INTER);
 3542 %}
 3543 
 3544 // Double Immediate one
 3545 operand immDPR1() %{
 3546   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 1.0 );
 3547   match(ConD);
 3548 
 3549   op_cost(5);
 3550   format %{ %}
 3551   interface(CONST_INTER);
 3552 %}
 3553 
 3554 // Double Immediate
 3555 operand immDPR() %{
 3556   predicate(UseSSE&lt;=1);
 3557   match(ConD);
 3558 
 3559   op_cost(5);
 3560   format %{ %}
 3561   interface(CONST_INTER);
 3562 %}
 3563 
 3564 operand immD() %{
 3565   predicate(UseSSE&gt;=2);
 3566   match(ConD);
 3567 
 3568   op_cost(5);
 3569   format %{ %}
 3570   interface(CONST_INTER);
 3571 %}
 3572 
 3573 // Double Immediate zero
 3574 operand immD0() %{
 3575   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3576   // bug that generates code such that NaNs compare equal to 0.0 AND do not
 3577   // compare equal to -0.0.
 3578   predicate( UseSSE&gt;=2 &amp;&amp; jlong_cast(n-&gt;getd()) == 0 );
 3579   match(ConD);
 3580 
 3581   format %{ %}
 3582   interface(CONST_INTER);
 3583 %}
 3584 
 3585 // Float Immediate zero
 3586 operand immFPR0() %{
 3587   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 0.0F);
 3588   match(ConF);
 3589 
 3590   op_cost(5);
 3591   format %{ %}
 3592   interface(CONST_INTER);
 3593 %}
 3594 
 3595 // Float Immediate one
 3596 operand immFPR1() %{
 3597   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 1.0F);
 3598   match(ConF);
 3599 
 3600   op_cost(5);
 3601   format %{ %}
 3602   interface(CONST_INTER);
 3603 %}
 3604 
 3605 // Float Immediate
 3606 operand immFPR() %{
 3607   predicate( UseSSE == 0 );
 3608   match(ConF);
 3609 
 3610   op_cost(5);
 3611   format %{ %}
 3612   interface(CONST_INTER);
 3613 %}
 3614 
 3615 // Float Immediate
 3616 operand immF() %{
 3617   predicate(UseSSE &gt;= 1);
 3618   match(ConF);
 3619 
 3620   op_cost(5);
 3621   format %{ %}
 3622   interface(CONST_INTER);
 3623 %}
 3624 
 3625 // Float Immediate zero.  Zero and not -0.0
 3626 operand immF0() %{
 3627   predicate( UseSSE &gt;= 1 &amp;&amp; jint_cast(n-&gt;getf()) == 0 );
 3628   match(ConF);
 3629 
 3630   op_cost(5);
 3631   format %{ %}
 3632   interface(CONST_INTER);
 3633 %}
 3634 
 3635 // Immediates for special shifts (sign extend)
 3636 
 3637 // Constants for increment
 3638 operand immI_16() %{
 3639   predicate( n-&gt;get_int() == 16 );
 3640   match(ConI);
 3641 
 3642   format %{ %}
 3643   interface(CONST_INTER);
 3644 %}
 3645 
 3646 operand immI_24() %{
 3647   predicate( n-&gt;get_int() == 24 );
 3648   match(ConI);
 3649 
 3650   format %{ %}
 3651   interface(CONST_INTER);
 3652 %}
 3653 
 3654 // Constant for byte-wide masking
 3655 operand immI_255() %{
 3656   predicate( n-&gt;get_int() == 255 );
 3657   match(ConI);
 3658 
 3659   format %{ %}
 3660   interface(CONST_INTER);
 3661 %}
 3662 
 3663 // Constant for short-wide masking
 3664 operand immI_65535() %{
 3665   predicate(n-&gt;get_int() == 65535);
 3666   match(ConI);
 3667 
 3668   format %{ %}
 3669   interface(CONST_INTER);
 3670 %}
 3671 
 3672 // Register Operands
 3673 // Integer Register
 3674 operand rRegI() %{
 3675   constraint(ALLOC_IN_RC(int_reg));
 3676   match(RegI);
 3677   match(xRegI);
 3678   match(eAXRegI);
 3679   match(eBXRegI);
 3680   match(eCXRegI);
 3681   match(eDXRegI);
 3682   match(eDIRegI);
 3683   match(eSIRegI);
 3684 
 3685   format %{ %}
 3686   interface(REG_INTER);
 3687 %}
 3688 
 3689 // Subset of Integer Register
 3690 operand xRegI(rRegI reg) %{
 3691   constraint(ALLOC_IN_RC(int_x_reg));
 3692   match(reg);
 3693   match(eAXRegI);
 3694   match(eBXRegI);
 3695   match(eCXRegI);
 3696   match(eDXRegI);
 3697 
 3698   format %{ %}
 3699   interface(REG_INTER);
 3700 %}
 3701 
 3702 // Special Registers
 3703 operand eAXRegI(xRegI reg) %{
 3704   constraint(ALLOC_IN_RC(eax_reg));
 3705   match(reg);
 3706   match(rRegI);
 3707 
 3708   format %{ &quot;EAX&quot; %}
 3709   interface(REG_INTER);
 3710 %}
 3711 
 3712 // Special Registers
 3713 operand eBXRegI(xRegI reg) %{
 3714   constraint(ALLOC_IN_RC(ebx_reg));
 3715   match(reg);
 3716   match(rRegI);
 3717 
 3718   format %{ &quot;EBX&quot; %}
 3719   interface(REG_INTER);
 3720 %}
 3721 
 3722 operand eCXRegI(xRegI reg) %{
 3723   constraint(ALLOC_IN_RC(ecx_reg));
 3724   match(reg);
 3725   match(rRegI);
 3726 
 3727   format %{ &quot;ECX&quot; %}
 3728   interface(REG_INTER);
 3729 %}
 3730 
 3731 operand eDXRegI(xRegI reg) %{
 3732   constraint(ALLOC_IN_RC(edx_reg));
 3733   match(reg);
 3734   match(rRegI);
 3735 
 3736   format %{ &quot;EDX&quot; %}
 3737   interface(REG_INTER);
 3738 %}
 3739 
 3740 operand eDIRegI(xRegI reg) %{
 3741   constraint(ALLOC_IN_RC(edi_reg));
 3742   match(reg);
 3743   match(rRegI);
 3744 
 3745   format %{ &quot;EDI&quot; %}
 3746   interface(REG_INTER);
 3747 %}
 3748 
 3749 operand naxRegI() %{
 3750   constraint(ALLOC_IN_RC(nax_reg));
 3751   match(RegI);
 3752   match(eCXRegI);
 3753   match(eDXRegI);
 3754   match(eSIRegI);
 3755   match(eDIRegI);
 3756 
 3757   format %{ %}
 3758   interface(REG_INTER);
 3759 %}
 3760 
 3761 operand nadxRegI() %{
 3762   constraint(ALLOC_IN_RC(nadx_reg));
 3763   match(RegI);
 3764   match(eBXRegI);
 3765   match(eCXRegI);
 3766   match(eSIRegI);
 3767   match(eDIRegI);
 3768 
 3769   format %{ %}
 3770   interface(REG_INTER);
 3771 %}
 3772 
 3773 operand ncxRegI() %{
 3774   constraint(ALLOC_IN_RC(ncx_reg));
 3775   match(RegI);
 3776   match(eAXRegI);
 3777   match(eDXRegI);
 3778   match(eSIRegI);
 3779   match(eDIRegI);
 3780 
 3781   format %{ %}
 3782   interface(REG_INTER);
 3783 %}
 3784 
 3785 // // This operand was used by cmpFastUnlock, but conflicted with &#39;object&#39; reg
 3786 // //
 3787 operand eSIRegI(xRegI reg) %{
 3788    constraint(ALLOC_IN_RC(esi_reg));
 3789    match(reg);
 3790    match(rRegI);
 3791 
 3792    format %{ &quot;ESI&quot; %}
 3793    interface(REG_INTER);
 3794 %}
 3795 
 3796 // Pointer Register
 3797 operand anyRegP() %{
 3798   constraint(ALLOC_IN_RC(any_reg));
 3799   match(RegP);
 3800   match(eAXRegP);
 3801   match(eBXRegP);
 3802   match(eCXRegP);
 3803   match(eDIRegP);
 3804   match(eRegP);
 3805 
 3806   format %{ %}
 3807   interface(REG_INTER);
 3808 %}
 3809 
 3810 operand eRegP() %{
 3811   constraint(ALLOC_IN_RC(int_reg));
 3812   match(RegP);
 3813   match(eAXRegP);
 3814   match(eBXRegP);
 3815   match(eCXRegP);
 3816   match(eDIRegP);
 3817 
 3818   format %{ %}
 3819   interface(REG_INTER);
 3820 %}
 3821 
 3822 // On windows95, EBP is not safe to use for implicit null tests.
 3823 operand eRegP_no_EBP() %{
 3824   constraint(ALLOC_IN_RC(int_reg_no_ebp));
 3825   match(RegP);
 3826   match(eAXRegP);
 3827   match(eBXRegP);
 3828   match(eCXRegP);
 3829   match(eDIRegP);
 3830 
 3831   op_cost(100);
 3832   format %{ %}
 3833   interface(REG_INTER);
 3834 %}
 3835 
 3836 operand naxRegP() %{
 3837   constraint(ALLOC_IN_RC(nax_reg));
 3838   match(RegP);
 3839   match(eBXRegP);
 3840   match(eDXRegP);
 3841   match(eCXRegP);
 3842   match(eSIRegP);
 3843   match(eDIRegP);
 3844 
 3845   format %{ %}
 3846   interface(REG_INTER);
 3847 %}
 3848 
 3849 operand nabxRegP() %{
 3850   constraint(ALLOC_IN_RC(nabx_reg));
 3851   match(RegP);
 3852   match(eCXRegP);
 3853   match(eDXRegP);
 3854   match(eSIRegP);
 3855   match(eDIRegP);
 3856 
 3857   format %{ %}
 3858   interface(REG_INTER);
 3859 %}
 3860 
 3861 operand pRegP() %{
 3862   constraint(ALLOC_IN_RC(p_reg));
 3863   match(RegP);
 3864   match(eBXRegP);
 3865   match(eDXRegP);
 3866   match(eSIRegP);
 3867   match(eDIRegP);
 3868 
 3869   format %{ %}
 3870   interface(REG_INTER);
 3871 %}
 3872 
 3873 // Special Registers
 3874 // Return a pointer value
 3875 operand eAXRegP(eRegP reg) %{
 3876   constraint(ALLOC_IN_RC(eax_reg));
 3877   match(reg);
 3878   format %{ &quot;EAX&quot; %}
 3879   interface(REG_INTER);
 3880 %}
 3881 
 3882 // Used in AtomicAdd
 3883 operand eBXRegP(eRegP reg) %{
 3884   constraint(ALLOC_IN_RC(ebx_reg));
 3885   match(reg);
 3886   format %{ &quot;EBX&quot; %}
 3887   interface(REG_INTER);
 3888 %}
 3889 
 3890 // Tail-call (interprocedural jump) to interpreter
 3891 operand eCXRegP(eRegP reg) %{
 3892   constraint(ALLOC_IN_RC(ecx_reg));
 3893   match(reg);
 3894   format %{ &quot;ECX&quot; %}
 3895   interface(REG_INTER);
 3896 %}
 3897 
 3898 operand eDXRegP(eRegP reg) %{
 3899   constraint(ALLOC_IN_RC(edx_reg));
 3900   match(reg);
 3901   format %{ &quot;EDX&quot; %}
 3902   interface(REG_INTER);
 3903 %}
 3904 
 3905 operand eSIRegP(eRegP reg) %{
 3906   constraint(ALLOC_IN_RC(esi_reg));
 3907   match(reg);
 3908   format %{ &quot;ESI&quot; %}
 3909   interface(REG_INTER);
 3910 %}
 3911 
 3912 // Used in rep stosw
 3913 operand eDIRegP(eRegP reg) %{
 3914   constraint(ALLOC_IN_RC(edi_reg));
 3915   match(reg);
 3916   format %{ &quot;EDI&quot; %}
 3917   interface(REG_INTER);
 3918 %}
 3919 
 3920 operand eRegL() %{
 3921   constraint(ALLOC_IN_RC(long_reg));
 3922   match(RegL);
 3923   match(eADXRegL);
 3924 
 3925   format %{ %}
 3926   interface(REG_INTER);
 3927 %}
 3928 
 3929 operand eADXRegL( eRegL reg ) %{
 3930   constraint(ALLOC_IN_RC(eadx_reg));
 3931   match(reg);
 3932 
 3933   format %{ &quot;EDX:EAX&quot; %}
 3934   interface(REG_INTER);
 3935 %}
 3936 
 3937 operand eBCXRegL( eRegL reg ) %{
 3938   constraint(ALLOC_IN_RC(ebcx_reg));
 3939   match(reg);
 3940 
 3941   format %{ &quot;EBX:ECX&quot; %}
 3942   interface(REG_INTER);
 3943 %}
 3944 
 3945 // Special case for integer high multiply
 3946 operand eADXRegL_low_only() %{
 3947   constraint(ALLOC_IN_RC(eadx_reg));
 3948   match(RegL);
 3949 
 3950   format %{ &quot;EAX&quot; %}
 3951   interface(REG_INTER);
 3952 %}
 3953 
 3954 // Flags register, used as output of compare instructions
 3955 operand eFlagsReg() %{
 3956   constraint(ALLOC_IN_RC(int_flags));
 3957   match(RegFlags);
 3958 
 3959   format %{ &quot;EFLAGS&quot; %}
 3960   interface(REG_INTER);
 3961 %}
 3962 
 3963 // Flags register, used as output of FLOATING POINT compare instructions
 3964 operand eFlagsRegU() %{
 3965   constraint(ALLOC_IN_RC(int_flags));
 3966   match(RegFlags);
 3967 
 3968   format %{ &quot;EFLAGS_U&quot; %}
 3969   interface(REG_INTER);
 3970 %}
 3971 
 3972 operand eFlagsRegUCF() %{
 3973   constraint(ALLOC_IN_RC(int_flags));
 3974   match(RegFlags);
 3975   predicate(false);
 3976 
 3977   format %{ &quot;EFLAGS_U_CF&quot; %}
 3978   interface(REG_INTER);
 3979 %}
 3980 
 3981 // Condition Code Register used by long compare
 3982 operand flagsReg_long_LTGE() %{
 3983   constraint(ALLOC_IN_RC(int_flags));
 3984   match(RegFlags);
 3985   format %{ &quot;FLAGS_LTGE&quot; %}
 3986   interface(REG_INTER);
 3987 %}
 3988 operand flagsReg_long_EQNE() %{
 3989   constraint(ALLOC_IN_RC(int_flags));
 3990   match(RegFlags);
 3991   format %{ &quot;FLAGS_EQNE&quot; %}
 3992   interface(REG_INTER);
 3993 %}
 3994 operand flagsReg_long_LEGT() %{
 3995   constraint(ALLOC_IN_RC(int_flags));
 3996   match(RegFlags);
 3997   format %{ &quot;FLAGS_LEGT&quot; %}
 3998   interface(REG_INTER);
 3999 %}
 4000 
 4001 // Condition Code Register used by unsigned long compare
 4002 operand flagsReg_ulong_LTGE() %{
 4003   constraint(ALLOC_IN_RC(int_flags));
 4004   match(RegFlags);
 4005   format %{ &quot;FLAGS_U_LTGE&quot; %}
 4006   interface(REG_INTER);
 4007 %}
 4008 operand flagsReg_ulong_EQNE() %{
 4009   constraint(ALLOC_IN_RC(int_flags));
 4010   match(RegFlags);
 4011   format %{ &quot;FLAGS_U_EQNE&quot; %}
 4012   interface(REG_INTER);
 4013 %}
 4014 operand flagsReg_ulong_LEGT() %{
 4015   constraint(ALLOC_IN_RC(int_flags));
 4016   match(RegFlags);
 4017   format %{ &quot;FLAGS_U_LEGT&quot; %}
 4018   interface(REG_INTER);
 4019 %}
 4020 
 4021 // Float register operands
 4022 operand regDPR() %{
 4023   predicate( UseSSE &lt; 2 );
 4024   constraint(ALLOC_IN_RC(fp_dbl_reg));
 4025   match(RegD);
 4026   match(regDPR1);
 4027   match(regDPR2);
 4028   format %{ %}
 4029   interface(REG_INTER);
 4030 %}
 4031 
 4032 operand regDPR1(regDPR reg) %{
 4033   predicate( UseSSE &lt; 2 );
 4034   constraint(ALLOC_IN_RC(fp_dbl_reg0));
 4035   match(reg);
 4036   format %{ &quot;FPR1&quot; %}
 4037   interface(REG_INTER);
 4038 %}
 4039 
 4040 operand regDPR2(regDPR reg) %{
 4041   predicate( UseSSE &lt; 2 );
 4042   constraint(ALLOC_IN_RC(fp_dbl_reg1));
 4043   match(reg);
 4044   format %{ &quot;FPR2&quot; %}
 4045   interface(REG_INTER);
 4046 %}
 4047 
 4048 operand regnotDPR1(regDPR reg) %{
 4049   predicate( UseSSE &lt; 2 );
 4050   constraint(ALLOC_IN_RC(fp_dbl_notreg0));
 4051   match(reg);
 4052   format %{ %}
 4053   interface(REG_INTER);
 4054 %}
 4055 
 4056 // Float register operands
 4057 operand regFPR() %{
 4058   predicate( UseSSE &lt; 2 );
 4059   constraint(ALLOC_IN_RC(fp_flt_reg));
 4060   match(RegF);
 4061   match(regFPR1);
 4062   format %{ %}
 4063   interface(REG_INTER);
 4064 %}
 4065 
 4066 // Float register operands
 4067 operand regFPR1(regFPR reg) %{
 4068   predicate( UseSSE &lt; 2 );
 4069   constraint(ALLOC_IN_RC(fp_flt_reg0));
 4070   match(reg);
 4071   format %{ &quot;FPR1&quot; %}
 4072   interface(REG_INTER);
 4073 %}
 4074 
 4075 // XMM Float register operands
 4076 operand regF() %{
 4077   predicate( UseSSE&gt;=1 );
 4078   constraint(ALLOC_IN_RC(float_reg_legacy));
 4079   match(RegF);
 4080   format %{ %}
 4081   interface(REG_INTER);
 4082 %}
 4083 
 4084 // Float register operands
 4085 operand vlRegF() %{
 4086    constraint(ALLOC_IN_RC(float_reg_vl));
 4087    match(RegF);
 4088 
 4089    format %{ %}
 4090    interface(REG_INTER);
 4091 %}
 4092 
 4093 // XMM Double register operands
 4094 operand regD() %{
 4095   predicate( UseSSE&gt;=2 );
 4096   constraint(ALLOC_IN_RC(double_reg_legacy));
 4097   match(RegD);
 4098   format %{ %}
 4099   interface(REG_INTER);
 4100 %}
 4101 
 4102 // Double register operands
 4103 operand vlRegD() %{
 4104    constraint(ALLOC_IN_RC(double_reg_vl));
 4105    match(RegD);
 4106 
 4107    format %{ %}
 4108    interface(REG_INTER);
 4109 %}
 4110 
 4111 //----------Memory Operands----------------------------------------------------
 4112 // Direct Memory Operand
 4113 operand direct(immP addr) %{
 4114   match(addr);
 4115 
 4116   format %{ &quot;[$addr]&quot; %}
 4117   interface(MEMORY_INTER) %{
 4118     base(0xFFFFFFFF);
 4119     index(0x4);
 4120     scale(0x0);
 4121     disp($addr);
 4122   %}
 4123 %}
 4124 
 4125 // Indirect Memory Operand
 4126 operand indirect(eRegP reg) %{
 4127   constraint(ALLOC_IN_RC(int_reg));
 4128   match(reg);
 4129 
 4130   format %{ &quot;[$reg]&quot; %}
 4131   interface(MEMORY_INTER) %{
 4132     base($reg);
 4133     index(0x4);
 4134     scale(0x0);
 4135     disp(0x0);
 4136   %}
 4137 %}
 4138 
 4139 // Indirect Memory Plus Short Offset Operand
 4140 operand indOffset8(eRegP reg, immI8 off) %{
 4141   match(AddP reg off);
 4142 
 4143   format %{ &quot;[$reg + $off]&quot; %}
 4144   interface(MEMORY_INTER) %{
 4145     base($reg);
 4146     index(0x4);
 4147     scale(0x0);
 4148     disp($off);
 4149   %}
 4150 %}
 4151 
 4152 // Indirect Memory Plus Long Offset Operand
 4153 operand indOffset32(eRegP reg, immI off) %{
 4154   match(AddP reg off);
 4155 
 4156   format %{ &quot;[$reg + $off]&quot; %}
 4157   interface(MEMORY_INTER) %{
 4158     base($reg);
 4159     index(0x4);
 4160     scale(0x0);
 4161     disp($off);
 4162   %}
 4163 %}
 4164 
 4165 // Indirect Memory Plus Long Offset Operand
 4166 operand indOffset32X(rRegI reg, immP off) %{
 4167   match(AddP off reg);
 4168 
 4169   format %{ &quot;[$reg + $off]&quot; %}
 4170   interface(MEMORY_INTER) %{
 4171     base($reg);
 4172     index(0x4);
 4173     scale(0x0);
 4174     disp($off);
 4175   %}
 4176 %}
 4177 
 4178 // Indirect Memory Plus Index Register Plus Offset Operand
 4179 operand indIndexOffset(eRegP reg, rRegI ireg, immI off) %{
 4180   match(AddP (AddP reg ireg) off);
 4181 
 4182   op_cost(10);
 4183   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4184   interface(MEMORY_INTER) %{
 4185     base($reg);
 4186     index($ireg);
 4187     scale(0x0);
 4188     disp($off);
 4189   %}
 4190 %}
 4191 
 4192 // Indirect Memory Plus Index Register Plus Offset Operand
 4193 operand indIndex(eRegP reg, rRegI ireg) %{
 4194   match(AddP reg ireg);
 4195 
 4196   op_cost(10);
 4197   format %{&quot;[$reg + $ireg]&quot; %}
 4198   interface(MEMORY_INTER) %{
 4199     base($reg);
 4200     index($ireg);
 4201     scale(0x0);
 4202     disp(0x0);
 4203   %}
 4204 %}
 4205 
 4206 // // -------------------------------------------------------------------------
 4207 // // 486 architecture doesn&#39;t support &quot;scale * index + offset&quot; with out a base
 4208 // // -------------------------------------------------------------------------
 4209 // // Scaled Memory Operands
 4210 // // Indirect Memory Times Scale Plus Offset Operand
 4211 // operand indScaleOffset(immP off, rRegI ireg, immI2 scale) %{
 4212 //   match(AddP off (LShiftI ireg scale));
 4213 //
 4214 //   op_cost(10);
 4215 //   format %{&quot;[$off + $ireg &lt;&lt; $scale]&quot; %}
 4216 //   interface(MEMORY_INTER) %{
 4217 //     base(0x4);
 4218 //     index($ireg);
 4219 //     scale($scale);
 4220 //     disp($off);
 4221 //   %}
 4222 // %}
 4223 
 4224 // Indirect Memory Times Scale Plus Index Register
 4225 operand indIndexScale(eRegP reg, rRegI ireg, immI2 scale) %{
 4226   match(AddP reg (LShiftI ireg scale));
 4227 
 4228   op_cost(10);
 4229   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4230   interface(MEMORY_INTER) %{
 4231     base($reg);
 4232     index($ireg);
 4233     scale($scale);
 4234     disp(0x0);
 4235   %}
 4236 %}
 4237 
 4238 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4239 operand indIndexScaleOffset(eRegP reg, immI off, rRegI ireg, immI2 scale) %{
 4240   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4241 
 4242   op_cost(10);
 4243   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4244   interface(MEMORY_INTER) %{
 4245     base($reg);
 4246     index($ireg);
 4247     scale($scale);
 4248     disp($off);
 4249   %}
 4250 %}
 4251 
 4252 //----------Load Long Memory Operands------------------------------------------
 4253 // The load-long idiom will use it&#39;s address expression again after loading
 4254 // the first word of the long.  If the load-long destination overlaps with
 4255 // registers used in the addressing expression, the 2nd half will be loaded
 4256 // from a clobbered address.  Fix this by requiring that load-long use
 4257 // address registers that do not overlap with the load-long target.
 4258 
 4259 // load-long support
 4260 operand load_long_RegP() %{
 4261   constraint(ALLOC_IN_RC(esi_reg));
 4262   match(RegP);
 4263   match(eSIRegP);
 4264   op_cost(100);
 4265   format %{  %}
 4266   interface(REG_INTER);
 4267 %}
 4268 
 4269 // Indirect Memory Operand Long
 4270 operand load_long_indirect(load_long_RegP reg) %{
 4271   constraint(ALLOC_IN_RC(esi_reg));
 4272   match(reg);
 4273 
 4274   format %{ &quot;[$reg]&quot; %}
 4275   interface(MEMORY_INTER) %{
 4276     base($reg);
 4277     index(0x4);
 4278     scale(0x0);
 4279     disp(0x0);
 4280   %}
 4281 %}
 4282 
 4283 // Indirect Memory Plus Long Offset Operand
 4284 operand load_long_indOffset32(load_long_RegP reg, immI off) %{
 4285   match(AddP reg off);
 4286 
 4287   format %{ &quot;[$reg + $off]&quot; %}
 4288   interface(MEMORY_INTER) %{
 4289     base($reg);
 4290     index(0x4);
 4291     scale(0x0);
 4292     disp($off);
 4293   %}
 4294 %}
 4295 
 4296 opclass load_long_memory(load_long_indirect, load_long_indOffset32);
 4297 
 4298 
 4299 //----------Special Memory Operands--------------------------------------------
 4300 // Stack Slot Operand - This operand is used for loading and storing temporary
 4301 //                      values on the stack where a match requires a value to
 4302 //                      flow through memory.
 4303 operand stackSlotP(sRegP reg) %{
 4304   constraint(ALLOC_IN_RC(stack_slots));
 4305   // No match rule because this operand is only generated in matching
 4306   format %{ &quot;[$reg]&quot; %}
 4307   interface(MEMORY_INTER) %{
 4308     base(0x4);   // ESP
 4309     index(0x4);  // No Index
 4310     scale(0x0);  // No Scale
 4311     disp($reg);  // Stack Offset
 4312   %}
 4313 %}
 4314 
 4315 operand stackSlotI(sRegI reg) %{
 4316   constraint(ALLOC_IN_RC(stack_slots));
 4317   // No match rule because this operand is only generated in matching
 4318   format %{ &quot;[$reg]&quot; %}
 4319   interface(MEMORY_INTER) %{
 4320     base(0x4);   // ESP
 4321     index(0x4);  // No Index
 4322     scale(0x0);  // No Scale
 4323     disp($reg);  // Stack Offset
 4324   %}
 4325 %}
 4326 
 4327 operand stackSlotF(sRegF reg) %{
 4328   constraint(ALLOC_IN_RC(stack_slots));
 4329   // No match rule because this operand is only generated in matching
 4330   format %{ &quot;[$reg]&quot; %}
 4331   interface(MEMORY_INTER) %{
 4332     base(0x4);   // ESP
 4333     index(0x4);  // No Index
 4334     scale(0x0);  // No Scale
 4335     disp($reg);  // Stack Offset
 4336   %}
 4337 %}
 4338 
 4339 operand stackSlotD(sRegD reg) %{
 4340   constraint(ALLOC_IN_RC(stack_slots));
 4341   // No match rule because this operand is only generated in matching
 4342   format %{ &quot;[$reg]&quot; %}
 4343   interface(MEMORY_INTER) %{
 4344     base(0x4);   // ESP
 4345     index(0x4);  // No Index
 4346     scale(0x0);  // No Scale
 4347     disp($reg);  // Stack Offset
 4348   %}
 4349 %}
 4350 
 4351 operand stackSlotL(sRegL reg) %{
 4352   constraint(ALLOC_IN_RC(stack_slots));
 4353   // No match rule because this operand is only generated in matching
 4354   format %{ &quot;[$reg]&quot; %}
 4355   interface(MEMORY_INTER) %{
 4356     base(0x4);   // ESP
 4357     index(0x4);  // No Index
 4358     scale(0x0);  // No Scale
 4359     disp($reg);  // Stack Offset
 4360   %}
 4361 %}
 4362 
 4363 //----------Memory Operands - Win95 Implicit Null Variants----------------
 4364 // Indirect Memory Operand
 4365 operand indirect_win95_safe(eRegP_no_EBP reg)
 4366 %{
 4367   constraint(ALLOC_IN_RC(int_reg));
 4368   match(reg);
 4369 
 4370   op_cost(100);
 4371   format %{ &quot;[$reg]&quot; %}
 4372   interface(MEMORY_INTER) %{
 4373     base($reg);
 4374     index(0x4);
 4375     scale(0x0);
 4376     disp(0x0);
 4377   %}
 4378 %}
 4379 
 4380 // Indirect Memory Plus Short Offset Operand
 4381 operand indOffset8_win95_safe(eRegP_no_EBP reg, immI8 off)
 4382 %{
 4383   match(AddP reg off);
 4384 
 4385   op_cost(100);
 4386   format %{ &quot;[$reg + $off]&quot; %}
 4387   interface(MEMORY_INTER) %{
 4388     base($reg);
 4389     index(0x4);
 4390     scale(0x0);
 4391     disp($off);
 4392   %}
 4393 %}
 4394 
 4395 // Indirect Memory Plus Long Offset Operand
 4396 operand indOffset32_win95_safe(eRegP_no_EBP reg, immI off)
 4397 %{
 4398   match(AddP reg off);
 4399 
 4400   op_cost(100);
 4401   format %{ &quot;[$reg + $off]&quot; %}
 4402   interface(MEMORY_INTER) %{
 4403     base($reg);
 4404     index(0x4);
 4405     scale(0x0);
 4406     disp($off);
 4407   %}
 4408 %}
 4409 
 4410 // Indirect Memory Plus Index Register Plus Offset Operand
 4411 operand indIndexOffset_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI off)
 4412 %{
 4413   match(AddP (AddP reg ireg) off);
 4414 
 4415   op_cost(100);
 4416   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4417   interface(MEMORY_INTER) %{
 4418     base($reg);
 4419     index($ireg);
 4420     scale(0x0);
 4421     disp($off);
 4422   %}
 4423 %}
 4424 
 4425 // Indirect Memory Times Scale Plus Index Register
 4426 operand indIndexScale_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI2 scale)
 4427 %{
 4428   match(AddP reg (LShiftI ireg scale));
 4429 
 4430   op_cost(100);
 4431   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4432   interface(MEMORY_INTER) %{
 4433     base($reg);
 4434     index($ireg);
 4435     scale($scale);
 4436     disp(0x0);
 4437   %}
 4438 %}
 4439 
 4440 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4441 operand indIndexScaleOffset_win95_safe(eRegP_no_EBP reg, immI off, rRegI ireg, immI2 scale)
 4442 %{
 4443   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4444 
 4445   op_cost(100);
 4446   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4447   interface(MEMORY_INTER) %{
 4448     base($reg);
 4449     index($ireg);
 4450     scale($scale);
 4451     disp($off);
 4452   %}
 4453 %}
 4454 
 4455 //----------Conditional Branch Operands----------------------------------------
 4456 // Comparison Op  - This is the operation of the comparison, and is limited to
 4457 //                  the following set of codes:
 4458 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4459 //
 4460 // Other attributes of the comparison, such as unsignedness, are specified
 4461 // by the comparison instruction that sets a condition code flags register.
 4462 // That result is represented by a flags operand whose subtype is appropriate
 4463 // to the unsignedness (etc.) of the comparison.
 4464 //
 4465 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4466 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4467 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4468 
 4469 // Comparision Code
 4470 operand cmpOp() %{
 4471   match(Bool);
 4472 
 4473   format %{ &quot;&quot; %}
 4474   interface(COND_INTER) %{
 4475     equal(0x4, &quot;e&quot;);
 4476     not_equal(0x5, &quot;ne&quot;);
 4477     less(0xC, &quot;l&quot;);
 4478     greater_equal(0xD, &quot;ge&quot;);
 4479     less_equal(0xE, &quot;le&quot;);
 4480     greater(0xF, &quot;g&quot;);
 4481     overflow(0x0, &quot;o&quot;);
 4482     no_overflow(0x1, &quot;no&quot;);
 4483   %}
 4484 %}
 4485 
 4486 // Comparison Code, unsigned compare.  Used by FP also, with
 4487 // C2 (unordered) turned into GT or LT already.  The other bits
 4488 // C0 and C3 are turned into Carry &amp; Zero flags.
 4489 operand cmpOpU() %{
 4490   match(Bool);
 4491 
 4492   format %{ &quot;&quot; %}
 4493   interface(COND_INTER) %{
 4494     equal(0x4, &quot;e&quot;);
 4495     not_equal(0x5, &quot;ne&quot;);
 4496     less(0x2, &quot;b&quot;);
 4497     greater_equal(0x3, &quot;nb&quot;);
 4498     less_equal(0x6, &quot;be&quot;);
 4499     greater(0x7, &quot;nbe&quot;);
 4500     overflow(0x0, &quot;o&quot;);
 4501     no_overflow(0x1, &quot;no&quot;);
 4502   %}
 4503 %}
 4504 
 4505 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4506 operand cmpOpUCF() %{
 4507   match(Bool);
 4508   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4509             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4510             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4511             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4512   format %{ &quot;&quot; %}
 4513   interface(COND_INTER) %{
 4514     equal(0x4, &quot;e&quot;);
 4515     not_equal(0x5, &quot;ne&quot;);
 4516     less(0x2, &quot;b&quot;);
 4517     greater_equal(0x3, &quot;nb&quot;);
 4518     less_equal(0x6, &quot;be&quot;);
 4519     greater(0x7, &quot;nbe&quot;);
 4520     overflow(0x0, &quot;o&quot;);
 4521     no_overflow(0x1, &quot;no&quot;);
 4522   %}
 4523 %}
 4524 
 4525 
 4526 // Floating comparisons that can be fixed up with extra conditional jumps
 4527 operand cmpOpUCF2() %{
 4528   match(Bool);
 4529   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4530             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4531   format %{ &quot;&quot; %}
 4532   interface(COND_INTER) %{
 4533     equal(0x4, &quot;e&quot;);
 4534     not_equal(0x5, &quot;ne&quot;);
 4535     less(0x2, &quot;b&quot;);
 4536     greater_equal(0x3, &quot;nb&quot;);
 4537     less_equal(0x6, &quot;be&quot;);
 4538     greater(0x7, &quot;nbe&quot;);
 4539     overflow(0x0, &quot;o&quot;);
 4540     no_overflow(0x1, &quot;no&quot;);
 4541   %}
 4542 %}
 4543 
 4544 // Comparison Code for FP conditional move
 4545 operand cmpOp_fcmov() %{
 4546   match(Bool);
 4547 
 4548   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4549             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4550   format %{ &quot;&quot; %}
 4551   interface(COND_INTER) %{
 4552     equal        (0x0C8);
 4553     not_equal    (0x1C8);
 4554     less         (0x0C0);
 4555     greater_equal(0x1C0);
 4556     less_equal   (0x0D0);
 4557     greater      (0x1D0);
 4558     overflow(0x0, &quot;o&quot;); // not really supported by the instruction
 4559     no_overflow(0x1, &quot;no&quot;); // not really supported by the instruction
 4560   %}
 4561 %}
 4562 
 4563 // Comparison Code used in long compares
 4564 operand cmpOp_commute() %{
 4565   match(Bool);
 4566 
 4567   format %{ &quot;&quot; %}
 4568   interface(COND_INTER) %{
 4569     equal(0x4, &quot;e&quot;);
 4570     not_equal(0x5, &quot;ne&quot;);
 4571     less(0xF, &quot;g&quot;);
 4572     greater_equal(0xE, &quot;le&quot;);
 4573     less_equal(0xD, &quot;ge&quot;);
 4574     greater(0xC, &quot;l&quot;);
 4575     overflow(0x0, &quot;o&quot;);
 4576     no_overflow(0x1, &quot;no&quot;);
 4577   %}
 4578 %}
 4579 
 4580 // Comparison Code used in unsigned long compares
 4581 operand cmpOpU_commute() %{
 4582   match(Bool);
 4583 
 4584   format %{ &quot;&quot; %}
 4585   interface(COND_INTER) %{
 4586     equal(0x4, &quot;e&quot;);
 4587     not_equal(0x5, &quot;ne&quot;);
 4588     less(0x7, &quot;nbe&quot;);
 4589     greater_equal(0x6, &quot;be&quot;);
 4590     less_equal(0x3, &quot;nb&quot;);
 4591     greater(0x2, &quot;b&quot;);
 4592     overflow(0x0, &quot;o&quot;);
 4593     no_overflow(0x1, &quot;no&quot;);
 4594   %}
 4595 %}
 4596 
 4597 //----------OPERAND CLASSES----------------------------------------------------
 4598 // Operand Classes are groups of operands that are used as to simplify
 4599 // instruction definitions by not requiring the AD writer to specify separate
 4600 // instructions for every form of operand when the instruction accepts
 4601 // multiple operand types with the same basic encoding and format.  The classic
 4602 // case of this is memory operands.
 4603 
 4604 opclass memory(direct, indirect, indOffset8, indOffset32, indOffset32X, indIndexOffset,
 4605                indIndex, indIndexScale, indIndexScaleOffset);
 4606 
 4607 // Long memory operations are encoded in 2 instructions and a +4 offset.
 4608 // This means some kind of offset is always required and you cannot use
 4609 // an oop as the offset (done when working on static globals).
 4610 opclass long_memory(direct, indirect, indOffset8, indOffset32, indIndexOffset,
 4611                     indIndex, indIndexScale, indIndexScaleOffset);
 4612 
 4613 
 4614 //----------PIPELINE-----------------------------------------------------------
 4615 // Rules which define the behavior of the target architectures pipeline.
 4616 pipeline %{
 4617 
 4618 //----------ATTRIBUTES---------------------------------------------------------
 4619 attributes %{
 4620   variable_size_instructions;        // Fixed size instructions
 4621   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4622   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4623   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4624   instruction_fetch_units = 1;       // of 16 bytes
 4625 
 4626   // List of nop instructions
 4627   nops( MachNop );
 4628 %}
 4629 
 4630 //----------RESOURCES----------------------------------------------------------
 4631 // Resources are the functional units available to the machine
 4632 
 4633 // Generic P2/P3 pipeline
 4634 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4635 // 3 instructions decoded per cycle.
 4636 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4637 // 2 ALU op, only ALU0 handles mul/div instructions.
 4638 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4639            MS0, MS1, MEM = MS0 | MS1,
 4640            BR, FPU,
 4641            ALU0, ALU1, ALU = ALU0 | ALU1 );
 4642 
 4643 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4644 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4645 
 4646 // Generic P2/P3 pipeline
 4647 pipe_desc(S0, S1, S2, S3, S4, S5);
 4648 
 4649 //----------PIPELINE CLASSES---------------------------------------------------
 4650 // Pipeline Classes describe the stages in which input and output are
 4651 // referenced by the hardware pipeline.
 4652 
 4653 // Naming convention: ialu or fpu
 4654 // Then: _reg
 4655 // Then: _reg if there is a 2nd register
 4656 // Then: _long if it&#39;s a pair of instructions implementing a long
 4657 // Then: _fat if it requires the big decoder
 4658 //   Or: _mem if it requires the big decoder and a memory unit.
 4659 
 4660 // Integer ALU reg operation
 4661 pipe_class ialu_reg(rRegI dst) %{
 4662     single_instruction;
 4663     dst    : S4(write);
 4664     dst    : S3(read);
 4665     DECODE : S0;        // any decoder
 4666     ALU    : S3;        // any alu
 4667 %}
 4668 
 4669 // Long ALU reg operation
 4670 pipe_class ialu_reg_long(eRegL dst) %{
 4671     instruction_count(2);
 4672     dst    : S4(write);
 4673     dst    : S3(read);
 4674     DECODE : S0(2);     // any 2 decoders
 4675     ALU    : S3(2);     // both alus
 4676 %}
 4677 
 4678 // Integer ALU reg operation using big decoder
 4679 pipe_class ialu_reg_fat(rRegI dst) %{
 4680     single_instruction;
 4681     dst    : S4(write);
 4682     dst    : S3(read);
 4683     D0     : S0;        // big decoder only
 4684     ALU    : S3;        // any alu
 4685 %}
 4686 
 4687 // Long ALU reg operation using big decoder
 4688 pipe_class ialu_reg_long_fat(eRegL dst) %{
 4689     instruction_count(2);
 4690     dst    : S4(write);
 4691     dst    : S3(read);
 4692     D0     : S0(2);     // big decoder only; twice
 4693     ALU    : S3(2);     // any 2 alus
 4694 %}
 4695 
 4696 // Integer ALU reg-reg operation
 4697 pipe_class ialu_reg_reg(rRegI dst, rRegI src) %{
 4698     single_instruction;
 4699     dst    : S4(write);
 4700     src    : S3(read);
 4701     DECODE : S0;        // any decoder
 4702     ALU    : S3;        // any alu
 4703 %}
 4704 
 4705 // Long ALU reg-reg operation
 4706 pipe_class ialu_reg_reg_long(eRegL dst, eRegL src) %{
 4707     instruction_count(2);
 4708     dst    : S4(write);
 4709     src    : S3(read);
 4710     DECODE : S0(2);     // any 2 decoders
 4711     ALU    : S3(2);     // both alus
 4712 %}
 4713 
 4714 // Integer ALU reg-reg operation
 4715 pipe_class ialu_reg_reg_fat(rRegI dst, memory src) %{
 4716     single_instruction;
 4717     dst    : S4(write);
 4718     src    : S3(read);
 4719     D0     : S0;        // big decoder only
 4720     ALU    : S3;        // any alu
 4721 %}
 4722 
 4723 // Long ALU reg-reg operation
 4724 pipe_class ialu_reg_reg_long_fat(eRegL dst, eRegL src) %{
 4725     instruction_count(2);
 4726     dst    : S4(write);
 4727     src    : S3(read);
 4728     D0     : S0(2);     // big decoder only; twice
 4729     ALU    : S3(2);     // both alus
 4730 %}
 4731 
 4732 // Integer ALU reg-mem operation
 4733 pipe_class ialu_reg_mem(rRegI dst, memory mem) %{
 4734     single_instruction;
 4735     dst    : S5(write);
 4736     mem    : S3(read);
 4737     D0     : S0;        // big decoder only
 4738     ALU    : S4;        // any alu
 4739     MEM    : S3;        // any mem
 4740 %}
 4741 
 4742 // Long ALU reg-mem operation
 4743 pipe_class ialu_reg_long_mem(eRegL dst, load_long_memory mem) %{
 4744     instruction_count(2);
 4745     dst    : S5(write);
 4746     mem    : S3(read);
 4747     D0     : S0(2);     // big decoder only; twice
 4748     ALU    : S4(2);     // any 2 alus
 4749     MEM    : S3(2);     // both mems
 4750 %}
 4751 
 4752 // Integer mem operation (prefetch)
 4753 pipe_class ialu_mem(memory mem)
 4754 %{
 4755     single_instruction;
 4756     mem    : S3(read);
 4757     D0     : S0;        // big decoder only
 4758     MEM    : S3;        // any mem
 4759 %}
 4760 
 4761 // Integer Store to Memory
 4762 pipe_class ialu_mem_reg(memory mem, rRegI src) %{
 4763     single_instruction;
 4764     mem    : S3(read);
 4765     src    : S5(read);
 4766     D0     : S0;        // big decoder only
 4767     ALU    : S4;        // any alu
 4768     MEM    : S3;
 4769 %}
 4770 
 4771 // Long Store to Memory
 4772 pipe_class ialu_mem_long_reg(memory mem, eRegL src) %{
 4773     instruction_count(2);
 4774     mem    : S3(read);
 4775     src    : S5(read);
 4776     D0     : S0(2);     // big decoder only; twice
 4777     ALU    : S4(2);     // any 2 alus
 4778     MEM    : S3(2);     // Both mems
 4779 %}
 4780 
 4781 // Integer Store to Memory
 4782 pipe_class ialu_mem_imm(memory mem) %{
 4783     single_instruction;
 4784     mem    : S3(read);
 4785     D0     : S0;        // big decoder only
 4786     ALU    : S4;        // any alu
 4787     MEM    : S3;
 4788 %}
 4789 
 4790 // Integer ALU0 reg-reg operation
 4791 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src) %{
 4792     single_instruction;
 4793     dst    : S4(write);
 4794     src    : S3(read);
 4795     D0     : S0;        // Big decoder only
 4796     ALU0   : S3;        // only alu0
 4797 %}
 4798 
 4799 // Integer ALU0 reg-mem operation
 4800 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem) %{
 4801     single_instruction;
 4802     dst    : S5(write);
 4803     mem    : S3(read);
 4804     D0     : S0;        // big decoder only
 4805     ALU0   : S4;        // ALU0 only
 4806     MEM    : S3;        // any mem
 4807 %}
 4808 
 4809 // Integer ALU reg-reg operation
 4810 pipe_class ialu_cr_reg_reg(eFlagsReg cr, rRegI src1, rRegI src2) %{
 4811     single_instruction;
 4812     cr     : S4(write);
 4813     src1   : S3(read);
 4814     src2   : S3(read);
 4815     DECODE : S0;        // any decoder
 4816     ALU    : S3;        // any alu
 4817 %}
 4818 
 4819 // Integer ALU reg-imm operation
 4820 pipe_class ialu_cr_reg_imm(eFlagsReg cr, rRegI src1) %{
 4821     single_instruction;
 4822     cr     : S4(write);
 4823     src1   : S3(read);
 4824     DECODE : S0;        // any decoder
 4825     ALU    : S3;        // any alu
 4826 %}
 4827 
 4828 // Integer ALU reg-mem operation
 4829 pipe_class ialu_cr_reg_mem(eFlagsReg cr, rRegI src1, memory src2) %{
 4830     single_instruction;
 4831     cr     : S4(write);
 4832     src1   : S3(read);
 4833     src2   : S3(read);
 4834     D0     : S0;        // big decoder only
 4835     ALU    : S4;        // any alu
 4836     MEM    : S3;
 4837 %}
 4838 
 4839 // Conditional move reg-reg
 4840 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y ) %{
 4841     instruction_count(4);
 4842     y      : S4(read);
 4843     q      : S3(read);
 4844     p      : S3(read);
 4845     DECODE : S0(4);     // any decoder
 4846 %}
 4847 
 4848 // Conditional move reg-reg
 4849 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, eFlagsReg cr ) %{
 4850     single_instruction;
 4851     dst    : S4(write);
 4852     src    : S3(read);
 4853     cr     : S3(read);
 4854     DECODE : S0;        // any decoder
 4855 %}
 4856 
 4857 // Conditional move reg-mem
 4858 pipe_class pipe_cmov_mem( eFlagsReg cr, rRegI dst, memory src) %{
 4859     single_instruction;
 4860     dst    : S4(write);
 4861     src    : S3(read);
 4862     cr     : S3(read);
 4863     DECODE : S0;        // any decoder
 4864     MEM    : S3;
 4865 %}
 4866 
 4867 // Conditional move reg-reg long
 4868 pipe_class pipe_cmov_reg_long( eFlagsReg cr, eRegL dst, eRegL src) %{
 4869     single_instruction;
 4870     dst    : S4(write);
 4871     src    : S3(read);
 4872     cr     : S3(read);
 4873     DECODE : S0(2);     // any 2 decoders
 4874 %}
 4875 
 4876 // Conditional move double reg-reg
 4877 pipe_class pipe_cmovDPR_reg( eFlagsReg cr, regDPR1 dst, regDPR src) %{
 4878     single_instruction;
 4879     dst    : S4(write);
 4880     src    : S3(read);
 4881     cr     : S3(read);
 4882     DECODE : S0;        // any decoder
 4883 %}
 4884 
 4885 // Float reg-reg operation
 4886 pipe_class fpu_reg(regDPR dst) %{
 4887     instruction_count(2);
 4888     dst    : S3(read);
 4889     DECODE : S0(2);     // any 2 decoders
 4890     FPU    : S3;
 4891 %}
 4892 
 4893 // Float reg-reg operation
 4894 pipe_class fpu_reg_reg(regDPR dst, regDPR src) %{
 4895     instruction_count(2);
 4896     dst    : S4(write);
 4897     src    : S3(read);
 4898     DECODE : S0(2);     // any 2 decoders
 4899     FPU    : S3;
 4900 %}
 4901 
 4902 // Float reg-reg operation
 4903 pipe_class fpu_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2) %{
 4904     instruction_count(3);
 4905     dst    : S4(write);
 4906     src1   : S3(read);
 4907     src2   : S3(read);
 4908     DECODE : S0(3);     // any 3 decoders
 4909     FPU    : S3(2);
 4910 %}
 4911 
 4912 // Float reg-reg operation
 4913 pipe_class fpu_reg_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2, regDPR src3) %{
 4914     instruction_count(4);
 4915     dst    : S4(write);
 4916     src1   : S3(read);
 4917     src2   : S3(read);
 4918     src3   : S3(read);
 4919     DECODE : S0(4);     // any 3 decoders
 4920     FPU    : S3(2);
 4921 %}
 4922 
 4923 // Float reg-reg operation
 4924 pipe_class fpu_reg_mem_reg_reg(regDPR dst, memory src1, regDPR src2, regDPR src3) %{
 4925     instruction_count(4);
 4926     dst    : S4(write);
 4927     src1   : S3(read);
 4928     src2   : S3(read);
 4929     src3   : S3(read);
 4930     DECODE : S1(3);     // any 3 decoders
 4931     D0     : S0;        // Big decoder only
 4932     FPU    : S3(2);
 4933     MEM    : S3;
 4934 %}
 4935 
 4936 // Float reg-mem operation
 4937 pipe_class fpu_reg_mem(regDPR dst, memory mem) %{
 4938     instruction_count(2);
 4939     dst    : S5(write);
 4940     mem    : S3(read);
 4941     D0     : S0;        // big decoder only
 4942     DECODE : S1;        // any decoder for FPU POP
 4943     FPU    : S4;
 4944     MEM    : S3;        // any mem
 4945 %}
 4946 
 4947 // Float reg-mem operation
 4948 pipe_class fpu_reg_reg_mem(regDPR dst, regDPR src1, memory mem) %{
 4949     instruction_count(3);
 4950     dst    : S5(write);
 4951     src1   : S3(read);
 4952     mem    : S3(read);
 4953     D0     : S0;        // big decoder only
 4954     DECODE : S1(2);     // any decoder for FPU POP
 4955     FPU    : S4;
 4956     MEM    : S3;        // any mem
 4957 %}
 4958 
 4959 // Float mem-reg operation
 4960 pipe_class fpu_mem_reg(memory mem, regDPR src) %{
 4961     instruction_count(2);
 4962     src    : S5(read);
 4963     mem    : S3(read);
 4964     DECODE : S0;        // any decoder for FPU PUSH
 4965     D0     : S1;        // big decoder only
 4966     FPU    : S4;
 4967     MEM    : S3;        // any mem
 4968 %}
 4969 
 4970 pipe_class fpu_mem_reg_reg(memory mem, regDPR src1, regDPR src2) %{
 4971     instruction_count(3);
 4972     src1   : S3(read);
 4973     src2   : S3(read);
 4974     mem    : S3(read);
 4975     DECODE : S0(2);     // any decoder for FPU PUSH
 4976     D0     : S1;        // big decoder only
 4977     FPU    : S4;
 4978     MEM    : S3;        // any mem
 4979 %}
 4980 
 4981 pipe_class fpu_mem_reg_mem(memory mem, regDPR src1, memory src2) %{
 4982     instruction_count(3);
 4983     src1   : S3(read);
 4984     src2   : S3(read);
 4985     mem    : S4(read);
 4986     DECODE : S0;        // any decoder for FPU PUSH
 4987     D0     : S0(2);     // big decoder only
 4988     FPU    : S4;
 4989     MEM    : S3(2);     // any mem
 4990 %}
 4991 
 4992 pipe_class fpu_mem_mem(memory dst, memory src1) %{
 4993     instruction_count(2);
 4994     src1   : S3(read);
 4995     dst    : S4(read);
 4996     D0     : S0(2);     // big decoder only
 4997     MEM    : S3(2);     // any mem
 4998 %}
 4999 
 5000 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2) %{
 5001     instruction_count(3);
 5002     src1   : S3(read);
 5003     src2   : S3(read);
 5004     dst    : S4(read);
 5005     D0     : S0(3);     // big decoder only
 5006     FPU    : S4;
 5007     MEM    : S3(3);     // any mem
 5008 %}
 5009 
 5010 pipe_class fpu_mem_reg_con(memory mem, regDPR src1) %{
 5011     instruction_count(3);
 5012     src1   : S4(read);
 5013     mem    : S4(read);
 5014     DECODE : S0;        // any decoder for FPU PUSH
 5015     D0     : S0(2);     // big decoder only
 5016     FPU    : S4;
 5017     MEM    : S3(2);     // any mem
 5018 %}
 5019 
 5020 // Float load constant
 5021 pipe_class fpu_reg_con(regDPR dst) %{
 5022     instruction_count(2);
 5023     dst    : S5(write);
 5024     D0     : S0;        // big decoder only for the load
 5025     DECODE : S1;        // any decoder for FPU POP
 5026     FPU    : S4;
 5027     MEM    : S3;        // any mem
 5028 %}
 5029 
 5030 // Float load constant
 5031 pipe_class fpu_reg_reg_con(regDPR dst, regDPR src) %{
 5032     instruction_count(3);
 5033     dst    : S5(write);
 5034     src    : S3(read);
 5035     D0     : S0;        // big decoder only for the load
 5036     DECODE : S1(2);     // any decoder for FPU POP
 5037     FPU    : S4;
 5038     MEM    : S3;        // any mem
 5039 %}
 5040 
 5041 // UnConditional branch
 5042 pipe_class pipe_jmp( label labl ) %{
 5043     single_instruction;
 5044     BR   : S3;
 5045 %}
 5046 
 5047 // Conditional branch
 5048 pipe_class pipe_jcc( cmpOp cmp, eFlagsReg cr, label labl ) %{
 5049     single_instruction;
 5050     cr    : S1(read);
 5051     BR    : S3;
 5052 %}
 5053 
 5054 // Allocation idiom
 5055 pipe_class pipe_cmpxchg( eRegP dst, eRegP heap_ptr ) %{
 5056     instruction_count(1); force_serialization;
 5057     fixed_latency(6);
 5058     heap_ptr : S3(read);
 5059     DECODE   : S0(3);
 5060     D0       : S2;
 5061     MEM      : S3;
 5062     ALU      : S3(2);
 5063     dst      : S5(write);
 5064     BR       : S5;
 5065 %}
 5066 
 5067 // Generic big/slow expanded idiom
 5068 pipe_class pipe_slow(  ) %{
 5069     instruction_count(10); multiple_bundles; force_serialization;
 5070     fixed_latency(100);
 5071     D0  : S0(2);
 5072     MEM : S3(2);
 5073 %}
 5074 
 5075 // The real do-nothing guy
 5076 pipe_class empty( ) %{
 5077     instruction_count(0);
 5078 %}
 5079 
 5080 // Define the class for the Nop node
 5081 define %{
 5082    MachNop = empty;
 5083 %}
 5084 
 5085 %}
 5086 
 5087 //----------INSTRUCTIONS-------------------------------------------------------
 5088 //
 5089 // match      -- States which machine-independent subtree may be replaced
 5090 //               by this instruction.
 5091 // ins_cost   -- The estimated cost of this instruction is used by instruction
 5092 //               selection to identify a minimum cost tree of machine
 5093 //               instructions that matches a tree of machine-independent
 5094 //               instructions.
 5095 // format     -- A string providing the disassembly for this instruction.
 5096 //               The value of an instruction&#39;s operand may be inserted
 5097 //               by referring to it with a &#39;$&#39; prefix.
 5098 // opcode     -- Three instruction opcodes may be provided.  These are referred
 5099 //               to within an encode class as $primary, $secondary, and $tertiary
 5100 //               respectively.  The primary opcode is commonly used to
 5101 //               indicate the type of machine instruction, while secondary
 5102 //               and tertiary are often used for prefix options or addressing
 5103 //               modes.
 5104 // ins_encode -- A list of encode classes with parameters. The encode class
 5105 //               name must have been defined in an &#39;enc_class&#39; specification
 5106 //               in the encode section of the architecture description.
 5107 
 5108 //----------BSWAP-Instruction--------------------------------------------------
 5109 instruct bytes_reverse_int(rRegI dst) %{
 5110   match(Set dst (ReverseBytesI dst));
 5111 
 5112   format %{ &quot;BSWAP  $dst&quot; %}
 5113   opcode(0x0F, 0xC8);
 5114   ins_encode( OpcP, OpcSReg(dst) );
 5115   ins_pipe( ialu_reg );
 5116 %}
 5117 
 5118 instruct bytes_reverse_long(eRegL dst) %{
 5119   match(Set dst (ReverseBytesL dst));
 5120 
 5121   format %{ &quot;BSWAP  $dst.lo\n\t&quot;
 5122             &quot;BSWAP  $dst.hi\n\t&quot;
 5123             &quot;XCHG   $dst.lo $dst.hi&quot; %}
 5124 
 5125   ins_cost(125);
 5126   ins_encode( bswap_long_bytes(dst) );
 5127   ins_pipe( ialu_reg_reg);
 5128 %}
 5129 
 5130 instruct bytes_reverse_unsigned_short(rRegI dst, eFlagsReg cr) %{
 5131   match(Set dst (ReverseBytesUS dst));
 5132   effect(KILL cr);
 5133 
 5134   format %{ &quot;BSWAP  $dst\n\t&quot;
 5135             &quot;SHR    $dst,16\n\t&quot; %}
 5136   ins_encode %{
 5137     __ bswapl($dst$$Register);
 5138     __ shrl($dst$$Register, 16);
 5139   %}
 5140   ins_pipe( ialu_reg );
 5141 %}
 5142 
 5143 instruct bytes_reverse_short(rRegI dst, eFlagsReg cr) %{
 5144   match(Set dst (ReverseBytesS dst));
 5145   effect(KILL cr);
 5146 
 5147   format %{ &quot;BSWAP  $dst\n\t&quot;
 5148             &quot;SAR    $dst,16\n\t&quot; %}
 5149   ins_encode %{
 5150     __ bswapl($dst$$Register);
 5151     __ sarl($dst$$Register, 16);
 5152   %}
 5153   ins_pipe( ialu_reg );
 5154 %}
 5155 
 5156 
 5157 //---------- Zeros Count Instructions ------------------------------------------
 5158 
 5159 instruct countLeadingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5160   predicate(UseCountLeadingZerosInstruction);
 5161   match(Set dst (CountLeadingZerosI src));
 5162   effect(KILL cr);
 5163 
 5164   format %{ &quot;LZCNT  $dst, $src\t# count leading zeros (int)&quot; %}
 5165   ins_encode %{
 5166     __ lzcntl($dst$$Register, $src$$Register);
 5167   %}
 5168   ins_pipe(ialu_reg);
 5169 %}
 5170 
 5171 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, eFlagsReg cr) %{
 5172   predicate(!UseCountLeadingZerosInstruction);
 5173   match(Set dst (CountLeadingZerosI src));
 5174   effect(KILL cr);
 5175 
 5176   format %{ &quot;BSR    $dst, $src\t# count leading zeros (int)\n\t&quot;
 5177             &quot;JNZ    skip\n\t&quot;
 5178             &quot;MOV    $dst, -1\n&quot;
 5179       &quot;skip:\n\t&quot;
 5180             &quot;NEG    $dst\n\t&quot;
 5181             &quot;ADD    $dst, 31&quot; %}
 5182   ins_encode %{
 5183     Register Rdst = $dst$$Register;
 5184     Register Rsrc = $src$$Register;
 5185     Label skip;
 5186     __ bsrl(Rdst, Rsrc);
 5187     __ jccb(Assembler::notZero, skip);
 5188     __ movl(Rdst, -1);
 5189     __ bind(skip);
 5190     __ negl(Rdst);
 5191     __ addl(Rdst, BitsPerInt - 1);
 5192   %}
 5193   ins_pipe(ialu_reg);
 5194 %}
 5195 
 5196 instruct countLeadingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5197   predicate(UseCountLeadingZerosInstruction);
 5198   match(Set dst (CountLeadingZerosL src));
 5199   effect(TEMP dst, KILL cr);
 5200 
 5201   format %{ &quot;LZCNT  $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5202             &quot;JNC    done\n\t&quot;
 5203             &quot;LZCNT  $dst, $src.lo\n\t&quot;
 5204             &quot;ADD    $dst, 32\n&quot;
 5205       &quot;done:&quot; %}
 5206   ins_encode %{
 5207     Register Rdst = $dst$$Register;
 5208     Register Rsrc = $src$$Register;
 5209     Label done;
 5210     __ lzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5211     __ jccb(Assembler::carryClear, done);
 5212     __ lzcntl(Rdst, Rsrc);
 5213     __ addl(Rdst, BitsPerInt);
 5214     __ bind(done);
 5215   %}
 5216   ins_pipe(ialu_reg);
 5217 %}
 5218 
 5219 instruct countLeadingZerosL_bsr(rRegI dst, eRegL src, eFlagsReg cr) %{
 5220   predicate(!UseCountLeadingZerosInstruction);
 5221   match(Set dst (CountLeadingZerosL src));
 5222   effect(TEMP dst, KILL cr);
 5223 
 5224   format %{ &quot;BSR    $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5225             &quot;JZ     msw_is_zero\n\t&quot;
 5226             &quot;ADD    $dst, 32\n\t&quot;
 5227             &quot;JMP    not_zero\n&quot;
 5228       &quot;msw_is_zero:\n\t&quot;
 5229             &quot;BSR    $dst, $src.lo\n\t&quot;
 5230             &quot;JNZ    not_zero\n\t&quot;
 5231             &quot;MOV    $dst, -1\n&quot;
 5232       &quot;not_zero:\n\t&quot;
 5233             &quot;NEG    $dst\n\t&quot;
 5234             &quot;ADD    $dst, 63\n&quot; %}
 5235  ins_encode %{
 5236     Register Rdst = $dst$$Register;
 5237     Register Rsrc = $src$$Register;
 5238     Label msw_is_zero;
 5239     Label not_zero;
 5240     __ bsrl(Rdst, HIGH_FROM_LOW(Rsrc));
 5241     __ jccb(Assembler::zero, msw_is_zero);
 5242     __ addl(Rdst, BitsPerInt);
 5243     __ jmpb(not_zero);
 5244     __ bind(msw_is_zero);
 5245     __ bsrl(Rdst, Rsrc);
 5246     __ jccb(Assembler::notZero, not_zero);
 5247     __ movl(Rdst, -1);
 5248     __ bind(not_zero);
 5249     __ negl(Rdst);
 5250     __ addl(Rdst, BitsPerLong - 1);
 5251   %}
 5252   ins_pipe(ialu_reg);
 5253 %}
 5254 
 5255 instruct countTrailingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5256   predicate(UseCountTrailingZerosInstruction);
 5257   match(Set dst (CountTrailingZerosI src));
 5258   effect(KILL cr);
 5259 
 5260   format %{ &quot;TZCNT    $dst, $src\t# count trailing zeros (int)&quot; %}
 5261   ins_encode %{
 5262     __ tzcntl($dst$$Register, $src$$Register);
 5263   %}
 5264   ins_pipe(ialu_reg);
 5265 %}
 5266 
 5267 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, eFlagsReg cr) %{
 5268   predicate(!UseCountTrailingZerosInstruction);
 5269   match(Set dst (CountTrailingZerosI src));
 5270   effect(KILL cr);
 5271 
 5272   format %{ &quot;BSF    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 5273             &quot;JNZ    done\n\t&quot;
 5274             &quot;MOV    $dst, 32\n&quot;
 5275       &quot;done:&quot; %}
 5276   ins_encode %{
 5277     Register Rdst = $dst$$Register;
 5278     Label done;
 5279     __ bsfl(Rdst, $src$$Register);
 5280     __ jccb(Assembler::notZero, done);
 5281     __ movl(Rdst, BitsPerInt);
 5282     __ bind(done);
 5283   %}
 5284   ins_pipe(ialu_reg);
 5285 %}
 5286 
 5287 instruct countTrailingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5288   predicate(UseCountTrailingZerosInstruction);
 5289   match(Set dst (CountTrailingZerosL src));
 5290   effect(TEMP dst, KILL cr);
 5291 
 5292   format %{ &quot;TZCNT  $dst, $src.lo\t# count trailing zeros (long) \n\t&quot;
 5293             &quot;JNC    done\n\t&quot;
 5294             &quot;TZCNT  $dst, $src.hi\n\t&quot;
 5295             &quot;ADD    $dst, 32\n&quot;
 5296             &quot;done:&quot; %}
 5297   ins_encode %{
 5298     Register Rdst = $dst$$Register;
 5299     Register Rsrc = $src$$Register;
 5300     Label done;
 5301     __ tzcntl(Rdst, Rsrc);
 5302     __ jccb(Assembler::carryClear, done);
 5303     __ tzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5304     __ addl(Rdst, BitsPerInt);
 5305     __ bind(done);
 5306   %}
 5307   ins_pipe(ialu_reg);
 5308 %}
 5309 
 5310 instruct countTrailingZerosL_bsf(rRegI dst, eRegL src, eFlagsReg cr) %{
 5311   predicate(!UseCountTrailingZerosInstruction);
 5312   match(Set dst (CountTrailingZerosL src));
 5313   effect(TEMP dst, KILL cr);
 5314 
 5315   format %{ &quot;BSF    $dst, $src.lo\t# count trailing zeros (long)\n\t&quot;
 5316             &quot;JNZ    done\n\t&quot;
 5317             &quot;BSF    $dst, $src.hi\n\t&quot;
 5318             &quot;JNZ    msw_not_zero\n\t&quot;
 5319             &quot;MOV    $dst, 32\n&quot;
 5320       &quot;msw_not_zero:\n\t&quot;
 5321             &quot;ADD    $dst, 32\n&quot;
 5322       &quot;done:&quot; %}
 5323   ins_encode %{
 5324     Register Rdst = $dst$$Register;
 5325     Register Rsrc = $src$$Register;
 5326     Label msw_not_zero;
 5327     Label done;
 5328     __ bsfl(Rdst, Rsrc);
 5329     __ jccb(Assembler::notZero, done);
 5330     __ bsfl(Rdst, HIGH_FROM_LOW(Rsrc));
 5331     __ jccb(Assembler::notZero, msw_not_zero);
 5332     __ movl(Rdst, BitsPerInt);
 5333     __ bind(msw_not_zero);
 5334     __ addl(Rdst, BitsPerInt);
 5335     __ bind(done);
 5336   %}
 5337   ins_pipe(ialu_reg);
 5338 %}
 5339 
 5340 
 5341 //---------- Population Count Instructions -------------------------------------
 5342 
 5343 instruct popCountI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5344   predicate(UsePopCountInstruction);
 5345   match(Set dst (PopCountI src));
 5346   effect(KILL cr);
 5347 
 5348   format %{ &quot;POPCNT $dst, $src&quot; %}
 5349   ins_encode %{
 5350     __ popcntl($dst$$Register, $src$$Register);
 5351   %}
 5352   ins_pipe(ialu_reg);
 5353 %}
 5354 
 5355 instruct popCountI_mem(rRegI dst, memory mem, eFlagsReg cr) %{
 5356   predicate(UsePopCountInstruction);
 5357   match(Set dst (PopCountI (LoadI mem)));
 5358   effect(KILL cr);
 5359 
 5360   format %{ &quot;POPCNT $dst, $mem&quot; %}
 5361   ins_encode %{
 5362     __ popcntl($dst$$Register, $mem$$Address);
 5363   %}
 5364   ins_pipe(ialu_reg);
 5365 %}
 5366 
 5367 // Note: Long.bitCount(long) returns an int.
 5368 instruct popCountL(rRegI dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 5369   predicate(UsePopCountInstruction);
 5370   match(Set dst (PopCountL src));
 5371   effect(KILL cr, TEMP tmp, TEMP dst);
 5372 
 5373   format %{ &quot;POPCNT $dst, $src.lo\n\t&quot;
 5374             &quot;POPCNT $tmp, $src.hi\n\t&quot;
 5375             &quot;ADD    $dst, $tmp&quot; %}
 5376   ins_encode %{
 5377     __ popcntl($dst$$Register, $src$$Register);
 5378     __ popcntl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 5379     __ addl($dst$$Register, $tmp$$Register);
 5380   %}
 5381   ins_pipe(ialu_reg);
 5382 %}
 5383 
 5384 // Note: Long.bitCount(long) returns an int.
 5385 instruct popCountL_mem(rRegI dst, memory mem, rRegI tmp, eFlagsReg cr) %{
 5386   predicate(UsePopCountInstruction);
 5387   match(Set dst (PopCountL (LoadL mem)));
 5388   effect(KILL cr, TEMP tmp, TEMP dst);
 5389 
 5390   format %{ &quot;POPCNT $dst, $mem\n\t&quot;
 5391             &quot;POPCNT $tmp, $mem+4\n\t&quot;
 5392             &quot;ADD    $dst, $tmp&quot; %}
 5393   ins_encode %{
 5394     //__ popcntl($dst$$Register, $mem$$Address$$first);
 5395     //__ popcntl($tmp$$Register, $mem$$Address$$second);
 5396     __ popcntl($dst$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none));
 5397     __ popcntl($tmp$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none));
 5398     __ addl($dst$$Register, $tmp$$Register);
 5399   %}
 5400   ins_pipe(ialu_reg);
 5401 %}
 5402 
 5403 
 5404 //----------Load/Store/Move Instructions---------------------------------------
 5405 //----------Load Instructions--------------------------------------------------
 5406 // Load Byte (8bit signed)
 5407 instruct loadB(xRegI dst, memory mem) %{
 5408   match(Set dst (LoadB mem));
 5409 
 5410   ins_cost(125);
 5411   format %{ &quot;MOVSX8 $dst,$mem\t# byte&quot; %}
 5412 
 5413   ins_encode %{
 5414     __ movsbl($dst$$Register, $mem$$Address);
 5415   %}
 5416 
 5417   ins_pipe(ialu_reg_mem);
 5418 %}
 5419 
 5420 // Load Byte (8bit signed) into Long Register
 5421 instruct loadB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5422   match(Set dst (ConvI2L (LoadB mem)));
 5423   effect(KILL cr);
 5424 
 5425   ins_cost(375);
 5426   format %{ &quot;MOVSX8 $dst.lo,$mem\t# byte -&gt; long\n\t&quot;
 5427             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5428             &quot;SAR    $dst.hi,7&quot; %}
 5429 
 5430   ins_encode %{
 5431     __ movsbl($dst$$Register, $mem$$Address);
 5432     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5433     __ sarl(HIGH_FROM_LOW($dst$$Register), 7); // 24+1 MSB are already signed extended.
 5434   %}
 5435 
 5436   ins_pipe(ialu_reg_mem);
 5437 %}
 5438 
 5439 // Load Unsigned Byte (8bit UNsigned)
 5440 instruct loadUB(xRegI dst, memory mem) %{
 5441   match(Set dst (LoadUB mem));
 5442 
 5443   ins_cost(125);
 5444   format %{ &quot;MOVZX8 $dst,$mem\t# ubyte -&gt; int&quot; %}
 5445 
 5446   ins_encode %{
 5447     __ movzbl($dst$$Register, $mem$$Address);
 5448   %}
 5449 
 5450   ins_pipe(ialu_reg_mem);
 5451 %}
 5452 
 5453 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 5454 instruct loadUB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5455   match(Set dst (ConvI2L (LoadUB mem)));
 5456   effect(KILL cr);
 5457 
 5458   ins_cost(250);
 5459   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte -&gt; long\n\t&quot;
 5460             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5461 
 5462   ins_encode %{
 5463     Register Rdst = $dst$$Register;
 5464     __ movzbl(Rdst, $mem$$Address);
 5465     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5466   %}
 5467 
 5468   ins_pipe(ialu_reg_mem);
 5469 %}
 5470 
 5471 // Load Unsigned Byte (8 bit UNsigned) with mask into Long Register
 5472 instruct loadUB2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5473   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5474   effect(KILL cr);
 5475 
 5476   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5477             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5478             &quot;AND    $dst.lo,right_n_bits($mask, 8)&quot; %}
 5479   ins_encode %{
 5480     Register Rdst = $dst$$Register;
 5481     __ movzbl(Rdst, $mem$$Address);
 5482     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5483     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 5484   %}
 5485   ins_pipe(ialu_reg_mem);
 5486 %}
 5487 
 5488 // Load Short (16bit signed)
 5489 instruct loadS(rRegI dst, memory mem) %{
 5490   match(Set dst (LoadS mem));
 5491 
 5492   ins_cost(125);
 5493   format %{ &quot;MOVSX  $dst,$mem\t# short&quot; %}
 5494 
 5495   ins_encode %{
 5496     __ movswl($dst$$Register, $mem$$Address);
 5497   %}
 5498 
 5499   ins_pipe(ialu_reg_mem);
 5500 %}
 5501 
 5502 // Load Short (16 bit signed) to Byte (8 bit signed)
 5503 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5504   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5505 
 5506   ins_cost(125);
 5507   format %{ &quot;MOVSX  $dst, $mem\t# short -&gt; byte&quot; %}
 5508   ins_encode %{
 5509     __ movsbl($dst$$Register, $mem$$Address);
 5510   %}
 5511   ins_pipe(ialu_reg_mem);
 5512 %}
 5513 
 5514 // Load Short (16bit signed) into Long Register
 5515 instruct loadS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5516   match(Set dst (ConvI2L (LoadS mem)));
 5517   effect(KILL cr);
 5518 
 5519   ins_cost(375);
 5520   format %{ &quot;MOVSX  $dst.lo,$mem\t# short -&gt; long\n\t&quot;
 5521             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5522             &quot;SAR    $dst.hi,15&quot; %}
 5523 
 5524   ins_encode %{
 5525     __ movswl($dst$$Register, $mem$$Address);
 5526     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5527     __ sarl(HIGH_FROM_LOW($dst$$Register), 15); // 16+1 MSB are already signed extended.
 5528   %}
 5529 
 5530   ins_pipe(ialu_reg_mem);
 5531 %}
 5532 
 5533 // Load Unsigned Short/Char (16bit unsigned)
 5534 instruct loadUS(rRegI dst, memory mem) %{
 5535   match(Set dst (LoadUS mem));
 5536 
 5537   ins_cost(125);
 5538   format %{ &quot;MOVZX  $dst,$mem\t# ushort/char -&gt; int&quot; %}
 5539 
 5540   ins_encode %{
 5541     __ movzwl($dst$$Register, $mem$$Address);
 5542   %}
 5543 
 5544   ins_pipe(ialu_reg_mem);
 5545 %}
 5546 
 5547 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5548 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5549   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5550 
 5551   ins_cost(125);
 5552   format %{ &quot;MOVSX  $dst, $mem\t# ushort -&gt; byte&quot; %}
 5553   ins_encode %{
 5554     __ movsbl($dst$$Register, $mem$$Address);
 5555   %}
 5556   ins_pipe(ialu_reg_mem);
 5557 %}
 5558 
 5559 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 5560 instruct loadUS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5561   match(Set dst (ConvI2L (LoadUS mem)));
 5562   effect(KILL cr);
 5563 
 5564   ins_cost(250);
 5565   format %{ &quot;MOVZX  $dst.lo,$mem\t# ushort/char -&gt; long\n\t&quot;
 5566             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5567 
 5568   ins_encode %{
 5569     __ movzwl($dst$$Register, $mem$$Address);
 5570     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5571   %}
 5572 
 5573   ins_pipe(ialu_reg_mem);
 5574 %}
 5575 
 5576 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 5577 instruct loadUS2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5578   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5579   effect(KILL cr);
 5580 
 5581   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ushort/char &amp; 0xFF -&gt; long\n\t&quot;
 5582             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5583   ins_encode %{
 5584     Register Rdst = $dst$$Register;
 5585     __ movzbl(Rdst, $mem$$Address);
 5586     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5587   %}
 5588   ins_pipe(ialu_reg_mem);
 5589 %}
 5590 
 5591 // Load Unsigned Short/Char (16 bit UNsigned) with a 32-bit mask into Long Register
 5592 instruct loadUS2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5593   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5594   effect(KILL cr);
 5595 
 5596   format %{ &quot;MOVZX  $dst.lo, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5597             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5598             &quot;AND    $dst.lo,right_n_bits($mask, 16)&quot; %}
 5599   ins_encode %{
 5600     Register Rdst = $dst$$Register;
 5601     __ movzwl(Rdst, $mem$$Address);
 5602     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5603     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 5604   %}
 5605   ins_pipe(ialu_reg_mem);
 5606 %}
 5607 
 5608 // Load Integer
 5609 instruct loadI(rRegI dst, memory mem) %{
 5610   match(Set dst (LoadI mem));
 5611 
 5612   ins_cost(125);
 5613   format %{ &quot;MOV    $dst,$mem\t# int&quot; %}
 5614 
 5615   ins_encode %{
 5616     __ movl($dst$$Register, $mem$$Address);
 5617   %}
 5618 
 5619   ins_pipe(ialu_reg_mem);
 5620 %}
 5621 
 5622 // Load Integer (32 bit signed) to Byte (8 bit signed)
 5623 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5624   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5625 
 5626   ins_cost(125);
 5627   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; byte&quot; %}
 5628   ins_encode %{
 5629     __ movsbl($dst$$Register, $mem$$Address);
 5630   %}
 5631   ins_pipe(ialu_reg_mem);
 5632 %}
 5633 
 5634 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 5635 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 5636   match(Set dst (AndI (LoadI mem) mask));
 5637 
 5638   ins_cost(125);
 5639   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5640   ins_encode %{
 5641     __ movzbl($dst$$Register, $mem$$Address);
 5642   %}
 5643   ins_pipe(ialu_reg_mem);
 5644 %}
 5645 
 5646 // Load Integer (32 bit signed) to Short (16 bit signed)
 5647 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5648   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5649 
 5650   ins_cost(125);
 5651   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; short&quot; %}
 5652   ins_encode %{
 5653     __ movswl($dst$$Register, $mem$$Address);
 5654   %}
 5655   ins_pipe(ialu_reg_mem);
 5656 %}
 5657 
 5658 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5659 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5660   match(Set dst (AndI (LoadI mem) mask));
 5661 
 5662   ins_cost(125);
 5663   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5664   ins_encode %{
 5665     __ movzwl($dst$$Register, $mem$$Address);
 5666   %}
 5667   ins_pipe(ialu_reg_mem);
 5668 %}
 5669 
 5670 // Load Integer into Long Register
 5671 instruct loadI2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5672   match(Set dst (ConvI2L (LoadI mem)));
 5673   effect(KILL cr);
 5674 
 5675   ins_cost(375);
 5676   format %{ &quot;MOV    $dst.lo,$mem\t# int -&gt; long\n\t&quot;
 5677             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5678             &quot;SAR    $dst.hi,31&quot; %}
 5679 
 5680   ins_encode %{
 5681     __ movl($dst$$Register, $mem$$Address);
 5682     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5683     __ sarl(HIGH_FROM_LOW($dst$$Register), 31);
 5684   %}
 5685 
 5686   ins_pipe(ialu_reg_mem);
 5687 %}
 5688 
 5689 // Load Integer with mask 0xFF into Long Register
 5690 instruct loadI2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5691   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5692   effect(KILL cr);
 5693 
 5694   format %{ &quot;MOVZX8 $dst.lo,$mem\t# int &amp; 0xFF -&gt; long\n\t&quot;
 5695             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5696   ins_encode %{
 5697     Register Rdst = $dst$$Register;
 5698     __ movzbl(Rdst, $mem$$Address);
 5699     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5700   %}
 5701   ins_pipe(ialu_reg_mem);
 5702 %}
 5703 
 5704 // Load Integer with mask 0xFFFF into Long Register
 5705 instruct loadI2L_immI_65535(eRegL dst, memory mem, immI_65535 mask, eFlagsReg cr) %{
 5706   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5707   effect(KILL cr);
 5708 
 5709   format %{ &quot;MOVZX  $dst.lo,$mem\t# int &amp; 0xFFFF -&gt; long\n\t&quot;
 5710             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5711   ins_encode %{
 5712     Register Rdst = $dst$$Register;
 5713     __ movzwl(Rdst, $mem$$Address);
 5714     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5715   %}
 5716   ins_pipe(ialu_reg_mem);
 5717 %}
 5718 
 5719 // Load Integer with 31-bit mask into Long Register
 5720 instruct loadI2L_immU31(eRegL dst, memory mem, immU31 mask, eFlagsReg cr) %{
 5721   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5722   effect(KILL cr);
 5723 
 5724   format %{ &quot;MOV    $dst.lo,$mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5725             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5726             &quot;AND    $dst.lo,$mask&quot; %}
 5727   ins_encode %{
 5728     Register Rdst = $dst$$Register;
 5729     __ movl(Rdst, $mem$$Address);
 5730     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5731     __ andl(Rdst, $mask$$constant);
 5732   %}
 5733   ins_pipe(ialu_reg_mem);
 5734 %}
 5735 
 5736 // Load Unsigned Integer into Long Register
 5737 instruct loadUI2L(eRegL dst, memory mem, immL_32bits mask, eFlagsReg cr) %{
 5738   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5739   effect(KILL cr);
 5740 
 5741   ins_cost(250);
 5742   format %{ &quot;MOV    $dst.lo,$mem\t# uint -&gt; long\n\t&quot;
 5743             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5744 
 5745   ins_encode %{
 5746     __ movl($dst$$Register, $mem$$Address);
 5747     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5748   %}
 5749 
 5750   ins_pipe(ialu_reg_mem);
 5751 %}
 5752 
 5753 // Load Long.  Cannot clobber address while loading, so restrict address
 5754 // register to ESI
 5755 instruct loadL(eRegL dst, load_long_memory mem) %{
 5756   predicate(!((LoadLNode*)n)-&gt;require_atomic_access());
 5757   match(Set dst (LoadL mem));
 5758 
 5759   ins_cost(250);
 5760   format %{ &quot;MOV    $dst.lo,$mem\t# long\n\t&quot;
 5761             &quot;MOV    $dst.hi,$mem+4&quot; %}
 5762 
 5763   ins_encode %{
 5764     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 5765     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 5766     __ movl($dst$$Register, Amemlo);
 5767     __ movl(HIGH_FROM_LOW($dst$$Register), Amemhi);
 5768   %}
 5769 
 5770   ins_pipe(ialu_reg_long_mem);
 5771 %}
 5772 
 5773 // Volatile Load Long.  Must be atomic, so do 64-bit FILD
 5774 // then store it down to the stack and reload on the int
 5775 // side.
 5776 instruct loadL_volatile(stackSlotL dst, memory mem) %{
 5777   predicate(UseSSE&lt;=1 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5778   match(Set dst (LoadL mem));
 5779 
 5780   ins_cost(200);
 5781   format %{ &quot;FILD   $mem\t# Atomic volatile long load\n\t&quot;
 5782             &quot;FISTp  $dst&quot; %}
 5783   ins_encode(enc_loadL_volatile(mem,dst));
 5784   ins_pipe( fpu_reg_mem );
 5785 %}
 5786 
 5787 instruct loadLX_volatile(stackSlotL dst, memory mem, regD tmp) %{
 5788   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5789   match(Set dst (LoadL mem));
 5790   effect(TEMP tmp);
 5791   ins_cost(180);
 5792   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5793             &quot;MOVSD  $dst,$tmp&quot; %}
 5794   ins_encode %{
 5795     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5796     __ movdbl(Address(rsp, $dst$$disp), $tmp$$XMMRegister);
 5797   %}
 5798   ins_pipe( pipe_slow );
 5799 %}
 5800 
 5801 instruct loadLX_reg_volatile(eRegL dst, memory mem, regD tmp) %{
 5802   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5803   match(Set dst (LoadL mem));
 5804   effect(TEMP tmp);
 5805   ins_cost(160);
 5806   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5807             &quot;MOVD   $dst.lo,$tmp\n\t&quot;
 5808             &quot;PSRLQ  $tmp,32\n\t&quot;
 5809             &quot;MOVD   $dst.hi,$tmp&quot; %}
 5810   ins_encode %{
 5811     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5812     __ movdl($dst$$Register, $tmp$$XMMRegister);
 5813     __ psrlq($tmp$$XMMRegister, 32);
 5814     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
 5815   %}
 5816   ins_pipe( pipe_slow );
 5817 %}
 5818 
 5819 // Load Range
 5820 instruct loadRange(rRegI dst, memory mem) %{
 5821   match(Set dst (LoadRange mem));
 5822 
 5823   ins_cost(125);
 5824   format %{ &quot;MOV    $dst,$mem&quot; %}
 5825   opcode(0x8B);
 5826   ins_encode( OpcP, RegMem(dst,mem));
 5827   ins_pipe( ialu_reg_mem );
 5828 %}
 5829 
 5830 
 5831 // Load Pointer
 5832 instruct loadP(eRegP dst, memory mem) %{
 5833   match(Set dst (LoadP mem));
 5834 
 5835   ins_cost(125);
 5836   format %{ &quot;MOV    $dst,$mem&quot; %}
 5837   opcode(0x8B);
 5838   ins_encode( OpcP, RegMem(dst,mem));
 5839   ins_pipe( ialu_reg_mem );
 5840 %}
 5841 
 5842 // Load Klass Pointer
 5843 instruct loadKlass(eRegP dst, memory mem) %{
 5844   match(Set dst (LoadKlass mem));
 5845 
 5846   ins_cost(125);
 5847   format %{ &quot;MOV    $dst,$mem&quot; %}
 5848   opcode(0x8B);
 5849   ins_encode( OpcP, RegMem(dst,mem));
 5850   ins_pipe( ialu_reg_mem );
 5851 %}
 5852 
 5853 // Load Double
 5854 instruct loadDPR(regDPR dst, memory mem) %{
 5855   predicate(UseSSE&lt;=1);
 5856   match(Set dst (LoadD mem));
 5857 
 5858   ins_cost(150);
 5859   format %{ &quot;FLD_D  ST,$mem\n\t&quot;
 5860             &quot;FSTP   $dst&quot; %}
 5861   opcode(0xDD);               /* DD /0 */
 5862   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5863               Pop_Reg_DPR(dst) );
 5864   ins_pipe( fpu_reg_mem );
 5865 %}
 5866 
 5867 // Load Double to XMM
 5868 instruct loadD(regD dst, memory mem) %{
 5869   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
 5870   match(Set dst (LoadD mem));
 5871   ins_cost(145);
 5872   format %{ &quot;MOVSD  $dst,$mem&quot; %}
 5873   ins_encode %{
 5874     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5875   %}
 5876   ins_pipe( pipe_slow );
 5877 %}
 5878 
 5879 instruct loadD_partial(regD dst, memory mem) %{
 5880   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
 5881   match(Set dst (LoadD mem));
 5882   ins_cost(145);
 5883   format %{ &quot;MOVLPD $dst,$mem&quot; %}
 5884   ins_encode %{
 5885     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5886   %}
 5887   ins_pipe( pipe_slow );
 5888 %}
 5889 
 5890 // Load to XMM register (single-precision floating point)
 5891 // MOVSS instruction
 5892 instruct loadF(regF dst, memory mem) %{
 5893   predicate(UseSSE&gt;=1);
 5894   match(Set dst (LoadF mem));
 5895   ins_cost(145);
 5896   format %{ &quot;MOVSS  $dst,$mem&quot; %}
 5897   ins_encode %{
 5898     __ movflt ($dst$$XMMRegister, $mem$$Address);
 5899   %}
 5900   ins_pipe( pipe_slow );
 5901 %}
 5902 
 5903 // Load Float
 5904 instruct loadFPR(regFPR dst, memory mem) %{
 5905   predicate(UseSSE==0);
 5906   match(Set dst (LoadF mem));
 5907 
 5908   ins_cost(150);
 5909   format %{ &quot;FLD_S  ST,$mem\n\t&quot;
 5910             &quot;FSTP   $dst&quot; %}
 5911   opcode(0xD9);               /* D9 /0 */
 5912   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5913               Pop_Reg_FPR(dst) );
 5914   ins_pipe( fpu_reg_mem );
 5915 %}
 5916 
 5917 // Load Effective Address
 5918 instruct leaP8(eRegP dst, indOffset8 mem) %{
 5919   match(Set dst mem);
 5920 
 5921   ins_cost(110);
 5922   format %{ &quot;LEA    $dst,$mem&quot; %}
 5923   opcode(0x8D);
 5924   ins_encode( OpcP, RegMem(dst,mem));
 5925   ins_pipe( ialu_reg_reg_fat );
 5926 %}
 5927 
 5928 instruct leaP32(eRegP dst, indOffset32 mem) %{
 5929   match(Set dst mem);
 5930 
 5931   ins_cost(110);
 5932   format %{ &quot;LEA    $dst,$mem&quot; %}
 5933   opcode(0x8D);
 5934   ins_encode( OpcP, RegMem(dst,mem));
 5935   ins_pipe( ialu_reg_reg_fat );
 5936 %}
 5937 
 5938 instruct leaPIdxOff(eRegP dst, indIndexOffset mem) %{
 5939   match(Set dst mem);
 5940 
 5941   ins_cost(110);
 5942   format %{ &quot;LEA    $dst,$mem&quot; %}
 5943   opcode(0x8D);
 5944   ins_encode( OpcP, RegMem(dst,mem));
 5945   ins_pipe( ialu_reg_reg_fat );
 5946 %}
 5947 
 5948 instruct leaPIdxScale(eRegP dst, indIndexScale mem) %{
 5949   match(Set dst mem);
 5950 
 5951   ins_cost(110);
 5952   format %{ &quot;LEA    $dst,$mem&quot; %}
 5953   opcode(0x8D);
 5954   ins_encode( OpcP, RegMem(dst,mem));
 5955   ins_pipe( ialu_reg_reg_fat );
 5956 %}
 5957 
 5958 instruct leaPIdxScaleOff(eRegP dst, indIndexScaleOffset mem) %{
 5959   match(Set dst mem);
 5960 
 5961   ins_cost(110);
 5962   format %{ &quot;LEA    $dst,$mem&quot; %}
 5963   opcode(0x8D);
 5964   ins_encode( OpcP, RegMem(dst,mem));
 5965   ins_pipe( ialu_reg_reg_fat );
 5966 %}
 5967 
 5968 // Load Constant
 5969 instruct loadConI(rRegI dst, immI src) %{
 5970   match(Set dst src);
 5971 
 5972   format %{ &quot;MOV    $dst,$src&quot; %}
 5973   ins_encode( LdImmI(dst, src) );
 5974   ins_pipe( ialu_reg_fat );
 5975 %}
 5976 
 5977 // Load Constant zero
 5978 instruct loadConI0(rRegI dst, immI0 src, eFlagsReg cr) %{
 5979   match(Set dst src);
 5980   effect(KILL cr);
 5981 
 5982   ins_cost(50);
 5983   format %{ &quot;XOR    $dst,$dst&quot; %}
 5984   opcode(0x33);  /* + rd */
 5985   ins_encode( OpcP, RegReg( dst, dst ) );
 5986   ins_pipe( ialu_reg );
 5987 %}
 5988 
 5989 instruct loadConP(eRegP dst, immP src) %{
 5990   match(Set dst src);
 5991 
 5992   format %{ &quot;MOV    $dst,$src&quot; %}
 5993   opcode(0xB8);  /* + rd */
 5994   ins_encode( LdImmP(dst, src) );
 5995   ins_pipe( ialu_reg_fat );
 5996 %}
 5997 
 5998 instruct loadConL(eRegL dst, immL src, eFlagsReg cr) %{
 5999   match(Set dst src);
 6000   effect(KILL cr);
 6001   ins_cost(200);
 6002   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
 6003             &quot;MOV    $dst.hi,$src.hi&quot; %}
 6004   opcode(0xB8);
 6005   ins_encode( LdImmL_Lo(dst, src), LdImmL_Hi(dst, src) );
 6006   ins_pipe( ialu_reg_long_fat );
 6007 %}
 6008 
 6009 instruct loadConL0(eRegL dst, immL0 src, eFlagsReg cr) %{
 6010   match(Set dst src);
 6011   effect(KILL cr);
 6012   ins_cost(150);
 6013   format %{ &quot;XOR    $dst.lo,$dst.lo\n\t&quot;
 6014             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 6015   opcode(0x33,0x33);
 6016   ins_encode( RegReg_Lo(dst,dst), RegReg_Hi(dst, dst) );
 6017   ins_pipe( ialu_reg_long );
 6018 %}
 6019 
 6020 // The instruction usage is guarded by predicate in operand immFPR().
 6021 instruct loadConFPR(regFPR dst, immFPR con) %{
 6022   match(Set dst con);
 6023   ins_cost(125);
 6024   format %{ &quot;FLD_S  ST,[$constantaddress]\t# load from constant table: float=$con\n\t&quot;
 6025             &quot;FSTP   $dst&quot; %}
 6026   ins_encode %{
 6027     __ fld_s($constantaddress($con));
 6028     __ fstp_d($dst$$reg);
 6029   %}
 6030   ins_pipe(fpu_reg_con);
 6031 %}
 6032 
 6033 // The instruction usage is guarded by predicate in operand immFPR0().
 6034 instruct loadConFPR0(regFPR dst, immFPR0 con) %{
 6035   match(Set dst con);
 6036   ins_cost(125);
 6037   format %{ &quot;FLDZ   ST\n\t&quot;
 6038             &quot;FSTP   $dst&quot; %}
 6039   ins_encode %{
 6040     __ fldz();
 6041     __ fstp_d($dst$$reg);
 6042   %}
 6043   ins_pipe(fpu_reg_con);
 6044 %}
 6045 
 6046 // The instruction usage is guarded by predicate in operand immFPR1().
 6047 instruct loadConFPR1(regFPR dst, immFPR1 con) %{
 6048   match(Set dst con);
 6049   ins_cost(125);
 6050   format %{ &quot;FLD1   ST\n\t&quot;
 6051             &quot;FSTP   $dst&quot; %}
 6052   ins_encode %{
 6053     __ fld1();
 6054     __ fstp_d($dst$$reg);
 6055   %}
 6056   ins_pipe(fpu_reg_con);
 6057 %}
 6058 
 6059 // The instruction usage is guarded by predicate in operand immF().
 6060 instruct loadConF(regF dst, immF con) %{
 6061   match(Set dst con);
 6062   ins_cost(125);
 6063   format %{ &quot;MOVSS  $dst,[$constantaddress]\t# load from constant table: float=$con&quot; %}
 6064   ins_encode %{
 6065     __ movflt($dst$$XMMRegister, $constantaddress($con));
 6066   %}
 6067   ins_pipe(pipe_slow);
 6068 %}
 6069 
 6070 // The instruction usage is guarded by predicate in operand immF0().
 6071 instruct loadConF0(regF dst, immF0 src) %{
 6072   match(Set dst src);
 6073   ins_cost(100);
 6074   format %{ &quot;XORPS  $dst,$dst\t# float 0.0&quot; %}
 6075   ins_encode %{
 6076     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 6077   %}
 6078   ins_pipe(pipe_slow);
 6079 %}
 6080 
 6081 // The instruction usage is guarded by predicate in operand immDPR().
 6082 instruct loadConDPR(regDPR dst, immDPR con) %{
 6083   match(Set dst con);
 6084   ins_cost(125);
 6085 
 6086   format %{ &quot;FLD_D  ST,[$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 6087             &quot;FSTP   $dst&quot; %}
 6088   ins_encode %{
 6089     __ fld_d($constantaddress($con));
 6090     __ fstp_d($dst$$reg);
 6091   %}
 6092   ins_pipe(fpu_reg_con);
 6093 %}
 6094 
 6095 // The instruction usage is guarded by predicate in operand immDPR0().
 6096 instruct loadConDPR0(regDPR dst, immDPR0 con) %{
 6097   match(Set dst con);
 6098   ins_cost(125);
 6099 
 6100   format %{ &quot;FLDZ   ST\n\t&quot;
 6101             &quot;FSTP   $dst&quot; %}
 6102   ins_encode %{
 6103     __ fldz();
 6104     __ fstp_d($dst$$reg);
 6105   %}
 6106   ins_pipe(fpu_reg_con);
 6107 %}
 6108 
 6109 // The instruction usage is guarded by predicate in operand immDPR1().
 6110 instruct loadConDPR1(regDPR dst, immDPR1 con) %{
 6111   match(Set dst con);
 6112   ins_cost(125);
 6113 
 6114   format %{ &quot;FLD1   ST\n\t&quot;
 6115             &quot;FSTP   $dst&quot; %}
 6116   ins_encode %{
 6117     __ fld1();
 6118     __ fstp_d($dst$$reg);
 6119   %}
 6120   ins_pipe(fpu_reg_con);
 6121 %}
 6122 
 6123 // The instruction usage is guarded by predicate in operand immD().
 6124 instruct loadConD(regD dst, immD con) %{
 6125   match(Set dst con);
 6126   ins_cost(125);
 6127   format %{ &quot;MOVSD  $dst,[$constantaddress]\t# load from constant table: double=$con&quot; %}
 6128   ins_encode %{
 6129     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 6130   %}
 6131   ins_pipe(pipe_slow);
 6132 %}
 6133 
 6134 // The instruction usage is guarded by predicate in operand immD0().
 6135 instruct loadConD0(regD dst, immD0 src) %{
 6136   match(Set dst src);
 6137   ins_cost(100);
 6138   format %{ &quot;XORPD  $dst,$dst\t# double 0.0&quot; %}
 6139   ins_encode %{
 6140     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 6141   %}
 6142   ins_pipe( pipe_slow );
 6143 %}
 6144 
 6145 // Load Stack Slot
 6146 instruct loadSSI(rRegI dst, stackSlotI src) %{
 6147   match(Set dst src);
 6148   ins_cost(125);
 6149 
 6150   format %{ &quot;MOV    $dst,$src&quot; %}
 6151   opcode(0x8B);
 6152   ins_encode( OpcP, RegMem(dst,src));
 6153   ins_pipe( ialu_reg_mem );
 6154 %}
 6155 
 6156 instruct loadSSL(eRegL dst, stackSlotL src) %{
 6157   match(Set dst src);
 6158 
 6159   ins_cost(200);
 6160   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6161             &quot;MOV    $dst+4,$src.hi&quot; %}
 6162   opcode(0x8B, 0x8B);
 6163   ins_encode( OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ) );
 6164   ins_pipe( ialu_mem_long_reg );
 6165 %}
 6166 
 6167 // Load Stack Slot
 6168 instruct loadSSP(eRegP dst, stackSlotP src) %{
 6169   match(Set dst src);
 6170   ins_cost(125);
 6171 
 6172   format %{ &quot;MOV    $dst,$src&quot; %}
 6173   opcode(0x8B);
 6174   ins_encode( OpcP, RegMem(dst,src));
 6175   ins_pipe( ialu_reg_mem );
 6176 %}
 6177 
 6178 // Load Stack Slot
 6179 instruct loadSSF(regFPR dst, stackSlotF src) %{
 6180   match(Set dst src);
 6181   ins_cost(125);
 6182 
 6183   format %{ &quot;FLD_S  $src\n\t&quot;
 6184             &quot;FSTP   $dst&quot; %}
 6185   opcode(0xD9);               /* D9 /0, FLD m32real */
 6186   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6187               Pop_Reg_FPR(dst) );
 6188   ins_pipe( fpu_reg_mem );
 6189 %}
 6190 
 6191 // Load Stack Slot
 6192 instruct loadSSD(regDPR dst, stackSlotD src) %{
 6193   match(Set dst src);
 6194   ins_cost(125);
 6195 
 6196   format %{ &quot;FLD_D  $src\n\t&quot;
 6197             &quot;FSTP   $dst&quot; %}
 6198   opcode(0xDD);               /* DD /0, FLD m64real */
 6199   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6200               Pop_Reg_DPR(dst) );
 6201   ins_pipe( fpu_reg_mem );
 6202 %}
 6203 
 6204 // Prefetch instructions for allocation.
 6205 // Must be safe to execute with invalid address (cannot fault).
 6206 
 6207 instruct prefetchAlloc0( memory mem ) %{
 6208   predicate(UseSSE==0 &amp;&amp; AllocatePrefetchInstr!=3);
 6209   match(PrefetchAllocation mem);
 6210   ins_cost(0);
 6211   size(0);
 6212   format %{ &quot;Prefetch allocation (non-SSE is empty encoding)&quot; %}
 6213   ins_encode();
 6214   ins_pipe(empty);
 6215 %}
 6216 
 6217 instruct prefetchAlloc( memory mem ) %{
 6218   predicate(AllocatePrefetchInstr==3);
 6219   match( PrefetchAllocation mem );
 6220   ins_cost(100);
 6221 
 6222   format %{ &quot;PREFETCHW $mem\t! Prefetch allocation into L1 cache and mark modified&quot; %}
 6223   ins_encode %{
 6224     __ prefetchw($mem$$Address);
 6225   %}
 6226   ins_pipe(ialu_mem);
 6227 %}
 6228 
 6229 instruct prefetchAllocNTA( memory mem ) %{
 6230   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==0);
 6231   match(PrefetchAllocation mem);
 6232   ins_cost(100);
 6233 
 6234   format %{ &quot;PREFETCHNTA $mem\t! Prefetch allocation into non-temporal cache for write&quot; %}
 6235   ins_encode %{
 6236     __ prefetchnta($mem$$Address);
 6237   %}
 6238   ins_pipe(ialu_mem);
 6239 %}
 6240 
 6241 instruct prefetchAllocT0( memory mem ) %{
 6242   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==1);
 6243   match(PrefetchAllocation mem);
 6244   ins_cost(100);
 6245 
 6246   format %{ &quot;PREFETCHT0 $mem\t! Prefetch allocation into L1 and L2 caches for write&quot; %}
 6247   ins_encode %{
 6248     __ prefetcht0($mem$$Address);
 6249   %}
 6250   ins_pipe(ialu_mem);
 6251 %}
 6252 
 6253 instruct prefetchAllocT2( memory mem ) %{
 6254   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==2);
 6255   match(PrefetchAllocation mem);
 6256   ins_cost(100);
 6257 
 6258   format %{ &quot;PREFETCHT2 $mem\t! Prefetch allocation into L2 cache for write&quot; %}
 6259   ins_encode %{
 6260     __ prefetcht2($mem$$Address);
 6261   %}
 6262   ins_pipe(ialu_mem);
 6263 %}
 6264 
 6265 //----------Store Instructions-------------------------------------------------
 6266 
 6267 // Store Byte
 6268 instruct storeB(memory mem, xRegI src) %{
 6269   match(Set mem (StoreB mem src));
 6270 
 6271   ins_cost(125);
 6272   format %{ &quot;MOV8   $mem,$src&quot; %}
 6273   opcode(0x88);
 6274   ins_encode( OpcP, RegMem( src, mem ) );
 6275   ins_pipe( ialu_mem_reg );
 6276 %}
 6277 
 6278 // Store Char/Short
 6279 instruct storeC(memory mem, rRegI src) %{
 6280   match(Set mem (StoreC mem src));
 6281 
 6282   ins_cost(125);
 6283   format %{ &quot;MOV16  $mem,$src&quot; %}
 6284   opcode(0x89, 0x66);
 6285   ins_encode( OpcS, OpcP, RegMem( src, mem ) );
 6286   ins_pipe( ialu_mem_reg );
 6287 %}
 6288 
 6289 // Store Integer
 6290 instruct storeI(memory mem, rRegI src) %{
 6291   match(Set mem (StoreI mem src));
 6292 
 6293   ins_cost(125);
 6294   format %{ &quot;MOV    $mem,$src&quot; %}
 6295   opcode(0x89);
 6296   ins_encode( OpcP, RegMem( src, mem ) );
 6297   ins_pipe( ialu_mem_reg );
 6298 %}
 6299 
 6300 // Store Long
 6301 instruct storeL(long_memory mem, eRegL src) %{
 6302   predicate(!((StoreLNode*)n)-&gt;require_atomic_access());
 6303   match(Set mem (StoreL mem src));
 6304 
 6305   ins_cost(200);
 6306   format %{ &quot;MOV    $mem,$src.lo\n\t&quot;
 6307             &quot;MOV    $mem+4,$src.hi&quot; %}
 6308   opcode(0x89, 0x89);
 6309   ins_encode( OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ) );
 6310   ins_pipe( ialu_mem_long_reg );
 6311 %}
 6312 
 6313 // Store Long to Integer
 6314 instruct storeL2I(memory mem, eRegL src) %{
 6315   match(Set mem (StoreI mem (ConvL2I src)));
 6316 
 6317   format %{ &quot;MOV    $mem,$src.lo\t# long -&gt; int&quot; %}
 6318   ins_encode %{
 6319     __ movl($mem$$Address, $src$$Register);
 6320   %}
 6321   ins_pipe(ialu_mem_reg);
 6322 %}
 6323 
 6324 // Volatile Store Long.  Must be atomic, so move it into
 6325 // the FP TOS and then do a 64-bit FIST.  Has to probe the
 6326 // target address before the store (for null-ptr checks)
 6327 // so the memory operand is used twice in the encoding.
 6328 instruct storeL_volatile(memory mem, stackSlotL src, eFlagsReg cr ) %{
 6329   predicate(UseSSE&lt;=1 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6330   match(Set mem (StoreL mem src));
 6331   effect( KILL cr );
 6332   ins_cost(400);
 6333   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6334             &quot;FILD   $src\n\t&quot;
 6335             &quot;FISTp  $mem\t # 64-bit atomic volatile long store&quot; %}
 6336   opcode(0x3B);
 6337   ins_encode( OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src));
 6338   ins_pipe( fpu_reg_mem );
 6339 %}
 6340 
 6341 instruct storeLX_volatile(memory mem, stackSlotL src, regD tmp, eFlagsReg cr) %{
 6342   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6343   match(Set mem (StoreL mem src));
 6344   effect( TEMP tmp, KILL cr );
 6345   ins_cost(380);
 6346   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6347             &quot;MOVSD  $tmp,$src\n\t&quot;
 6348             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6349   ins_encode %{
 6350     __ cmpl(rax, $mem$$Address);
 6351     __ movdbl($tmp$$XMMRegister, Address(rsp, $src$$disp));
 6352     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6353   %}
 6354   ins_pipe( pipe_slow );
 6355 %}
 6356 
 6357 instruct storeLX_reg_volatile(memory mem, eRegL src, regD tmp2, regD tmp, eFlagsReg cr) %{
 6358   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6359   match(Set mem (StoreL mem src));
 6360   effect( TEMP tmp2 , TEMP tmp, KILL cr );
 6361   ins_cost(360);
 6362   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6363             &quot;MOVD   $tmp,$src.lo\n\t&quot;
 6364             &quot;MOVD   $tmp2,$src.hi\n\t&quot;
 6365             &quot;PUNPCKLDQ $tmp,$tmp2\n\t&quot;
 6366             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6367   ins_encode %{
 6368     __ cmpl(rax, $mem$$Address);
 6369     __ movdl($tmp$$XMMRegister, $src$$Register);
 6370     __ movdl($tmp2$$XMMRegister, HIGH_FROM_LOW($src$$Register));
 6371     __ punpckldq($tmp$$XMMRegister, $tmp2$$XMMRegister);
 6372     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6373   %}
 6374   ins_pipe( pipe_slow );
 6375 %}
 6376 
 6377 // Store Pointer; for storing unknown oops and raw pointers
 6378 instruct storeP(memory mem, anyRegP src) %{
 6379   match(Set mem (StoreP mem src));
 6380 
 6381   ins_cost(125);
 6382   format %{ &quot;MOV    $mem,$src&quot; %}
 6383   opcode(0x89);
 6384   ins_encode( OpcP, RegMem( src, mem ) );
 6385   ins_pipe( ialu_mem_reg );
 6386 %}
 6387 
 6388 // Store Integer Immediate
 6389 instruct storeImmI(memory mem, immI src) %{
 6390   match(Set mem (StoreI mem src));
 6391 
 6392   ins_cost(150);
 6393   format %{ &quot;MOV    $mem,$src&quot; %}
 6394   opcode(0xC7);               /* C7 /0 */
 6395   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6396   ins_pipe( ialu_mem_imm );
 6397 %}
 6398 
 6399 // Store Short/Char Immediate
 6400 instruct storeImmI16(memory mem, immI16 src) %{
 6401   predicate(UseStoreImmI16);
 6402   match(Set mem (StoreC mem src));
 6403 
 6404   ins_cost(150);
 6405   format %{ &quot;MOV16  $mem,$src&quot; %}
 6406   opcode(0xC7);     /* C7 /0 Same as 32 store immediate with prefix */
 6407   ins_encode( SizePrefix, OpcP, RMopc_Mem(0x00,mem),  Con16( src ));
 6408   ins_pipe( ialu_mem_imm );
 6409 %}
 6410 
 6411 // Store Pointer Immediate; null pointers or constant oops that do not
 6412 // need card-mark barriers.
 6413 instruct storeImmP(memory mem, immP src) %{
 6414   match(Set mem (StoreP mem src));
 6415 
 6416   ins_cost(150);
 6417   format %{ &quot;MOV    $mem,$src&quot; %}
 6418   opcode(0xC7);               /* C7 /0 */
 6419   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6420   ins_pipe( ialu_mem_imm );
 6421 %}
 6422 
 6423 // Store Byte Immediate
 6424 instruct storeImmB(memory mem, immI8 src) %{
 6425   match(Set mem (StoreB mem src));
 6426 
 6427   ins_cost(150);
 6428   format %{ &quot;MOV8   $mem,$src&quot; %}
 6429   opcode(0xC6);               /* C6 /0 */
 6430   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6431   ins_pipe( ialu_mem_imm );
 6432 %}
 6433 
 6434 // Store CMS card-mark Immediate
 6435 instruct storeImmCM(memory mem, immI8 src) %{
 6436   match(Set mem (StoreCM mem src));
 6437 
 6438   ins_cost(150);
 6439   format %{ &quot;MOV8   $mem,$src\t! CMS card-mark imm0&quot; %}
 6440   opcode(0xC6);               /* C6 /0 */
 6441   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6442   ins_pipe( ialu_mem_imm );
 6443 %}
 6444 
 6445 // Store Double
 6446 instruct storeDPR( memory mem, regDPR1 src) %{
 6447   predicate(UseSSE&lt;=1);
 6448   match(Set mem (StoreD mem src));
 6449 
 6450   ins_cost(100);
 6451   format %{ &quot;FST_D  $mem,$src&quot; %}
 6452   opcode(0xDD);       /* DD /2 */
 6453   ins_encode( enc_FPR_store(mem,src) );
 6454   ins_pipe( fpu_mem_reg );
 6455 %}
 6456 
 6457 // Store double does rounding on x86
 6458 instruct storeDPR_rounded( memory mem, regDPR1 src) %{
 6459   predicate(UseSSE&lt;=1);
 6460   match(Set mem (StoreD mem (RoundDouble src)));
 6461 
 6462   ins_cost(100);
 6463   format %{ &quot;FST_D  $mem,$src\t# round&quot; %}
 6464   opcode(0xDD);       /* DD /2 */
 6465   ins_encode( enc_FPR_store(mem,src) );
 6466   ins_pipe( fpu_mem_reg );
 6467 %}
 6468 
 6469 // Store XMM register to memory (double-precision floating points)
 6470 // MOVSD instruction
 6471 instruct storeD(memory mem, regD src) %{
 6472   predicate(UseSSE&gt;=2);
 6473   match(Set mem (StoreD mem src));
 6474   ins_cost(95);
 6475   format %{ &quot;MOVSD  $mem,$src&quot; %}
 6476   ins_encode %{
 6477     __ movdbl($mem$$Address, $src$$XMMRegister);
 6478   %}
 6479   ins_pipe( pipe_slow );
 6480 %}
 6481 
 6482 // Load Double
 6483 instruct MoveD2VL(vlRegD dst, regD src) %{
 6484   match(Set dst src);
 6485   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6486   ins_encode %{
 6487     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6488   %}
 6489   ins_pipe( fpu_reg_reg );
 6490 %}
 6491 
 6492 // Load Double
 6493 instruct MoveVL2D(regD dst, vlRegD src) %{
 6494   match(Set dst src);
 6495   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6496   ins_encode %{
 6497     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6498   %}
 6499   ins_pipe( fpu_reg_reg );
 6500 %}
 6501 
 6502 // Store XMM register to memory (single-precision floating point)
 6503 // MOVSS instruction
 6504 instruct storeF(memory mem, regF src) %{
 6505   predicate(UseSSE&gt;=1);
 6506   match(Set mem (StoreF mem src));
 6507   ins_cost(95);
 6508   format %{ &quot;MOVSS  $mem,$src&quot; %}
 6509   ins_encode %{
 6510     __ movflt($mem$$Address, $src$$XMMRegister);
 6511   %}
 6512   ins_pipe( pipe_slow );
 6513 %}
 6514 
 6515 // Load Float
 6516 instruct MoveF2VL(vlRegF dst, regF src) %{
 6517   match(Set dst src);
 6518   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6519   ins_encode %{
 6520     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6521   %}
 6522   ins_pipe( fpu_reg_reg );
 6523 %}
 6524 
 6525 // Load Float
 6526 instruct MoveVL2F(regF dst, vlRegF src) %{
 6527   match(Set dst src);
 6528   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6529   ins_encode %{
 6530     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6531   %}
 6532   ins_pipe( fpu_reg_reg );
 6533 %}
 6534 
 6535 // Store Float
 6536 instruct storeFPR( memory mem, regFPR1 src) %{
 6537   predicate(UseSSE==0);
 6538   match(Set mem (StoreF mem src));
 6539 
 6540   ins_cost(100);
 6541   format %{ &quot;FST_S  $mem,$src&quot; %}
 6542   opcode(0xD9);       /* D9 /2 */
 6543   ins_encode( enc_FPR_store(mem,src) );
 6544   ins_pipe( fpu_mem_reg );
 6545 %}
 6546 
 6547 // Store Float does rounding on x86
 6548 instruct storeFPR_rounded( memory mem, regFPR1 src) %{
 6549   predicate(UseSSE==0);
 6550   match(Set mem (StoreF mem (RoundFloat src)));
 6551 
 6552   ins_cost(100);
 6553   format %{ &quot;FST_S  $mem,$src\t# round&quot; %}
 6554   opcode(0xD9);       /* D9 /2 */
 6555   ins_encode( enc_FPR_store(mem,src) );
 6556   ins_pipe( fpu_mem_reg );
 6557 %}
 6558 
 6559 // Store Float does rounding on x86
 6560 instruct storeFPR_Drounded( memory mem, regDPR1 src) %{
 6561   predicate(UseSSE&lt;=1);
 6562   match(Set mem (StoreF mem (ConvD2F src)));
 6563 
 6564   ins_cost(100);
 6565   format %{ &quot;FST_S  $mem,$src\t# D-round&quot; %}
 6566   opcode(0xD9);       /* D9 /2 */
 6567   ins_encode( enc_FPR_store(mem,src) );
 6568   ins_pipe( fpu_mem_reg );
 6569 %}
 6570 
 6571 // Store immediate Float value (it is faster than store from FPU register)
 6572 // The instruction usage is guarded by predicate in operand immFPR().
 6573 instruct storeFPR_imm( memory mem, immFPR src) %{
 6574   match(Set mem (StoreF mem src));
 6575 
 6576   ins_cost(50);
 6577   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6578   opcode(0xC7);               /* C7 /0 */
 6579   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits( src ));
 6580   ins_pipe( ialu_mem_imm );
 6581 %}
 6582 
 6583 // Store immediate Float value (it is faster than store from XMM register)
 6584 // The instruction usage is guarded by predicate in operand immF().
 6585 instruct storeF_imm( memory mem, immF src) %{
 6586   match(Set mem (StoreF mem src));
 6587 
 6588   ins_cost(50);
 6589   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6590   opcode(0xC7);               /* C7 /0 */
 6591   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits( src ));
 6592   ins_pipe( ialu_mem_imm );
 6593 %}
 6594 
 6595 // Store Integer to stack slot
 6596 instruct storeSSI(stackSlotI dst, rRegI src) %{
 6597   match(Set dst src);
 6598 
 6599   ins_cost(100);
 6600   format %{ &quot;MOV    $dst,$src&quot; %}
 6601   opcode(0x89);
 6602   ins_encode( OpcPRegSS( dst, src ) );
 6603   ins_pipe( ialu_mem_reg );
 6604 %}
 6605 
 6606 // Store Integer to stack slot
 6607 instruct storeSSP(stackSlotP dst, eRegP src) %{
 6608   match(Set dst src);
 6609 
 6610   ins_cost(100);
 6611   format %{ &quot;MOV    $dst,$src&quot; %}
 6612   opcode(0x89);
 6613   ins_encode( OpcPRegSS( dst, src ) );
 6614   ins_pipe( ialu_mem_reg );
 6615 %}
 6616 
 6617 // Store Long to stack slot
 6618 instruct storeSSL(stackSlotL dst, eRegL src) %{
 6619   match(Set dst src);
 6620 
 6621   ins_cost(200);
 6622   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6623             &quot;MOV    $dst+4,$src.hi&quot; %}
 6624   opcode(0x89, 0x89);
 6625   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
 6626   ins_pipe( ialu_mem_long_reg );
 6627 %}
 6628 
 6629 //----------MemBar Instructions-----------------------------------------------
 6630 // Memory barrier flavors
 6631 
 6632 instruct membar_acquire() %{
 6633   match(MemBarAcquire);
 6634   match(LoadFence);
 6635   ins_cost(400);
 6636 
 6637   size(0);
 6638   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6639   ins_encode();
 6640   ins_pipe(empty);
 6641 %}
 6642 
 6643 instruct membar_acquire_lock() %{
 6644   match(MemBarAcquireLock);
 6645   ins_cost(0);
 6646 
 6647   size(0);
 6648   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6649   ins_encode( );
 6650   ins_pipe(empty);
 6651 %}
 6652 
 6653 instruct membar_release() %{
 6654   match(MemBarRelease);
 6655   match(StoreFence);
 6656   ins_cost(400);
 6657 
 6658   size(0);
 6659   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6660   ins_encode( );
 6661   ins_pipe(empty);
 6662 %}
 6663 
 6664 instruct membar_release_lock() %{
 6665   match(MemBarReleaseLock);
 6666   ins_cost(0);
 6667 
 6668   size(0);
 6669   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6670   ins_encode( );
 6671   ins_pipe(empty);
 6672 %}
 6673 
 6674 instruct membar_volatile(eFlagsReg cr) %{
 6675   match(MemBarVolatile);
 6676   effect(KILL cr);
 6677   ins_cost(400);
 6678 
 6679   format %{
 6680     $$template
 6681     $$emit$$&quot;LOCK ADDL [ESP + #0], 0\t! membar_volatile&quot;
 6682   %}
 6683   ins_encode %{
 6684     __ membar(Assembler::StoreLoad);
 6685   %}
 6686   ins_pipe(pipe_slow);
 6687 %}
 6688 
 6689 instruct unnecessary_membar_volatile() %{
 6690   match(MemBarVolatile);
 6691   predicate(Matcher::post_store_load_barrier(n));
 6692   ins_cost(0);
 6693 
 6694   size(0);
 6695   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6696   ins_encode( );
 6697   ins_pipe(empty);
 6698 %}
 6699 
 6700 instruct membar_storestore() %{
 6701   match(MemBarStoreStore);
 6702   ins_cost(0);
 6703 
 6704   size(0);
 6705   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6706   ins_encode( );
 6707   ins_pipe(empty);
 6708 %}
 6709 
 6710 //----------Move Instructions--------------------------------------------------
 6711 instruct castX2P(eAXRegP dst, eAXRegI src) %{
 6712   match(Set dst (CastX2P src));
 6713   format %{ &quot;# X2P  $dst, $src&quot; %}
 6714   ins_encode( /*empty encoding*/ );
 6715   ins_cost(0);
 6716   ins_pipe(empty);
 6717 %}
 6718 
 6719 instruct castP2X(rRegI dst, eRegP src ) %{
 6720   match(Set dst (CastP2X src));
 6721   ins_cost(50);
 6722   format %{ &quot;MOV    $dst, $src\t# CastP2X&quot; %}
 6723   ins_encode( enc_Copy( dst, src) );
 6724   ins_pipe( ialu_reg_reg );
 6725 %}
 6726 
 6727 //----------Conditional Move---------------------------------------------------
 6728 // Conditional move
 6729 instruct jmovI_reg(cmpOp cop, eFlagsReg cr, rRegI dst, rRegI src) %{
 6730   predicate(!VM_Version::supports_cmov() );
 6731   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6732   ins_cost(200);
 6733   format %{ &quot;J$cop,us skip\t# signed cmove\n\t&quot;
 6734             &quot;MOV    $dst,$src\n&quot;
 6735       &quot;skip:&quot; %}
 6736   ins_encode %{
 6737     Label Lskip;
 6738     // Invert sense of branch from sense of CMOV
 6739     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6740     __ movl($dst$$Register, $src$$Register);
 6741     __ bind(Lskip);
 6742   %}
 6743   ins_pipe( pipe_cmov_reg );
 6744 %}
 6745 
 6746 instruct jmovI_regU(cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src) %{
 6747   predicate(!VM_Version::supports_cmov() );
 6748   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6749   ins_cost(200);
 6750   format %{ &quot;J$cop,us skip\t# unsigned cmove\n\t&quot;
 6751             &quot;MOV    $dst,$src\n&quot;
 6752       &quot;skip:&quot; %}
 6753   ins_encode %{
 6754     Label Lskip;
 6755     // Invert sense of branch from sense of CMOV
 6756     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6757     __ movl($dst$$Register, $src$$Register);
 6758     __ bind(Lskip);
 6759   %}
 6760   ins_pipe( pipe_cmov_reg );
 6761 %}
 6762 
 6763 instruct cmovI_reg(rRegI dst, rRegI src, eFlagsReg cr, cmpOp cop ) %{
 6764   predicate(VM_Version::supports_cmov() );
 6765   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6766   ins_cost(200);
 6767   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6768   opcode(0x0F,0x40);
 6769   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6770   ins_pipe( pipe_cmov_reg );
 6771 %}
 6772 
 6773 instruct cmovI_regU( cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src ) %{
 6774   predicate(VM_Version::supports_cmov() );
 6775   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6776   ins_cost(200);
 6777   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6778   opcode(0x0F,0x40);
 6779   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6780   ins_pipe( pipe_cmov_reg );
 6781 %}
 6782 
 6783 instruct cmovI_regUCF( cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, rRegI src ) %{
 6784   predicate(VM_Version::supports_cmov() );
 6785   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6786   ins_cost(200);
 6787   expand %{
 6788     cmovI_regU(cop, cr, dst, src);
 6789   %}
 6790 %}
 6791 
 6792 // Conditional move
 6793 instruct cmovI_mem(cmpOp cop, eFlagsReg cr, rRegI dst, memory src) %{
 6794   predicate(VM_Version::supports_cmov() );
 6795   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6796   ins_cost(250);
 6797   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6798   opcode(0x0F,0x40);
 6799   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6800   ins_pipe( pipe_cmov_mem );
 6801 %}
 6802 
 6803 // Conditional move
 6804 instruct cmovI_memU(cmpOpU cop, eFlagsRegU cr, rRegI dst, memory src) %{
 6805   predicate(VM_Version::supports_cmov() );
 6806   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6807   ins_cost(250);
 6808   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6809   opcode(0x0F,0x40);
 6810   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6811   ins_pipe( pipe_cmov_mem );
 6812 %}
 6813 
 6814 instruct cmovI_memUCF(cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, memory src) %{
 6815   predicate(VM_Version::supports_cmov() );
 6816   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6817   ins_cost(250);
 6818   expand %{
 6819     cmovI_memU(cop, cr, dst, src);
 6820   %}
 6821 %}
 6822 
 6823 // Conditional move
 6824 instruct cmovP_reg(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6825   predicate(VM_Version::supports_cmov() );
 6826   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6827   ins_cost(200);
 6828   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6829   opcode(0x0F,0x40);
 6830   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6831   ins_pipe( pipe_cmov_reg );
 6832 %}
 6833 
 6834 // Conditional move (non-P6 version)
 6835 // Note:  a CMoveP is generated for  stubs and native wrappers
 6836 //        regardless of whether we are on a P6, so we
 6837 //        emulate a cmov here
 6838 instruct cmovP_reg_nonP6(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6839   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6840   ins_cost(300);
 6841   format %{ &quot;Jn$cop   skip\n\t&quot;
 6842           &quot;MOV    $dst,$src\t# pointer\n&quot;
 6843       &quot;skip:&quot; %}
 6844   opcode(0x8b);
 6845   ins_encode( enc_cmov_branch(cop, 0x2), OpcP, RegReg(dst, src));
 6846   ins_pipe( pipe_cmov_reg );
 6847 %}
 6848 
 6849 // Conditional move
 6850 instruct cmovP_regU(cmpOpU cop, eFlagsRegU cr, eRegP dst, eRegP src ) %{
 6851   predicate(VM_Version::supports_cmov() );
 6852   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6853   ins_cost(200);
 6854   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6855   opcode(0x0F,0x40);
 6856   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6857   ins_pipe( pipe_cmov_reg );
 6858 %}
 6859 
 6860 instruct cmovP_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegP dst, eRegP src ) %{
 6861   predicate(VM_Version::supports_cmov() );
 6862   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6863   ins_cost(200);
 6864   expand %{
 6865     cmovP_regU(cop, cr, dst, src);
 6866   %}
 6867 %}
 6868 
 6869 // DISABLED: Requires the ADLC to emit a bottom_type call that
 6870 // correctly meets the two pointer arguments; one is an incoming
 6871 // register but the other is a memory operand.  ALSO appears to
 6872 // be buggy with implicit null checks.
 6873 //
 6874 //// Conditional move
 6875 //instruct cmovP_mem(cmpOp cop, eFlagsReg cr, eRegP dst, memory src) %{
 6876 //  predicate(VM_Version::supports_cmov() );
 6877 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6878 //  ins_cost(250);
 6879 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6880 //  opcode(0x0F,0x40);
 6881 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6882 //  ins_pipe( pipe_cmov_mem );
 6883 //%}
 6884 //
 6885 //// Conditional move
 6886 //instruct cmovP_memU(cmpOpU cop, eFlagsRegU cr, eRegP dst, memory src) %{
 6887 //  predicate(VM_Version::supports_cmov() );
 6888 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6889 //  ins_cost(250);
 6890 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6891 //  opcode(0x0F,0x40);
 6892 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6893 //  ins_pipe( pipe_cmov_mem );
 6894 //%}
 6895 
 6896 // Conditional move
 6897 instruct fcmovDPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regDPR1 dst, regDPR src) %{
 6898   predicate(UseSSE&lt;=1);
 6899   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6900   ins_cost(200);
 6901   format %{ &quot;FCMOV$cop $dst,$src\t# double&quot; %}
 6902   opcode(0xDA);
 6903   ins_encode( enc_cmov_dpr(cop,src) );
 6904   ins_pipe( pipe_cmovDPR_reg );
 6905 %}
 6906 
 6907 // Conditional move
 6908 instruct fcmovFPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regFPR1 dst, regFPR src) %{
 6909   predicate(UseSSE==0);
 6910   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6911   ins_cost(200);
 6912   format %{ &quot;FCMOV$cop $dst,$src\t# float&quot; %}
 6913   opcode(0xDA);
 6914   ins_encode( enc_cmov_dpr(cop,src) );
 6915   ins_pipe( pipe_cmovDPR_reg );
 6916 %}
 6917 
 6918 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6919 instruct fcmovDPR_regS(cmpOp cop, eFlagsReg cr, regDPR dst, regDPR src) %{
 6920   predicate(UseSSE&lt;=1);
 6921   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6922   ins_cost(200);
 6923   format %{ &quot;Jn$cop   skip\n\t&quot;
 6924             &quot;MOV    $dst,$src\t# double\n&quot;
 6925       &quot;skip:&quot; %}
 6926   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6927   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_DPR(src), OpcP, RegOpc(dst) );
 6928   ins_pipe( pipe_cmovDPR_reg );
 6929 %}
 6930 
 6931 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6932 instruct fcmovFPR_regS(cmpOp cop, eFlagsReg cr, regFPR dst, regFPR src) %{
 6933   predicate(UseSSE==0);
 6934   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6935   ins_cost(200);
 6936   format %{ &quot;Jn$cop    skip\n\t&quot;
 6937             &quot;MOV    $dst,$src\t# float\n&quot;
 6938       &quot;skip:&quot; %}
 6939   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6940   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_FPR(src), OpcP, RegOpc(dst) );
 6941   ins_pipe( pipe_cmovDPR_reg );
 6942 %}
 6943 
 6944 // No CMOVE with SSE/SSE2
 6945 instruct fcmovF_regS(cmpOp cop, eFlagsReg cr, regF dst, regF src) %{
 6946   predicate (UseSSE&gt;=1);
 6947   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6948   ins_cost(200);
 6949   format %{ &quot;Jn$cop   skip\n\t&quot;
 6950             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6951       &quot;skip:&quot; %}
 6952   ins_encode %{
 6953     Label skip;
 6954     // Invert sense of branch from sense of CMOV
 6955     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6956     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6957     __ bind(skip);
 6958   %}
 6959   ins_pipe( pipe_slow );
 6960 %}
 6961 
 6962 // No CMOVE with SSE/SSE2
 6963 instruct fcmovD_regS(cmpOp cop, eFlagsReg cr, regD dst, regD src) %{
 6964   predicate (UseSSE&gt;=2);
 6965   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6966   ins_cost(200);
 6967   format %{ &quot;Jn$cop   skip\n\t&quot;
 6968             &quot;MOVSD  $dst,$src\t# float\n&quot;
 6969       &quot;skip:&quot; %}
 6970   ins_encode %{
 6971     Label skip;
 6972     // Invert sense of branch from sense of CMOV
 6973     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6974     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6975     __ bind(skip);
 6976   %}
 6977   ins_pipe( pipe_slow );
 6978 %}
 6979 
 6980 // unsigned version
 6981 instruct fcmovF_regU(cmpOpU cop, eFlagsRegU cr, regF dst, regF src) %{
 6982   predicate (UseSSE&gt;=1);
 6983   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6984   ins_cost(200);
 6985   format %{ &quot;Jn$cop   skip\n\t&quot;
 6986             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6987       &quot;skip:&quot; %}
 6988   ins_encode %{
 6989     Label skip;
 6990     // Invert sense of branch from sense of CMOV
 6991     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6992     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6993     __ bind(skip);
 6994   %}
 6995   ins_pipe( pipe_slow );
 6996 %}
 6997 
 6998 instruct fcmovF_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regF dst, regF src) %{
 6999   predicate (UseSSE&gt;=1);
 7000   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7001   ins_cost(200);
 7002   expand %{
 7003     fcmovF_regU(cop, cr, dst, src);
 7004   %}
 7005 %}
 7006 
 7007 // unsigned version
 7008 instruct fcmovD_regU(cmpOpU cop, eFlagsRegU cr, regD dst, regD src) %{
 7009   predicate (UseSSE&gt;=2);
 7010   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7011   ins_cost(200);
 7012   format %{ &quot;Jn$cop   skip\n\t&quot;
 7013             &quot;MOVSD  $dst,$src\t# float\n&quot;
 7014       &quot;skip:&quot; %}
 7015   ins_encode %{
 7016     Label skip;
 7017     // Invert sense of branch from sense of CMOV
 7018     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7019     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7020     __ bind(skip);
 7021   %}
 7022   ins_pipe( pipe_slow );
 7023 %}
 7024 
 7025 instruct fcmovD_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regD dst, regD src) %{
 7026   predicate (UseSSE&gt;=2);
 7027   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7028   ins_cost(200);
 7029   expand %{
 7030     fcmovD_regU(cop, cr, dst, src);
 7031   %}
 7032 %}
 7033 
 7034 instruct cmovL_reg(cmpOp cop, eFlagsReg cr, eRegL dst, eRegL src) %{
 7035   predicate(VM_Version::supports_cmov() );
 7036   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7037   ins_cost(200);
 7038   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7039             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7040   opcode(0x0F,0x40);
 7041   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7042   ins_pipe( pipe_cmov_reg_long );
 7043 %}
 7044 
 7045 instruct cmovL_regU(cmpOpU cop, eFlagsRegU cr, eRegL dst, eRegL src) %{
 7046   predicate(VM_Version::supports_cmov() );
 7047   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7048   ins_cost(200);
 7049   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7050             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7051   opcode(0x0F,0x40);
 7052   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7053   ins_pipe( pipe_cmov_reg_long );
 7054 %}
 7055 
 7056 instruct cmovL_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegL dst, eRegL src) %{
 7057   predicate(VM_Version::supports_cmov() );
 7058   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7059   ins_cost(200);
 7060   expand %{
 7061     cmovL_regU(cop, cr, dst, src);
 7062   %}
 7063 %}
 7064 
 7065 //----------Arithmetic Instructions--------------------------------------------
 7066 //----------Addition Instructions----------------------------------------------
 7067 
 7068 // Integer Addition Instructions
 7069 instruct addI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7070   match(Set dst (AddI dst src));
 7071   effect(KILL cr);
 7072 
 7073   size(2);
 7074   format %{ &quot;ADD    $dst,$src&quot; %}
 7075   opcode(0x03);
 7076   ins_encode( OpcP, RegReg( dst, src) );
 7077   ins_pipe( ialu_reg_reg );
 7078 %}
 7079 
 7080 instruct addI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7081   match(Set dst (AddI dst src));
 7082   effect(KILL cr);
 7083 
 7084   format %{ &quot;ADD    $dst,$src&quot; %}
 7085   opcode(0x81, 0x00); /* /0 id */
 7086   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7087   ins_pipe( ialu_reg );
 7088 %}
 7089 
 7090 instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
 7091   predicate(UseIncDec);
 7092   match(Set dst (AddI dst src));
 7093   effect(KILL cr);
 7094 
 7095   size(1);
 7096   format %{ &quot;INC    $dst&quot; %}
 7097   opcode(0x40); /*  */
 7098   ins_encode( Opc_plus( primary, dst ) );
 7099   ins_pipe( ialu_reg );
 7100 %}
 7101 
 7102 instruct leaI_eReg_immI(rRegI dst, rRegI src0, immI src1) %{
 7103   match(Set dst (AddI src0 src1));
 7104   ins_cost(110);
 7105 
 7106   format %{ &quot;LEA    $dst,[$src0 + $src1]&quot; %}
 7107   opcode(0x8D); /* 0x8D /r */
 7108   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7109   ins_pipe( ialu_reg_reg );
 7110 %}
 7111 
 7112 instruct leaP_eReg_immI(eRegP dst, eRegP src0, immI src1) %{
 7113   match(Set dst (AddP src0 src1));
 7114   ins_cost(110);
 7115 
 7116   format %{ &quot;LEA    $dst,[$src0 + $src1]\t# ptr&quot; %}
 7117   opcode(0x8D); /* 0x8D /r */
 7118   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7119   ins_pipe( ialu_reg_reg );
 7120 %}
 7121 
 7122 instruct decI_eReg(rRegI dst, immI_M1 src, eFlagsReg cr) %{
 7123   predicate(UseIncDec);
 7124   match(Set dst (AddI dst src));
 7125   effect(KILL cr);
 7126 
 7127   size(1);
 7128   format %{ &quot;DEC    $dst&quot; %}
 7129   opcode(0x48); /*  */
 7130   ins_encode( Opc_plus( primary, dst ) );
 7131   ins_pipe( ialu_reg );
 7132 %}
 7133 
 7134 instruct addP_eReg(eRegP dst, rRegI src, eFlagsReg cr) %{
 7135   match(Set dst (AddP dst src));
 7136   effect(KILL cr);
 7137 
 7138   size(2);
 7139   format %{ &quot;ADD    $dst,$src&quot; %}
 7140   opcode(0x03);
 7141   ins_encode( OpcP, RegReg( dst, src) );
 7142   ins_pipe( ialu_reg_reg );
 7143 %}
 7144 
 7145 instruct addP_eReg_imm(eRegP dst, immI src, eFlagsReg cr) %{
 7146   match(Set dst (AddP dst src));
 7147   effect(KILL cr);
 7148 
 7149   format %{ &quot;ADD    $dst,$src&quot; %}
 7150   opcode(0x81,0x00); /* Opcode 81 /0 id */
 7151   // ins_encode( RegImm( dst, src) );
 7152   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7153   ins_pipe( ialu_reg );
 7154 %}
 7155 
 7156 instruct addI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7157   match(Set dst (AddI dst (LoadI src)));
 7158   effect(KILL cr);
 7159 
 7160   ins_cost(125);
 7161   format %{ &quot;ADD    $dst,$src&quot; %}
 7162   opcode(0x03);
 7163   ins_encode( OpcP, RegMem( dst, src) );
 7164   ins_pipe( ialu_reg_mem );
 7165 %}
 7166 
 7167 instruct addI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7168   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7169   effect(KILL cr);
 7170 
 7171   ins_cost(150);
 7172   format %{ &quot;ADD    $dst,$src&quot; %}
 7173   opcode(0x01);  /* Opcode 01 /r */
 7174   ins_encode( OpcP, RegMem( src, dst ) );
 7175   ins_pipe( ialu_mem_reg );
 7176 %}
 7177 
 7178 // Add Memory with Immediate
 7179 instruct addI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 7180   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7181   effect(KILL cr);
 7182 
 7183   ins_cost(125);
 7184   format %{ &quot;ADD    $dst,$src&quot; %}
 7185   opcode(0x81);               /* Opcode 81 /0 id */
 7186   ins_encode( OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32( src ) );
 7187   ins_pipe( ialu_mem_imm );
 7188 %}
 7189 
 7190 instruct incI_mem(memory dst, immI1 src, eFlagsReg cr) %{
 7191   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7192   effect(KILL cr);
 7193 
 7194   ins_cost(125);
 7195   format %{ &quot;INC    $dst&quot; %}
 7196   opcode(0xFF);               /* Opcode FF /0 */
 7197   ins_encode( OpcP, RMopc_Mem(0x00,dst));
 7198   ins_pipe( ialu_mem_imm );
 7199 %}
 7200 
 7201 instruct decI_mem(memory dst, immI_M1 src, eFlagsReg cr) %{
 7202   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7203   effect(KILL cr);
 7204 
 7205   ins_cost(125);
 7206   format %{ &quot;DEC    $dst&quot; %}
 7207   opcode(0xFF);               /* Opcode FF /1 */
 7208   ins_encode( OpcP, RMopc_Mem(0x01,dst));
 7209   ins_pipe( ialu_mem_imm );
 7210 %}
 7211 
 7212 
 7213 instruct checkCastPP( eRegP dst ) %{
 7214   match(Set dst (CheckCastPP dst));
 7215 
 7216   size(0);
 7217   format %{ &quot;#checkcastPP of $dst&quot; %}
 7218   ins_encode( /*empty encoding*/ );
 7219   ins_pipe( empty );
 7220 %}
 7221 
 7222 instruct castPP( eRegP dst ) %{
 7223   match(Set dst (CastPP dst));
 7224   format %{ &quot;#castPP of $dst&quot; %}
 7225   ins_encode( /*empty encoding*/ );
 7226   ins_pipe( empty );
 7227 %}
 7228 
 7229 instruct castII( rRegI dst ) %{
 7230   match(Set dst (CastII dst));
 7231   format %{ &quot;#castII of $dst&quot; %}
 7232   ins_encode( /*empty encoding*/ );
 7233   ins_cost(0);
 7234   ins_pipe( empty );
 7235 %}
 7236 
 7237 // Load-locked - same as a regular pointer load when used with compare-swap
 7238 instruct loadPLocked(eRegP dst, memory mem) %{
 7239   match(Set dst (LoadPLocked mem));
 7240 
 7241   ins_cost(125);
 7242   format %{ &quot;MOV    $dst,$mem\t# Load ptr. locked&quot; %}
 7243   opcode(0x8B);
 7244   ins_encode( OpcP, RegMem(dst,mem));
 7245   ins_pipe( ialu_reg_mem );
 7246 %}
 7247 
 7248 // Conditional-store of the updated heap-top.
 7249 // Used during allocation of the shared heap.
 7250 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7251 instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{
 7252   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7253   // EAX is killed if there is contention, but then it&#39;s also unused.
 7254   // In the common case of no contention, EAX holds the new oop address.
 7255   format %{ &quot;CMPXCHG $heap_top_ptr,$newval\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr&quot; %}
 7256   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval,heap_top_ptr) );
 7257   ins_pipe( pipe_cmpxchg );
 7258 %}
 7259 
 7260 // Conditional-store of an int value.
 7261 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG on Intel.
 7262 instruct storeIConditional( memory mem, eAXRegI oldval, rRegI newval, eFlagsReg cr ) %{
 7263   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7264   effect(KILL oldval);
 7265   format %{ &quot;CMPXCHG $mem,$newval\t# If EAX==$mem Then store $newval into $mem&quot; %}
 7266   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval, mem) );
 7267   ins_pipe( pipe_cmpxchg );
 7268 %}
 7269 
 7270 // Conditional-store of a long value.
 7271 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG8 on Intel.
 7272 instruct storeLConditional( memory mem, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7273   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7274   effect(KILL oldval);
 7275   format %{ &quot;XCHG   EBX,ECX\t# correct order for CMPXCHG8 instruction\n\t&quot;
 7276             &quot;CMPXCHG8 $mem,ECX:EBX\t# If EDX:EAX==$mem Then store ECX:EBX into $mem\n\t&quot;
 7277             &quot;XCHG   EBX,ECX&quot;
 7278   %}
 7279   ins_encode %{
 7280     // Note: we need to swap rbx, and rcx before and after the
 7281     //       cmpxchg8 instruction because the instruction uses
 7282     //       rcx as the high order word of the new value to store but
 7283     //       our register encoding uses rbx.
 7284     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7285     __ lock();
 7286     __ cmpxchg8($mem$$Address);
 7287     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7288   %}
 7289   ins_pipe( pipe_cmpxchg );
 7290 %}
 7291 
 7292 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7293 
 7294 instruct compareAndSwapL( rRegI res, eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7295   predicate(VM_Version::supports_cx8());
 7296   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7297   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7298   effect(KILL cr, KILL oldval);
 7299   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7300             &quot;MOV    $res,0\n\t&quot;
 7301             &quot;JNE,s  fail\n\t&quot;
 7302             &quot;MOV    $res,1\n&quot;
 7303           &quot;fail:&quot; %}
 7304   ins_encode( enc_cmpxchg8(mem_ptr),
 7305               enc_flags_ne_to_boolean(res) );
 7306   ins_pipe( pipe_cmpxchg );
 7307 %}
 7308 
 7309 instruct compareAndSwapP( rRegI res,  pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7310   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7311   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7312   effect(KILL cr, KILL oldval);
 7313   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7314             &quot;MOV    $res,0\n\t&quot;
 7315             &quot;JNE,s  fail\n\t&quot;
 7316             &quot;MOV    $res,1\n&quot;
 7317           &quot;fail:&quot; %}
 7318   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7319   ins_pipe( pipe_cmpxchg );
 7320 %}
 7321 
 7322 instruct compareAndSwapB( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7323   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7324   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7325   effect(KILL cr, KILL oldval);
 7326   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7327             &quot;MOV    $res,0\n\t&quot;
 7328             &quot;JNE,s  fail\n\t&quot;
 7329             &quot;MOV    $res,1\n&quot;
 7330           &quot;fail:&quot; %}
 7331   ins_encode( enc_cmpxchgb(mem_ptr),
 7332               enc_flags_ne_to_boolean(res) );
 7333   ins_pipe( pipe_cmpxchg );
 7334 %}
 7335 
 7336 instruct compareAndSwapS( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7337   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7338   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7339   effect(KILL cr, KILL oldval);
 7340   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7341             &quot;MOV    $res,0\n\t&quot;
 7342             &quot;JNE,s  fail\n\t&quot;
 7343             &quot;MOV    $res,1\n&quot;
 7344           &quot;fail:&quot; %}
 7345   ins_encode( enc_cmpxchgw(mem_ptr),
 7346               enc_flags_ne_to_boolean(res) );
 7347   ins_pipe( pipe_cmpxchg );
 7348 %}
 7349 
 7350 instruct compareAndSwapI( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7351   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7352   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7353   effect(KILL cr, KILL oldval);
 7354   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7355             &quot;MOV    $res,0\n\t&quot;
 7356             &quot;JNE,s  fail\n\t&quot;
 7357             &quot;MOV    $res,1\n&quot;
 7358           &quot;fail:&quot; %}
 7359   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7360   ins_pipe( pipe_cmpxchg );
 7361 %}
 7362 
 7363 instruct compareAndExchangeL( eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7364   predicate(VM_Version::supports_cx8());
 7365   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7366   effect(KILL cr);
 7367   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7368   ins_encode( enc_cmpxchg8(mem_ptr) );
 7369   ins_pipe( pipe_cmpxchg );
 7370 %}
 7371 
 7372 instruct compareAndExchangeP( pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7373   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7374   effect(KILL cr);
 7375   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7376   ins_encode( enc_cmpxchg(mem_ptr) );
 7377   ins_pipe( pipe_cmpxchg );
 7378 %}
 7379 
 7380 instruct compareAndExchangeB( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7381   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7382   effect(KILL cr);
 7383   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7384   ins_encode( enc_cmpxchgb(mem_ptr) );
 7385   ins_pipe( pipe_cmpxchg );
 7386 %}
 7387 
 7388 instruct compareAndExchangeS( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7389   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7390   effect(KILL cr);
 7391   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7392   ins_encode( enc_cmpxchgw(mem_ptr) );
 7393   ins_pipe( pipe_cmpxchg );
 7394 %}
 7395 
 7396 instruct compareAndExchangeI( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7397   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7398   effect(KILL cr);
 7399   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7400   ins_encode( enc_cmpxchg(mem_ptr) );
 7401   ins_pipe( pipe_cmpxchg );
 7402 %}
 7403 
 7404 instruct xaddB_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7405   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7406   match(Set dummy (GetAndAddB mem add));
 7407   effect(KILL cr);
 7408   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7409   ins_encode %{
 7410     __ lock();
 7411     __ addb($mem$$Address, $add$$constant);
 7412   %}
 7413   ins_pipe( pipe_cmpxchg );
 7414 %}
 7415 
 7416 // Important to match to xRegI: only 8-bit regs.
 7417 instruct xaddB( memory mem, xRegI newval, eFlagsReg cr) %{
 7418   match(Set newval (GetAndAddB mem newval));
 7419   effect(KILL cr);
 7420   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7421   ins_encode %{
 7422     __ lock();
 7423     __ xaddb($mem$$Address, $newval$$Register);
 7424   %}
 7425   ins_pipe( pipe_cmpxchg );
 7426 %}
 7427 
 7428 instruct xaddS_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7429   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7430   match(Set dummy (GetAndAddS mem add));
 7431   effect(KILL cr);
 7432   format %{ &quot;ADDS  [$mem],$add&quot; %}
 7433   ins_encode %{
 7434     __ lock();
 7435     __ addw($mem$$Address, $add$$constant);
 7436   %}
 7437   ins_pipe( pipe_cmpxchg );
 7438 %}
 7439 
 7440 instruct xaddS( memory mem, rRegI newval, eFlagsReg cr) %{
 7441   match(Set newval (GetAndAddS mem newval));
 7442   effect(KILL cr);
 7443   format %{ &quot;XADDS  [$mem],$newval&quot; %}
 7444   ins_encode %{
 7445     __ lock();
 7446     __ xaddw($mem$$Address, $newval$$Register);
 7447   %}
 7448   ins_pipe( pipe_cmpxchg );
 7449 %}
 7450 
 7451 instruct xaddI_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7452   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7453   match(Set dummy (GetAndAddI mem add));
 7454   effect(KILL cr);
 7455   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7456   ins_encode %{
 7457     __ lock();
 7458     __ addl($mem$$Address, $add$$constant);
 7459   %}
 7460   ins_pipe( pipe_cmpxchg );
 7461 %}
 7462 
 7463 instruct xaddI( memory mem, rRegI newval, eFlagsReg cr) %{
 7464   match(Set newval (GetAndAddI mem newval));
 7465   effect(KILL cr);
 7466   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7467   ins_encode %{
 7468     __ lock();
 7469     __ xaddl($mem$$Address, $newval$$Register);
 7470   %}
 7471   ins_pipe( pipe_cmpxchg );
 7472 %}
 7473 
 7474 // Important to match to xRegI: only 8-bit regs.
 7475 instruct xchgB( memory mem, xRegI newval) %{
 7476   match(Set newval (GetAndSetB mem newval));
 7477   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7478   ins_encode %{
 7479     __ xchgb($newval$$Register, $mem$$Address);
 7480   %}
 7481   ins_pipe( pipe_cmpxchg );
 7482 %}
 7483 
 7484 instruct xchgS( memory mem, rRegI newval) %{
 7485   match(Set newval (GetAndSetS mem newval));
 7486   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7487   ins_encode %{
 7488     __ xchgw($newval$$Register, $mem$$Address);
 7489   %}
 7490   ins_pipe( pipe_cmpxchg );
 7491 %}
 7492 
 7493 instruct xchgI( memory mem, rRegI newval) %{
 7494   match(Set newval (GetAndSetI mem newval));
 7495   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7496   ins_encode %{
 7497     __ xchgl($newval$$Register, $mem$$Address);
 7498   %}
 7499   ins_pipe( pipe_cmpxchg );
 7500 %}
 7501 
 7502 instruct xchgP( memory mem, pRegP newval) %{
 7503   match(Set newval (GetAndSetP mem newval));
 7504   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7505   ins_encode %{
 7506     __ xchgl($newval$$Register, $mem$$Address);
 7507   %}
 7508   ins_pipe( pipe_cmpxchg );
 7509 %}
 7510 
 7511 //----------Subtraction Instructions-------------------------------------------
 7512 
 7513 // Integer Subtraction Instructions
 7514 instruct subI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7515   match(Set dst (SubI dst src));
 7516   effect(KILL cr);
 7517 
 7518   size(2);
 7519   format %{ &quot;SUB    $dst,$src&quot; %}
 7520   opcode(0x2B);
 7521   ins_encode( OpcP, RegReg( dst, src) );
 7522   ins_pipe( ialu_reg_reg );
 7523 %}
 7524 
 7525 instruct subI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7526   match(Set dst (SubI dst src));
 7527   effect(KILL cr);
 7528 
 7529   format %{ &quot;SUB    $dst,$src&quot; %}
 7530   opcode(0x81,0x05);  /* Opcode 81 /5 */
 7531   // ins_encode( RegImm( dst, src) );
 7532   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7533   ins_pipe( ialu_reg );
 7534 %}
 7535 
 7536 instruct subI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7537   match(Set dst (SubI dst (LoadI src)));
 7538   effect(KILL cr);
 7539 
 7540   ins_cost(125);
 7541   format %{ &quot;SUB    $dst,$src&quot; %}
 7542   opcode(0x2B);
 7543   ins_encode( OpcP, RegMem( dst, src) );
 7544   ins_pipe( ialu_reg_mem );
 7545 %}
 7546 
 7547 instruct subI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7548   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 7549   effect(KILL cr);
 7550 
 7551   ins_cost(150);
 7552   format %{ &quot;SUB    $dst,$src&quot; %}
 7553   opcode(0x29);  /* Opcode 29 /r */
 7554   ins_encode( OpcP, RegMem( src, dst ) );
 7555   ins_pipe( ialu_mem_reg );
 7556 %}
 7557 
 7558 // Subtract from a pointer
 7559 instruct subP_eReg(eRegP dst, rRegI src, immI0 zero, eFlagsReg cr) %{
 7560   match(Set dst (AddP dst (SubI zero src)));
 7561   effect(KILL cr);
 7562 
 7563   size(2);
 7564   format %{ &quot;SUB    $dst,$src&quot; %}
 7565   opcode(0x2B);
 7566   ins_encode( OpcP, RegReg( dst, src) );
 7567   ins_pipe( ialu_reg_reg );
 7568 %}
 7569 
 7570 instruct negI_eReg(rRegI dst, immI0 zero, eFlagsReg cr) %{
 7571   match(Set dst (SubI zero dst));
 7572   effect(KILL cr);
 7573 
 7574   size(2);
 7575   format %{ &quot;NEG    $dst&quot; %}
 7576   opcode(0xF7,0x03);  // Opcode F7 /3
 7577   ins_encode( OpcP, RegOpc( dst ) );
 7578   ins_pipe( ialu_reg );
 7579 %}
 7580 
 7581 //----------Multiplication/Division Instructions-------------------------------
 7582 // Integer Multiplication Instructions
 7583 // Multiply Register
 7584 instruct mulI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7585   match(Set dst (MulI dst src));
 7586   effect(KILL cr);
 7587 
 7588   size(3);
 7589   ins_cost(300);
 7590   format %{ &quot;IMUL   $dst,$src&quot; %}
 7591   opcode(0xAF, 0x0F);
 7592   ins_encode( OpcS, OpcP, RegReg( dst, src) );
 7593   ins_pipe( ialu_reg_reg_alu0 );
 7594 %}
 7595 
 7596 // Multiply 32-bit Immediate
 7597 instruct mulI_eReg_imm(rRegI dst, rRegI src, immI imm, eFlagsReg cr) %{
 7598   match(Set dst (MulI src imm));
 7599   effect(KILL cr);
 7600 
 7601   ins_cost(300);
 7602   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7603   opcode(0x69);  /* 69 /r id */
 7604   ins_encode( OpcSE(imm), RegReg( dst, src ), Con8or32( imm ) );
 7605   ins_pipe( ialu_reg_reg_alu0 );
 7606 %}
 7607 
 7608 instruct loadConL_low_only(eADXRegL_low_only dst, immL32 src, eFlagsReg cr) %{
 7609   match(Set dst src);
 7610   effect(KILL cr);
 7611 
 7612   // Note that this is artificially increased to make it more expensive than loadConL
 7613   ins_cost(250);
 7614   format %{ &quot;MOV    EAX,$src\t// low word only&quot; %}
 7615   opcode(0xB8);
 7616   ins_encode( LdImmL_Lo(dst, src) );
 7617   ins_pipe( ialu_reg_fat );
 7618 %}
 7619 
 7620 // Multiply by 32-bit Immediate, taking the shifted high order results
 7621 //  (special case for shift by 32)
 7622 instruct mulI_imm_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32 cnt, eFlagsReg cr) %{
 7623   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7624   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7625              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7626              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7627   effect(USE src1, KILL cr);
 7628 
 7629   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7630   ins_cost(0*100 + 1*400 - 150);
 7631   format %{ &quot;IMUL   EDX:EAX,$src1&quot; %}
 7632   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7633   ins_pipe( pipe_slow );
 7634 %}
 7635 
 7636 // Multiply by 32-bit Immediate, taking the shifted high order results
 7637 instruct mulI_imm_RShift_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr) %{
 7638   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7639   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7640              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7641              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7642   effect(USE src1, KILL cr);
 7643 
 7644   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7645   ins_cost(1*100 + 1*400 - 150);
 7646   format %{ &quot;IMUL   EDX:EAX,$src1\n\t&quot;
 7647             &quot;SAR    EDX,$cnt-32&quot; %}
 7648   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7649   ins_pipe( pipe_slow );
 7650 %}
 7651 
 7652 // Multiply Memory 32-bit Immediate
 7653 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, eFlagsReg cr) %{
 7654   match(Set dst (MulI (LoadI src) imm));
 7655   effect(KILL cr);
 7656 
 7657   ins_cost(300);
 7658   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7659   opcode(0x69);  /* 69 /r id */
 7660   ins_encode( OpcSE(imm), RegMem( dst, src ), Con8or32( imm ) );
 7661   ins_pipe( ialu_reg_mem_alu0 );
 7662 %}
 7663 
 7664 // Multiply Memory
 7665 instruct mulI(rRegI dst, memory src, eFlagsReg cr) %{
 7666   match(Set dst (MulI dst (LoadI src)));
 7667   effect(KILL cr);
 7668 
 7669   ins_cost(350);
 7670   format %{ &quot;IMUL   $dst,$src&quot; %}
 7671   opcode(0xAF, 0x0F);
 7672   ins_encode( OpcS, OpcP, RegMem( dst, src) );
 7673   ins_pipe( ialu_reg_mem_alu0 );
 7674 %}
 7675 
 7676 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, eFlagsReg cr)
 7677 %{
 7678   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 7679   effect(KILL cr, KILL src2);
 7680 
 7681   expand %{ mulI_eReg(dst, src1, cr);
 7682            mulI_eReg(src2, src3, cr);
 7683            addI_eReg(dst, src2, cr); %}
 7684 %}
 7685 
 7686 // Multiply Register Int to Long
 7687 instruct mulI2L(eADXRegL dst, eAXRegI src, nadxRegI src1, eFlagsReg flags) %{
 7688   // Basic Idea: long = (long)int * (long)int
 7689   match(Set dst (MulL (ConvI2L src) (ConvI2L src1)));
 7690   effect(DEF dst, USE src, USE src1, KILL flags);
 7691 
 7692   ins_cost(300);
 7693   format %{ &quot;IMUL   $dst,$src1&quot; %}
 7694 
 7695   ins_encode( long_int_multiply( dst, src1 ) );
 7696   ins_pipe( ialu_reg_reg_alu0 );
 7697 %}
 7698 
 7699 instruct mulIS_eReg(eADXRegL dst, immL_32bits mask, eFlagsReg flags, eAXRegI src, nadxRegI src1) %{
 7700   // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 7701   match(Set dst (MulL (AndL (ConvI2L src) mask) (AndL (ConvI2L src1) mask)));
 7702   effect(KILL flags);
 7703 
 7704   ins_cost(300);
 7705   format %{ &quot;MUL    $dst,$src1&quot; %}
 7706 
 7707   ins_encode( long_uint_multiply(dst, src1) );
 7708   ins_pipe( ialu_reg_reg_alu0 );
 7709 %}
 7710 
 7711 // Multiply Register Long
 7712 instruct mulL_eReg(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7713   match(Set dst (MulL dst src));
 7714   effect(KILL cr, TEMP tmp);
 7715   ins_cost(4*100+3*400);
 7716 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7717 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 7718   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7719             &quot;IMUL   $tmp,EDX\n\t&quot;
 7720             &quot;MOV    EDX,$src.hi\n\t&quot;
 7721             &quot;IMUL   EDX,EAX\n\t&quot;
 7722             &quot;ADD    $tmp,EDX\n\t&quot;
 7723             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7724             &quot;ADD    EDX,$tmp&quot; %}
 7725   ins_encode( long_multiply( dst, src, tmp ) );
 7726   ins_pipe( pipe_slow );
 7727 %}
 7728 
 7729 // Multiply Register Long where the left operand&#39;s high 32 bits are zero
 7730 instruct mulL_eReg_lhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7731   predicate(is_operand_hi32_zero(n-&gt;in(1)));
 7732   match(Set dst (MulL dst src));
 7733   effect(KILL cr, TEMP tmp);
 7734   ins_cost(2*100+2*400);
 7735 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7736 //             hi(result) = hi(x_lo * y_lo) + lo(x_lo * y_hi) where lo(x_hi * y_lo) = 0 because x_hi = 0
 7737   format %{ &quot;MOV    $tmp,$src.hi\n\t&quot;
 7738             &quot;IMUL   $tmp,EAX\n\t&quot;
 7739             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7740             &quot;ADD    EDX,$tmp&quot; %}
 7741   ins_encode %{
 7742     __ movl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 7743     __ imull($tmp$$Register, rax);
 7744     __ mull($src$$Register);
 7745     __ addl(rdx, $tmp$$Register);
 7746   %}
 7747   ins_pipe( pipe_slow );
 7748 %}
 7749 
 7750 // Multiply Register Long where the right operand&#39;s high 32 bits are zero
 7751 instruct mulL_eReg_rhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7752   predicate(is_operand_hi32_zero(n-&gt;in(2)));
 7753   match(Set dst (MulL dst src));
 7754   effect(KILL cr, TEMP tmp);
 7755   ins_cost(2*100+2*400);
 7756 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7757 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) where lo(x_lo * y_hi) = 0 because y_hi = 0
 7758   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7759             &quot;IMUL   $tmp,EDX\n\t&quot;
 7760             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7761             &quot;ADD    EDX,$tmp&quot; %}
 7762   ins_encode %{
 7763     __ movl($tmp$$Register, $src$$Register);
 7764     __ imull($tmp$$Register, rdx);
 7765     __ mull($src$$Register);
 7766     __ addl(rdx, $tmp$$Register);
 7767   %}
 7768   ins_pipe( pipe_slow );
 7769 %}
 7770 
 7771 // Multiply Register Long where the left and the right operands&#39; high 32 bits are zero
 7772 instruct mulL_eReg_hi0(eADXRegL dst, eRegL src, eFlagsReg cr) %{
 7773   predicate(is_operand_hi32_zero(n-&gt;in(1)) &amp;&amp; is_operand_hi32_zero(n-&gt;in(2)));
 7774   match(Set dst (MulL dst src));
 7775   effect(KILL cr);
 7776   ins_cost(1*400);
 7777 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7778 //             hi(result) = hi(x_lo * y_lo) where lo(x_hi * y_lo) = 0 and lo(x_lo * y_hi) = 0 because x_hi = 0 and y_hi = 0
 7779   format %{ &quot;MUL    EDX:EAX,$src.lo\n\t&quot; %}
 7780   ins_encode %{
 7781     __ mull($src$$Register);
 7782   %}
 7783   ins_pipe( pipe_slow );
 7784 %}
 7785 
 7786 // Multiply Register Long by small constant
 7787 instruct mulL_eReg_con(eADXRegL dst, immL_127 src, rRegI tmp, eFlagsReg cr) %{
 7788   match(Set dst (MulL dst src));
 7789   effect(KILL cr, TEMP tmp);
 7790   ins_cost(2*100+2*400);
 7791   size(12);
 7792 // Basic idea: lo(result) = lo(src * EAX)
 7793 //             hi(result) = hi(src * EAX) + lo(src * EDX)
 7794   format %{ &quot;IMUL   $tmp,EDX,$src\n\t&quot;
 7795             &quot;MOV    EDX,$src\n\t&quot;
 7796             &quot;MUL    EDX\t# EDX*EAX -&gt; EDX:EAX\n\t&quot;
 7797             &quot;ADD    EDX,$tmp&quot; %}
 7798   ins_encode( long_multiply_con( dst, src, tmp ) );
 7799   ins_pipe( pipe_slow );
 7800 %}
 7801 
 7802 // Integer DIV with Register
 7803 instruct divI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7804   match(Set rax (DivI rax div));
 7805   effect(KILL rdx, KILL cr);
 7806   size(26);
 7807   ins_cost(30*100+10*100);
 7808   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7809             &quot;JNE,s  normal\n\t&quot;
 7810             &quot;XOR    EDX,EDX\n\t&quot;
 7811             &quot;CMP    ECX,-1\n\t&quot;
 7812             &quot;JE,s   done\n&quot;
 7813     &quot;normal: CDQ\n\t&quot;
 7814             &quot;IDIV   $div\n\t&quot;
 7815     &quot;done:&quot;        %}
 7816   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7817   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7818   ins_pipe( ialu_reg_reg_alu0 );
 7819 %}
 7820 
 7821 // Divide Register Long
 7822 instruct divL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7823   match(Set dst (DivL src1 src2));
 7824   effect( KILL cr, KILL cx, KILL bx );
 7825   ins_cost(10000);
 7826   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7827             &quot;PUSH   $src1.lo\n\t&quot;
 7828             &quot;PUSH   $src2.hi\n\t&quot;
 7829             &quot;PUSH   $src2.lo\n\t&quot;
 7830             &quot;CALL   SharedRuntime::ldiv\n\t&quot;
 7831             &quot;ADD    ESP,16&quot; %}
 7832   ins_encode( long_div(src1,src2) );
 7833   ins_pipe( pipe_slow );
 7834 %}
 7835 
 7836 // Integer DIVMOD with Register, both quotient and mod results
 7837 instruct divModI_eReg_divmod(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7838   match(DivModI rax div);
 7839   effect(KILL cr);
 7840   size(26);
 7841   ins_cost(30*100+10*100);
 7842   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7843             &quot;JNE,s  normal\n\t&quot;
 7844             &quot;XOR    EDX,EDX\n\t&quot;
 7845             &quot;CMP    ECX,-1\n\t&quot;
 7846             &quot;JE,s   done\n&quot;
 7847     &quot;normal: CDQ\n\t&quot;
 7848             &quot;IDIV   $div\n\t&quot;
 7849     &quot;done:&quot;        %}
 7850   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7851   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7852   ins_pipe( pipe_slow );
 7853 %}
 7854 
 7855 // Integer MOD with Register
 7856 instruct modI_eReg(eDXRegI rdx, eAXRegI rax, eCXRegI div, eFlagsReg cr) %{
 7857   match(Set rdx (ModI rax div));
 7858   effect(KILL rax, KILL cr);
 7859 
 7860   size(26);
 7861   ins_cost(300);
 7862   format %{ &quot;CDQ\n\t&quot;
 7863             &quot;IDIV   $div&quot; %}
 7864   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7865   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7866   ins_pipe( ialu_reg_reg_alu0 );
 7867 %}
 7868 
 7869 // Remainder Register Long
 7870 instruct modL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7871   match(Set dst (ModL src1 src2));
 7872   effect( KILL cr, KILL cx, KILL bx );
 7873   ins_cost(10000);
 7874   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7875             &quot;PUSH   $src1.lo\n\t&quot;
 7876             &quot;PUSH   $src2.hi\n\t&quot;
 7877             &quot;PUSH   $src2.lo\n\t&quot;
 7878             &quot;CALL   SharedRuntime::lrem\n\t&quot;
 7879             &quot;ADD    ESP,16&quot; %}
 7880   ins_encode( long_mod(src1,src2) );
 7881   ins_pipe( pipe_slow );
 7882 %}
 7883 
 7884 // Divide Register Long (no special case since divisor != -1)
 7885 instruct divL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7886   match(Set dst (DivL dst imm));
 7887   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7888   ins_cost(1000);
 7889   format %{ &quot;MOV    $tmp,abs($imm) # ldiv EDX:EAX,$imm\n\t&quot;
 7890             &quot;XOR    $tmp2,$tmp2\n\t&quot;
 7891             &quot;CMP    $tmp,EDX\n\t&quot;
 7892             &quot;JA,s   fast\n\t&quot;
 7893             &quot;MOV    $tmp2,EAX\n\t&quot;
 7894             &quot;MOV    EAX,EDX\n\t&quot;
 7895             &quot;MOV    EDX,0\n\t&quot;
 7896             &quot;JLE,s  pos\n\t&quot;
 7897             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7898             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7899             &quot;XCHG   EAX,$tmp2\n\t&quot;
 7900             &quot;DIV    $tmp\n\t&quot;
 7901             &quot;LNEG   $tmp2 : EAX\n\t&quot;
 7902             &quot;JMP,s  done\n&quot;
 7903     &quot;pos:\n\t&quot;
 7904             &quot;DIV    $tmp\n\t&quot;
 7905             &quot;XCHG   EAX,$tmp2\n&quot;
 7906     &quot;fast:\n\t&quot;
 7907             &quot;DIV    $tmp\n&quot;
 7908     &quot;done:\n\t&quot;
 7909             &quot;MOV    EDX,$tmp2\n\t&quot;
 7910             &quot;NEG    EDX:EAX # if $imm &lt; 0&quot; %}
 7911   ins_encode %{
 7912     int con = (int)$imm$$constant;
 7913     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7914     int pcon = (con &gt; 0) ? con : -con;
 7915     Label Lfast, Lpos, Ldone;
 7916 
 7917     __ movl($tmp$$Register, pcon);
 7918     __ xorl($tmp2$$Register,$tmp2$$Register);
 7919     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 7920     __ jccb(Assembler::above, Lfast); // result fits into 32 bit
 7921 
 7922     __ movl($tmp2$$Register, $dst$$Register); // save
 7923     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 7924     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 7925     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 7926 
 7927     // Negative dividend.
 7928     // convert value to positive to use unsigned division
 7929     __ lneg($dst$$Register, $tmp2$$Register);
 7930     __ divl($tmp$$Register);
 7931     __ xchgl($dst$$Register, $tmp2$$Register);
 7932     __ divl($tmp$$Register);
 7933     // revert result back to negative
 7934     __ lneg($tmp2$$Register, $dst$$Register);
 7935     __ jmpb(Ldone);
 7936 
 7937     __ bind(Lpos);
 7938     __ divl($tmp$$Register); // Use unsigned division
 7939     __ xchgl($dst$$Register, $tmp2$$Register);
 7940     // Fallthrow for final divide, tmp2 has 32 bit hi result
 7941 
 7942     __ bind(Lfast);
 7943     // fast path: src is positive
 7944     __ divl($tmp$$Register); // Use unsigned division
 7945 
 7946     __ bind(Ldone);
 7947     __ movl(HIGH_FROM_LOW($dst$$Register),$tmp2$$Register);
 7948     if (con &lt; 0) {
 7949       __ lneg(HIGH_FROM_LOW($dst$$Register), $dst$$Register);
 7950     }
 7951   %}
 7952   ins_pipe( pipe_slow );
 7953 %}
 7954 
 7955 // Remainder Register Long (remainder fit into 32 bits)
 7956 instruct modL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7957   match(Set dst (ModL dst imm));
 7958   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7959   ins_cost(1000);
 7960   format %{ &quot;MOV    $tmp,abs($imm) # lrem EDX:EAX,$imm\n\t&quot;
 7961             &quot;CMP    $tmp,EDX\n\t&quot;
 7962             &quot;JA,s   fast\n\t&quot;
 7963             &quot;MOV    $tmp2,EAX\n\t&quot;
 7964             &quot;MOV    EAX,EDX\n\t&quot;
 7965             &quot;MOV    EDX,0\n\t&quot;
 7966             &quot;JLE,s  pos\n\t&quot;
 7967             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7968             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7969             &quot;MOV    EAX,$tmp2\n\t&quot;
 7970             &quot;DIV    $tmp\n\t&quot;
 7971             &quot;NEG    EDX\n\t&quot;
 7972             &quot;JMP,s  done\n&quot;
 7973     &quot;pos:\n\t&quot;
 7974             &quot;DIV    $tmp\n\t&quot;
 7975             &quot;MOV    EAX,$tmp2\n&quot;
 7976     &quot;fast:\n\t&quot;
 7977             &quot;DIV    $tmp\n&quot;
 7978     &quot;done:\n\t&quot;
 7979             &quot;MOV    EAX,EDX\n\t&quot;
 7980             &quot;SAR    EDX,31\n\t&quot; %}
 7981   ins_encode %{
 7982     int con = (int)$imm$$constant;
 7983     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7984     int pcon = (con &gt; 0) ? con : -con;
 7985     Label  Lfast, Lpos, Ldone;
 7986 
 7987     __ movl($tmp$$Register, pcon);
 7988     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 7989     __ jccb(Assembler::above, Lfast); // src is positive and result fits into 32 bit
 7990 
 7991     __ movl($tmp2$$Register, $dst$$Register); // save
 7992     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 7993     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 7994     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 7995 
 7996     // Negative dividend.
 7997     // convert value to positive to use unsigned division
 7998     __ lneg($dst$$Register, $tmp2$$Register);
 7999     __ divl($tmp$$Register);
 8000     __ movl($dst$$Register, $tmp2$$Register);
 8001     __ divl($tmp$$Register);
 8002     // revert remainder back to negative
 8003     __ negl(HIGH_FROM_LOW($dst$$Register));
 8004     __ jmpb(Ldone);
 8005 
 8006     __ bind(Lpos);
 8007     __ divl($tmp$$Register);
 8008     __ movl($dst$$Register, $tmp2$$Register);
 8009 
 8010     __ bind(Lfast);
 8011     // fast path: src is positive
 8012     __ divl($tmp$$Register);
 8013 
 8014     __ bind(Ldone);
 8015     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8016     __ sarl(HIGH_FROM_LOW($dst$$Register), 31); // result sign
 8017 
 8018   %}
 8019   ins_pipe( pipe_slow );
 8020 %}
 8021 
 8022 // Integer Shift Instructions
 8023 // Shift Left by one
 8024 instruct shlI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8025   match(Set dst (LShiftI dst shift));
 8026   effect(KILL cr);
 8027 
 8028   size(2);
 8029   format %{ &quot;SHL    $dst,$shift&quot; %}
 8030   opcode(0xD1, 0x4);  /* D1 /4 */
 8031   ins_encode( OpcP, RegOpc( dst ) );
 8032   ins_pipe( ialu_reg );
 8033 %}
 8034 
 8035 // Shift Left by 8-bit immediate
 8036 instruct salI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8037   match(Set dst (LShiftI dst shift));
 8038   effect(KILL cr);
 8039 
 8040   size(3);
 8041   format %{ &quot;SHL    $dst,$shift&quot; %}
 8042   opcode(0xC1, 0x4);  /* C1 /4 ib */
 8043   ins_encode( RegOpcImm( dst, shift) );
 8044   ins_pipe( ialu_reg );
 8045 %}
 8046 
 8047 // Shift Left by variable
 8048 instruct salI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8049   match(Set dst (LShiftI dst shift));
 8050   effect(KILL cr);
 8051 
 8052   size(2);
 8053   format %{ &quot;SHL    $dst,$shift&quot; %}
 8054   opcode(0xD3, 0x4);  /* D3 /4 */
 8055   ins_encode( OpcP, RegOpc( dst ) );
 8056   ins_pipe( ialu_reg_reg );
 8057 %}
 8058 
 8059 // Arithmetic shift right by one
 8060 instruct sarI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8061   match(Set dst (RShiftI dst shift));
 8062   effect(KILL cr);
 8063 
 8064   size(2);
 8065   format %{ &quot;SAR    $dst,$shift&quot; %}
 8066   opcode(0xD1, 0x7);  /* D1 /7 */
 8067   ins_encode( OpcP, RegOpc( dst ) );
 8068   ins_pipe( ialu_reg );
 8069 %}
 8070 
 8071 // Arithmetic shift right by one
 8072 instruct sarI_mem_1(memory dst, immI1 shift, eFlagsReg cr) %{
 8073   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8074   effect(KILL cr);
 8075   format %{ &quot;SAR    $dst,$shift&quot; %}
 8076   opcode(0xD1, 0x7);  /* D1 /7 */
 8077   ins_encode( OpcP, RMopc_Mem(secondary,dst) );
 8078   ins_pipe( ialu_mem_imm );
 8079 %}
 8080 
 8081 // Arithmetic Shift Right by 8-bit immediate
 8082 instruct sarI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8083   match(Set dst (RShiftI dst shift));
 8084   effect(KILL cr);
 8085 
 8086   size(3);
 8087   format %{ &quot;SAR    $dst,$shift&quot; %}
 8088   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8089   ins_encode( RegOpcImm( dst, shift ) );
 8090   ins_pipe( ialu_mem_imm );
 8091 %}
 8092 
 8093 // Arithmetic Shift Right by 8-bit immediate
 8094 instruct sarI_mem_imm(memory dst, immI8 shift, eFlagsReg cr) %{
 8095   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8096   effect(KILL cr);
 8097 
 8098   format %{ &quot;SAR    $dst,$shift&quot; %}
 8099   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8100   ins_encode( OpcP, RMopc_Mem(secondary, dst ), Con8or32( shift ) );
 8101   ins_pipe( ialu_mem_imm );
 8102 %}
 8103 
 8104 // Arithmetic Shift Right by variable
 8105 instruct sarI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8106   match(Set dst (RShiftI dst shift));
 8107   effect(KILL cr);
 8108 
 8109   size(2);
 8110   format %{ &quot;SAR    $dst,$shift&quot; %}
 8111   opcode(0xD3, 0x7);  /* D3 /7 */
 8112   ins_encode( OpcP, RegOpc( dst ) );
 8113   ins_pipe( ialu_reg_reg );
 8114 %}
 8115 
 8116 // Logical shift right by one
 8117 instruct shrI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8118   match(Set dst (URShiftI dst shift));
 8119   effect(KILL cr);
 8120 
 8121   size(2);
 8122   format %{ &quot;SHR    $dst,$shift&quot; %}
 8123   opcode(0xD1, 0x5);  /* D1 /5 */
 8124   ins_encode( OpcP, RegOpc( dst ) );
 8125   ins_pipe( ialu_reg );
 8126 %}
 8127 
 8128 // Logical Shift Right by 8-bit immediate
 8129 instruct shrI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8130   match(Set dst (URShiftI dst shift));
 8131   effect(KILL cr);
 8132 
 8133   size(3);
 8134   format %{ &quot;SHR    $dst,$shift&quot; %}
 8135   opcode(0xC1, 0x5);  /* C1 /5 ib */
 8136   ins_encode( RegOpcImm( dst, shift) );
 8137   ins_pipe( ialu_reg );
 8138 %}
 8139 
 8140 
 8141 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8142 // This idiom is used by the compiler for the i2b bytecode.
 8143 instruct i2b(rRegI dst, xRegI src, immI_24 twentyfour) %{
 8144   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8145 
 8146   size(3);
 8147   format %{ &quot;MOVSX  $dst,$src :8&quot; %}
 8148   ins_encode %{
 8149     __ movsbl($dst$$Register, $src$$Register);
 8150   %}
 8151   ins_pipe(ialu_reg_reg);
 8152 %}
 8153 
 8154 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8155 // This idiom is used by the compiler the i2s bytecode.
 8156 instruct i2s(rRegI dst, xRegI src, immI_16 sixteen) %{
 8157   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8158 
 8159   size(3);
 8160   format %{ &quot;MOVSX  $dst,$src :16&quot; %}
 8161   ins_encode %{
 8162     __ movswl($dst$$Register, $src$$Register);
 8163   %}
 8164   ins_pipe(ialu_reg_reg);
 8165 %}
 8166 
 8167 
 8168 // Logical Shift Right by variable
 8169 instruct shrI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8170   match(Set dst (URShiftI dst shift));
 8171   effect(KILL cr);
 8172 
 8173   size(2);
 8174   format %{ &quot;SHR    $dst,$shift&quot; %}
 8175   opcode(0xD3, 0x5);  /* D3 /5 */
 8176   ins_encode( OpcP, RegOpc( dst ) );
 8177   ins_pipe( ialu_reg_reg );
 8178 %}
 8179 
 8180 
 8181 //----------Logical Instructions-----------------------------------------------
 8182 //----------Integer Logical Instructions---------------------------------------
 8183 // And Instructions
 8184 // And Register with Register
 8185 instruct andI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8186   match(Set dst (AndI dst src));
 8187   effect(KILL cr);
 8188 
 8189   size(2);
 8190   format %{ &quot;AND    $dst,$src&quot; %}
 8191   opcode(0x23);
 8192   ins_encode( OpcP, RegReg( dst, src) );
 8193   ins_pipe( ialu_reg_reg );
 8194 %}
 8195 
 8196 // And Register with Immediate
 8197 instruct andI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8198   match(Set dst (AndI dst src));
 8199   effect(KILL cr);
 8200 
 8201   format %{ &quot;AND    $dst,$src&quot; %}
 8202   opcode(0x81,0x04);  /* Opcode 81 /4 */
 8203   // ins_encode( RegImm( dst, src) );
 8204   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8205   ins_pipe( ialu_reg );
 8206 %}
 8207 
 8208 // And Register with Memory
 8209 instruct andI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8210   match(Set dst (AndI dst (LoadI src)));
 8211   effect(KILL cr);
 8212 
 8213   ins_cost(125);
 8214   format %{ &quot;AND    $dst,$src&quot; %}
 8215   opcode(0x23);
 8216   ins_encode( OpcP, RegMem( dst, src) );
 8217   ins_pipe( ialu_reg_mem );
 8218 %}
 8219 
 8220 // And Memory with Register
 8221 instruct andI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8222   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8223   effect(KILL cr);
 8224 
 8225   ins_cost(150);
 8226   format %{ &quot;AND    $dst,$src&quot; %}
 8227   opcode(0x21);  /* Opcode 21 /r */
 8228   ins_encode( OpcP, RegMem( src, dst ) );
 8229   ins_pipe( ialu_mem_reg );
 8230 %}
 8231 
 8232 // And Memory with Immediate
 8233 instruct andI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8234   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8235   effect(KILL cr);
 8236 
 8237   ins_cost(125);
 8238   format %{ &quot;AND    $dst,$src&quot; %}
 8239   opcode(0x81, 0x4);  /* Opcode 81 /4 id */
 8240   // ins_encode( MemImm( dst, src) );
 8241   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8242   ins_pipe( ialu_mem_imm );
 8243 %}
 8244 
 8245 // BMI1 instructions
 8246 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, eFlagsReg cr) %{
 8247   match(Set dst (AndI (XorI src1 minus_1) src2));
 8248   predicate(UseBMI1Instructions);
 8249   effect(KILL cr);
 8250 
 8251   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8252 
 8253   ins_encode %{
 8254     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 8255   %}
 8256   ins_pipe(ialu_reg);
 8257 %}
 8258 
 8259 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, eFlagsReg cr) %{
 8260   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2) ));
 8261   predicate(UseBMI1Instructions);
 8262   effect(KILL cr);
 8263 
 8264   ins_cost(125);
 8265   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8266 
 8267   ins_encode %{
 8268     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 8269   %}
 8270   ins_pipe(ialu_reg_mem);
 8271 %}
 8272 
 8273 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, eFlagsReg cr) %{
 8274   match(Set dst (AndI (SubI imm_zero src) src));
 8275   predicate(UseBMI1Instructions);
 8276   effect(KILL cr);
 8277 
 8278   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8279 
 8280   ins_encode %{
 8281     __ blsil($dst$$Register, $src$$Register);
 8282   %}
 8283   ins_pipe(ialu_reg);
 8284 %}
 8285 
 8286 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, eFlagsReg cr) %{
 8287   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 8288   predicate(UseBMI1Instructions);
 8289   effect(KILL cr);
 8290 
 8291   ins_cost(125);
 8292   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8293 
 8294   ins_encode %{
 8295     __ blsil($dst$$Register, $src$$Address);
 8296   %}
 8297   ins_pipe(ialu_reg_mem);
 8298 %}
 8299 
 8300 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8301 %{
 8302   match(Set dst (XorI (AddI src minus_1) src));
 8303   predicate(UseBMI1Instructions);
 8304   effect(KILL cr);
 8305 
 8306   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8307 
 8308   ins_encode %{
 8309     __ blsmskl($dst$$Register, $src$$Register);
 8310   %}
 8311 
 8312   ins_pipe(ialu_reg);
 8313 %}
 8314 
 8315 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8316 %{
 8317   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ));
 8318   predicate(UseBMI1Instructions);
 8319   effect(KILL cr);
 8320 
 8321   ins_cost(125);
 8322   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8323 
 8324   ins_encode %{
 8325     __ blsmskl($dst$$Register, $src$$Address);
 8326   %}
 8327 
 8328   ins_pipe(ialu_reg_mem);
 8329 %}
 8330 
 8331 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8332 %{
 8333   match(Set dst (AndI (AddI src minus_1) src) );
 8334   predicate(UseBMI1Instructions);
 8335   effect(KILL cr);
 8336 
 8337   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8338 
 8339   ins_encode %{
 8340     __ blsrl($dst$$Register, $src$$Register);
 8341   %}
 8342 
 8343   ins_pipe(ialu_reg);
 8344 %}
 8345 
 8346 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8347 %{
 8348   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ));
 8349   predicate(UseBMI1Instructions);
 8350   effect(KILL cr);
 8351 
 8352   ins_cost(125);
 8353   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8354 
 8355   ins_encode %{
 8356     __ blsrl($dst$$Register, $src$$Address);
 8357   %}
 8358 
 8359   ins_pipe(ialu_reg_mem);
 8360 %}
 8361 
 8362 // Or Instructions
 8363 // Or Register with Register
 8364 instruct orI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8365   match(Set dst (OrI dst src));
 8366   effect(KILL cr);
 8367 
 8368   size(2);
 8369   format %{ &quot;OR     $dst,$src&quot; %}
 8370   opcode(0x0B);
 8371   ins_encode( OpcP, RegReg( dst, src) );
 8372   ins_pipe( ialu_reg_reg );
 8373 %}
 8374 
 8375 instruct orI_eReg_castP2X(rRegI dst, eRegP src, eFlagsReg cr) %{
 8376   match(Set dst (OrI dst (CastP2X src)));
 8377   effect(KILL cr);
 8378 
 8379   size(2);
 8380   format %{ &quot;OR     $dst,$src&quot; %}
 8381   opcode(0x0B);
 8382   ins_encode( OpcP, RegReg( dst, src) );
 8383   ins_pipe( ialu_reg_reg );
 8384 %}
 8385 
 8386 
 8387 // Or Register with Immediate
 8388 instruct orI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8389   match(Set dst (OrI dst src));
 8390   effect(KILL cr);
 8391 
 8392   format %{ &quot;OR     $dst,$src&quot; %}
 8393   opcode(0x81,0x01);  /* Opcode 81 /1 id */
 8394   // ins_encode( RegImm( dst, src) );
 8395   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8396   ins_pipe( ialu_reg );
 8397 %}
 8398 
 8399 // Or Register with Memory
 8400 instruct orI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8401   match(Set dst (OrI dst (LoadI src)));
 8402   effect(KILL cr);
 8403 
 8404   ins_cost(125);
 8405   format %{ &quot;OR     $dst,$src&quot; %}
 8406   opcode(0x0B);
 8407   ins_encode( OpcP, RegMem( dst, src) );
 8408   ins_pipe( ialu_reg_mem );
 8409 %}
 8410 
 8411 // Or Memory with Register
 8412 instruct orI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8413   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8414   effect(KILL cr);
 8415 
 8416   ins_cost(150);
 8417   format %{ &quot;OR     $dst,$src&quot; %}
 8418   opcode(0x09);  /* Opcode 09 /r */
 8419   ins_encode( OpcP, RegMem( src, dst ) );
 8420   ins_pipe( ialu_mem_reg );
 8421 %}
 8422 
 8423 // Or Memory with Immediate
 8424 instruct orI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8425   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8426   effect(KILL cr);
 8427 
 8428   ins_cost(125);
 8429   format %{ &quot;OR     $dst,$src&quot; %}
 8430   opcode(0x81,0x1);  /* Opcode 81 /1 id */
 8431   // ins_encode( MemImm( dst, src) );
 8432   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8433   ins_pipe( ialu_mem_imm );
 8434 %}
 8435 
 8436 // ROL/ROR
 8437 // ROL expand
 8438 instruct rolI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8439   effect(USE_DEF dst, USE shift, KILL cr);
 8440 
 8441   format %{ &quot;ROL    $dst, $shift&quot; %}
 8442   opcode(0xD1, 0x0); /* Opcode D1 /0 */
 8443   ins_encode( OpcP, RegOpc( dst ));
 8444   ins_pipe( ialu_reg );
 8445 %}
 8446 
 8447 instruct rolI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8448   effect(USE_DEF dst, USE shift, KILL cr);
 8449 
 8450   format %{ &quot;ROL    $dst, $shift&quot; %}
 8451   opcode(0xC1, 0x0); /*Opcode /C1  /0  */
 8452   ins_encode( RegOpcImm(dst, shift) );
 8453   ins_pipe(ialu_reg);
 8454 %}
 8455 
 8456 instruct rolI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8457   effect(USE_DEF dst, USE shift, KILL cr);
 8458 
 8459   format %{ &quot;ROL    $dst, $shift&quot; %}
 8460   opcode(0xD3, 0x0);    /* Opcode D3 /0 */
 8461   ins_encode(OpcP, RegOpc(dst));
 8462   ins_pipe( ialu_reg_reg );
 8463 %}
 8464 // end of ROL expand
 8465 
 8466 // ROL 32bit by one once
 8467 instruct rolI_eReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, eFlagsReg cr) %{
 8468   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8469 
 8470   expand %{
 8471     rolI_eReg_imm1(dst, lshift, cr);
 8472   %}
 8473 %}
 8474 
 8475 // ROL 32bit var by imm8 once
 8476 instruct rolI_eReg_i8(rRegI dst, immI8 lshift, immI8 rshift, eFlagsReg cr) %{
 8477   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8478   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8479 
 8480   expand %{
 8481     rolI_eReg_imm8(dst, lshift, cr);
 8482   %}
 8483 %}
 8484 
 8485 // ROL 32bit var by var once
 8486 instruct rolI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8487   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 8488 
 8489   expand %{
 8490     rolI_eReg_CL(dst, shift, cr);
 8491   %}
 8492 %}
 8493 
 8494 // ROL 32bit var by var once
 8495 instruct rolI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8496   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 8497 
 8498   expand %{
 8499     rolI_eReg_CL(dst, shift, cr);
 8500   %}
 8501 %}
 8502 
 8503 // ROR expand
 8504 instruct rorI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8505   effect(USE_DEF dst, USE shift, KILL cr);
 8506 
 8507   format %{ &quot;ROR    $dst, $shift&quot; %}
 8508   opcode(0xD1,0x1);  /* Opcode D1 /1 */
 8509   ins_encode( OpcP, RegOpc( dst ) );
 8510   ins_pipe( ialu_reg );
 8511 %}
 8512 
 8513 instruct rorI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8514   effect (USE_DEF dst, USE shift, KILL cr);
 8515 
 8516   format %{ &quot;ROR    $dst, $shift&quot; %}
 8517   opcode(0xC1, 0x1); /* Opcode /C1 /1 ib */
 8518   ins_encode( RegOpcImm(dst, shift) );
 8519   ins_pipe( ialu_reg );
 8520 %}
 8521 
 8522 instruct rorI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr)%{
 8523   effect(USE_DEF dst, USE shift, KILL cr);
 8524 
 8525   format %{ &quot;ROR    $dst, $shift&quot; %}
 8526   opcode(0xD3, 0x1);    /* Opcode D3 /1 */
 8527   ins_encode(OpcP, RegOpc(dst));
 8528   ins_pipe( ialu_reg_reg );
 8529 %}
 8530 // end of ROR expand
 8531 
 8532 // ROR right once
 8533 instruct rorI_eReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, eFlagsReg cr) %{
 8534   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8535 
 8536   expand %{
 8537     rorI_eReg_imm1(dst, rshift, cr);
 8538   %}
 8539 %}
 8540 
 8541 // ROR 32bit by immI8 once
 8542 instruct rorI_eReg_i8(rRegI dst, immI8 rshift, immI8 lshift, eFlagsReg cr) %{
 8543   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8544   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8545 
 8546   expand %{
 8547     rorI_eReg_imm8(dst, rshift, cr);
 8548   %}
 8549 %}
 8550 
 8551 // ROR 32bit var by var once
 8552 instruct rorI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8553   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 8554 
 8555   expand %{
 8556     rorI_eReg_CL(dst, shift, cr);
 8557   %}
 8558 %}
 8559 
 8560 // ROR 32bit var by var once
 8561 instruct rorI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8562   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 8563 
 8564   expand %{
 8565     rorI_eReg_CL(dst, shift, cr);
 8566   %}
 8567 %}
 8568 
 8569 // Xor Instructions
 8570 // Xor Register with Register
 8571 instruct xorI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8572   match(Set dst (XorI dst src));
 8573   effect(KILL cr);
 8574 
 8575   size(2);
 8576   format %{ &quot;XOR    $dst,$src&quot; %}
 8577   opcode(0x33);
 8578   ins_encode( OpcP, RegReg( dst, src) );
 8579   ins_pipe( ialu_reg_reg );
 8580 %}
 8581 
 8582 // Xor Register with Immediate -1
 8583 instruct xorI_eReg_im1(rRegI dst, immI_M1 imm) %{
 8584   match(Set dst (XorI dst imm));
 8585 
 8586   size(2);
 8587   format %{ &quot;NOT    $dst&quot; %}
 8588   ins_encode %{
 8589      __ notl($dst$$Register);
 8590   %}
 8591   ins_pipe( ialu_reg );
 8592 %}
 8593 
 8594 // Xor Register with Immediate
 8595 instruct xorI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8596   match(Set dst (XorI dst src));
 8597   effect(KILL cr);
 8598 
 8599   format %{ &quot;XOR    $dst,$src&quot; %}
 8600   opcode(0x81,0x06);  /* Opcode 81 /6 id */
 8601   // ins_encode( RegImm( dst, src) );
 8602   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8603   ins_pipe( ialu_reg );
 8604 %}
 8605 
 8606 // Xor Register with Memory
 8607 instruct xorI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8608   match(Set dst (XorI dst (LoadI src)));
 8609   effect(KILL cr);
 8610 
 8611   ins_cost(125);
 8612   format %{ &quot;XOR    $dst,$src&quot; %}
 8613   opcode(0x33);
 8614   ins_encode( OpcP, RegMem(dst, src) );
 8615   ins_pipe( ialu_reg_mem );
 8616 %}
 8617 
 8618 // Xor Memory with Register
 8619 instruct xorI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8620   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8621   effect(KILL cr);
 8622 
 8623   ins_cost(150);
 8624   format %{ &quot;XOR    $dst,$src&quot; %}
 8625   opcode(0x31);  /* Opcode 31 /r */
 8626   ins_encode( OpcP, RegMem( src, dst ) );
 8627   ins_pipe( ialu_mem_reg );
 8628 %}
 8629 
 8630 // Xor Memory with Immediate
 8631 instruct xorI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8632   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8633   effect(KILL cr);
 8634 
 8635   ins_cost(125);
 8636   format %{ &quot;XOR    $dst,$src&quot; %}
 8637   opcode(0x81,0x6);  /* Opcode 81 /6 id */
 8638   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8639   ins_pipe( ialu_mem_imm );
 8640 %}
 8641 
 8642 //----------Convert Int to Boolean---------------------------------------------
 8643 
 8644 instruct movI_nocopy(rRegI dst, rRegI src) %{
 8645   effect( DEF dst, USE src );
 8646   format %{ &quot;MOV    $dst,$src&quot; %}
 8647   ins_encode( enc_Copy( dst, src) );
 8648   ins_pipe( ialu_reg_reg );
 8649 %}
 8650 
 8651 instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8652   effect( USE_DEF dst, USE src, KILL cr );
 8653 
 8654   size(4);
 8655   format %{ &quot;NEG    $dst\n\t&quot;
 8656             &quot;ADC    $dst,$src&quot; %}
 8657   ins_encode( neg_reg(dst),
 8658               OpcRegReg(0x13,dst,src) );
 8659   ins_pipe( ialu_reg_reg_long );
 8660 %}
 8661 
 8662 instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8663   match(Set dst (Conv2B src));
 8664 
 8665   expand %{
 8666     movI_nocopy(dst,src);
 8667     ci2b(dst,src,cr);
 8668   %}
 8669 %}
 8670 
 8671 instruct movP_nocopy(rRegI dst, eRegP src) %{
 8672   effect( DEF dst, USE src );
 8673   format %{ &quot;MOV    $dst,$src&quot; %}
 8674   ins_encode( enc_Copy( dst, src) );
 8675   ins_pipe( ialu_reg_reg );
 8676 %}
 8677 
 8678 instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8679   effect( USE_DEF dst, USE src, KILL cr );
 8680   format %{ &quot;NEG    $dst\n\t&quot;
 8681             &quot;ADC    $dst,$src&quot; %}
 8682   ins_encode( neg_reg(dst),
 8683               OpcRegReg(0x13,dst,src) );
 8684   ins_pipe( ialu_reg_reg_long );
 8685 %}
 8686 
 8687 instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8688   match(Set dst (Conv2B src));
 8689 
 8690   expand %{
 8691     movP_nocopy(dst,src);
 8692     cp2b(dst,src,cr);
 8693   %}
 8694 %}
 8695 
 8696 instruct cmpLTMask(eCXRegI dst, ncxRegI p, ncxRegI q, eFlagsReg cr) %{
 8697   match(Set dst (CmpLTMask p q));
 8698   effect(KILL cr);
 8699   ins_cost(400);
 8700 
 8701   // SETlt can only use low byte of EAX,EBX, ECX, or EDX as destination
 8702   format %{ &quot;XOR    $dst,$dst\n\t&quot;
 8703             &quot;CMP    $p,$q\n\t&quot;
 8704             &quot;SETlt  $dst\n\t&quot;
 8705             &quot;NEG    $dst&quot; %}
 8706   ins_encode %{
 8707     Register Rp = $p$$Register;
 8708     Register Rq = $q$$Register;
 8709     Register Rd = $dst$$Register;
 8710     Label done;
 8711     __ xorl(Rd, Rd);
 8712     __ cmpl(Rp, Rq);
 8713     __ setb(Assembler::less, Rd);
 8714     __ negl(Rd);
 8715   %}
 8716 
 8717   ins_pipe(pipe_slow);
 8718 %}
 8719 
 8720 instruct cmpLTMask0(rRegI dst, immI0 zero, eFlagsReg cr) %{
 8721   match(Set dst (CmpLTMask dst zero));
 8722   effect(DEF dst, KILL cr);
 8723   ins_cost(100);
 8724 
 8725   format %{ &quot;SAR    $dst,31\t# cmpLTMask0&quot; %}
 8726   ins_encode %{
 8727   __ sarl($dst$$Register, 31);
 8728   %}
 8729   ins_pipe(ialu_reg);
 8730 %}
 8731 
 8732 /* better to save a register than avoid a branch */
 8733 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8734   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 8735   effect(KILL cr);
 8736   ins_cost(400);
 8737   format %{ &quot;SUB    $p,$q\t# cadd_cmpLTMask\n\t&quot;
 8738             &quot;JGE    done\n\t&quot;
 8739             &quot;ADD    $p,$y\n&quot;
 8740             &quot;done:  &quot; %}
 8741   ins_encode %{
 8742     Register Rp = $p$$Register;
 8743     Register Rq = $q$$Register;
 8744     Register Ry = $y$$Register;
 8745     Label done;
 8746     __ subl(Rp, Rq);
 8747     __ jccb(Assembler::greaterEqual, done);
 8748     __ addl(Rp, Ry);
 8749     __ bind(done);
 8750   %}
 8751 
 8752   ins_pipe(pipe_cmplt);
 8753 %}
 8754 
 8755 /* better to save a register than avoid a branch */
 8756 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8757   match(Set y (AndI (CmpLTMask p q) y));
 8758   effect(KILL cr);
 8759 
 8760   ins_cost(300);
 8761 
 8762   format %{ &quot;CMPL     $p, $q\t# and_cmpLTMask\n\t&quot;
 8763             &quot;JLT      done\n\t&quot;
 8764             &quot;XORL     $y, $y\n&quot;
 8765             &quot;done:  &quot; %}
 8766   ins_encode %{
 8767     Register Rp = $p$$Register;
 8768     Register Rq = $q$$Register;
 8769     Register Ry = $y$$Register;
 8770     Label done;
 8771     __ cmpl(Rp, Rq);
 8772     __ jccb(Assembler::less, done);
 8773     __ xorl(Ry, Ry);
 8774     __ bind(done);
 8775   %}
 8776 
 8777   ins_pipe(pipe_cmplt);
 8778 %}
 8779 
 8780 /* If I enable this, I encourage spilling in the inner loop of compress.
 8781 instruct cadd_cmpLTMask_mem(ncxRegI p, ncxRegI q, memory y, eCXRegI tmp, eFlagsReg cr) %{
 8782   match(Set p (AddI (AndI (CmpLTMask p q) (LoadI y)) (SubI p q)));
 8783 */
 8784 //----------Overflow Math Instructions-----------------------------------------
 8785 
 8786 instruct overflowAddI_eReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8787 %{
 8788   match(Set cr (OverflowAddI op1 op2));
 8789   effect(DEF cr, USE_KILL op1, USE op2);
 8790 
 8791   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8792 
 8793   ins_encode %{
 8794     __ addl($op1$$Register, $op2$$Register);
 8795   %}
 8796   ins_pipe(ialu_reg_reg);
 8797 %}
 8798 
 8799 instruct overflowAddI_rReg_imm(eFlagsReg cr, eAXRegI op1, immI op2)
 8800 %{
 8801   match(Set cr (OverflowAddI op1 op2));
 8802   effect(DEF cr, USE_KILL op1, USE op2);
 8803 
 8804   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8805 
 8806   ins_encode %{
 8807     __ addl($op1$$Register, $op2$$constant);
 8808   %}
 8809   ins_pipe(ialu_reg_reg);
 8810 %}
 8811 
 8812 instruct overflowSubI_rReg(eFlagsReg cr, rRegI op1, rRegI op2)
 8813 %{
 8814   match(Set cr (OverflowSubI op1 op2));
 8815 
 8816   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8817   ins_encode %{
 8818     __ cmpl($op1$$Register, $op2$$Register);
 8819   %}
 8820   ins_pipe(ialu_reg_reg);
 8821 %}
 8822 
 8823 instruct overflowSubI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2)
 8824 %{
 8825   match(Set cr (OverflowSubI op1 op2));
 8826 
 8827   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8828   ins_encode %{
 8829     __ cmpl($op1$$Register, $op2$$constant);
 8830   %}
 8831   ins_pipe(ialu_reg_reg);
 8832 %}
 8833 
 8834 instruct overflowNegI_rReg(eFlagsReg cr, immI0 zero, eAXRegI op2)
 8835 %{
 8836   match(Set cr (OverflowSubI zero op2));
 8837   effect(DEF cr, USE_KILL op2);
 8838 
 8839   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}
 8840   ins_encode %{
 8841     __ negl($op2$$Register);
 8842   %}
 8843   ins_pipe(ialu_reg_reg);
 8844 %}
 8845 
 8846 instruct overflowMulI_rReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8847 %{
 8848   match(Set cr (OverflowMulI op1 op2));
 8849   effect(DEF cr, USE_KILL op1, USE op2);
 8850 
 8851   format %{ &quot;IMUL    $op1, $op2\t# overflow check int&quot; %}
 8852   ins_encode %{
 8853     __ imull($op1$$Register, $op2$$Register);
 8854   %}
 8855   ins_pipe(ialu_reg_reg_alu0);
 8856 %}
 8857 
 8858 instruct overflowMulI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
 8859 %{
 8860   match(Set cr (OverflowMulI op1 op2));
 8861   effect(DEF cr, TEMP tmp, USE op1, USE op2);
 8862 
 8863   format %{ &quot;IMUL    $tmp, $op1, $op2\t# overflow check int&quot; %}
 8864   ins_encode %{
 8865     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
 8866   %}
 8867   ins_pipe(ialu_reg_reg_alu0);
 8868 %}
 8869 
 8870 // Integer Absolute Instructions
 8871 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, eFlagsReg cr)
 8872 %{
 8873   match(Set dst (AbsI src));
 8874   effect(TEMP dst, TEMP tmp, KILL cr);
 8875   format %{ &quot;movl $tmp, $src\n\t&quot;
 8876             &quot;sarl $tmp, 31\n\t&quot;
 8877             &quot;movl $dst, $src\n\t&quot;
 8878             &quot;xorl $dst, $tmp\n\t&quot;
 8879             &quot;subl $dst, $tmp\n&quot;
 8880           %}
 8881   ins_encode %{
 8882     __ movl($tmp$$Register, $src$$Register);
 8883     __ sarl($tmp$$Register, 31);
 8884     __ movl($dst$$Register, $src$$Register);
 8885     __ xorl($dst$$Register, $tmp$$Register);
 8886     __ subl($dst$$Register, $tmp$$Register);
 8887   %}
 8888 
 8889   ins_pipe(ialu_reg_reg);
 8890 %}
 8891 
 8892 //----------Long Instructions------------------------------------------------
 8893 // Add Long Register with Register
 8894 instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8895   match(Set dst (AddL dst src));
 8896   effect(KILL cr);
 8897   ins_cost(200);
 8898   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8899             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8900   opcode(0x03, 0x13);
 8901   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8902   ins_pipe( ialu_reg_reg_long );
 8903 %}
 8904 
 8905 // Add Long Register with Immediate
 8906 instruct addL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8907   match(Set dst (AddL dst src));
 8908   effect(KILL cr);
 8909   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8910             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8911   opcode(0x81,0x00,0x02);  /* Opcode 81 /0, 81 /2 */
 8912   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8913   ins_pipe( ialu_reg_long );
 8914 %}
 8915 
 8916 // Add Long Register with Memory
 8917 instruct addL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8918   match(Set dst (AddL dst (LoadL mem)));
 8919   effect(KILL cr);
 8920   ins_cost(125);
 8921   format %{ &quot;ADD    $dst.lo,$mem\n\t&quot;
 8922             &quot;ADC    $dst.hi,$mem+4&quot; %}
 8923   opcode(0x03, 0x13);
 8924   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8925   ins_pipe( ialu_reg_long_mem );
 8926 %}
 8927 
 8928 // Subtract Long Register with Register.
 8929 instruct subL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8930   match(Set dst (SubL dst src));
 8931   effect(KILL cr);
 8932   ins_cost(200);
 8933   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8934             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8935   opcode(0x2B, 0x1B);
 8936   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8937   ins_pipe( ialu_reg_reg_long );
 8938 %}
 8939 
 8940 // Subtract Long Register with Immediate
 8941 instruct subL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8942   match(Set dst (SubL dst src));
 8943   effect(KILL cr);
 8944   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8945             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8946   opcode(0x81,0x05,0x03);  /* Opcode 81 /5, 81 /3 */
 8947   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8948   ins_pipe( ialu_reg_long );
 8949 %}
 8950 
 8951 // Subtract Long Register with Memory
 8952 instruct subL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8953   match(Set dst (SubL dst (LoadL mem)));
 8954   effect(KILL cr);
 8955   ins_cost(125);
 8956   format %{ &quot;SUB    $dst.lo,$mem\n\t&quot;
 8957             &quot;SBB    $dst.hi,$mem+4&quot; %}
 8958   opcode(0x2B, 0x1B);
 8959   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8960   ins_pipe( ialu_reg_long_mem );
 8961 %}
 8962 
 8963 instruct negL_eReg(eRegL dst, immL0 zero, eFlagsReg cr) %{
 8964   match(Set dst (SubL zero dst));
 8965   effect(KILL cr);
 8966   ins_cost(300);
 8967   format %{ &quot;NEG    $dst.hi\n\tNEG    $dst.lo\n\tSBB    $dst.hi,0&quot; %}
 8968   ins_encode( neg_long(dst) );
 8969   ins_pipe( ialu_reg_reg_long );
 8970 %}
 8971 
 8972 // And Long Register with Register
 8973 instruct andL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8974   match(Set dst (AndL dst src));
 8975   effect(KILL cr);
 8976   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 8977             &quot;AND    $dst.hi,$src.hi&quot; %}
 8978   opcode(0x23,0x23);
 8979   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 8980   ins_pipe( ialu_reg_reg_long );
 8981 %}
 8982 
 8983 // And Long Register with Immediate
 8984 instruct andL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8985   match(Set dst (AndL dst src));
 8986   effect(KILL cr);
 8987   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 8988             &quot;AND    $dst.hi,$src.hi&quot; %}
 8989   opcode(0x81,0x04,0x04);  /* Opcode 81 /4, 81 /4 */
 8990   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8991   ins_pipe( ialu_reg_long );
 8992 %}
 8993 
 8994 // And Long Register with Memory
 8995 instruct andL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8996   match(Set dst (AndL dst (LoadL mem)));
 8997   effect(KILL cr);
 8998   ins_cost(125);
 8999   format %{ &quot;AND    $dst.lo,$mem\n\t&quot;
 9000             &quot;AND    $dst.hi,$mem+4&quot; %}
 9001   opcode(0x23, 0x23);
 9002   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9003   ins_pipe( ialu_reg_long_mem );
 9004 %}
 9005 
 9006 // BMI1 instructions
 9007 instruct andnL_eReg_eReg_eReg(eRegL dst, eRegL src1, eRegL src2, immL_M1 minus_1, eFlagsReg cr) %{
 9008   match(Set dst (AndL (XorL src1 minus_1) src2));
 9009   predicate(UseBMI1Instructions);
 9010   effect(KILL cr, TEMP dst);
 9011 
 9012   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2.lo\n\t&quot;
 9013             &quot;ANDNL  $dst.hi, $src1.hi, $src2.hi&quot;
 9014          %}
 9015 
 9016   ins_encode %{
 9017     Register Rdst = $dst$$Register;
 9018     Register Rsrc1 = $src1$$Register;
 9019     Register Rsrc2 = $src2$$Register;
 9020     __ andnl(Rdst, Rsrc1, Rsrc2);
 9021     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), HIGH_FROM_LOW(Rsrc2));
 9022   %}
 9023   ins_pipe(ialu_reg_reg_long);
 9024 %}
 9025 
 9026 instruct andnL_eReg_eReg_mem(eRegL dst, eRegL src1, memory src2, immL_M1 minus_1, eFlagsReg cr) %{
 9027   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2) ));
 9028   predicate(UseBMI1Instructions);
 9029   effect(KILL cr, TEMP dst);
 9030 
 9031   ins_cost(125);
 9032   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2\n\t&quot;
 9033             &quot;ANDNL  $dst.hi, $src1.hi, $src2+4&quot;
 9034          %}
 9035 
 9036   ins_encode %{
 9037     Register Rdst = $dst$$Register;
 9038     Register Rsrc1 = $src1$$Register;
 9039     Address src2_hi = Address::make_raw($src2$$base, $src2$$index, $src2$$scale, $src2$$disp + 4, relocInfo::none);
 9040 
 9041     __ andnl(Rdst, Rsrc1, $src2$$Address);
 9042     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), src2_hi);
 9043   %}
 9044   ins_pipe(ialu_reg_mem);
 9045 %}
 9046 
 9047 instruct blsiL_eReg_eReg(eRegL dst, eRegL src, immL0 imm_zero, eFlagsReg cr) %{
 9048   match(Set dst (AndL (SubL imm_zero src) src));
 9049   predicate(UseBMI1Instructions);
 9050   effect(KILL cr, TEMP dst);
 9051 
 9052   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9053             &quot;BLSIL  $dst.lo, $src.lo\n\t&quot;
 9054             &quot;JNZ    done\n\t&quot;
 9055             &quot;BLSIL  $dst.hi, $src.hi\n&quot;
 9056             &quot;done:&quot;
 9057          %}
 9058 
 9059   ins_encode %{
 9060     Label done;
 9061     Register Rdst = $dst$$Register;
 9062     Register Rsrc = $src$$Register;
 9063     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9064     __ blsil(Rdst, Rsrc);
 9065     __ jccb(Assembler::notZero, done);
 9066     __ blsil(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9067     __ bind(done);
 9068   %}
 9069   ins_pipe(ialu_reg);
 9070 %}
 9071 
 9072 instruct blsiL_eReg_mem(eRegL dst, memory src, immL0 imm_zero, eFlagsReg cr) %{
 9073   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9074   predicate(UseBMI1Instructions);
 9075   effect(KILL cr, TEMP dst);
 9076 
 9077   ins_cost(125);
 9078   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9079             &quot;BLSIL  $dst.lo, $src\n\t&quot;
 9080             &quot;JNZ    done\n\t&quot;
 9081             &quot;BLSIL  $dst.hi, $src+4\n&quot;
 9082             &quot;done:&quot;
 9083          %}
 9084 
 9085   ins_encode %{
 9086     Label done;
 9087     Register Rdst = $dst$$Register;
 9088     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9089 
 9090     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9091     __ blsil(Rdst, $src$$Address);
 9092     __ jccb(Assembler::notZero, done);
 9093     __ blsil(HIGH_FROM_LOW(Rdst), src_hi);
 9094     __ bind(done);
 9095   %}
 9096   ins_pipe(ialu_reg_mem);
 9097 %}
 9098 
 9099 instruct blsmskL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9100 %{
 9101   match(Set dst (XorL (AddL src minus_1) src));
 9102   predicate(UseBMI1Instructions);
 9103   effect(KILL cr, TEMP dst);
 9104 
 9105   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9106             &quot;BLSMSKL $dst.lo, $src.lo\n\t&quot;
 9107             &quot;JNC     done\n\t&quot;
 9108             &quot;BLSMSKL $dst.hi, $src.hi\n&quot;
 9109             &quot;done:&quot;
 9110          %}
 9111 
 9112   ins_encode %{
 9113     Label done;
 9114     Register Rdst = $dst$$Register;
 9115     Register Rsrc = $src$$Register;
 9116     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9117     __ blsmskl(Rdst, Rsrc);
 9118     __ jccb(Assembler::carryClear, done);
 9119     __ blsmskl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9120     __ bind(done);
 9121   %}
 9122 
 9123   ins_pipe(ialu_reg);
 9124 %}
 9125 
 9126 instruct blsmskL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9127 %{
 9128   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ));
 9129   predicate(UseBMI1Instructions);
 9130   effect(KILL cr, TEMP dst);
 9131 
 9132   ins_cost(125);
 9133   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9134             &quot;BLSMSKL $dst.lo, $src\n\t&quot;
 9135             &quot;JNC     done\n\t&quot;
 9136             &quot;BLSMSKL $dst.hi, $src+4\n&quot;
 9137             &quot;done:&quot;
 9138          %}
 9139 
 9140   ins_encode %{
 9141     Label done;
 9142     Register Rdst = $dst$$Register;
 9143     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9144 
 9145     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9146     __ blsmskl(Rdst, $src$$Address);
 9147     __ jccb(Assembler::carryClear, done);
 9148     __ blsmskl(HIGH_FROM_LOW(Rdst), src_hi);
 9149     __ bind(done);
 9150   %}
 9151 
 9152   ins_pipe(ialu_reg_mem);
 9153 %}
 9154 
 9155 instruct blsrL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9156 %{
 9157   match(Set dst (AndL (AddL src minus_1) src) );
 9158   predicate(UseBMI1Instructions);
 9159   effect(KILL cr, TEMP dst);
 9160 
 9161   format %{ &quot;MOVL   $dst.hi, $src.hi\n\t&quot;
 9162             &quot;BLSRL  $dst.lo, $src.lo\n\t&quot;
 9163             &quot;JNC    done\n\t&quot;
 9164             &quot;BLSRL  $dst.hi, $src.hi\n&quot;
 9165             &quot;done:&quot;
 9166   %}
 9167 
 9168   ins_encode %{
 9169     Label done;
 9170     Register Rdst = $dst$$Register;
 9171     Register Rsrc = $src$$Register;
 9172     __ movl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9173     __ blsrl(Rdst, Rsrc);
 9174     __ jccb(Assembler::carryClear, done);
 9175     __ blsrl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9176     __ bind(done);
 9177   %}
 9178 
 9179   ins_pipe(ialu_reg);
 9180 %}
 9181 
 9182 instruct blsrL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9183 %{
 9184   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src) ));
 9185   predicate(UseBMI1Instructions);
 9186   effect(KILL cr, TEMP dst);
 9187 
 9188   ins_cost(125);
 9189   format %{ &quot;MOVL   $dst.hi, $src+4\n\t&quot;
 9190             &quot;BLSRL  $dst.lo, $src\n\t&quot;
 9191             &quot;JNC    done\n\t&quot;
 9192             &quot;BLSRL  $dst.hi, $src+4\n&quot;
 9193             &quot;done:&quot;
 9194   %}
 9195 
 9196   ins_encode %{
 9197     Label done;
 9198     Register Rdst = $dst$$Register;
 9199     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9200     __ movl(HIGH_FROM_LOW(Rdst), src_hi);
 9201     __ blsrl(Rdst, $src$$Address);
 9202     __ jccb(Assembler::carryClear, done);
 9203     __ blsrl(HIGH_FROM_LOW(Rdst), src_hi);
 9204     __ bind(done);
 9205   %}
 9206 
 9207   ins_pipe(ialu_reg_mem);
 9208 %}
 9209 
 9210 // Or Long Register with Register
 9211 instruct orl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9212   match(Set dst (OrL dst src));
 9213   effect(KILL cr);
 9214   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9215             &quot;OR     $dst.hi,$src.hi&quot; %}
 9216   opcode(0x0B,0x0B);
 9217   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9218   ins_pipe( ialu_reg_reg_long );
 9219 %}
 9220 
 9221 // Or Long Register with Immediate
 9222 instruct orl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9223   match(Set dst (OrL dst src));
 9224   effect(KILL cr);
 9225   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9226             &quot;OR     $dst.hi,$src.hi&quot; %}
 9227   opcode(0x81,0x01,0x01);  /* Opcode 81 /1, 81 /1 */
 9228   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9229   ins_pipe( ialu_reg_long );
 9230 %}
 9231 
 9232 // Or Long Register with Memory
 9233 instruct orl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9234   match(Set dst (OrL dst (LoadL mem)));
 9235   effect(KILL cr);
 9236   ins_cost(125);
 9237   format %{ &quot;OR     $dst.lo,$mem\n\t&quot;
 9238             &quot;OR     $dst.hi,$mem+4&quot; %}
 9239   opcode(0x0B,0x0B);
 9240   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9241   ins_pipe( ialu_reg_long_mem );
 9242 %}
 9243 
 9244 // Xor Long Register with Register
 9245 instruct xorl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9246   match(Set dst (XorL dst src));
 9247   effect(KILL cr);
 9248   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9249             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9250   opcode(0x33,0x33);
 9251   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9252   ins_pipe( ialu_reg_reg_long );
 9253 %}
 9254 
 9255 // Xor Long Register with Immediate -1
 9256 instruct xorl_eReg_im1(eRegL dst, immL_M1 imm) %{
 9257   match(Set dst (XorL dst imm));
 9258   format %{ &quot;NOT    $dst.lo\n\t&quot;
 9259             &quot;NOT    $dst.hi&quot; %}
 9260   ins_encode %{
 9261      __ notl($dst$$Register);
 9262      __ notl(HIGH_FROM_LOW($dst$$Register));
 9263   %}
 9264   ins_pipe( ialu_reg_long );
 9265 %}
 9266 
 9267 // Xor Long Register with Immediate
 9268 instruct xorl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9269   match(Set dst (XorL dst src));
 9270   effect(KILL cr);
 9271   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9272             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9273   opcode(0x81,0x06,0x06);  /* Opcode 81 /6, 81 /6 */
 9274   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9275   ins_pipe( ialu_reg_long );
 9276 %}
 9277 
 9278 // Xor Long Register with Memory
 9279 instruct xorl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9280   match(Set dst (XorL dst (LoadL mem)));
 9281   effect(KILL cr);
 9282   ins_cost(125);
 9283   format %{ &quot;XOR    $dst.lo,$mem\n\t&quot;
 9284             &quot;XOR    $dst.hi,$mem+4&quot; %}
 9285   opcode(0x33,0x33);
 9286   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9287   ins_pipe( ialu_reg_long_mem );
 9288 %}
 9289 
 9290 // Shift Left Long by 1
 9291 instruct shlL_eReg_1(eRegL dst, immI_1 cnt, eFlagsReg cr) %{
 9292   predicate(UseNewLongLShift);
 9293   match(Set dst (LShiftL dst cnt));
 9294   effect(KILL cr);
 9295   ins_cost(100);
 9296   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9297             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9298   ins_encode %{
 9299     __ addl($dst$$Register,$dst$$Register);
 9300     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9301   %}
 9302   ins_pipe( ialu_reg_long );
 9303 %}
 9304 
 9305 // Shift Left Long by 2
 9306 instruct shlL_eReg_2(eRegL dst, immI_2 cnt, eFlagsReg cr) %{
 9307   predicate(UseNewLongLShift);
 9308   match(Set dst (LShiftL dst cnt));
 9309   effect(KILL cr);
 9310   ins_cost(100);
 9311   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9312             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9313             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9314             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9315   ins_encode %{
 9316     __ addl($dst$$Register,$dst$$Register);
 9317     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9318     __ addl($dst$$Register,$dst$$Register);
 9319     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9320   %}
 9321   ins_pipe( ialu_reg_long );
 9322 %}
 9323 
 9324 // Shift Left Long by 3
 9325 instruct shlL_eReg_3(eRegL dst, immI_3 cnt, eFlagsReg cr) %{
 9326   predicate(UseNewLongLShift);
 9327   match(Set dst (LShiftL dst cnt));
 9328   effect(KILL cr);
 9329   ins_cost(100);
 9330   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9331             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9332             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9333             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9334             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9335             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9336   ins_encode %{
 9337     __ addl($dst$$Register,$dst$$Register);
 9338     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9339     __ addl($dst$$Register,$dst$$Register);
 9340     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9341     __ addl($dst$$Register,$dst$$Register);
 9342     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9343   %}
 9344   ins_pipe( ialu_reg_long );
 9345 %}
 9346 
 9347 // Shift Left Long by 1-31
 9348 instruct shlL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9349   match(Set dst (LShiftL dst cnt));
 9350   effect(KILL cr);
 9351   ins_cost(200);
 9352   format %{ &quot;SHLD   $dst.hi,$dst.lo,$cnt\n\t&quot;
 9353             &quot;SHL    $dst.lo,$cnt&quot; %}
 9354   opcode(0xC1, 0x4, 0xA4);  /* 0F/A4, then C1 /4 ib */
 9355   ins_encode( move_long_small_shift(dst,cnt) );
 9356   ins_pipe( ialu_reg_long );
 9357 %}
 9358 
 9359 // Shift Left Long by 32-63
 9360 instruct shlL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9361   match(Set dst (LShiftL dst cnt));
 9362   effect(KILL cr);
 9363   ins_cost(300);
 9364   format %{ &quot;MOV    $dst.hi,$dst.lo\n&quot;
 9365           &quot;\tSHL    $dst.hi,$cnt-32\n&quot;
 9366           &quot;\tXOR    $dst.lo,$dst.lo&quot; %}
 9367   opcode(0xC1, 0x4);  /* C1 /4 ib */
 9368   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9369   ins_pipe( ialu_reg_long );
 9370 %}
 9371 
 9372 // Shift Left Long by variable
 9373 instruct salL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9374   match(Set dst (LShiftL dst shift));
 9375   effect(KILL cr);
 9376   ins_cost(500+200);
 9377   size(17);
 9378   format %{ &quot;TEST   $shift,32\n\t&quot;
 9379             &quot;JEQ,s  small\n\t&quot;
 9380             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 9381             &quot;XOR    $dst.lo,$dst.lo\n&quot;
 9382     &quot;small:\tSHLD   $dst.hi,$dst.lo,$shift\n\t&quot;
 9383             &quot;SHL    $dst.lo,$shift&quot; %}
 9384   ins_encode( shift_left_long( dst, shift ) );
 9385   ins_pipe( pipe_slow );
 9386 %}
 9387 
 9388 // Shift Right Long by 1-31
 9389 instruct shrL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9390   match(Set dst (URShiftL dst cnt));
 9391   effect(KILL cr);
 9392   ins_cost(200);
 9393   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9394             &quot;SHR    $dst.hi,$cnt&quot; %}
 9395   opcode(0xC1, 0x5, 0xAC);  /* 0F/AC, then C1 /5 ib */
 9396   ins_encode( move_long_small_shift(dst,cnt) );
 9397   ins_pipe( ialu_reg_long );
 9398 %}
 9399 
 9400 // Shift Right Long by 32-63
 9401 instruct shrL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9402   match(Set dst (URShiftL dst cnt));
 9403   effect(KILL cr);
 9404   ins_cost(300);
 9405   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9406           &quot;\tSHR    $dst.lo,$cnt-32\n&quot;
 9407           &quot;\tXOR    $dst.hi,$dst.hi&quot; %}
 9408   opcode(0xC1, 0x5);  /* C1 /5 ib */
 9409   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9410   ins_pipe( ialu_reg_long );
 9411 %}
 9412 
 9413 // Shift Right Long by variable
 9414 instruct shrL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9415   match(Set dst (URShiftL dst shift));
 9416   effect(KILL cr);
 9417   ins_cost(600);
 9418   size(17);
 9419   format %{ &quot;TEST   $shift,32\n\t&quot;
 9420             &quot;JEQ,s  small\n\t&quot;
 9421             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9422             &quot;XOR    $dst.hi,$dst.hi\n&quot;
 9423     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9424             &quot;SHR    $dst.hi,$shift&quot; %}
 9425   ins_encode( shift_right_long( dst, shift ) );
 9426   ins_pipe( pipe_slow );
 9427 %}
 9428 
 9429 // Shift Right Long by 1-31
 9430 instruct sarL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9431   match(Set dst (RShiftL dst cnt));
 9432   effect(KILL cr);
 9433   ins_cost(200);
 9434   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9435             &quot;SAR    $dst.hi,$cnt&quot; %}
 9436   opcode(0xC1, 0x7, 0xAC);  /* 0F/AC, then C1 /7 ib */
 9437   ins_encode( move_long_small_shift(dst,cnt) );
 9438   ins_pipe( ialu_reg_long );
 9439 %}
 9440 
 9441 // Shift Right Long by 32-63
 9442 instruct sarL_eReg_32_63( eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9443   match(Set dst (RShiftL dst cnt));
 9444   effect(KILL cr);
 9445   ins_cost(300);
 9446   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9447           &quot;\tSAR    $dst.lo,$cnt-32\n&quot;
 9448           &quot;\tSAR    $dst.hi,31&quot; %}
 9449   opcode(0xC1, 0x7);  /* C1 /7 ib */
 9450   ins_encode( move_long_big_shift_sign(dst,cnt) );
 9451   ins_pipe( ialu_reg_long );
 9452 %}
 9453 
 9454 // Shift Right arithmetic Long by variable
 9455 instruct sarL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9456   match(Set dst (RShiftL dst shift));
 9457   effect(KILL cr);
 9458   ins_cost(600);
 9459   size(18);
 9460   format %{ &quot;TEST   $shift,32\n\t&quot;
 9461             &quot;JEQ,s  small\n\t&quot;
 9462             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9463             &quot;SAR    $dst.hi,31\n&quot;
 9464     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9465             &quot;SAR    $dst.hi,$shift&quot; %}
 9466   ins_encode( shift_right_arith_long( dst, shift ) );
 9467   ins_pipe( pipe_slow );
 9468 %}
 9469 
 9470 
 9471 //----------Double Instructions------------------------------------------------
 9472 // Double Math
 9473 
 9474 // Compare &amp; branch
 9475 
 9476 // P6 version of float compare, sets condition codes in EFLAGS
 9477 instruct cmpDPR_cc_P6(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9478   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9479   match(Set cr (CmpD src1 src2));
 9480   effect(KILL rax);
 9481   ins_cost(150);
 9482   format %{ &quot;FLD    $src1\n\t&quot;
 9483             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
 9484             &quot;JNP    exit\n\t&quot;
 9485             &quot;MOV    ah,1       // saw a NaN, set CF\n\t&quot;
 9486             &quot;SAHF\n&quot;
 9487      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
 9488   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9489   ins_encode( Push_Reg_DPR(src1),
 9490               OpcP, RegOpc(src2),
 9491               cmpF_P6_fixup );
 9492   ins_pipe( pipe_slow );
 9493 %}
 9494 
 9495 instruct cmpDPR_cc_P6CF(eFlagsRegUCF cr, regDPR src1, regDPR src2) %{
 9496   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9497   match(Set cr (CmpD src1 src2));
 9498   ins_cost(150);
 9499   format %{ &quot;FLD    $src1\n\t&quot;
 9500             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
 9501   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9502   ins_encode( Push_Reg_DPR(src1),
 9503               OpcP, RegOpc(src2));
 9504   ins_pipe( pipe_slow );
 9505 %}
 9506 
 9507 // Compare &amp; branch
 9508 instruct cmpDPR_cc(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9509   predicate(UseSSE&lt;=1);
 9510   match(Set cr (CmpD src1 src2));
 9511   effect(KILL rax);
 9512   ins_cost(200);
 9513   format %{ &quot;FLD    $src1\n\t&quot;
 9514             &quot;FCOMp  $src2\n\t&quot;
 9515             &quot;FNSTSW AX\n\t&quot;
 9516             &quot;TEST   AX,0x400\n\t&quot;
 9517             &quot;JZ,s   flags\n\t&quot;
 9518             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
 9519     &quot;flags:\tSAHF&quot; %}
 9520   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9521   ins_encode( Push_Reg_DPR(src1),
 9522               OpcP, RegOpc(src2),
 9523               fpu_flags);
 9524   ins_pipe( pipe_slow );
 9525 %}
 9526 
 9527 // Compare vs zero into -1,0,1
 9528 instruct cmpDPR_0(rRegI dst, regDPR src1, immDPR0 zero, eAXRegI rax, eFlagsReg cr) %{
 9529   predicate(UseSSE&lt;=1);
 9530   match(Set dst (CmpD3 src1 zero));
 9531   effect(KILL cr, KILL rax);
 9532   ins_cost(280);
 9533   format %{ &quot;FTSTD  $dst,$src1&quot; %}
 9534   opcode(0xE4, 0xD9);
 9535   ins_encode( Push_Reg_DPR(src1),
 9536               OpcS, OpcP, PopFPU,
 9537               CmpF_Result(dst));
 9538   ins_pipe( pipe_slow );
 9539 %}
 9540 
 9541 // Compare into -1,0,1
 9542 instruct cmpDPR_reg(rRegI dst, regDPR src1, regDPR src2, eAXRegI rax, eFlagsReg cr) %{
 9543   predicate(UseSSE&lt;=1);
 9544   match(Set dst (CmpD3 src1 src2));
 9545   effect(KILL cr, KILL rax);
 9546   ins_cost(300);
 9547   format %{ &quot;FCMPD  $dst,$src1,$src2&quot; %}
 9548   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9549   ins_encode( Push_Reg_DPR(src1),
 9550               OpcP, RegOpc(src2),
 9551               CmpF_Result(dst));
 9552   ins_pipe( pipe_slow );
 9553 %}
 9554 
 9555 // float compare and set condition codes in EFLAGS by XMM regs
 9556 instruct cmpD_cc(eFlagsRegU cr, regD src1, regD src2) %{
 9557   predicate(UseSSE&gt;=2);
 9558   match(Set cr (CmpD src1 src2));
 9559   ins_cost(145);
 9560   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9561             &quot;JNP,s   exit\n\t&quot;
 9562             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9563             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9564             &quot;POPF\n&quot;
 9565     &quot;exit:&quot; %}
 9566   ins_encode %{
 9567     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9568     emit_cmpfp_fixup(_masm);
 9569   %}
 9570   ins_pipe( pipe_slow );
 9571 %}
 9572 
 9573 instruct cmpD_ccCF(eFlagsRegUCF cr, regD src1, regD src2) %{
 9574   predicate(UseSSE&gt;=2);
 9575   match(Set cr (CmpD src1 src2));
 9576   ins_cost(100);
 9577   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9578   ins_encode %{
 9579     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9580   %}
 9581   ins_pipe( pipe_slow );
 9582 %}
 9583 
 9584 // float compare and set condition codes in EFLAGS by XMM regs
 9585 instruct cmpD_ccmem(eFlagsRegU cr, regD src1, memory src2) %{
 9586   predicate(UseSSE&gt;=2);
 9587   match(Set cr (CmpD src1 (LoadD src2)));
 9588   ins_cost(145);
 9589   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9590             &quot;JNP,s   exit\n\t&quot;
 9591             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9592             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9593             &quot;POPF\n&quot;
 9594     &quot;exit:&quot; %}
 9595   ins_encode %{
 9596     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9597     emit_cmpfp_fixup(_masm);
 9598   %}
 9599   ins_pipe( pipe_slow );
 9600 %}
 9601 
 9602 instruct cmpD_ccmemCF(eFlagsRegUCF cr, regD src1, memory src2) %{
 9603   predicate(UseSSE&gt;=2);
 9604   match(Set cr (CmpD src1 (LoadD src2)));
 9605   ins_cost(100);
 9606   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9607   ins_encode %{
 9608     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9609   %}
 9610   ins_pipe( pipe_slow );
 9611 %}
 9612 
 9613 // Compare into -1,0,1 in XMM
 9614 instruct cmpD_reg(xRegI dst, regD src1, regD src2, eFlagsReg cr) %{
 9615   predicate(UseSSE&gt;=2);
 9616   match(Set dst (CmpD3 src1 src2));
 9617   effect(KILL cr);
 9618   ins_cost(255);
 9619   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9620             &quot;MOV     $dst, #-1\n\t&quot;
 9621             &quot;JP,s    done\n\t&quot;
 9622             &quot;JB,s    done\n\t&quot;
 9623             &quot;SETNE   $dst\n\t&quot;
 9624             &quot;MOVZB   $dst, $dst\n&quot;
 9625     &quot;done:&quot; %}
 9626   ins_encode %{
 9627     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9628     emit_cmpfp3(_masm, $dst$$Register);
 9629   %}
 9630   ins_pipe( pipe_slow );
 9631 %}
 9632 
 9633 // Compare into -1,0,1 in XMM and memory
 9634 instruct cmpD_regmem(xRegI dst, regD src1, memory src2, eFlagsReg cr) %{
 9635   predicate(UseSSE&gt;=2);
 9636   match(Set dst (CmpD3 src1 (LoadD src2)));
 9637   effect(KILL cr);
 9638   ins_cost(275);
 9639   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9640             &quot;MOV     $dst, #-1\n\t&quot;
 9641             &quot;JP,s    done\n\t&quot;
 9642             &quot;JB,s    done\n\t&quot;
 9643             &quot;SETNE   $dst\n\t&quot;
 9644             &quot;MOVZB   $dst, $dst\n&quot;
 9645     &quot;done:&quot; %}
 9646   ins_encode %{
 9647     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9648     emit_cmpfp3(_masm, $dst$$Register);
 9649   %}
 9650   ins_pipe( pipe_slow );
 9651 %}
 9652 
 9653 
 9654 instruct subDPR_reg(regDPR dst, regDPR src) %{
 9655   predicate (UseSSE &lt;=1);
 9656   match(Set dst (SubD dst src));
 9657 
 9658   format %{ &quot;FLD    $src\n\t&quot;
 9659             &quot;DSUBp  $dst,ST&quot; %}
 9660   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
 9661   ins_cost(150);
 9662   ins_encode( Push_Reg_DPR(src),
 9663               OpcP, RegOpc(dst) );
 9664   ins_pipe( fpu_reg_reg );
 9665 %}
 9666 
 9667 instruct subDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9668   predicate (UseSSE &lt;=1);
 9669   match(Set dst (RoundDouble (SubD src1 src2)));
 9670   ins_cost(250);
 9671 
 9672   format %{ &quot;FLD    $src2\n\t&quot;
 9673             &quot;DSUB   ST,$src1\n\t&quot;
 9674             &quot;FSTP_D $dst\t# D-round&quot; %}
 9675   opcode(0xD8, 0x5);
 9676   ins_encode( Push_Reg_DPR(src2),
 9677               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9678   ins_pipe( fpu_mem_reg_reg );
 9679 %}
 9680 
 9681 
 9682 instruct subDPR_reg_mem(regDPR dst, memory src) %{
 9683   predicate (UseSSE &lt;=1);
 9684   match(Set dst (SubD dst (LoadD src)));
 9685   ins_cost(150);
 9686 
 9687   format %{ &quot;FLD    $src\n\t&quot;
 9688             &quot;DSUBp  $dst,ST&quot; %}
 9689   opcode(0xDE, 0x5, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9690   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9691               OpcP, RegOpc(dst) );
 9692   ins_pipe( fpu_reg_mem );
 9693 %}
 9694 
 9695 instruct absDPR_reg(regDPR1 dst, regDPR1 src) %{
 9696   predicate (UseSSE&lt;=1);
 9697   match(Set dst (AbsD src));
 9698   ins_cost(100);
 9699   format %{ &quot;FABS&quot; %}
 9700   opcode(0xE1, 0xD9);
 9701   ins_encode( OpcS, OpcP );
 9702   ins_pipe( fpu_reg_reg );
 9703 %}
 9704 
 9705 instruct negDPR_reg(regDPR1 dst, regDPR1 src) %{
 9706   predicate(UseSSE&lt;=1);
 9707   match(Set dst (NegD src));
 9708   ins_cost(100);
 9709   format %{ &quot;FCHS&quot; %}
 9710   opcode(0xE0, 0xD9);
 9711   ins_encode( OpcS, OpcP );
 9712   ins_pipe( fpu_reg_reg );
 9713 %}
 9714 
 9715 instruct addDPR_reg(regDPR dst, regDPR src) %{
 9716   predicate(UseSSE&lt;=1);
 9717   match(Set dst (AddD dst src));
 9718   format %{ &quot;FLD    $src\n\t&quot;
 9719             &quot;DADD   $dst,ST&quot; %}
 9720   size(4);
 9721   ins_cost(150);
 9722   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
 9723   ins_encode( Push_Reg_DPR(src),
 9724               OpcP, RegOpc(dst) );
 9725   ins_pipe( fpu_reg_reg );
 9726 %}
 9727 
 9728 
 9729 instruct addDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9730   predicate(UseSSE&lt;=1);
 9731   match(Set dst (RoundDouble (AddD src1 src2)));
 9732   ins_cost(250);
 9733 
 9734   format %{ &quot;FLD    $src2\n\t&quot;
 9735             &quot;DADD   ST,$src1\n\t&quot;
 9736             &quot;FSTP_D $dst\t# D-round&quot; %}
 9737   opcode(0xD8, 0x0); /* D8 C0+i or D8 /0*/
 9738   ins_encode( Push_Reg_DPR(src2),
 9739               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9740   ins_pipe( fpu_mem_reg_reg );
 9741 %}
 9742 
 9743 
 9744 instruct addDPR_reg_mem(regDPR dst, memory src) %{
 9745   predicate(UseSSE&lt;=1);
 9746   match(Set dst (AddD dst (LoadD src)));
 9747   ins_cost(150);
 9748 
 9749   format %{ &quot;FLD    $src\n\t&quot;
 9750             &quot;DADDp  $dst,ST&quot; %}
 9751   opcode(0xDE, 0x0, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9752   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9753               OpcP, RegOpc(dst) );
 9754   ins_pipe( fpu_reg_mem );
 9755 %}
 9756 
 9757 // add-to-memory
 9758 instruct addDPR_mem_reg(memory dst, regDPR src) %{
 9759   predicate(UseSSE&lt;=1);
 9760   match(Set dst (StoreD dst (RoundDouble (AddD (LoadD dst) src))));
 9761   ins_cost(150);
 9762 
 9763   format %{ &quot;FLD_D  $dst\n\t&quot;
 9764             &quot;DADD   ST,$src\n\t&quot;
 9765             &quot;FST_D  $dst&quot; %}
 9766   opcode(0xDD, 0x0);
 9767   ins_encode( Opcode(0xDD), RMopc_Mem(0x00,dst),
 9768               Opcode(0xD8), RegOpc(src),
 9769               set_instruction_start,
 9770               Opcode(0xDD), RMopc_Mem(0x03,dst) );
 9771   ins_pipe( fpu_reg_mem );
 9772 %}
 9773 
 9774 instruct addDPR_reg_imm1(regDPR dst, immDPR1 con) %{
 9775   predicate(UseSSE&lt;=1);
 9776   match(Set dst (AddD dst con));
 9777   ins_cost(125);
 9778   format %{ &quot;FLD1\n\t&quot;
 9779             &quot;DADDp  $dst,ST&quot; %}
 9780   ins_encode %{
 9781     __ fld1();
 9782     __ faddp($dst$$reg);
 9783   %}
 9784   ins_pipe(fpu_reg);
 9785 %}
 9786 
 9787 instruct addDPR_reg_imm(regDPR dst, immDPR con) %{
 9788   predicate(UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9789   match(Set dst (AddD dst con));
 9790   ins_cost(200);
 9791   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9792             &quot;DADDp  $dst,ST&quot; %}
 9793   ins_encode %{
 9794     __ fld_d($constantaddress($con));
 9795     __ faddp($dst$$reg);
 9796   %}
 9797   ins_pipe(fpu_reg_mem);
 9798 %}
 9799 
 9800 instruct addDPR_reg_imm_round(stackSlotD dst, regDPR src, immDPR con) %{
 9801   predicate(UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9802   match(Set dst (RoundDouble (AddD src con)));
 9803   ins_cost(200);
 9804   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9805             &quot;DADD   ST,$src\n\t&quot;
 9806             &quot;FSTP_D $dst\t# D-round&quot; %}
 9807   ins_encode %{
 9808     __ fld_d($constantaddress($con));
 9809     __ fadd($src$$reg);
 9810     __ fstp_d(Address(rsp, $dst$$disp));
 9811   %}
 9812   ins_pipe(fpu_mem_reg_con);
 9813 %}
 9814 
 9815 instruct mulDPR_reg(regDPR dst, regDPR src) %{
 9816   predicate(UseSSE&lt;=1);
 9817   match(Set dst (MulD dst src));
 9818   format %{ &quot;FLD    $src\n\t&quot;
 9819             &quot;DMULp  $dst,ST&quot; %}
 9820   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9821   ins_cost(150);
 9822   ins_encode( Push_Reg_DPR(src),
 9823               OpcP, RegOpc(dst) );
 9824   ins_pipe( fpu_reg_reg );
 9825 %}
 9826 
 9827 // Strict FP instruction biases argument before multiply then
 9828 // biases result to avoid double rounding of subnormals.
 9829 //
 9830 // scale arg1 by multiplying arg1 by 2^(-15360)
 9831 // load arg2
 9832 // multiply scaled arg1 by arg2
 9833 // rescale product by 2^(15360)
 9834 //
 9835 instruct strictfp_mulDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9836   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9837   match(Set dst (MulD dst src));
 9838   ins_cost(1);   // Select this instruction for all strict FP double multiplies
 9839 
 9840   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9841             &quot;DMULp  $dst,ST\n\t&quot;
 9842             &quot;FLD    $src\n\t&quot;
 9843             &quot;DMULp  $dst,ST\n\t&quot;
 9844             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9845             &quot;DMULp  $dst,ST\n\t&quot; %}
 9846   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9847   ins_encode( strictfp_bias1(dst),
 9848               Push_Reg_DPR(src),
 9849               OpcP, RegOpc(dst),
 9850               strictfp_bias2(dst) );
 9851   ins_pipe( fpu_reg_reg );
 9852 %}
 9853 
 9854 instruct mulDPR_reg_imm(regDPR dst, immDPR con) %{
 9855   predicate( UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9856   match(Set dst (MulD dst con));
 9857   ins_cost(200);
 9858   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9859             &quot;DMULp  $dst,ST&quot; %}
 9860   ins_encode %{
 9861     __ fld_d($constantaddress($con));
 9862     __ fmulp($dst$$reg);
 9863   %}
 9864   ins_pipe(fpu_reg_mem);
 9865 %}
 9866 
 9867 
 9868 instruct mulDPR_reg_mem(regDPR dst, memory src) %{
 9869   predicate( UseSSE&lt;=1 );
 9870   match(Set dst (MulD dst (LoadD src)));
 9871   ins_cost(200);
 9872   format %{ &quot;FLD_D  $src\n\t&quot;
 9873             &quot;DMULp  $dst,ST&quot; %}
 9874   opcode(0xDE, 0x1, 0xDD); /* DE C8+i or DE /1*/  /* LoadD  DD /0 */
 9875   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9876               OpcP, RegOpc(dst) );
 9877   ins_pipe( fpu_reg_mem );
 9878 %}
 9879 
 9880 //
 9881 // Cisc-alternate to reg-reg multiply
 9882 instruct mulDPR_reg_mem_cisc(regDPR dst, regDPR src, memory mem) %{
 9883   predicate( UseSSE&lt;=1 );
 9884   match(Set dst (MulD src (LoadD mem)));
 9885   ins_cost(250);
 9886   format %{ &quot;FLD_D  $mem\n\t&quot;
 9887             &quot;DMUL   ST,$src\n\t&quot;
 9888             &quot;FSTP_D $dst&quot; %}
 9889   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadD D9 /0 */
 9890   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem),
 9891               OpcReg_FPR(src),
 9892               Pop_Reg_DPR(dst) );
 9893   ins_pipe( fpu_reg_reg_mem );
 9894 %}
 9895 
 9896 
 9897 // MACRO3 -- addDPR a mulDPR
 9898 // This instruction is a &#39;2-address&#39; instruction in that the result goes
 9899 // back to src2.  This eliminates a move from the macro; possibly the
 9900 // register allocator will have to add it back (and maybe not).
 9901 instruct addDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9902   predicate( UseSSE&lt;=1 );
 9903   match(Set src2 (AddD (MulD src0 src1) src2));
 9904   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9905             &quot;DMUL   ST,$src1\n\t&quot;
 9906             &quot;DADDp  $src2,ST&quot; %}
 9907   ins_cost(250);
 9908   opcode(0xDD); /* LoadD DD /0 */
 9909   ins_encode( Push_Reg_FPR(src0),
 9910               FMul_ST_reg(src1),
 9911               FAddP_reg_ST(src2) );
 9912   ins_pipe( fpu_reg_reg_reg );
 9913 %}
 9914 
 9915 
 9916 // MACRO3 -- subDPR a mulDPR
 9917 instruct subDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9918   predicate( UseSSE&lt;=1 );
 9919   match(Set src2 (SubD (MulD src0 src1) src2));
 9920   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9921             &quot;DMUL   ST,$src1\n\t&quot;
 9922             &quot;DSUBRp $src2,ST&quot; %}
 9923   ins_cost(250);
 9924   ins_encode( Push_Reg_FPR(src0),
 9925               FMul_ST_reg(src1),
 9926               Opcode(0xDE), Opc_plus(0xE0,src2));
 9927   ins_pipe( fpu_reg_reg_reg );
 9928 %}
 9929 
 9930 
 9931 instruct divDPR_reg(regDPR dst, regDPR src) %{
 9932   predicate( UseSSE&lt;=1 );
 9933   match(Set dst (DivD dst src));
 9934 
 9935   format %{ &quot;FLD    $src\n\t&quot;
 9936             &quot;FDIVp  $dst,ST&quot; %}
 9937   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9938   ins_cost(150);
 9939   ins_encode( Push_Reg_DPR(src),
 9940               OpcP, RegOpc(dst) );
 9941   ins_pipe( fpu_reg_reg );
 9942 %}
 9943 
 9944 // Strict FP instruction biases argument before division then
 9945 // biases result, to avoid double rounding of subnormals.
 9946 //
 9947 // scale dividend by multiplying dividend by 2^(-15360)
 9948 // load divisor
 9949 // divide scaled dividend by divisor
 9950 // rescale quotient by 2^(15360)
 9951 //
 9952 instruct strictfp_divDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9953   predicate (UseSSE&lt;=1);
 9954   match(Set dst (DivD dst src));
 9955   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9956   ins_cost(01);
 9957 
 9958   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9959             &quot;DMULp  $dst,ST\n\t&quot;
 9960             &quot;FLD    $src\n\t&quot;
 9961             &quot;FDIVp  $dst,ST\n\t&quot;
 9962             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9963             &quot;DMULp  $dst,ST\n\t&quot; %}
 9964   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9965   ins_encode( strictfp_bias1(dst),
 9966               Push_Reg_DPR(src),
 9967               OpcP, RegOpc(dst),
 9968               strictfp_bias2(dst) );
 9969   ins_pipe( fpu_reg_reg );
 9970 %}
 9971 
 9972 instruct divDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9973   predicate( UseSSE&lt;=1 &amp;&amp; !(Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict()) );
 9974   match(Set dst (RoundDouble (DivD src1 src2)));
 9975 
 9976   format %{ &quot;FLD    $src1\n\t&quot;
 9977             &quot;FDIV   ST,$src2\n\t&quot;
 9978             &quot;FSTP_D $dst\t# D-round&quot; %}
 9979   opcode(0xD8, 0x6); /* D8 F0+i or D8 /6 */
 9980   ins_encode( Push_Reg_DPR(src1),
 9981               OpcP, RegOpc(src2), Pop_Mem_DPR(dst) );
 9982   ins_pipe( fpu_mem_reg_reg );
 9983 %}
 9984 
 9985 
 9986 instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{
 9987   predicate(UseSSE&lt;=1);
 9988   match(Set dst (ModD dst src));
 9989   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
 9990 
 9991   format %{ &quot;DMOD   $dst,$src&quot; %}
 9992   ins_cost(250);
 9993   ins_encode(Push_Reg_Mod_DPR(dst, src),
 9994               emitModDPR(),
 9995               Push_Result_Mod_DPR(src),
 9996               Pop_Reg_DPR(dst));
 9997   ins_pipe( pipe_slow );
 9998 %}
 9999 
10000 instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{
10001   predicate(UseSSE&gt;=2);
10002   match(Set dst (ModD src0 src1));
10003   effect(KILL rax, KILL cr);
10004 
10005   format %{ &quot;SUB    ESP,8\t # DMOD\n&quot;
10006           &quot;\tMOVSD  [ESP+0],$src1\n&quot;
10007           &quot;\tFLD_D  [ESP+0]\n&quot;
10008           &quot;\tMOVSD  [ESP+0],$src0\n&quot;
10009           &quot;\tFLD_D  [ESP+0]\n&quot;
10010      &quot;loop:\tFPREM\n&quot;
10011           &quot;\tFWAIT\n&quot;
10012           &quot;\tFNSTSW AX\n&quot;
10013           &quot;\tSAHF\n&quot;
10014           &quot;\tJP     loop\n&quot;
10015           &quot;\tFSTP_D [ESP+0]\n&quot;
10016           &quot;\tMOVSD  $dst,[ESP+0]\n&quot;
10017           &quot;\tADD    ESP,8\n&quot;
10018           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10019     %}
10020   ins_cost(250);
10021   ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);
10022   ins_pipe( pipe_slow );
10023 %}
10024 
10025 instruct atanDPR_reg(regDPR dst, regDPR src) %{
10026   predicate (UseSSE&lt;=1);
10027   match(Set dst(AtanD dst src));
10028   format %{ &quot;DATA   $dst,$src&quot; %}
10029   opcode(0xD9, 0xF3);
10030   ins_encode( Push_Reg_DPR(src),
10031               OpcP, OpcS, RegOpc(dst) );
10032   ins_pipe( pipe_slow );
10033 %}
10034 
10035 instruct atanD_reg(regD dst, regD src, eFlagsReg cr) %{
10036   predicate (UseSSE&gt;=2);
10037   match(Set dst(AtanD dst src));
10038   effect(KILL cr); // Push_{Src|Result}D() uses &quot;{SUB|ADD} ESP,8&quot;
10039   format %{ &quot;DATA   $dst,$src&quot; %}
10040   opcode(0xD9, 0xF3);
10041   ins_encode( Push_SrcD(src),
10042               OpcP, OpcS, Push_ResultD(dst) );
10043   ins_pipe( pipe_slow );
10044 %}
10045 
10046 instruct sqrtDPR_reg(regDPR dst, regDPR src) %{
10047   predicate (UseSSE&lt;=1);
10048   match(Set dst (SqrtD src));
10049   format %{ &quot;DSQRT  $dst,$src&quot; %}
10050   opcode(0xFA, 0xD9);
10051   ins_encode( Push_Reg_DPR(src),
10052               OpcS, OpcP, Pop_Reg_DPR(dst) );
10053   ins_pipe( pipe_slow );
10054 %}
10055 
10056 //-------------Float Instructions-------------------------------
10057 // Float Math
10058 
10059 // Code for float compare:
10060 //     fcompp();
10061 //     fwait(); fnstsw_ax();
10062 //     sahf();
10063 //     movl(dst, unordered_result);
10064 //     jcc(Assembler::parity, exit);
10065 //     movl(dst, less_result);
10066 //     jcc(Assembler::below, exit);
10067 //     movl(dst, equal_result);
10068 //     jcc(Assembler::equal, exit);
10069 //     movl(dst, greater_result);
10070 //   exit:
10071 
10072 // P6 version of float compare, sets condition codes in EFLAGS
10073 instruct cmpFPR_cc_P6(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10074   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10075   match(Set cr (CmpF src1 src2));
10076   effect(KILL rax);
10077   ins_cost(150);
10078   format %{ &quot;FLD    $src1\n\t&quot;
10079             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
10080             &quot;JNP    exit\n\t&quot;
10081             &quot;MOV    ah,1       // saw a NaN, set CF (treat as LT)\n\t&quot;
10082             &quot;SAHF\n&quot;
10083      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
10084   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10085   ins_encode( Push_Reg_DPR(src1),
10086               OpcP, RegOpc(src2),
10087               cmpF_P6_fixup );
10088   ins_pipe( pipe_slow );
10089 %}
10090 
10091 instruct cmpFPR_cc_P6CF(eFlagsRegUCF cr, regFPR src1, regFPR src2) %{
10092   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10093   match(Set cr (CmpF src1 src2));
10094   ins_cost(100);
10095   format %{ &quot;FLD    $src1\n\t&quot;
10096             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
10097   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10098   ins_encode( Push_Reg_DPR(src1),
10099               OpcP, RegOpc(src2));
10100   ins_pipe( pipe_slow );
10101 %}
10102 
10103 
10104 // Compare &amp; branch
10105 instruct cmpFPR_cc(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10106   predicate(UseSSE == 0);
10107   match(Set cr (CmpF src1 src2));
10108   effect(KILL rax);
10109   ins_cost(200);
10110   format %{ &quot;FLD    $src1\n\t&quot;
10111             &quot;FCOMp  $src2\n\t&quot;
10112             &quot;FNSTSW AX\n\t&quot;
10113             &quot;TEST   AX,0x400\n\t&quot;
10114             &quot;JZ,s   flags\n\t&quot;
10115             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
10116     &quot;flags:\tSAHF&quot; %}
10117   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10118   ins_encode( Push_Reg_DPR(src1),
10119               OpcP, RegOpc(src2),
10120               fpu_flags);
10121   ins_pipe( pipe_slow );
10122 %}
10123 
10124 // Compare vs zero into -1,0,1
10125 instruct cmpFPR_0(rRegI dst, regFPR src1, immFPR0 zero, eAXRegI rax, eFlagsReg cr) %{
10126   predicate(UseSSE == 0);
10127   match(Set dst (CmpF3 src1 zero));
10128   effect(KILL cr, KILL rax);
10129   ins_cost(280);
10130   format %{ &quot;FTSTF  $dst,$src1&quot; %}
10131   opcode(0xE4, 0xD9);
10132   ins_encode( Push_Reg_DPR(src1),
10133               OpcS, OpcP, PopFPU,
10134               CmpF_Result(dst));
10135   ins_pipe( pipe_slow );
10136 %}
10137 
10138 // Compare into -1,0,1
10139 instruct cmpFPR_reg(rRegI dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10140   predicate(UseSSE == 0);
10141   match(Set dst (CmpF3 src1 src2));
10142   effect(KILL cr, KILL rax);
10143   ins_cost(300);
10144   format %{ &quot;FCMPF  $dst,$src1,$src2&quot; %}
10145   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10146   ins_encode( Push_Reg_DPR(src1),
10147               OpcP, RegOpc(src2),
10148               CmpF_Result(dst));
10149   ins_pipe( pipe_slow );
10150 %}
10151 
10152 // float compare and set condition codes in EFLAGS by XMM regs
10153 instruct cmpF_cc(eFlagsRegU cr, regF src1, regF src2) %{
10154   predicate(UseSSE&gt;=1);
10155   match(Set cr (CmpF src1 src2));
10156   ins_cost(145);
10157   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10158             &quot;JNP,s   exit\n\t&quot;
10159             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10160             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10161             &quot;POPF\n&quot;
10162     &quot;exit:&quot; %}
10163   ins_encode %{
10164     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10165     emit_cmpfp_fixup(_masm);
10166   %}
10167   ins_pipe( pipe_slow );
10168 %}
10169 
10170 instruct cmpF_ccCF(eFlagsRegUCF cr, regF src1, regF src2) %{
10171   predicate(UseSSE&gt;=1);
10172   match(Set cr (CmpF src1 src2));
10173   ins_cost(100);
10174   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10175   ins_encode %{
10176     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10177   %}
10178   ins_pipe( pipe_slow );
10179 %}
10180 
10181 // float compare and set condition codes in EFLAGS by XMM regs
10182 instruct cmpF_ccmem(eFlagsRegU cr, regF src1, memory src2) %{
10183   predicate(UseSSE&gt;=1);
10184   match(Set cr (CmpF src1 (LoadF src2)));
10185   ins_cost(165);
10186   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10187             &quot;JNP,s   exit\n\t&quot;
10188             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10189             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10190             &quot;POPF\n&quot;
10191     &quot;exit:&quot; %}
10192   ins_encode %{
10193     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10194     emit_cmpfp_fixup(_masm);
10195   %}
10196   ins_pipe( pipe_slow );
10197 %}
10198 
10199 instruct cmpF_ccmemCF(eFlagsRegUCF cr, regF src1, memory src2) %{
10200   predicate(UseSSE&gt;=1);
10201   match(Set cr (CmpF src1 (LoadF src2)));
10202   ins_cost(100);
10203   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10204   ins_encode %{
10205     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10206   %}
10207   ins_pipe( pipe_slow );
10208 %}
10209 
10210 // Compare into -1,0,1 in XMM
10211 instruct cmpF_reg(xRegI dst, regF src1, regF src2, eFlagsReg cr) %{
10212   predicate(UseSSE&gt;=1);
10213   match(Set dst (CmpF3 src1 src2));
10214   effect(KILL cr);
10215   ins_cost(255);
10216   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10217             &quot;MOV     $dst, #-1\n\t&quot;
10218             &quot;JP,s    done\n\t&quot;
10219             &quot;JB,s    done\n\t&quot;
10220             &quot;SETNE   $dst\n\t&quot;
10221             &quot;MOVZB   $dst, $dst\n&quot;
10222     &quot;done:&quot; %}
10223   ins_encode %{
10224     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10225     emit_cmpfp3(_masm, $dst$$Register);
10226   %}
10227   ins_pipe( pipe_slow );
10228 %}
10229 
10230 // Compare into -1,0,1 in XMM and memory
10231 instruct cmpF_regmem(xRegI dst, regF src1, memory src2, eFlagsReg cr) %{
10232   predicate(UseSSE&gt;=1);
10233   match(Set dst (CmpF3 src1 (LoadF src2)));
10234   effect(KILL cr);
10235   ins_cost(275);
10236   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10237             &quot;MOV     $dst, #-1\n\t&quot;
10238             &quot;JP,s    done\n\t&quot;
10239             &quot;JB,s    done\n\t&quot;
10240             &quot;SETNE   $dst\n\t&quot;
10241             &quot;MOVZB   $dst, $dst\n&quot;
10242     &quot;done:&quot; %}
10243   ins_encode %{
10244     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10245     emit_cmpfp3(_masm, $dst$$Register);
10246   %}
10247   ins_pipe( pipe_slow );
10248 %}
10249 
10250 // Spill to obtain 24-bit precision
10251 instruct subFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10252   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10253   match(Set dst (SubF src1 src2));
10254 
10255   format %{ &quot;FSUB   $dst,$src1 - $src2&quot; %}
10256   opcode(0xD8, 0x4); /* D8 E0+i or D8 /4 mod==0x3 ;; result in TOS */
10257   ins_encode( Push_Reg_FPR(src1),
10258               OpcReg_FPR(src2),
10259               Pop_Mem_FPR(dst) );
10260   ins_pipe( fpu_mem_reg_reg );
10261 %}
10262 //
10263 // This instruction does not round to 24-bits
10264 instruct subFPR_reg(regFPR dst, regFPR src) %{
10265   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10266   match(Set dst (SubF dst src));
10267 
10268   format %{ &quot;FSUB   $dst,$src&quot; %}
10269   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
10270   ins_encode( Push_Reg_FPR(src),
10271               OpcP, RegOpc(dst) );
10272   ins_pipe( fpu_reg_reg );
10273 %}
10274 
10275 // Spill to obtain 24-bit precision
10276 instruct addFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10277   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10278   match(Set dst (AddF src1 src2));
10279 
10280   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10281   opcode(0xD8, 0x0); /* D8 C0+i */
10282   ins_encode( Push_Reg_FPR(src2),
10283               OpcReg_FPR(src1),
10284               Pop_Mem_FPR(dst) );
10285   ins_pipe( fpu_mem_reg_reg );
10286 %}
10287 //
10288 // This instruction does not round to 24-bits
10289 instruct addFPR_reg(regFPR dst, regFPR src) %{
10290   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10291   match(Set dst (AddF dst src));
10292 
10293   format %{ &quot;FLD    $src\n\t&quot;
10294             &quot;FADDp  $dst,ST&quot; %}
10295   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
10296   ins_encode( Push_Reg_FPR(src),
10297               OpcP, RegOpc(dst) );
10298   ins_pipe( fpu_reg_reg );
10299 %}
10300 
10301 instruct absFPR_reg(regFPR1 dst, regFPR1 src) %{
10302   predicate(UseSSE==0);
10303   match(Set dst (AbsF src));
10304   ins_cost(100);
10305   format %{ &quot;FABS&quot; %}
10306   opcode(0xE1, 0xD9);
10307   ins_encode( OpcS, OpcP );
10308   ins_pipe( fpu_reg_reg );
10309 %}
10310 
10311 instruct negFPR_reg(regFPR1 dst, regFPR1 src) %{
10312   predicate(UseSSE==0);
10313   match(Set dst (NegF src));
10314   ins_cost(100);
10315   format %{ &quot;FCHS&quot; %}
10316   opcode(0xE0, 0xD9);
10317   ins_encode( OpcS, OpcP );
10318   ins_pipe( fpu_reg_reg );
10319 %}
10320 
10321 // Cisc-alternate to addFPR_reg
10322 // Spill to obtain 24-bit precision
10323 instruct addFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10324   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10325   match(Set dst (AddF src1 (LoadF src2)));
10326 
10327   format %{ &quot;FLD    $src2\n\t&quot;
10328             &quot;FADD   ST,$src1\n\t&quot;
10329             &quot;FSTP_S $dst&quot; %}
10330   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10331   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10332               OpcReg_FPR(src1),
10333               Pop_Mem_FPR(dst) );
10334   ins_pipe( fpu_mem_reg_mem );
10335 %}
10336 //
10337 // Cisc-alternate to addFPR_reg
10338 // This instruction does not round to 24-bits
10339 instruct addFPR_reg_mem(regFPR dst, memory src) %{
10340   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10341   match(Set dst (AddF dst (LoadF src)));
10342 
10343   format %{ &quot;FADD   $dst,$src&quot; %}
10344   opcode(0xDE, 0x0, 0xD9); /* DE C0+i or DE /0*/  /* LoadF  D9 /0 */
10345   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
10346               OpcP, RegOpc(dst) );
10347   ins_pipe( fpu_reg_mem );
10348 %}
10349 
10350 // // Following two instructions for _222_mpegaudio
10351 // Spill to obtain 24-bit precision
10352 instruct addFPR24_mem_reg(stackSlotF dst, regFPR src2, memory src1 ) %{
10353   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10354   match(Set dst (AddF src1 src2));
10355 
10356   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10357   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10358   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src1),
10359               OpcReg_FPR(src2),
10360               Pop_Mem_FPR(dst) );
10361   ins_pipe( fpu_mem_reg_mem );
10362 %}
10363 
10364 // Cisc-spill variant
10365 // Spill to obtain 24-bit precision
10366 instruct addFPR24_mem_cisc(stackSlotF dst, memory src1, memory src2) %{
10367   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10368   match(Set dst (AddF src1 (LoadF src2)));
10369 
10370   format %{ &quot;FADD   $dst,$src1,$src2 cisc&quot; %}
10371   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10372   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10373               set_instruction_start,
10374               OpcP, RMopc_Mem(secondary,src1),
10375               Pop_Mem_FPR(dst) );
10376   ins_pipe( fpu_mem_mem_mem );
10377 %}
10378 
10379 // Spill to obtain 24-bit precision
10380 instruct addFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10381   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10382   match(Set dst (AddF src1 src2));
10383 
10384   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10385   opcode(0xD8, 0x0, 0xD9); /* D8 /0 */  /* LoadF  D9 /0 */
10386   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10387               set_instruction_start,
10388               OpcP, RMopc_Mem(secondary,src1),
10389               Pop_Mem_FPR(dst) );
10390   ins_pipe( fpu_mem_mem_mem );
10391 %}
10392 
10393 
10394 // Spill to obtain 24-bit precision
10395 instruct addFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10396   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10397   match(Set dst (AddF src con));
10398   format %{ &quot;FLD    $src\n\t&quot;
10399             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10400             &quot;FSTP_S $dst&quot;  %}
10401   ins_encode %{
10402     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10403     __ fadd_s($constantaddress($con));
10404     __ fstp_s(Address(rsp, $dst$$disp));
10405   %}
10406   ins_pipe(fpu_mem_reg_con);
10407 %}
10408 //
10409 // This instruction does not round to 24-bits
10410 instruct addFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10411   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10412   match(Set dst (AddF src con));
10413   format %{ &quot;FLD    $src\n\t&quot;
10414             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10415             &quot;FSTP   $dst&quot;  %}
10416   ins_encode %{
10417     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10418     __ fadd_s($constantaddress($con));
10419     __ fstp_d($dst$$reg);
10420   %}
10421   ins_pipe(fpu_reg_reg_con);
10422 %}
10423 
10424 // Spill to obtain 24-bit precision
10425 instruct mulFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10426   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10427   match(Set dst (MulF src1 src2));
10428 
10429   format %{ &quot;FLD    $src1\n\t&quot;
10430             &quot;FMUL   $src2\n\t&quot;
10431             &quot;FSTP_S $dst&quot;  %}
10432   opcode(0xD8, 0x1); /* D8 C8+i or D8 /1 ;; result in TOS */
10433   ins_encode( Push_Reg_FPR(src1),
10434               OpcReg_FPR(src2),
10435               Pop_Mem_FPR(dst) );
10436   ins_pipe( fpu_mem_reg_reg );
10437 %}
10438 //
10439 // This instruction does not round to 24-bits
10440 instruct mulFPR_reg(regFPR dst, regFPR src1, regFPR src2) %{
10441   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10442   match(Set dst (MulF src1 src2));
10443 
10444   format %{ &quot;FLD    $src1\n\t&quot;
10445             &quot;FMUL   $src2\n\t&quot;
10446             &quot;FSTP_S $dst&quot;  %}
10447   opcode(0xD8, 0x1); /* D8 C8+i */
10448   ins_encode( Push_Reg_FPR(src2),
10449               OpcReg_FPR(src1),
10450               Pop_Reg_FPR(dst) );
10451   ins_pipe( fpu_reg_reg_reg );
10452 %}
10453 
10454 
10455 // Spill to obtain 24-bit precision
10456 // Cisc-alternate to reg-reg multiply
10457 instruct mulFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10458   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10459   match(Set dst (MulF src1 (LoadF src2)));
10460 
10461   format %{ &quot;FLD_S  $src2\n\t&quot;
10462             &quot;FMUL   $src1\n\t&quot;
10463             &quot;FSTP_S $dst&quot;  %}
10464   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or DE /1*/  /* LoadF D9 /0 */
10465   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10466               OpcReg_FPR(src1),
10467               Pop_Mem_FPR(dst) );
10468   ins_pipe( fpu_mem_reg_mem );
10469 %}
10470 //
10471 // This instruction does not round to 24-bits
10472 // Cisc-alternate to reg-reg multiply
10473 instruct mulFPR_reg_mem(regFPR dst, regFPR src1, memory src2) %{
10474   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10475   match(Set dst (MulF src1 (LoadF src2)));
10476 
10477   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10478   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadF D9 /0 */
10479   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10480               OpcReg_FPR(src1),
10481               Pop_Reg_FPR(dst) );
10482   ins_pipe( fpu_reg_reg_mem );
10483 %}
10484 
10485 // Spill to obtain 24-bit precision
10486 instruct mulFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10487   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10488   match(Set dst (MulF src1 src2));
10489 
10490   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10491   opcode(0xD8, 0x1, 0xD9); /* D8 /1 */  /* LoadF D9 /0 */
10492   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10493               set_instruction_start,
10494               OpcP, RMopc_Mem(secondary,src1),
10495               Pop_Mem_FPR(dst) );
10496   ins_pipe( fpu_mem_mem_mem );
10497 %}
10498 
10499 // Spill to obtain 24-bit precision
10500 instruct mulFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10501   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10502   match(Set dst (MulF src con));
10503 
10504   format %{ &quot;FLD    $src\n\t&quot;
10505             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10506             &quot;FSTP_S $dst&quot;  %}
10507   ins_encode %{
10508     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10509     __ fmul_s($constantaddress($con));
10510     __ fstp_s(Address(rsp, $dst$$disp));
10511   %}
10512   ins_pipe(fpu_mem_reg_con);
10513 %}
10514 //
10515 // This instruction does not round to 24-bits
10516 instruct mulFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10517   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10518   match(Set dst (MulF src con));
10519 
10520   format %{ &quot;FLD    $src\n\t&quot;
10521             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10522             &quot;FSTP   $dst&quot;  %}
10523   ins_encode %{
10524     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10525     __ fmul_s($constantaddress($con));
10526     __ fstp_d($dst$$reg);
10527   %}
10528   ins_pipe(fpu_reg_reg_con);
10529 %}
10530 
10531 
10532 //
10533 // MACRO1 -- subsume unshared load into mulFPR
10534 // This instruction does not round to 24-bits
10535 instruct mulFPR_reg_load1(regFPR dst, regFPR src, memory mem1 ) %{
10536   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10537   match(Set dst (MulF (LoadF mem1) src));
10538 
10539   format %{ &quot;FLD    $mem1    ===MACRO1===\n\t&quot;
10540             &quot;FMUL   ST,$src\n\t&quot;
10541             &quot;FSTP   $dst&quot; %}
10542   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or D8 /1 */  /* LoadF D9 /0 */
10543   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem1),
10544               OpcReg_FPR(src),
10545               Pop_Reg_FPR(dst) );
10546   ins_pipe( fpu_reg_reg_mem );
10547 %}
10548 //
10549 // MACRO2 -- addFPR a mulFPR which subsumed an unshared load
10550 // This instruction does not round to 24-bits
10551 instruct addFPR_mulFPR_reg_load1(regFPR dst, memory mem1, regFPR src1, regFPR src2) %{
10552   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10553   match(Set dst (AddF (MulF (LoadF mem1) src1) src2));
10554   ins_cost(95);
10555 
10556   format %{ &quot;FLD    $mem1     ===MACRO2===\n\t&quot;
10557             &quot;FMUL   ST,$src1  subsume mulFPR left load\n\t&quot;
10558             &quot;FADD   ST,$src2\n\t&quot;
10559             &quot;FSTP   $dst&quot; %}
10560   opcode(0xD9); /* LoadF D9 /0 */
10561   ins_encode( OpcP, RMopc_Mem(0x00,mem1),
10562               FMul_ST_reg(src1),
10563               FAdd_ST_reg(src2),
10564               Pop_Reg_FPR(dst) );
10565   ins_pipe( fpu_reg_mem_reg_reg );
10566 %}
10567 
10568 // MACRO3 -- addFPR a mulFPR
10569 // This instruction does not round to 24-bits.  It is a &#39;2-address&#39;
10570 // instruction in that the result goes back to src2.  This eliminates
10571 // a move from the macro; possibly the register allocator will have
10572 // to add it back (and maybe not).
10573 instruct addFPR_mulFPR_reg(regFPR src2, regFPR src1, regFPR src0) %{
10574   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10575   match(Set src2 (AddF (MulF src0 src1) src2));
10576 
10577   format %{ &quot;FLD    $src0     ===MACRO3===\n\t&quot;
10578             &quot;FMUL   ST,$src1\n\t&quot;
10579             &quot;FADDP  $src2,ST&quot; %}
10580   opcode(0xD9); /* LoadF D9 /0 */
10581   ins_encode( Push_Reg_FPR(src0),
10582               FMul_ST_reg(src1),
10583               FAddP_reg_ST(src2) );
10584   ins_pipe( fpu_reg_reg_reg );
10585 %}
10586 
10587 // MACRO4 -- divFPR subFPR
10588 // This instruction does not round to 24-bits
10589 instruct subFPR_divFPR_reg(regFPR dst, regFPR src1, regFPR src2, regFPR src3) %{
10590   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10591   match(Set dst (DivF (SubF src2 src1) src3));
10592 
10593   format %{ &quot;FLD    $src2   ===MACRO4===\n\t&quot;
10594             &quot;FSUB   ST,$src1\n\t&quot;
10595             &quot;FDIV   ST,$src3\n\t&quot;
10596             &quot;FSTP  $dst&quot; %}
10597   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10598   ins_encode( Push_Reg_FPR(src2),
10599               subFPR_divFPR_encode(src1,src3),
10600               Pop_Reg_FPR(dst) );
10601   ins_pipe( fpu_reg_reg_reg_reg );
10602 %}
10603 
10604 // Spill to obtain 24-bit precision
10605 instruct divFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10606   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10607   match(Set dst (DivF src1 src2));
10608 
10609   format %{ &quot;FDIV   $dst,$src1,$src2&quot; %}
10610   opcode(0xD8, 0x6); /* D8 F0+i or DE /6*/
10611   ins_encode( Push_Reg_FPR(src1),
10612               OpcReg_FPR(src2),
10613               Pop_Mem_FPR(dst) );
10614   ins_pipe( fpu_mem_reg_reg );
10615 %}
10616 //
10617 // This instruction does not round to 24-bits
10618 instruct divFPR_reg(regFPR dst, regFPR src) %{
10619   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10620   match(Set dst (DivF dst src));
10621 
10622   format %{ &quot;FDIV   $dst,$src&quot; %}
10623   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10624   ins_encode( Push_Reg_FPR(src),
10625               OpcP, RegOpc(dst) );
10626   ins_pipe( fpu_reg_reg );
10627 %}
10628 
10629 
10630 // Spill to obtain 24-bit precision
10631 instruct modFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10632   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10633   match(Set dst (ModF src1 src2));
10634   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10635 
10636   format %{ &quot;FMOD   $dst,$src1,$src2&quot; %}
10637   ins_encode( Push_Reg_Mod_DPR(src1, src2),
10638               emitModDPR(),
10639               Push_Result_Mod_DPR(src2),
10640               Pop_Mem_FPR(dst));
10641   ins_pipe( pipe_slow );
10642 %}
10643 //
10644 // This instruction does not round to 24-bits
10645 instruct modFPR_reg(regFPR dst, regFPR src, eAXRegI rax, eFlagsReg cr) %{
10646   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10647   match(Set dst (ModF dst src));
10648   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10649 
10650   format %{ &quot;FMOD   $dst,$src&quot; %}
10651   ins_encode(Push_Reg_Mod_DPR(dst, src),
10652               emitModDPR(),
10653               Push_Result_Mod_DPR(src),
10654               Pop_Reg_FPR(dst));
10655   ins_pipe( pipe_slow );
10656 %}
10657 
10658 instruct modF_reg(regF dst, regF src0, regF src1, eAXRegI rax, eFlagsReg cr) %{
10659   predicate(UseSSE&gt;=1);
10660   match(Set dst (ModF src0 src1));
10661   effect(KILL rax, KILL cr);
10662   format %{ &quot;SUB    ESP,4\t # FMOD\n&quot;
10663           &quot;\tMOVSS  [ESP+0],$src1\n&quot;
10664           &quot;\tFLD_S  [ESP+0]\n&quot;
10665           &quot;\tMOVSS  [ESP+0],$src0\n&quot;
10666           &quot;\tFLD_S  [ESP+0]\n&quot;
10667      &quot;loop:\tFPREM\n&quot;
10668           &quot;\tFWAIT\n&quot;
10669           &quot;\tFNSTSW AX\n&quot;
10670           &quot;\tSAHF\n&quot;
10671           &quot;\tJP     loop\n&quot;
10672           &quot;\tFSTP_S [ESP+0]\n&quot;
10673           &quot;\tMOVSS  $dst,[ESP+0]\n&quot;
10674           &quot;\tADD    ESP,4\n&quot;
10675           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10676     %}
10677   ins_cost(250);
10678   ins_encode( Push_ModF_encoding(src0, src1), emitModDPR(), Push_ResultF(dst,0x4), PopFPU);
10679   ins_pipe( pipe_slow );
10680 %}
10681 
10682 
10683 //----------Arithmetic Conversion Instructions---------------------------------
10684 // The conversions operations are all Alpha sorted.  Please keep it that way!
10685 
10686 instruct roundFloat_mem_reg(stackSlotF dst, regFPR src) %{
10687   predicate(UseSSE==0);
10688   match(Set dst (RoundFloat src));
10689   ins_cost(125);
10690   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10691   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
10692   ins_pipe( fpu_mem_reg );
10693 %}
10694 
10695 instruct roundDouble_mem_reg(stackSlotD dst, regDPR src) %{
10696   predicate(UseSSE&lt;=1);
10697   match(Set dst (RoundDouble src));
10698   ins_cost(125);
10699   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10700   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
10701   ins_pipe( fpu_mem_reg );
10702 %}
10703 
10704 // Force rounding to 24-bit precision and 6-bit exponent
10705 instruct convDPR2FPR_reg(stackSlotF dst, regDPR src) %{
10706   predicate(UseSSE==0);
10707   match(Set dst (ConvD2F src));
10708   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10709   expand %{
10710     roundFloat_mem_reg(dst,src);
10711   %}
10712 %}
10713 
10714 // Force rounding to 24-bit precision and 6-bit exponent
10715 instruct convDPR2F_reg(regF dst, regDPR src, eFlagsReg cr) %{
10716   predicate(UseSSE==1);
10717   match(Set dst (ConvD2F src));
10718   effect( KILL cr );
10719   format %{ &quot;SUB    ESP,4\n\t&quot;
10720             &quot;FST_S  [ESP],$src\t# F-round\n\t&quot;
10721             &quot;MOVSS  $dst,[ESP]\n\t&quot;
10722             &quot;ADD ESP,4&quot; %}
10723   ins_encode %{
10724     __ subptr(rsp, 4);
10725     if ($src$$reg != FPR1L_enc) {
10726       __ fld_s($src$$reg-1);
10727       __ fstp_s(Address(rsp, 0));
10728     } else {
10729       __ fst_s(Address(rsp, 0));
10730     }
10731     __ movflt($dst$$XMMRegister, Address(rsp, 0));
10732     __ addptr(rsp, 4);
10733   %}
10734   ins_pipe( pipe_slow );
10735 %}
10736 
10737 // Force rounding double precision to single precision
10738 instruct convD2F_reg(regF dst, regD src) %{
10739   predicate(UseSSE&gt;=2);
10740   match(Set dst (ConvD2F src));
10741   format %{ &quot;CVTSD2SS $dst,$src\t# F-round&quot; %}
10742   ins_encode %{
10743     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10744   %}
10745   ins_pipe( pipe_slow );
10746 %}
10747 
10748 instruct convFPR2DPR_reg_reg(regDPR dst, regFPR src) %{
10749   predicate(UseSSE==0);
10750   match(Set dst (ConvF2D src));
10751   format %{ &quot;FST_S  $dst,$src\t# D-round&quot; %}
10752   ins_encode( Pop_Reg_Reg_DPR(dst, src));
10753   ins_pipe( fpu_reg_reg );
10754 %}
10755 
10756 instruct convFPR2D_reg(stackSlotD dst, regFPR src) %{
10757   predicate(UseSSE==1);
10758   match(Set dst (ConvF2D src));
10759   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10760   expand %{
10761     roundDouble_mem_reg(dst,src);
10762   %}
10763 %}
10764 
10765 instruct convF2DPR_reg(regDPR dst, regF src, eFlagsReg cr) %{
10766   predicate(UseSSE==1);
10767   match(Set dst (ConvF2D src));
10768   effect( KILL cr );
10769   format %{ &quot;SUB    ESP,4\n\t&quot;
10770             &quot;MOVSS  [ESP] $src\n\t&quot;
10771             &quot;FLD_S  [ESP]\n\t&quot;
10772             &quot;ADD    ESP,4\n\t&quot;
10773             &quot;FSTP   $dst\t# D-round&quot; %}
10774   ins_encode %{
10775     __ subptr(rsp, 4);
10776     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10777     __ fld_s(Address(rsp, 0));
10778     __ addptr(rsp, 4);
10779     __ fstp_d($dst$$reg);
10780   %}
10781   ins_pipe( pipe_slow );
10782 %}
10783 
10784 instruct convF2D_reg(regD dst, regF src) %{
10785   predicate(UseSSE&gt;=2);
10786   match(Set dst (ConvF2D src));
10787   format %{ &quot;CVTSS2SD $dst,$src\t# D-round&quot; %}
10788   ins_encode %{
10789     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10790   %}
10791   ins_pipe( pipe_slow );
10792 %}
10793 
10794 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10795 instruct convDPR2I_reg_reg( eAXRegI dst, eDXRegI tmp, regDPR src, eFlagsReg cr ) %{
10796   predicate(UseSSE&lt;=1);
10797   match(Set dst (ConvD2I src));
10798   effect( KILL tmp, KILL cr );
10799   format %{ &quot;FLD    $src\t# Convert double to int \n\t&quot;
10800             &quot;FLDCW  trunc mode\n\t&quot;
10801             &quot;SUB    ESP,4\n\t&quot;
10802             &quot;FISTp  [ESP + #0]\n\t&quot;
10803             &quot;FLDCW  std/24-bit mode\n\t&quot;
10804             &quot;POP    EAX\n\t&quot;
10805             &quot;CMP    EAX,0x80000000\n\t&quot;
10806             &quot;JNE,s  fast\n\t&quot;
10807             &quot;FLD_D  $src\n\t&quot;
10808             &quot;CALL   d2i_wrapper\n&quot;
10809       &quot;fast:&quot; %}
10810   ins_encode( Push_Reg_DPR(src), DPR2I_encoding(src) );
10811   ins_pipe( pipe_slow );
10812 %}
10813 
10814 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10815 instruct convD2I_reg_reg( eAXRegI dst, eDXRegI tmp, regD src, eFlagsReg cr ) %{
10816   predicate(UseSSE&gt;=2);
10817   match(Set dst (ConvD2I src));
10818   effect( KILL tmp, KILL cr );
10819   format %{ &quot;CVTTSD2SI $dst, $src\n\t&quot;
10820             &quot;CMP    $dst,0x80000000\n\t&quot;
10821             &quot;JNE,s  fast\n\t&quot;
10822             &quot;SUB    ESP, 8\n\t&quot;
10823             &quot;MOVSD  [ESP], $src\n\t&quot;
10824             &quot;FLD_D  [ESP]\n\t&quot;
10825             &quot;ADD    ESP, 8\n\t&quot;
10826             &quot;CALL   d2i_wrapper\n&quot;
10827       &quot;fast:&quot; %}
10828   ins_encode %{
10829     Label fast;
10830     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10831     __ cmpl($dst$$Register, 0x80000000);
10832     __ jccb(Assembler::notEqual, fast);
10833     __ subptr(rsp, 8);
10834     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10835     __ fld_d(Address(rsp, 0));
10836     __ addptr(rsp, 8);
10837     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10838     __ bind(fast);
10839   %}
10840   ins_pipe( pipe_slow );
10841 %}
10842 
10843 instruct convDPR2L_reg_reg( eADXRegL dst, regDPR src, eFlagsReg cr ) %{
10844   predicate(UseSSE&lt;=1);
10845   match(Set dst (ConvD2L src));
10846   effect( KILL cr );
10847   format %{ &quot;FLD    $src\t# Convert double to long\n\t&quot;
10848             &quot;FLDCW  trunc mode\n\t&quot;
10849             &quot;SUB    ESP,8\n\t&quot;
10850             &quot;FISTp  [ESP + #0]\n\t&quot;
10851             &quot;FLDCW  std/24-bit mode\n\t&quot;
10852             &quot;POP    EAX\n\t&quot;
10853             &quot;POP    EDX\n\t&quot;
10854             &quot;CMP    EDX,0x80000000\n\t&quot;
10855             &quot;JNE,s  fast\n\t&quot;
10856             &quot;TEST   EAX,EAX\n\t&quot;
10857             &quot;JNE,s  fast\n\t&quot;
10858             &quot;FLD    $src\n\t&quot;
10859             &quot;CALL   d2l_wrapper\n&quot;
10860       &quot;fast:&quot; %}
10861   ins_encode( Push_Reg_DPR(src),  DPR2L_encoding(src) );
10862   ins_pipe( pipe_slow );
10863 %}
10864 
10865 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
10866 instruct convD2L_reg_reg( eADXRegL dst, regD src, eFlagsReg cr ) %{
10867   predicate (UseSSE&gt;=2);
10868   match(Set dst (ConvD2L src));
10869   effect( KILL cr );
10870   format %{ &quot;SUB    ESP,8\t# Convert double to long\n\t&quot;
10871             &quot;MOVSD  [ESP],$src\n\t&quot;
10872             &quot;FLD_D  [ESP]\n\t&quot;
10873             &quot;FLDCW  trunc mode\n\t&quot;
10874             &quot;FISTp  [ESP + #0]\n\t&quot;
10875             &quot;FLDCW  std/24-bit mode\n\t&quot;
10876             &quot;POP    EAX\n\t&quot;
10877             &quot;POP    EDX\n\t&quot;
10878             &quot;CMP    EDX,0x80000000\n\t&quot;
10879             &quot;JNE,s  fast\n\t&quot;
10880             &quot;TEST   EAX,EAX\n\t&quot;
10881             &quot;JNE,s  fast\n\t&quot;
10882             &quot;SUB    ESP,8\n\t&quot;
10883             &quot;MOVSD  [ESP],$src\n\t&quot;
10884             &quot;FLD_D  [ESP]\n\t&quot;
10885             &quot;ADD    ESP,8\n\t&quot;
10886             &quot;CALL   d2l_wrapper\n&quot;
10887       &quot;fast:&quot; %}
10888   ins_encode %{
10889     Label fast;
10890     __ subptr(rsp, 8);
10891     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10892     __ fld_d(Address(rsp, 0));
10893     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
10894     __ fistp_d(Address(rsp, 0));
10895     // Restore the rounding mode, mask the exception
10896     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
10897       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
10898     } else {
10899       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
10900     }
10901     // Load the converted long, adjust CPU stack
10902     __ pop(rax);
10903     __ pop(rdx);
10904     __ cmpl(rdx, 0x80000000);
10905     __ jccb(Assembler::notEqual, fast);
10906     __ testl(rax, rax);
10907     __ jccb(Assembler::notEqual, fast);
10908     __ subptr(rsp, 8);
10909     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10910     __ fld_d(Address(rsp, 0));
10911     __ addptr(rsp, 8);
10912     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
10913     __ bind(fast);
10914   %}
10915   ins_pipe( pipe_slow );
10916 %}
10917 
10918 // Convert a double to an int.  Java semantics require we do complex
10919 // manglations in the corner cases.  So we set the rounding mode to
10920 // &#39;zero&#39;, store the darned double down as an int, and reset the
10921 // rounding mode to &#39;nearest&#39;.  The hardware stores a flag value down
10922 // if we would overflow or converted a NAN; we check for this and
10923 // and go the slow path if needed.
10924 instruct convFPR2I_reg_reg(eAXRegI dst, eDXRegI tmp, regFPR src, eFlagsReg cr ) %{
10925   predicate(UseSSE==0);
10926   match(Set dst (ConvF2I src));
10927   effect( KILL tmp, KILL cr );
10928   format %{ &quot;FLD    $src\t# Convert float to int \n\t&quot;
10929             &quot;FLDCW  trunc mode\n\t&quot;
10930             &quot;SUB    ESP,4\n\t&quot;
10931             &quot;FISTp  [ESP + #0]\n\t&quot;
10932             &quot;FLDCW  std/24-bit mode\n\t&quot;
10933             &quot;POP    EAX\n\t&quot;
10934             &quot;CMP    EAX,0x80000000\n\t&quot;
10935             &quot;JNE,s  fast\n\t&quot;
10936             &quot;FLD    $src\n\t&quot;
10937             &quot;CALL   d2i_wrapper\n&quot;
10938       &quot;fast:&quot; %}
10939   // DPR2I_encoding works for FPR2I
10940   ins_encode( Push_Reg_FPR(src), DPR2I_encoding(src) );
10941   ins_pipe( pipe_slow );
10942 %}
10943 
10944 // Convert a float in xmm to an int reg.
10945 instruct convF2I_reg(eAXRegI dst, eDXRegI tmp, regF src, eFlagsReg cr ) %{
10946   predicate(UseSSE&gt;=1);
10947   match(Set dst (ConvF2I src));
10948   effect( KILL tmp, KILL cr );
10949   format %{ &quot;CVTTSS2SI $dst, $src\n\t&quot;
10950             &quot;CMP    $dst,0x80000000\n\t&quot;
10951             &quot;JNE,s  fast\n\t&quot;
10952             &quot;SUB    ESP, 4\n\t&quot;
10953             &quot;MOVSS  [ESP], $src\n\t&quot;
10954             &quot;FLD    [ESP]\n\t&quot;
10955             &quot;ADD    ESP, 4\n\t&quot;
10956             &quot;CALL   d2i_wrapper\n&quot;
10957       &quot;fast:&quot; %}
10958   ins_encode %{
10959     Label fast;
10960     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
10961     __ cmpl($dst$$Register, 0x80000000);
10962     __ jccb(Assembler::notEqual, fast);
10963     __ subptr(rsp, 4);
10964     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10965     __ fld_s(Address(rsp, 0));
10966     __ addptr(rsp, 4);
10967     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10968     __ bind(fast);
10969   %}
10970   ins_pipe( pipe_slow );
10971 %}
10972 
10973 instruct convFPR2L_reg_reg( eADXRegL dst, regFPR src, eFlagsReg cr ) %{
10974   predicate(UseSSE==0);
10975   match(Set dst (ConvF2L src));
10976   effect( KILL cr );
10977   format %{ &quot;FLD    $src\t# Convert float to long\n\t&quot;
10978             &quot;FLDCW  trunc mode\n\t&quot;
10979             &quot;SUB    ESP,8\n\t&quot;
10980             &quot;FISTp  [ESP + #0]\n\t&quot;
10981             &quot;FLDCW  std/24-bit mode\n\t&quot;
10982             &quot;POP    EAX\n\t&quot;
10983             &quot;POP    EDX\n\t&quot;
10984             &quot;CMP    EDX,0x80000000\n\t&quot;
10985             &quot;JNE,s  fast\n\t&quot;
10986             &quot;TEST   EAX,EAX\n\t&quot;
10987             &quot;JNE,s  fast\n\t&quot;
10988             &quot;FLD    $src\n\t&quot;
10989             &quot;CALL   d2l_wrapper\n&quot;
10990       &quot;fast:&quot; %}
10991   // DPR2L_encoding works for FPR2L
10992   ins_encode( Push_Reg_FPR(src), DPR2L_encoding(src) );
10993   ins_pipe( pipe_slow );
10994 %}
10995 
10996 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
10997 instruct convF2L_reg_reg( eADXRegL dst, regF src, eFlagsReg cr ) %{
10998   predicate (UseSSE&gt;=1);
10999   match(Set dst (ConvF2L src));
11000   effect( KILL cr );
11001   format %{ &quot;SUB    ESP,8\t# Convert float to long\n\t&quot;
11002             &quot;MOVSS  [ESP],$src\n\t&quot;
11003             &quot;FLD_S  [ESP]\n\t&quot;
11004             &quot;FLDCW  trunc mode\n\t&quot;
11005             &quot;FISTp  [ESP + #0]\n\t&quot;
11006             &quot;FLDCW  std/24-bit mode\n\t&quot;
11007             &quot;POP    EAX\n\t&quot;
11008             &quot;POP    EDX\n\t&quot;
11009             &quot;CMP    EDX,0x80000000\n\t&quot;
11010             &quot;JNE,s  fast\n\t&quot;
11011             &quot;TEST   EAX,EAX\n\t&quot;
11012             &quot;JNE,s  fast\n\t&quot;
11013             &quot;SUB    ESP,4\t# Convert float to long\n\t&quot;
11014             &quot;MOVSS  [ESP],$src\n\t&quot;
11015             &quot;FLD_S  [ESP]\n\t&quot;
11016             &quot;ADD    ESP,4\n\t&quot;
11017             &quot;CALL   d2l_wrapper\n&quot;
11018       &quot;fast:&quot; %}
11019   ins_encode %{
11020     Label fast;
11021     __ subptr(rsp, 8);
11022     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11023     __ fld_s(Address(rsp, 0));
11024     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
11025     __ fistp_d(Address(rsp, 0));
11026     // Restore the rounding mode, mask the exception
11027     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
11028       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
11029     } else {
11030       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
11031     }
11032     // Load the converted long, adjust CPU stack
11033     __ pop(rax);
11034     __ pop(rdx);
11035     __ cmpl(rdx, 0x80000000);
11036     __ jccb(Assembler::notEqual, fast);
11037     __ testl(rax, rax);
11038     __ jccb(Assembler::notEqual, fast);
11039     __ subptr(rsp, 4);
11040     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11041     __ fld_s(Address(rsp, 0));
11042     __ addptr(rsp, 4);
11043     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
11044     __ bind(fast);
11045   %}
11046   ins_pipe( pipe_slow );
11047 %}
11048 
11049 instruct convI2DPR_reg(regDPR dst, stackSlotI src) %{
11050   predicate( UseSSE&lt;=1 );
11051   match(Set dst (ConvI2D src));
11052   format %{ &quot;FILD   $src\n\t&quot;
11053             &quot;FSTP   $dst&quot; %}
11054   opcode(0xDB, 0x0);  /* DB /0 */
11055   ins_encode(Push_Mem_I(src), Pop_Reg_DPR(dst));
11056   ins_pipe( fpu_reg_mem );
11057 %}
11058 
11059 instruct convI2D_reg(regD dst, rRegI src) %{
11060   predicate( UseSSE&gt;=2 &amp;&amp; !UseXmmI2D );
11061   match(Set dst (ConvI2D src));
11062   format %{ &quot;CVTSI2SD $dst,$src&quot; %}
11063   ins_encode %{
11064     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
11065   %}
11066   ins_pipe( pipe_slow );
11067 %}
11068 
11069 instruct convI2D_mem(regD dst, memory mem) %{
11070   predicate( UseSSE&gt;=2 );
11071   match(Set dst (ConvI2D (LoadI mem)));
11072   format %{ &quot;CVTSI2SD $dst,$mem&quot; %}
11073   ins_encode %{
11074     __ cvtsi2sdl ($dst$$XMMRegister, $mem$$Address);
11075   %}
11076   ins_pipe( pipe_slow );
11077 %}
11078 
11079 instruct convXI2D_reg(regD dst, rRegI src)
11080 %{
11081   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2D );
11082   match(Set dst (ConvI2D src));
11083 
11084   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11085             &quot;CVTDQ2PD $dst,$dst\t# i2d&quot; %}
11086   ins_encode %{
11087     __ movdl($dst$$XMMRegister, $src$$Register);
11088     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
11089   %}
11090   ins_pipe(pipe_slow); // XXX
11091 %}
11092 
11093 instruct convI2DPR_mem(regDPR dst, memory mem) %{
11094   predicate( UseSSE&lt;=1 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11095   match(Set dst (ConvI2D (LoadI mem)));
11096   format %{ &quot;FILD   $mem\n\t&quot;
11097             &quot;FSTP   $dst&quot; %}
11098   opcode(0xDB);      /* DB /0 */
11099   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11100               Pop_Reg_DPR(dst));
11101   ins_pipe( fpu_reg_mem );
11102 %}
11103 
11104 // Convert a byte to a float; no rounding step needed.
11105 instruct conv24I2FPR_reg(regFPR dst, stackSlotI src) %{
11106   predicate( UseSSE==0 &amp;&amp; n-&gt;in(1)-&gt;Opcode() == Op_AndI &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;get_int() == 255 );
11107   match(Set dst (ConvI2F src));
11108   format %{ &quot;FILD   $src\n\t&quot;
11109             &quot;FSTP   $dst&quot; %}
11110 
11111   opcode(0xDB, 0x0);  /* DB /0 */
11112   ins_encode(Push_Mem_I(src), Pop_Reg_FPR(dst));
11113   ins_pipe( fpu_reg_mem );
11114 %}
11115 
11116 // In 24-bit mode, force exponent rounding by storing back out
11117 instruct convI2FPR_SSF(stackSlotF dst, stackSlotI src) %{
11118   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11119   match(Set dst (ConvI2F src));
11120   ins_cost(200);
11121   format %{ &quot;FILD   $src\n\t&quot;
11122             &quot;FSTP_S $dst&quot; %}
11123   opcode(0xDB, 0x0);  /* DB /0 */
11124   ins_encode( Push_Mem_I(src),
11125               Pop_Mem_FPR(dst));
11126   ins_pipe( fpu_mem_mem );
11127 %}
11128 
11129 // In 24-bit mode, force exponent rounding by storing back out
11130 instruct convI2FPR_SSF_mem(stackSlotF dst, memory mem) %{
11131   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11132   match(Set dst (ConvI2F (LoadI mem)));
11133   ins_cost(200);
11134   format %{ &quot;FILD   $mem\n\t&quot;
11135             &quot;FSTP_S $dst&quot; %}
11136   opcode(0xDB);  /* DB /0 */
11137   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11138               Pop_Mem_FPR(dst));
11139   ins_pipe( fpu_mem_mem );
11140 %}
11141 
11142 // This instruction does not round to 24-bits
11143 instruct convI2FPR_reg(regFPR dst, stackSlotI src) %{
11144   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11145   match(Set dst (ConvI2F src));
11146   format %{ &quot;FILD   $src\n\t&quot;
11147             &quot;FSTP   $dst&quot; %}
11148   opcode(0xDB, 0x0);  /* DB /0 */
11149   ins_encode( Push_Mem_I(src),
11150               Pop_Reg_FPR(dst));
11151   ins_pipe( fpu_reg_mem );
11152 %}
11153 
11154 // This instruction does not round to 24-bits
11155 instruct convI2FPR_mem(regFPR dst, memory mem) %{
11156   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11157   match(Set dst (ConvI2F (LoadI mem)));
11158   format %{ &quot;FILD   $mem\n\t&quot;
11159             &quot;FSTP   $dst&quot; %}
11160   opcode(0xDB);      /* DB /0 */
11161   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11162               Pop_Reg_FPR(dst));
11163   ins_pipe( fpu_reg_mem );
11164 %}
11165 
11166 // Convert an int to a float in xmm; no rounding step needed.
11167 instruct convI2F_reg(regF dst, rRegI src) %{
11168   predicate( UseSSE==1 || UseSSE&gt;=2 &amp;&amp; !UseXmmI2F );
11169   match(Set dst (ConvI2F src));
11170   format %{ &quot;CVTSI2SS $dst, $src&quot; %}
11171   ins_encode %{
11172     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
11173   %}
11174   ins_pipe( pipe_slow );
11175 %}
11176 
11177  instruct convXI2F_reg(regF dst, rRegI src)
11178 %{
11179   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2F );
11180   match(Set dst (ConvI2F src));
11181 
11182   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11183             &quot;CVTDQ2PS $dst,$dst\t# i2f&quot; %}
11184   ins_encode %{
11185     __ movdl($dst$$XMMRegister, $src$$Register);
11186     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
11187   %}
11188   ins_pipe(pipe_slow); // XXX
11189 %}
11190 
11191 instruct convI2L_reg( eRegL dst, rRegI src, eFlagsReg cr) %{
11192   match(Set dst (ConvI2L src));
11193   effect(KILL cr);
11194   ins_cost(375);
11195   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11196             &quot;MOV    $dst.hi,$src\n\t&quot;
11197             &quot;SAR    $dst.hi,31&quot; %}
11198   ins_encode(convert_int_long(dst,src));
11199   ins_pipe( ialu_reg_reg_long );
11200 %}
11201 
11202 // Zero-extend convert int to long
11203 instruct convI2L_reg_zex(eRegL dst, rRegI src, immL_32bits mask, eFlagsReg flags ) %{
11204   match(Set dst (AndL (ConvI2L src) mask) );
11205   effect( KILL flags );
11206   ins_cost(250);
11207   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11208             &quot;XOR    $dst.hi,$dst.hi&quot; %}
11209   opcode(0x33); // XOR
11210   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11211   ins_pipe( ialu_reg_reg_long );
11212 %}
11213 
11214 // Zero-extend long
11215 instruct zerox_long(eRegL dst, eRegL src, immL_32bits mask, eFlagsReg flags ) %{
11216   match(Set dst (AndL src mask) );
11217   effect( KILL flags );
11218   ins_cost(250);
11219   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
11220             &quot;XOR    $dst.hi,$dst.hi\n\t&quot; %}
11221   opcode(0x33); // XOR
11222   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11223   ins_pipe( ialu_reg_reg_long );
11224 %}
11225 
11226 instruct convL2DPR_reg( stackSlotD dst, eRegL src, eFlagsReg cr) %{
11227   predicate (UseSSE&lt;=1);
11228   match(Set dst (ConvL2D src));
11229   effect( KILL cr );
11230   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11231             &quot;PUSH   $src.lo\n\t&quot;
11232             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11233             &quot;ADD    ESP,8\n\t&quot;
11234             &quot;FSTP_D $dst\t# D-round&quot; %}
11235   opcode(0xDF, 0x5);  /* DF /5 */
11236   ins_encode(convert_long_double(src), Pop_Mem_DPR(dst));
11237   ins_pipe( pipe_slow );
11238 %}
11239 
11240 instruct convL2D_reg( regD dst, eRegL src, eFlagsReg cr) %{
11241   predicate (UseSSE&gt;=2);
11242   match(Set dst (ConvL2D src));
11243   effect( KILL cr );
11244   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11245             &quot;PUSH   $src.lo\n\t&quot;
11246             &quot;FILD_D [ESP]\n\t&quot;
11247             &quot;FSTP_D [ESP]\n\t&quot;
11248             &quot;MOVSD  $dst,[ESP]\n\t&quot;
11249             &quot;ADD    ESP,8&quot; %}
11250   opcode(0xDF, 0x5);  /* DF /5 */
11251   ins_encode(convert_long_double2(src), Push_ResultD(dst));
11252   ins_pipe( pipe_slow );
11253 %}
11254 
11255 instruct convL2F_reg( regF dst, eRegL src, eFlagsReg cr) %{
11256   predicate (UseSSE&gt;=1);
11257   match(Set dst (ConvL2F src));
11258   effect( KILL cr );
11259   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11260             &quot;PUSH   $src.lo\n\t&quot;
11261             &quot;FILD_D [ESP]\n\t&quot;
11262             &quot;FSTP_S [ESP]\n\t&quot;
11263             &quot;MOVSS  $dst,[ESP]\n\t&quot;
11264             &quot;ADD    ESP,8&quot; %}
11265   opcode(0xDF, 0x5);  /* DF /5 */
11266   ins_encode(convert_long_double2(src), Push_ResultF(dst,0x8));
11267   ins_pipe( pipe_slow );
11268 %}
11269 
11270 instruct convL2FPR_reg( stackSlotF dst, eRegL src, eFlagsReg cr) %{
11271   match(Set dst (ConvL2F src));
11272   effect( KILL cr );
11273   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11274             &quot;PUSH   $src.lo\n\t&quot;
11275             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11276             &quot;ADD    ESP,8\n\t&quot;
11277             &quot;FSTP_S $dst\t# F-round&quot; %}
11278   opcode(0xDF, 0x5);  /* DF /5 */
11279   ins_encode(convert_long_double(src), Pop_Mem_FPR(dst));
11280   ins_pipe( pipe_slow );
11281 %}
11282 
11283 instruct convL2I_reg( rRegI dst, eRegL src ) %{
11284   match(Set dst (ConvL2I src));
11285   effect( DEF dst, USE src );
11286   format %{ &quot;MOV    $dst,$src.lo&quot; %}
11287   ins_encode(enc_CopyL_Lo(dst,src));
11288   ins_pipe( ialu_reg_reg );
11289 %}
11290 
11291 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
11292   match(Set dst (MoveF2I src));
11293   effect( DEF dst, USE src );
11294   ins_cost(100);
11295   format %{ &quot;MOV    $dst,$src\t# MoveF2I_stack_reg&quot; %}
11296   ins_encode %{
11297     __ movl($dst$$Register, Address(rsp, $src$$disp));
11298   %}
11299   ins_pipe( ialu_reg_mem );
11300 %}
11301 
11302 instruct MoveFPR2I_reg_stack(stackSlotI dst, regFPR src) %{
11303   predicate(UseSSE==0);
11304   match(Set dst (MoveF2I src));
11305   effect( DEF dst, USE src );
11306 
11307   ins_cost(125);
11308   format %{ &quot;FST_S  $dst,$src\t# MoveF2I_reg_stack&quot; %}
11309   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
11310   ins_pipe( fpu_mem_reg );
11311 %}
11312 
11313 instruct MoveF2I_reg_stack_sse(stackSlotI dst, regF src) %{
11314   predicate(UseSSE&gt;=1);
11315   match(Set dst (MoveF2I src));
11316   effect( DEF dst, USE src );
11317 
11318   ins_cost(95);
11319   format %{ &quot;MOVSS  $dst,$src\t# MoveF2I_reg_stack_sse&quot; %}
11320   ins_encode %{
11321     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
11322   %}
11323   ins_pipe( pipe_slow );
11324 %}
11325 
11326 instruct MoveF2I_reg_reg_sse(rRegI dst, regF src) %{
11327   predicate(UseSSE&gt;=2);
11328   match(Set dst (MoveF2I src));
11329   effect( DEF dst, USE src );
11330   ins_cost(85);
11331   format %{ &quot;MOVD   $dst,$src\t# MoveF2I_reg_reg_sse&quot; %}
11332   ins_encode %{
11333     __ movdl($dst$$Register, $src$$XMMRegister);
11334   %}
11335   ins_pipe( pipe_slow );
11336 %}
11337 
11338 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
11339   match(Set dst (MoveI2F src));
11340   effect( DEF dst, USE src );
11341 
11342   ins_cost(100);
11343   format %{ &quot;MOV    $dst,$src\t# MoveI2F_reg_stack&quot; %}
11344   ins_encode %{
11345     __ movl(Address(rsp, $dst$$disp), $src$$Register);
11346   %}
11347   ins_pipe( ialu_mem_reg );
11348 %}
11349 
11350 
11351 instruct MoveI2FPR_stack_reg(regFPR dst, stackSlotI src) %{
11352   predicate(UseSSE==0);
11353   match(Set dst (MoveI2F src));
11354   effect(DEF dst, USE src);
11355 
11356   ins_cost(125);
11357   format %{ &quot;FLD_S  $src\n\t&quot;
11358             &quot;FSTP   $dst\t# MoveI2F_stack_reg&quot; %}
11359   opcode(0xD9);               /* D9 /0, FLD m32real */
11360   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11361               Pop_Reg_FPR(dst) );
11362   ins_pipe( fpu_reg_mem );
11363 %}
11364 
11365 instruct MoveI2F_stack_reg_sse(regF dst, stackSlotI src) %{
11366   predicate(UseSSE&gt;=1);
11367   match(Set dst (MoveI2F src));
11368   effect( DEF dst, USE src );
11369 
11370   ins_cost(95);
11371   format %{ &quot;MOVSS  $dst,$src\t# MoveI2F_stack_reg_sse&quot; %}
11372   ins_encode %{
11373     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
11374   %}
11375   ins_pipe( pipe_slow );
11376 %}
11377 
11378 instruct MoveI2F_reg_reg_sse(regF dst, rRegI src) %{
11379   predicate(UseSSE&gt;=2);
11380   match(Set dst (MoveI2F src));
11381   effect( DEF dst, USE src );
11382 
11383   ins_cost(85);
11384   format %{ &quot;MOVD   $dst,$src\t# MoveI2F_reg_reg_sse&quot; %}
11385   ins_encode %{
11386     __ movdl($dst$$XMMRegister, $src$$Register);
11387   %}
11388   ins_pipe( pipe_slow );
11389 %}
11390 
11391 instruct MoveD2L_stack_reg(eRegL dst, stackSlotD src) %{
11392   match(Set dst (MoveD2L src));
11393   effect(DEF dst, USE src);
11394 
11395   ins_cost(250);
11396   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11397             &quot;MOV    $dst.hi,$src+4\t# MoveD2L_stack_reg&quot; %}
11398   opcode(0x8B, 0x8B);
11399   ins_encode( OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src));
11400   ins_pipe( ialu_mem_long_reg );
11401 %}
11402 
11403 instruct MoveDPR2L_reg_stack(stackSlotL dst, regDPR src) %{
11404   predicate(UseSSE&lt;=1);
11405   match(Set dst (MoveD2L src));
11406   effect(DEF dst, USE src);
11407 
11408   ins_cost(125);
11409   format %{ &quot;FST_D  $dst,$src\t# MoveD2L_reg_stack&quot; %}
11410   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
11411   ins_pipe( fpu_mem_reg );
11412 %}
11413 
11414 instruct MoveD2L_reg_stack_sse(stackSlotL dst, regD src) %{
11415   predicate(UseSSE&gt;=2);
11416   match(Set dst (MoveD2L src));
11417   effect(DEF dst, USE src);
11418   ins_cost(95);
11419   format %{ &quot;MOVSD  $dst,$src\t# MoveD2L_reg_stack_sse&quot; %}
11420   ins_encode %{
11421     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
11422   %}
11423   ins_pipe( pipe_slow );
11424 %}
11425 
11426 instruct MoveD2L_reg_reg_sse(eRegL dst, regD src, regD tmp) %{
11427   predicate(UseSSE&gt;=2);
11428   match(Set dst (MoveD2L src));
11429   effect(DEF dst, USE src, TEMP tmp);
11430   ins_cost(85);
11431   format %{ &quot;MOVD   $dst.lo,$src\n\t&quot;
11432             &quot;PSHUFLW $tmp,$src,0x4E\n\t&quot;
11433             &quot;MOVD   $dst.hi,$tmp\t# MoveD2L_reg_reg_sse&quot; %}
11434   ins_encode %{
11435     __ movdl($dst$$Register, $src$$XMMRegister);
11436     __ pshuflw($tmp$$XMMRegister, $src$$XMMRegister, 0x4e);
11437     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
11438   %}
11439   ins_pipe( pipe_slow );
11440 %}
11441 
11442 instruct MoveL2D_reg_stack(stackSlotD dst, eRegL src) %{
11443   match(Set dst (MoveL2D src));
11444   effect(DEF dst, USE src);
11445 
11446   ins_cost(200);
11447   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
11448             &quot;MOV    $dst+4,$src.hi\t# MoveL2D_reg_stack&quot; %}
11449   opcode(0x89, 0x89);
11450   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
11451   ins_pipe( ialu_mem_long_reg );
11452 %}
11453 
11454 
11455 instruct MoveL2DPR_stack_reg(regDPR dst, stackSlotL src) %{
11456   predicate(UseSSE&lt;=1);
11457   match(Set dst (MoveL2D src));
11458   effect(DEF dst, USE src);
11459   ins_cost(125);
11460 
11461   format %{ &quot;FLD_D  $src\n\t&quot;
11462             &quot;FSTP   $dst\t# MoveL2D_stack_reg&quot; %}
11463   opcode(0xDD);               /* DD /0, FLD m64real */
11464   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11465               Pop_Reg_DPR(dst) );
11466   ins_pipe( fpu_reg_mem );
11467 %}
11468 
11469 
11470 instruct MoveL2D_stack_reg_sse(regD dst, stackSlotL src) %{
11471   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
11472   match(Set dst (MoveL2D src));
11473   effect(DEF dst, USE src);
11474 
11475   ins_cost(95);
11476   format %{ &quot;MOVSD  $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11477   ins_encode %{
11478     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11479   %}
11480   ins_pipe( pipe_slow );
11481 %}
11482 
11483 instruct MoveL2D_stack_reg_sse_partial(regD dst, stackSlotL src) %{
11484   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
11485   match(Set dst (MoveL2D src));
11486   effect(DEF dst, USE src);
11487 
11488   ins_cost(95);
11489   format %{ &quot;MOVLPD $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11490   ins_encode %{
11491     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11492   %}
11493   ins_pipe( pipe_slow );
11494 %}
11495 
11496 instruct MoveL2D_reg_reg_sse(regD dst, eRegL src, regD tmp) %{
11497   predicate(UseSSE&gt;=2);
11498   match(Set dst (MoveL2D src));
11499   effect(TEMP dst, USE src, TEMP tmp);
11500   ins_cost(85);
11501   format %{ &quot;MOVD   $dst,$src.lo\n\t&quot;
11502             &quot;MOVD   $tmp,$src.hi\n\t&quot;
11503             &quot;PUNPCKLDQ $dst,$tmp\t# MoveL2D_reg_reg_sse&quot; %}
11504   ins_encode %{
11505     __ movdl($dst$$XMMRegister, $src$$Register);
11506     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));
11507     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);
11508   %}
11509   ins_pipe( pipe_slow );
11510 %}
11511 
11512 
11513 // =======================================================================
11514 // fast clearing of an array
11515 instruct rep_stos(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11516   predicate(!((ClearArrayNode*)n)-&gt;is_large());
11517   match(Set dummy (ClearArray cnt base));
11518   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11519 
11520   format %{ $$template
11521     $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11522     $$emit$$&quot;CMP    InitArrayShortSize,rcx\n\t&quot;
11523     $$emit$$&quot;JG     LARGE\n\t&quot;
11524     $$emit$$&quot;SHL    ECX, 1\n\t&quot;
11525     $$emit$$&quot;DEC    ECX\n\t&quot;
11526     $$emit$$&quot;JS     DONE\t# Zero length\n\t&quot;
11527     $$emit$$&quot;MOV    EAX,(EDI,ECX,4)\t# LOOP\n\t&quot;
11528     $$emit$$&quot;DEC    ECX\n\t&quot;
11529     $$emit$$&quot;JGE    LOOP\n\t&quot;
11530     $$emit$$&quot;JMP    DONE\n\t&quot;
11531     $$emit$$&quot;# LARGE:\n\t&quot;
11532     if (UseFastStosb) {
11533        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11534        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11535     } else if (UseXMMForObjInit) {
11536        $$emit$$&quot;MOV     RDI,RAX\n\t&quot;
11537        $$emit$$&quot;VPXOR    YMM0,YMM0,YMM0\n\t&quot;
11538        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11539        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11540        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11541        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11542        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11543        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11544        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11545        $$emit$$&quot;JGE     L_loop\n\t&quot;
11546        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11547        $$emit$$&quot;JL      L_tail\n\t&quot;
11548        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11549        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11550        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11551        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11552        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11553        $$emit$$&quot;JLE     L_end\n\t&quot;
11554        $$emit$$&quot;DEC     RCX\n\t&quot;
11555        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11556        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11557        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11558        $$emit$$&quot;DEC     RCX\n\t&quot;
11559        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11560        $$emit$$&quot;# L_end:\n\t&quot;
11561     } else {
11562        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11563        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11564     }
11565     $$emit$$&quot;# DONE&quot;
11566   %}
11567   ins_encode %{
11568     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11569                  $tmp$$XMMRegister, false);
11570   %}
11571   ins_pipe( pipe_slow );
11572 %}
11573 
11574 instruct rep_stos_large(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11575   predicate(((ClearArrayNode*)n)-&gt;is_large());
11576   match(Set dummy (ClearArray cnt base));
11577   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11578   format %{ $$template
11579     if (UseFastStosb) {
11580        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11581        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11582        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11583     } else if (UseXMMForObjInit) {
11584        $$emit$$&quot;MOV     RDI,RAX\t# ClearArray:\n\t&quot;
11585        $$emit$$&quot;VPXOR   YMM0,YMM0,YMM0\n\t&quot;
11586        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11587        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11588        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11589        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11590        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11591        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11592        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11593        $$emit$$&quot;JGE     L_loop\n\t&quot;
11594        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11595        $$emit$$&quot;JL      L_tail\n\t&quot;
11596        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11597        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11598        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11599        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11600        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11601        $$emit$$&quot;JLE     L_end\n\t&quot;
11602        $$emit$$&quot;DEC     RCX\n\t&quot;
11603        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11604        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11605        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11606        $$emit$$&quot;DEC     RCX\n\t&quot;
11607        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11608        $$emit$$&quot;# L_end:\n\t&quot;
11609     } else {
11610        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11611        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11612        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11613     }
11614     $$emit$$&quot;# DONE&quot;
11615   %}
11616   ins_encode %{
11617     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11618                  $tmp$$XMMRegister, true);
11619   %}
11620   ins_pipe( pipe_slow );
11621 %}
11622 
11623 instruct string_compareL(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11624                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11625   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11626   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11627   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11628 
11629   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11630   ins_encode %{
11631     __ string_compare($str1$$Register, $str2$$Register,
11632                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11633                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11634   %}
11635   ins_pipe( pipe_slow );
11636 %}
11637 
11638 instruct string_compareU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11639                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11640   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11641   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11642   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11643 
11644   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11645   ins_encode %{
11646     __ string_compare($str1$$Register, $str2$$Register,
11647                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11648                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11649   %}
11650   ins_pipe( pipe_slow );
11651 %}
11652 
11653 instruct string_compareLU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11654                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11655   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11656   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11657   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11658 
11659   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11660   ins_encode %{
11661     __ string_compare($str1$$Register, $str2$$Register,
11662                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11663                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11664   %}
11665   ins_pipe( pipe_slow );
11666 %}
11667 
11668 instruct string_compareUL(eSIRegP str1, eDXRegI cnt1, eDIRegP str2, eCXRegI cnt2,
11669                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11670   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11671   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11672   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11673 
11674   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11675   ins_encode %{
11676     __ string_compare($str2$$Register, $str1$$Register,
11677                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11678                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11679   %}
11680   ins_pipe( pipe_slow );
11681 %}
11682 
11683 // fast string equals
11684 instruct string_equals(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,
11685                        regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr) %{
11686   match(Set result (StrEquals (Binary str1 str2) cnt));
11687   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11688 
11689   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11690   ins_encode %{
11691     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11692                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11693                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11694   %}
11695 
11696   ins_pipe( pipe_slow );
11697 %}
11698 
11699 // fast search of substring with known size.
11700 instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11701                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11702   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11703   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11704   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11705 
11706   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11707   ins_encode %{
11708     int icnt2 = (int)$int_cnt2$$constant;
11709     if (icnt2 &gt;= 16) {
11710       // IndexOf for constant substrings with size &gt;= 16 elements
11711       // which don&#39;t need to be loaded through stack.
11712       __ string_indexofC8($str1$$Register, $str2$$Register,
11713                           $cnt1$$Register, $cnt2$$Register,
11714                           icnt2, $result$$Register,
11715                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11716     } else {
11717       // Small strings are loaded through stack if they cross page boundary.
11718       __ string_indexof($str1$$Register, $str2$$Register,
11719                         $cnt1$$Register, $cnt2$$Register,
11720                         icnt2, $result$$Register,
11721                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11722     }
11723   %}
11724   ins_pipe( pipe_slow );
11725 %}
11726 
11727 // fast search of substring with known size.
11728 instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11729                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11730   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11731   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11732   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11733 
11734   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11735   ins_encode %{
11736     int icnt2 = (int)$int_cnt2$$constant;
11737     if (icnt2 &gt;= 8) {
11738       // IndexOf for constant substrings with size &gt;= 8 elements
11739       // which don&#39;t need to be loaded through stack.
11740       __ string_indexofC8($str1$$Register, $str2$$Register,
11741                           $cnt1$$Register, $cnt2$$Register,
11742                           icnt2, $result$$Register,
11743                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11744     } else {
11745       // Small strings are loaded through stack if they cross page boundary.
11746       __ string_indexof($str1$$Register, $str2$$Register,
11747                         $cnt1$$Register, $cnt2$$Register,
11748                         icnt2, $result$$Register,
11749                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11750     }
11751   %}
11752   ins_pipe( pipe_slow );
11753 %}
11754 
11755 // fast search of substring with known size.
11756 instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11757                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11758   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11759   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11760   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11761 
11762   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11763   ins_encode %{
11764     int icnt2 = (int)$int_cnt2$$constant;
11765     if (icnt2 &gt;= 8) {
11766       // IndexOf for constant substrings with size &gt;= 8 elements
11767       // which don&#39;t need to be loaded through stack.
11768       __ string_indexofC8($str1$$Register, $str2$$Register,
11769                           $cnt1$$Register, $cnt2$$Register,
11770                           icnt2, $result$$Register,
11771                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11772     } else {
11773       // Small strings are loaded through stack if they cross page boundary.
11774       __ string_indexof($str1$$Register, $str2$$Register,
11775                         $cnt1$$Register, $cnt2$$Register,
11776                         icnt2, $result$$Register,
11777                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11778     }
11779   %}
11780   ins_pipe( pipe_slow );
11781 %}
11782 
11783 instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11784                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11785   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11786   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11787   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11788 
11789   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11790   ins_encode %{
11791     __ string_indexof($str1$$Register, $str2$$Register,
11792                       $cnt1$$Register, $cnt2$$Register,
11793                       (-1), $result$$Register,
11794                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11795   %}
11796   ins_pipe( pipe_slow );
11797 %}
11798 
11799 instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11800                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11801   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11802   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11803   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11804 
11805   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11806   ins_encode %{
11807     __ string_indexof($str1$$Register, $str2$$Register,
11808                       $cnt1$$Register, $cnt2$$Register,
11809                       (-1), $result$$Register,
11810                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11811   %}
11812   ins_pipe( pipe_slow );
11813 %}
11814 
11815 instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11816                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11817   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11818   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11819   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11820 
11821   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11822   ins_encode %{
11823     __ string_indexof($str1$$Register, $str2$$Register,
11824                       $cnt1$$Register, $cnt2$$Register,
11825                       (-1), $result$$Register,
11826                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11827   %}
11828   ins_pipe( pipe_slow );
11829 %}
11830 
11831 instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
11832                               eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{
11833   predicate(UseSSE42Intrinsics);
11834   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11835   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11836   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11837   ins_encode %{
11838     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11839                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
11840   %}
11841   ins_pipe( pipe_slow );
11842 %}
11843 
11844 // fast array equals
11845 instruct array_equalsB(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11846                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11847 %{
11848   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11849   match(Set result (AryEq ary1 ary2));
11850   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11851   //ins_cost(300);
11852 
11853   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11854   ins_encode %{
11855     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11856                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11857                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11858   %}
11859   ins_pipe( pipe_slow );
11860 %}
11861 
11862 instruct array_equalsC(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11863                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11864 %{
11865   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11866   match(Set result (AryEq ary1 ary2));
11867   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11868   //ins_cost(300);
11869 
11870   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11871   ins_encode %{
11872     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11873                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11874                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11875   %}
11876   ins_pipe( pipe_slow );
11877 %}
11878 
11879 instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,
11880                       regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)
11881 %{
11882   match(Set result (HasNegatives ary1 len));
11883   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11884 
11885   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11886   ins_encode %{
11887     __ has_negatives($ary1$$Register, $len$$Register,
11888                      $result$$Register, $tmp3$$Register,
11889                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11890   %}
11891   ins_pipe( pipe_slow );
11892 %}
11893 
11894 // fast char[] to byte[] compression
11895 instruct string_compress(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11896                          eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11897   match(Set result (StrCompressedCopy src (Binary dst len)));
11898   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11899 
11900   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11901   ins_encode %{
11902     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11903                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11904                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11905   %}
11906   ins_pipe( pipe_slow );
11907 %}
11908 
11909 // fast byte[] to char[] inflation
11910 instruct string_inflate(Universe dummy, eSIRegP src, eDIRegP dst, eDXRegI len,
11911                         regD tmp1, eCXRegI tmp2, eFlagsReg cr) %{
11912   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11913   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11914 
11915   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11916   ins_encode %{
11917     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11918                           $tmp1$$XMMRegister, $tmp2$$Register);
11919   %}
11920   ins_pipe( pipe_slow );
11921 %}
11922 
11923 // encode char[] to byte[] in ISO_8859_1
11924 instruct encode_iso_array(eSIRegP src, eDIRegP dst, eDXRegI len,
11925                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11926                           eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11927   match(Set result (EncodeISOArray src (Binary dst len)));
11928   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11929 
11930   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL ECX, EDX, $tmp1, $tmp2, $tmp3, $tmp4, ESI, EDI &quot; %}
11931   ins_encode %{
11932     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11933                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11934                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11935   %}
11936   ins_pipe( pipe_slow );
11937 %}
11938 
11939 
11940 //----------Control Flow Instructions------------------------------------------
11941 // Signed compare Instructions
11942 instruct compI_eReg(eFlagsReg cr, rRegI op1, rRegI op2) %{
11943   match(Set cr (CmpI op1 op2));
11944   effect( DEF cr, USE op1, USE op2 );
11945   format %{ &quot;CMP    $op1,$op2&quot; %}
11946   opcode(0x3B);  /* Opcode 3B /r */
11947   ins_encode( OpcP, RegReg( op1, op2) );
11948   ins_pipe( ialu_cr_reg_reg );
11949 %}
11950 
11951 instruct compI_eReg_imm(eFlagsReg cr, rRegI op1, immI op2) %{
11952   match(Set cr (CmpI op1 op2));
11953   effect( DEF cr, USE op1 );
11954   format %{ &quot;CMP    $op1,$op2&quot; %}
11955   opcode(0x81,0x07);  /* Opcode 81 /7 */
11956   // ins_encode( RegImm( op1, op2) );  /* Was CmpImm */
11957   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
11958   ins_pipe( ialu_cr_reg_imm );
11959 %}
11960 
11961 // Cisc-spilled version of cmpI_eReg
11962 instruct compI_eReg_mem(eFlagsReg cr, rRegI op1, memory op2) %{
11963   match(Set cr (CmpI op1 (LoadI op2)));
11964 
11965   format %{ &quot;CMP    $op1,$op2&quot; %}
11966   ins_cost(500);
11967   opcode(0x3B);  /* Opcode 3B /r */
11968   ins_encode( OpcP, RegMem( op1, op2) );
11969   ins_pipe( ialu_cr_reg_mem );
11970 %}
11971 
11972 instruct testI_reg( eFlagsReg cr, rRegI src, immI0 zero ) %{
11973   match(Set cr (CmpI src zero));
11974   effect( DEF cr, USE src );
11975 
11976   format %{ &quot;TEST   $src,$src&quot; %}
11977   opcode(0x85);
11978   ins_encode( OpcP, RegReg( src, src ) );
11979   ins_pipe( ialu_cr_reg_imm );
11980 %}
11981 
11982 instruct testI_reg_imm( eFlagsReg cr, rRegI src, immI con, immI0 zero ) %{
11983   match(Set cr (CmpI (AndI src con) zero));
11984 
11985   format %{ &quot;TEST   $src,$con&quot; %}
11986   opcode(0xF7,0x00);
11987   ins_encode( OpcP, RegOpc(src), Con32(con) );
11988   ins_pipe( ialu_cr_reg_imm );
11989 %}
11990 
11991 instruct testI_reg_mem( eFlagsReg cr, rRegI src, memory mem, immI0 zero ) %{
11992   match(Set cr (CmpI (AndI src mem) zero));
11993 
11994   format %{ &quot;TEST   $src,$mem&quot; %}
11995   opcode(0x85);
11996   ins_encode( OpcP, RegMem( src, mem ) );
11997   ins_pipe( ialu_cr_reg_mem );
11998 %}
11999 
12000 // Unsigned compare Instructions; really, same as signed except they
12001 // produce an eFlagsRegU instead of eFlagsReg.
12002 instruct compU_eReg(eFlagsRegU cr, rRegI op1, rRegI op2) %{
12003   match(Set cr (CmpU op1 op2));
12004 
12005   format %{ &quot;CMPu   $op1,$op2&quot; %}
12006   opcode(0x3B);  /* Opcode 3B /r */
12007   ins_encode( OpcP, RegReg( op1, op2) );
12008   ins_pipe( ialu_cr_reg_reg );
12009 %}
12010 
12011 instruct compU_eReg_imm(eFlagsRegU cr, rRegI op1, immI op2) %{
12012   match(Set cr (CmpU op1 op2));
12013 
12014   format %{ &quot;CMPu   $op1,$op2&quot; %}
12015   opcode(0x81,0x07);  /* Opcode 81 /7 */
12016   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12017   ins_pipe( ialu_cr_reg_imm );
12018 %}
12019 
12020 // // Cisc-spilled version of cmpU_eReg
12021 instruct compU_eReg_mem(eFlagsRegU cr, rRegI op1, memory op2) %{
12022   match(Set cr (CmpU op1 (LoadI op2)));
12023 
12024   format %{ &quot;CMPu   $op1,$op2&quot; %}
12025   ins_cost(500);
12026   opcode(0x3B);  /* Opcode 3B /r */
12027   ins_encode( OpcP, RegMem( op1, op2) );
12028   ins_pipe( ialu_cr_reg_mem );
12029 %}
12030 
12031 // // Cisc-spilled version of cmpU_eReg
12032 //instruct compU_mem_eReg(eFlagsRegU cr, memory op1, rRegI op2) %{
12033 //  match(Set cr (CmpU (LoadI op1) op2));
12034 //
12035 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12036 //  ins_cost(500);
12037 //  opcode(0x39);  /* Opcode 39 /r */
12038 //  ins_encode( OpcP, RegMem( op1, op2) );
12039 //%}
12040 
12041 instruct testU_reg( eFlagsRegU cr, rRegI src, immI0 zero ) %{
12042   match(Set cr (CmpU src zero));
12043 
12044   format %{ &quot;TESTu  $src,$src&quot; %}
12045   opcode(0x85);
12046   ins_encode( OpcP, RegReg( src, src ) );
12047   ins_pipe( ialu_cr_reg_imm );
12048 %}
12049 
12050 // Unsigned pointer compare Instructions
12051 instruct compP_eReg(eFlagsRegU cr, eRegP op1, eRegP op2) %{
12052   match(Set cr (CmpP op1 op2));
12053 
12054   format %{ &quot;CMPu   $op1,$op2&quot; %}
12055   opcode(0x3B);  /* Opcode 3B /r */
12056   ins_encode( OpcP, RegReg( op1, op2) );
12057   ins_pipe( ialu_cr_reg_reg );
12058 %}
12059 
12060 instruct compP_eReg_imm(eFlagsRegU cr, eRegP op1, immP op2) %{
12061   match(Set cr (CmpP op1 op2));
12062 
12063   format %{ &quot;CMPu   $op1,$op2&quot; %}
12064   opcode(0x81,0x07);  /* Opcode 81 /7 */
12065   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12066   ins_pipe( ialu_cr_reg_imm );
12067 %}
12068 
12069 // // Cisc-spilled version of cmpP_eReg
12070 instruct compP_eReg_mem(eFlagsRegU cr, eRegP op1, memory op2) %{
12071   match(Set cr (CmpP op1 (LoadP op2)));
12072 
12073   format %{ &quot;CMPu   $op1,$op2&quot; %}
12074   ins_cost(500);
12075   opcode(0x3B);  /* Opcode 3B /r */
12076   ins_encode( OpcP, RegMem( op1, op2) );
12077   ins_pipe( ialu_cr_reg_mem );
12078 %}
12079 
12080 // // Cisc-spilled version of cmpP_eReg
12081 //instruct compP_mem_eReg(eFlagsRegU cr, memory op1, eRegP op2) %{
12082 //  match(Set cr (CmpP (LoadP op1) op2));
12083 //
12084 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12085 //  ins_cost(500);
12086 //  opcode(0x39);  /* Opcode 39 /r */
12087 //  ins_encode( OpcP, RegMem( op1, op2) );
12088 //%}
12089 
12090 // Compare raw pointer (used in out-of-heap check).
12091 // Only works because non-oop pointers must be raw pointers
12092 // and raw pointers have no anti-dependencies.
12093 instruct compP_mem_eReg( eFlagsRegU cr, eRegP op1, memory op2 ) %{
12094   predicate( n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none );
12095   match(Set cr (CmpP op1 (LoadP op2)));
12096 
12097   format %{ &quot;CMPu   $op1,$op2&quot; %}
12098   opcode(0x3B);  /* Opcode 3B /r */
12099   ins_encode( OpcP, RegMem( op1, op2) );
12100   ins_pipe( ialu_cr_reg_mem );
12101 %}
12102 
12103 //
12104 // This will generate a signed flags result. This should be ok
12105 // since any compare to a zero should be eq/neq.
12106 instruct testP_reg( eFlagsReg cr, eRegP src, immP0 zero ) %{
12107   match(Set cr (CmpP src zero));
12108 
12109   format %{ &quot;TEST   $src,$src&quot; %}
12110   opcode(0x85);
12111   ins_encode( OpcP, RegReg( src, src ) );
12112   ins_pipe( ialu_cr_reg_imm );
12113 %}
12114 
12115 // Cisc-spilled version of testP_reg
12116 // This will generate a signed flags result. This should be ok
12117 // since any compare to a zero should be eq/neq.
12118 instruct testP_Reg_mem( eFlagsReg cr, memory op, immI0 zero ) %{
12119   match(Set cr (CmpP (LoadP op) zero));
12120 
12121   format %{ &quot;TEST   $op,0xFFFFFFFF&quot; %}
12122   ins_cost(500);
12123   opcode(0xF7);               /* Opcode F7 /0 */
12124   ins_encode( OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF) );
12125   ins_pipe( ialu_cr_reg_imm );
12126 %}
12127 
12128 // Yanked all unsigned pointer compare operations.
12129 // Pointer compares are done with CmpP which is already unsigned.
12130 
12131 //----------Max and Min--------------------------------------------------------
12132 // Min Instructions
12133 ////
12134 //   *** Min and Max using the conditional move are slower than the
12135 //   *** branch version on a Pentium III.
12136 // // Conditional move for min
12137 //instruct cmovI_reg_lt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12138 //  effect( USE_DEF op2, USE op1, USE cr );
12139 //  format %{ &quot;CMOVlt $op2,$op1\t! min&quot; %}
12140 //  opcode(0x4C,0x0F);
12141 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12142 //  ins_pipe( pipe_cmov_reg );
12143 //%}
12144 //
12145 //// Min Register with Register (P6 version)
12146 //instruct minI_eReg_p6( rRegI op1, rRegI op2 ) %{
12147 //  predicate(VM_Version::supports_cmov() );
12148 //  match(Set op2 (MinI op1 op2));
12149 //  ins_cost(200);
12150 //  expand %{
12151 //    eFlagsReg cr;
12152 //    compI_eReg(cr,op1,op2);
12153 //    cmovI_reg_lt(op2,op1,cr);
12154 //  %}
12155 //%}
12156 
12157 // Min Register with Register (generic version)
12158 instruct minI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12159   match(Set dst (MinI dst src));
12160   effect(KILL flags);
12161   ins_cost(300);
12162 
12163   format %{ &quot;MIN    $dst,$src&quot; %}
12164   opcode(0xCC);
12165   ins_encode( min_enc(dst,src) );
12166   ins_pipe( pipe_slow );
12167 %}
12168 
12169 // Max Register with Register
12170 //   *** Min and Max using the conditional move are slower than the
12171 //   *** branch version on a Pentium III.
12172 // // Conditional move for max
12173 //instruct cmovI_reg_gt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12174 //  effect( USE_DEF op2, USE op1, USE cr );
12175 //  format %{ &quot;CMOVgt $op2,$op1\t! max&quot; %}
12176 //  opcode(0x4F,0x0F);
12177 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12178 //  ins_pipe( pipe_cmov_reg );
12179 //%}
12180 //
12181 // // Max Register with Register (P6 version)
12182 //instruct maxI_eReg_p6( rRegI op1, rRegI op2 ) %{
12183 //  predicate(VM_Version::supports_cmov() );
12184 //  match(Set op2 (MaxI op1 op2));
12185 //  ins_cost(200);
12186 //  expand %{
12187 //    eFlagsReg cr;
12188 //    compI_eReg(cr,op1,op2);
12189 //    cmovI_reg_gt(op2,op1,cr);
12190 //  %}
12191 //%}
12192 
12193 // Max Register with Register (generic version)
12194 instruct maxI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12195   match(Set dst (MaxI dst src));
12196   effect(KILL flags);
12197   ins_cost(300);
12198 
12199   format %{ &quot;MAX    $dst,$src&quot; %}
12200   opcode(0xCC);
12201   ins_encode( max_enc(dst,src) );
12202   ins_pipe( pipe_slow );
12203 %}
12204 
12205 // ============================================================================
12206 // Counted Loop limit node which represents exact final iterator value.
12207 // Note: the resulting value should fit into integer range since
12208 // counted loops have limit check on overflow.
12209 instruct loopLimit_eReg(eAXRegI limit, nadxRegI init, immI stride, eDXRegI limit_hi, nadxRegI tmp, eFlagsReg flags) %{
12210   match(Set limit (LoopLimit (Binary init limit) stride));
12211   effect(TEMP limit_hi, TEMP tmp, KILL flags);
12212   ins_cost(300);
12213 
12214   format %{ &quot;loopLimit $init,$limit,$stride  # $limit = $init + $stride *( $limit - $init + $stride -1)/ $stride, kills $limit_hi&quot; %}
12215   ins_encode %{
12216     int strd = (int)$stride$$constant;
12217     assert(strd != 1 &amp;&amp; strd != -1, &quot;sanity&quot;);
12218     int m1 = (strd &gt; 0) ? 1 : -1;
12219     // Convert limit to long (EAX:EDX)
12220     __ cdql();
12221     // Convert init to long (init:tmp)
12222     __ movl($tmp$$Register, $init$$Register);
12223     __ sarl($tmp$$Register, 31);
12224     // $limit - $init
12225     __ subl($limit$$Register, $init$$Register);
12226     __ sbbl($limit_hi$$Register, $tmp$$Register);
12227     // + ($stride - 1)
12228     if (strd &gt; 0) {
12229       __ addl($limit$$Register, (strd - 1));
12230       __ adcl($limit_hi$$Register, 0);
12231       __ movl($tmp$$Register, strd);
12232     } else {
12233       __ addl($limit$$Register, (strd + 1));
12234       __ adcl($limit_hi$$Register, -1);
12235       __ lneg($limit_hi$$Register, $limit$$Register);
12236       __ movl($tmp$$Register, -strd);
12237     }
12238     // signed devision: (EAX:EDX) / pos_stride
12239     __ idivl($tmp$$Register);
12240     if (strd &lt; 0) {
12241       // restore sign
12242       __ negl($tmp$$Register);
12243     }
12244     // (EAX) * stride
12245     __ mull($tmp$$Register);
12246     // + init (ignore upper bits)
12247     __ addl($limit$$Register, $init$$Register);
12248   %}
12249   ins_pipe( pipe_slow );
12250 %}
12251 
12252 // ============================================================================
12253 // Branch Instructions
12254 // Jump Table
12255 instruct jumpXtnd(rRegI switch_val) %{
12256   match(Jump switch_val);
12257   ins_cost(350);
12258   format %{  &quot;JMP    [$constantaddress](,$switch_val,1)\n\t&quot; %}
12259   ins_encode %{
12260     // Jump to Address(table_base + switch_reg)
12261     Address index(noreg, $switch_val$$Register, Address::times_1);
12262     __ jump(ArrayAddress($constantaddress, index));
12263   %}
12264   ins_pipe(pipe_jmp);
12265 %}
12266 
12267 // Jump Direct - Label defines a relative address from JMP+1
12268 instruct jmpDir(label labl) %{
12269   match(Goto);
12270   effect(USE labl);
12271 
12272   ins_cost(300);
12273   format %{ &quot;JMP    $labl&quot; %}
12274   size(5);
12275   ins_encode %{
12276     Label* L = $labl$$label;
12277     __ jmp(*L, false); // Always long jump
12278   %}
12279   ins_pipe( pipe_jmp );
12280 %}
12281 
12282 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12283 instruct jmpCon(cmpOp cop, eFlagsReg cr, label labl) %{
12284   match(If cop cr);
12285   effect(USE labl);
12286 
12287   ins_cost(300);
12288   format %{ &quot;J$cop    $labl&quot; %}
12289   size(6);
12290   ins_encode %{
12291     Label* L = $labl$$label;
12292     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12293   %}
12294   ins_pipe( pipe_jcc );
12295 %}
12296 
12297 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12298 instruct jmpLoopEnd(cmpOp cop, eFlagsReg cr, label labl) %{
12299   predicate(!n-&gt;has_vector_mask_set());
12300   match(CountedLoopEnd cop cr);
12301   effect(USE labl);
12302 
12303   ins_cost(300);
12304   format %{ &quot;J$cop    $labl\t# Loop end&quot; %}
12305   size(6);
12306   ins_encode %{
12307     Label* L = $labl$$label;
12308     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12309   %}
12310   ins_pipe( pipe_jcc );
12311 %}
12312 
12313 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12314 instruct jmpLoopEndU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12315   predicate(!n-&gt;has_vector_mask_set());
12316   match(CountedLoopEnd cop cmp);
12317   effect(USE labl);
12318 
12319   ins_cost(300);
12320   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12321   size(6);
12322   ins_encode %{
12323     Label* L = $labl$$label;
12324     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12325   %}
12326   ins_pipe( pipe_jcc );
12327 %}
12328 
12329 instruct jmpLoopEndUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12330   predicate(!n-&gt;has_vector_mask_set());
12331   match(CountedLoopEnd cop cmp);
12332   effect(USE labl);
12333 
12334   ins_cost(200);
12335   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12336   size(6);
12337   ins_encode %{
12338     Label* L = $labl$$label;
12339     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12340   %}
12341   ins_pipe( pipe_jcc );
12342 %}
12343 
12344 // mask version
12345 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12346 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, eFlagsReg cr, label labl) %{
12347   predicate(n-&gt;has_vector_mask_set());
12348   match(CountedLoopEnd cop cr);
12349   effect(USE labl);
12350 
12351   ins_cost(400);
12352   format %{ &quot;J$cop    $labl\t# Loop end\n\t&quot;
12353             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12354   size(10);
12355   ins_encode %{
12356     Label* L = $labl$$label;
12357     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12358     __ restorevectmask();
12359   %}
12360   ins_pipe( pipe_jcc );
12361 %}
12362 
12363 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12364 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12365   predicate(n-&gt;has_vector_mask_set());
12366   match(CountedLoopEnd cop cmp);
12367   effect(USE labl);
12368 
12369   ins_cost(400);
12370   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12371             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12372   size(10);
12373   ins_encode %{
12374     Label* L = $labl$$label;
12375     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12376     __ restorevectmask();
12377   %}
12378   ins_pipe( pipe_jcc );
12379 %}
12380 
12381 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12382   predicate(n-&gt;has_vector_mask_set());
12383   match(CountedLoopEnd cop cmp);
12384   effect(USE labl);
12385 
12386   ins_cost(300);
12387   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12388             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12389   size(10);
12390   ins_encode %{
12391     Label* L = $labl$$label;
12392     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12393     __ restorevectmask();
12394   %}
12395   ins_pipe( pipe_jcc );
12396 %}
12397 
12398 // Jump Direct Conditional - using unsigned comparison
12399 instruct jmpConU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12400   match(If cop cmp);
12401   effect(USE labl);
12402 
12403   ins_cost(300);
12404   format %{ &quot;J$cop,u  $labl&quot; %}
12405   size(6);
12406   ins_encode %{
12407     Label* L = $labl$$label;
12408     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12409   %}
12410   ins_pipe(pipe_jcc);
12411 %}
12412 
12413 instruct jmpConUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12414   match(If cop cmp);
12415   effect(USE labl);
12416 
12417   ins_cost(200);
12418   format %{ &quot;J$cop,u  $labl&quot; %}
12419   size(6);
12420   ins_encode %{
12421     Label* L = $labl$$label;
12422     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12423   %}
12424   ins_pipe(pipe_jcc);
12425 %}
12426 
12427 instruct jmpConUCF2(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12428   match(If cop cmp);
12429   effect(USE labl);
12430 
12431   ins_cost(200);
12432   format %{ $$template
12433     if ($cop$$cmpcode == Assembler::notEqual) {
12434       $$emit$$&quot;JP,u   $labl\n\t&quot;
12435       $$emit$$&quot;J$cop,u   $labl&quot;
12436     } else {
12437       $$emit$$&quot;JP,u   done\n\t&quot;
12438       $$emit$$&quot;J$cop,u   $labl\n\t&quot;
12439       $$emit$$&quot;done:&quot;
12440     }
12441   %}
12442   ins_encode %{
12443     Label* l = $labl$$label;
12444     if ($cop$$cmpcode == Assembler::notEqual) {
12445       __ jcc(Assembler::parity, *l, false);
12446       __ jcc(Assembler::notEqual, *l, false);
12447     } else if ($cop$$cmpcode == Assembler::equal) {
12448       Label done;
12449       __ jccb(Assembler::parity, done);
12450       __ jcc(Assembler::equal, *l, false);
12451       __ bind(done);
12452     } else {
12453        ShouldNotReachHere();
12454     }
12455   %}
12456   ins_pipe(pipe_jcc);
12457 %}
12458 
12459 // ============================================================================
12460 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
12461 // array for an instance of the superklass.  Set a hidden internal cache on a
12462 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
12463 // NZ for a miss or zero for a hit.  The encoding ALSO sets flags.
12464 instruct partialSubtypeCheck( eDIRegP result, eSIRegP sub, eAXRegP super, eCXRegI rcx, eFlagsReg cr ) %{
12465   match(Set result (PartialSubtypeCheck sub super));
12466   effect( KILL rcx, KILL cr );
12467 
12468   ins_cost(1100);  // slightly larger than the next version
12469   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12470             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12471             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12472             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12473             &quot;JNE,s  miss\t\t# Missed: EDI not-zero\n\t&quot;
12474             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache\n\t&quot;
12475             &quot;XOR    $result,$result\t\t Hit: EDI zero\n\t&quot;
12476      &quot;miss:\t&quot; %}
12477 
12478   opcode(0x1); // Force a XOR of EDI
12479   ins_encode( enc_PartialSubtypeCheck() );
12480   ins_pipe( pipe_slow );
12481 %}
12482 
12483 instruct partialSubtypeCheck_vs_Zero( eFlagsReg cr, eSIRegP sub, eAXRegP super, eCXRegI rcx, eDIRegP result, immP0 zero ) %{
12484   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12485   effect( KILL rcx, KILL result );
12486 
12487   ins_cost(1000);
12488   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12489             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12490             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12491             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12492             &quot;JNE,s  miss\t\t# Missed: flags NZ\n\t&quot;
12493             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache, flags Z\n\t&quot;
12494      &quot;miss:\t&quot; %}
12495 
12496   opcode(0x0);  // No need to XOR EDI
12497   ins_encode( enc_PartialSubtypeCheck() );
12498   ins_pipe( pipe_slow );
12499 %}
12500 
12501 // ============================================================================
12502 // Branch Instructions -- short offset versions
12503 //
12504 // These instructions are used to replace jumps of a long offset (the default
12505 // match) with jumps of a shorter offset.  These instructions are all tagged
12506 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12507 // match rules in general matching.  Instead, the ADLC generates a conversion
12508 // method in the MachNode which can be used to do in-place replacement of the
12509 // long variant with the shorter variant.  The compiler will determine if a
12510 // branch can be taken by the is_short_branch_offset() predicate in the machine
12511 // specific code section of the file.
12512 
12513 // Jump Direct - Label defines a relative address from JMP+1
12514 instruct jmpDir_short(label labl) %{
12515   match(Goto);
12516   effect(USE labl);
12517 
12518   ins_cost(300);
12519   format %{ &quot;JMP,s  $labl&quot; %}
12520   size(2);
12521   ins_encode %{
12522     Label* L = $labl$$label;
12523     __ jmpb(*L);
12524   %}
12525   ins_pipe( pipe_jmp );
12526   ins_short_branch(1);
12527 %}
12528 
12529 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12530 instruct jmpCon_short(cmpOp cop, eFlagsReg cr, label labl) %{
12531   match(If cop cr);
12532   effect(USE labl);
12533 
12534   ins_cost(300);
12535   format %{ &quot;J$cop,s  $labl&quot; %}
12536   size(2);
12537   ins_encode %{
12538     Label* L = $labl$$label;
12539     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12540   %}
12541   ins_pipe( pipe_jcc );
12542   ins_short_branch(1);
12543 %}
12544 
12545 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12546 instruct jmpLoopEnd_short(cmpOp cop, eFlagsReg cr, label labl) %{
12547   match(CountedLoopEnd cop cr);
12548   effect(USE labl);
12549 
12550   ins_cost(300);
12551   format %{ &quot;J$cop,s  $labl\t# Loop end&quot; %}
12552   size(2);
12553   ins_encode %{
12554     Label* L = $labl$$label;
12555     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12556   %}
12557   ins_pipe( pipe_jcc );
12558   ins_short_branch(1);
12559 %}
12560 
12561 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12562 instruct jmpLoopEndU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12563   match(CountedLoopEnd cop cmp);
12564   effect(USE labl);
12565 
12566   ins_cost(300);
12567   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12568   size(2);
12569   ins_encode %{
12570     Label* L = $labl$$label;
12571     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12572   %}
12573   ins_pipe( pipe_jcc );
12574   ins_short_branch(1);
12575 %}
12576 
12577 instruct jmpLoopEndUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12578   match(CountedLoopEnd cop cmp);
12579   effect(USE labl);
12580 
12581   ins_cost(300);
12582   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12583   size(2);
12584   ins_encode %{
12585     Label* L = $labl$$label;
12586     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12587   %}
12588   ins_pipe( pipe_jcc );
12589   ins_short_branch(1);
12590 %}
12591 
12592 // Jump Direct Conditional - using unsigned comparison
12593 instruct jmpConU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12594   match(If cop cmp);
12595   effect(USE labl);
12596 
12597   ins_cost(300);
12598   format %{ &quot;J$cop,us $labl&quot; %}
12599   size(2);
12600   ins_encode %{
12601     Label* L = $labl$$label;
12602     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12603   %}
12604   ins_pipe( pipe_jcc );
12605   ins_short_branch(1);
12606 %}
12607 
12608 instruct jmpConUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12609   match(If cop cmp);
12610   effect(USE labl);
12611 
12612   ins_cost(300);
12613   format %{ &quot;J$cop,us $labl&quot; %}
12614   size(2);
12615   ins_encode %{
12616     Label* L = $labl$$label;
12617     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12618   %}
12619   ins_pipe( pipe_jcc );
12620   ins_short_branch(1);
12621 %}
12622 
12623 instruct jmpConUCF2_short(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12624   match(If cop cmp);
12625   effect(USE labl);
12626 
12627   ins_cost(300);
12628   format %{ $$template
12629     if ($cop$$cmpcode == Assembler::notEqual) {
12630       $$emit$$&quot;JP,u,s   $labl\n\t&quot;
12631       $$emit$$&quot;J$cop,u,s   $labl&quot;
12632     } else {
12633       $$emit$$&quot;JP,u,s   done\n\t&quot;
12634       $$emit$$&quot;J$cop,u,s  $labl\n\t&quot;
12635       $$emit$$&quot;done:&quot;
12636     }
12637   %}
12638   size(4);
12639   ins_encode %{
12640     Label* l = $labl$$label;
12641     if ($cop$$cmpcode == Assembler::notEqual) {
12642       __ jccb(Assembler::parity, *l);
12643       __ jccb(Assembler::notEqual, *l);
12644     } else if ($cop$$cmpcode == Assembler::equal) {
12645       Label done;
12646       __ jccb(Assembler::parity, done);
12647       __ jccb(Assembler::equal, *l);
12648       __ bind(done);
12649     } else {
12650        ShouldNotReachHere();
12651     }
12652   %}
12653   ins_pipe(pipe_jcc);
12654   ins_short_branch(1);
12655 %}
12656 
12657 // ============================================================================
12658 // Long Compare
12659 //
12660 // Currently we hold longs in 2 registers.  Comparing such values efficiently
12661 // is tricky.  The flavor of compare used depends on whether we are testing
12662 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
12663 // The GE test is the negated LT test.  The LE test can be had by commuting
12664 // the operands (yielding a GE test) and then negating; negate again for the
12665 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
12666 // NE test is negated from that.
12667 
12668 // Due to a shortcoming in the ADLC, it mixes up expressions like:
12669 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
12670 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
12671 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
12672 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
12673 // foo match ends up with the wrong leaf.  One fix is to not match both
12674 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
12675 // both forms beat the trinary form of long-compare and both are very useful
12676 // on Intel which has so few registers.
12677 
12678 // Manifest a CmpL result in an integer register.  Very painful.
12679 // This is the test to avoid.
12680 instruct cmpL3_reg_reg(eSIRegI dst, eRegL src1, eRegL src2, eFlagsReg flags ) %{
12681   match(Set dst (CmpL3 src1 src2));
12682   effect( KILL flags );
12683   ins_cost(1000);
12684   format %{ &quot;XOR    $dst,$dst\n\t&quot;
12685             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12686             &quot;JLT,s  m_one\n\t&quot;
12687             &quot;JGT,s  p_one\n\t&quot;
12688             &quot;CMP    $src1.lo,$src2.lo\n\t&quot;
12689             &quot;JB,s   m_one\n\t&quot;
12690             &quot;JEQ,s  done\n&quot;
12691     &quot;p_one:\tINC    $dst\n\t&quot;
12692             &quot;JMP,s  done\n&quot;
12693     &quot;m_one:\tDEC    $dst\n&quot;
12694      &quot;done:&quot; %}
12695   ins_encode %{
12696     Label p_one, m_one, done;
12697     __ xorptr($dst$$Register, $dst$$Register);
12698     __ cmpl(HIGH_FROM_LOW($src1$$Register), HIGH_FROM_LOW($src2$$Register));
12699     __ jccb(Assembler::less,    m_one);
12700     __ jccb(Assembler::greater, p_one);
12701     __ cmpl($src1$$Register, $src2$$Register);
12702     __ jccb(Assembler::below,   m_one);
12703     __ jccb(Assembler::equal,   done);
12704     __ bind(p_one);
12705     __ incrementl($dst$$Register);
12706     __ jmpb(done);
12707     __ bind(m_one);
12708     __ decrementl($dst$$Register);
12709     __ bind(done);
12710   %}
12711   ins_pipe( pipe_slow );
12712 %}
12713 
12714 //======
12715 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12716 // compares.  Can be used for LE or GT compares by reversing arguments.
12717 // NOT GOOD FOR EQ/NE tests.
12718 instruct cmpL_zero_flags_LTGE( flagsReg_long_LTGE flags, eRegL src, immL0 zero ) %{
12719   match( Set flags (CmpL src zero ));
12720   ins_cost(100);
12721   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12722   opcode(0x85);
12723   ins_encode( OpcP, RegReg_Hi2( src, src ) );
12724   ins_pipe( ialu_cr_reg_reg );
12725 %}
12726 
12727 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12728 // compares.  Can be used for LE or GT compares by reversing arguments.
12729 // NOT GOOD FOR EQ/NE tests.
12730 instruct cmpL_reg_flags_LTGE( flagsReg_long_LTGE flags, eRegL src1, eRegL src2, rRegI tmp ) %{
12731   match( Set flags (CmpL src1 src2 ));
12732   effect( TEMP tmp );
12733   ins_cost(300);
12734   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12735             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12736             &quot;SBB    $tmp,$src2.hi\t! Compute flags for long compare&quot; %}
12737   ins_encode( long_cmp_flags2( src1, src2, tmp ) );
12738   ins_pipe( ialu_cr_reg_reg );
12739 %}
12740 
12741 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
12742 // Just a wrapper for a normal branch, plus the predicate test.
12743 instruct cmpL_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, label labl) %{
12744   match(If cmp flags);
12745   effect(USE labl);
12746   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12747   expand %{
12748     jmpCon(cmp,flags,labl);    // JLT or JGE...
12749   %}
12750 %}
12751 
12752 //======
12753 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12754 // compares.  Can be used for LE or GT compares by reversing arguments.
12755 // NOT GOOD FOR EQ/NE tests.
12756 instruct cmpUL_zero_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src, immL0 zero) %{
12757   match(Set flags (CmpUL src zero));
12758   ins_cost(100);
12759   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12760   opcode(0x85);
12761   ins_encode(OpcP, RegReg_Hi2(src, src));
12762   ins_pipe(ialu_cr_reg_reg);
12763 %}
12764 
12765 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12766 // compares.  Can be used for LE or GT compares by reversing arguments.
12767 // NOT GOOD FOR EQ/NE tests.
12768 instruct cmpUL_reg_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src1, eRegL src2, rRegI tmp) %{
12769   match(Set flags (CmpUL src1 src2));
12770   effect(TEMP tmp);
12771   ins_cost(300);
12772   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12773             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12774             &quot;SBB    $tmp,$src2.hi\t! Compute flags for unsigned long compare&quot; %}
12775   ins_encode(long_cmp_flags2(src1, src2, tmp));
12776   ins_pipe(ialu_cr_reg_reg);
12777 %}
12778 
12779 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
12780 // Just a wrapper for a normal branch, plus the predicate test.
12781 instruct cmpUL_LTGE(cmpOpU cmp, flagsReg_ulong_LTGE flags, label labl) %{
12782   match(If cmp flags);
12783   effect(USE labl);
12784   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
12785   expand %{
12786     jmpCon(cmp, flags, labl);    // JLT or JGE...
12787   %}
12788 %}
12789 
12790 // Compare 2 longs and CMOVE longs.
12791 instruct cmovLL_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, eRegL src) %{
12792   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12793   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12794   ins_cost(400);
12795   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12796             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12797   opcode(0x0F,0x40);
12798   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12799   ins_pipe( pipe_cmov_reg_long );
12800 %}
12801 
12802 instruct cmovLL_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, load_long_memory src) %{
12803   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12804   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12805   ins_cost(500);
12806   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12807             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12808   opcode(0x0F,0x40);
12809   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12810   ins_pipe( pipe_cmov_reg_long );
12811 %}
12812 
12813 // Compare 2 longs and CMOVE ints.
12814 instruct cmovII_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, rRegI src) %{
12815   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12816   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12817   ins_cost(200);
12818   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12819   opcode(0x0F,0x40);
12820   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12821   ins_pipe( pipe_cmov_reg );
12822 %}
12823 
12824 instruct cmovII_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, memory src) %{
12825   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12826   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
12827   ins_cost(250);
12828   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12829   opcode(0x0F,0x40);
12830   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
12831   ins_pipe( pipe_cmov_mem );
12832 %}
12833 
12834 // Compare 2 longs and CMOVE ints.
12835 instruct cmovPP_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegP dst, eRegP src) %{
12836   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12837   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
12838   ins_cost(200);
12839   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12840   opcode(0x0F,0x40);
12841   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12842   ins_pipe( pipe_cmov_reg );
12843 %}
12844 
12845 // Compare 2 longs and CMOVE doubles
12846 instruct cmovDDPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regDPR dst, regDPR src) %{
12847   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12848   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12849   ins_cost(200);
12850   expand %{
12851     fcmovDPR_regS(cmp,flags,dst,src);
12852   %}
12853 %}
12854 
12855 // Compare 2 longs and CMOVE doubles
12856 instruct cmovDD_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regD dst, regD src) %{
12857   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12858   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12859   ins_cost(200);
12860   expand %{
12861     fcmovD_regS(cmp,flags,dst,src);
12862   %}
12863 %}
12864 
12865 instruct cmovFFPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regFPR dst, regFPR src) %{
12866   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12867   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12868   ins_cost(200);
12869   expand %{
12870     fcmovFPR_regS(cmp,flags,dst,src);
12871   %}
12872 %}
12873 
12874 instruct cmovFF_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regF dst, regF src) %{
12875   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12876   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12877   ins_cost(200);
12878   expand %{
12879     fcmovF_regS(cmp,flags,dst,src);
12880   %}
12881 %}
12882 
12883 //======
12884 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12885 instruct cmpL_zero_flags_EQNE( flagsReg_long_EQNE flags, eRegL src, immL0 zero, rRegI tmp ) %{
12886   match( Set flags (CmpL src zero ));
12887   effect(TEMP tmp);
12888   ins_cost(200);
12889   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12890             &quot;OR     $tmp,$src.hi\t! Long is EQ/NE 0?&quot; %}
12891   ins_encode( long_cmp_flags0( src, tmp ) );
12892   ins_pipe( ialu_reg_reg_long );
12893 %}
12894 
12895 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12896 instruct cmpL_reg_flags_EQNE( flagsReg_long_EQNE flags, eRegL src1, eRegL src2 ) %{
12897   match( Set flags (CmpL src1 src2 ));
12898   ins_cost(200+300);
12899   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12900             &quot;JNE,s  skip\n\t&quot;
12901             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12902      &quot;skip:\t&quot; %}
12903   ins_encode( long_cmp_flags1( src1, src2 ) );
12904   ins_pipe( ialu_cr_reg_reg );
12905 %}
12906 
12907 // Long compare reg == zero/reg OR reg != zero/reg
12908 // Just a wrapper for a normal branch, plus the predicate test.
12909 instruct cmpL_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, label labl) %{
12910   match(If cmp flags);
12911   effect(USE labl);
12912   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
12913   expand %{
12914     jmpCon(cmp,flags,labl);    // JEQ or JNE...
12915   %}
12916 %}
12917 
12918 //======
12919 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12920 instruct cmpUL_zero_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src, immL0 zero, rRegI tmp) %{
12921   match(Set flags (CmpUL src zero));
12922   effect(TEMP tmp);
12923   ins_cost(200);
12924   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12925             &quot;OR     $tmp,$src.hi\t! Unsigned long is EQ/NE 0?&quot; %}
12926   ins_encode(long_cmp_flags0(src, tmp));
12927   ins_pipe(ialu_reg_reg_long);
12928 %}
12929 
12930 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12931 instruct cmpUL_reg_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src1, eRegL src2) %{
12932   match(Set flags (CmpUL src1 src2));
12933   ins_cost(200+300);
12934   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12935             &quot;JNE,s  skip\n\t&quot;
12936             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12937      &quot;skip:\t&quot; %}
12938   ins_encode(long_cmp_flags1(src1, src2));
12939   ins_pipe(ialu_cr_reg_reg);
12940 %}
12941 
12942 // Unsigned long compare reg == zero/reg OR reg != zero/reg
12943 // Just a wrapper for a normal branch, plus the predicate test.
12944 instruct cmpUL_EQNE(cmpOpU cmp, flagsReg_ulong_EQNE flags, label labl) %{
12945   match(If cmp flags);
12946   effect(USE labl);
12947   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne);
12948   expand %{
12949     jmpCon(cmp, flags, labl);    // JEQ or JNE...
12950   %}
12951 %}
12952 
12953 // Compare 2 longs and CMOVE longs.
12954 instruct cmovLL_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, eRegL src) %{
12955   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12956   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12957   ins_cost(400);
12958   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12959             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12960   opcode(0x0F,0x40);
12961   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12962   ins_pipe( pipe_cmov_reg_long );
12963 %}
12964 
12965 instruct cmovLL_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, load_long_memory src) %{
12966   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12967   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12968   ins_cost(500);
12969   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12970             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12971   opcode(0x0F,0x40);
12972   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12973   ins_pipe( pipe_cmov_reg_long );
12974 %}
12975 
12976 // Compare 2 longs and CMOVE ints.
12977 instruct cmovII_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, rRegI src) %{
12978   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12979   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12980   ins_cost(200);
12981   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12982   opcode(0x0F,0x40);
12983   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12984   ins_pipe( pipe_cmov_reg );
12985 %}
12986 
12987 instruct cmovII_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, memory src) %{
12988   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12989   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
12990   ins_cost(250);
12991   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12992   opcode(0x0F,0x40);
12993   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
12994   ins_pipe( pipe_cmov_mem );
12995 %}
12996 
12997 // Compare 2 longs and CMOVE ints.
12998 instruct cmovPP_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegP dst, eRegP src) %{
12999   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13000   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13001   ins_cost(200);
13002   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13003   opcode(0x0F,0x40);
13004   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13005   ins_pipe( pipe_cmov_reg );
13006 %}
13007 
13008 // Compare 2 longs and CMOVE doubles
13009 instruct cmovDDPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regDPR dst, regDPR src) %{
13010   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13011   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13012   ins_cost(200);
13013   expand %{
13014     fcmovDPR_regS(cmp,flags,dst,src);
13015   %}
13016 %}
13017 
13018 // Compare 2 longs and CMOVE doubles
13019 instruct cmovDD_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regD dst, regD src) %{
13020   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13021   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13022   ins_cost(200);
13023   expand %{
13024     fcmovD_regS(cmp,flags,dst,src);
13025   %}
13026 %}
13027 
13028 instruct cmovFFPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regFPR dst, regFPR src) %{
13029   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13030   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13031   ins_cost(200);
13032   expand %{
13033     fcmovFPR_regS(cmp,flags,dst,src);
13034   %}
13035 %}
13036 
13037 instruct cmovFF_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regF dst, regF src) %{
13038   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13039   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13040   ins_cost(200);
13041   expand %{
13042     fcmovF_regS(cmp,flags,dst,src);
13043   %}
13044 %}
13045 
13046 //======
13047 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13048 // Same as cmpL_reg_flags_LEGT except must negate src
13049 instruct cmpL_zero_flags_LEGT( flagsReg_long_LEGT flags, eRegL src, immL0 zero, rRegI tmp ) %{
13050   match( Set flags (CmpL src zero ));
13051   effect( TEMP tmp );
13052   ins_cost(300);
13053   format %{ &quot;XOR    $tmp,$tmp\t# Long compare for -$src &lt; 0, use commuted test\n\t&quot;
13054             &quot;CMP    $tmp,$src.lo\n\t&quot;
13055             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13056   ins_encode( long_cmp_flags3(src, tmp) );
13057   ins_pipe( ialu_reg_reg_long );
13058 %}
13059 
13060 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13061 // Same as cmpL_reg_flags_LTGE except operands swapped.  Swapping operands
13062 // requires a commuted test to get the same result.
13063 instruct cmpL_reg_flags_LEGT( flagsReg_long_LEGT flags, eRegL src1, eRegL src2, rRegI tmp ) %{
13064   match( Set flags (CmpL src1 src2 ));
13065   effect( TEMP tmp );
13066   ins_cost(300);
13067   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Long compare, swapped operands, use with commuted test\n\t&quot;
13068             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13069             &quot;SBB    $tmp,$src1.hi\t! Compute flags for long compare&quot; %}
13070   ins_encode( long_cmp_flags2( src2, src1, tmp ) );
13071   ins_pipe( ialu_cr_reg_reg );
13072 %}
13073 
13074 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
13075 // Just a wrapper for a normal branch, plus the predicate test
13076 instruct cmpL_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, label labl) %{
13077   match(If cmp flags);
13078   effect(USE labl);
13079   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le );
13080   ins_cost(300);
13081   expand %{
13082     jmpCon(cmp,flags,labl);    // JGT or JLE...
13083   %}
13084 %}
13085 
13086 //======
13087 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13088 // Same as cmpUL_reg_flags_LEGT except must negate src
13089 instruct cmpUL_zero_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src, immL0 zero, rRegI tmp) %{
13090   match(Set flags (CmpUL src zero));
13091   effect(TEMP tmp);
13092   ins_cost(300);
13093   format %{ &quot;XOR    $tmp,$tmp\t# Unsigned long compare for -$src &lt; 0, use commuted test\n\t&quot;
13094             &quot;CMP    $tmp,$src.lo\n\t&quot;
13095             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13096   ins_encode(long_cmp_flags3(src, tmp));
13097   ins_pipe(ialu_reg_reg_long);
13098 %}
13099 
13100 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13101 // Same as cmpUL_reg_flags_LTGE except operands swapped.  Swapping operands
13102 // requires a commuted test to get the same result.
13103 instruct cmpUL_reg_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src1, eRegL src2, rRegI tmp) %{
13104   match(Set flags (CmpUL src1 src2));
13105   effect(TEMP tmp);
13106   ins_cost(300);
13107   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Unsigned long compare, swapped operands, use with commuted test\n\t&quot;
13108             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13109             &quot;SBB    $tmp,$src1.hi\t! Compute flags for unsigned long compare&quot; %}
13110   ins_encode(long_cmp_flags2( src2, src1, tmp));
13111   ins_pipe(ialu_cr_reg_reg);
13112 %}
13113 
13114 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
13115 // Just a wrapper for a normal branch, plus the predicate test
13116 instruct cmpUL_LEGT(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, label labl) %{
13117   match(If cmp flags);
13118   effect(USE labl);
13119   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le);
13120   ins_cost(300);
13121   expand %{
13122     jmpCon(cmp, flags, labl);    // JGT or JLE...
13123   %}
13124 %}
13125 
13126 // Compare 2 longs and CMOVE longs.
13127 instruct cmovLL_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, eRegL src) %{
13128   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
13129   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13130   ins_cost(400);
13131   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13132             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
13133   opcode(0x0F,0x40);
13134   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
13135   ins_pipe( pipe_cmov_reg_long );
13136 %}
13137 
13138 instruct cmovLL_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, load_long_memory src) %{
13139   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
13140   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13141   ins_cost(500);
13142   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13143             &quot;CMOV$cmp $dst.hi,$src.hi+4&quot; %}
13144   opcode(0x0F,0x40);
13145   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13146   ins_pipe( pipe_cmov_reg_long );
13147 %}
13148 
13149 // Compare 2 longs and CMOVE ints.
13150 instruct cmovII_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, rRegI src) %{
13151   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13152   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13153   ins_cost(200);
13154   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13155   opcode(0x0F,0x40);
13156   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13157   ins_pipe( pipe_cmov_reg );
13158 %}
13159 
13160 instruct cmovII_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, memory src) %{
13161   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13162   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13163   ins_cost(250);
13164   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13165   opcode(0x0F,0x40);
13166   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13167   ins_pipe( pipe_cmov_mem );
13168 %}
13169 
13170 // Compare 2 longs and CMOVE ptrs.
13171 instruct cmovPP_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegP dst, eRegP src) %{
13172   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13173   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13174   ins_cost(200);
13175   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13176   opcode(0x0F,0x40);
13177   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13178   ins_pipe( pipe_cmov_reg );
13179 %}
13180 
13181 // Compare 2 longs and CMOVE doubles
13182 instruct cmovDDPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regDPR dst, regDPR src) %{
13183   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13184   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13185   ins_cost(200);
13186   expand %{
13187     fcmovDPR_regS(cmp,flags,dst,src);
13188   %}
13189 %}
13190 
13191 // Compare 2 longs and CMOVE doubles
13192 instruct cmovDD_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regD dst, regD src) %{
13193   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13194   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13195   ins_cost(200);
13196   expand %{
13197     fcmovD_regS(cmp,flags,dst,src);
13198   %}
13199 %}
13200 
13201 instruct cmovFFPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regFPR dst, regFPR src) %{
13202   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13203   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13204   ins_cost(200);
13205   expand %{
13206     fcmovFPR_regS(cmp,flags,dst,src);
13207   %}
13208 %}
13209 
13210 
13211 instruct cmovFF_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regF dst, regF src) %{
13212   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13213   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13214   ins_cost(200);
13215   expand %{
13216     fcmovF_regS(cmp,flags,dst,src);
13217   %}
13218 %}
13219 
13220 
13221 // ============================================================================
13222 // Procedure Call/Return Instructions
13223 // Call Java Static Instruction
13224 // Note: If this code changes, the corresponding ret_addr_offset() and
13225 //       compute_padding() functions will have to be adjusted.
13226 instruct CallStaticJavaDirect(method meth) %{
13227   match(CallStaticJava);
13228   effect(USE meth);
13229 
13230   ins_cost(300);
13231   format %{ &quot;CALL,static &quot; %}
13232   opcode(0xE8); /* E8 cd */
13233   ins_encode( pre_call_resets,
13234               Java_Static_Call( meth ),
13235               call_epilog,
13236               post_call_FPU );
13237   ins_pipe( pipe_slow );
13238   ins_alignment(4);
13239 %}
13240 
13241 // Call Java Dynamic Instruction
13242 // Note: If this code changes, the corresponding ret_addr_offset() and
13243 //       compute_padding() functions will have to be adjusted.
13244 instruct CallDynamicJavaDirect(method meth) %{
13245   match(CallDynamicJava);
13246   effect(USE meth);
13247 
13248   ins_cost(300);
13249   format %{ &quot;MOV    EAX,(oop)-1\n\t&quot;
13250             &quot;CALL,dynamic&quot; %}
13251   opcode(0xE8); /* E8 cd */
13252   ins_encode( pre_call_resets,
13253               Java_Dynamic_Call( meth ),
13254               call_epilog,
13255               post_call_FPU );
13256   ins_pipe( pipe_slow );
13257   ins_alignment(4);
13258 %}
13259 
13260 // Call Runtime Instruction
13261 instruct CallRuntimeDirect(method meth) %{
13262   match(CallRuntime );
13263   effect(USE meth);
13264 
13265   ins_cost(300);
13266   format %{ &quot;CALL,runtime &quot; %}
13267   opcode(0xE8); /* E8 cd */
13268   // Use FFREEs to clear entries in float stack
13269   ins_encode( pre_call_resets,
13270               FFree_Float_Stack_All,
13271               Java_To_Runtime( meth ),
13272               post_call_FPU );
13273   ins_pipe( pipe_slow );
13274 %}
13275 
13276 // Call runtime without safepoint
13277 instruct CallLeafDirect(method meth) %{
13278   match(CallLeaf);
13279   effect(USE meth);
13280 
13281   ins_cost(300);
13282   format %{ &quot;CALL_LEAF,runtime &quot; %}
13283   opcode(0xE8); /* E8 cd */
13284   ins_encode( pre_call_resets,
13285               FFree_Float_Stack_All,
13286               Java_To_Runtime( meth ),
13287               Verify_FPU_For_Leaf, post_call_FPU );
13288   ins_pipe( pipe_slow );
13289 %}
13290 
13291 instruct CallLeafNoFPDirect(method meth) %{
13292   match(CallLeafNoFP);
13293   effect(USE meth);
13294 
13295   ins_cost(300);
13296   format %{ &quot;CALL_LEAF_NOFP,runtime &quot; %}
13297   opcode(0xE8); /* E8 cd */
13298   ins_encode(pre_call_resets, Java_To_Runtime(meth));
13299   ins_pipe( pipe_slow );
13300 %}
13301 
13302 
13303 // Return Instruction
13304 // Remove the return address &amp; jump to it.
13305 instruct Ret() %{
13306   match(Return);
13307   format %{ &quot;RET&quot; %}
13308   opcode(0xC3);
13309   ins_encode(OpcP);
13310   ins_pipe( pipe_jmp );
13311 %}
13312 
13313 // Tail Call; Jump from runtime stub to Java code.
13314 // Also known as an &#39;interprocedural jump&#39;.
13315 // Target of jump will eventually return to caller.
13316 // TailJump below removes the return address.
13317 instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_oop) %{
13318   match(TailCall jump_target method_oop );
13319   ins_cost(300);
13320   format %{ &quot;JMP    $jump_target \t# EBX holds method oop&quot; %}
13321   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13322   ins_encode( OpcP, RegOpc(jump_target) );
13323   ins_pipe( pipe_jmp );
13324 %}
13325 
13326 
13327 // Tail Jump; remove the return address; jump to target.
13328 // TailCall above leaves the return address around.
13329 instruct tailjmpInd(eRegP_no_EBP jump_target, eAXRegP ex_oop) %{
13330   match( TailJump jump_target ex_oop );
13331   ins_cost(300);
13332   format %{ &quot;POP    EDX\t# pop return address into dummy\n\t&quot;
13333             &quot;JMP    $jump_target &quot; %}
13334   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13335   ins_encode( enc_pop_rdx,
13336               OpcP, RegOpc(jump_target) );
13337   ins_pipe( pipe_jmp );
13338 %}
13339 
13340 // Create exception oop: created by stack-crawling runtime code.
13341 // Created exception is now available to this handler, and is setup
13342 // just prior to jumping to this handler.  No code emitted.
13343 instruct CreateException( eAXRegP ex_oop )
13344 %{
13345   match(Set ex_oop (CreateEx));
13346 
13347   size(0);
13348   // use the following format syntax
13349   format %{ &quot;# exception oop is in EAX; no code emitted&quot; %}
13350   ins_encode();
13351   ins_pipe( empty );
13352 %}
13353 
13354 
13355 // Rethrow exception:
13356 // The exception oop will come in the first argument position.
13357 // Then JUMP (not call) to the rethrow stub code.
13358 instruct RethrowException()
13359 %{
13360   match(Rethrow);
13361 
13362   // use the following format syntax
13363   format %{ &quot;JMP    rethrow_stub&quot; %}
13364   ins_encode(enc_rethrow);
13365   ins_pipe( pipe_jmp );
13366 %}
13367 
13368 // inlined locking and unlocking
13369 
13370 instruct cmpFastLockRTM(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eDXRegI scr, rRegI cx1, rRegI cx2) %{
13371   predicate(Compile::current()-&gt;use_rtm());
13372   match(Set cr (FastLock object box));
13373   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
13374   ins_cost(300);
13375   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
13376   ins_encode %{
13377     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13378                  $scr$$Register, $cx1$$Register, $cx2$$Register,
13379                  _counters, _rtm_counters, _stack_rtm_counters,
13380                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
13381                  true, ra_-&gt;C-&gt;profile_rtm());
13382   %}
13383   ins_pipe(pipe_slow);
13384 %}
13385 
13386 instruct cmpFastLock(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eRegP scr) %{
13387   predicate(!Compile::current()-&gt;use_rtm());
13388   match(Set cr (FastLock object box));
13389   effect(TEMP tmp, TEMP scr, USE_KILL box);
13390   ins_cost(300);
13391   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr&quot; %}
13392   ins_encode %{
13393     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13394                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13395   %}
13396   ins_pipe(pipe_slow);
13397 %}
13398 
13399 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13400   match(Set cr (FastUnlock object box));
13401   effect(TEMP tmp, USE_KILL box);
13402   ins_cost(300);
13403   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13404   ins_encode %{
13405     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13406   %}
13407   ins_pipe(pipe_slow);
13408 %}
13409 
13410 
13411 
13412 // ============================================================================
13413 // Safepoint Instruction
13414 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{
13415   match(SafePoint poll);
13416   effect(KILL cr, USE poll);
13417 
13418   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13419   ins_cost(125);
13420   // EBP would need size(3)
13421   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13422   ins_encode %{
13423     __ relocate(relocInfo::poll_type);
13424     address pre_pc = __ pc();
13425     __ testl(rax, Address($poll$$Register, 0));
13426     address post_pc = __ pc();
13427     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13428   %}
13429   ins_pipe(ialu_reg_mem);
13430 %}
13431 
13432 
13433 // ============================================================================
13434 // This name is KNOWN by the ADLC and cannot be changed.
13435 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
13436 // for this guy.
13437 instruct tlsLoadP(eRegP dst, eFlagsReg cr) %{
13438   match(Set dst (ThreadLocal));
13439   effect(DEF dst, KILL cr);
13440 
13441   format %{ &quot;MOV    $dst, Thread::current()&quot; %}
13442   ins_encode %{
13443     Register dstReg = as_Register($dst$$reg);
13444     __ get_thread(dstReg);
13445   %}
13446   ins_pipe( ialu_reg_fat );
13447 %}
13448 
13449 
13450 
13451 //----------PEEPHOLE RULES-----------------------------------------------------
13452 // These must follow all instruction definitions as they use the names
13453 // defined in the instructions definitions.
13454 //
13455 // peepmatch ( root_instr_name [preceding_instruction]* );
13456 //
13457 // peepconstraint %{
13458 // (instruction_number.operand_name relational_op instruction_number.operand_name
13459 //  [, ...] );
13460 // // instruction numbers are zero-based using left to right order in peepmatch
13461 //
13462 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
13463 // // provide an instruction_number.operand_name for each operand that appears
13464 // // in the replacement instruction&#39;s match rule
13465 //
13466 // ---------VM FLAGS---------------------------------------------------------
13467 //
13468 // All peephole optimizations can be turned off using -XX:-OptoPeephole
13469 //
13470 // Each peephole rule is given an identifying number starting with zero and
13471 // increasing by one in the order seen by the parser.  An individual peephole
13472 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
13473 // on the command-line.
13474 //
13475 // ---------CURRENT LIMITATIONS----------------------------------------------
13476 //
13477 // Only match adjacent instructions in same basic block
13478 // Only equality constraints
13479 // Only constraints between operands, not (0.dest_reg == EAX_enc)
13480 // Only one replacement instruction
13481 //
13482 // ---------EXAMPLE----------------------------------------------------------
13483 //
13484 // // pertinent parts of existing instructions in architecture description
13485 // instruct movI(rRegI dst, rRegI src) %{
13486 //   match(Set dst (CopyI src));
13487 // %}
13488 //
13489 // instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
13490 //   match(Set dst (AddI dst src));
13491 //   effect(KILL cr);
13492 // %}
13493 //
13494 // // Change (inc mov) to lea
13495 // peephole %{
13496 //   // increment preceeded by register-register move
13497 //   peepmatch ( incI_eReg movI );
13498 //   // require that the destination register of the increment
13499 //   // match the destination register of the move
13500 //   peepconstraint ( 0.dst == 1.dst );
13501 //   // construct a replacement instruction that sets
13502 //   // the destination to ( move&#39;s source register + one )
13503 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13504 // %}
13505 //
13506 // Implementation no longer uses movX instructions since
13507 // machine-independent system no longer uses CopyX nodes.
13508 //
13509 // peephole %{
13510 //   peepmatch ( incI_eReg movI );
13511 //   peepconstraint ( 0.dst == 1.dst );
13512 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13513 // %}
13514 //
13515 // peephole %{
13516 //   peepmatch ( decI_eReg movI );
13517 //   peepconstraint ( 0.dst == 1.dst );
13518 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13519 // %}
13520 //
13521 // peephole %{
13522 //   peepmatch ( addI_eReg_imm movI );
13523 //   peepconstraint ( 0.dst == 1.dst );
13524 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13525 // %}
13526 //
13527 // peephole %{
13528 //   peepmatch ( addP_eReg_imm movP );
13529 //   peepconstraint ( 0.dst == 1.dst );
13530 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
13531 // %}
13532 
13533 // // Change load of spilled value to only a spill
13534 // instruct storeI(memory mem, rRegI src) %{
13535 //   match(Set mem (StoreI mem src));
13536 // %}
13537 //
13538 // instruct loadI(rRegI dst, memory mem) %{
13539 //   match(Set dst (LoadI mem));
13540 // %}
13541 //
13542 peephole %{
13543   peepmatch ( loadI storeI );
13544   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13545   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
13546 %}
13547 
13548 //----------SMARTSPILL RULES---------------------------------------------------
13549 // These must follow all instruction definitions as they use the names
13550 // defined in the instructions definitions.
    </pre>
  </body>
</html>
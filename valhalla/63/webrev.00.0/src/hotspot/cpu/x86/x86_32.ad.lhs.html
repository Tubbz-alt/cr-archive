<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // X86 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // architecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // Previously set EBX, ESI, and EDI as save-on-entry for java code
   64 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   65 // Now that allocator is better, turn on ESI and EDI as SOE registers.
   66 
   67 reg_def EBX(SOC, SOE, Op_RegI, 3, rbx-&gt;as_VMReg());
   68 reg_def ECX(SOC, SOC, Op_RegI, 1, rcx-&gt;as_VMReg());
   69 reg_def ESI(SOC, SOE, Op_RegI, 6, rsi-&gt;as_VMReg());
   70 reg_def EDI(SOC, SOE, Op_RegI, 7, rdi-&gt;as_VMReg());
   71 // now that adapter frames are gone EBP is always saved and restored by the prolog/epilog code
   72 reg_def EBP(NS, SOE, Op_RegI, 5, rbp-&gt;as_VMReg());
   73 reg_def EDX(SOC, SOC, Op_RegI, 2, rdx-&gt;as_VMReg());
   74 reg_def EAX(SOC, SOC, Op_RegI, 0, rax-&gt;as_VMReg());
   75 reg_def ESP( NS,  NS, Op_RegI, 4, rsp-&gt;as_VMReg());
   76 
   77 // Float registers.  We treat TOS/FPR0 special.  It is invisible to the
   78 // allocator, and only shows up in the encodings.
   79 reg_def FPR0L( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   80 reg_def FPR0H( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   81 // Ok so here&#39;s the trick FPR1 is really st(0) except in the midst
   82 // of emission of assembly for a machnode. During the emission the fpu stack
   83 // is pushed making FPR1 == st(1) temporarily. However at any safepoint
   84 // the stack will not have this element so FPR1 == st(0) from the
   85 // oopMap viewpoint. This same weirdness with numbering causes
   86 // instruction encoding to have to play games with the register
   87 // encode to correct for this 0/1 issue. See MachSpillCopyNode::implementation
   88 // where it does flt-&gt;flt moves to see an example
   89 //
   90 reg_def FPR1L( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg());
   91 reg_def FPR1H( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg()-&gt;next());
   92 reg_def FPR2L( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg());
   93 reg_def FPR2H( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg()-&gt;next());
   94 reg_def FPR3L( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg());
   95 reg_def FPR3H( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg()-&gt;next());
   96 reg_def FPR4L( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg());
   97 reg_def FPR4H( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg()-&gt;next());
   98 reg_def FPR5L( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg());
   99 reg_def FPR5H( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg()-&gt;next());
  100 reg_def FPR6L( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg());
  101 reg_def FPR6H( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg()-&gt;next());
  102 reg_def FPR7L( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg());
  103 reg_def FPR7H( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg()-&gt;next());
  104 //
  105 // Empty fill registers, which are never used, but supply alignment to xmm regs
  106 //
  107 reg_def FILL0( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());
  108 reg_def FILL1( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());
  109 reg_def FILL2( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());
  110 reg_def FILL3( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());
  111 reg_def FILL4( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());
  112 reg_def FILL5( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());
  113 reg_def FILL6( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());
  114 reg_def FILL7( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());
  115 
  116 // Specify priority of register selection within phases of register
  117 // allocation.  Highest priority is first.  A useful heuristic is to
  118 // give registers a low priority when they are required by machine
  119 // instructions, like EAX and EDX.  Registers which are used as
  120 // pairs must fall on an even boundary (witness the FPR#L&#39;s in this list).
  121 // For the Intel integer registers, the equivalent Long pairs are
  122 // EDX:EAX, EBX:ECX, and EDI:EBP.
  123 alloc_class chunk0( ECX,   EBX,   EBP,   EDI,   EAX,   EDX,   ESI, ESP,
  124                     FPR0L, FPR0H, FPR1L, FPR1H, FPR2L, FPR2H,
  125                     FPR3L, FPR3H, FPR4L, FPR4H, FPR5L, FPR5H,
  126                     FPR6L, FPR6H, FPR7L, FPR7H,
  127                     FILL0, FILL1, FILL2, FILL3, FILL4, FILL5, FILL6, FILL7);
  128 
  129 
  130 //----------Architecture Description Register Classes--------------------------
  131 // Several register classes are automatically defined based upon information in
  132 // this architecture description.
  133 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  134 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  135 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  136 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  137 //
  138 // Class for no registers (empty set).
  139 reg_class no_reg();
  140 
  141 // Class for all registers
  142 reg_class any_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX, ESP);
  143 // Class for all registers (excluding EBP)
  144 reg_class any_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX, ESP);
  145 // Dynamic register class that selects at runtime between register classes
  146 // any_reg and any_no_ebp_reg (depending on the value of the flag PreserveFramePointer).
  147 // Equivalent to: return PreserveFramePointer ? any_no_ebp_reg : any_reg;
  148 reg_class_dynamic any_reg(any_reg_no_ebp, any_reg_with_ebp, %{ PreserveFramePointer %});
  149 
  150 // Class for general registers
  151 reg_class int_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX);
  152 // Class for general registers (excluding EBP).
  153 // This register class can be used for implicit null checks on win95.
  154 // It is also safe for use by tailjumps (we don&#39;t want to allocate in ebp).
  155 // Used also if the PreserveFramePointer flag is true.
  156 reg_class int_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX);
  157 // Dynamic register class that selects between int_reg and int_reg_no_ebp.
  158 reg_class_dynamic int_reg(int_reg_no_ebp, int_reg_with_ebp, %{ PreserveFramePointer %});
  159 
  160 // Class of &quot;X&quot; registers
  161 reg_class int_x_reg(EBX, ECX, EDX, EAX);
  162 
  163 // Class of registers that can appear in an address with no offset.
  164 // EBP and ESP require an extra instruction byte for zero offset.
  165 // Used in fast-unlock
  166 reg_class p_reg(EDX, EDI, ESI, EBX);
  167 
  168 // Class for general registers excluding ECX
  169 reg_class ncx_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, EBX);
  170 // Class for general registers excluding ECX (and EBP)
  171 reg_class ncx_reg_no_ebp(EAX, EDX, EDI, ESI, EBX);
  172 // Dynamic register class that selects between ncx_reg and ncx_reg_no_ebp.
  173 reg_class_dynamic ncx_reg(ncx_reg_no_ebp, ncx_reg_with_ebp, %{ PreserveFramePointer %});
  174 
  175 // Class for general registers excluding EAX
  176 reg_class nax_reg(EDX, EDI, ESI, ECX, EBX);
  177 
  178 // Class for general registers excluding EAX and EBX.
  179 reg_class nabx_reg_with_ebp(EDX, EDI, ESI, ECX, EBP);
  180 // Class for general registers excluding EAX and EBX (and EBP)
  181 reg_class nabx_reg_no_ebp(EDX, EDI, ESI, ECX);
  182 // Dynamic register class that selects between nabx_reg and nabx_reg_no_ebp.
  183 reg_class_dynamic nabx_reg(nabx_reg_no_ebp, nabx_reg_with_ebp, %{ PreserveFramePointer %});
  184 
  185 // Class of EAX (for multiply and divide operations)
  186 reg_class eax_reg(EAX);
  187 
  188 // Class of EBX (for atomic add)
  189 reg_class ebx_reg(EBX);
  190 
  191 // Class of ECX (for shift and JCXZ operations and cmpLTMask)
  192 reg_class ecx_reg(ECX);
  193 
  194 // Class of EDX (for multiply and divide operations)
  195 reg_class edx_reg(EDX);
  196 
  197 // Class of EDI (for synchronization)
  198 reg_class edi_reg(EDI);
  199 
  200 // Class of ESI (for synchronization)
  201 reg_class esi_reg(ESI);
  202 
  203 // Singleton class for stack pointer
  204 reg_class sp_reg(ESP);
  205 
  206 // Singleton class for instruction pointer
  207 // reg_class ip_reg(EIP);
  208 
  209 // Class of integer register pairs
  210 reg_class long_reg_with_ebp( EAX,EDX, ECX,EBX, EBP,EDI );
  211 // Class of integer register pairs (excluding EBP and EDI);
  212 reg_class long_reg_no_ebp( EAX,EDX, ECX,EBX );
  213 // Dynamic register class that selects between long_reg and long_reg_no_ebp.
  214 reg_class_dynamic long_reg(long_reg_no_ebp, long_reg_with_ebp, %{ PreserveFramePointer %});
  215 
  216 // Class of integer register pairs that aligns with calling convention
  217 reg_class eadx_reg( EAX,EDX );
  218 reg_class ebcx_reg( ECX,EBX );
  219 
  220 // Not AX or DX, used in divides
  221 reg_class nadx_reg_with_ebp(EBX, ECX, ESI, EDI, EBP);
  222 // Not AX or DX (and neither EBP), used in divides
  223 reg_class nadx_reg_no_ebp(EBX, ECX, ESI, EDI);
  224 // Dynamic register class that selects between nadx_reg and nadx_reg_no_ebp.
  225 reg_class_dynamic nadx_reg(nadx_reg_no_ebp, nadx_reg_with_ebp, %{ PreserveFramePointer %});
  226 
  227 // Floating point registers.  Notice FPR0 is not a choice.
  228 // FPR0 is not ever allocated; we use clever encodings to fake
  229 // a 2-address instructions out of Intels FP stack.
  230 reg_class fp_flt_reg( FPR1L,FPR2L,FPR3L,FPR4L,FPR5L,FPR6L,FPR7L );
  231 
  232 reg_class fp_dbl_reg( FPR1L,FPR1H, FPR2L,FPR2H, FPR3L,FPR3H,
  233                       FPR4L,FPR4H, FPR5L,FPR5H, FPR6L,FPR6H,
  234                       FPR7L,FPR7H );
  235 
  236 reg_class fp_flt_reg0( FPR1L );
  237 reg_class fp_dbl_reg0( FPR1L,FPR1H );
  238 reg_class fp_dbl_reg1( FPR2L,FPR2H );
  239 reg_class fp_dbl_notreg0( FPR2L,FPR2H, FPR3L,FPR3H, FPR4L,FPR4H,
  240                           FPR5L,FPR5H, FPR6L,FPR6H, FPR7L,FPR7H );
  241 
  242 %}
  243 
  244 
  245 //----------SOURCE BLOCK-------------------------------------------------------
  246 // This is a block of C++ code which provides values, functions, and
  247 // definitions necessary in the rest of the architecture description
  248 source_hpp %{
  249 // Must be visible to the DFA in dfa_x86_32.cpp
  250 extern bool is_operand_hi32_zero(Node* n);
  251 %}
  252 
  253 source %{
  254 #define   RELOC_IMM32    Assembler::imm_operand
  255 #define   RELOC_DISP32   Assembler::disp32_operand
  256 
  257 #define __ _masm.
  258 
  259 // How to find the high register of a Long pair, given the low register
  260 #define   HIGH_FROM_LOW(x) ((x)+2)
  261 
  262 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  263 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  264 // fast versions of NegF/NegD and AbsF/AbsD.
  265 
  266 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  267 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  268   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  269   // of 128-bits operands for SSE instructions.
  270   jlong *operand = (jlong*)(((uintptr_t)adr)&amp;((uintptr_t)(~0xF)));
  271   // Store the value to a 128-bits operand.
  272   operand[0] = lo;
  273   operand[1] = hi;
  274   return operand;
  275 }
  276 
  277 // Buffer for 128-bits masks used by SSE instructions.
  278 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  279 
  280 // Static initialization during VM startup.
  281 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2], CONST64(0x7FFFFFFF7FFFFFFF), CONST64(0x7FFFFFFF7FFFFFFF));
  282 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2], CONST64(0x7FFFFFFFFFFFFFFF), CONST64(0x7FFFFFFFFFFFFFFF));
  283 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], CONST64(0x8000000080000000), CONST64(0x8000000080000000));
  284 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
  285 
  286 // Offset hacking within calls.
  287 static int pre_call_resets_size() {
  288   int size = 0;
  289   Compile* C = Compile::current();
  290   if (C-&gt;in_24_bit_fp_mode()) {
  291     size += 6; // fldcw
  292   }
  293   if (VM_Version::supports_vzeroupper()) {
  294     size += 3; // vzeroupper
  295   }
  296   return size;
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 
  317 //
  318 // Compute padding required for nodes which need alignment
  319 //
  320 
  321 // The address of the call instruction needs to be 4-byte aligned to
  322 // ensure that it does not span a cache line so that it can be patched.
  323 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  324   current_offset += pre_call_resets_size();  // skip fldcw, if any
  325   current_offset += 1;      // skip call opcode byte
  326   return align_up(current_offset, alignment_required()) - current_offset;
  327 }
  328 
  329 // The address of the call instruction needs to be 4-byte aligned to
  330 // ensure that it does not span a cache line so that it can be patched.
  331 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  332   current_offset += pre_call_resets_size();  // skip fldcw, if any
  333   current_offset += 5;      // skip MOV instruction
  334   current_offset += 1;      // skip call opcode byte
  335   return align_up(current_offset, alignment_required()) - current_offset;
  336 }
  337 
  338 // EMIT_RM()
  339 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  340   unsigned char c = (unsigned char)((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  341   cbuf.insts()-&gt;emit_int8(c);
  342 }
  343 
  344 // EMIT_CC()
  345 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  346   unsigned char c = (unsigned char)( f1 | f2 );
  347   cbuf.insts()-&gt;emit_int8(c);
  348 }
  349 
  350 // EMIT_OPCODE()
  351 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  352   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  353 }
  354 
  355 // EMIT_OPCODE() w/ relocation information
  356 void emit_opcode(CodeBuffer &amp;cbuf, int code, relocInfo::relocType reloc, int offset = 0) {
  357   cbuf.relocate(cbuf.insts_mark() + offset, reloc);
  358   emit_opcode(cbuf, code);
  359 }
  360 
  361 // EMIT_D8()
  362 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  363   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  364 }
  365 
  366 // EMIT_D16()
  367 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  368   cbuf.insts()-&gt;emit_int16(d16);
  369 }
  370 
  371 // EMIT_D32()
  372 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  373   cbuf.insts()-&gt;emit_int32(d32);
  374 }
  375 
  376 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  377 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, relocInfo::relocType reloc,
  378         int format) {
  379   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  380   cbuf.insts()-&gt;emit_int32(d32);
  381 }
  382 
  383 // emit 32 bit value and construct relocation entry from RelocationHolder
  384 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, RelocationHolder const&amp; rspec,
  385         int format) {
  386 #ifdef ASSERT
  387   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp; d32 != 0 &amp;&amp; d32 != (int)Universe::non_oop_word()) {
  388     assert(oopDesc::is_oop(cast_to_oop(d32)), &quot;cannot embed broken oops in code&quot;);
  389   }
  390 #endif
  391   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  392   cbuf.insts()-&gt;emit_int32(d32);
  393 }
  394 
  395 // Access stack slot for load or store
  396 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp) {
  397   emit_opcode( cbuf, opcode );               // (e.g., FILD   [ESP+src])
  398   if( -128 &lt;= disp &amp;&amp; disp &lt;= 127 ) {
  399     emit_rm( cbuf, 0x01, rm_field, ESP_enc );  // R/M byte
  400     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  401     emit_d8 (cbuf, disp);     // Displacement  // R/M byte
  402   } else {
  403     emit_rm( cbuf, 0x02, rm_field, ESP_enc );  // R/M byte
  404     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  405     emit_d32(cbuf, disp);     // Displacement  // R/M byte
  406   }
  407 }
  408 
  409    // rRegI ereg, memory mem) %{    // emit_reg_mem
  410 void encode_RegMem( CodeBuffer &amp;cbuf, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {
  411   // There is no index &amp; no scale, use form without SIB byte
  412   if ((index == 0x4) &amp;&amp;
  413       (scale == 0) &amp;&amp; (base != ESP_enc)) {
  414     // If no displacement, mode is 0x0; unless base is [EBP]
  415     if ( (displace == 0) &amp;&amp; (base != EBP_enc) ) {
  416       emit_rm(cbuf, 0x0, reg_encoding, base);
  417     }
  418     else {                    // If 8-bit displacement, mode 0x1
  419       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  420           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  421         emit_rm(cbuf, 0x1, reg_encoding, base);
  422         emit_d8(cbuf, displace);
  423       }
  424       else {                  // If 32-bit displacement
  425         if (base == -1) { // Special flag for absolute address
  426           emit_rm(cbuf, 0x0, reg_encoding, 0x5);
  427           // (manual lies; no SIB needed here)
  428           if ( disp_reloc != relocInfo::none ) {
  429             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  430           } else {
  431             emit_d32      (cbuf, displace);
  432           }
  433         }
  434         else {                // Normal base + offset
  435           emit_rm(cbuf, 0x2, reg_encoding, base);
  436           if ( disp_reloc != relocInfo::none ) {
  437             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  438           } else {
  439             emit_d32      (cbuf, displace);
  440           }
  441         }
  442       }
  443     }
  444   }
  445   else {                      // Else, encode with the SIB byte
  446     // If no displacement, mode is 0x0; unless base is [EBP]
  447     if (displace == 0 &amp;&amp; (base != EBP_enc)) {  // If no displacement
  448       emit_rm(cbuf, 0x0, reg_encoding, 0x4);
  449       emit_rm(cbuf, scale, index, base);
  450     }
  451     else {                    // If 8-bit displacement, mode 0x1
  452       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  453           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  454         emit_rm(cbuf, 0x1, reg_encoding, 0x4);
  455         emit_rm(cbuf, scale, index, base);
  456         emit_d8(cbuf, displace);
  457       }
  458       else {                  // If 32-bit displacement
  459         if (base == 0x04 ) {
  460           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  461           emit_rm(cbuf, scale, index, 0x04);
  462         } else {
  463           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  464           emit_rm(cbuf, scale, index, base);
  465         }
  466         if ( disp_reloc != relocInfo::none ) {
  467           emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  468         } else {
  469           emit_d32      (cbuf, displace);
  470         }
  471       }
  472     }
  473   }
  474 }
  475 
  476 
  477 void encode_Copy( CodeBuffer &amp;cbuf, int dst_encoding, int src_encoding ) {
  478   if( dst_encoding == src_encoding ) {
  479     // reg-reg copy, use an empty encoding
  480   } else {
  481     emit_opcode( cbuf, 0x8B );
  482     emit_rm(cbuf, 0x3, dst_encoding, src_encoding );
  483   }
  484 }
  485 
  486 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  487   Label exit;
  488   __ jccb(Assembler::noParity, exit);
  489   __ pushf();
  490   //
  491   // comiss/ucomiss instructions set ZF,PF,CF flags and
  492   // zero OF,AF,SF for NaN values.
  493   // Fixup flags by zeroing ZF,PF so that compare of NaN
  494   // values returns &#39;less than&#39; result (CF is set).
  495   // Leave the rest of flags unchanged.
  496   //
  497   //    7 6 5 4 3 2 1 0
  498   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  499   //    0 0 1 0 1 0 1 1   (0x2B)
  500   //
  501   __ andl(Address(rsp, 0), 0xffffff2b);
  502   __ popf();
  503   __ bind(exit);
  504 }
  505 
  506 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  507   Label done;
  508   __ movl(dst, -1);
  509   __ jcc(Assembler::parity, done);
  510   __ jcc(Assembler::below, done);
  511   __ setb(Assembler::notEqual, dst);
  512   __ movzbl(dst, dst);
  513   __ bind(done);
  514 }
  515 
  516 
  517 //=============================================================================
  518 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  519 
  520 int ConstantTable::calculate_table_base_offset() const {
  521   return 0;  // absolute addressing, no offset
  522 }
  523 
  524 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  525 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  526   ShouldNotReachHere();
  527 }
  528 
  529 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  530   // Empty encoding
  531 }
  532 
  533 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  534   return 0;
  535 }
  536 
  537 #ifndef PRODUCT
  538 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  539   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  540 }
  541 #endif
  542 
  543 
  544 //=============================================================================
  545 #ifndef PRODUCT
  546 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  547   Compile* C = ra_-&gt;C;
  548 
  549   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  550   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  551   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  552   // Remove wordSize for return addr which is already pushed.
  553   framesize -= wordSize;
  554 
  555   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  556     framesize -= wordSize;
  557     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  558     st-&gt;print(&quot;\n\t&quot;);
  559     st-&gt;print(&quot;PUSH   EBP\t# Save EBP&quot;);
  560     if (PreserveFramePointer) {
  561       st-&gt;print(&quot;\n\t&quot;);
  562       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  563     }
  564     if (framesize) {
  565       st-&gt;print(&quot;\n\t&quot;);
  566       st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  567     }
  568   } else {
  569     st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  570     st-&gt;print(&quot;\n\t&quot;);
  571     framesize -= wordSize;
  572     st-&gt;print(&quot;MOV    [ESP + #%d], EBP\t# Save EBP&quot;,framesize);
  573     if (PreserveFramePointer) {
  574       st-&gt;print(&quot;\n\t&quot;);
  575       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  576       if (framesize &gt; 0) {
  577         st-&gt;print(&quot;\n\t&quot;);
  578         st-&gt;print(&quot;ADD    EBP, #%d&quot;, framesize);
  579       }
  580     }
  581   }
  582 
  583   if (VerifyStackAtCalls) {
  584     st-&gt;print(&quot;\n\t&quot;);
  585     framesize -= wordSize;
  586     st-&gt;print(&quot;MOV    [ESP + #%d], 0xBADB100D\t# Majik cookie for stack depth check&quot;,framesize);
  587   }
  588 
  589   if( C-&gt;in_24_bit_fp_mode() ) {
  590     st-&gt;print(&quot;\n\t&quot;);
  591     st-&gt;print(&quot;FLDCW  \t# load 24 bit fpu control word&quot;);
  592   }
  593   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
  594     st-&gt;print(&quot;\n\t&quot;);
  595     st-&gt;print(&quot;# verify FPU stack (must be clean on entry)&quot;);
  596   }
  597 
  598 #ifdef ASSERT
  599   if (VerifyStackAtCalls) {
  600     st-&gt;print(&quot;\n\t&quot;);
  601     st-&gt;print(&quot;# stack alignment check&quot;);
  602   }
  603 #endif
  604   st-&gt;cr();
  605 }
  606 #endif
  607 
  608 
  609 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  610   Compile* C = ra_-&gt;C;
  611   MacroAssembler _masm(&amp;cbuf);
  612 
  613   __ verified_entry(C);
  614 
  615   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  616 
  617   if (C-&gt;has_mach_constant_base_node()) {
  618     // NOTE: We set the table base offset here because users might be
  619     // emitted before MachConstantBaseNode.
  620     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  621     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  622   }
  623 }
  624 
  625 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  626   return MachNode::size(ra_); // too many variables; just compute it the hard way
  627 }
  628 
  629 int MachPrologNode::reloc() const {
  630   return 0; // a large enough number
  631 }
  632 
  633 //=============================================================================
  634 #ifndef PRODUCT
  635 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  636   Compile *C = ra_-&gt;C;
  637   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  638   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  639   // Remove two words for return addr and rbp,
  640   framesize -= 2*wordSize;
  641 
  642   if (C-&gt;max_vector_size() &gt; 16) {
  643     st-&gt;print(&quot;VZEROUPPER&quot;);
  644     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  645   }
  646   if (C-&gt;in_24_bit_fp_mode()) {
  647     st-&gt;print(&quot;FLDCW  standard control word&quot;);
  648     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  649   }
  650   if (framesize) {
  651     st-&gt;print(&quot;ADD    ESP,%d\t# Destroy frame&quot;,framesize);
  652     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  653   }
  654   st-&gt;print_cr(&quot;POPL   EBP&quot;); st-&gt;print(&quot;\t&quot;);
  655   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  656     st-&gt;print(&quot;TEST   PollPage,EAX\t! Poll Safepoint&quot;);
  657     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  658   }
  659 }
  660 #endif
  661 
  662 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  663   Compile *C = ra_-&gt;C;
  664   MacroAssembler _masm(&amp;cbuf);
  665 
  666   if (C-&gt;max_vector_size() &gt; 16) {
  667     // Clear upper bits of YMM registers when current compiled code uses
  668     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  669     _masm.vzeroupper();
  670   }
  671   // If method set FPU control word, restore to standard control word
  672   if (C-&gt;in_24_bit_fp_mode()) {
  673     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
  674   }
  675 
  676   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  677   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  678   // Remove two words for return addr and rbp,
  679   framesize -= 2*wordSize;
  680 
  681   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  682 
  683   if (framesize &gt;= 128) {
  684     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  685     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  686     emit_d32(cbuf, framesize);
  687   } else if (framesize) {
  688     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  689     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  690     emit_d8(cbuf, framesize);
  691   }
  692 
  693   emit_opcode(cbuf, 0x58 | EBP_enc);
  694 
  695   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  696     __ reserved_stack_check();
  697   }
  698 
  699   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  700     Register pollReg = as_Register(EBX_enc);
  701     MacroAssembler masm(&amp;cbuf);
  702     masm.get_thread(pollReg);
  703     masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));
  704     masm.relocate(relocInfo::poll_return_type);
  705     masm.testl(rax, Address(pollReg, 0));
  706   }
  707 }
  708 
  709 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  710   return MachNode::size(ra_); // too many variables; just compute it
  711                               // the hard way
  712 }
  713 
  714 int MachEpilogNode::reloc() const {
  715   return 0; // a large enough number
  716 }
  717 
  718 const Pipeline * MachEpilogNode::pipeline() const {
  719   return MachNode::pipeline_class();
  720 }
  721 
  722 //=============================================================================
  723 
  724 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  725 static enum RC rc_class( OptoReg::Name reg ) {
  726 
  727   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  728   if (OptoReg::is_stack(reg)) return rc_stack;
  729 
  730   VMReg r = OptoReg::as_VMReg(reg);
  731   if (r-&gt;is_Register()) return rc_int;
  732   if (r-&gt;is_FloatRegister()) {
  733     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  734     return rc_float;
  735   }
  736   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  737   return rc_xmm;
  738 }
  739 
  740 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  741                         int opcode, const char *op_str, int size, outputStream* st ) {
  742   if( cbuf ) {
  743     emit_opcode  (*cbuf, opcode );
  744     encode_RegMem(*cbuf, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);
  745 #ifndef PRODUCT
  746   } else if( !do_size ) {
  747     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  748     if( opcode == 0x8B || opcode == 0x89 ) { // MOV
  749       if( is_load ) st-&gt;print(&quot;%s   %s,[ESP + #%d]&quot;,op_str,Matcher::regName[reg],offset);
  750       else          st-&gt;print(&quot;%s   [ESP + #%d],%s&quot;,op_str,offset,Matcher::regName[reg]);
  751     } else { // FLD, FST, PUSH, POP
  752       st-&gt;print(&quot;%s [ESP + #%d]&quot;,op_str,offset);
  753     }
  754 #endif
  755   }
  756   int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  757   return size+3+offset_size;
  758 }
  759 
  760 // Helper for XMM registers.  Extra opcode bits, limited syntax.
  761 static int impl_x_helper( CodeBuffer *cbuf, bool do_size, bool is_load,
  762                          int offset, int reg_lo, int reg_hi, int size, outputStream* st ) {
  763   int in_size_in_bits = Assembler::EVEX_32bit;
  764   int evex_encoding = 0;
  765   if (reg_lo+1 == reg_hi) {
  766     in_size_in_bits = Assembler::EVEX_64bit;
  767     evex_encoding = Assembler::VEX_W;
  768   }
  769   if (cbuf) {
  770     MacroAssembler _masm(cbuf);
  771     // EVEX spills remain EVEX: Compressed displacemement is better than AVX on spill mem operations,
  772     //                          it maps more cases to single byte displacement
  773     _masm.set_managed();
  774     if (reg_lo+1 == reg_hi) { // double move?
  775       if (is_load) {
  776         __ movdbl(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  777       } else {
  778         __ movdbl(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  779       }
  780     } else {
  781       if (is_load) {
  782         __ movflt(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  783       } else {
  784         __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  785       }
  786     }
  787 #ifndef PRODUCT
  788   } else if (!do_size) {
  789     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  790     if (reg_lo+1 == reg_hi) { // double move?
  791       if (is_load) st-&gt;print(&quot;%s %s,[ESP + #%d]&quot;,
  792                               UseXmmLoadAndClearUpper ? &quot;MOVSD &quot; : &quot;MOVLPD&quot;,
  793                               Matcher::regName[reg_lo], offset);
  794       else         st-&gt;print(&quot;MOVSD  [ESP + #%d],%s&quot;,
  795                               offset, Matcher::regName[reg_lo]);
  796     } else {
  797       if (is_load) st-&gt;print(&quot;MOVSS  %s,[ESP + #%d]&quot;,
  798                               Matcher::regName[reg_lo], offset);
  799       else         st-&gt;print(&quot;MOVSS  [ESP + #%d],%s&quot;,
  800                               offset, Matcher::regName[reg_lo]);
  801     }
  802 #endif
  803   }
  804   bool is_single_byte = false;
  805   if ((UseAVX &gt; 2) &amp;&amp; (offset != 0)) {
  806     is_single_byte = Assembler::query_compressed_disp_byte(offset, true, 0, Assembler::EVEX_T1S, in_size_in_bits, evex_encoding);
  807   }
  808   int offset_size = 0;
  809   if (UseAVX &gt; 2 ) {
  810     offset_size = (offset == 0) ? 0 : ((is_single_byte) ? 1 : 4);
  811   } else {
  812     offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  813   }
  814   size += (UseAVX &gt; 2) ? 2 : 0; // Need an additional two bytes for EVEX
  815   // VEX_2bytes prefix is used if UseAVX &gt; 0, so it takes the same 2 bytes as SIMD prefix.
  816   return size+5+offset_size;
  817 }
  818 
  819 
  820 static int impl_movx_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  821                             int src_hi, int dst_hi, int size, outputStream* st ) {
  822   if (cbuf) {
  823     MacroAssembler _masm(cbuf);
  824     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  825     _masm.set_managed();
  826     if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  827       __ movdbl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  828                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  829     } else {
  830       __ movflt(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  831                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  832     }
  833 #ifndef PRODUCT
  834   } else if (!do_size) {
  835     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  836     if (UseXmmRegToRegMoveAll) {//Use movaps,movapd to move between xmm registers
  837       if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  838         st-&gt;print(&quot;MOVAPD %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  839       } else {
  840         st-&gt;print(&quot;MOVAPS %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  841       }
  842     } else {
  843       if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double move?
  844         st-&gt;print(&quot;MOVSD  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  845       } else {
  846         st-&gt;print(&quot;MOVSS  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  847       }
  848     }
  849 #endif
  850   }
  851   // VEX_2bytes prefix is used if UseAVX &gt; 0, and it takes the same 2 bytes as SIMD prefix.
  852   // Only MOVAPS SSE prefix uses 1 byte.  EVEX uses an additional 2 bytes.
  853   int sz = (UseAVX &gt; 2) ? 6 : 4;
  854   if (!(src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) &amp;&amp;
  855       UseXmmRegToRegMoveAll &amp;&amp; (UseAVX == 0)) sz = 3;
  856   return size + sz;
  857 }
  858 
  859 static int impl_movgpr2x_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  860                             int src_hi, int dst_hi, int size, outputStream* st ) {
  861   // 32-bit
  862   if (cbuf) {
  863     MacroAssembler _masm(cbuf);
  864     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  865     _masm.set_managed();
  866     __ movdl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  867              as_Register(Matcher::_regEncode[src_lo]));
  868 #ifndef PRODUCT
  869   } else if (!do_size) {
  870     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  871 #endif
  872   }
  873   return (UseAVX&gt; 2) ? 6 : 4;
  874 }
  875 
  876 
  877 static int impl_movx2gpr_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  878                                  int src_hi, int dst_hi, int size, outputStream* st ) {
  879   // 32-bit
  880   if (cbuf) {
  881     MacroAssembler _masm(cbuf);
  882     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  883     _masm.set_managed();
  884     __ movdl(as_Register(Matcher::_regEncode[dst_lo]),
  885              as_XMMRegister(Matcher::_regEncode[src_lo]));
  886 #ifndef PRODUCT
  887   } else if (!do_size) {
  888     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  889 #endif
  890   }
  891   return (UseAVX&gt; 2) ? 6 : 4;
  892 }
  893 
  894 static int impl_mov_helper( CodeBuffer *cbuf, bool do_size, int src, int dst, int size, outputStream* st ) {
  895   if( cbuf ) {
  896     emit_opcode(*cbuf, 0x8B );
  897     emit_rm    (*cbuf, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );
  898 #ifndef PRODUCT
  899   } else if( !do_size ) {
  900     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  901     st-&gt;print(&quot;MOV    %s,%s&quot;,Matcher::regName[dst],Matcher::regName[src]);
  902 #endif
  903   }
  904   return size+2;
  905 }
  906 
  907 static int impl_fp_store_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,
  908                                  int offset, int size, outputStream* st ) {
  909   if( src_lo != FPR1L_num ) {      // Move value to top of FP stack, if not already there
  910     if( cbuf ) {
  911       emit_opcode( *cbuf, 0xD9 );  // FLD (i.e., push it)
  912       emit_d8( *cbuf, 0xC0-1+Matcher::_regEncode[src_lo] );
  913 #ifndef PRODUCT
  914     } else if( !do_size ) {
  915       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  916       st-&gt;print(&quot;FLD    %s&quot;,Matcher::regName[src_lo]);
  917 #endif
  918     }
  919     size += 2;
  920   }
  921 
  922   int st_op = (src_lo != FPR1L_num) ? EBX_num /*store &amp; pop*/ : EDX_num /*store no pop*/;
  923   const char *op_str;
  924   int op;
  925   if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double store?
  926     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_D&quot; : &quot;FST_D &quot;;
  927     op = 0xDD;
  928   } else {                   // 32-bit store
  929     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_S&quot; : &quot;FST_S &quot;;
  930     op = 0xD9;
  931     assert( !OptoReg::is_valid(src_hi) &amp;&amp; !OptoReg::is_valid(dst_hi), &quot;no non-adjacent float-stores&quot; );
  932   }
  933 
  934   return impl_helper(cbuf,do_size,false,offset,st_op,op,op_str,size, st);
  935 }
  936 
  937 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
  938 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  939                           int src_hi, int dst_hi, uint ireg, outputStream* st);
  940 
  941 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
  942                             int stack_offset, int reg, uint ireg, outputStream* st);
  943 
  944 static int vec_stack_to_stack_helper(CodeBuffer *cbuf, bool do_size, int src_offset,
  945                                      int dst_offset, uint ireg, outputStream* st) {
  946   int calc_size = 0;
  947   int src_offset_size = (src_offset == 0) ? 0 : ((src_offset &lt; 0x80) ? 1 : 4);
  948   int dst_offset_size = (dst_offset == 0) ? 0 : ((dst_offset &lt; 0x80) ? 1 : 4);
  949   switch (ireg) {
  950   case Op_VecS:
  951     calc_size = 3+src_offset_size + 3+dst_offset_size;
  952     break;
  953   case Op_VecD: {
  954     calc_size = 3+src_offset_size + 3+dst_offset_size;
  955     int tmp_src_offset = src_offset + 4;
  956     int tmp_dst_offset = dst_offset + 4;
  957     src_offset_size = (tmp_src_offset == 0) ? 0 : ((tmp_src_offset &lt; 0x80) ? 1 : 4);
  958     dst_offset_size = (tmp_dst_offset == 0) ? 0 : ((tmp_dst_offset &lt; 0x80) ? 1 : 4);
  959     calc_size += 3+src_offset_size + 3+dst_offset_size;
  960     break;
  961   }
  962   case Op_VecX:
  963   case Op_VecY:
  964   case Op_VecZ:
  965     calc_size = 6 + 6 + 5+src_offset_size + 5+dst_offset_size;
  966     break;
  967   default:
  968     ShouldNotReachHere();
  969   }
  970   if (cbuf) {
  971     MacroAssembler _masm(cbuf);
  972     int offset = __ offset();
  973     switch (ireg) {
  974     case Op_VecS:
  975       __ pushl(Address(rsp, src_offset));
  976       __ popl (Address(rsp, dst_offset));
  977       break;
  978     case Op_VecD:
  979       __ pushl(Address(rsp, src_offset));
  980       __ popl (Address(rsp, dst_offset));
  981       __ pushl(Address(rsp, src_offset+4));
  982       __ popl (Address(rsp, dst_offset+4));
  983       break;
  984     case Op_VecX:
  985       __ movdqu(Address(rsp, -16), xmm0);
  986       __ movdqu(xmm0, Address(rsp, src_offset));
  987       __ movdqu(Address(rsp, dst_offset), xmm0);
  988       __ movdqu(xmm0, Address(rsp, -16));
  989       break;
  990     case Op_VecY:
  991       __ vmovdqu(Address(rsp, -32), xmm0);
  992       __ vmovdqu(xmm0, Address(rsp, src_offset));
  993       __ vmovdqu(Address(rsp, dst_offset), xmm0);
  994       __ vmovdqu(xmm0, Address(rsp, -32));
  995       break;
  996     case Op_VecZ:
  997       __ evmovdquq(Address(rsp, -64), xmm0, 2);
  998       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
  999       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1000       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1001       break;
 1002     default:
 1003       ShouldNotReachHere();
 1004     }
 1005     int size = __ offset() - offset;
 1006     assert(size == calc_size, &quot;incorrect size calculation&quot;);
 1007     return size;
 1008 #ifndef PRODUCT
 1009   } else if (!do_size) {
 1010     switch (ireg) {
 1011     case Op_VecS:
 1012       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 32-bit mem-mem spill\n\t&quot;
 1013                 &quot;popl    [rsp + #%d]&quot;,
 1014                 src_offset, dst_offset);
 1015       break;
 1016     case Op_VecD:
 1017       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1018                 &quot;popq    [rsp + #%d]\n\t&quot;
 1019                 &quot;pushl   [rsp + #%d]\n\t&quot;
 1020                 &quot;popq    [rsp + #%d]&quot;,
 1021                 src_offset, dst_offset, src_offset+4, dst_offset+4);
 1022       break;
 1023      case Op_VecX:
 1024       st-&gt;print(&quot;movdqu  [rsp - #16], xmm0\t# 128-bit mem-mem spill\n\t&quot;
 1025                 &quot;movdqu  xmm0, [rsp + #%d]\n\t&quot;
 1026                 &quot;movdqu  [rsp + #%d], xmm0\n\t&quot;
 1027                 &quot;movdqu  xmm0, [rsp - #16]&quot;,
 1028                 src_offset, dst_offset);
 1029       break;
 1030     case Op_VecY:
 1031       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1032                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1033                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1034                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1035                 src_offset, dst_offset);
 1036       break;
 1037     case Op_VecZ:
 1038       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1039                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1040                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1041                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1042                 src_offset, dst_offset);
 1043       break;
 1044     default:
 1045       ShouldNotReachHere();
 1046     }
 1047 #endif
 1048   }
 1049   return calc_size;
 1050 }
 1051 
 1052 uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {
 1053   // Get registers to move
 1054   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1055   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1056   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this );
 1057   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this );
 1058 
 1059   enum RC src_second_rc = rc_class(src_second);
 1060   enum RC src_first_rc = rc_class(src_first);
 1061   enum RC dst_second_rc = rc_class(dst_second);
 1062   enum RC dst_first_rc = rc_class(dst_first);
 1063 
 1064   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
 1065 
 1066   // Generate spill code!
 1067   int size = 0;
 1068 
 1069   if( src_first == dst_first &amp;&amp; src_second == dst_second )
 1070     return size;            // Self copy, no move
 1071 
 1072   if (bottom_type()-&gt;isa_vect() != NULL) {
 1073     uint ireg = ideal_reg();
 1074     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1075     assert((src_first_rc != rc_float &amp;&amp; dst_first_rc != rc_float), &quot;sanity&quot;);
 1076     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1077     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1078       // mem -&gt; mem
 1079       int src_offset = ra_-&gt;reg2offset(src_first);
 1080       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1081       return vec_stack_to_stack_helper(cbuf, do_size, src_offset, dst_offset, ireg, st);
 1082     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1083       return vec_mov_helper(cbuf, do_size, src_first, dst_first, src_second, dst_second, ireg, st);
 1084     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1085       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1086       return vec_spill_helper(cbuf, do_size, false, stack_offset, src_first, ireg, st);
 1087     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_xmm ) {
 1088       int stack_offset = ra_-&gt;reg2offset(src_first);
 1089       return vec_spill_helper(cbuf, do_size, true,  stack_offset, dst_first, ireg, st);
 1090     } else {
 1091       ShouldNotReachHere();
 1092     }
 1093   }
 1094 
 1095   // --------------------------------------
 1096   // Check for mem-mem move.  push/pop to move.
 1097   if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1098     if( src_second == dst_first ) { // overlapping stack copy ranges
 1099       assert( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack, &quot;we only expect a stk-stk copy here&quot; );
 1100       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1101       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1102       src_second_rc = dst_second_rc = rc_bad;  // flag as already moved the second bits
 1103     }
 1104     // move low bits
 1105     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1106     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1107     if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) { // mov second bits
 1108       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1109       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1110     }
 1111     return size;
 1112   }
 1113 
 1114   // --------------------------------------
 1115   // Check for integer reg-reg copy
 1116   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int )
 1117     size = impl_mov_helper(cbuf,do_size,src_first,dst_first,size, st);
 1118 
 1119   // Check for integer store
 1120   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack )
 1121     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first,0x89,&quot;MOV &quot;,size, st);
 1122 
 1123   // Check for integer load
 1124   if( dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack )
 1125     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first,0x8B,&quot;MOV &quot;,size, st);
 1126 
 1127   // Check for integer reg-xmm reg copy
 1128   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_xmm ) {
 1129     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1130             &quot;no 64 bit integer-float reg moves&quot; );
 1131     return impl_movgpr2x_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1132   }
 1133   // --------------------------------------
 1134   // Check for float reg-reg copy
 1135   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1136     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1137             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second), &quot;no non-adjacent float-moves&quot; );
 1138     if( cbuf ) {
 1139 
 1140       // Note the mucking with the register encode to compensate for the 0/1
 1141       // indexing issue mentioned in a comment in the reg_def sections
 1142       // for FPR registers many lines above here.
 1143 
 1144       if( src_first != FPR1L_num ) {
 1145         emit_opcode  (*cbuf, 0xD9 );           // FLD    ST(i)
 1146         emit_d8      (*cbuf, 0xC0+Matcher::_regEncode[src_first]-1 );
 1147         emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1148         emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1149      } else {
 1150         emit_opcode  (*cbuf, 0xDD );           // FST    ST(i)
 1151         emit_d8      (*cbuf, 0xD0+Matcher::_regEncode[dst_first]-1 );
 1152      }
 1153 #ifndef PRODUCT
 1154     } else if( !do_size ) {
 1155       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1156       if( src_first != FPR1L_num ) st-&gt;print(&quot;FLD    %s\n\tFSTP   %s&quot;,Matcher::regName[src_first],Matcher::regName[dst_first]);
 1157       else                      st-&gt;print(             &quot;FST    %s&quot;,                            Matcher::regName[dst_first]);
 1158 #endif
 1159     }
 1160     return size + ((src_first != FPR1L_num) ? 2+2 : 2);
 1161   }
 1162 
 1163   // Check for float store
 1164   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1165     return impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,ra_-&gt;reg2offset(dst_first),size, st);
 1166   }
 1167 
 1168   // Check for float load
 1169   if( dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack ) {
 1170     int offset = ra_-&gt;reg2offset(src_first);
 1171     const char *op_str;
 1172     int op;
 1173     if( src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second ) { // double load?
 1174       op_str = &quot;FLD_D&quot;;
 1175       op = 0xDD;
 1176     } else {                   // 32-bit load
 1177       op_str = &quot;FLD_S&quot;;
 1178       op = 0xD9;
 1179       assert( src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad, &quot;no non-adjacent float-loads&quot; );
 1180     }
 1181     if( cbuf ) {
 1182       emit_opcode  (*cbuf, op );
 1183       encode_RegMem(*cbuf, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);
 1184       emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1185       emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1186 #ifndef PRODUCT
 1187     } else if( !do_size ) {
 1188       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1189       st-&gt;print(&quot;%s  ST,[ESP + #%d]\n\tFSTP   %s&quot;,op_str, offset,Matcher::regName[dst_first]);
 1190 #endif
 1191     }
 1192     int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
 1193     return size + 3+offset_size+2;
 1194   }
 1195 
 1196   // Check for xmm reg-reg copy
 1197   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1198     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1199             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second),
 1200             &quot;no non-adjacent float-moves&quot; );
 1201     return impl_movx_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1202   }
 1203 
 1204   // Check for xmm reg-integer reg copy
 1205   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_int ) {
 1206     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1207             &quot;no 64 bit float-integer reg moves&quot; );
 1208     return impl_movx2gpr_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1209   }
 1210 
 1211   // Check for xmm store
 1212   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1213     return impl_x_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first, src_second, size, st);
 1214   }
 1215 
 1216   // Check for float xmm load
 1217   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_stack ) {
 1218     return impl_x_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first, dst_second, size, st);
 1219   }
 1220 
 1221   // Copy from float reg to xmm reg
 1222   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_float ) {
 1223     // copy to the top of stack from floating point reg
 1224     // and use LEA to preserve flags
 1225     if( cbuf ) {
 1226       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP-8]
 1227       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1228       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1229       emit_d8(*cbuf,0xF8);
 1230 #ifndef PRODUCT
 1231     } else if( !do_size ) {
 1232       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1233       st-&gt;print(&quot;LEA    ESP,[ESP-8]&quot;);
 1234 #endif
 1235     }
 1236     size += 4;
 1237 
 1238     size = impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,0,size, st);
 1239 
 1240     // Copy from the temp memory to the xmm reg.
 1241     size = impl_x_helper(cbuf,do_size,true ,0,dst_first, dst_second, size, st);
 1242 
 1243     if( cbuf ) {
 1244       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP+8]
 1245       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1246       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1247       emit_d8(*cbuf,0x08);
 1248 #ifndef PRODUCT
 1249     } else if( !do_size ) {
 1250       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1251       st-&gt;print(&quot;LEA    ESP,[ESP+8]&quot;);
 1252 #endif
 1253     }
 1254     size += 4;
 1255     return size;
 1256   }
 1257 
 1258   assert( size &gt; 0, &quot;missed a case&quot; );
 1259 
 1260   // --------------------------------------------------------------------
 1261   // Check for second bits still needing moving.
 1262   if( src_second == dst_second )
 1263     return size;               // Self copy; no move
 1264   assert( src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot; );
 1265 
 1266   // Check for second word int-int move
 1267   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_int )
 1268     return impl_mov_helper(cbuf,do_size,src_second,dst_second,size, st);
 1269 
 1270   // Check for second word integer store
 1271   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_stack )
 1272     return impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),src_second,0x89,&quot;MOV &quot;,size, st);
 1273 
 1274   // Check for second word integer load
 1275   if( dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack )
 1276     return impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),dst_second,0x8B,&quot;MOV &quot;,size, st);
 1277 
 1278 
 1279   Unimplemented();
 1280   return 0; // Mute compiler
 1281 }
 1282 
 1283 #ifndef PRODUCT
 1284 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1285   implementation( NULL, ra_, false, st );
 1286 }
 1287 #endif
 1288 
 1289 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1290   implementation( &amp;cbuf, ra_, false, NULL );
 1291 }
 1292 
 1293 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1294   return MachNode::size(ra_);
 1295 }
 1296 
 1297 
 1298 //=============================================================================
 1299 #ifndef PRODUCT
 1300 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1301   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1302   int reg = ra_-&gt;get_reg_first(this);
 1303   st-&gt;print(&quot;LEA    %s,[ESP + #%d]&quot;,Matcher::regName[reg],offset);
 1304 }
 1305 #endif
 1306 
 1307 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1308   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1309   int reg = ra_-&gt;get_encode(this);
 1310   if( offset &gt;= 128 ) {
 1311     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1312     emit_rm(cbuf, 0x2, reg, 0x04);
 1313     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1314     emit_d32(cbuf, offset);
 1315   }
 1316   else {
 1317     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1318     emit_rm(cbuf, 0x1, reg, 0x04);
 1319     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1320     emit_d8(cbuf, offset);
 1321   }
 1322 }
 1323 
 1324 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1325   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1326   if( offset &gt;= 128 ) {
 1327     return 7;
 1328   }
 1329   else {
 1330     return 4;
 1331   }
 1332 }
 1333 
 1334 //=============================================================================
 1335 #ifndef PRODUCT
 1336 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1337   st-&gt;print_cr(  &quot;CMP    EAX,[ECX+4]\t# Inline cache check&quot;);
 1338   st-&gt;print_cr(&quot;\tJNE    SharedRuntime::handle_ic_miss_stub&quot;);
 1339   st-&gt;print_cr(&quot;\tNOP&quot;);
 1340   st-&gt;print_cr(&quot;\tNOP&quot;);
 1341   if( !OptoBreakpoint )
 1342     st-&gt;print_cr(&quot;\tNOP&quot;);
 1343 }
 1344 #endif
 1345 
 1346 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1347   MacroAssembler masm(&amp;cbuf);
 1348 #ifdef ASSERT
 1349   uint insts_size = cbuf.insts_size();
 1350 #endif
 1351   masm.cmpptr(rax, Address(rcx, oopDesc::klass_offset_in_bytes()));
 1352   masm.jump_cc(Assembler::notEqual,
 1353                RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1354   /* WARNING these NOPs are critical so that verified entry point is properly
 1355      aligned for patching by NativeJump::patch_verified_entry() */
 1356   int nops_cnt = 2;
 1357   if( !OptoBreakpoint ) // Leave space for int3
 1358      nops_cnt += 1;
 1359   masm.nop(nops_cnt);
 1360 
 1361   assert(cbuf.insts_size() - insts_size == size(ra_), &quot;checking code size of inline cache node&quot;);
 1362 }
 1363 
 1364 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1365   return OptoBreakpoint ? 11 : 12;
 1366 }
 1367 
 1368 
 1369 //=============================================================================
 1370 
 1371 int Matcher::regnum_to_fpu_offset(int regnum) {
 1372   return regnum - 32; // The FP registers are in the second chunk
 1373 }
 1374 
 1375 // This is UltraSparc specific, true just means we have fast l2f conversion
 1376 const bool Matcher::convL2FSupported(void) {
 1377   return true;
 1378 }
 1379 
 1380 // Is this branch offset short enough that a short branch can be used?
 1381 //
 1382 // NOTE: If the platform does not provide any short branch variants, then
 1383 //       this method should return false for offset 0.
 1384 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1385   // The passed offset is relative to address of the branch.
 1386   // On 86 a branch displacement is calculated relative to address
 1387   // of a next instruction.
 1388   offset -= br_size;
 1389 
 1390   // the short version of jmpConUCF2 contains multiple branches,
 1391   // making the reach slightly less
 1392   if (rule == jmpConUCF2_rule)
 1393     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1394   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1395 }
 1396 
 1397 const bool Matcher::isSimpleConstant64(jlong value) {
 1398   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1399   return false;
 1400 }
 1401 
 1402 // The ecx parameter to rep stos for the ClearArray node is in dwords.
 1403 const bool Matcher::init_array_count_is_in_bytes = false;
 1404 
 1405 // Needs 2 CMOV&#39;s for longs.
 1406 const int Matcher::long_cmove_cost() { return 1; }
 1407 
 1408 // No CMOVF/CMOVD with SSE/SSE2
 1409 const int Matcher::float_cmove_cost() { return (UseSSE&gt;=1) ? ConditionalMoveLimit : 0; }
 1410 
 1411 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1412 const bool Matcher::require_postalloc_expand = false;
 1413 
 1414 // Do we need to mask the count passed to shift instructions or does
 1415 // the cpu only look at the lower 5/6 bits anyway?
 1416 const bool Matcher::need_masked_shift_count = false;
 1417 
 1418 bool Matcher::narrow_oop_use_complex_address() {
 1419   ShouldNotCallThis();
 1420   return true;
 1421 }
 1422 
 1423 bool Matcher::narrow_klass_use_complex_address() {
 1424   ShouldNotCallThis();
 1425   return true;
 1426 }
 1427 
 1428 bool Matcher::const_oop_prefer_decode() {
 1429   ShouldNotCallThis();
 1430   return true;
 1431 }
 1432 
 1433 bool Matcher::const_klass_prefer_decode() {
 1434   ShouldNotCallThis();
 1435   return true;
 1436 }
 1437 
 1438 // Is it better to copy float constants, or load them directly from memory?
 1439 // Intel can load a float constant from a direct address, requiring no
 1440 // extra registers.  Most RISCs will have to materialize an address into a
 1441 // register first, so they would do better to copy the constant from stack.
 1442 const bool Matcher::rematerialize_float_constants = true;
 1443 
 1444 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1445 // needed.  Else we split the double into 2 integer pieces and move it
 1446 // piece-by-piece.  Only happens when passing doubles into C code as the
 1447 // Java calling convention forces doubles to be aligned.
 1448 const bool Matcher::misaligned_doubles_ok = true;
 1449 
 1450 
 1451 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1452   // Get the memory operand from the node
 1453   uint numopnds = node-&gt;num_opnds();        // Virtual call for number of operands
 1454   uint skipped  = node-&gt;oper_input_base();  // Sum of leaves skipped so far
 1455   assert( idx &gt;= skipped, &quot;idx too low in pd_implicit_null_fixup&quot; );
 1456   uint opcnt     = 1;                 // First operand
 1457   uint num_edges = node-&gt;_opnds[1]-&gt;num_edges(); // leaves for first operand
 1458   while( idx &gt;= skipped+num_edges ) {
 1459     skipped += num_edges;
 1460     opcnt++;                          // Bump operand count
 1461     assert( opcnt &lt; numopnds, &quot;Accessing non-existent operand&quot; );
 1462     num_edges = node-&gt;_opnds[opcnt]-&gt;num_edges(); // leaves for next operand
 1463   }
 1464 
 1465   MachOper *memory = node-&gt;_opnds[opcnt];
 1466   MachOper *new_memory = NULL;
 1467   switch (memory-&gt;opcode()) {
 1468   case DIRECT:
 1469   case INDOFFSET32X:
 1470     // No transformation necessary.
 1471     return;
 1472   case INDIRECT:
 1473     new_memory = new indirect_win95_safeOper( );
 1474     break;
 1475   case INDOFFSET8:
 1476     new_memory = new indOffset8_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1477     break;
 1478   case INDOFFSET32:
 1479     new_memory = new indOffset32_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1480     break;
 1481   case INDINDEXOFFSET:
 1482     new_memory = new indIndexOffset_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1483     break;
 1484   case INDINDEXSCALE:
 1485     new_memory = new indIndexScale_win95_safeOper(memory-&gt;scale());
 1486     break;
 1487   case INDINDEXSCALEOFFSET:
 1488     new_memory = new indIndexScaleOffset_win95_safeOper(memory-&gt;scale(), memory-&gt;disp(NULL, NULL, 0));
 1489     break;
 1490   case LOAD_LONG_INDIRECT:
 1491   case LOAD_LONG_INDOFFSET32:
 1492     // Does not use EBP as address register, use { EDX, EBX, EDI, ESI}
 1493     return;
 1494   default:
 1495     assert(false, &quot;unexpected memory operand in pd_implicit_null_fixup()&quot;);
 1496     return;
 1497   }
 1498   node-&gt;_opnds[opcnt] = new_memory;
 1499 }
 1500 
 1501 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1502 const bool Matcher::strict_fp_requires_explicit_rounding = true;
 1503 
 1504 // Are floats conerted to double when stored to stack during deoptimization?
 1505 // On x32 it is stored with convertion only when FPU is used for floats.
 1506 bool Matcher::float_in_double() { return (UseSSE == 0); }
 1507 
 1508 // Do ints take an entire long register or just half?
 1509 const bool Matcher::int_in_long = false;
 1510 
 1511 // Return whether or not this register is ever used as an argument.  This
 1512 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1513 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1514 // arguments in those registers not be available to the callee.
 1515 bool Matcher::can_be_java_arg( int reg ) {
 1516   if(  reg == ECX_num   || reg == EDX_num   ) return true;
 1517   if( (reg == XMM0_num  || reg == XMM1_num ) &amp;&amp; UseSSE&gt;=1 ) return true;
 1518   if( (reg == XMM0b_num || reg == XMM1b_num) &amp;&amp; UseSSE&gt;=2 ) return true;
 1519   return false;
 1520 }
 1521 
 1522 bool Matcher::is_spillable_arg( int reg ) {
 1523   return can_be_java_arg(reg);
 1524 }
 1525 
 1526 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1527   // Use hardware integer DIV instruction when
 1528   // it is faster than a code which use multiply.
 1529   // Only when constant divisor fits into 32 bit
 1530   // (min_jint is excluded to get only correct
 1531   // positive 32 bit values from negative).
 1532   return VM_Version::has_fast_idiv() &amp;&amp;
 1533          (divisor == (int)divisor &amp;&amp; divisor != min_jint);
 1534 }
 1535 
 1536 // Register for DIVI projection of divmodI
 1537 RegMask Matcher::divI_proj_mask() {
 1538   return EAX_REG_mask();
 1539 }
 1540 
 1541 // Register for MODI projection of divmodI
 1542 RegMask Matcher::modI_proj_mask() {
 1543   return EDX_REG_mask();
 1544 }
 1545 
 1546 // Register for DIVL projection of divmodL
 1547 RegMask Matcher::divL_proj_mask() {
 1548   ShouldNotReachHere();
 1549   return RegMask();
 1550 }
 1551 
 1552 // Register for MODL projection of divmodL
 1553 RegMask Matcher::modL_proj_mask() {
 1554   ShouldNotReachHere();
 1555   return RegMask();
 1556 }
 1557 
 1558 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1559   return NO_REG_mask();
 1560 }
 1561 
 1562 // Returns true if the high 32 bits of the value is known to be zero.
 1563 bool is_operand_hi32_zero(Node* n) {
 1564   int opc = n-&gt;Opcode();
 1565   if (opc == Op_AndL) {
 1566     Node* o2 = n-&gt;in(2);
 1567     if (o2-&gt;is_Con() &amp;&amp; (o2-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1568       return true;
 1569     }
 1570   }
 1571   if (opc == Op_ConL &amp;&amp; (n-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1572     return true;
 1573   }
 1574   return false;
 1575 }
 1576 
 1577 %}
 1578 
 1579 //----------ENCODING BLOCK-----------------------------------------------------
 1580 // This block specifies the encoding classes used by the compiler to output
 1581 // byte streams.  Encoding classes generate functions which are called by
 1582 // Machine Instruction Nodes in order to generate the bit encoding of the
 1583 // instruction.  Operands specify their base encoding interface with the
 1584 // interface keyword.  There are currently supported four interfaces,
 1585 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1586 // operand to generate a function which returns its register number when
 1587 // queried.   CONST_INTER causes an operand to generate a function which
 1588 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1589 // operand to generate four functions which return the Base Register, the
 1590 // Index Register, the Scale Value, and the Offset Value of the operand when
 1591 // queried.  COND_INTER causes an operand to generate six functions which
 1592 // return the encoding code (ie - encoding bits for the instruction)
 1593 // associated with each basic boolean condition for a conditional instruction.
 1594 // Instructions specify two basic values for encoding.  They use the
 1595 // ins_encode keyword to specify their encoding class (which must be one of
 1596 // the class names specified in the encoding block), and they use the
 1597 // opcode keyword to specify, in order, their primary, secondary, and
 1598 // tertiary opcode.  Only the opcode sections which a particular instruction
 1599 // needs for encoding need to be specified.
 1600 encode %{
 1601   // Build emit functions for each basic byte or larger field in the intel
 1602   // encoding scheme (opcode, rm, sib, immediate), and call them from C++
 1603   // code in the enc_class source block.  Emit functions will live in the
 1604   // main source block for now.  In future, we can generalize this by
 1605   // adding a syntax that specifies the sizes of fields in an order,
 1606   // so that the adlc can build the emit functions automagically
 1607 
 1608   // Emit primary opcode
 1609   enc_class OpcP %{
 1610     emit_opcode(cbuf, $primary);
 1611   %}
 1612 
 1613   // Emit secondary opcode
 1614   enc_class OpcS %{
 1615     emit_opcode(cbuf, $secondary);
 1616   %}
 1617 
 1618   // Emit opcode directly
 1619   enc_class Opcode(immI d8) %{
 1620     emit_opcode(cbuf, $d8$$constant);
 1621   %}
 1622 
 1623   enc_class SizePrefix %{
 1624     emit_opcode(cbuf,0x66);
 1625   %}
 1626 
 1627   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 1628     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1629   %}
 1630 
 1631   enc_class OpcRegReg (immI opcode, rRegI dst, rRegI src) %{    // OpcRegReg(Many)
 1632     emit_opcode(cbuf,$opcode$$constant);
 1633     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1634   %}
 1635 
 1636   enc_class mov_r32_imm0( rRegI dst ) %{
 1637     emit_opcode( cbuf, 0xB8 + $dst$$reg ); // 0xB8+ rd   -- MOV r32  ,imm32
 1638     emit_d32   ( cbuf, 0x0  );             //                         imm32==0x0
 1639   %}
 1640 
 1641   enc_class cdq_enc %{
 1642     // Full implementation of Java idiv and irem; checks for
 1643     // special case as described in JVM spec., p.243 &amp; p.271.
 1644     //
 1645     //         normal case                           special case
 1646     //
 1647     // input : rax,: dividend                         min_int
 1648     //         reg: divisor                          -1
 1649     //
 1650     // output: rax,: quotient  (= rax, idiv reg)       min_int
 1651     //         rdx: remainder (= rax, irem reg)       0
 1652     //
 1653     //  Code sequnce:
 1654     //
 1655     //  81 F8 00 00 00 80    cmp         rax,80000000h
 1656     //  0F 85 0B 00 00 00    jne         normal_case
 1657     //  33 D2                xor         rdx,edx
 1658     //  83 F9 FF             cmp         rcx,0FFh
 1659     //  0F 84 03 00 00 00    je          done
 1660     //                  normal_case:
 1661     //  99                   cdq
 1662     //  F7 F9                idiv        rax,ecx
 1663     //                  done:
 1664     //
 1665     emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);
 1666     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);
 1667     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     // cmp rax,80000000h
 1668     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);
 1669     emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);
 1670     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // jne normal_case
 1671     emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     // xor rdx,edx
 1672     emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); // cmp rcx,0FFh
 1673     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);
 1674     emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);
 1675     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // je done
 1676     // normal_case:
 1677     emit_opcode(cbuf,0x99);                                         // cdq
 1678     // idiv (note: must be emitted by the user of this rule)
 1679     // normal:
 1680   %}
 1681 
 1682   // Dense encoding for older common ops
 1683   enc_class Opc_plus(immI opcode, rRegI reg) %{
 1684     emit_opcode(cbuf, $opcode$$constant + $reg$$reg);
 1685   %}
 1686 
 1687 
 1688   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1689   enc_class OpcSE (immI imm) %{ // Emit primary opcode and set sign-extend bit
 1690     // Check for 8-bit immediate, and set sign extend bit in opcode
 1691     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1692       emit_opcode(cbuf, $primary | 0x02);
 1693     }
 1694     else {                          // If 32-bit immediate
 1695       emit_opcode(cbuf, $primary);
 1696     }
 1697   %}
 1698 
 1699   enc_class OpcSErm (rRegI dst, immI imm) %{    // OpcSEr/m
 1700     // Emit primary opcode and set sign-extend bit
 1701     // Check for 8-bit immediate, and set sign extend bit in opcode
 1702     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1703       emit_opcode(cbuf, $primary | 0x02);    }
 1704     else {                          // If 32-bit immediate
 1705       emit_opcode(cbuf, $primary);
 1706     }
 1707     // Emit r/m byte with secondary opcode, after primary opcode.
 1708     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1709   %}
 1710 
 1711   enc_class Con8or32 (immI imm) %{    // Con8or32(storeImmI), 8 or 32 bits
 1712     // Check for 8-bit immediate, and set sign extend bit in opcode
 1713     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1714       $$$emit8$imm$$constant;
 1715     }
 1716     else {                          // If 32-bit immediate
 1717       // Output immediate
 1718       $$$emit32$imm$$constant;
 1719     }
 1720   %}
 1721 
 1722   enc_class Long_OpcSErm_Lo(eRegL dst, immL imm) %{
 1723     // Emit primary opcode and set sign-extend bit
 1724     // Check for 8-bit immediate, and set sign extend bit in opcode
 1725     int con = (int)$imm$$constant; // Throw away top bits
 1726     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1727     // Emit r/m byte with secondary opcode, after primary opcode.
 1728     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1729     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1730     else                               emit_d32(cbuf,con);
 1731   %}
 1732 
 1733   enc_class Long_OpcSErm_Hi(eRegL dst, immL imm) %{
 1734     // Emit primary opcode and set sign-extend bit
 1735     // Check for 8-bit immediate, and set sign extend bit in opcode
 1736     int con = (int)($imm$$constant &gt;&gt; 32); // Throw away bottom bits
 1737     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1738     // Emit r/m byte with tertiary opcode, after primary opcode.
 1739     emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));
 1740     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1741     else                               emit_d32(cbuf,con);
 1742   %}
 1743 
 1744   enc_class OpcSReg (rRegI dst) %{    // BSWAP
 1745     emit_cc(cbuf, $secondary, $dst$$reg );
 1746   %}
 1747 
 1748   enc_class bswap_long_bytes(eRegL dst) %{ // BSWAP
 1749     int destlo = $dst$$reg;
 1750     int desthi = HIGH_FROM_LOW(destlo);
 1751     // bswap lo
 1752     emit_opcode(cbuf, 0x0F);
 1753     emit_cc(cbuf, 0xC8, destlo);
 1754     // bswap hi
 1755     emit_opcode(cbuf, 0x0F);
 1756     emit_cc(cbuf, 0xC8, desthi);
 1757     // xchg lo and hi
 1758     emit_opcode(cbuf, 0x87);
 1759     emit_rm(cbuf, 0x3, destlo, desthi);
 1760   %}
 1761 
 1762   enc_class RegOpc (rRegI div) %{    // IDIV, IMOD, JMP indirect, ...
 1763     emit_rm(cbuf, 0x3, $secondary, $div$$reg );
 1764   %}
 1765 
 1766   enc_class enc_cmov(cmpOp cop ) %{ // CMOV
 1767     $$$emit8$primary;
 1768     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 1769   %}
 1770 
 1771   enc_class enc_cmov_dpr(cmpOp cop, regDPR src ) %{ // CMOV
 1772     int op = 0xDA00 + $cop$$cmpcode + ($src$$reg-1);
 1773     emit_d8(cbuf, op &gt;&gt; 8 );
 1774     emit_d8(cbuf, op &amp; 255);
 1775   %}
 1776 
 1777   // emulate a CMOV with a conditional branch around a MOV
 1778   enc_class enc_cmov_branch( cmpOp cop, immI brOffs ) %{ // CMOV
 1779     // Invert sense of branch from sense of CMOV
 1780     emit_cc( cbuf, 0x70, ($cop$$cmpcode^1) );
 1781     emit_d8( cbuf, $brOffs$$constant );
 1782   %}
 1783 
 1784   enc_class enc_PartialSubtypeCheck( ) %{
 1785     Register Redi = as_Register(EDI_enc); // result register
 1786     Register Reax = as_Register(EAX_enc); // super class
 1787     Register Recx = as_Register(ECX_enc); // killed
 1788     Register Resi = as_Register(ESI_enc); // sub class
 1789     Label miss;
 1790 
 1791     MacroAssembler _masm(&amp;cbuf);
 1792     __ check_klass_subtype_slow_path(Resi, Reax, Recx, Redi,
 1793                                      NULL, &amp;miss,
 1794                                      /*set_cond_codes:*/ true);
 1795     if ($primary) {
 1796       __ xorptr(Redi, Redi);
 1797     }
 1798     __ bind(miss);
 1799   %}
 1800 
 1801   enc_class FFree_Float_Stack_All %{    // Free_Float_Stack_All
 1802     MacroAssembler masm(&amp;cbuf);
 1803     int start = masm.offset();
 1804     if (UseSSE &gt;= 2) {
 1805       if (VerifyFPU) {
 1806         masm.verify_FPU(0, &quot;must be empty in SSE2+ mode&quot;);
 1807       }
 1808     } else {
 1809       // External c_calling_convention expects the FPU stack to be &#39;clean&#39;.
 1810       // Compiled code leaves it dirty.  Do cleanup now.
 1811       masm.empty_FPU_stack();
 1812     }
 1813     if (sizeof_FFree_Float_Stack_All == -1) {
 1814       sizeof_FFree_Float_Stack_All = masm.offset() - start;
 1815     } else {
 1816       assert(masm.offset() - start == sizeof_FFree_Float_Stack_All, &quot;wrong size&quot;);
 1817     }
 1818   %}
 1819 
 1820   enc_class Verify_FPU_For_Leaf %{
 1821     if( VerifyFPU ) {
 1822       MacroAssembler masm(&amp;cbuf);
 1823       masm.verify_FPU( -3, &quot;Returning from Runtime Leaf call&quot;);
 1824     }
 1825   %}
 1826 
 1827   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime, Java_To_Runtime_Leaf
 1828     // This is the instruction starting address for relocation info.
 1829     cbuf.set_insts_mark();
 1830     $$$emit8$primary;
 1831     // CALL directly to the runtime
 1832     emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1833                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1834 
 1835     if (UseSSE &gt;= 2) {
 1836       MacroAssembler _masm(&amp;cbuf);
 1837       BasicType rt = tf()-&gt;return_type();
 1838 
 1839       if ((rt == T_FLOAT || rt == T_DOUBLE) &amp;&amp; !return_value_is_used()) {
 1840         // A C runtime call where the return value is unused.  In SSE2+
 1841         // mode the result needs to be removed from the FPU stack.  It&#39;s
 1842         // likely that this function call could be removed by the
 1843         // optimizer if the C function is a pure function.
 1844         __ ffree(0);
 1845       } else if (rt == T_FLOAT) {
 1846         __ lea(rsp, Address(rsp, -4));
 1847         __ fstp_s(Address(rsp, 0));
 1848         __ movflt(xmm0, Address(rsp, 0));
 1849         __ lea(rsp, Address(rsp,  4));
 1850       } else if (rt == T_DOUBLE) {
 1851         __ lea(rsp, Address(rsp, -8));
 1852         __ fstp_d(Address(rsp, 0));
 1853         __ movdbl(xmm0, Address(rsp, 0));
 1854         __ lea(rsp, Address(rsp,  8));
 1855       }
 1856     }
 1857   %}
 1858 
 1859   enc_class pre_call_resets %{
 1860     // If method sets FPU control word restore it here
 1861     debug_only(int off0 = cbuf.insts_size());
 1862     if (ra_-&gt;C-&gt;in_24_bit_fp_mode()) {
 1863       MacroAssembler _masm(&amp;cbuf);
 1864       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
 1865     }
 1866     // Clear upper bits of YMM registers when current compiled code uses
 1867     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 1868     MacroAssembler _masm(&amp;cbuf);
 1869     __ vzeroupper();
 1870     debug_only(int off1 = cbuf.insts_size());
 1871     assert(off1 - off0 == pre_call_resets_size(), &quot;correct size prediction&quot;);
 1872   %}
 1873 
 1874   enc_class post_call_FPU %{
 1875     // If method sets FPU control word do it here also
 1876     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
 1877       MacroAssembler masm(&amp;cbuf);
 1878       masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 1879     }
 1880   %}
 1881 
 1882   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 1883     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1884     // who we intended to call.
 1885     cbuf.set_insts_mark();
 1886     $$$emit8$primary;
 1887 
 1888     if (!_method) {
 1889       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1890                      runtime_call_Relocation::spec(),
 1891                      RELOC_IMM32);
 1892     } else {
 1893       int method_index = resolved_method_index(cbuf);
 1894       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1895                                                   : static_call_Relocation::spec(method_index);
 1896       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1897                      rspec, RELOC_DISP32);
 1898       // Emit stubs for static call.
 1899       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1900       if (stub == NULL) {
 1901         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1902         return;
 1903       }
 1904     }
 1905   %}
 1906 
 1907   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 1908     MacroAssembler _masm(&amp;cbuf);
 1909     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 1910   %}
 1911 
 1912   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 1913     int disp = in_bytes(Method::from_compiled_offset());
 1914     assert( -128 &lt;= disp &amp;&amp; disp &lt;= 127, &quot;compiled_code_offset isn&#39;t small&quot;);
 1915 
 1916     // CALL *[EAX+in_bytes(Method::from_compiled_code_entry_point_offset())]
 1917     cbuf.set_insts_mark();
 1918     $$$emit8$primary;
 1919     emit_rm(cbuf, 0x01, $secondary, EAX_enc );  // R/M byte
 1920     emit_d8(cbuf, disp);             // Displacement
 1921 
 1922   %}
 1923 
 1924 //   Following encoding is no longer used, but may be restored if calling
 1925 //   convention changes significantly.
 1926 //   Became: Xor_Reg(EBP), Java_To_Runtime( labl )
 1927 //
 1928 //   enc_class Java_Interpreter_Call (label labl) %{    // JAVA INTERPRETER CALL
 1929 //     // int ic_reg     = Matcher::inline_cache_reg();
 1930 //     // int ic_encode  = Matcher::_regEncode[ic_reg];
 1931 //     // int imo_reg    = Matcher::interpreter_method_oop_reg();
 1932 //     // int imo_encode = Matcher::_regEncode[imo_reg];
 1933 //
 1934 //     // // Interpreter expects method_oop in EBX, currently a callee-saved register,
 1935 //     // // so we load it immediately before the call
 1936 //     // emit_opcode(cbuf, 0x8B);                     // MOV    imo_reg,ic_reg  # method_oop
 1937 //     // emit_rm(cbuf, 0x03, imo_encode, ic_encode ); // R/M byte
 1938 //
 1939 //     // xor rbp,ebp
 1940 //     emit_opcode(cbuf, 0x33);
 1941 //     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);
 1942 //
 1943 //     // CALL to interpreter.
 1944 //     cbuf.set_insts_mark();
 1945 //     $$$emit8$primary;
 1946 //     emit_d32_reloc(cbuf, ($labl$$label - (int)(cbuf.insts_end()) - 4),
 1947 //                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1948 //   %}
 1949 
 1950   enc_class RegOpcImm (rRegI dst, immI8 shift) %{    // SHL, SAR, SHR
 1951     $$$emit8$primary;
 1952     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1953     $$$emit8$shift$$constant;
 1954   %}
 1955 
 1956   enc_class LdImmI (rRegI dst, immI src) %{    // Load Immediate
 1957     // Load immediate does not have a zero or sign extended version
 1958     // for 8-bit immediates
 1959     emit_opcode(cbuf, 0xB8 + $dst$$reg);
 1960     $$$emit32$src$$constant;
 1961   %}
 1962 
 1963   enc_class LdImmP (rRegI dst, immI src) %{    // Load Immediate
 1964     // Load immediate does not have a zero or sign extended version
 1965     // for 8-bit immediates
 1966     emit_opcode(cbuf, $primary + $dst$$reg);
 1967     $$$emit32$src$$constant;
 1968   %}
 1969 
 1970   enc_class LdImmL_Lo( eRegL dst, immL src) %{    // Load Immediate
 1971     // Load immediate does not have a zero or sign extended version
 1972     // for 8-bit immediates
 1973     int dst_enc = $dst$$reg;
 1974     int src_con = $src$$constant &amp; 0x0FFFFFFFFL;
 1975     if (src_con == 0) {
 1976       // xor dst, dst
 1977       emit_opcode(cbuf, 0x33);
 1978       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1979     } else {
 1980       emit_opcode(cbuf, $primary + dst_enc);
 1981       emit_d32(cbuf, src_con);
 1982     }
 1983   %}
 1984 
 1985   enc_class LdImmL_Hi( eRegL dst, immL src) %{    // Load Immediate
 1986     // Load immediate does not have a zero or sign extended version
 1987     // for 8-bit immediates
 1988     int dst_enc = $dst$$reg + 2;
 1989     int src_con = ((julong)($src$$constant)) &gt;&gt; 32;
 1990     if (src_con == 0) {
 1991       // xor dst, dst
 1992       emit_opcode(cbuf, 0x33);
 1993       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1994     } else {
 1995       emit_opcode(cbuf, $primary + dst_enc);
 1996       emit_d32(cbuf, src_con);
 1997     }
 1998   %}
 1999 
 2000 
 2001   // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2002   enc_class enc_Copy( rRegI dst, rRegI src ) %{
 2003     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2004   %}
 2005 
 2006   enc_class enc_CopyL_Lo( rRegI dst, eRegL src ) %{
 2007     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2008   %}
 2009 
 2010   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 2011     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2012   %}
 2013 
 2014   enc_class RegReg_Lo(eRegL dst, eRegL src) %{    // RegReg(Many)
 2015     $$$emit8$primary;
 2016     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2017   %}
 2018 
 2019   enc_class RegReg_Hi(eRegL dst, eRegL src) %{    // RegReg(Many)
 2020     $$$emit8$secondary;
 2021     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2022   %}
 2023 
 2024   enc_class RegReg_Lo2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2025     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2026   %}
 2027 
 2028   enc_class RegReg_Hi2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2029     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2030   %}
 2031 
 2032   enc_class RegReg_HiLo( eRegL src, rRegI dst ) %{
 2033     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));
 2034   %}
 2035 
 2036   enc_class Con32 (immI src) %{    // Con32(storeImmI)
 2037     // Output immediate
 2038     $$$emit32$src$$constant;
 2039   %}
 2040 
 2041   enc_class Con32FPR_as_bits(immFPR src) %{        // storeF_imm
 2042     // Output Float immediate bits
 2043     jfloat jf = $src$$constant;
 2044     int    jf_as_bits = jint_cast( jf );
 2045     emit_d32(cbuf, jf_as_bits);
 2046   %}
 2047 
 2048   enc_class Con32F_as_bits(immF src) %{      // storeX_imm
 2049     // Output Float immediate bits
 2050     jfloat jf = $src$$constant;
 2051     int    jf_as_bits = jint_cast( jf );
 2052     emit_d32(cbuf, jf_as_bits);
 2053   %}
 2054 
 2055   enc_class Con16 (immI src) %{    // Con16(storeImmI)
 2056     // Output immediate
 2057     $$$emit16$src$$constant;
 2058   %}
 2059 
 2060   enc_class Con_d32(immI src) %{
 2061     emit_d32(cbuf,$src$$constant);
 2062   %}
 2063 
 2064   enc_class conmemref (eRegP t1) %{    // Con32(storeImmI)
 2065     // Output immediate memory reference
 2066     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2067     emit_d32(cbuf, 0x00);
 2068   %}
 2069 
 2070   enc_class lock_prefix( ) %{
 2071     emit_opcode(cbuf,0xF0);         // [Lock]
 2072   %}
 2073 
 2074   // Cmp-xchg long value.
 2075   // Note: we need to swap rbx, and rcx before and after the
 2076   //       cmpxchg8 instruction because the instruction uses
 2077   //       rcx as the high order word of the new value to store but
 2078   //       our register encoding uses rbx,.
 2079   enc_class enc_cmpxchg8(eSIRegP mem_ptr) %{
 2080 
 2081     // XCHG  rbx,ecx
 2082     emit_opcode(cbuf,0x87);
 2083     emit_opcode(cbuf,0xD9);
 2084     // [Lock]
 2085     emit_opcode(cbuf,0xF0);
 2086     // CMPXCHG8 [Eptr]
 2087     emit_opcode(cbuf,0x0F);
 2088     emit_opcode(cbuf,0xC7);
 2089     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2090     // XCHG  rbx,ecx
 2091     emit_opcode(cbuf,0x87);
 2092     emit_opcode(cbuf,0xD9);
 2093   %}
 2094 
 2095   enc_class enc_cmpxchg(eSIRegP mem_ptr) %{
 2096     // [Lock]
 2097     emit_opcode(cbuf,0xF0);
 2098 
 2099     // CMPXCHG [Eptr]
 2100     emit_opcode(cbuf,0x0F);
 2101     emit_opcode(cbuf,0xB1);
 2102     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2103   %}
 2104 
 2105   enc_class enc_cmpxchgb(eSIRegP mem_ptr) %{
 2106     // [Lock]
 2107     emit_opcode(cbuf,0xF0);
 2108 
 2109     // CMPXCHGB [Eptr]
 2110     emit_opcode(cbuf,0x0F);
 2111     emit_opcode(cbuf,0xB0);
 2112     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2113   %}
 2114 
 2115   enc_class enc_cmpxchgw(eSIRegP mem_ptr) %{
 2116     // [Lock]
 2117     emit_opcode(cbuf,0xF0);
 2118 
 2119     // 16-bit mode
 2120     emit_opcode(cbuf, 0x66);
 2121 
 2122     // CMPXCHGW [Eptr]
 2123     emit_opcode(cbuf,0x0F);
 2124     emit_opcode(cbuf,0xB1);
 2125     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2126   %}
 2127 
 2128   enc_class enc_flags_ne_to_boolean( iRegI res ) %{
 2129     int res_encoding = $res$$reg;
 2130 
 2131     // MOV  res,0
 2132     emit_opcode( cbuf, 0xB8 + res_encoding);
 2133     emit_d32( cbuf, 0 );
 2134     // JNE,s  fail
 2135     emit_opcode(cbuf,0x75);
 2136     emit_d8(cbuf, 5 );
 2137     // MOV  res,1
 2138     emit_opcode( cbuf, 0xB8 + res_encoding);
 2139     emit_d32( cbuf, 1 );
 2140     // fail:
 2141   %}
 2142 
 2143   enc_class set_instruction_start( ) %{
 2144     cbuf.set_insts_mark();            // Mark start of opcode for reloc info in mem operand
 2145   %}
 2146 
 2147   enc_class RegMem (rRegI ereg, memory mem) %{    // emit_reg_mem
 2148     int reg_encoding = $ereg$$reg;
 2149     int base  = $mem$$base;
 2150     int index = $mem$$index;
 2151     int scale = $mem$$scale;
 2152     int displace = $mem$$disp;
 2153     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2154     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2155   %}
 2156 
 2157   enc_class RegMem_Hi(eRegL ereg, memory mem) %{    // emit_reg_mem
 2158     int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  // Hi register of pair, computed from lo
 2159     int base  = $mem$$base;
 2160     int index = $mem$$index;
 2161     int scale = $mem$$scale;
 2162     int displace = $mem$$disp + 4;      // Offset is 4 further in memory
 2163     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;Cannot add 4 to oop&quot; );
 2164     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, relocInfo::none);
 2165   %}
 2166 
 2167   enc_class move_long_small_shift( eRegL dst, immI_1_31 cnt ) %{
 2168     int r1, r2;
 2169     if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2170     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2171     emit_opcode(cbuf,0x0F);
 2172     emit_opcode(cbuf,$tertiary);
 2173     emit_rm(cbuf, 0x3, r1, r2);
 2174     emit_d8(cbuf,$cnt$$constant);
 2175     emit_d8(cbuf,$primary);
 2176     emit_rm(cbuf, 0x3, $secondary, r1);
 2177     emit_d8(cbuf,$cnt$$constant);
 2178   %}
 2179 
 2180   enc_class move_long_big_shift_sign( eRegL dst, immI_32_63 cnt ) %{
 2181     emit_opcode( cbuf, 0x8B ); // Move
 2182     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2183     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2184       emit_d8(cbuf,$primary);
 2185       emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 2186       emit_d8(cbuf,$cnt$$constant-32);
 2187     }
 2188     emit_d8(cbuf,$primary);
 2189     emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));
 2190     emit_d8(cbuf,31);
 2191   %}
 2192 
 2193   enc_class move_long_big_shift_clr( eRegL dst, immI_32_63 cnt ) %{
 2194     int r1, r2;
 2195     if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2196     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2197 
 2198     emit_opcode( cbuf, 0x8B ); // Move r1,r2
 2199     emit_rm(cbuf, 0x3, r1, r2);
 2200     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2201       emit_opcode(cbuf,$primary);
 2202       emit_rm(cbuf, 0x3, $secondary, r1);
 2203       emit_d8(cbuf,$cnt$$constant-32);
 2204     }
 2205     emit_opcode(cbuf,0x33);  // XOR r2,r2
 2206     emit_rm(cbuf, 0x3, r2, r2);
 2207   %}
 2208 
 2209   // Clone of RegMem but accepts an extra parameter to access each
 2210   // half of a double in memory; it never needs relocation info.
 2211   enc_class Mov_MemD_half_to_Reg (immI opcode, memory mem, immI disp_for_half, rRegI rm_reg) %{
 2212     emit_opcode(cbuf,$opcode$$constant);
 2213     int reg_encoding = $rm_reg$$reg;
 2214     int base     = $mem$$base;
 2215     int index    = $mem$$index;
 2216     int scale    = $mem$$scale;
 2217     int displace = $mem$$disp + $disp_for_half$$constant;
 2218     relocInfo::relocType disp_reloc = relocInfo::none;
 2219     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2220   %}
 2221 
 2222   // !!!!! Special Custom Code used by MemMove, and stack access instructions !!!!!
 2223   //
 2224   // Clone of RegMem except the RM-byte&#39;s reg/opcode field is an ADLC-time constant
 2225   // and it never needs relocation information.
 2226   // Frequently used to move data between FPU&#39;s Stack Top and memory.
 2227   enc_class RMopc_Mem_no_oop (immI rm_opcode, memory mem) %{
 2228     int rm_byte_opcode = $rm_opcode$$constant;
 2229     int base     = $mem$$base;
 2230     int index    = $mem$$index;
 2231     int scale    = $mem$$scale;
 2232     int displace = $mem$$disp;
 2233     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;No oops here because no reloc info allowed&quot; );
 2234     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, relocInfo::none);
 2235   %}
 2236 
 2237   enc_class RMopc_Mem (immI rm_opcode, memory mem) %{
 2238     int rm_byte_opcode = $rm_opcode$$constant;
 2239     int base     = $mem$$base;
 2240     int index    = $mem$$index;
 2241     int scale    = $mem$$scale;
 2242     int displace = $mem$$disp;
 2243     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2244     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 2245   %}
 2246 
 2247   enc_class RegLea (rRegI dst, rRegI src0, immI src1 ) %{    // emit_reg_lea
 2248     int reg_encoding = $dst$$reg;
 2249     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2250     int index        = 0x04;            // 0x04 indicates no index
 2251     int scale        = 0x00;            // 0x00 indicates no scale
 2252     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2253     relocInfo::relocType disp_reloc = relocInfo::none;
 2254     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2255   %}
 2256 
 2257   enc_class min_enc (rRegI dst, rRegI src) %{    // MIN
 2258     // Compare dst,src
 2259     emit_opcode(cbuf,0x3B);
 2260     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2261     // jmp dst &lt; src around move
 2262     emit_opcode(cbuf,0x7C);
 2263     emit_d8(cbuf,2);
 2264     // move dst,src
 2265     emit_opcode(cbuf,0x8B);
 2266     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2267   %}
 2268 
 2269   enc_class max_enc (rRegI dst, rRegI src) %{    // MAX
 2270     // Compare dst,src
 2271     emit_opcode(cbuf,0x3B);
 2272     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2273     // jmp dst &gt; src around move
 2274     emit_opcode(cbuf,0x7F);
 2275     emit_d8(cbuf,2);
 2276     // move dst,src
 2277     emit_opcode(cbuf,0x8B);
 2278     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2279   %}
 2280 
 2281   enc_class enc_FPR_store(memory mem, regDPR src) %{
 2282     // If src is FPR1, we can just FST to store it.
 2283     // Else we need to FLD it to FPR1, then FSTP to store/pop it.
 2284     int reg_encoding = 0x2; // Just store
 2285     int base  = $mem$$base;
 2286     int index = $mem$$index;
 2287     int scale = $mem$$scale;
 2288     int displace = $mem$$disp;
 2289     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2290     if( $src$$reg != FPR1L_enc ) {
 2291       reg_encoding = 0x3;  // Store &amp; pop
 2292       emit_opcode( cbuf, 0xD9 ); // FLD (i.e., push it)
 2293       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2294     }
 2295     cbuf.set_insts_mark();       // Mark start of opcode for reloc info in mem operand
 2296     emit_opcode(cbuf,$primary);
 2297     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2298   %}
 2299 
 2300   enc_class neg_reg(rRegI dst) %{
 2301     // NEG $dst
 2302     emit_opcode(cbuf,0xF7);
 2303     emit_rm(cbuf, 0x3, 0x03, $dst$$reg );
 2304   %}
 2305 
 2306   enc_class setLT_reg(eCXRegI dst) %{
 2307     // SETLT $dst
 2308     emit_opcode(cbuf,0x0F);
 2309     emit_opcode(cbuf,0x9C);
 2310     emit_rm( cbuf, 0x3, 0x4, $dst$$reg );
 2311   %}
 2312 
 2313   enc_class enc_cmpLTP(ncxRegI p, ncxRegI q, ncxRegI y, eCXRegI tmp) %{    // cadd_cmpLT
 2314     int tmpReg = $tmp$$reg;
 2315 
 2316     // SUB $p,$q
 2317     emit_opcode(cbuf,0x2B);
 2318     emit_rm(cbuf, 0x3, $p$$reg, $q$$reg);
 2319     // SBB $tmp,$tmp
 2320     emit_opcode(cbuf,0x1B);
 2321     emit_rm(cbuf, 0x3, tmpReg, tmpReg);
 2322     // AND $tmp,$y
 2323     emit_opcode(cbuf,0x23);
 2324     emit_rm(cbuf, 0x3, tmpReg, $y$$reg);
 2325     // ADD $p,$tmp
 2326     emit_opcode(cbuf,0x03);
 2327     emit_rm(cbuf, 0x3, $p$$reg, tmpReg);
 2328   %}
 2329 
 2330   enc_class shift_left_long( eRegL dst, eCXRegI shift ) %{
 2331     // TEST shift,32
 2332     emit_opcode(cbuf,0xF7);
 2333     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2334     emit_d32(cbuf,0x20);
 2335     // JEQ,s small
 2336     emit_opcode(cbuf, 0x74);
 2337     emit_d8(cbuf, 0x04);
 2338     // MOV    $dst.hi,$dst.lo
 2339     emit_opcode( cbuf, 0x8B );
 2340     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2341     // CLR    $dst.lo
 2342     emit_opcode(cbuf, 0x33);
 2343     emit_rm(cbuf, 0x3, $dst$$reg, $dst$$reg);
 2344 // small:
 2345     // SHLD   $dst.hi,$dst.lo,$shift
 2346     emit_opcode(cbuf,0x0F);
 2347     emit_opcode(cbuf,0xA5);
 2348     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2349     // SHL    $dst.lo,$shift&quot;
 2350     emit_opcode(cbuf,0xD3);
 2351     emit_rm(cbuf, 0x3, 0x4, $dst$$reg );
 2352   %}
 2353 
 2354   enc_class shift_right_long( eRegL dst, eCXRegI shift ) %{
 2355     // TEST shift,32
 2356     emit_opcode(cbuf,0xF7);
 2357     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2358     emit_d32(cbuf,0x20);
 2359     // JEQ,s small
 2360     emit_opcode(cbuf, 0x74);
 2361     emit_d8(cbuf, 0x04);
 2362     // MOV    $dst.lo,$dst.hi
 2363     emit_opcode( cbuf, 0x8B );
 2364     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2365     // CLR    $dst.hi
 2366     emit_opcode(cbuf, 0x33);
 2367     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));
 2368 // small:
 2369     // SHRD   $dst.lo,$dst.hi,$shift
 2370     emit_opcode(cbuf,0x0F);
 2371     emit_opcode(cbuf,0xAD);
 2372     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2373     // SHR    $dst.hi,$shift&quot;
 2374     emit_opcode(cbuf,0xD3);
 2375     emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );
 2376   %}
 2377 
 2378   enc_class shift_right_arith_long( eRegL dst, eCXRegI shift ) %{
 2379     // TEST shift,32
 2380     emit_opcode(cbuf,0xF7);
 2381     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2382     emit_d32(cbuf,0x20);
 2383     // JEQ,s small
 2384     emit_opcode(cbuf, 0x74);
 2385     emit_d8(cbuf, 0x05);
 2386     // MOV    $dst.lo,$dst.hi
 2387     emit_opcode( cbuf, 0x8B );
 2388     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2389     // SAR    $dst.hi,31
 2390     emit_opcode(cbuf, 0xC1);
 2391     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );
 2392     emit_d8(cbuf, 0x1F );
 2393 // small:
 2394     // SHRD   $dst.lo,$dst.hi,$shift
 2395     emit_opcode(cbuf,0x0F);
 2396     emit_opcode(cbuf,0xAD);
 2397     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2398     // SAR    $dst.hi,$shift&quot;
 2399     emit_opcode(cbuf,0xD3);
 2400     emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );
 2401   %}
 2402 
 2403 
 2404   // ----------------- Encodings for floating point unit -----------------
 2405   // May leave result in FPU-TOS or FPU reg depending on opcodes
 2406   enc_class OpcReg_FPR(regFPR src) %{    // FMUL, FDIV
 2407     $$$emit8$primary;
 2408     emit_rm(cbuf, 0x3, $secondary, $src$$reg );
 2409   %}
 2410 
 2411   // Pop argument in FPR0 with FSTP ST(0)
 2412   enc_class PopFPU() %{
 2413     emit_opcode( cbuf, 0xDD );
 2414     emit_d8( cbuf, 0xD8 );
 2415   %}
 2416 
 2417   // !!!!! equivalent to Pop_Reg_F
 2418   enc_class Pop_Reg_DPR( regDPR dst ) %{
 2419     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2420     emit_d8( cbuf, 0xD8+$dst$$reg );
 2421   %}
 2422 
 2423   enc_class Push_Reg_DPR( regDPR dst ) %{
 2424     emit_opcode( cbuf, 0xD9 );
 2425     emit_d8( cbuf, 0xC0-1+$dst$$reg );   // FLD ST(i-1)
 2426   %}
 2427 
 2428   enc_class strictfp_bias1( regDPR dst ) %{
 2429     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2430     emit_opcode( cbuf, 0x2D );
 2431     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias1() );
 2432     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2433     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2434   %}
 2435 
 2436   enc_class strictfp_bias2( regDPR dst ) %{
 2437     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2438     emit_opcode( cbuf, 0x2D );
 2439     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias2() );
 2440     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2441     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2442   %}
 2443 
 2444   // Special case for moving an integer register to a stack slot.
 2445   enc_class OpcPRegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2446     store_to_stackslot( cbuf, $primary, $src$$reg, $dst$$disp );
 2447   %}
 2448 
 2449   // Special case for moving a register to a stack slot.
 2450   enc_class RegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2451     // Opcode already emitted
 2452     emit_rm( cbuf, 0x02, $src$$reg, ESP_enc );   // R/M byte
 2453     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);          // SIB byte
 2454     emit_d32(cbuf, $dst$$disp);   // Displacement
 2455   %}
 2456 
 2457   // Push the integer in stackSlot &#39;src&#39; onto FP-stack
 2458   enc_class Push_Mem_I( memory src ) %{    // FILD   [ESP+src]
 2459     store_to_stackslot( cbuf, $primary, $secondary, $src$$disp );
 2460   %}
 2461 
 2462   // Push FPU&#39;s TOS float to a stack-slot, and pop FPU-stack
 2463   enc_class Pop_Mem_FPR( stackSlotF dst ) %{ // FSTP_S [ESP+dst]
 2464     store_to_stackslot( cbuf, 0xD9, 0x03, $dst$$disp );
 2465   %}
 2466 
 2467   // Same as Pop_Mem_F except for opcode
 2468   // Push FPU&#39;s TOS double to a stack-slot, and pop FPU-stack
 2469   enc_class Pop_Mem_DPR( stackSlotD dst ) %{ // FSTP_D [ESP+dst]
 2470     store_to_stackslot( cbuf, 0xDD, 0x03, $dst$$disp );
 2471   %}
 2472 
 2473   enc_class Pop_Reg_FPR( regFPR dst ) %{
 2474     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2475     emit_d8( cbuf, 0xD8+$dst$$reg );
 2476   %}
 2477 
 2478   enc_class Push_Reg_FPR( regFPR dst ) %{
 2479     emit_opcode( cbuf, 0xD9 );           // FLD    ST(i-1)
 2480     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2481   %}
 2482 
 2483   // Push FPU&#39;s float to a stack-slot, and pop FPU-stack
 2484   enc_class Pop_Mem_Reg_FPR( stackSlotF dst, regFPR src ) %{
 2485     int pop = 0x02;
 2486     if ($src$$reg != FPR1L_enc) {
 2487       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2488       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2489       pop = 0x03;
 2490     }
 2491     store_to_stackslot( cbuf, 0xD9, pop, $dst$$disp ); // FST&lt;P&gt;_S  [ESP+dst]
 2492   %}
 2493 
 2494   // Push FPU&#39;s double to a stack-slot, and pop FPU-stack
 2495   enc_class Pop_Mem_Reg_DPR( stackSlotD dst, regDPR src ) %{
 2496     int pop = 0x02;
 2497     if ($src$$reg != FPR1L_enc) {
 2498       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2499       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2500       pop = 0x03;
 2501     }
 2502     store_to_stackslot( cbuf, 0xDD, pop, $dst$$disp ); // FST&lt;P&gt;_D  [ESP+dst]
 2503   %}
 2504 
 2505   // Push FPU&#39;s double to a FPU-stack-slot, and pop FPU-stack
 2506   enc_class Pop_Reg_Reg_DPR( regDPR dst, regFPR src ) %{
 2507     int pop = 0xD0 - 1; // -1 since we skip FLD
 2508     if ($src$$reg != FPR1L_enc) {
 2509       emit_opcode( cbuf, 0xD9 );         // FLD    ST(src-1)
 2510       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2511       pop = 0xD8;
 2512     }
 2513     emit_opcode( cbuf, 0xDD );
 2514     emit_d8( cbuf, pop+$dst$$reg );      // FST&lt;P&gt; ST(i)
 2515   %}
 2516 
 2517 
 2518   enc_class Push_Reg_Mod_DPR( regDPR dst, regDPR src) %{
 2519     // load dst in FPR0
 2520     emit_opcode( cbuf, 0xD9 );
 2521     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2522     if ($src$$reg != FPR1L_enc) {
 2523       // fincstp
 2524       emit_opcode (cbuf, 0xD9);
 2525       emit_opcode (cbuf, 0xF7);
 2526       // swap src with FPR1:
 2527       // FXCH FPR1 with src
 2528       emit_opcode(cbuf, 0xD9);
 2529       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2530       // fdecstp
 2531       emit_opcode (cbuf, 0xD9);
 2532       emit_opcode (cbuf, 0xF6);
 2533     }
 2534   %}
 2535 
 2536   enc_class Push_ModD_encoding(regD src0, regD src1) %{
 2537     MacroAssembler _masm(&amp;cbuf);
 2538     __ subptr(rsp, 8);
 2539     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
 2540     __ fld_d(Address(rsp, 0));
 2541     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
 2542     __ fld_d(Address(rsp, 0));
 2543   %}
 2544 
 2545   enc_class Push_ModF_encoding(regF src0, regF src1) %{
 2546     MacroAssembler _masm(&amp;cbuf);
 2547     __ subptr(rsp, 4);
 2548     __ movflt(Address(rsp, 0), $src1$$XMMRegister);
 2549     __ fld_s(Address(rsp, 0));
 2550     __ movflt(Address(rsp, 0), $src0$$XMMRegister);
 2551     __ fld_s(Address(rsp, 0));
 2552   %}
 2553 
 2554   enc_class Push_ResultD(regD dst) %{
 2555     MacroAssembler _masm(&amp;cbuf);
 2556     __ fstp_d(Address(rsp, 0));
 2557     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2558     __ addptr(rsp, 8);
 2559   %}
 2560 
 2561   enc_class Push_ResultF(regF dst, immI d8) %{
 2562     MacroAssembler _masm(&amp;cbuf);
 2563     __ fstp_s(Address(rsp, 0));
 2564     __ movflt($dst$$XMMRegister, Address(rsp, 0));
 2565     __ addptr(rsp, $d8$$constant);
 2566   %}
 2567 
 2568   enc_class Push_SrcD(regD src) %{
 2569     MacroAssembler _masm(&amp;cbuf);
 2570     __ subptr(rsp, 8);
 2571     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2572     __ fld_d(Address(rsp, 0));
 2573   %}
 2574 
 2575   enc_class push_stack_temp_qword() %{
 2576     MacroAssembler _masm(&amp;cbuf);
 2577     __ subptr(rsp, 8);
 2578   %}
 2579 
 2580   enc_class pop_stack_temp_qword() %{
 2581     MacroAssembler _masm(&amp;cbuf);
 2582     __ addptr(rsp, 8);
 2583   %}
 2584 
 2585   enc_class push_xmm_to_fpr1(regD src) %{
 2586     MacroAssembler _masm(&amp;cbuf);
 2587     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2588     __ fld_d(Address(rsp, 0));
 2589   %}
 2590 
 2591   enc_class Push_Result_Mod_DPR( regDPR src) %{
 2592     if ($src$$reg != FPR1L_enc) {
 2593       // fincstp
 2594       emit_opcode (cbuf, 0xD9);
 2595       emit_opcode (cbuf, 0xF7);
 2596       // FXCH FPR1 with src
 2597       emit_opcode(cbuf, 0xD9);
 2598       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2599       // fdecstp
 2600       emit_opcode (cbuf, 0xD9);
 2601       emit_opcode (cbuf, 0xF6);
 2602     }
 2603     // // following asm replaced with Pop_Reg_F or Pop_Mem_F
 2604     // // FSTP   FPR$dst$$reg
 2605     // emit_opcode( cbuf, 0xDD );
 2606     // emit_d8( cbuf, 0xD8+$dst$$reg );
 2607   %}
 2608 
 2609   enc_class fnstsw_sahf_skip_parity() %{
 2610     // fnstsw ax
 2611     emit_opcode( cbuf, 0xDF );
 2612     emit_opcode( cbuf, 0xE0 );
 2613     // sahf
 2614     emit_opcode( cbuf, 0x9E );
 2615     // jnp  ::skip
 2616     emit_opcode( cbuf, 0x7B );
 2617     emit_opcode( cbuf, 0x05 );
 2618   %}
 2619 
 2620   enc_class emitModDPR() %{
 2621     // fprem must be iterative
 2622     // :: loop
 2623     // fprem
 2624     emit_opcode( cbuf, 0xD9 );
 2625     emit_opcode( cbuf, 0xF8 );
 2626     // wait
 2627     emit_opcode( cbuf, 0x9b );
 2628     // fnstsw ax
 2629     emit_opcode( cbuf, 0xDF );
 2630     emit_opcode( cbuf, 0xE0 );
 2631     // sahf
 2632     emit_opcode( cbuf, 0x9E );
 2633     // jp  ::loop
 2634     emit_opcode( cbuf, 0x0F );
 2635     emit_opcode( cbuf, 0x8A );
 2636     emit_opcode( cbuf, 0xF4 );
 2637     emit_opcode( cbuf, 0xFF );
 2638     emit_opcode( cbuf, 0xFF );
 2639     emit_opcode( cbuf, 0xFF );
 2640   %}
 2641 
 2642   enc_class fpu_flags() %{
 2643     // fnstsw_ax
 2644     emit_opcode( cbuf, 0xDF);
 2645     emit_opcode( cbuf, 0xE0);
 2646     // test ax,0x0400
 2647     emit_opcode( cbuf, 0x66 );   // operand-size prefix for 16-bit immediate
 2648     emit_opcode( cbuf, 0xA9 );
 2649     emit_d16   ( cbuf, 0x0400 );
 2650     // // // This sequence works, but stalls for 12-16 cycles on PPro
 2651     // // test rax,0x0400
 2652     // emit_opcode( cbuf, 0xA9 );
 2653     // emit_d32   ( cbuf, 0x00000400 );
 2654     //
 2655     // jz exit (no unordered comparison)
 2656     emit_opcode( cbuf, 0x74 );
 2657     emit_d8    ( cbuf, 0x02 );
 2658     // mov ah,1 - treat as LT case (set carry flag)
 2659     emit_opcode( cbuf, 0xB4 );
 2660     emit_d8    ( cbuf, 0x01 );
 2661     // sahf
 2662     emit_opcode( cbuf, 0x9E);
 2663   %}
 2664 
 2665   enc_class cmpF_P6_fixup() %{
 2666     // Fixup the integer flags in case comparison involved a NaN
 2667     //
 2668     // JNP exit (no unordered comparison, P-flag is set by NaN)
 2669     emit_opcode( cbuf, 0x7B );
 2670     emit_d8    ( cbuf, 0x03 );
 2671     // MOV AH,1 - treat as LT case (set carry flag)
 2672     emit_opcode( cbuf, 0xB4 );
 2673     emit_d8    ( cbuf, 0x01 );
 2674     // SAHF
 2675     emit_opcode( cbuf, 0x9E);
 2676     // NOP     // target for branch to avoid branch to branch
 2677     emit_opcode( cbuf, 0x90);
 2678   %}
 2679 
 2680 //     fnstsw_ax();
 2681 //     sahf();
 2682 //     movl(dst, nan_result);
 2683 //     jcc(Assembler::parity, exit);
 2684 //     movl(dst, less_result);
 2685 //     jcc(Assembler::below, exit);
 2686 //     movl(dst, equal_result);
 2687 //     jcc(Assembler::equal, exit);
 2688 //     movl(dst, greater_result);
 2689 
 2690 // less_result     =  1;
 2691 // greater_result  = -1;
 2692 // equal_result    = 0;
 2693 // nan_result      = -1;
 2694 
 2695   enc_class CmpF_Result(rRegI dst) %{
 2696     // fnstsw_ax();
 2697     emit_opcode( cbuf, 0xDF);
 2698     emit_opcode( cbuf, 0xE0);
 2699     // sahf
 2700     emit_opcode( cbuf, 0x9E);
 2701     // movl(dst, nan_result);
 2702     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2703     emit_d32( cbuf, -1 );
 2704     // jcc(Assembler::parity, exit);
 2705     emit_opcode( cbuf, 0x7A );
 2706     emit_d8    ( cbuf, 0x13 );
 2707     // movl(dst, less_result);
 2708     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2709     emit_d32( cbuf, -1 );
 2710     // jcc(Assembler::below, exit);
 2711     emit_opcode( cbuf, 0x72 );
 2712     emit_d8    ( cbuf, 0x0C );
 2713     // movl(dst, equal_result);
 2714     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2715     emit_d32( cbuf, 0 );
 2716     // jcc(Assembler::equal, exit);
 2717     emit_opcode( cbuf, 0x74 );
 2718     emit_d8    ( cbuf, 0x05 );
 2719     // movl(dst, greater_result);
 2720     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2721     emit_d32( cbuf, 1 );
 2722   %}
 2723 
 2724 
 2725   // Compare the longs and set flags
 2726   // BROKEN!  Do Not use as-is
 2727   enc_class cmpl_test( eRegL src1, eRegL src2 ) %{
 2728     // CMP    $src1.hi,$src2.hi
 2729     emit_opcode( cbuf, 0x3B );
 2730     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2731     // JNE,s  done
 2732     emit_opcode(cbuf,0x75);
 2733     emit_d8(cbuf, 2 );
 2734     // CMP    $src1.lo,$src2.lo
 2735     emit_opcode( cbuf, 0x3B );
 2736     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2737 // done:
 2738   %}
 2739 
 2740   enc_class convert_int_long( regL dst, rRegI src ) %{
 2741     // mov $dst.lo,$src
 2742     int dst_encoding = $dst$$reg;
 2743     int src_encoding = $src$$reg;
 2744     encode_Copy( cbuf, dst_encoding  , src_encoding );
 2745     // mov $dst.hi,$src
 2746     encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );
 2747     // sar $dst.hi,31
 2748     emit_opcode( cbuf, 0xC1 );
 2749     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );
 2750     emit_d8(cbuf, 0x1F );
 2751   %}
 2752 
 2753   enc_class convert_long_double( eRegL src ) %{
 2754     // push $src.hi
 2755     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2756     // push $src.lo
 2757     emit_opcode(cbuf, 0x50+$src$$reg  );
 2758     // fild 64-bits at [SP]
 2759     emit_opcode(cbuf,0xdf);
 2760     emit_d8(cbuf, 0x6C);
 2761     emit_d8(cbuf, 0x24);
 2762     emit_d8(cbuf, 0x00);
 2763     // pop stack
 2764     emit_opcode(cbuf, 0x83); // add  SP, #8
 2765     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2766     emit_d8(cbuf, 0x8);
 2767   %}
 2768 
 2769   enc_class multiply_con_and_shift_high( eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr ) %{
 2770     // IMUL   EDX:EAX,$src1
 2771     emit_opcode( cbuf, 0xF7 );
 2772     emit_rm( cbuf, 0x3, 0x5, $src1$$reg );
 2773     // SAR    EDX,$cnt-32
 2774     int shift_count = ((int)$cnt$$constant) - 32;
 2775     if (shift_count &gt; 0) {
 2776       emit_opcode(cbuf, 0xC1);
 2777       emit_rm(cbuf, 0x3, 7, $dst$$reg );
 2778       emit_d8(cbuf, shift_count);
 2779     }
 2780   %}
 2781 
 2782   // this version doesn&#39;t have add sp, 8
 2783   enc_class convert_long_double2( eRegL src ) %{
 2784     // push $src.hi
 2785     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2786     // push $src.lo
 2787     emit_opcode(cbuf, 0x50+$src$$reg  );
 2788     // fild 64-bits at [SP]
 2789     emit_opcode(cbuf,0xdf);
 2790     emit_d8(cbuf, 0x6C);
 2791     emit_d8(cbuf, 0x24);
 2792     emit_d8(cbuf, 0x00);
 2793   %}
 2794 
 2795   enc_class long_int_multiply( eADXRegL dst, nadxRegI src) %{
 2796     // Basic idea: long = (long)int * (long)int
 2797     // IMUL EDX:EAX, src
 2798     emit_opcode( cbuf, 0xF7 );
 2799     emit_rm( cbuf, 0x3, 0x5, $src$$reg);
 2800   %}
 2801 
 2802   enc_class long_uint_multiply( eADXRegL dst, nadxRegI src) %{
 2803     // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 2804     // MUL EDX:EAX, src
 2805     emit_opcode( cbuf, 0xF7 );
 2806     emit_rm( cbuf, 0x3, 0x4, $src$$reg);
 2807   %}
 2808 
 2809   enc_class long_multiply( eADXRegL dst, eRegL src, rRegI tmp ) %{
 2810     // Basic idea: lo(result) = lo(x_lo * y_lo)
 2811     //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 2812     // MOV    $tmp,$src.lo
 2813     encode_Copy( cbuf, $tmp$$reg, $src$$reg );
 2814     // IMUL   $tmp,EDX
 2815     emit_opcode( cbuf, 0x0F );
 2816     emit_opcode( cbuf, 0xAF );
 2817     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2818     // MOV    EDX,$src.hi
 2819     encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );
 2820     // IMUL   EDX,EAX
 2821     emit_opcode( cbuf, 0x0F );
 2822     emit_opcode( cbuf, 0xAF );
 2823     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2824     // ADD    $tmp,EDX
 2825     emit_opcode( cbuf, 0x03 );
 2826     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2827     // MUL   EDX:EAX,$src.lo
 2828     emit_opcode( cbuf, 0xF7 );
 2829     emit_rm( cbuf, 0x3, 0x4, $src$$reg );
 2830     // ADD    EDX,ESI
 2831     emit_opcode( cbuf, 0x03 );
 2832     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );
 2833   %}
 2834 
 2835   enc_class long_multiply_con( eADXRegL dst, immL_127 src, rRegI tmp ) %{
 2836     // Basic idea: lo(result) = lo(src * y_lo)
 2837     //             hi(result) = hi(src * y_lo) + lo(src * y_hi)
 2838     // IMUL   $tmp,EDX,$src
 2839     emit_opcode( cbuf, 0x6B );
 2840     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2841     emit_d8( cbuf, (int)$src$$constant );
 2842     // MOV    EDX,$src
 2843     emit_opcode(cbuf, 0xB8 + EDX_enc);
 2844     emit_d32( cbuf, (int)$src$$constant );
 2845     // MUL   EDX:EAX,EDX
 2846     emit_opcode( cbuf, 0xF7 );
 2847     emit_rm( cbuf, 0x3, 0x4, EDX_enc );
 2848     // ADD    EDX,ESI
 2849     emit_opcode( cbuf, 0x03 );
 2850     emit_rm( cbuf, 0x3, EDX_enc, $tmp$$reg );
 2851   %}
 2852 
 2853   enc_class long_div( eRegL src1, eRegL src2 ) %{
 2854     // PUSH src1.hi
 2855     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2856     // PUSH src1.lo
 2857     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2858     // PUSH src2.hi
 2859     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2860     // PUSH src2.lo
 2861     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2862     // CALL directly to the runtime
 2863     cbuf.set_insts_mark();
 2864     emit_opcode(cbuf,0xE8);       // Call into runtime
 2865     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2866     // Restore stack
 2867     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2868     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2869     emit_d8(cbuf, 4*4);
 2870   %}
 2871 
 2872   enc_class long_mod( eRegL src1, eRegL src2 ) %{
 2873     // PUSH src1.hi
 2874     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2875     // PUSH src1.lo
 2876     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2877     // PUSH src2.hi
 2878     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2879     // PUSH src2.lo
 2880     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2881     // CALL directly to the runtime
 2882     cbuf.set_insts_mark();
 2883     emit_opcode(cbuf,0xE8);       // Call into runtime
 2884     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2885     // Restore stack
 2886     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2887     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2888     emit_d8(cbuf, 4*4);
 2889   %}
 2890 
 2891   enc_class long_cmp_flags0( eRegL src, rRegI tmp ) %{
 2892     // MOV   $tmp,$src.lo
 2893     emit_opcode(cbuf, 0x8B);
 2894     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg);
 2895     // OR    $tmp,$src.hi
 2896     emit_opcode(cbuf, 0x0B);
 2897     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));
 2898   %}
 2899 
 2900   enc_class long_cmp_flags1( eRegL src1, eRegL src2 ) %{
 2901     // CMP    $src1.lo,$src2.lo
 2902     emit_opcode( cbuf, 0x3B );
 2903     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2904     // JNE,s  skip
 2905     emit_cc(cbuf, 0x70, 0x5);
 2906     emit_d8(cbuf,2);
 2907     // CMP    $src1.hi,$src2.hi
 2908     emit_opcode( cbuf, 0x3B );
 2909     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2910   %}
 2911 
 2912   enc_class long_cmp_flags2( eRegL src1, eRegL src2, rRegI tmp ) %{
 2913     // CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits
 2914     emit_opcode( cbuf, 0x3B );
 2915     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2916     // MOV    $tmp,$src1.hi
 2917     emit_opcode( cbuf, 0x8B );
 2918     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );
 2919     // SBB   $tmp,$src2.hi\t! Compute flags for long compare
 2920     emit_opcode( cbuf, 0x1B );
 2921     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );
 2922   %}
 2923 
 2924   enc_class long_cmp_flags3( eRegL src, rRegI tmp ) %{
 2925     // XOR    $tmp,$tmp
 2926     emit_opcode(cbuf,0x33);  // XOR
 2927     emit_rm(cbuf,0x3, $tmp$$reg, $tmp$$reg);
 2928     // CMP    $tmp,$src.lo
 2929     emit_opcode( cbuf, 0x3B );
 2930     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg );
 2931     // SBB    $tmp,$src.hi
 2932     emit_opcode( cbuf, 0x1B );
 2933     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );
 2934   %}
 2935 
 2936  // Sniff, sniff... smells like Gnu Superoptimizer
 2937   enc_class neg_long( eRegL dst ) %{
 2938     emit_opcode(cbuf,0xF7);    // NEG hi
 2939     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2940     emit_opcode(cbuf,0xF7);    // NEG lo
 2941     emit_rm    (cbuf,0x3, 0x3,               $dst$$reg );
 2942     emit_opcode(cbuf,0x83);    // SBB hi,0
 2943     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2944     emit_d8    (cbuf,0 );
 2945   %}
 2946 
 2947   enc_class enc_pop_rdx() %{
 2948     emit_opcode(cbuf,0x5A);
 2949   %}
 2950 
 2951   enc_class enc_rethrow() %{
 2952     cbuf.set_insts_mark();
 2953     emit_opcode(cbuf, 0xE9);        // jmp    entry
 2954     emit_d32_reloc(cbuf, (int)OptoRuntime::rethrow_stub() - ((int)cbuf.insts_end())-4,
 2955                    runtime_call_Relocation::spec(), RELOC_IMM32 );
 2956   %}
 2957 
 2958 
 2959   // Convert a double to an int.  Java semantics require we do complex
 2960   // manglelations in the corner cases.  So we set the rounding mode to
 2961   // &#39;zero&#39;, store the darned double down as an int, and reset the
 2962   // rounding mode to &#39;nearest&#39;.  The hardware throws an exception which
 2963   // patches up the correct value directly to the stack.
 2964   enc_class DPR2I_encoding( regDPR src ) %{
 2965     // Flip to round-to-zero mode.  We attempted to allow invalid-op
 2966     // exceptions here, so that a NAN or other corner-case value will
 2967     // thrown an exception (but normal values get converted at full speed).
 2968     // However, I2C adapters and other float-stack manglers leave pending
 2969     // invalid-op exceptions hanging.  We would have to clear them before
 2970     // enabling them and that is more expensive than just testing for the
 2971     // invalid value Intel stores down in the corner cases.
 2972     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 2973     emit_opcode(cbuf,0x2D);
 2974     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 2975     // Allocate a word
 2976     emit_opcode(cbuf,0x83);            // SUB ESP,4
 2977     emit_opcode(cbuf,0xEC);
 2978     emit_d8(cbuf,0x04);
 2979     // Encoding assumes a double has been pushed into FPR0.
 2980     // Store down the double as an int, popping the FPU stack
 2981     emit_opcode(cbuf,0xDB);            // FISTP [ESP]
 2982     emit_opcode(cbuf,0x1C);
 2983     emit_d8(cbuf,0x24);
 2984     // Restore the rounding mode; mask the exception
 2985     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 2986     emit_opcode(cbuf,0x2D);
 2987     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 2988         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 2989         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 2990 
 2991     // Load the converted int; adjust CPU stack
 2992     emit_opcode(cbuf,0x58);       // POP EAX
 2993     emit_opcode(cbuf,0x3D);       // CMP EAX,imm
 2994     emit_d32   (cbuf,0x80000000); //         0x80000000
 2995     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 2996     emit_d8    (cbuf,0x07);       // Size of slow_call
 2997     // Push src onto stack slow-path
 2998     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 2999     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3000     // CALL directly to the runtime
 3001     cbuf.set_insts_mark();
 3002     emit_opcode(cbuf,0xE8);       // Call into runtime
 3003     emit_d32_reloc(cbuf, (StubRoutines::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3004     // Carry on here...
 3005   %}
 3006 
 3007   enc_class DPR2L_encoding( regDPR src ) %{
 3008     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 3009     emit_opcode(cbuf,0x2D);
 3010     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 3011     // Allocate a word
 3012     emit_opcode(cbuf,0x83);            // SUB ESP,8
 3013     emit_opcode(cbuf,0xEC);
 3014     emit_d8(cbuf,0x08);
 3015     // Encoding assumes a double has been pushed into FPR0.
 3016     // Store down the double as a long, popping the FPU stack
 3017     emit_opcode(cbuf,0xDF);            // FISTP [ESP]
 3018     emit_opcode(cbuf,0x3C);
 3019     emit_d8(cbuf,0x24);
 3020     // Restore the rounding mode; mask the exception
 3021     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3022     emit_opcode(cbuf,0x2D);
 3023     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3024         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3025         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3026 
 3027     // Load the converted int; adjust CPU stack
 3028     emit_opcode(cbuf,0x58);       // POP EAX
 3029     emit_opcode(cbuf,0x5A);       // POP EDX
 3030     emit_opcode(cbuf,0x81);       // CMP EDX,imm
 3031     emit_d8    (cbuf,0xFA);       // rdx
 3032     emit_d32   (cbuf,0x80000000); //         0x80000000
 3033     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3034     emit_d8    (cbuf,0x07+4);     // Size of slow_call
 3035     emit_opcode(cbuf,0x85);       // TEST EAX,EAX
 3036     emit_opcode(cbuf,0xC0);       // 2/rax,/rax,
 3037     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3038     emit_d8    (cbuf,0x07);       // Size of slow_call
 3039     // Push src onto stack slow-path
 3040     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3041     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3042     // CALL directly to the runtime
 3043     cbuf.set_insts_mark();
 3044     emit_opcode(cbuf,0xE8);       // Call into runtime
 3045     emit_d32_reloc(cbuf, (StubRoutines::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3046     // Carry on here...
 3047   %}
 3048 
 3049   enc_class FMul_ST_reg( eRegFPR src1 ) %{
 3050     // Operand was loaded from memory into fp ST (stack top)
 3051     // FMUL   ST,$src  /* D8 C8+i */
 3052     emit_opcode(cbuf, 0xD8);
 3053     emit_opcode(cbuf, 0xC8 + $src1$$reg);
 3054   %}
 3055 
 3056   enc_class FAdd_ST_reg( eRegFPR src2 ) %{
 3057     // FADDP  ST,src2  /* D8 C0+i */
 3058     emit_opcode(cbuf, 0xD8);
 3059     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3060     //could use FADDP  src2,fpST  /* DE C0+i */
 3061   %}
 3062 
 3063   enc_class FAddP_reg_ST( eRegFPR src2 ) %{
 3064     // FADDP  src2,ST  /* DE C0+i */
 3065     emit_opcode(cbuf, 0xDE);
 3066     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3067   %}
 3068 
 3069   enc_class subFPR_divFPR_encode( eRegFPR src1, eRegFPR src2) %{
 3070     // Operand has been loaded into fp ST (stack top)
 3071       // FSUB   ST,$src1
 3072       emit_opcode(cbuf, 0xD8);
 3073       emit_opcode(cbuf, 0xE0 + $src1$$reg);
 3074 
 3075       // FDIV
 3076       emit_opcode(cbuf, 0xD8);
 3077       emit_opcode(cbuf, 0xF0 + $src2$$reg);
 3078   %}
 3079 
 3080   enc_class MulFAddF (eRegFPR src1, eRegFPR src2) %{
 3081     // Operand was loaded from memory into fp ST (stack top)
 3082     // FADD   ST,$src  /* D8 C0+i */
 3083     emit_opcode(cbuf, 0xD8);
 3084     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3085 
 3086     // FMUL  ST,src2  /* D8 C*+i */
 3087     emit_opcode(cbuf, 0xD8);
 3088     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3089   %}
 3090 
 3091 
 3092   enc_class MulFAddFreverse (eRegFPR src1, eRegFPR src2) %{
 3093     // Operand was loaded from memory into fp ST (stack top)
 3094     // FADD   ST,$src  /* D8 C0+i */
 3095     emit_opcode(cbuf, 0xD8);
 3096     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3097 
 3098     // FMULP  src2,ST  /* DE C8+i */
 3099     emit_opcode(cbuf, 0xDE);
 3100     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3101   %}
 3102 
 3103   // Atomically load the volatile long
 3104   enc_class enc_loadL_volatile( memory mem, stackSlotL dst ) %{
 3105     emit_opcode(cbuf,0xDF);
 3106     int rm_byte_opcode = 0x05;
 3107     int base     = $mem$$base;
 3108     int index    = $mem$$index;
 3109     int scale    = $mem$$scale;
 3110     int displace = $mem$$disp;
 3111     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3112     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3113     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3114   %}
 3115 
 3116   // Volatile Store Long.  Must be atomic, so move it into
 3117   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3118   // target address before the store (for null-ptr checks)
 3119   // so the memory operand is used twice in the encoding.
 3120   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3121     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3122     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3123     emit_opcode(cbuf,0xDF);
 3124     int rm_byte_opcode = 0x07;
 3125     int base     = $mem$$base;
 3126     int index    = $mem$$index;
 3127     int scale    = $mem$$scale;
 3128     int displace = $mem$$disp;
 3129     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3130     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3131   %}
 3132 
 3133 %}
 3134 
 3135 
 3136 //----------FRAME--------------------------------------------------------------
 3137 // Definition of frame structure and management information.
 3138 //
 3139 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3140 //                             |   (to get allocators register number
 3141 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3142 //  r   CALLER     |        |
 3143 //  o     |        +--------+      pad to even-align allocators stack-slot
 3144 //  w     V        |  pad0  |        numbers; owned by CALLER
 3145 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3146 //  h     ^        |   in   |  5
 3147 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3148 //  |     |        |        |  3
 3149 //  |     |        +--------+
 3150 //  V     |        | old out|      Empty on Intel, window on Sparc
 3151 //        |    old |preserve|      Must be even aligned.
 3152 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 3153 //        |        |   in   |  3   area for Intel ret address
 3154 //     Owned by    |preserve|      Empty on Sparc.
 3155 //       SELF      +--------+
 3156 //        |        |  pad2  |  2   pad to align old SP
 3157 //        |        +--------+  1
 3158 //        |        | locks  |  0
 3159 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 3160 //        |        |  pad1  | 11   pad to align new SP
 3161 //        |        +--------+
 3162 //        |        |        | 10
 3163 //        |        | spills |  9   spills
 3164 //        V        |        |  8   (pad0 slot for callee)
 3165 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 3166 //        ^        |  out   |  7
 3167 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 3168 //     Owned by    +--------+
 3169 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 3170 //        |    new |preserve|      Must be even-aligned.
 3171 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 3172 //        |        |        |
 3173 //
 3174 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 3175 //         known from SELF&#39;s arguments and the Java calling convention.
 3176 //         Region 6-7 is determined per call site.
 3177 // Note 2: If the calling convention leaves holes in the incoming argument
 3178 //         area, those holes are owned by SELF.  Holes in the outgoing area
 3179 //         are owned by the CALLEE.  Holes should not be nessecary in the
 3180 //         incoming area, as the Java calling convention is completely under
 3181 //         the control of the AD file.  Doubles can be sorted and packed to
 3182 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 3183 //         varargs C calling conventions.
 3184 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 3185 //         even aligned with pad0 as needed.
 3186 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 3187 //         region 6-11 is even aligned; it may be padded out more so that
 3188 //         the region from SP to FP meets the minimum stack alignment.
 3189 
 3190 frame %{
 3191   // What direction does stack grow in (assumed to be same for C &amp; Java)
 3192   stack_direction(TOWARDS_LOW);
 3193 
 3194   // These three registers define part of the calling convention
 3195   // between compiled code and the interpreter.
 3196   inline_cache_reg(EAX);                // Inline Cache Register
 3197   interpreter_method_oop_reg(EBX);      // Method Oop Register when calling interpreter
 3198 
 3199   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 3200   cisc_spilling_operand_name(indOffset32);
 3201 
 3202   // Number of stack slots consumed by locking an object
 3203   sync_stack_slots(1);
 3204 
 3205   // Compiled code&#39;s Frame Pointer
 3206   frame_pointer(ESP);
 3207   // Interpreter stores its frame pointer in a register which is
 3208   // stored to the stack by I2CAdaptors.
 3209   // I2CAdaptors convert from interpreted java to compiled java.
 3210   interpreter_frame_pointer(EBP);
 3211 
 3212   // Stack alignment requirement
 3213   // Alignment size in bytes (128-bit -&gt; 16 bytes)
 3214   stack_alignment(StackAlignmentInBytes);
 3215 
 3216   // Number of stack slots between incoming argument block and the start of
 3217   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3218   // EPILOG must remove this many slots.  Intel needs one slot for
 3219   // return address and one for rbp, (must save rbp)
 3220   in_preserve_stack_slots(2+VerifyStackAtCalls);
 3221 
 3222   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3223   // for calls to C.  Supports the var-args backing area for register parms.
 3224   varargs_C_out_slots_killed(0);
 3225 
 3226   // The after-PROLOG location of the return address.  Location of
 3227   // return address specifies a type (REG or STACK) and a number
 3228   // representing the register number (i.e. - use a register name) or
 3229   // stack slot.
 3230   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 3231   // Otherwise, it is above the locks and verification slot and alignment word
 3232   return_addr(STACK - 1 +
 3233               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 3234                         Compile::current()-&gt;fixed_slots()),
 3235                        stack_alignment_in_slots()));
 3236 
 3237   // Body of function which returns an integer array locating
 3238   // arguments either in registers or in stack slots.  Passed an array
 3239   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3240   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3241   // arguments for a CALLEE.  Incoming stack arguments are
 3242   // automatically biased by the preserve_stack_slots field above.
 3243   calling_convention %{
 3244     // No difference between ingoing/outgoing just pass false
 3245     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 3246   %}
 3247 
 3248 
 3249   // Body of function which returns an integer array locating
 3250   // arguments either in registers or in stack slots.  Passed an array
 3251   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3252   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3253   // arguments for a CALLEE.  Incoming stack arguments are
 3254   // automatically biased by the preserve_stack_slots field above.
 3255   c_calling_convention %{
 3256     // This is obviously always outgoing
 3257     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3258   %}
 3259 
 3260   // Location of C &amp; interpreter return values
 3261   c_return_value %{
 3262     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3263     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3264     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3265 
 3266     // in SSE2+ mode we want to keep the FPU stack clean so pretend
 3267     // that C functions return float and double results in XMM0.
 3268     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3269       return OptoRegPair(XMM0b_num,XMM0_num);
 3270     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=2 )
 3271       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3272 
 3273     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3274   %}
 3275 
 3276   // Location of return values
 3277   return_value %{
 3278     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3279     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3280     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3281     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3282       return OptoRegPair(XMM0b_num,XMM0_num);
 3283     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=1 )
 3284       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3285     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3286   %}
 3287 
 3288 %}
 3289 
 3290 //----------ATTRIBUTES---------------------------------------------------------
 3291 //----------Operand Attributes-------------------------------------------------
 3292 op_attrib op_cost(0);        // Required cost attribute
 3293 
 3294 //----------Instruction Attributes---------------------------------------------
 3295 ins_attrib ins_cost(100);       // Required cost attribute
 3296 ins_attrib ins_size(8);         // Required size attribute (in bits)
 3297 ins_attrib ins_short_branch(0); // Required flag: is this instruction a
 3298                                 // non-matching short branch variant of some
 3299                                                             // long branch?
 3300 ins_attrib ins_alignment(1);    // Required alignment attribute (must be a power of 2)
 3301                                 // specifies the alignment that some part of the instruction (not
 3302                                 // necessarily the start) requires.  If &gt; 1, a compute_padding()
 3303                                 // function must be provided for the instruction
 3304 
 3305 //----------OPERANDS-----------------------------------------------------------
 3306 // Operand definitions must precede instruction definitions for correct parsing
 3307 // in the ADLC because operands constitute user defined types which are used in
 3308 // instruction definitions.
 3309 
 3310 //----------Simple Operands----------------------------------------------------
 3311 // Immediate Operands
 3312 // Integer Immediate
 3313 operand immI() %{
 3314   match(ConI);
 3315 
 3316   op_cost(10);
 3317   format %{ %}
 3318   interface(CONST_INTER);
 3319 %}
 3320 
 3321 // Constant for test vs zero
 3322 operand immI0() %{
 3323   predicate(n-&gt;get_int() == 0);
 3324   match(ConI);
 3325 
 3326   op_cost(0);
 3327   format %{ %}
 3328   interface(CONST_INTER);
 3329 %}
 3330 
 3331 // Constant for increment
 3332 operand immI1() %{
 3333   predicate(n-&gt;get_int() == 1);
 3334   match(ConI);
 3335 
 3336   op_cost(0);
 3337   format %{ %}
 3338   interface(CONST_INTER);
 3339 %}
 3340 
 3341 // Constant for decrement
 3342 operand immI_M1() %{
 3343   predicate(n-&gt;get_int() == -1);
 3344   match(ConI);
 3345 
 3346   op_cost(0);
 3347   format %{ %}
 3348   interface(CONST_INTER);
 3349 %}
 3350 
 3351 // Valid scale values for addressing modes
 3352 operand immI2() %{
 3353   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3354   match(ConI);
 3355 
 3356   format %{ %}
 3357   interface(CONST_INTER);
 3358 %}
 3359 
 3360 operand immI8() %{
 3361   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3362   match(ConI);
 3363 
 3364   op_cost(5);
 3365   format %{ %}
 3366   interface(CONST_INTER);
 3367 %}
 3368 
 3369 operand immU8() %{
 3370   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 3371   match(ConI);
 3372 
 3373   op_cost(5);
 3374   format %{ %}
 3375   interface(CONST_INTER);
 3376 %}
 3377 
 3378 operand immI16() %{
 3379   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3380   match(ConI);
 3381 
 3382   op_cost(10);
 3383   format %{ %}
 3384   interface(CONST_INTER);
 3385 %}
 3386 
 3387 // Int Immediate non-negative
 3388 operand immU31()
 3389 %{
 3390   predicate(n-&gt;get_int() &gt;= 0);
 3391   match(ConI);
 3392 
 3393   op_cost(0);
 3394   format %{ %}
 3395   interface(CONST_INTER);
 3396 %}
 3397 
 3398 // Constant for long shifts
 3399 operand immI_32() %{
 3400   predicate( n-&gt;get_int() == 32 );
 3401   match(ConI);
 3402 
 3403   op_cost(0);
 3404   format %{ %}
 3405   interface(CONST_INTER);
 3406 %}
 3407 
 3408 operand immI_1_31() %{
 3409   predicate( n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31 );
 3410   match(ConI);
 3411 
 3412   op_cost(0);
 3413   format %{ %}
 3414   interface(CONST_INTER);
 3415 %}
 3416 
 3417 operand immI_32_63() %{
 3418   predicate( n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63 );
 3419   match(ConI);
 3420   op_cost(0);
 3421 
 3422   format %{ %}
 3423   interface(CONST_INTER);
 3424 %}
 3425 
 3426 operand immI_1() %{
 3427   predicate( n-&gt;get_int() == 1 );
 3428   match(ConI);
 3429 
 3430   op_cost(0);
 3431   format %{ %}
 3432   interface(CONST_INTER);
 3433 %}
 3434 
 3435 operand immI_2() %{
 3436   predicate( n-&gt;get_int() == 2 );
 3437   match(ConI);
 3438 
 3439   op_cost(0);
 3440   format %{ %}
 3441   interface(CONST_INTER);
 3442 %}
 3443 
 3444 operand immI_3() %{
 3445   predicate( n-&gt;get_int() == 3 );
 3446   match(ConI);
 3447 
 3448   op_cost(0);
 3449   format %{ %}
 3450   interface(CONST_INTER);
 3451 %}
 3452 
 3453 // Pointer Immediate
 3454 operand immP() %{
 3455   match(ConP);
 3456 
 3457   op_cost(10);
 3458   format %{ %}
 3459   interface(CONST_INTER);
 3460 %}
 3461 
 3462 // NULL Pointer Immediate
 3463 operand immP0() %{
 3464   predicate( n-&gt;get_ptr() == 0 );
 3465   match(ConP);
 3466   op_cost(0);
 3467 
 3468   format %{ %}
 3469   interface(CONST_INTER);
 3470 %}
 3471 
 3472 // Long Immediate
 3473 operand immL() %{
 3474   match(ConL);
 3475 
 3476   op_cost(20);
 3477   format %{ %}
 3478   interface(CONST_INTER);
 3479 %}
 3480 
 3481 // Long Immediate zero
 3482 operand immL0() %{
 3483   predicate( n-&gt;get_long() == 0L );
 3484   match(ConL);
 3485   op_cost(0);
 3486 
 3487   format %{ %}
 3488   interface(CONST_INTER);
 3489 %}
 3490 
 3491 // Long Immediate zero
 3492 operand immL_M1() %{
 3493   predicate( n-&gt;get_long() == -1L );
 3494   match(ConL);
 3495   op_cost(0);
 3496 
 3497   format %{ %}
 3498   interface(CONST_INTER);
 3499 %}
 3500 
 3501 // Long immediate from 0 to 127.
 3502 // Used for a shorter form of long mul by 10.
 3503 operand immL_127() %{
 3504   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 127));
 3505   match(ConL);
 3506   op_cost(0);
 3507 
 3508   format %{ %}
 3509   interface(CONST_INTER);
 3510 %}
 3511 
 3512 // Long Immediate: low 32-bit mask
 3513 operand immL_32bits() %{
 3514   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3515   match(ConL);
 3516   op_cost(0);
 3517 
 3518   format %{ %}
 3519   interface(CONST_INTER);
 3520 %}
 3521 
 3522 // Long Immediate: low 32-bit mask
 3523 operand immL32() %{
 3524   predicate(n-&gt;get_long() == (int)(n-&gt;get_long()));
 3525   match(ConL);
 3526   op_cost(20);
 3527 
 3528   format %{ %}
 3529   interface(CONST_INTER);
 3530 %}
 3531 
 3532 //Double Immediate zero
 3533 operand immDPR0() %{
 3534   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3535   // bug that generates code such that NaNs compare equal to 0.0
 3536   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 0.0 &amp;&amp; !g_isnan(n-&gt;getd()) );
 3537   match(ConD);
 3538 
 3539   op_cost(5);
 3540   format %{ %}
 3541   interface(CONST_INTER);
 3542 %}
 3543 
 3544 // Double Immediate one
 3545 operand immDPR1() %{
 3546   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 1.0 );
 3547   match(ConD);
 3548 
 3549   op_cost(5);
 3550   format %{ %}
 3551   interface(CONST_INTER);
 3552 %}
 3553 
 3554 // Double Immediate
 3555 operand immDPR() %{
 3556   predicate(UseSSE&lt;=1);
 3557   match(ConD);
 3558 
 3559   op_cost(5);
 3560   format %{ %}
 3561   interface(CONST_INTER);
 3562 %}
 3563 
 3564 operand immD() %{
 3565   predicate(UseSSE&gt;=2);
 3566   match(ConD);
 3567 
 3568   op_cost(5);
 3569   format %{ %}
 3570   interface(CONST_INTER);
 3571 %}
 3572 
 3573 // Double Immediate zero
 3574 operand immD0() %{
 3575   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3576   // bug that generates code such that NaNs compare equal to 0.0 AND do not
 3577   // compare equal to -0.0.
 3578   predicate( UseSSE&gt;=2 &amp;&amp; jlong_cast(n-&gt;getd()) == 0 );
 3579   match(ConD);
 3580 
 3581   format %{ %}
 3582   interface(CONST_INTER);
 3583 %}
 3584 
 3585 // Float Immediate zero
 3586 operand immFPR0() %{
 3587   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 0.0F);
 3588   match(ConF);
 3589 
 3590   op_cost(5);
 3591   format %{ %}
 3592   interface(CONST_INTER);
 3593 %}
 3594 
 3595 // Float Immediate one
 3596 operand immFPR1() %{
 3597   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 1.0F);
 3598   match(ConF);
 3599 
 3600   op_cost(5);
 3601   format %{ %}
 3602   interface(CONST_INTER);
 3603 %}
 3604 
 3605 // Float Immediate
 3606 operand immFPR() %{
 3607   predicate( UseSSE == 0 );
 3608   match(ConF);
 3609 
 3610   op_cost(5);
 3611   format %{ %}
 3612   interface(CONST_INTER);
 3613 %}
 3614 
 3615 // Float Immediate
 3616 operand immF() %{
 3617   predicate(UseSSE &gt;= 1);
 3618   match(ConF);
 3619 
 3620   op_cost(5);
 3621   format %{ %}
 3622   interface(CONST_INTER);
 3623 %}
 3624 
 3625 // Float Immediate zero.  Zero and not -0.0
 3626 operand immF0() %{
 3627   predicate( UseSSE &gt;= 1 &amp;&amp; jint_cast(n-&gt;getf()) == 0 );
 3628   match(ConF);
 3629 
 3630   op_cost(5);
 3631   format %{ %}
 3632   interface(CONST_INTER);
 3633 %}
 3634 
 3635 // Immediates for special shifts (sign extend)
 3636 
 3637 // Constants for increment
 3638 operand immI_16() %{
 3639   predicate( n-&gt;get_int() == 16 );
 3640   match(ConI);
 3641 
 3642   format %{ %}
 3643   interface(CONST_INTER);
 3644 %}
 3645 
 3646 operand immI_24() %{
 3647   predicate( n-&gt;get_int() == 24 );
 3648   match(ConI);
 3649 
 3650   format %{ %}
 3651   interface(CONST_INTER);
 3652 %}
 3653 
 3654 // Constant for byte-wide masking
 3655 operand immI_255() %{
 3656   predicate( n-&gt;get_int() == 255 );
 3657   match(ConI);
 3658 
 3659   format %{ %}
 3660   interface(CONST_INTER);
 3661 %}
 3662 
 3663 // Constant for short-wide masking
 3664 operand immI_65535() %{
 3665   predicate(n-&gt;get_int() == 65535);
 3666   match(ConI);
 3667 
 3668   format %{ %}
 3669   interface(CONST_INTER);
 3670 %}
 3671 
 3672 // Register Operands
 3673 // Integer Register
 3674 operand rRegI() %{
 3675   constraint(ALLOC_IN_RC(int_reg));
 3676   match(RegI);
 3677   match(xRegI);
 3678   match(eAXRegI);
 3679   match(eBXRegI);
 3680   match(eCXRegI);
 3681   match(eDXRegI);
 3682   match(eDIRegI);
 3683   match(eSIRegI);
 3684 
 3685   format %{ %}
 3686   interface(REG_INTER);
 3687 %}
 3688 
 3689 // Subset of Integer Register
 3690 operand xRegI(rRegI reg) %{
 3691   constraint(ALLOC_IN_RC(int_x_reg));
 3692   match(reg);
 3693   match(eAXRegI);
 3694   match(eBXRegI);
 3695   match(eCXRegI);
 3696   match(eDXRegI);
 3697 
 3698   format %{ %}
 3699   interface(REG_INTER);
 3700 %}
 3701 
 3702 // Special Registers
 3703 operand eAXRegI(xRegI reg) %{
 3704   constraint(ALLOC_IN_RC(eax_reg));
 3705   match(reg);
 3706   match(rRegI);
 3707 
 3708   format %{ &quot;EAX&quot; %}
 3709   interface(REG_INTER);
 3710 %}
 3711 
 3712 // Special Registers
 3713 operand eBXRegI(xRegI reg) %{
 3714   constraint(ALLOC_IN_RC(ebx_reg));
 3715   match(reg);
 3716   match(rRegI);
 3717 
 3718   format %{ &quot;EBX&quot; %}
 3719   interface(REG_INTER);
 3720 %}
 3721 
 3722 operand eCXRegI(xRegI reg) %{
 3723   constraint(ALLOC_IN_RC(ecx_reg));
 3724   match(reg);
 3725   match(rRegI);
 3726 
 3727   format %{ &quot;ECX&quot; %}
 3728   interface(REG_INTER);
 3729 %}
 3730 
 3731 operand eDXRegI(xRegI reg) %{
 3732   constraint(ALLOC_IN_RC(edx_reg));
 3733   match(reg);
 3734   match(rRegI);
 3735 
 3736   format %{ &quot;EDX&quot; %}
 3737   interface(REG_INTER);
 3738 %}
 3739 
 3740 operand eDIRegI(xRegI reg) %{
 3741   constraint(ALLOC_IN_RC(edi_reg));
 3742   match(reg);
 3743   match(rRegI);
 3744 
 3745   format %{ &quot;EDI&quot; %}
 3746   interface(REG_INTER);
 3747 %}
 3748 
 3749 operand naxRegI() %{
 3750   constraint(ALLOC_IN_RC(nax_reg));
 3751   match(RegI);
 3752   match(eCXRegI);
 3753   match(eDXRegI);
 3754   match(eSIRegI);
 3755   match(eDIRegI);
 3756 
 3757   format %{ %}
 3758   interface(REG_INTER);
 3759 %}
 3760 
 3761 operand nadxRegI() %{
 3762   constraint(ALLOC_IN_RC(nadx_reg));
 3763   match(RegI);
 3764   match(eBXRegI);
 3765   match(eCXRegI);
 3766   match(eSIRegI);
 3767   match(eDIRegI);
 3768 
 3769   format %{ %}
 3770   interface(REG_INTER);
 3771 %}
 3772 
 3773 operand ncxRegI() %{
 3774   constraint(ALLOC_IN_RC(ncx_reg));
 3775   match(RegI);
 3776   match(eAXRegI);
 3777   match(eDXRegI);
 3778   match(eSIRegI);
 3779   match(eDIRegI);
 3780 
 3781   format %{ %}
 3782   interface(REG_INTER);
 3783 %}
 3784 
 3785 // // This operand was used by cmpFastUnlock, but conflicted with &#39;object&#39; reg
 3786 // //
 3787 operand eSIRegI(xRegI reg) %{
 3788    constraint(ALLOC_IN_RC(esi_reg));
 3789    match(reg);
 3790    match(rRegI);
 3791 
 3792    format %{ &quot;ESI&quot; %}
 3793    interface(REG_INTER);
 3794 %}
 3795 
 3796 // Pointer Register
 3797 operand anyRegP() %{
 3798   constraint(ALLOC_IN_RC(any_reg));
 3799   match(RegP);
 3800   match(eAXRegP);
 3801   match(eBXRegP);
 3802   match(eCXRegP);
 3803   match(eDIRegP);
 3804   match(eRegP);
 3805 
 3806   format %{ %}
 3807   interface(REG_INTER);
 3808 %}
 3809 
 3810 operand eRegP() %{
 3811   constraint(ALLOC_IN_RC(int_reg));
 3812   match(RegP);
 3813   match(eAXRegP);
 3814   match(eBXRegP);
 3815   match(eCXRegP);
 3816   match(eDIRegP);
 3817 
 3818   format %{ %}
 3819   interface(REG_INTER);
 3820 %}
 3821 
 3822 // On windows95, EBP is not safe to use for implicit null tests.
 3823 operand eRegP_no_EBP() %{
 3824   constraint(ALLOC_IN_RC(int_reg_no_ebp));
 3825   match(RegP);
 3826   match(eAXRegP);
 3827   match(eBXRegP);
 3828   match(eCXRegP);
 3829   match(eDIRegP);
 3830 
 3831   op_cost(100);
 3832   format %{ %}
 3833   interface(REG_INTER);
 3834 %}
 3835 
 3836 operand naxRegP() %{
 3837   constraint(ALLOC_IN_RC(nax_reg));
 3838   match(RegP);
 3839   match(eBXRegP);
 3840   match(eDXRegP);
 3841   match(eCXRegP);
 3842   match(eSIRegP);
 3843   match(eDIRegP);
 3844 
 3845   format %{ %}
 3846   interface(REG_INTER);
 3847 %}
 3848 
 3849 operand nabxRegP() %{
 3850   constraint(ALLOC_IN_RC(nabx_reg));
 3851   match(RegP);
 3852   match(eCXRegP);
 3853   match(eDXRegP);
 3854   match(eSIRegP);
 3855   match(eDIRegP);
 3856 
 3857   format %{ %}
 3858   interface(REG_INTER);
 3859 %}
 3860 
 3861 operand pRegP() %{
 3862   constraint(ALLOC_IN_RC(p_reg));
 3863   match(RegP);
 3864   match(eBXRegP);
 3865   match(eDXRegP);
 3866   match(eSIRegP);
 3867   match(eDIRegP);
 3868 
 3869   format %{ %}
 3870   interface(REG_INTER);
 3871 %}
 3872 
 3873 // Special Registers
 3874 // Return a pointer value
 3875 operand eAXRegP(eRegP reg) %{
 3876   constraint(ALLOC_IN_RC(eax_reg));
 3877   match(reg);
 3878   format %{ &quot;EAX&quot; %}
 3879   interface(REG_INTER);
 3880 %}
 3881 
 3882 // Used in AtomicAdd
 3883 operand eBXRegP(eRegP reg) %{
 3884   constraint(ALLOC_IN_RC(ebx_reg));
 3885   match(reg);
 3886   format %{ &quot;EBX&quot; %}
 3887   interface(REG_INTER);
 3888 %}
 3889 
 3890 // Tail-call (interprocedural jump) to interpreter
 3891 operand eCXRegP(eRegP reg) %{
 3892   constraint(ALLOC_IN_RC(ecx_reg));
 3893   match(reg);
 3894   format %{ &quot;ECX&quot; %}
 3895   interface(REG_INTER);
 3896 %}
 3897 
 3898 operand eDXRegP(eRegP reg) %{
 3899   constraint(ALLOC_IN_RC(edx_reg));
 3900   match(reg);
 3901   format %{ &quot;EDX&quot; %}
 3902   interface(REG_INTER);
 3903 %}
 3904 
 3905 operand eSIRegP(eRegP reg) %{
 3906   constraint(ALLOC_IN_RC(esi_reg));
 3907   match(reg);
 3908   format %{ &quot;ESI&quot; %}
 3909   interface(REG_INTER);
 3910 %}
 3911 
 3912 // Used in rep stosw
 3913 operand eDIRegP(eRegP reg) %{
 3914   constraint(ALLOC_IN_RC(edi_reg));
 3915   match(reg);
 3916   format %{ &quot;EDI&quot; %}
 3917   interface(REG_INTER);
 3918 %}
 3919 
 3920 operand eRegL() %{
 3921   constraint(ALLOC_IN_RC(long_reg));
 3922   match(RegL);
 3923   match(eADXRegL);
 3924 
 3925   format %{ %}
 3926   interface(REG_INTER);
 3927 %}
 3928 
 3929 operand eADXRegL( eRegL reg ) %{
 3930   constraint(ALLOC_IN_RC(eadx_reg));
 3931   match(reg);
 3932 
 3933   format %{ &quot;EDX:EAX&quot; %}
 3934   interface(REG_INTER);
 3935 %}
 3936 
 3937 operand eBCXRegL( eRegL reg ) %{
 3938   constraint(ALLOC_IN_RC(ebcx_reg));
 3939   match(reg);
 3940 
 3941   format %{ &quot;EBX:ECX&quot; %}
 3942   interface(REG_INTER);
 3943 %}
 3944 
 3945 // Special case for integer high multiply
 3946 operand eADXRegL_low_only() %{
 3947   constraint(ALLOC_IN_RC(eadx_reg));
 3948   match(RegL);
 3949 
 3950   format %{ &quot;EAX&quot; %}
 3951   interface(REG_INTER);
 3952 %}
 3953 
 3954 // Flags register, used as output of compare instructions
 3955 operand eFlagsReg() %{
 3956   constraint(ALLOC_IN_RC(int_flags));
 3957   match(RegFlags);
 3958 
 3959   format %{ &quot;EFLAGS&quot; %}
 3960   interface(REG_INTER);
 3961 %}
 3962 
 3963 // Flags register, used as output of FLOATING POINT compare instructions
 3964 operand eFlagsRegU() %{
 3965   constraint(ALLOC_IN_RC(int_flags));
 3966   match(RegFlags);
 3967 
 3968   format %{ &quot;EFLAGS_U&quot; %}
 3969   interface(REG_INTER);
 3970 %}
 3971 
 3972 operand eFlagsRegUCF() %{
 3973   constraint(ALLOC_IN_RC(int_flags));
 3974   match(RegFlags);
 3975   predicate(false);
 3976 
 3977   format %{ &quot;EFLAGS_U_CF&quot; %}
 3978   interface(REG_INTER);
 3979 %}
 3980 
 3981 // Condition Code Register used by long compare
 3982 operand flagsReg_long_LTGE() %{
 3983   constraint(ALLOC_IN_RC(int_flags));
 3984   match(RegFlags);
 3985   format %{ &quot;FLAGS_LTGE&quot; %}
 3986   interface(REG_INTER);
 3987 %}
 3988 operand flagsReg_long_EQNE() %{
 3989   constraint(ALLOC_IN_RC(int_flags));
 3990   match(RegFlags);
 3991   format %{ &quot;FLAGS_EQNE&quot; %}
 3992   interface(REG_INTER);
 3993 %}
 3994 operand flagsReg_long_LEGT() %{
 3995   constraint(ALLOC_IN_RC(int_flags));
 3996   match(RegFlags);
 3997   format %{ &quot;FLAGS_LEGT&quot; %}
 3998   interface(REG_INTER);
 3999 %}
 4000 
 4001 // Condition Code Register used by unsigned long compare
 4002 operand flagsReg_ulong_LTGE() %{
 4003   constraint(ALLOC_IN_RC(int_flags));
 4004   match(RegFlags);
 4005   format %{ &quot;FLAGS_U_LTGE&quot; %}
 4006   interface(REG_INTER);
 4007 %}
 4008 operand flagsReg_ulong_EQNE() %{
 4009   constraint(ALLOC_IN_RC(int_flags));
 4010   match(RegFlags);
 4011   format %{ &quot;FLAGS_U_EQNE&quot; %}
 4012   interface(REG_INTER);
 4013 %}
 4014 operand flagsReg_ulong_LEGT() %{
 4015   constraint(ALLOC_IN_RC(int_flags));
 4016   match(RegFlags);
 4017   format %{ &quot;FLAGS_U_LEGT&quot; %}
 4018   interface(REG_INTER);
 4019 %}
 4020 
 4021 // Float register operands
 4022 operand regDPR() %{
 4023   predicate( UseSSE &lt; 2 );
 4024   constraint(ALLOC_IN_RC(fp_dbl_reg));
 4025   match(RegD);
 4026   match(regDPR1);
 4027   match(regDPR2);
 4028   format %{ %}
 4029   interface(REG_INTER);
 4030 %}
 4031 
 4032 operand regDPR1(regDPR reg) %{
 4033   predicate( UseSSE &lt; 2 );
 4034   constraint(ALLOC_IN_RC(fp_dbl_reg0));
 4035   match(reg);
 4036   format %{ &quot;FPR1&quot; %}
 4037   interface(REG_INTER);
 4038 %}
 4039 
 4040 operand regDPR2(regDPR reg) %{
 4041   predicate( UseSSE &lt; 2 );
 4042   constraint(ALLOC_IN_RC(fp_dbl_reg1));
 4043   match(reg);
 4044   format %{ &quot;FPR2&quot; %}
 4045   interface(REG_INTER);
 4046 %}
 4047 
 4048 operand regnotDPR1(regDPR reg) %{
 4049   predicate( UseSSE &lt; 2 );
 4050   constraint(ALLOC_IN_RC(fp_dbl_notreg0));
 4051   match(reg);
 4052   format %{ %}
 4053   interface(REG_INTER);
 4054 %}
 4055 
 4056 // Float register operands
 4057 operand regFPR() %{
 4058   predicate( UseSSE &lt; 2 );
 4059   constraint(ALLOC_IN_RC(fp_flt_reg));
 4060   match(RegF);
 4061   match(regFPR1);
 4062   format %{ %}
 4063   interface(REG_INTER);
 4064 %}
 4065 
 4066 // Float register operands
 4067 operand regFPR1(regFPR reg) %{
 4068   predicate( UseSSE &lt; 2 );
 4069   constraint(ALLOC_IN_RC(fp_flt_reg0));
 4070   match(reg);
 4071   format %{ &quot;FPR1&quot; %}
 4072   interface(REG_INTER);
 4073 %}
 4074 
 4075 // XMM Float register operands
 4076 operand regF() %{
 4077   predicate( UseSSE&gt;=1 );
 4078   constraint(ALLOC_IN_RC(float_reg_legacy));
 4079   match(RegF);
 4080   format %{ %}
 4081   interface(REG_INTER);
 4082 %}
 4083 
 4084 // Float register operands
 4085 operand vlRegF() %{
 4086    constraint(ALLOC_IN_RC(float_reg_vl));
 4087    match(RegF);
 4088 
 4089    format %{ %}
 4090    interface(REG_INTER);
 4091 %}
 4092 
 4093 // XMM Double register operands
 4094 operand regD() %{
 4095   predicate( UseSSE&gt;=2 );
 4096   constraint(ALLOC_IN_RC(double_reg_legacy));
 4097   match(RegD);
 4098   format %{ %}
 4099   interface(REG_INTER);
 4100 %}
 4101 
 4102 // Double register operands
 4103 operand vlRegD() %{
 4104    constraint(ALLOC_IN_RC(double_reg_vl));
 4105    match(RegD);
 4106 
 4107    format %{ %}
 4108    interface(REG_INTER);
 4109 %}
 4110 
 4111 //----------Memory Operands----------------------------------------------------
 4112 // Direct Memory Operand
 4113 operand direct(immP addr) %{
 4114   match(addr);
 4115 
 4116   format %{ &quot;[$addr]&quot; %}
 4117   interface(MEMORY_INTER) %{
 4118     base(0xFFFFFFFF);
 4119     index(0x4);
 4120     scale(0x0);
 4121     disp($addr);
 4122   %}
 4123 %}
 4124 
 4125 // Indirect Memory Operand
 4126 operand indirect(eRegP reg) %{
 4127   constraint(ALLOC_IN_RC(int_reg));
 4128   match(reg);
 4129 
 4130   format %{ &quot;[$reg]&quot; %}
 4131   interface(MEMORY_INTER) %{
 4132     base($reg);
 4133     index(0x4);
 4134     scale(0x0);
 4135     disp(0x0);
 4136   %}
 4137 %}
 4138 
 4139 // Indirect Memory Plus Short Offset Operand
 4140 operand indOffset8(eRegP reg, immI8 off) %{
 4141   match(AddP reg off);
 4142 
 4143   format %{ &quot;[$reg + $off]&quot; %}
 4144   interface(MEMORY_INTER) %{
 4145     base($reg);
 4146     index(0x4);
 4147     scale(0x0);
 4148     disp($off);
 4149   %}
 4150 %}
 4151 
 4152 // Indirect Memory Plus Long Offset Operand
 4153 operand indOffset32(eRegP reg, immI off) %{
 4154   match(AddP reg off);
 4155 
 4156   format %{ &quot;[$reg + $off]&quot; %}
 4157   interface(MEMORY_INTER) %{
 4158     base($reg);
 4159     index(0x4);
 4160     scale(0x0);
 4161     disp($off);
 4162   %}
 4163 %}
 4164 
 4165 // Indirect Memory Plus Long Offset Operand
 4166 operand indOffset32X(rRegI reg, immP off) %{
 4167   match(AddP off reg);
 4168 
 4169   format %{ &quot;[$reg + $off]&quot; %}
 4170   interface(MEMORY_INTER) %{
 4171     base($reg);
 4172     index(0x4);
 4173     scale(0x0);
 4174     disp($off);
 4175   %}
 4176 %}
 4177 
 4178 // Indirect Memory Plus Index Register Plus Offset Operand
 4179 operand indIndexOffset(eRegP reg, rRegI ireg, immI off) %{
 4180   match(AddP (AddP reg ireg) off);
 4181 
 4182   op_cost(10);
 4183   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4184   interface(MEMORY_INTER) %{
 4185     base($reg);
 4186     index($ireg);
 4187     scale(0x0);
 4188     disp($off);
 4189   %}
 4190 %}
 4191 
 4192 // Indirect Memory Plus Index Register Plus Offset Operand
 4193 operand indIndex(eRegP reg, rRegI ireg) %{
 4194   match(AddP reg ireg);
 4195 
 4196   op_cost(10);
 4197   format %{&quot;[$reg + $ireg]&quot; %}
 4198   interface(MEMORY_INTER) %{
 4199     base($reg);
 4200     index($ireg);
 4201     scale(0x0);
 4202     disp(0x0);
 4203   %}
 4204 %}
 4205 
 4206 // // -------------------------------------------------------------------------
 4207 // // 486 architecture doesn&#39;t support &quot;scale * index + offset&quot; with out a base
 4208 // // -------------------------------------------------------------------------
 4209 // // Scaled Memory Operands
 4210 // // Indirect Memory Times Scale Plus Offset Operand
 4211 // operand indScaleOffset(immP off, rRegI ireg, immI2 scale) %{
 4212 //   match(AddP off (LShiftI ireg scale));
 4213 //
 4214 //   op_cost(10);
 4215 //   format %{&quot;[$off + $ireg &lt;&lt; $scale]&quot; %}
 4216 //   interface(MEMORY_INTER) %{
 4217 //     base(0x4);
 4218 //     index($ireg);
 4219 //     scale($scale);
 4220 //     disp($off);
 4221 //   %}
 4222 // %}
 4223 
 4224 // Indirect Memory Times Scale Plus Index Register
 4225 operand indIndexScale(eRegP reg, rRegI ireg, immI2 scale) %{
 4226   match(AddP reg (LShiftI ireg scale));
 4227 
 4228   op_cost(10);
 4229   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4230   interface(MEMORY_INTER) %{
 4231     base($reg);
 4232     index($ireg);
 4233     scale($scale);
 4234     disp(0x0);
 4235   %}
 4236 %}
 4237 
 4238 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4239 operand indIndexScaleOffset(eRegP reg, immI off, rRegI ireg, immI2 scale) %{
 4240   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4241 
 4242   op_cost(10);
 4243   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4244   interface(MEMORY_INTER) %{
 4245     base($reg);
 4246     index($ireg);
 4247     scale($scale);
 4248     disp($off);
 4249   %}
 4250 %}
 4251 
 4252 //----------Load Long Memory Operands------------------------------------------
 4253 // The load-long idiom will use it&#39;s address expression again after loading
 4254 // the first word of the long.  If the load-long destination overlaps with
 4255 // registers used in the addressing expression, the 2nd half will be loaded
 4256 // from a clobbered address.  Fix this by requiring that load-long use
 4257 // address registers that do not overlap with the load-long target.
 4258 
 4259 // load-long support
 4260 operand load_long_RegP() %{
 4261   constraint(ALLOC_IN_RC(esi_reg));
 4262   match(RegP);
 4263   match(eSIRegP);
 4264   op_cost(100);
 4265   format %{  %}
 4266   interface(REG_INTER);
 4267 %}
 4268 
 4269 // Indirect Memory Operand Long
 4270 operand load_long_indirect(load_long_RegP reg) %{
 4271   constraint(ALLOC_IN_RC(esi_reg));
 4272   match(reg);
 4273 
 4274   format %{ &quot;[$reg]&quot; %}
 4275   interface(MEMORY_INTER) %{
 4276     base($reg);
 4277     index(0x4);
 4278     scale(0x0);
 4279     disp(0x0);
 4280   %}
 4281 %}
 4282 
 4283 // Indirect Memory Plus Long Offset Operand
 4284 operand load_long_indOffset32(load_long_RegP reg, immI off) %{
 4285   match(AddP reg off);
 4286 
 4287   format %{ &quot;[$reg + $off]&quot; %}
 4288   interface(MEMORY_INTER) %{
 4289     base($reg);
 4290     index(0x4);
 4291     scale(0x0);
 4292     disp($off);
 4293   %}
 4294 %}
 4295 
 4296 opclass load_long_memory(load_long_indirect, load_long_indOffset32);
 4297 
 4298 
 4299 //----------Special Memory Operands--------------------------------------------
 4300 // Stack Slot Operand - This operand is used for loading and storing temporary
 4301 //                      values on the stack where a match requires a value to
 4302 //                      flow through memory.
 4303 operand stackSlotP(sRegP reg) %{
 4304   constraint(ALLOC_IN_RC(stack_slots));
 4305   // No match rule because this operand is only generated in matching
 4306   format %{ &quot;[$reg]&quot; %}
 4307   interface(MEMORY_INTER) %{
 4308     base(0x4);   // ESP
 4309     index(0x4);  // No Index
 4310     scale(0x0);  // No Scale
 4311     disp($reg);  // Stack Offset
 4312   %}
 4313 %}
 4314 
 4315 operand stackSlotI(sRegI reg) %{
 4316   constraint(ALLOC_IN_RC(stack_slots));
 4317   // No match rule because this operand is only generated in matching
 4318   format %{ &quot;[$reg]&quot; %}
 4319   interface(MEMORY_INTER) %{
 4320     base(0x4);   // ESP
 4321     index(0x4);  // No Index
 4322     scale(0x0);  // No Scale
 4323     disp($reg);  // Stack Offset
 4324   %}
 4325 %}
 4326 
 4327 operand stackSlotF(sRegF reg) %{
 4328   constraint(ALLOC_IN_RC(stack_slots));
 4329   // No match rule because this operand is only generated in matching
 4330   format %{ &quot;[$reg]&quot; %}
 4331   interface(MEMORY_INTER) %{
 4332     base(0x4);   // ESP
 4333     index(0x4);  // No Index
 4334     scale(0x0);  // No Scale
 4335     disp($reg);  // Stack Offset
 4336   %}
 4337 %}
 4338 
 4339 operand stackSlotD(sRegD reg) %{
 4340   constraint(ALLOC_IN_RC(stack_slots));
 4341   // No match rule because this operand is only generated in matching
 4342   format %{ &quot;[$reg]&quot; %}
 4343   interface(MEMORY_INTER) %{
 4344     base(0x4);   // ESP
 4345     index(0x4);  // No Index
 4346     scale(0x0);  // No Scale
 4347     disp($reg);  // Stack Offset
 4348   %}
 4349 %}
 4350 
 4351 operand stackSlotL(sRegL reg) %{
 4352   constraint(ALLOC_IN_RC(stack_slots));
 4353   // No match rule because this operand is only generated in matching
 4354   format %{ &quot;[$reg]&quot; %}
 4355   interface(MEMORY_INTER) %{
 4356     base(0x4);   // ESP
 4357     index(0x4);  // No Index
 4358     scale(0x0);  // No Scale
 4359     disp($reg);  // Stack Offset
 4360   %}
 4361 %}
 4362 
 4363 //----------Memory Operands - Win95 Implicit Null Variants----------------
 4364 // Indirect Memory Operand
 4365 operand indirect_win95_safe(eRegP_no_EBP reg)
 4366 %{
 4367   constraint(ALLOC_IN_RC(int_reg));
 4368   match(reg);
 4369 
 4370   op_cost(100);
 4371   format %{ &quot;[$reg]&quot; %}
 4372   interface(MEMORY_INTER) %{
 4373     base($reg);
 4374     index(0x4);
 4375     scale(0x0);
 4376     disp(0x0);
 4377   %}
 4378 %}
 4379 
 4380 // Indirect Memory Plus Short Offset Operand
 4381 operand indOffset8_win95_safe(eRegP_no_EBP reg, immI8 off)
 4382 %{
 4383   match(AddP reg off);
 4384 
 4385   op_cost(100);
 4386   format %{ &quot;[$reg + $off]&quot; %}
 4387   interface(MEMORY_INTER) %{
 4388     base($reg);
 4389     index(0x4);
 4390     scale(0x0);
 4391     disp($off);
 4392   %}
 4393 %}
 4394 
 4395 // Indirect Memory Plus Long Offset Operand
 4396 operand indOffset32_win95_safe(eRegP_no_EBP reg, immI off)
 4397 %{
 4398   match(AddP reg off);
 4399 
 4400   op_cost(100);
 4401   format %{ &quot;[$reg + $off]&quot; %}
 4402   interface(MEMORY_INTER) %{
 4403     base($reg);
 4404     index(0x4);
 4405     scale(0x0);
 4406     disp($off);
 4407   %}
 4408 %}
 4409 
 4410 // Indirect Memory Plus Index Register Plus Offset Operand
 4411 operand indIndexOffset_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI off)
 4412 %{
 4413   match(AddP (AddP reg ireg) off);
 4414 
 4415   op_cost(100);
 4416   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4417   interface(MEMORY_INTER) %{
 4418     base($reg);
 4419     index($ireg);
 4420     scale(0x0);
 4421     disp($off);
 4422   %}
 4423 %}
 4424 
 4425 // Indirect Memory Times Scale Plus Index Register
 4426 operand indIndexScale_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI2 scale)
 4427 %{
 4428   match(AddP reg (LShiftI ireg scale));
 4429 
 4430   op_cost(100);
 4431   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4432   interface(MEMORY_INTER) %{
 4433     base($reg);
 4434     index($ireg);
 4435     scale($scale);
 4436     disp(0x0);
 4437   %}
 4438 %}
 4439 
 4440 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4441 operand indIndexScaleOffset_win95_safe(eRegP_no_EBP reg, immI off, rRegI ireg, immI2 scale)
 4442 %{
 4443   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4444 
 4445   op_cost(100);
 4446   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4447   interface(MEMORY_INTER) %{
 4448     base($reg);
 4449     index($ireg);
 4450     scale($scale);
 4451     disp($off);
 4452   %}
 4453 %}
 4454 
 4455 //----------Conditional Branch Operands----------------------------------------
 4456 // Comparison Op  - This is the operation of the comparison, and is limited to
 4457 //                  the following set of codes:
 4458 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4459 //
 4460 // Other attributes of the comparison, such as unsignedness, are specified
 4461 // by the comparison instruction that sets a condition code flags register.
 4462 // That result is represented by a flags operand whose subtype is appropriate
 4463 // to the unsignedness (etc.) of the comparison.
 4464 //
 4465 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4466 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4467 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4468 
 4469 // Comparision Code
 4470 operand cmpOp() %{
 4471   match(Bool);
 4472 
 4473   format %{ &quot;&quot; %}
 4474   interface(COND_INTER) %{
 4475     equal(0x4, &quot;e&quot;);
 4476     not_equal(0x5, &quot;ne&quot;);
 4477     less(0xC, &quot;l&quot;);
 4478     greater_equal(0xD, &quot;ge&quot;);
 4479     less_equal(0xE, &quot;le&quot;);
 4480     greater(0xF, &quot;g&quot;);
 4481     overflow(0x0, &quot;o&quot;);
 4482     no_overflow(0x1, &quot;no&quot;);
 4483   %}
 4484 %}
 4485 
 4486 // Comparison Code, unsigned compare.  Used by FP also, with
 4487 // C2 (unordered) turned into GT or LT already.  The other bits
 4488 // C0 and C3 are turned into Carry &amp; Zero flags.
 4489 operand cmpOpU() %{
 4490   match(Bool);
 4491 
 4492   format %{ &quot;&quot; %}
 4493   interface(COND_INTER) %{
 4494     equal(0x4, &quot;e&quot;);
 4495     not_equal(0x5, &quot;ne&quot;);
 4496     less(0x2, &quot;b&quot;);
 4497     greater_equal(0x3, &quot;nb&quot;);
 4498     less_equal(0x6, &quot;be&quot;);
 4499     greater(0x7, &quot;nbe&quot;);
 4500     overflow(0x0, &quot;o&quot;);
 4501     no_overflow(0x1, &quot;no&quot;);
 4502   %}
 4503 %}
 4504 
 4505 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4506 operand cmpOpUCF() %{
 4507   match(Bool);
 4508   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4509             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4510             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4511             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4512   format %{ &quot;&quot; %}
 4513   interface(COND_INTER) %{
 4514     equal(0x4, &quot;e&quot;);
 4515     not_equal(0x5, &quot;ne&quot;);
 4516     less(0x2, &quot;b&quot;);
 4517     greater_equal(0x3, &quot;nb&quot;);
 4518     less_equal(0x6, &quot;be&quot;);
 4519     greater(0x7, &quot;nbe&quot;);
 4520     overflow(0x0, &quot;o&quot;);
 4521     no_overflow(0x1, &quot;no&quot;);
 4522   %}
 4523 %}
 4524 
 4525 
 4526 // Floating comparisons that can be fixed up with extra conditional jumps
 4527 operand cmpOpUCF2() %{
 4528   match(Bool);
 4529   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4530             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4531   format %{ &quot;&quot; %}
 4532   interface(COND_INTER) %{
 4533     equal(0x4, &quot;e&quot;);
 4534     not_equal(0x5, &quot;ne&quot;);
 4535     less(0x2, &quot;b&quot;);
 4536     greater_equal(0x3, &quot;nb&quot;);
 4537     less_equal(0x6, &quot;be&quot;);
 4538     greater(0x7, &quot;nbe&quot;);
 4539     overflow(0x0, &quot;o&quot;);
 4540     no_overflow(0x1, &quot;no&quot;);
 4541   %}
 4542 %}
 4543 
 4544 // Comparison Code for FP conditional move
 4545 operand cmpOp_fcmov() %{
 4546   match(Bool);
 4547 
 4548   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4549             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4550   format %{ &quot;&quot; %}
 4551   interface(COND_INTER) %{
 4552     equal        (0x0C8);
 4553     not_equal    (0x1C8);
 4554     less         (0x0C0);
 4555     greater_equal(0x1C0);
 4556     less_equal   (0x0D0);
 4557     greater      (0x1D0);
 4558     overflow(0x0, &quot;o&quot;); // not really supported by the instruction
 4559     no_overflow(0x1, &quot;no&quot;); // not really supported by the instruction
 4560   %}
 4561 %}
 4562 
 4563 // Comparison Code used in long compares
 4564 operand cmpOp_commute() %{
 4565   match(Bool);
 4566 
 4567   format %{ &quot;&quot; %}
 4568   interface(COND_INTER) %{
 4569     equal(0x4, &quot;e&quot;);
 4570     not_equal(0x5, &quot;ne&quot;);
 4571     less(0xF, &quot;g&quot;);
 4572     greater_equal(0xE, &quot;le&quot;);
 4573     less_equal(0xD, &quot;ge&quot;);
 4574     greater(0xC, &quot;l&quot;);
 4575     overflow(0x0, &quot;o&quot;);
 4576     no_overflow(0x1, &quot;no&quot;);
 4577   %}
 4578 %}
 4579 
 4580 // Comparison Code used in unsigned long compares
 4581 operand cmpOpU_commute() %{
 4582   match(Bool);
 4583 
 4584   format %{ &quot;&quot; %}
 4585   interface(COND_INTER) %{
 4586     equal(0x4, &quot;e&quot;);
 4587     not_equal(0x5, &quot;ne&quot;);
 4588     less(0x7, &quot;nbe&quot;);
 4589     greater_equal(0x6, &quot;be&quot;);
 4590     less_equal(0x3, &quot;nb&quot;);
 4591     greater(0x2, &quot;b&quot;);
 4592     overflow(0x0, &quot;o&quot;);
 4593     no_overflow(0x1, &quot;no&quot;);
 4594   %}
 4595 %}
 4596 
 4597 //----------OPERAND CLASSES----------------------------------------------------
 4598 // Operand Classes are groups of operands that are used as to simplify
 4599 // instruction definitions by not requiring the AD writer to specify separate
 4600 // instructions for every form of operand when the instruction accepts
 4601 // multiple operand types with the same basic encoding and format.  The classic
 4602 // case of this is memory operands.
 4603 
 4604 opclass memory(direct, indirect, indOffset8, indOffset32, indOffset32X, indIndexOffset,
 4605                indIndex, indIndexScale, indIndexScaleOffset);
 4606 
 4607 // Long memory operations are encoded in 2 instructions and a +4 offset.
 4608 // This means some kind of offset is always required and you cannot use
 4609 // an oop as the offset (done when working on static globals).
 4610 opclass long_memory(direct, indirect, indOffset8, indOffset32, indIndexOffset,
 4611                     indIndex, indIndexScale, indIndexScaleOffset);
 4612 
 4613 
 4614 //----------PIPELINE-----------------------------------------------------------
 4615 // Rules which define the behavior of the target architectures pipeline.
 4616 pipeline %{
 4617 
 4618 //----------ATTRIBUTES---------------------------------------------------------
 4619 attributes %{
 4620   variable_size_instructions;        // Fixed size instructions
 4621   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4622   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4623   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4624   instruction_fetch_units = 1;       // of 16 bytes
 4625 
 4626   // List of nop instructions
 4627   nops( MachNop );
 4628 %}
 4629 
 4630 //----------RESOURCES----------------------------------------------------------
 4631 // Resources are the functional units available to the machine
 4632 
 4633 // Generic P2/P3 pipeline
 4634 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4635 // 3 instructions decoded per cycle.
 4636 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4637 // 2 ALU op, only ALU0 handles mul/div instructions.
 4638 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4639            MS0, MS1, MEM = MS0 | MS1,
 4640            BR, FPU,
 4641            ALU0, ALU1, ALU = ALU0 | ALU1 );
 4642 
 4643 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4644 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4645 
 4646 // Generic P2/P3 pipeline
 4647 pipe_desc(S0, S1, S2, S3, S4, S5);
 4648 
 4649 //----------PIPELINE CLASSES---------------------------------------------------
 4650 // Pipeline Classes describe the stages in which input and output are
 4651 // referenced by the hardware pipeline.
 4652 
 4653 // Naming convention: ialu or fpu
 4654 // Then: _reg
 4655 // Then: _reg if there is a 2nd register
 4656 // Then: _long if it&#39;s a pair of instructions implementing a long
 4657 // Then: _fat if it requires the big decoder
 4658 //   Or: _mem if it requires the big decoder and a memory unit.
 4659 
 4660 // Integer ALU reg operation
 4661 pipe_class ialu_reg(rRegI dst) %{
 4662     single_instruction;
 4663     dst    : S4(write);
 4664     dst    : S3(read);
 4665     DECODE : S0;        // any decoder
 4666     ALU    : S3;        // any alu
 4667 %}
 4668 
 4669 // Long ALU reg operation
 4670 pipe_class ialu_reg_long(eRegL dst) %{
 4671     instruction_count(2);
 4672     dst    : S4(write);
 4673     dst    : S3(read);
 4674     DECODE : S0(2);     // any 2 decoders
 4675     ALU    : S3(2);     // both alus
 4676 %}
 4677 
 4678 // Integer ALU reg operation using big decoder
 4679 pipe_class ialu_reg_fat(rRegI dst) %{
 4680     single_instruction;
 4681     dst    : S4(write);
 4682     dst    : S3(read);
 4683     D0     : S0;        // big decoder only
 4684     ALU    : S3;        // any alu
 4685 %}
 4686 
 4687 // Long ALU reg operation using big decoder
 4688 pipe_class ialu_reg_long_fat(eRegL dst) %{
 4689     instruction_count(2);
 4690     dst    : S4(write);
 4691     dst    : S3(read);
 4692     D0     : S0(2);     // big decoder only; twice
 4693     ALU    : S3(2);     // any 2 alus
 4694 %}
 4695 
 4696 // Integer ALU reg-reg operation
 4697 pipe_class ialu_reg_reg(rRegI dst, rRegI src) %{
 4698     single_instruction;
 4699     dst    : S4(write);
 4700     src    : S3(read);
 4701     DECODE : S0;        // any decoder
 4702     ALU    : S3;        // any alu
 4703 %}
 4704 
 4705 // Long ALU reg-reg operation
 4706 pipe_class ialu_reg_reg_long(eRegL dst, eRegL src) %{
 4707     instruction_count(2);
 4708     dst    : S4(write);
 4709     src    : S3(read);
 4710     DECODE : S0(2);     // any 2 decoders
 4711     ALU    : S3(2);     // both alus
 4712 %}
 4713 
 4714 // Integer ALU reg-reg operation
 4715 pipe_class ialu_reg_reg_fat(rRegI dst, memory src) %{
 4716     single_instruction;
 4717     dst    : S4(write);
 4718     src    : S3(read);
 4719     D0     : S0;        // big decoder only
 4720     ALU    : S3;        // any alu
 4721 %}
 4722 
 4723 // Long ALU reg-reg operation
 4724 pipe_class ialu_reg_reg_long_fat(eRegL dst, eRegL src) %{
 4725     instruction_count(2);
 4726     dst    : S4(write);
 4727     src    : S3(read);
 4728     D0     : S0(2);     // big decoder only; twice
 4729     ALU    : S3(2);     // both alus
 4730 %}
 4731 
 4732 // Integer ALU reg-mem operation
 4733 pipe_class ialu_reg_mem(rRegI dst, memory mem) %{
 4734     single_instruction;
 4735     dst    : S5(write);
 4736     mem    : S3(read);
 4737     D0     : S0;        // big decoder only
 4738     ALU    : S4;        // any alu
 4739     MEM    : S3;        // any mem
 4740 %}
 4741 
 4742 // Long ALU reg-mem operation
 4743 pipe_class ialu_reg_long_mem(eRegL dst, load_long_memory mem) %{
 4744     instruction_count(2);
 4745     dst    : S5(write);
 4746     mem    : S3(read);
 4747     D0     : S0(2);     // big decoder only; twice
 4748     ALU    : S4(2);     // any 2 alus
 4749     MEM    : S3(2);     // both mems
 4750 %}
 4751 
 4752 // Integer mem operation (prefetch)
 4753 pipe_class ialu_mem(memory mem)
 4754 %{
 4755     single_instruction;
 4756     mem    : S3(read);
 4757     D0     : S0;        // big decoder only
 4758     MEM    : S3;        // any mem
 4759 %}
 4760 
 4761 // Integer Store to Memory
 4762 pipe_class ialu_mem_reg(memory mem, rRegI src) %{
 4763     single_instruction;
 4764     mem    : S3(read);
 4765     src    : S5(read);
 4766     D0     : S0;        // big decoder only
 4767     ALU    : S4;        // any alu
 4768     MEM    : S3;
 4769 %}
 4770 
 4771 // Long Store to Memory
 4772 pipe_class ialu_mem_long_reg(memory mem, eRegL src) %{
 4773     instruction_count(2);
 4774     mem    : S3(read);
 4775     src    : S5(read);
 4776     D0     : S0(2);     // big decoder only; twice
 4777     ALU    : S4(2);     // any 2 alus
 4778     MEM    : S3(2);     // Both mems
 4779 %}
 4780 
 4781 // Integer Store to Memory
 4782 pipe_class ialu_mem_imm(memory mem) %{
 4783     single_instruction;
 4784     mem    : S3(read);
 4785     D0     : S0;        // big decoder only
 4786     ALU    : S4;        // any alu
 4787     MEM    : S3;
 4788 %}
 4789 
 4790 // Integer ALU0 reg-reg operation
 4791 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src) %{
 4792     single_instruction;
 4793     dst    : S4(write);
 4794     src    : S3(read);
 4795     D0     : S0;        // Big decoder only
 4796     ALU0   : S3;        // only alu0
 4797 %}
 4798 
 4799 // Integer ALU0 reg-mem operation
 4800 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem) %{
 4801     single_instruction;
 4802     dst    : S5(write);
 4803     mem    : S3(read);
 4804     D0     : S0;        // big decoder only
 4805     ALU0   : S4;        // ALU0 only
 4806     MEM    : S3;        // any mem
 4807 %}
 4808 
 4809 // Integer ALU reg-reg operation
 4810 pipe_class ialu_cr_reg_reg(eFlagsReg cr, rRegI src1, rRegI src2) %{
 4811     single_instruction;
 4812     cr     : S4(write);
 4813     src1   : S3(read);
 4814     src2   : S3(read);
 4815     DECODE : S0;        // any decoder
 4816     ALU    : S3;        // any alu
 4817 %}
 4818 
 4819 // Integer ALU reg-imm operation
 4820 pipe_class ialu_cr_reg_imm(eFlagsReg cr, rRegI src1) %{
 4821     single_instruction;
 4822     cr     : S4(write);
 4823     src1   : S3(read);
 4824     DECODE : S0;        // any decoder
 4825     ALU    : S3;        // any alu
 4826 %}
 4827 
 4828 // Integer ALU reg-mem operation
 4829 pipe_class ialu_cr_reg_mem(eFlagsReg cr, rRegI src1, memory src2) %{
 4830     single_instruction;
 4831     cr     : S4(write);
 4832     src1   : S3(read);
 4833     src2   : S3(read);
 4834     D0     : S0;        // big decoder only
 4835     ALU    : S4;        // any alu
 4836     MEM    : S3;
 4837 %}
 4838 
 4839 // Conditional move reg-reg
 4840 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y ) %{
 4841     instruction_count(4);
 4842     y      : S4(read);
 4843     q      : S3(read);
 4844     p      : S3(read);
 4845     DECODE : S0(4);     // any decoder
 4846 %}
 4847 
 4848 // Conditional move reg-reg
 4849 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, eFlagsReg cr ) %{
 4850     single_instruction;
 4851     dst    : S4(write);
 4852     src    : S3(read);
 4853     cr     : S3(read);
 4854     DECODE : S0;        // any decoder
 4855 %}
 4856 
 4857 // Conditional move reg-mem
 4858 pipe_class pipe_cmov_mem( eFlagsReg cr, rRegI dst, memory src) %{
 4859     single_instruction;
 4860     dst    : S4(write);
 4861     src    : S3(read);
 4862     cr     : S3(read);
 4863     DECODE : S0;        // any decoder
 4864     MEM    : S3;
 4865 %}
 4866 
 4867 // Conditional move reg-reg long
 4868 pipe_class pipe_cmov_reg_long( eFlagsReg cr, eRegL dst, eRegL src) %{
 4869     single_instruction;
 4870     dst    : S4(write);
 4871     src    : S3(read);
 4872     cr     : S3(read);
 4873     DECODE : S0(2);     // any 2 decoders
 4874 %}
 4875 
 4876 // Conditional move double reg-reg
 4877 pipe_class pipe_cmovDPR_reg( eFlagsReg cr, regDPR1 dst, regDPR src) %{
 4878     single_instruction;
 4879     dst    : S4(write);
 4880     src    : S3(read);
 4881     cr     : S3(read);
 4882     DECODE : S0;        // any decoder
 4883 %}
 4884 
 4885 // Float reg-reg operation
 4886 pipe_class fpu_reg(regDPR dst) %{
 4887     instruction_count(2);
 4888     dst    : S3(read);
 4889     DECODE : S0(2);     // any 2 decoders
 4890     FPU    : S3;
 4891 %}
 4892 
 4893 // Float reg-reg operation
 4894 pipe_class fpu_reg_reg(regDPR dst, regDPR src) %{
 4895     instruction_count(2);
 4896     dst    : S4(write);
 4897     src    : S3(read);
 4898     DECODE : S0(2);     // any 2 decoders
 4899     FPU    : S3;
 4900 %}
 4901 
 4902 // Float reg-reg operation
 4903 pipe_class fpu_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2) %{
 4904     instruction_count(3);
 4905     dst    : S4(write);
 4906     src1   : S3(read);
 4907     src2   : S3(read);
 4908     DECODE : S0(3);     // any 3 decoders
 4909     FPU    : S3(2);
 4910 %}
 4911 
 4912 // Float reg-reg operation
 4913 pipe_class fpu_reg_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2, regDPR src3) %{
 4914     instruction_count(4);
 4915     dst    : S4(write);
 4916     src1   : S3(read);
 4917     src2   : S3(read);
 4918     src3   : S3(read);
 4919     DECODE : S0(4);     // any 3 decoders
 4920     FPU    : S3(2);
 4921 %}
 4922 
 4923 // Float reg-reg operation
 4924 pipe_class fpu_reg_mem_reg_reg(regDPR dst, memory src1, regDPR src2, regDPR src3) %{
 4925     instruction_count(4);
 4926     dst    : S4(write);
 4927     src1   : S3(read);
 4928     src2   : S3(read);
 4929     src3   : S3(read);
 4930     DECODE : S1(3);     // any 3 decoders
 4931     D0     : S0;        // Big decoder only
 4932     FPU    : S3(2);
 4933     MEM    : S3;
 4934 %}
 4935 
 4936 // Float reg-mem operation
 4937 pipe_class fpu_reg_mem(regDPR dst, memory mem) %{
 4938     instruction_count(2);
 4939     dst    : S5(write);
 4940     mem    : S3(read);
 4941     D0     : S0;        // big decoder only
 4942     DECODE : S1;        // any decoder for FPU POP
 4943     FPU    : S4;
 4944     MEM    : S3;        // any mem
 4945 %}
 4946 
 4947 // Float reg-mem operation
 4948 pipe_class fpu_reg_reg_mem(regDPR dst, regDPR src1, memory mem) %{
 4949     instruction_count(3);
 4950     dst    : S5(write);
 4951     src1   : S3(read);
 4952     mem    : S3(read);
 4953     D0     : S0;        // big decoder only
 4954     DECODE : S1(2);     // any decoder for FPU POP
 4955     FPU    : S4;
 4956     MEM    : S3;        // any mem
 4957 %}
 4958 
 4959 // Float mem-reg operation
 4960 pipe_class fpu_mem_reg(memory mem, regDPR src) %{
 4961     instruction_count(2);
 4962     src    : S5(read);
 4963     mem    : S3(read);
 4964     DECODE : S0;        // any decoder for FPU PUSH
 4965     D0     : S1;        // big decoder only
 4966     FPU    : S4;
 4967     MEM    : S3;        // any mem
 4968 %}
 4969 
 4970 pipe_class fpu_mem_reg_reg(memory mem, regDPR src1, regDPR src2) %{
 4971     instruction_count(3);
 4972     src1   : S3(read);
 4973     src2   : S3(read);
 4974     mem    : S3(read);
 4975     DECODE : S0(2);     // any decoder for FPU PUSH
 4976     D0     : S1;        // big decoder only
 4977     FPU    : S4;
 4978     MEM    : S3;        // any mem
 4979 %}
 4980 
 4981 pipe_class fpu_mem_reg_mem(memory mem, regDPR src1, memory src2) %{
 4982     instruction_count(3);
 4983     src1   : S3(read);
 4984     src2   : S3(read);
 4985     mem    : S4(read);
 4986     DECODE : S0;        // any decoder for FPU PUSH
 4987     D0     : S0(2);     // big decoder only
 4988     FPU    : S4;
 4989     MEM    : S3(2);     // any mem
 4990 %}
 4991 
 4992 pipe_class fpu_mem_mem(memory dst, memory src1) %{
 4993     instruction_count(2);
 4994     src1   : S3(read);
 4995     dst    : S4(read);
 4996     D0     : S0(2);     // big decoder only
 4997     MEM    : S3(2);     // any mem
 4998 %}
 4999 
 5000 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2) %{
 5001     instruction_count(3);
 5002     src1   : S3(read);
 5003     src2   : S3(read);
 5004     dst    : S4(read);
 5005     D0     : S0(3);     // big decoder only
 5006     FPU    : S4;
 5007     MEM    : S3(3);     // any mem
 5008 %}
 5009 
 5010 pipe_class fpu_mem_reg_con(memory mem, regDPR src1) %{
 5011     instruction_count(3);
 5012     src1   : S4(read);
 5013     mem    : S4(read);
 5014     DECODE : S0;        // any decoder for FPU PUSH
 5015     D0     : S0(2);     // big decoder only
 5016     FPU    : S4;
 5017     MEM    : S3(2);     // any mem
 5018 %}
 5019 
 5020 // Float load constant
 5021 pipe_class fpu_reg_con(regDPR dst) %{
 5022     instruction_count(2);
 5023     dst    : S5(write);
 5024     D0     : S0;        // big decoder only for the load
 5025     DECODE : S1;        // any decoder for FPU POP
 5026     FPU    : S4;
 5027     MEM    : S3;        // any mem
 5028 %}
 5029 
 5030 // Float load constant
 5031 pipe_class fpu_reg_reg_con(regDPR dst, regDPR src) %{
 5032     instruction_count(3);
 5033     dst    : S5(write);
 5034     src    : S3(read);
 5035     D0     : S0;        // big decoder only for the load
 5036     DECODE : S1(2);     // any decoder for FPU POP
 5037     FPU    : S4;
 5038     MEM    : S3;        // any mem
 5039 %}
 5040 
 5041 // UnConditional branch
 5042 pipe_class pipe_jmp( label labl ) %{
 5043     single_instruction;
 5044     BR   : S3;
 5045 %}
 5046 
 5047 // Conditional branch
 5048 pipe_class pipe_jcc( cmpOp cmp, eFlagsReg cr, label labl ) %{
 5049     single_instruction;
 5050     cr    : S1(read);
 5051     BR    : S3;
 5052 %}
 5053 
 5054 // Allocation idiom
 5055 pipe_class pipe_cmpxchg( eRegP dst, eRegP heap_ptr ) %{
 5056     instruction_count(1); force_serialization;
 5057     fixed_latency(6);
 5058     heap_ptr : S3(read);
 5059     DECODE   : S0(3);
 5060     D0       : S2;
 5061     MEM      : S3;
 5062     ALU      : S3(2);
 5063     dst      : S5(write);
 5064     BR       : S5;
 5065 %}
 5066 
 5067 // Generic big/slow expanded idiom
 5068 pipe_class pipe_slow(  ) %{
 5069     instruction_count(10); multiple_bundles; force_serialization;
 5070     fixed_latency(100);
 5071     D0  : S0(2);
 5072     MEM : S3(2);
 5073 %}
 5074 
 5075 // The real do-nothing guy
 5076 pipe_class empty( ) %{
 5077     instruction_count(0);
 5078 %}
 5079 
 5080 // Define the class for the Nop node
 5081 define %{
 5082    MachNop = empty;
 5083 %}
 5084 
 5085 %}
 5086 
 5087 //----------INSTRUCTIONS-------------------------------------------------------
 5088 //
 5089 // match      -- States which machine-independent subtree may be replaced
 5090 //               by this instruction.
 5091 // ins_cost   -- The estimated cost of this instruction is used by instruction
 5092 //               selection to identify a minimum cost tree of machine
 5093 //               instructions that matches a tree of machine-independent
 5094 //               instructions.
 5095 // format     -- A string providing the disassembly for this instruction.
 5096 //               The value of an instruction&#39;s operand may be inserted
 5097 //               by referring to it with a &#39;$&#39; prefix.
 5098 // opcode     -- Three instruction opcodes may be provided.  These are referred
 5099 //               to within an encode class as $primary, $secondary, and $tertiary
 5100 //               respectively.  The primary opcode is commonly used to
 5101 //               indicate the type of machine instruction, while secondary
 5102 //               and tertiary are often used for prefix options or addressing
 5103 //               modes.
 5104 // ins_encode -- A list of encode classes with parameters. The encode class
 5105 //               name must have been defined in an &#39;enc_class&#39; specification
 5106 //               in the encode section of the architecture description.
 5107 
 5108 //----------BSWAP-Instruction--------------------------------------------------
 5109 instruct bytes_reverse_int(rRegI dst) %{
 5110   match(Set dst (ReverseBytesI dst));
 5111 
 5112   format %{ &quot;BSWAP  $dst&quot; %}
 5113   opcode(0x0F, 0xC8);
 5114   ins_encode( OpcP, OpcSReg(dst) );
 5115   ins_pipe( ialu_reg );
 5116 %}
 5117 
 5118 instruct bytes_reverse_long(eRegL dst) %{
 5119   match(Set dst (ReverseBytesL dst));
 5120 
 5121   format %{ &quot;BSWAP  $dst.lo\n\t&quot;
 5122             &quot;BSWAP  $dst.hi\n\t&quot;
 5123             &quot;XCHG   $dst.lo $dst.hi&quot; %}
 5124 
 5125   ins_cost(125);
 5126   ins_encode( bswap_long_bytes(dst) );
 5127   ins_pipe( ialu_reg_reg);
 5128 %}
 5129 
 5130 instruct bytes_reverse_unsigned_short(rRegI dst, eFlagsReg cr) %{
 5131   match(Set dst (ReverseBytesUS dst));
 5132   effect(KILL cr);
 5133 
 5134   format %{ &quot;BSWAP  $dst\n\t&quot;
 5135             &quot;SHR    $dst,16\n\t&quot; %}
 5136   ins_encode %{
 5137     __ bswapl($dst$$Register);
 5138     __ shrl($dst$$Register, 16);
 5139   %}
 5140   ins_pipe( ialu_reg );
 5141 %}
 5142 
 5143 instruct bytes_reverse_short(rRegI dst, eFlagsReg cr) %{
 5144   match(Set dst (ReverseBytesS dst));
 5145   effect(KILL cr);
 5146 
 5147   format %{ &quot;BSWAP  $dst\n\t&quot;
 5148             &quot;SAR    $dst,16\n\t&quot; %}
 5149   ins_encode %{
 5150     __ bswapl($dst$$Register);
 5151     __ sarl($dst$$Register, 16);
 5152   %}
 5153   ins_pipe( ialu_reg );
 5154 %}
 5155 
 5156 
 5157 //---------- Zeros Count Instructions ------------------------------------------
 5158 
 5159 instruct countLeadingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5160   predicate(UseCountLeadingZerosInstruction);
 5161   match(Set dst (CountLeadingZerosI src));
 5162   effect(KILL cr);
 5163 
 5164   format %{ &quot;LZCNT  $dst, $src\t# count leading zeros (int)&quot; %}
 5165   ins_encode %{
 5166     __ lzcntl($dst$$Register, $src$$Register);
 5167   %}
 5168   ins_pipe(ialu_reg);
 5169 %}
 5170 
 5171 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, eFlagsReg cr) %{
 5172   predicate(!UseCountLeadingZerosInstruction);
 5173   match(Set dst (CountLeadingZerosI src));
 5174   effect(KILL cr);
 5175 
 5176   format %{ &quot;BSR    $dst, $src\t# count leading zeros (int)\n\t&quot;
 5177             &quot;JNZ    skip\n\t&quot;
 5178             &quot;MOV    $dst, -1\n&quot;
 5179       &quot;skip:\n\t&quot;
 5180             &quot;NEG    $dst\n\t&quot;
 5181             &quot;ADD    $dst, 31&quot; %}
 5182   ins_encode %{
 5183     Register Rdst = $dst$$Register;
 5184     Register Rsrc = $src$$Register;
 5185     Label skip;
 5186     __ bsrl(Rdst, Rsrc);
 5187     __ jccb(Assembler::notZero, skip);
 5188     __ movl(Rdst, -1);
 5189     __ bind(skip);
 5190     __ negl(Rdst);
 5191     __ addl(Rdst, BitsPerInt - 1);
 5192   %}
 5193   ins_pipe(ialu_reg);
 5194 %}
 5195 
 5196 instruct countLeadingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5197   predicate(UseCountLeadingZerosInstruction);
 5198   match(Set dst (CountLeadingZerosL src));
 5199   effect(TEMP dst, KILL cr);
 5200 
 5201   format %{ &quot;LZCNT  $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5202             &quot;JNC    done\n\t&quot;
 5203             &quot;LZCNT  $dst, $src.lo\n\t&quot;
 5204             &quot;ADD    $dst, 32\n&quot;
 5205       &quot;done:&quot; %}
 5206   ins_encode %{
 5207     Register Rdst = $dst$$Register;
 5208     Register Rsrc = $src$$Register;
 5209     Label done;
 5210     __ lzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5211     __ jccb(Assembler::carryClear, done);
 5212     __ lzcntl(Rdst, Rsrc);
 5213     __ addl(Rdst, BitsPerInt);
 5214     __ bind(done);
 5215   %}
 5216   ins_pipe(ialu_reg);
 5217 %}
 5218 
 5219 instruct countLeadingZerosL_bsr(rRegI dst, eRegL src, eFlagsReg cr) %{
 5220   predicate(!UseCountLeadingZerosInstruction);
 5221   match(Set dst (CountLeadingZerosL src));
 5222   effect(TEMP dst, KILL cr);
 5223 
 5224   format %{ &quot;BSR    $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5225             &quot;JZ     msw_is_zero\n\t&quot;
 5226             &quot;ADD    $dst, 32\n\t&quot;
 5227             &quot;JMP    not_zero\n&quot;
 5228       &quot;msw_is_zero:\n\t&quot;
 5229             &quot;BSR    $dst, $src.lo\n\t&quot;
 5230             &quot;JNZ    not_zero\n\t&quot;
 5231             &quot;MOV    $dst, -1\n&quot;
 5232       &quot;not_zero:\n\t&quot;
 5233             &quot;NEG    $dst\n\t&quot;
 5234             &quot;ADD    $dst, 63\n&quot; %}
 5235  ins_encode %{
 5236     Register Rdst = $dst$$Register;
 5237     Register Rsrc = $src$$Register;
 5238     Label msw_is_zero;
 5239     Label not_zero;
 5240     __ bsrl(Rdst, HIGH_FROM_LOW(Rsrc));
 5241     __ jccb(Assembler::zero, msw_is_zero);
 5242     __ addl(Rdst, BitsPerInt);
 5243     __ jmpb(not_zero);
 5244     __ bind(msw_is_zero);
 5245     __ bsrl(Rdst, Rsrc);
 5246     __ jccb(Assembler::notZero, not_zero);
 5247     __ movl(Rdst, -1);
 5248     __ bind(not_zero);
 5249     __ negl(Rdst);
 5250     __ addl(Rdst, BitsPerLong - 1);
 5251   %}
 5252   ins_pipe(ialu_reg);
 5253 %}
 5254 
 5255 instruct countTrailingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5256   predicate(UseCountTrailingZerosInstruction);
 5257   match(Set dst (CountTrailingZerosI src));
 5258   effect(KILL cr);
 5259 
 5260   format %{ &quot;TZCNT    $dst, $src\t# count trailing zeros (int)&quot; %}
 5261   ins_encode %{
 5262     __ tzcntl($dst$$Register, $src$$Register);
 5263   %}
 5264   ins_pipe(ialu_reg);
 5265 %}
 5266 
 5267 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, eFlagsReg cr) %{
 5268   predicate(!UseCountTrailingZerosInstruction);
 5269   match(Set dst (CountTrailingZerosI src));
 5270   effect(KILL cr);
 5271 
 5272   format %{ &quot;BSF    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 5273             &quot;JNZ    done\n\t&quot;
 5274             &quot;MOV    $dst, 32\n&quot;
 5275       &quot;done:&quot; %}
 5276   ins_encode %{
 5277     Register Rdst = $dst$$Register;
 5278     Label done;
 5279     __ bsfl(Rdst, $src$$Register);
 5280     __ jccb(Assembler::notZero, done);
 5281     __ movl(Rdst, BitsPerInt);
 5282     __ bind(done);
 5283   %}
 5284   ins_pipe(ialu_reg);
 5285 %}
 5286 
 5287 instruct countTrailingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5288   predicate(UseCountTrailingZerosInstruction);
 5289   match(Set dst (CountTrailingZerosL src));
 5290   effect(TEMP dst, KILL cr);
 5291 
 5292   format %{ &quot;TZCNT  $dst, $src.lo\t# count trailing zeros (long) \n\t&quot;
 5293             &quot;JNC    done\n\t&quot;
 5294             &quot;TZCNT  $dst, $src.hi\n\t&quot;
 5295             &quot;ADD    $dst, 32\n&quot;
 5296             &quot;done:&quot; %}
 5297   ins_encode %{
 5298     Register Rdst = $dst$$Register;
 5299     Register Rsrc = $src$$Register;
 5300     Label done;
 5301     __ tzcntl(Rdst, Rsrc);
 5302     __ jccb(Assembler::carryClear, done);
 5303     __ tzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5304     __ addl(Rdst, BitsPerInt);
 5305     __ bind(done);
 5306   %}
 5307   ins_pipe(ialu_reg);
 5308 %}
 5309 
 5310 instruct countTrailingZerosL_bsf(rRegI dst, eRegL src, eFlagsReg cr) %{
 5311   predicate(!UseCountTrailingZerosInstruction);
 5312   match(Set dst (CountTrailingZerosL src));
 5313   effect(TEMP dst, KILL cr);
 5314 
 5315   format %{ &quot;BSF    $dst, $src.lo\t# count trailing zeros (long)\n\t&quot;
 5316             &quot;JNZ    done\n\t&quot;
 5317             &quot;BSF    $dst, $src.hi\n\t&quot;
 5318             &quot;JNZ    msw_not_zero\n\t&quot;
 5319             &quot;MOV    $dst, 32\n&quot;
 5320       &quot;msw_not_zero:\n\t&quot;
 5321             &quot;ADD    $dst, 32\n&quot;
 5322       &quot;done:&quot; %}
 5323   ins_encode %{
 5324     Register Rdst = $dst$$Register;
 5325     Register Rsrc = $src$$Register;
 5326     Label msw_not_zero;
 5327     Label done;
 5328     __ bsfl(Rdst, Rsrc);
 5329     __ jccb(Assembler::notZero, done);
 5330     __ bsfl(Rdst, HIGH_FROM_LOW(Rsrc));
 5331     __ jccb(Assembler::notZero, msw_not_zero);
 5332     __ movl(Rdst, BitsPerInt);
 5333     __ bind(msw_not_zero);
 5334     __ addl(Rdst, BitsPerInt);
 5335     __ bind(done);
 5336   %}
 5337   ins_pipe(ialu_reg);
 5338 %}
 5339 
 5340 
 5341 //---------- Population Count Instructions -------------------------------------
 5342 
 5343 instruct popCountI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5344   predicate(UsePopCountInstruction);
 5345   match(Set dst (PopCountI src));
 5346   effect(KILL cr);
 5347 
 5348   format %{ &quot;POPCNT $dst, $src&quot; %}
 5349   ins_encode %{
 5350     __ popcntl($dst$$Register, $src$$Register);
 5351   %}
 5352   ins_pipe(ialu_reg);
 5353 %}
 5354 
 5355 instruct popCountI_mem(rRegI dst, memory mem, eFlagsReg cr) %{
 5356   predicate(UsePopCountInstruction);
 5357   match(Set dst (PopCountI (LoadI mem)));
 5358   effect(KILL cr);
 5359 
 5360   format %{ &quot;POPCNT $dst, $mem&quot; %}
 5361   ins_encode %{
 5362     __ popcntl($dst$$Register, $mem$$Address);
 5363   %}
 5364   ins_pipe(ialu_reg);
 5365 %}
 5366 
 5367 // Note: Long.bitCount(long) returns an int.
 5368 instruct popCountL(rRegI dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 5369   predicate(UsePopCountInstruction);
 5370   match(Set dst (PopCountL src));
 5371   effect(KILL cr, TEMP tmp, TEMP dst);
 5372 
 5373   format %{ &quot;POPCNT $dst, $src.lo\n\t&quot;
 5374             &quot;POPCNT $tmp, $src.hi\n\t&quot;
 5375             &quot;ADD    $dst, $tmp&quot; %}
 5376   ins_encode %{
 5377     __ popcntl($dst$$Register, $src$$Register);
 5378     __ popcntl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 5379     __ addl($dst$$Register, $tmp$$Register);
 5380   %}
 5381   ins_pipe(ialu_reg);
 5382 %}
 5383 
 5384 // Note: Long.bitCount(long) returns an int.
 5385 instruct popCountL_mem(rRegI dst, memory mem, rRegI tmp, eFlagsReg cr) %{
 5386   predicate(UsePopCountInstruction);
 5387   match(Set dst (PopCountL (LoadL mem)));
 5388   effect(KILL cr, TEMP tmp, TEMP dst);
 5389 
 5390   format %{ &quot;POPCNT $dst, $mem\n\t&quot;
 5391             &quot;POPCNT $tmp, $mem+4\n\t&quot;
 5392             &quot;ADD    $dst, $tmp&quot; %}
 5393   ins_encode %{
 5394     //__ popcntl($dst$$Register, $mem$$Address$$first);
 5395     //__ popcntl($tmp$$Register, $mem$$Address$$second);
 5396     __ popcntl($dst$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none));
 5397     __ popcntl($tmp$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none));
 5398     __ addl($dst$$Register, $tmp$$Register);
 5399   %}
 5400   ins_pipe(ialu_reg);
 5401 %}
 5402 
 5403 
 5404 //----------Load/Store/Move Instructions---------------------------------------
 5405 //----------Load Instructions--------------------------------------------------
 5406 // Load Byte (8bit signed)
 5407 instruct loadB(xRegI dst, memory mem) %{
 5408   match(Set dst (LoadB mem));
 5409 
 5410   ins_cost(125);
 5411   format %{ &quot;MOVSX8 $dst,$mem\t# byte&quot; %}
 5412 
 5413   ins_encode %{
 5414     __ movsbl($dst$$Register, $mem$$Address);
 5415   %}
 5416 
 5417   ins_pipe(ialu_reg_mem);
 5418 %}
 5419 
 5420 // Load Byte (8bit signed) into Long Register
 5421 instruct loadB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5422   match(Set dst (ConvI2L (LoadB mem)));
 5423   effect(KILL cr);
 5424 
 5425   ins_cost(375);
 5426   format %{ &quot;MOVSX8 $dst.lo,$mem\t# byte -&gt; long\n\t&quot;
 5427             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5428             &quot;SAR    $dst.hi,7&quot; %}
 5429 
 5430   ins_encode %{
 5431     __ movsbl($dst$$Register, $mem$$Address);
 5432     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5433     __ sarl(HIGH_FROM_LOW($dst$$Register), 7); // 24+1 MSB are already signed extended.
 5434   %}
 5435 
 5436   ins_pipe(ialu_reg_mem);
 5437 %}
 5438 
 5439 // Load Unsigned Byte (8bit UNsigned)
 5440 instruct loadUB(xRegI dst, memory mem) %{
 5441   match(Set dst (LoadUB mem));
 5442 
 5443   ins_cost(125);
 5444   format %{ &quot;MOVZX8 $dst,$mem\t# ubyte -&gt; int&quot; %}
 5445 
 5446   ins_encode %{
 5447     __ movzbl($dst$$Register, $mem$$Address);
 5448   %}
 5449 
 5450   ins_pipe(ialu_reg_mem);
 5451 %}
 5452 
 5453 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 5454 instruct loadUB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5455   match(Set dst (ConvI2L (LoadUB mem)));
 5456   effect(KILL cr);
 5457 
 5458   ins_cost(250);
 5459   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte -&gt; long\n\t&quot;
 5460             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5461 
 5462   ins_encode %{
 5463     Register Rdst = $dst$$Register;
 5464     __ movzbl(Rdst, $mem$$Address);
 5465     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5466   %}
 5467 
 5468   ins_pipe(ialu_reg_mem);
 5469 %}
 5470 
 5471 // Load Unsigned Byte (8 bit UNsigned) with mask into Long Register
 5472 instruct loadUB2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5473   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5474   effect(KILL cr);
 5475 
 5476   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5477             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5478             &quot;AND    $dst.lo,right_n_bits($mask, 8)&quot; %}
 5479   ins_encode %{
 5480     Register Rdst = $dst$$Register;
 5481     __ movzbl(Rdst, $mem$$Address);
 5482     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5483     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 5484   %}
 5485   ins_pipe(ialu_reg_mem);
 5486 %}
 5487 
 5488 // Load Short (16bit signed)
 5489 instruct loadS(rRegI dst, memory mem) %{
 5490   match(Set dst (LoadS mem));
 5491 
 5492   ins_cost(125);
 5493   format %{ &quot;MOVSX  $dst,$mem\t# short&quot; %}
 5494 
 5495   ins_encode %{
 5496     __ movswl($dst$$Register, $mem$$Address);
 5497   %}
 5498 
 5499   ins_pipe(ialu_reg_mem);
 5500 %}
 5501 
 5502 // Load Short (16 bit signed) to Byte (8 bit signed)
 5503 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5504   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5505 
 5506   ins_cost(125);
 5507   format %{ &quot;MOVSX  $dst, $mem\t# short -&gt; byte&quot; %}
 5508   ins_encode %{
 5509     __ movsbl($dst$$Register, $mem$$Address);
 5510   %}
 5511   ins_pipe(ialu_reg_mem);
 5512 %}
 5513 
 5514 // Load Short (16bit signed) into Long Register
 5515 instruct loadS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5516   match(Set dst (ConvI2L (LoadS mem)));
 5517   effect(KILL cr);
 5518 
 5519   ins_cost(375);
 5520   format %{ &quot;MOVSX  $dst.lo,$mem\t# short -&gt; long\n\t&quot;
 5521             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5522             &quot;SAR    $dst.hi,15&quot; %}
 5523 
 5524   ins_encode %{
 5525     __ movswl($dst$$Register, $mem$$Address);
 5526     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5527     __ sarl(HIGH_FROM_LOW($dst$$Register), 15); // 16+1 MSB are already signed extended.
 5528   %}
 5529 
 5530   ins_pipe(ialu_reg_mem);
 5531 %}
 5532 
 5533 // Load Unsigned Short/Char (16bit unsigned)
 5534 instruct loadUS(rRegI dst, memory mem) %{
 5535   match(Set dst (LoadUS mem));
 5536 
 5537   ins_cost(125);
 5538   format %{ &quot;MOVZX  $dst,$mem\t# ushort/char -&gt; int&quot; %}
 5539 
 5540   ins_encode %{
 5541     __ movzwl($dst$$Register, $mem$$Address);
 5542   %}
 5543 
 5544   ins_pipe(ialu_reg_mem);
 5545 %}
 5546 
 5547 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5548 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5549   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5550 
 5551   ins_cost(125);
 5552   format %{ &quot;MOVSX  $dst, $mem\t# ushort -&gt; byte&quot; %}
 5553   ins_encode %{
 5554     __ movsbl($dst$$Register, $mem$$Address);
 5555   %}
 5556   ins_pipe(ialu_reg_mem);
 5557 %}
 5558 
 5559 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 5560 instruct loadUS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5561   match(Set dst (ConvI2L (LoadUS mem)));
 5562   effect(KILL cr);
 5563 
 5564   ins_cost(250);
 5565   format %{ &quot;MOVZX  $dst.lo,$mem\t# ushort/char -&gt; long\n\t&quot;
 5566             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5567 
 5568   ins_encode %{
 5569     __ movzwl($dst$$Register, $mem$$Address);
 5570     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5571   %}
 5572 
 5573   ins_pipe(ialu_reg_mem);
 5574 %}
 5575 
 5576 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 5577 instruct loadUS2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5578   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5579   effect(KILL cr);
 5580 
 5581   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ushort/char &amp; 0xFF -&gt; long\n\t&quot;
 5582             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5583   ins_encode %{
 5584     Register Rdst = $dst$$Register;
 5585     __ movzbl(Rdst, $mem$$Address);
 5586     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5587   %}
 5588   ins_pipe(ialu_reg_mem);
 5589 %}
 5590 
 5591 // Load Unsigned Short/Char (16 bit UNsigned) with a 32-bit mask into Long Register
 5592 instruct loadUS2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5593   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5594   effect(KILL cr);
 5595 
 5596   format %{ &quot;MOVZX  $dst.lo, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5597             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5598             &quot;AND    $dst.lo,right_n_bits($mask, 16)&quot; %}
 5599   ins_encode %{
 5600     Register Rdst = $dst$$Register;
 5601     __ movzwl(Rdst, $mem$$Address);
 5602     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5603     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 5604   %}
 5605   ins_pipe(ialu_reg_mem);
 5606 %}
 5607 
 5608 // Load Integer
 5609 instruct loadI(rRegI dst, memory mem) %{
 5610   match(Set dst (LoadI mem));
 5611 
 5612   ins_cost(125);
 5613   format %{ &quot;MOV    $dst,$mem\t# int&quot; %}
 5614 
 5615   ins_encode %{
 5616     __ movl($dst$$Register, $mem$$Address);
 5617   %}
 5618 
 5619   ins_pipe(ialu_reg_mem);
 5620 %}
 5621 
 5622 // Load Integer (32 bit signed) to Byte (8 bit signed)
 5623 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5624   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5625 
 5626   ins_cost(125);
 5627   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; byte&quot; %}
 5628   ins_encode %{
 5629     __ movsbl($dst$$Register, $mem$$Address);
 5630   %}
 5631   ins_pipe(ialu_reg_mem);
 5632 %}
 5633 
 5634 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 5635 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 5636   match(Set dst (AndI (LoadI mem) mask));
 5637 
 5638   ins_cost(125);
 5639   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5640   ins_encode %{
 5641     __ movzbl($dst$$Register, $mem$$Address);
 5642   %}
 5643   ins_pipe(ialu_reg_mem);
 5644 %}
 5645 
 5646 // Load Integer (32 bit signed) to Short (16 bit signed)
 5647 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5648   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5649 
 5650   ins_cost(125);
 5651   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; short&quot; %}
 5652   ins_encode %{
 5653     __ movswl($dst$$Register, $mem$$Address);
 5654   %}
 5655   ins_pipe(ialu_reg_mem);
 5656 %}
 5657 
 5658 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5659 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5660   match(Set dst (AndI (LoadI mem) mask));
 5661 
 5662   ins_cost(125);
 5663   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5664   ins_encode %{
 5665     __ movzwl($dst$$Register, $mem$$Address);
 5666   %}
 5667   ins_pipe(ialu_reg_mem);
 5668 %}
 5669 
 5670 // Load Integer into Long Register
 5671 instruct loadI2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5672   match(Set dst (ConvI2L (LoadI mem)));
 5673   effect(KILL cr);
 5674 
 5675   ins_cost(375);
 5676   format %{ &quot;MOV    $dst.lo,$mem\t# int -&gt; long\n\t&quot;
 5677             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5678             &quot;SAR    $dst.hi,31&quot; %}
 5679 
 5680   ins_encode %{
 5681     __ movl($dst$$Register, $mem$$Address);
 5682     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5683     __ sarl(HIGH_FROM_LOW($dst$$Register), 31);
 5684   %}
 5685 
 5686   ins_pipe(ialu_reg_mem);
 5687 %}
 5688 
 5689 // Load Integer with mask 0xFF into Long Register
 5690 instruct loadI2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5691   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5692   effect(KILL cr);
 5693 
 5694   format %{ &quot;MOVZX8 $dst.lo,$mem\t# int &amp; 0xFF -&gt; long\n\t&quot;
 5695             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5696   ins_encode %{
 5697     Register Rdst = $dst$$Register;
 5698     __ movzbl(Rdst, $mem$$Address);
 5699     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5700   %}
 5701   ins_pipe(ialu_reg_mem);
 5702 %}
 5703 
 5704 // Load Integer with mask 0xFFFF into Long Register
 5705 instruct loadI2L_immI_65535(eRegL dst, memory mem, immI_65535 mask, eFlagsReg cr) %{
 5706   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5707   effect(KILL cr);
 5708 
 5709   format %{ &quot;MOVZX  $dst.lo,$mem\t# int &amp; 0xFFFF -&gt; long\n\t&quot;
 5710             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5711   ins_encode %{
 5712     Register Rdst = $dst$$Register;
 5713     __ movzwl(Rdst, $mem$$Address);
 5714     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5715   %}
 5716   ins_pipe(ialu_reg_mem);
 5717 %}
 5718 
 5719 // Load Integer with 31-bit mask into Long Register
 5720 instruct loadI2L_immU31(eRegL dst, memory mem, immU31 mask, eFlagsReg cr) %{
 5721   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5722   effect(KILL cr);
 5723 
 5724   format %{ &quot;MOV    $dst.lo,$mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5725             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5726             &quot;AND    $dst.lo,$mask&quot; %}
 5727   ins_encode %{
 5728     Register Rdst = $dst$$Register;
 5729     __ movl(Rdst, $mem$$Address);
 5730     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5731     __ andl(Rdst, $mask$$constant);
 5732   %}
 5733   ins_pipe(ialu_reg_mem);
 5734 %}
 5735 
 5736 // Load Unsigned Integer into Long Register
 5737 instruct loadUI2L(eRegL dst, memory mem, immL_32bits mask, eFlagsReg cr) %{
 5738   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5739   effect(KILL cr);
 5740 
 5741   ins_cost(250);
 5742   format %{ &quot;MOV    $dst.lo,$mem\t# uint -&gt; long\n\t&quot;
 5743             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5744 
 5745   ins_encode %{
 5746     __ movl($dst$$Register, $mem$$Address);
 5747     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5748   %}
 5749 
 5750   ins_pipe(ialu_reg_mem);
 5751 %}
 5752 
 5753 // Load Long.  Cannot clobber address while loading, so restrict address
 5754 // register to ESI
 5755 instruct loadL(eRegL dst, load_long_memory mem) %{
 5756   predicate(!((LoadLNode*)n)-&gt;require_atomic_access());
 5757   match(Set dst (LoadL mem));
 5758 
 5759   ins_cost(250);
 5760   format %{ &quot;MOV    $dst.lo,$mem\t# long\n\t&quot;
 5761             &quot;MOV    $dst.hi,$mem+4&quot; %}
 5762 
 5763   ins_encode %{
 5764     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 5765     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 5766     __ movl($dst$$Register, Amemlo);
 5767     __ movl(HIGH_FROM_LOW($dst$$Register), Amemhi);
 5768   %}
 5769 
 5770   ins_pipe(ialu_reg_long_mem);
 5771 %}
 5772 
 5773 // Volatile Load Long.  Must be atomic, so do 64-bit FILD
 5774 // then store it down to the stack and reload on the int
 5775 // side.
 5776 instruct loadL_volatile(stackSlotL dst, memory mem) %{
 5777   predicate(UseSSE&lt;=1 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5778   match(Set dst (LoadL mem));
 5779 
 5780   ins_cost(200);
 5781   format %{ &quot;FILD   $mem\t# Atomic volatile long load\n\t&quot;
 5782             &quot;FISTp  $dst&quot; %}
 5783   ins_encode(enc_loadL_volatile(mem,dst));
 5784   ins_pipe( fpu_reg_mem );
 5785 %}
 5786 
 5787 instruct loadLX_volatile(stackSlotL dst, memory mem, regD tmp) %{
 5788   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5789   match(Set dst (LoadL mem));
 5790   effect(TEMP tmp);
 5791   ins_cost(180);
 5792   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5793             &quot;MOVSD  $dst,$tmp&quot; %}
 5794   ins_encode %{
 5795     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5796     __ movdbl(Address(rsp, $dst$$disp), $tmp$$XMMRegister);
 5797   %}
 5798   ins_pipe( pipe_slow );
 5799 %}
 5800 
 5801 instruct loadLX_reg_volatile(eRegL dst, memory mem, regD tmp) %{
 5802   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5803   match(Set dst (LoadL mem));
 5804   effect(TEMP tmp);
 5805   ins_cost(160);
 5806   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5807             &quot;MOVD   $dst.lo,$tmp\n\t&quot;
 5808             &quot;PSRLQ  $tmp,32\n\t&quot;
 5809             &quot;MOVD   $dst.hi,$tmp&quot; %}
 5810   ins_encode %{
 5811     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5812     __ movdl($dst$$Register, $tmp$$XMMRegister);
 5813     __ psrlq($tmp$$XMMRegister, 32);
 5814     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
 5815   %}
 5816   ins_pipe( pipe_slow );
 5817 %}
 5818 
 5819 // Load Range
 5820 instruct loadRange(rRegI dst, memory mem) %{
 5821   match(Set dst (LoadRange mem));
 5822 
 5823   ins_cost(125);
 5824   format %{ &quot;MOV    $dst,$mem&quot; %}
 5825   opcode(0x8B);
 5826   ins_encode( OpcP, RegMem(dst,mem));
 5827   ins_pipe( ialu_reg_mem );
 5828 %}
 5829 
 5830 
 5831 // Load Pointer
 5832 instruct loadP(eRegP dst, memory mem) %{
 5833   match(Set dst (LoadP mem));
 5834 
 5835   ins_cost(125);
 5836   format %{ &quot;MOV    $dst,$mem&quot; %}
 5837   opcode(0x8B);
 5838   ins_encode( OpcP, RegMem(dst,mem));
 5839   ins_pipe( ialu_reg_mem );
 5840 %}
 5841 
 5842 // Load Klass Pointer
 5843 instruct loadKlass(eRegP dst, memory mem) %{
 5844   match(Set dst (LoadKlass mem));
 5845 
 5846   ins_cost(125);
 5847   format %{ &quot;MOV    $dst,$mem&quot; %}
 5848   opcode(0x8B);
 5849   ins_encode( OpcP, RegMem(dst,mem));
 5850   ins_pipe( ialu_reg_mem );
 5851 %}
 5852 
 5853 // Load Double
 5854 instruct loadDPR(regDPR dst, memory mem) %{
 5855   predicate(UseSSE&lt;=1);
 5856   match(Set dst (LoadD mem));
 5857 
 5858   ins_cost(150);
 5859   format %{ &quot;FLD_D  ST,$mem\n\t&quot;
 5860             &quot;FSTP   $dst&quot; %}
 5861   opcode(0xDD);               /* DD /0 */
 5862   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5863               Pop_Reg_DPR(dst) );
 5864   ins_pipe( fpu_reg_mem );
 5865 %}
 5866 
 5867 // Load Double to XMM
 5868 instruct loadD(regD dst, memory mem) %{
 5869   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
 5870   match(Set dst (LoadD mem));
 5871   ins_cost(145);
 5872   format %{ &quot;MOVSD  $dst,$mem&quot; %}
 5873   ins_encode %{
 5874     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5875   %}
 5876   ins_pipe( pipe_slow );
 5877 %}
 5878 
 5879 instruct loadD_partial(regD dst, memory mem) %{
 5880   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
 5881   match(Set dst (LoadD mem));
 5882   ins_cost(145);
 5883   format %{ &quot;MOVLPD $dst,$mem&quot; %}
 5884   ins_encode %{
 5885     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5886   %}
 5887   ins_pipe( pipe_slow );
 5888 %}
 5889 
 5890 // Load to XMM register (single-precision floating point)
 5891 // MOVSS instruction
 5892 instruct loadF(regF dst, memory mem) %{
 5893   predicate(UseSSE&gt;=1);
 5894   match(Set dst (LoadF mem));
 5895   ins_cost(145);
 5896   format %{ &quot;MOVSS  $dst,$mem&quot; %}
 5897   ins_encode %{
 5898     __ movflt ($dst$$XMMRegister, $mem$$Address);
 5899   %}
 5900   ins_pipe( pipe_slow );
 5901 %}
 5902 
 5903 // Load Float
 5904 instruct loadFPR(regFPR dst, memory mem) %{
 5905   predicate(UseSSE==0);
 5906   match(Set dst (LoadF mem));
 5907 
 5908   ins_cost(150);
 5909   format %{ &quot;FLD_S  ST,$mem\n\t&quot;
 5910             &quot;FSTP   $dst&quot; %}
 5911   opcode(0xD9);               /* D9 /0 */
 5912   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5913               Pop_Reg_FPR(dst) );
 5914   ins_pipe( fpu_reg_mem );
 5915 %}
 5916 
 5917 // Load Effective Address
 5918 instruct leaP8(eRegP dst, indOffset8 mem) %{
 5919   match(Set dst mem);
 5920 
 5921   ins_cost(110);
 5922   format %{ &quot;LEA    $dst,$mem&quot; %}
 5923   opcode(0x8D);
 5924   ins_encode( OpcP, RegMem(dst,mem));
 5925   ins_pipe( ialu_reg_reg_fat );
 5926 %}
 5927 
 5928 instruct leaP32(eRegP dst, indOffset32 mem) %{
 5929   match(Set dst mem);
 5930 
 5931   ins_cost(110);
 5932   format %{ &quot;LEA    $dst,$mem&quot; %}
 5933   opcode(0x8D);
 5934   ins_encode( OpcP, RegMem(dst,mem));
 5935   ins_pipe( ialu_reg_reg_fat );
 5936 %}
 5937 
 5938 instruct leaPIdxOff(eRegP dst, indIndexOffset mem) %{
 5939   match(Set dst mem);
 5940 
 5941   ins_cost(110);
 5942   format %{ &quot;LEA    $dst,$mem&quot; %}
 5943   opcode(0x8D);
 5944   ins_encode( OpcP, RegMem(dst,mem));
 5945   ins_pipe( ialu_reg_reg_fat );
 5946 %}
 5947 
 5948 instruct leaPIdxScale(eRegP dst, indIndexScale mem) %{
 5949   match(Set dst mem);
 5950 
 5951   ins_cost(110);
 5952   format %{ &quot;LEA    $dst,$mem&quot; %}
 5953   opcode(0x8D);
 5954   ins_encode( OpcP, RegMem(dst,mem));
 5955   ins_pipe( ialu_reg_reg_fat );
 5956 %}
 5957 
 5958 instruct leaPIdxScaleOff(eRegP dst, indIndexScaleOffset mem) %{
 5959   match(Set dst mem);
 5960 
 5961   ins_cost(110);
 5962   format %{ &quot;LEA    $dst,$mem&quot; %}
 5963   opcode(0x8D);
 5964   ins_encode( OpcP, RegMem(dst,mem));
 5965   ins_pipe( ialu_reg_reg_fat );
 5966 %}
 5967 
 5968 // Load Constant
 5969 instruct loadConI(rRegI dst, immI src) %{
 5970   match(Set dst src);
 5971 
 5972   format %{ &quot;MOV    $dst,$src&quot; %}
 5973   ins_encode( LdImmI(dst, src) );
 5974   ins_pipe( ialu_reg_fat );
 5975 %}
 5976 
 5977 // Load Constant zero
 5978 instruct loadConI0(rRegI dst, immI0 src, eFlagsReg cr) %{
 5979   match(Set dst src);
 5980   effect(KILL cr);
 5981 
 5982   ins_cost(50);
 5983   format %{ &quot;XOR    $dst,$dst&quot; %}
 5984   opcode(0x33);  /* + rd */
 5985   ins_encode( OpcP, RegReg( dst, dst ) );
 5986   ins_pipe( ialu_reg );
 5987 %}
 5988 
 5989 instruct loadConP(eRegP dst, immP src) %{
 5990   match(Set dst src);
 5991 
 5992   format %{ &quot;MOV    $dst,$src&quot; %}
 5993   opcode(0xB8);  /* + rd */
 5994   ins_encode( LdImmP(dst, src) );
 5995   ins_pipe( ialu_reg_fat );
 5996 %}
 5997 
 5998 instruct loadConL(eRegL dst, immL src, eFlagsReg cr) %{
 5999   match(Set dst src);
 6000   effect(KILL cr);
 6001   ins_cost(200);
 6002   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
 6003             &quot;MOV    $dst.hi,$src.hi&quot; %}
 6004   opcode(0xB8);
 6005   ins_encode( LdImmL_Lo(dst, src), LdImmL_Hi(dst, src) );
 6006   ins_pipe( ialu_reg_long_fat );
 6007 %}
 6008 
 6009 instruct loadConL0(eRegL dst, immL0 src, eFlagsReg cr) %{
 6010   match(Set dst src);
 6011   effect(KILL cr);
 6012   ins_cost(150);
 6013   format %{ &quot;XOR    $dst.lo,$dst.lo\n\t&quot;
 6014             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 6015   opcode(0x33,0x33);
 6016   ins_encode( RegReg_Lo(dst,dst), RegReg_Hi(dst, dst) );
 6017   ins_pipe( ialu_reg_long );
 6018 %}
 6019 
 6020 // The instruction usage is guarded by predicate in operand immFPR().
 6021 instruct loadConFPR(regFPR dst, immFPR con) %{
 6022   match(Set dst con);
 6023   ins_cost(125);
 6024   format %{ &quot;FLD_S  ST,[$constantaddress]\t# load from constant table: float=$con\n\t&quot;
 6025             &quot;FSTP   $dst&quot; %}
 6026   ins_encode %{
 6027     __ fld_s($constantaddress($con));
 6028     __ fstp_d($dst$$reg);
 6029   %}
 6030   ins_pipe(fpu_reg_con);
 6031 %}
 6032 
 6033 // The instruction usage is guarded by predicate in operand immFPR0().
 6034 instruct loadConFPR0(regFPR dst, immFPR0 con) %{
 6035   match(Set dst con);
 6036   ins_cost(125);
 6037   format %{ &quot;FLDZ   ST\n\t&quot;
 6038             &quot;FSTP   $dst&quot; %}
 6039   ins_encode %{
 6040     __ fldz();
 6041     __ fstp_d($dst$$reg);
 6042   %}
 6043   ins_pipe(fpu_reg_con);
 6044 %}
 6045 
 6046 // The instruction usage is guarded by predicate in operand immFPR1().
 6047 instruct loadConFPR1(regFPR dst, immFPR1 con) %{
 6048   match(Set dst con);
 6049   ins_cost(125);
 6050   format %{ &quot;FLD1   ST\n\t&quot;
 6051             &quot;FSTP   $dst&quot; %}
 6052   ins_encode %{
 6053     __ fld1();
 6054     __ fstp_d($dst$$reg);
 6055   %}
 6056   ins_pipe(fpu_reg_con);
 6057 %}
 6058 
 6059 // The instruction usage is guarded by predicate in operand immF().
 6060 instruct loadConF(regF dst, immF con) %{
 6061   match(Set dst con);
 6062   ins_cost(125);
 6063   format %{ &quot;MOVSS  $dst,[$constantaddress]\t# load from constant table: float=$con&quot; %}
 6064   ins_encode %{
 6065     __ movflt($dst$$XMMRegister, $constantaddress($con));
 6066   %}
 6067   ins_pipe(pipe_slow);
 6068 %}
 6069 
 6070 // The instruction usage is guarded by predicate in operand immF0().
 6071 instruct loadConF0(regF dst, immF0 src) %{
 6072   match(Set dst src);
 6073   ins_cost(100);
 6074   format %{ &quot;XORPS  $dst,$dst\t# float 0.0&quot; %}
 6075   ins_encode %{
 6076     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 6077   %}
 6078   ins_pipe(pipe_slow);
 6079 %}
 6080 
 6081 // The instruction usage is guarded by predicate in operand immDPR().
 6082 instruct loadConDPR(regDPR dst, immDPR con) %{
 6083   match(Set dst con);
 6084   ins_cost(125);
 6085 
 6086   format %{ &quot;FLD_D  ST,[$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 6087             &quot;FSTP   $dst&quot; %}
 6088   ins_encode %{
 6089     __ fld_d($constantaddress($con));
 6090     __ fstp_d($dst$$reg);
 6091   %}
 6092   ins_pipe(fpu_reg_con);
 6093 %}
 6094 
 6095 // The instruction usage is guarded by predicate in operand immDPR0().
 6096 instruct loadConDPR0(regDPR dst, immDPR0 con) %{
 6097   match(Set dst con);
 6098   ins_cost(125);
 6099 
 6100   format %{ &quot;FLDZ   ST\n\t&quot;
 6101             &quot;FSTP   $dst&quot; %}
 6102   ins_encode %{
 6103     __ fldz();
 6104     __ fstp_d($dst$$reg);
 6105   %}
 6106   ins_pipe(fpu_reg_con);
 6107 %}
 6108 
 6109 // The instruction usage is guarded by predicate in operand immDPR1().
 6110 instruct loadConDPR1(regDPR dst, immDPR1 con) %{
 6111   match(Set dst con);
 6112   ins_cost(125);
 6113 
 6114   format %{ &quot;FLD1   ST\n\t&quot;
 6115             &quot;FSTP   $dst&quot; %}
 6116   ins_encode %{
 6117     __ fld1();
 6118     __ fstp_d($dst$$reg);
 6119   %}
 6120   ins_pipe(fpu_reg_con);
 6121 %}
 6122 
 6123 // The instruction usage is guarded by predicate in operand immD().
 6124 instruct loadConD(regD dst, immD con) %{
 6125   match(Set dst con);
 6126   ins_cost(125);
 6127   format %{ &quot;MOVSD  $dst,[$constantaddress]\t# load from constant table: double=$con&quot; %}
 6128   ins_encode %{
 6129     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 6130   %}
 6131   ins_pipe(pipe_slow);
 6132 %}
 6133 
 6134 // The instruction usage is guarded by predicate in operand immD0().
 6135 instruct loadConD0(regD dst, immD0 src) %{
 6136   match(Set dst src);
 6137   ins_cost(100);
 6138   format %{ &quot;XORPD  $dst,$dst\t# double 0.0&quot; %}
 6139   ins_encode %{
 6140     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 6141   %}
 6142   ins_pipe( pipe_slow );
 6143 %}
 6144 
 6145 // Load Stack Slot
 6146 instruct loadSSI(rRegI dst, stackSlotI src) %{
 6147   match(Set dst src);
 6148   ins_cost(125);
 6149 
 6150   format %{ &quot;MOV    $dst,$src&quot; %}
 6151   opcode(0x8B);
 6152   ins_encode( OpcP, RegMem(dst,src));
 6153   ins_pipe( ialu_reg_mem );
 6154 %}
 6155 
 6156 instruct loadSSL(eRegL dst, stackSlotL src) %{
 6157   match(Set dst src);
 6158 
 6159   ins_cost(200);
 6160   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6161             &quot;MOV    $dst+4,$src.hi&quot; %}
 6162   opcode(0x8B, 0x8B);
 6163   ins_encode( OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ) );
 6164   ins_pipe( ialu_mem_long_reg );
 6165 %}
 6166 
 6167 // Load Stack Slot
 6168 instruct loadSSP(eRegP dst, stackSlotP src) %{
 6169   match(Set dst src);
 6170   ins_cost(125);
 6171 
 6172   format %{ &quot;MOV    $dst,$src&quot; %}
 6173   opcode(0x8B);
 6174   ins_encode( OpcP, RegMem(dst,src));
 6175   ins_pipe( ialu_reg_mem );
 6176 %}
 6177 
 6178 // Load Stack Slot
 6179 instruct loadSSF(regFPR dst, stackSlotF src) %{
 6180   match(Set dst src);
 6181   ins_cost(125);
 6182 
 6183   format %{ &quot;FLD_S  $src\n\t&quot;
 6184             &quot;FSTP   $dst&quot; %}
 6185   opcode(0xD9);               /* D9 /0, FLD m32real */
 6186   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6187               Pop_Reg_FPR(dst) );
 6188   ins_pipe( fpu_reg_mem );
 6189 %}
 6190 
 6191 // Load Stack Slot
 6192 instruct loadSSD(regDPR dst, stackSlotD src) %{
 6193   match(Set dst src);
 6194   ins_cost(125);
 6195 
 6196   format %{ &quot;FLD_D  $src\n\t&quot;
 6197             &quot;FSTP   $dst&quot; %}
 6198   opcode(0xDD);               /* DD /0, FLD m64real */
 6199   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6200               Pop_Reg_DPR(dst) );
 6201   ins_pipe( fpu_reg_mem );
 6202 %}
 6203 
 6204 // Prefetch instructions for allocation.
 6205 // Must be safe to execute with invalid address (cannot fault).
 6206 
 6207 instruct prefetchAlloc0( memory mem ) %{
 6208   predicate(UseSSE==0 &amp;&amp; AllocatePrefetchInstr!=3);
 6209   match(PrefetchAllocation mem);
 6210   ins_cost(0);
 6211   size(0);
 6212   format %{ &quot;Prefetch allocation (non-SSE is empty encoding)&quot; %}
 6213   ins_encode();
 6214   ins_pipe(empty);
 6215 %}
 6216 
 6217 instruct prefetchAlloc( memory mem ) %{
 6218   predicate(AllocatePrefetchInstr==3);
 6219   match( PrefetchAllocation mem );
 6220   ins_cost(100);
 6221 
 6222   format %{ &quot;PREFETCHW $mem\t! Prefetch allocation into L1 cache and mark modified&quot; %}
 6223   ins_encode %{
 6224     __ prefetchw($mem$$Address);
 6225   %}
 6226   ins_pipe(ialu_mem);
 6227 %}
 6228 
 6229 instruct prefetchAllocNTA( memory mem ) %{
 6230   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==0);
 6231   match(PrefetchAllocation mem);
 6232   ins_cost(100);
 6233 
 6234   format %{ &quot;PREFETCHNTA $mem\t! Prefetch allocation into non-temporal cache for write&quot; %}
 6235   ins_encode %{
 6236     __ prefetchnta($mem$$Address);
 6237   %}
 6238   ins_pipe(ialu_mem);
 6239 %}
 6240 
 6241 instruct prefetchAllocT0( memory mem ) %{
 6242   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==1);
 6243   match(PrefetchAllocation mem);
 6244   ins_cost(100);
 6245 
 6246   format %{ &quot;PREFETCHT0 $mem\t! Prefetch allocation into L1 and L2 caches for write&quot; %}
 6247   ins_encode %{
 6248     __ prefetcht0($mem$$Address);
 6249   %}
 6250   ins_pipe(ialu_mem);
 6251 %}
 6252 
 6253 instruct prefetchAllocT2( memory mem ) %{
 6254   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==2);
 6255   match(PrefetchAllocation mem);
 6256   ins_cost(100);
 6257 
 6258   format %{ &quot;PREFETCHT2 $mem\t! Prefetch allocation into L2 cache for write&quot; %}
 6259   ins_encode %{
 6260     __ prefetcht2($mem$$Address);
 6261   %}
 6262   ins_pipe(ialu_mem);
 6263 %}
 6264 
 6265 //----------Store Instructions-------------------------------------------------
 6266 
 6267 // Store Byte
 6268 instruct storeB(memory mem, xRegI src) %{
 6269   match(Set mem (StoreB mem src));
 6270 
 6271   ins_cost(125);
 6272   format %{ &quot;MOV8   $mem,$src&quot; %}
 6273   opcode(0x88);
 6274   ins_encode( OpcP, RegMem( src, mem ) );
 6275   ins_pipe( ialu_mem_reg );
 6276 %}
 6277 
 6278 // Store Char/Short
 6279 instruct storeC(memory mem, rRegI src) %{
 6280   match(Set mem (StoreC mem src));
 6281 
 6282   ins_cost(125);
 6283   format %{ &quot;MOV16  $mem,$src&quot; %}
 6284   opcode(0x89, 0x66);
 6285   ins_encode( OpcS, OpcP, RegMem( src, mem ) );
 6286   ins_pipe( ialu_mem_reg );
 6287 %}
 6288 
 6289 // Store Integer
 6290 instruct storeI(memory mem, rRegI src) %{
 6291   match(Set mem (StoreI mem src));
 6292 
 6293   ins_cost(125);
 6294   format %{ &quot;MOV    $mem,$src&quot; %}
 6295   opcode(0x89);
 6296   ins_encode( OpcP, RegMem( src, mem ) );
 6297   ins_pipe( ialu_mem_reg );
 6298 %}
 6299 
 6300 // Store Long
 6301 instruct storeL(long_memory mem, eRegL src) %{
 6302   predicate(!((StoreLNode*)n)-&gt;require_atomic_access());
 6303   match(Set mem (StoreL mem src));
 6304 
 6305   ins_cost(200);
 6306   format %{ &quot;MOV    $mem,$src.lo\n\t&quot;
 6307             &quot;MOV    $mem+4,$src.hi&quot; %}
 6308   opcode(0x89, 0x89);
 6309   ins_encode( OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ) );
 6310   ins_pipe( ialu_mem_long_reg );
 6311 %}
 6312 
 6313 // Store Long to Integer
 6314 instruct storeL2I(memory mem, eRegL src) %{
 6315   match(Set mem (StoreI mem (ConvL2I src)));
 6316 
 6317   format %{ &quot;MOV    $mem,$src.lo\t# long -&gt; int&quot; %}
 6318   ins_encode %{
 6319     __ movl($mem$$Address, $src$$Register);
 6320   %}
 6321   ins_pipe(ialu_mem_reg);
 6322 %}
 6323 
 6324 // Volatile Store Long.  Must be atomic, so move it into
 6325 // the FP TOS and then do a 64-bit FIST.  Has to probe the
 6326 // target address before the store (for null-ptr checks)
 6327 // so the memory operand is used twice in the encoding.
 6328 instruct storeL_volatile(memory mem, stackSlotL src, eFlagsReg cr ) %{
 6329   predicate(UseSSE&lt;=1 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6330   match(Set mem (StoreL mem src));
 6331   effect( KILL cr );
 6332   ins_cost(400);
 6333   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6334             &quot;FILD   $src\n\t&quot;
 6335             &quot;FISTp  $mem\t # 64-bit atomic volatile long store&quot; %}
 6336   opcode(0x3B);
 6337   ins_encode( OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src));
 6338   ins_pipe( fpu_reg_mem );
 6339 %}
 6340 
 6341 instruct storeLX_volatile(memory mem, stackSlotL src, regD tmp, eFlagsReg cr) %{
 6342   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6343   match(Set mem (StoreL mem src));
 6344   effect( TEMP tmp, KILL cr );
 6345   ins_cost(380);
 6346   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6347             &quot;MOVSD  $tmp,$src\n\t&quot;
 6348             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6349   ins_encode %{
 6350     __ cmpl(rax, $mem$$Address);
 6351     __ movdbl($tmp$$XMMRegister, Address(rsp, $src$$disp));
 6352     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6353   %}
 6354   ins_pipe( pipe_slow );
 6355 %}
 6356 
 6357 instruct storeLX_reg_volatile(memory mem, eRegL src, regD tmp2, regD tmp, eFlagsReg cr) %{
 6358   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6359   match(Set mem (StoreL mem src));
 6360   effect( TEMP tmp2 , TEMP tmp, KILL cr );
 6361   ins_cost(360);
 6362   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6363             &quot;MOVD   $tmp,$src.lo\n\t&quot;
 6364             &quot;MOVD   $tmp2,$src.hi\n\t&quot;
 6365             &quot;PUNPCKLDQ $tmp,$tmp2\n\t&quot;
 6366             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6367   ins_encode %{
 6368     __ cmpl(rax, $mem$$Address);
 6369     __ movdl($tmp$$XMMRegister, $src$$Register);
 6370     __ movdl($tmp2$$XMMRegister, HIGH_FROM_LOW($src$$Register));
 6371     __ punpckldq($tmp$$XMMRegister, $tmp2$$XMMRegister);
 6372     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6373   %}
 6374   ins_pipe( pipe_slow );
 6375 %}
 6376 
 6377 // Store Pointer; for storing unknown oops and raw pointers
 6378 instruct storeP(memory mem, anyRegP src) %{
 6379   match(Set mem (StoreP mem src));
 6380 
 6381   ins_cost(125);
 6382   format %{ &quot;MOV    $mem,$src&quot; %}
 6383   opcode(0x89);
 6384   ins_encode( OpcP, RegMem( src, mem ) );
 6385   ins_pipe( ialu_mem_reg );
 6386 %}
 6387 
 6388 // Store Integer Immediate
 6389 instruct storeImmI(memory mem, immI src) %{
 6390   match(Set mem (StoreI mem src));
 6391 
 6392   ins_cost(150);
 6393   format %{ &quot;MOV    $mem,$src&quot; %}
 6394   opcode(0xC7);               /* C7 /0 */
 6395   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6396   ins_pipe( ialu_mem_imm );
 6397 %}
 6398 
 6399 // Store Short/Char Immediate
 6400 instruct storeImmI16(memory mem, immI16 src) %{
 6401   predicate(UseStoreImmI16);
 6402   match(Set mem (StoreC mem src));
 6403 
 6404   ins_cost(150);
 6405   format %{ &quot;MOV16  $mem,$src&quot; %}
 6406   opcode(0xC7);     /* C7 /0 Same as 32 store immediate with prefix */
 6407   ins_encode( SizePrefix, OpcP, RMopc_Mem(0x00,mem),  Con16( src ));
 6408   ins_pipe( ialu_mem_imm );
 6409 %}
 6410 
 6411 // Store Pointer Immediate; null pointers or constant oops that do not
 6412 // need card-mark barriers.
 6413 instruct storeImmP(memory mem, immP src) %{
 6414   match(Set mem (StoreP mem src));
 6415 
 6416   ins_cost(150);
 6417   format %{ &quot;MOV    $mem,$src&quot; %}
 6418   opcode(0xC7);               /* C7 /0 */
 6419   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6420   ins_pipe( ialu_mem_imm );
 6421 %}
 6422 
 6423 // Store Byte Immediate
 6424 instruct storeImmB(memory mem, immI8 src) %{
 6425   match(Set mem (StoreB mem src));
 6426 
 6427   ins_cost(150);
 6428   format %{ &quot;MOV8   $mem,$src&quot; %}
 6429   opcode(0xC6);               /* C6 /0 */
 6430   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6431   ins_pipe( ialu_mem_imm );
 6432 %}
 6433 
 6434 // Store CMS card-mark Immediate
 6435 instruct storeImmCM(memory mem, immI8 src) %{
 6436   match(Set mem (StoreCM mem src));
 6437 
 6438   ins_cost(150);
 6439   format %{ &quot;MOV8   $mem,$src\t! CMS card-mark imm0&quot; %}
 6440   opcode(0xC6);               /* C6 /0 */
 6441   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6442   ins_pipe( ialu_mem_imm );
 6443 %}
 6444 
 6445 // Store Double
 6446 instruct storeDPR( memory mem, regDPR1 src) %{
 6447   predicate(UseSSE&lt;=1);
 6448   match(Set mem (StoreD mem src));
 6449 
 6450   ins_cost(100);
 6451   format %{ &quot;FST_D  $mem,$src&quot; %}
 6452   opcode(0xDD);       /* DD /2 */
 6453   ins_encode( enc_FPR_store(mem,src) );
 6454   ins_pipe( fpu_mem_reg );
 6455 %}
 6456 
 6457 // Store double does rounding on x86
 6458 instruct storeDPR_rounded( memory mem, regDPR1 src) %{
 6459   predicate(UseSSE&lt;=1);
 6460   match(Set mem (StoreD mem (RoundDouble src)));
 6461 
 6462   ins_cost(100);
 6463   format %{ &quot;FST_D  $mem,$src\t# round&quot; %}
 6464   opcode(0xDD);       /* DD /2 */
 6465   ins_encode( enc_FPR_store(mem,src) );
 6466   ins_pipe( fpu_mem_reg );
 6467 %}
 6468 
 6469 // Store XMM register to memory (double-precision floating points)
 6470 // MOVSD instruction
 6471 instruct storeD(memory mem, regD src) %{
 6472   predicate(UseSSE&gt;=2);
 6473   match(Set mem (StoreD mem src));
 6474   ins_cost(95);
 6475   format %{ &quot;MOVSD  $mem,$src&quot; %}
 6476   ins_encode %{
 6477     __ movdbl($mem$$Address, $src$$XMMRegister);
 6478   %}
 6479   ins_pipe( pipe_slow );
 6480 %}
 6481 
 6482 // Load Double
 6483 instruct MoveD2VL(vlRegD dst, regD src) %{
 6484   match(Set dst src);
 6485   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6486   ins_encode %{
 6487     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6488   %}
 6489   ins_pipe( fpu_reg_reg );
 6490 %}
 6491 
 6492 // Load Double
 6493 instruct MoveVL2D(regD dst, vlRegD src) %{
 6494   match(Set dst src);
 6495   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6496   ins_encode %{
 6497     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6498   %}
 6499   ins_pipe( fpu_reg_reg );
 6500 %}
 6501 
 6502 // Store XMM register to memory (single-precision floating point)
 6503 // MOVSS instruction
 6504 instruct storeF(memory mem, regF src) %{
 6505   predicate(UseSSE&gt;=1);
 6506   match(Set mem (StoreF mem src));
 6507   ins_cost(95);
 6508   format %{ &quot;MOVSS  $mem,$src&quot; %}
 6509   ins_encode %{
 6510     __ movflt($mem$$Address, $src$$XMMRegister);
 6511   %}
 6512   ins_pipe( pipe_slow );
 6513 %}
 6514 
 6515 // Load Float
 6516 instruct MoveF2VL(vlRegF dst, regF src) %{
 6517   match(Set dst src);
 6518   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6519   ins_encode %{
 6520     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6521   %}
 6522   ins_pipe( fpu_reg_reg );
 6523 %}
 6524 
 6525 // Load Float
 6526 instruct MoveVL2F(regF dst, vlRegF src) %{
 6527   match(Set dst src);
 6528   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6529   ins_encode %{
 6530     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6531   %}
 6532   ins_pipe( fpu_reg_reg );
 6533 %}
 6534 
 6535 // Store Float
 6536 instruct storeFPR( memory mem, regFPR1 src) %{
 6537   predicate(UseSSE==0);
 6538   match(Set mem (StoreF mem src));
 6539 
 6540   ins_cost(100);
 6541   format %{ &quot;FST_S  $mem,$src&quot; %}
 6542   opcode(0xD9);       /* D9 /2 */
 6543   ins_encode( enc_FPR_store(mem,src) );
 6544   ins_pipe( fpu_mem_reg );
 6545 %}
 6546 
 6547 // Store Float does rounding on x86
 6548 instruct storeFPR_rounded( memory mem, regFPR1 src) %{
 6549   predicate(UseSSE==0);
 6550   match(Set mem (StoreF mem (RoundFloat src)));
 6551 
 6552   ins_cost(100);
 6553   format %{ &quot;FST_S  $mem,$src\t# round&quot; %}
 6554   opcode(0xD9);       /* D9 /2 */
 6555   ins_encode( enc_FPR_store(mem,src) );
 6556   ins_pipe( fpu_mem_reg );
 6557 %}
 6558 
 6559 // Store Float does rounding on x86
 6560 instruct storeFPR_Drounded( memory mem, regDPR1 src) %{
 6561   predicate(UseSSE&lt;=1);
 6562   match(Set mem (StoreF mem (ConvD2F src)));
 6563 
 6564   ins_cost(100);
 6565   format %{ &quot;FST_S  $mem,$src\t# D-round&quot; %}
 6566   opcode(0xD9);       /* D9 /2 */
 6567   ins_encode( enc_FPR_store(mem,src) );
 6568   ins_pipe( fpu_mem_reg );
 6569 %}
 6570 
 6571 // Store immediate Float value (it is faster than store from FPU register)
 6572 // The instruction usage is guarded by predicate in operand immFPR().
 6573 instruct storeFPR_imm( memory mem, immFPR src) %{
 6574   match(Set mem (StoreF mem src));
 6575 
 6576   ins_cost(50);
 6577   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6578   opcode(0xC7);               /* C7 /0 */
 6579   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits( src ));
 6580   ins_pipe( ialu_mem_imm );
 6581 %}
 6582 
 6583 // Store immediate Float value (it is faster than store from XMM register)
 6584 // The instruction usage is guarded by predicate in operand immF().
 6585 instruct storeF_imm( memory mem, immF src) %{
 6586   match(Set mem (StoreF mem src));
 6587 
 6588   ins_cost(50);
 6589   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6590   opcode(0xC7);               /* C7 /0 */
 6591   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits( src ));
 6592   ins_pipe( ialu_mem_imm );
 6593 %}
 6594 
 6595 // Store Integer to stack slot
 6596 instruct storeSSI(stackSlotI dst, rRegI src) %{
 6597   match(Set dst src);
 6598 
 6599   ins_cost(100);
 6600   format %{ &quot;MOV    $dst,$src&quot; %}
 6601   opcode(0x89);
 6602   ins_encode( OpcPRegSS( dst, src ) );
 6603   ins_pipe( ialu_mem_reg );
 6604 %}
 6605 
 6606 // Store Integer to stack slot
 6607 instruct storeSSP(stackSlotP dst, eRegP src) %{
 6608   match(Set dst src);
 6609 
 6610   ins_cost(100);
 6611   format %{ &quot;MOV    $dst,$src&quot; %}
 6612   opcode(0x89);
 6613   ins_encode( OpcPRegSS( dst, src ) );
 6614   ins_pipe( ialu_mem_reg );
 6615 %}
 6616 
 6617 // Store Long to stack slot
 6618 instruct storeSSL(stackSlotL dst, eRegL src) %{
 6619   match(Set dst src);
 6620 
 6621   ins_cost(200);
 6622   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6623             &quot;MOV    $dst+4,$src.hi&quot; %}
 6624   opcode(0x89, 0x89);
 6625   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
 6626   ins_pipe( ialu_mem_long_reg );
 6627 %}
 6628 
 6629 //----------MemBar Instructions-----------------------------------------------
 6630 // Memory barrier flavors
 6631 
 6632 instruct membar_acquire() %{
 6633   match(MemBarAcquire);
 6634   match(LoadFence);
 6635   ins_cost(400);
 6636 
 6637   size(0);
 6638   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6639   ins_encode();
 6640   ins_pipe(empty);
 6641 %}
 6642 
 6643 instruct membar_acquire_lock() %{
 6644   match(MemBarAcquireLock);
 6645   ins_cost(0);
 6646 
 6647   size(0);
 6648   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6649   ins_encode( );
 6650   ins_pipe(empty);
 6651 %}
 6652 
 6653 instruct membar_release() %{
 6654   match(MemBarRelease);
 6655   match(StoreFence);
 6656   ins_cost(400);
 6657 
 6658   size(0);
 6659   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6660   ins_encode( );
 6661   ins_pipe(empty);
 6662 %}
 6663 
 6664 instruct membar_release_lock() %{
 6665   match(MemBarReleaseLock);
 6666   ins_cost(0);
 6667 
 6668   size(0);
 6669   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6670   ins_encode( );
 6671   ins_pipe(empty);
 6672 %}
 6673 
 6674 instruct membar_volatile(eFlagsReg cr) %{
 6675   match(MemBarVolatile);
 6676   effect(KILL cr);
 6677   ins_cost(400);
 6678 
 6679   format %{
 6680     $$template
 6681     $$emit$$&quot;LOCK ADDL [ESP + #0], 0\t! membar_volatile&quot;
 6682   %}
 6683   ins_encode %{
 6684     __ membar(Assembler::StoreLoad);
 6685   %}
 6686   ins_pipe(pipe_slow);
 6687 %}
 6688 
 6689 instruct unnecessary_membar_volatile() %{
 6690   match(MemBarVolatile);
 6691   predicate(Matcher::post_store_load_barrier(n));
 6692   ins_cost(0);
 6693 
 6694   size(0);
 6695   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6696   ins_encode( );
 6697   ins_pipe(empty);
 6698 %}
 6699 
 6700 instruct membar_storestore() %{
 6701   match(MemBarStoreStore);
 6702   ins_cost(0);
 6703 
 6704   size(0);
 6705   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6706   ins_encode( );
 6707   ins_pipe(empty);
 6708 %}
 6709 
 6710 //----------Move Instructions--------------------------------------------------
 6711 instruct castX2P(eAXRegP dst, eAXRegI src) %{
 6712   match(Set dst (CastX2P src));
 6713   format %{ &quot;# X2P  $dst, $src&quot; %}
 6714   ins_encode( /*empty encoding*/ );
 6715   ins_cost(0);
 6716   ins_pipe(empty);
 6717 %}
 6718 
 6719 instruct castP2X(rRegI dst, eRegP src ) %{
 6720   match(Set dst (CastP2X src));
 6721   ins_cost(50);
 6722   format %{ &quot;MOV    $dst, $src\t# CastP2X&quot; %}
 6723   ins_encode( enc_Copy( dst, src) );
 6724   ins_pipe( ialu_reg_reg );
 6725 %}
 6726 
 6727 //----------Conditional Move---------------------------------------------------
 6728 // Conditional move
 6729 instruct jmovI_reg(cmpOp cop, eFlagsReg cr, rRegI dst, rRegI src) %{
 6730   predicate(!VM_Version::supports_cmov() );
 6731   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6732   ins_cost(200);
 6733   format %{ &quot;J$cop,us skip\t# signed cmove\n\t&quot;
 6734             &quot;MOV    $dst,$src\n&quot;
 6735       &quot;skip:&quot; %}
 6736   ins_encode %{
 6737     Label Lskip;
 6738     // Invert sense of branch from sense of CMOV
 6739     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6740     __ movl($dst$$Register, $src$$Register);
 6741     __ bind(Lskip);
 6742   %}
 6743   ins_pipe( pipe_cmov_reg );
 6744 %}
 6745 
 6746 instruct jmovI_regU(cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src) %{
 6747   predicate(!VM_Version::supports_cmov() );
 6748   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6749   ins_cost(200);
 6750   format %{ &quot;J$cop,us skip\t# unsigned cmove\n\t&quot;
 6751             &quot;MOV    $dst,$src\n&quot;
 6752       &quot;skip:&quot; %}
 6753   ins_encode %{
 6754     Label Lskip;
 6755     // Invert sense of branch from sense of CMOV
 6756     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6757     __ movl($dst$$Register, $src$$Register);
 6758     __ bind(Lskip);
 6759   %}
 6760   ins_pipe( pipe_cmov_reg );
 6761 %}
 6762 
 6763 instruct cmovI_reg(rRegI dst, rRegI src, eFlagsReg cr, cmpOp cop ) %{
 6764   predicate(VM_Version::supports_cmov() );
 6765   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6766   ins_cost(200);
 6767   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6768   opcode(0x0F,0x40);
 6769   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6770   ins_pipe( pipe_cmov_reg );
 6771 %}
 6772 
 6773 instruct cmovI_regU( cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src ) %{
 6774   predicate(VM_Version::supports_cmov() );
 6775   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6776   ins_cost(200);
 6777   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6778   opcode(0x0F,0x40);
 6779   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6780   ins_pipe( pipe_cmov_reg );
 6781 %}
 6782 
 6783 instruct cmovI_regUCF( cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, rRegI src ) %{
 6784   predicate(VM_Version::supports_cmov() );
 6785   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6786   ins_cost(200);
 6787   expand %{
 6788     cmovI_regU(cop, cr, dst, src);
 6789   %}
 6790 %}
 6791 
 6792 // Conditional move
 6793 instruct cmovI_mem(cmpOp cop, eFlagsReg cr, rRegI dst, memory src) %{
 6794   predicate(VM_Version::supports_cmov() );
 6795   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6796   ins_cost(250);
 6797   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6798   opcode(0x0F,0x40);
 6799   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6800   ins_pipe( pipe_cmov_mem );
 6801 %}
 6802 
 6803 // Conditional move
 6804 instruct cmovI_memU(cmpOpU cop, eFlagsRegU cr, rRegI dst, memory src) %{
 6805   predicate(VM_Version::supports_cmov() );
 6806   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6807   ins_cost(250);
 6808   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6809   opcode(0x0F,0x40);
 6810   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6811   ins_pipe( pipe_cmov_mem );
 6812 %}
 6813 
 6814 instruct cmovI_memUCF(cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, memory src) %{
 6815   predicate(VM_Version::supports_cmov() );
 6816   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6817   ins_cost(250);
 6818   expand %{
 6819     cmovI_memU(cop, cr, dst, src);
 6820   %}
 6821 %}
 6822 
 6823 // Conditional move
 6824 instruct cmovP_reg(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6825   predicate(VM_Version::supports_cmov() );
 6826   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6827   ins_cost(200);
 6828   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6829   opcode(0x0F,0x40);
 6830   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6831   ins_pipe( pipe_cmov_reg );
 6832 %}
 6833 
 6834 // Conditional move (non-P6 version)
 6835 // Note:  a CMoveP is generated for  stubs and native wrappers
 6836 //        regardless of whether we are on a P6, so we
 6837 //        emulate a cmov here
 6838 instruct cmovP_reg_nonP6(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6839   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6840   ins_cost(300);
 6841   format %{ &quot;Jn$cop   skip\n\t&quot;
 6842           &quot;MOV    $dst,$src\t# pointer\n&quot;
 6843       &quot;skip:&quot; %}
 6844   opcode(0x8b);
 6845   ins_encode( enc_cmov_branch(cop, 0x2), OpcP, RegReg(dst, src));
 6846   ins_pipe( pipe_cmov_reg );
 6847 %}
 6848 
 6849 // Conditional move
 6850 instruct cmovP_regU(cmpOpU cop, eFlagsRegU cr, eRegP dst, eRegP src ) %{
 6851   predicate(VM_Version::supports_cmov() );
 6852   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6853   ins_cost(200);
 6854   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6855   opcode(0x0F,0x40);
 6856   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6857   ins_pipe( pipe_cmov_reg );
 6858 %}
 6859 
 6860 instruct cmovP_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegP dst, eRegP src ) %{
 6861   predicate(VM_Version::supports_cmov() );
 6862   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6863   ins_cost(200);
 6864   expand %{
 6865     cmovP_regU(cop, cr, dst, src);
 6866   %}
 6867 %}
 6868 
 6869 // DISABLED: Requires the ADLC to emit a bottom_type call that
 6870 // correctly meets the two pointer arguments; one is an incoming
 6871 // register but the other is a memory operand.  ALSO appears to
 6872 // be buggy with implicit null checks.
 6873 //
 6874 //// Conditional move
 6875 //instruct cmovP_mem(cmpOp cop, eFlagsReg cr, eRegP dst, memory src) %{
 6876 //  predicate(VM_Version::supports_cmov() );
 6877 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6878 //  ins_cost(250);
 6879 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6880 //  opcode(0x0F,0x40);
 6881 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6882 //  ins_pipe( pipe_cmov_mem );
 6883 //%}
 6884 //
 6885 //// Conditional move
 6886 //instruct cmovP_memU(cmpOpU cop, eFlagsRegU cr, eRegP dst, memory src) %{
 6887 //  predicate(VM_Version::supports_cmov() );
 6888 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6889 //  ins_cost(250);
 6890 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6891 //  opcode(0x0F,0x40);
 6892 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6893 //  ins_pipe( pipe_cmov_mem );
 6894 //%}
 6895 
 6896 // Conditional move
 6897 instruct fcmovDPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regDPR1 dst, regDPR src) %{
 6898   predicate(UseSSE&lt;=1);
 6899   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6900   ins_cost(200);
 6901   format %{ &quot;FCMOV$cop $dst,$src\t# double&quot; %}
 6902   opcode(0xDA);
 6903   ins_encode( enc_cmov_dpr(cop,src) );
 6904   ins_pipe( pipe_cmovDPR_reg );
 6905 %}
 6906 
 6907 // Conditional move
 6908 instruct fcmovFPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regFPR1 dst, regFPR src) %{
 6909   predicate(UseSSE==0);
 6910   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6911   ins_cost(200);
 6912   format %{ &quot;FCMOV$cop $dst,$src\t# float&quot; %}
 6913   opcode(0xDA);
 6914   ins_encode( enc_cmov_dpr(cop,src) );
 6915   ins_pipe( pipe_cmovDPR_reg );
 6916 %}
 6917 
 6918 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6919 instruct fcmovDPR_regS(cmpOp cop, eFlagsReg cr, regDPR dst, regDPR src) %{
 6920   predicate(UseSSE&lt;=1);
 6921   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6922   ins_cost(200);
 6923   format %{ &quot;Jn$cop   skip\n\t&quot;
 6924             &quot;MOV    $dst,$src\t# double\n&quot;
 6925       &quot;skip:&quot; %}
 6926   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6927   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_DPR(src), OpcP, RegOpc(dst) );
 6928   ins_pipe( pipe_cmovDPR_reg );
 6929 %}
 6930 
 6931 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6932 instruct fcmovFPR_regS(cmpOp cop, eFlagsReg cr, regFPR dst, regFPR src) %{
 6933   predicate(UseSSE==0);
 6934   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6935   ins_cost(200);
 6936   format %{ &quot;Jn$cop    skip\n\t&quot;
 6937             &quot;MOV    $dst,$src\t# float\n&quot;
 6938       &quot;skip:&quot; %}
 6939   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6940   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_FPR(src), OpcP, RegOpc(dst) );
 6941   ins_pipe( pipe_cmovDPR_reg );
 6942 %}
 6943 
 6944 // No CMOVE with SSE/SSE2
 6945 instruct fcmovF_regS(cmpOp cop, eFlagsReg cr, regF dst, regF src) %{
 6946   predicate (UseSSE&gt;=1);
 6947   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6948   ins_cost(200);
 6949   format %{ &quot;Jn$cop   skip\n\t&quot;
 6950             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6951       &quot;skip:&quot; %}
 6952   ins_encode %{
 6953     Label skip;
 6954     // Invert sense of branch from sense of CMOV
 6955     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6956     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6957     __ bind(skip);
 6958   %}
 6959   ins_pipe( pipe_slow );
 6960 %}
 6961 
 6962 // No CMOVE with SSE/SSE2
 6963 instruct fcmovD_regS(cmpOp cop, eFlagsReg cr, regD dst, regD src) %{
 6964   predicate (UseSSE&gt;=2);
 6965   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6966   ins_cost(200);
 6967   format %{ &quot;Jn$cop   skip\n\t&quot;
 6968             &quot;MOVSD  $dst,$src\t# float\n&quot;
 6969       &quot;skip:&quot; %}
 6970   ins_encode %{
 6971     Label skip;
 6972     // Invert sense of branch from sense of CMOV
 6973     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6974     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6975     __ bind(skip);
 6976   %}
 6977   ins_pipe( pipe_slow );
 6978 %}
 6979 
 6980 // unsigned version
 6981 instruct fcmovF_regU(cmpOpU cop, eFlagsRegU cr, regF dst, regF src) %{
 6982   predicate (UseSSE&gt;=1);
 6983   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6984   ins_cost(200);
 6985   format %{ &quot;Jn$cop   skip\n\t&quot;
 6986             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6987       &quot;skip:&quot; %}
 6988   ins_encode %{
 6989     Label skip;
 6990     // Invert sense of branch from sense of CMOV
 6991     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6992     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6993     __ bind(skip);
 6994   %}
 6995   ins_pipe( pipe_slow );
 6996 %}
 6997 
 6998 instruct fcmovF_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regF dst, regF src) %{
 6999   predicate (UseSSE&gt;=1);
 7000   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7001   ins_cost(200);
 7002   expand %{
 7003     fcmovF_regU(cop, cr, dst, src);
 7004   %}
 7005 %}
 7006 
 7007 // unsigned version
 7008 instruct fcmovD_regU(cmpOpU cop, eFlagsRegU cr, regD dst, regD src) %{
 7009   predicate (UseSSE&gt;=2);
 7010   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7011   ins_cost(200);
 7012   format %{ &quot;Jn$cop   skip\n\t&quot;
 7013             &quot;MOVSD  $dst,$src\t# float\n&quot;
 7014       &quot;skip:&quot; %}
 7015   ins_encode %{
 7016     Label skip;
 7017     // Invert sense of branch from sense of CMOV
 7018     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7019     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7020     __ bind(skip);
 7021   %}
 7022   ins_pipe( pipe_slow );
 7023 %}
 7024 
 7025 instruct fcmovD_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regD dst, regD src) %{
 7026   predicate (UseSSE&gt;=2);
 7027   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7028   ins_cost(200);
 7029   expand %{
 7030     fcmovD_regU(cop, cr, dst, src);
 7031   %}
 7032 %}
 7033 
 7034 instruct cmovL_reg(cmpOp cop, eFlagsReg cr, eRegL dst, eRegL src) %{
 7035   predicate(VM_Version::supports_cmov() );
 7036   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7037   ins_cost(200);
 7038   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7039             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7040   opcode(0x0F,0x40);
 7041   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7042   ins_pipe( pipe_cmov_reg_long );
 7043 %}
 7044 
 7045 instruct cmovL_regU(cmpOpU cop, eFlagsRegU cr, eRegL dst, eRegL src) %{
 7046   predicate(VM_Version::supports_cmov() );
 7047   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7048   ins_cost(200);
 7049   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7050             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7051   opcode(0x0F,0x40);
 7052   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7053   ins_pipe( pipe_cmov_reg_long );
 7054 %}
 7055 
 7056 instruct cmovL_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegL dst, eRegL src) %{
 7057   predicate(VM_Version::supports_cmov() );
 7058   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7059   ins_cost(200);
 7060   expand %{
 7061     cmovL_regU(cop, cr, dst, src);
 7062   %}
 7063 %}
 7064 
 7065 //----------Arithmetic Instructions--------------------------------------------
 7066 //----------Addition Instructions----------------------------------------------
 7067 
 7068 // Integer Addition Instructions
 7069 instruct addI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7070   match(Set dst (AddI dst src));
 7071   effect(KILL cr);
 7072 
 7073   size(2);
 7074   format %{ &quot;ADD    $dst,$src&quot; %}
 7075   opcode(0x03);
 7076   ins_encode( OpcP, RegReg( dst, src) );
 7077   ins_pipe( ialu_reg_reg );
 7078 %}
 7079 
 7080 instruct addI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7081   match(Set dst (AddI dst src));
 7082   effect(KILL cr);
 7083 
 7084   format %{ &quot;ADD    $dst,$src&quot; %}
 7085   opcode(0x81, 0x00); /* /0 id */
 7086   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7087   ins_pipe( ialu_reg );
 7088 %}
 7089 
 7090 instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
 7091   predicate(UseIncDec);
 7092   match(Set dst (AddI dst src));
 7093   effect(KILL cr);
 7094 
 7095   size(1);
 7096   format %{ &quot;INC    $dst&quot; %}
 7097   opcode(0x40); /*  */
 7098   ins_encode( Opc_plus( primary, dst ) );
 7099   ins_pipe( ialu_reg );
 7100 %}
 7101 
 7102 instruct leaI_eReg_immI(rRegI dst, rRegI src0, immI src1) %{
 7103   match(Set dst (AddI src0 src1));
 7104   ins_cost(110);
 7105 
 7106   format %{ &quot;LEA    $dst,[$src0 + $src1]&quot; %}
 7107   opcode(0x8D); /* 0x8D /r */
 7108   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7109   ins_pipe( ialu_reg_reg );
 7110 %}
 7111 
 7112 instruct leaP_eReg_immI(eRegP dst, eRegP src0, immI src1) %{
 7113   match(Set dst (AddP src0 src1));
 7114   ins_cost(110);
 7115 
 7116   format %{ &quot;LEA    $dst,[$src0 + $src1]\t# ptr&quot; %}
 7117   opcode(0x8D); /* 0x8D /r */
 7118   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7119   ins_pipe( ialu_reg_reg );
 7120 %}
 7121 
 7122 instruct decI_eReg(rRegI dst, immI_M1 src, eFlagsReg cr) %{
 7123   predicate(UseIncDec);
 7124   match(Set dst (AddI dst src));
 7125   effect(KILL cr);
 7126 
 7127   size(1);
 7128   format %{ &quot;DEC    $dst&quot; %}
 7129   opcode(0x48); /*  */
 7130   ins_encode( Opc_plus( primary, dst ) );
 7131   ins_pipe( ialu_reg );
 7132 %}
 7133 
 7134 instruct addP_eReg(eRegP dst, rRegI src, eFlagsReg cr) %{
 7135   match(Set dst (AddP dst src));
 7136   effect(KILL cr);
 7137 
 7138   size(2);
 7139   format %{ &quot;ADD    $dst,$src&quot; %}
 7140   opcode(0x03);
 7141   ins_encode( OpcP, RegReg( dst, src) );
 7142   ins_pipe( ialu_reg_reg );
 7143 %}
 7144 
 7145 instruct addP_eReg_imm(eRegP dst, immI src, eFlagsReg cr) %{
 7146   match(Set dst (AddP dst src));
 7147   effect(KILL cr);
 7148 
 7149   format %{ &quot;ADD    $dst,$src&quot; %}
 7150   opcode(0x81,0x00); /* Opcode 81 /0 id */
 7151   // ins_encode( RegImm( dst, src) );
 7152   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7153   ins_pipe( ialu_reg );
 7154 %}
 7155 
 7156 instruct addI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7157   match(Set dst (AddI dst (LoadI src)));
 7158   effect(KILL cr);
 7159 
 7160   ins_cost(125);
 7161   format %{ &quot;ADD    $dst,$src&quot; %}
 7162   opcode(0x03);
 7163   ins_encode( OpcP, RegMem( dst, src) );
 7164   ins_pipe( ialu_reg_mem );
 7165 %}
 7166 
 7167 instruct addI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7168   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7169   effect(KILL cr);
 7170 
 7171   ins_cost(150);
 7172   format %{ &quot;ADD    $dst,$src&quot; %}
 7173   opcode(0x01);  /* Opcode 01 /r */
 7174   ins_encode( OpcP, RegMem( src, dst ) );
 7175   ins_pipe( ialu_mem_reg );
 7176 %}
 7177 
 7178 // Add Memory with Immediate
 7179 instruct addI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 7180   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7181   effect(KILL cr);
 7182 
 7183   ins_cost(125);
 7184   format %{ &quot;ADD    $dst,$src&quot; %}
 7185   opcode(0x81);               /* Opcode 81 /0 id */
 7186   ins_encode( OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32( src ) );
 7187   ins_pipe( ialu_mem_imm );
 7188 %}
 7189 
 7190 instruct incI_mem(memory dst, immI1 src, eFlagsReg cr) %{
 7191   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7192   effect(KILL cr);
 7193 
 7194   ins_cost(125);
 7195   format %{ &quot;INC    $dst&quot; %}
 7196   opcode(0xFF);               /* Opcode FF /0 */
 7197   ins_encode( OpcP, RMopc_Mem(0x00,dst));
 7198   ins_pipe( ialu_mem_imm );
 7199 %}
 7200 
 7201 instruct decI_mem(memory dst, immI_M1 src, eFlagsReg cr) %{
 7202   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7203   effect(KILL cr);
 7204 
 7205   ins_cost(125);
 7206   format %{ &quot;DEC    $dst&quot; %}
 7207   opcode(0xFF);               /* Opcode FF /1 */
 7208   ins_encode( OpcP, RMopc_Mem(0x01,dst));
 7209   ins_pipe( ialu_mem_imm );
 7210 %}
 7211 
 7212 
 7213 instruct checkCastPP( eRegP dst ) %{
 7214   match(Set dst (CheckCastPP dst));
 7215 
 7216   size(0);
 7217   format %{ &quot;#checkcastPP of $dst&quot; %}
 7218   ins_encode( /*empty encoding*/ );
 7219   ins_pipe( empty );
 7220 %}
 7221 
 7222 instruct castPP( eRegP dst ) %{
 7223   match(Set dst (CastPP dst));
 7224   format %{ &quot;#castPP of $dst&quot; %}
 7225   ins_encode( /*empty encoding*/ );
 7226   ins_pipe( empty );
 7227 %}
 7228 
 7229 instruct castII( rRegI dst ) %{
 7230   match(Set dst (CastII dst));
 7231   format %{ &quot;#castII of $dst&quot; %}
 7232   ins_encode( /*empty encoding*/ );
 7233   ins_cost(0);
 7234   ins_pipe( empty );
 7235 %}
 7236 
<a name="1" id="anc1"></a><span class="line-removed"> 7237 instruct castLL( eRegL dst ) %{</span>
<span class="line-removed"> 7238   match(Set dst (CastLL dst));</span>
<span class="line-removed"> 7239   format %{ &quot;#castLL of $dst&quot; %}</span>
<span class="line-removed"> 7240   ins_encode( /*empty encoding*/ );</span>
<span class="line-removed"> 7241   ins_cost(0);</span>
<span class="line-removed"> 7242   ins_pipe( empty );</span>
<span class="line-removed"> 7243 %}</span>
<span class="line-removed"> 7244 </span>
<span class="line-removed"> 7245 </span>
 7246 // Load-locked - same as a regular pointer load when used with compare-swap
 7247 instruct loadPLocked(eRegP dst, memory mem) %{
 7248   match(Set dst (LoadPLocked mem));
 7249 
 7250   ins_cost(125);
 7251   format %{ &quot;MOV    $dst,$mem\t# Load ptr. locked&quot; %}
 7252   opcode(0x8B);
 7253   ins_encode( OpcP, RegMem(dst,mem));
 7254   ins_pipe( ialu_reg_mem );
 7255 %}
 7256 
 7257 // Conditional-store of the updated heap-top.
 7258 // Used during allocation of the shared heap.
 7259 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7260 instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{
 7261   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7262   // EAX is killed if there is contention, but then it&#39;s also unused.
 7263   // In the common case of no contention, EAX holds the new oop address.
 7264   format %{ &quot;CMPXCHG $heap_top_ptr,$newval\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr&quot; %}
 7265   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval,heap_top_ptr) );
 7266   ins_pipe( pipe_cmpxchg );
 7267 %}
 7268 
 7269 // Conditional-store of an int value.
 7270 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG on Intel.
 7271 instruct storeIConditional( memory mem, eAXRegI oldval, rRegI newval, eFlagsReg cr ) %{
 7272   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7273   effect(KILL oldval);
 7274   format %{ &quot;CMPXCHG $mem,$newval\t# If EAX==$mem Then store $newval into $mem&quot; %}
 7275   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval, mem) );
 7276   ins_pipe( pipe_cmpxchg );
 7277 %}
 7278 
 7279 // Conditional-store of a long value.
 7280 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG8 on Intel.
 7281 instruct storeLConditional( memory mem, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7282   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7283   effect(KILL oldval);
 7284   format %{ &quot;XCHG   EBX,ECX\t# correct order for CMPXCHG8 instruction\n\t&quot;
 7285             &quot;CMPXCHG8 $mem,ECX:EBX\t# If EDX:EAX==$mem Then store ECX:EBX into $mem\n\t&quot;
 7286             &quot;XCHG   EBX,ECX&quot;
 7287   %}
 7288   ins_encode %{
 7289     // Note: we need to swap rbx, and rcx before and after the
 7290     //       cmpxchg8 instruction because the instruction uses
 7291     //       rcx as the high order word of the new value to store but
 7292     //       our register encoding uses rbx.
 7293     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7294     __ lock();
 7295     __ cmpxchg8($mem$$Address);
 7296     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7297   %}
 7298   ins_pipe( pipe_cmpxchg );
 7299 %}
 7300 
 7301 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7302 
 7303 instruct compareAndSwapL( rRegI res, eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7304   predicate(VM_Version::supports_cx8());
 7305   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7306   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7307   effect(KILL cr, KILL oldval);
 7308   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7309             &quot;MOV    $res,0\n\t&quot;
 7310             &quot;JNE,s  fail\n\t&quot;
 7311             &quot;MOV    $res,1\n&quot;
 7312           &quot;fail:&quot; %}
 7313   ins_encode( enc_cmpxchg8(mem_ptr),
 7314               enc_flags_ne_to_boolean(res) );
 7315   ins_pipe( pipe_cmpxchg );
 7316 %}
 7317 
 7318 instruct compareAndSwapP( rRegI res,  pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7319   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7320   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7321   effect(KILL cr, KILL oldval);
 7322   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7323             &quot;MOV    $res,0\n\t&quot;
 7324             &quot;JNE,s  fail\n\t&quot;
 7325             &quot;MOV    $res,1\n&quot;
 7326           &quot;fail:&quot; %}
 7327   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7328   ins_pipe( pipe_cmpxchg );
 7329 %}
 7330 
 7331 instruct compareAndSwapB( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7332   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7333   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7334   effect(KILL cr, KILL oldval);
 7335   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7336             &quot;MOV    $res,0\n\t&quot;
 7337             &quot;JNE,s  fail\n\t&quot;
 7338             &quot;MOV    $res,1\n&quot;
 7339           &quot;fail:&quot; %}
 7340   ins_encode( enc_cmpxchgb(mem_ptr),
 7341               enc_flags_ne_to_boolean(res) );
 7342   ins_pipe( pipe_cmpxchg );
 7343 %}
 7344 
 7345 instruct compareAndSwapS( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7346   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7347   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7348   effect(KILL cr, KILL oldval);
 7349   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7350             &quot;MOV    $res,0\n\t&quot;
 7351             &quot;JNE,s  fail\n\t&quot;
 7352             &quot;MOV    $res,1\n&quot;
 7353           &quot;fail:&quot; %}
 7354   ins_encode( enc_cmpxchgw(mem_ptr),
 7355               enc_flags_ne_to_boolean(res) );
 7356   ins_pipe( pipe_cmpxchg );
 7357 %}
 7358 
 7359 instruct compareAndSwapI( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7360   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7361   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7362   effect(KILL cr, KILL oldval);
 7363   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7364             &quot;MOV    $res,0\n\t&quot;
 7365             &quot;JNE,s  fail\n\t&quot;
 7366             &quot;MOV    $res,1\n&quot;
 7367           &quot;fail:&quot; %}
 7368   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7369   ins_pipe( pipe_cmpxchg );
 7370 %}
 7371 
 7372 instruct compareAndExchangeL( eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7373   predicate(VM_Version::supports_cx8());
 7374   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7375   effect(KILL cr);
 7376   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7377   ins_encode( enc_cmpxchg8(mem_ptr) );
 7378   ins_pipe( pipe_cmpxchg );
 7379 %}
 7380 
 7381 instruct compareAndExchangeP( pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7382   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7383   effect(KILL cr);
 7384   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7385   ins_encode( enc_cmpxchg(mem_ptr) );
 7386   ins_pipe( pipe_cmpxchg );
 7387 %}
 7388 
 7389 instruct compareAndExchangeB( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7390   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7391   effect(KILL cr);
 7392   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7393   ins_encode( enc_cmpxchgb(mem_ptr) );
 7394   ins_pipe( pipe_cmpxchg );
 7395 %}
 7396 
 7397 instruct compareAndExchangeS( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7398   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7399   effect(KILL cr);
 7400   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7401   ins_encode( enc_cmpxchgw(mem_ptr) );
 7402   ins_pipe( pipe_cmpxchg );
 7403 %}
 7404 
 7405 instruct compareAndExchangeI( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7406   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7407   effect(KILL cr);
 7408   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7409   ins_encode( enc_cmpxchg(mem_ptr) );
 7410   ins_pipe( pipe_cmpxchg );
 7411 %}
 7412 
 7413 instruct xaddB_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7414   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7415   match(Set dummy (GetAndAddB mem add));
 7416   effect(KILL cr);
 7417   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7418   ins_encode %{
 7419     __ lock();
 7420     __ addb($mem$$Address, $add$$constant);
 7421   %}
 7422   ins_pipe( pipe_cmpxchg );
 7423 %}
 7424 
 7425 // Important to match to xRegI: only 8-bit regs.
 7426 instruct xaddB( memory mem, xRegI newval, eFlagsReg cr) %{
 7427   match(Set newval (GetAndAddB mem newval));
 7428   effect(KILL cr);
 7429   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7430   ins_encode %{
 7431     __ lock();
 7432     __ xaddb($mem$$Address, $newval$$Register);
 7433   %}
 7434   ins_pipe( pipe_cmpxchg );
 7435 %}
 7436 
 7437 instruct xaddS_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7438   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7439   match(Set dummy (GetAndAddS mem add));
 7440   effect(KILL cr);
 7441   format %{ &quot;ADDS  [$mem],$add&quot; %}
 7442   ins_encode %{
 7443     __ lock();
 7444     __ addw($mem$$Address, $add$$constant);
 7445   %}
 7446   ins_pipe( pipe_cmpxchg );
 7447 %}
 7448 
 7449 instruct xaddS( memory mem, rRegI newval, eFlagsReg cr) %{
 7450   match(Set newval (GetAndAddS mem newval));
 7451   effect(KILL cr);
 7452   format %{ &quot;XADDS  [$mem],$newval&quot; %}
 7453   ins_encode %{
 7454     __ lock();
 7455     __ xaddw($mem$$Address, $newval$$Register);
 7456   %}
 7457   ins_pipe( pipe_cmpxchg );
 7458 %}
 7459 
 7460 instruct xaddI_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7461   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7462   match(Set dummy (GetAndAddI mem add));
 7463   effect(KILL cr);
 7464   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7465   ins_encode %{
 7466     __ lock();
 7467     __ addl($mem$$Address, $add$$constant);
 7468   %}
 7469   ins_pipe( pipe_cmpxchg );
 7470 %}
 7471 
 7472 instruct xaddI( memory mem, rRegI newval, eFlagsReg cr) %{
 7473   match(Set newval (GetAndAddI mem newval));
 7474   effect(KILL cr);
 7475   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7476   ins_encode %{
 7477     __ lock();
 7478     __ xaddl($mem$$Address, $newval$$Register);
 7479   %}
 7480   ins_pipe( pipe_cmpxchg );
 7481 %}
 7482 
 7483 // Important to match to xRegI: only 8-bit regs.
 7484 instruct xchgB( memory mem, xRegI newval) %{
 7485   match(Set newval (GetAndSetB mem newval));
 7486   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7487   ins_encode %{
 7488     __ xchgb($newval$$Register, $mem$$Address);
 7489   %}
 7490   ins_pipe( pipe_cmpxchg );
 7491 %}
 7492 
 7493 instruct xchgS( memory mem, rRegI newval) %{
 7494   match(Set newval (GetAndSetS mem newval));
 7495   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7496   ins_encode %{
 7497     __ xchgw($newval$$Register, $mem$$Address);
 7498   %}
 7499   ins_pipe( pipe_cmpxchg );
 7500 %}
 7501 
 7502 instruct xchgI( memory mem, rRegI newval) %{
 7503   match(Set newval (GetAndSetI mem newval));
 7504   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7505   ins_encode %{
 7506     __ xchgl($newval$$Register, $mem$$Address);
 7507   %}
 7508   ins_pipe( pipe_cmpxchg );
 7509 %}
 7510 
 7511 instruct xchgP( memory mem, pRegP newval) %{
 7512   match(Set newval (GetAndSetP mem newval));
 7513   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7514   ins_encode %{
 7515     __ xchgl($newval$$Register, $mem$$Address);
 7516   %}
 7517   ins_pipe( pipe_cmpxchg );
 7518 %}
 7519 
 7520 //----------Subtraction Instructions-------------------------------------------
 7521 
 7522 // Integer Subtraction Instructions
 7523 instruct subI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7524   match(Set dst (SubI dst src));
 7525   effect(KILL cr);
 7526 
 7527   size(2);
 7528   format %{ &quot;SUB    $dst,$src&quot; %}
 7529   opcode(0x2B);
 7530   ins_encode( OpcP, RegReg( dst, src) );
 7531   ins_pipe( ialu_reg_reg );
 7532 %}
 7533 
 7534 instruct subI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7535   match(Set dst (SubI dst src));
 7536   effect(KILL cr);
 7537 
 7538   format %{ &quot;SUB    $dst,$src&quot; %}
 7539   opcode(0x81,0x05);  /* Opcode 81 /5 */
 7540   // ins_encode( RegImm( dst, src) );
 7541   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7542   ins_pipe( ialu_reg );
 7543 %}
 7544 
 7545 instruct subI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7546   match(Set dst (SubI dst (LoadI src)));
 7547   effect(KILL cr);
 7548 
 7549   ins_cost(125);
 7550   format %{ &quot;SUB    $dst,$src&quot; %}
 7551   opcode(0x2B);
 7552   ins_encode( OpcP, RegMem( dst, src) );
 7553   ins_pipe( ialu_reg_mem );
 7554 %}
 7555 
 7556 instruct subI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7557   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 7558   effect(KILL cr);
 7559 
 7560   ins_cost(150);
 7561   format %{ &quot;SUB    $dst,$src&quot; %}
 7562   opcode(0x29);  /* Opcode 29 /r */
 7563   ins_encode( OpcP, RegMem( src, dst ) );
 7564   ins_pipe( ialu_mem_reg );
 7565 %}
 7566 
 7567 // Subtract from a pointer
 7568 instruct subP_eReg(eRegP dst, rRegI src, immI0 zero, eFlagsReg cr) %{
 7569   match(Set dst (AddP dst (SubI zero src)));
 7570   effect(KILL cr);
 7571 
 7572   size(2);
 7573   format %{ &quot;SUB    $dst,$src&quot; %}
 7574   opcode(0x2B);
 7575   ins_encode( OpcP, RegReg( dst, src) );
 7576   ins_pipe( ialu_reg_reg );
 7577 %}
 7578 
 7579 instruct negI_eReg(rRegI dst, immI0 zero, eFlagsReg cr) %{
 7580   match(Set dst (SubI zero dst));
 7581   effect(KILL cr);
 7582 
 7583   size(2);
 7584   format %{ &quot;NEG    $dst&quot; %}
 7585   opcode(0xF7,0x03);  // Opcode F7 /3
 7586   ins_encode( OpcP, RegOpc( dst ) );
 7587   ins_pipe( ialu_reg );
 7588 %}
 7589 
 7590 //----------Multiplication/Division Instructions-------------------------------
 7591 // Integer Multiplication Instructions
 7592 // Multiply Register
 7593 instruct mulI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7594   match(Set dst (MulI dst src));
 7595   effect(KILL cr);
 7596 
 7597   size(3);
 7598   ins_cost(300);
 7599   format %{ &quot;IMUL   $dst,$src&quot; %}
 7600   opcode(0xAF, 0x0F);
 7601   ins_encode( OpcS, OpcP, RegReg( dst, src) );
 7602   ins_pipe( ialu_reg_reg_alu0 );
 7603 %}
 7604 
 7605 // Multiply 32-bit Immediate
 7606 instruct mulI_eReg_imm(rRegI dst, rRegI src, immI imm, eFlagsReg cr) %{
 7607   match(Set dst (MulI src imm));
 7608   effect(KILL cr);
 7609 
 7610   ins_cost(300);
 7611   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7612   opcode(0x69);  /* 69 /r id */
 7613   ins_encode( OpcSE(imm), RegReg( dst, src ), Con8or32( imm ) );
 7614   ins_pipe( ialu_reg_reg_alu0 );
 7615 %}
 7616 
 7617 instruct loadConL_low_only(eADXRegL_low_only dst, immL32 src, eFlagsReg cr) %{
 7618   match(Set dst src);
 7619   effect(KILL cr);
 7620 
 7621   // Note that this is artificially increased to make it more expensive than loadConL
 7622   ins_cost(250);
 7623   format %{ &quot;MOV    EAX,$src\t// low word only&quot; %}
 7624   opcode(0xB8);
 7625   ins_encode( LdImmL_Lo(dst, src) );
 7626   ins_pipe( ialu_reg_fat );
 7627 %}
 7628 
 7629 // Multiply by 32-bit Immediate, taking the shifted high order results
 7630 //  (special case for shift by 32)
 7631 instruct mulI_imm_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32 cnt, eFlagsReg cr) %{
 7632   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7633   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7634              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7635              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7636   effect(USE src1, KILL cr);
 7637 
 7638   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7639   ins_cost(0*100 + 1*400 - 150);
 7640   format %{ &quot;IMUL   EDX:EAX,$src1&quot; %}
 7641   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7642   ins_pipe( pipe_slow );
 7643 %}
 7644 
 7645 // Multiply by 32-bit Immediate, taking the shifted high order results
 7646 instruct mulI_imm_RShift_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr) %{
 7647   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7648   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7649              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7650              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7651   effect(USE src1, KILL cr);
 7652 
 7653   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7654   ins_cost(1*100 + 1*400 - 150);
 7655   format %{ &quot;IMUL   EDX:EAX,$src1\n\t&quot;
 7656             &quot;SAR    EDX,$cnt-32&quot; %}
 7657   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7658   ins_pipe( pipe_slow );
 7659 %}
 7660 
 7661 // Multiply Memory 32-bit Immediate
 7662 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, eFlagsReg cr) %{
 7663   match(Set dst (MulI (LoadI src) imm));
 7664   effect(KILL cr);
 7665 
 7666   ins_cost(300);
 7667   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7668   opcode(0x69);  /* 69 /r id */
 7669   ins_encode( OpcSE(imm), RegMem( dst, src ), Con8or32( imm ) );
 7670   ins_pipe( ialu_reg_mem_alu0 );
 7671 %}
 7672 
 7673 // Multiply Memory
 7674 instruct mulI(rRegI dst, memory src, eFlagsReg cr) %{
 7675   match(Set dst (MulI dst (LoadI src)));
 7676   effect(KILL cr);
 7677 
 7678   ins_cost(350);
 7679   format %{ &quot;IMUL   $dst,$src&quot; %}
 7680   opcode(0xAF, 0x0F);
 7681   ins_encode( OpcS, OpcP, RegMem( dst, src) );
 7682   ins_pipe( ialu_reg_mem_alu0 );
 7683 %}
 7684 
 7685 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, eFlagsReg cr)
 7686 %{
 7687   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 7688   effect(KILL cr, KILL src2);
 7689 
 7690   expand %{ mulI_eReg(dst, src1, cr);
 7691            mulI_eReg(src2, src3, cr);
 7692            addI_eReg(dst, src2, cr); %}
 7693 %}
 7694 
 7695 // Multiply Register Int to Long
 7696 instruct mulI2L(eADXRegL dst, eAXRegI src, nadxRegI src1, eFlagsReg flags) %{
 7697   // Basic Idea: long = (long)int * (long)int
 7698   match(Set dst (MulL (ConvI2L src) (ConvI2L src1)));
 7699   effect(DEF dst, USE src, USE src1, KILL flags);
 7700 
 7701   ins_cost(300);
 7702   format %{ &quot;IMUL   $dst,$src1&quot; %}
 7703 
 7704   ins_encode( long_int_multiply( dst, src1 ) );
 7705   ins_pipe( ialu_reg_reg_alu0 );
 7706 %}
 7707 
 7708 instruct mulIS_eReg(eADXRegL dst, immL_32bits mask, eFlagsReg flags, eAXRegI src, nadxRegI src1) %{
 7709   // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 7710   match(Set dst (MulL (AndL (ConvI2L src) mask) (AndL (ConvI2L src1) mask)));
 7711   effect(KILL flags);
 7712 
 7713   ins_cost(300);
 7714   format %{ &quot;MUL    $dst,$src1&quot; %}
 7715 
 7716   ins_encode( long_uint_multiply(dst, src1) );
 7717   ins_pipe( ialu_reg_reg_alu0 );
 7718 %}
 7719 
 7720 // Multiply Register Long
 7721 instruct mulL_eReg(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7722   match(Set dst (MulL dst src));
 7723   effect(KILL cr, TEMP tmp);
 7724   ins_cost(4*100+3*400);
 7725 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7726 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 7727   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7728             &quot;IMUL   $tmp,EDX\n\t&quot;
 7729             &quot;MOV    EDX,$src.hi\n\t&quot;
 7730             &quot;IMUL   EDX,EAX\n\t&quot;
 7731             &quot;ADD    $tmp,EDX\n\t&quot;
 7732             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7733             &quot;ADD    EDX,$tmp&quot; %}
 7734   ins_encode( long_multiply( dst, src, tmp ) );
 7735   ins_pipe( pipe_slow );
 7736 %}
 7737 
 7738 // Multiply Register Long where the left operand&#39;s high 32 bits are zero
 7739 instruct mulL_eReg_lhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7740   predicate(is_operand_hi32_zero(n-&gt;in(1)));
 7741   match(Set dst (MulL dst src));
 7742   effect(KILL cr, TEMP tmp);
 7743   ins_cost(2*100+2*400);
 7744 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7745 //             hi(result) = hi(x_lo * y_lo) + lo(x_lo * y_hi) where lo(x_hi * y_lo) = 0 because x_hi = 0
 7746   format %{ &quot;MOV    $tmp,$src.hi\n\t&quot;
 7747             &quot;IMUL   $tmp,EAX\n\t&quot;
 7748             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7749             &quot;ADD    EDX,$tmp&quot; %}
 7750   ins_encode %{
 7751     __ movl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 7752     __ imull($tmp$$Register, rax);
 7753     __ mull($src$$Register);
 7754     __ addl(rdx, $tmp$$Register);
 7755   %}
 7756   ins_pipe( pipe_slow );
 7757 %}
 7758 
 7759 // Multiply Register Long where the right operand&#39;s high 32 bits are zero
 7760 instruct mulL_eReg_rhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7761   predicate(is_operand_hi32_zero(n-&gt;in(2)));
 7762   match(Set dst (MulL dst src));
 7763   effect(KILL cr, TEMP tmp);
 7764   ins_cost(2*100+2*400);
 7765 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7766 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) where lo(x_lo * y_hi) = 0 because y_hi = 0
 7767   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7768             &quot;IMUL   $tmp,EDX\n\t&quot;
 7769             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7770             &quot;ADD    EDX,$tmp&quot; %}
 7771   ins_encode %{
 7772     __ movl($tmp$$Register, $src$$Register);
 7773     __ imull($tmp$$Register, rdx);
 7774     __ mull($src$$Register);
 7775     __ addl(rdx, $tmp$$Register);
 7776   %}
 7777   ins_pipe( pipe_slow );
 7778 %}
 7779 
 7780 // Multiply Register Long where the left and the right operands&#39; high 32 bits are zero
 7781 instruct mulL_eReg_hi0(eADXRegL dst, eRegL src, eFlagsReg cr) %{
 7782   predicate(is_operand_hi32_zero(n-&gt;in(1)) &amp;&amp; is_operand_hi32_zero(n-&gt;in(2)));
 7783   match(Set dst (MulL dst src));
 7784   effect(KILL cr);
 7785   ins_cost(1*400);
 7786 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7787 //             hi(result) = hi(x_lo * y_lo) where lo(x_hi * y_lo) = 0 and lo(x_lo * y_hi) = 0 because x_hi = 0 and y_hi = 0
 7788   format %{ &quot;MUL    EDX:EAX,$src.lo\n\t&quot; %}
 7789   ins_encode %{
 7790     __ mull($src$$Register);
 7791   %}
 7792   ins_pipe( pipe_slow );
 7793 %}
 7794 
 7795 // Multiply Register Long by small constant
 7796 instruct mulL_eReg_con(eADXRegL dst, immL_127 src, rRegI tmp, eFlagsReg cr) %{
 7797   match(Set dst (MulL dst src));
 7798   effect(KILL cr, TEMP tmp);
 7799   ins_cost(2*100+2*400);
 7800   size(12);
 7801 // Basic idea: lo(result) = lo(src * EAX)
 7802 //             hi(result) = hi(src * EAX) + lo(src * EDX)
 7803   format %{ &quot;IMUL   $tmp,EDX,$src\n\t&quot;
 7804             &quot;MOV    EDX,$src\n\t&quot;
 7805             &quot;MUL    EDX\t# EDX*EAX -&gt; EDX:EAX\n\t&quot;
 7806             &quot;ADD    EDX,$tmp&quot; %}
 7807   ins_encode( long_multiply_con( dst, src, tmp ) );
 7808   ins_pipe( pipe_slow );
 7809 %}
 7810 
 7811 // Integer DIV with Register
 7812 instruct divI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7813   match(Set rax (DivI rax div));
 7814   effect(KILL rdx, KILL cr);
 7815   size(26);
 7816   ins_cost(30*100+10*100);
 7817   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7818             &quot;JNE,s  normal\n\t&quot;
 7819             &quot;XOR    EDX,EDX\n\t&quot;
 7820             &quot;CMP    ECX,-1\n\t&quot;
 7821             &quot;JE,s   done\n&quot;
 7822     &quot;normal: CDQ\n\t&quot;
 7823             &quot;IDIV   $div\n\t&quot;
 7824     &quot;done:&quot;        %}
 7825   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7826   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7827   ins_pipe( ialu_reg_reg_alu0 );
 7828 %}
 7829 
 7830 // Divide Register Long
 7831 instruct divL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7832   match(Set dst (DivL src1 src2));
 7833   effect( KILL cr, KILL cx, KILL bx );
 7834   ins_cost(10000);
 7835   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7836             &quot;PUSH   $src1.lo\n\t&quot;
 7837             &quot;PUSH   $src2.hi\n\t&quot;
 7838             &quot;PUSH   $src2.lo\n\t&quot;
 7839             &quot;CALL   SharedRuntime::ldiv\n\t&quot;
 7840             &quot;ADD    ESP,16&quot; %}
 7841   ins_encode( long_div(src1,src2) );
 7842   ins_pipe( pipe_slow );
 7843 %}
 7844 
 7845 // Integer DIVMOD with Register, both quotient and mod results
 7846 instruct divModI_eReg_divmod(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7847   match(DivModI rax div);
 7848   effect(KILL cr);
 7849   size(26);
 7850   ins_cost(30*100+10*100);
 7851   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7852             &quot;JNE,s  normal\n\t&quot;
 7853             &quot;XOR    EDX,EDX\n\t&quot;
 7854             &quot;CMP    ECX,-1\n\t&quot;
 7855             &quot;JE,s   done\n&quot;
 7856     &quot;normal: CDQ\n\t&quot;
 7857             &quot;IDIV   $div\n\t&quot;
 7858     &quot;done:&quot;        %}
 7859   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7860   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7861   ins_pipe( pipe_slow );
 7862 %}
 7863 
 7864 // Integer MOD with Register
 7865 instruct modI_eReg(eDXRegI rdx, eAXRegI rax, eCXRegI div, eFlagsReg cr) %{
 7866   match(Set rdx (ModI rax div));
 7867   effect(KILL rax, KILL cr);
 7868 
 7869   size(26);
 7870   ins_cost(300);
 7871   format %{ &quot;CDQ\n\t&quot;
 7872             &quot;IDIV   $div&quot; %}
 7873   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7874   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7875   ins_pipe( ialu_reg_reg_alu0 );
 7876 %}
 7877 
 7878 // Remainder Register Long
 7879 instruct modL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7880   match(Set dst (ModL src1 src2));
 7881   effect( KILL cr, KILL cx, KILL bx );
 7882   ins_cost(10000);
 7883   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7884             &quot;PUSH   $src1.lo\n\t&quot;
 7885             &quot;PUSH   $src2.hi\n\t&quot;
 7886             &quot;PUSH   $src2.lo\n\t&quot;
 7887             &quot;CALL   SharedRuntime::lrem\n\t&quot;
 7888             &quot;ADD    ESP,16&quot; %}
 7889   ins_encode( long_mod(src1,src2) );
 7890   ins_pipe( pipe_slow );
 7891 %}
 7892 
 7893 // Divide Register Long (no special case since divisor != -1)
 7894 instruct divL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7895   match(Set dst (DivL dst imm));
 7896   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7897   ins_cost(1000);
 7898   format %{ &quot;MOV    $tmp,abs($imm) # ldiv EDX:EAX,$imm\n\t&quot;
 7899             &quot;XOR    $tmp2,$tmp2\n\t&quot;
 7900             &quot;CMP    $tmp,EDX\n\t&quot;
 7901             &quot;JA,s   fast\n\t&quot;
 7902             &quot;MOV    $tmp2,EAX\n\t&quot;
 7903             &quot;MOV    EAX,EDX\n\t&quot;
 7904             &quot;MOV    EDX,0\n\t&quot;
 7905             &quot;JLE,s  pos\n\t&quot;
 7906             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7907             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7908             &quot;XCHG   EAX,$tmp2\n\t&quot;
 7909             &quot;DIV    $tmp\n\t&quot;
 7910             &quot;LNEG   $tmp2 : EAX\n\t&quot;
 7911             &quot;JMP,s  done\n&quot;
 7912     &quot;pos:\n\t&quot;
 7913             &quot;DIV    $tmp\n\t&quot;
 7914             &quot;XCHG   EAX,$tmp2\n&quot;
 7915     &quot;fast:\n\t&quot;
 7916             &quot;DIV    $tmp\n&quot;
 7917     &quot;done:\n\t&quot;
 7918             &quot;MOV    EDX,$tmp2\n\t&quot;
 7919             &quot;NEG    EDX:EAX # if $imm &lt; 0&quot; %}
 7920   ins_encode %{
 7921     int con = (int)$imm$$constant;
 7922     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7923     int pcon = (con &gt; 0) ? con : -con;
 7924     Label Lfast, Lpos, Ldone;
 7925 
 7926     __ movl($tmp$$Register, pcon);
 7927     __ xorl($tmp2$$Register,$tmp2$$Register);
 7928     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 7929     __ jccb(Assembler::above, Lfast); // result fits into 32 bit
 7930 
 7931     __ movl($tmp2$$Register, $dst$$Register); // save
 7932     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 7933     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 7934     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 7935 
 7936     // Negative dividend.
 7937     // convert value to positive to use unsigned division
 7938     __ lneg($dst$$Register, $tmp2$$Register);
 7939     __ divl($tmp$$Register);
 7940     __ xchgl($dst$$Register, $tmp2$$Register);
 7941     __ divl($tmp$$Register);
 7942     // revert result back to negative
 7943     __ lneg($tmp2$$Register, $dst$$Register);
 7944     __ jmpb(Ldone);
 7945 
 7946     __ bind(Lpos);
 7947     __ divl($tmp$$Register); // Use unsigned division
 7948     __ xchgl($dst$$Register, $tmp2$$Register);
 7949     // Fallthrow for final divide, tmp2 has 32 bit hi result
 7950 
 7951     __ bind(Lfast);
 7952     // fast path: src is positive
 7953     __ divl($tmp$$Register); // Use unsigned division
 7954 
 7955     __ bind(Ldone);
 7956     __ movl(HIGH_FROM_LOW($dst$$Register),$tmp2$$Register);
 7957     if (con &lt; 0) {
 7958       __ lneg(HIGH_FROM_LOW($dst$$Register), $dst$$Register);
 7959     }
 7960   %}
 7961   ins_pipe( pipe_slow );
 7962 %}
 7963 
 7964 // Remainder Register Long (remainder fit into 32 bits)
 7965 instruct modL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7966   match(Set dst (ModL dst imm));
 7967   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7968   ins_cost(1000);
 7969   format %{ &quot;MOV    $tmp,abs($imm) # lrem EDX:EAX,$imm\n\t&quot;
 7970             &quot;CMP    $tmp,EDX\n\t&quot;
 7971             &quot;JA,s   fast\n\t&quot;
 7972             &quot;MOV    $tmp2,EAX\n\t&quot;
 7973             &quot;MOV    EAX,EDX\n\t&quot;
 7974             &quot;MOV    EDX,0\n\t&quot;
 7975             &quot;JLE,s  pos\n\t&quot;
 7976             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7977             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7978             &quot;MOV    EAX,$tmp2\n\t&quot;
 7979             &quot;DIV    $tmp\n\t&quot;
 7980             &quot;NEG    EDX\n\t&quot;
 7981             &quot;JMP,s  done\n&quot;
 7982     &quot;pos:\n\t&quot;
 7983             &quot;DIV    $tmp\n\t&quot;
 7984             &quot;MOV    EAX,$tmp2\n&quot;
 7985     &quot;fast:\n\t&quot;
 7986             &quot;DIV    $tmp\n&quot;
 7987     &quot;done:\n\t&quot;
 7988             &quot;MOV    EAX,EDX\n\t&quot;
 7989             &quot;SAR    EDX,31\n\t&quot; %}
 7990   ins_encode %{
 7991     int con = (int)$imm$$constant;
 7992     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7993     int pcon = (con &gt; 0) ? con : -con;
 7994     Label  Lfast, Lpos, Ldone;
 7995 
 7996     __ movl($tmp$$Register, pcon);
 7997     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 7998     __ jccb(Assembler::above, Lfast); // src is positive and result fits into 32 bit
 7999 
 8000     __ movl($tmp2$$Register, $dst$$Register); // save
 8001     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8002     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 8003     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 8004 
 8005     // Negative dividend.
 8006     // convert value to positive to use unsigned division
 8007     __ lneg($dst$$Register, $tmp2$$Register);
 8008     __ divl($tmp$$Register);
 8009     __ movl($dst$$Register, $tmp2$$Register);
 8010     __ divl($tmp$$Register);
 8011     // revert remainder back to negative
 8012     __ negl(HIGH_FROM_LOW($dst$$Register));
 8013     __ jmpb(Ldone);
 8014 
 8015     __ bind(Lpos);
 8016     __ divl($tmp$$Register);
 8017     __ movl($dst$$Register, $tmp2$$Register);
 8018 
 8019     __ bind(Lfast);
 8020     // fast path: src is positive
 8021     __ divl($tmp$$Register);
 8022 
 8023     __ bind(Ldone);
 8024     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8025     __ sarl(HIGH_FROM_LOW($dst$$Register), 31); // result sign
 8026 
 8027   %}
 8028   ins_pipe( pipe_slow );
 8029 %}
 8030 
 8031 // Integer Shift Instructions
 8032 // Shift Left by one
 8033 instruct shlI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8034   match(Set dst (LShiftI dst shift));
 8035   effect(KILL cr);
 8036 
 8037   size(2);
 8038   format %{ &quot;SHL    $dst,$shift&quot; %}
 8039   opcode(0xD1, 0x4);  /* D1 /4 */
 8040   ins_encode( OpcP, RegOpc( dst ) );
 8041   ins_pipe( ialu_reg );
 8042 %}
 8043 
 8044 // Shift Left by 8-bit immediate
 8045 instruct salI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8046   match(Set dst (LShiftI dst shift));
 8047   effect(KILL cr);
 8048 
 8049   size(3);
 8050   format %{ &quot;SHL    $dst,$shift&quot; %}
 8051   opcode(0xC1, 0x4);  /* C1 /4 ib */
 8052   ins_encode( RegOpcImm( dst, shift) );
 8053   ins_pipe( ialu_reg );
 8054 %}
 8055 
 8056 // Shift Left by variable
 8057 instruct salI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8058   match(Set dst (LShiftI dst shift));
 8059   effect(KILL cr);
 8060 
 8061   size(2);
 8062   format %{ &quot;SHL    $dst,$shift&quot; %}
 8063   opcode(0xD3, 0x4);  /* D3 /4 */
 8064   ins_encode( OpcP, RegOpc( dst ) );
 8065   ins_pipe( ialu_reg_reg );
 8066 %}
 8067 
 8068 // Arithmetic shift right by one
 8069 instruct sarI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8070   match(Set dst (RShiftI dst shift));
 8071   effect(KILL cr);
 8072 
 8073   size(2);
 8074   format %{ &quot;SAR    $dst,$shift&quot; %}
 8075   opcode(0xD1, 0x7);  /* D1 /7 */
 8076   ins_encode( OpcP, RegOpc( dst ) );
 8077   ins_pipe( ialu_reg );
 8078 %}
 8079 
 8080 // Arithmetic shift right by one
 8081 instruct sarI_mem_1(memory dst, immI1 shift, eFlagsReg cr) %{
 8082   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8083   effect(KILL cr);
 8084   format %{ &quot;SAR    $dst,$shift&quot; %}
 8085   opcode(0xD1, 0x7);  /* D1 /7 */
 8086   ins_encode( OpcP, RMopc_Mem(secondary,dst) );
 8087   ins_pipe( ialu_mem_imm );
 8088 %}
 8089 
 8090 // Arithmetic Shift Right by 8-bit immediate
 8091 instruct sarI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8092   match(Set dst (RShiftI dst shift));
 8093   effect(KILL cr);
 8094 
 8095   size(3);
 8096   format %{ &quot;SAR    $dst,$shift&quot; %}
 8097   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8098   ins_encode( RegOpcImm( dst, shift ) );
 8099   ins_pipe( ialu_mem_imm );
 8100 %}
 8101 
 8102 // Arithmetic Shift Right by 8-bit immediate
 8103 instruct sarI_mem_imm(memory dst, immI8 shift, eFlagsReg cr) %{
 8104   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8105   effect(KILL cr);
 8106 
 8107   format %{ &quot;SAR    $dst,$shift&quot; %}
 8108   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8109   ins_encode( OpcP, RMopc_Mem(secondary, dst ), Con8or32( shift ) );
 8110   ins_pipe( ialu_mem_imm );
 8111 %}
 8112 
 8113 // Arithmetic Shift Right by variable
 8114 instruct sarI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8115   match(Set dst (RShiftI dst shift));
 8116   effect(KILL cr);
 8117 
 8118   size(2);
 8119   format %{ &quot;SAR    $dst,$shift&quot; %}
 8120   opcode(0xD3, 0x7);  /* D3 /7 */
 8121   ins_encode( OpcP, RegOpc( dst ) );
 8122   ins_pipe( ialu_reg_reg );
 8123 %}
 8124 
 8125 // Logical shift right by one
 8126 instruct shrI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8127   match(Set dst (URShiftI dst shift));
 8128   effect(KILL cr);
 8129 
 8130   size(2);
 8131   format %{ &quot;SHR    $dst,$shift&quot; %}
 8132   opcode(0xD1, 0x5);  /* D1 /5 */
 8133   ins_encode( OpcP, RegOpc( dst ) );
 8134   ins_pipe( ialu_reg );
 8135 %}
 8136 
 8137 // Logical Shift Right by 8-bit immediate
 8138 instruct shrI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8139   match(Set dst (URShiftI dst shift));
 8140   effect(KILL cr);
 8141 
 8142   size(3);
 8143   format %{ &quot;SHR    $dst,$shift&quot; %}
 8144   opcode(0xC1, 0x5);  /* C1 /5 ib */
 8145   ins_encode( RegOpcImm( dst, shift) );
 8146   ins_pipe( ialu_reg );
 8147 %}
 8148 
 8149 
 8150 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8151 // This idiom is used by the compiler for the i2b bytecode.
 8152 instruct i2b(rRegI dst, xRegI src, immI_24 twentyfour) %{
 8153   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8154 
 8155   size(3);
 8156   format %{ &quot;MOVSX  $dst,$src :8&quot; %}
 8157   ins_encode %{
 8158     __ movsbl($dst$$Register, $src$$Register);
 8159   %}
 8160   ins_pipe(ialu_reg_reg);
 8161 %}
 8162 
 8163 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8164 // This idiom is used by the compiler the i2s bytecode.
 8165 instruct i2s(rRegI dst, xRegI src, immI_16 sixteen) %{
 8166   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8167 
 8168   size(3);
 8169   format %{ &quot;MOVSX  $dst,$src :16&quot; %}
 8170   ins_encode %{
 8171     __ movswl($dst$$Register, $src$$Register);
 8172   %}
 8173   ins_pipe(ialu_reg_reg);
 8174 %}
 8175 
 8176 
 8177 // Logical Shift Right by variable
 8178 instruct shrI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8179   match(Set dst (URShiftI dst shift));
 8180   effect(KILL cr);
 8181 
 8182   size(2);
 8183   format %{ &quot;SHR    $dst,$shift&quot; %}
 8184   opcode(0xD3, 0x5);  /* D3 /5 */
 8185   ins_encode( OpcP, RegOpc( dst ) );
 8186   ins_pipe( ialu_reg_reg );
 8187 %}
 8188 
 8189 
 8190 //----------Logical Instructions-----------------------------------------------
 8191 //----------Integer Logical Instructions---------------------------------------
 8192 // And Instructions
 8193 // And Register with Register
 8194 instruct andI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8195   match(Set dst (AndI dst src));
 8196   effect(KILL cr);
 8197 
 8198   size(2);
 8199   format %{ &quot;AND    $dst,$src&quot; %}
 8200   opcode(0x23);
 8201   ins_encode( OpcP, RegReg( dst, src) );
 8202   ins_pipe( ialu_reg_reg );
 8203 %}
 8204 
 8205 // And Register with Immediate
 8206 instruct andI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8207   match(Set dst (AndI dst src));
 8208   effect(KILL cr);
 8209 
 8210   format %{ &quot;AND    $dst,$src&quot; %}
 8211   opcode(0x81,0x04);  /* Opcode 81 /4 */
 8212   // ins_encode( RegImm( dst, src) );
 8213   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8214   ins_pipe( ialu_reg );
 8215 %}
 8216 
 8217 // And Register with Memory
 8218 instruct andI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8219   match(Set dst (AndI dst (LoadI src)));
 8220   effect(KILL cr);
 8221 
 8222   ins_cost(125);
 8223   format %{ &quot;AND    $dst,$src&quot; %}
 8224   opcode(0x23);
 8225   ins_encode( OpcP, RegMem( dst, src) );
 8226   ins_pipe( ialu_reg_mem );
 8227 %}
 8228 
 8229 // And Memory with Register
 8230 instruct andI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8231   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8232   effect(KILL cr);
 8233 
 8234   ins_cost(150);
 8235   format %{ &quot;AND    $dst,$src&quot; %}
 8236   opcode(0x21);  /* Opcode 21 /r */
 8237   ins_encode( OpcP, RegMem( src, dst ) );
 8238   ins_pipe( ialu_mem_reg );
 8239 %}
 8240 
 8241 // And Memory with Immediate
 8242 instruct andI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8243   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8244   effect(KILL cr);
 8245 
 8246   ins_cost(125);
 8247   format %{ &quot;AND    $dst,$src&quot; %}
 8248   opcode(0x81, 0x4);  /* Opcode 81 /4 id */
 8249   // ins_encode( MemImm( dst, src) );
 8250   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8251   ins_pipe( ialu_mem_imm );
 8252 %}
 8253 
 8254 // BMI1 instructions
 8255 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, eFlagsReg cr) %{
 8256   match(Set dst (AndI (XorI src1 minus_1) src2));
 8257   predicate(UseBMI1Instructions);
 8258   effect(KILL cr);
 8259 
 8260   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8261 
 8262   ins_encode %{
 8263     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 8264   %}
 8265   ins_pipe(ialu_reg);
 8266 %}
 8267 
 8268 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, eFlagsReg cr) %{
 8269   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2) ));
 8270   predicate(UseBMI1Instructions);
 8271   effect(KILL cr);
 8272 
 8273   ins_cost(125);
 8274   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8275 
 8276   ins_encode %{
 8277     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 8278   %}
 8279   ins_pipe(ialu_reg_mem);
 8280 %}
 8281 
 8282 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, eFlagsReg cr) %{
 8283   match(Set dst (AndI (SubI imm_zero src) src));
 8284   predicate(UseBMI1Instructions);
 8285   effect(KILL cr);
 8286 
 8287   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8288 
 8289   ins_encode %{
 8290     __ blsil($dst$$Register, $src$$Register);
 8291   %}
 8292   ins_pipe(ialu_reg);
 8293 %}
 8294 
 8295 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, eFlagsReg cr) %{
 8296   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 8297   predicate(UseBMI1Instructions);
 8298   effect(KILL cr);
 8299 
 8300   ins_cost(125);
 8301   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8302 
 8303   ins_encode %{
 8304     __ blsil($dst$$Register, $src$$Address);
 8305   %}
 8306   ins_pipe(ialu_reg_mem);
 8307 %}
 8308 
 8309 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8310 %{
 8311   match(Set dst (XorI (AddI src minus_1) src));
 8312   predicate(UseBMI1Instructions);
 8313   effect(KILL cr);
 8314 
 8315   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8316 
 8317   ins_encode %{
 8318     __ blsmskl($dst$$Register, $src$$Register);
 8319   %}
 8320 
 8321   ins_pipe(ialu_reg);
 8322 %}
 8323 
 8324 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8325 %{
 8326   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ));
 8327   predicate(UseBMI1Instructions);
 8328   effect(KILL cr);
 8329 
 8330   ins_cost(125);
 8331   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8332 
 8333   ins_encode %{
 8334     __ blsmskl($dst$$Register, $src$$Address);
 8335   %}
 8336 
 8337   ins_pipe(ialu_reg_mem);
 8338 %}
 8339 
 8340 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8341 %{
 8342   match(Set dst (AndI (AddI src minus_1) src) );
 8343   predicate(UseBMI1Instructions);
 8344   effect(KILL cr);
 8345 
 8346   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8347 
 8348   ins_encode %{
 8349     __ blsrl($dst$$Register, $src$$Register);
 8350   %}
 8351 
 8352   ins_pipe(ialu_reg);
 8353 %}
 8354 
 8355 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8356 %{
 8357   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ));
 8358   predicate(UseBMI1Instructions);
 8359   effect(KILL cr);
 8360 
 8361   ins_cost(125);
 8362   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8363 
 8364   ins_encode %{
 8365     __ blsrl($dst$$Register, $src$$Address);
 8366   %}
 8367 
 8368   ins_pipe(ialu_reg_mem);
 8369 %}
 8370 
 8371 // Or Instructions
 8372 // Or Register with Register
 8373 instruct orI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8374   match(Set dst (OrI dst src));
 8375   effect(KILL cr);
 8376 
 8377   size(2);
 8378   format %{ &quot;OR     $dst,$src&quot; %}
 8379   opcode(0x0B);
 8380   ins_encode( OpcP, RegReg( dst, src) );
 8381   ins_pipe( ialu_reg_reg );
 8382 %}
 8383 
 8384 instruct orI_eReg_castP2X(rRegI dst, eRegP src, eFlagsReg cr) %{
 8385   match(Set dst (OrI dst (CastP2X src)));
 8386   effect(KILL cr);
 8387 
 8388   size(2);
 8389   format %{ &quot;OR     $dst,$src&quot; %}
 8390   opcode(0x0B);
 8391   ins_encode( OpcP, RegReg( dst, src) );
 8392   ins_pipe( ialu_reg_reg );
 8393 %}
 8394 
 8395 
 8396 // Or Register with Immediate
 8397 instruct orI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8398   match(Set dst (OrI dst src));
 8399   effect(KILL cr);
 8400 
 8401   format %{ &quot;OR     $dst,$src&quot; %}
 8402   opcode(0x81,0x01);  /* Opcode 81 /1 id */
 8403   // ins_encode( RegImm( dst, src) );
 8404   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8405   ins_pipe( ialu_reg );
 8406 %}
 8407 
 8408 // Or Register with Memory
 8409 instruct orI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8410   match(Set dst (OrI dst (LoadI src)));
 8411   effect(KILL cr);
 8412 
 8413   ins_cost(125);
 8414   format %{ &quot;OR     $dst,$src&quot; %}
 8415   opcode(0x0B);
 8416   ins_encode( OpcP, RegMem( dst, src) );
 8417   ins_pipe( ialu_reg_mem );
 8418 %}
 8419 
 8420 // Or Memory with Register
 8421 instruct orI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8422   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8423   effect(KILL cr);
 8424 
 8425   ins_cost(150);
 8426   format %{ &quot;OR     $dst,$src&quot; %}
 8427   opcode(0x09);  /* Opcode 09 /r */
 8428   ins_encode( OpcP, RegMem( src, dst ) );
 8429   ins_pipe( ialu_mem_reg );
 8430 %}
 8431 
 8432 // Or Memory with Immediate
 8433 instruct orI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8434   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8435   effect(KILL cr);
 8436 
 8437   ins_cost(125);
 8438   format %{ &quot;OR     $dst,$src&quot; %}
 8439   opcode(0x81,0x1);  /* Opcode 81 /1 id */
 8440   // ins_encode( MemImm( dst, src) );
 8441   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8442   ins_pipe( ialu_mem_imm );
 8443 %}
 8444 
 8445 // ROL/ROR
 8446 // ROL expand
 8447 instruct rolI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8448   effect(USE_DEF dst, USE shift, KILL cr);
 8449 
 8450   format %{ &quot;ROL    $dst, $shift&quot; %}
 8451   opcode(0xD1, 0x0); /* Opcode D1 /0 */
 8452   ins_encode( OpcP, RegOpc( dst ));
 8453   ins_pipe( ialu_reg );
 8454 %}
 8455 
 8456 instruct rolI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8457   effect(USE_DEF dst, USE shift, KILL cr);
 8458 
 8459   format %{ &quot;ROL    $dst, $shift&quot; %}
 8460   opcode(0xC1, 0x0); /*Opcode /C1  /0  */
 8461   ins_encode( RegOpcImm(dst, shift) );
 8462   ins_pipe(ialu_reg);
 8463 %}
 8464 
 8465 instruct rolI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8466   effect(USE_DEF dst, USE shift, KILL cr);
 8467 
 8468   format %{ &quot;ROL    $dst, $shift&quot; %}
 8469   opcode(0xD3, 0x0);    /* Opcode D3 /0 */
 8470   ins_encode(OpcP, RegOpc(dst));
 8471   ins_pipe( ialu_reg_reg );
 8472 %}
 8473 // end of ROL expand
 8474 
 8475 // ROL 32bit by one once
 8476 instruct rolI_eReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, eFlagsReg cr) %{
 8477   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8478 
 8479   expand %{
 8480     rolI_eReg_imm1(dst, lshift, cr);
 8481   %}
 8482 %}
 8483 
 8484 // ROL 32bit var by imm8 once
 8485 instruct rolI_eReg_i8(rRegI dst, immI8 lshift, immI8 rshift, eFlagsReg cr) %{
 8486   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8487   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8488 
 8489   expand %{
 8490     rolI_eReg_imm8(dst, lshift, cr);
 8491   %}
 8492 %}
 8493 
 8494 // ROL 32bit var by var once
 8495 instruct rolI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8496   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 8497 
 8498   expand %{
 8499     rolI_eReg_CL(dst, shift, cr);
 8500   %}
 8501 %}
 8502 
 8503 // ROL 32bit var by var once
 8504 instruct rolI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8505   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 8506 
 8507   expand %{
 8508     rolI_eReg_CL(dst, shift, cr);
 8509   %}
 8510 %}
 8511 
 8512 // ROR expand
 8513 instruct rorI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8514   effect(USE_DEF dst, USE shift, KILL cr);
 8515 
 8516   format %{ &quot;ROR    $dst, $shift&quot; %}
 8517   opcode(0xD1,0x1);  /* Opcode D1 /1 */
 8518   ins_encode( OpcP, RegOpc( dst ) );
 8519   ins_pipe( ialu_reg );
 8520 %}
 8521 
 8522 instruct rorI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8523   effect (USE_DEF dst, USE shift, KILL cr);
 8524 
 8525   format %{ &quot;ROR    $dst, $shift&quot; %}
 8526   opcode(0xC1, 0x1); /* Opcode /C1 /1 ib */
 8527   ins_encode( RegOpcImm(dst, shift) );
 8528   ins_pipe( ialu_reg );
 8529 %}
 8530 
 8531 instruct rorI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr)%{
 8532   effect(USE_DEF dst, USE shift, KILL cr);
 8533 
 8534   format %{ &quot;ROR    $dst, $shift&quot; %}
 8535   opcode(0xD3, 0x1);    /* Opcode D3 /1 */
 8536   ins_encode(OpcP, RegOpc(dst));
 8537   ins_pipe( ialu_reg_reg );
 8538 %}
 8539 // end of ROR expand
 8540 
 8541 // ROR right once
 8542 instruct rorI_eReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, eFlagsReg cr) %{
 8543   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8544 
 8545   expand %{
 8546     rorI_eReg_imm1(dst, rshift, cr);
 8547   %}
 8548 %}
 8549 
 8550 // ROR 32bit by immI8 once
 8551 instruct rorI_eReg_i8(rRegI dst, immI8 rshift, immI8 lshift, eFlagsReg cr) %{
 8552   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8553   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8554 
 8555   expand %{
 8556     rorI_eReg_imm8(dst, rshift, cr);
 8557   %}
 8558 %}
 8559 
 8560 // ROR 32bit var by var once
 8561 instruct rorI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8562   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 8563 
 8564   expand %{
 8565     rorI_eReg_CL(dst, shift, cr);
 8566   %}
 8567 %}
 8568 
 8569 // ROR 32bit var by var once
 8570 instruct rorI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8571   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 8572 
 8573   expand %{
 8574     rorI_eReg_CL(dst, shift, cr);
 8575   %}
 8576 %}
 8577 
 8578 // Xor Instructions
 8579 // Xor Register with Register
 8580 instruct xorI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8581   match(Set dst (XorI dst src));
 8582   effect(KILL cr);
 8583 
 8584   size(2);
 8585   format %{ &quot;XOR    $dst,$src&quot; %}
 8586   opcode(0x33);
 8587   ins_encode( OpcP, RegReg( dst, src) );
 8588   ins_pipe( ialu_reg_reg );
 8589 %}
 8590 
 8591 // Xor Register with Immediate -1
 8592 instruct xorI_eReg_im1(rRegI dst, immI_M1 imm) %{
 8593   match(Set dst (XorI dst imm));
 8594 
 8595   size(2);
 8596   format %{ &quot;NOT    $dst&quot; %}
 8597   ins_encode %{
 8598      __ notl($dst$$Register);
 8599   %}
 8600   ins_pipe( ialu_reg );
 8601 %}
 8602 
 8603 // Xor Register with Immediate
 8604 instruct xorI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8605   match(Set dst (XorI dst src));
 8606   effect(KILL cr);
 8607 
 8608   format %{ &quot;XOR    $dst,$src&quot; %}
 8609   opcode(0x81,0x06);  /* Opcode 81 /6 id */
 8610   // ins_encode( RegImm( dst, src) );
 8611   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8612   ins_pipe( ialu_reg );
 8613 %}
 8614 
 8615 // Xor Register with Memory
 8616 instruct xorI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8617   match(Set dst (XorI dst (LoadI src)));
 8618   effect(KILL cr);
 8619 
 8620   ins_cost(125);
 8621   format %{ &quot;XOR    $dst,$src&quot; %}
 8622   opcode(0x33);
 8623   ins_encode( OpcP, RegMem(dst, src) );
 8624   ins_pipe( ialu_reg_mem );
 8625 %}
 8626 
 8627 // Xor Memory with Register
 8628 instruct xorI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8629   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8630   effect(KILL cr);
 8631 
 8632   ins_cost(150);
 8633   format %{ &quot;XOR    $dst,$src&quot; %}
 8634   opcode(0x31);  /* Opcode 31 /r */
 8635   ins_encode( OpcP, RegMem( src, dst ) );
 8636   ins_pipe( ialu_mem_reg );
 8637 %}
 8638 
 8639 // Xor Memory with Immediate
 8640 instruct xorI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8641   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8642   effect(KILL cr);
 8643 
 8644   ins_cost(125);
 8645   format %{ &quot;XOR    $dst,$src&quot; %}
 8646   opcode(0x81,0x6);  /* Opcode 81 /6 id */
 8647   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8648   ins_pipe( ialu_mem_imm );
 8649 %}
 8650 
 8651 //----------Convert Int to Boolean---------------------------------------------
 8652 
 8653 instruct movI_nocopy(rRegI dst, rRegI src) %{
 8654   effect( DEF dst, USE src );
 8655   format %{ &quot;MOV    $dst,$src&quot; %}
 8656   ins_encode( enc_Copy( dst, src) );
 8657   ins_pipe( ialu_reg_reg );
 8658 %}
 8659 
 8660 instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8661   effect( USE_DEF dst, USE src, KILL cr );
 8662 
 8663   size(4);
 8664   format %{ &quot;NEG    $dst\n\t&quot;
 8665             &quot;ADC    $dst,$src&quot; %}
 8666   ins_encode( neg_reg(dst),
 8667               OpcRegReg(0x13,dst,src) );
 8668   ins_pipe( ialu_reg_reg_long );
 8669 %}
 8670 
 8671 instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8672   match(Set dst (Conv2B src));
 8673 
 8674   expand %{
 8675     movI_nocopy(dst,src);
 8676     ci2b(dst,src,cr);
 8677   %}
 8678 %}
 8679 
 8680 instruct movP_nocopy(rRegI dst, eRegP src) %{
 8681   effect( DEF dst, USE src );
 8682   format %{ &quot;MOV    $dst,$src&quot; %}
 8683   ins_encode( enc_Copy( dst, src) );
 8684   ins_pipe( ialu_reg_reg );
 8685 %}
 8686 
 8687 instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8688   effect( USE_DEF dst, USE src, KILL cr );
 8689   format %{ &quot;NEG    $dst\n\t&quot;
 8690             &quot;ADC    $dst,$src&quot; %}
 8691   ins_encode( neg_reg(dst),
 8692               OpcRegReg(0x13,dst,src) );
 8693   ins_pipe( ialu_reg_reg_long );
 8694 %}
 8695 
 8696 instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8697   match(Set dst (Conv2B src));
 8698 
 8699   expand %{
 8700     movP_nocopy(dst,src);
 8701     cp2b(dst,src,cr);
 8702   %}
 8703 %}
 8704 
 8705 instruct cmpLTMask(eCXRegI dst, ncxRegI p, ncxRegI q, eFlagsReg cr) %{
 8706   match(Set dst (CmpLTMask p q));
 8707   effect(KILL cr);
 8708   ins_cost(400);
 8709 
 8710   // SETlt can only use low byte of EAX,EBX, ECX, or EDX as destination
 8711   format %{ &quot;XOR    $dst,$dst\n\t&quot;
 8712             &quot;CMP    $p,$q\n\t&quot;
 8713             &quot;SETlt  $dst\n\t&quot;
 8714             &quot;NEG    $dst&quot; %}
 8715   ins_encode %{
 8716     Register Rp = $p$$Register;
 8717     Register Rq = $q$$Register;
 8718     Register Rd = $dst$$Register;
 8719     Label done;
 8720     __ xorl(Rd, Rd);
 8721     __ cmpl(Rp, Rq);
 8722     __ setb(Assembler::less, Rd);
 8723     __ negl(Rd);
 8724   %}
 8725 
 8726   ins_pipe(pipe_slow);
 8727 %}
 8728 
 8729 instruct cmpLTMask0(rRegI dst, immI0 zero, eFlagsReg cr) %{
 8730   match(Set dst (CmpLTMask dst zero));
 8731   effect(DEF dst, KILL cr);
 8732   ins_cost(100);
 8733 
 8734   format %{ &quot;SAR    $dst,31\t# cmpLTMask0&quot; %}
 8735   ins_encode %{
 8736   __ sarl($dst$$Register, 31);
 8737   %}
 8738   ins_pipe(ialu_reg);
 8739 %}
 8740 
 8741 /* better to save a register than avoid a branch */
 8742 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8743   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 8744   effect(KILL cr);
 8745   ins_cost(400);
 8746   format %{ &quot;SUB    $p,$q\t# cadd_cmpLTMask\n\t&quot;
 8747             &quot;JGE    done\n\t&quot;
 8748             &quot;ADD    $p,$y\n&quot;
 8749             &quot;done:  &quot; %}
 8750   ins_encode %{
 8751     Register Rp = $p$$Register;
 8752     Register Rq = $q$$Register;
 8753     Register Ry = $y$$Register;
 8754     Label done;
 8755     __ subl(Rp, Rq);
 8756     __ jccb(Assembler::greaterEqual, done);
 8757     __ addl(Rp, Ry);
 8758     __ bind(done);
 8759   %}
 8760 
 8761   ins_pipe(pipe_cmplt);
 8762 %}
 8763 
 8764 /* better to save a register than avoid a branch */
 8765 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8766   match(Set y (AndI (CmpLTMask p q) y));
 8767   effect(KILL cr);
 8768 
 8769   ins_cost(300);
 8770 
 8771   format %{ &quot;CMPL     $p, $q\t# and_cmpLTMask\n\t&quot;
 8772             &quot;JLT      done\n\t&quot;
 8773             &quot;XORL     $y, $y\n&quot;
 8774             &quot;done:  &quot; %}
 8775   ins_encode %{
 8776     Register Rp = $p$$Register;
 8777     Register Rq = $q$$Register;
 8778     Register Ry = $y$$Register;
 8779     Label done;
 8780     __ cmpl(Rp, Rq);
 8781     __ jccb(Assembler::less, done);
 8782     __ xorl(Ry, Ry);
 8783     __ bind(done);
 8784   %}
 8785 
 8786   ins_pipe(pipe_cmplt);
 8787 %}
 8788 
 8789 /* If I enable this, I encourage spilling in the inner loop of compress.
 8790 instruct cadd_cmpLTMask_mem(ncxRegI p, ncxRegI q, memory y, eCXRegI tmp, eFlagsReg cr) %{
 8791   match(Set p (AddI (AndI (CmpLTMask p q) (LoadI y)) (SubI p q)));
 8792 */
 8793 //----------Overflow Math Instructions-----------------------------------------
 8794 
 8795 instruct overflowAddI_eReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8796 %{
 8797   match(Set cr (OverflowAddI op1 op2));
 8798   effect(DEF cr, USE_KILL op1, USE op2);
 8799 
 8800   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8801 
 8802   ins_encode %{
 8803     __ addl($op1$$Register, $op2$$Register);
 8804   %}
 8805   ins_pipe(ialu_reg_reg);
 8806 %}
 8807 
 8808 instruct overflowAddI_rReg_imm(eFlagsReg cr, eAXRegI op1, immI op2)
 8809 %{
 8810   match(Set cr (OverflowAddI op1 op2));
 8811   effect(DEF cr, USE_KILL op1, USE op2);
 8812 
 8813   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8814 
 8815   ins_encode %{
 8816     __ addl($op1$$Register, $op2$$constant);
 8817   %}
 8818   ins_pipe(ialu_reg_reg);
 8819 %}
 8820 
 8821 instruct overflowSubI_rReg(eFlagsReg cr, rRegI op1, rRegI op2)
 8822 %{
 8823   match(Set cr (OverflowSubI op1 op2));
 8824 
 8825   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8826   ins_encode %{
 8827     __ cmpl($op1$$Register, $op2$$Register);
 8828   %}
 8829   ins_pipe(ialu_reg_reg);
 8830 %}
 8831 
 8832 instruct overflowSubI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2)
 8833 %{
 8834   match(Set cr (OverflowSubI op1 op2));
 8835 
 8836   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8837   ins_encode %{
 8838     __ cmpl($op1$$Register, $op2$$constant);
 8839   %}
 8840   ins_pipe(ialu_reg_reg);
 8841 %}
 8842 
 8843 instruct overflowNegI_rReg(eFlagsReg cr, immI0 zero, eAXRegI op2)
 8844 %{
 8845   match(Set cr (OverflowSubI zero op2));
 8846   effect(DEF cr, USE_KILL op2);
 8847 
 8848   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}
 8849   ins_encode %{
 8850     __ negl($op2$$Register);
 8851   %}
 8852   ins_pipe(ialu_reg_reg);
 8853 %}
 8854 
 8855 instruct overflowMulI_rReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8856 %{
 8857   match(Set cr (OverflowMulI op1 op2));
 8858   effect(DEF cr, USE_KILL op1, USE op2);
 8859 
 8860   format %{ &quot;IMUL    $op1, $op2\t# overflow check int&quot; %}
 8861   ins_encode %{
 8862     __ imull($op1$$Register, $op2$$Register);
 8863   %}
 8864   ins_pipe(ialu_reg_reg_alu0);
 8865 %}
 8866 
 8867 instruct overflowMulI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
 8868 %{
 8869   match(Set cr (OverflowMulI op1 op2));
 8870   effect(DEF cr, TEMP tmp, USE op1, USE op2);
 8871 
 8872   format %{ &quot;IMUL    $tmp, $op1, $op2\t# overflow check int&quot; %}
 8873   ins_encode %{
 8874     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
 8875   %}
 8876   ins_pipe(ialu_reg_reg_alu0);
 8877 %}
 8878 
 8879 // Integer Absolute Instructions
 8880 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, eFlagsReg cr)
 8881 %{
 8882   match(Set dst (AbsI src));
 8883   effect(TEMP dst, TEMP tmp, KILL cr);
 8884   format %{ &quot;movl $tmp, $src\n\t&quot;
 8885             &quot;sarl $tmp, 31\n\t&quot;
 8886             &quot;movl $dst, $src\n\t&quot;
 8887             &quot;xorl $dst, $tmp\n\t&quot;
 8888             &quot;subl $dst, $tmp\n&quot;
 8889           %}
 8890   ins_encode %{
 8891     __ movl($tmp$$Register, $src$$Register);
 8892     __ sarl($tmp$$Register, 31);
 8893     __ movl($dst$$Register, $src$$Register);
 8894     __ xorl($dst$$Register, $tmp$$Register);
 8895     __ subl($dst$$Register, $tmp$$Register);
 8896   %}
 8897 
 8898   ins_pipe(ialu_reg_reg);
 8899 %}
 8900 
 8901 //----------Long Instructions------------------------------------------------
 8902 // Add Long Register with Register
 8903 instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8904   match(Set dst (AddL dst src));
 8905   effect(KILL cr);
 8906   ins_cost(200);
 8907   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8908             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8909   opcode(0x03, 0x13);
 8910   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8911   ins_pipe( ialu_reg_reg_long );
 8912 %}
 8913 
 8914 // Add Long Register with Immediate
 8915 instruct addL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8916   match(Set dst (AddL dst src));
 8917   effect(KILL cr);
 8918   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8919             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8920   opcode(0x81,0x00,0x02);  /* Opcode 81 /0, 81 /2 */
 8921   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8922   ins_pipe( ialu_reg_long );
 8923 %}
 8924 
 8925 // Add Long Register with Memory
 8926 instruct addL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8927   match(Set dst (AddL dst (LoadL mem)));
 8928   effect(KILL cr);
 8929   ins_cost(125);
 8930   format %{ &quot;ADD    $dst.lo,$mem\n\t&quot;
 8931             &quot;ADC    $dst.hi,$mem+4&quot; %}
 8932   opcode(0x03, 0x13);
 8933   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8934   ins_pipe( ialu_reg_long_mem );
 8935 %}
 8936 
 8937 // Subtract Long Register with Register.
 8938 instruct subL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8939   match(Set dst (SubL dst src));
 8940   effect(KILL cr);
 8941   ins_cost(200);
 8942   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8943             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8944   opcode(0x2B, 0x1B);
 8945   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8946   ins_pipe( ialu_reg_reg_long );
 8947 %}
 8948 
 8949 // Subtract Long Register with Immediate
 8950 instruct subL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8951   match(Set dst (SubL dst src));
 8952   effect(KILL cr);
 8953   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8954             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8955   opcode(0x81,0x05,0x03);  /* Opcode 81 /5, 81 /3 */
 8956   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8957   ins_pipe( ialu_reg_long );
 8958 %}
 8959 
 8960 // Subtract Long Register with Memory
 8961 instruct subL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8962   match(Set dst (SubL dst (LoadL mem)));
 8963   effect(KILL cr);
 8964   ins_cost(125);
 8965   format %{ &quot;SUB    $dst.lo,$mem\n\t&quot;
 8966             &quot;SBB    $dst.hi,$mem+4&quot; %}
 8967   opcode(0x2B, 0x1B);
 8968   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8969   ins_pipe( ialu_reg_long_mem );
 8970 %}
 8971 
 8972 instruct negL_eReg(eRegL dst, immL0 zero, eFlagsReg cr) %{
 8973   match(Set dst (SubL zero dst));
 8974   effect(KILL cr);
 8975   ins_cost(300);
 8976   format %{ &quot;NEG    $dst.hi\n\tNEG    $dst.lo\n\tSBB    $dst.hi,0&quot; %}
 8977   ins_encode( neg_long(dst) );
 8978   ins_pipe( ialu_reg_reg_long );
 8979 %}
 8980 
 8981 // And Long Register with Register
 8982 instruct andL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8983   match(Set dst (AndL dst src));
 8984   effect(KILL cr);
 8985   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 8986             &quot;AND    $dst.hi,$src.hi&quot; %}
 8987   opcode(0x23,0x23);
 8988   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 8989   ins_pipe( ialu_reg_reg_long );
 8990 %}
 8991 
 8992 // And Long Register with Immediate
 8993 instruct andL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8994   match(Set dst (AndL dst src));
 8995   effect(KILL cr);
 8996   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 8997             &quot;AND    $dst.hi,$src.hi&quot; %}
 8998   opcode(0x81,0x04,0x04);  /* Opcode 81 /4, 81 /4 */
 8999   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9000   ins_pipe( ialu_reg_long );
 9001 %}
 9002 
 9003 // And Long Register with Memory
 9004 instruct andL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9005   match(Set dst (AndL dst (LoadL mem)));
 9006   effect(KILL cr);
 9007   ins_cost(125);
 9008   format %{ &quot;AND    $dst.lo,$mem\n\t&quot;
 9009             &quot;AND    $dst.hi,$mem+4&quot; %}
 9010   opcode(0x23, 0x23);
 9011   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9012   ins_pipe( ialu_reg_long_mem );
 9013 %}
 9014 
 9015 // BMI1 instructions
 9016 instruct andnL_eReg_eReg_eReg(eRegL dst, eRegL src1, eRegL src2, immL_M1 minus_1, eFlagsReg cr) %{
 9017   match(Set dst (AndL (XorL src1 minus_1) src2));
 9018   predicate(UseBMI1Instructions);
 9019   effect(KILL cr, TEMP dst);
 9020 
 9021   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2.lo\n\t&quot;
 9022             &quot;ANDNL  $dst.hi, $src1.hi, $src2.hi&quot;
 9023          %}
 9024 
 9025   ins_encode %{
 9026     Register Rdst = $dst$$Register;
 9027     Register Rsrc1 = $src1$$Register;
 9028     Register Rsrc2 = $src2$$Register;
 9029     __ andnl(Rdst, Rsrc1, Rsrc2);
 9030     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), HIGH_FROM_LOW(Rsrc2));
 9031   %}
 9032   ins_pipe(ialu_reg_reg_long);
 9033 %}
 9034 
 9035 instruct andnL_eReg_eReg_mem(eRegL dst, eRegL src1, memory src2, immL_M1 minus_1, eFlagsReg cr) %{
 9036   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2) ));
 9037   predicate(UseBMI1Instructions);
 9038   effect(KILL cr, TEMP dst);
 9039 
 9040   ins_cost(125);
 9041   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2\n\t&quot;
 9042             &quot;ANDNL  $dst.hi, $src1.hi, $src2+4&quot;
 9043          %}
 9044 
 9045   ins_encode %{
 9046     Register Rdst = $dst$$Register;
 9047     Register Rsrc1 = $src1$$Register;
 9048     Address src2_hi = Address::make_raw($src2$$base, $src2$$index, $src2$$scale, $src2$$disp + 4, relocInfo::none);
 9049 
 9050     __ andnl(Rdst, Rsrc1, $src2$$Address);
 9051     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), src2_hi);
 9052   %}
 9053   ins_pipe(ialu_reg_mem);
 9054 %}
 9055 
 9056 instruct blsiL_eReg_eReg(eRegL dst, eRegL src, immL0 imm_zero, eFlagsReg cr) %{
 9057   match(Set dst (AndL (SubL imm_zero src) src));
 9058   predicate(UseBMI1Instructions);
 9059   effect(KILL cr, TEMP dst);
 9060 
 9061   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9062             &quot;BLSIL  $dst.lo, $src.lo\n\t&quot;
 9063             &quot;JNZ    done\n\t&quot;
 9064             &quot;BLSIL  $dst.hi, $src.hi\n&quot;
 9065             &quot;done:&quot;
 9066          %}
 9067 
 9068   ins_encode %{
 9069     Label done;
 9070     Register Rdst = $dst$$Register;
 9071     Register Rsrc = $src$$Register;
 9072     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9073     __ blsil(Rdst, Rsrc);
 9074     __ jccb(Assembler::notZero, done);
 9075     __ blsil(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9076     __ bind(done);
 9077   %}
 9078   ins_pipe(ialu_reg);
 9079 %}
 9080 
 9081 instruct blsiL_eReg_mem(eRegL dst, memory src, immL0 imm_zero, eFlagsReg cr) %{
 9082   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9083   predicate(UseBMI1Instructions);
 9084   effect(KILL cr, TEMP dst);
 9085 
 9086   ins_cost(125);
 9087   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9088             &quot;BLSIL  $dst.lo, $src\n\t&quot;
 9089             &quot;JNZ    done\n\t&quot;
 9090             &quot;BLSIL  $dst.hi, $src+4\n&quot;
 9091             &quot;done:&quot;
 9092          %}
 9093 
 9094   ins_encode %{
 9095     Label done;
 9096     Register Rdst = $dst$$Register;
 9097     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9098 
 9099     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9100     __ blsil(Rdst, $src$$Address);
 9101     __ jccb(Assembler::notZero, done);
 9102     __ blsil(HIGH_FROM_LOW(Rdst), src_hi);
 9103     __ bind(done);
 9104   %}
 9105   ins_pipe(ialu_reg_mem);
 9106 %}
 9107 
 9108 instruct blsmskL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9109 %{
 9110   match(Set dst (XorL (AddL src minus_1) src));
 9111   predicate(UseBMI1Instructions);
 9112   effect(KILL cr, TEMP dst);
 9113 
 9114   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9115             &quot;BLSMSKL $dst.lo, $src.lo\n\t&quot;
 9116             &quot;JNC     done\n\t&quot;
 9117             &quot;BLSMSKL $dst.hi, $src.hi\n&quot;
 9118             &quot;done:&quot;
 9119          %}
 9120 
 9121   ins_encode %{
 9122     Label done;
 9123     Register Rdst = $dst$$Register;
 9124     Register Rsrc = $src$$Register;
 9125     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9126     __ blsmskl(Rdst, Rsrc);
 9127     __ jccb(Assembler::carryClear, done);
 9128     __ blsmskl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9129     __ bind(done);
 9130   %}
 9131 
 9132   ins_pipe(ialu_reg);
 9133 %}
 9134 
 9135 instruct blsmskL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9136 %{
 9137   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ));
 9138   predicate(UseBMI1Instructions);
 9139   effect(KILL cr, TEMP dst);
 9140 
 9141   ins_cost(125);
 9142   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9143             &quot;BLSMSKL $dst.lo, $src\n\t&quot;
 9144             &quot;JNC     done\n\t&quot;
 9145             &quot;BLSMSKL $dst.hi, $src+4\n&quot;
 9146             &quot;done:&quot;
 9147          %}
 9148 
 9149   ins_encode %{
 9150     Label done;
 9151     Register Rdst = $dst$$Register;
 9152     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9153 
 9154     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9155     __ blsmskl(Rdst, $src$$Address);
 9156     __ jccb(Assembler::carryClear, done);
 9157     __ blsmskl(HIGH_FROM_LOW(Rdst), src_hi);
 9158     __ bind(done);
 9159   %}
 9160 
 9161   ins_pipe(ialu_reg_mem);
 9162 %}
 9163 
 9164 instruct blsrL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9165 %{
 9166   match(Set dst (AndL (AddL src minus_1) src) );
 9167   predicate(UseBMI1Instructions);
 9168   effect(KILL cr, TEMP dst);
 9169 
 9170   format %{ &quot;MOVL   $dst.hi, $src.hi\n\t&quot;
 9171             &quot;BLSRL  $dst.lo, $src.lo\n\t&quot;
 9172             &quot;JNC    done\n\t&quot;
 9173             &quot;BLSRL  $dst.hi, $src.hi\n&quot;
 9174             &quot;done:&quot;
 9175   %}
 9176 
 9177   ins_encode %{
 9178     Label done;
 9179     Register Rdst = $dst$$Register;
 9180     Register Rsrc = $src$$Register;
 9181     __ movl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9182     __ blsrl(Rdst, Rsrc);
 9183     __ jccb(Assembler::carryClear, done);
 9184     __ blsrl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9185     __ bind(done);
 9186   %}
 9187 
 9188   ins_pipe(ialu_reg);
 9189 %}
 9190 
 9191 instruct blsrL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9192 %{
 9193   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src) ));
 9194   predicate(UseBMI1Instructions);
 9195   effect(KILL cr, TEMP dst);
 9196 
 9197   ins_cost(125);
 9198   format %{ &quot;MOVL   $dst.hi, $src+4\n\t&quot;
 9199             &quot;BLSRL  $dst.lo, $src\n\t&quot;
 9200             &quot;JNC    done\n\t&quot;
 9201             &quot;BLSRL  $dst.hi, $src+4\n&quot;
 9202             &quot;done:&quot;
 9203   %}
 9204 
 9205   ins_encode %{
 9206     Label done;
 9207     Register Rdst = $dst$$Register;
 9208     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9209     __ movl(HIGH_FROM_LOW(Rdst), src_hi);
 9210     __ blsrl(Rdst, $src$$Address);
 9211     __ jccb(Assembler::carryClear, done);
 9212     __ blsrl(HIGH_FROM_LOW(Rdst), src_hi);
 9213     __ bind(done);
 9214   %}
 9215 
 9216   ins_pipe(ialu_reg_mem);
 9217 %}
 9218 
 9219 // Or Long Register with Register
 9220 instruct orl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9221   match(Set dst (OrL dst src));
 9222   effect(KILL cr);
 9223   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9224             &quot;OR     $dst.hi,$src.hi&quot; %}
 9225   opcode(0x0B,0x0B);
 9226   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9227   ins_pipe( ialu_reg_reg_long );
 9228 %}
 9229 
 9230 // Or Long Register with Immediate
 9231 instruct orl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9232   match(Set dst (OrL dst src));
 9233   effect(KILL cr);
 9234   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9235             &quot;OR     $dst.hi,$src.hi&quot; %}
 9236   opcode(0x81,0x01,0x01);  /* Opcode 81 /1, 81 /1 */
 9237   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9238   ins_pipe( ialu_reg_long );
 9239 %}
 9240 
 9241 // Or Long Register with Memory
 9242 instruct orl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9243   match(Set dst (OrL dst (LoadL mem)));
 9244   effect(KILL cr);
 9245   ins_cost(125);
 9246   format %{ &quot;OR     $dst.lo,$mem\n\t&quot;
 9247             &quot;OR     $dst.hi,$mem+4&quot; %}
 9248   opcode(0x0B,0x0B);
 9249   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9250   ins_pipe( ialu_reg_long_mem );
 9251 %}
 9252 
 9253 // Xor Long Register with Register
 9254 instruct xorl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9255   match(Set dst (XorL dst src));
 9256   effect(KILL cr);
 9257   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9258             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9259   opcode(0x33,0x33);
 9260   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9261   ins_pipe( ialu_reg_reg_long );
 9262 %}
 9263 
 9264 // Xor Long Register with Immediate -1
 9265 instruct xorl_eReg_im1(eRegL dst, immL_M1 imm) %{
 9266   match(Set dst (XorL dst imm));
 9267   format %{ &quot;NOT    $dst.lo\n\t&quot;
 9268             &quot;NOT    $dst.hi&quot; %}
 9269   ins_encode %{
 9270      __ notl($dst$$Register);
 9271      __ notl(HIGH_FROM_LOW($dst$$Register));
 9272   %}
 9273   ins_pipe( ialu_reg_long );
 9274 %}
 9275 
 9276 // Xor Long Register with Immediate
 9277 instruct xorl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9278   match(Set dst (XorL dst src));
 9279   effect(KILL cr);
 9280   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9281             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9282   opcode(0x81,0x06,0x06);  /* Opcode 81 /6, 81 /6 */
 9283   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9284   ins_pipe( ialu_reg_long );
 9285 %}
 9286 
 9287 // Xor Long Register with Memory
 9288 instruct xorl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9289   match(Set dst (XorL dst (LoadL mem)));
 9290   effect(KILL cr);
 9291   ins_cost(125);
 9292   format %{ &quot;XOR    $dst.lo,$mem\n\t&quot;
 9293             &quot;XOR    $dst.hi,$mem+4&quot; %}
 9294   opcode(0x33,0x33);
 9295   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9296   ins_pipe( ialu_reg_long_mem );
 9297 %}
 9298 
 9299 // Shift Left Long by 1
 9300 instruct shlL_eReg_1(eRegL dst, immI_1 cnt, eFlagsReg cr) %{
 9301   predicate(UseNewLongLShift);
 9302   match(Set dst (LShiftL dst cnt));
 9303   effect(KILL cr);
 9304   ins_cost(100);
 9305   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9306             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9307   ins_encode %{
 9308     __ addl($dst$$Register,$dst$$Register);
 9309     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9310   %}
 9311   ins_pipe( ialu_reg_long );
 9312 %}
 9313 
 9314 // Shift Left Long by 2
 9315 instruct shlL_eReg_2(eRegL dst, immI_2 cnt, eFlagsReg cr) %{
 9316   predicate(UseNewLongLShift);
 9317   match(Set dst (LShiftL dst cnt));
 9318   effect(KILL cr);
 9319   ins_cost(100);
 9320   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9321             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9322             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9323             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9324   ins_encode %{
 9325     __ addl($dst$$Register,$dst$$Register);
 9326     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9327     __ addl($dst$$Register,$dst$$Register);
 9328     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9329   %}
 9330   ins_pipe( ialu_reg_long );
 9331 %}
 9332 
 9333 // Shift Left Long by 3
 9334 instruct shlL_eReg_3(eRegL dst, immI_3 cnt, eFlagsReg cr) %{
 9335   predicate(UseNewLongLShift);
 9336   match(Set dst (LShiftL dst cnt));
 9337   effect(KILL cr);
 9338   ins_cost(100);
 9339   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9340             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9341             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9342             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9343             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9344             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9345   ins_encode %{
 9346     __ addl($dst$$Register,$dst$$Register);
 9347     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9348     __ addl($dst$$Register,$dst$$Register);
 9349     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9350     __ addl($dst$$Register,$dst$$Register);
 9351     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9352   %}
 9353   ins_pipe( ialu_reg_long );
 9354 %}
 9355 
 9356 // Shift Left Long by 1-31
 9357 instruct shlL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9358   match(Set dst (LShiftL dst cnt));
 9359   effect(KILL cr);
 9360   ins_cost(200);
 9361   format %{ &quot;SHLD   $dst.hi,$dst.lo,$cnt\n\t&quot;
 9362             &quot;SHL    $dst.lo,$cnt&quot; %}
 9363   opcode(0xC1, 0x4, 0xA4);  /* 0F/A4, then C1 /4 ib */
 9364   ins_encode( move_long_small_shift(dst,cnt) );
 9365   ins_pipe( ialu_reg_long );
 9366 %}
 9367 
 9368 // Shift Left Long by 32-63
 9369 instruct shlL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9370   match(Set dst (LShiftL dst cnt));
 9371   effect(KILL cr);
 9372   ins_cost(300);
 9373   format %{ &quot;MOV    $dst.hi,$dst.lo\n&quot;
 9374           &quot;\tSHL    $dst.hi,$cnt-32\n&quot;
 9375           &quot;\tXOR    $dst.lo,$dst.lo&quot; %}
 9376   opcode(0xC1, 0x4);  /* C1 /4 ib */
 9377   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9378   ins_pipe( ialu_reg_long );
 9379 %}
 9380 
 9381 // Shift Left Long by variable
 9382 instruct salL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9383   match(Set dst (LShiftL dst shift));
 9384   effect(KILL cr);
 9385   ins_cost(500+200);
 9386   size(17);
 9387   format %{ &quot;TEST   $shift,32\n\t&quot;
 9388             &quot;JEQ,s  small\n\t&quot;
 9389             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 9390             &quot;XOR    $dst.lo,$dst.lo\n&quot;
 9391     &quot;small:\tSHLD   $dst.hi,$dst.lo,$shift\n\t&quot;
 9392             &quot;SHL    $dst.lo,$shift&quot; %}
 9393   ins_encode( shift_left_long( dst, shift ) );
 9394   ins_pipe( pipe_slow );
 9395 %}
 9396 
 9397 // Shift Right Long by 1-31
 9398 instruct shrL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9399   match(Set dst (URShiftL dst cnt));
 9400   effect(KILL cr);
 9401   ins_cost(200);
 9402   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9403             &quot;SHR    $dst.hi,$cnt&quot; %}
 9404   opcode(0xC1, 0x5, 0xAC);  /* 0F/AC, then C1 /5 ib */
 9405   ins_encode( move_long_small_shift(dst,cnt) );
 9406   ins_pipe( ialu_reg_long );
 9407 %}
 9408 
 9409 // Shift Right Long by 32-63
 9410 instruct shrL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9411   match(Set dst (URShiftL dst cnt));
 9412   effect(KILL cr);
 9413   ins_cost(300);
 9414   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9415           &quot;\tSHR    $dst.lo,$cnt-32\n&quot;
 9416           &quot;\tXOR    $dst.hi,$dst.hi&quot; %}
 9417   opcode(0xC1, 0x5);  /* C1 /5 ib */
 9418   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9419   ins_pipe( ialu_reg_long );
 9420 %}
 9421 
 9422 // Shift Right Long by variable
 9423 instruct shrL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9424   match(Set dst (URShiftL dst shift));
 9425   effect(KILL cr);
 9426   ins_cost(600);
 9427   size(17);
 9428   format %{ &quot;TEST   $shift,32\n\t&quot;
 9429             &quot;JEQ,s  small\n\t&quot;
 9430             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9431             &quot;XOR    $dst.hi,$dst.hi\n&quot;
 9432     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9433             &quot;SHR    $dst.hi,$shift&quot; %}
 9434   ins_encode( shift_right_long( dst, shift ) );
 9435   ins_pipe( pipe_slow );
 9436 %}
 9437 
 9438 // Shift Right Long by 1-31
 9439 instruct sarL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9440   match(Set dst (RShiftL dst cnt));
 9441   effect(KILL cr);
 9442   ins_cost(200);
 9443   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9444             &quot;SAR    $dst.hi,$cnt&quot; %}
 9445   opcode(0xC1, 0x7, 0xAC);  /* 0F/AC, then C1 /7 ib */
 9446   ins_encode( move_long_small_shift(dst,cnt) );
 9447   ins_pipe( ialu_reg_long );
 9448 %}
 9449 
 9450 // Shift Right Long by 32-63
 9451 instruct sarL_eReg_32_63( eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9452   match(Set dst (RShiftL dst cnt));
 9453   effect(KILL cr);
 9454   ins_cost(300);
 9455   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9456           &quot;\tSAR    $dst.lo,$cnt-32\n&quot;
 9457           &quot;\tSAR    $dst.hi,31&quot; %}
 9458   opcode(0xC1, 0x7);  /* C1 /7 ib */
 9459   ins_encode( move_long_big_shift_sign(dst,cnt) );
 9460   ins_pipe( ialu_reg_long );
 9461 %}
 9462 
 9463 // Shift Right arithmetic Long by variable
 9464 instruct sarL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9465   match(Set dst (RShiftL dst shift));
 9466   effect(KILL cr);
 9467   ins_cost(600);
 9468   size(18);
 9469   format %{ &quot;TEST   $shift,32\n\t&quot;
 9470             &quot;JEQ,s  small\n\t&quot;
 9471             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9472             &quot;SAR    $dst.hi,31\n&quot;
 9473     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9474             &quot;SAR    $dst.hi,$shift&quot; %}
 9475   ins_encode( shift_right_arith_long( dst, shift ) );
 9476   ins_pipe( pipe_slow );
 9477 %}
 9478 
 9479 
 9480 //----------Double Instructions------------------------------------------------
 9481 // Double Math
 9482 
 9483 // Compare &amp; branch
 9484 
 9485 // P6 version of float compare, sets condition codes in EFLAGS
 9486 instruct cmpDPR_cc_P6(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9487   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9488   match(Set cr (CmpD src1 src2));
 9489   effect(KILL rax);
 9490   ins_cost(150);
 9491   format %{ &quot;FLD    $src1\n\t&quot;
 9492             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
 9493             &quot;JNP    exit\n\t&quot;
 9494             &quot;MOV    ah,1       // saw a NaN, set CF\n\t&quot;
 9495             &quot;SAHF\n&quot;
 9496      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
 9497   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9498   ins_encode( Push_Reg_DPR(src1),
 9499               OpcP, RegOpc(src2),
 9500               cmpF_P6_fixup );
 9501   ins_pipe( pipe_slow );
 9502 %}
 9503 
 9504 instruct cmpDPR_cc_P6CF(eFlagsRegUCF cr, regDPR src1, regDPR src2) %{
 9505   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9506   match(Set cr (CmpD src1 src2));
 9507   ins_cost(150);
 9508   format %{ &quot;FLD    $src1\n\t&quot;
 9509             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
 9510   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9511   ins_encode( Push_Reg_DPR(src1),
 9512               OpcP, RegOpc(src2));
 9513   ins_pipe( pipe_slow );
 9514 %}
 9515 
 9516 // Compare &amp; branch
 9517 instruct cmpDPR_cc(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9518   predicate(UseSSE&lt;=1);
 9519   match(Set cr (CmpD src1 src2));
 9520   effect(KILL rax);
 9521   ins_cost(200);
 9522   format %{ &quot;FLD    $src1\n\t&quot;
 9523             &quot;FCOMp  $src2\n\t&quot;
 9524             &quot;FNSTSW AX\n\t&quot;
 9525             &quot;TEST   AX,0x400\n\t&quot;
 9526             &quot;JZ,s   flags\n\t&quot;
 9527             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
 9528     &quot;flags:\tSAHF&quot; %}
 9529   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9530   ins_encode( Push_Reg_DPR(src1),
 9531               OpcP, RegOpc(src2),
 9532               fpu_flags);
 9533   ins_pipe( pipe_slow );
 9534 %}
 9535 
 9536 // Compare vs zero into -1,0,1
 9537 instruct cmpDPR_0(rRegI dst, regDPR src1, immDPR0 zero, eAXRegI rax, eFlagsReg cr) %{
 9538   predicate(UseSSE&lt;=1);
 9539   match(Set dst (CmpD3 src1 zero));
 9540   effect(KILL cr, KILL rax);
 9541   ins_cost(280);
 9542   format %{ &quot;FTSTD  $dst,$src1&quot; %}
 9543   opcode(0xE4, 0xD9);
 9544   ins_encode( Push_Reg_DPR(src1),
 9545               OpcS, OpcP, PopFPU,
 9546               CmpF_Result(dst));
 9547   ins_pipe( pipe_slow );
 9548 %}
 9549 
 9550 // Compare into -1,0,1
 9551 instruct cmpDPR_reg(rRegI dst, regDPR src1, regDPR src2, eAXRegI rax, eFlagsReg cr) %{
 9552   predicate(UseSSE&lt;=1);
 9553   match(Set dst (CmpD3 src1 src2));
 9554   effect(KILL cr, KILL rax);
 9555   ins_cost(300);
 9556   format %{ &quot;FCMPD  $dst,$src1,$src2&quot; %}
 9557   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9558   ins_encode( Push_Reg_DPR(src1),
 9559               OpcP, RegOpc(src2),
 9560               CmpF_Result(dst));
 9561   ins_pipe( pipe_slow );
 9562 %}
 9563 
 9564 // float compare and set condition codes in EFLAGS by XMM regs
 9565 instruct cmpD_cc(eFlagsRegU cr, regD src1, regD src2) %{
 9566   predicate(UseSSE&gt;=2);
 9567   match(Set cr (CmpD src1 src2));
 9568   ins_cost(145);
 9569   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9570             &quot;JNP,s   exit\n\t&quot;
 9571             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9572             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9573             &quot;POPF\n&quot;
 9574     &quot;exit:&quot; %}
 9575   ins_encode %{
 9576     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9577     emit_cmpfp_fixup(_masm);
 9578   %}
 9579   ins_pipe( pipe_slow );
 9580 %}
 9581 
 9582 instruct cmpD_ccCF(eFlagsRegUCF cr, regD src1, regD src2) %{
 9583   predicate(UseSSE&gt;=2);
 9584   match(Set cr (CmpD src1 src2));
 9585   ins_cost(100);
 9586   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9587   ins_encode %{
 9588     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9589   %}
 9590   ins_pipe( pipe_slow );
 9591 %}
 9592 
 9593 // float compare and set condition codes in EFLAGS by XMM regs
 9594 instruct cmpD_ccmem(eFlagsRegU cr, regD src1, memory src2) %{
 9595   predicate(UseSSE&gt;=2);
 9596   match(Set cr (CmpD src1 (LoadD src2)));
 9597   ins_cost(145);
 9598   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9599             &quot;JNP,s   exit\n\t&quot;
 9600             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9601             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9602             &quot;POPF\n&quot;
 9603     &quot;exit:&quot; %}
 9604   ins_encode %{
 9605     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9606     emit_cmpfp_fixup(_masm);
 9607   %}
 9608   ins_pipe( pipe_slow );
 9609 %}
 9610 
 9611 instruct cmpD_ccmemCF(eFlagsRegUCF cr, regD src1, memory src2) %{
 9612   predicate(UseSSE&gt;=2);
 9613   match(Set cr (CmpD src1 (LoadD src2)));
 9614   ins_cost(100);
 9615   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9616   ins_encode %{
 9617     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9618   %}
 9619   ins_pipe( pipe_slow );
 9620 %}
 9621 
 9622 // Compare into -1,0,1 in XMM
 9623 instruct cmpD_reg(xRegI dst, regD src1, regD src2, eFlagsReg cr) %{
 9624   predicate(UseSSE&gt;=2);
 9625   match(Set dst (CmpD3 src1 src2));
 9626   effect(KILL cr);
 9627   ins_cost(255);
 9628   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9629             &quot;MOV     $dst, #-1\n\t&quot;
 9630             &quot;JP,s    done\n\t&quot;
 9631             &quot;JB,s    done\n\t&quot;
 9632             &quot;SETNE   $dst\n\t&quot;
 9633             &quot;MOVZB   $dst, $dst\n&quot;
 9634     &quot;done:&quot; %}
 9635   ins_encode %{
 9636     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9637     emit_cmpfp3(_masm, $dst$$Register);
 9638   %}
 9639   ins_pipe( pipe_slow );
 9640 %}
 9641 
 9642 // Compare into -1,0,1 in XMM and memory
 9643 instruct cmpD_regmem(xRegI dst, regD src1, memory src2, eFlagsReg cr) %{
 9644   predicate(UseSSE&gt;=2);
 9645   match(Set dst (CmpD3 src1 (LoadD src2)));
 9646   effect(KILL cr);
 9647   ins_cost(275);
 9648   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9649             &quot;MOV     $dst, #-1\n\t&quot;
 9650             &quot;JP,s    done\n\t&quot;
 9651             &quot;JB,s    done\n\t&quot;
 9652             &quot;SETNE   $dst\n\t&quot;
 9653             &quot;MOVZB   $dst, $dst\n&quot;
 9654     &quot;done:&quot; %}
 9655   ins_encode %{
 9656     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9657     emit_cmpfp3(_masm, $dst$$Register);
 9658   %}
 9659   ins_pipe( pipe_slow );
 9660 %}
 9661 
 9662 
 9663 instruct subDPR_reg(regDPR dst, regDPR src) %{
 9664   predicate (UseSSE &lt;=1);
 9665   match(Set dst (SubD dst src));
 9666 
 9667   format %{ &quot;FLD    $src\n\t&quot;
 9668             &quot;DSUBp  $dst,ST&quot; %}
 9669   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
 9670   ins_cost(150);
 9671   ins_encode( Push_Reg_DPR(src),
 9672               OpcP, RegOpc(dst) );
 9673   ins_pipe( fpu_reg_reg );
 9674 %}
 9675 
 9676 instruct subDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9677   predicate (UseSSE &lt;=1);
 9678   match(Set dst (RoundDouble (SubD src1 src2)));
 9679   ins_cost(250);
 9680 
 9681   format %{ &quot;FLD    $src2\n\t&quot;
 9682             &quot;DSUB   ST,$src1\n\t&quot;
 9683             &quot;FSTP_D $dst\t# D-round&quot; %}
 9684   opcode(0xD8, 0x5);
 9685   ins_encode( Push_Reg_DPR(src2),
 9686               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9687   ins_pipe( fpu_mem_reg_reg );
 9688 %}
 9689 
 9690 
 9691 instruct subDPR_reg_mem(regDPR dst, memory src) %{
 9692   predicate (UseSSE &lt;=1);
 9693   match(Set dst (SubD dst (LoadD src)));
 9694   ins_cost(150);
 9695 
 9696   format %{ &quot;FLD    $src\n\t&quot;
 9697             &quot;DSUBp  $dst,ST&quot; %}
 9698   opcode(0xDE, 0x5, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9699   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9700               OpcP, RegOpc(dst) );
 9701   ins_pipe( fpu_reg_mem );
 9702 %}
 9703 
 9704 instruct absDPR_reg(regDPR1 dst, regDPR1 src) %{
 9705   predicate (UseSSE&lt;=1);
 9706   match(Set dst (AbsD src));
 9707   ins_cost(100);
 9708   format %{ &quot;FABS&quot; %}
 9709   opcode(0xE1, 0xD9);
 9710   ins_encode( OpcS, OpcP );
 9711   ins_pipe( fpu_reg_reg );
 9712 %}
 9713 
 9714 instruct negDPR_reg(regDPR1 dst, regDPR1 src) %{
 9715   predicate(UseSSE&lt;=1);
 9716   match(Set dst (NegD src));
 9717   ins_cost(100);
 9718   format %{ &quot;FCHS&quot; %}
 9719   opcode(0xE0, 0xD9);
 9720   ins_encode( OpcS, OpcP );
 9721   ins_pipe( fpu_reg_reg );
 9722 %}
 9723 
 9724 instruct addDPR_reg(regDPR dst, regDPR src) %{
 9725   predicate(UseSSE&lt;=1);
 9726   match(Set dst (AddD dst src));
 9727   format %{ &quot;FLD    $src\n\t&quot;
 9728             &quot;DADD   $dst,ST&quot; %}
 9729   size(4);
 9730   ins_cost(150);
 9731   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
 9732   ins_encode( Push_Reg_DPR(src),
 9733               OpcP, RegOpc(dst) );
 9734   ins_pipe( fpu_reg_reg );
 9735 %}
 9736 
 9737 
 9738 instruct addDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9739   predicate(UseSSE&lt;=1);
 9740   match(Set dst (RoundDouble (AddD src1 src2)));
 9741   ins_cost(250);
 9742 
 9743   format %{ &quot;FLD    $src2\n\t&quot;
 9744             &quot;DADD   ST,$src1\n\t&quot;
 9745             &quot;FSTP_D $dst\t# D-round&quot; %}
 9746   opcode(0xD8, 0x0); /* D8 C0+i or D8 /0*/
 9747   ins_encode( Push_Reg_DPR(src2),
 9748               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9749   ins_pipe( fpu_mem_reg_reg );
 9750 %}
 9751 
 9752 
 9753 instruct addDPR_reg_mem(regDPR dst, memory src) %{
 9754   predicate(UseSSE&lt;=1);
 9755   match(Set dst (AddD dst (LoadD src)));
 9756   ins_cost(150);
 9757 
 9758   format %{ &quot;FLD    $src\n\t&quot;
 9759             &quot;DADDp  $dst,ST&quot; %}
 9760   opcode(0xDE, 0x0, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9761   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9762               OpcP, RegOpc(dst) );
 9763   ins_pipe( fpu_reg_mem );
 9764 %}
 9765 
 9766 // add-to-memory
 9767 instruct addDPR_mem_reg(memory dst, regDPR src) %{
 9768   predicate(UseSSE&lt;=1);
 9769   match(Set dst (StoreD dst (RoundDouble (AddD (LoadD dst) src))));
 9770   ins_cost(150);
 9771 
 9772   format %{ &quot;FLD_D  $dst\n\t&quot;
 9773             &quot;DADD   ST,$src\n\t&quot;
 9774             &quot;FST_D  $dst&quot; %}
 9775   opcode(0xDD, 0x0);
 9776   ins_encode( Opcode(0xDD), RMopc_Mem(0x00,dst),
 9777               Opcode(0xD8), RegOpc(src),
 9778               set_instruction_start,
 9779               Opcode(0xDD), RMopc_Mem(0x03,dst) );
 9780   ins_pipe( fpu_reg_mem );
 9781 %}
 9782 
 9783 instruct addDPR_reg_imm1(regDPR dst, immDPR1 con) %{
 9784   predicate(UseSSE&lt;=1);
 9785   match(Set dst (AddD dst con));
 9786   ins_cost(125);
 9787   format %{ &quot;FLD1\n\t&quot;
 9788             &quot;DADDp  $dst,ST&quot; %}
 9789   ins_encode %{
 9790     __ fld1();
 9791     __ faddp($dst$$reg);
 9792   %}
 9793   ins_pipe(fpu_reg);
 9794 %}
 9795 
 9796 instruct addDPR_reg_imm(regDPR dst, immDPR con) %{
 9797   predicate(UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9798   match(Set dst (AddD dst con));
 9799   ins_cost(200);
 9800   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9801             &quot;DADDp  $dst,ST&quot; %}
 9802   ins_encode %{
 9803     __ fld_d($constantaddress($con));
 9804     __ faddp($dst$$reg);
 9805   %}
 9806   ins_pipe(fpu_reg_mem);
 9807 %}
 9808 
 9809 instruct addDPR_reg_imm_round(stackSlotD dst, regDPR src, immDPR con) %{
 9810   predicate(UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9811   match(Set dst (RoundDouble (AddD src con)));
 9812   ins_cost(200);
 9813   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9814             &quot;DADD   ST,$src\n\t&quot;
 9815             &quot;FSTP_D $dst\t# D-round&quot; %}
 9816   ins_encode %{
 9817     __ fld_d($constantaddress($con));
 9818     __ fadd($src$$reg);
 9819     __ fstp_d(Address(rsp, $dst$$disp));
 9820   %}
 9821   ins_pipe(fpu_mem_reg_con);
 9822 %}
 9823 
 9824 instruct mulDPR_reg(regDPR dst, regDPR src) %{
 9825   predicate(UseSSE&lt;=1);
 9826   match(Set dst (MulD dst src));
 9827   format %{ &quot;FLD    $src\n\t&quot;
 9828             &quot;DMULp  $dst,ST&quot; %}
 9829   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9830   ins_cost(150);
 9831   ins_encode( Push_Reg_DPR(src),
 9832               OpcP, RegOpc(dst) );
 9833   ins_pipe( fpu_reg_reg );
 9834 %}
 9835 
 9836 // Strict FP instruction biases argument before multiply then
 9837 // biases result to avoid double rounding of subnormals.
 9838 //
 9839 // scale arg1 by multiplying arg1 by 2^(-15360)
 9840 // load arg2
 9841 // multiply scaled arg1 by arg2
 9842 // rescale product by 2^(15360)
 9843 //
 9844 instruct strictfp_mulDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9845   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9846   match(Set dst (MulD dst src));
 9847   ins_cost(1);   // Select this instruction for all strict FP double multiplies
 9848 
 9849   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9850             &quot;DMULp  $dst,ST\n\t&quot;
 9851             &quot;FLD    $src\n\t&quot;
 9852             &quot;DMULp  $dst,ST\n\t&quot;
 9853             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9854             &quot;DMULp  $dst,ST\n\t&quot; %}
 9855   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9856   ins_encode( strictfp_bias1(dst),
 9857               Push_Reg_DPR(src),
 9858               OpcP, RegOpc(dst),
 9859               strictfp_bias2(dst) );
 9860   ins_pipe( fpu_reg_reg );
 9861 %}
 9862 
 9863 instruct mulDPR_reg_imm(regDPR dst, immDPR con) %{
 9864   predicate( UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9865   match(Set dst (MulD dst con));
 9866   ins_cost(200);
 9867   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9868             &quot;DMULp  $dst,ST&quot; %}
 9869   ins_encode %{
 9870     __ fld_d($constantaddress($con));
 9871     __ fmulp($dst$$reg);
 9872   %}
 9873   ins_pipe(fpu_reg_mem);
 9874 %}
 9875 
 9876 
 9877 instruct mulDPR_reg_mem(regDPR dst, memory src) %{
 9878   predicate( UseSSE&lt;=1 );
 9879   match(Set dst (MulD dst (LoadD src)));
 9880   ins_cost(200);
 9881   format %{ &quot;FLD_D  $src\n\t&quot;
 9882             &quot;DMULp  $dst,ST&quot; %}
 9883   opcode(0xDE, 0x1, 0xDD); /* DE C8+i or DE /1*/  /* LoadD  DD /0 */
 9884   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9885               OpcP, RegOpc(dst) );
 9886   ins_pipe( fpu_reg_mem );
 9887 %}
 9888 
 9889 //
 9890 // Cisc-alternate to reg-reg multiply
 9891 instruct mulDPR_reg_mem_cisc(regDPR dst, regDPR src, memory mem) %{
 9892   predicate( UseSSE&lt;=1 );
 9893   match(Set dst (MulD src (LoadD mem)));
 9894   ins_cost(250);
 9895   format %{ &quot;FLD_D  $mem\n\t&quot;
 9896             &quot;DMUL   ST,$src\n\t&quot;
 9897             &quot;FSTP_D $dst&quot; %}
 9898   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadD D9 /0 */
 9899   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem),
 9900               OpcReg_FPR(src),
 9901               Pop_Reg_DPR(dst) );
 9902   ins_pipe( fpu_reg_reg_mem );
 9903 %}
 9904 
 9905 
 9906 // MACRO3 -- addDPR a mulDPR
 9907 // This instruction is a &#39;2-address&#39; instruction in that the result goes
 9908 // back to src2.  This eliminates a move from the macro; possibly the
 9909 // register allocator will have to add it back (and maybe not).
 9910 instruct addDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9911   predicate( UseSSE&lt;=1 );
 9912   match(Set src2 (AddD (MulD src0 src1) src2));
 9913   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9914             &quot;DMUL   ST,$src1\n\t&quot;
 9915             &quot;DADDp  $src2,ST&quot; %}
 9916   ins_cost(250);
 9917   opcode(0xDD); /* LoadD DD /0 */
 9918   ins_encode( Push_Reg_FPR(src0),
 9919               FMul_ST_reg(src1),
 9920               FAddP_reg_ST(src2) );
 9921   ins_pipe( fpu_reg_reg_reg );
 9922 %}
 9923 
 9924 
 9925 // MACRO3 -- subDPR a mulDPR
 9926 instruct subDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9927   predicate( UseSSE&lt;=1 );
 9928   match(Set src2 (SubD (MulD src0 src1) src2));
 9929   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9930             &quot;DMUL   ST,$src1\n\t&quot;
 9931             &quot;DSUBRp $src2,ST&quot; %}
 9932   ins_cost(250);
 9933   ins_encode( Push_Reg_FPR(src0),
 9934               FMul_ST_reg(src1),
 9935               Opcode(0xDE), Opc_plus(0xE0,src2));
 9936   ins_pipe( fpu_reg_reg_reg );
 9937 %}
 9938 
 9939 
 9940 instruct divDPR_reg(regDPR dst, regDPR src) %{
 9941   predicate( UseSSE&lt;=1 );
 9942   match(Set dst (DivD dst src));
 9943 
 9944   format %{ &quot;FLD    $src\n\t&quot;
 9945             &quot;FDIVp  $dst,ST&quot; %}
 9946   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9947   ins_cost(150);
 9948   ins_encode( Push_Reg_DPR(src),
 9949               OpcP, RegOpc(dst) );
 9950   ins_pipe( fpu_reg_reg );
 9951 %}
 9952 
 9953 // Strict FP instruction biases argument before division then
 9954 // biases result, to avoid double rounding of subnormals.
 9955 //
 9956 // scale dividend by multiplying dividend by 2^(-15360)
 9957 // load divisor
 9958 // divide scaled dividend by divisor
 9959 // rescale quotient by 2^(15360)
 9960 //
 9961 instruct strictfp_divDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9962   predicate (UseSSE&lt;=1);
 9963   match(Set dst (DivD dst src));
 9964   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9965   ins_cost(01);
 9966 
 9967   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9968             &quot;DMULp  $dst,ST\n\t&quot;
 9969             &quot;FLD    $src\n\t&quot;
 9970             &quot;FDIVp  $dst,ST\n\t&quot;
 9971             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9972             &quot;DMULp  $dst,ST\n\t&quot; %}
 9973   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9974   ins_encode( strictfp_bias1(dst),
 9975               Push_Reg_DPR(src),
 9976               OpcP, RegOpc(dst),
 9977               strictfp_bias2(dst) );
 9978   ins_pipe( fpu_reg_reg );
 9979 %}
 9980 
 9981 instruct divDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9982   predicate( UseSSE&lt;=1 &amp;&amp; !(Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict()) );
 9983   match(Set dst (RoundDouble (DivD src1 src2)));
 9984 
 9985   format %{ &quot;FLD    $src1\n\t&quot;
 9986             &quot;FDIV   ST,$src2\n\t&quot;
 9987             &quot;FSTP_D $dst\t# D-round&quot; %}
 9988   opcode(0xD8, 0x6); /* D8 F0+i or D8 /6 */
 9989   ins_encode( Push_Reg_DPR(src1),
 9990               OpcP, RegOpc(src2), Pop_Mem_DPR(dst) );
 9991   ins_pipe( fpu_mem_reg_reg );
 9992 %}
 9993 
 9994 
 9995 instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{
 9996   predicate(UseSSE&lt;=1);
 9997   match(Set dst (ModD dst src));
 9998   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
 9999 
10000   format %{ &quot;DMOD   $dst,$src&quot; %}
10001   ins_cost(250);
10002   ins_encode(Push_Reg_Mod_DPR(dst, src),
10003               emitModDPR(),
10004               Push_Result_Mod_DPR(src),
10005               Pop_Reg_DPR(dst));
10006   ins_pipe( pipe_slow );
10007 %}
10008 
10009 instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{
10010   predicate(UseSSE&gt;=2);
10011   match(Set dst (ModD src0 src1));
10012   effect(KILL rax, KILL cr);
10013 
10014   format %{ &quot;SUB    ESP,8\t # DMOD\n&quot;
10015           &quot;\tMOVSD  [ESP+0],$src1\n&quot;
10016           &quot;\tFLD_D  [ESP+0]\n&quot;
10017           &quot;\tMOVSD  [ESP+0],$src0\n&quot;
10018           &quot;\tFLD_D  [ESP+0]\n&quot;
10019      &quot;loop:\tFPREM\n&quot;
10020           &quot;\tFWAIT\n&quot;
10021           &quot;\tFNSTSW AX\n&quot;
10022           &quot;\tSAHF\n&quot;
10023           &quot;\tJP     loop\n&quot;
10024           &quot;\tFSTP_D [ESP+0]\n&quot;
10025           &quot;\tMOVSD  $dst,[ESP+0]\n&quot;
10026           &quot;\tADD    ESP,8\n&quot;
10027           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10028     %}
10029   ins_cost(250);
10030   ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);
10031   ins_pipe( pipe_slow );
10032 %}
10033 
10034 instruct atanDPR_reg(regDPR dst, regDPR src) %{
10035   predicate (UseSSE&lt;=1);
10036   match(Set dst(AtanD dst src));
10037   format %{ &quot;DATA   $dst,$src&quot; %}
10038   opcode(0xD9, 0xF3);
10039   ins_encode( Push_Reg_DPR(src),
10040               OpcP, OpcS, RegOpc(dst) );
10041   ins_pipe( pipe_slow );
10042 %}
10043 
10044 instruct atanD_reg(regD dst, regD src, eFlagsReg cr) %{
10045   predicate (UseSSE&gt;=2);
10046   match(Set dst(AtanD dst src));
10047   effect(KILL cr); // Push_{Src|Result}D() uses &quot;{SUB|ADD} ESP,8&quot;
10048   format %{ &quot;DATA   $dst,$src&quot; %}
10049   opcode(0xD9, 0xF3);
10050   ins_encode( Push_SrcD(src),
10051               OpcP, OpcS, Push_ResultD(dst) );
10052   ins_pipe( pipe_slow );
10053 %}
10054 
10055 instruct sqrtDPR_reg(regDPR dst, regDPR src) %{
10056   predicate (UseSSE&lt;=1);
10057   match(Set dst (SqrtD src));
10058   format %{ &quot;DSQRT  $dst,$src&quot; %}
10059   opcode(0xFA, 0xD9);
10060   ins_encode( Push_Reg_DPR(src),
10061               OpcS, OpcP, Pop_Reg_DPR(dst) );
10062   ins_pipe( pipe_slow );
10063 %}
10064 
10065 //-------------Float Instructions-------------------------------
10066 // Float Math
10067 
10068 // Code for float compare:
10069 //     fcompp();
10070 //     fwait(); fnstsw_ax();
10071 //     sahf();
10072 //     movl(dst, unordered_result);
10073 //     jcc(Assembler::parity, exit);
10074 //     movl(dst, less_result);
10075 //     jcc(Assembler::below, exit);
10076 //     movl(dst, equal_result);
10077 //     jcc(Assembler::equal, exit);
10078 //     movl(dst, greater_result);
10079 //   exit:
10080 
10081 // P6 version of float compare, sets condition codes in EFLAGS
10082 instruct cmpFPR_cc_P6(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10083   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10084   match(Set cr (CmpF src1 src2));
10085   effect(KILL rax);
10086   ins_cost(150);
10087   format %{ &quot;FLD    $src1\n\t&quot;
10088             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
10089             &quot;JNP    exit\n\t&quot;
10090             &quot;MOV    ah,1       // saw a NaN, set CF (treat as LT)\n\t&quot;
10091             &quot;SAHF\n&quot;
10092      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
10093   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10094   ins_encode( Push_Reg_DPR(src1),
10095               OpcP, RegOpc(src2),
10096               cmpF_P6_fixup );
10097   ins_pipe( pipe_slow );
10098 %}
10099 
10100 instruct cmpFPR_cc_P6CF(eFlagsRegUCF cr, regFPR src1, regFPR src2) %{
10101   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10102   match(Set cr (CmpF src1 src2));
10103   ins_cost(100);
10104   format %{ &quot;FLD    $src1\n\t&quot;
10105             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
10106   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10107   ins_encode( Push_Reg_DPR(src1),
10108               OpcP, RegOpc(src2));
10109   ins_pipe( pipe_slow );
10110 %}
10111 
10112 
10113 // Compare &amp; branch
10114 instruct cmpFPR_cc(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10115   predicate(UseSSE == 0);
10116   match(Set cr (CmpF src1 src2));
10117   effect(KILL rax);
10118   ins_cost(200);
10119   format %{ &quot;FLD    $src1\n\t&quot;
10120             &quot;FCOMp  $src2\n\t&quot;
10121             &quot;FNSTSW AX\n\t&quot;
10122             &quot;TEST   AX,0x400\n\t&quot;
10123             &quot;JZ,s   flags\n\t&quot;
10124             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
10125     &quot;flags:\tSAHF&quot; %}
10126   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10127   ins_encode( Push_Reg_DPR(src1),
10128               OpcP, RegOpc(src2),
10129               fpu_flags);
10130   ins_pipe( pipe_slow );
10131 %}
10132 
10133 // Compare vs zero into -1,0,1
10134 instruct cmpFPR_0(rRegI dst, regFPR src1, immFPR0 zero, eAXRegI rax, eFlagsReg cr) %{
10135   predicate(UseSSE == 0);
10136   match(Set dst (CmpF3 src1 zero));
10137   effect(KILL cr, KILL rax);
10138   ins_cost(280);
10139   format %{ &quot;FTSTF  $dst,$src1&quot; %}
10140   opcode(0xE4, 0xD9);
10141   ins_encode( Push_Reg_DPR(src1),
10142               OpcS, OpcP, PopFPU,
10143               CmpF_Result(dst));
10144   ins_pipe( pipe_slow );
10145 %}
10146 
10147 // Compare into -1,0,1
10148 instruct cmpFPR_reg(rRegI dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10149   predicate(UseSSE == 0);
10150   match(Set dst (CmpF3 src1 src2));
10151   effect(KILL cr, KILL rax);
10152   ins_cost(300);
10153   format %{ &quot;FCMPF  $dst,$src1,$src2&quot; %}
10154   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10155   ins_encode( Push_Reg_DPR(src1),
10156               OpcP, RegOpc(src2),
10157               CmpF_Result(dst));
10158   ins_pipe( pipe_slow );
10159 %}
10160 
10161 // float compare and set condition codes in EFLAGS by XMM regs
10162 instruct cmpF_cc(eFlagsRegU cr, regF src1, regF src2) %{
10163   predicate(UseSSE&gt;=1);
10164   match(Set cr (CmpF src1 src2));
10165   ins_cost(145);
10166   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10167             &quot;JNP,s   exit\n\t&quot;
10168             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10169             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10170             &quot;POPF\n&quot;
10171     &quot;exit:&quot; %}
10172   ins_encode %{
10173     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10174     emit_cmpfp_fixup(_masm);
10175   %}
10176   ins_pipe( pipe_slow );
10177 %}
10178 
10179 instruct cmpF_ccCF(eFlagsRegUCF cr, regF src1, regF src2) %{
10180   predicate(UseSSE&gt;=1);
10181   match(Set cr (CmpF src1 src2));
10182   ins_cost(100);
10183   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10184   ins_encode %{
10185     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10186   %}
10187   ins_pipe( pipe_slow );
10188 %}
10189 
10190 // float compare and set condition codes in EFLAGS by XMM regs
10191 instruct cmpF_ccmem(eFlagsRegU cr, regF src1, memory src2) %{
10192   predicate(UseSSE&gt;=1);
10193   match(Set cr (CmpF src1 (LoadF src2)));
10194   ins_cost(165);
10195   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10196             &quot;JNP,s   exit\n\t&quot;
10197             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10198             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10199             &quot;POPF\n&quot;
10200     &quot;exit:&quot; %}
10201   ins_encode %{
10202     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10203     emit_cmpfp_fixup(_masm);
10204   %}
10205   ins_pipe( pipe_slow );
10206 %}
10207 
10208 instruct cmpF_ccmemCF(eFlagsRegUCF cr, regF src1, memory src2) %{
10209   predicate(UseSSE&gt;=1);
10210   match(Set cr (CmpF src1 (LoadF src2)));
10211   ins_cost(100);
10212   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10213   ins_encode %{
10214     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10215   %}
10216   ins_pipe( pipe_slow );
10217 %}
10218 
10219 // Compare into -1,0,1 in XMM
10220 instruct cmpF_reg(xRegI dst, regF src1, regF src2, eFlagsReg cr) %{
10221   predicate(UseSSE&gt;=1);
10222   match(Set dst (CmpF3 src1 src2));
10223   effect(KILL cr);
10224   ins_cost(255);
10225   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10226             &quot;MOV     $dst, #-1\n\t&quot;
10227             &quot;JP,s    done\n\t&quot;
10228             &quot;JB,s    done\n\t&quot;
10229             &quot;SETNE   $dst\n\t&quot;
10230             &quot;MOVZB   $dst, $dst\n&quot;
10231     &quot;done:&quot; %}
10232   ins_encode %{
10233     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10234     emit_cmpfp3(_masm, $dst$$Register);
10235   %}
10236   ins_pipe( pipe_slow );
10237 %}
10238 
10239 // Compare into -1,0,1 in XMM and memory
10240 instruct cmpF_regmem(xRegI dst, regF src1, memory src2, eFlagsReg cr) %{
10241   predicate(UseSSE&gt;=1);
10242   match(Set dst (CmpF3 src1 (LoadF src2)));
10243   effect(KILL cr);
10244   ins_cost(275);
10245   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10246             &quot;MOV     $dst, #-1\n\t&quot;
10247             &quot;JP,s    done\n\t&quot;
10248             &quot;JB,s    done\n\t&quot;
10249             &quot;SETNE   $dst\n\t&quot;
10250             &quot;MOVZB   $dst, $dst\n&quot;
10251     &quot;done:&quot; %}
10252   ins_encode %{
10253     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10254     emit_cmpfp3(_masm, $dst$$Register);
10255   %}
10256   ins_pipe( pipe_slow );
10257 %}
10258 
10259 // Spill to obtain 24-bit precision
10260 instruct subFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10261   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10262   match(Set dst (SubF src1 src2));
10263 
10264   format %{ &quot;FSUB   $dst,$src1 - $src2&quot; %}
10265   opcode(0xD8, 0x4); /* D8 E0+i or D8 /4 mod==0x3 ;; result in TOS */
10266   ins_encode( Push_Reg_FPR(src1),
10267               OpcReg_FPR(src2),
10268               Pop_Mem_FPR(dst) );
10269   ins_pipe( fpu_mem_reg_reg );
10270 %}
10271 //
10272 // This instruction does not round to 24-bits
10273 instruct subFPR_reg(regFPR dst, regFPR src) %{
10274   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10275   match(Set dst (SubF dst src));
10276 
10277   format %{ &quot;FSUB   $dst,$src&quot; %}
10278   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
10279   ins_encode( Push_Reg_FPR(src),
10280               OpcP, RegOpc(dst) );
10281   ins_pipe( fpu_reg_reg );
10282 %}
10283 
10284 // Spill to obtain 24-bit precision
10285 instruct addFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10286   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10287   match(Set dst (AddF src1 src2));
10288 
10289   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10290   opcode(0xD8, 0x0); /* D8 C0+i */
10291   ins_encode( Push_Reg_FPR(src2),
10292               OpcReg_FPR(src1),
10293               Pop_Mem_FPR(dst) );
10294   ins_pipe( fpu_mem_reg_reg );
10295 %}
10296 //
10297 // This instruction does not round to 24-bits
10298 instruct addFPR_reg(regFPR dst, regFPR src) %{
10299   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10300   match(Set dst (AddF dst src));
10301 
10302   format %{ &quot;FLD    $src\n\t&quot;
10303             &quot;FADDp  $dst,ST&quot; %}
10304   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
10305   ins_encode( Push_Reg_FPR(src),
10306               OpcP, RegOpc(dst) );
10307   ins_pipe( fpu_reg_reg );
10308 %}
10309 
10310 instruct absFPR_reg(regFPR1 dst, regFPR1 src) %{
10311   predicate(UseSSE==0);
10312   match(Set dst (AbsF src));
10313   ins_cost(100);
10314   format %{ &quot;FABS&quot; %}
10315   opcode(0xE1, 0xD9);
10316   ins_encode( OpcS, OpcP );
10317   ins_pipe( fpu_reg_reg );
10318 %}
10319 
10320 instruct negFPR_reg(regFPR1 dst, regFPR1 src) %{
10321   predicate(UseSSE==0);
10322   match(Set dst (NegF src));
10323   ins_cost(100);
10324   format %{ &quot;FCHS&quot; %}
10325   opcode(0xE0, 0xD9);
10326   ins_encode( OpcS, OpcP );
10327   ins_pipe( fpu_reg_reg );
10328 %}
10329 
10330 // Cisc-alternate to addFPR_reg
10331 // Spill to obtain 24-bit precision
10332 instruct addFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10333   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10334   match(Set dst (AddF src1 (LoadF src2)));
10335 
10336   format %{ &quot;FLD    $src2\n\t&quot;
10337             &quot;FADD   ST,$src1\n\t&quot;
10338             &quot;FSTP_S $dst&quot; %}
10339   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10340   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10341               OpcReg_FPR(src1),
10342               Pop_Mem_FPR(dst) );
10343   ins_pipe( fpu_mem_reg_mem );
10344 %}
10345 //
10346 // Cisc-alternate to addFPR_reg
10347 // This instruction does not round to 24-bits
10348 instruct addFPR_reg_mem(regFPR dst, memory src) %{
10349   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10350   match(Set dst (AddF dst (LoadF src)));
10351 
10352   format %{ &quot;FADD   $dst,$src&quot; %}
10353   opcode(0xDE, 0x0, 0xD9); /* DE C0+i or DE /0*/  /* LoadF  D9 /0 */
10354   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
10355               OpcP, RegOpc(dst) );
10356   ins_pipe( fpu_reg_mem );
10357 %}
10358 
10359 // // Following two instructions for _222_mpegaudio
10360 // Spill to obtain 24-bit precision
10361 instruct addFPR24_mem_reg(stackSlotF dst, regFPR src2, memory src1 ) %{
10362   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10363   match(Set dst (AddF src1 src2));
10364 
10365   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10366   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10367   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src1),
10368               OpcReg_FPR(src2),
10369               Pop_Mem_FPR(dst) );
10370   ins_pipe( fpu_mem_reg_mem );
10371 %}
10372 
10373 // Cisc-spill variant
10374 // Spill to obtain 24-bit precision
10375 instruct addFPR24_mem_cisc(stackSlotF dst, memory src1, memory src2) %{
10376   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10377   match(Set dst (AddF src1 (LoadF src2)));
10378 
10379   format %{ &quot;FADD   $dst,$src1,$src2 cisc&quot; %}
10380   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10381   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10382               set_instruction_start,
10383               OpcP, RMopc_Mem(secondary,src1),
10384               Pop_Mem_FPR(dst) );
10385   ins_pipe( fpu_mem_mem_mem );
10386 %}
10387 
10388 // Spill to obtain 24-bit precision
10389 instruct addFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10390   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10391   match(Set dst (AddF src1 src2));
10392 
10393   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10394   opcode(0xD8, 0x0, 0xD9); /* D8 /0 */  /* LoadF  D9 /0 */
10395   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10396               set_instruction_start,
10397               OpcP, RMopc_Mem(secondary,src1),
10398               Pop_Mem_FPR(dst) );
10399   ins_pipe( fpu_mem_mem_mem );
10400 %}
10401 
10402 
10403 // Spill to obtain 24-bit precision
10404 instruct addFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10405   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10406   match(Set dst (AddF src con));
10407   format %{ &quot;FLD    $src\n\t&quot;
10408             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10409             &quot;FSTP_S $dst&quot;  %}
10410   ins_encode %{
10411     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10412     __ fadd_s($constantaddress($con));
10413     __ fstp_s(Address(rsp, $dst$$disp));
10414   %}
10415   ins_pipe(fpu_mem_reg_con);
10416 %}
10417 //
10418 // This instruction does not round to 24-bits
10419 instruct addFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10420   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10421   match(Set dst (AddF src con));
10422   format %{ &quot;FLD    $src\n\t&quot;
10423             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10424             &quot;FSTP   $dst&quot;  %}
10425   ins_encode %{
10426     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10427     __ fadd_s($constantaddress($con));
10428     __ fstp_d($dst$$reg);
10429   %}
10430   ins_pipe(fpu_reg_reg_con);
10431 %}
10432 
10433 // Spill to obtain 24-bit precision
10434 instruct mulFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10435   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10436   match(Set dst (MulF src1 src2));
10437 
10438   format %{ &quot;FLD    $src1\n\t&quot;
10439             &quot;FMUL   $src2\n\t&quot;
10440             &quot;FSTP_S $dst&quot;  %}
10441   opcode(0xD8, 0x1); /* D8 C8+i or D8 /1 ;; result in TOS */
10442   ins_encode( Push_Reg_FPR(src1),
10443               OpcReg_FPR(src2),
10444               Pop_Mem_FPR(dst) );
10445   ins_pipe( fpu_mem_reg_reg );
10446 %}
10447 //
10448 // This instruction does not round to 24-bits
10449 instruct mulFPR_reg(regFPR dst, regFPR src1, regFPR src2) %{
10450   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10451   match(Set dst (MulF src1 src2));
10452 
10453   format %{ &quot;FLD    $src1\n\t&quot;
10454             &quot;FMUL   $src2\n\t&quot;
10455             &quot;FSTP_S $dst&quot;  %}
10456   opcode(0xD8, 0x1); /* D8 C8+i */
10457   ins_encode( Push_Reg_FPR(src2),
10458               OpcReg_FPR(src1),
10459               Pop_Reg_FPR(dst) );
10460   ins_pipe( fpu_reg_reg_reg );
10461 %}
10462 
10463 
10464 // Spill to obtain 24-bit precision
10465 // Cisc-alternate to reg-reg multiply
10466 instruct mulFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10467   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10468   match(Set dst (MulF src1 (LoadF src2)));
10469 
10470   format %{ &quot;FLD_S  $src2\n\t&quot;
10471             &quot;FMUL   $src1\n\t&quot;
10472             &quot;FSTP_S $dst&quot;  %}
10473   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or DE /1*/  /* LoadF D9 /0 */
10474   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10475               OpcReg_FPR(src1),
10476               Pop_Mem_FPR(dst) );
10477   ins_pipe( fpu_mem_reg_mem );
10478 %}
10479 //
10480 // This instruction does not round to 24-bits
10481 // Cisc-alternate to reg-reg multiply
10482 instruct mulFPR_reg_mem(regFPR dst, regFPR src1, memory src2) %{
10483   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10484   match(Set dst (MulF src1 (LoadF src2)));
10485 
10486   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10487   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadF D9 /0 */
10488   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10489               OpcReg_FPR(src1),
10490               Pop_Reg_FPR(dst) );
10491   ins_pipe( fpu_reg_reg_mem );
10492 %}
10493 
10494 // Spill to obtain 24-bit precision
10495 instruct mulFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10496   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10497   match(Set dst (MulF src1 src2));
10498 
10499   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10500   opcode(0xD8, 0x1, 0xD9); /* D8 /1 */  /* LoadF D9 /0 */
10501   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10502               set_instruction_start,
10503               OpcP, RMopc_Mem(secondary,src1),
10504               Pop_Mem_FPR(dst) );
10505   ins_pipe( fpu_mem_mem_mem );
10506 %}
10507 
10508 // Spill to obtain 24-bit precision
10509 instruct mulFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10510   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10511   match(Set dst (MulF src con));
10512 
10513   format %{ &quot;FLD    $src\n\t&quot;
10514             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10515             &quot;FSTP_S $dst&quot;  %}
10516   ins_encode %{
10517     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10518     __ fmul_s($constantaddress($con));
10519     __ fstp_s(Address(rsp, $dst$$disp));
10520   %}
10521   ins_pipe(fpu_mem_reg_con);
10522 %}
10523 //
10524 // This instruction does not round to 24-bits
10525 instruct mulFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10526   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10527   match(Set dst (MulF src con));
10528 
10529   format %{ &quot;FLD    $src\n\t&quot;
10530             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10531             &quot;FSTP   $dst&quot;  %}
10532   ins_encode %{
10533     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10534     __ fmul_s($constantaddress($con));
10535     __ fstp_d($dst$$reg);
10536   %}
10537   ins_pipe(fpu_reg_reg_con);
10538 %}
10539 
10540 
10541 //
10542 // MACRO1 -- subsume unshared load into mulFPR
10543 // This instruction does not round to 24-bits
10544 instruct mulFPR_reg_load1(regFPR dst, regFPR src, memory mem1 ) %{
10545   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10546   match(Set dst (MulF (LoadF mem1) src));
10547 
10548   format %{ &quot;FLD    $mem1    ===MACRO1===\n\t&quot;
10549             &quot;FMUL   ST,$src\n\t&quot;
10550             &quot;FSTP   $dst&quot; %}
10551   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or D8 /1 */  /* LoadF D9 /0 */
10552   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem1),
10553               OpcReg_FPR(src),
10554               Pop_Reg_FPR(dst) );
10555   ins_pipe( fpu_reg_reg_mem );
10556 %}
10557 //
10558 // MACRO2 -- addFPR a mulFPR which subsumed an unshared load
10559 // This instruction does not round to 24-bits
10560 instruct addFPR_mulFPR_reg_load1(regFPR dst, memory mem1, regFPR src1, regFPR src2) %{
10561   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10562   match(Set dst (AddF (MulF (LoadF mem1) src1) src2));
10563   ins_cost(95);
10564 
10565   format %{ &quot;FLD    $mem1     ===MACRO2===\n\t&quot;
10566             &quot;FMUL   ST,$src1  subsume mulFPR left load\n\t&quot;
10567             &quot;FADD   ST,$src2\n\t&quot;
10568             &quot;FSTP   $dst&quot; %}
10569   opcode(0xD9); /* LoadF D9 /0 */
10570   ins_encode( OpcP, RMopc_Mem(0x00,mem1),
10571               FMul_ST_reg(src1),
10572               FAdd_ST_reg(src2),
10573               Pop_Reg_FPR(dst) );
10574   ins_pipe( fpu_reg_mem_reg_reg );
10575 %}
10576 
10577 // MACRO3 -- addFPR a mulFPR
10578 // This instruction does not round to 24-bits.  It is a &#39;2-address&#39;
10579 // instruction in that the result goes back to src2.  This eliminates
10580 // a move from the macro; possibly the register allocator will have
10581 // to add it back (and maybe not).
10582 instruct addFPR_mulFPR_reg(regFPR src2, regFPR src1, regFPR src0) %{
10583   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10584   match(Set src2 (AddF (MulF src0 src1) src2));
10585 
10586   format %{ &quot;FLD    $src0     ===MACRO3===\n\t&quot;
10587             &quot;FMUL   ST,$src1\n\t&quot;
10588             &quot;FADDP  $src2,ST&quot; %}
10589   opcode(0xD9); /* LoadF D9 /0 */
10590   ins_encode( Push_Reg_FPR(src0),
10591               FMul_ST_reg(src1),
10592               FAddP_reg_ST(src2) );
10593   ins_pipe( fpu_reg_reg_reg );
10594 %}
10595 
10596 // MACRO4 -- divFPR subFPR
10597 // This instruction does not round to 24-bits
10598 instruct subFPR_divFPR_reg(regFPR dst, regFPR src1, regFPR src2, regFPR src3) %{
10599   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10600   match(Set dst (DivF (SubF src2 src1) src3));
10601 
10602   format %{ &quot;FLD    $src2   ===MACRO4===\n\t&quot;
10603             &quot;FSUB   ST,$src1\n\t&quot;
10604             &quot;FDIV   ST,$src3\n\t&quot;
10605             &quot;FSTP  $dst&quot; %}
10606   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10607   ins_encode( Push_Reg_FPR(src2),
10608               subFPR_divFPR_encode(src1,src3),
10609               Pop_Reg_FPR(dst) );
10610   ins_pipe( fpu_reg_reg_reg_reg );
10611 %}
10612 
10613 // Spill to obtain 24-bit precision
10614 instruct divFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10615   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10616   match(Set dst (DivF src1 src2));
10617 
10618   format %{ &quot;FDIV   $dst,$src1,$src2&quot; %}
10619   opcode(0xD8, 0x6); /* D8 F0+i or DE /6*/
10620   ins_encode( Push_Reg_FPR(src1),
10621               OpcReg_FPR(src2),
10622               Pop_Mem_FPR(dst) );
10623   ins_pipe( fpu_mem_reg_reg );
10624 %}
10625 //
10626 // This instruction does not round to 24-bits
10627 instruct divFPR_reg(regFPR dst, regFPR src) %{
10628   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10629   match(Set dst (DivF dst src));
10630 
10631   format %{ &quot;FDIV   $dst,$src&quot; %}
10632   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10633   ins_encode( Push_Reg_FPR(src),
10634               OpcP, RegOpc(dst) );
10635   ins_pipe( fpu_reg_reg );
10636 %}
10637 
10638 
10639 // Spill to obtain 24-bit precision
10640 instruct modFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10641   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10642   match(Set dst (ModF src1 src2));
10643   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10644 
10645   format %{ &quot;FMOD   $dst,$src1,$src2&quot; %}
10646   ins_encode( Push_Reg_Mod_DPR(src1, src2),
10647               emitModDPR(),
10648               Push_Result_Mod_DPR(src2),
10649               Pop_Mem_FPR(dst));
10650   ins_pipe( pipe_slow );
10651 %}
10652 //
10653 // This instruction does not round to 24-bits
10654 instruct modFPR_reg(regFPR dst, regFPR src, eAXRegI rax, eFlagsReg cr) %{
10655   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10656   match(Set dst (ModF dst src));
10657   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10658 
10659   format %{ &quot;FMOD   $dst,$src&quot; %}
10660   ins_encode(Push_Reg_Mod_DPR(dst, src),
10661               emitModDPR(),
10662               Push_Result_Mod_DPR(src),
10663               Pop_Reg_FPR(dst));
10664   ins_pipe( pipe_slow );
10665 %}
10666 
10667 instruct modF_reg(regF dst, regF src0, regF src1, eAXRegI rax, eFlagsReg cr) %{
10668   predicate(UseSSE&gt;=1);
10669   match(Set dst (ModF src0 src1));
10670   effect(KILL rax, KILL cr);
10671   format %{ &quot;SUB    ESP,4\t # FMOD\n&quot;
10672           &quot;\tMOVSS  [ESP+0],$src1\n&quot;
10673           &quot;\tFLD_S  [ESP+0]\n&quot;
10674           &quot;\tMOVSS  [ESP+0],$src0\n&quot;
10675           &quot;\tFLD_S  [ESP+0]\n&quot;
10676      &quot;loop:\tFPREM\n&quot;
10677           &quot;\tFWAIT\n&quot;
10678           &quot;\tFNSTSW AX\n&quot;
10679           &quot;\tSAHF\n&quot;
10680           &quot;\tJP     loop\n&quot;
10681           &quot;\tFSTP_S [ESP+0]\n&quot;
10682           &quot;\tMOVSS  $dst,[ESP+0]\n&quot;
10683           &quot;\tADD    ESP,4\n&quot;
10684           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10685     %}
10686   ins_cost(250);
10687   ins_encode( Push_ModF_encoding(src0, src1), emitModDPR(), Push_ResultF(dst,0x4), PopFPU);
10688   ins_pipe( pipe_slow );
10689 %}
10690 
10691 
10692 //----------Arithmetic Conversion Instructions---------------------------------
10693 // The conversions operations are all Alpha sorted.  Please keep it that way!
10694 
10695 instruct roundFloat_mem_reg(stackSlotF dst, regFPR src) %{
10696   predicate(UseSSE==0);
10697   match(Set dst (RoundFloat src));
10698   ins_cost(125);
10699   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10700   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
10701   ins_pipe( fpu_mem_reg );
10702 %}
10703 
10704 instruct roundDouble_mem_reg(stackSlotD dst, regDPR src) %{
10705   predicate(UseSSE&lt;=1);
10706   match(Set dst (RoundDouble src));
10707   ins_cost(125);
10708   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10709   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
10710   ins_pipe( fpu_mem_reg );
10711 %}
10712 
10713 // Force rounding to 24-bit precision and 6-bit exponent
10714 instruct convDPR2FPR_reg(stackSlotF dst, regDPR src) %{
10715   predicate(UseSSE==0);
10716   match(Set dst (ConvD2F src));
10717   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10718   expand %{
10719     roundFloat_mem_reg(dst,src);
10720   %}
10721 %}
10722 
10723 // Force rounding to 24-bit precision and 6-bit exponent
10724 instruct convDPR2F_reg(regF dst, regDPR src, eFlagsReg cr) %{
10725   predicate(UseSSE==1);
10726   match(Set dst (ConvD2F src));
10727   effect( KILL cr );
10728   format %{ &quot;SUB    ESP,4\n\t&quot;
10729             &quot;FST_S  [ESP],$src\t# F-round\n\t&quot;
10730             &quot;MOVSS  $dst,[ESP]\n\t&quot;
10731             &quot;ADD ESP,4&quot; %}
10732   ins_encode %{
10733     __ subptr(rsp, 4);
10734     if ($src$$reg != FPR1L_enc) {
10735       __ fld_s($src$$reg-1);
10736       __ fstp_s(Address(rsp, 0));
10737     } else {
10738       __ fst_s(Address(rsp, 0));
10739     }
10740     __ movflt($dst$$XMMRegister, Address(rsp, 0));
10741     __ addptr(rsp, 4);
10742   %}
10743   ins_pipe( pipe_slow );
10744 %}
10745 
10746 // Force rounding double precision to single precision
10747 instruct convD2F_reg(regF dst, regD src) %{
10748   predicate(UseSSE&gt;=2);
10749   match(Set dst (ConvD2F src));
10750   format %{ &quot;CVTSD2SS $dst,$src\t# F-round&quot; %}
10751   ins_encode %{
10752     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10753   %}
10754   ins_pipe( pipe_slow );
10755 %}
10756 
10757 instruct convFPR2DPR_reg_reg(regDPR dst, regFPR src) %{
10758   predicate(UseSSE==0);
10759   match(Set dst (ConvF2D src));
10760   format %{ &quot;FST_S  $dst,$src\t# D-round&quot; %}
10761   ins_encode( Pop_Reg_Reg_DPR(dst, src));
10762   ins_pipe( fpu_reg_reg );
10763 %}
10764 
10765 instruct convFPR2D_reg(stackSlotD dst, regFPR src) %{
10766   predicate(UseSSE==1);
10767   match(Set dst (ConvF2D src));
10768   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10769   expand %{
10770     roundDouble_mem_reg(dst,src);
10771   %}
10772 %}
10773 
10774 instruct convF2DPR_reg(regDPR dst, regF src, eFlagsReg cr) %{
10775   predicate(UseSSE==1);
10776   match(Set dst (ConvF2D src));
10777   effect( KILL cr );
10778   format %{ &quot;SUB    ESP,4\n\t&quot;
10779             &quot;MOVSS  [ESP] $src\n\t&quot;
10780             &quot;FLD_S  [ESP]\n\t&quot;
10781             &quot;ADD    ESP,4\n\t&quot;
10782             &quot;FSTP   $dst\t# D-round&quot; %}
10783   ins_encode %{
10784     __ subptr(rsp, 4);
10785     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10786     __ fld_s(Address(rsp, 0));
10787     __ addptr(rsp, 4);
10788     __ fstp_d($dst$$reg);
10789   %}
10790   ins_pipe( pipe_slow );
10791 %}
10792 
10793 instruct convF2D_reg(regD dst, regF src) %{
10794   predicate(UseSSE&gt;=2);
10795   match(Set dst (ConvF2D src));
10796   format %{ &quot;CVTSS2SD $dst,$src\t# D-round&quot; %}
10797   ins_encode %{
10798     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10799   %}
10800   ins_pipe( pipe_slow );
10801 %}
10802 
10803 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10804 instruct convDPR2I_reg_reg( eAXRegI dst, eDXRegI tmp, regDPR src, eFlagsReg cr ) %{
10805   predicate(UseSSE&lt;=1);
10806   match(Set dst (ConvD2I src));
10807   effect( KILL tmp, KILL cr );
10808   format %{ &quot;FLD    $src\t# Convert double to int \n\t&quot;
10809             &quot;FLDCW  trunc mode\n\t&quot;
10810             &quot;SUB    ESP,4\n\t&quot;
10811             &quot;FISTp  [ESP + #0]\n\t&quot;
10812             &quot;FLDCW  std/24-bit mode\n\t&quot;
10813             &quot;POP    EAX\n\t&quot;
10814             &quot;CMP    EAX,0x80000000\n\t&quot;
10815             &quot;JNE,s  fast\n\t&quot;
10816             &quot;FLD_D  $src\n\t&quot;
10817             &quot;CALL   d2i_wrapper\n&quot;
10818       &quot;fast:&quot; %}
10819   ins_encode( Push_Reg_DPR(src), DPR2I_encoding(src) );
10820   ins_pipe( pipe_slow );
10821 %}
10822 
10823 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10824 instruct convD2I_reg_reg( eAXRegI dst, eDXRegI tmp, regD src, eFlagsReg cr ) %{
10825   predicate(UseSSE&gt;=2);
10826   match(Set dst (ConvD2I src));
10827   effect( KILL tmp, KILL cr );
10828   format %{ &quot;CVTTSD2SI $dst, $src\n\t&quot;
10829             &quot;CMP    $dst,0x80000000\n\t&quot;
10830             &quot;JNE,s  fast\n\t&quot;
10831             &quot;SUB    ESP, 8\n\t&quot;
10832             &quot;MOVSD  [ESP], $src\n\t&quot;
10833             &quot;FLD_D  [ESP]\n\t&quot;
10834             &quot;ADD    ESP, 8\n\t&quot;
10835             &quot;CALL   d2i_wrapper\n&quot;
10836       &quot;fast:&quot; %}
10837   ins_encode %{
10838     Label fast;
10839     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10840     __ cmpl($dst$$Register, 0x80000000);
10841     __ jccb(Assembler::notEqual, fast);
10842     __ subptr(rsp, 8);
10843     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10844     __ fld_d(Address(rsp, 0));
10845     __ addptr(rsp, 8);
10846     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10847     __ bind(fast);
10848   %}
10849   ins_pipe( pipe_slow );
10850 %}
10851 
10852 instruct convDPR2L_reg_reg( eADXRegL dst, regDPR src, eFlagsReg cr ) %{
10853   predicate(UseSSE&lt;=1);
10854   match(Set dst (ConvD2L src));
10855   effect( KILL cr );
10856   format %{ &quot;FLD    $src\t# Convert double to long\n\t&quot;
10857             &quot;FLDCW  trunc mode\n\t&quot;
10858             &quot;SUB    ESP,8\n\t&quot;
10859             &quot;FISTp  [ESP + #0]\n\t&quot;
10860             &quot;FLDCW  std/24-bit mode\n\t&quot;
10861             &quot;POP    EAX\n\t&quot;
10862             &quot;POP    EDX\n\t&quot;
10863             &quot;CMP    EDX,0x80000000\n\t&quot;
10864             &quot;JNE,s  fast\n\t&quot;
10865             &quot;TEST   EAX,EAX\n\t&quot;
10866             &quot;JNE,s  fast\n\t&quot;
10867             &quot;FLD    $src\n\t&quot;
10868             &quot;CALL   d2l_wrapper\n&quot;
10869       &quot;fast:&quot; %}
10870   ins_encode( Push_Reg_DPR(src),  DPR2L_encoding(src) );
10871   ins_pipe( pipe_slow );
10872 %}
10873 
10874 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
10875 instruct convD2L_reg_reg( eADXRegL dst, regD src, eFlagsReg cr ) %{
10876   predicate (UseSSE&gt;=2);
10877   match(Set dst (ConvD2L src));
10878   effect( KILL cr );
10879   format %{ &quot;SUB    ESP,8\t# Convert double to long\n\t&quot;
10880             &quot;MOVSD  [ESP],$src\n\t&quot;
10881             &quot;FLD_D  [ESP]\n\t&quot;
10882             &quot;FLDCW  trunc mode\n\t&quot;
10883             &quot;FISTp  [ESP + #0]\n\t&quot;
10884             &quot;FLDCW  std/24-bit mode\n\t&quot;
10885             &quot;POP    EAX\n\t&quot;
10886             &quot;POP    EDX\n\t&quot;
10887             &quot;CMP    EDX,0x80000000\n\t&quot;
10888             &quot;JNE,s  fast\n\t&quot;
10889             &quot;TEST   EAX,EAX\n\t&quot;
10890             &quot;JNE,s  fast\n\t&quot;
10891             &quot;SUB    ESP,8\n\t&quot;
10892             &quot;MOVSD  [ESP],$src\n\t&quot;
10893             &quot;FLD_D  [ESP]\n\t&quot;
10894             &quot;ADD    ESP,8\n\t&quot;
10895             &quot;CALL   d2l_wrapper\n&quot;
10896       &quot;fast:&quot; %}
10897   ins_encode %{
10898     Label fast;
10899     __ subptr(rsp, 8);
10900     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10901     __ fld_d(Address(rsp, 0));
10902     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
10903     __ fistp_d(Address(rsp, 0));
10904     // Restore the rounding mode, mask the exception
10905     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
10906       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
10907     } else {
10908       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
10909     }
10910     // Load the converted long, adjust CPU stack
10911     __ pop(rax);
10912     __ pop(rdx);
10913     __ cmpl(rdx, 0x80000000);
10914     __ jccb(Assembler::notEqual, fast);
10915     __ testl(rax, rax);
10916     __ jccb(Assembler::notEqual, fast);
10917     __ subptr(rsp, 8);
10918     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10919     __ fld_d(Address(rsp, 0));
10920     __ addptr(rsp, 8);
10921     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
10922     __ bind(fast);
10923   %}
10924   ins_pipe( pipe_slow );
10925 %}
10926 
10927 // Convert a double to an int.  Java semantics require we do complex
10928 // manglations in the corner cases.  So we set the rounding mode to
10929 // &#39;zero&#39;, store the darned double down as an int, and reset the
10930 // rounding mode to &#39;nearest&#39;.  The hardware stores a flag value down
10931 // if we would overflow or converted a NAN; we check for this and
10932 // and go the slow path if needed.
10933 instruct convFPR2I_reg_reg(eAXRegI dst, eDXRegI tmp, regFPR src, eFlagsReg cr ) %{
10934   predicate(UseSSE==0);
10935   match(Set dst (ConvF2I src));
10936   effect( KILL tmp, KILL cr );
10937   format %{ &quot;FLD    $src\t# Convert float to int \n\t&quot;
10938             &quot;FLDCW  trunc mode\n\t&quot;
10939             &quot;SUB    ESP,4\n\t&quot;
10940             &quot;FISTp  [ESP + #0]\n\t&quot;
10941             &quot;FLDCW  std/24-bit mode\n\t&quot;
10942             &quot;POP    EAX\n\t&quot;
10943             &quot;CMP    EAX,0x80000000\n\t&quot;
10944             &quot;JNE,s  fast\n\t&quot;
10945             &quot;FLD    $src\n\t&quot;
10946             &quot;CALL   d2i_wrapper\n&quot;
10947       &quot;fast:&quot; %}
10948   // DPR2I_encoding works for FPR2I
10949   ins_encode( Push_Reg_FPR(src), DPR2I_encoding(src) );
10950   ins_pipe( pipe_slow );
10951 %}
10952 
10953 // Convert a float in xmm to an int reg.
10954 instruct convF2I_reg(eAXRegI dst, eDXRegI tmp, regF src, eFlagsReg cr ) %{
10955   predicate(UseSSE&gt;=1);
10956   match(Set dst (ConvF2I src));
10957   effect( KILL tmp, KILL cr );
10958   format %{ &quot;CVTTSS2SI $dst, $src\n\t&quot;
10959             &quot;CMP    $dst,0x80000000\n\t&quot;
10960             &quot;JNE,s  fast\n\t&quot;
10961             &quot;SUB    ESP, 4\n\t&quot;
10962             &quot;MOVSS  [ESP], $src\n\t&quot;
10963             &quot;FLD    [ESP]\n\t&quot;
10964             &quot;ADD    ESP, 4\n\t&quot;
10965             &quot;CALL   d2i_wrapper\n&quot;
10966       &quot;fast:&quot; %}
10967   ins_encode %{
10968     Label fast;
10969     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
10970     __ cmpl($dst$$Register, 0x80000000);
10971     __ jccb(Assembler::notEqual, fast);
10972     __ subptr(rsp, 4);
10973     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10974     __ fld_s(Address(rsp, 0));
10975     __ addptr(rsp, 4);
10976     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10977     __ bind(fast);
10978   %}
10979   ins_pipe( pipe_slow );
10980 %}
10981 
10982 instruct convFPR2L_reg_reg( eADXRegL dst, regFPR src, eFlagsReg cr ) %{
10983   predicate(UseSSE==0);
10984   match(Set dst (ConvF2L src));
10985   effect( KILL cr );
10986   format %{ &quot;FLD    $src\t# Convert float to long\n\t&quot;
10987             &quot;FLDCW  trunc mode\n\t&quot;
10988             &quot;SUB    ESP,8\n\t&quot;
10989             &quot;FISTp  [ESP + #0]\n\t&quot;
10990             &quot;FLDCW  std/24-bit mode\n\t&quot;
10991             &quot;POP    EAX\n\t&quot;
10992             &quot;POP    EDX\n\t&quot;
10993             &quot;CMP    EDX,0x80000000\n\t&quot;
10994             &quot;JNE,s  fast\n\t&quot;
10995             &quot;TEST   EAX,EAX\n\t&quot;
10996             &quot;JNE,s  fast\n\t&quot;
10997             &quot;FLD    $src\n\t&quot;
10998             &quot;CALL   d2l_wrapper\n&quot;
10999       &quot;fast:&quot; %}
11000   // DPR2L_encoding works for FPR2L
11001   ins_encode( Push_Reg_FPR(src), DPR2L_encoding(src) );
11002   ins_pipe( pipe_slow );
11003 %}
11004 
11005 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
11006 instruct convF2L_reg_reg( eADXRegL dst, regF src, eFlagsReg cr ) %{
11007   predicate (UseSSE&gt;=1);
11008   match(Set dst (ConvF2L src));
11009   effect( KILL cr );
11010   format %{ &quot;SUB    ESP,8\t# Convert float to long\n\t&quot;
11011             &quot;MOVSS  [ESP],$src\n\t&quot;
11012             &quot;FLD_S  [ESP]\n\t&quot;
11013             &quot;FLDCW  trunc mode\n\t&quot;
11014             &quot;FISTp  [ESP + #0]\n\t&quot;
11015             &quot;FLDCW  std/24-bit mode\n\t&quot;
11016             &quot;POP    EAX\n\t&quot;
11017             &quot;POP    EDX\n\t&quot;
11018             &quot;CMP    EDX,0x80000000\n\t&quot;
11019             &quot;JNE,s  fast\n\t&quot;
11020             &quot;TEST   EAX,EAX\n\t&quot;
11021             &quot;JNE,s  fast\n\t&quot;
11022             &quot;SUB    ESP,4\t# Convert float to long\n\t&quot;
11023             &quot;MOVSS  [ESP],$src\n\t&quot;
11024             &quot;FLD_S  [ESP]\n\t&quot;
11025             &quot;ADD    ESP,4\n\t&quot;
11026             &quot;CALL   d2l_wrapper\n&quot;
11027       &quot;fast:&quot; %}
11028   ins_encode %{
11029     Label fast;
11030     __ subptr(rsp, 8);
11031     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11032     __ fld_s(Address(rsp, 0));
11033     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
11034     __ fistp_d(Address(rsp, 0));
11035     // Restore the rounding mode, mask the exception
11036     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
11037       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
11038     } else {
11039       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
11040     }
11041     // Load the converted long, adjust CPU stack
11042     __ pop(rax);
11043     __ pop(rdx);
11044     __ cmpl(rdx, 0x80000000);
11045     __ jccb(Assembler::notEqual, fast);
11046     __ testl(rax, rax);
11047     __ jccb(Assembler::notEqual, fast);
11048     __ subptr(rsp, 4);
11049     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11050     __ fld_s(Address(rsp, 0));
11051     __ addptr(rsp, 4);
11052     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
11053     __ bind(fast);
11054   %}
11055   ins_pipe( pipe_slow );
11056 %}
11057 
11058 instruct convI2DPR_reg(regDPR dst, stackSlotI src) %{
11059   predicate( UseSSE&lt;=1 );
11060   match(Set dst (ConvI2D src));
11061   format %{ &quot;FILD   $src\n\t&quot;
11062             &quot;FSTP   $dst&quot; %}
11063   opcode(0xDB, 0x0);  /* DB /0 */
11064   ins_encode(Push_Mem_I(src), Pop_Reg_DPR(dst));
11065   ins_pipe( fpu_reg_mem );
11066 %}
11067 
11068 instruct convI2D_reg(regD dst, rRegI src) %{
11069   predicate( UseSSE&gt;=2 &amp;&amp; !UseXmmI2D );
11070   match(Set dst (ConvI2D src));
11071   format %{ &quot;CVTSI2SD $dst,$src&quot; %}
11072   ins_encode %{
11073     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
11074   %}
11075   ins_pipe( pipe_slow );
11076 %}
11077 
11078 instruct convI2D_mem(regD dst, memory mem) %{
11079   predicate( UseSSE&gt;=2 );
11080   match(Set dst (ConvI2D (LoadI mem)));
11081   format %{ &quot;CVTSI2SD $dst,$mem&quot; %}
11082   ins_encode %{
11083     __ cvtsi2sdl ($dst$$XMMRegister, $mem$$Address);
11084   %}
11085   ins_pipe( pipe_slow );
11086 %}
11087 
11088 instruct convXI2D_reg(regD dst, rRegI src)
11089 %{
11090   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2D );
11091   match(Set dst (ConvI2D src));
11092 
11093   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11094             &quot;CVTDQ2PD $dst,$dst\t# i2d&quot; %}
11095   ins_encode %{
11096     __ movdl($dst$$XMMRegister, $src$$Register);
11097     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
11098   %}
11099   ins_pipe(pipe_slow); // XXX
11100 %}
11101 
11102 instruct convI2DPR_mem(regDPR dst, memory mem) %{
11103   predicate( UseSSE&lt;=1 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11104   match(Set dst (ConvI2D (LoadI mem)));
11105   format %{ &quot;FILD   $mem\n\t&quot;
11106             &quot;FSTP   $dst&quot; %}
11107   opcode(0xDB);      /* DB /0 */
11108   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11109               Pop_Reg_DPR(dst));
11110   ins_pipe( fpu_reg_mem );
11111 %}
11112 
11113 // Convert a byte to a float; no rounding step needed.
11114 instruct conv24I2FPR_reg(regFPR dst, stackSlotI src) %{
11115   predicate( UseSSE==0 &amp;&amp; n-&gt;in(1)-&gt;Opcode() == Op_AndI &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;get_int() == 255 );
11116   match(Set dst (ConvI2F src));
11117   format %{ &quot;FILD   $src\n\t&quot;
11118             &quot;FSTP   $dst&quot; %}
11119 
11120   opcode(0xDB, 0x0);  /* DB /0 */
11121   ins_encode(Push_Mem_I(src), Pop_Reg_FPR(dst));
11122   ins_pipe( fpu_reg_mem );
11123 %}
11124 
11125 // In 24-bit mode, force exponent rounding by storing back out
11126 instruct convI2FPR_SSF(stackSlotF dst, stackSlotI src) %{
11127   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11128   match(Set dst (ConvI2F src));
11129   ins_cost(200);
11130   format %{ &quot;FILD   $src\n\t&quot;
11131             &quot;FSTP_S $dst&quot; %}
11132   opcode(0xDB, 0x0);  /* DB /0 */
11133   ins_encode( Push_Mem_I(src),
11134               Pop_Mem_FPR(dst));
11135   ins_pipe( fpu_mem_mem );
11136 %}
11137 
11138 // In 24-bit mode, force exponent rounding by storing back out
11139 instruct convI2FPR_SSF_mem(stackSlotF dst, memory mem) %{
11140   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11141   match(Set dst (ConvI2F (LoadI mem)));
11142   ins_cost(200);
11143   format %{ &quot;FILD   $mem\n\t&quot;
11144             &quot;FSTP_S $dst&quot; %}
11145   opcode(0xDB);  /* DB /0 */
11146   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11147               Pop_Mem_FPR(dst));
11148   ins_pipe( fpu_mem_mem );
11149 %}
11150 
11151 // This instruction does not round to 24-bits
11152 instruct convI2FPR_reg(regFPR dst, stackSlotI src) %{
11153   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11154   match(Set dst (ConvI2F src));
11155   format %{ &quot;FILD   $src\n\t&quot;
11156             &quot;FSTP   $dst&quot; %}
11157   opcode(0xDB, 0x0);  /* DB /0 */
11158   ins_encode( Push_Mem_I(src),
11159               Pop_Reg_FPR(dst));
11160   ins_pipe( fpu_reg_mem );
11161 %}
11162 
11163 // This instruction does not round to 24-bits
11164 instruct convI2FPR_mem(regFPR dst, memory mem) %{
11165   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11166   match(Set dst (ConvI2F (LoadI mem)));
11167   format %{ &quot;FILD   $mem\n\t&quot;
11168             &quot;FSTP   $dst&quot; %}
11169   opcode(0xDB);      /* DB /0 */
11170   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11171               Pop_Reg_FPR(dst));
11172   ins_pipe( fpu_reg_mem );
11173 %}
11174 
11175 // Convert an int to a float in xmm; no rounding step needed.
11176 instruct convI2F_reg(regF dst, rRegI src) %{
11177   predicate( UseSSE==1 || UseSSE&gt;=2 &amp;&amp; !UseXmmI2F );
11178   match(Set dst (ConvI2F src));
11179   format %{ &quot;CVTSI2SS $dst, $src&quot; %}
11180   ins_encode %{
11181     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
11182   %}
11183   ins_pipe( pipe_slow );
11184 %}
11185 
11186  instruct convXI2F_reg(regF dst, rRegI src)
11187 %{
11188   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2F );
11189   match(Set dst (ConvI2F src));
11190 
11191   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11192             &quot;CVTDQ2PS $dst,$dst\t# i2f&quot; %}
11193   ins_encode %{
11194     __ movdl($dst$$XMMRegister, $src$$Register);
11195     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
11196   %}
11197   ins_pipe(pipe_slow); // XXX
11198 %}
11199 
11200 instruct convI2L_reg( eRegL dst, rRegI src, eFlagsReg cr) %{
11201   match(Set dst (ConvI2L src));
11202   effect(KILL cr);
11203   ins_cost(375);
11204   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11205             &quot;MOV    $dst.hi,$src\n\t&quot;
11206             &quot;SAR    $dst.hi,31&quot; %}
11207   ins_encode(convert_int_long(dst,src));
11208   ins_pipe( ialu_reg_reg_long );
11209 %}
11210 
11211 // Zero-extend convert int to long
11212 instruct convI2L_reg_zex(eRegL dst, rRegI src, immL_32bits mask, eFlagsReg flags ) %{
11213   match(Set dst (AndL (ConvI2L src) mask) );
11214   effect( KILL flags );
11215   ins_cost(250);
11216   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11217             &quot;XOR    $dst.hi,$dst.hi&quot; %}
11218   opcode(0x33); // XOR
11219   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11220   ins_pipe( ialu_reg_reg_long );
11221 %}
11222 
11223 // Zero-extend long
11224 instruct zerox_long(eRegL dst, eRegL src, immL_32bits mask, eFlagsReg flags ) %{
11225   match(Set dst (AndL src mask) );
11226   effect( KILL flags );
11227   ins_cost(250);
11228   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
11229             &quot;XOR    $dst.hi,$dst.hi\n\t&quot; %}
11230   opcode(0x33); // XOR
11231   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11232   ins_pipe( ialu_reg_reg_long );
11233 %}
11234 
11235 instruct convL2DPR_reg( stackSlotD dst, eRegL src, eFlagsReg cr) %{
11236   predicate (UseSSE&lt;=1);
11237   match(Set dst (ConvL2D src));
11238   effect( KILL cr );
11239   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11240             &quot;PUSH   $src.lo\n\t&quot;
11241             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11242             &quot;ADD    ESP,8\n\t&quot;
11243             &quot;FSTP_D $dst\t# D-round&quot; %}
11244   opcode(0xDF, 0x5);  /* DF /5 */
11245   ins_encode(convert_long_double(src), Pop_Mem_DPR(dst));
11246   ins_pipe( pipe_slow );
11247 %}
11248 
11249 instruct convL2D_reg( regD dst, eRegL src, eFlagsReg cr) %{
11250   predicate (UseSSE&gt;=2);
11251   match(Set dst (ConvL2D src));
11252   effect( KILL cr );
11253   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11254             &quot;PUSH   $src.lo\n\t&quot;
11255             &quot;FILD_D [ESP]\n\t&quot;
11256             &quot;FSTP_D [ESP]\n\t&quot;
11257             &quot;MOVSD  $dst,[ESP]\n\t&quot;
11258             &quot;ADD    ESP,8&quot; %}
11259   opcode(0xDF, 0x5);  /* DF /5 */
11260   ins_encode(convert_long_double2(src), Push_ResultD(dst));
11261   ins_pipe( pipe_slow );
11262 %}
11263 
11264 instruct convL2F_reg( regF dst, eRegL src, eFlagsReg cr) %{
11265   predicate (UseSSE&gt;=1);
11266   match(Set dst (ConvL2F src));
11267   effect( KILL cr );
11268   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11269             &quot;PUSH   $src.lo\n\t&quot;
11270             &quot;FILD_D [ESP]\n\t&quot;
11271             &quot;FSTP_S [ESP]\n\t&quot;
11272             &quot;MOVSS  $dst,[ESP]\n\t&quot;
11273             &quot;ADD    ESP,8&quot; %}
11274   opcode(0xDF, 0x5);  /* DF /5 */
11275   ins_encode(convert_long_double2(src), Push_ResultF(dst,0x8));
11276   ins_pipe( pipe_slow );
11277 %}
11278 
11279 instruct convL2FPR_reg( stackSlotF dst, eRegL src, eFlagsReg cr) %{
11280   match(Set dst (ConvL2F src));
11281   effect( KILL cr );
11282   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11283             &quot;PUSH   $src.lo\n\t&quot;
11284             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11285             &quot;ADD    ESP,8\n\t&quot;
11286             &quot;FSTP_S $dst\t# F-round&quot; %}
11287   opcode(0xDF, 0x5);  /* DF /5 */
11288   ins_encode(convert_long_double(src), Pop_Mem_FPR(dst));
11289   ins_pipe( pipe_slow );
11290 %}
11291 
11292 instruct convL2I_reg( rRegI dst, eRegL src ) %{
11293   match(Set dst (ConvL2I src));
11294   effect( DEF dst, USE src );
11295   format %{ &quot;MOV    $dst,$src.lo&quot; %}
11296   ins_encode(enc_CopyL_Lo(dst,src));
11297   ins_pipe( ialu_reg_reg );
11298 %}
11299 
11300 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
11301   match(Set dst (MoveF2I src));
11302   effect( DEF dst, USE src );
11303   ins_cost(100);
11304   format %{ &quot;MOV    $dst,$src\t# MoveF2I_stack_reg&quot; %}
11305   ins_encode %{
11306     __ movl($dst$$Register, Address(rsp, $src$$disp));
11307   %}
11308   ins_pipe( ialu_reg_mem );
11309 %}
11310 
11311 instruct MoveFPR2I_reg_stack(stackSlotI dst, regFPR src) %{
11312   predicate(UseSSE==0);
11313   match(Set dst (MoveF2I src));
11314   effect( DEF dst, USE src );
11315 
11316   ins_cost(125);
11317   format %{ &quot;FST_S  $dst,$src\t# MoveF2I_reg_stack&quot; %}
11318   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
11319   ins_pipe( fpu_mem_reg );
11320 %}
11321 
11322 instruct MoveF2I_reg_stack_sse(stackSlotI dst, regF src) %{
11323   predicate(UseSSE&gt;=1);
11324   match(Set dst (MoveF2I src));
11325   effect( DEF dst, USE src );
11326 
11327   ins_cost(95);
11328   format %{ &quot;MOVSS  $dst,$src\t# MoveF2I_reg_stack_sse&quot; %}
11329   ins_encode %{
11330     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
11331   %}
11332   ins_pipe( pipe_slow );
11333 %}
11334 
11335 instruct MoveF2I_reg_reg_sse(rRegI dst, regF src) %{
11336   predicate(UseSSE&gt;=2);
11337   match(Set dst (MoveF2I src));
11338   effect( DEF dst, USE src );
11339   ins_cost(85);
11340   format %{ &quot;MOVD   $dst,$src\t# MoveF2I_reg_reg_sse&quot; %}
11341   ins_encode %{
11342     __ movdl($dst$$Register, $src$$XMMRegister);
11343   %}
11344   ins_pipe( pipe_slow );
11345 %}
11346 
11347 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
11348   match(Set dst (MoveI2F src));
11349   effect( DEF dst, USE src );
11350 
11351   ins_cost(100);
11352   format %{ &quot;MOV    $dst,$src\t# MoveI2F_reg_stack&quot; %}
11353   ins_encode %{
11354     __ movl(Address(rsp, $dst$$disp), $src$$Register);
11355   %}
11356   ins_pipe( ialu_mem_reg );
11357 %}
11358 
11359 
11360 instruct MoveI2FPR_stack_reg(regFPR dst, stackSlotI src) %{
11361   predicate(UseSSE==0);
11362   match(Set dst (MoveI2F src));
11363   effect(DEF dst, USE src);
11364 
11365   ins_cost(125);
11366   format %{ &quot;FLD_S  $src\n\t&quot;
11367             &quot;FSTP   $dst\t# MoveI2F_stack_reg&quot; %}
11368   opcode(0xD9);               /* D9 /0, FLD m32real */
11369   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11370               Pop_Reg_FPR(dst) );
11371   ins_pipe( fpu_reg_mem );
11372 %}
11373 
11374 instruct MoveI2F_stack_reg_sse(regF dst, stackSlotI src) %{
11375   predicate(UseSSE&gt;=1);
11376   match(Set dst (MoveI2F src));
11377   effect( DEF dst, USE src );
11378 
11379   ins_cost(95);
11380   format %{ &quot;MOVSS  $dst,$src\t# MoveI2F_stack_reg_sse&quot; %}
11381   ins_encode %{
11382     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
11383   %}
11384   ins_pipe( pipe_slow );
11385 %}
11386 
11387 instruct MoveI2F_reg_reg_sse(regF dst, rRegI src) %{
11388   predicate(UseSSE&gt;=2);
11389   match(Set dst (MoveI2F src));
11390   effect( DEF dst, USE src );
11391 
11392   ins_cost(85);
11393   format %{ &quot;MOVD   $dst,$src\t# MoveI2F_reg_reg_sse&quot; %}
11394   ins_encode %{
11395     __ movdl($dst$$XMMRegister, $src$$Register);
11396   %}
11397   ins_pipe( pipe_slow );
11398 %}
11399 
11400 instruct MoveD2L_stack_reg(eRegL dst, stackSlotD src) %{
11401   match(Set dst (MoveD2L src));
11402   effect(DEF dst, USE src);
11403 
11404   ins_cost(250);
11405   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11406             &quot;MOV    $dst.hi,$src+4\t# MoveD2L_stack_reg&quot; %}
11407   opcode(0x8B, 0x8B);
11408   ins_encode( OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src));
11409   ins_pipe( ialu_mem_long_reg );
11410 %}
11411 
11412 instruct MoveDPR2L_reg_stack(stackSlotL dst, regDPR src) %{
11413   predicate(UseSSE&lt;=1);
11414   match(Set dst (MoveD2L src));
11415   effect(DEF dst, USE src);
11416 
11417   ins_cost(125);
11418   format %{ &quot;FST_D  $dst,$src\t# MoveD2L_reg_stack&quot; %}
11419   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
11420   ins_pipe( fpu_mem_reg );
11421 %}
11422 
11423 instruct MoveD2L_reg_stack_sse(stackSlotL dst, regD src) %{
11424   predicate(UseSSE&gt;=2);
11425   match(Set dst (MoveD2L src));
11426   effect(DEF dst, USE src);
11427   ins_cost(95);
11428   format %{ &quot;MOVSD  $dst,$src\t# MoveD2L_reg_stack_sse&quot; %}
11429   ins_encode %{
11430     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
11431   %}
11432   ins_pipe( pipe_slow );
11433 %}
11434 
11435 instruct MoveD2L_reg_reg_sse(eRegL dst, regD src, regD tmp) %{
11436   predicate(UseSSE&gt;=2);
11437   match(Set dst (MoveD2L src));
11438   effect(DEF dst, USE src, TEMP tmp);
11439   ins_cost(85);
11440   format %{ &quot;MOVD   $dst.lo,$src\n\t&quot;
11441             &quot;PSHUFLW $tmp,$src,0x4E\n\t&quot;
11442             &quot;MOVD   $dst.hi,$tmp\t# MoveD2L_reg_reg_sse&quot; %}
11443   ins_encode %{
11444     __ movdl($dst$$Register, $src$$XMMRegister);
11445     __ pshuflw($tmp$$XMMRegister, $src$$XMMRegister, 0x4e);
11446     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
11447   %}
11448   ins_pipe( pipe_slow );
11449 %}
11450 
11451 instruct MoveL2D_reg_stack(stackSlotD dst, eRegL src) %{
11452   match(Set dst (MoveL2D src));
11453   effect(DEF dst, USE src);
11454 
11455   ins_cost(200);
11456   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
11457             &quot;MOV    $dst+4,$src.hi\t# MoveL2D_reg_stack&quot; %}
11458   opcode(0x89, 0x89);
11459   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
11460   ins_pipe( ialu_mem_long_reg );
11461 %}
11462 
11463 
11464 instruct MoveL2DPR_stack_reg(regDPR dst, stackSlotL src) %{
11465   predicate(UseSSE&lt;=1);
11466   match(Set dst (MoveL2D src));
11467   effect(DEF dst, USE src);
11468   ins_cost(125);
11469 
11470   format %{ &quot;FLD_D  $src\n\t&quot;
11471             &quot;FSTP   $dst\t# MoveL2D_stack_reg&quot; %}
11472   opcode(0xDD);               /* DD /0, FLD m64real */
11473   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11474               Pop_Reg_DPR(dst) );
11475   ins_pipe( fpu_reg_mem );
11476 %}
11477 
11478 
11479 instruct MoveL2D_stack_reg_sse(regD dst, stackSlotL src) %{
11480   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
11481   match(Set dst (MoveL2D src));
11482   effect(DEF dst, USE src);
11483 
11484   ins_cost(95);
11485   format %{ &quot;MOVSD  $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11486   ins_encode %{
11487     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11488   %}
11489   ins_pipe( pipe_slow );
11490 %}
11491 
11492 instruct MoveL2D_stack_reg_sse_partial(regD dst, stackSlotL src) %{
11493   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
11494   match(Set dst (MoveL2D src));
11495   effect(DEF dst, USE src);
11496 
11497   ins_cost(95);
11498   format %{ &quot;MOVLPD $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11499   ins_encode %{
11500     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11501   %}
11502   ins_pipe( pipe_slow );
11503 %}
11504 
11505 instruct MoveL2D_reg_reg_sse(regD dst, eRegL src, regD tmp) %{
11506   predicate(UseSSE&gt;=2);
11507   match(Set dst (MoveL2D src));
11508   effect(TEMP dst, USE src, TEMP tmp);
11509   ins_cost(85);
11510   format %{ &quot;MOVD   $dst,$src.lo\n\t&quot;
11511             &quot;MOVD   $tmp,$src.hi\n\t&quot;
11512             &quot;PUNPCKLDQ $dst,$tmp\t# MoveL2D_reg_reg_sse&quot; %}
11513   ins_encode %{
11514     __ movdl($dst$$XMMRegister, $src$$Register);
11515     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));
11516     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);
11517   %}
11518   ins_pipe( pipe_slow );
11519 %}
11520 
11521 
11522 // =======================================================================
11523 // fast clearing of an array
11524 instruct rep_stos(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11525   predicate(!((ClearArrayNode*)n)-&gt;is_large());
11526   match(Set dummy (ClearArray cnt base));
11527   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11528 
11529   format %{ $$template
11530     $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11531     $$emit$$&quot;CMP    InitArrayShortSize,rcx\n\t&quot;
11532     $$emit$$&quot;JG     LARGE\n\t&quot;
11533     $$emit$$&quot;SHL    ECX, 1\n\t&quot;
11534     $$emit$$&quot;DEC    ECX\n\t&quot;
11535     $$emit$$&quot;JS     DONE\t# Zero length\n\t&quot;
11536     $$emit$$&quot;MOV    EAX,(EDI,ECX,4)\t# LOOP\n\t&quot;
11537     $$emit$$&quot;DEC    ECX\n\t&quot;
11538     $$emit$$&quot;JGE    LOOP\n\t&quot;
11539     $$emit$$&quot;JMP    DONE\n\t&quot;
11540     $$emit$$&quot;# LARGE:\n\t&quot;
11541     if (UseFastStosb) {
11542        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11543        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11544     } else if (UseXMMForObjInit) {
11545        $$emit$$&quot;MOV     RDI,RAX\n\t&quot;
11546        $$emit$$&quot;VPXOR    YMM0,YMM0,YMM0\n\t&quot;
11547        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11548        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11549        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11550        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11551        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11552        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11553        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11554        $$emit$$&quot;JGE     L_loop\n\t&quot;
11555        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11556        $$emit$$&quot;JL      L_tail\n\t&quot;
11557        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11558        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11559        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11560        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11561        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11562        $$emit$$&quot;JLE     L_end\n\t&quot;
11563        $$emit$$&quot;DEC     RCX\n\t&quot;
11564        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11565        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11566        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11567        $$emit$$&quot;DEC     RCX\n\t&quot;
11568        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11569        $$emit$$&quot;# L_end:\n\t&quot;
11570     } else {
11571        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11572        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11573     }
11574     $$emit$$&quot;# DONE&quot;
11575   %}
11576   ins_encode %{
11577     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11578                  $tmp$$XMMRegister, false);
11579   %}
11580   ins_pipe( pipe_slow );
11581 %}
11582 
11583 instruct rep_stos_large(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11584   predicate(((ClearArrayNode*)n)-&gt;is_large());
11585   match(Set dummy (ClearArray cnt base));
11586   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11587   format %{ $$template
11588     if (UseFastStosb) {
11589        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11590        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11591        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11592     } else if (UseXMMForObjInit) {
11593        $$emit$$&quot;MOV     RDI,RAX\t# ClearArray:\n\t&quot;
11594        $$emit$$&quot;VPXOR   YMM0,YMM0,YMM0\n\t&quot;
11595        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11596        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11597        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11598        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11599        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11600        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11601        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11602        $$emit$$&quot;JGE     L_loop\n\t&quot;
11603        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11604        $$emit$$&quot;JL      L_tail\n\t&quot;
11605        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11606        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11607        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11608        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11609        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11610        $$emit$$&quot;JLE     L_end\n\t&quot;
11611        $$emit$$&quot;DEC     RCX\n\t&quot;
11612        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11613        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11614        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11615        $$emit$$&quot;DEC     RCX\n\t&quot;
11616        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11617        $$emit$$&quot;# L_end:\n\t&quot;
11618     } else {
11619        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11620        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11621        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11622     }
11623     $$emit$$&quot;# DONE&quot;
11624   %}
11625   ins_encode %{
11626     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11627                  $tmp$$XMMRegister, true);
11628   %}
11629   ins_pipe( pipe_slow );
11630 %}
11631 
11632 instruct string_compareL(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11633                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11634   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11635   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11636   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11637 
11638   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11639   ins_encode %{
11640     __ string_compare($str1$$Register, $str2$$Register,
11641                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11642                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11643   %}
11644   ins_pipe( pipe_slow );
11645 %}
11646 
11647 instruct string_compareU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11648                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11649   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11650   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11651   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11652 
11653   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11654   ins_encode %{
11655     __ string_compare($str1$$Register, $str2$$Register,
11656                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11657                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11658   %}
11659   ins_pipe( pipe_slow );
11660 %}
11661 
11662 instruct string_compareLU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11663                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11664   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11665   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11666   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11667 
11668   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11669   ins_encode %{
11670     __ string_compare($str1$$Register, $str2$$Register,
11671                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11672                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11673   %}
11674   ins_pipe( pipe_slow );
11675 %}
11676 
11677 instruct string_compareUL(eSIRegP str1, eDXRegI cnt1, eDIRegP str2, eCXRegI cnt2,
11678                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11679   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11680   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11681   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11682 
11683   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11684   ins_encode %{
11685     __ string_compare($str2$$Register, $str1$$Register,
11686                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11687                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11688   %}
11689   ins_pipe( pipe_slow );
11690 %}
11691 
11692 // fast string equals
11693 instruct string_equals(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,
11694                        regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr) %{
11695   match(Set result (StrEquals (Binary str1 str2) cnt));
11696   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11697 
11698   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11699   ins_encode %{
11700     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11701                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11702                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11703   %}
11704 
11705   ins_pipe( pipe_slow );
11706 %}
11707 
11708 // fast search of substring with known size.
11709 instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11710                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11711   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11712   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11713   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11714 
11715   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11716   ins_encode %{
11717     int icnt2 = (int)$int_cnt2$$constant;
11718     if (icnt2 &gt;= 16) {
11719       // IndexOf for constant substrings with size &gt;= 16 elements
11720       // which don&#39;t need to be loaded through stack.
11721       __ string_indexofC8($str1$$Register, $str2$$Register,
11722                           $cnt1$$Register, $cnt2$$Register,
11723                           icnt2, $result$$Register,
11724                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11725     } else {
11726       // Small strings are loaded through stack if they cross page boundary.
11727       __ string_indexof($str1$$Register, $str2$$Register,
11728                         $cnt1$$Register, $cnt2$$Register,
11729                         icnt2, $result$$Register,
11730                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11731     }
11732   %}
11733   ins_pipe( pipe_slow );
11734 %}
11735 
11736 // fast search of substring with known size.
11737 instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11738                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11739   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11740   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11741   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11742 
11743   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11744   ins_encode %{
11745     int icnt2 = (int)$int_cnt2$$constant;
11746     if (icnt2 &gt;= 8) {
11747       // IndexOf for constant substrings with size &gt;= 8 elements
11748       // which don&#39;t need to be loaded through stack.
11749       __ string_indexofC8($str1$$Register, $str2$$Register,
11750                           $cnt1$$Register, $cnt2$$Register,
11751                           icnt2, $result$$Register,
11752                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11753     } else {
11754       // Small strings are loaded through stack if they cross page boundary.
11755       __ string_indexof($str1$$Register, $str2$$Register,
11756                         $cnt1$$Register, $cnt2$$Register,
11757                         icnt2, $result$$Register,
11758                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11759     }
11760   %}
11761   ins_pipe( pipe_slow );
11762 %}
11763 
11764 // fast search of substring with known size.
11765 instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11766                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11767   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11768   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11769   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11770 
11771   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11772   ins_encode %{
11773     int icnt2 = (int)$int_cnt2$$constant;
11774     if (icnt2 &gt;= 8) {
11775       // IndexOf for constant substrings with size &gt;= 8 elements
11776       // which don&#39;t need to be loaded through stack.
11777       __ string_indexofC8($str1$$Register, $str2$$Register,
11778                           $cnt1$$Register, $cnt2$$Register,
11779                           icnt2, $result$$Register,
11780                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11781     } else {
11782       // Small strings are loaded through stack if they cross page boundary.
11783       __ string_indexof($str1$$Register, $str2$$Register,
11784                         $cnt1$$Register, $cnt2$$Register,
11785                         icnt2, $result$$Register,
11786                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11787     }
11788   %}
11789   ins_pipe( pipe_slow );
11790 %}
11791 
11792 instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11793                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11794   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11795   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11796   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11797 
11798   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11799   ins_encode %{
11800     __ string_indexof($str1$$Register, $str2$$Register,
11801                       $cnt1$$Register, $cnt2$$Register,
11802                       (-1), $result$$Register,
11803                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11804   %}
11805   ins_pipe( pipe_slow );
11806 %}
11807 
11808 instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11809                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11810   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11811   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11812   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11813 
11814   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11815   ins_encode %{
11816     __ string_indexof($str1$$Register, $str2$$Register,
11817                       $cnt1$$Register, $cnt2$$Register,
11818                       (-1), $result$$Register,
11819                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11820   %}
11821   ins_pipe( pipe_slow );
11822 %}
11823 
11824 instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11825                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11826   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11827   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11828   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11829 
11830   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11831   ins_encode %{
11832     __ string_indexof($str1$$Register, $str2$$Register,
11833                       $cnt1$$Register, $cnt2$$Register,
11834                       (-1), $result$$Register,
11835                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11836   %}
11837   ins_pipe( pipe_slow );
11838 %}
11839 
11840 instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
11841                               eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{
11842   predicate(UseSSE42Intrinsics);
11843   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11844   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11845   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11846   ins_encode %{
11847     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11848                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
11849   %}
11850   ins_pipe( pipe_slow );
11851 %}
11852 
11853 // fast array equals
11854 instruct array_equalsB(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11855                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11856 %{
11857   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11858   match(Set result (AryEq ary1 ary2));
11859   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11860   //ins_cost(300);
11861 
11862   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11863   ins_encode %{
11864     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11865                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11866                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11867   %}
11868   ins_pipe( pipe_slow );
11869 %}
11870 
11871 instruct array_equalsC(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11872                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11873 %{
11874   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11875   match(Set result (AryEq ary1 ary2));
11876   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11877   //ins_cost(300);
11878 
11879   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11880   ins_encode %{
11881     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11882                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11883                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11884   %}
11885   ins_pipe( pipe_slow );
11886 %}
11887 
11888 instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,
11889                       regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)
11890 %{
11891   match(Set result (HasNegatives ary1 len));
11892   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11893 
11894   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11895   ins_encode %{
11896     __ has_negatives($ary1$$Register, $len$$Register,
11897                      $result$$Register, $tmp3$$Register,
11898                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11899   %}
11900   ins_pipe( pipe_slow );
11901 %}
11902 
11903 // fast char[] to byte[] compression
11904 instruct string_compress(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11905                          eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11906   match(Set result (StrCompressedCopy src (Binary dst len)));
11907   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11908 
11909   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11910   ins_encode %{
11911     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11912                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11913                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11914   %}
11915   ins_pipe( pipe_slow );
11916 %}
11917 
11918 // fast byte[] to char[] inflation
11919 instruct string_inflate(Universe dummy, eSIRegP src, eDIRegP dst, eDXRegI len,
11920                         regD tmp1, eCXRegI tmp2, eFlagsReg cr) %{
11921   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11922   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11923 
11924   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11925   ins_encode %{
11926     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11927                           $tmp1$$XMMRegister, $tmp2$$Register);
11928   %}
11929   ins_pipe( pipe_slow );
11930 %}
11931 
11932 // encode char[] to byte[] in ISO_8859_1
11933 instruct encode_iso_array(eSIRegP src, eDIRegP dst, eDXRegI len,
11934                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11935                           eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11936   match(Set result (EncodeISOArray src (Binary dst len)));
11937   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11938 
11939   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL ECX, EDX, $tmp1, $tmp2, $tmp3, $tmp4, ESI, EDI &quot; %}
11940   ins_encode %{
11941     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11942                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11943                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11944   %}
11945   ins_pipe( pipe_slow );
11946 %}
11947 
11948 
11949 //----------Control Flow Instructions------------------------------------------
11950 // Signed compare Instructions
11951 instruct compI_eReg(eFlagsReg cr, rRegI op1, rRegI op2) %{
11952   match(Set cr (CmpI op1 op2));
11953   effect( DEF cr, USE op1, USE op2 );
11954   format %{ &quot;CMP    $op1,$op2&quot; %}
11955   opcode(0x3B);  /* Opcode 3B /r */
11956   ins_encode( OpcP, RegReg( op1, op2) );
11957   ins_pipe( ialu_cr_reg_reg );
11958 %}
11959 
11960 instruct compI_eReg_imm(eFlagsReg cr, rRegI op1, immI op2) %{
11961   match(Set cr (CmpI op1 op2));
11962   effect( DEF cr, USE op1 );
11963   format %{ &quot;CMP    $op1,$op2&quot; %}
11964   opcode(0x81,0x07);  /* Opcode 81 /7 */
11965   // ins_encode( RegImm( op1, op2) );  /* Was CmpImm */
11966   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
11967   ins_pipe( ialu_cr_reg_imm );
11968 %}
11969 
11970 // Cisc-spilled version of cmpI_eReg
11971 instruct compI_eReg_mem(eFlagsReg cr, rRegI op1, memory op2) %{
11972   match(Set cr (CmpI op1 (LoadI op2)));
11973 
11974   format %{ &quot;CMP    $op1,$op2&quot; %}
11975   ins_cost(500);
11976   opcode(0x3B);  /* Opcode 3B /r */
11977   ins_encode( OpcP, RegMem( op1, op2) );
11978   ins_pipe( ialu_cr_reg_mem );
11979 %}
11980 
11981 instruct testI_reg( eFlagsReg cr, rRegI src, immI0 zero ) %{
11982   match(Set cr (CmpI src zero));
11983   effect( DEF cr, USE src );
11984 
11985   format %{ &quot;TEST   $src,$src&quot; %}
11986   opcode(0x85);
11987   ins_encode( OpcP, RegReg( src, src ) );
11988   ins_pipe( ialu_cr_reg_imm );
11989 %}
11990 
11991 instruct testI_reg_imm( eFlagsReg cr, rRegI src, immI con, immI0 zero ) %{
11992   match(Set cr (CmpI (AndI src con) zero));
11993 
11994   format %{ &quot;TEST   $src,$con&quot; %}
11995   opcode(0xF7,0x00);
11996   ins_encode( OpcP, RegOpc(src), Con32(con) );
11997   ins_pipe( ialu_cr_reg_imm );
11998 %}
11999 
12000 instruct testI_reg_mem( eFlagsReg cr, rRegI src, memory mem, immI0 zero ) %{
12001   match(Set cr (CmpI (AndI src mem) zero));
12002 
12003   format %{ &quot;TEST   $src,$mem&quot; %}
12004   opcode(0x85);
12005   ins_encode( OpcP, RegMem( src, mem ) );
12006   ins_pipe( ialu_cr_reg_mem );
12007 %}
12008 
12009 // Unsigned compare Instructions; really, same as signed except they
12010 // produce an eFlagsRegU instead of eFlagsReg.
12011 instruct compU_eReg(eFlagsRegU cr, rRegI op1, rRegI op2) %{
12012   match(Set cr (CmpU op1 op2));
12013 
12014   format %{ &quot;CMPu   $op1,$op2&quot; %}
12015   opcode(0x3B);  /* Opcode 3B /r */
12016   ins_encode( OpcP, RegReg( op1, op2) );
12017   ins_pipe( ialu_cr_reg_reg );
12018 %}
12019 
12020 instruct compU_eReg_imm(eFlagsRegU cr, rRegI op1, immI op2) %{
12021   match(Set cr (CmpU op1 op2));
12022 
12023   format %{ &quot;CMPu   $op1,$op2&quot; %}
12024   opcode(0x81,0x07);  /* Opcode 81 /7 */
12025   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12026   ins_pipe( ialu_cr_reg_imm );
12027 %}
12028 
12029 // // Cisc-spilled version of cmpU_eReg
12030 instruct compU_eReg_mem(eFlagsRegU cr, rRegI op1, memory op2) %{
12031   match(Set cr (CmpU op1 (LoadI op2)));
12032 
12033   format %{ &quot;CMPu   $op1,$op2&quot; %}
12034   ins_cost(500);
12035   opcode(0x3B);  /* Opcode 3B /r */
12036   ins_encode( OpcP, RegMem( op1, op2) );
12037   ins_pipe( ialu_cr_reg_mem );
12038 %}
12039 
12040 // // Cisc-spilled version of cmpU_eReg
12041 //instruct compU_mem_eReg(eFlagsRegU cr, memory op1, rRegI op2) %{
12042 //  match(Set cr (CmpU (LoadI op1) op2));
12043 //
12044 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12045 //  ins_cost(500);
12046 //  opcode(0x39);  /* Opcode 39 /r */
12047 //  ins_encode( OpcP, RegMem( op1, op2) );
12048 //%}
12049 
12050 instruct testU_reg( eFlagsRegU cr, rRegI src, immI0 zero ) %{
12051   match(Set cr (CmpU src zero));
12052 
12053   format %{ &quot;TESTu  $src,$src&quot; %}
12054   opcode(0x85);
12055   ins_encode( OpcP, RegReg( src, src ) );
12056   ins_pipe( ialu_cr_reg_imm );
12057 %}
12058 
12059 // Unsigned pointer compare Instructions
12060 instruct compP_eReg(eFlagsRegU cr, eRegP op1, eRegP op2) %{
12061   match(Set cr (CmpP op1 op2));
12062 
12063   format %{ &quot;CMPu   $op1,$op2&quot; %}
12064   opcode(0x3B);  /* Opcode 3B /r */
12065   ins_encode( OpcP, RegReg( op1, op2) );
12066   ins_pipe( ialu_cr_reg_reg );
12067 %}
12068 
12069 instruct compP_eReg_imm(eFlagsRegU cr, eRegP op1, immP op2) %{
12070   match(Set cr (CmpP op1 op2));
12071 
12072   format %{ &quot;CMPu   $op1,$op2&quot; %}
12073   opcode(0x81,0x07);  /* Opcode 81 /7 */
12074   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12075   ins_pipe( ialu_cr_reg_imm );
12076 %}
12077 
12078 // // Cisc-spilled version of cmpP_eReg
12079 instruct compP_eReg_mem(eFlagsRegU cr, eRegP op1, memory op2) %{
12080   match(Set cr (CmpP op1 (LoadP op2)));
12081 
12082   format %{ &quot;CMPu   $op1,$op2&quot; %}
12083   ins_cost(500);
12084   opcode(0x3B);  /* Opcode 3B /r */
12085   ins_encode( OpcP, RegMem( op1, op2) );
12086   ins_pipe( ialu_cr_reg_mem );
12087 %}
12088 
12089 // // Cisc-spilled version of cmpP_eReg
12090 //instruct compP_mem_eReg(eFlagsRegU cr, memory op1, eRegP op2) %{
12091 //  match(Set cr (CmpP (LoadP op1) op2));
12092 //
12093 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12094 //  ins_cost(500);
12095 //  opcode(0x39);  /* Opcode 39 /r */
12096 //  ins_encode( OpcP, RegMem( op1, op2) );
12097 //%}
12098 
12099 // Compare raw pointer (used in out-of-heap check).
12100 // Only works because non-oop pointers must be raw pointers
12101 // and raw pointers have no anti-dependencies.
12102 instruct compP_mem_eReg( eFlagsRegU cr, eRegP op1, memory op2 ) %{
12103   predicate( n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none );
12104   match(Set cr (CmpP op1 (LoadP op2)));
12105 
12106   format %{ &quot;CMPu   $op1,$op2&quot; %}
12107   opcode(0x3B);  /* Opcode 3B /r */
12108   ins_encode( OpcP, RegMem( op1, op2) );
12109   ins_pipe( ialu_cr_reg_mem );
12110 %}
12111 
12112 //
12113 // This will generate a signed flags result. This should be ok
12114 // since any compare to a zero should be eq/neq.
12115 instruct testP_reg( eFlagsReg cr, eRegP src, immP0 zero ) %{
12116   match(Set cr (CmpP src zero));
12117 
12118   format %{ &quot;TEST   $src,$src&quot; %}
12119   opcode(0x85);
12120   ins_encode( OpcP, RegReg( src, src ) );
12121   ins_pipe( ialu_cr_reg_imm );
12122 %}
12123 
12124 // Cisc-spilled version of testP_reg
12125 // This will generate a signed flags result. This should be ok
12126 // since any compare to a zero should be eq/neq.
12127 instruct testP_Reg_mem( eFlagsReg cr, memory op, immI0 zero ) %{
12128   match(Set cr (CmpP (LoadP op) zero));
12129 
12130   format %{ &quot;TEST   $op,0xFFFFFFFF&quot; %}
12131   ins_cost(500);
12132   opcode(0xF7);               /* Opcode F7 /0 */
12133   ins_encode( OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF) );
12134   ins_pipe( ialu_cr_reg_imm );
12135 %}
12136 
12137 // Yanked all unsigned pointer compare operations.
12138 // Pointer compares are done with CmpP which is already unsigned.
12139 
12140 //----------Max and Min--------------------------------------------------------
12141 // Min Instructions
12142 ////
12143 //   *** Min and Max using the conditional move are slower than the
12144 //   *** branch version on a Pentium III.
12145 // // Conditional move for min
12146 //instruct cmovI_reg_lt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12147 //  effect( USE_DEF op2, USE op1, USE cr );
12148 //  format %{ &quot;CMOVlt $op2,$op1\t! min&quot; %}
12149 //  opcode(0x4C,0x0F);
12150 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12151 //  ins_pipe( pipe_cmov_reg );
12152 //%}
12153 //
12154 //// Min Register with Register (P6 version)
12155 //instruct minI_eReg_p6( rRegI op1, rRegI op2 ) %{
12156 //  predicate(VM_Version::supports_cmov() );
12157 //  match(Set op2 (MinI op1 op2));
12158 //  ins_cost(200);
12159 //  expand %{
12160 //    eFlagsReg cr;
12161 //    compI_eReg(cr,op1,op2);
12162 //    cmovI_reg_lt(op2,op1,cr);
12163 //  %}
12164 //%}
12165 
12166 // Min Register with Register (generic version)
12167 instruct minI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12168   match(Set dst (MinI dst src));
12169   effect(KILL flags);
12170   ins_cost(300);
12171 
12172   format %{ &quot;MIN    $dst,$src&quot; %}
12173   opcode(0xCC);
12174   ins_encode( min_enc(dst,src) );
12175   ins_pipe( pipe_slow );
12176 %}
12177 
12178 // Max Register with Register
12179 //   *** Min and Max using the conditional move are slower than the
12180 //   *** branch version on a Pentium III.
12181 // // Conditional move for max
12182 //instruct cmovI_reg_gt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12183 //  effect( USE_DEF op2, USE op1, USE cr );
12184 //  format %{ &quot;CMOVgt $op2,$op1\t! max&quot; %}
12185 //  opcode(0x4F,0x0F);
12186 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12187 //  ins_pipe( pipe_cmov_reg );
12188 //%}
12189 //
12190 // // Max Register with Register (P6 version)
12191 //instruct maxI_eReg_p6( rRegI op1, rRegI op2 ) %{
12192 //  predicate(VM_Version::supports_cmov() );
12193 //  match(Set op2 (MaxI op1 op2));
12194 //  ins_cost(200);
12195 //  expand %{
12196 //    eFlagsReg cr;
12197 //    compI_eReg(cr,op1,op2);
12198 //    cmovI_reg_gt(op2,op1,cr);
12199 //  %}
12200 //%}
12201 
12202 // Max Register with Register (generic version)
12203 instruct maxI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12204   match(Set dst (MaxI dst src));
12205   effect(KILL flags);
12206   ins_cost(300);
12207 
12208   format %{ &quot;MAX    $dst,$src&quot; %}
12209   opcode(0xCC);
12210   ins_encode( max_enc(dst,src) );
12211   ins_pipe( pipe_slow );
12212 %}
12213 
12214 // ============================================================================
12215 // Counted Loop limit node which represents exact final iterator value.
12216 // Note: the resulting value should fit into integer range since
12217 // counted loops have limit check on overflow.
12218 instruct loopLimit_eReg(eAXRegI limit, nadxRegI init, immI stride, eDXRegI limit_hi, nadxRegI tmp, eFlagsReg flags) %{
12219   match(Set limit (LoopLimit (Binary init limit) stride));
12220   effect(TEMP limit_hi, TEMP tmp, KILL flags);
12221   ins_cost(300);
12222 
12223   format %{ &quot;loopLimit $init,$limit,$stride  # $limit = $init + $stride *( $limit - $init + $stride -1)/ $stride, kills $limit_hi&quot; %}
12224   ins_encode %{
12225     int strd = (int)$stride$$constant;
12226     assert(strd != 1 &amp;&amp; strd != -1, &quot;sanity&quot;);
12227     int m1 = (strd &gt; 0) ? 1 : -1;
12228     // Convert limit to long (EAX:EDX)
12229     __ cdql();
12230     // Convert init to long (init:tmp)
12231     __ movl($tmp$$Register, $init$$Register);
12232     __ sarl($tmp$$Register, 31);
12233     // $limit - $init
12234     __ subl($limit$$Register, $init$$Register);
12235     __ sbbl($limit_hi$$Register, $tmp$$Register);
12236     // + ($stride - 1)
12237     if (strd &gt; 0) {
12238       __ addl($limit$$Register, (strd - 1));
12239       __ adcl($limit_hi$$Register, 0);
12240       __ movl($tmp$$Register, strd);
12241     } else {
12242       __ addl($limit$$Register, (strd + 1));
12243       __ adcl($limit_hi$$Register, -1);
12244       __ lneg($limit_hi$$Register, $limit$$Register);
12245       __ movl($tmp$$Register, -strd);
12246     }
12247     // signed devision: (EAX:EDX) / pos_stride
12248     __ idivl($tmp$$Register);
12249     if (strd &lt; 0) {
12250       // restore sign
12251       __ negl($tmp$$Register);
12252     }
12253     // (EAX) * stride
12254     __ mull($tmp$$Register);
12255     // + init (ignore upper bits)
12256     __ addl($limit$$Register, $init$$Register);
12257   %}
12258   ins_pipe( pipe_slow );
12259 %}
12260 
12261 // ============================================================================
12262 // Branch Instructions
12263 // Jump Table
12264 instruct jumpXtnd(rRegI switch_val) %{
12265   match(Jump switch_val);
12266   ins_cost(350);
12267   format %{  &quot;JMP    [$constantaddress](,$switch_val,1)\n\t&quot; %}
12268   ins_encode %{
12269     // Jump to Address(table_base + switch_reg)
12270     Address index(noreg, $switch_val$$Register, Address::times_1);
12271     __ jump(ArrayAddress($constantaddress, index));
12272   %}
12273   ins_pipe(pipe_jmp);
12274 %}
12275 
12276 // Jump Direct - Label defines a relative address from JMP+1
12277 instruct jmpDir(label labl) %{
12278   match(Goto);
12279   effect(USE labl);
12280 
12281   ins_cost(300);
12282   format %{ &quot;JMP    $labl&quot; %}
12283   size(5);
12284   ins_encode %{
12285     Label* L = $labl$$label;
12286     __ jmp(*L, false); // Always long jump
12287   %}
12288   ins_pipe( pipe_jmp );
12289 %}
12290 
12291 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12292 instruct jmpCon(cmpOp cop, eFlagsReg cr, label labl) %{
12293   match(If cop cr);
12294   effect(USE labl);
12295 
12296   ins_cost(300);
12297   format %{ &quot;J$cop    $labl&quot; %}
12298   size(6);
12299   ins_encode %{
12300     Label* L = $labl$$label;
12301     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12302   %}
12303   ins_pipe( pipe_jcc );
12304 %}
12305 
12306 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12307 instruct jmpLoopEnd(cmpOp cop, eFlagsReg cr, label labl) %{
12308   predicate(!n-&gt;has_vector_mask_set());
12309   match(CountedLoopEnd cop cr);
12310   effect(USE labl);
12311 
12312   ins_cost(300);
12313   format %{ &quot;J$cop    $labl\t# Loop end&quot; %}
12314   size(6);
12315   ins_encode %{
12316     Label* L = $labl$$label;
12317     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12318   %}
12319   ins_pipe( pipe_jcc );
12320 %}
12321 
12322 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12323 instruct jmpLoopEndU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12324   predicate(!n-&gt;has_vector_mask_set());
12325   match(CountedLoopEnd cop cmp);
12326   effect(USE labl);
12327 
12328   ins_cost(300);
12329   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12330   size(6);
12331   ins_encode %{
12332     Label* L = $labl$$label;
12333     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12334   %}
12335   ins_pipe( pipe_jcc );
12336 %}
12337 
12338 instruct jmpLoopEndUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12339   predicate(!n-&gt;has_vector_mask_set());
12340   match(CountedLoopEnd cop cmp);
12341   effect(USE labl);
12342 
12343   ins_cost(200);
12344   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12345   size(6);
12346   ins_encode %{
12347     Label* L = $labl$$label;
12348     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12349   %}
12350   ins_pipe( pipe_jcc );
12351 %}
12352 
12353 // mask version
12354 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12355 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, eFlagsReg cr, label labl) %{
12356   predicate(n-&gt;has_vector_mask_set());
12357   match(CountedLoopEnd cop cr);
12358   effect(USE labl);
12359 
12360   ins_cost(400);
12361   format %{ &quot;J$cop    $labl\t# Loop end\n\t&quot;
12362             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12363   size(10);
12364   ins_encode %{
12365     Label* L = $labl$$label;
12366     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12367     __ restorevectmask();
12368   %}
12369   ins_pipe( pipe_jcc );
12370 %}
12371 
12372 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12373 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12374   predicate(n-&gt;has_vector_mask_set());
12375   match(CountedLoopEnd cop cmp);
12376   effect(USE labl);
12377 
12378   ins_cost(400);
12379   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12380             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12381   size(10);
12382   ins_encode %{
12383     Label* L = $labl$$label;
12384     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12385     __ restorevectmask();
12386   %}
12387   ins_pipe( pipe_jcc );
12388 %}
12389 
12390 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12391   predicate(n-&gt;has_vector_mask_set());
12392   match(CountedLoopEnd cop cmp);
12393   effect(USE labl);
12394 
12395   ins_cost(300);
12396   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12397             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12398   size(10);
12399   ins_encode %{
12400     Label* L = $labl$$label;
12401     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12402     __ restorevectmask();
12403   %}
12404   ins_pipe( pipe_jcc );
12405 %}
12406 
12407 // Jump Direct Conditional - using unsigned comparison
12408 instruct jmpConU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12409   match(If cop cmp);
12410   effect(USE labl);
12411 
12412   ins_cost(300);
12413   format %{ &quot;J$cop,u  $labl&quot; %}
12414   size(6);
12415   ins_encode %{
12416     Label* L = $labl$$label;
12417     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12418   %}
12419   ins_pipe(pipe_jcc);
12420 %}
12421 
12422 instruct jmpConUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12423   match(If cop cmp);
12424   effect(USE labl);
12425 
12426   ins_cost(200);
12427   format %{ &quot;J$cop,u  $labl&quot; %}
12428   size(6);
12429   ins_encode %{
12430     Label* L = $labl$$label;
12431     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12432   %}
12433   ins_pipe(pipe_jcc);
12434 %}
12435 
12436 instruct jmpConUCF2(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12437   match(If cop cmp);
12438   effect(USE labl);
12439 
12440   ins_cost(200);
12441   format %{ $$template
12442     if ($cop$$cmpcode == Assembler::notEqual) {
12443       $$emit$$&quot;JP,u   $labl\n\t&quot;
12444       $$emit$$&quot;J$cop,u   $labl&quot;
12445     } else {
12446       $$emit$$&quot;JP,u   done\n\t&quot;
12447       $$emit$$&quot;J$cop,u   $labl\n\t&quot;
12448       $$emit$$&quot;done:&quot;
12449     }
12450   %}
12451   ins_encode %{
12452     Label* l = $labl$$label;
12453     if ($cop$$cmpcode == Assembler::notEqual) {
12454       __ jcc(Assembler::parity, *l, false);
12455       __ jcc(Assembler::notEqual, *l, false);
12456     } else if ($cop$$cmpcode == Assembler::equal) {
12457       Label done;
12458       __ jccb(Assembler::parity, done);
12459       __ jcc(Assembler::equal, *l, false);
12460       __ bind(done);
12461     } else {
12462        ShouldNotReachHere();
12463     }
12464   %}
12465   ins_pipe(pipe_jcc);
12466 %}
12467 
12468 // ============================================================================
12469 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
12470 // array for an instance of the superklass.  Set a hidden internal cache on a
12471 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
12472 // NZ for a miss or zero for a hit.  The encoding ALSO sets flags.
12473 instruct partialSubtypeCheck( eDIRegP result, eSIRegP sub, eAXRegP super, eCXRegI rcx, eFlagsReg cr ) %{
12474   match(Set result (PartialSubtypeCheck sub super));
12475   effect( KILL rcx, KILL cr );
12476 
12477   ins_cost(1100);  // slightly larger than the next version
12478   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12479             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12480             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12481             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12482             &quot;JNE,s  miss\t\t# Missed: EDI not-zero\n\t&quot;
12483             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache\n\t&quot;
12484             &quot;XOR    $result,$result\t\t Hit: EDI zero\n\t&quot;
12485      &quot;miss:\t&quot; %}
12486 
12487   opcode(0x1); // Force a XOR of EDI
12488   ins_encode( enc_PartialSubtypeCheck() );
12489   ins_pipe( pipe_slow );
12490 %}
12491 
12492 instruct partialSubtypeCheck_vs_Zero( eFlagsReg cr, eSIRegP sub, eAXRegP super, eCXRegI rcx, eDIRegP result, immP0 zero ) %{
12493   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12494   effect( KILL rcx, KILL result );
12495 
12496   ins_cost(1000);
12497   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12498             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12499             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12500             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12501             &quot;JNE,s  miss\t\t# Missed: flags NZ\n\t&quot;
12502             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache, flags Z\n\t&quot;
12503      &quot;miss:\t&quot; %}
12504 
12505   opcode(0x0);  // No need to XOR EDI
12506   ins_encode( enc_PartialSubtypeCheck() );
12507   ins_pipe( pipe_slow );
12508 %}
12509 
12510 // ============================================================================
12511 // Branch Instructions -- short offset versions
12512 //
12513 // These instructions are used to replace jumps of a long offset (the default
12514 // match) with jumps of a shorter offset.  These instructions are all tagged
12515 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12516 // match rules in general matching.  Instead, the ADLC generates a conversion
12517 // method in the MachNode which can be used to do in-place replacement of the
12518 // long variant with the shorter variant.  The compiler will determine if a
12519 // branch can be taken by the is_short_branch_offset() predicate in the machine
12520 // specific code section of the file.
12521 
12522 // Jump Direct - Label defines a relative address from JMP+1
12523 instruct jmpDir_short(label labl) %{
12524   match(Goto);
12525   effect(USE labl);
12526 
12527   ins_cost(300);
12528   format %{ &quot;JMP,s  $labl&quot; %}
12529   size(2);
12530   ins_encode %{
12531     Label* L = $labl$$label;
12532     __ jmpb(*L);
12533   %}
12534   ins_pipe( pipe_jmp );
12535   ins_short_branch(1);
12536 %}
12537 
12538 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12539 instruct jmpCon_short(cmpOp cop, eFlagsReg cr, label labl) %{
12540   match(If cop cr);
12541   effect(USE labl);
12542 
12543   ins_cost(300);
12544   format %{ &quot;J$cop,s  $labl&quot; %}
12545   size(2);
12546   ins_encode %{
12547     Label* L = $labl$$label;
12548     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12549   %}
12550   ins_pipe( pipe_jcc );
12551   ins_short_branch(1);
12552 %}
12553 
12554 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12555 instruct jmpLoopEnd_short(cmpOp cop, eFlagsReg cr, label labl) %{
12556   match(CountedLoopEnd cop cr);
12557   effect(USE labl);
12558 
12559   ins_cost(300);
12560   format %{ &quot;J$cop,s  $labl\t# Loop end&quot; %}
12561   size(2);
12562   ins_encode %{
12563     Label* L = $labl$$label;
12564     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12565   %}
12566   ins_pipe( pipe_jcc );
12567   ins_short_branch(1);
12568 %}
12569 
12570 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12571 instruct jmpLoopEndU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12572   match(CountedLoopEnd cop cmp);
12573   effect(USE labl);
12574 
12575   ins_cost(300);
12576   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12577   size(2);
12578   ins_encode %{
12579     Label* L = $labl$$label;
12580     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12581   %}
12582   ins_pipe( pipe_jcc );
12583   ins_short_branch(1);
12584 %}
12585 
12586 instruct jmpLoopEndUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12587   match(CountedLoopEnd cop cmp);
12588   effect(USE labl);
12589 
12590   ins_cost(300);
12591   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12592   size(2);
12593   ins_encode %{
12594     Label* L = $labl$$label;
12595     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12596   %}
12597   ins_pipe( pipe_jcc );
12598   ins_short_branch(1);
12599 %}
12600 
12601 // Jump Direct Conditional - using unsigned comparison
12602 instruct jmpConU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12603   match(If cop cmp);
12604   effect(USE labl);
12605 
12606   ins_cost(300);
12607   format %{ &quot;J$cop,us $labl&quot; %}
12608   size(2);
12609   ins_encode %{
12610     Label* L = $labl$$label;
12611     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12612   %}
12613   ins_pipe( pipe_jcc );
12614   ins_short_branch(1);
12615 %}
12616 
12617 instruct jmpConUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12618   match(If cop cmp);
12619   effect(USE labl);
12620 
12621   ins_cost(300);
12622   format %{ &quot;J$cop,us $labl&quot; %}
12623   size(2);
12624   ins_encode %{
12625     Label* L = $labl$$label;
12626     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12627   %}
12628   ins_pipe( pipe_jcc );
12629   ins_short_branch(1);
12630 %}
12631 
12632 instruct jmpConUCF2_short(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12633   match(If cop cmp);
12634   effect(USE labl);
12635 
12636   ins_cost(300);
12637   format %{ $$template
12638     if ($cop$$cmpcode == Assembler::notEqual) {
12639       $$emit$$&quot;JP,u,s   $labl\n\t&quot;
12640       $$emit$$&quot;J$cop,u,s   $labl&quot;
12641     } else {
12642       $$emit$$&quot;JP,u,s   done\n\t&quot;
12643       $$emit$$&quot;J$cop,u,s  $labl\n\t&quot;
12644       $$emit$$&quot;done:&quot;
12645     }
12646   %}
12647   size(4);
12648   ins_encode %{
12649     Label* l = $labl$$label;
12650     if ($cop$$cmpcode == Assembler::notEqual) {
12651       __ jccb(Assembler::parity, *l);
12652       __ jccb(Assembler::notEqual, *l);
12653     } else if ($cop$$cmpcode == Assembler::equal) {
12654       Label done;
12655       __ jccb(Assembler::parity, done);
12656       __ jccb(Assembler::equal, *l);
12657       __ bind(done);
12658     } else {
12659        ShouldNotReachHere();
12660     }
12661   %}
12662   ins_pipe(pipe_jcc);
12663   ins_short_branch(1);
12664 %}
12665 
12666 // ============================================================================
12667 // Long Compare
12668 //
12669 // Currently we hold longs in 2 registers.  Comparing such values efficiently
12670 // is tricky.  The flavor of compare used depends on whether we are testing
12671 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
12672 // The GE test is the negated LT test.  The LE test can be had by commuting
12673 // the operands (yielding a GE test) and then negating; negate again for the
12674 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
12675 // NE test is negated from that.
12676 
12677 // Due to a shortcoming in the ADLC, it mixes up expressions like:
12678 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
12679 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
12680 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
12681 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
12682 // foo match ends up with the wrong leaf.  One fix is to not match both
12683 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
12684 // both forms beat the trinary form of long-compare and both are very useful
12685 // on Intel which has so few registers.
12686 
12687 // Manifest a CmpL result in an integer register.  Very painful.
12688 // This is the test to avoid.
12689 instruct cmpL3_reg_reg(eSIRegI dst, eRegL src1, eRegL src2, eFlagsReg flags ) %{
12690   match(Set dst (CmpL3 src1 src2));
12691   effect( KILL flags );
12692   ins_cost(1000);
12693   format %{ &quot;XOR    $dst,$dst\n\t&quot;
12694             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12695             &quot;JLT,s  m_one\n\t&quot;
12696             &quot;JGT,s  p_one\n\t&quot;
12697             &quot;CMP    $src1.lo,$src2.lo\n\t&quot;
12698             &quot;JB,s   m_one\n\t&quot;
12699             &quot;JEQ,s  done\n&quot;
12700     &quot;p_one:\tINC    $dst\n\t&quot;
12701             &quot;JMP,s  done\n&quot;
12702     &quot;m_one:\tDEC    $dst\n&quot;
12703      &quot;done:&quot; %}
12704   ins_encode %{
12705     Label p_one, m_one, done;
12706     __ xorptr($dst$$Register, $dst$$Register);
12707     __ cmpl(HIGH_FROM_LOW($src1$$Register), HIGH_FROM_LOW($src2$$Register));
12708     __ jccb(Assembler::less,    m_one);
12709     __ jccb(Assembler::greater, p_one);
12710     __ cmpl($src1$$Register, $src2$$Register);
12711     __ jccb(Assembler::below,   m_one);
12712     __ jccb(Assembler::equal,   done);
12713     __ bind(p_one);
12714     __ incrementl($dst$$Register);
12715     __ jmpb(done);
12716     __ bind(m_one);
12717     __ decrementl($dst$$Register);
12718     __ bind(done);
12719   %}
12720   ins_pipe( pipe_slow );
12721 %}
12722 
12723 //======
12724 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12725 // compares.  Can be used for LE or GT compares by reversing arguments.
12726 // NOT GOOD FOR EQ/NE tests.
12727 instruct cmpL_zero_flags_LTGE( flagsReg_long_LTGE flags, eRegL src, immL0 zero ) %{
12728   match( Set flags (CmpL src zero ));
12729   ins_cost(100);
12730   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12731   opcode(0x85);
12732   ins_encode( OpcP, RegReg_Hi2( src, src ) );
12733   ins_pipe( ialu_cr_reg_reg );
12734 %}
12735 
12736 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12737 // compares.  Can be used for LE or GT compares by reversing arguments.
12738 // NOT GOOD FOR EQ/NE tests.
12739 instruct cmpL_reg_flags_LTGE( flagsReg_long_LTGE flags, eRegL src1, eRegL src2, rRegI tmp ) %{
12740   match( Set flags (CmpL src1 src2 ));
12741   effect( TEMP tmp );
12742   ins_cost(300);
12743   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12744             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12745             &quot;SBB    $tmp,$src2.hi\t! Compute flags for long compare&quot; %}
12746   ins_encode( long_cmp_flags2( src1, src2, tmp ) );
12747   ins_pipe( ialu_cr_reg_reg );
12748 %}
12749 
12750 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
12751 // Just a wrapper for a normal branch, plus the predicate test.
12752 instruct cmpL_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, label labl) %{
12753   match(If cmp flags);
12754   effect(USE labl);
12755   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12756   expand %{
12757     jmpCon(cmp,flags,labl);    // JLT or JGE...
12758   %}
12759 %}
12760 
12761 //======
12762 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12763 // compares.  Can be used for LE or GT compares by reversing arguments.
12764 // NOT GOOD FOR EQ/NE tests.
12765 instruct cmpUL_zero_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src, immL0 zero) %{
12766   match(Set flags (CmpUL src zero));
12767   ins_cost(100);
12768   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12769   opcode(0x85);
12770   ins_encode(OpcP, RegReg_Hi2(src, src));
12771   ins_pipe(ialu_cr_reg_reg);
12772 %}
12773 
12774 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12775 // compares.  Can be used for LE or GT compares by reversing arguments.
12776 // NOT GOOD FOR EQ/NE tests.
12777 instruct cmpUL_reg_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src1, eRegL src2, rRegI tmp) %{
12778   match(Set flags (CmpUL src1 src2));
12779   effect(TEMP tmp);
12780   ins_cost(300);
12781   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12782             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12783             &quot;SBB    $tmp,$src2.hi\t! Compute flags for unsigned long compare&quot; %}
12784   ins_encode(long_cmp_flags2(src1, src2, tmp));
12785   ins_pipe(ialu_cr_reg_reg);
12786 %}
12787 
12788 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
12789 // Just a wrapper for a normal branch, plus the predicate test.
12790 instruct cmpUL_LTGE(cmpOpU cmp, flagsReg_ulong_LTGE flags, label labl) %{
12791   match(If cmp flags);
12792   effect(USE labl);
12793   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
12794   expand %{
12795     jmpCon(cmp, flags, labl);    // JLT or JGE...
12796   %}
12797 %}
12798 
12799 // Compare 2 longs and CMOVE longs.
12800 instruct cmovLL_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, eRegL src) %{
12801   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12802   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12803   ins_cost(400);
12804   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12805             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12806   opcode(0x0F,0x40);
12807   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12808   ins_pipe( pipe_cmov_reg_long );
12809 %}
12810 
12811 instruct cmovLL_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, load_long_memory src) %{
12812   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12813   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12814   ins_cost(500);
12815   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12816             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12817   opcode(0x0F,0x40);
12818   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12819   ins_pipe( pipe_cmov_reg_long );
12820 %}
12821 
12822 // Compare 2 longs and CMOVE ints.
12823 instruct cmovII_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, rRegI src) %{
12824   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12825   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12826   ins_cost(200);
12827   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12828   opcode(0x0F,0x40);
12829   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12830   ins_pipe( pipe_cmov_reg );
12831 %}
12832 
12833 instruct cmovII_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, memory src) %{
12834   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12835   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
12836   ins_cost(250);
12837   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12838   opcode(0x0F,0x40);
12839   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
12840   ins_pipe( pipe_cmov_mem );
12841 %}
12842 
12843 // Compare 2 longs and CMOVE ints.
12844 instruct cmovPP_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegP dst, eRegP src) %{
12845   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12846   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
12847   ins_cost(200);
12848   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12849   opcode(0x0F,0x40);
12850   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12851   ins_pipe( pipe_cmov_reg );
12852 %}
12853 
12854 // Compare 2 longs and CMOVE doubles
12855 instruct cmovDDPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regDPR dst, regDPR src) %{
12856   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12857   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12858   ins_cost(200);
12859   expand %{
12860     fcmovDPR_regS(cmp,flags,dst,src);
12861   %}
12862 %}
12863 
12864 // Compare 2 longs and CMOVE doubles
12865 instruct cmovDD_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regD dst, regD src) %{
12866   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12867   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12868   ins_cost(200);
12869   expand %{
12870     fcmovD_regS(cmp,flags,dst,src);
12871   %}
12872 %}
12873 
12874 instruct cmovFFPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regFPR dst, regFPR src) %{
12875   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12876   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12877   ins_cost(200);
12878   expand %{
12879     fcmovFPR_regS(cmp,flags,dst,src);
12880   %}
12881 %}
12882 
12883 instruct cmovFF_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regF dst, regF src) %{
12884   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12885   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12886   ins_cost(200);
12887   expand %{
12888     fcmovF_regS(cmp,flags,dst,src);
12889   %}
12890 %}
12891 
12892 //======
12893 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12894 instruct cmpL_zero_flags_EQNE( flagsReg_long_EQNE flags, eRegL src, immL0 zero, rRegI tmp ) %{
12895   match( Set flags (CmpL src zero ));
12896   effect(TEMP tmp);
12897   ins_cost(200);
12898   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12899             &quot;OR     $tmp,$src.hi\t! Long is EQ/NE 0?&quot; %}
12900   ins_encode( long_cmp_flags0( src, tmp ) );
12901   ins_pipe( ialu_reg_reg_long );
12902 %}
12903 
12904 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12905 instruct cmpL_reg_flags_EQNE( flagsReg_long_EQNE flags, eRegL src1, eRegL src2 ) %{
12906   match( Set flags (CmpL src1 src2 ));
12907   ins_cost(200+300);
12908   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12909             &quot;JNE,s  skip\n\t&quot;
12910             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12911      &quot;skip:\t&quot; %}
12912   ins_encode( long_cmp_flags1( src1, src2 ) );
12913   ins_pipe( ialu_cr_reg_reg );
12914 %}
12915 
12916 // Long compare reg == zero/reg OR reg != zero/reg
12917 // Just a wrapper for a normal branch, plus the predicate test.
12918 instruct cmpL_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, label labl) %{
12919   match(If cmp flags);
12920   effect(USE labl);
12921   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
12922   expand %{
12923     jmpCon(cmp,flags,labl);    // JEQ or JNE...
12924   %}
12925 %}
12926 
12927 //======
12928 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12929 instruct cmpUL_zero_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src, immL0 zero, rRegI tmp) %{
12930   match(Set flags (CmpUL src zero));
12931   effect(TEMP tmp);
12932   ins_cost(200);
12933   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12934             &quot;OR     $tmp,$src.hi\t! Unsigned long is EQ/NE 0?&quot; %}
12935   ins_encode(long_cmp_flags0(src, tmp));
12936   ins_pipe(ialu_reg_reg_long);
12937 %}
12938 
12939 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12940 instruct cmpUL_reg_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src1, eRegL src2) %{
12941   match(Set flags (CmpUL src1 src2));
12942   ins_cost(200+300);
12943   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12944             &quot;JNE,s  skip\n\t&quot;
12945             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12946      &quot;skip:\t&quot; %}
12947   ins_encode(long_cmp_flags1(src1, src2));
12948   ins_pipe(ialu_cr_reg_reg);
12949 %}
12950 
12951 // Unsigned long compare reg == zero/reg OR reg != zero/reg
12952 // Just a wrapper for a normal branch, plus the predicate test.
12953 instruct cmpUL_EQNE(cmpOpU cmp, flagsReg_ulong_EQNE flags, label labl) %{
12954   match(If cmp flags);
12955   effect(USE labl);
12956   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne);
12957   expand %{
12958     jmpCon(cmp, flags, labl);    // JEQ or JNE...
12959   %}
12960 %}
12961 
12962 // Compare 2 longs and CMOVE longs.
12963 instruct cmovLL_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, eRegL src) %{
12964   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12965   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12966   ins_cost(400);
12967   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12968             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12969   opcode(0x0F,0x40);
12970   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12971   ins_pipe( pipe_cmov_reg_long );
12972 %}
12973 
12974 instruct cmovLL_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, load_long_memory src) %{
12975   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12976   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12977   ins_cost(500);
12978   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12979             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12980   opcode(0x0F,0x40);
12981   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12982   ins_pipe( pipe_cmov_reg_long );
12983 %}
12984 
12985 // Compare 2 longs and CMOVE ints.
12986 instruct cmovII_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, rRegI src) %{
12987   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12988   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12989   ins_cost(200);
12990   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12991   opcode(0x0F,0x40);
12992   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12993   ins_pipe( pipe_cmov_reg );
12994 %}
12995 
12996 instruct cmovII_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, memory src) %{
12997   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12998   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
12999   ins_cost(250);
13000   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13001   opcode(0x0F,0x40);
13002   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13003   ins_pipe( pipe_cmov_mem );
13004 %}
13005 
13006 // Compare 2 longs and CMOVE ints.
13007 instruct cmovPP_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegP dst, eRegP src) %{
13008   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13009   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13010   ins_cost(200);
13011   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13012   opcode(0x0F,0x40);
13013   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13014   ins_pipe( pipe_cmov_reg );
13015 %}
13016 
13017 // Compare 2 longs and CMOVE doubles
13018 instruct cmovDDPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regDPR dst, regDPR src) %{
13019   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13020   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13021   ins_cost(200);
13022   expand %{
13023     fcmovDPR_regS(cmp,flags,dst,src);
13024   %}
13025 %}
13026 
13027 // Compare 2 longs and CMOVE doubles
13028 instruct cmovDD_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regD dst, regD src) %{
13029   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13030   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13031   ins_cost(200);
13032   expand %{
13033     fcmovD_regS(cmp,flags,dst,src);
13034   %}
13035 %}
13036 
13037 instruct cmovFFPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regFPR dst, regFPR src) %{
13038   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13039   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13040   ins_cost(200);
13041   expand %{
13042     fcmovFPR_regS(cmp,flags,dst,src);
13043   %}
13044 %}
13045 
13046 instruct cmovFF_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regF dst, regF src) %{
13047   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13048   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13049   ins_cost(200);
13050   expand %{
13051     fcmovF_regS(cmp,flags,dst,src);
13052   %}
13053 %}
13054 
13055 //======
13056 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13057 // Same as cmpL_reg_flags_LEGT except must negate src
13058 instruct cmpL_zero_flags_LEGT( flagsReg_long_LEGT flags, eRegL src, immL0 zero, rRegI tmp ) %{
13059   match( Set flags (CmpL src zero ));
13060   effect( TEMP tmp );
13061   ins_cost(300);
13062   format %{ &quot;XOR    $tmp,$tmp\t# Long compare for -$src &lt; 0, use commuted test\n\t&quot;
13063             &quot;CMP    $tmp,$src.lo\n\t&quot;
13064             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13065   ins_encode( long_cmp_flags3(src, tmp) );
13066   ins_pipe( ialu_reg_reg_long );
13067 %}
13068 
13069 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13070 // Same as cmpL_reg_flags_LTGE except operands swapped.  Swapping operands
13071 // requires a commuted test to get the same result.
13072 instruct cmpL_reg_flags_LEGT( flagsReg_long_LEGT flags, eRegL src1, eRegL src2, rRegI tmp ) %{
13073   match( Set flags (CmpL src1 src2 ));
13074   effect( TEMP tmp );
13075   ins_cost(300);
13076   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Long compare, swapped operands, use with commuted test\n\t&quot;
13077             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13078             &quot;SBB    $tmp,$src1.hi\t! Compute flags for long compare&quot; %}
13079   ins_encode( long_cmp_flags2( src2, src1, tmp ) );
13080   ins_pipe( ialu_cr_reg_reg );
13081 %}
13082 
13083 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
13084 // Just a wrapper for a normal branch, plus the predicate test
13085 instruct cmpL_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, label labl) %{
13086   match(If cmp flags);
13087   effect(USE labl);
13088   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le );
13089   ins_cost(300);
13090   expand %{
13091     jmpCon(cmp,flags,labl);    // JGT or JLE...
13092   %}
13093 %}
13094 
13095 //======
13096 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13097 // Same as cmpUL_reg_flags_LEGT except must negate src
13098 instruct cmpUL_zero_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src, immL0 zero, rRegI tmp) %{
13099   match(Set flags (CmpUL src zero));
13100   effect(TEMP tmp);
13101   ins_cost(300);
13102   format %{ &quot;XOR    $tmp,$tmp\t# Unsigned long compare for -$src &lt; 0, use commuted test\n\t&quot;
13103             &quot;CMP    $tmp,$src.lo\n\t&quot;
13104             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13105   ins_encode(long_cmp_flags3(src, tmp));
13106   ins_pipe(ialu_reg_reg_long);
13107 %}
13108 
13109 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13110 // Same as cmpUL_reg_flags_LTGE except operands swapped.  Swapping operands
13111 // requires a commuted test to get the same result.
13112 instruct cmpUL_reg_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src1, eRegL src2, rRegI tmp) %{
13113   match(Set flags (CmpUL src1 src2));
13114   effect(TEMP tmp);
13115   ins_cost(300);
13116   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Unsigned long compare, swapped operands, use with commuted test\n\t&quot;
13117             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13118             &quot;SBB    $tmp,$src1.hi\t! Compute flags for unsigned long compare&quot; %}
13119   ins_encode(long_cmp_flags2( src2, src1, tmp));
13120   ins_pipe(ialu_cr_reg_reg);
13121 %}
13122 
13123 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
13124 // Just a wrapper for a normal branch, plus the predicate test
13125 instruct cmpUL_LEGT(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, label labl) %{
13126   match(If cmp flags);
13127   effect(USE labl);
13128   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le);
13129   ins_cost(300);
13130   expand %{
13131     jmpCon(cmp, flags, labl);    // JGT or JLE...
13132   %}
13133 %}
13134 
13135 // Compare 2 longs and CMOVE longs.
13136 instruct cmovLL_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, eRegL src) %{
13137   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
13138   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13139   ins_cost(400);
13140   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13141             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
13142   opcode(0x0F,0x40);
13143   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
13144   ins_pipe( pipe_cmov_reg_long );
13145 %}
13146 
13147 instruct cmovLL_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, load_long_memory src) %{
13148   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
13149   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13150   ins_cost(500);
13151   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13152             &quot;CMOV$cmp $dst.hi,$src.hi+4&quot; %}
13153   opcode(0x0F,0x40);
13154   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13155   ins_pipe( pipe_cmov_reg_long );
13156 %}
13157 
13158 // Compare 2 longs and CMOVE ints.
13159 instruct cmovII_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, rRegI src) %{
13160   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13161   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13162   ins_cost(200);
13163   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13164   opcode(0x0F,0x40);
13165   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13166   ins_pipe( pipe_cmov_reg );
13167 %}
13168 
13169 instruct cmovII_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, memory src) %{
13170   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13171   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13172   ins_cost(250);
13173   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13174   opcode(0x0F,0x40);
13175   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13176   ins_pipe( pipe_cmov_mem );
13177 %}
13178 
13179 // Compare 2 longs and CMOVE ptrs.
13180 instruct cmovPP_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegP dst, eRegP src) %{
13181   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13182   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13183   ins_cost(200);
13184   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13185   opcode(0x0F,0x40);
13186   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13187   ins_pipe( pipe_cmov_reg );
13188 %}
13189 
13190 // Compare 2 longs and CMOVE doubles
13191 instruct cmovDDPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regDPR dst, regDPR src) %{
13192   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13193   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13194   ins_cost(200);
13195   expand %{
13196     fcmovDPR_regS(cmp,flags,dst,src);
13197   %}
13198 %}
13199 
13200 // Compare 2 longs and CMOVE doubles
13201 instruct cmovDD_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regD dst, regD src) %{
13202   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13203   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13204   ins_cost(200);
13205   expand %{
13206     fcmovD_regS(cmp,flags,dst,src);
13207   %}
13208 %}
13209 
13210 instruct cmovFFPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regFPR dst, regFPR src) %{
13211   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13212   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13213   ins_cost(200);
13214   expand %{
13215     fcmovFPR_regS(cmp,flags,dst,src);
13216   %}
13217 %}
13218 
13219 
13220 instruct cmovFF_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regF dst, regF src) %{
13221   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13222   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13223   ins_cost(200);
13224   expand %{
13225     fcmovF_regS(cmp,flags,dst,src);
13226   %}
13227 %}
13228 
13229 
13230 // ============================================================================
13231 // Procedure Call/Return Instructions
13232 // Call Java Static Instruction
13233 // Note: If this code changes, the corresponding ret_addr_offset() and
13234 //       compute_padding() functions will have to be adjusted.
13235 instruct CallStaticJavaDirect(method meth) %{
13236   match(CallStaticJava);
13237   effect(USE meth);
13238 
13239   ins_cost(300);
13240   format %{ &quot;CALL,static &quot; %}
13241   opcode(0xE8); /* E8 cd */
13242   ins_encode( pre_call_resets,
13243               Java_Static_Call( meth ),
13244               call_epilog,
13245               post_call_FPU );
13246   ins_pipe( pipe_slow );
13247   ins_alignment(4);
13248 %}
13249 
13250 // Call Java Dynamic Instruction
13251 // Note: If this code changes, the corresponding ret_addr_offset() and
13252 //       compute_padding() functions will have to be adjusted.
13253 instruct CallDynamicJavaDirect(method meth) %{
13254   match(CallDynamicJava);
13255   effect(USE meth);
13256 
13257   ins_cost(300);
13258   format %{ &quot;MOV    EAX,(oop)-1\n\t&quot;
13259             &quot;CALL,dynamic&quot; %}
13260   opcode(0xE8); /* E8 cd */
13261   ins_encode( pre_call_resets,
13262               Java_Dynamic_Call( meth ),
13263               call_epilog,
13264               post_call_FPU );
13265   ins_pipe( pipe_slow );
13266   ins_alignment(4);
13267 %}
13268 
13269 // Call Runtime Instruction
13270 instruct CallRuntimeDirect(method meth) %{
13271   match(CallRuntime );
13272   effect(USE meth);
13273 
13274   ins_cost(300);
13275   format %{ &quot;CALL,runtime &quot; %}
13276   opcode(0xE8); /* E8 cd */
13277   // Use FFREEs to clear entries in float stack
13278   ins_encode( pre_call_resets,
13279               FFree_Float_Stack_All,
13280               Java_To_Runtime( meth ),
13281               post_call_FPU );
13282   ins_pipe( pipe_slow );
13283 %}
13284 
13285 // Call runtime without safepoint
13286 instruct CallLeafDirect(method meth) %{
13287   match(CallLeaf);
13288   effect(USE meth);
13289 
13290   ins_cost(300);
13291   format %{ &quot;CALL_LEAF,runtime &quot; %}
13292   opcode(0xE8); /* E8 cd */
13293   ins_encode( pre_call_resets,
13294               FFree_Float_Stack_All,
13295               Java_To_Runtime( meth ),
13296               Verify_FPU_For_Leaf, post_call_FPU );
13297   ins_pipe( pipe_slow );
13298 %}
13299 
13300 instruct CallLeafNoFPDirect(method meth) %{
13301   match(CallLeafNoFP);
13302   effect(USE meth);
13303 
13304   ins_cost(300);
13305   format %{ &quot;CALL_LEAF_NOFP,runtime &quot; %}
13306   opcode(0xE8); /* E8 cd */
13307   ins_encode(pre_call_resets, Java_To_Runtime(meth));
13308   ins_pipe( pipe_slow );
13309 %}
13310 
13311 
13312 // Return Instruction
13313 // Remove the return address &amp; jump to it.
13314 instruct Ret() %{
13315   match(Return);
13316   format %{ &quot;RET&quot; %}
13317   opcode(0xC3);
13318   ins_encode(OpcP);
13319   ins_pipe( pipe_jmp );
13320 %}
13321 
13322 // Tail Call; Jump from runtime stub to Java code.
13323 // Also known as an &#39;interprocedural jump&#39;.
13324 // Target of jump will eventually return to caller.
13325 // TailJump below removes the return address.
13326 instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_oop) %{
13327   match(TailCall jump_target method_oop );
13328   ins_cost(300);
13329   format %{ &quot;JMP    $jump_target \t# EBX holds method oop&quot; %}
13330   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13331   ins_encode( OpcP, RegOpc(jump_target) );
13332   ins_pipe( pipe_jmp );
13333 %}
13334 
13335 
13336 // Tail Jump; remove the return address; jump to target.
13337 // TailCall above leaves the return address around.
13338 instruct tailjmpInd(eRegP_no_EBP jump_target, eAXRegP ex_oop) %{
13339   match( TailJump jump_target ex_oop );
13340   ins_cost(300);
13341   format %{ &quot;POP    EDX\t# pop return address into dummy\n\t&quot;
13342             &quot;JMP    $jump_target &quot; %}
13343   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13344   ins_encode( enc_pop_rdx,
13345               OpcP, RegOpc(jump_target) );
13346   ins_pipe( pipe_jmp );
13347 %}
13348 
13349 // Create exception oop: created by stack-crawling runtime code.
13350 // Created exception is now available to this handler, and is setup
13351 // just prior to jumping to this handler.  No code emitted.
13352 instruct CreateException( eAXRegP ex_oop )
13353 %{
13354   match(Set ex_oop (CreateEx));
13355 
13356   size(0);
13357   // use the following format syntax
13358   format %{ &quot;# exception oop is in EAX; no code emitted&quot; %}
13359   ins_encode();
13360   ins_pipe( empty );
13361 %}
13362 
13363 
13364 // Rethrow exception:
13365 // The exception oop will come in the first argument position.
13366 // Then JUMP (not call) to the rethrow stub code.
13367 instruct RethrowException()
13368 %{
13369   match(Rethrow);
13370 
13371   // use the following format syntax
13372   format %{ &quot;JMP    rethrow_stub&quot; %}
13373   ins_encode(enc_rethrow);
13374   ins_pipe( pipe_jmp );
13375 %}
13376 
13377 // inlined locking and unlocking
13378 
13379 instruct cmpFastLockRTM(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eDXRegI scr, rRegI cx1, rRegI cx2) %{
13380   predicate(Compile::current()-&gt;use_rtm());
13381   match(Set cr (FastLock object box));
13382   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
13383   ins_cost(300);
13384   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
13385   ins_encode %{
13386     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13387                  $scr$$Register, $cx1$$Register, $cx2$$Register,
13388                  _counters, _rtm_counters, _stack_rtm_counters,
13389                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
13390                  true, ra_-&gt;C-&gt;profile_rtm());
13391   %}
13392   ins_pipe(pipe_slow);
13393 %}
13394 
13395 instruct cmpFastLock(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eRegP scr) %{
13396   predicate(!Compile::current()-&gt;use_rtm());
13397   match(Set cr (FastLock object box));
13398   effect(TEMP tmp, TEMP scr, USE_KILL box);
13399   ins_cost(300);
13400   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr&quot; %}
13401   ins_encode %{
13402     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13403                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13404   %}
13405   ins_pipe(pipe_slow);
13406 %}
13407 
13408 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13409   match(Set cr (FastUnlock object box));
13410   effect(TEMP tmp, USE_KILL box);
13411   ins_cost(300);
13412   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13413   ins_encode %{
13414     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13415   %}
13416   ins_pipe(pipe_slow);
13417 %}
13418 
13419 
13420 
13421 // ============================================================================
13422 // Safepoint Instruction
13423 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{
13424   match(SafePoint poll);
13425   effect(KILL cr, USE poll);
13426 
13427   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13428   ins_cost(125);
13429   // EBP would need size(3)
13430   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13431   ins_encode %{
13432     __ relocate(relocInfo::poll_type);
13433     address pre_pc = __ pc();
13434     __ testl(rax, Address($poll$$Register, 0));
13435     address post_pc = __ pc();
13436     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13437   %}
13438   ins_pipe(ialu_reg_mem);
13439 %}
13440 
13441 
13442 // ============================================================================
13443 // This name is KNOWN by the ADLC and cannot be changed.
13444 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
13445 // for this guy.
13446 instruct tlsLoadP(eRegP dst, eFlagsReg cr) %{
13447   match(Set dst (ThreadLocal));
13448   effect(DEF dst, KILL cr);
13449 
13450   format %{ &quot;MOV    $dst, Thread::current()&quot; %}
13451   ins_encode %{
13452     Register dstReg = as_Register($dst$$reg);
13453     __ get_thread(dstReg);
13454   %}
13455   ins_pipe( ialu_reg_fat );
13456 %}
13457 
13458 
13459 
13460 //----------PEEPHOLE RULES-----------------------------------------------------
13461 // These must follow all instruction definitions as they use the names
13462 // defined in the instructions definitions.
13463 //
13464 // peepmatch ( root_instr_name [preceding_instruction]* );
13465 //
13466 // peepconstraint %{
13467 // (instruction_number.operand_name relational_op instruction_number.operand_name
13468 //  [, ...] );
13469 // // instruction numbers are zero-based using left to right order in peepmatch
13470 //
13471 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
13472 // // provide an instruction_number.operand_name for each operand that appears
13473 // // in the replacement instruction&#39;s match rule
13474 //
13475 // ---------VM FLAGS---------------------------------------------------------
13476 //
13477 // All peephole optimizations can be turned off using -XX:-OptoPeephole
13478 //
13479 // Each peephole rule is given an identifying number starting with zero and
13480 // increasing by one in the order seen by the parser.  An individual peephole
13481 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
13482 // on the command-line.
13483 //
13484 // ---------CURRENT LIMITATIONS----------------------------------------------
13485 //
13486 // Only match adjacent instructions in same basic block
13487 // Only equality constraints
13488 // Only constraints between operands, not (0.dest_reg == EAX_enc)
13489 // Only one replacement instruction
13490 //
13491 // ---------EXAMPLE----------------------------------------------------------
13492 //
13493 // // pertinent parts of existing instructions in architecture description
13494 // instruct movI(rRegI dst, rRegI src) %{
13495 //   match(Set dst (CopyI src));
13496 // %}
13497 //
13498 // instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
13499 //   match(Set dst (AddI dst src));
13500 //   effect(KILL cr);
13501 // %}
13502 //
13503 // // Change (inc mov) to lea
13504 // peephole %{
13505 //   // increment preceeded by register-register move
13506 //   peepmatch ( incI_eReg movI );
13507 //   // require that the destination register of the increment
13508 //   // match the destination register of the move
13509 //   peepconstraint ( 0.dst == 1.dst );
13510 //   // construct a replacement instruction that sets
13511 //   // the destination to ( move&#39;s source register + one )
13512 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13513 // %}
13514 //
13515 // Implementation no longer uses movX instructions since
13516 // machine-independent system no longer uses CopyX nodes.
13517 //
13518 // peephole %{
13519 //   peepmatch ( incI_eReg movI );
13520 //   peepconstraint ( 0.dst == 1.dst );
13521 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13522 // %}
13523 //
13524 // peephole %{
13525 //   peepmatch ( decI_eReg movI );
13526 //   peepconstraint ( 0.dst == 1.dst );
13527 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13528 // %}
13529 //
13530 // peephole %{
13531 //   peepmatch ( addI_eReg_imm movI );
13532 //   peepconstraint ( 0.dst == 1.dst );
13533 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13534 // %}
13535 //
13536 // peephole %{
13537 //   peepmatch ( addP_eReg_imm movP );
13538 //   peepconstraint ( 0.dst == 1.dst );
13539 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
13540 // %}
13541 
13542 // // Change load of spilled value to only a spill
13543 // instruct storeI(memory mem, rRegI src) %{
13544 //   match(Set mem (StoreI mem src));
13545 // %}
13546 //
13547 // instruct loadI(rRegI dst, memory mem) %{
13548 //   match(Set dst (LoadI mem));
13549 // %}
13550 //
13551 peephole %{
13552   peepmatch ( loadI storeI );
13553   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13554   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
13555 %}
13556 
13557 //----------SMARTSPILL RULES---------------------------------------------------
13558 // These must follow all instruction definitions as they use the names
13559 // defined in the instructions definitions.
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../.hgtags.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/classfile/javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 1625   if (C-&gt;output()-&gt;need_stack_bang(framesize))
 1626     st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
 1627 
 1628   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1629     st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
 1630     st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
 1631     if (PreserveFramePointer) st-&gt;print(&quot;\n\tadd  rfp, sp, #%d&quot;, framesize - 2 * wordSize);
 1632   } else {
 1633     st-&gt;print(&quot;stp  lr, rfp, [sp, #%d]!\n\t&quot;, -(2 * wordSize));
 1634     if (PreserveFramePointer) st-&gt;print(&quot;mov  rfp, sp\n\t&quot;);
 1635     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1636     st-&gt;print(&quot;sub  sp, sp, rscratch1&quot;);
 1637   }
 1638 }
 1639 #endif
 1640 
 1641 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1642   Compile* C = ra_-&gt;C;
 1643   C2_MacroAssembler _masm(&amp;cbuf);
 1644 
<span class="line-modified"> 1645   // n.b. frame size includes space for return pc and rfp</span>
<span class="line-modified"> 1646   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-removed"> 1647   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);</span>
<span class="line-removed"> 1648 </span>
<span class="line-removed"> 1649   // insert a nop at the start of the prolog so we can patch in a</span>
<span class="line-removed"> 1650   // branch if we need to invalidate the method later</span>
<span class="line-removed"> 1651   __ nop();</span>
<span class="line-removed"> 1652 </span>
<span class="line-removed"> 1653   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-removed"> 1654     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-removed"> 1655 </span>
<span class="line-removed"> 1656     Label L_skip_barrier;</span>
<span class="line-removed"> 1657 </span>
<span class="line-removed"> 1658     __ mov_metadata(rscratch2, C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-removed"> 1659     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-removed"> 1660     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-removed"> 1661     __ bind(L_skip_barrier);</span>
<span class="line-removed"> 1662   }</span>
<span class="line-removed"> 1663 </span>
<span class="line-removed"> 1664   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-removed"> 1665   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="line-removed"> 1666     __ generate_stack_overflow_check(bangsize);</span>
<span class="line-removed"> 1667 </span>
<span class="line-removed"> 1668   __ build_frame(framesize);</span>
<span class="line-removed"> 1669 </span>
<span class="line-removed"> 1670   if (VerifyStackAtCalls) {</span>
<span class="line-removed"> 1671     Unimplemented();</span>
<span class="line-removed"> 1672   }</span>
 1673 
 1674   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
 1675 
 1676   if (C-&gt;has_mach_constant_base_node()) {
 1677     // NOTE: We set the table base offset here because users might be
 1678     // emitted before MachConstantBaseNode.
 1679     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
 1680     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1681   }
 1682 }
 1683 
 1684 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 1685 {
 1686   return MachNode::size(ra_); // too many variables; just compute it
 1687                               // the hard way
 1688 }
 1689 
 1690 int MachPrologNode::reloc() const
 1691 {
 1692   return 0;
</pre>
<hr />
<pre>
 1962 #endif
 1963 
 1964 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1965   C2_MacroAssembler _masm(&amp;cbuf);
 1966 
 1967   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1968   int reg    = ra_-&gt;get_encode(this);
 1969 
 1970   if (Assembler::operand_valid_for_add_sub_immediate(offset)) {
 1971     __ add(as_Register(reg), sp, offset);
 1972   } else {
 1973     ShouldNotReachHere();
 1974   }
 1975 }
 1976 
 1977 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1978   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 1979   return 4;
 1980 }
 1981 
<span class="line-modified"> 1982 //=============================================================================</span>





































 1983 

 1984 #ifndef PRODUCT
 1985 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1986 {
 1987   st-&gt;print_cr(&quot;# MachUEPNode&quot;);
 1988   if (UseCompressedClassPointers) {
 1989     st-&gt;print_cr(&quot;\tldrw rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1990     if (CompressedKlassPointers::shift() != 0) {
 1991       st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1992     }
 1993   } else {
 1994    st-&gt;print_cr(&quot;\tldr rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1995   }
 1996   st-&gt;print_cr(&quot;\tcmp r0, rscratch1\t # Inline cache check&quot;);
 1997   st-&gt;print_cr(&quot;\tbne, SharedRuntime::_ic_miss_stub&quot;);
 1998 }
 1999 #endif
 2000 
 2001 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 2002 {
 2003   // This is the unverified entry point.
 2004   C2_MacroAssembler _masm(&amp;cbuf);

 2005 

 2006   __ cmp_klass(j_rarg0, rscratch2, rscratch1);
<span class="line-modified"> 2007   Label skip;</span>
 2008   // TODO
 2009   // can we avoid this skip and still use a reloc?
 2010   __ br(Assembler::EQ, skip);
 2011   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 2012   __ bind(skip);
 2013 }
 2014 
 2015 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
 2016 {
 2017   return MachNode::size(ra_);
 2018 }
 2019 
 2020 // REQUIRED EMIT CODE
 2021 
 2022 //=============================================================================
 2023 
 2024 // Emit exception handler code.
 2025 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf)
 2026 {
 2027   // mov rscratch1 #exception_blob_entry_point
</pre>
<hr />
<pre>
 2403     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
 2404     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
 2405     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
 2406     return true;
 2407   } else if (off-&gt;Opcode() == Op_ConvI2L &amp;&amp;
 2408              // Are there other uses besides address expressions?
 2409              !is_visited(off)) {
 2410     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
 2411     address_visited.set(off-&gt;_idx); // Flag as address_visited
 2412     mstack.push(off-&gt;in(1), Pre_Visit);
 2413     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
 2414     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
 2415     return true;
 2416   }
 2417   return false;
 2418 }
 2419 
 2420 void Compile::reshape_address(AddPNode* addp) {
 2421 }
 2422 
<span class="line-removed"> 2423 </span>
 2424 #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
 2425   C2_MacroAssembler _masm(&amp;cbuf);                                       \
 2426   {                                                                     \
 2427     guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
 2428     guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
 2429     guarantee(SCALE == 0, &quot;mode not permitted for volatile&quot;);           \
 2430     __ INSN(REG, as_Register(BASE));                                    \
 2431   }
 2432 
 2433 
 2434 static Address mem2address(int opcode, Register base, int index, int size, int disp)
 2435   {
 2436     Address::extend scale;
 2437 
 2438     // Hooboy, this is fugly.  We need a way to communicate to the
 2439     // encoder that the index needs to be sign extended, so we have to
 2440     // enumerate all the cases.
 2441     switch (opcode) {
 2442     case INDINDEXSCALEDI2L:
 2443     case INDINDEXSCALEDI2LN:
</pre>
<hr />
<pre>
 8265 %}
 8266 
 8267 // ============================================================================
 8268 // Cast/Convert Instructions
 8269 
 8270 instruct castX2P(iRegPNoSp dst, iRegL src) %{
 8271   match(Set dst (CastX2P src));
 8272 
 8273   ins_cost(INSN_COST);
 8274   format %{ &quot;mov $dst, $src\t# long -&gt; ptr&quot; %}
 8275 
 8276   ins_encode %{
 8277     if ($dst$$reg != $src$$reg) {
 8278       __ mov(as_Register($dst$$reg), as_Register($src$$reg));
 8279     }
 8280   %}
 8281 
 8282   ins_pipe(ialu_reg);
 8283 %}
 8284 















 8285 instruct castP2X(iRegLNoSp dst, iRegP src) %{
 8286   match(Set dst (CastP2X src));
 8287 
 8288   ins_cost(INSN_COST);
 8289   format %{ &quot;mov $dst, $src\t# ptr -&gt; long&quot; %}
 8290 
 8291   ins_encode %{
 8292     if ($dst$$reg != $src$$reg) {
 8293       __ mov(as_Register($dst$$reg), as_Register($src$$reg));
 8294     }
 8295   %}
 8296 
 8297   ins_pipe(ialu_reg);
 8298 %}
 8299 































 8300 // Convert oop into int for vectors alignment masking
 8301 instruct convP2I(iRegINoSp dst, iRegP src) %{
 8302   match(Set dst (ConvL2I (CastP2X src)));
 8303 
 8304   ins_cost(INSN_COST);
 8305   format %{ &quot;movw $dst, $src\t# ptr -&gt; int&quot; %}
 8306   ins_encode %{
 8307     __ movw($dst$$Register, $src$$Register);
 8308   %}
 8309 
 8310   ins_pipe(ialu_reg);
 8311 %}
 8312 
 8313 // Convert compressed oop into int for vectors alignment masking
 8314 // in case of 32bit oops (heap &lt; 4Gb).
 8315 instruct convN2I(iRegINoSp dst, iRegN src)
 8316 %{
 8317   predicate(CompressedOops::shift() == 0);
 8318   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 8319 
</pre>
<hr />
<pre>
13873 
13874   match(Set dst (MoveL2D src));
13875 
13876   effect(DEF dst, USE src);
13877 
13878   ins_cost(INSN_COST);
13879 
13880   format %{ &quot;fmovd $dst, $src\t# MoveL2D_reg_reg&quot; %}
13881 
13882   ins_encode %{
13883     __ fmovd(as_FloatRegister($dst$$reg), $src$$Register);
13884   %}
13885 
13886   ins_pipe(fp_l2d);
13887 
13888 %}
13889 
13890 // ============================================================================
13891 // clearing of an array
13892 
<span class="line-modified">13893 instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)</span>
13894 %{
<span class="line-modified">13895   match(Set dummy (ClearArray cnt base));</span>
13896   effect(USE_KILL cnt, USE_KILL base);
13897 
13898   ins_cost(4 * INSN_COST);
<span class="line-modified">13899   format %{ &quot;ClearArray $cnt, $base&quot; %}</span>
<span class="line-removed">13900 </span>
<span class="line-removed">13901   ins_encode %{</span>
<span class="line-removed">13902     __ zero_words($base$$Register, $cnt$$Register);</span>
<span class="line-removed">13903   %}</span>
<span class="line-removed">13904 </span>
<span class="line-removed">13905   ins_pipe(pipe_class_memory);</span>
<span class="line-removed">13906 %}</span>
<span class="line-removed">13907 </span>
<span class="line-removed">13908 instruct clearArray_imm_reg(immL cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)</span>
<span class="line-removed">13909 %{</span>
<span class="line-removed">13910   predicate((u_int64_t)n-&gt;in(2)-&gt;get_long()</span>
<span class="line-removed">13911             &lt; (u_int64_t)(BlockZeroingLowLimit &gt;&gt; LogBytesPerWord));</span>
<span class="line-removed">13912   match(Set dummy (ClearArray cnt base));</span>
<span class="line-removed">13913   effect(USE_KILL base);</span>
<span class="line-removed">13914 </span>
<span class="line-removed">13915   ins_cost(4 * INSN_COST);</span>
<span class="line-removed">13916   format %{ &quot;ClearArray $cnt, $base&quot; %}</span>
13917 
13918   ins_encode %{
<span class="line-modified">13919     __ zero_words($base$$Register, (u_int64_t)$cnt$$constant);</span>
13920   %}
13921 
13922   ins_pipe(pipe_class_memory);
13923 %}
13924 
13925 // ============================================================================
13926 // Overflow Math Instructions
13927 
13928 instruct overflowAddI_reg_reg(rFlagsReg cr, iRegIorL2I op1, iRegIorL2I op2)
13929 %{
13930   match(Set cr (OverflowAddI op1 op2));
13931 
13932   format %{ &quot;cmnw  $op1, $op2\t# overflow check int&quot; %}
13933   ins_cost(INSN_COST);
13934   ins_encode %{
13935     __ cmnw($op1$$Register, $op2$$Register);
13936   %}
13937 
13938   ins_pipe(icmp_reg_reg);
13939 %}
</pre>
</td>
<td>
<hr />
<pre>
 1625   if (C-&gt;output()-&gt;need_stack_bang(framesize))
 1626     st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
 1627 
 1628   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1629     st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
 1630     st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
 1631     if (PreserveFramePointer) st-&gt;print(&quot;\n\tadd  rfp, sp, #%d&quot;, framesize - 2 * wordSize);
 1632   } else {
 1633     st-&gt;print(&quot;stp  lr, rfp, [sp, #%d]!\n\t&quot;, -(2 * wordSize));
 1634     if (PreserveFramePointer) st-&gt;print(&quot;mov  rfp, sp\n\t&quot;);
 1635     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1636     st-&gt;print(&quot;sub  sp, sp, rscratch1&quot;);
 1637   }
 1638 }
 1639 #endif
 1640 
 1641 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1642   Compile* C = ra_-&gt;C;
 1643   C2_MacroAssembler _masm(&amp;cbuf);
 1644 
<span class="line-modified"> 1645   __ verified_entry(C, 0);</span>
<span class="line-modified"> 1646   __ bind(*_verified_entry);</span>


























 1647 
 1648   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
 1649 
 1650   if (C-&gt;has_mach_constant_base_node()) {
 1651     // NOTE: We set the table base offset here because users might be
 1652     // emitted before MachConstantBaseNode.
 1653     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
 1654     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1655   }
 1656 }
 1657 
 1658 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 1659 {
 1660   return MachNode::size(ra_); // too many variables; just compute it
 1661                               // the hard way
 1662 }
 1663 
 1664 int MachPrologNode::reloc() const
 1665 {
 1666   return 0;
</pre>
<hr />
<pre>
 1936 #endif
 1937 
 1938 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1939   C2_MacroAssembler _masm(&amp;cbuf);
 1940 
 1941   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1942   int reg    = ra_-&gt;get_encode(this);
 1943 
 1944   if (Assembler::operand_valid_for_add_sub_immediate(offset)) {
 1945     __ add(as_Register(reg), sp, offset);
 1946   } else {
 1947     ShouldNotReachHere();
 1948   }
 1949 }
 1950 
 1951 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1952   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 1953   return 4;
 1954 }
 1955 
<span class="line-modified"> 1956 ///=============================================================================</span>
<span class="line-added"> 1957 #ifndef PRODUCT</span>
<span class="line-added"> 1958 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const</span>
<span class="line-added"> 1959 {</span>
<span class="line-added"> 1960   st-&gt;print_cr(&quot;# MachVEPNode&quot;);</span>
<span class="line-added"> 1961   if (!_verified) {</span>
<span class="line-added"> 1962     st-&gt;print_cr(&quot;\t load_class&quot;);</span>
<span class="line-added"> 1963   } else {</span>
<span class="line-added"> 1964     st-&gt;print_cr(&quot;\t unpack_value_arg&quot;);</span>
<span class="line-added"> 1965   }</span>
<span class="line-added"> 1966 }</span>
<span class="line-added"> 1967 #endif</span>
<span class="line-added"> 1968 </span>
<span class="line-added"> 1969 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const</span>
<span class="line-added"> 1970 {</span>
<span class="line-added"> 1971   MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-added"> 1972 </span>
<span class="line-added"> 1973   if (!_verified) {</span>
<span class="line-added"> 1974     Label skip;</span>
<span class="line-added"> 1975     __ cmp_klass(j_rarg0, rscratch2, rscratch1);</span>
<span class="line-added"> 1976     __ br(Assembler::EQ, skip);</span>
<span class="line-added"> 1977       __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));</span>
<span class="line-added"> 1978     __ bind(skip);</span>
<span class="line-added"> 1979 </span>
<span class="line-added"> 1980   } else {</span>
<span class="line-added"> 1981     // Unpack value type args passed as oop and then jump to</span>
<span class="line-added"> 1982     // the verified entry point (skipping the unverified entry).</span>
<span class="line-added"> 1983     __ unpack_value_args(ra_-&gt;C, _receiver_only);</span>
<span class="line-added"> 1984     __ b(*_verified_entry);</span>
<span class="line-added"> 1985   }</span>
<span class="line-added"> 1986 }</span>
<span class="line-added"> 1987 </span>
<span class="line-added"> 1988 </span>
<span class="line-added"> 1989 uint MachVEPNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-added"> 1990 {</span>
<span class="line-added"> 1991   return MachNode::size(ra_); // too many variables; just compute it the hard way</span>
<span class="line-added"> 1992 }</span>
<span class="line-added"> 1993 </span>
 1994 
<span class="line-added"> 1995 //=============================================================================</span>
 1996 #ifndef PRODUCT
 1997 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1998 {
 1999   st-&gt;print_cr(&quot;# MachUEPNode&quot;);
 2000   if (UseCompressedClassPointers) {
 2001     st-&gt;print_cr(&quot;\tldrw rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 2002     if (CompressedKlassPointers::shift() != 0) {
 2003       st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 2004     }
 2005   } else {
 2006    st-&gt;print_cr(&quot;\tldr rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 2007   }
 2008   st-&gt;print_cr(&quot;\tcmp r0, rscratch1\t # Inline cache check&quot;);
 2009   st-&gt;print_cr(&quot;\tbne, SharedRuntime::_ic_miss_stub&quot;);
 2010 }
 2011 #endif
 2012 
 2013 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 2014 {
 2015   // This is the unverified entry point.
 2016   C2_MacroAssembler _masm(&amp;cbuf);
<span class="line-added"> 2017   Label skip;</span>
 2018 
<span class="line-added"> 2019   // UseCompressedClassPointers logic are inside cmp_klass</span>
 2020   __ cmp_klass(j_rarg0, rscratch2, rscratch1);
<span class="line-modified"> 2021 </span>
 2022   // TODO
 2023   // can we avoid this skip and still use a reloc?
 2024   __ br(Assembler::EQ, skip);
 2025   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 2026   __ bind(skip);
 2027 }
 2028 
 2029 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
 2030 {
 2031   return MachNode::size(ra_);
 2032 }
 2033 
 2034 // REQUIRED EMIT CODE
 2035 
 2036 //=============================================================================
 2037 
 2038 // Emit exception handler code.
 2039 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf)
 2040 {
 2041   // mov rscratch1 #exception_blob_entry_point
</pre>
<hr />
<pre>
 2417     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
 2418     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
 2419     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
 2420     return true;
 2421   } else if (off-&gt;Opcode() == Op_ConvI2L &amp;&amp;
 2422              // Are there other uses besides address expressions?
 2423              !is_visited(off)) {
 2424     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
 2425     address_visited.set(off-&gt;_idx); // Flag as address_visited
 2426     mstack.push(off-&gt;in(1), Pre_Visit);
 2427     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
 2428     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
 2429     return true;
 2430   }
 2431   return false;
 2432 }
 2433 
 2434 void Compile::reshape_address(AddPNode* addp) {
 2435 }
 2436 

 2437 #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
 2438   C2_MacroAssembler _masm(&amp;cbuf);                                       \
 2439   {                                                                     \
 2440     guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
 2441     guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
 2442     guarantee(SCALE == 0, &quot;mode not permitted for volatile&quot;);           \
 2443     __ INSN(REG, as_Register(BASE));                                    \
 2444   }
 2445 
 2446 
 2447 static Address mem2address(int opcode, Register base, int index, int size, int disp)
 2448   {
 2449     Address::extend scale;
 2450 
 2451     // Hooboy, this is fugly.  We need a way to communicate to the
 2452     // encoder that the index needs to be sign extended, so we have to
 2453     // enumerate all the cases.
 2454     switch (opcode) {
 2455     case INDINDEXSCALEDI2L:
 2456     case INDINDEXSCALEDI2LN:
</pre>
<hr />
<pre>
 8278 %}
 8279 
 8280 // ============================================================================
 8281 // Cast/Convert Instructions
 8282 
 8283 instruct castX2P(iRegPNoSp dst, iRegL src) %{
 8284   match(Set dst (CastX2P src));
 8285 
 8286   ins_cost(INSN_COST);
 8287   format %{ &quot;mov $dst, $src\t# long -&gt; ptr&quot; %}
 8288 
 8289   ins_encode %{
 8290     if ($dst$$reg != $src$$reg) {
 8291       __ mov(as_Register($dst$$reg), as_Register($src$$reg));
 8292     }
 8293   %}
 8294 
 8295   ins_pipe(ialu_reg);
 8296 %}
 8297 
<span class="line-added"> 8298 instruct castN2X(iRegLNoSp dst, iRegN src) %{</span>
<span class="line-added"> 8299   match(Set dst (CastP2X src));</span>
<span class="line-added"> 8300 </span>
<span class="line-added"> 8301   ins_cost(INSN_COST);</span>
<span class="line-added"> 8302   format %{ &quot;mov $dst, $src\t# ptr -&gt; long&quot; %}</span>
<span class="line-added"> 8303 </span>
<span class="line-added"> 8304   ins_encode %{</span>
<span class="line-added"> 8305     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 8306       __ mov(as_Register($dst$$reg), as_Register($src$$reg));</span>
<span class="line-added"> 8307     }</span>
<span class="line-added"> 8308   %}</span>
<span class="line-added"> 8309 </span>
<span class="line-added"> 8310   ins_pipe(ialu_reg);</span>
<span class="line-added"> 8311 %}</span>
<span class="line-added"> 8312 </span>
 8313 instruct castP2X(iRegLNoSp dst, iRegP src) %{
 8314   match(Set dst (CastP2X src));
 8315 
 8316   ins_cost(INSN_COST);
 8317   format %{ &quot;mov $dst, $src\t# ptr -&gt; long&quot; %}
 8318 
 8319   ins_encode %{
 8320     if ($dst$$reg != $src$$reg) {
 8321       __ mov(as_Register($dst$$reg), as_Register($src$$reg));
 8322     }
 8323   %}
 8324 
 8325   ins_pipe(ialu_reg);
 8326 %}
 8327 
<span class="line-added"> 8328 instruct castN2I(iRegINoSp dst, iRegN src) %{</span>
<span class="line-added"> 8329   match(Set dst (CastN2I src));</span>
<span class="line-added"> 8330 </span>
<span class="line-added"> 8331   ins_cost(INSN_COST);</span>
<span class="line-added"> 8332   format %{ &quot;movw $dst, $src\t# compressed ptr -&gt; int&quot; %}</span>
<span class="line-added"> 8333 </span>
<span class="line-added"> 8334   ins_encode %{</span>
<span class="line-added"> 8335     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 8336       __ movw(as_Register($dst$$reg), as_Register($src$$reg));</span>
<span class="line-added"> 8337     }</span>
<span class="line-added"> 8338   %}</span>
<span class="line-added"> 8339 </span>
<span class="line-added"> 8340   ins_pipe(ialu_reg);</span>
<span class="line-added"> 8341 %}</span>
<span class="line-added"> 8342 </span>
<span class="line-added"> 8343 instruct castI2N(iRegNNoSp dst, iRegI src) %{</span>
<span class="line-added"> 8344   match(Set dst (CastI2N src));</span>
<span class="line-added"> 8345 </span>
<span class="line-added"> 8346   ins_cost(INSN_COST);</span>
<span class="line-added"> 8347   format %{ &quot;movw $dst, $src\t# int -&gt; compressed ptr&quot; %}</span>
<span class="line-added"> 8348 </span>
<span class="line-added"> 8349   ins_encode %{</span>
<span class="line-added"> 8350     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 8351       __ movw(as_Register($dst$$reg), as_Register($src$$reg));</span>
<span class="line-added"> 8352     }</span>
<span class="line-added"> 8353   %}</span>
<span class="line-added"> 8354 </span>
<span class="line-added"> 8355   ins_pipe(ialu_reg);</span>
<span class="line-added"> 8356 %}</span>
<span class="line-added"> 8357 </span>
<span class="line-added"> 8358 </span>
 8359 // Convert oop into int for vectors alignment masking
 8360 instruct convP2I(iRegINoSp dst, iRegP src) %{
 8361   match(Set dst (ConvL2I (CastP2X src)));
 8362 
 8363   ins_cost(INSN_COST);
 8364   format %{ &quot;movw $dst, $src\t# ptr -&gt; int&quot; %}
 8365   ins_encode %{
 8366     __ movw($dst$$Register, $src$$Register);
 8367   %}
 8368 
 8369   ins_pipe(ialu_reg);
 8370 %}
 8371 
 8372 // Convert compressed oop into int for vectors alignment masking
 8373 // in case of 32bit oops (heap &lt; 4Gb).
 8374 instruct convN2I(iRegINoSp dst, iRegN src)
 8375 %{
 8376   predicate(CompressedOops::shift() == 0);
 8377   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 8378 
</pre>
<hr />
<pre>
13932 
13933   match(Set dst (MoveL2D src));
13934 
13935   effect(DEF dst, USE src);
13936 
13937   ins_cost(INSN_COST);
13938 
13939   format %{ &quot;fmovd $dst, $src\t# MoveL2D_reg_reg&quot; %}
13940 
13941   ins_encode %{
13942     __ fmovd(as_FloatRegister($dst$$reg), $src$$Register);
13943   %}
13944 
13945   ins_pipe(fp_l2d);
13946 
13947 %}
13948 
13949 // ============================================================================
13950 // clearing of an array
13951 
<span class="line-modified">13952 instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, iRegL val, Universe dummy, rFlagsReg cr)</span>
13953 %{
<span class="line-modified">13954   match(Set dummy (ClearArray (Binary cnt base) val));</span>
13955   effect(USE_KILL cnt, USE_KILL base);
13956 
13957   ins_cost(4 * INSN_COST);
<span class="line-modified">13958   format %{ &quot;ClearArray $cnt, $base, $val&quot; %}</span>

















13959 
13960   ins_encode %{
<span class="line-modified">13961     __ fill_words($base$$Register, $cnt$$Register, $val$$Register);</span>
13962   %}
13963 
13964   ins_pipe(pipe_class_memory);
13965 %}
13966 
13967 // ============================================================================
13968 // Overflow Math Instructions
13969 
13970 instruct overflowAddI_reg_reg(rFlagsReg cr, iRegIorL2I op1, iRegIorL2I op2)
13971 %{
13972   match(Set cr (OverflowAddI op1 op2));
13973 
13974   format %{ &quot;cmnw  $op1, $op2\t# overflow check int&quot; %}
13975   ins_cost(INSN_COST);
13976   ins_encode %{
13977     __ cmnw($op1$$Register, $op2$$Register);
13978   %}
13979 
13980   ins_pipe(icmp_reg_reg);
13981 %}
</pre>
</td>
</tr>
</table>
<center><a href="../../../../.hgtags.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/classfile/javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
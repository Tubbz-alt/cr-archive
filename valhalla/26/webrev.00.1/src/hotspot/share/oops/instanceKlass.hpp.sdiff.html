<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include &quot;classfile/classLoaderData.hpp&quot;

  29 #include &quot;memory/referenceType.hpp&quot;
  30 #include &quot;oops/annotations.hpp&quot;
  31 #include &quot;oops/constMethod.hpp&quot;
  32 #include &quot;oops/fieldInfo.hpp&quot;
  33 #include &quot;oops/instanceOop.hpp&quot;
  34 #include &quot;oops/klassVtable.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;runtime/os.hpp&quot;
  37 #include &quot;utilities/accessFlags.hpp&quot;
  38 #include &quot;utilities/align.hpp&quot;
  39 #include &quot;utilities/macros.hpp&quot;
  40 #if INCLUDE_JFR
  41 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  42 #endif
  43 
  44 class RecordComponent;
  45 
  46 // An InstanceKlass is the VM level representation of a Java class.
  47 // It contains all information needed for at class at execution runtime.
  48 
  49 //  InstanceKlass embedded field layout (after declared fields):
  50 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  51 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  52 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  53 //      indicating where oops are located in instances of this klass.
  54 //    [EMBEDDED implementor of the interface] only exist for interface
  55 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  56 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true

  57 
  58 
  59 // forward declaration for class -- see below for definition
  60 #if INCLUDE_JVMTI
  61 class BreakpointInfo;
  62 #endif
  63 class ClassFileParser;
  64 class ClassFileStream;
  65 class KlassDepChange;
  66 class DependencyContext;
  67 class fieldDescriptor;
  68 class jniIdMapBase;
  69 class JNIid;
  70 class JvmtiCachedClassFieldMap;
  71 class nmethodBucket;
  72 class OopMapCache;

  73 class InterpreterOopMap;
  74 class PackageEntry;
  75 class ModuleEntry;
  76 
  77 // This is used in iterators below.
  78 class FieldClosure: public StackObj {
  79 public:
  80   virtual void do_field(fieldDescriptor* fd) = 0;
  81 };
  82 
  83 #ifndef PRODUCT
  84 // Print fields.
  85 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  86 class FieldPrinter: public FieldClosure {
  87    oop _obj;
  88    outputStream* _st;
  89  public:
  90    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  91    void do_field(fieldDescriptor* fd);
  92 };
</pre>
<hr />
<pre>
 115     return another_offset == end_offset();
 116   }
 117 
 118   // sizeof(OopMapBlock) in words.
 119   static const int size_in_words() {
 120     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 121       LogBytesPerWord;
 122   }
 123 
 124   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {
 125     return a-&gt;offset() - b-&gt;offset();
 126   }
 127 
 128  private:
 129   int  _offset;
 130   uint _count;
 131 };
 132 
 133 struct JvmtiCachedClassFileData;
 134 























 135 class InstanceKlass: public Klass {
 136   friend class VMStructs;
 137   friend class JVMCIVMStructs;
 138   friend class ClassFileParser;
 139   friend class CompileReplay;

 140 
 141  public:
 142   static const KlassID ID = InstanceKlassID;
 143 
 144  protected:
 145   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 146 
 147  public:
 148   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 149 
 150   // See &quot;The Java Virtual Machine Specification&quot; section 2.16.2-5 for a detailed description
 151   // of the class loading &amp; initialization procedure, and the use of the states.
 152   enum ClassState {
 153     allocated,                          // allocated (but not yet linked)
 154     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 155     linked,                             // successfully linked/verified (but not initialized yet)
 156     being_initialized,                  // currently running class initializer
<span class="line-modified"> 157     fully_initialized,                  // initialized (successfull final state)</span>
 158     initialization_error                // error happened during initialization
 159   };
 160 
 161  private:
 162   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 163 
 164  protected:
 165   // If you add a new field that points to any metaspace object, you
 166   // must add this field to InstanceKlass::metaspace_pointers_do().
 167 
 168   // Annotations for this class
 169   Annotations*    _annotations;
 170   // Package this class is defined in
 171   PackageEntry*   _package_entry;
 172   // Array classes holding elements of this class.
 173   Klass* volatile _array_klasses;
 174   // Constant pool for this class.
 175   ConstantPool* _constants;
 176   // The InnerClasses attribute and EnclosingMethod attribute. The
 177   // _inner_classes is an array of shorts. If the class has InnerClasses
</pre>
<hr />
<pre>
 182   // last two shorts [class_index, method_index] of the array. If only
 183   // the InnerClasses attribute exists, the _inner_classes array length is
 184   // number_of_inner_classes * 4. If the class has both InnerClasses
 185   // and EnclosingMethod attributes the _inner_classes array length is
 186   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 187   Array&lt;jushort&gt;* _inner_classes;
 188 
 189   // The NestMembers attribute. An array of shorts, where each is a
 190   // class info index for the class that is a nest member. This data
 191   // has not been validated.
 192   Array&lt;jushort&gt;* _nest_members;
 193 
 194   // The NestHost attribute. The class info index for the class
 195   // that is the nest-host of this class. This data has not been validated.
 196   jushort _nest_host_index;
 197 
 198   // Resolved nest-host klass: either true nest-host or self if we are not nested.
 199   // By always being set it makes nest-member access checks simpler.
 200   InstanceKlass* _nest_host;
 201 


 202   // The contents of the Record attribute.
 203   Array&lt;RecordComponent*&gt;* _record_components;
 204 
 205   // the source debug extension for this klass, NULL if not specified.
 206   // Specified as UTF-8 string without terminating zero byte in the classfile,
 207   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 208   const char*     _source_debug_extension;
 209   // Array name derived from this class which needs unreferencing
 210   // if this class is unloaded.
 211   Symbol*         _array_name;
 212 
 213   // Number of heapOopSize words used by non-static fields in this klass
 214   // (including inherited fields but after header_size()).
 215   int             _nonstatic_field_size;
 216   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 217   // Constant pool index to the utf8 entry of the Generic signature,
 218   // or 0 if none.
 219   u2              _generic_signature_index;
 220   // Constant pool index to the utf8 entry for the name of source file
 221   // containing this klass, 0 if not specified.
 222   u2              _source_file_name_index;
 223   u2              _static_oop_field_count;// number of static oop fields in this klass
 224   u2              _java_fields_count;    // The number of declared Java fields
 225   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 226 
 227   int             _itable_len;           // length of Java itable (in words)
 228   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 229   // _misc_flags.
 230   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 231 
<span class="line-modified"> 232   // The low two bits of _misc_flags contains the kind field.</span>
<span class="line-modified"> 233   // This can be used to quickly discriminate among the four kinds of</span>
 234   // InstanceKlass.
 235 
<span class="line-modified"> 236   static const unsigned _misc_kind_field_size = 2;</span>
 237   static const unsigned _misc_kind_field_pos  = 0;
 238   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 239 
 240   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 241   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 242   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 243   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass

 244 
 245   // Start after _misc_kind field.
 246   enum {
<span class="line-modified"> 247     _misc_rewritten                           = 1 &lt;&lt; 2,  // methods rewritten.</span>
<span class="line-modified"> 248     _misc_has_nonstatic_fields                = 1 &lt;&lt; 3,  // for sizing with UseCompressedOops</span>
<span class="line-modified"> 249     _misc_should_verify_class                 = 1 &lt;&lt; 4,  // allow caching of preverification</span>
<span class="line-modified"> 250     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 5,  // has embedded _unsafe_anonymous_host field</span>
<span class="line-modified"> 251     _misc_is_contended                        = 1 &lt;&lt; 6,  // marked with contended annotation</span>
<span class="line-modified"> 252     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 7,  // class/superclass/implemented interfaces has non-static, concrete methods</span>
<span class="line-modified"> 253     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 8,  // directly declares non-static, concrete methods</span>
<span class="line-modified"> 254     _misc_has_been_redefined                  = 1 &lt;&lt; 9,  // class has been redefined</span>
<span class="line-modified"> 255     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 10, // when this class was loaded, the fingerprint computed from its</span>
 256                                                          // code source was found to be matching the value recorded by AOT.
<span class="line-modified"> 257     _misc_is_scratch_class                    = 1 &lt;&lt; 11, // class is the redefined scratch class</span>
<span class="line-modified"> 258     _misc_is_shared_boot_class                = 1 &lt;&lt; 12, // defining class loader is boot class loader</span>
<span class="line-modified"> 259     _misc_is_shared_platform_class            = 1 &lt;&lt; 13, // defining class loader is platform class loader</span>
<span class="line-modified"> 260     _misc_is_shared_app_class                 = 1 &lt;&lt; 14, // defining class loader is app class loader</span>
<span class="line-modified"> 261     _misc_has_resolved_methods                = 1 &lt;&lt; 15, // resolved methods table entries added for this class</span>
<span class="line-modified"> 262     _misc_is_being_redefined                  = 1 &lt;&lt; 16, // used for locking redefinition</span>
<span class="line-modified"> 263     _misc_has_contended_annotations           = 1 &lt;&lt; 17  // has @Contended annotation</span>




 264   };
 265   u2 shared_loader_type_bits() const {
 266     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 267   }
 268   u4              _misc_flags;
 269   u2              _minor_version;        // minor version number of class file
 270   u2              _major_version;        // major version number of class file
 271   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 272   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 273   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 274   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 275   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 276   uint64_t        volatile _dep_context_last_cleaned;
 277   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 278 #if INCLUDE_JVMTI
 279   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 280   // Linked instanceKlasses of previous versions
 281   InstanceKlass* _previous_versions;
 282   // JVMTI fields can be moved to their own structure - see 6315920
 283   // JVMTI: cached class file, before retransformable agent modified it in CFLH
</pre>
<hr />
<pre>
 310   // Int array containing the original order of method in the class file (for JVMTI).
 311   Array&lt;int&gt;*     _method_ordering;
 312   // Int array containing the vtable_indices for default_methods
 313   // offset matches _default_methods offset
 314   Array&lt;int&gt;*     _default_vtable_indices;
 315 
 316   // Instance and static variable information, starts with 6-tuples of shorts
 317   // [access, name index, sig index, initval index, low_offset, high_offset]
 318   // for all fields, followed by the generic signature data at the end of
 319   // the array. Only fields with generic signature attributes have the generic
 320   // signature data set in the array. The fields array looks like following:
 321   //
 322   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 323   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 324   //      ...
 325   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 326   //     [generic signature index]
 327   //     [generic signature index]
 328   //     ...
 329   Array&lt;u2&gt;*      _fields;



 330 
 331   // embedded Java vtable follows here
 332   // embedded Java itables follows here
 333   // embedded static fields follows here
 334   // embedded nonstatic oop-map blocks follows here
 335   // embedded implementor of this interface follows here
 336   //   The embedded implementor only exists if the current klass is an
 337   //   iterface. The possible values of the implementor fall into following
 338   //   three cases:
 339   //     NULL: no implementor.
 340   //     A Klass* that&#39;s not itself: one implementor.
 341   //     Itself: more than one implementors.
 342   // embedded unsafe_anonymous_host klass follows here
 343   //   The embedded host klass only exists in an unsafe anonymous class for
 344   //   dynamic language support (JSR 292 enabled). The host class grants
 345   //   its access privileges to this class also. The host class is either
 346   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 347   //   or an anonymous class loaded through normal classloading does not
 348   //   have this embedded field.
 349   //
</pre>
<hr />
<pre>
 368     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 369   }
 370 
 371   void clear_shared_class_loader_type() {
 372     _misc_flags &amp;= ~shared_loader_type_bits();
 373   }
 374 
 375   void set_shared_class_loader_type(s2 loader_type);
 376 
 377   bool has_nonstatic_fields() const        {
 378     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 379   }
 380   void set_has_nonstatic_fields(bool b)    {
 381     if (b) {
 382       _misc_flags |= _misc_has_nonstatic_fields;
 383     } else {
 384       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 385     }
 386   }
 387 








































 388   // field sizes
 389   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 390   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 391 
 392   int static_field_size() const            { return _static_field_size; }
 393   void set_static_field_size(int size)     { _static_field_size = size; }
 394 
 395   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 396   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 397 
 398   // Java itable
 399   int  itable_length() const               { return _itable_len; }
 400   void set_itable_length(int len)          { _itable_len = len; }
 401 
 402   // array klasses
 403   Klass* array_klasses() const             { return _array_klasses; }
 404   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 405   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 406   inline void release_set_array_klasses(Klass* k); // store with release semantics
 407 
</pre>
<hr />
<pre>
 430   Array&lt;InstanceKlass*&gt;* local_interfaces() const          { return _local_interfaces; }
 431   void set_local_interfaces(Array&lt;InstanceKlass*&gt;* a)      {
 432     guarantee(_local_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 433     _local_interfaces = a; }
 434 
 435   Array&lt;InstanceKlass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 436   void set_transitive_interfaces(Array&lt;InstanceKlass*&gt;* a) {
 437     guarantee(_transitive_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 438     _transitive_interfaces = a;
 439   }
 440 
 441  private:
 442   friend class fieldDescriptor;
 443   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 444 
 445  public:
 446   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 447   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 448   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 449   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }


 450 
 451   // Number of Java declared fields
 452   int java_fields_count() const           { return (int)_java_fields_count; }
 453 
 454   Array&lt;u2&gt;* fields() const            { return _fields; }
 455   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 456     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 457     _fields = f;
 458     _java_fields_count = java_fields_count;
 459   }
 460 
 461   // inner classes
 462   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 463   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 464 
 465   // nest members
 466   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 467   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 468 
 469   // nest-host index
</pre>
<hr />
<pre>
 537   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 538   ClassState  init_state()                 { return (ClassState)_init_state; }
 539   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 540 
 541   // defineClass specified verification
 542   bool should_verify_class() const         {
 543     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 544   }
 545   void set_should_verify_class(bool value) {
 546     if (value) {
 547       _misc_flags |= _misc_should_verify_class;
 548     } else {
 549       _misc_flags &amp;= ~_misc_should_verify_class;
 550     }
 551   }
 552 
 553   // marking
 554   bool is_marked_dependent() const         { return _is_marked_dependent; }
 555   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 556 



 557   // initialization (virtuals from Klass)
 558   bool should_be_initialized() const;  // means that initialize should be called
 559   void initialize(TRAPS);
 560   void link_class(TRAPS);
 561   bool link_class_or_fail(TRAPS); // returns false on failure
 562   void rewrite_class(TRAPS);
 563   void link_methods(TRAPS);
 564   Method* class_initializer() const;
 565 
 566   // set the class to initialized if no static initializer is present
 567   void eager_initialize(Thread *thread);
 568 
 569   // reference type
 570   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 571   void set_reference_type(ReferenceType t) {
 572     assert(t == (u1)t, &quot;overflow&quot;);
 573     _reference_type = (u1)t;
 574   }
 575 
 576   // this class cp index
</pre>
<hr />
<pre>
 747     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 748   }
 749   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 750   void set_nonstatic_oop_map_size(int words) {
 751     _nonstatic_oop_map_size = words;
 752   }
 753 
 754   bool has_contended_annotations() const {
 755     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 756   }
 757   void set_has_contended_annotations(bool value)  {
 758     if (value) {
 759       _misc_flags |= _misc_has_contended_annotations;
 760     } else {
 761       _misc_flags &amp;= ~_misc_has_contended_annotations;
 762     }
 763   }
 764 
 765 #if INCLUDE_JVMTI
 766   // Redefinition locking.  Class can only be redefined by one thread at a time.

 767   bool is_being_redefined() const          {
<span class="line-modified"> 768     return ((_misc_flags &amp; _misc_is_being_redefined) != 0);</span>
 769   }
 770   void set_is_being_redefined(bool value)  {
 771     if (value) {
 772       _misc_flags |= _misc_is_being_redefined;
 773     } else {
 774       _misc_flags &amp;= ~_misc_is_being_redefined;
 775     }
 776   }
 777 
 778   // RedefineClasses() support for previous versions:
 779   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 780   void purge_previous_version_list();
 781 
 782   InstanceKlass* previous_versions() const { return _previous_versions; }
 783 #else
 784   InstanceKlass* previous_versions() const { return NULL; }
 785 #endif
 786 
 787   InstanceKlass* get_klass_version(int version) {
 788     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
</pre>
<hr />
<pre>
 837 
 838   void set_kind(unsigned kind) {
 839     assert(kind &lt;= _misc_kind_field_mask, &quot;Invalid InstanceKlass kind&quot;);
 840     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 841     unsigned flags = _misc_flags &amp; ~fmask;
 842     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 843   }
 844 
 845   bool is_kind(unsigned desired) const {
 846     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 847     return kind == desired;
 848   }
 849 
 850 public:
 851 
 852   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 853   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 854   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 855   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 856   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }

 857 
 858 #if INCLUDE_JVMTI
 859 
 860   void init_previous_versions() {
 861     _previous_versions = NULL;
 862   }
 863 
 864  private:
 865   static bool  _has_previous_versions;
 866  public:
 867   static void purge_previous_versions(InstanceKlass* ik) {
 868     if (ik-&gt;has_been_redefined()) {
 869       ik-&gt;purge_previous_version_list();
 870     }
 871   }
 872 
 873   static bool has_previous_versions_and_reset();
 874   static bool has_previous_versions() { return _has_previous_versions; }
 875 
 876   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
</pre>
<hr />
<pre>
1012 
1013   // On-stack replacement support
1014   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
1015   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
1016   void add_osr_nmethod(nmethod* n);
1017   bool remove_osr_nmethod(nmethod* n);
1018   int mark_osr_nmethods(const Method* m);
1019   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1020 
1021 #if INCLUDE_JVMTI
1022   // Breakpoint support (see methods on Method* for details)
1023   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1024   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1025 #endif
1026 
1027   // support for stub routines
1028   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1029   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1030   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1031 



1032   // subclass/subinterface checks
1033   bool implements_interface(Klass* k) const;
1034   bool is_same_or_direct_interface(Klass* k) const;
1035 
1036 #ifdef ASSERT
1037   // check whether this class or one of its superclasses was redefined
1038   bool has_redefined_this_or_super() const;
1039 #endif
1040 
1041   // Access to the implementor of an interface.
1042   Klass* implementor() const;
1043   void set_implementor(Klass* k);
1044   int  nof_implementors() const;
1045   void add_implementor(Klass* k);  // k is a new class that implements this interface
1046   void init_implementor();           // initialize
1047 
1048   // link this class into the implementors list of every interface it implements
1049   void process_interfaces(Thread *thread);
1050 
1051   // virtual operations from Klass
1052   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1053                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1054   bool can_be_primary_super_slow() const;
1055   int oop_size(oop obj)  const             { return size_helper(); }
1056   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1057   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1058   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1059 
1060   // Iterators
1061   void do_local_static_fields(FieldClosure* cl);
1062   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1063   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1064 
1065   void methods_do(void f(Method* method));
<span class="line-modified">1066   void array_klasses_do(void f(Klass* k));</span>
<span class="line-removed">1067   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);</span>
1068 
1069   static InstanceKlass* cast(Klass* k) {
1070     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1071   }
1072 
1073   static const InstanceKlass* cast(const Klass* k) {
1074     assert(k != NULL, &quot;k should not be null&quot;);
1075     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1076     return static_cast&lt;const InstanceKlass*&gt;(k);
1077   }
1078 
1079   virtual InstanceKlass* java_super() const {
1080     return (super() == NULL) ? NULL : cast(super());
1081   }
1082 
1083   // Sizing (in words)
1084   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1085 
1086   static int size(int vtable_length, int itable_length,
1087                   int nonstatic_oop_map_size,
<span class="line-modified">1088                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint) {</span>

1089     return align_metadata_size(header_size() +
1090            vtable_length +
1091            itable_length +
1092            nonstatic_oop_map_size +
1093            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1094            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
<span class="line-modified">1095            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0));</span>


1096   }
1097   int size() const                    { return size(vtable_length(),
1098                                                itable_length(),
1099                                                nonstatic_oop_map_size(),
1100                                                is_interface(),
1101                                                is_unsafe_anonymous(),
<span class="line-modified">1102                                                has_stored_fingerprint());</span>


1103   }
1104 
1105   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1106   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1107 
1108   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1109 
1110   oop static_field_base_raw() { return java_mirror(); }
1111 


1112   OopMapBlock* start_of_nonstatic_oop_maps() const {
1113     return (OopMapBlock*)(start_of_itable() + itable_length());
1114   }
1115 
1116   Klass** end_of_nonstatic_oop_maps() const {
1117     return (Klass**)(start_of_nonstatic_oop_maps() +
1118                      nonstatic_oop_map_count());
1119   }
1120 
1121   Klass* volatile* adr_implementor() const {
1122     if (is_interface()) {
1123       return (Klass* volatile*)end_of_nonstatic_oop_maps();
1124     } else {
1125       return NULL;
1126     }
1127   };
1128 
1129   InstanceKlass** adr_unsafe_anonymous_host() const {
1130     if (is_unsafe_anonymous()) {
1131       InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();
</pre>
<hr />
<pre>
1140   }
1141 
1142   address adr_fingerprint() const {
1143     if (has_stored_fingerprint()) {
1144       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1145       if (adr_host != NULL) {
1146         return (address)(adr_host + 1);
1147       }
1148 
1149       Klass* volatile* adr_impl = adr_implementor();
1150       if (adr_impl != NULL) {
1151         return (address)(adr_impl + 1);
1152       }
1153 
1154       return (address)end_of_nonstatic_oop_maps();
1155     } else {
1156       return NULL;
1157     }
1158   }
1159 













































1160   // Use this to return the size of an instance in heap words:
<span class="line-modified">1161   int size_helper() const {</span>
1162     return layout_helper_to_size_helper(layout_helper());
1163   }
1164 
1165   // This bit is initialized in classFileParser.cpp.
1166   // It is false under any of the following conditions:
1167   //  - the class is abstract (including any interface)
1168   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1169   //  - the class size is larger than FastAllocateSizeLimit
1170   //  - the class is java/lang/Class, which cannot be allocated directly
1171   bool can_be_fastpath_allocated() const {
1172     return !layout_helper_needs_slow_path(layout_helper());
1173   }
1174 
1175   // Java itable
1176   klassItable itable() const;        // return klassItable wrapper
1177   Method* method_at_itable(Klass* holder, int index, TRAPS);
1178 
1179 #if INCLUDE_JVMTI
1180   void adjust_default_methods(bool* trace_name_printed);
1181 #endif // INCLUDE_JVMTI
</pre>
<hr />
<pre>
1192   void deallocate_contents(ClassLoaderData* loader_data);
1193   static void deallocate_methods(ClassLoaderData* loader_data,
1194                                  Array&lt;Method*&gt;* methods);
1195   void static deallocate_interfaces(ClassLoaderData* loader_data,
1196                                     const Klass* super_klass,
1197                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1198                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1199   void static deallocate_record_components(ClassLoaderData* loader_data,
1200                                            Array&lt;RecordComponent*&gt;* record_component);
1201 
1202   // The constant pool is on stack if any of the methods are executing or
1203   // referenced by handles.
1204   bool on_stack() const { return _constants-&gt;on_stack(); }
1205 
1206   // callbacks for actions during class unloading
1207   static void unload_class(InstanceKlass* ik);
1208   static void release_C_heap_structures(InstanceKlass* ik);
1209 
1210   // Naming
1211   const char* signature_name() const;

1212 
1213   // Oop fields (and metadata) iterators
1214   //
1215   // The InstanceKlass iterators also visits the Object&#39;s klass.
1216 
1217   // Forward iteration
1218  public:
1219   // Iterate over all oop fields in the oop maps.
1220   template &lt;typename T, class OopClosureType&gt;
1221   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1222 
1223   // Iterate over all oop fields and metadata.
1224   template &lt;typename T, class OopClosureType&gt;
1225   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1226 
1227   // Iterate over all oop fields in one oop map.
1228   template &lt;typename T, class OopClosureType&gt;
1229   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1230 
1231 
</pre>
<hr />
<pre>
1277   inline jmethodID* methods_jmethod_ids_acquire() const;
1278   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1279 
1280   // Lock during initialization
1281 public:
1282   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1283   // Must be one per class and it has to be a VM internal object so java code
1284   // cannot lock it (like the mirror).
1285   // It has to be an object not a Mutex because it&#39;s held through java calls.
1286   oop init_lock() const;
1287 private:
1288   void fence_and_clear_init_lock();
1289 
1290   bool link_class_impl                           (TRAPS);
1291   bool verify_code                               (TRAPS);
1292   void initialize_impl                           (TRAPS);
1293   void initialize_super_interfaces               (TRAPS);
1294   void eager_initialize_impl                     ();
1295   /* jni_id_for_impl for jfieldID only */
1296   JNIid* jni_id_for_impl                         (int offset);
<span class="line-modified">1297 </span>
1298   // Returns the array class for the n&#39;th dimension
<span class="line-modified">1299   Klass* array_klass_impl(bool or_null, int n, TRAPS);</span>
1300 
1301   // Returns the array class with this class as element type
<span class="line-modified">1302   Klass* array_klass_impl(bool or_null, TRAPS);</span>


1303 
1304   // find a local method (returns NULL if not found)
1305   Method* find_method_impl(const Symbol* name,
1306                            const Symbol* signature,
1307                            OverpassLookupMode overpass_mode,
1308                            StaticLookupMode static_mode,
1309                            PrivateLookupMode private_mode) const;
1310 
1311   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1312                                   const Symbol* name,
1313                                   const Symbol* signature,
1314                                   OverpassLookupMode overpass_mode,
1315                                   StaticLookupMode static_mode,
1316                                   PrivateLookupMode private_mode);
1317 
1318   // Free CHeap allocated fields.
1319   void release_C_heap_structures();
1320 
1321 #if INCLUDE_JVMTI
1322   // RedefineClasses support
1323   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1324   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1325 #endif
1326 public:
1327   // CDS support - remove and restore oops from metadata. Oops are not shared.
1328   virtual void remove_unshareable_info();
1329   virtual void remove_java_mirror();
<span class="line-modified">1330   void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);</span>
1331 
1332   // jvm support
1333   jint compute_modifier_flags(TRAPS) const;
1334 
1335 public:
1336   // JVMTI support
1337   jint jvmti_class_status() const;
1338 
1339   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1340 
1341  public:
1342   // Printing
1343 #ifndef PRODUCT
1344   void print_on(outputStream* st) const;
1345 #endif
1346   void print_value_on(outputStream* st) const;
1347 
1348   void oop_print_value_on(oop obj, outputStream* st);
1349 
1350 #ifndef PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include &quot;classfile/classLoaderData.hpp&quot;
<span class="line-added">  29 #include &quot;code/vmreg.hpp&quot;</span>
  30 #include &quot;memory/referenceType.hpp&quot;
  31 #include &quot;oops/annotations.hpp&quot;
  32 #include &quot;oops/constMethod.hpp&quot;
  33 #include &quot;oops/fieldInfo.hpp&quot;
  34 #include &quot;oops/instanceOop.hpp&quot;
  35 #include &quot;oops/klassVtable.hpp&quot;
  36 #include &quot;runtime/handles.hpp&quot;
  37 #include &quot;runtime/os.hpp&quot;
  38 #include &quot;utilities/accessFlags.hpp&quot;
  39 #include &quot;utilities/align.hpp&quot;
  40 #include &quot;utilities/macros.hpp&quot;
  41 #if INCLUDE_JFR
  42 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  43 #endif
  44 
  45 class RecordComponent;
  46 
  47 // An InstanceKlass is the VM level representation of a Java class.
  48 // It contains all information needed for at class at execution runtime.
  49 
  50 //  InstanceKlass embedded field layout (after declared fields):
  51 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  52 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  53 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  54 //      indicating where oops are located in instances of this klass.
  55 //    [EMBEDDED implementor of the interface] only exist for interface
  56 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  57 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
<span class="line-added">  58 //    [EMBEDDED ValueKlassFixedBlock] only if is a ValueKlass instance</span>
  59 
  60 
  61 // forward declaration for class -- see below for definition
  62 #if INCLUDE_JVMTI
  63 class BreakpointInfo;
  64 #endif
  65 class ClassFileParser;
  66 class ClassFileStream;
  67 class KlassDepChange;
  68 class DependencyContext;
  69 class fieldDescriptor;
  70 class jniIdMapBase;
  71 class JNIid;
  72 class JvmtiCachedClassFieldMap;
  73 class nmethodBucket;
  74 class OopMapCache;
<span class="line-added">  75 class BufferedValueTypeBlob;</span>
  76 class InterpreterOopMap;
  77 class PackageEntry;
  78 class ModuleEntry;
  79 
  80 // This is used in iterators below.
  81 class FieldClosure: public StackObj {
  82 public:
  83   virtual void do_field(fieldDescriptor* fd) = 0;
  84 };
  85 
  86 #ifndef PRODUCT
  87 // Print fields.
  88 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  89 class FieldPrinter: public FieldClosure {
  90    oop _obj;
  91    outputStream* _st;
  92  public:
  93    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  94    void do_field(fieldDescriptor* fd);
  95 };
</pre>
<hr />
<pre>
 118     return another_offset == end_offset();
 119   }
 120 
 121   // sizeof(OopMapBlock) in words.
 122   static const int size_in_words() {
 123     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 124       LogBytesPerWord;
 125   }
 126 
 127   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {
 128     return a-&gt;offset() - b-&gt;offset();
 129   }
 130 
 131  private:
 132   int  _offset;
 133   uint _count;
 134 };
 135 
 136 struct JvmtiCachedClassFileData;
 137 
<span class="line-added"> 138 class SigEntry;</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140 class ValueKlassFixedBlock {</span>
<span class="line-added"> 141   Array&lt;SigEntry&gt;** _extended_sig;</span>
<span class="line-added"> 142   Array&lt;VMRegPair&gt;** _return_regs;</span>
<span class="line-added"> 143   address* _pack_handler;</span>
<span class="line-added"> 144   address* _pack_handler_jobject;</span>
<span class="line-added"> 145   address* _unpack_handler;</span>
<span class="line-added"> 146   int* _default_value_offset;</span>
<span class="line-added"> 147   Klass** _value_array_klass;</span>
<span class="line-added"> 148   int _alignment;</span>
<span class="line-added"> 149   int _first_field_offset;</span>
<span class="line-added"> 150   int _exact_size_in_bytes;</span>
<span class="line-added"> 151 </span>
<span class="line-added"> 152   friend class ValueKlass;</span>
<span class="line-added"> 153 };</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155 class ValueTypes {</span>
<span class="line-added"> 156 public:</span>
<span class="line-added"> 157   u2 _class_info_index;</span>
<span class="line-added"> 158   Symbol* _class_name;</span>
<span class="line-added"> 159 };</span>
<span class="line-added"> 160 </span>
 161 class InstanceKlass: public Klass {
 162   friend class VMStructs;
 163   friend class JVMCIVMStructs;
 164   friend class ClassFileParser;
 165   friend class CompileReplay;
<span class="line-added"> 166   friend class TemplateTable;</span>
 167 
 168  public:
 169   static const KlassID ID = InstanceKlassID;
 170 
 171  protected:
 172   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 173 
 174  public:
 175   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 176 
 177   // See &quot;The Java Virtual Machine Specification&quot; section 2.16.2-5 for a detailed description
 178   // of the class loading &amp; initialization procedure, and the use of the states.
 179   enum ClassState {
 180     allocated,                          // allocated (but not yet linked)
 181     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 182     linked,                             // successfully linked/verified (but not initialized yet)
 183     being_initialized,                  // currently running class initializer
<span class="line-modified"> 184     fully_initialized,                  // initialized (successful final state)</span>
 185     initialization_error                // error happened during initialization
 186   };
 187 
 188  private:
 189   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 190 
 191  protected:
 192   // If you add a new field that points to any metaspace object, you
 193   // must add this field to InstanceKlass::metaspace_pointers_do().
 194 
 195   // Annotations for this class
 196   Annotations*    _annotations;
 197   // Package this class is defined in
 198   PackageEntry*   _package_entry;
 199   // Array classes holding elements of this class.
 200   Klass* volatile _array_klasses;
 201   // Constant pool for this class.
 202   ConstantPool* _constants;
 203   // The InnerClasses attribute and EnclosingMethod attribute. The
 204   // _inner_classes is an array of shorts. If the class has InnerClasses
</pre>
<hr />
<pre>
 209   // last two shorts [class_index, method_index] of the array. If only
 210   // the InnerClasses attribute exists, the _inner_classes array length is
 211   // number_of_inner_classes * 4. If the class has both InnerClasses
 212   // and EnclosingMethod attributes the _inner_classes array length is
 213   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 214   Array&lt;jushort&gt;* _inner_classes;
 215 
 216   // The NestMembers attribute. An array of shorts, where each is a
 217   // class info index for the class that is a nest member. This data
 218   // has not been validated.
 219   Array&lt;jushort&gt;* _nest_members;
 220 
 221   // The NestHost attribute. The class info index for the class
 222   // that is the nest-host of this class. This data has not been validated.
 223   jushort _nest_host_index;
 224 
 225   // Resolved nest-host klass: either true nest-host or self if we are not nested.
 226   // By always being set it makes nest-member access checks simpler.
 227   InstanceKlass* _nest_host;
 228 
<span class="line-added"> 229   Array&lt;ValueTypes&gt;* _value_types;</span>
<span class="line-added"> 230 </span>
 231   // The contents of the Record attribute.
 232   Array&lt;RecordComponent*&gt;* _record_components;
 233 
 234   // the source debug extension for this klass, NULL if not specified.
 235   // Specified as UTF-8 string without terminating zero byte in the classfile,
 236   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 237   const char*     _source_debug_extension;
 238   // Array name derived from this class which needs unreferencing
 239   // if this class is unloaded.
 240   Symbol*         _array_name;
 241 
 242   // Number of heapOopSize words used by non-static fields in this klass
 243   // (including inherited fields but after header_size()).
 244   int             _nonstatic_field_size;
 245   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 246   // Constant pool index to the utf8 entry of the Generic signature,
 247   // or 0 if none.
 248   u2              _generic_signature_index;
 249   // Constant pool index to the utf8 entry for the name of source file
 250   // containing this klass, 0 if not specified.
 251   u2              _source_file_name_index;
 252   u2              _static_oop_field_count;// number of static oop fields in this klass
 253   u2              _java_fields_count;    // The number of declared Java fields
 254   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 255 
 256   int             _itable_len;           // length of Java itable (in words)
 257   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 258   // _misc_flags.
 259   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 260 
<span class="line-modified"> 261   // The low three bits of _misc_flags contains the kind field.</span>
<span class="line-modified"> 262   // This can be used to quickly discriminate among the five kinds of</span>
 263   // InstanceKlass.
 264 
<span class="line-modified"> 265   static const unsigned _misc_kind_field_size = 3;</span>
 266   static const unsigned _misc_kind_field_pos  = 0;
 267   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 268 
 269   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 270   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 271   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 272   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
<span class="line-added"> 273   static const unsigned _misc_kind_value_type   = 4; // ValueKlass</span>
 274 
 275   // Start after _misc_kind field.
 276   enum {
<span class="line-modified"> 277     _misc_rewritten                           = 1 &lt;&lt; 3,  // methods rewritten.</span>
<span class="line-modified"> 278     _misc_has_nonstatic_fields                = 1 &lt;&lt; 4,  // for sizing with UseCompressedOops</span>
<span class="line-modified"> 279     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification</span>
<span class="line-modified"> 280     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field</span>
<span class="line-modified"> 281     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation</span>
<span class="line-modified"> 282     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods</span>
<span class="line-modified"> 283     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods</span>
<span class="line-modified"> 284     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined</span>
<span class="line-modified"> 285     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its</span>
 286                                                          // code source was found to be matching the value recorded by AOT.
<span class="line-modified"> 287     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class</span>
<span class="line-modified"> 288     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader</span>
<span class="line-modified"> 289     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader</span>
<span class="line-modified"> 290     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader</span>
<span class="line-modified"> 291     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class</span>
<span class="line-modified"> 292     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition</span>
<span class="line-modified"> 293     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation</span>
<span class="line-added"> 294     _misc_has_value_fields                    = 1 &lt;&lt; 19, // has value fields and related embedded section is not empty</span>
<span class="line-added"> 295     _misc_is_empty_value                      = 1 &lt;&lt; 20, // empty value type</span>
<span class="line-added"> 296     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction</span>
<span class="line-added"> 297     _misc_is_declared_atomic                  = 1 &lt;&lt; 22  // implements jl.NonTearable</span>
 298   };
 299   u2 shared_loader_type_bits() const {
 300     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 301   }
 302   u4              _misc_flags;
 303   u2              _minor_version;        // minor version number of class file
 304   u2              _major_version;        // major version number of class file
 305   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 306   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 307   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 308   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 309   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 310   uint64_t        volatile _dep_context_last_cleaned;
 311   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 312 #if INCLUDE_JVMTI
 313   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 314   // Linked instanceKlasses of previous versions
 315   InstanceKlass* _previous_versions;
 316   // JVMTI fields can be moved to their own structure - see 6315920
 317   // JVMTI: cached class file, before retransformable agent modified it in CFLH
</pre>
<hr />
<pre>
 344   // Int array containing the original order of method in the class file (for JVMTI).
 345   Array&lt;int&gt;*     _method_ordering;
 346   // Int array containing the vtable_indices for default_methods
 347   // offset matches _default_methods offset
 348   Array&lt;int&gt;*     _default_vtable_indices;
 349 
 350   // Instance and static variable information, starts with 6-tuples of shorts
 351   // [access, name index, sig index, initval index, low_offset, high_offset]
 352   // for all fields, followed by the generic signature data at the end of
 353   // the array. Only fields with generic signature attributes have the generic
 354   // signature data set in the array. The fields array looks like following:
 355   //
 356   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 357   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 358   //      ...
 359   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 360   //     [generic signature index]
 361   //     [generic signature index]
 362   //     ...
 363   Array&lt;u2&gt;*      _fields;
<span class="line-added"> 364   const Klass**   _value_field_klasses; // For &quot;inline class&quot; fields, NULL if none present</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366   const ValueKlassFixedBlock* _adr_valueklass_fixed_block;</span>
 367 
 368   // embedded Java vtable follows here
 369   // embedded Java itables follows here
 370   // embedded static fields follows here
 371   // embedded nonstatic oop-map blocks follows here
 372   // embedded implementor of this interface follows here
 373   //   The embedded implementor only exists if the current klass is an
 374   //   iterface. The possible values of the implementor fall into following
 375   //   three cases:
 376   //     NULL: no implementor.
 377   //     A Klass* that&#39;s not itself: one implementor.
 378   //     Itself: more than one implementors.
 379   // embedded unsafe_anonymous_host klass follows here
 380   //   The embedded host klass only exists in an unsafe anonymous class for
 381   //   dynamic language support (JSR 292 enabled). The host class grants
 382   //   its access privileges to this class also. The host class is either
 383   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 384   //   or an anonymous class loaded through normal classloading does not
 385   //   have this embedded field.
 386   //
</pre>
<hr />
<pre>
 405     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 406   }
 407 
 408   void clear_shared_class_loader_type() {
 409     _misc_flags &amp;= ~shared_loader_type_bits();
 410   }
 411 
 412   void set_shared_class_loader_type(s2 loader_type);
 413 
 414   bool has_nonstatic_fields() const        {
 415     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 416   }
 417   void set_has_nonstatic_fields(bool b)    {
 418     if (b) {
 419       _misc_flags |= _misc_has_nonstatic_fields;
 420     } else {
 421       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 422     }
 423   }
 424 
<span class="line-added"> 425   bool has_value_fields() const          {</span>
<span class="line-added"> 426     return (_misc_flags &amp; _misc_has_value_fields) != 0;</span>
<span class="line-added"> 427   }</span>
<span class="line-added"> 428   void set_has_value_fields()  {</span>
<span class="line-added"> 429     _misc_flags |= _misc_has_value_fields;</span>
<span class="line-added"> 430   }</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432   bool is_empty_value() const {</span>
<span class="line-added"> 433     return (_misc_flags &amp; _misc_is_empty_value) != 0;</span>
<span class="line-added"> 434   }</span>
<span class="line-added"> 435   void set_is_empty_value() {</span>
<span class="line-added"> 436     _misc_flags |= _misc_is_empty_value;</span>
<span class="line-added"> 437   }</span>
<span class="line-added"> 438 </span>
<span class="line-added"> 439   // Note:  The naturally_atomic property only applies to</span>
<span class="line-added"> 440   // inline classes; it is never true on identity classes.</span>
<span class="line-added"> 441   // The bit is placed on instanceKlass for convenience.</span>
<span class="line-added"> 442 </span>
<span class="line-added"> 443   // Query if h/w provides atomic load/store for instances.</span>
<span class="line-added"> 444   bool is_naturally_atomic() const {</span>
<span class="line-added"> 445     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;</span>
<span class="line-added"> 446   }</span>
<span class="line-added"> 447   // Initialized in the class file parser, not changed later.</span>
<span class="line-added"> 448   void set_is_naturally_atomic() {</span>
<span class="line-added"> 449     _misc_flags |= _misc_is_naturally_atomic;</span>
<span class="line-added"> 450   }</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452   // Query if this class implements jl.NonTearable or was</span>
<span class="line-added"> 453   // mentioned in the JVM option AlwaysAtomicValueTypes.</span>
<span class="line-added"> 454   // This bit can occur anywhere, but is only significant</span>
<span class="line-added"> 455   // for inline classes *and* their super types.</span>
<span class="line-added"> 456   // It inherits from supers along with NonTearable.</span>
<span class="line-added"> 457   bool is_declared_atomic() const {</span>
<span class="line-added"> 458     return (_misc_flags &amp; _misc_is_declared_atomic) != 0;</span>
<span class="line-added"> 459   }</span>
<span class="line-added"> 460   // Initialized in the class file parser, not changed later.</span>
<span class="line-added"> 461   void set_is_declared_atomic() {</span>
<span class="line-added"> 462     _misc_flags |= _misc_is_declared_atomic;</span>
<span class="line-added"> 463   }</span>
<span class="line-added"> 464 </span>
 465   // field sizes
 466   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 467   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 468 
 469   int static_field_size() const            { return _static_field_size; }
 470   void set_static_field_size(int size)     { _static_field_size = size; }
 471 
 472   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 473   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 474 
 475   // Java itable
 476   int  itable_length() const               { return _itable_len; }
 477   void set_itable_length(int len)          { _itable_len = len; }
 478 
 479   // array klasses
 480   Klass* array_klasses() const             { return _array_klasses; }
 481   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 482   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 483   inline void release_set_array_klasses(Klass* k); // store with release semantics
 484 
</pre>
<hr />
<pre>
 507   Array&lt;InstanceKlass*&gt;* local_interfaces() const          { return _local_interfaces; }
 508   void set_local_interfaces(Array&lt;InstanceKlass*&gt;* a)      {
 509     guarantee(_local_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 510     _local_interfaces = a; }
 511 
 512   Array&lt;InstanceKlass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 513   void set_transitive_interfaces(Array&lt;InstanceKlass*&gt;* a) {
 514     guarantee(_transitive_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 515     _transitive_interfaces = a;
 516   }
 517 
 518  private:
 519   friend class fieldDescriptor;
 520   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 521 
 522  public:
 523   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 524   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 525   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 526   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
<span class="line-added"> 527   bool    field_is_flattened(int index) const { return field(index)-&gt;is_flattened(); }</span>
<span class="line-added"> 528   bool    field_is_flattenable(int index) const { return field(index)-&gt;is_flattenable(); }</span>
 529 
 530   // Number of Java declared fields
 531   int java_fields_count() const           { return (int)_java_fields_count; }
 532 
 533   Array&lt;u2&gt;* fields() const            { return _fields; }
 534   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 535     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 536     _fields = f;
 537     _java_fields_count = java_fields_count;
 538   }
 539 
 540   // inner classes
 541   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 542   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 543 
 544   // nest members
 545   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 546   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 547 
 548   // nest-host index
</pre>
<hr />
<pre>
 616   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 617   ClassState  init_state()                 { return (ClassState)_init_state; }
 618   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 619 
 620   // defineClass specified verification
 621   bool should_verify_class() const         {
 622     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 623   }
 624   void set_should_verify_class(bool value) {
 625     if (value) {
 626       _misc_flags |= _misc_should_verify_class;
 627     } else {
 628       _misc_flags &amp;= ~_misc_should_verify_class;
 629     }
 630   }
 631 
 632   // marking
 633   bool is_marked_dependent() const         { return _is_marked_dependent; }
 634   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 635 
<span class="line-added"> 636   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }</span>
<span class="line-added"> 637   static u4 misc_flags_is_empty_value() { return _misc_is_empty_value; }</span>
<span class="line-added"> 638 </span>
 639   // initialization (virtuals from Klass)
 640   bool should_be_initialized() const;  // means that initialize should be called
 641   void initialize(TRAPS);
 642   void link_class(TRAPS);
 643   bool link_class_or_fail(TRAPS); // returns false on failure
 644   void rewrite_class(TRAPS);
 645   void link_methods(TRAPS);
 646   Method* class_initializer() const;
 647 
 648   // set the class to initialized if no static initializer is present
 649   void eager_initialize(Thread *thread);
 650 
 651   // reference type
 652   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 653   void set_reference_type(ReferenceType t) {
 654     assert(t == (u1)t, &quot;overflow&quot;);
 655     _reference_type = (u1)t;
 656   }
 657 
 658   // this class cp index
</pre>
<hr />
<pre>
 829     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 830   }
 831   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 832   void set_nonstatic_oop_map_size(int words) {
 833     _nonstatic_oop_map_size = words;
 834   }
 835 
 836   bool has_contended_annotations() const {
 837     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 838   }
 839   void set_has_contended_annotations(bool value)  {
 840     if (value) {
 841       _misc_flags |= _misc_has_contended_annotations;
 842     } else {
 843       _misc_flags &amp;= ~_misc_has_contended_annotations;
 844     }
 845   }
 846 
 847 #if INCLUDE_JVMTI
 848   // Redefinition locking.  Class can only be redefined by one thread at a time.
<span class="line-added"> 849 </span>
 850   bool is_being_redefined() const          {
<span class="line-modified"> 851     return (_misc_flags &amp; _misc_is_being_redefined);</span>
 852   }
 853   void set_is_being_redefined(bool value)  {
 854     if (value) {
 855       _misc_flags |= _misc_is_being_redefined;
 856     } else {
 857       _misc_flags &amp;= ~_misc_is_being_redefined;
 858     }
 859   }
 860 
 861   // RedefineClasses() support for previous versions:
 862   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 863   void purge_previous_version_list();
 864 
 865   InstanceKlass* previous_versions() const { return _previous_versions; }
 866 #else
 867   InstanceKlass* previous_versions() const { return NULL; }
 868 #endif
 869 
 870   InstanceKlass* get_klass_version(int version) {
 871     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
</pre>
<hr />
<pre>
 920 
 921   void set_kind(unsigned kind) {
 922     assert(kind &lt;= _misc_kind_field_mask, &quot;Invalid InstanceKlass kind&quot;);
 923     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 924     unsigned flags = _misc_flags &amp; ~fmask;
 925     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 926   }
 927 
 928   bool is_kind(unsigned desired) const {
 929     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 930     return kind == desired;
 931   }
 932 
 933 public:
 934 
 935   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 936   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 937   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 938   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 939   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }
<span class="line-added"> 940   bool is_value_type_klass()            const { return is_kind(_misc_kind_value_type); }</span>
 941 
 942 #if INCLUDE_JVMTI
 943 
 944   void init_previous_versions() {
 945     _previous_versions = NULL;
 946   }
 947 
 948  private:
 949   static bool  _has_previous_versions;
 950  public:
 951   static void purge_previous_versions(InstanceKlass* ik) {
 952     if (ik-&gt;has_been_redefined()) {
 953       ik-&gt;purge_previous_version_list();
 954     }
 955   }
 956 
 957   static bool has_previous_versions_and_reset();
 958   static bool has_previous_versions() { return _has_previous_versions; }
 959 
 960   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
</pre>
<hr />
<pre>
1096 
1097   // On-stack replacement support
1098   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
1099   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
1100   void add_osr_nmethod(nmethod* n);
1101   bool remove_osr_nmethod(nmethod* n);
1102   int mark_osr_nmethods(const Method* m);
1103   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1104 
1105 #if INCLUDE_JVMTI
1106   // Breakpoint support (see methods on Method* for details)
1107   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1108   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1109 #endif
1110 
1111   // support for stub routines
1112   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1113   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1114   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1115 
<span class="line-added">1116   static ByteSize value_field_klasses_offset() { return in_ByteSize(offset_of(InstanceKlass, _value_field_klasses)); }</span>
<span class="line-added">1117   static ByteSize adr_valueklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_valueklass_fixed_block)); }</span>
<span class="line-added">1118 </span>
1119   // subclass/subinterface checks
1120   bool implements_interface(Klass* k) const;
1121   bool is_same_or_direct_interface(Klass* k) const;
1122 
1123 #ifdef ASSERT
1124   // check whether this class or one of its superclasses was redefined
1125   bool has_redefined_this_or_super() const;
1126 #endif
1127 
1128   // Access to the implementor of an interface.
1129   Klass* implementor() const;
1130   void set_implementor(Klass* k);
1131   int  nof_implementors() const;
1132   void add_implementor(Klass* k);  // k is a new class that implements this interface
1133   void init_implementor();           // initialize
1134 
1135   // link this class into the implementors list of every interface it implements
1136   void process_interfaces(Thread *thread);
1137 
1138   // virtual operations from Klass
1139   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1140                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1141   bool can_be_primary_super_slow() const;
1142   int oop_size(oop obj)  const             { return size_helper(); }
1143   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1144   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1145   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1146 
1147   // Iterators
1148   void do_local_static_fields(FieldClosure* cl);
1149   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1150   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1151 
1152   void methods_do(void f(Method* method));
<span class="line-modified">1153   virtual void array_klasses_do(void f(Klass* k));</span>

1154 
1155   static InstanceKlass* cast(Klass* k) {
1156     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1157   }
1158 
1159   static const InstanceKlass* cast(const Klass* k) {
1160     assert(k != NULL, &quot;k should not be null&quot;);
1161     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1162     return static_cast&lt;const InstanceKlass*&gt;(k);
1163   }
1164 
1165   virtual InstanceKlass* java_super() const {
1166     return (super() == NULL) ? NULL : cast(super());
1167   }
1168 
1169   // Sizing (in words)
1170   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1171 
1172   static int size(int vtable_length, int itable_length,
1173                   int nonstatic_oop_map_size,
<span class="line-modified">1174                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint,</span>
<span class="line-added">1175                   int java_fields, bool is_value_type) {</span>
1176     return align_metadata_size(header_size() +
1177            vtable_length +
1178            itable_length +
1179            nonstatic_oop_map_size +
1180            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1181            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
<span class="line-modified">1182            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0) +</span>
<span class="line-added">1183            (java_fields * (int)sizeof(Klass*)/wordSize) +</span>
<span class="line-added">1184            (is_value_type ? (int)sizeof(ValueKlassFixedBlock) : 0));</span>
1185   }
1186   int size() const                    { return size(vtable_length(),
1187                                                itable_length(),
1188                                                nonstatic_oop_map_size(),
1189                                                is_interface(),
1190                                                is_unsafe_anonymous(),
<span class="line-modified">1191                                                has_stored_fingerprint(),</span>
<span class="line-added">1192                                                has_value_fields() ? java_fields_count() : 0,</span>
<span class="line-added">1193                                                is_value());</span>
1194   }
1195 
1196   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1197   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1198 
1199   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1200 
1201   oop static_field_base_raw() { return java_mirror(); }
1202 
<span class="line-added">1203   bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;</span>
<span class="line-added">1204 </span>
1205   OopMapBlock* start_of_nonstatic_oop_maps() const {
1206     return (OopMapBlock*)(start_of_itable() + itable_length());
1207   }
1208 
1209   Klass** end_of_nonstatic_oop_maps() const {
1210     return (Klass**)(start_of_nonstatic_oop_maps() +
1211                      nonstatic_oop_map_count());
1212   }
1213 
1214   Klass* volatile* adr_implementor() const {
1215     if (is_interface()) {
1216       return (Klass* volatile*)end_of_nonstatic_oop_maps();
1217     } else {
1218       return NULL;
1219     }
1220   };
1221 
1222   InstanceKlass** adr_unsafe_anonymous_host() const {
1223     if (is_unsafe_anonymous()) {
1224       InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();
</pre>
<hr />
<pre>
1233   }
1234 
1235   address adr_fingerprint() const {
1236     if (has_stored_fingerprint()) {
1237       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1238       if (adr_host != NULL) {
1239         return (address)(adr_host + 1);
1240       }
1241 
1242       Klass* volatile* adr_impl = adr_implementor();
1243       if (adr_impl != NULL) {
1244         return (address)(adr_impl + 1);
1245       }
1246 
1247       return (address)end_of_nonstatic_oop_maps();
1248     } else {
1249       return NULL;
1250     }
1251   }
1252 
<span class="line-added">1253   address adr_value_fields_klasses() const {</span>
<span class="line-added">1254     if (has_value_fields()) {</span>
<span class="line-added">1255       address adr_fing = adr_fingerprint();</span>
<span class="line-added">1256       if (adr_fing != NULL) {</span>
<span class="line-added">1257         return adr_fingerprint() + sizeof(u8);</span>
<span class="line-added">1258       }</span>
<span class="line-added">1259 </span>
<span class="line-added">1260       InstanceKlass** adr_host = adr_unsafe_anonymous_host();</span>
<span class="line-added">1261       if (adr_host != NULL) {</span>
<span class="line-added">1262         return (address)(adr_host + 1);</span>
<span class="line-added">1263       }</span>
<span class="line-added">1264 </span>
<span class="line-added">1265       Klass* volatile* adr_impl = adr_implementor();</span>
<span class="line-added">1266       if (adr_impl != NULL) {</span>
<span class="line-added">1267         return (address)(adr_impl + 1);</span>
<span class="line-added">1268       }</span>
<span class="line-added">1269 </span>
<span class="line-added">1270       return (address)end_of_nonstatic_oop_maps();</span>
<span class="line-added">1271     } else {</span>
<span class="line-added">1272       return NULL;</span>
<span class="line-added">1273     }</span>
<span class="line-added">1274   }</span>
<span class="line-added">1275 </span>
<span class="line-added">1276   Klass* get_value_field_klass(int idx) const {</span>
<span class="line-added">1277     assert(has_value_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-added">1278     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];</span>
<span class="line-added">1279     assert(k != NULL, &quot;Should always be set before being read&quot;);</span>
<span class="line-added">1280     assert(k-&gt;is_value(), &quot;Must be a value type&quot;);</span>
<span class="line-added">1281     return k;</span>
<span class="line-added">1282   }</span>
<span class="line-added">1283 </span>
<span class="line-added">1284   Klass* get_value_field_klass_or_null(int idx) const {</span>
<span class="line-added">1285     assert(has_value_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-added">1286     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];</span>
<span class="line-added">1287     assert(k == NULL || k-&gt;is_value(), &quot;Must be a value type&quot;);</span>
<span class="line-added">1288     return k;</span>
<span class="line-added">1289   }</span>
<span class="line-added">1290 </span>
<span class="line-added">1291   void set_value_field_klass(int idx, Klass* k) {</span>
<span class="line-added">1292     assert(has_value_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-added">1293     assert(k != NULL, &quot;Should not be set to NULL&quot;);</span>
<span class="line-added">1294     assert(((Klass**)adr_value_fields_klasses())[idx] == NULL, &quot;Should not be set twice&quot;);</span>
<span class="line-added">1295     ((Klass**)adr_value_fields_klasses())[idx] = k;</span>
<span class="line-added">1296   }</span>
<span class="line-added">1297 </span>
1298   // Use this to return the size of an instance in heap words:
<span class="line-modified">1299   virtual int size_helper() const {</span>
1300     return layout_helper_to_size_helper(layout_helper());
1301   }
1302 
1303   // This bit is initialized in classFileParser.cpp.
1304   // It is false under any of the following conditions:
1305   //  - the class is abstract (including any interface)
1306   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1307   //  - the class size is larger than FastAllocateSizeLimit
1308   //  - the class is java/lang/Class, which cannot be allocated directly
1309   bool can_be_fastpath_allocated() const {
1310     return !layout_helper_needs_slow_path(layout_helper());
1311   }
1312 
1313   // Java itable
1314   klassItable itable() const;        // return klassItable wrapper
1315   Method* method_at_itable(Klass* holder, int index, TRAPS);
1316 
1317 #if INCLUDE_JVMTI
1318   void adjust_default_methods(bool* trace_name_printed);
1319 #endif // INCLUDE_JVMTI
</pre>
<hr />
<pre>
1330   void deallocate_contents(ClassLoaderData* loader_data);
1331   static void deallocate_methods(ClassLoaderData* loader_data,
1332                                  Array&lt;Method*&gt;* methods);
1333   void static deallocate_interfaces(ClassLoaderData* loader_data,
1334                                     const Klass* super_klass,
1335                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1336                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1337   void static deallocate_record_components(ClassLoaderData* loader_data,
1338                                            Array&lt;RecordComponent*&gt;* record_component);
1339 
1340   // The constant pool is on stack if any of the methods are executing or
1341   // referenced by handles.
1342   bool on_stack() const { return _constants-&gt;on_stack(); }
1343 
1344   // callbacks for actions during class unloading
1345   static void unload_class(InstanceKlass* ik);
1346   static void release_C_heap_structures(InstanceKlass* ik);
1347 
1348   // Naming
1349   const char* signature_name() const;
<span class="line-added">1350   const char* signature_name_of(char c) const;</span>
1351 
1352   // Oop fields (and metadata) iterators
1353   //
1354   // The InstanceKlass iterators also visits the Object&#39;s klass.
1355 
1356   // Forward iteration
1357  public:
1358   // Iterate over all oop fields in the oop maps.
1359   template &lt;typename T, class OopClosureType&gt;
1360   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1361 
1362   // Iterate over all oop fields and metadata.
1363   template &lt;typename T, class OopClosureType&gt;
1364   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1365 
1366   // Iterate over all oop fields in one oop map.
1367   template &lt;typename T, class OopClosureType&gt;
1368   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1369 
1370 
</pre>
<hr />
<pre>
1416   inline jmethodID* methods_jmethod_ids_acquire() const;
1417   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1418 
1419   // Lock during initialization
1420 public:
1421   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1422   // Must be one per class and it has to be a VM internal object so java code
1423   // cannot lock it (like the mirror).
1424   // It has to be an object not a Mutex because it&#39;s held through java calls.
1425   oop init_lock() const;
1426 private:
1427   void fence_and_clear_init_lock();
1428 
1429   bool link_class_impl                           (TRAPS);
1430   bool verify_code                               (TRAPS);
1431   void initialize_impl                           (TRAPS);
1432   void initialize_super_interfaces               (TRAPS);
1433   void eager_initialize_impl                     ();
1434   /* jni_id_for_impl for jfieldID only */
1435   JNIid* jni_id_for_impl                         (int offset);
<span class="line-modified">1436 protected:</span>
1437   // Returns the array class for the n&#39;th dimension
<span class="line-modified">1438   virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS);</span>
1439 
1440   // Returns the array class with this class as element type
<span class="line-modified">1441   virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);</span>
<span class="line-added">1442 </span>
<span class="line-added">1443 private:</span>
1444 
1445   // find a local method (returns NULL if not found)
1446   Method* find_method_impl(const Symbol* name,
1447                            const Symbol* signature,
1448                            OverpassLookupMode overpass_mode,
1449                            StaticLookupMode static_mode,
1450                            PrivateLookupMode private_mode) const;
1451 
1452   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1453                                   const Symbol* name,
1454                                   const Symbol* signature,
1455                                   OverpassLookupMode overpass_mode,
1456                                   StaticLookupMode static_mode,
1457                                   PrivateLookupMode private_mode);
1458 
1459   // Free CHeap allocated fields.
1460   void release_C_heap_structures();
1461 
1462 #if INCLUDE_JVMTI
1463   // RedefineClasses support
1464   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1465   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1466 #endif
1467 public:
1468   // CDS support - remove and restore oops from metadata. Oops are not shared.
1469   virtual void remove_unshareable_info();
1470   virtual void remove_java_mirror();
<span class="line-modified">1471   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);</span>
1472 
1473   // jvm support
1474   jint compute_modifier_flags(TRAPS) const;
1475 
1476 public:
1477   // JVMTI support
1478   jint jvmti_class_status() const;
1479 
1480   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1481 
1482  public:
1483   // Printing
1484 #ifndef PRODUCT
1485   void print_on(outputStream* st) const;
1486 #endif
1487   void print_value_on(outputStream* st) const;
1488 
1489   void oop_print_value_on(oop obj, outputStream* st);
1490 
1491 #ifndef PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
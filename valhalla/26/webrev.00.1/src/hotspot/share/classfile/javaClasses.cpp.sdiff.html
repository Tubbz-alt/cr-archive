<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/aarch64/aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;


  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 934   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 935   k-&gt;set_modifier_flags(computed_modifiers);
 936   // Class_klass has to be loaded because it is used to allocate
 937   // the mirror.
 938   if (SystemDictionary::Class_klass_loaded()) {
 939     // Allocate mirror (java.lang.Class instance)
 940     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 941     Handle mirror(THREAD, mirror_oop);
 942     Handle comp_mirror;
 943 
 944     // Setup indirection from mirror-&gt;klass
 945     java_lang_Class::set_klass(mirror(), k);
 946 
 947     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 948     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 949 
 950     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 951 
 952     // It might also have a component mirror.  This mirror must already exist.
 953     if (k-&gt;is_array_klass()) {
<span class="line-modified"> 954       if (k-&gt;is_typeArray_klass()) {</span>





 955         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 956         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 957       } else {
 958         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 959         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 960         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
<span class="line-modified"> 961         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());</span>








 962       }
 963       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 964 
 965       // Two-way link between the array klass and its component mirror:
 966       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 967       set_component_mirror(mirror(), comp_mirror());
 968       // See below for ordering dependencies between field array_klass in component mirror
 969       // and java_mirror in this klass.
 970     } else {
 971       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
 972 
 973       initialize_mirror_fields(k, mirror, protection_domain, THREAD);
 974       if (HAS_PENDING_EXCEPTION) {
 975         // If any of the fields throws an exception like OOM remove the klass field
 976         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
 977         // This mirror looks like a primitive type, which logically it is because it
 978         // it represents no class.
 979         java_lang_Class::set_klass(mirror(), NULL);
 980         return;
 981       }
 982     }
 983 
 984     // set the classLoader field in the java_lang_Class instance
 985     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
 986     set_class_loader(mirror(), class_loader());
 987 
 988     // Setup indirection from klass-&gt;mirror
 989     // after any exceptions can happen during allocations.
 990     k-&gt;set_java_mirror(mirror);
 991 
 992     // Set the module field in the java_lang_Class instance.  This must be done
 993     // after the mirror is set.
 994     set_mirror_module_field(k, mirror, module, THREAD);
 995 
 996     if (comp_mirror() != NULL) {
 997       // Set after k-&gt;java_mirror() is published, because compiled code running
 998       // concurrently doesn&#39;t expect a k to have a null java_mirror.
 999       release_set_array_klass(comp_mirror(), k);
1000     }







1001   } else {
1002     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1003     fixup_mirror_list()-&gt;push(k);
1004   }
1005 }
1006 






















1007 #if INCLUDE_CDS_JAVA_HEAP
1008 // Clears mirror fields. Static final fields with initial values are reloaded
1009 // from constant pool. The object identity hash is in the object header and is
1010 // not affected.
1011 class ResetMirrorField: public FieldClosure {
1012  private:
1013   Handle _m;
1014 
1015  public:
1016   ResetMirrorField(Handle mirror) : _m(mirror) {}
1017 
1018   void do_field(fieldDescriptor* fd) {
1019     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1020     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1021 
1022     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1023       initialize_static_field(fd, _m, Thread::current());
1024       return;
1025     }
1026 
</pre>
<hr />
<pre>
1137 
1138   // No mirror
1139   oop mirror = k-&gt;java_mirror();
1140   if (mirror == NULL) {
1141     return NULL;
1142   }
1143 
1144   if (k-&gt;is_instance_klass()) {
1145     InstanceKlass *ik = InstanceKlass::cast(k);
1146     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1147 
1148     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1149           ik-&gt;is_shared_app_class())) {
1150       // Archiving mirror for classes from non-builtin loaders is not
1151       // supported. Clear the _java_mirror within the archived class.
1152       k-&gt;set_java_mirror_handle(NULL);
1153       return NULL;
1154     }
1155   }
1156 






1157   // Now start archiving the mirror object
1158   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1159   if (archived_mirror == NULL) {
1160     return NULL;
1161   }
1162 
1163   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1164   if (archived_mirror == NULL) {
1165     return NULL;
1166   }
1167 
1168   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1169 
1170   k-&gt;set_has_raw_archived_mirror();
1171 
1172   ResourceMark rm;
1173   log_trace(cds, heap, mirror)(
1174     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1175     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1176 
</pre>
<hr />
<pre>
1421 oop java_lang_Class::name(Handle java_class, TRAPS) {
1422   assert(_name_offset != 0, &quot;must be set&quot;);
1423   oop o = java_class-&gt;obj_field(_name_offset);
1424   if (o == NULL) {
1425     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1426     java_class-&gt;obj_field_put(_name_offset, o);
1427   }
1428   return o;
1429 }
1430 
1431 oop java_lang_Class::source_file(oop java_class) {
1432   assert(_source_file_offset != 0, &quot;must be set&quot;);
1433   return java_class-&gt;obj_field(_source_file_offset);
1434 }
1435 
1436 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1437   assert(_source_file_offset != 0, &quot;must be set&quot;);
1438   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1439 }
1440 




















1441 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1442   // This should be improved by adding a field at the Java level or by
1443   // introducing a new VM klass (see comment in ClassFileParser)
1444   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1445   if (type != T_VOID) {
1446     Klass* aklass = Universe::typeArrayKlassObj(type);
1447     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1448     release_set_array_klass(java_class, aklass);
1449   }
1450 #ifdef ASSERT
1451   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1452   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1453 #endif
1454   return java_class;
1455 }
1456 
1457 
1458 Klass* java_lang_Class::as_Klass(oop java_class) {
1459   //%note memory_2
1460   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
</pre>
<hr />
<pre>
1465 
1466 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1467   //%note memory_2
1468   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1469   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1470   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1471   return k;
1472 }
1473 
1474 
1475 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1476   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1477   java_class-&gt;metadata_field_put(_klass_offset, klass);
1478 }
1479 
1480 
1481 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1482   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1483   Symbol* name = NULL;
1484   bool is_instance = false;

1485   if (is_primitive(java_class)) {
1486     name = vmSymbols::type_signature(primitive_type(java_class));
1487   } else {
1488     Klass* k = as_Klass(java_class);
1489     is_instance = k-&gt;is_instance_klass();

1490     name = k-&gt;name();
1491   }
1492   if (name == NULL) {
1493     st-&gt;print(&quot;&lt;null&gt;&quot;);
1494     return;
1495   }
<span class="line-modified">1496   if (is_instance)  st-&gt;print(&quot;L&quot;);</span>






1497   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1498   if (is_instance)  st-&gt;print(&quot;;&quot;);
1499 }
1500 
1501 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1502   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1503   Symbol* name;
1504   if (is_primitive(java_class)) {
1505     name = vmSymbols::type_signature(primitive_type(java_class));
1506     // Because this can create a new symbol, the caller has to decrement
1507     // the refcount, so make adjustment here and below for symbols returned
1508     // that are not created or incremented due to a successful lookup.
1509     name-&gt;increment_refcount();
1510   } else {
1511     Klass* k = as_Klass(java_class);
1512     if (!k-&gt;is_instance_klass()) {
1513       name = k-&gt;name();
1514       name-&gt;increment_refcount();
1515     } else {
1516       ResourceMark rm;
<span class="line-modified">1517       const char* sigstr = k-&gt;signature_name();</span>
<span class="line-modified">1518       int         siglen = (int) strlen(sigstr);</span>







1519       if (!intern_if_not_found) {
1520         name = SymbolTable::probe(sigstr, siglen);
1521       } else {
1522         name = SymbolTable::new_symbol(sigstr, siglen);
1523       }
1524     }
1525   }
1526   return name;
1527 }
1528 
1529 // Returns the Java name for this Java mirror (Resource allocated)
1530 // See Klass::external_name().
1531 // For primitive type Java mirrors, its type name is returned.
1532 const char* java_lang_Class::as_external_name(oop java_class) {
1533   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1534   const char* name = NULL;
1535   if (is_primitive(java_class)) {
1536     name = type2name(primitive_type(java_class));
1537   } else {
1538     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1583   }
1584 }
1585 
1586 
1587 oop java_lang_Class::primitive_mirror(BasicType t) {
1588   oop mirror = Universe::java_mirror(t);
1589   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1590   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1591   return mirror;
1592 }
1593 
1594 bool java_lang_Class::offsets_computed = false;
1595 int  java_lang_Class::classRedefinedCount_offset = -1;
1596 
1597 #define CLASS_FIELDS_DO(macro) \
1598   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1599   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1600   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1601   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1602   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \


1603 
1604 void java_lang_Class::compute_offsets() {
1605   if (offsets_computed) {
1606     return;
1607   }
1608 
1609   offsets_computed = true;
1610 
1611   InstanceKlass* k = SystemDictionary::Class_klass();
1612   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1613 
1614   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1615   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1616   // GC treats them the same.
1617   _init_lock_offset = _component_mirror_offset;
1618 
1619   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1620 }
1621 
1622 #if INCLUDE_CDS
</pre>
<hr />
<pre>
2457 #endif
2458 
2459     // the format of the stacktrace will be:
2460     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2461     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2462     // - rest of the stack
2463 
2464     if (!skip_fillInStackTrace_check) {
2465       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2466           throwable-&gt;is_a(method-&gt;method_holder())) {
2467         continue;
2468       }
2469       else {
2470         skip_fillInStackTrace_check = true; // gone past them all
2471       }
2472     }
2473     if (!skip_throwableInit_check) {
2474       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2475 
2476       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2477       // This is simlar to classic VM.</span>
<span class="line-modified">2478       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
2479           throwable-&gt;is_a(method-&gt;method_holder())) {
2480         continue;
2481       } else {
2482         // there are none or we&#39;ve seen them all - either way stop checking
2483         skip_throwableInit_check = true;
2484       }
2485     }
2486     if (method-&gt;is_hidden()) {
2487       if (skip_hidden) {
2488         if (total_count == 0) {
2489           // The top frame will be hidden from the stack trace.
2490           bt.set_has_hidden_top_frame(CHECK);
2491         }
2492         continue;
2493       }
2494     }
2495     bt.push(method, bci, CHECK);
2496     total_count++;
2497   }
2498 
</pre>
<hr />
<pre>
3741 int java_lang_invoke_MemberName::flags(oop mname) {
3742   assert(is_instance(mname), &quot;wrong type&quot;);
3743   return mname-&gt;int_field(_flags_offset);
3744 }
3745 
3746 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3747   assert(is_instance(mname), &quot;wrong type&quot;);
3748   mname-&gt;int_field_put(_flags_offset, flags);
3749 }
3750 
3751 
3752 // Return vmtarget from ResolvedMethodName method field through indirection
3753 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3754   assert(is_instance(mname), &quot;wrong type&quot;);
3755   oop method = mname-&gt;obj_field(_method_offset);
3756   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3757 }
3758 
3759 bool java_lang_invoke_MemberName::is_method(oop mname) {
3760   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3761   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;</span>
3762 }
3763 
3764 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3765   assert(is_instance(mname), &quot;wrong type&quot;);
3766   mname-&gt;obj_field_put(_method_offset, resolved_method);
3767 }
3768 
3769 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3770   assert(is_instance(mname), &quot;wrong type&quot;);
3771   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3772 }
3773 
3774 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3775   assert(is_instance(mname), &quot;wrong type&quot;);
3776   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3777 }
3778 
3779 
3780 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3781   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4247       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4248     } else {
4249       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4250     }
4251   }
4252 };
4253 
4254 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4255   UnsafeConstantsFixup fixup;
4256   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4257 }
4258 
4259 int java_lang_Class::_klass_offset;
4260 int java_lang_Class::_array_klass_offset;
4261 int java_lang_Class::_oop_size_offset;
4262 int java_lang_Class::_static_oop_field_count_offset;
4263 int java_lang_Class::_class_loader_offset;
4264 int java_lang_Class::_module_offset;
4265 int java_lang_Class::_protection_domain_offset;
4266 int java_lang_Class::_component_mirror_offset;


4267 int java_lang_Class::_init_lock_offset;
4268 int java_lang_Class::_signers_offset;
4269 int java_lang_Class::_name_offset;
4270 int java_lang_Class::_source_file_offset;
4271 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4272 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4273 int java_lang_Throwable::backtrace_offset;
4274 int java_lang_Throwable::detailMessage_offset;
4275 int java_lang_Throwable::stackTrace_offset;
4276 int java_lang_Throwable::depth_offset;
4277 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4278 int java_lang_reflect_AccessibleObject::override_offset;
4279 int java_lang_reflect_Method::clazz_offset;
4280 int java_lang_reflect_Method::name_offset;
4281 int java_lang_reflect_Method::returnType_offset;
4282 int java_lang_reflect_Method::parameterTypes_offset;
4283 int java_lang_reflect_Method::exceptionTypes_offset;
4284 int java_lang_reflect_Method::slot_offset;
4285 int java_lang_reflect_Method::modifiers_offset;
4286 int java_lang_reflect_Method::signature_offset;
</pre>
<hr />
<pre>
4340 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4341 int java_lang_AssertionStatusDirectives::deflt_offset;
4342 int java_nio_Buffer::_limit_offset;
4343 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4344 int reflect_ConstantPool::_oop_offset;
4345 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4346 int java_lang_Integer_IntegerCache::_static_cache_offset;
4347 int java_lang_Long_LongCache::_static_cache_offset;
4348 int java_lang_Character_CharacterCache::_static_cache_offset;
4349 int java_lang_Short_ShortCache::_static_cache_offset;
4350 int java_lang_Byte_ByteCache::_static_cache_offset;
4351 int java_lang_Boolean::_static_TRUE_offset;
4352 int java_lang_Boolean::_static_FALSE_offset;
4353 int java_lang_reflect_RecordComponent::clazz_offset;
4354 int java_lang_reflect_RecordComponent::name_offset;
4355 int java_lang_reflect_RecordComponent::type_offset;
4356 int java_lang_reflect_RecordComponent::accessor_offset;
4357 int java_lang_reflect_RecordComponent::signature_offset;
4358 int java_lang_reflect_RecordComponent::annotations_offset;
4359 int java_lang_reflect_RecordComponent::typeAnnotations_offset;





4360 
4361 
4362 
4363 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4364   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4365   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4366   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4367   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4368   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4369   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4370   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4371   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4372 
4373 // Support for java_lang_StackTraceElement
4374 void java_lang_StackTraceElement::compute_offsets() {
4375   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4376   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4377 }
4378 
4379 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4645   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4646   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4647 }
4648 
4649 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4650   oop base = ik-&gt;static_field_base_raw();
4651   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4652 }
4653 
4654 Symbol* java_lang_Byte_ByteCache::symbol() {
4655   return vmSymbols::java_lang_Byte_ByteCache();
4656 }
4657 
4658 #if INCLUDE_CDS
4659 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4660   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4661 }
4662 #endif
4663 #undef BYTE_CACHE_FIELDS_DO
4664 































































4665 jbyte java_lang_Byte::value(oop obj) {
4666    jvalue v;
4667    java_lang_boxing_object::get_value(obj, &amp;v);
4668    return v.b;
4669 }
4670 #define BOOLEAN_FIELDS_DO(macro) \
4671   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4672   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4673 
4674 
4675 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4676   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4677   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4678 }
4679 
4680 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4681   oop base = ik-&gt;static_field_base_raw();
4682   return base-&gt;obj_field(_static_TRUE_offset);
4683 }
4684 
</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  55 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  56 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/vframe.inline.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/utf8.hpp&quot;
  75 #if INCLUDE_JVMCI
  76 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 936   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 937   k-&gt;set_modifier_flags(computed_modifiers);
 938   // Class_klass has to be loaded because it is used to allocate
 939   // the mirror.
 940   if (SystemDictionary::Class_klass_loaded()) {
 941     // Allocate mirror (java.lang.Class instance)
 942     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 943     Handle mirror(THREAD, mirror_oop);
 944     Handle comp_mirror;
 945 
 946     // Setup indirection from mirror-&gt;klass
 947     java_lang_Class::set_klass(mirror(), k);
 948 
 949     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 950     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 951 
 952     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 953 
 954     // It might also have a component mirror.  This mirror must already exist.
 955     if (k-&gt;is_array_klass()) {
<span class="line-modified"> 956       if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 957         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 958         assert(element_klass-&gt;is_value(), &quot;Must be value type component&quot;);</span>
<span class="line-added"> 959         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added"> 960         comp_mirror = Handle(THREAD, vk-&gt;value_mirror());</span>
<span class="line-added"> 961       } else if (k-&gt;is_typeArray_klass()) {</span>
 962         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 963         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 964       } else {
 965         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 966         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 967         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
<span class="line-modified"> 968         if (element_klass-&gt;is_value()) {</span>
<span class="line-added"> 969           ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added"> 970           assert(vk-&gt;java_mirror() == vk-&gt;value_mirror(), &quot;primary mirror is the value mirror&quot;);</span>
<span class="line-added"> 971           assert(vk-&gt;indirect_mirror() != NULL, &quot;must have an indirect class mirror&quot;);</span>
<span class="line-added"> 972           comp_mirror = k-&gt;name()-&gt;is_Q_array_signature() ? Handle(THREAD, vk-&gt;value_mirror())</span>
<span class="line-added"> 973                                                           : Handle(THREAD, vk-&gt;indirect_mirror());</span>
<span class="line-added"> 974         } else {</span>
<span class="line-added"> 975           comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());</span>
<span class="line-added"> 976         }</span>
 977       }
 978       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 979 
 980       // Two-way link between the array klass and its component mirror:
 981       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 982       set_component_mirror(mirror(), comp_mirror());
 983       // See below for ordering dependencies between field array_klass in component mirror
 984       // and java_mirror in this klass.
 985     } else {
 986       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
 987 
 988       initialize_mirror_fields(k, mirror, protection_domain, THREAD);
 989       if (HAS_PENDING_EXCEPTION) {
 990         // If any of the fields throws an exception like OOM remove the klass field
 991         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
 992         // This mirror looks like a primitive type, which logically it is because it
 993         // it represents no class.
 994         java_lang_Class::set_klass(mirror(), NULL);
 995         return;
 996       }
 997     }
 998 
 999     // set the classLoader field in the java_lang_Class instance
1000     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1001     set_class_loader(mirror(), class_loader());
1002 
1003     // Setup indirection from klass-&gt;mirror
1004     // after any exceptions can happen during allocations.
1005     k-&gt;set_java_mirror(mirror);
1006 
1007     // Set the module field in the java_lang_Class instance.  This must be done
1008     // after the mirror is set.
1009     set_mirror_module_field(k, mirror, module, THREAD);
1010 
1011     if (comp_mirror() != NULL) {
1012       // Set after k-&gt;java_mirror() is published, because compiled code running
1013       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1014       release_set_array_klass(comp_mirror(), k);
1015     }
<span class="line-added">1016 </span>
<span class="line-added">1017     if (k-&gt;is_value()) {</span>
<span class="line-added">1018       // create the secondary mirror for an inline class</span>
<span class="line-added">1019       oop indirect_mirror_oop = create_indirect_type_mirror(k, mirror, CHECK);</span>
<span class="line-added">1020       set_inline_type_mirror(mirror(), mirror());</span>
<span class="line-added">1021       set_indirect_type_mirror(mirror(), indirect_mirror_oop);</span>
<span class="line-added">1022     }</span>
1023   } else {
1024     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1025     fixup_mirror_list()-&gt;push(k);
1026   }
1027 }
1028 
<span class="line-added">1029 // Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class</span>
<span class="line-added">1030 // instance with the same value as the primary mirror</span>
<span class="line-added">1031 oop java_lang_Class::create_indirect_type_mirror(Klass* k, Handle mirror, TRAPS) {</span>
<span class="line-added">1032   assert(k-&gt;is_value(), &quot;inline class&quot;);</span>
<span class="line-added">1033   // Allocate mirror (java.lang.Class instance)</span>
<span class="line-added">1034   oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK_0);</span>
<span class="line-added">1035   Handle indirect_mirror(THREAD, mirror_oop);</span>
<span class="line-added">1036 </span>
<span class="line-added">1037   java_lang_Class::set_klass(indirect_mirror(), k);</span>
<span class="line-added">1038   java_lang_Class::set_static_oop_field_count(indirect_mirror(), static_oop_field_count(mirror()));</span>
<span class="line-added">1039   // ## do we need to set init lock?</span>
<span class="line-added">1040   java_lang_Class::set_init_lock(indirect_mirror(), init_lock(mirror()));</span>
<span class="line-added">1041 </span>
<span class="line-added">1042   set_protection_domain(indirect_mirror(), protection_domain(mirror()));</span>
<span class="line-added">1043   set_class_loader(indirect_mirror(), class_loader(mirror()));</span>
<span class="line-added">1044   // ## handle if java.base is not yet defined</span>
<span class="line-added">1045   set_module(indirect_mirror(), module(mirror()));</span>
<span class="line-added">1046   set_inline_type_mirror(indirect_mirror(), mirror());</span>
<span class="line-added">1047   set_indirect_type_mirror(indirect_mirror(), indirect_mirror());</span>
<span class="line-added">1048   return indirect_mirror();</span>
<span class="line-added">1049 }</span>
<span class="line-added">1050 </span>
1051 #if INCLUDE_CDS_JAVA_HEAP
1052 // Clears mirror fields. Static final fields with initial values are reloaded
1053 // from constant pool. The object identity hash is in the object header and is
1054 // not affected.
1055 class ResetMirrorField: public FieldClosure {
1056  private:
1057   Handle _m;
1058 
1059  public:
1060   ResetMirrorField(Handle mirror) : _m(mirror) {}
1061 
1062   void do_field(fieldDescriptor* fd) {
1063     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1064     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1065 
1066     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1067       initialize_static_field(fd, _m, Thread::current());
1068       return;
1069     }
1070 
</pre>
<hr />
<pre>
1181 
1182   // No mirror
1183   oop mirror = k-&gt;java_mirror();
1184   if (mirror == NULL) {
1185     return NULL;
1186   }
1187 
1188   if (k-&gt;is_instance_klass()) {
1189     InstanceKlass *ik = InstanceKlass::cast(k);
1190     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1191 
1192     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1193           ik-&gt;is_shared_app_class())) {
1194       // Archiving mirror for classes from non-builtin loaders is not
1195       // supported. Clear the _java_mirror within the archived class.
1196       k-&gt;set_java_mirror_handle(NULL);
1197       return NULL;
1198     }
1199   }
1200 
<span class="line-added">1201   if (k-&gt;is_value()) {</span>
<span class="line-added">1202     // Values have a mirror and an indirect mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1203     k-&gt;set_java_mirror_handle(NULL);</span>
<span class="line-added">1204     return NULL;</span>
<span class="line-added">1205   }</span>
<span class="line-added">1206 </span>
1207   // Now start archiving the mirror object
1208   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1209   if (archived_mirror == NULL) {
1210     return NULL;
1211   }
1212 
1213   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1214   if (archived_mirror == NULL) {
1215     return NULL;
1216   }
1217 
1218   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1219 
1220   k-&gt;set_has_raw_archived_mirror();
1221 
1222   ResourceMark rm;
1223   log_trace(cds, heap, mirror)(
1224     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1225     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1226 
</pre>
<hr />
<pre>
1471 oop java_lang_Class::name(Handle java_class, TRAPS) {
1472   assert(_name_offset != 0, &quot;must be set&quot;);
1473   oop o = java_class-&gt;obj_field(_name_offset);
1474   if (o == NULL) {
1475     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1476     java_class-&gt;obj_field_put(_name_offset, o);
1477   }
1478   return o;
1479 }
1480 
1481 oop java_lang_Class::source_file(oop java_class) {
1482   assert(_source_file_offset != 0, &quot;must be set&quot;);
1483   return java_class-&gt;obj_field(_source_file_offset);
1484 }
1485 
1486 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1487   assert(_source_file_offset != 0, &quot;must be set&quot;);
1488   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1489 }
1490 
<span class="line-added">1491 oop java_lang_Class::inline_type_mirror(oop java_class) {</span>
<span class="line-added">1492   assert(_inline_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1493   return java_class-&gt;obj_field(_inline_mirror_offset);</span>
<span class="line-added">1494 }</span>
<span class="line-added">1495 </span>
<span class="line-added">1496 void java_lang_Class::set_inline_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1497   assert(_inline_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1498   java_class-&gt;obj_field_put(_inline_mirror_offset, mirror);</span>
<span class="line-added">1499 }</span>
<span class="line-added">1500 </span>
<span class="line-added">1501 oop java_lang_Class::indirect_type_mirror(oop java_class) {</span>
<span class="line-added">1502   assert(_indirect_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1503   return java_class-&gt;obj_field(_indirect_mirror_offset);</span>
<span class="line-added">1504 }</span>
<span class="line-added">1505 </span>
<span class="line-added">1506 void java_lang_Class::set_indirect_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1507   assert(_indirect_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1508   java_class-&gt;obj_field_put(_indirect_mirror_offset, mirror);</span>
<span class="line-added">1509 }</span>
<span class="line-added">1510 </span>
1511 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1512   // This should be improved by adding a field at the Java level or by
1513   // introducing a new VM klass (see comment in ClassFileParser)
1514   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1515   if (type != T_VOID) {
1516     Klass* aklass = Universe::typeArrayKlassObj(type);
1517     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1518     release_set_array_klass(java_class, aklass);
1519   }
1520 #ifdef ASSERT
1521   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1522   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1523 #endif
1524   return java_class;
1525 }
1526 
1527 
1528 Klass* java_lang_Class::as_Klass(oop java_class) {
1529   //%note memory_2
1530   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
</pre>
<hr />
<pre>
1535 
1536 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1537   //%note memory_2
1538   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1539   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1540   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1541   return k;
1542 }
1543 
1544 
1545 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1546   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1547   java_class-&gt;metadata_field_put(_klass_offset, klass);
1548 }
1549 
1550 
1551 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1552   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1553   Symbol* name = NULL;
1554   bool is_instance = false;
<span class="line-added">1555   bool is_value = false;</span>
1556   if (is_primitive(java_class)) {
1557     name = vmSymbols::type_signature(primitive_type(java_class));
1558   } else {
1559     Klass* k = as_Klass(java_class);
1560     is_instance = k-&gt;is_instance_klass();
<span class="line-added">1561     is_value = k-&gt;is_value();</span>
1562     name = k-&gt;name();
1563   }
1564   if (name == NULL) {
1565     st-&gt;print(&quot;&lt;null&gt;&quot;);
1566     return;
1567   }
<span class="line-modified">1568   if (is_instance)  {</span>
<span class="line-added">1569     if (is_value &amp;&amp; (java_class == inline_type_mirror(java_class))) {</span>
<span class="line-added">1570       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1571     } else {</span>
<span class="line-added">1572       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1573     }</span>
<span class="line-added">1574   }</span>
1575   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1576   if (is_instance)  st-&gt;print(&quot;;&quot;);
1577 }
1578 
1579 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1580   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1581   Symbol* name;
1582   if (is_primitive(java_class)) {
1583     name = vmSymbols::type_signature(primitive_type(java_class));
1584     // Because this can create a new symbol, the caller has to decrement
1585     // the refcount, so make adjustment here and below for symbols returned
1586     // that are not created or incremented due to a successful lookup.
1587     name-&gt;increment_refcount();
1588   } else {
1589     Klass* k = as_Klass(java_class);
1590     if (!k-&gt;is_instance_klass()) {
1591       name = k-&gt;name();
1592       name-&gt;increment_refcount();
1593     } else {
1594       ResourceMark rm;
<span class="line-modified">1595       const char* sigstr;</span>
<span class="line-modified">1596       if (k-&gt;is_value()) {</span>
<span class="line-added">1597         char c = (java_class == inline_type_mirror(java_class)) ?</span>
<span class="line-added">1598           JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;</span>
<span class="line-added">1599         sigstr = InstanceKlass::cast(k)-&gt;signature_name_of(c);</span>
<span class="line-added">1600       } else {</span>
<span class="line-added">1601         sigstr = k-&gt;signature_name();</span>
<span class="line-added">1602       }</span>
<span class="line-added">1603       int siglen = (int) strlen(sigstr);</span>
1604       if (!intern_if_not_found) {
1605         name = SymbolTable::probe(sigstr, siglen);
1606       } else {
1607         name = SymbolTable::new_symbol(sigstr, siglen);
1608       }
1609     }
1610   }
1611   return name;
1612 }
1613 
1614 // Returns the Java name for this Java mirror (Resource allocated)
1615 // See Klass::external_name().
1616 // For primitive type Java mirrors, its type name is returned.
1617 const char* java_lang_Class::as_external_name(oop java_class) {
1618   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1619   const char* name = NULL;
1620   if (is_primitive(java_class)) {
1621     name = type2name(primitive_type(java_class));
1622   } else {
1623     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1668   }
1669 }
1670 
1671 
1672 oop java_lang_Class::primitive_mirror(BasicType t) {
1673   oop mirror = Universe::java_mirror(t);
1674   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1675   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1676   return mirror;
1677 }
1678 
1679 bool java_lang_Class::offsets_computed = false;
1680 int  java_lang_Class::classRedefinedCount_offset = -1;
1681 
1682 #define CLASS_FIELDS_DO(macro) \
1683   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1684   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1685   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1686   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1687   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
<span class="line-added">1688   macro(_inline_mirror_offset,      k, &quot;inlineType&quot;,          class_signature,       false); \</span>
<span class="line-added">1689   macro(_indirect_mirror_offset,    k, &quot;indirectType&quot;,        class_signature,       false); \</span>
1690 
1691 void java_lang_Class::compute_offsets() {
1692   if (offsets_computed) {
1693     return;
1694   }
1695 
1696   offsets_computed = true;
1697 
1698   InstanceKlass* k = SystemDictionary::Class_klass();
1699   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1700 
1701   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1702   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1703   // GC treats them the same.
1704   _init_lock_offset = _component_mirror_offset;
1705 
1706   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1707 }
1708 
1709 #if INCLUDE_CDS
</pre>
<hr />
<pre>
2544 #endif
2545 
2546     // the format of the stacktrace will be:
2547     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2548     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2549     // - rest of the stack
2550 
2551     if (!skip_fillInStackTrace_check) {
2552       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2553           throwable-&gt;is_a(method-&gt;method_holder())) {
2554         continue;
2555       }
2556       else {
2557         skip_fillInStackTrace_check = true; // gone past them all
2558       }
2559     }
2560     if (!skip_throwableInit_check) {
2561       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2562 
2563       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2564       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2565       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2566           throwable-&gt;is_a(method-&gt;method_holder())) {
2567         continue;
2568       } else {
2569         // there are none or we&#39;ve seen them all - either way stop checking
2570         skip_throwableInit_check = true;
2571       }
2572     }
2573     if (method-&gt;is_hidden()) {
2574       if (skip_hidden) {
2575         if (total_count == 0) {
2576           // The top frame will be hidden from the stack trace.
2577           bt.set_has_hidden_top_frame(CHECK);
2578         }
2579         continue;
2580       }
2581     }
2582     bt.push(method, bci, CHECK);
2583     total_count++;
2584   }
2585 
</pre>
<hr />
<pre>
3828 int java_lang_invoke_MemberName::flags(oop mname) {
3829   assert(is_instance(mname), &quot;wrong type&quot;);
3830   return mname-&gt;int_field(_flags_offset);
3831 }
3832 
3833 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3834   assert(is_instance(mname), &quot;wrong type&quot;);
3835   mname-&gt;int_field_put(_flags_offset, flags);
3836 }
3837 
3838 
3839 // Return vmtarget from ResolvedMethodName method field through indirection
3840 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3841   assert(is_instance(mname), &quot;wrong type&quot;);
3842   oop method = mname-&gt;obj_field(_method_offset);
3843   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3844 }
3845 
3846 bool java_lang_invoke_MemberName::is_method(oop mname) {
3847   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3848   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3849 }
3850 
3851 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3852   assert(is_instance(mname), &quot;wrong type&quot;);
3853   mname-&gt;obj_field_put(_method_offset, resolved_method);
3854 }
3855 
3856 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3857   assert(is_instance(mname), &quot;wrong type&quot;);
3858   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3859 }
3860 
3861 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3862   assert(is_instance(mname), &quot;wrong type&quot;);
3863   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3864 }
3865 
3866 
3867 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3868   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4334       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4335     } else {
4336       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4337     }
4338   }
4339 };
4340 
4341 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4342   UnsafeConstantsFixup fixup;
4343   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4344 }
4345 
4346 int java_lang_Class::_klass_offset;
4347 int java_lang_Class::_array_klass_offset;
4348 int java_lang_Class::_oop_size_offset;
4349 int java_lang_Class::_static_oop_field_count_offset;
4350 int java_lang_Class::_class_loader_offset;
4351 int java_lang_Class::_module_offset;
4352 int java_lang_Class::_protection_domain_offset;
4353 int java_lang_Class::_component_mirror_offset;
<span class="line-added">4354 int java_lang_Class::_inline_mirror_offset;</span>
<span class="line-added">4355 int java_lang_Class::_indirect_mirror_offset;</span>
4356 int java_lang_Class::_init_lock_offset;
4357 int java_lang_Class::_signers_offset;
4358 int java_lang_Class::_name_offset;
4359 int java_lang_Class::_source_file_offset;
4360 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4361 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4362 int java_lang_Throwable::backtrace_offset;
4363 int java_lang_Throwable::detailMessage_offset;
4364 int java_lang_Throwable::stackTrace_offset;
4365 int java_lang_Throwable::depth_offset;
4366 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4367 int java_lang_reflect_AccessibleObject::override_offset;
4368 int java_lang_reflect_Method::clazz_offset;
4369 int java_lang_reflect_Method::name_offset;
4370 int java_lang_reflect_Method::returnType_offset;
4371 int java_lang_reflect_Method::parameterTypes_offset;
4372 int java_lang_reflect_Method::exceptionTypes_offset;
4373 int java_lang_reflect_Method::slot_offset;
4374 int java_lang_reflect_Method::modifiers_offset;
4375 int java_lang_reflect_Method::signature_offset;
</pre>
<hr />
<pre>
4429 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4430 int java_lang_AssertionStatusDirectives::deflt_offset;
4431 int java_nio_Buffer::_limit_offset;
4432 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4433 int reflect_ConstantPool::_oop_offset;
4434 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4435 int java_lang_Integer_IntegerCache::_static_cache_offset;
4436 int java_lang_Long_LongCache::_static_cache_offset;
4437 int java_lang_Character_CharacterCache::_static_cache_offset;
4438 int java_lang_Short_ShortCache::_static_cache_offset;
4439 int java_lang_Byte_ByteCache::_static_cache_offset;
4440 int java_lang_Boolean::_static_TRUE_offset;
4441 int java_lang_Boolean::_static_FALSE_offset;
4442 int java_lang_reflect_RecordComponent::clazz_offset;
4443 int java_lang_reflect_RecordComponent::name_offset;
4444 int java_lang_reflect_RecordComponent::type_offset;
4445 int java_lang_reflect_RecordComponent::accessor_offset;
4446 int java_lang_reflect_RecordComponent::signature_offset;
4447 int java_lang_reflect_RecordComponent::annotations_offset;
4448 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
<span class="line-added">4449 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4450 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4451 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4452 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-added">4453 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
4454 
4455 
4456 
4457 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4458   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4459   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4460   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4461   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4462   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4463   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4464   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4465   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4466 
4467 // Support for java_lang_StackTraceElement
4468 void java_lang_StackTraceElement::compute_offsets() {
4469   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4470   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4471 }
4472 
4473 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4739   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4740   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4741 }
4742 
4743 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4744   oop base = ik-&gt;static_field_base_raw();
4745   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4746 }
4747 
4748 Symbol* java_lang_Byte_ByteCache::symbol() {
4749   return vmSymbols::java_lang_Byte_ByteCache();
4750 }
4751 
4752 #if INCLUDE_CDS
4753 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4754   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4755 }
4756 #endif
4757 #undef BYTE_CACHE_FIELDS_DO
4758 
<span class="line-added">4759 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4760   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4761   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4762   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4763   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \</span>
<span class="line-added">4764   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);</span>
<span class="line-added">4765 </span>
<span class="line-added">4766 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4767   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4768   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4769 }</span>
<span class="line-added">4770 </span>
<span class="line-added">4771 #if INCLUDE_CDS</span>
<span class="line-added">4772 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4773   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4774 }</span>
<span class="line-added">4775 #endif</span>
<span class="line-added">4776 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4777 </span>
<span class="line-added">4778 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4779   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4780 }</span>
<span class="line-added">4781 </span>
<span class="line-added">4782 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4783   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4784 }</span>
<span class="line-added">4785 </span>
<span class="line-added">4786 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4787   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4788 }</span>
<span class="line-added">4789 </span>
<span class="line-added">4790 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4791   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4792 }</span>
<span class="line-added">4793 </span>
<span class="line-added">4794 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4795   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4796 }</span>
<span class="line-added">4797 </span>
<span class="line-added">4798 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4799   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4800 }</span>
<span class="line-added">4801 </span>
<span class="line-added">4802 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4803   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4804 }</span>
<span class="line-added">4805 </span>
<span class="line-added">4806 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattened(oop obj) {</span>
<span class="line-added">4807   return obj-&gt;bool_field(_isFlattened_offset);</span>
<span class="line-added">4808 }</span>
<span class="line-added">4809 </span>
<span class="line-added">4810 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {</span>
<span class="line-added">4811   obj-&gt;bool_field_put(_isFlattened_offset, b);</span>
<span class="line-added">4812 }</span>
<span class="line-added">4813 </span>
<span class="line-added">4814 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {</span>
<span class="line-added">4815   return obj-&gt;bool_field(_isFlattenable_offset);</span>
<span class="line-added">4816 }</span>
<span class="line-added">4817 </span>
<span class="line-added">4818 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {</span>
<span class="line-added">4819   obj-&gt;bool_field_put(_isFlattenable_offset, b);</span>
<span class="line-added">4820 }</span>
<span class="line-added">4821 </span>
4822 jbyte java_lang_Byte::value(oop obj) {
4823    jvalue v;
4824    java_lang_boxing_object::get_value(obj, &amp;v);
4825    return v.b;
4826 }
4827 #define BOOLEAN_FIELDS_DO(macro) \
4828   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4829   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4830 
4831 
4832 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4833   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4834   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4835 }
4836 
4837 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4838   oop base = ik-&gt;static_field_base_raw();
4839   return base-&gt;obj_field(_static_TRUE_offset);
4840 }
4841 
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/aarch64/aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
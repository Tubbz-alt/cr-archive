<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../java.base/share/classes/java/lang/reflect/Modifier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../test/hotspot/jtreg/ProblemList.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.stream.Collectors;
  30 
  31 import com.sun.tools.javac.code.*;
  32 import com.sun.tools.javac.code.Kinds.KindSelector;
  33 import com.sun.tools.javac.code.Scope.WriteableScope;

  34 import com.sun.tools.javac.jvm.*;
  35 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  36 import com.sun.tools.javac.main.Option.PkgInfo;
  37 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  38 import com.sun.tools.javac.tree.*;
  39 import com.sun.tools.javac.util.*;
  40 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  41 import com.sun.tools.javac.util.List;
  42 
  43 import com.sun.tools.javac.code.Symbol.*;
  44 import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;
  45 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  46 import com.sun.tools.javac.tree.JCTree.*;
  47 import com.sun.tools.javac.code.Type.*;
  48 
  49 import com.sun.tools.javac.jvm.Target;
  50 import com.sun.tools.javac.tree.EndPosTable;
  51 
  52 import static com.sun.tools.javac.code.Flags.*;
  53 import static com.sun.tools.javac.code.Flags.BLOCK;
</pre>
<hr />
<pre>
 861 
 862     /** A list of all class symbols used for access constructor tags.
 863      */
 864     private List&lt;ClassSymbol&gt; accessConstrTags;
 865 
 866     /** A queue for all accessed symbols.
 867      */
 868     private ListBuffer&lt;Symbol&gt; accessed;
 869 
 870     /** return access code for identifier,
 871      *  @param tree     The tree representing the identifier use.
 872      *  @param enclOp   The closest enclosing operation node of tree,
 873      *                  null if tree is not a subtree of an operation.
 874      */
 875     private static int accessCode(JCTree tree, JCTree enclOp) {
 876         if (enclOp == null)
 877             return AccessCode.DEREF.code;
 878         else if (enclOp.hasTag(ASSIGN) &amp;&amp;
 879                  tree == TreeInfo.skipParens(((JCAssign) enclOp).lhs))
 880             return AccessCode.ASSIGN.code;



 881         else if ((enclOp.getTag().isIncOrDecUnaryOp() || enclOp.getTag().isAssignop()) &amp;&amp;
 882                 tree == TreeInfo.skipParens(((JCOperatorExpression) enclOp).getOperand(LEFT)))
 883             return (((JCOperatorExpression) enclOp).operator).getAccessCode(enclOp.getTag());
 884         else
 885             return AccessCode.DEREF.code;
 886     }
 887 
 888     /** Return binary operator that corresponds to given access code.
 889      */
 890     private OperatorSymbol binaryAccessOperator(int acode, Tag tag) {
 891         return operators.lookupBinaryOp(op -&gt; op.getAccessCode(tag) == acode);
 892     }
 893 
 894     /** Return tree tag for assignment operation corresponding
 895      *  to given binary operator.
 896      */
 897     private static JCTree.Tag treeTag(OperatorSymbol operator) {
 898         switch (operator.opcode) {
 899         case ByteCodes.ior: case ByteCodes.lor:
 900             return BITOR_ASG;
</pre>
<hr />
<pre>
 971             anum = accessed.length();
 972             accessNums.put(vsym, anum);
 973             accessSyms.put(vsym, new MethodSymbol[AccessCode.numberOfAccessCodes]);
 974             accessed.append(vsym);
 975             // System.out.println(&quot;accessing &quot; + vsym + &quot; in &quot; + vsym.location());
 976         }
 977 
 978         int acode;                // The access code of the access method.
 979         List&lt;Type&gt; argtypes;      // The argument types of the access method.
 980         Type restype;             // The result type of the access method.
 981         List&lt;Type&gt; thrown;        // The thrown exceptions of the access method.
 982         switch (vsym.kind) {
 983         case VAR:
 984             acode = accessCode(tree, enclOp);
 985             if (acode &gt;= AccessCode.FIRSTASGOP.code) {
 986                 OperatorSymbol operator = binaryAccessOperator(acode, enclOp.getTag());
 987                 if (operator.opcode == string_add)
 988                     argtypes = List.of(syms.objectType);
 989                 else
 990                     argtypes = operator.type.getParameterTypes().tail;
<span class="line-modified"> 991             } else if (acode == AccessCode.ASSIGN.code)</span>
 992                 argtypes = List.of(vsym.erasure(types));
 993             else
 994                 argtypes = List.nil();
<span class="line-modified"> 995             restype = vsym.erasure(types);</span>
 996             thrown = List.nil();
 997             break;
 998         case MTH:
 999             acode = AccessCode.DEREF.code;
1000             argtypes = vsym.erasure(types).getParameterTypes();
1001             restype = vsym.erasure(types).getReturnType();
1002             thrown = vsym.type.getThrownTypes();
1003             break;
1004         default:
1005             throw new AssertionError();
1006         }
1007 
1008         // For references via qualified super, increment acode by one,
1009         // making it odd.
1010         if (protAccess &amp;&amp; refSuper) acode++;
1011 
1012         // Instance access methods get instance as first parameter.
1013         // For protected symbols this needs to be the instance as a member
1014         // of the type containing the accessed symbol, not the class
1015         // containing the access method.
</pre>
<hr />
<pre>
1344             ref = make.Select(site, sym);
1345             args = make.Idents(md.params.tail);
1346         }
1347         JCStatement stat;          // The statement accessing the private symbol.
1348         if (sym.kind == VAR) {
1349             // Normalize out all odd access codes by taking floor modulo 2:
1350             int acode1 = acode - (acode &amp; 1);
1351 
1352             JCExpression expr;      // The access method&#39;s return value.
1353             AccessCode aCode = AccessCode.getFromCode(acode1);
1354             switch (aCode) {
1355             case DEREF:
1356                 expr = ref;
1357                 break;
1358             case ASSIGN:
1359                 expr = make.Assign(ref, args.head);
1360                 break;
1361             case PREINC: case POSTINC: case PREDEC: case POSTDEC:
1362                 expr = makeUnary(aCode.tag, ref);
1363                 break;



1364             default:
1365                 expr = make.Assignop(
1366                     treeTag(binaryAccessOperator(acode1, JCTree.Tag.NO_TAG)), ref, args.head);
1367                 ((JCAssignOp) expr).operator = binaryAccessOperator(acode1, JCTree.Tag.NO_TAG);
1368             }
<span class="line-modified">1369             stat = make.Return(expr.setType(sym.type));</span>
1370         } else {
1371             stat = make.Call(make.App(ref, args));
1372         }
1373         md.body = make.Block(0, List.of(stat));
1374 
1375         // Make sure all parameters, result types and thrown exceptions
1376         // are accessible.
1377         for (List&lt;JCVariableDecl&gt; l = md.params; l.nonEmpty(); l = l.tail)
1378             l.head.vartype = access(l.head.vartype);
1379         md.restype = access(md.restype);
1380         for (List&lt;JCExpression&gt; l = md.thrown; l.nonEmpty(); l = l.tail)
1381             l.head = access(l.head);
1382 
1383         return md;
1384     }
1385 
1386     /** Construct definition of an access constructor.
1387      *  @param pos        The source code position of the definition.
1388      *  @param constr     The private constructor.
1389      *  @param accessor   The access method for the constructor.
</pre>
<hr />
<pre>
1443      *  @param pos        The source code position of the definition.
1444      *  @param freevars   The free variables.
1445      *  @param owner      The class in which the definitions go.
1446      */
1447     List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner) {
1448         return freevarDefs(pos, freevars, owner, 0);
1449     }
1450 
1451     List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner,
1452             long additionalFlags) {
1453         long flags = FINAL | SYNTHETIC | additionalFlags;
1454         List&lt;JCVariableDecl&gt; defs = List.nil();
1455         Set&lt;Name&gt; proxyNames = new HashSet&lt;&gt;();
1456         for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail) {
1457             VarSymbol v = l.head;
1458             int index = 0;
1459             Name proxyName;
1460             do {
1461                 proxyName = proxyName(v.name, index++);
1462             } while (!proxyNames.add(proxyName));

1463             VarSymbol proxy = new VarSymbol(
<span class="line-modified">1464                 flags, proxyName, v.erasure(types), owner);</span>
1465             proxies.put(v, proxy);
1466             JCVariableDecl vd = make.at(pos).VarDef(proxy, null);
1467             vd.vartype = access(vd.vartype);
1468             defs = defs.prepend(vd);
1469         }
1470         return defs;
1471     }
1472 
1473     /** The name of a this$n field
1474      *  @param type   The class referenced by the this$n field
1475      */
1476     Name outerThisName(Type type, Symbol owner) {
1477         Type t = type.getEnclosingType();
1478         int nestingLevel = 0;
1479         while (t.hasTag(CLASS)) {
1480             t = t.getEnclosingType();
1481             nestingLevel++;
1482         }
1483         Name result = names.fromString(&quot;this&quot; + target.syntheticNameChar() + nestingLevel);
1484         while (owner.kind == TYP &amp;&amp; ((ClassSymbol)owner).members().findFirst(result) != null)
</pre>
<hr />
<pre>
1507     JCVariableDecl outerThisDef(int pos, MethodSymbol owner) {
1508         ClassSymbol c = owner.enclClass();
1509         boolean isMandated =
1510             // Anonymous constructors
1511             (owner.isConstructor() &amp;&amp; owner.isAnonymous()) ||
1512             // Constructors of non-private inner member classes
1513             (owner.isConstructor() &amp;&amp; c.isInner() &amp;&amp;
1514              !c.isPrivate() &amp;&amp; !c.isStatic());
1515         long flags =
1516             FINAL | (isMandated ? MANDATED : SYNTHETIC) | PARAMETER;
1517         VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);
1518         owner.extraParams = owner.extraParams.prepend(outerThis);
1519         return makeOuterThisVarDecl(pos, outerThis);
1520     }
1521 
1522     /** Definition for this$n field.
1523      *  @param pos        The source code position of the definition.
1524      *  @param owner      The class in which the definition goes.
1525      */
1526     JCVariableDecl outerThisDef(int pos, ClassSymbol owner) {
<span class="line-modified">1527         VarSymbol outerThis = makeOuterThisVarSymbol(owner, FINAL | SYNTHETIC);</span>


1528         return makeOuterThisVarDecl(pos, outerThis);
1529     }
1530 
1531     /** Return a list of trees that load the free variables in given list,
1532      *  in reverse order.
1533      *  @param pos          The source code position to be used for the trees.
1534      *  @param freevars     The list of free variables.
1535      */
1536     List&lt;JCExpression&gt; loadFreevars(DiagnosticPosition pos, List&lt;VarSymbol&gt; freevars) {
1537         List&lt;JCExpression&gt; args = List.nil();
1538         for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail)
1539             args = args.prepend(loadFreevar(pos, l.head));
1540         return args;
1541     }
1542 //where
1543         JCExpression loadFreevar(DiagnosticPosition pos, VarSymbol v) {
1544             return access(v, make.at(pos).Ident(v), null, false);
1545         }
1546 
1547     /** Construct a tree simulating the expression {@code C.this}.
</pre>
<hr />
<pre>
3550                 new MethodSymbol(tree.flags | BLOCK,
3551                                  names.empty, null,
3552                                  currentClass);
3553         }
3554         super.visitBlock(tree);
3555         currentMethodSym = oldMethodSym;
3556     }
3557 
3558     public void visitDoLoop(JCDoWhileLoop tree) {
3559         tree.body = translate(tree.body);
3560         tree.cond = translate(tree.cond, syms.booleanType);
3561         result = tree;
3562     }
3563 
3564     public void visitWhileLoop(JCWhileLoop tree) {
3565         tree.cond = translate(tree.cond, syms.booleanType);
3566         tree.body = translate(tree.body);
3567         result = tree;
3568     }
3569 

















3570     public void visitForLoop(JCForLoop tree) {
3571         tree.init = translate(tree.init);
3572         if (tree.cond != null)
3573             tree.cond = translate(tree.cond, syms.booleanType);
3574         tree.step = translate(tree.step);
3575         tree.body = translate(tree.body);
3576         result = tree;
3577     }
3578 
3579     public void visitReturn(JCReturn tree) {
3580         if (tree.expr != null)
3581             tree.expr = translate(tree.expr,
3582                                   types.erasure(currentMethodDef
3583                                                 .restype.type));
3584         result = tree;
3585     }
3586 
3587     public void visitSwitch(JCSwitch tree) {
3588         handleSwitch(tree, tree.selector, tree.cases);
3589     }
</pre>
</td>
<td>
<hr />
<pre>
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.stream.Collectors;
  30 
  31 import com.sun.tools.javac.code.*;
  32 import com.sun.tools.javac.code.Kinds.KindSelector;
  33 import com.sun.tools.javac.code.Scope.WriteableScope;
<span class="line-added">  34 import com.sun.tools.javac.code.Source.Feature;</span>
  35 import com.sun.tools.javac.jvm.*;
  36 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  37 import com.sun.tools.javac.main.Option.PkgInfo;
  38 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  39 import com.sun.tools.javac.tree.*;
  40 import com.sun.tools.javac.util.*;
  41 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  42 import com.sun.tools.javac.util.List;
  43 
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;
  46 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  47 import com.sun.tools.javac.tree.JCTree.*;
  48 import com.sun.tools.javac.code.Type.*;
  49 
  50 import com.sun.tools.javac.jvm.Target;
  51 import com.sun.tools.javac.tree.EndPosTable;
  52 
  53 import static com.sun.tools.javac.code.Flags.*;
  54 import static com.sun.tools.javac.code.Flags.BLOCK;
</pre>
<hr />
<pre>
 862 
 863     /** A list of all class symbols used for access constructor tags.
 864      */
 865     private List&lt;ClassSymbol&gt; accessConstrTags;
 866 
 867     /** A queue for all accessed symbols.
 868      */
 869     private ListBuffer&lt;Symbol&gt; accessed;
 870 
 871     /** return access code for identifier,
 872      *  @param tree     The tree representing the identifier use.
 873      *  @param enclOp   The closest enclosing operation node of tree,
 874      *                  null if tree is not a subtree of an operation.
 875      */
 876     private static int accessCode(JCTree tree, JCTree enclOp) {
 877         if (enclOp == null)
 878             return AccessCode.DEREF.code;
 879         else if (enclOp.hasTag(ASSIGN) &amp;&amp;
 880                  tree == TreeInfo.skipParens(((JCAssign) enclOp).lhs))
 881             return AccessCode.ASSIGN.code;
<span class="line-added"> 882         else if (enclOp.hasTag(WITHFIELD) &amp;&amp;</span>
<span class="line-added"> 883                 tree == TreeInfo.skipParens(((JCWithField) enclOp).field))</span>
<span class="line-added"> 884             return AccessCode.WITHFIELD.code;</span>
 885         else if ((enclOp.getTag().isIncOrDecUnaryOp() || enclOp.getTag().isAssignop()) &amp;&amp;
 886                 tree == TreeInfo.skipParens(((JCOperatorExpression) enclOp).getOperand(LEFT)))
 887             return (((JCOperatorExpression) enclOp).operator).getAccessCode(enclOp.getTag());
 888         else
 889             return AccessCode.DEREF.code;
 890     }
 891 
 892     /** Return binary operator that corresponds to given access code.
 893      */
 894     private OperatorSymbol binaryAccessOperator(int acode, Tag tag) {
 895         return operators.lookupBinaryOp(op -&gt; op.getAccessCode(tag) == acode);
 896     }
 897 
 898     /** Return tree tag for assignment operation corresponding
 899      *  to given binary operator.
 900      */
 901     private static JCTree.Tag treeTag(OperatorSymbol operator) {
 902         switch (operator.opcode) {
 903         case ByteCodes.ior: case ByteCodes.lor:
 904             return BITOR_ASG;
</pre>
<hr />
<pre>
 975             anum = accessed.length();
 976             accessNums.put(vsym, anum);
 977             accessSyms.put(vsym, new MethodSymbol[AccessCode.numberOfAccessCodes]);
 978             accessed.append(vsym);
 979             // System.out.println(&quot;accessing &quot; + vsym + &quot; in &quot; + vsym.location());
 980         }
 981 
 982         int acode;                // The access code of the access method.
 983         List&lt;Type&gt; argtypes;      // The argument types of the access method.
 984         Type restype;             // The result type of the access method.
 985         List&lt;Type&gt; thrown;        // The thrown exceptions of the access method.
 986         switch (vsym.kind) {
 987         case VAR:
 988             acode = accessCode(tree, enclOp);
 989             if (acode &gt;= AccessCode.FIRSTASGOP.code) {
 990                 OperatorSymbol operator = binaryAccessOperator(acode, enclOp.getTag());
 991                 if (operator.opcode == string_add)
 992                     argtypes = List.of(syms.objectType);
 993                 else
 994                     argtypes = operator.type.getParameterTypes().tail;
<span class="line-modified"> 995             } else if (acode == AccessCode.ASSIGN.code || acode == AccessCode.WITHFIELD.code)</span>
 996                 argtypes = List.of(vsym.erasure(types));
 997             else
 998                 argtypes = List.nil();
<span class="line-modified"> 999             restype = acode == AccessCode.WITHFIELD.code ? vsym.owner.erasure(types) : vsym.erasure(types);</span>
1000             thrown = List.nil();
1001             break;
1002         case MTH:
1003             acode = AccessCode.DEREF.code;
1004             argtypes = vsym.erasure(types).getParameterTypes();
1005             restype = vsym.erasure(types).getReturnType();
1006             thrown = vsym.type.getThrownTypes();
1007             break;
1008         default:
1009             throw new AssertionError();
1010         }
1011 
1012         // For references via qualified super, increment acode by one,
1013         // making it odd.
1014         if (protAccess &amp;&amp; refSuper) acode++;
1015 
1016         // Instance access methods get instance as first parameter.
1017         // For protected symbols this needs to be the instance as a member
1018         // of the type containing the accessed symbol, not the class
1019         // containing the access method.
</pre>
<hr />
<pre>
1348             ref = make.Select(site, sym);
1349             args = make.Idents(md.params.tail);
1350         }
1351         JCStatement stat;          // The statement accessing the private symbol.
1352         if (sym.kind == VAR) {
1353             // Normalize out all odd access codes by taking floor modulo 2:
1354             int acode1 = acode - (acode &amp; 1);
1355 
1356             JCExpression expr;      // The access method&#39;s return value.
1357             AccessCode aCode = AccessCode.getFromCode(acode1);
1358             switch (aCode) {
1359             case DEREF:
1360                 expr = ref;
1361                 break;
1362             case ASSIGN:
1363                 expr = make.Assign(ref, args.head);
1364                 break;
1365             case PREINC: case POSTINC: case PREDEC: case POSTDEC:
1366                 expr = makeUnary(aCode.tag, ref);
1367                 break;
<span class="line-added">1368             case WITHFIELD:</span>
<span class="line-added">1369                 expr = make.WithField(ref, args.head);</span>
<span class="line-added">1370                 break;</span>
1371             default:
1372                 expr = make.Assignop(
1373                     treeTag(binaryAccessOperator(acode1, JCTree.Tag.NO_TAG)), ref, args.head);
1374                 ((JCAssignOp) expr).operator = binaryAccessOperator(acode1, JCTree.Tag.NO_TAG);
1375             }
<span class="line-modified">1376             stat = make.Return(expr.setType(aCode == AccessCode.WITHFIELD ? sym.owner.type : sym.type));</span>
1377         } else {
1378             stat = make.Call(make.App(ref, args));
1379         }
1380         md.body = make.Block(0, List.of(stat));
1381 
1382         // Make sure all parameters, result types and thrown exceptions
1383         // are accessible.
1384         for (List&lt;JCVariableDecl&gt; l = md.params; l.nonEmpty(); l = l.tail)
1385             l.head.vartype = access(l.head.vartype);
1386         md.restype = access(md.restype);
1387         for (List&lt;JCExpression&gt; l = md.thrown; l.nonEmpty(); l = l.tail)
1388             l.head = access(l.head);
1389 
1390         return md;
1391     }
1392 
1393     /** Construct definition of an access constructor.
1394      *  @param pos        The source code position of the definition.
1395      *  @param constr     The private constructor.
1396      *  @param accessor   The access method for the constructor.
</pre>
<hr />
<pre>
1450      *  @param pos        The source code position of the definition.
1451      *  @param freevars   The free variables.
1452      *  @param owner      The class in which the definitions go.
1453      */
1454     List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner) {
1455         return freevarDefs(pos, freevars, owner, 0);
1456     }
1457 
1458     List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner,
1459             long additionalFlags) {
1460         long flags = FINAL | SYNTHETIC | additionalFlags;
1461         List&lt;JCVariableDecl&gt; defs = List.nil();
1462         Set&lt;Name&gt; proxyNames = new HashSet&lt;&gt;();
1463         for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail) {
1464             VarSymbol v = l.head;
1465             int index = 0;
1466             Name proxyName;
1467             do {
1468                 proxyName = proxyName(v.name, index++);
1469             } while (!proxyNames.add(proxyName));
<span class="line-added">1470             final Type type = v.erasure(types);</span>
1471             VarSymbol proxy = new VarSymbol(
<span class="line-modified">1472                 flags, proxyName, type, owner);</span>
1473             proxies.put(v, proxy);
1474             JCVariableDecl vd = make.at(pos).VarDef(proxy, null);
1475             vd.vartype = access(vd.vartype);
1476             defs = defs.prepend(vd);
1477         }
1478         return defs;
1479     }
1480 
1481     /** The name of a this$n field
1482      *  @param type   The class referenced by the this$n field
1483      */
1484     Name outerThisName(Type type, Symbol owner) {
1485         Type t = type.getEnclosingType();
1486         int nestingLevel = 0;
1487         while (t.hasTag(CLASS)) {
1488             t = t.getEnclosingType();
1489             nestingLevel++;
1490         }
1491         Name result = names.fromString(&quot;this&quot; + target.syntheticNameChar() + nestingLevel);
1492         while (owner.kind == TYP &amp;&amp; ((ClassSymbol)owner).members().findFirst(result) != null)
</pre>
<hr />
<pre>
1515     JCVariableDecl outerThisDef(int pos, MethodSymbol owner) {
1516         ClassSymbol c = owner.enclClass();
1517         boolean isMandated =
1518             // Anonymous constructors
1519             (owner.isConstructor() &amp;&amp; owner.isAnonymous()) ||
1520             // Constructors of non-private inner member classes
1521             (owner.isConstructor() &amp;&amp; c.isInner() &amp;&amp;
1522              !c.isPrivate() &amp;&amp; !c.isStatic());
1523         long flags =
1524             FINAL | (isMandated ? MANDATED : SYNTHETIC) | PARAMETER;
1525         VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);
1526         owner.extraParams = owner.extraParams.prepend(outerThis);
1527         return makeOuterThisVarDecl(pos, outerThis);
1528     }
1529 
1530     /** Definition for this$n field.
1531      *  @param pos        The source code position of the definition.
1532      *  @param owner      The class in which the definition goes.
1533      */
1534     JCVariableDecl outerThisDef(int pos, ClassSymbol owner) {
<span class="line-modified">1535         Type target = types.erasure(owner.enclClass().type.getEnclosingType());</span>
<span class="line-added">1536         long flags = FINAL | SYNTHETIC;</span>
<span class="line-added">1537         VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);</span>
1538         return makeOuterThisVarDecl(pos, outerThis);
1539     }
1540 
1541     /** Return a list of trees that load the free variables in given list,
1542      *  in reverse order.
1543      *  @param pos          The source code position to be used for the trees.
1544      *  @param freevars     The list of free variables.
1545      */
1546     List&lt;JCExpression&gt; loadFreevars(DiagnosticPosition pos, List&lt;VarSymbol&gt; freevars) {
1547         List&lt;JCExpression&gt; args = List.nil();
1548         for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail)
1549             args = args.prepend(loadFreevar(pos, l.head));
1550         return args;
1551     }
1552 //where
1553         JCExpression loadFreevar(DiagnosticPosition pos, VarSymbol v) {
1554             return access(v, make.at(pos).Ident(v), null, false);
1555         }
1556 
1557     /** Construct a tree simulating the expression {@code C.this}.
</pre>
<hr />
<pre>
3560                 new MethodSymbol(tree.flags | BLOCK,
3561                                  names.empty, null,
3562                                  currentClass);
3563         }
3564         super.visitBlock(tree);
3565         currentMethodSym = oldMethodSym;
3566     }
3567 
3568     public void visitDoLoop(JCDoWhileLoop tree) {
3569         tree.body = translate(tree.body);
3570         tree.cond = translate(tree.cond, syms.booleanType);
3571         result = tree;
3572     }
3573 
3574     public void visitWhileLoop(JCWhileLoop tree) {
3575         tree.cond = translate(tree.cond, syms.booleanType);
3576         tree.body = translate(tree.body);
3577         result = tree;
3578     }
3579 
<span class="line-added">3580     public void visitWithField(JCWithField tree) {</span>
<span class="line-added">3581         Type fieldType = tree.field.type;</span>
<span class="line-added">3582         tree.field = translate(tree.field, tree);</span>
<span class="line-added">3583         tree.value = translate(tree.value, fieldType); // important to use pre-translation type.</span>
<span class="line-added">3584 </span>
<span class="line-added">3585         // If translated field is an Apply, we are</span>
<span class="line-added">3586         // seeing an access method invocation. In this case, append</span>
<span class="line-added">3587         // right hand side as last argument of the access method.</span>
<span class="line-added">3588         if (tree.field.hasTag(APPLY)) {</span>
<span class="line-added">3589             JCMethodInvocation app = (JCMethodInvocation) tree.field;</span>
<span class="line-added">3590             app.args = List.of(tree.value).prependList(app.args);</span>
<span class="line-added">3591             result = app;</span>
<span class="line-added">3592         } else {</span>
<span class="line-added">3593             result = tree;</span>
<span class="line-added">3594         }</span>
<span class="line-added">3595     }</span>
<span class="line-added">3596 </span>
3597     public void visitForLoop(JCForLoop tree) {
3598         tree.init = translate(tree.init);
3599         if (tree.cond != null)
3600             tree.cond = translate(tree.cond, syms.booleanType);
3601         tree.step = translate(tree.step);
3602         tree.body = translate(tree.body);
3603         result = tree;
3604     }
3605 
3606     public void visitReturn(JCReturn tree) {
3607         if (tree.expr != null)
3608             tree.expr = translate(tree.expr,
3609                                   types.erasure(currentMethodDef
3610                                                 .restype.type));
3611         result = tree;
3612     }
3613 
3614     public void visitSwitch(JCSwitch tree) {
3615         handleSwitch(tree, tree.selector, tree.cases);
3616     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../java.base/share/classes/java/lang/reflect/Modifier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../test/hotspot/jtreg/ProblemList.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
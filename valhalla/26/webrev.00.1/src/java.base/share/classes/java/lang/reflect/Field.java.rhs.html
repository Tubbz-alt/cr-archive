<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/reflect/Field.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
  28 import jdk.internal.access.SharedSecrets;
  29 import jdk.internal.reflect.CallerSensitive;
  30 import jdk.internal.reflect.FieldAccessor;
  31 import jdk.internal.reflect.Reflection;
  32 import jdk.internal.vm.annotation.ForceInline;
  33 import sun.reflect.generics.repository.FieldRepository;
  34 import sun.reflect.generics.factory.CoreReflectionFactory;
  35 import sun.reflect.generics.factory.GenericsFactory;
  36 import sun.reflect.generics.scope.ClassScope;
  37 import java.lang.annotation.Annotation;
  38 import java.util.Map;
  39 import java.util.Objects;
  40 import sun.reflect.annotation.AnnotationParser;
  41 import sun.reflect.annotation.AnnotationSupport;
  42 import sun.reflect.annotation.TypeAnnotation;
  43 import sun.reflect.annotation.TypeAnnotationParser;
  44 
  45 /**
  46  * A {@code Field} provides information about, and dynamic access to, a
  47  * single field of a class or an interface.  The reflected field may
  48  * be a class (static) field or an instance field.
  49  *
  50  * &lt;p&gt;A {@code Field} permits widening conversions to occur during a get or
  51  * set access operation, but throws an {@code IllegalArgumentException} if a
  52  * narrowing conversion would occur.
  53  *
  54  * @see Member
  55  * @see java.lang.Class
  56  * @see java.lang.Class#getFields()
  57  * @see java.lang.Class#getField(String)
  58  * @see java.lang.Class#getDeclaredFields()
  59  * @see java.lang.Class#getDeclaredField(String)
  60  *
  61  * @author Kenneth Russell
  62  * @author Nakul Saraiya
  63  * @since 1.1
  64  */
  65 public final
  66 class Field extends AccessibleObject implements Member {
  67 
  68     private Class&lt;?&gt;            clazz;
  69     private int                 slot;
  70     // This is guaranteed to be interned by the VM in the 1.4
  71     // reflection implementation
  72     private String              name;
  73     private Class&lt;?&gt;            type;
  74     private int                 modifiers;
  75     // Generics and annotations support
  76     private transient String    signature;
  77     // generic info repository; lazily initialized
  78     private transient FieldRepository genericInfo;
  79     private byte[]              annotations;
  80     // Cached field accessor created without override
  81     private FieldAccessor fieldAccessor;
  82     // Cached field accessor created with override
  83     private FieldAccessor overrideFieldAccessor;
  84     // For sharing of FieldAccessors. This branching structure is
  85     // currently only two levels deep (i.e., one root Field and
  86     // potentially many Field objects pointing to it.)
  87     //
  88     // If this branching structure would ever contain cycles, deadlocks can
  89     // occur in annotation code.
  90     private Field               root;
  91 
  92     // Generics infrastructure
  93 
  94     private String getGenericSignature() {return signature;}
  95 
  96     // Accessor for factory
  97     private GenericsFactory getFactory() {
  98         Class&lt;?&gt; c = getDeclaringClass();
  99         // create scope and factory
 100         return CoreReflectionFactory.make(c, ClassScope.make(c));
 101     }
 102 
 103     // Accessor for generic info repository
 104     private FieldRepository getGenericInfo() {
 105         // lazily initialize repository if necessary
 106         if (genericInfo == null) {
 107             // create and cache generic info repository
 108             genericInfo = FieldRepository.make(getGenericSignature(),
 109                                                getFactory());
 110         }
 111         return genericInfo; //return cached repository
 112     }
 113 
 114 
 115     /**
 116      * Package-private constructor
 117      */
 118     Field(Class&lt;?&gt; declaringClass,
 119           String name,
 120           Class&lt;?&gt; type,
 121           int modifiers,
 122           int slot,
 123           String signature,
 124           byte[] annotations)
 125     {
 126         this.clazz = declaringClass;
 127         this.name = name;
 128         this.type = type;
 129         this.modifiers = modifiers;
 130         this.slot = slot;
 131         this.signature = signature;
 132         this.annotations = annotations;
 133     }
 134 
 135     /**
 136      * Package-private routine (exposed to java.lang.Class via
 137      * ReflectAccess) which returns a copy of this Field. The copy&#39;s
 138      * &quot;root&quot; field points to this Field.
 139      */
 140     Field copy() {
 141         // This routine enables sharing of FieldAccessor objects
 142         // among Field objects which refer to the same underlying
 143         // method in the VM. (All of this contortion is only necessary
 144         // because of the &quot;accessibility&quot; bit in AccessibleObject,
 145         // which implicitly requires that new java.lang.reflect
 146         // objects be fabricated for each reflective call on Class
 147         // objects.)
 148         if (this.root != null)
 149             throw new IllegalArgumentException(&quot;Can not copy a non-root Field&quot;);
 150 
 151         Field res = new Field(clazz, name, type, modifiers, slot, signature, annotations);
 152         res.root = this;
 153         // Might as well eagerly propagate this if already present
 154         res.fieldAccessor = fieldAccessor;
 155         res.overrideFieldAccessor = overrideFieldAccessor;
 156 
 157         return res;
 158     }
 159 
 160     /**
 161      * @throws InaccessibleObjectException {@inheritDoc}
 162      * @throws SecurityException {@inheritDoc}
 163      */
 164     @Override
 165     @CallerSensitive
 166     public void setAccessible(boolean flag) {
 167         AccessibleObject.checkPermission();
<a name="1" id="anc1"></a><span class="line-modified"> 168 </span>
<span class="line-added"> 169         if (clazz.isInlineClass()) {</span>
<span class="line-added"> 170             throw new InaccessibleObjectException(&quot;cannot make a field accessible of inline class &quot;</span>
<span class="line-added"> 171                     + clazz.getName());</span>
<span class="line-added"> 172         }</span>
<span class="line-added"> 173         if (flag) {</span>
<span class="line-added"> 174             checkCanSetAccessible(Reflection.getCallerClass());</span>
<span class="line-added"> 175         }</span>
 176         setAccessible0(flag);
 177     }
 178 
 179     @Override
 180     void checkCanSetAccessible(Class&lt;?&gt; caller) {
 181         checkCanSetAccessible(caller, clazz);
 182     }
 183 
 184     /**
 185      * Returns the {@code Class} object representing the class or interface
 186      * that declares the field represented by this {@code Field} object.
 187      */
 188     @Override
 189     public Class&lt;?&gt; getDeclaringClass() {
 190         return clazz;
 191     }
 192 
 193     /**
 194      * Returns the name of the field represented by this {@code Field} object.
 195      */
 196     public String getName() {
 197         return name;
 198     }
 199 
 200     /**
 201      * Returns the Java language modifiers for the field represented
 202      * by this {@code Field} object, as an integer. The {@code Modifier} class should
 203      * be used to decode the modifiers.
 204      *
 205      * @see Modifier
 206      */
 207     public int getModifiers() {
 208         return modifiers;
 209     }
 210 
 211     /**
 212      * Returns {@code true} if this field represents an element of
 213      * an enumerated type; returns {@code false} otherwise.
 214      *
 215      * @return {@code true} if and only if this field represents an element of
 216      * an enumerated type.
 217      * @since 1.5
 218      */
 219     public boolean isEnumConstant() {
 220         return (getModifiers() &amp; Modifier.ENUM) != 0;
 221     }
 222 
 223     /**
 224      * Returns {@code true} if this field is a synthetic
 225      * field; returns {@code false} otherwise.
 226      *
 227      * @return true if and only if this field is a synthetic
 228      * field as defined by the Java Language Specification.
 229      * @since 1.5
 230      */
 231     public boolean isSynthetic() {
 232         return Modifier.isSynthetic(getModifiers());
 233     }
 234 
 235     /**
 236      * Returns a {@code Class} object that identifies the
 237      * declared type for the field represented by this
 238      * {@code Field} object.
 239      *
 240      * @return a {@code Class} object identifying the declared
 241      * type of the field represented by this object
 242      */
 243     public Class&lt;?&gt; getType() {
 244         return type;
 245     }
 246 
 247     /**
 248      * Returns a {@code Type} object that represents the declared type for
 249      * the field represented by this {@code Field} object.
 250      *
 251      * &lt;p&gt;If the declared type of the field is a parameterized type,
 252      * the {@code Type} object returned must accurately reflect the
 253      * actual type arguments used in the source code.
 254      *
 255      * &lt;p&gt;If the type of the underlying field is a type variable or a
 256      * parameterized type, it is created. Otherwise, it is resolved.
 257      *
 258      * @return a {@code Type} object that represents the declared type for
 259      *     the field represented by this {@code Field} object
 260      * @throws GenericSignatureFormatError if the generic field
 261      *     signature does not conform to the format specified in
 262      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 263      * @throws TypeNotPresentException if the generic type
 264      *     signature of the underlying field refers to a non-existent
 265      *     type declaration
 266      * @throws MalformedParameterizedTypeException if the generic
 267      *     signature of the underlying field refers to a parameterized type
 268      *     that cannot be instantiated for any reason
 269      * @since 1.5
 270      */
 271     public Type getGenericType() {
 272         if (getGenericSignature() != null)
 273             return getGenericInfo().getGenericType();
 274         else
 275             return getType();
 276     }
 277 
 278 
 279     /**
 280      * Compares this {@code Field} against the specified object.  Returns
 281      * true if the objects are the same.  Two {@code Field} objects are the same if
 282      * they were declared by the same class and have the same name
 283      * and type.
 284      */
 285     public boolean equals(Object obj) {
 286         if (obj != null &amp;&amp; obj instanceof Field) {
 287             Field other = (Field)obj;
 288             return (getDeclaringClass() == other.getDeclaringClass())
 289                 &amp;&amp; (getName() == other.getName())
 290                 &amp;&amp; (getType() == other.getType());
 291         }
 292         return false;
 293     }
 294 
 295     /**
 296      * Returns a hashcode for this {@code Field}.  This is computed as the
 297      * exclusive-or of the hashcodes for the underlying field&#39;s
 298      * declaring class name and its name.
 299      */
 300     public int hashCode() {
 301         return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
 302     }
 303 
 304     /**
 305      * Returns a string describing this {@code Field}.  The format is
 306      * the access modifiers for the field, if any, followed
 307      * by the field type, followed by a space, followed by
 308      * the fully-qualified name of the class declaring the field,
 309      * followed by a period, followed by the name of the field.
 310      * For example:
 311      * &lt;pre&gt;
 312      *    public static final int java.lang.Thread.MIN_PRIORITY
 313      *    private int java.io.FileDescriptor.fd
 314      * &lt;/pre&gt;
 315      *
 316      * &lt;p&gt;The modifiers are placed in canonical order as specified by
 317      * &quot;The Java Language Specification&quot;.  This is {@code public},
 318      * {@code protected} or {@code private} first, and then other
 319      * modifiers in the following order: {@code static}, {@code final},
 320      * {@code transient}, {@code volatile}.
 321      *
 322      * @return a string describing this {@code Field}
 323      * @jls 8.3.1 Field Modifiers
 324      */
 325     public String toString() {
 326         int mod = getModifiers();
 327         return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))
 328             + getType().getTypeName() + &quot; &quot;
 329             + getDeclaringClass().getTypeName() + &quot;.&quot;
 330             + getName());
 331     }
 332 
 333     @Override
 334     String toShortString() {
 335         return &quot;field &quot; + getDeclaringClass().getTypeName() + &quot;.&quot; + getName();
 336     }
 337 
 338     /**
 339      * Returns a string describing this {@code Field}, including
 340      * its generic type.  The format is the access modifiers for the
 341      * field, if any, followed by the generic field type, followed by
 342      * a space, followed by the fully-qualified name of the class
 343      * declaring the field, followed by a period, followed by the name
 344      * of the field.
 345      *
 346      * &lt;p&gt;The modifiers are placed in canonical order as specified by
 347      * &quot;The Java Language Specification&quot;.  This is {@code public},
 348      * {@code protected} or {@code private} first, and then other
 349      * modifiers in the following order: {@code static}, {@code final},
 350      * {@code transient}, {@code volatile}.
 351      *
 352      * @return a string describing this {@code Field}, including
 353      * its generic type
 354      *
 355      * @since 1.5
 356      * @jls 8.3.1 Field Modifiers
 357      */
 358     public String toGenericString() {
 359         int mod = getModifiers();
 360         Type fieldType = getGenericType();
 361         return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))
 362             + fieldType.getTypeName() + &quot; &quot;
 363             + getDeclaringClass().getTypeName() + &quot;.&quot;
 364             + getName());
 365     }
 366 
 367     /**
 368      * Returns the value of the field represented by this {@code Field}, on
 369      * the specified object. The value is automatically wrapped in an
 370      * object if it has a primitive type.
 371      *
 372      * &lt;p&gt;The underlying field&#39;s value is obtained as follows:
 373      *
 374      * &lt;p&gt;If the underlying field is a static field, the {@code obj} argument
 375      * is ignored; it may be null.
 376      *
 377      * &lt;p&gt;Otherwise, the underlying field is an instance field.  If the
 378      * specified {@code obj} argument is null, the method throws a
 379      * {@code NullPointerException}. If the specified object is not an
 380      * instance of the class or interface declaring the underlying
 381      * field, the method throws an {@code IllegalArgumentException}.
 382      *
 383      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 384      * the underlying field is inaccessible, the method throws an
 385      * {@code IllegalAccessException}.
 386      * If the underlying field is static, the class that declared the
 387      * field is initialized if it has not already been initialized.
 388      *
 389      * &lt;p&gt;Otherwise, the value is retrieved from the underlying instance
 390      * or static field.  If the field has a primitive type, the value
 391      * is wrapped in an object before being returned, otherwise it is
 392      * returned as is.
 393      *
 394      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 395      * the field&#39;s value is obtained according to the preceding rules.
 396      *
 397      * @param obj object from which the represented field&#39;s value is
 398      * to be extracted
 399      * @return the value of the represented field in object
 400      * {@code obj}; primitive values are wrapped in an appropriate
 401      * object before being returned
 402      *
 403      * @throws    IllegalAccessException    if this {@code Field} object
 404      *              is enforcing Java language access control and the underlying
 405      *              field is inaccessible.
 406      * @throws    IllegalArgumentException  if the specified object is not an
 407      *              instance of the class or interface declaring the underlying
 408      *              field (or a subclass or implementor thereof).
 409      * @throws    NullPointerException      if the specified object is null
 410      *              and the field is an instance field.
 411      * @throws    ExceptionInInitializerError if the initialization provoked
 412      *              by this method fails.
 413      */
 414     @CallerSensitive
 415     @ForceInline // to ensure Reflection.getCallerClass optimization
 416     public Object get(Object obj)
 417         throws IllegalArgumentException, IllegalAccessException
 418     {
 419         if (!override) {
 420             Class&lt;?&gt; caller = Reflection.getCallerClass();
 421             checkAccess(caller, obj);
 422         }
 423         return getFieldAccessor(obj).get(obj);
 424     }
 425 
 426     /**
 427      * Gets the value of a static or instance {@code boolean} field.
 428      *
 429      * @param obj the object to extract the {@code boolean} value
 430      * from
 431      * @return the value of the {@code boolean} field
 432      *
 433      * @throws    IllegalAccessException    if this {@code Field} object
 434      *              is enforcing Java language access control and the underlying
 435      *              field is inaccessible.
 436      * @throws    IllegalArgumentException  if the specified object is not
 437      *              an instance of the class or interface declaring the
 438      *              underlying field (or a subclass or implementor
 439      *              thereof), or if the field value cannot be
 440      *              converted to the type {@code boolean} by a
 441      *              widening conversion.
 442      * @throws    NullPointerException      if the specified object is null
 443      *              and the field is an instance field.
 444      * @throws    ExceptionInInitializerError if the initialization provoked
 445      *              by this method fails.
 446      * @see       Field#get
 447      */
 448     @CallerSensitive
 449     @ForceInline // to ensure Reflection.getCallerClass optimization
 450     public boolean getBoolean(Object obj)
 451         throws IllegalArgumentException, IllegalAccessException
 452     {
 453         if (!override) {
 454             Class&lt;?&gt; caller = Reflection.getCallerClass();
 455             checkAccess(caller, obj);
 456         }
 457         return getFieldAccessor(obj).getBoolean(obj);
 458     }
 459 
 460     /**
 461      * Gets the value of a static or instance {@code byte} field.
 462      *
 463      * @param obj the object to extract the {@code byte} value
 464      * from
 465      * @return the value of the {@code byte} field
 466      *
 467      * @throws    IllegalAccessException    if this {@code Field} object
 468      *              is enforcing Java language access control and the underlying
 469      *              field is inaccessible.
 470      * @throws    IllegalArgumentException  if the specified object is not
 471      *              an instance of the class or interface declaring the
 472      *              underlying field (or a subclass or implementor
 473      *              thereof), or if the field value cannot be
 474      *              converted to the type {@code byte} by a
 475      *              widening conversion.
 476      * @throws    NullPointerException      if the specified object is null
 477      *              and the field is an instance field.
 478      * @throws    ExceptionInInitializerError if the initialization provoked
 479      *              by this method fails.
 480      * @see       Field#get
 481      */
 482     @CallerSensitive
 483     @ForceInline // to ensure Reflection.getCallerClass optimization
 484     public byte getByte(Object obj)
 485         throws IllegalArgumentException, IllegalAccessException
 486     {
 487         if (!override) {
 488             Class&lt;?&gt; caller = Reflection.getCallerClass();
 489             checkAccess(caller, obj);
 490         }
 491         return getFieldAccessor(obj).getByte(obj);
 492     }
 493 
 494     /**
 495      * Gets the value of a static or instance field of type
 496      * {@code char} or of another primitive type convertible to
 497      * type {@code char} via a widening conversion.
 498      *
 499      * @param obj the object to extract the {@code char} value
 500      * from
 501      * @return the value of the field converted to type {@code char}
 502      *
 503      * @throws    IllegalAccessException    if this {@code Field} object
 504      *              is enforcing Java language access control and the underlying
 505      *              field is inaccessible.
 506      * @throws    IllegalArgumentException  if the specified object is not
 507      *              an instance of the class or interface declaring the
 508      *              underlying field (or a subclass or implementor
 509      *              thereof), or if the field value cannot be
 510      *              converted to the type {@code char} by a
 511      *              widening conversion.
 512      * @throws    NullPointerException      if the specified object is null
 513      *              and the field is an instance field.
 514      * @throws    ExceptionInInitializerError if the initialization provoked
 515      *              by this method fails.
 516      * @see Field#get
 517      */
 518     @CallerSensitive
 519     @ForceInline // to ensure Reflection.getCallerClass optimization
 520     public char getChar(Object obj)
 521         throws IllegalArgumentException, IllegalAccessException
 522     {
 523         if (!override) {
 524             Class&lt;?&gt; caller = Reflection.getCallerClass();
 525             checkAccess(caller, obj);
 526         }
 527         return getFieldAccessor(obj).getChar(obj);
 528     }
 529 
 530     /**
 531      * Gets the value of a static or instance field of type
 532      * {@code short} or of another primitive type convertible to
 533      * type {@code short} via a widening conversion.
 534      *
 535      * @param obj the object to extract the {@code short} value
 536      * from
 537      * @return the value of the field converted to type {@code short}
 538      *
 539      * @throws    IllegalAccessException    if this {@code Field} object
 540      *              is enforcing Java language access control and the underlying
 541      *              field is inaccessible.
 542      * @throws    IllegalArgumentException  if the specified object is not
 543      *              an instance of the class or interface declaring the
 544      *              underlying field (or a subclass or implementor
 545      *              thereof), or if the field value cannot be
 546      *              converted to the type {@code short} by a
 547      *              widening conversion.
 548      * @throws    NullPointerException      if the specified object is null
 549      *              and the field is an instance field.
 550      * @throws    ExceptionInInitializerError if the initialization provoked
 551      *              by this method fails.
 552      * @see       Field#get
 553      */
 554     @CallerSensitive
 555     @ForceInline // to ensure Reflection.getCallerClass optimization
 556     public short getShort(Object obj)
 557         throws IllegalArgumentException, IllegalAccessException
 558     {
 559         if (!override) {
 560             Class&lt;?&gt; caller = Reflection.getCallerClass();
 561             checkAccess(caller, obj);
 562         }
 563         return getFieldAccessor(obj).getShort(obj);
 564     }
 565 
 566     /**
 567      * Gets the value of a static or instance field of type
 568      * {@code int} or of another primitive type convertible to
 569      * type {@code int} via a widening conversion.
 570      *
 571      * @param obj the object to extract the {@code int} value
 572      * from
 573      * @return the value of the field converted to type {@code int}
 574      *
 575      * @throws    IllegalAccessException    if this {@code Field} object
 576      *              is enforcing Java language access control and the underlying
 577      *              field is inaccessible.
 578      * @throws    IllegalArgumentException  if the specified object is not
 579      *              an instance of the class or interface declaring the
 580      *              underlying field (or a subclass or implementor
 581      *              thereof), or if the field value cannot be
 582      *              converted to the type {@code int} by a
 583      *              widening conversion.
 584      * @throws    NullPointerException      if the specified object is null
 585      *              and the field is an instance field.
 586      * @throws    ExceptionInInitializerError if the initialization provoked
 587      *              by this method fails.
 588      * @see       Field#get
 589      */
 590     @CallerSensitive
 591     @ForceInline // to ensure Reflection.getCallerClass optimization
 592     public int getInt(Object obj)
 593         throws IllegalArgumentException, IllegalAccessException
 594     {
 595         if (!override) {
 596             Class&lt;?&gt; caller = Reflection.getCallerClass();
 597             checkAccess(caller, obj);
 598         }
 599         return getFieldAccessor(obj).getInt(obj);
 600     }
 601 
 602     /**
 603      * Gets the value of a static or instance field of type
 604      * {@code long} or of another primitive type convertible to
 605      * type {@code long} via a widening conversion.
 606      *
 607      * @param obj the object to extract the {@code long} value
 608      * from
 609      * @return the value of the field converted to type {@code long}
 610      *
 611      * @throws    IllegalAccessException    if this {@code Field} object
 612      *              is enforcing Java language access control and the underlying
 613      *              field is inaccessible.
 614      * @throws    IllegalArgumentException  if the specified object is not
 615      *              an instance of the class or interface declaring the
 616      *              underlying field (or a subclass or implementor
 617      *              thereof), or if the field value cannot be
 618      *              converted to the type {@code long} by a
 619      *              widening conversion.
 620      * @throws    NullPointerException      if the specified object is null
 621      *              and the field is an instance field.
 622      * @throws    ExceptionInInitializerError if the initialization provoked
 623      *              by this method fails.
 624      * @see       Field#get
 625      */
 626     @CallerSensitive
 627     @ForceInline // to ensure Reflection.getCallerClass optimization
 628     public long getLong(Object obj)
 629         throws IllegalArgumentException, IllegalAccessException
 630     {
 631         if (!override) {
 632             Class&lt;?&gt; caller = Reflection.getCallerClass();
 633             checkAccess(caller, obj);
 634         }
 635         return getFieldAccessor(obj).getLong(obj);
 636     }
 637 
 638     /**
 639      * Gets the value of a static or instance field of type
 640      * {@code float} or of another primitive type convertible to
 641      * type {@code float} via a widening conversion.
 642      *
 643      * @param obj the object to extract the {@code float} value
 644      * from
 645      * @return the value of the field converted to type {@code float}
 646      *
 647      * @throws    IllegalAccessException    if this {@code Field} object
 648      *              is enforcing Java language access control and the underlying
 649      *              field is inaccessible.
 650      * @throws    IllegalArgumentException  if the specified object is not
 651      *              an instance of the class or interface declaring the
 652      *              underlying field (or a subclass or implementor
 653      *              thereof), or if the field value cannot be
 654      *              converted to the type {@code float} by a
 655      *              widening conversion.
 656      * @throws    NullPointerException      if the specified object is null
 657      *              and the field is an instance field.
 658      * @throws    ExceptionInInitializerError if the initialization provoked
 659      *              by this method fails.
 660      * @see Field#get
 661      */
 662     @CallerSensitive
 663     @ForceInline // to ensure Reflection.getCallerClass optimization
 664     public float getFloat(Object obj)
 665         throws IllegalArgumentException, IllegalAccessException
 666     {
 667         if (!override) {
 668             Class&lt;?&gt; caller = Reflection.getCallerClass();
 669             checkAccess(caller, obj);
 670         }
 671         return getFieldAccessor(obj).getFloat(obj);
 672     }
 673 
 674     /**
 675      * Gets the value of a static or instance field of type
 676      * {@code double} or of another primitive type convertible to
 677      * type {@code double} via a widening conversion.
 678      *
 679      * @param obj the object to extract the {@code double} value
 680      * from
 681      * @return the value of the field converted to type {@code double}
 682      *
 683      * @throws    IllegalAccessException    if this {@code Field} object
 684      *              is enforcing Java language access control and the underlying
 685      *              field is inaccessible.
 686      * @throws    IllegalArgumentException  if the specified object is not
 687      *              an instance of the class or interface declaring the
 688      *              underlying field (or a subclass or implementor
 689      *              thereof), or if the field value cannot be
 690      *              converted to the type {@code double} by a
 691      *              widening conversion.
 692      * @throws    NullPointerException      if the specified object is null
 693      *              and the field is an instance field.
 694      * @throws    ExceptionInInitializerError if the initialization provoked
 695      *              by this method fails.
 696      * @see       Field#get
 697      */
 698     @CallerSensitive
 699     @ForceInline // to ensure Reflection.getCallerClass optimization
 700     public double getDouble(Object obj)
 701         throws IllegalArgumentException, IllegalAccessException
 702     {
 703         if (!override) {
 704             Class&lt;?&gt; caller = Reflection.getCallerClass();
 705             checkAccess(caller, obj);
 706         }
 707         return getFieldAccessor(obj).getDouble(obj);
 708     }
 709 
 710     /**
 711      * Sets the field represented by this {@code Field} object on the
 712      * specified object argument to the specified new value. The new
 713      * value is automatically unwrapped if the underlying field has a
 714      * primitive type.
 715      *
 716      * &lt;p&gt;The operation proceeds as follows:
 717      *
 718      * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
 719      * ignored; it may be null.
 720      *
 721      * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
 722      * specified object argument is null, the method throws a
 723      * {@code NullPointerException}.  If the specified object argument is not
 724      * an instance of the class or interface declaring the underlying
 725      * field, the method throws an {@code IllegalArgumentException}.
 726      *
 727      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 728      * the underlying field is inaccessible, the method throws an
 729      * {@code IllegalAccessException}.
 730      *
 731      * &lt;p&gt;If the underlying field is final, the method throws an
 732      * {@code IllegalAccessException} unless {@code setAccessible(true)}
 733      * has succeeded for this {@code Field} object
 734      * and the field is non-static. Setting a final field in this way
 735      * is meaningful only during deserialization or reconstruction of
 736      * instances of classes with blank final fields, before they are
 737      * made available for access by other parts of a program. Use in
 738      * any other context may have unpredictable effects, including cases
 739      * in which other parts of a program continue to use the original
 740      * value of this field.
 741      *
 742      * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
 743      * conversion is attempted to convert the new value to a value of
 744      * a primitive type.  If this attempt fails, the method throws an
 745      * {@code IllegalArgumentException}.
 746      *
 747      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 748      * converted to the type of the underlying field by an identity or
 749      * widening conversion, the method throws an
 750      * {@code IllegalArgumentException}.
 751      *
 752      * &lt;p&gt;If the underlying field is static, the class that declared the
 753      * field is initialized if it has not already been initialized.
 754      *
 755      * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
 756      *
 757      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 758      * the field&#39;s value is set according to the preceding rules.
 759      *
 760      * @param obj the object whose field should be modified
 761      * @param value the new value for the field of {@code obj}
 762      * being modified
 763      *
 764      * @throws    IllegalAccessException    if this {@code Field} object
 765      *              is enforcing Java language access control and the underlying
 766      *              field is either inaccessible or final.
 767      * @throws    IllegalArgumentException  if the specified object is not an
 768      *              instance of the class or interface declaring the underlying
 769      *              field (or a subclass or implementor thereof),
 770      *              or if an unwrapping conversion fails.
 771      * @throws    NullPointerException      if the specified object is null
 772      *              and the field is an instance field.
 773      * @throws    ExceptionInInitializerError if the initialization provoked
 774      *              by this method fails.
 775      */
 776     @CallerSensitive
 777     @ForceInline // to ensure Reflection.getCallerClass optimization
 778     public void set(Object obj, Object value)
 779         throws IllegalArgumentException, IllegalAccessException
 780     {
<a name="2" id="anc2"></a><span class="line-added"> 781         ensureNotValueClass();</span>
<span class="line-added"> 782 </span>
 783         if (!override) {
 784             Class&lt;?&gt; caller = Reflection.getCallerClass();
 785             checkAccess(caller, obj);
 786         }
 787         getFieldAccessor(obj).set(obj, value);
 788     }
 789 
 790     /**
 791      * Sets the value of a field as a {@code boolean} on the specified object.
 792      * This method is equivalent to
 793      * {@code set(obj, zObj)},
 794      * where {@code zObj} is a {@code Boolean} object and
 795      * {@code zObj.booleanValue() == z}.
 796      *
 797      * @param obj the object whose field should be modified
 798      * @param z   the new value for the field of {@code obj}
 799      * being modified
 800      *
 801      * @throws    IllegalAccessException    if this {@code Field} object
 802      *              is enforcing Java language access control and the underlying
 803      *              field is either inaccessible or final.
 804      * @throws    IllegalArgumentException  if the specified object is not an
 805      *              instance of the class or interface declaring the underlying
 806      *              field (or a subclass or implementor thereof),
 807      *              or if an unwrapping conversion fails.
 808      * @throws    NullPointerException      if the specified object is null
 809      *              and the field is an instance field.
 810      * @throws    ExceptionInInitializerError if the initialization provoked
 811      *              by this method fails.
 812      * @see       Field#set
 813      */
 814     @CallerSensitive
 815     @ForceInline // to ensure Reflection.getCallerClass optimization
 816     public void setBoolean(Object obj, boolean z)
 817         throws IllegalArgumentException, IllegalAccessException
 818     {
<a name="3" id="anc3"></a><span class="line-added"> 819         ensureNotValueClass();</span>
<span class="line-added"> 820 </span>
 821         if (!override) {
 822             Class&lt;?&gt; caller = Reflection.getCallerClass();
 823             checkAccess(caller, obj);
 824         }
 825         getFieldAccessor(obj).setBoolean(obj, z);
 826     }
 827 
 828     /**
 829      * Sets the value of a field as a {@code byte} on the specified object.
 830      * This method is equivalent to
 831      * {@code set(obj, bObj)},
 832      * where {@code bObj} is a {@code Byte} object and
 833      * {@code bObj.byteValue() == b}.
 834      *
 835      * @param obj the object whose field should be modified
 836      * @param b   the new value for the field of {@code obj}
 837      * being modified
 838      *
 839      * @throws    IllegalAccessException    if this {@code Field} object
 840      *              is enforcing Java language access control and the underlying
 841      *              field is either inaccessible or final.
 842      * @throws    IllegalArgumentException  if the specified object is not an
 843      *              instance of the class or interface declaring the underlying
 844      *              field (or a subclass or implementor thereof),
 845      *              or if an unwrapping conversion fails.
 846      * @throws    NullPointerException      if the specified object is null
 847      *              and the field is an instance field.
 848      * @throws    ExceptionInInitializerError if the initialization provoked
 849      *              by this method fails.
 850      * @see       Field#set
 851      */
 852     @CallerSensitive
 853     @ForceInline // to ensure Reflection.getCallerClass optimization
 854     public void setByte(Object obj, byte b)
 855         throws IllegalArgumentException, IllegalAccessException
 856     {
<a name="4" id="anc4"></a><span class="line-added"> 857         ensureNotValueClass();</span>
<span class="line-added"> 858 </span>
 859         if (!override) {
 860             Class&lt;?&gt; caller = Reflection.getCallerClass();
 861             checkAccess(caller, obj);
 862         }
 863         getFieldAccessor(obj).setByte(obj, b);
 864     }
 865 
 866     /**
 867      * Sets the value of a field as a {@code char} on the specified object.
 868      * This method is equivalent to
 869      * {@code set(obj, cObj)},
 870      * where {@code cObj} is a {@code Character} object and
 871      * {@code cObj.charValue() == c}.
 872      *
 873      * @param obj the object whose field should be modified
 874      * @param c   the new value for the field of {@code obj}
 875      * being modified
 876      *
 877      * @throws    IllegalAccessException    if this {@code Field} object
 878      *              is enforcing Java language access control and the underlying
 879      *              field is either inaccessible or final.
 880      * @throws    IllegalArgumentException  if the specified object is not an
 881      *              instance of the class or interface declaring the underlying
 882      *              field (or a subclass or implementor thereof),
 883      *              or if an unwrapping conversion fails.
 884      * @throws    NullPointerException      if the specified object is null
 885      *              and the field is an instance field.
 886      * @throws    ExceptionInInitializerError if the initialization provoked
 887      *              by this method fails.
 888      * @see       Field#set
 889      */
 890     @CallerSensitive
 891     @ForceInline // to ensure Reflection.getCallerClass optimization
 892     public void setChar(Object obj, char c)
 893         throws IllegalArgumentException, IllegalAccessException
 894     {
<a name="5" id="anc5"></a><span class="line-added"> 895         ensureNotValueClass();</span>
<span class="line-added"> 896 </span>
 897         if (!override) {
 898             Class&lt;?&gt; caller = Reflection.getCallerClass();
 899             checkAccess(caller, obj);
 900         }
 901         getFieldAccessor(obj).setChar(obj, c);
 902     }
 903 
 904     /**
 905      * Sets the value of a field as a {@code short} on the specified object.
 906      * This method is equivalent to
 907      * {@code set(obj, sObj)},
 908      * where {@code sObj} is a {@code Short} object and
 909      * {@code sObj.shortValue() == s}.
 910      *
 911      * @param obj the object whose field should be modified
 912      * @param s   the new value for the field of {@code obj}
 913      * being modified
 914      *
 915      * @throws    IllegalAccessException    if this {@code Field} object
 916      *              is enforcing Java language access control and the underlying
 917      *              field is either inaccessible or final.
 918      * @throws    IllegalArgumentException  if the specified object is not an
 919      *              instance of the class or interface declaring the underlying
 920      *              field (or a subclass or implementor thereof),
 921      *              or if an unwrapping conversion fails.
 922      * @throws    NullPointerException      if the specified object is null
 923      *              and the field is an instance field.
 924      * @throws    ExceptionInInitializerError if the initialization provoked
 925      *              by this method fails.
 926      * @see       Field#set
 927      */
 928     @CallerSensitive
 929     @ForceInline // to ensure Reflection.getCallerClass optimization
 930     public void setShort(Object obj, short s)
 931         throws IllegalArgumentException, IllegalAccessException
 932     {
<a name="6" id="anc6"></a><span class="line-added"> 933         ensureNotValueClass();</span>
<span class="line-added"> 934 </span>
 935         if (!override) {
 936             Class&lt;?&gt; caller = Reflection.getCallerClass();
 937             checkAccess(caller, obj);
 938         }
 939         getFieldAccessor(obj).setShort(obj, s);
 940     }
 941 
 942     /**
 943      * Sets the value of a field as an {@code int} on the specified object.
 944      * This method is equivalent to
 945      * {@code set(obj, iObj)},
 946      * where {@code iObj} is an {@code Integer} object and
 947      * {@code iObj.intValue() == i}.
 948      *
 949      * @param obj the object whose field should be modified
 950      * @param i   the new value for the field of {@code obj}
 951      * being modified
 952      *
 953      * @throws    IllegalAccessException    if this {@code Field} object
 954      *              is enforcing Java language access control and the underlying
 955      *              field is either inaccessible or final.
 956      * @throws    IllegalArgumentException  if the specified object is not an
 957      *              instance of the class or interface declaring the underlying
 958      *              field (or a subclass or implementor thereof),
 959      *              or if an unwrapping conversion fails.
 960      * @throws    NullPointerException      if the specified object is null
 961      *              and the field is an instance field.
 962      * @throws    ExceptionInInitializerError if the initialization provoked
 963      *              by this method fails.
 964      * @see       Field#set
 965      */
 966     @CallerSensitive
 967     @ForceInline // to ensure Reflection.getCallerClass optimization
 968     public void setInt(Object obj, int i)
 969         throws IllegalArgumentException, IllegalAccessException
 970     {
<a name="7" id="anc7"></a><span class="line-added"> 971         ensureNotValueClass();</span>
<span class="line-added"> 972 </span>
 973         if (!override) {
 974             Class&lt;?&gt; caller = Reflection.getCallerClass();
 975             checkAccess(caller, obj);
 976         }
 977         getFieldAccessor(obj).setInt(obj, i);
 978     }
 979 
 980     /**
 981      * Sets the value of a field as a {@code long} on the specified object.
 982      * This method is equivalent to
 983      * {@code set(obj, lObj)},
 984      * where {@code lObj} is a {@code Long} object and
 985      * {@code lObj.longValue() == l}.
 986      *
 987      * @param obj the object whose field should be modified
 988      * @param l   the new value for the field of {@code obj}
 989      * being modified
 990      *
 991      * @throws    IllegalAccessException    if this {@code Field} object
 992      *              is enforcing Java language access control and the underlying
 993      *              field is either inaccessible or final.
 994      * @throws    IllegalArgumentException  if the specified object is not an
 995      *              instance of the class or interface declaring the underlying
 996      *              field (or a subclass or implementor thereof),
 997      *              or if an unwrapping conversion fails.
 998      * @throws    NullPointerException      if the specified object is null
 999      *              and the field is an instance field.
1000      * @throws    ExceptionInInitializerError if the initialization provoked
1001      *              by this method fails.
1002      * @see       Field#set
1003      */
1004     @CallerSensitive
1005     @ForceInline // to ensure Reflection.getCallerClass optimization
1006     public void setLong(Object obj, long l)
1007         throws IllegalArgumentException, IllegalAccessException
1008     {
<a name="8" id="anc8"></a><span class="line-added">1009         ensureNotValueClass();</span>
<span class="line-added">1010 </span>
1011         if (!override) {
1012             Class&lt;?&gt; caller = Reflection.getCallerClass();
1013             checkAccess(caller, obj);
1014         }
1015         getFieldAccessor(obj).setLong(obj, l);
1016     }
1017 
1018     /**
1019      * Sets the value of a field as a {@code float} on the specified object.
1020      * This method is equivalent to
1021      * {@code set(obj, fObj)},
1022      * where {@code fObj} is a {@code Float} object and
1023      * {@code fObj.floatValue() == f}.
1024      *
1025      * @param obj the object whose field should be modified
1026      * @param f   the new value for the field of {@code obj}
1027      * being modified
1028      *
1029      * @throws    IllegalAccessException    if this {@code Field} object
1030      *              is enforcing Java language access control and the underlying
1031      *              field is either inaccessible or final.
1032      * @throws    IllegalArgumentException  if the specified object is not an
1033      *              instance of the class or interface declaring the underlying
1034      *              field (or a subclass or implementor thereof),
1035      *              or if an unwrapping conversion fails.
1036      * @throws    NullPointerException      if the specified object is null
1037      *              and the field is an instance field.
1038      * @throws    ExceptionInInitializerError if the initialization provoked
1039      *              by this method fails.
1040      * @see       Field#set
1041      */
1042     @CallerSensitive
1043     @ForceInline // to ensure Reflection.getCallerClass optimization
1044     public void setFloat(Object obj, float f)
1045         throws IllegalArgumentException, IllegalAccessException
1046     {
<a name="9" id="anc9"></a><span class="line-added">1047         ensureNotValueClass();</span>
<span class="line-added">1048 </span>
1049         if (!override) {
1050             Class&lt;?&gt; caller = Reflection.getCallerClass();
1051             checkAccess(caller, obj);
1052         }
1053         getFieldAccessor(obj).setFloat(obj, f);
1054     }
1055 
1056     /**
1057      * Sets the value of a field as a {@code double} on the specified object.
1058      * This method is equivalent to
1059      * {@code set(obj, dObj)},
1060      * where {@code dObj} is a {@code Double} object and
1061      * {@code dObj.doubleValue() == d}.
1062      *
1063      * @param obj the object whose field should be modified
1064      * @param d   the new value for the field of {@code obj}
1065      * being modified
1066      *
1067      * @throws    IllegalAccessException    if this {@code Field} object
1068      *              is enforcing Java language access control and the underlying
1069      *              field is either inaccessible or final.
1070      * @throws    IllegalArgumentException  if the specified object is not an
1071      *              instance of the class or interface declaring the underlying
1072      *              field (or a subclass or implementor thereof),
1073      *              or if an unwrapping conversion fails.
1074      * @throws    NullPointerException      if the specified object is null
1075      *              and the field is an instance field.
1076      * @throws    ExceptionInInitializerError if the initialization provoked
1077      *              by this method fails.
1078      * @see       Field#set
1079      */
1080     @CallerSensitive
1081     @ForceInline // to ensure Reflection.getCallerClass optimization
1082     public void setDouble(Object obj, double d)
1083         throws IllegalArgumentException, IllegalAccessException
1084     {
<a name="10" id="anc10"></a><span class="line-added">1085         ensureNotValueClass();</span>
<span class="line-added">1086 </span>
1087         if (!override) {
1088             Class&lt;?&gt; caller = Reflection.getCallerClass();
1089             checkAccess(caller, obj);
1090         }
1091         getFieldAccessor(obj).setDouble(obj, d);
1092     }
1093 
1094     // check access to field
1095     private void checkAccess(Class&lt;?&gt; caller, Object obj)
1096         throws IllegalAccessException
1097     {
1098         checkAccess(caller, clazz,
1099                     Modifier.isStatic(modifiers) ? null : obj.getClass(),
1100                     modifiers);
1101     }
1102 
<a name="11" id="anc11"></a><span class="line-added">1103     /*</span>
<span class="line-added">1104      * Ensure the declaring class is not an inline class.</span>
<span class="line-added">1105      */</span>
<span class="line-added">1106     private void ensureNotValueClass() throws IllegalAccessException {</span>
<span class="line-added">1107         if (clazz.isInlineClass()) {</span>
<span class="line-added">1108             throw new IllegalAccessException(&quot;cannot set field \&quot;&quot; + this + &quot;\&quot; of inline class &quot;</span>
<span class="line-added">1109                 + clazz.getName());</span>
<span class="line-added">1110         }</span>
<span class="line-added">1111     }</span>
<span class="line-added">1112 </span>
1113     // security check is done before calling this method
1114     private FieldAccessor getFieldAccessor(Object obj)
1115         throws IllegalAccessException
1116     {
1117         boolean ov = override;
1118         FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;
1119         return (a != null) ? a : acquireFieldAccessor(ov);
1120     }
1121 
1122     // NOTE that there is no synchronization used here. It is correct
1123     // (though not efficient) to generate more than one FieldAccessor
1124     // for a given Field. However, avoiding synchronization will
1125     // probably make the implementation more scalable.
1126     private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) {
1127         // First check to see if one has been created yet, and take it
1128         // if so
1129         FieldAccessor tmp = null;
1130         if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck);
1131         if (tmp != null) {
1132             if (overrideFinalCheck)
1133                 overrideFieldAccessor = tmp;
1134             else
1135                 fieldAccessor = tmp;
1136         } else {
1137             // Otherwise fabricate one and propagate it up to the root
1138             tmp = reflectionFactory.newFieldAccessor(this, overrideFinalCheck);
1139             setFieldAccessor(tmp, overrideFinalCheck);
1140         }
1141 
1142         return tmp;
1143     }
1144 
1145     // Returns FieldAccessor for this Field object, not looking up
1146     // the chain to the root
1147     private FieldAccessor getFieldAccessor(boolean overrideFinalCheck) {
1148         return (overrideFinalCheck)? overrideFieldAccessor : fieldAccessor;
1149     }
1150 
1151     // Sets the FieldAccessor for this Field object and
1152     // (recursively) its root
1153     private void setFieldAccessor(FieldAccessor accessor, boolean overrideFinalCheck) {
1154         if (overrideFinalCheck)
1155             overrideFieldAccessor = accessor;
1156         else
1157             fieldAccessor = accessor;
1158         // Propagate up
1159         if (root != null) {
1160             root.setFieldAccessor(accessor, overrideFinalCheck);
1161         }
1162     }
1163 
1164     @Override
1165     Field getRoot() {
1166         return root;
1167     }
1168 
1169     /**
1170      * {@inheritDoc}
1171      *
1172      * @throws NullPointerException {@inheritDoc}
1173      * @since 1.5
1174      */
1175     @Override
1176     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
1177         Objects.requireNonNull(annotationClass);
1178         return annotationClass.cast(declaredAnnotations().get(annotationClass));
1179     }
1180 
1181     /**
1182      * {@inheritDoc}
1183      *
1184      * @throws NullPointerException {@inheritDoc}
1185      * @since 1.8
1186      */
1187     @Override
1188     public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
1189         Objects.requireNonNull(annotationClass);
1190 
1191         return AnnotationSupport.getDirectlyAndIndirectlyPresent(declaredAnnotations(), annotationClass);
1192     }
1193 
1194     /**
1195      * {@inheritDoc}
1196      */
1197     @Override
1198     public Annotation[] getDeclaredAnnotations()  {
1199         return AnnotationParser.toArray(declaredAnnotations());
1200     }
1201 
1202     private transient volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
1203 
1204     private Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {
1205         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declAnnos;
1206         if ((declAnnos = declaredAnnotations) == null) {
1207             synchronized (this) {
1208                 if ((declAnnos = declaredAnnotations) == null) {
1209                     Field root = this.root;
1210                     if (root != null) {
1211                         declAnnos = root.declaredAnnotations();
1212                     } else {
1213                         declAnnos = AnnotationParser.parseAnnotations(
1214                                 annotations,
1215                                 SharedSecrets.getJavaLangAccess()
1216                                         .getConstantPool(getDeclaringClass()),
1217                                 getDeclaringClass());
1218                     }
1219                     declaredAnnotations = declAnnos;
1220                 }
1221             }
1222         }
1223         return declAnnos;
1224     }
1225 
1226     private native byte[] getTypeAnnotationBytes0();
1227 
1228     /**
1229      * Returns an AnnotatedType object that represents the use of a type to specify
1230      * the declared type of the field represented by this Field.
1231      * @return an object representing the declared type of the field
1232      * represented by this Field
1233      *
1234      * @since 1.8
1235      */
1236     public AnnotatedType getAnnotatedType() {
1237         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
1238                                                        SharedSecrets.getJavaLangAccess().
1239                                                            getConstantPool(getDeclaringClass()),
1240                                                        this,
1241                                                        getDeclaringClass(),
1242                                                        getGenericType(),
1243                                                        TypeAnnotation.TypeAnnotationTarget.FIELD);
1244 }
1245 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
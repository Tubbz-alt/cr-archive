<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../io/ObjectStreamClass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;
  49 import java.lang.reflect.RecordComponent;
  50 import java.lang.reflect.Type;
  51 import java.lang.reflect.TypeVariable;
  52 import java.lang.constant.Constable;
  53 import java.net.URL;
  54 import java.security.AccessController;
  55 import java.security.PrivilegedAction;
  56 import java.util.ArrayList;
  57 import java.util.Arrays;
  58 import java.util.Collection;
  59 import java.util.HashMap;
  60 import java.util.LinkedHashMap;
  61 import java.util.LinkedHashSet;
  62 import java.util.List;
  63 import java.util.Map;
  64 import java.util.Objects;
  65 import java.util.Optional;
<span class="line-removed">  66 import java.util.StringJoiner;</span>
<span class="line-removed">  67 import java.util.stream.Stream;</span>
  68 import java.util.stream.Collectors;
  69 
  70 import jdk.internal.HotSpotIntrinsicCandidate;
  71 import jdk.internal.loader.BootLoader;
  72 import jdk.internal.loader.BuiltinClassLoader;
  73 import jdk.internal.misc.Unsafe;
  74 import jdk.internal.module.Resources;
  75 import jdk.internal.reflect.CallerSensitive;
  76 import jdk.internal.reflect.ConstantPool;
  77 import jdk.internal.reflect.Reflection;
  78 import jdk.internal.reflect.ReflectionFactory;
  79 import jdk.internal.vm.annotation.ForceInline;
  80 import sun.invoke.util.Wrapper;
  81 import sun.reflect.generics.factory.CoreReflectionFactory;
  82 import sun.reflect.generics.factory.GenericsFactory;
  83 import sun.reflect.generics.repository.ClassRepository;
  84 import sun.reflect.generics.repository.MethodRepository;
  85 import sun.reflect.generics.repository.ConstructorRepository;
  86 import sun.reflect.generics.scope.ClassScope;
  87 import sun.security.util.SecurityConstants;
</pre>
<hr />
<pre>
 145  *
 146  * &lt;blockquote&gt;
 147  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}
 148  * &lt;/blockquote&gt;
 149  *
 150  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 151  * object.  For example, the type of {@code String.class} is {@code
 152  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 153  * unknown.
 154  *
 155  * @author  unascribed
 156  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 157  * @since   1.0
 158  */
 159 public final class Class&lt;T&gt; implements java.io.Serializable,
 160                               GenericDeclaration,
 161                               Type,
 162                               AnnotatedElement,
 163                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 164                               Constable {
<span class="line-modified"> 165     private static final int ANNOTATION= 0x00002000;</span>
<span class="line-modified"> 166     private static final int ENUM      = 0x00004000;</span>
<span class="line-modified"> 167     private static final int SYNTHETIC = 0x00001000;</span>

 168 
 169     private static native void registerNatives();
 170     static {
 171         registerNatives();
 172     }
 173 
 174     /*
 175      * Private constructor. Only the Java Virtual Machine creates Class objects.
 176      * This constructor is not used and prevents the default constructor being
 177      * generated.
 178      */
 179     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 180         // Initialize final field for classLoader.  The initialization value of non-null
 181         // prevents future JIT optimizations from assuming this final field is null.
 182         classLoader = loader;
 183         componentType = arrayComponentType;
 184     }
 185 
 186     /**
 187      * Converts the object to a string. The string representation is the
 188      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 189      * fully qualified name of the class in the format returned by
 190      * {@code getName}.  If this {@code Class} object represents a
 191      * primitive type, this method returns the name of the primitive type.  If
 192      * this {@code Class} object represents void this method returns
 193      * &quot;void&quot;. If this {@code Class} object represents an array type,
 194      * this method returns &quot;class &quot; followed by {@code getName}.
 195      *
 196      * @return a string representation of this {@code Class} object.
 197      */
 198     public String toString() {
<span class="line-modified"> 199         return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))</span>
<span class="line-modified"> 200             + getName();</span>

 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 242             Class&lt;?&gt; component = this;
 243             int arrayDepth = 0;
 244 
 245             if (isArray()) {
 246                 do {
 247                     arrayDepth++;
 248                     component = component.getComponentType();
 249                 } while (component.isArray());
 250                 sb.append(component.getName());
 251             } else {
 252                 // Class modifiers are a superset of interface modifiers
 253                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 254                 if (modifiers != 0) {
 255                     sb.append(Modifier.toString(modifiers));
 256                     sb.append(&#39; &#39;);
 257                 }
 258 
 259                 if (isAnnotation()) {
 260                     sb.append(&#39;@&#39;);
 261                 }




 262                 if (isInterface()) { // Note: all annotation types are interfaces
 263                     sb.append(&quot;interface&quot;);
 264                 } else {
 265                     if (isEnum())
 266                         sb.append(&quot;enum&quot;);
 267                     else if (isRecord())
 268                         sb.append(&quot;record&quot;);
 269                     else
 270                         sb.append(&quot;class&quot;);
 271                 }
 272                 sb.append(&#39; &#39;);
 273                 sb.append(getName());
 274             }
 275 
 276             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 277             if (typeparms.length &gt; 0) {
 278                 sb.append(Arrays.stream(typeparms)
 279                           .map(Class::typeVarBounds)
 280                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 281             }
</pre>
<hr />
<pre>
 416     {
 417         Class&lt;?&gt; caller = null;
 418         SecurityManager sm = System.getSecurityManager();
 419         if (sm != null) {
 420             // Reflective call to get caller class is only needed if a security manager
 421             // is present.  Avoid the overhead of making this call otherwise.
 422             caller = Reflection.getCallerClass();
 423             if (loader == null) {
 424                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 425                 if (ccl != null) {
 426                     sm.checkPermission(
 427                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 428                 }
 429             }
 430         }
 431         return forName0(name, initialize, loader, caller);
 432     }
 433 
 434     /** Called after security check for system loader access checks have been made. */
 435     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
<span class="line-modified"> 436                                             ClassLoader loader,</span>
<span class="line-modified"> 437                                             Class&lt;?&gt; caller)</span>
 438         throws ClassNotFoundException;
 439 
 440 
 441     /**
 442      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 443      * binary name&lt;/a&gt; in the given module.
 444      *
 445      * &lt;p&gt; This method attempts to locate and load the class or interface.
 446      * It does not link the class, and does not run the class initializer.
 447      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 448      *
 449      * &lt;p&gt; If the class loader of the given module defines other modules and
 450      * the given name is a class defined in a different module, this method
 451      * returns {@code null} after the class is loaded. &lt;/p&gt;
 452      *
 453      * &lt;p&gt; This method does not check whether the requested class is
 454      * accessible to its caller. &lt;/p&gt;
 455      *
 456      * @apiNote
 457      * This method returns {@code null} on failure rather than
</pre>
<hr />
<pre>
 495         if (sm != null) {
 496             Class&lt;?&gt; caller = Reflection.getCallerClass();
 497             if (caller != null &amp;&amp; caller.getModule() != module) {
 498                 // if caller is null, Class.forName is the last java frame on the stack.
 499                 // java.base has all permissions
 500                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 501             }
 502             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 503             cl = AccessController.doPrivileged(pa);
 504         } else {
 505             cl = module.getClassLoader();
 506         }
 507 
 508         if (cl != null) {
 509             return cl.loadClass(module, name);
 510         } else {
 511             return BootLoader.loadClass(module, name);
 512         }
 513     }
 514 
























































































 515     /**
 516      * Creates a new instance of the class represented by this {@code Class}
 517      * object.  The class is instantiated as if by a {@code new}
 518      * expression with an empty argument list.  The class is initialized if it
 519      * has not already been initialized.
 520      *
 521      * @deprecated This method propagates any exception thrown by the
 522      * nullary constructor, including a checked exception.  Use of
 523      * this method effectively bypasses the compile-time exception
 524      * checking that would otherwise be performed by the compiler.
 525      * The {@link
 526      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 527      * Constructor.newInstance} method avoids this problem by wrapping
 528      * any exception thrown by the constructor in a (checked) {@link
 529      * java.lang.reflect.InvocationTargetException}.
 530      *
 531      * &lt;p&gt;The call
 532      *
 533      * &lt;pre&gt;{@code
 534      * clazz.newInstance()
</pre>
<hr />
<pre>
 769      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 770      * name returned is a {@code String} equal to the Java language
 771      * keyword corresponding to the primitive type or void.
 772      *
 773      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 774      * form of the name consists of the name of the element type preceded by
 775      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 776      * nesting.  The encoding of element type names is as follows:
 777      *
 778      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 779      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 780      * &lt;thead&gt;
 781      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 782      * &lt;/thead&gt;
 783      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 784      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 785      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 786      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 787      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 788      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;


 789      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 790      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 791      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 792      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 793      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 794      * &lt;/tbody&gt;
 795      * &lt;/table&gt;&lt;/blockquote&gt;
 796      *
 797      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 798      * the class specified above.
 799      *
 800      * &lt;p&gt; Examples:
 801      * &lt;blockquote&gt;&lt;pre&gt;
 802      * String.class.getName()
 803      *     returns &quot;java.lang.String&quot;
 804      * byte.class.getName()
 805      *     returns &quot;byte&quot;


 806      * (new Object[3]).getClass().getName()
 807      *     returns &quot;[Ljava.lang.Object;&quot;




 808      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 809      *     returns &quot;[[[[[[[I&quot;
 810      * &lt;/pre&gt;&lt;/blockquote&gt;
 811      *
 812      * @return  the name of the class or interface
 813      *          represented by this {@code Class} object.
 814      */
 815     public String getName() {
 816         String name = this.name;
 817         return name != null ? name : initClassName();
 818     }
 819 
 820     // Cache the name to reduce the number of calls into the VM.
 821     // This field would be set by VM itself during initClassName call.
 822     private transient String name;
 823     private native String initClassName();
 824 
 825     /**
 826      * Returns the class loader for the class.  Some implementations may use
 827      * null to represent the bootstrap class loader. This method will return
</pre>
<hr />
<pre>
1198      * modifiers are the same as those of its component type.  If this
1199      * {@code Class} object represents a primitive type or void, its
1200      * {@code public} modifier is always {@code true}, and its
1201      * {@code protected} and {@code private} modifiers are always
1202      * {@code false}. If this {@code Class} object represents an array class, a
1203      * primitive type or void, then its {@code final} modifier is always
1204      * {@code true} and its interface modifier is always
1205      * {@code false}. The values of its other modifiers are not determined
1206      * by this specification.
1207      *
1208      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1209      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1210      *
1211      * @return the {@code int} representing the modifiers for this class
1212      * @see     java.lang.reflect.Modifier
1213      * @since 1.1
1214      */
1215     @HotSpotIntrinsicCandidate
1216     public native int getModifiers();
1217 
<span class="line-removed">1218 </span>
1219     /**
1220      * Gets the signers of this class.
1221      *
1222      * @return  the signers of this class, or null if there are no signers.  In
1223      *          particular, this method returns null if this {@code Class} object represents
1224      *          a primitive type or void.
1225      * @since   1.1
1226      */
<span class="line-modified">1227     public native Object[] getSigners();</span>


1228 

1229 
1230     /**
1231      * Set the signers of this class.
1232      */
<span class="line-modified">1233     native void setSigners(Object[] signers);</span>




1234 
1235 
1236     /**
1237      * If this {@code Class} object represents a local or anonymous
1238      * class within a method, returns a {@link
1239      * java.lang.reflect.Method Method} object representing the
1240      * immediately enclosing method of the underlying class. Returns
1241      * {@code null} otherwise.
1242      *
1243      * In particular, this method returns {@code null} if the underlying
1244      * class is a local or anonymous class immediately enclosed by a type
1245      * declaration, instance initializer or static initializer.
1246      *
1247      * @return the immediately enclosing method of the underlying class, if
1248      *     that class is a local or anonymous class; otherwise {@code null}.
1249      *
1250      * @throws SecurityException
1251      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1252      *         following conditions is met:
1253      *
</pre>
<hr />
<pre>
1572      * @since 1.5
1573      */
1574     public String getSimpleName() {
1575         ReflectionData&lt;T&gt; rd = reflectionData();
1576         String simpleName = rd.simpleName;
1577         if (simpleName == null) {
1578             rd.simpleName = simpleName = getSimpleName0();
1579         }
1580         return simpleName;
1581     }
1582 
1583     private String getSimpleName0() {
1584         if (isArray()) {
1585             return getComponentType().getSimpleName() + &quot;[]&quot;;
1586         }
1587         String simpleName = getSimpleBinaryName();
1588         if (simpleName == null) { // top level class
1589             simpleName = getName();
1590             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1591         }
<span class="line-modified">1592         return simpleName;</span>
1593     }
1594 
1595     /**
1596      * Return an informative string for the name of this type.
1597      *
1598      * @return an informative string for the name of this type
1599      * @since 1.8
1600      */
1601     public String getTypeName() {
1602         if (isArray()) {
1603             try {
1604                 Class&lt;?&gt; cl = this;
1605                 int dimensions = 0;
1606                 do {
1607                     dimensions++;
1608                     cl = cl.getComponentType();
1609                 } while (cl.isArray());
<span class="line-modified">1610                 return cl.getName() + &quot;[]&quot;.repeat(dimensions);</span>
1611             } catch (Throwable e) { /*FALLTHRU*/ }
1612         }
<span class="line-modified">1613         return getName();</span>
1614     }
1615 
1616     /**
1617      * Returns the canonical name of the underlying class as defined
1618      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1619      * {@jls 6.7}.  Returns null if the underlying class does not have
1620      * a canonical name (i.e., if it is a local or anonymous class or
1621      * an array whose component type does not have a canonical name).
1622      * @return the canonical name of the underlying class if it exists, and
1623      * {@code null} otherwise.
1624      * @since 1.5
1625      */
1626     public String getCanonicalName() {
1627         ReflectionData&lt;T&gt; rd = reflectionData();
1628         String canonicalName = rd.canonicalName;
1629         if (canonicalName == null) {
1630             rd.canonicalName = canonicalName = getCanonicalName0();
1631         }
1632         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1633     }
</pre>
<hr />
<pre>
3487         }
3488         return out;
3489     }
3490 
3491     private native Field[]       getDeclaredFields0(boolean publicOnly);
3492     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3493     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3494     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3495     @SuppressWarnings(&quot;preview&quot;)
3496     private native RecordComponent[] getRecordComponents0();
3497     private native boolean      isRecord0();
3498 
3499     /**
3500      * Helper method to get the method name from arguments.
3501      */
3502     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3503         return getName() + &#39;.&#39; + name +
3504                 ((argTypes == null || argTypes.length == 0) ?
3505                 &quot;()&quot; :
3506                 Arrays.stream(argTypes)
<span class="line-modified">3507                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())</span>
3508                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3509     }
3510 








3511     /** use serialVersionUID from JDK 1.1 for interoperability */
3512     @java.io.Serial
3513     private static final long serialVersionUID = 3206093459760846163L;
3514 
3515 
3516     /**
3517      * Class Class is special cased within the Serialization Stream Protocol.
3518      *
3519      * A Class instance is written initially into an ObjectOutputStream in the
3520      * following format:
3521      * &lt;pre&gt;
3522      *      {@code TC_CLASS} ClassDescriptor
3523      *      A ClassDescriptor is a special cased serialization of
3524      *      a {@code java.io.ObjectStreamClass} instance.
3525      * &lt;/pre&gt;
3526      * A new handle is generated for the initial time the class descriptor
3527      * is written into the stream. Future references to the class descriptor
3528      * are written as references to the initial class descriptor instance.
3529      *
3530      * @see java.io.ObjectStreamClass
</pre>
<hr />
<pre>
3715                 throw new IllegalArgumentException(
3716                     getName() + &quot; is not an enum type&quot;);
3717             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3718             for (T constant : universe) {
3719                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3720             }
3721             enumConstantDirectory = directory;
3722         }
3723         return directory;
3724     }
3725     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3726 
3727     /**
3728      * Casts an object to the class or interface represented
3729      * by this {@code Class} object.
3730      *
3731      * @param obj the object to be cast
3732      * @return the object after casting, or null if obj is null
3733      *
3734      * @throws ClassCastException if the object is not
<span class="line-modified">3735      * null and is not assignable to the type T.</span>


3736      *
3737      * @since 1.5
3738      */
3739     @SuppressWarnings(&quot;unchecked&quot;)
3740     @HotSpotIntrinsicCandidate
3741     public T cast(Object obj) {



3742         if (obj != null &amp;&amp; !isInstance(obj))
3743             throw new ClassCastException(cannotCastMsg(obj));
3744         return (T) obj;
3745     }
3746 
3747     private String cannotCastMsg(Object obj) {
3748         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3749     }
3750 
3751     /**
3752      * Casts this {@code Class} object to represent a subclass of the class
3753      * represented by the specified class object.  Checks that the cast
3754      * is valid, and throws a {@code ClassCastException} if it is not.  If
3755      * this method succeeds, it always returns a reference to this {@code Class} object.
3756      *
3757      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3758      * a {@code Class} object to pass it to an API that restricts the
3759      * {@code Class} objects that it is willing to accept.  A cast would
3760      * generate a compile-time warning, as the correctness of the cast
3761      * could not be checked at runtime (because generic types are implemented
</pre>
<hr />
<pre>
4017      *
4018      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4019      * value is an array containing objects representing the uses of interface
4020      * types to specify interfaces directly extended by the interface. The
4021      * order of the objects in the array corresponds to the order of the
4022      * interface types used in the &#39;extends&#39; clause of the declaration of this
4023      * {@code Class} object.
4024      *
4025      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4026      * declaration does not explicitly indicate any annotated superinterfaces,
4027      * the return value is an array of length 0.
4028      *
4029      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4030      * class, an array type, a primitive type, or void, the return value is an
4031      * array of length 0.
4032      *
4033      * @return an array representing the superinterfaces
4034      * @since 1.8
4035      */
4036     public AnnotatedType[] getAnnotatedInterfaces() {
<span class="line-modified">4037          return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);</span>
4038     }
4039 
4040     private native Class&lt;?&gt; getNestHost0();
4041 
4042     /**
4043      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4044      * or interface represented by this {@code Class} object belongs.
4045      * Every class and interface is a member of exactly one nest.
4046      * A class or interface that is not recorded as belonging to a nest
4047      * belongs to the nest consisting only of itself, and is the nest
4048      * host.
4049      *
4050      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4051      * primitive types, and {@code void} returns {@code this} to indicate
4052      * that the represented entity belongs to the nest consisting only of
4053      * itself, and is the nest host.
4054      *
4055      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4056      * the nest host, or if this class or interface is not enumerated as
4057      * a member of the nest by the nest host, then it is considered to belong
</pre>
</td>
<td>
<hr />
<pre>
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;
  49 import java.lang.reflect.RecordComponent;
  50 import java.lang.reflect.Type;
  51 import java.lang.reflect.TypeVariable;
  52 import java.lang.constant.Constable;
  53 import java.net.URL;
  54 import java.security.AccessController;
  55 import java.security.PrivilegedAction;
  56 import java.util.ArrayList;
  57 import java.util.Arrays;
  58 import java.util.Collection;
  59 import java.util.HashMap;
  60 import java.util.LinkedHashMap;
  61 import java.util.LinkedHashSet;
  62 import java.util.List;
  63 import java.util.Map;
  64 import java.util.Objects;
  65 import java.util.Optional;


  66 import java.util.stream.Collectors;
  67 
  68 import jdk.internal.HotSpotIntrinsicCandidate;
  69 import jdk.internal.loader.BootLoader;
  70 import jdk.internal.loader.BuiltinClassLoader;
  71 import jdk.internal.misc.Unsafe;
  72 import jdk.internal.module.Resources;
  73 import jdk.internal.reflect.CallerSensitive;
  74 import jdk.internal.reflect.ConstantPool;
  75 import jdk.internal.reflect.Reflection;
  76 import jdk.internal.reflect.ReflectionFactory;
  77 import jdk.internal.vm.annotation.ForceInline;
  78 import sun.invoke.util.Wrapper;
  79 import sun.reflect.generics.factory.CoreReflectionFactory;
  80 import sun.reflect.generics.factory.GenericsFactory;
  81 import sun.reflect.generics.repository.ClassRepository;
  82 import sun.reflect.generics.repository.MethodRepository;
  83 import sun.reflect.generics.repository.ConstructorRepository;
  84 import sun.reflect.generics.scope.ClassScope;
  85 import sun.security.util.SecurityConstants;
</pre>
<hr />
<pre>
 143  *
 144  * &lt;blockquote&gt;
 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
<span class="line-modified"> 163     private static final int ANNOTATION = 0x00002000;</span>
<span class="line-modified"> 164     private static final int ENUM       = 0x00004000;</span>
<span class="line-modified"> 165     private static final int SYNTHETIC  = 0x00001000;</span>
<span class="line-added"> 166     private static final int VALUE_TYPE = 0x00000100;</span>
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
<span class="line-modified"> 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)</span>
<span class="line-modified"> 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))</span>
<span class="line-added"> 200                + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);</span>
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 242             Class&lt;?&gt; component = this;
 243             int arrayDepth = 0;
 244 
 245             if (isArray()) {
 246                 do {
 247                     arrayDepth++;
 248                     component = component.getComponentType();
 249                 } while (component.isArray());
 250                 sb.append(component.getName());
 251             } else {
 252                 // Class modifiers are a superset of interface modifiers
 253                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 254                 if (modifiers != 0) {
 255                     sb.append(Modifier.toString(modifiers));
 256                     sb.append(&#39; &#39;);
 257                 }
 258 
 259                 if (isAnnotation()) {
 260                     sb.append(&#39;@&#39;);
 261                 }
<span class="line-added"> 262                 if (isInlineClass()) {</span>
<span class="line-added"> 263                     sb.append(&quot;inline&quot;);</span>
<span class="line-added"> 264                     sb.append(&#39; &#39;);</span>
<span class="line-added"> 265                 }</span>
 266                 if (isInterface()) { // Note: all annotation types are interfaces
 267                     sb.append(&quot;interface&quot;);
 268                 } else {
 269                     if (isEnum())
 270                         sb.append(&quot;enum&quot;);
 271                     else if (isRecord())
 272                         sb.append(&quot;record&quot;);
 273                     else
 274                         sb.append(&quot;class&quot;);
 275                 }
 276                 sb.append(&#39; &#39;);
 277                 sb.append(getName());
 278             }
 279 
 280             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 281             if (typeparms.length &gt; 0) {
 282                 sb.append(Arrays.stream(typeparms)
 283                           .map(Class::typeVarBounds)
 284                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 285             }
</pre>
<hr />
<pre>
 420     {
 421         Class&lt;?&gt; caller = null;
 422         SecurityManager sm = System.getSecurityManager();
 423         if (sm != null) {
 424             // Reflective call to get caller class is only needed if a security manager
 425             // is present.  Avoid the overhead of making this call otherwise.
 426             caller = Reflection.getCallerClass();
 427             if (loader == null) {
 428                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 429                 if (ccl != null) {
 430                     sm.checkPermission(
 431                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 432                 }
 433             }
 434         }
 435         return forName0(name, initialize, loader, caller);
 436     }
 437 
 438     /** Called after security check for system loader access checks have been made. */
 439     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
<span class="line-modified"> 440                                     ClassLoader loader,</span>
<span class="line-modified"> 441                                     Class&lt;?&gt; caller)</span>
 442         throws ClassNotFoundException;
 443 
 444 
 445     /**
 446      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 447      * binary name&lt;/a&gt; in the given module.
 448      *
 449      * &lt;p&gt; This method attempts to locate and load the class or interface.
 450      * It does not link the class, and does not run the class initializer.
 451      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 452      *
 453      * &lt;p&gt; If the class loader of the given module defines other modules and
 454      * the given name is a class defined in a different module, this method
 455      * returns {@code null} after the class is loaded. &lt;/p&gt;
 456      *
 457      * &lt;p&gt; This method does not check whether the requested class is
 458      * accessible to its caller. &lt;/p&gt;
 459      *
 460      * @apiNote
 461      * This method returns {@code null} on failure rather than
</pre>
<hr />
<pre>
 499         if (sm != null) {
 500             Class&lt;?&gt; caller = Reflection.getCallerClass();
 501             if (caller != null &amp;&amp; caller.getModule() != module) {
 502                 // if caller is null, Class.forName is the last java frame on the stack.
 503                 // java.base has all permissions
 504                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 505             }
 506             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 507             cl = AccessController.doPrivileged(pa);
 508         } else {
 509             cl = module.getClassLoader();
 510         }
 511 
 512         if (cl != null) {
 513             return cl.loadClass(module, name);
 514         } else {
 515             return BootLoader.loadClass(module, name);
 516         }
 517     }
 518 
<span class="line-added"> 519     /**</span>
<span class="line-added"> 520      * Returns {@code true} if this class is an inline class.</span>
<span class="line-added"> 521      *</span>
<span class="line-added"> 522      * @return {@code true} if this class is an inline class.</span>
<span class="line-added"> 523      */</span>
<span class="line-added"> 524     public boolean isInlineClass() {</span>
<span class="line-added"> 525         return (this.getModifiers() &amp; VALUE_TYPE) != 0;</span>
<span class="line-added"> 526     }</span>
<span class="line-added"> 527 </span>
<span class="line-added"> 528     /**</span>
<span class="line-added"> 529      * Returns a {@code Class} object representing the primary type of</span>
<span class="line-added"> 530      * this class.</span>
<span class="line-added"> 531      *</span>
<span class="line-added"> 532      * &lt;p&gt; For class {@code C}, {@code C.class} is the primary type of {@code C}.</span>
<span class="line-added"> 533      * For a primitive type, the {@code Class} instance representing</span>
<span class="line-added"> 534      * that primitive type is its primary type, for example {@code int.class}.</span>
<span class="line-added"> 535      *</span>
<span class="line-added"> 536      * @return the {@code Class} object representing the primary type of</span>
<span class="line-added"> 537      *         this class</span>
<span class="line-added"> 538      */</span>
<span class="line-added"> 539     @HotSpotIntrinsicCandidate</span>
<span class="line-added"> 540     public Class&lt;T&gt; asPrimaryType() {</span>
<span class="line-added"> 541         return isInlineClass() ? inlineType : this;</span>
<span class="line-added"> 542     }</span>
<span class="line-added"> 543 </span>
<span class="line-added"> 544     /**</span>
<span class="line-added"> 545      * Returns a {@code Class} object representing the &lt;em&gt;indirect projection&lt;/em&gt;</span>
<span class="line-added"> 546      * type if this class is an {@linkplain #isInlineClass() inline class};</span>
<span class="line-added"> 547      * otherwise, returns this class.</span>
<span class="line-added"> 548      *</span>
<span class="line-added"> 549      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,</span>
<span class="line-added"> 550      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection</span>
<span class="line-added"> 551      * type}.  The indirect projection type is always</span>
<span class="line-added"> 552      * {@linkplain #isNullableType() nullable}.</span>
<span class="line-added"> 553      * The indirect projection type of a zero-default inline class</span>
<span class="line-added"> 554      * is also its nullable projection type.</span>
<span class="line-added"> 555      *</span>
<span class="line-added"> 556      * @return the {@code Class} object representing the indirect projection type of</span>
<span class="line-added"> 557      *         this class if this class is an inline class; otherwise, this class.</span>
<span class="line-added"> 558      */</span>
<span class="line-added"> 559     @HotSpotIntrinsicCandidate</span>
<span class="line-added"> 560     public Class&lt;T&gt; asIndirectType() {</span>
<span class="line-added"> 561         return isInlineClass() ? indirectType : this;</span>
<span class="line-added"> 562     }</span>
<span class="line-added"> 563 </span>
<span class="line-added"> 564     /**</span>
<span class="line-added"> 565      * Returns a {@code Class} object representing the &lt;em&gt;nullable projection&lt;/em&gt;</span>
<span class="line-added"> 566      * type if this class is an {@linkplain #isInlineClass() inline class};</span>
<span class="line-added"> 567      * otherwise, returns this class.</span>
<span class="line-added"> 568      *</span>
<span class="line-added"> 569      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,</span>
<span class="line-added"> 570      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection</span>
<span class="line-added"> 571      * type}.  The indirect projection type is always</span>
<span class="line-added"> 572      * {@linkplain #isNullableType() nullable}.</span>
<span class="line-added"> 573      * The indirect projection type of a zero-default inline class</span>
<span class="line-added"> 574      * is also its nullable projection type.</span>
<span class="line-added"> 575      *</span>
<span class="line-added"> 576      * @return the {@code Class} object representing the nullable projection type of</span>
<span class="line-added"> 577      *         this class if this class is an inline class; otherwise, this class.</span>
<span class="line-added"> 578      */</span>
<span class="line-added"> 579     public Class&lt;T&gt; asNullableType() {</span>
<span class="line-added"> 580         return asIndirectType();</span>
<span class="line-added"> 581     }</span>
<span class="line-added"> 582 </span>
<span class="line-added"> 583     /**</span>
<span class="line-added"> 584      * Returns {@code true} if this class is an indirect type.</span>
<span class="line-added"> 585      * An indirect type is always {@linkplain #isNullableType() nullable}.</span>
<span class="line-added"> 586      *</span>
<span class="line-added"> 587      * @return {@code true} if this class is an indirect type.</span>
<span class="line-added"> 588      */</span>
<span class="line-added"> 589     public boolean isIndirectType() {</span>
<span class="line-added"> 590         return indirectType == null || this == indirectType;</span>
<span class="line-added"> 591     }</span>
<span class="line-added"> 592 </span>
<span class="line-added"> 593     /**</span>
<span class="line-added"> 594      * Returns {@code true} if this class is a nullable type.</span>
<span class="line-added"> 595      *</span>
<span class="line-added"> 596      * @return {@code true} if this class is a nullable type.</span>
<span class="line-added"> 597      */</span>
<span class="line-added"> 598     public boolean isNullableType() {</span>
<span class="line-added"> 599         return isIndirectType();</span>
<span class="line-added"> 600     }</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602     // set by VM if this class is an inline type</span>
<span class="line-added"> 603     // otherwise, these two fields are null</span>
<span class="line-added"> 604     private transient Class&lt;T&gt; inlineType;</span>
<span class="line-added"> 605     private transient Class&lt;T&gt; indirectType;</span>
<span class="line-added"> 606 </span>
 607     /**
 608      * Creates a new instance of the class represented by this {@code Class}
 609      * object.  The class is instantiated as if by a {@code new}
 610      * expression with an empty argument list.  The class is initialized if it
 611      * has not already been initialized.
 612      *
 613      * @deprecated This method propagates any exception thrown by the
 614      * nullary constructor, including a checked exception.  Use of
 615      * this method effectively bypasses the compile-time exception
 616      * checking that would otherwise be performed by the compiler.
 617      * The {@link
 618      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 619      * Constructor.newInstance} method avoids this problem by wrapping
 620      * any exception thrown by the constructor in a (checked) {@link
 621      * java.lang.reflect.InvocationTargetException}.
 622      *
 623      * &lt;p&gt;The call
 624      *
 625      * &lt;pre&gt;{@code
 626      * clazz.newInstance()
</pre>
<hr />
<pre>
 861      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 862      * name returned is a {@code String} equal to the Java language
 863      * keyword corresponding to the primitive type or void.
 864      *
 865      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 866      * form of the name consists of the name of the element type preceded by
 867      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 868      * nesting.  The encoding of element type names is as follows:
 869      *
 870      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 871      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 872      * &lt;thead&gt;
 873      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 874      * &lt;/thead&gt;
 875      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 880      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
<span class="line-added"> 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; non-nullable {@linkplain #isInlineClass() inline class}</span>
<span class="line-added"> 882      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;</span>
 883      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 886      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 887      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 888      * &lt;/tbody&gt;
 889      * &lt;/table&gt;&lt;/blockquote&gt;
 890      *
 891      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 892      * the class specified above.
 893      *
 894      * &lt;p&gt; Examples:
 895      * &lt;blockquote&gt;&lt;pre&gt;
 896      * String.class.getName()
 897      *     returns &quot;java.lang.String&quot;
 898      * byte.class.getName()
 899      *     returns &quot;byte&quot;
<span class="line-added"> 900      * Point.class.getName()</span>
<span class="line-added"> 901      *     returns &quot;Point&quot;</span>
 902      * (new Object[3]).getClass().getName()
 903      *     returns &quot;[Ljava.lang.Object;&quot;
<span class="line-added"> 904      * (new Point[3]).getClass().getName()</span>
<span class="line-added"> 905      *     returns &quot;[QPoint;&quot;</span>
<span class="line-added"> 906      * (new Point?[3][4]).getClass().getName()</span>
<span class="line-added"> 907      *     returns &quot;[[LPoint;&quot;</span>
 908      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 909      *     returns &quot;[[[[[[[I&quot;
 910      * &lt;/pre&gt;&lt;/blockquote&gt;
 911      *
 912      * @return  the name of the class or interface
 913      *          represented by this {@code Class} object.
 914      */
 915     public String getName() {
 916         String name = this.name;
 917         return name != null ? name : initClassName();
 918     }
 919 
 920     // Cache the name to reduce the number of calls into the VM.
 921     // This field would be set by VM itself during initClassName call.
 922     private transient String name;
 923     private native String initClassName();
 924 
 925     /**
 926      * Returns the class loader for the class.  Some implementations may use
 927      * null to represent the bootstrap class loader. This method will return
</pre>
<hr />
<pre>
1298      * modifiers are the same as those of its component type.  If this
1299      * {@code Class} object represents a primitive type or void, its
1300      * {@code public} modifier is always {@code true}, and its
1301      * {@code protected} and {@code private} modifiers are always
1302      * {@code false}. If this {@code Class} object represents an array class, a
1303      * primitive type or void, then its {@code final} modifier is always
1304      * {@code true} and its interface modifier is always
1305      * {@code false}. The values of its other modifiers are not determined
1306      * by this specification.
1307      *
1308      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1309      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1310      *
1311      * @return the {@code int} representing the modifiers for this class
1312      * @see     java.lang.reflect.Modifier
1313      * @since 1.1
1314      */
1315     @HotSpotIntrinsicCandidate
1316     public native int getModifiers();
1317 

1318     /**
1319      * Gets the signers of this class.
1320      *
1321      * @return  the signers of this class, or null if there are no signers.  In
1322      *          particular, this method returns null if this {@code Class} object represents
1323      *          a primitive type or void.
1324      * @since   1.1
1325      */
<span class="line-modified">1326     public Object[] getSigners() {</span>
<span class="line-added">1327         return asPrimaryType().getSigners0();</span>
<span class="line-added">1328     }</span>
1329 
<span class="line-added">1330     private native Object[] getSigners0();</span>
1331 
1332     /**
1333      * Set the signers of this class.
1334      */
<span class="line-modified">1335     void setSigners(Object[] signers) {</span>
<span class="line-added">1336         asPrimaryType().setSigners0(signers);</span>
<span class="line-added">1337     }</span>
<span class="line-added">1338 </span>
<span class="line-added">1339     native void setSigners0(Object[] signers);</span>
1340 
1341 
1342     /**
1343      * If this {@code Class} object represents a local or anonymous
1344      * class within a method, returns a {@link
1345      * java.lang.reflect.Method Method} object representing the
1346      * immediately enclosing method of the underlying class. Returns
1347      * {@code null} otherwise.
1348      *
1349      * In particular, this method returns {@code null} if the underlying
1350      * class is a local or anonymous class immediately enclosed by a type
1351      * declaration, instance initializer or static initializer.
1352      *
1353      * @return the immediately enclosing method of the underlying class, if
1354      *     that class is a local or anonymous class; otherwise {@code null}.
1355      *
1356      * @throws SecurityException
1357      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1358      *         following conditions is met:
1359      *
</pre>
<hr />
<pre>
1678      * @since 1.5
1679      */
1680     public String getSimpleName() {
1681         ReflectionData&lt;T&gt; rd = reflectionData();
1682         String simpleName = rd.simpleName;
1683         if (simpleName == null) {
1684             rd.simpleName = simpleName = getSimpleName0();
1685         }
1686         return simpleName;
1687     }
1688 
1689     private String getSimpleName0() {
1690         if (isArray()) {
1691             return getComponentType().getSimpleName() + &quot;[]&quot;;
1692         }
1693         String simpleName = getSimpleBinaryName();
1694         if (simpleName == null) { // top level class
1695             simpleName = getName();
1696             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1697         }
<span class="line-modified">1698         return isInlineClass() &amp;&amp; isIndirectType() ? simpleName + &quot;?&quot; : simpleName;</span>
1699     }
1700 
1701     /**
1702      * Return an informative string for the name of this type.
1703      *
1704      * @return an informative string for the name of this type
1705      * @since 1.8
1706      */
1707     public String getTypeName() {
1708         if (isArray()) {
1709             try {
1710                 Class&lt;?&gt; cl = this;
1711                 int dimensions = 0;
1712                 do {
1713                     dimensions++;
1714                     cl = cl.getComponentType();
1715                 } while (cl.isArray());
<span class="line-modified">1716                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);</span>
1717             } catch (Throwable e) { /*FALLTHRU*/ }
1718         }
<span class="line-modified">1719         return toTypeName();</span>
1720     }
1721 
1722     /**
1723      * Returns the canonical name of the underlying class as defined
1724      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1725      * {@jls 6.7}.  Returns null if the underlying class does not have
1726      * a canonical name (i.e., if it is a local or anonymous class or
1727      * an array whose component type does not have a canonical name).
1728      * @return the canonical name of the underlying class if it exists, and
1729      * {@code null} otherwise.
1730      * @since 1.5
1731      */
1732     public String getCanonicalName() {
1733         ReflectionData&lt;T&gt; rd = reflectionData();
1734         String canonicalName = rd.canonicalName;
1735         if (canonicalName == null) {
1736             rd.canonicalName = canonicalName = getCanonicalName0();
1737         }
1738         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1739     }
</pre>
<hr />
<pre>
3593         }
3594         return out;
3595     }
3596 
3597     private native Field[]       getDeclaredFields0(boolean publicOnly);
3598     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3599     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3600     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3601     @SuppressWarnings(&quot;preview&quot;)
3602     private native RecordComponent[] getRecordComponents0();
3603     private native boolean      isRecord0();
3604 
3605     /**
3606      * Helper method to get the method name from arguments.
3607      */
3608     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3609         return getName() + &#39;.&#39; + name +
3610                 ((argTypes == null || argTypes.length == 0) ?
3611                 &quot;()&quot; :
3612                 Arrays.stream(argTypes)
<span class="line-modified">3613                         .map(c -&gt; c == null ? &quot;null&quot; : c.toTypeName())</span>
3614                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3615     }
3616 
<span class="line-added">3617     /*</span>
<span class="line-added">3618      * Returns the class name appended with &quot;?&quot; if it is the nullable projection</span>
<span class="line-added">3619      * of an inline class.</span>
<span class="line-added">3620      */</span>
<span class="line-added">3621     private String toTypeName() {</span>
<span class="line-added">3622         return isInlineClass() &amp;&amp; isIndirectType() ? getName() + &quot;?&quot; : getName();</span>
<span class="line-added">3623     }</span>
<span class="line-added">3624 </span>
3625     /** use serialVersionUID from JDK 1.1 for interoperability */
3626     @java.io.Serial
3627     private static final long serialVersionUID = 3206093459760846163L;
3628 
3629 
3630     /**
3631      * Class Class is special cased within the Serialization Stream Protocol.
3632      *
3633      * A Class instance is written initially into an ObjectOutputStream in the
3634      * following format:
3635      * &lt;pre&gt;
3636      *      {@code TC_CLASS} ClassDescriptor
3637      *      A ClassDescriptor is a special cased serialization of
3638      *      a {@code java.io.ObjectStreamClass} instance.
3639      * &lt;/pre&gt;
3640      * A new handle is generated for the initial time the class descriptor
3641      * is written into the stream. Future references to the class descriptor
3642      * are written as references to the initial class descriptor instance.
3643      *
3644      * @see java.io.ObjectStreamClass
</pre>
<hr />
<pre>
3829                 throw new IllegalArgumentException(
3830                     getName() + &quot; is not an enum type&quot;);
3831             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3832             for (T constant : universe) {
3833                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3834             }
3835             enumConstantDirectory = directory;
3836         }
3837         return directory;
3838     }
3839     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3840 
3841     /**
3842      * Casts an object to the class or interface represented
3843      * by this {@code Class} object.
3844      *
3845      * @param obj the object to be cast
3846      * @return the object after casting, or null if obj is null
3847      *
3848      * @throws ClassCastException if the object is not
<span class="line-modified">3849      * {@code null} and is not assignable to the type T.</span>
<span class="line-added">3850      * @throws NullPointerException if this is not a {@linkplain #isNullableType()</span>
<span class="line-added">3851      * nullable type} and the object is {@code null}</span>
3852      *
3853      * @since 1.5
3854      */
3855     @SuppressWarnings(&quot;unchecked&quot;)
3856     @HotSpotIntrinsicCandidate
3857     public T cast(Object obj) {
<span class="line-added">3858         if (!isNullableType() &amp;&amp; obj == null)</span>
<span class="line-added">3859             throw new NullPointerException(getName() + &quot; is an inline class&quot;);</span>
<span class="line-added">3860 </span>
3861         if (obj != null &amp;&amp; !isInstance(obj))
3862             throw new ClassCastException(cannotCastMsg(obj));
3863         return (T) obj;
3864     }
3865 
3866     private String cannotCastMsg(Object obj) {
3867         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3868     }
3869 
3870     /**
3871      * Casts this {@code Class} object to represent a subclass of the class
3872      * represented by the specified class object.  Checks that the cast
3873      * is valid, and throws a {@code ClassCastException} if it is not.  If
3874      * this method succeeds, it always returns a reference to this {@code Class} object.
3875      *
3876      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3877      * a {@code Class} object to pass it to an API that restricts the
3878      * {@code Class} objects that it is willing to accept.  A cast would
3879      * generate a compile-time warning, as the correctness of the cast
3880      * could not be checked at runtime (because generic types are implemented
</pre>
<hr />
<pre>
4136      *
4137      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4138      * value is an array containing objects representing the uses of interface
4139      * types to specify interfaces directly extended by the interface. The
4140      * order of the objects in the array corresponds to the order of the
4141      * interface types used in the &#39;extends&#39; clause of the declaration of this
4142      * {@code Class} object.
4143      *
4144      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4145      * declaration does not explicitly indicate any annotated superinterfaces,
4146      * the return value is an array of length 0.
4147      *
4148      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4149      * class, an array type, a primitive type, or void, the return value is an
4150      * array of length 0.
4151      *
4152      * @return an array representing the superinterfaces
4153      * @since 1.8
4154      */
4155     public AnnotatedType[] getAnnotatedInterfaces() {
<span class="line-modified">4156         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);</span>
4157     }
4158 
4159     private native Class&lt;?&gt; getNestHost0();
4160 
4161     /**
4162      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4163      * or interface represented by this {@code Class} object belongs.
4164      * Every class and interface is a member of exactly one nest.
4165      * A class or interface that is not recorded as belonging to a nest
4166      * belongs to the nest consisting only of itself, and is the nest
4167      * host.
4168      *
4169      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4170      * primitive types, and {@code void} returns {@code this} to indicate
4171      * that the represented entity belongs to the nest consisting only of
4172      * itself, and is the nest host.
4173      *
4174      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4175      * the nest host, or if this class or interface is not enumerated as
4176      * a member of the nest by the nest host, then it is considered to belong
</pre>
</td>
</tr>
</table>
<center><a href="../io/ObjectStreamClass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
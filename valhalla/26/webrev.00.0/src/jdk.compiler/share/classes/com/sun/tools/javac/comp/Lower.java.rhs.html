<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.stream.Collectors;
  30 
  31 import com.sun.tools.javac.code.*;
  32 import com.sun.tools.javac.code.Kinds.KindSelector;
  33 import com.sun.tools.javac.code.Scope.WriteableScope;
  34 import com.sun.tools.javac.code.Source.Feature;
  35 import com.sun.tools.javac.jvm.*;
  36 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  37 import com.sun.tools.javac.main.Option.PkgInfo;
  38 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  39 import com.sun.tools.javac.tree.*;
  40 import com.sun.tools.javac.util.*;
  41 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  42 import com.sun.tools.javac.util.List;
  43 
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;
  46 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  47 import com.sun.tools.javac.tree.JCTree.*;
  48 import com.sun.tools.javac.code.Type.*;
  49 
  50 import com.sun.tools.javac.jvm.Target;
  51 import com.sun.tools.javac.tree.EndPosTable;
  52 
  53 import static com.sun.tools.javac.code.Flags.*;
  54 import static com.sun.tools.javac.code.Flags.BLOCK;
  55 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  56 import static com.sun.tools.javac.code.TypeTag.*;
  57 import static com.sun.tools.javac.code.Kinds.Kind.*;
  58 import static com.sun.tools.javac.jvm.ByteCodes.*;
  59 import com.sun.tools.javac.tree.JCTree.JCBreak;
  60 import com.sun.tools.javac.tree.JCTree.JCCase;
  61 import com.sun.tools.javac.tree.JCTree.JCExpression;
  62 import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;
  63 import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.LEFT;
  64 import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;
  65 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  66 
  67 /** This pass translates away some syntactic sugar: inner classes,
  68  *  class literals, assertions, foreach loops, etc.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class Lower extends TreeTranslator {
  76     protected static final Context.Key&lt;Lower&gt; lowerKey = new Context.Key&lt;&gt;();
  77 
  78     public static Lower instance(Context context) {
  79         Lower instance = context.get(lowerKey);
  80         if (instance == null)
  81             instance = new Lower(context);
  82         return instance;
  83     }
  84 
  85     private final Names names;
  86     private final Log log;
  87     private final Symtab syms;
  88     private final Resolve rs;
  89     private final Operators operators;
  90     private final Check chk;
  91     private final Attr attr;
  92     private TreeMaker make;
  93     private DiagnosticPosition make_pos;
  94     private final ConstFold cfolder;
  95     private final Target target;
  96     private final Source source;
  97     private final TypeEnvs typeEnvs;
  98     private final Name dollarAssertionsDisabled;
  99     private final Name classDollar;
 100     private final Name dollarCloseResource;
 101     private final Types types;
 102     private final boolean debugLower;
 103     private final boolean disableProtectedAccessors; // experimental
 104     private final PkgInfo pkginfoOpt;
 105 
 106     protected Lower(Context context) {
 107         context.put(lowerKey, this);
 108         names = Names.instance(context);
 109         log = Log.instance(context);
 110         syms = Symtab.instance(context);
 111         rs = Resolve.instance(context);
 112         operators = Operators.instance(context);
 113         chk = Check.instance(context);
 114         attr = Attr.instance(context);
 115         make = TreeMaker.instance(context);
 116         cfolder = ConstFold.instance(context);
 117         target = Target.instance(context);
 118         source = Source.instance(context);
 119         typeEnvs = TypeEnvs.instance(context);
 120         dollarAssertionsDisabled = names.
 121             fromString(target.syntheticNameChar() + &quot;assertionsDisabled&quot;);
 122         classDollar = names.
 123             fromString(&quot;class&quot; + target.syntheticNameChar());
 124         dollarCloseResource = names.
 125             fromString(target.syntheticNameChar() + &quot;closeResource&quot;);
 126 
 127         types = Types.instance(context);
 128         Options options = Options.instance(context);
 129         debugLower = options.isSet(&quot;debuglower&quot;);
 130         pkginfoOpt = PkgInfo.get(options);
 131         disableProtectedAccessors = options.isSet(&quot;disableProtectedAccessors&quot;);
 132     }
 133 
 134     /** The currently enclosing class.
 135      */
 136     ClassSymbol currentClass;
 137 
 138     /** A queue of all translated classes.
 139      */
 140     ListBuffer&lt;JCTree&gt; translated;
 141 
 142     /** Environment for symbol lookup, set by translateTopLevelClass.
 143      */
 144     Env&lt;AttrContext&gt; attrEnv;
 145 
 146     /** A hash table mapping syntax trees to their ending source positions.
 147      */
 148     EndPosTable endPosTable;
 149 
 150 /**************************************************************************
 151  * Global mappings
 152  *************************************************************************/
 153 
 154     /** A hash table mapping local classes to their definitions.
 155      */
 156     Map&lt;ClassSymbol, JCClassDecl&gt; classdefs;
 157 
 158     /** A hash table mapping local classes to a list of pruned trees.
 159      */
 160     public Map&lt;ClassSymbol, List&lt;JCTree&gt;&gt; prunedTree = new WeakHashMap&lt;&gt;();
 161 
 162     /** A hash table mapping virtual accessed symbols in outer subclasses
 163      *  to the actually referred symbol in superclasses.
 164      */
 165     Map&lt;Symbol,Symbol&gt; actualSymbols;
 166 
 167     /** The current method definition.
 168      */
 169     JCMethodDecl currentMethodDef;
 170 
 171     /** The current method symbol.
 172      */
 173     MethodSymbol currentMethodSym;
 174 
 175     /** The currently enclosing outermost class definition.
 176      */
 177     JCClassDecl outermostClassDef;
 178 
 179     /** The currently enclosing outermost member definition.
 180      */
 181     JCTree outermostMemberDef;
 182 
 183     /** A map from local variable symbols to their translation (as per LambdaToMethod).
 184      * This is required when a capturing local class is created from a lambda (in which
 185      * case the captured symbols should be replaced with the translated lambda symbols).
 186      */
 187     Map&lt;Symbol, Symbol&gt; lambdaTranslationMap = null;
 188 
 189     /** A navigator class for assembling a mapping from local class symbols
 190      *  to class definition trees.
 191      *  There is only one case; all other cases simply traverse down the tree.
 192      */
 193     class ClassMap extends TreeScanner {
 194 
 195         /** All encountered class defs are entered into classdefs table.
 196          */
 197         public void visitClassDef(JCClassDecl tree) {
 198             classdefs.put(tree.sym, tree);
 199             super.visitClassDef(tree);
 200         }
 201     }
 202     ClassMap classMap = new ClassMap();
 203 
 204     /** Map a class symbol to its definition.
 205      *  @param c    The class symbol of which we want to determine the definition.
 206      */
 207     JCClassDecl classDef(ClassSymbol c) {
 208         // First lookup the class in the classdefs table.
 209         JCClassDecl def = classdefs.get(c);
 210         if (def == null &amp;&amp; outermostMemberDef != null) {
 211             // If this fails, traverse outermost member definition, entering all
 212             // local classes into classdefs, and try again.
 213             classMap.scan(outermostMemberDef);
 214             def = classdefs.get(c);
 215         }
 216         if (def == null) {
 217             // If this fails, traverse outermost class definition, entering all
 218             // local classes into classdefs, and try again.
 219             classMap.scan(outermostClassDef);
 220             def = classdefs.get(c);
 221         }
 222         return def;
 223     }
 224 
 225     /** A hash table mapping class symbols to lists of free variables.
 226      *  accessed by them. Only free variables of the method immediately containing
 227      *  a class are associated with that class.
 228      */
 229     Map&lt;ClassSymbol,List&lt;VarSymbol&gt;&gt; freevarCache;
 230 
 231     /** A navigator class for collecting the free variables accessed
 232      *  from a local class. There is only one case; all other cases simply
 233      *  traverse down the tree. This class doesn&#39;t deal with the specific
 234      *  of Lower - it&#39;s an abstract visitor that is meant to be reused in
 235      *  order to share the local variable capture logic.
 236      */
 237     abstract class BasicFreeVarCollector extends TreeScanner {
 238 
 239         /** Add all free variables of class c to fvs list
 240          *  unless they are already there.
 241          */
 242         abstract void addFreeVars(ClassSymbol c);
 243 
 244         /** If tree refers to a variable in owner of local class, add it to
 245          *  free variables list.
 246          */
 247         public void visitIdent(JCIdent tree) {
 248             visitSymbol(tree.sym);
 249         }
 250         // where
 251         abstract void visitSymbol(Symbol _sym);
 252 
 253         /** If tree refers to a class instance creation expression
 254          *  add all free variables of the freshly created class.
 255          */
 256         public void visitNewClass(JCNewClass tree) {
 257             ClassSymbol c = (ClassSymbol)tree.constructor.owner;
 258             addFreeVars(c);
 259             super.visitNewClass(tree);
 260         }
 261 
 262         /** If tree refers to a superclass constructor call,
 263          *  add all free variables of the superclass.
 264          */
 265         public void visitApply(JCMethodInvocation tree) {
 266             if (TreeInfo.name(tree.meth) == names._super) {
 267                 addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);
 268             }
 269             super.visitApply(tree);
 270         }
 271 
 272         @Override
 273         public void visitYield(JCYield tree) {
 274             scan(tree.value);
 275         }
 276 
 277     }
 278 
 279     /**
 280      * Lower-specific subclass of {@code BasicFreeVarCollector}.
 281      */
 282     class FreeVarCollector extends BasicFreeVarCollector {
 283 
 284         /** The owner of the local class.
 285          */
 286         Symbol owner;
 287 
 288         /** The local class.
 289          */
 290         ClassSymbol clazz;
 291 
 292         /** The list of owner&#39;s variables accessed from within the local class,
 293          *  without any duplicates.
 294          */
 295         List&lt;VarSymbol&gt; fvs;
 296 
 297         FreeVarCollector(ClassSymbol clazz) {
 298             this.clazz = clazz;
 299             this.owner = clazz.owner;
 300             this.fvs = List.nil();
 301         }
 302 
 303         /** Add free variable to fvs list unless it is already there.
 304          */
 305         private void addFreeVar(VarSymbol v) {
 306             for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail)
 307                 if (l.head == v) return;
 308             fvs = fvs.prepend(v);
 309         }
 310 
 311         @Override
 312         void addFreeVars(ClassSymbol c) {
 313             List&lt;VarSymbol&gt; fvs = freevarCache.get(c);
 314             if (fvs != null) {
 315                 for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail) {
 316                     addFreeVar(l.head);
 317                 }
 318             }
 319         }
 320 
 321         @Override
 322         void visitSymbol(Symbol _sym) {
 323             Symbol sym = _sym;
 324             if (sym.kind == VAR || sym.kind == MTH) {
 325                 if (sym != null &amp;&amp; sym.owner != owner)
 326                     sym = proxies.get(sym);
 327                 if (sym != null &amp;&amp; sym.owner == owner) {
 328                     VarSymbol v = (VarSymbol)sym;
 329                     if (v.getConstValue() == null) {
 330                         addFreeVar(v);
 331                     }
 332                 } else {
 333                     if (outerThisStack.head != null &amp;&amp;
 334                         outerThisStack.head != _sym)
 335                         visitSymbol(outerThisStack.head);
 336                 }
 337             }
 338         }
 339 
 340         /** If tree refers to a class instance creation expression
 341          *  add all free variables of the freshly created class.
 342          */
 343         public void visitNewClass(JCNewClass tree) {
 344             ClassSymbol c = (ClassSymbol)tree.constructor.owner;
 345             if (tree.encl == null &amp;&amp;
 346                 c.hasOuterInstance() &amp;&amp;
 347                 outerThisStack.head != null)
 348                 visitSymbol(outerThisStack.head);
 349             super.visitNewClass(tree);
 350         }
 351 
 352         /** If tree refers to a qualified this or super expression
 353          *  for anything but the current class, add the outer this
 354          *  stack as a free variable.
 355          */
 356         public void visitSelect(JCFieldAccess tree) {
 357             if ((tree.name == names._this || tree.name == names._super) &amp;&amp;
 358                 tree.selected.type.tsym != clazz &amp;&amp;
 359                 outerThisStack.head != null)
 360                 visitSymbol(outerThisStack.head);
 361             super.visitSelect(tree);
 362         }
 363 
 364         /** If tree refers to a superclass constructor call,
 365          *  add all free variables of the superclass.
 366          */
 367         public void visitApply(JCMethodInvocation tree) {
 368             if (TreeInfo.name(tree.meth) == names._super) {
 369                 Symbol constructor = TreeInfo.symbol(tree.meth);
 370                 ClassSymbol c = (ClassSymbol)constructor.owner;
 371                 if (c.hasOuterInstance() &amp;&amp;
 372                     !tree.meth.hasTag(SELECT) &amp;&amp;
 373                     outerThisStack.head != null)
 374                     visitSymbol(outerThisStack.head);
 375             }
 376             super.visitApply(tree);
 377         }
 378 
 379     }
 380 
 381     ClassSymbol ownerToCopyFreeVarsFrom(ClassSymbol c) {
 382         if (!c.isLocal()) {
 383             return null;
 384         }
 385         Symbol currentOwner = c.owner;
 386         while (currentOwner.owner.kind.matches(KindSelector.TYP) &amp;&amp; currentOwner.isLocal()) {
 387             currentOwner = currentOwner.owner;
 388         }
 389         if (currentOwner.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp; c.isSubClass(currentOwner, types)) {
 390             return (ClassSymbol)currentOwner;
 391         }
 392         return null;
 393     }
 394 
 395     /** Return the variables accessed from within a local class, which
 396      *  are declared in the local class&#39; owner.
 397      *  (in reverse order of first access).
 398      */
 399     List&lt;VarSymbol&gt; freevars(ClassSymbol c)  {
 400         List&lt;VarSymbol&gt; fvs = freevarCache.get(c);
 401         if (fvs != null) {
 402             return fvs;
 403         }
 404         if (c.owner.kind.matches(KindSelector.VAL_MTH)) {
 405             FreeVarCollector collector = new FreeVarCollector(c);
 406             collector.scan(classDef(c));
 407             fvs = collector.fvs;
 408             freevarCache.put(c, fvs);
 409             return fvs;
 410         } else {
 411             ClassSymbol owner = ownerToCopyFreeVarsFrom(c);
 412             if (owner != null) {
 413                 fvs = freevarCache.get(owner);
 414                 freevarCache.put(c, fvs);
 415                 return fvs;
 416             } else {
 417                 return List.nil();
 418             }
 419         }
 420     }
 421 
 422     Map&lt;TypeSymbol,EnumMapping&gt; enumSwitchMap = new LinkedHashMap&lt;&gt;();
 423 
 424     EnumMapping mapForEnum(DiagnosticPosition pos, TypeSymbol enumClass) {
 425         EnumMapping map = enumSwitchMap.get(enumClass);
 426         if (map == null)
 427             enumSwitchMap.put(enumClass, map = new EnumMapping(pos, enumClass));
 428         return map;
 429     }
 430 
 431     /** This map gives a translation table to be used for enum
 432      *  switches.
 433      *
 434      *  &lt;p&gt;For each enum that appears as the type of a switch
 435      *  expression, we maintain an EnumMapping to assist in the
 436      *  translation, as exemplified by the following example:
 437      *
 438      *  &lt;p&gt;we translate
 439      *  &lt;pre&gt;
 440      *          switch(colorExpression) {
 441      *          case red: stmt1;
 442      *          case green: stmt2;
 443      *          }
 444      *  &lt;/pre&gt;
 445      *  into
 446      *  &lt;pre&gt;
 447      *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
 448      *          case 1: stmt1;
 449      *          case 2: stmt2
 450      *          }
 451      *  &lt;/pre&gt;
 452      *  with the auxiliary table initialized as follows:
 453      *  &lt;pre&gt;
 454      *          class Outer$0 {
 455      *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 456      *              static {
 457      *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 458      *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 459      *              }
 460      *          }
 461      *  &lt;/pre&gt;
 462      *  class EnumMapping provides mapping data and support methods for this translation.
 463      */
 464     class EnumMapping {
 465         EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {
 466             this.forEnum = forEnum;
 467             this.values = new LinkedHashMap&lt;&gt;();
 468             this.pos = pos;
 469             Name varName = names
 470                 .fromString(target.syntheticNameChar() +
 471                             &quot;SwitchMap&quot; +
 472                             target.syntheticNameChar() +
 473                             names.fromUtf(ClassWriter.externalize(forEnum.type.tsym.flatName())).toString()
 474                             .replace(&#39;/&#39;, &#39;.&#39;)
 475                             .replace(&#39;.&#39;, target.syntheticNameChar()));
 476             ClassSymbol outerCacheClass = outerCacheClass();
 477             this.mapVar = new VarSymbol(STATIC | SYNTHETIC | FINAL,
 478                                         varName,
 479                                         new ArrayType(syms.intType, syms.arrayClass),
 480                                         outerCacheClass);
 481             enterSynthetic(pos, mapVar, outerCacheClass.members());
 482         }
 483 
 484         DiagnosticPosition pos = null;
 485 
 486         // the next value to use
 487         int next = 1; // 0 (unused map elements) go to the default label
 488 
 489         // the enum for which this is a map
 490         final TypeSymbol forEnum;
 491 
 492         // the field containing the map
 493         final VarSymbol mapVar;
 494 
 495         // the mapped values
 496         final Map&lt;VarSymbol,Integer&gt; values;
 497 
 498         JCLiteral forConstant(VarSymbol v) {
 499             Integer result = values.get(v);
 500             if (result == null)
 501                 values.put(v, result = next++);
 502             return make.Literal(result);
 503         }
 504 
 505         // generate the field initializer for the map
 506         void translate() {
 507             make.at(pos.getStartPosition());
 508             JCClassDecl owner = classDef((ClassSymbol)mapVar.owner);
 509 
 510             // synthetic static final int[] $SwitchMap$Color = new int[Color.values().length];
 511             MethodSymbol valuesMethod = lookupMethod(pos,
 512                                                      names.values,
 513                                                      forEnum.type,
 514                                                      List.nil());
 515             JCExpression size = make // Color.values().length
 516                 .Select(make.App(make.QualIdent(valuesMethod)),
 517                         syms.lengthVar);
 518             JCExpression mapVarInit = make
 519                 .NewArray(make.Type(syms.intType), List.of(size), null)
 520                 .setType(new ArrayType(syms.intType, syms.arrayClass));
 521 
 522             // try { $SwitchMap$Color[red.ordinal()] = 1; } catch (java.lang.NoSuchFieldError ex) {}
 523             ListBuffer&lt;JCStatement&gt; stmts = new ListBuffer&lt;&gt;();
 524             Symbol ordinalMethod = lookupMethod(pos,
 525                                                 names.ordinal,
 526                                                 forEnum.type,
 527                                                 List.nil());
 528             List&lt;JCCatch&gt; catcher = List.&lt;JCCatch&gt;nil()
 529                 .prepend(make.Catch(make.VarDef(new VarSymbol(PARAMETER, names.ex,
 530                                                               syms.noSuchFieldErrorType,
 531                                                               syms.noSymbol),
 532                                                 null),
 533                                     make.Block(0, List.nil())));
 534             for (Map.Entry&lt;VarSymbol,Integer&gt; e : values.entrySet()) {
 535                 VarSymbol enumerator = e.getKey();
 536                 Integer mappedValue = e.getValue();
 537                 JCExpression assign = make
 538                     .Assign(make.Indexed(mapVar,
 539                                          make.App(make.Select(make.QualIdent(enumerator),
 540                                                               ordinalMethod))),
 541                             make.Literal(mappedValue))
 542                     .setType(syms.intType);
 543                 JCStatement exec = make.Exec(assign);
 544                 JCStatement _try = make.Try(make.Block(0, List.of(exec)), catcher, null);
 545                 stmts.append(_try);
 546             }
 547 
 548             owner.defs = owner.defs
 549                 .prepend(make.Block(STATIC, stmts.toList()))
 550                 .prepend(make.VarDef(mapVar, mapVarInit));
 551         }
 552     }
 553 
 554 
 555 /**************************************************************************
 556  * Tree building blocks
 557  *************************************************************************/
 558 
 559     /** Equivalent to make.at(pos.getStartPosition()) with side effect of caching
 560      *  pos as make_pos, for use in diagnostics.
 561      **/
 562     TreeMaker make_at(DiagnosticPosition pos) {
 563         make_pos = pos;
 564         return make.at(pos);
 565     }
 566 
 567     /** Make an attributed tree representing a literal. This will be an
 568      *  Ident node in the case of boolean literals, a Literal node in all
 569      *  other cases.
 570      *  @param type       The literal&#39;s type.
 571      *  @param value      The literal&#39;s value.
 572      */
 573     JCExpression makeLit(Type type, Object value) {
 574         return make.Literal(type.getTag(), value).setType(type.constType(value));
 575     }
 576 
 577     /** Make an attributed tree representing null.
 578      */
 579     JCExpression makeNull() {
 580         return makeLit(syms.botType, null);
 581     }
 582 
 583     /** Make an attributed class instance creation expression.
 584      *  @param ctype    The class type.
 585      *  @param args     The constructor arguments.
 586      */
 587     JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args) {
 588         JCNewClass tree = make.NewClass(null,
 589             null, make.QualIdent(ctype.tsym), args, null);
 590         tree.constructor = rs.resolveConstructor(
 591             make_pos, attrEnv, ctype, TreeInfo.types(args), List.nil());
 592         tree.type = ctype;
 593         return tree;
 594     }
 595 
 596     /** Make an attributed unary expression.
 597      *  @param optag    The operators tree tag.
 598      *  @param arg      The operator&#39;s argument.
 599      */
 600     JCUnary makeUnary(JCTree.Tag optag, JCExpression arg) {
 601         JCUnary tree = make.Unary(optag, arg);
 602         tree.operator = operators.resolveUnary(tree, optag, arg.type);
 603         tree.type = tree.operator.type.getReturnType();
 604         return tree;
 605     }
 606 
 607     /** Make an attributed binary expression.
 608      *  @param optag    The operators tree tag.
 609      *  @param lhs      The operator&#39;s left argument.
 610      *  @param rhs      The operator&#39;s right argument.
 611      */
 612     JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
 613         JCBinary tree = make.Binary(optag, lhs, rhs);
 614         tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);
 615         tree.type = tree.operator.type.getReturnType();
 616         return tree;
 617     }
 618 
 619     /** Make an attributed assignop expression.
 620      *  @param optag    The operators tree tag.
 621      *  @param lhs      The operator&#39;s left argument.
 622      *  @param rhs      The operator&#39;s right argument.
 623      */
 624     JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {
 625         JCAssignOp tree = make.Assignop(optag, lhs, rhs);
 626         tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);
 627         tree.type = lhs.type;
 628         return tree;
 629     }
 630 
 631     /** Convert tree into string object, unless it has already a
 632      *  reference type..
 633      */
 634     JCExpression makeString(JCExpression tree) {
 635         if (!tree.type.isPrimitiveOrVoid()) {
 636             return tree;
 637         } else {
 638             Symbol valueOfSym = lookupMethod(tree.pos(),
 639                                              names.valueOf,
 640                                              syms.stringType,
 641                                              List.of(tree.type));
 642             return make.App(make.QualIdent(valueOfSym), List.of(tree));
 643         }
 644     }
 645 
 646     /** Create an empty anonymous class definition and enter and complete
 647      *  its symbol. Return the class definition&#39;s symbol.
 648      *  and create
 649      *  @param flags    The class symbol&#39;s flags
 650      *  @param owner    The class symbol&#39;s owner
 651      */
 652     JCClassDecl makeEmptyClass(long flags, ClassSymbol owner) {
 653         return makeEmptyClass(flags, owner, null, true);
 654     }
 655 
 656     JCClassDecl makeEmptyClass(long flags, ClassSymbol owner, Name flatname,
 657             boolean addToDefs) {
 658         // Create class symbol.
 659         ClassSymbol c = syms.defineClass(names.empty, owner);
 660         if (flatname != null) {
 661             c.flatname = flatname;
 662         } else {
 663             c.flatname = chk.localClassName(c);
 664         }
 665         c.sourcefile = owner.sourcefile;
 666         c.completer = Completer.NULL_COMPLETER;
 667         c.members_field = WriteableScope.create(c);
 668         c.flags_field = flags;
 669         ClassType ctype = (ClassType) c.type;
 670         ctype.supertype_field = syms.objectType;
 671         ctype.interfaces_field = List.nil();
 672 
 673         JCClassDecl odef = classDef(owner);
 674 
 675         // Enter class symbol in owner scope and compiled table.
 676         enterSynthetic(odef.pos(), c, owner.members());
 677         chk.putCompiled(c);
 678 
 679         // Create class definition tree.
 680         JCClassDecl cdef = make.ClassDef(
 681             make.Modifiers(flags), names.empty,
 682             List.nil(),
 683             null, List.nil(), List.nil());
 684         cdef.sym = c;
 685         cdef.type = c.type;
 686 
 687         // Append class definition tree to owner&#39;s definitions.
 688         if (addToDefs) odef.defs = odef.defs.prepend(cdef);
 689         return cdef;
 690     }
 691 
 692 /**************************************************************************
 693  * Symbol manipulation utilities
 694  *************************************************************************/
 695 
 696     /** Enter a synthetic symbol in a given scope, but complain if there was already one there.
 697      *  @param pos           Position for error reporting.
 698      *  @param sym           The symbol.
 699      *  @param s             The scope.
 700      */
 701     private void enterSynthetic(DiagnosticPosition pos, Symbol sym, WriteableScope s) {
 702         s.enter(sym);
 703     }
 704 
 705     /** Create a fresh synthetic name within a given scope - the unique name is
 706      *  obtained by appending &#39;$&#39; chars at the end of the name until no match
 707      *  is found.
 708      *
 709      * @param name base name
 710      * @param s scope in which the name has to be unique
 711      * @return fresh synthetic name
 712      */
 713     private Name makeSyntheticName(Name name, Scope s) {
 714         do {
 715             name = name.append(
 716                     target.syntheticNameChar(),
 717                     names.empty);
 718         } while (lookupSynthetic(name, s) != null);
 719         return name;
 720     }
 721 
 722     /** Check whether synthetic symbols generated during lowering conflict
 723      *  with user-defined symbols.
 724      *
 725      *  @param translatedTrees lowered class trees
 726      */
 727     void checkConflicts(List&lt;JCTree&gt; translatedTrees) {
 728         for (JCTree t : translatedTrees) {
 729             t.accept(conflictsChecker);
 730         }
 731     }
 732 
 733     JCTree.Visitor conflictsChecker = new TreeScanner() {
 734 
 735         TypeSymbol currentClass;
 736 
 737         @Override
 738         public void visitMethodDef(JCMethodDecl that) {
 739             checkConflicts(that.pos(), that.sym, currentClass);
 740             super.visitMethodDef(that);
 741         }
 742 
 743         @Override
 744         public void visitVarDef(JCVariableDecl that) {
 745             if (that.sym.owner.kind == TYP) {
 746                 checkConflicts(that.pos(), that.sym, currentClass);
 747             }
 748             super.visitVarDef(that);
 749         }
 750 
 751         @Override
 752         public void visitClassDef(JCClassDecl that) {
 753             TypeSymbol prevCurrentClass = currentClass;
 754             currentClass = that.sym;
 755             try {
 756                 super.visitClassDef(that);
 757             }
 758             finally {
 759                 currentClass = prevCurrentClass;
 760             }
 761         }
 762 
 763         void checkConflicts(DiagnosticPosition pos, Symbol sym, TypeSymbol c) {
 764             for (Type ct = c.type; ct != Type.noType ; ct = types.supertype(ct)) {
 765                 for (Symbol sym2 : ct.tsym.members().getSymbolsByName(sym.name, NON_RECURSIVE)) {
 766                     // VM allows methods and variables with differing types
 767                     if (sym.kind == sym2.kind &amp;&amp;
 768                         types.isSameType(types.erasure(sym.type), types.erasure(sym2.type)) &amp;&amp;
 769                         sym != sym2 &amp;&amp;
 770                         (sym.flags() &amp; Flags.SYNTHETIC) != (sym2.flags() &amp; Flags.SYNTHETIC) &amp;&amp;
 771                         (sym.flags() &amp; BRIDGE) == 0 &amp;&amp; (sym2.flags() &amp; BRIDGE) == 0) {
 772                         syntheticError(pos, (sym2.flags() &amp; SYNTHETIC) == 0 ? sym2 : sym);
 773                         return;
 774                     }
 775                 }
 776             }
 777         }
 778 
 779         /** Report a conflict between a user symbol and a synthetic symbol.
 780          */
 781         private void syntheticError(DiagnosticPosition pos, Symbol sym) {
 782             if (!sym.type.isErroneous()) {
 783                 log.error(pos, Errors.CannotGenerateClass(sym.location(), Fragments.SyntheticNameConflict(sym, sym.location())));
 784             }
 785         }
 786     };
 787 
 788     /** Look up a synthetic name in a given scope.
 789      *  @param s            The scope.
 790      *  @param name         The name.
 791      */
 792     private Symbol lookupSynthetic(Name name, Scope s) {
 793         Symbol sym = s.findFirst(name);
 794         return (sym==null || (sym.flags()&amp;SYNTHETIC)==0) ? null : sym;
 795     }
 796 
 797     /** Look up a method in a given scope.
 798      */
 799     private MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List&lt;Type&gt; args) {
 800         return rs.resolveInternalMethod(pos, attrEnv, qual, name, args, List.nil());
 801     }
 802 
 803     /** Anon inner classes are used as access constructor tags.
 804      * accessConstructorTag will use an existing anon class if one is available,
 805      * and synthesize a class (with makeEmptyClass) if one is not available.
 806      * However, there is a small possibility that an existing class will not
 807      * be generated as expected if it is inside a conditional with a constant
 808      * expression. If that is found to be the case, create an empty class tree here.
 809      */
 810     private void checkAccessConstructorTags() {
 811         for (List&lt;ClassSymbol&gt; l = accessConstrTags; l.nonEmpty(); l = l.tail) {
 812             ClassSymbol c = l.head;
 813             if (isTranslatedClassAvailable(c))
 814                 continue;
 815             // Create class definition tree.
 816             JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,
 817                     c.outermostClass(), c.flatname, false);
 818             swapAccessConstructorTag(c, cdec.sym);
 819             translated.append(cdec);
 820         }
 821     }
 822     // where
 823     private boolean isTranslatedClassAvailable(ClassSymbol c) {
 824         for (JCTree tree: translated) {
 825             if (tree.hasTag(CLASSDEF)
 826                     &amp;&amp; ((JCClassDecl) tree).sym == c) {
 827                 return true;
 828             }
 829         }
 830         return false;
 831     }
 832 
 833     void swapAccessConstructorTag(ClassSymbol oldCTag, ClassSymbol newCTag) {
 834         for (MethodSymbol methodSymbol : accessConstrs.values()) {
 835             Assert.check(methodSymbol.type.hasTag(METHOD));
 836             MethodType oldMethodType =
 837                     (MethodType)methodSymbol.type;
 838             if (oldMethodType.argtypes.head.tsym == oldCTag)
 839                 methodSymbol.type =
 840                     types.createMethodTypeWithParameters(oldMethodType,
 841                         oldMethodType.getParameterTypes().tail
 842                             .prepend(newCTag.erasure(types)));
 843         }
 844     }
 845 
 846 /**************************************************************************
 847  * Access methods
 848  *************************************************************************/
 849 
 850     /** A mapping from symbols to their access numbers.
 851      */
 852     private Map&lt;Symbol,Integer&gt; accessNums;
 853 
 854     /** A mapping from symbols to an array of access symbols, indexed by
 855      *  access code.
 856      */
 857     private Map&lt;Symbol,MethodSymbol[]&gt; accessSyms;
 858 
 859     /** A mapping from (constructor) symbols to access constructor symbols.
 860      */
 861     private Map&lt;Symbol,MethodSymbol&gt; accessConstrs;
 862 
 863     /** A list of all class symbols used for access constructor tags.
 864      */
 865     private List&lt;ClassSymbol&gt; accessConstrTags;
 866 
 867     /** A queue for all accessed symbols.
 868      */
 869     private ListBuffer&lt;Symbol&gt; accessed;
 870 
 871     /** return access code for identifier,
 872      *  @param tree     The tree representing the identifier use.
 873      *  @param enclOp   The closest enclosing operation node of tree,
 874      *                  null if tree is not a subtree of an operation.
 875      */
 876     private static int accessCode(JCTree tree, JCTree enclOp) {
 877         if (enclOp == null)
 878             return AccessCode.DEREF.code;
 879         else if (enclOp.hasTag(ASSIGN) &amp;&amp;
 880                  tree == TreeInfo.skipParens(((JCAssign) enclOp).lhs))
 881             return AccessCode.ASSIGN.code;
 882         else if (enclOp.hasTag(WITHFIELD) &amp;&amp;
 883                 tree == TreeInfo.skipParens(((JCWithField) enclOp).field))
 884             return AccessCode.WITHFIELD.code;
 885         else if ((enclOp.getTag().isIncOrDecUnaryOp() || enclOp.getTag().isAssignop()) &amp;&amp;
 886                 tree == TreeInfo.skipParens(((JCOperatorExpression) enclOp).getOperand(LEFT)))
 887             return (((JCOperatorExpression) enclOp).operator).getAccessCode(enclOp.getTag());
 888         else
 889             return AccessCode.DEREF.code;
 890     }
 891 
 892     /** Return binary operator that corresponds to given access code.
 893      */
 894     private OperatorSymbol binaryAccessOperator(int acode, Tag tag) {
 895         return operators.lookupBinaryOp(op -&gt; op.getAccessCode(tag) == acode);
 896     }
 897 
 898     /** Return tree tag for assignment operation corresponding
 899      *  to given binary operator.
 900      */
 901     private static JCTree.Tag treeTag(OperatorSymbol operator) {
 902         switch (operator.opcode) {
 903         case ByteCodes.ior: case ByteCodes.lor:
 904             return BITOR_ASG;
 905         case ByteCodes.ixor: case ByteCodes.lxor:
 906             return BITXOR_ASG;
 907         case ByteCodes.iand: case ByteCodes.land:
 908             return BITAND_ASG;
 909         case ByteCodes.ishl: case ByteCodes.lshl:
 910         case ByteCodes.ishll: case ByteCodes.lshll:
 911             return SL_ASG;
 912         case ByteCodes.ishr: case ByteCodes.lshr:
 913         case ByteCodes.ishrl: case ByteCodes.lshrl:
 914             return SR_ASG;
 915         case ByteCodes.iushr: case ByteCodes.lushr:
 916         case ByteCodes.iushrl: case ByteCodes.lushrl:
 917             return USR_ASG;
 918         case ByteCodes.iadd: case ByteCodes.ladd:
 919         case ByteCodes.fadd: case ByteCodes.dadd:
 920         case ByteCodes.string_add:
 921             return PLUS_ASG;
 922         case ByteCodes.isub: case ByteCodes.lsub:
 923         case ByteCodes.fsub: case ByteCodes.dsub:
 924             return MINUS_ASG;
 925         case ByteCodes.imul: case ByteCodes.lmul:
 926         case ByteCodes.fmul: case ByteCodes.dmul:
 927             return MUL_ASG;
 928         case ByteCodes.idiv: case ByteCodes.ldiv:
 929         case ByteCodes.fdiv: case ByteCodes.ddiv:
 930             return DIV_ASG;
 931         case ByteCodes.imod: case ByteCodes.lmod:
 932         case ByteCodes.fmod: case ByteCodes.dmod:
 933             return MOD_ASG;
 934         default:
 935             throw new AssertionError();
 936         }
 937     }
 938 
 939     /** The name of the access method with number `anum&#39; and access code `acode&#39;.
 940      */
 941     Name accessName(int anum, int acode) {
 942         return names.fromString(
 943             &quot;access&quot; + target.syntheticNameChar() + anum + acode / 10 + acode % 10);
 944     }
 945 
 946     /** Return access symbol for a private or protected symbol from an inner class.
 947      *  @param sym        The accessed private symbol.
 948      *  @param tree       The accessing tree.
 949      *  @param enclOp     The closest enclosing operation node of tree,
 950      *                    null if tree is not a subtree of an operation.
 951      *  @param protAccess Is access to a protected symbol in another
 952      *                    package?
 953      *  @param refSuper   Is access via a (qualified) C.super?
 954      */
 955     MethodSymbol accessSymbol(Symbol sym, JCTree tree, JCTree enclOp,
 956                               boolean protAccess, boolean refSuper) {
 957         ClassSymbol accOwner = refSuper &amp;&amp; protAccess
 958             // For access via qualified super (T.super.x), place the
 959             // access symbol on T.
 960             ? (ClassSymbol)((JCFieldAccess) tree).selected.type.tsym
 961             // Otherwise pretend that the owner of an accessed
 962             // protected symbol is the enclosing class of the current
 963             // class which is a subclass of the symbol&#39;s owner.
 964             : accessClass(sym, protAccess, tree);
 965 
 966         Symbol vsym = sym;
 967         if (sym.owner != accOwner) {
 968             vsym = sym.clone(accOwner);
 969             actualSymbols.put(vsym, sym);
 970         }
 971 
 972         Integer anum              // The access number of the access method.
 973             = accessNums.get(vsym);
 974         if (anum == null) {
 975             anum = accessed.length();
 976             accessNums.put(vsym, anum);
 977             accessSyms.put(vsym, new MethodSymbol[AccessCode.numberOfAccessCodes]);
 978             accessed.append(vsym);
 979             // System.out.println(&quot;accessing &quot; + vsym + &quot; in &quot; + vsym.location());
 980         }
 981 
 982         int acode;                // The access code of the access method.
 983         List&lt;Type&gt; argtypes;      // The argument types of the access method.
 984         Type restype;             // The result type of the access method.
 985         List&lt;Type&gt; thrown;        // The thrown exceptions of the access method.
 986         switch (vsym.kind) {
 987         case VAR:
 988             acode = accessCode(tree, enclOp);
 989             if (acode &gt;= AccessCode.FIRSTASGOP.code) {
 990                 OperatorSymbol operator = binaryAccessOperator(acode, enclOp.getTag());
 991                 if (operator.opcode == string_add)
 992                     argtypes = List.of(syms.objectType);
 993                 else
 994                     argtypes = operator.type.getParameterTypes().tail;
 995             } else if (acode == AccessCode.ASSIGN.code || acode == AccessCode.WITHFIELD.code)
 996                 argtypes = List.of(vsym.erasure(types));
 997             else
 998                 argtypes = List.nil();
 999             restype = acode == AccessCode.WITHFIELD.code ? vsym.owner.erasure(types) : vsym.erasure(types);
1000             thrown = List.nil();
1001             break;
1002         case MTH:
1003             acode = AccessCode.DEREF.code;
1004             argtypes = vsym.erasure(types).getParameterTypes();
1005             restype = vsym.erasure(types).getReturnType();
1006             thrown = vsym.type.getThrownTypes();
1007             break;
1008         default:
1009             throw new AssertionError();
1010         }
1011 
1012         // For references via qualified super, increment acode by one,
1013         // making it odd.
1014         if (protAccess &amp;&amp; refSuper) acode++;
1015 
1016         // Instance access methods get instance as first parameter.
1017         // For protected symbols this needs to be the instance as a member
1018         // of the type containing the accessed symbol, not the class
1019         // containing the access method.
1020         if ((vsym.flags() &amp; STATIC) == 0) {
1021             argtypes = argtypes.prepend(vsym.owner.erasure(types));
1022         }
1023         MethodSymbol[] accessors = accessSyms.get(vsym);
1024         MethodSymbol accessor = accessors[acode];
1025         if (accessor == null) {
1026             accessor = new MethodSymbol(
1027                 STATIC | SYNTHETIC | (accOwner.isInterface() ? PUBLIC : 0),
1028                 accessName(anum.intValue(), acode),
1029                 new MethodType(argtypes, restype, thrown, syms.methodClass),
1030                 accOwner);
1031             enterSynthetic(tree.pos(), accessor, accOwner.members());
1032             accessors[acode] = accessor;
1033         }
1034         return accessor;
1035     }
1036 
1037     /** The qualifier to be used for accessing a symbol in an outer class.
1038      *  This is either C.sym or C.this.sym, depending on whether or not
1039      *  sym is static.
1040      *  @param sym   The accessed symbol.
1041      */
1042     JCExpression accessBase(DiagnosticPosition pos, Symbol sym) {
1043         return (sym.flags() &amp; STATIC) != 0
1044             ? access(make.at(pos.getStartPosition()).QualIdent(sym.owner))
1045             : makeOwnerThis(pos, sym, true);
1046     }
1047 
1048     /** Do we need an access method to reference private symbol?
1049      */
1050     boolean needsPrivateAccess(Symbol sym) {
1051         if (target.hasNestmateAccess()) {
1052             return false;
1053         }
1054         if ((sym.flags() &amp; PRIVATE) == 0 || sym.owner == currentClass) {
1055             return false;
1056         } else if (sym.name == names.init &amp;&amp; sym.owner.isLocal()) {
1057             // private constructor in local class: relax protection
1058             sym.flags_field &amp;= ~PRIVATE;
1059             return false;
1060         } else {
1061             return true;
1062         }
1063     }
1064 
1065     /** Do we need an access method to reference symbol in other package?
1066      */
1067     boolean needsProtectedAccess(Symbol sym, JCTree tree) {
1068         if (disableProtectedAccessors) return false;
1069         if ((sym.flags() &amp; PROTECTED) == 0 ||
1070             sym.owner.owner == currentClass.owner || // fast special case
1071             sym.packge() == currentClass.packge())
1072             return false;
1073         if (!currentClass.isSubClass(sym.owner, types))
1074             return true;
1075         if ((sym.flags() &amp; STATIC) != 0 ||
1076             !tree.hasTag(SELECT) ||
1077             TreeInfo.name(((JCFieldAccess) tree).selected) == names._super)
1078             return false;
1079         return !((JCFieldAccess) tree).selected.type.tsym.isSubClass(currentClass, types);
1080     }
1081 
1082     /** The class in which an access method for given symbol goes.
1083      *  @param sym        The access symbol
1084      *  @param protAccess Is access to a protected symbol in another
1085      *                    package?
1086      */
1087     ClassSymbol accessClass(Symbol sym, boolean protAccess, JCTree tree) {
1088         if (protAccess) {
1089             Symbol qualifier = null;
1090             ClassSymbol c = currentClass;
1091             if (tree.hasTag(SELECT) &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
1092                 qualifier = ((JCFieldAccess) tree).selected.type.tsym;
1093                 while (!qualifier.isSubClass(c, types)) {
1094                     c = c.owner.enclClass();
1095                 }
1096                 return c;
1097             } else {
1098                 while (!c.isSubClass(sym.owner, types)) {
1099                     c = c.owner.enclClass();
1100                 }
1101             }
1102             return c;
1103         } else {
1104             // the symbol is private
1105             return sym.owner.enclClass();
1106         }
1107     }
1108 
1109     private void addPrunedInfo(JCTree tree) {
1110         List&lt;JCTree&gt; infoList = prunedTree.get(currentClass);
1111         infoList = (infoList == null) ? List.of(tree) : infoList.prepend(tree);
1112         prunedTree.put(currentClass, infoList);
1113     }
1114 
1115     /** Ensure that identifier is accessible, return tree accessing the identifier.
1116      *  @param sym      The accessed symbol.
1117      *  @param tree     The tree referring to the symbol.
1118      *  @param enclOp   The closest enclosing operation node of tree,
1119      *                  null if tree is not a subtree of an operation.
1120      *  @param refSuper Is access via a (qualified) C.super?
1121      */
1122     JCExpression access(Symbol sym, JCExpression tree, JCExpression enclOp, boolean refSuper) {
1123         // Access a free variable via its proxy, or its proxy&#39;s proxy
1124         while (sym.kind == VAR &amp;&amp; sym.owner.kind == MTH &amp;&amp;
1125             sym.owner.enclClass() != currentClass) {
1126             // A constant is replaced by its constant value.
1127             Object cv = ((VarSymbol)sym).getConstValue();
1128             if (cv != null) {
1129                 make.at(tree.pos);
1130                 return makeLit(sym.type, cv);
1131             }
1132             if (lambdaTranslationMap != null &amp;&amp; lambdaTranslationMap.get(sym) != null) {
1133                 return make.at(tree.pos).Ident(lambdaTranslationMap.get(sym));
1134             } else {
1135                 // Otherwise replace the variable by its proxy.
1136                 sym = proxies.get(sym);
1137                 Assert.check(sym != null &amp;&amp; (sym.flags_field &amp; FINAL) != 0);
1138                 tree = make.at(tree.pos).Ident(sym);
1139             }
1140         }
1141         JCExpression base = (tree.hasTag(SELECT)) ? ((JCFieldAccess) tree).selected : null;
1142         switch (sym.kind) {
1143         case TYP:
1144             if (sym.owner.kind != PCK) {
1145                 // Convert type idents to
1146                 // &lt;flat name&gt; or &lt;package name&gt; . &lt;flat name&gt;
1147                 Name flatname = Convert.shortName(sym.flatName());
1148                 while (base != null &amp;&amp;
1149                        TreeInfo.symbol(base) != null &amp;&amp;
1150                        TreeInfo.symbol(base).kind != PCK) {
1151                     base = (base.hasTag(SELECT))
1152                         ? ((JCFieldAccess) base).selected
1153                         : null;
1154                 }
1155                 if (tree.hasTag(IDENT)) {
1156                     ((JCIdent) tree).name = flatname;
1157                 } else if (base == null) {
1158                     tree = make.at(tree.pos).Ident(sym);
1159                     ((JCIdent) tree).name = flatname;
1160                 } else {
1161                     ((JCFieldAccess) tree).selected = base;
1162                     ((JCFieldAccess) tree).name = flatname;
1163                 }
1164             }
1165             break;
1166         case MTH: case VAR:
1167             if (sym.owner.kind == TYP) {
1168 
1169                 // Access methods are required for
1170                 //  - private members,
1171                 //  - protected members in a superclass of an
1172                 //    enclosing class contained in another package.
1173                 //  - all non-private members accessed via a qualified super.
1174                 boolean protAccess = refSuper &amp;&amp; !needsPrivateAccess(sym)
1175                     || needsProtectedAccess(sym, tree);
1176                 boolean accReq = protAccess || needsPrivateAccess(sym);
1177 
1178                 // A base has to be supplied for
1179                 //  - simple identifiers accessing variables in outer classes.
1180                 boolean baseReq =
1181                     base == null &amp;&amp;
1182                     sym.owner != syms.predefClass &amp;&amp;
1183                     !sym.isMemberOf(currentClass, types);
1184 
1185                 if (accReq || baseReq) {
1186                     make.at(tree.pos);
1187 
1188                     // Constants are replaced by their constant value.
1189                     if (sym.kind == VAR) {
1190                         Object cv = ((VarSymbol)sym).getConstValue();
1191                         if (cv != null) {
1192                             addPrunedInfo(tree);
1193                             return makeLit(sym.type, cv);
1194                         }
1195                     }
1196 
1197                     // Private variables and methods are replaced by calls
1198                     // to their access methods.
1199                     if (accReq) {
1200                         List&lt;JCExpression&gt; args = List.nil();
1201                         if ((sym.flags() &amp; STATIC) == 0) {
1202                             // Instance access methods get instance
1203                             // as first parameter.
1204                             if (base == null)
1205                                 base = makeOwnerThis(tree.pos(), sym, true);
1206                             args = args.prepend(base);
1207                             base = null;   // so we don&#39;t duplicate code
1208                         }
1209                         Symbol access = accessSymbol(sym, tree,
1210                                                      enclOp, protAccess,
1211                                                      refSuper);
1212                         JCExpression receiver = make.Select(
1213                             base != null ? base : make.QualIdent(access.owner),
1214                             access);
1215                         return make.App(receiver, args);
1216 
1217                     // Other accesses to members of outer classes get a
1218                     // qualifier.
1219                     } else if (baseReq) {
1220                         return make.at(tree.pos).Select(
1221                             accessBase(tree.pos(), sym), sym).setType(tree.type);
1222                     }
1223                 }
1224             } else if (sym.owner.kind == MTH &amp;&amp; lambdaTranslationMap != null) {
1225                 //sym is a local variable - check the lambda translation map to
1226                 //see if sym has been translated to something else in the current
1227                 //scope (by LambdaToMethod)
1228                 Symbol translatedSym = lambdaTranslationMap.get(sym);
1229                 if (translatedSym != null) {
1230                     tree = make.at(tree.pos).Ident(translatedSym);
1231                 }
1232             }
1233         }
1234         return tree;
1235     }
1236 
1237     /** Ensure that identifier is accessible, return tree accessing the identifier.
1238      *  @param tree     The identifier tree.
1239      */
1240     JCExpression access(JCExpression tree) {
1241         Symbol sym = TreeInfo.symbol(tree);
1242         return sym == null ? tree : access(sym, tree, null, false);
1243     }
1244 
1245     /** Return access constructor for a private constructor,
1246      *  or the constructor itself, if no access constructor is needed.
1247      *  @param pos       The position to report diagnostics, if any.
1248      *  @param constr    The private constructor.
1249      */
1250     Symbol accessConstructor(DiagnosticPosition pos, Symbol constr) {
1251         if (needsPrivateAccess(constr)) {
1252             ClassSymbol accOwner = constr.owner.enclClass();
1253             MethodSymbol aconstr = accessConstrs.get(constr);
1254             if (aconstr == null) {
1255                 List&lt;Type&gt; argtypes = constr.type.getParameterTypes();
1256                 if ((accOwner.flags_field &amp; ENUM) != 0)
1257                     argtypes = argtypes
1258                         .prepend(syms.intType)
1259                         .prepend(syms.stringType);
1260                 aconstr = new MethodSymbol(
1261                     SYNTHETIC,
1262                     names.init,
1263                     new MethodType(
1264                         argtypes.append(
1265                             accessConstructorTag().erasure(types)),
1266                         constr.type.getReturnType(),
1267                         constr.type.getThrownTypes(),
1268                         syms.methodClass),
1269                     accOwner);
1270                 enterSynthetic(pos, aconstr, accOwner.members());
1271                 accessConstrs.put(constr, aconstr);
1272                 accessed.append(constr);
1273             }
1274             return aconstr;
1275         } else {
1276             return constr;
1277         }
1278     }
1279 
1280     /** Return an anonymous class nested in this toplevel class.
1281      */
1282     ClassSymbol accessConstructorTag() {
1283         ClassSymbol topClass = currentClass.outermostClass();
1284         ModuleSymbol topModle = topClass.packge().modle;
1285         for (int i = 1; ; i++) {
1286             Name flatname = names.fromString(&quot;&quot; + topClass.getQualifiedName() +
1287                                             target.syntheticNameChar() +
1288                                             i);
1289             ClassSymbol ctag = chk.getCompiled(topModle, flatname);
1290             if (ctag == null)
1291                 ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass).sym;
1292             else if (!ctag.isAnonymous())
1293                 continue;
1294             // keep a record of all tags, to verify that all are generated as required
1295             accessConstrTags = accessConstrTags.prepend(ctag);
1296             return ctag;
1297         }
1298     }
1299 
1300     /** Add all required access methods for a private symbol to enclosing class.
1301      *  @param sym       The symbol.
1302      */
1303     void makeAccessible(Symbol sym) {
1304         JCClassDecl cdef = classDef(sym.owner.enclClass());
1305         if (cdef == null) Assert.error(&quot;class def not found: &quot; + sym + &quot; in &quot; + sym.owner);
1306         if (sym.name == names.init) {
1307             cdef.defs = cdef.defs.prepend(
1308                 accessConstructorDef(cdef.pos, sym, accessConstrs.get(sym)));
1309         } else {
1310             MethodSymbol[] accessors = accessSyms.get(sym);
1311             for (int i = 0; i &lt; AccessCode.numberOfAccessCodes; i++) {
1312                 if (accessors[i] != null)
1313                     cdef.defs = cdef.defs.prepend(
1314                         accessDef(cdef.pos, sym, accessors[i], i));
1315             }
1316         }
1317     }
1318 
1319     /** Construct definition of an access method.
1320      *  @param pos        The source code position of the definition.
1321      *  @param vsym       The private or protected symbol.
1322      *  @param accessor   The access method for the symbol.
1323      *  @param acode      The access code.
1324      */
1325     JCTree accessDef(int pos, Symbol vsym, MethodSymbol accessor, int acode) {
1326 //      System.err.println(&quot;access &quot; + vsym + &quot; with &quot; + accessor);//DEBUG
1327         currentClass = vsym.owner.enclClass();
1328         make.at(pos);
1329         JCMethodDecl md = make.MethodDef(accessor, null);
1330 
1331         // Find actual symbol
1332         Symbol sym = actualSymbols.get(vsym);
1333         if (sym == null) sym = vsym;
1334 
1335         JCExpression ref;           // The tree referencing the private symbol.
1336         List&lt;JCExpression&gt; args;    // Any additional arguments to be passed along.
1337         if ((sym.flags() &amp; STATIC) != 0) {
1338             ref = make.Ident(sym);
1339             args = make.Idents(md.params);
1340         } else {
1341             JCExpression site = make.Ident(md.params.head);
1342             if (acode % 2 != 0) {
1343                 //odd access codes represent qualified super accesses - need to
1344                 //emit reference to the direct superclass, even if the referred
1345                 //member is from an indirect superclass (JLS 13.1)
1346                 site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));
1347             }
1348             ref = make.Select(site, sym);
1349             args = make.Idents(md.params.tail);
1350         }
1351         JCStatement stat;          // The statement accessing the private symbol.
1352         if (sym.kind == VAR) {
1353             // Normalize out all odd access codes by taking floor modulo 2:
1354             int acode1 = acode - (acode &amp; 1);
1355 
1356             JCExpression expr;      // The access method&#39;s return value.
1357             AccessCode aCode = AccessCode.getFromCode(acode1);
1358             switch (aCode) {
1359             case DEREF:
1360                 expr = ref;
1361                 break;
1362             case ASSIGN:
1363                 expr = make.Assign(ref, args.head);
1364                 break;
1365             case PREINC: case POSTINC: case PREDEC: case POSTDEC:
1366                 expr = makeUnary(aCode.tag, ref);
1367                 break;
1368             case WITHFIELD:
1369                 expr = make.WithField(ref, args.head);
1370                 break;
1371             default:
1372                 expr = make.Assignop(
1373                     treeTag(binaryAccessOperator(acode1, JCTree.Tag.NO_TAG)), ref, args.head);
1374                 ((JCAssignOp) expr).operator = binaryAccessOperator(acode1, JCTree.Tag.NO_TAG);
1375             }
1376             stat = make.Return(expr.setType(aCode == AccessCode.WITHFIELD ? sym.owner.type : sym.type));
1377         } else {
1378             stat = make.Call(make.App(ref, args));
1379         }
1380         md.body = make.Block(0, List.of(stat));
1381 
1382         // Make sure all parameters, result types and thrown exceptions
1383         // are accessible.
1384         for (List&lt;JCVariableDecl&gt; l = md.params; l.nonEmpty(); l = l.tail)
1385             l.head.vartype = access(l.head.vartype);
1386         md.restype = access(md.restype);
1387         for (List&lt;JCExpression&gt; l = md.thrown; l.nonEmpty(); l = l.tail)
1388             l.head = access(l.head);
1389 
1390         return md;
1391     }
1392 
1393     /** Construct definition of an access constructor.
1394      *  @param pos        The source code position of the definition.
1395      *  @param constr     The private constructor.
1396      *  @param accessor   The access method for the constructor.
1397      */
1398     JCTree accessConstructorDef(int pos, Symbol constr, MethodSymbol accessor) {
1399         make.at(pos);
1400         JCMethodDecl md = make.MethodDef(accessor,
1401                                       accessor.externalType(types),
1402                                       null);
1403         JCIdent callee = make.Ident(names._this);
1404         callee.sym = constr;
1405         callee.type = constr.type;
1406         md.body =
1407             make.Block(0, List.of(
1408                 make.Call(
1409                     make.App(
1410                         callee,
1411                         make.Idents(md.params.reverse().tail.reverse())))));
1412         return md;
1413     }
1414 
1415 /**************************************************************************
1416  * Free variables proxies and this$n
1417  *************************************************************************/
1418 
1419     /** A map which allows to retrieve the translated proxy variable for any given symbol of an
1420      *  enclosing scope that is accessed (the accessed symbol could be the synthetic &#39;this$n&#39; symbol).
1421      *  Inside a constructor, the map temporarily overrides entries corresponding to proxies and any
1422      *  &#39;this$n&#39; symbols, where they represent the constructor parameters.
1423      */
1424     Map&lt;Symbol, Symbol&gt; proxies;
1425 
1426     /** A scope containing all unnamed resource variables/saved
1427      *  exception variables for translated TWR blocks
1428      */
1429     WriteableScope twrVars;
1430 
1431     /** A stack containing the this$n field of the currently translated
1432      *  classes (if needed) in innermost first order.
1433      *  Inside a constructor, proxies and any this$n symbol are duplicated
1434      *  in an additional innermost scope, where they represent the constructor
1435      *  parameters.
1436      */
1437     List&lt;VarSymbol&gt; outerThisStack;
1438 
1439     /** The name of a free variable proxy.
1440      */
1441     Name proxyName(Name name, int index) {
1442         Name proxyName = names.fromString(&quot;val&quot; + target.syntheticNameChar() + name);
1443         if (index &gt; 0) {
1444             proxyName = proxyName.append(names.fromString(&quot;&quot; + target.syntheticNameChar() + index));
1445         }
1446         return proxyName;
1447     }
1448 
1449     /** Proxy definitions for all free variables in given list, in reverse order.
1450      *  @param pos        The source code position of the definition.
1451      *  @param freevars   The free variables.
1452      *  @param owner      The class in which the definitions go.
1453      */
1454     List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner) {
1455         return freevarDefs(pos, freevars, owner, 0);
1456     }
1457 
1458     List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner,
1459             long additionalFlags) {
1460         long flags = FINAL | SYNTHETIC | additionalFlags;
1461         List&lt;JCVariableDecl&gt; defs = List.nil();
1462         Set&lt;Name&gt; proxyNames = new HashSet&lt;&gt;();
1463         for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail) {
1464             VarSymbol v = l.head;
1465             int index = 0;
1466             Name proxyName;
1467             do {
1468                 proxyName = proxyName(v.name, index++);
1469             } while (!proxyNames.add(proxyName));
1470             final Type type = v.erasure(types);
1471             VarSymbol proxy = new VarSymbol(
1472                 flags, proxyName, type, owner);
1473             proxies.put(v, proxy);
1474             JCVariableDecl vd = make.at(pos).VarDef(proxy, null);
1475             vd.vartype = access(vd.vartype);
1476             defs = defs.prepend(vd);
1477         }
1478         return defs;
1479     }
1480 
1481     /** The name of a this$n field
1482      *  @param type   The class referenced by the this$n field
1483      */
1484     Name outerThisName(Type type, Symbol owner) {
1485         Type t = type.getEnclosingType();
1486         int nestingLevel = 0;
1487         while (t.hasTag(CLASS)) {
1488             t = t.getEnclosingType();
1489             nestingLevel++;
1490         }
1491         Name result = names.fromString(&quot;this&quot; + target.syntheticNameChar() + nestingLevel);
1492         while (owner.kind == TYP &amp;&amp; ((ClassSymbol)owner).members().findFirst(result) != null)
1493             result = names.fromString(result.toString() + target.syntheticNameChar());
1494         return result;
1495     }
1496 
1497     private VarSymbol makeOuterThisVarSymbol(Symbol owner, long flags) {
1498         Type target = types.erasure(owner.enclClass().type.getEnclosingType());
1499         VarSymbol outerThis =
1500             new VarSymbol(flags, outerThisName(target, owner), target, owner);
1501         outerThisStack = outerThisStack.prepend(outerThis);
1502         return outerThis;
1503     }
1504 
1505     private JCVariableDecl makeOuterThisVarDecl(int pos, VarSymbol sym) {
1506         JCVariableDecl vd = make.at(pos).VarDef(sym, null);
1507         vd.vartype = access(vd.vartype);
1508         return vd;
1509     }
1510 
1511     /** Definition for this$n field.
1512      *  @param pos        The source code position of the definition.
1513      *  @param owner      The method in which the definition goes.
1514      */
1515     JCVariableDecl outerThisDef(int pos, MethodSymbol owner) {
1516         ClassSymbol c = owner.enclClass();
1517         boolean isMandated =
1518             // Anonymous constructors
1519             (owner.isConstructor() &amp;&amp; owner.isAnonymous()) ||
1520             // Constructors of non-private inner member classes
1521             (owner.isConstructor() &amp;&amp; c.isInner() &amp;&amp;
1522              !c.isPrivate() &amp;&amp; !c.isStatic());
1523         long flags =
1524             FINAL | (isMandated ? MANDATED : SYNTHETIC) | PARAMETER;
1525         VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);
1526         owner.extraParams = owner.extraParams.prepend(outerThis);
1527         return makeOuterThisVarDecl(pos, outerThis);
1528     }
1529 
1530     /** Definition for this$n field.
1531      *  @param pos        The source code position of the definition.
1532      *  @param owner      The class in which the definition goes.
1533      */
1534     JCVariableDecl outerThisDef(int pos, ClassSymbol owner) {
1535         Type target = types.erasure(owner.enclClass().type.getEnclosingType());
1536         long flags = FINAL | SYNTHETIC;
1537         VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);
1538         return makeOuterThisVarDecl(pos, outerThis);
1539     }
1540 
1541     /** Return a list of trees that load the free variables in given list,
1542      *  in reverse order.
1543      *  @param pos          The source code position to be used for the trees.
1544      *  @param freevars     The list of free variables.
1545      */
1546     List&lt;JCExpression&gt; loadFreevars(DiagnosticPosition pos, List&lt;VarSymbol&gt; freevars) {
1547         List&lt;JCExpression&gt; args = List.nil();
1548         for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail)
1549             args = args.prepend(loadFreevar(pos, l.head));
1550         return args;
1551     }
1552 //where
1553         JCExpression loadFreevar(DiagnosticPosition pos, VarSymbol v) {
1554             return access(v, make.at(pos).Ident(v), null, false);
1555         }
1556 
1557     /** Construct a tree simulating the expression {@code C.this}.
1558      *  @param pos           The source code position to be used for the tree.
1559      *  @param c             The qualifier class.
1560      */
1561     JCExpression makeThis(DiagnosticPosition pos, TypeSymbol c) {
1562         if (currentClass == c) {
1563             // in this case, `this&#39; works fine
1564             return make.at(pos).This(c.erasure(types));
1565         } else {
1566             // need to go via this$n
1567             return makeOuterThis(pos, c);
1568         }
1569     }
1570 
1571     /**
1572      * Optionally replace a try statement with the desugaring of a
1573      * try-with-resources statement.  The canonical desugaring of
1574      *
1575      * try ResourceSpecification
1576      *   Block
1577      *
1578      * is
1579      *
1580      * {
1581      *   final VariableModifiers_minus_final R #resource = Expression;
1582      *
1583      *   try ResourceSpecificationtail
1584      *     Block
1585      *   } body-only-finally {
1586      *     if (#resource != null) //nullcheck skipped if Expression is provably non-null
1587      *         #resource.close();
1588      *   } catch (Throwable #primaryException) {
1589      *       if (#resource != null) //nullcheck skipped if Expression is provably non-null
1590      *           try {
1591      *               #resource.close();
1592      *           } catch (Throwable #suppressedException) {
1593      *              #primaryException.addSuppressed(#suppressedException);
1594      *           }
1595      *       throw #primaryException;
1596      *   }
1597      * }
1598      *
1599      * @param tree  The try statement to inspect.
1600      * @return A a desugared try-with-resources tree, or the original
1601      * try block if there are no resources to manage.
1602      */
1603     JCTree makeTwrTry(JCTry tree) {
1604         make_at(tree.pos());
1605         twrVars = twrVars.dup();
1606         JCBlock twrBlock = makeTwrBlock(tree.resources, tree.body, 0);
1607         if (tree.catchers.isEmpty() &amp;&amp; tree.finalizer == null)
1608             result = translate(twrBlock);
1609         else
1610             result = translate(make.Try(twrBlock, tree.catchers, tree.finalizer));
1611         twrVars = twrVars.leave();
1612         return result;
1613     }
1614 
1615     private JCBlock makeTwrBlock(List&lt;JCTree&gt; resources, JCBlock block, int depth) {
1616         if (resources.isEmpty())
1617             return block;
1618 
1619         // Add resource declaration or expression to block statements
1620         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1621         JCTree resource = resources.head;
1622         JCExpression resourceUse;
1623         boolean resourceNonNull;
1624         if (resource instanceof JCVariableDecl) {
1625             JCVariableDecl var = (JCVariableDecl) resource;
1626             resourceUse = make.Ident(var.sym).setType(resource.type);
1627             resourceNonNull = var.init != null &amp;&amp; TreeInfo.skipParens(var.init).hasTag(NEWCLASS);
1628             stats.add(var);
1629         } else {
1630             Assert.check(resource instanceof JCExpression);
1631             VarSymbol syntheticTwrVar =
1632             new VarSymbol(SYNTHETIC | FINAL,
1633                           makeSyntheticName(names.fromString(&quot;twrVar&quot; +
1634                                            depth), twrVars),
1635                           (resource.type.hasTag(BOT)) ?
1636                           syms.autoCloseableType : resource.type,
1637                           currentMethodSym);
1638             twrVars.enter(syntheticTwrVar);
1639             JCVariableDecl syntheticTwrVarDecl =
1640                 make.VarDef(syntheticTwrVar, (JCExpression)resource);
1641             resourceUse = (JCExpression)make.Ident(syntheticTwrVar);
1642             resourceNonNull = false;
1643             stats.add(syntheticTwrVarDecl);
1644         }
1645 
1646         //create (semi-) finally block that will be copied into the main try body:
1647         int oldPos = make.pos;
1648         make.at(TreeInfo.endPos(block));
1649 
1650         // if (#resource != null) { #resource.close(); }
1651         JCStatement bodyCloseStatement = makeResourceCloseInvocation(resourceUse);
1652 
1653         if (!resourceNonNull) {
1654             bodyCloseStatement = make.If(makeNonNullCheck(resourceUse),
1655                                          bodyCloseStatement,
1656                                          null);
1657         }
1658 
1659         JCBlock finallyClause = make.Block(BODY_ONLY_FINALIZE, List.of(bodyCloseStatement));
1660         make.at(oldPos);
1661 
1662         // Create catch clause that saves exception, closes the resource and then rethrows the exception:
1663         VarSymbol primaryException =
1664             new VarSymbol(FINAL|SYNTHETIC,
1665                           names.fromString(&quot;t&quot; +
1666                                            target.syntheticNameChar()),
1667                           syms.throwableType,
1668                           currentMethodSym);
1669         JCVariableDecl primaryExceptionDecl = make.VarDef(primaryException, null);
1670 
1671         // close resource:
1672         // try {
1673         //     #resource.close();
1674         // } catch (Throwable #suppressedException) {
1675         //     #primaryException.addSuppressed(#suppressedException);
1676         // }
1677         VarSymbol suppressedException =
1678             new VarSymbol(SYNTHETIC, make.paramName(2),
1679                           syms.throwableType,
1680                           currentMethodSym);
1681         JCStatement addSuppressedStatement =
1682             make.Exec(makeCall(make.Ident(primaryException),
1683                                names.addSuppressed,
1684                                List.of(make.Ident(suppressedException))));
1685         JCBlock closeResourceTryBlock =
1686             make.Block(0L, List.of(makeResourceCloseInvocation(resourceUse)));
1687         JCVariableDecl catchSuppressedDecl = make.VarDef(suppressedException, null);
1688         JCBlock catchSuppressedBlock = make.Block(0L, List.of(addSuppressedStatement));
1689         List&lt;JCCatch&gt; catchSuppressedClauses =
1690                 List.of(make.Catch(catchSuppressedDecl, catchSuppressedBlock));
1691         JCTry closeResourceTry = make.Try(closeResourceTryBlock, catchSuppressedClauses, null);
1692         closeResourceTry.finallyCanCompleteNormally = true;
1693 
1694         JCStatement exceptionalCloseStatement = closeResourceTry;
1695 
1696         if (!resourceNonNull) {
1697             // if (#resource != null) {  }
1698             exceptionalCloseStatement = make.If(makeNonNullCheck(resourceUse),
1699                                                 exceptionalCloseStatement,
1700                                                 null);
1701         }
1702 
1703         JCStatement exceptionalRethrow = make.Throw(make.Ident(primaryException));
1704         JCBlock exceptionalCloseBlock = make.Block(0L, List.of(exceptionalCloseStatement, exceptionalRethrow));
1705         JCCatch exceptionalCatchClause = make.Catch(primaryExceptionDecl, exceptionalCloseBlock);
1706 
1707         //create the main try statement with the close:
1708         JCTry outerTry = make.Try(makeTwrBlock(resources.tail, block, depth + 1),
1709                                   List.of(exceptionalCatchClause),
1710                                   finallyClause);
1711 
1712         outerTry.finallyCanCompleteNormally = true;
1713         stats.add(outerTry);
1714 
1715         JCBlock newBlock = make.Block(0L, stats.toList());
1716         return newBlock;
1717     }
1718 
1719     private JCStatement makeResourceCloseInvocation(JCExpression resource) {
1720         // convert to AutoCloseable if needed
1721         if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {
1722             resource = convert(resource, syms.autoCloseableType);
1723         }
1724 
1725         // create resource.close() method invocation
1726         JCExpression resourceClose = makeCall(resource,
1727                                               names.close,
1728                                               List.nil());
1729         return make.Exec(resourceClose);
1730     }
1731 
1732     private JCExpression makeNonNullCheck(JCExpression expression) {
1733         return makeBinary(NE, expression, makeNull());
1734     }
1735 
1736     /** Construct a tree that represents the outer instance
1737      *  {@code C.this}. Never pick the current `this&#39;.
1738      *  @param pos           The source code position to be used for the tree.
1739      *  @param c             The qualifier class.
1740      */
1741     JCExpression makeOuterThis(DiagnosticPosition pos, TypeSymbol c) {
1742         List&lt;VarSymbol&gt; ots = outerThisStack;
1743         if (ots.isEmpty()) {
1744             log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
1745             Assert.error();
1746             return makeNull();
1747         }
1748         VarSymbol ot = ots.head;
1749         JCExpression tree = access(make.at(pos).Ident(ot));
1750         TypeSymbol otc = ot.type.tsym;
1751         while (otc != c) {
1752             do {
1753                 ots = ots.tail;
1754                 if (ots.isEmpty()) {
1755                     log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
1756                     Assert.error(); // should have been caught in Attr
1757                     return tree;
1758                 }
1759                 ot = ots.head;
1760             } while (ot.owner != otc);
1761             if (otc.owner.kind != PCK &amp;&amp; !otc.hasOuterInstance()) {
1762                 chk.earlyRefError(pos, c);
1763                 Assert.error(); // should have been caught in Attr
1764                 return makeNull();
1765             }
1766             tree = access(make.at(pos).Select(tree, ot));
1767             otc = ot.type.tsym;
1768         }
1769         return tree;
1770     }
1771 
1772     /** Construct a tree that represents the closest outer instance
1773      *  {@code C.this} such that the given symbol is a member of C.
1774      *  @param pos           The source code position to be used for the tree.
1775      *  @param sym           The accessed symbol.
1776      *  @param preciseMatch  should we accept a type that is a subtype of
1777      *                       sym&#39;s owner, even if it doesn&#39;t contain sym
1778      *                       due to hiding, overriding, or non-inheritance
1779      *                       due to protection?
1780      */
1781     JCExpression makeOwnerThis(DiagnosticPosition pos, Symbol sym, boolean preciseMatch) {
1782         Symbol c = sym.owner;
1783         if (preciseMatch ? sym.isMemberOf(currentClass, types)
1784                          : currentClass.isSubClass(sym.owner, types)) {
1785             // in this case, `this&#39; works fine
1786             return make.at(pos).This(c.erasure(types));
1787         } else {
1788             // need to go via this$n
1789             return makeOwnerThisN(pos, sym, preciseMatch);
1790         }
1791     }
1792 
1793     /**
1794      * Similar to makeOwnerThis but will never pick &quot;this&quot;.
1795      */
1796     JCExpression makeOwnerThisN(DiagnosticPosition pos, Symbol sym, boolean preciseMatch) {
1797         Symbol c = sym.owner;
1798         List&lt;VarSymbol&gt; ots = outerThisStack;
1799         if (ots.isEmpty()) {
1800             log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
1801             Assert.error();
1802             return makeNull();
1803         }
1804         VarSymbol ot = ots.head;
1805         JCExpression tree = access(make.at(pos).Ident(ot));
1806         TypeSymbol otc = ot.type.tsym;
1807         while (!(preciseMatch ? sym.isMemberOf(otc, types) : otc.isSubClass(sym.owner, types))) {
1808             do {
1809                 ots = ots.tail;
1810                 if (ots.isEmpty()) {
1811                     log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
1812                     Assert.error();
1813                     return tree;
1814                 }
1815                 ot = ots.head;
1816             } while (ot.owner != otc);
1817             tree = access(make.at(pos).Select(tree, ot));
1818             otc = ot.type.tsym;
1819         }
1820         return tree;
1821     }
1822 
1823     /** Return tree simulating the assignment {@code this.name = name}, where
1824      *  name is the name of a free variable.
1825      */
1826     JCStatement initField(int pos, Symbol rhs, Symbol lhs) {
1827         Assert.check(rhs.owner.kind == MTH);
1828         Assert.check(rhs.owner.owner == lhs.owner);
1829         make.at(pos);
1830         return
1831             make.Exec(
1832                 make.Assign(
1833                     make.Select(make.This(lhs.owner.erasure(types)), lhs),
1834                     make.Ident(rhs)).setType(lhs.erasure(types)));
1835     }
1836 
1837     /** Return tree simulating the assignment {@code this.this$n = this$n}.
1838      */
1839     JCStatement initOuterThis(int pos) {
1840         VarSymbol rhs = outerThisStack.head;
1841         Assert.check(rhs.owner.kind == MTH);
1842         VarSymbol lhs = outerThisStack.tail.head;
1843         Assert.check(rhs.owner.owner == lhs.owner);
1844         make.at(pos);
1845         return
1846             make.Exec(
1847                 make.Assign(
1848                     make.Select(make.This(lhs.owner.erasure(types)), lhs),
1849                     make.Ident(rhs)).setType(lhs.erasure(types)));
1850     }
1851 
1852 /**************************************************************************
1853  * Code for .class
1854  *************************************************************************/
1855 
1856     /** Return the symbol of a class to contain a cache of
1857      *  compiler-generated statics such as class$ and the
1858      *  $assertionsDisabled flag.  We create an anonymous nested class
1859      *  (unless one already exists) and return its symbol.  However,
1860      *  for backward compatibility in 1.4 and earlier we use the
1861      *  top-level class itself.
1862      */
1863     private ClassSymbol outerCacheClass() {
1864         ClassSymbol clazz = outermostClassDef.sym;
1865         Scope s = clazz.members();
1866         for (Symbol sym : s.getSymbols(NON_RECURSIVE))
1867             if (sym.kind == TYP &amp;&amp;
1868                 sym.name == names.empty &amp;&amp;
1869                 (sym.flags() &amp; INTERFACE) == 0) return (ClassSymbol) sym;
1870         return makeEmptyClass(STATIC | SYNTHETIC, clazz).sym;
1871     }
1872 
1873     /** Create an attributed tree of the form left.name(). */
1874     private JCMethodInvocation makeCall(JCExpression left, Name name, List&lt;JCExpression&gt; args) {
1875         Assert.checkNonNull(left.type);
1876         Symbol funcsym = lookupMethod(make_pos, name, left.type,
1877                                       TreeInfo.types(args));
1878         return make.App(make.Select(left, funcsym), args);
1879     }
1880 
1881     /** The tree simulating a T.class expression.
1882      *  @param clazz      The tree identifying type T.
1883      */
1884     private JCExpression classOf(JCTree clazz) {
1885         return classOfType(clazz.type, clazz.pos());
1886     }
1887 
1888     private JCExpression classOfType(Type type, DiagnosticPosition pos) {
1889         switch (type.getTag()) {
1890         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1891         case DOUBLE: case BOOLEAN: case VOID:
1892             // replace with &lt;BoxedClass&gt;.TYPE
1893             ClassSymbol c = types.boxedClass(type);
1894             Symbol typeSym =
1895                 rs.accessBase(
1896                     rs.findIdentInType(pos, attrEnv, c.type, names.TYPE, KindSelector.VAR),
1897                     pos, c.type, names.TYPE, true);
1898             if (typeSym.kind == VAR)
1899                 ((VarSymbol)typeSym).getConstValue(); // ensure initializer is evaluated
1900             return make.QualIdent(typeSym);
1901         case CLASS: case ARRAY:
1902                 VarSymbol sym = new VarSymbol(
1903                         STATIC | PUBLIC | FINAL, names._class,
1904                         syms.classType, type.tsym);
1905                 return make_at(pos).Select(make.Type(type), sym);
1906         default:
1907             throw new AssertionError();
1908         }
1909     }
1910 
1911 /**************************************************************************
1912  * Code for enabling/disabling assertions.
1913  *************************************************************************/
1914 
1915     private ClassSymbol assertionsDisabledClassCache;
1916 
1917     /**Used to create an auxiliary class to hold $assertionsDisabled for interfaces.
1918      */
1919     private ClassSymbol assertionsDisabledClass() {
1920         if (assertionsDisabledClassCache != null) return assertionsDisabledClassCache;
1921 
1922         assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC, outermostClassDef.sym).sym;
1923 
1924         return assertionsDisabledClassCache;
1925     }
1926 
1927     // This code is not particularly robust if the user has
1928     // previously declared a member named &#39;$assertionsDisabled&#39;.
1929     // The same faulty idiom also appears in the translation of
1930     // class literals above.  We should report an error if a
1931     // previous declaration is not synthetic.
1932 
1933     private JCExpression assertFlagTest(DiagnosticPosition pos) {
1934         // Outermost class may be either true class or an interface.
1935         ClassSymbol outermostClass = outermostClassDef.sym;
1936 
1937         //only classes can hold a non-public field, look for a usable one:
1938         ClassSymbol container = !currentClass.isInterface() ? currentClass :
1939                 assertionsDisabledClass();
1940 
1941         VarSymbol assertDisabledSym =
1942             (VarSymbol)lookupSynthetic(dollarAssertionsDisabled,
1943                                        container.members());
1944         if (assertDisabledSym == null) {
1945             assertDisabledSym =
1946                 new VarSymbol(STATIC | FINAL | SYNTHETIC,
1947                               dollarAssertionsDisabled,
1948                               syms.booleanType,
1949                               container);
1950             enterSynthetic(pos, assertDisabledSym, container.members());
1951             Symbol desiredAssertionStatusSym = lookupMethod(pos,
1952                                                             names.desiredAssertionStatus,
1953                                                             types.erasure(syms.classType),
1954                                                             List.nil());
1955             JCClassDecl containerDef = classDef(container);
1956             make_at(containerDef.pos());
1957             JCExpression notStatus = makeUnary(NOT, make.App(make.Select(
1958                     classOfType(types.erasure(outermostClass.type),
1959                                 containerDef.pos()),
1960                     desiredAssertionStatusSym)));
1961             JCVariableDecl assertDisabledDef = make.VarDef(assertDisabledSym,
1962                                                    notStatus);
1963             containerDef.defs = containerDef.defs.prepend(assertDisabledDef);
1964 
1965             if (currentClass.isInterface()) {
1966                 //need to load the assertions enabled/disabled state while
1967                 //initializing the interface:
1968                 JCClassDecl currentClassDef = classDef(currentClass);
1969                 make_at(currentClassDef.pos());
1970                 JCStatement dummy = make.If(make.QualIdent(assertDisabledSym), make.Skip(), null);
1971                 JCBlock clinit = make.Block(STATIC, List.of(dummy));
1972                 currentClassDef.defs = currentClassDef.defs.prepend(clinit);
1973             }
1974         }
1975         make_at(pos);
1976         return makeUnary(NOT, make.Ident(assertDisabledSym));
1977     }
1978 
1979 
1980 /**************************************************************************
1981  * Building blocks for let expressions
1982  *************************************************************************/
1983 
1984     interface TreeBuilder {
1985         JCExpression build(JCExpression arg);
1986     }
1987 
1988     /** Construct an expression using the builder, with the given rval
1989      *  expression as an argument to the builder.  However, the rval
1990      *  expression must be computed only once, even if used multiple
1991      *  times in the result of the builder.  We do that by
1992      *  constructing a &quot;let&quot; expression that saves the rvalue into a
1993      *  temporary variable and then uses the temporary variable in
1994      *  place of the expression built by the builder.  The complete
1995      *  resulting expression is of the form
1996      *  &lt;pre&gt;
1997      *    (let &lt;b&gt;TYPE&lt;/b&gt; &lt;b&gt;TEMP&lt;/b&gt; = &lt;b&gt;RVAL&lt;/b&gt;;
1998      *     in (&lt;b&gt;BUILDER&lt;/b&gt;(&lt;b&gt;TEMP&lt;/b&gt;)))
1999      *  &lt;/pre&gt;
2000      *  where &lt;code&gt;&lt;b&gt;TEMP&lt;/b&gt;&lt;/code&gt; is a newly declared variable
2001      *  in the let expression.
2002      */
2003     JCExpression abstractRval(JCExpression rval, Type type, TreeBuilder builder) {
2004         rval = TreeInfo.skipParens(rval);
2005         switch (rval.getTag()) {
2006         case LITERAL:
2007             return builder.build(rval);
2008         case IDENT:
2009             JCIdent id = (JCIdent) rval;
2010             if ((id.sym.flags() &amp; FINAL) != 0 &amp;&amp; id.sym.owner.kind == MTH)
2011                 return builder.build(rval);
2012         }
2013         Name name = TreeInfo.name(rval);
2014         if (name == names._super || name == names._this)
2015             return builder.build(rval);
2016         VarSymbol var =
2017             new VarSymbol(FINAL|SYNTHETIC,
2018                           names.fromString(
2019                                           target.syntheticNameChar()
2020                                           + &quot;&quot; + rval.hashCode()),
2021                                       type,
2022                                       currentMethodSym);
2023         rval = convert(rval,type);
2024         JCVariableDecl def = make.VarDef(var, rval); // XXX cast
2025         JCExpression built = builder.build(make.Ident(var));
2026         JCExpression res = make.LetExpr(def, built);
2027         res.type = built.type;
2028         return res;
2029     }
2030 
2031     // same as above, with the type of the temporary variable computed
2032     JCExpression abstractRval(JCExpression rval, TreeBuilder builder) {
2033         return abstractRval(rval, rval.type, builder);
2034     }
2035 
2036     // same as above, but for an expression that may be used as either
2037     // an rvalue or an lvalue.  This requires special handling for
2038     // Select expressions, where we place the left-hand-side of the
2039     // select in a temporary, and for Indexed expressions, where we
2040     // place both the indexed expression and the index value in temps.
2041     JCExpression abstractLval(JCExpression lval, final TreeBuilder builder) {
2042         lval = TreeInfo.skipParens(lval);
2043         switch (lval.getTag()) {
2044         case IDENT:
2045             return builder.build(lval);
2046         case SELECT: {
2047             final JCFieldAccess s = (JCFieldAccess)lval;
2048             Symbol lid = TreeInfo.symbol(s.selected);
2049             if (lid != null &amp;&amp; lid.kind == TYP) return builder.build(lval);
2050             return abstractRval(s.selected, selected -&gt; builder.build(make.Select(selected, s.sym)));
2051         }
2052         case INDEXED: {
2053             final JCArrayAccess i = (JCArrayAccess)lval;
2054             return abstractRval(i.indexed, indexed -&gt; abstractRval(i.index, syms.intType, index -&gt; {
2055                 JCExpression newLval = make.Indexed(indexed, index);
2056                 newLval.setType(i.type);
2057                 return builder.build(newLval);
2058             }));
2059         }
2060         case TYPECAST: {
2061             return abstractLval(((JCTypeCast)lval).expr, builder);
2062         }
2063         }
2064         throw new AssertionError(lval);
2065     }
2066 
2067     // evaluate and discard the first expression, then evaluate the second.
2068     JCExpression makeComma(final JCExpression expr1, final JCExpression expr2) {
2069         JCExpression res = make.LetExpr(List.of(make.Exec(expr1)), expr2);
2070         res.type = expr2.type;
2071         return res;
2072     }
2073 
2074 /**************************************************************************
2075  * Translation methods
2076  *************************************************************************/
2077 
2078     /** Visitor argument: enclosing operator node.
2079      */
2080     private JCExpression enclOp;
2081 
2082     /** Visitor method: Translate a single node.
2083      *  Attach the source position from the old tree to its replacement tree.
2084      */
2085     @Override
2086     public &lt;T extends JCTree&gt; T translate(T tree) {
2087         if (tree == null) {
2088             return null;
2089         } else {
2090             make_at(tree.pos());
2091             T result = super.translate(tree);
2092             if (endPosTable != null &amp;&amp; result != tree) {
2093                 endPosTable.replaceTree(tree, result);
2094             }
2095             return result;
2096         }
2097     }
2098 
2099     /** Visitor method: Translate a single node, boxing or unboxing if needed.
2100      */
2101     public &lt;T extends JCExpression&gt; T translate(T tree, Type type) {
2102         return (tree == null) ? null : boxIfNeeded(translate(tree), type);
2103     }
2104 
2105     /** Visitor method: Translate tree.
2106      */
2107     public &lt;T extends JCTree&gt; T translate(T tree, JCExpression enclOp) {
2108         JCExpression prevEnclOp = this.enclOp;
2109         this.enclOp = enclOp;
2110         T res = translate(tree);
2111         this.enclOp = prevEnclOp;
2112         return res;
2113     }
2114 
2115     /** Visitor method: Translate list of trees.
2116      */
2117     public &lt;T extends JCExpression&gt; List&lt;T&gt; translate(List&lt;T&gt; trees, Type type) {
2118         if (trees == null) return null;
2119         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
2120             l.head = translate(l.head, type);
2121         return trees;
2122     }
2123 
2124     public void visitPackageDef(JCPackageDecl tree) {
2125         if (!needPackageInfoClass(tree))
2126                         return;
2127 
2128         long flags = Flags.ABSTRACT | Flags.INTERFACE;
2129         // package-info is marked SYNTHETIC in JDK 1.6 and later releases
2130         flags = flags | Flags.SYNTHETIC;
2131         ClassSymbol c = tree.packge.package_info;
2132         c.setAttributes(tree.packge);
2133         c.flags_field |= flags;
2134         ClassType ctype = (ClassType) c.type;
2135         ctype.supertype_field = syms.objectType;
2136         ctype.interfaces_field = List.nil();
2137         createInfoClass(tree.annotations, c);
2138     }
2139     // where
2140     private boolean needPackageInfoClass(JCPackageDecl pd) {
2141         switch (pkginfoOpt) {
2142             case ALWAYS:
2143                 return true;
2144             case LEGACY:
2145                 return pd.getAnnotations().nonEmpty();
2146             case NONEMPTY:
2147                 for (Attribute.Compound a :
2148                          pd.packge.getDeclarationAttributes()) {
2149                     Attribute.RetentionPolicy p = types.getRetention(a);
2150                     if (p != Attribute.RetentionPolicy.SOURCE)
2151                         return true;
2152                 }
2153                 return false;
2154         }
2155         throw new AssertionError();
2156     }
2157 
2158     public void visitModuleDef(JCModuleDecl tree) {
2159         ModuleSymbol msym = tree.sym;
2160         ClassSymbol c = msym.module_info;
2161         c.setAttributes(msym);
2162         c.flags_field |= Flags.MODULE;
2163         createInfoClass(List.nil(), tree.sym.module_info);
2164     }
2165 
2166     private void createInfoClass(List&lt;JCAnnotation&gt; annots, ClassSymbol c) {
2167         long flags = Flags.ABSTRACT | Flags.INTERFACE;
2168         JCClassDecl infoClass =
2169                 make.ClassDef(make.Modifiers(flags, annots),
2170                     c.name, List.nil(),
2171                     null, List.nil(), List.nil());
2172         infoClass.sym = c;
2173         translated.append(infoClass);
2174     }
2175 
2176     public void visitClassDef(JCClassDecl tree) {
2177         Env&lt;AttrContext&gt; prevEnv = attrEnv;
2178         ClassSymbol currentClassPrev = currentClass;
2179         MethodSymbol currentMethodSymPrev = currentMethodSym;
2180 
2181         currentClass = tree.sym;
2182         currentMethodSym = null;
2183         attrEnv = typeEnvs.remove(currentClass);
2184         if (attrEnv == null)
2185             attrEnv = prevEnv;
2186 
2187         classdefs.put(currentClass, tree);
2188 
2189         Map&lt;Symbol, Symbol&gt; prevProxies = proxies;
2190         proxies = new HashMap&lt;&gt;(proxies);
2191         List&lt;VarSymbol&gt; prevOuterThisStack = outerThisStack;
2192 
2193         // If this is an enum definition
2194         if ((tree.mods.flags &amp; ENUM) != 0 &amp;&amp;
2195             (types.supertype(currentClass.type).tsym.flags() &amp; ENUM) == 0)
2196             visitEnumDef(tree);
2197 
2198         if ((tree.mods.flags &amp; RECORD) != 0) {
2199             visitRecordDef(tree);
2200         }
2201 
2202         // If this is a nested class, define a this$n field for
2203         // it and add to proxies.
2204         JCVariableDecl otdef = null;
2205         if (currentClass.hasOuterInstance())
2206             otdef = outerThisDef(tree.pos, currentClass);
2207 
2208         // If this is a local class, define proxies for all its free variables.
2209         List&lt;JCVariableDecl&gt; fvdefs = freevarDefs(
2210             tree.pos, freevars(currentClass), currentClass);
2211 
2212         // Recursively translate superclass, interfaces.
2213         tree.extending = translate(tree.extending);
2214         tree.implementing = translate(tree.implementing);
2215 
2216         if (currentClass.isLocal()) {
2217             ClassSymbol encl = currentClass.owner.enclClass();
2218             if (encl.trans_local == null) {
2219                 encl.trans_local = List.nil();
2220             }
2221             encl.trans_local = encl.trans_local.prepend(currentClass);
2222         }
2223 
2224         // Recursively translate members, taking into account that new members
2225         // might be created during the translation and prepended to the member
2226         // list `tree.defs&#39;.
2227         List&lt;JCTree&gt; seen = List.nil();
2228         while (tree.defs != seen) {
2229             List&lt;JCTree&gt; unseen = tree.defs;
2230             for (List&lt;JCTree&gt; l = unseen; l.nonEmpty() &amp;&amp; l != seen; l = l.tail) {
2231                 JCTree outermostMemberDefPrev = outermostMemberDef;
2232                 if (outermostMemberDefPrev == null) outermostMemberDef = l.head;
2233                 l.head = translate(l.head);
2234                 outermostMemberDef = outermostMemberDefPrev;
2235             }
2236             seen = unseen;
2237         }
2238 
2239         // Convert a protected modifier to public, mask static modifier.
2240         if ((tree.mods.flags &amp; PROTECTED) != 0) tree.mods.flags |= PUBLIC;
2241         tree.mods.flags &amp;= ClassFlags;
2242 
2243         // Convert name to flat representation, replacing &#39;.&#39; by &#39;$&#39;.
2244         tree.name = Convert.shortName(currentClass.flatName());
2245 
2246         // Add this$n and free variables proxy definitions to class.
2247 
2248         for (List&lt;JCVariableDecl&gt; l = fvdefs; l.nonEmpty(); l = l.tail) {
2249             tree.defs = tree.defs.prepend(l.head);
2250             enterSynthetic(tree.pos(), l.head.sym, currentClass.members());
2251         }
2252         if (currentClass.hasOuterInstance()) {
2253             tree.defs = tree.defs.prepend(otdef);
2254             enterSynthetic(tree.pos(), otdef.sym, currentClass.members());
2255         }
2256 
2257         proxies = prevProxies;
2258         outerThisStack = prevOuterThisStack;
2259 
2260         // Append translated tree to `translated&#39; queue.
2261         translated.append(tree);
2262 
2263         attrEnv = prevEnv;
2264         currentClass = currentClassPrev;
2265         currentMethodSym = currentMethodSymPrev;
2266 
2267         // Return empty block {} as a placeholder for an inner class.
2268         result = make_at(tree.pos()).Block(SYNTHETIC, List.nil());
2269     }
2270 
2271     List&lt;JCTree&gt; generateMandatedAccessors(JCClassDecl tree) {
2272         List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
2273         return tree.sym.getRecordComponents().stream()
2274                 .filter(rc -&gt; (rc.accessor.flags() &amp; Flags.GENERATED_MEMBER) != 0)
2275                 .map(rc -&gt; {
2276                     // we need to return the field not the record component
2277                     JCVariableDecl field = fields.stream().filter(f -&gt; f.name == rc.name).findAny().get();
2278                     make_at(tree.pos());
2279                     return make.MethodDef(rc.accessor, make.Block(0,
2280                             List.of(make.Return(make.Ident(field)))));
2281                 }).collect(List.collector());
2282     }
2283 
2284     /** Translate an enum class. */
2285     private void visitEnumDef(JCClassDecl tree) {
2286         make_at(tree.pos());
2287 
2288         // add the supertype, if needed
2289         if (tree.extending == null)
2290             tree.extending = make.Type(types.supertype(tree.type));
2291 
2292         // classOfType adds a cache field to tree.defs
2293         JCExpression e_class = classOfType(tree.sym.type, tree.pos()).
2294             setType(types.erasure(syms.classType));
2295 
2296         // process each enumeration constant, adding implicit constructor parameters
2297         int nextOrdinal = 0;
2298         ListBuffer&lt;JCExpression&gt; values = new ListBuffer&lt;&gt;();
2299         ListBuffer&lt;JCTree&gt; enumDefs = new ListBuffer&lt;&gt;();
2300         ListBuffer&lt;JCTree&gt; otherDefs = new ListBuffer&lt;&gt;();
2301         for (List&lt;JCTree&gt; defs = tree.defs;
2302              defs.nonEmpty();
2303              defs=defs.tail) {
2304             if (defs.head.hasTag(VARDEF) &amp;&amp; (((JCVariableDecl) defs.head).mods.flags &amp; ENUM) != 0) {
2305                 JCVariableDecl var = (JCVariableDecl)defs.head;
2306                 visitEnumConstantDef(var, nextOrdinal++);
2307                 values.append(make.QualIdent(var.sym));
2308                 enumDefs.append(var);
2309             } else {
2310                 otherDefs.append(defs.head);
2311             }
2312         }
2313 
<a name="1" id="anc1"></a><span class="line-modified">2314         // synthetic private static T[] $values() { return new T[] { a, b, c }; }</span>
<span class="line-modified">2315         // synthetic private static final T[] $VALUES = $values();</span>
<span class="line-modified">2316         Name valuesName = syntheticName(tree, &quot;VALUES&quot;);</span>

2317         Type arrayType = new ArrayType(types.erasure(tree.type), syms.arrayClass);
2318         VarSymbol valuesVar = new VarSymbol(PRIVATE|FINAL|STATIC|SYNTHETIC,
2319                                             valuesName,
2320                                             arrayType,
2321                                             tree.type.tsym);
2322         JCNewArray newArray = make.NewArray(make.Type(types.erasure(tree.type)),
2323                                           List.nil(),
2324                                           values.toList());
2325         newArray.type = arrayType;
<a name="2" id="anc2"></a><span class="line-modified">2326 </span>
<span class="line-added">2327         MethodSymbol valuesMethod = new MethodSymbol(PRIVATE|STATIC|SYNTHETIC,</span>
<span class="line-added">2328                 syntheticName(tree, &quot;values&quot;),</span>
<span class="line-added">2329                 new MethodType(List.nil(), arrayType, List.nil(), tree.type.tsym),</span>
<span class="line-added">2330                 tree.type.tsym);</span>
<span class="line-added">2331         enumDefs.append(make.MethodDef(valuesMethod, make.Block(0, List.of(make.Return(newArray)))));</span>
<span class="line-added">2332         tree.sym.members().enter(valuesMethod);</span>
<span class="line-added">2333 </span>
<span class="line-added">2334         enumDefs.append(make.VarDef(valuesVar, make.App(make.QualIdent(valuesMethod))));</span>
2335         tree.sym.members().enter(valuesVar);
2336 
2337         Symbol valuesSym = lookupMethod(tree.pos(), names.values,
2338                                         tree.type, List.nil());
2339         List&lt;JCStatement&gt; valuesBody;
2340         if (useClone()) {
2341             // return (T[]) $VALUES.clone();
2342             JCTypeCast valuesResult =
2343                 make.TypeCast(valuesSym.type.getReturnType(),
2344                               make.App(make.Select(make.Ident(valuesVar),
2345                                                    syms.arrayCloneMethod)));
2346             valuesBody = List.of(make.Return(valuesResult));
2347         } else {
2348             // template: T[] $result = new T[$values.length];
<a name="3" id="anc3"></a><span class="line-modified">2349             Name resultName = syntheticName(tree, &quot;result&quot;);</span>


2350             VarSymbol resultVar = new VarSymbol(FINAL|SYNTHETIC,
2351                                                 resultName,
2352                                                 arrayType,
2353                                                 valuesSym);
2354             JCNewArray resultArray = make.NewArray(make.Type(types.erasure(tree.type)),
2355                                   List.of(make.Select(make.Ident(valuesVar), syms.lengthVar)),
2356                                   null);
2357             resultArray.type = arrayType;
2358             JCVariableDecl decl = make.VarDef(resultVar, resultArray);
2359 
2360             // template: System.arraycopy($VALUES, 0, $result, 0, $VALUES.length);
2361             if (systemArraycopyMethod == null) {
2362                 systemArraycopyMethod =
2363                     new MethodSymbol(PUBLIC | STATIC,
2364                                      names.fromString(&quot;arraycopy&quot;),
2365                                      new MethodType(List.of(syms.objectType,
2366                                                             syms.intType,
2367                                                             syms.objectType,
2368                                                             syms.intType,
2369                                                             syms.intType),
2370                                                     syms.voidType,
2371                                                     List.nil(),
2372                                                     syms.methodClass),
2373                                      syms.systemType.tsym);
2374             }
2375             JCStatement copy =
2376                 make.Exec(make.App(make.Select(make.Ident(syms.systemType.tsym),
2377                                                systemArraycopyMethod),
2378                           List.of(make.Ident(valuesVar), make.Literal(0),
2379                                   make.Ident(resultVar), make.Literal(0),
2380                                   make.Select(make.Ident(valuesVar), syms.lengthVar))));
2381 
2382             // template: return $result;
2383             JCStatement ret = make.Return(make.Ident(resultVar));
2384             valuesBody = List.of(decl, copy, ret);
2385         }
2386 
2387         JCMethodDecl valuesDef =
2388              make.MethodDef((MethodSymbol)valuesSym, make.Block(0, valuesBody));
2389 
2390         enumDefs.append(valuesDef);
2391 
2392         if (debugLower)
2393             System.err.println(tree.sym + &quot;.valuesDef = &quot; + valuesDef);
2394 
2395         /** The template for the following code is:
2396          *
2397          *     public static E valueOf(String name) {
2398          *         return (E)Enum.valueOf(E.class, name);
2399          *     }
2400          *
2401          *  where E is tree.sym
2402          */
2403         MethodSymbol valueOfSym = lookupMethod(tree.pos(),
2404                          names.valueOf,
2405                          tree.sym.type,
2406                          List.of(syms.stringType));
2407         Assert.check((valueOfSym.flags() &amp; STATIC) != 0);
2408         VarSymbol nameArgSym = valueOfSym.params.head;
2409         JCIdent nameVal = make.Ident(nameArgSym);
2410         JCStatement enum_ValueOf =
2411             make.Return(make.TypeCast(tree.sym.type,
2412                                       makeCall(make.Ident(syms.enumSym),
2413                                                names.valueOf,
2414                                                List.of(e_class, nameVal))));
2415         JCMethodDecl valueOf = make.MethodDef(valueOfSym,
2416                                            make.Block(0, List.of(enum_ValueOf)));
2417         nameVal.sym = valueOf.params.head.sym;
2418         if (debugLower)
2419             System.err.println(tree.sym + &quot;.valueOf = &quot; + valueOf);
2420         enumDefs.append(valueOf);
2421 
2422         enumDefs.appendList(otherDefs.toList());
2423         tree.defs = enumDefs.toList();
2424     }
2425         // where
2426         private MethodSymbol systemArraycopyMethod;
2427         private boolean useClone() {
2428             try {
2429                 return syms.objectType.tsym.members().findFirst(names.clone) != null;
2430             }
2431             catch (CompletionFailure e) {
2432                 return false;
2433             }
2434         }
2435 
<a name="4" id="anc4"></a><span class="line-added">2436         private Name syntheticName(JCClassDecl tree, String baseName) {</span>
<span class="line-added">2437             Name valuesName = names.fromString(target.syntheticNameChar() + baseName);</span>
<span class="line-added">2438             while (tree.sym.members().findFirst(valuesName) != null) // avoid name clash</span>
<span class="line-added">2439                 valuesName = names.fromString(valuesName + &quot;&quot; + target.syntheticNameChar());</span>
<span class="line-added">2440             return valuesName;</span>
<span class="line-added">2441         }</span>
<span class="line-added">2442 </span>
2443     /** Translate an enumeration constant and its initializer. */
2444     private void visitEnumConstantDef(JCVariableDecl var, int ordinal) {
2445         JCNewClass varDef = (JCNewClass)var.init;
2446         varDef.args = varDef.args.
2447             prepend(makeLit(syms.intType, ordinal)).
2448             prepend(makeLit(syms.stringType, var.name.toString()));
2449     }
2450 
2451     private List&lt;VarSymbol&gt; recordVars(Type t) {
2452         List&lt;VarSymbol&gt; vars = List.nil();
2453         while (!t.hasTag(NONE)) {
2454             if (t.hasTag(CLASS)) {
2455                 for (Symbol s : t.tsym.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; (s.flags() &amp; RECORD) != 0)) {
2456                     vars = vars.prepend((VarSymbol)s);
2457                 }
2458             }
2459             t = types.supertype(t);
2460         }
2461         return vars;
2462     }
2463 
2464     /** Translate a record. */
2465     private void visitRecordDef(JCClassDecl tree) {
2466         make_at(tree.pos());
2467         List&lt;VarSymbol&gt; vars = recordVars(tree.type);
2468         MethodHandleSymbol[] getterMethHandles = new MethodHandleSymbol[vars.size()];
2469         int index = 0;
2470         for (VarSymbol var : vars) {
2471             if (var.owner != tree.sym) {
2472                 var = new VarSymbol(var.flags_field, var.name, var.type, tree.sym);
2473             }
2474             getterMethHandles[index] = var.asMethodHandle(true);
2475             index++;
2476         }
2477 
2478         tree.defs = tree.defs.appendList(generateMandatedAccessors(tree));
2479         tree.defs = tree.defs.appendList(List.of(
2480                 generateRecordMethod(tree, names.toString, vars, getterMethHandles),
2481                 generateRecordMethod(tree, names.hashCode, vars, getterMethHandles),
2482                 generateRecordMethod(tree, names.equals, vars, getterMethHandles)
2483         ));
2484     }
2485 
2486     JCTree generateRecordMethod(JCClassDecl tree, Name name, List&lt;VarSymbol&gt; vars, MethodHandleSymbol[] getterMethHandles) {
2487         make_at(tree.pos());
2488         boolean isEquals = name == names.equals;
2489         MethodSymbol msym = lookupMethod(tree.pos(),
2490                 name,
2491                 tree.sym.type,
2492                 isEquals ? List.of(syms.objectType) : List.nil());
2493         // compiler generated methods have the record flag set, user defined ones dont
2494         if ((msym.flags() &amp; RECORD) != 0) {
2495             /* class java.lang.runtime.ObjectMethods provides a common bootstrap that provides a customized implementation
2496              * for methods: toString, hashCode and equals. Here we just need to generate and indy call to:
2497              * java.lang.runtime.ObjectMethods::bootstrap and provide: the record class, the record component names and
2498              * the accessors.
2499              */
2500             Name bootstrapName = names.bootstrap;
2501             LoadableConstant[] staticArgsValues = new LoadableConstant[2 + getterMethHandles.length];
2502             staticArgsValues[0] = (ClassType)tree.sym.type;
2503             String concatNames = vars.stream()
2504                     .map(v -&gt; v.name)
2505                     .collect(Collectors.joining(&quot;;&quot;, &quot;&quot;, &quot;&quot;));
2506             staticArgsValues[1] = LoadableConstant.String(concatNames);
2507             int index = 2;
2508             for (MethodHandleSymbol mho : getterMethHandles) {
2509                 staticArgsValues[index] = mho;
2510                 index++;
2511             }
2512 
2513             List&lt;Type&gt; staticArgTypes = List.of(syms.classType,
2514                     syms.stringType,
2515                     new ArrayType(syms.methodHandleType, syms.arrayClass));
2516 
2517             JCFieldAccess qualifier = makeIndyQualifier(syms.objectMethodsType, tree, msym,
2518                     List.of(syms.methodHandleLookupType,
2519                             syms.stringType,
2520                             syms.typeDescriptorType).appendList(staticArgTypes),
2521                     staticArgsValues, bootstrapName, name, false);
2522 
2523             VarSymbol _this = new VarSymbol(SYNTHETIC, names._this, tree.sym.type, tree.sym);
2524 
2525             JCMethodInvocation proxyCall;
2526             if (!isEquals) {
2527                 proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this)));
2528             } else {
2529                 VarSymbol o = msym.params.head;
2530                 o.adr = 0;
2531                 proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this), make.Ident(o)));
2532             }
2533             proxyCall.type = qualifier.type;
2534             return make.MethodDef(msym, make.Block(0, List.of(make.Return(proxyCall))));
2535         } else {
2536             return make.Block(SYNTHETIC, List.nil());
2537         }
2538     }
2539 
2540     private String argsTypeSig(List&lt;Type&gt; typeList) {
2541         LowerSignatureGenerator sg = new LowerSignatureGenerator();
2542         sg.assembleSig(typeList);
2543         return sg.toString();
2544     }
2545 
2546     /**
2547      * Signature Generation
2548      */
2549     private class LowerSignatureGenerator extends Types.SignatureGenerator {
2550 
2551         /**
2552          * An output buffer for type signatures.
2553          */
2554         StringBuilder sb = new StringBuilder();
2555 
2556         LowerSignatureGenerator() {
2557             super(types);
2558         }
2559 
2560         @Override
2561         protected void append(char ch) {
2562             sb.append(ch);
2563         }
2564 
2565         @Override
2566         protected void append(byte[] ba) {
2567             sb.append(new String(ba));
2568         }
2569 
2570         @Override
2571         protected void append(Name name) {
2572             sb.append(name.toString());
2573         }
2574 
2575         @Override
2576         public String toString() {
2577             return sb.toString();
2578         }
2579     }
2580 
2581     /**
2582      * Creates an indy qualifier, helpful to be part of an indy invocation
2583      * @param site                the site
2584      * @param tree                a class declaration tree
2585      * @param msym                the method symbol
2586      * @param staticArgTypes      the static argument types
2587      * @param staticArgValues     the static argument values
2588      * @param bootstrapName       the bootstrap name to look for
2589      * @param argName             normally bootstraps receives a method name as second argument, if you want that name
2590      *                            to be different to that of the bootstrap name pass a different name here
2591      * @param isStatic            is it static or not
2592      * @return                    a field access tree
2593      */
2594     JCFieldAccess makeIndyQualifier(
2595             Type site,
2596             JCClassDecl tree,
2597             MethodSymbol msym,
2598             List&lt;Type&gt; staticArgTypes,
2599             LoadableConstant[] staticArgValues,
2600             Name bootstrapName,
2601             Name argName,
2602             boolean isStatic) {
2603         Symbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,
2604                 bootstrapName, staticArgTypes, List.nil());
2605 
2606         MethodType indyType = msym.type.asMethodType();
2607         indyType = new MethodType(
2608                 isStatic ? List.nil() : indyType.argtypes.prepend(tree.sym.type),
2609                 indyType.restype,
2610                 indyType.thrown,
2611                 syms.methodClass
2612         );
2613         DynamicMethodSymbol dynSym = new DynamicMethodSymbol(argName,
2614                 syms.noSymbol,
2615                 ((MethodSymbol)bsm).asHandle(),
2616                 indyType,
2617                 staticArgValues);
2618         JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), argName);
2619         qualifier.sym = dynSym;
2620         qualifier.type = msym.type.asMethodType().restype;
2621         return qualifier;
2622     }
2623 
2624     public void visitMethodDef(JCMethodDecl tree) {
2625         if (tree.name == names.init &amp;&amp; (currentClass.flags_field&amp;ENUM) != 0) {
2626             // Add &quot;String $enum$name, int $enum$ordinal&quot; to the beginning of the
2627             // argument list for each constructor of an enum.
2628             JCVariableDecl nameParam = make_at(tree.pos()).
2629                 Param(names.fromString(target.syntheticNameChar() +
2630                                        &quot;enum&quot; + target.syntheticNameChar() + &quot;name&quot;),
2631                       syms.stringType, tree.sym);
2632             nameParam.mods.flags |= SYNTHETIC; nameParam.sym.flags_field |= SYNTHETIC;
2633             JCVariableDecl ordParam = make.
2634                 Param(names.fromString(target.syntheticNameChar() +
2635                                        &quot;enum&quot; + target.syntheticNameChar() +
2636                                        &quot;ordinal&quot;),
2637                       syms.intType, tree.sym);
2638             ordParam.mods.flags |= SYNTHETIC; ordParam.sym.flags_field |= SYNTHETIC;
2639 
2640             MethodSymbol m = tree.sym;
2641             tree.params = tree.params.prepend(ordParam).prepend(nameParam);
2642 
2643             m.extraParams = m.extraParams.prepend(ordParam.sym);
2644             m.extraParams = m.extraParams.prepend(nameParam.sym);
2645             Type olderasure = m.erasure(types);
2646             m.erasure_field = new MethodType(
2647                 olderasure.getParameterTypes().prepend(syms.intType).prepend(syms.stringType),
2648                 olderasure.getReturnType(),
2649                 olderasure.getThrownTypes(),
2650                 syms.methodClass);
2651         }
2652 
2653         JCMethodDecl prevMethodDef = currentMethodDef;
2654         MethodSymbol prevMethodSym = currentMethodSym;
2655         try {
2656             currentMethodDef = tree;
2657             currentMethodSym = tree.sym;
2658             visitMethodDefInternal(tree);
2659         } finally {
2660             currentMethodDef = prevMethodDef;
2661             currentMethodSym = prevMethodSym;
2662         }
2663     }
2664 
2665     private void visitMethodDefInternal(JCMethodDecl tree) {
2666         if (tree.name == names.init &amp;&amp;
2667             (currentClass.isInner() || currentClass.isLocal())) {
2668             // We are seeing a constructor of an inner class.
2669             MethodSymbol m = tree.sym;
2670 
2671             // Push a new proxy scope for constructor parameters.
2672             // and create definitions for any this$n and proxy parameters.
2673             Map&lt;Symbol, Symbol&gt; prevProxies = proxies;
2674             proxies = new HashMap&lt;&gt;(proxies);
2675             List&lt;VarSymbol&gt; prevOuterThisStack = outerThisStack;
2676             List&lt;VarSymbol&gt; fvs = freevars(currentClass);
2677             JCVariableDecl otdef = null;
2678             if (currentClass.hasOuterInstance())
2679                 otdef = outerThisDef(tree.pos, m);
2680             List&lt;JCVariableDecl&gt; fvdefs = freevarDefs(tree.pos, fvs, m, PARAMETER);
2681 
2682             // Recursively translate result type, parameters and thrown list.
2683             tree.restype = translate(tree.restype);
2684             tree.params = translateVarDefs(tree.params);
2685             tree.thrown = translate(tree.thrown);
2686 
2687             // when compiling stubs, don&#39;t process body
2688             if (tree.body == null) {
2689                 result = tree;
2690                 return;
2691             }
2692 
2693             // Add this$n (if needed) in front of and free variables behind
2694             // constructor parameter list.
2695             tree.params = tree.params.appendList(fvdefs);
2696             if (currentClass.hasOuterInstance()) {
2697                 tree.params = tree.params.prepend(otdef);
2698             }
2699 
2700             // If this is an initial constructor, i.e., it does not start with
2701             // this(...), insert initializers for this$n and proxies
2702             // before (pre-1.4, after) the call to superclass constructor.
2703             JCStatement selfCall = translate(tree.body.stats.head);
2704 
2705             List&lt;JCStatement&gt; added = List.nil();
2706             if (fvs.nonEmpty()) {
2707                 List&lt;Type&gt; addedargtypes = List.nil();
2708                 for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail) {
2709                     m.capturedLocals =
2710                         m.capturedLocals.prepend((VarSymbol)
2711                                                 (proxies.get(l.head)));
2712                     if (TreeInfo.isInitialConstructor(tree)) {
2713                         added = added.prepend(
2714                           initField(tree.body.pos, proxies.get(l.head), prevProxies.get(l.head)));
2715                     }
2716                     addedargtypes = addedargtypes.prepend(l.head.erasure(types));
2717                 }
2718                 Type olderasure = m.erasure(types);
2719                 m.erasure_field = new MethodType(
2720                     olderasure.getParameterTypes().appendList(addedargtypes),
2721                     olderasure.getReturnType(),
2722                     olderasure.getThrownTypes(),
2723                     syms.methodClass);
2724             }
2725             if (currentClass.hasOuterInstance() &amp;&amp;
2726                 TreeInfo.isInitialConstructor(tree))
2727             {
2728                 added = added.prepend(initOuterThis(tree.body.pos));
2729             }
2730 
2731             // pop local variables from proxy stack
2732             proxies = prevProxies;
2733 
2734             // recursively translate following local statements and
2735             // combine with this- or super-call
2736             List&lt;JCStatement&gt; stats = translate(tree.body.stats.tail);
2737             tree.body.stats = stats.prepend(selfCall).prependList(added);
2738             outerThisStack = prevOuterThisStack;
2739         } else {
2740             Map&lt;Symbol, Symbol&gt; prevLambdaTranslationMap =
2741                     lambdaTranslationMap;
2742             try {
2743                 lambdaTranslationMap = (tree.sym.flags() &amp; SYNTHETIC) != 0 &amp;&amp;
2744                         tree.sym.name.startsWith(names.lambda) ?
2745                         makeTranslationMap(tree) : null;
2746                 super.visitMethodDef(tree);
2747             } finally {
2748                 lambdaTranslationMap = prevLambdaTranslationMap;
2749             }
2750         }
2751         if (tree.name == names.init &amp;&amp; (tree.sym.flags_field &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
2752             // lets find out if there is any field waiting to be initialized
2753             ListBuffer&lt;VarSymbol&gt; fields = new ListBuffer&lt;&gt;();
2754             for (Symbol sym : currentClass.getEnclosedElements()) {
2755                 if (sym.kind == Kinds.Kind.VAR &amp;&amp; ((sym.flags() &amp; RECORD) != 0))
2756                     fields.append((VarSymbol) sym);
2757             }
2758             for (VarSymbol field: fields) {
2759                 if ((field.flags_field &amp; Flags.UNINITIALIZED_FIELD) != 0) {
2760                     VarSymbol param = tree.params.stream().filter(p -&gt; p.name == field.name).findFirst().get().sym;
2761                     make.at(tree.pos);
2762                     tree.body.stats = tree.body.stats.append(
2763                             make.Exec(
2764                                     make.Assign(
2765                                             make.Select(make.This(field.owner.erasure(types)), field),
2766                                             make.Ident(param)).setType(field.erasure(types))));
2767                     // we don&#39;t need the flag at the field anymore
2768                     field.flags_field &amp;= ~Flags.UNINITIALIZED_FIELD;
2769                 }
2770             }
2771         }
2772         result = tree;
2773     }
2774     //where
2775         private Map&lt;Symbol, Symbol&gt; makeTranslationMap(JCMethodDecl tree) {
2776             Map&lt;Symbol, Symbol&gt; translationMap = new HashMap&lt;&gt;();
2777             for (JCVariableDecl vd : tree.params) {
2778                 Symbol p = vd.sym;
2779                 if (p != p.baseSymbol()) {
2780                     translationMap.put(p.baseSymbol(), p);
2781                 }
2782             }
2783             return translationMap;
2784         }
2785 
2786     public void visitTypeCast(JCTypeCast tree) {
2787         tree.clazz = translate(tree.clazz);
2788         if (tree.type.isPrimitive() != tree.expr.type.isPrimitive())
2789             tree.expr = translate(tree.expr, tree.type);
2790         else
2791             tree.expr = translate(tree.expr);
2792         result = tree;
2793     }
2794 
2795     public void visitNewClass(JCNewClass tree) {
2796         ClassSymbol c = (ClassSymbol)tree.constructor.owner;
2797 
2798         // Box arguments, if necessary
2799         boolean isEnum = (tree.constructor.owner.flags() &amp; ENUM) != 0;
2800         List&lt;Type&gt; argTypes = tree.constructor.type.getParameterTypes();
2801         if (isEnum) argTypes = argTypes.prepend(syms.intType).prepend(syms.stringType);
2802         tree.args = boxArgs(argTypes, tree.args, tree.varargsElement);
2803         tree.varargsElement = null;
2804 
2805         // If created class is local, add free variables after
2806         // explicit constructor arguments.
2807         if (c.isLocal()) {
2808             tree.args = tree.args.appendList(loadFreevars(tree.pos(), freevars(c)));
2809         }
2810 
2811         // If an access constructor is used, append null as a last argument.
2812         Symbol constructor = accessConstructor(tree.pos(), tree.constructor);
2813         if (constructor != tree.constructor) {
2814             tree.args = tree.args.append(makeNull());
2815             tree.constructor = constructor;
2816         }
2817 
2818         // If created class has an outer instance, and new is qualified, pass
2819         // qualifier as first argument. If new is not qualified, pass the
2820         // correct outer instance as first argument.
2821         if (c.hasOuterInstance()) {
2822             JCExpression thisArg;
2823             if (tree.encl != null) {
2824                 thisArg = attr.makeNullCheck(translate(tree.encl));
2825                 thisArg.type = tree.encl.type;
2826             } else if (c.isLocal()) {
2827                 // local class
2828                 thisArg = makeThis(tree.pos(), c.type.getEnclosingType().tsym);
2829             } else {
2830                 // nested class
2831                 thisArg = makeOwnerThis(tree.pos(), c, false);
2832             }
2833             tree.args = tree.args.prepend(thisArg);
2834         }
2835         tree.encl = null;
2836 
2837         // If we have an anonymous class, create its flat version, rather
2838         // than the class or interface following new.
2839         if (tree.def != null) {
2840             translate(tree.def);
2841             tree.clazz = access(make_at(tree.clazz.pos()).Ident(tree.def.sym));
2842             tree.def = null;
2843         } else {
2844             tree.clazz = access(c, tree.clazz, enclOp, false);
2845         }
2846         result = tree;
2847     }
2848 
2849     // Simplify conditionals with known constant controlling expressions.
2850     // This allows us to avoid generating supporting declarations for
2851     // the dead code, which will not be eliminated during code generation.
2852     // Note that Flow.isFalse and Flow.isTrue only return true
2853     // for constant expressions in the sense of JLS 15.27, which
2854     // are guaranteed to have no side-effects.  More aggressive
2855     // constant propagation would require that we take care to
2856     // preserve possible side-effects in the condition expression.
2857 
2858     // One common case is equality expressions involving a constant and null.
2859     // Since null is not a constant expression (because null cannot be
2860     // represented in the constant pool), equality checks involving null are
2861     // not captured by Flow.isTrue/isFalse.
2862     // Equality checks involving a constant and null, e.g.
2863     //     &quot;&quot; == null
2864     // are safe to simplify as no side-effects can occur.
2865 
2866     private boolean isTrue(JCTree exp) {
2867         if (exp.type.isTrue())
2868             return true;
2869         Boolean b = expValue(exp);
2870         return b == null ? false : b;
2871     }
2872     private boolean isFalse(JCTree exp) {
2873         if (exp.type.isFalse())
2874             return true;
2875         Boolean b = expValue(exp);
2876         return b == null ? false : !b;
2877     }
2878     /* look for (in)equality relations involving null.
2879      * return true - if expression is always true
2880      *       false - if expression is always false
2881      *        null - if expression cannot be eliminated
2882      */
2883     private Boolean expValue(JCTree exp) {
2884         while (exp.hasTag(PARENS))
2885             exp = ((JCParens)exp).expr;
2886 
2887         boolean eq;
2888         switch (exp.getTag()) {
2889         case EQ: eq = true;  break;
2890         case NE: eq = false; break;
2891         default:
2892             return null;
2893         }
2894 
2895         // we have a JCBinary(EQ|NE)
2896         // check if we have two literals (constants or null)
2897         JCBinary b = (JCBinary)exp;
2898         if (b.lhs.type.hasTag(BOT)) return expValueIsNull(eq, b.rhs);
2899         if (b.rhs.type.hasTag(BOT)) return expValueIsNull(eq, b.lhs);
2900         return null;
2901     }
2902     private Boolean expValueIsNull(boolean eq, JCTree t) {
2903         if (t.type.hasTag(BOT)) return Boolean.valueOf(eq);
2904         if (t.hasTag(LITERAL))  return Boolean.valueOf(!eq);
2905         return null;
2906     }
2907 
2908     /** Visitor method for conditional expressions.
2909      */
2910     @Override
2911     public void visitConditional(JCConditional tree) {
2912         JCTree cond = tree.cond = translate(tree.cond, syms.booleanType);
2913         if (isTrue(cond)) {
2914             result = convert(translate(tree.truepart, tree.type), tree.type);
2915             addPrunedInfo(cond);
2916         } else if (isFalse(cond)) {
2917             result = convert(translate(tree.falsepart, tree.type), tree.type);
2918             addPrunedInfo(cond);
2919         } else {
2920             // Condition is not a compile-time constant.
2921             tree.truepart = translate(tree.truepart, tree.type);
2922             tree.falsepart = translate(tree.falsepart, tree.type);
2923             result = tree;
2924         }
2925     }
2926 //where
2927     private JCExpression convert(JCExpression tree, Type pt) {
2928         if (tree.type == pt || tree.type.hasTag(BOT))
2929             return tree;
2930         JCExpression result = make_at(tree.pos()).TypeCast(make.Type(pt), tree);
2931         result.type = (tree.type.constValue() != null) ? cfolder.coerce(tree.type, pt)
2932                                                        : pt;
2933         return result;
2934     }
2935 
2936     /** Visitor method for if statements.
2937      */
2938     public void visitIf(JCIf tree) {
2939         JCTree cond = tree.cond = translate(tree.cond, syms.booleanType);
2940         if (isTrue(cond)) {
2941             result = translate(tree.thenpart);
2942             addPrunedInfo(cond);
2943         } else if (isFalse(cond)) {
2944             if (tree.elsepart != null) {
2945                 result = translate(tree.elsepart);
2946             } else {
2947                 result = make.Skip();
2948             }
2949             addPrunedInfo(cond);
2950         } else {
2951             // Condition is not a compile-time constant.
2952             tree.thenpart = translate(tree.thenpart);
2953             tree.elsepart = translate(tree.elsepart);
2954             result = tree;
2955         }
2956     }
2957 
2958     /** Visitor method for assert statements. Translate them away.
2959      */
2960     public void visitAssert(JCAssert tree) {
2961         tree.cond = translate(tree.cond, syms.booleanType);
2962         if (!tree.cond.type.isTrue()) {
2963             JCExpression cond = assertFlagTest(tree.pos());
2964             List&lt;JCExpression&gt; exnArgs = (tree.detail == null) ?
2965                 List.nil() : List.of(translate(tree.detail));
2966             if (!tree.cond.type.isFalse()) {
2967                 cond = makeBinary
2968                     (AND,
2969                      cond,
2970                      makeUnary(NOT, tree.cond));
2971             }
2972             result =
2973                 make.If(cond,
2974                         make_at(tree).
2975                            Throw(makeNewClass(syms.assertionErrorType, exnArgs)),
2976                         null);
2977         } else {
2978             result = make.Skip();
2979         }
2980     }
2981 
2982     public void visitApply(JCMethodInvocation tree) {
2983         Symbol meth = TreeInfo.symbol(tree.meth);
2984         List&lt;Type&gt; argtypes = meth.type.getParameterTypes();
2985         if (meth.name == names.init &amp;&amp; meth.owner == syms.enumSym)
2986             argtypes = argtypes.tail.tail;
2987         tree.args = boxArgs(argtypes, tree.args, tree.varargsElement);
2988         tree.varargsElement = null;
2989         Name methName = TreeInfo.name(tree.meth);
2990         if (meth.name==names.init) {
2991             // We are seeing a this(...) or super(...) constructor call.
2992             // If an access constructor is used, append null as a last argument.
2993             Symbol constructor = accessConstructor(tree.pos(), meth);
2994             if (constructor != meth) {
2995                 tree.args = tree.args.append(makeNull());
2996                 TreeInfo.setSymbol(tree.meth, constructor);
2997             }
2998 
2999             // If we are calling a constructor of a local class, add
3000             // free variables after explicit constructor arguments.
3001             ClassSymbol c = (ClassSymbol)constructor.owner;
3002             if (c.isLocal()) {
3003                 tree.args = tree.args.appendList(loadFreevars(tree.pos(), freevars(c)));
3004             }
3005 
3006             // If we are calling a constructor of an enum class, pass
3007             // along the name and ordinal arguments
3008             if ((c.flags_field&amp;ENUM) != 0 || c.getQualifiedName() == names.java_lang_Enum) {
3009                 List&lt;JCVariableDecl&gt; params = currentMethodDef.params;
3010                 if (currentMethodSym.owner.hasOuterInstance())
3011                     params = params.tail; // drop this$n
3012                 tree.args = tree.args
3013                     .prepend(make_at(tree.pos()).Ident(params.tail.head.sym)) // ordinal
3014                     .prepend(make.Ident(params.head.sym)); // name
3015             }
3016 
3017             // If we are calling a constructor of a class with an outer
3018             // instance, and the call
3019             // is qualified, pass qualifier as first argument in front of
3020             // the explicit constructor arguments. If the call
3021             // is not qualified, pass the correct outer instance as
3022             // first argument.
3023             if (c.hasOuterInstance()) {
3024                 JCExpression thisArg;
3025                 if (tree.meth.hasTag(SELECT)) {
3026                     thisArg = attr.
3027                         makeNullCheck(translate(((JCFieldAccess) tree.meth).selected));
3028                     tree.meth = make.Ident(constructor);
3029                     ((JCIdent) tree.meth).name = methName;
3030                 } else if (c.isLocal() || methName == names._this){
3031                     // local class or this() call
3032                     thisArg = makeThis(tree.meth.pos(), c.type.getEnclosingType().tsym);
3033                 } else {
3034                     // super() call of nested class - never pick &#39;this&#39;
3035                     thisArg = makeOwnerThisN(tree.meth.pos(), c, false);
3036                 }
3037                 tree.args = tree.args.prepend(thisArg);
3038             }
3039         } else {
3040             // We are seeing a normal method invocation; translate this as usual.
3041             tree.meth = translate(tree.meth);
3042 
3043             // If the translated method itself is an Apply tree, we are
3044             // seeing an access method invocation. In this case, append
3045             // the method arguments to the arguments of the access method.
3046             if (tree.meth.hasTag(APPLY)) {
3047                 JCMethodInvocation app = (JCMethodInvocation)tree.meth;
3048                 app.args = tree.args.prependList(app.args);
3049                 result = app;
3050                 return;
3051             }
3052         }
3053         result = tree;
3054     }
3055 
3056     List&lt;JCExpression&gt; boxArgs(List&lt;Type&gt; parameters, List&lt;JCExpression&gt; _args, Type varargsElement) {
3057         List&lt;JCExpression&gt; args = _args;
3058         if (parameters.isEmpty()) return args;
3059         boolean anyChanges = false;
3060         ListBuffer&lt;JCExpression&gt; result = new ListBuffer&lt;&gt;();
3061         while (parameters.tail.nonEmpty()) {
3062             JCExpression arg = translate(args.head, parameters.head);
3063             anyChanges |= (arg != args.head);
3064             result.append(arg);
3065             args = args.tail;
3066             parameters = parameters.tail;
3067         }
3068         Type parameter = parameters.head;
3069         if (varargsElement != null) {
3070             anyChanges = true;
3071             ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
3072             while (args.nonEmpty()) {
3073                 JCExpression arg = translate(args.head, varargsElement);
3074                 elems.append(arg);
3075                 args = args.tail;
3076             }
3077             JCNewArray boxedArgs = make.NewArray(make.Type(varargsElement),
3078                                                List.nil(),
3079                                                elems.toList());
3080             boxedArgs.type = new ArrayType(varargsElement, syms.arrayClass);
3081             result.append(boxedArgs);
3082         } else {
3083             if (args.length() != 1) throw new AssertionError(args);
3084             JCExpression arg = translate(args.head, parameter);
3085             anyChanges |= (arg != args.head);
3086             result.append(arg);
3087             if (!anyChanges) return _args;
3088         }
3089         return result.toList();
3090     }
3091 
3092     /** Expand a boxing or unboxing conversion if needed. */
3093     @SuppressWarnings(&quot;unchecked&quot;) // XXX unchecked
3094     &lt;T extends JCExpression&gt; T boxIfNeeded(T tree, Type type) {
3095         boolean havePrimitive = tree.type.isPrimitive();
3096         if (havePrimitive == type.isPrimitive())
3097             return tree;
3098         if (havePrimitive) {
3099             Type unboxedTarget = types.unboxedType(type);
3100             if (!unboxedTarget.hasTag(NONE)) {
3101                 if (!types.isSubtype(tree.type, unboxedTarget)) //e.g. Character c = 89;
3102                     tree.type = unboxedTarget.constType(tree.type.constValue());
3103                 return (T)boxPrimitive(tree, types.erasure(type));
3104             } else {
3105                 tree = (T)boxPrimitive(tree);
3106             }
3107         } else {
3108             tree = (T)unbox(tree, type);
3109         }
3110         return tree;
3111     }
3112 
3113     /** Box up a single primitive expression. */
3114     JCExpression boxPrimitive(JCExpression tree) {
3115         return boxPrimitive(tree, types.boxedClass(tree.type).type);
3116     }
3117 
3118     /** Box up a single primitive expression. */
3119     JCExpression boxPrimitive(JCExpression tree, Type box) {
3120         make_at(tree.pos());
3121         Symbol valueOfSym = lookupMethod(tree.pos(),
3122                                          names.valueOf,
3123                                          box,
3124                                          List.&lt;Type&gt;nil()
3125                                          .prepend(tree.type));
3126         return make.App(make.QualIdent(valueOfSym), List.of(tree));
3127     }
3128 
3129     /** Unbox an object to a primitive value. */
3130     JCExpression unbox(JCExpression tree, Type primitive) {
3131         Type unboxedType = types.unboxedType(tree.type);
3132         if (unboxedType.hasTag(NONE)) {
3133             unboxedType = primitive;
3134             if (!unboxedType.isPrimitive())
3135                 throw new AssertionError(unboxedType);
3136             make_at(tree.pos());
3137             tree = make.TypeCast(types.boxedClass(unboxedType).type, tree);
3138         } else {
3139             // There must be a conversion from unboxedType to primitive.
3140             if (!types.isSubtype(unboxedType, primitive))
3141                 throw new AssertionError(tree);
3142         }
3143         make_at(tree.pos());
3144         Symbol valueSym = lookupMethod(tree.pos(),
3145                                        unboxedType.tsym.name.append(names.Value), // x.intValue()
3146                                        tree.type,
3147                                        List.nil());
3148         return make.App(make.Select(tree, valueSym));
3149     }
3150 
3151     /** Visitor method for parenthesized expressions.
3152      *  If the subexpression has changed, omit the parens.
3153      */
3154     public void visitParens(JCParens tree) {
3155         JCTree expr = translate(tree.expr);
3156         result = ((expr == tree.expr) ? tree : expr);
3157     }
3158 
3159     public void visitIndexed(JCArrayAccess tree) {
3160         tree.indexed = translate(tree.indexed);
3161         tree.index = translate(tree.index, syms.intType);
3162         result = tree;
3163     }
3164 
3165     public void visitAssign(JCAssign tree) {
3166         tree.lhs = translate(tree.lhs, tree);
3167         tree.rhs = translate(tree.rhs, tree.lhs.type);
3168 
3169         // If translated left hand side is an Apply, we are
3170         // seeing an access method invocation. In this case, append
3171         // right hand side as last argument of the access method.
3172         if (tree.lhs.hasTag(APPLY)) {
3173             JCMethodInvocation app = (JCMethodInvocation)tree.lhs;
3174             app.args = List.of(tree.rhs).prependList(app.args);
3175             result = app;
3176         } else {
3177             result = tree;
3178         }
3179     }
3180 
3181     public void visitAssignop(final JCAssignOp tree) {
3182         final boolean boxingReq = !tree.lhs.type.isPrimitive() &amp;&amp;
3183             tree.operator.type.getReturnType().isPrimitive();
3184 
3185         AssignopDependencyScanner depScanner = new AssignopDependencyScanner(tree);
3186         depScanner.scan(tree.rhs);
3187 
3188         if (boxingReq || depScanner.dependencyFound) {
3189             // boxing required; need to rewrite as x = (unbox typeof x)(x op y);
3190             // or if x == (typeof x)z then z = (unbox typeof x)((typeof x)z op y)
3191             // (but without recomputing x)
3192             JCTree newTree = abstractLval(tree.lhs, lhs -&gt; {
3193                 Tag newTag = tree.getTag().noAssignOp();
3194                 // Erasure (TransTypes) can change the type of
3195                 // tree.lhs.  However, we can still get the
3196                 // unerased type of tree.lhs as it is stored
3197                 // in tree.type in Attr.
3198                 OperatorSymbol newOperator = operators.resolveBinary(tree,
3199                                                               newTag,
3200                                                               tree.type,
3201                                                               tree.rhs.type);
3202                 //Need to use the &quot;lhs&quot; at two places, once on the future left hand side
3203                 //and once in the future binary operator. But further processing may change
3204                 //the components of the tree in place (see visitSelect for e.g. &lt;Class&gt;.super.&lt;ident&gt;),
3205                 //so cloning the tree to avoid interference between the uses:
3206                 JCExpression expr = (JCExpression) lhs.clone();
3207                 if (expr.type != tree.type)
3208                     expr = make.TypeCast(tree.type, expr);
3209                 JCBinary opResult = make.Binary(newTag, expr, tree.rhs);
3210                 opResult.operator = newOperator;
3211                 opResult.type = newOperator.type.getReturnType();
3212                 JCExpression newRhs = boxingReq ?
3213                     make.TypeCast(types.unboxedType(tree.type), opResult) :
3214                     opResult;
3215                 return make.Assign(lhs, newRhs).setType(tree.type);
3216             });
3217             result = translate(newTree);
3218             return;
3219         }
3220         tree.lhs = translate(tree.lhs, tree);
3221         tree.rhs = translate(tree.rhs, tree.operator.type.getParameterTypes().tail.head);
3222 
3223         // If translated left hand side is an Apply, we are
3224         // seeing an access method invocation. In this case, append
3225         // right hand side as last argument of the access method.
3226         if (tree.lhs.hasTag(APPLY)) {
3227             JCMethodInvocation app = (JCMethodInvocation)tree.lhs;
3228             // if operation is a += on strings,
3229             // make sure to convert argument to string
3230             JCExpression rhs = tree.operator.opcode == string_add
3231               ? makeString(tree.rhs)
3232               : tree.rhs;
3233             app.args = List.of(rhs).prependList(app.args);
3234             result = app;
3235         } else {
3236             result = tree;
3237         }
3238     }
3239 
3240     class AssignopDependencyScanner extends TreeScanner {
3241 
3242         Symbol sym;
3243         boolean dependencyFound = false;
3244 
3245         AssignopDependencyScanner(JCAssignOp tree) {
3246             this.sym = TreeInfo.symbol(tree.lhs);
3247         }
3248 
3249         @Override
3250         public void scan(JCTree tree) {
3251             if (tree != null &amp;&amp; sym != null) {
3252                 tree.accept(this);
3253             }
3254         }
3255 
3256         @Override
3257         public void visitAssignop(JCAssignOp tree) {
3258             if (TreeInfo.symbol(tree.lhs) == sym) {
3259                 dependencyFound = true;
3260                 return;
3261             }
3262             super.visitAssignop(tree);
3263         }
3264 
3265         @Override
3266         public void visitUnary(JCUnary tree) {
3267             if (TreeInfo.symbol(tree.arg) == sym) {
3268                 dependencyFound = true;
3269                 return;
3270             }
3271             super.visitUnary(tree);
3272         }
3273     }
3274 
3275     /** Lower a tree of the form e++ or e-- where e is an object type */
3276     JCExpression lowerBoxedPostop(final JCUnary tree) {
3277         // translate to tmp1=lval(e); tmp2=tmp1; tmp1 OP 1; tmp2
3278         // or
3279         // translate to tmp1=lval(e); tmp2=tmp1; (typeof tree)tmp1 OP 1; tmp2
3280         // where OP is += or -=
3281         final boolean cast = TreeInfo.skipParens(tree.arg).hasTag(TYPECAST);
3282         return abstractLval(tree.arg, tmp1 -&gt; abstractRval(tmp1, tree.arg.type, tmp2 -&gt; {
3283             Tag opcode = (tree.hasTag(POSTINC))
3284                 ? PLUS_ASG : MINUS_ASG;
3285             //&quot;tmp1&quot; and &quot;tmp2&quot; may refer to the same instance
3286             //(for e.g. &lt;Class&gt;.super.&lt;ident&gt;). But further processing may
3287             //change the components of the tree in place (see visitSelect),
3288             //so cloning the tree to avoid interference between the two uses:
3289             JCExpression lhs = (JCExpression)tmp1.clone();
3290             lhs = cast
3291                 ? make.TypeCast(tree.arg.type, lhs)
3292                 : lhs;
3293             JCExpression update = makeAssignop(opcode,
3294                                          lhs,
3295                                          make.Literal(1));
3296             return makeComma(update, tmp2);
3297         }));
3298     }
3299 
3300     public void visitUnary(JCUnary tree) {
3301         boolean isUpdateOperator = tree.getTag().isIncOrDecUnaryOp();
3302         if (isUpdateOperator &amp;&amp; !tree.arg.type.isPrimitive()) {
3303             switch(tree.getTag()) {
3304             case PREINC:            // ++ e
3305                     // translate to e += 1
3306             case PREDEC:            // -- e
3307                     // translate to e -= 1
3308                 {
3309                     JCTree.Tag opcode = (tree.hasTag(PREINC))
3310                         ? PLUS_ASG : MINUS_ASG;
3311                     JCAssignOp newTree = makeAssignop(opcode,
3312                                                     tree.arg,
3313                                                     make.Literal(1));
3314                     result = translate(newTree, tree.type);
3315                     return;
3316                 }
3317             case POSTINC:           // e ++
3318             case POSTDEC:           // e --
3319                 {
3320                     result = translate(lowerBoxedPostop(tree), tree.type);
3321                     return;
3322                 }
3323             }
3324             throw new AssertionError(tree);
3325         }
3326 
3327         tree.arg = boxIfNeeded(translate(tree.arg, tree), tree.type);
3328 
3329         if (tree.hasTag(NOT) &amp;&amp; tree.arg.type.constValue() != null) {
3330             tree.type = cfolder.fold1(bool_not, tree.arg.type);
3331         }
3332 
3333         // If translated left hand side is an Apply, we are
3334         // seeing an access method invocation. In this case, return
3335         // that access method invocation as result.
3336         if (isUpdateOperator &amp;&amp; tree.arg.hasTag(APPLY)) {
3337             result = tree.arg;
3338         } else {
3339             result = tree;
3340         }
3341     }
3342 
3343     public void visitBinary(JCBinary tree) {
3344         List&lt;Type&gt; formals = tree.operator.type.getParameterTypes();
3345         JCTree lhs = tree.lhs = translate(tree.lhs, formals.head);
3346         switch (tree.getTag()) {
3347         case OR:
3348             if (isTrue(lhs)) {
3349                 result = lhs;
3350                 return;
3351             }
3352             if (isFalse(lhs)) {
3353                 result = translate(tree.rhs, formals.tail.head);
3354                 return;
3355             }
3356             break;
3357         case AND:
3358             if (isFalse(lhs)) {
3359                 result = lhs;
3360                 return;
3361             }
3362             if (isTrue(lhs)) {
3363                 result = translate(tree.rhs, formals.tail.head);
3364                 return;
3365             }
3366             break;
3367         }
3368         tree.rhs = translate(tree.rhs, formals.tail.head);
3369         result = tree;
3370     }
3371 
3372     public void visitIdent(JCIdent tree) {
3373         result = access(tree.sym, tree, enclOp, false);
3374     }
3375 
3376     /** Translate away the foreach loop.  */
3377     public void visitForeachLoop(JCEnhancedForLoop tree) {
3378         if (types.elemtype(tree.expr.type) == null)
3379             visitIterableForeachLoop(tree);
3380         else
3381             visitArrayForeachLoop(tree);
3382     }
3383         // where
3384         /**
3385          * A statement of the form
3386          *
3387          * &lt;pre&gt;
3388          *     for ( T v : arrayexpr ) stmt;
3389          * &lt;/pre&gt;
3390          *
3391          * (where arrayexpr is of an array type) gets translated to
3392          *
3393          * &lt;pre&gt;{@code
3394          *     for ( { arraytype #arr = arrayexpr;
3395          *             int #len = array.length;
3396          *             int #i = 0; };
3397          *           #i &lt; #len; i$++ ) {
3398          *         T v = arr$[#i];
3399          *         stmt;
3400          *     }
3401          * }&lt;/pre&gt;
3402          *
3403          * where #arr, #len, and #i are freshly named synthetic local variables.
3404          */
3405         private void visitArrayForeachLoop(JCEnhancedForLoop tree) {
3406             make_at(tree.expr.pos());
3407             VarSymbol arraycache = new VarSymbol(SYNTHETIC,
3408                                                  names.fromString(&quot;arr&quot; + target.syntheticNameChar()),
3409                                                  tree.expr.type,
3410                                                  currentMethodSym);
3411             JCStatement arraycachedef = make.VarDef(arraycache, tree.expr);
3412             VarSymbol lencache = new VarSymbol(SYNTHETIC,
3413                                                names.fromString(&quot;len&quot; + target.syntheticNameChar()),
3414                                                syms.intType,
3415                                                currentMethodSym);
3416             JCStatement lencachedef = make.
3417                 VarDef(lencache, make.Select(make.Ident(arraycache), syms.lengthVar));
3418             VarSymbol index = new VarSymbol(SYNTHETIC,
3419                                             names.fromString(&quot;i&quot; + target.syntheticNameChar()),
3420                                             syms.intType,
3421                                             currentMethodSym);
3422 
3423             JCVariableDecl indexdef = make.VarDef(index, make.Literal(INT, 0));
3424             indexdef.init.type = indexdef.type = syms.intType.constType(0);
3425 
3426             List&lt;JCStatement&gt; loopinit = List.of(arraycachedef, lencachedef, indexdef);
3427             JCBinary cond = makeBinary(LT, make.Ident(index), make.Ident(lencache));
3428 
3429             JCExpressionStatement step = make.Exec(makeUnary(PREINC, make.Ident(index)));
3430 
3431             Type elemtype = types.elemtype(tree.expr.type);
3432             JCExpression loopvarinit = make.Indexed(make.Ident(arraycache),
3433                                                     make.Ident(index)).setType(elemtype);
3434             JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,
3435                                                   tree.var.name,
3436                                                   tree.var.vartype,
3437                                                   loopvarinit).setType(tree.var.type);
3438             loopvardef.sym = tree.var.sym;
3439             JCBlock body = make.
3440                 Block(0, List.of(loopvardef, tree.body));
3441 
3442             result = translate(make.
3443                                ForLoop(loopinit,
3444                                        cond,
3445                                        List.of(step),
3446                                        body));
3447             patchTargets(body, tree, result);
3448         }
3449         /** Patch up break and continue targets. */
3450         private void patchTargets(JCTree body, final JCTree src, final JCTree dest) {
3451             class Patcher extends TreeScanner {
3452                 public void visitBreak(JCBreak tree) {
3453                     if (tree.target == src)
3454                         tree.target = dest;
3455                 }
3456                 public void visitYield(JCYield tree) {
3457                     if (tree.target == src)
3458                         tree.target = dest;
3459                     scan(tree.value);
3460                 }
3461                 public void visitContinue(JCContinue tree) {
3462                     if (tree.target == src)
3463                         tree.target = dest;
3464                 }
3465                 public void visitClassDef(JCClassDecl tree) {}
3466             }
3467             new Patcher().scan(body);
3468         }
3469         /**
3470          * A statement of the form
3471          *
3472          * &lt;pre&gt;
3473          *     for ( T v : coll ) stmt ;
3474          * &lt;/pre&gt;
3475          *
3476          * (where coll implements {@code Iterable&lt;? extends T&gt;}) gets translated to
3477          *
3478          * &lt;pre&gt;{@code
3479          *     for ( Iterator&lt;? extends T&gt; #i = coll.iterator(); #i.hasNext(); ) {
3480          *         T v = (T) #i.next();
3481          *         stmt;
3482          *     }
3483          * }&lt;/pre&gt;
3484          *
3485          * where #i is a freshly named synthetic local variable.
3486          */
3487         private void visitIterableForeachLoop(JCEnhancedForLoop tree) {
3488             make_at(tree.expr.pos());
3489             Type iteratorTarget = syms.objectType;
3490             Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),
3491                                               syms.iterableType.tsym);
3492             if (iterableType.getTypeArguments().nonEmpty())
3493                 iteratorTarget = types.erasure(iterableType.getTypeArguments().head);
3494             Type eType = types.skipTypeVars(tree.expr.type, false);
3495             tree.expr.type = types.erasure(eType);
3496             if (eType.isCompound())
3497                 tree.expr = make.TypeCast(types.erasure(iterableType), tree.expr);
3498             Symbol iterator = lookupMethod(tree.expr.pos(),
3499                                            names.iterator,
3500                                            eType,
3501                                            List.nil());
3502             VarSymbol itvar = new VarSymbol(SYNTHETIC, names.fromString(&quot;i&quot; + target.syntheticNameChar()),
3503                                             types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)),
3504                                             currentMethodSym);
3505 
3506              JCStatement init = make.
3507                 VarDef(itvar, make.App(make.Select(tree.expr, iterator)
3508                      .setType(types.erasure(iterator.type))));
3509 
3510             Symbol hasNext = lookupMethod(tree.expr.pos(),
3511                                           names.hasNext,
3512                                           itvar.type,
3513                                           List.nil());
3514             JCMethodInvocation cond = make.App(make.Select(make.Ident(itvar), hasNext));
3515             Symbol next = lookupMethod(tree.expr.pos(),
3516                                        names.next,
3517                                        itvar.type,
3518                                        List.nil());
3519             JCExpression vardefinit = make.App(make.Select(make.Ident(itvar), next));
3520             if (tree.var.type.isPrimitive())
3521                 vardefinit = make.TypeCast(types.cvarUpperBound(iteratorTarget), vardefinit);
3522             else
3523                 vardefinit = make.TypeCast(tree.var.type, vardefinit);
3524             JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,
3525                                                   tree.var.name,
3526                                                   tree.var.vartype,
3527                                                   vardefinit).setType(tree.var.type);
3528             indexDef.sym = tree.var.sym;
3529             JCBlock body = make.Block(0, List.of(indexDef, tree.body));
3530             body.endpos = TreeInfo.endPos(tree.body);
3531             result = translate(make.
3532                 ForLoop(List.of(init),
3533                         cond,
3534                         List.nil(),
3535                         body));
3536             patchTargets(body, tree, result);
3537         }
3538 
3539     public void visitVarDef(JCVariableDecl tree) {
3540         MethodSymbol oldMethodSym = currentMethodSym;
3541         tree.mods = translate(tree.mods);
3542         tree.vartype = translate(tree.vartype);
3543         if (currentMethodSym == null) {
3544             // A class or instance field initializer.
3545             currentMethodSym =
3546                 new MethodSymbol((tree.mods.flags&amp;STATIC) | BLOCK,
3547                                  names.empty, null,
3548                                  currentClass);
3549         }
3550         if (tree.init != null) tree.init = translate(tree.init, tree.type);
3551         result = tree;
3552         currentMethodSym = oldMethodSym;
3553     }
3554 
3555     public void visitBlock(JCBlock tree) {
3556         MethodSymbol oldMethodSym = currentMethodSym;
3557         if (currentMethodSym == null) {
3558             // Block is a static or instance initializer.
3559             currentMethodSym =
3560                 new MethodSymbol(tree.flags | BLOCK,
3561                                  names.empty, null,
3562                                  currentClass);
3563         }
3564         super.visitBlock(tree);
3565         currentMethodSym = oldMethodSym;
3566     }
3567 
3568     public void visitDoLoop(JCDoWhileLoop tree) {
3569         tree.body = translate(tree.body);
3570         tree.cond = translate(tree.cond, syms.booleanType);
3571         result = tree;
3572     }
3573 
3574     public void visitWhileLoop(JCWhileLoop tree) {
3575         tree.cond = translate(tree.cond, syms.booleanType);
3576         tree.body = translate(tree.body);
3577         result = tree;
3578     }
3579 
3580     public void visitWithField(JCWithField tree) {
3581         Type fieldType = tree.field.type;
3582         tree.field = translate(tree.field, tree);
3583         tree.value = translate(tree.value, fieldType); // important to use pre-translation type.
3584 
3585         // If translated field is an Apply, we are
3586         // seeing an access method invocation. In this case, append
3587         // right hand side as last argument of the access method.
3588         if (tree.field.hasTag(APPLY)) {
3589             JCMethodInvocation app = (JCMethodInvocation) tree.field;
3590             app.args = List.of(tree.value).prependList(app.args);
3591             result = app;
3592         } else {
3593             result = tree;
3594         }
3595     }
3596 
3597     public void visitForLoop(JCForLoop tree) {
3598         tree.init = translate(tree.init);
3599         if (tree.cond != null)
3600             tree.cond = translate(tree.cond, syms.booleanType);
3601         tree.step = translate(tree.step);
3602         tree.body = translate(tree.body);
3603         result = tree;
3604     }
3605 
3606     public void visitReturn(JCReturn tree) {
3607         if (tree.expr != null)
3608             tree.expr = translate(tree.expr,
3609                                   types.erasure(currentMethodDef
3610                                                 .restype.type));
3611         result = tree;
3612     }
3613 
3614     public void visitSwitch(JCSwitch tree) {
3615         handleSwitch(tree, tree.selector, tree.cases);
3616     }
3617 
3618     @Override
3619     public void visitSwitchExpression(JCSwitchExpression tree) {
3620         if (tree.cases.stream().noneMatch(c -&gt; c.pats.isEmpty())) {
3621             JCThrow thr = make.Throw(makeNewClass(syms.incompatibleClassChangeErrorType,
3622                                                   List.nil()));
3623             JCCase c = make.Case(JCCase.STATEMENT, List.nil(), List.of(thr), null);
3624             tree.cases = tree.cases.append(c);
3625         }
3626         handleSwitch(tree, tree.selector, tree.cases);
3627     }
3628 
3629     private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
3630         //expand multiple label cases:
3631         ListBuffer&lt;JCCase&gt; convertedCases = new ListBuffer&lt;&gt;();
3632 
3633         for (JCCase c : cases) {
3634             switch (c.pats.size()) {
3635                 case 0: //default
3636                 case 1: //single label
3637                     convertedCases.append(c);
3638                     break;
3639                 default: //multiple labels, expand:
3640                     //case C1, C2, C3: ...
3641                     //=&gt;
3642                     //case C1:
3643                     //case C2:
3644                     //case C3: ...
3645                     List&lt;JCExpression&gt; patterns = c.pats;
3646                     while (patterns.tail.nonEmpty()) {
3647                         convertedCases.append(make_at(c.pos()).Case(JCCase.STATEMENT,
3648                                                            List.of(patterns.head),
3649                                                            List.nil(),
3650                                                            null));
3651                         patterns = patterns.tail;
3652                     }
3653                     c.pats = patterns;
3654                     convertedCases.append(c);
3655                     break;
3656             }
3657         }
3658 
3659         for (JCCase c : convertedCases) {
3660             if (c.caseKind == JCCase.RULE &amp;&amp; c.completesNormally) {
3661                 JCBreak b = make_at(c.pos()).Break(null);
3662                 b.target = tree;
3663                 c.stats = c.stats.append(b);
3664             }
3665         }
3666 
3667         cases = convertedCases.toList();
3668 
3669         Type selsuper = types.supertype(selector.type);
3670         boolean enumSwitch = selsuper != null &amp;&amp;
3671             (selector.type.tsym.flags() &amp; ENUM) != 0;
3672         boolean stringSwitch = selsuper != null &amp;&amp;
3673             types.isSameType(selector.type, syms.stringType);
3674         Type target = enumSwitch ? selector.type :
3675             (stringSwitch? syms.stringType : syms.intType);
3676         selector = translate(selector, target);
3677         cases = translateCases(cases);
3678         if (tree.hasTag(SWITCH)) {
3679             ((JCSwitch) tree).selector = selector;
3680             ((JCSwitch) tree).cases = cases;
3681         } else if (tree.hasTag(SWITCH_EXPRESSION)) {
3682             ((JCSwitchExpression) tree).selector = selector;
3683             ((JCSwitchExpression) tree).cases = cases;
3684         } else {
3685             Assert.error();
3686         }
3687         if (enumSwitch) {
3688             result = visitEnumSwitch(tree, selector, cases);
3689         } else if (stringSwitch) {
3690             result = visitStringSwitch(tree, selector, cases);
3691         } else {
3692             result = tree;
3693         }
3694     }
3695 
3696     public JCTree visitEnumSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
3697         TypeSymbol enumSym = selector.type.tsym;
3698         EnumMapping map = mapForEnum(tree.pos(), enumSym);
3699         make_at(tree.pos());
3700         Symbol ordinalMethod = lookupMethod(tree.pos(),
3701                                             names.ordinal,
3702                                             selector.type,
3703                                             List.nil());
3704         JCArrayAccess newSelector = make.Indexed(map.mapVar,
3705                                         make.App(make.Select(selector,
3706                                                              ordinalMethod)));
3707         ListBuffer&lt;JCCase&gt; newCases = new ListBuffer&lt;&gt;();
3708         for (JCCase c : cases) {
3709             if (c.pats.nonEmpty()) {
3710                 VarSymbol label = (VarSymbol)TreeInfo.symbol(c.pats.head);
3711                 JCLiteral pat = map.forConstant(label);
3712                 newCases.append(make.Case(JCCase.STATEMENT, List.of(pat), c.stats, null));
3713             } else {
3714                 newCases.append(c);
3715             }
3716         }
3717         JCTree enumSwitch;
3718         if (tree.hasTag(SWITCH)) {
3719             enumSwitch = make.Switch(newSelector, newCases.toList());
3720         } else if (tree.hasTag(SWITCH_EXPRESSION)) {
3721             enumSwitch = make.SwitchExpression(newSelector, newCases.toList());
3722             enumSwitch.setType(tree.type);
3723         } else {
3724             Assert.error();
3725             throw new AssertionError();
3726         }
3727         patchTargets(enumSwitch, tree, enumSwitch);
3728         return enumSwitch;
3729     }
3730 
3731     public JCTree visitStringSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; caseList) {
3732         int alternatives = caseList.size();
3733 
3734         if (alternatives == 0) { // Strange but legal possibility (only legal for switch statement)
3735             return make.at(tree.pos()).Exec(attr.makeNullCheck(selector));
3736         } else {
3737             /*
3738              * The general approach used is to translate a single
3739              * string switch statement into a series of two chained
3740              * switch statements: the first a synthesized statement
3741              * switching on the argument string&#39;s hash value and
3742              * computing a string&#39;s position in the list of original
3743              * case labels, if any, followed by a second switch on the
3744              * computed integer value.  The second switch has the same
3745              * code structure as the original string switch statement
3746              * except that the string case labels are replaced with
3747              * positional integer constants starting at 0.
3748              *
3749              * The first switch statement can be thought of as an
3750              * inlined map from strings to their position in the case
3751              * label list.  An alternate implementation would use an
3752              * actual Map for this purpose, as done for enum switches.
3753              *
3754              * With some additional effort, it would be possible to
3755              * use a single switch statement on the hash code of the
3756              * argument, but care would need to be taken to preserve
3757              * the proper control flow in the presence of hash
3758              * collisions and other complications, such as
3759              * fallthroughs.  Switch statements with one or two
3760              * alternatives could also be specially translated into
3761              * if-then statements to omit the computation of the hash
3762              * code.
3763              *
3764              * The generated code assumes that the hashing algorithm
3765              * of String is the same in the compilation environment as
3766              * in the environment the code will run in.  The string
3767              * hashing algorithm in the SE JDK has been unchanged
3768              * since at least JDK 1.2.  Since the algorithm has been
3769              * specified since that release as well, it is very
3770              * unlikely to be changed in the future.
3771              *
3772              * Different hashing algorithms, such as the length of the
3773              * strings or a perfect hashing algorithm over the
3774              * particular set of case labels, could potentially be
3775              * used instead of String.hashCode.
3776              */
3777 
3778             ListBuffer&lt;JCStatement&gt; stmtList = new ListBuffer&lt;&gt;();
3779 
3780             // Map from String case labels to their original position in
3781             // the list of case labels.
3782             Map&lt;String, Integer&gt; caseLabelToPosition = new LinkedHashMap&lt;&gt;(alternatives + 1, 1.0f);
3783 
3784             // Map of hash codes to the string case labels having that hashCode.
3785             Map&lt;Integer, Set&lt;String&gt;&gt; hashToString = new LinkedHashMap&lt;&gt;(alternatives + 1, 1.0f);
3786 
3787             int casePosition = 0;
3788 
3789             for(JCCase oneCase : caseList) {
3790                 if (oneCase.pats.nonEmpty()) { // pats is empty for a &quot;default&quot; case
3791                     JCExpression expression = oneCase.pats.head;
3792                     String labelExpr = (String) expression.type.constValue();
3793                     Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);
3794                     Assert.checkNull(mapping);
3795                     int hashCode = labelExpr.hashCode();
3796 
3797                     Set&lt;String&gt; stringSet = hashToString.get(hashCode);
3798                     if (stringSet == null) {
3799                         stringSet = new LinkedHashSet&lt;&gt;(1, 1.0f);
3800                         stringSet.add(labelExpr);
3801                         hashToString.put(hashCode, stringSet);
3802                     } else {
3803                         boolean added = stringSet.add(labelExpr);
3804                         Assert.check(added);
3805                     }
3806                 }
3807                 casePosition++;
3808             }
3809 
3810             // Synthesize a switch statement that has the effect of
3811             // mapping from a string to the integer position of that
3812             // string in the list of case labels.  This is done by
3813             // switching on the hashCode of the string followed by an
3814             // if-then-else chain comparing the input for equality
3815             // with all the case labels having that hash value.
3816 
3817             /*
3818              * s$ = top of stack;
3819              * tmp$ = -1;
3820              * switch($s.hashCode()) {
3821              *     case caseLabel.hashCode:
3822              *         if (s$.equals(&quot;caseLabel_1&quot;)
3823              *           tmp$ = caseLabelToPosition(&quot;caseLabel_1&quot;);
3824              *         else if (s$.equals(&quot;caseLabel_2&quot;))
3825              *           tmp$ = caseLabelToPosition(&quot;caseLabel_2&quot;);
3826              *         ...
3827              *         break;
3828              * ...
3829              * }
3830              */
3831 
3832             VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,
3833                                                names.fromString(&quot;s&quot; + tree.pos + target.syntheticNameChar()),
3834                                                syms.stringType,
3835                                                currentMethodSym);
3836             stmtList.append(make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type));
3837 
3838             VarSymbol dollar_tmp = new VarSymbol(SYNTHETIC,
3839                                                  names.fromString(&quot;tmp&quot; + tree.pos + target.syntheticNameChar()),
3840                                                  syms.intType,
3841                                                  currentMethodSym);
3842             JCVariableDecl dollar_tmp_def =
3843                 (JCVariableDecl)make.VarDef(dollar_tmp, make.Literal(INT, -1)).setType(dollar_tmp.type);
3844             dollar_tmp_def.init.type = dollar_tmp.type = syms.intType;
3845             stmtList.append(dollar_tmp_def);
3846             ListBuffer&lt;JCCase&gt; caseBuffer = new ListBuffer&lt;&gt;();
3847             // hashCode will trigger nullcheck on original switch expression
3848             JCMethodInvocation hashCodeCall = makeCall(make.Ident(dollar_s),
3849                                                        names.hashCode,
3850                                                        List.nil()).setType(syms.intType);
3851             JCSwitch switch1 = make.Switch(hashCodeCall,
3852                                         caseBuffer.toList());
3853             for(Map.Entry&lt;Integer, Set&lt;String&gt;&gt; entry : hashToString.entrySet()) {
3854                 int hashCode = entry.getKey();
3855                 Set&lt;String&gt; stringsWithHashCode = entry.getValue();
3856                 Assert.check(stringsWithHashCode.size() &gt;= 1);
3857 
3858                 JCStatement elsepart = null;
3859                 for(String caseLabel : stringsWithHashCode ) {
3860                     JCMethodInvocation stringEqualsCall = makeCall(make.Ident(dollar_s),
3861                                                                    names.equals,
3862                                                                    List.of(make.Literal(caseLabel)));
3863                     elsepart = make.If(stringEqualsCall,
3864                                        make.Exec(make.Assign(make.Ident(dollar_tmp),
3865                                                              make.Literal(caseLabelToPosition.get(caseLabel))).
3866                                                  setType(dollar_tmp.type)),
3867                                        elsepart);
3868                 }
3869 
3870                 ListBuffer&lt;JCStatement&gt; lb = new ListBuffer&lt;&gt;();
3871                 JCBreak breakStmt = make.Break(null);
3872                 breakStmt.target = switch1;
3873                 lb.append(elsepart).append(breakStmt);
3874 
3875                 caseBuffer.append(make.Case(JCCase.STATEMENT, List.of(make.Literal(hashCode)), lb.toList(), null));
3876             }
3877 
3878             switch1.cases = caseBuffer.toList();
3879             stmtList.append(switch1);
3880 
3881             // Make isomorphic switch tree replacing string labels
3882             // with corresponding integer ones from the label to
3883             // position map.
3884 
3885             ListBuffer&lt;JCCase&gt; lb = new ListBuffer&lt;&gt;();
3886             for(JCCase oneCase : caseList ) {
3887                 boolean isDefault = (oneCase.pats.isEmpty());
3888                 JCExpression caseExpr;
3889                 if (isDefault)
3890                     caseExpr = null;
3891                 else {
3892                     caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens(oneCase.pats.head).
3893                                                                     type.constValue()));
3894                 }
3895 
3896                 lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.nil() : List.of(caseExpr),
3897                                     oneCase.stats, null));
3898             }
3899 
3900             if (tree.hasTag(SWITCH)) {
3901                 JCSwitch switch2 = make.Switch(make.Ident(dollar_tmp), lb.toList());
3902                 // Rewire up old unlabeled break statements to the
3903                 // replacement switch being created.
3904                 patchTargets(switch2, tree, switch2);
3905 
3906                 stmtList.append(switch2);
3907 
3908                 return make.Block(0L, stmtList.toList());
3909             } else {
3910                 JCSwitchExpression switch2 = make.SwitchExpression(make.Ident(dollar_tmp), lb.toList());
3911 
3912                 // Rewire up old unlabeled break statements to the
3913                 // replacement switch being created.
3914                 patchTargets(switch2, tree, switch2);
3915 
3916                 switch2.setType(tree.type);
3917 
3918                 LetExpr res = make.LetExpr(stmtList.toList(), switch2);
3919 
3920                 res.needsCond = true;
3921                 res.setType(tree.type);
3922 
3923                 return res;
3924             }
3925         }
3926     }
3927 
3928     @Override
3929     public void visitBreak(JCBreak tree) {
3930         result = tree;
3931     }
3932 
3933     @Override
3934     public void visitYield(JCYield tree) {
3935         tree.value = translate(tree.value, tree.target.type);
3936         result = tree;
3937     }
3938 
3939     public void visitNewArray(JCNewArray tree) {
3940         tree.elemtype = translate(tree.elemtype);
3941         for (List&lt;JCExpression&gt; t = tree.dims; t.tail != null; t = t.tail)
3942             if (t.head != null) t.head = translate(t.head, syms.intType);
3943         tree.elems = translate(tree.elems, types.elemtype(tree.type));
3944         result = tree;
3945     }
3946 
3947     public void visitSelect(JCFieldAccess tree) {
3948         // need to special case-access of the form C.super.x
3949         // these will always need an access method, unless C
3950         // is a default interface subclassed by the current class.
3951         boolean qualifiedSuperAccess =
3952             tree.selected.hasTag(SELECT) &amp;&amp;
3953             TreeInfo.name(tree.selected) == names._super &amp;&amp;
3954             !types.isDirectSuperInterface(((JCFieldAccess)tree.selected).selected.type.tsym, currentClass);
3955         tree.selected = translate(tree.selected);
3956         if (tree.name == names._class) {
3957             result = classOf(tree.selected);
3958         }
3959         else if (tree.name == names._super &amp;&amp;
3960                 types.isDirectSuperInterface(tree.selected.type.tsym, currentClass)) {
3961             //default super call!! Not a classic qualified super call
3962             TypeSymbol supSym = tree.selected.type.tsym;
3963             Assert.checkNonNull(types.asSuper(currentClass.type, supSym));
3964             result = tree;
3965         }
3966         else if (tree.name == names._this || tree.name == names._super) {
3967             result = makeThis(tree.pos(), tree.selected.type.tsym);
3968         }
3969         else
3970             result = access(tree.sym, tree, enclOp, qualifiedSuperAccess);
3971     }
3972 
3973     public void visitLetExpr(LetExpr tree) {
3974         tree.defs = translate(tree.defs);
3975         tree.expr = translate(tree.expr, tree.type);
3976         result = tree;
3977     }
3978 
3979     // There ought to be nothing to rewrite here;
3980     // we don&#39;t generate code.
3981     public void visitAnnotation(JCAnnotation tree) {
3982         result = tree;
3983     }
3984 
3985     @Override
3986     public void visitTry(JCTry tree) {
3987         if (tree.resources.nonEmpty()) {
3988             result = makeTwrTry(tree);
3989             return;
3990         }
3991 
3992         boolean hasBody = tree.body.getStatements().nonEmpty();
3993         boolean hasCatchers = tree.catchers.nonEmpty();
3994         boolean hasFinally = tree.finalizer != null &amp;&amp;
3995                 tree.finalizer.getStatements().nonEmpty();
3996 
3997         if (!hasCatchers &amp;&amp; !hasFinally) {
3998             result = translate(tree.body);
3999             return;
4000         }
4001 
4002         if (!hasBody) {
4003             if (hasFinally) {
4004                 result = translate(tree.finalizer);
4005             } else {
4006                 result = translate(tree.body);
4007             }
4008             return;
4009         }
4010 
4011         // no optimizations possible
4012         super.visitTry(tree);
4013     }
4014 
4015 /**************************************************************************
4016  * main method
4017  *************************************************************************/
4018 
4019     /** Translate a toplevel class and return a list consisting of
4020      *  the translated class and translated versions of all inner classes.
4021      *  @param env   The attribution environment current at the class definition.
4022      *               We need this for resolving some additional symbols.
4023      *  @param cdef  The tree representing the class definition.
4024      */
4025     public List&lt;JCTree&gt; translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
4026         ListBuffer&lt;JCTree&gt; translated = null;
4027         try {
4028             attrEnv = env;
4029             this.make = make;
4030             endPosTable = env.toplevel.endPositions;
4031             currentClass = null;
4032             currentMethodDef = null;
4033             outermostClassDef = (cdef.hasTag(CLASSDEF)) ? (JCClassDecl)cdef : null;
4034             outermostMemberDef = null;
4035             this.translated = new ListBuffer&lt;&gt;();
4036             classdefs = new HashMap&lt;&gt;();
4037             actualSymbols = new HashMap&lt;&gt;();
4038             freevarCache = new HashMap&lt;&gt;();
4039             proxies = new HashMap&lt;&gt;();
4040             twrVars = WriteableScope.create(syms.noSymbol);
4041             outerThisStack = List.nil();
4042             accessNums = new HashMap&lt;&gt;();
4043             accessSyms = new HashMap&lt;&gt;();
4044             accessConstrs = new HashMap&lt;&gt;();
4045             accessConstrTags = List.nil();
4046             accessed = new ListBuffer&lt;&gt;();
4047             translate(cdef, (JCExpression)null);
4048             for (List&lt;Symbol&gt; l = accessed.toList(); l.nonEmpty(); l = l.tail)
4049                 makeAccessible(l.head);
4050             for (EnumMapping map : enumSwitchMap.values())
4051                 map.translate();
4052             checkConflicts(this.translated.toList());
4053             checkAccessConstructorTags();
4054             translated = this.translated;
4055         } finally {
4056             // note that recursive invocations of this method fail hard
4057             attrEnv = null;
4058             this.make = null;
4059             endPosTable = null;
4060             currentClass = null;
4061             currentMethodDef = null;
4062             outermostClassDef = null;
4063             outermostMemberDef = null;
4064             this.translated = null;
4065             classdefs = null;
4066             actualSymbols = null;
4067             freevarCache = null;
4068             proxies = null;
4069             outerThisStack = null;
4070             accessNums = null;
4071             accessSyms = null;
4072             accessConstrs = null;
4073             accessConstrTags = null;
4074             accessed = null;
4075             enumSwitchMap.clear();
4076             assertionsDisabledClassCache = null;
4077         }
4078         return translated.toList();
4079     }
4080 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
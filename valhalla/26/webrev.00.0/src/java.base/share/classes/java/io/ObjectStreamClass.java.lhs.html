<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/ObjectStreamClass.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.lang.invoke.MethodHandle;
  29 import java.lang.invoke.MethodHandles;
  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.SoftReference;
  33 import java.lang.ref.WeakReference;
  34 import java.lang.reflect.Constructor;
  35 import java.lang.reflect.Field;
  36 import java.lang.reflect.InaccessibleObjectException;
  37 import java.lang.reflect.InvocationTargetException;
  38 import java.lang.reflect.RecordComponent;
  39 import java.lang.reflect.UndeclaredThrowableException;
  40 import java.lang.reflect.Member;
  41 import java.lang.reflect.Method;
  42 import java.lang.reflect.Modifier;
  43 import java.lang.reflect.Proxy;
  44 import java.security.AccessControlContext;
  45 import java.security.AccessController;
  46 import java.security.MessageDigest;
  47 import java.security.NoSuchAlgorithmException;
  48 import java.security.PermissionCollection;
  49 import java.security.Permissions;
  50 import java.security.PrivilegedAction;
  51 import java.security.PrivilegedActionException;
  52 import java.security.PrivilegedExceptionAction;
  53 import java.security.ProtectionDomain;
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashSet;
  59 import java.util.Set;
  60 import java.util.concurrent.ConcurrentHashMap;
  61 import java.util.concurrent.ConcurrentMap;
  62 import jdk.internal.misc.Unsafe;
  63 import jdk.internal.reflect.CallerSensitive;
  64 import jdk.internal.reflect.Reflection;
  65 import jdk.internal.reflect.ReflectionFactory;
  66 import jdk.internal.access.SharedSecrets;
  67 import jdk.internal.access.JavaSecurityAccess;
  68 import sun.reflect.misc.ReflectUtil;
  69 import static java.io.ObjectStreamField.*;
  70 
  71 /**
  72  * Serialization&#39;s descriptor for classes.  It contains the name and
  73  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  74  * loaded in this Java VM can be found/created using the lookup method.
  75  *
  76  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  77  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  78  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
  79  *
  80  * @author      Mike Warres
  81  * @author      Roger Riggs
  82  * @see ObjectStreamField
  83  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html&quot;&gt;
  84  *     Object Serialization Specification, Section 4, Class Descriptors&lt;/a&gt;
  85  * @since   1.1
  86  */
  87 public class ObjectStreamClass implements Serializable {
  88 
  89     /** serialPersistentFields value indicating no serializable fields */
  90     public static final ObjectStreamField[] NO_FIELDS =
  91         new ObjectStreamField[0];
  92 
  93     @java.io.Serial
  94     private static final long serialVersionUID = -6120832682080437368L;
  95     @java.io.Serial
  96     private static final ObjectStreamField[] serialPersistentFields =
  97         NO_FIELDS;
  98 
  99     /** reflection factory for obtaining serialization constructors */
 100     private static final ReflectionFactory reflFactory =
 101         AccessController.doPrivileged(
 102             new ReflectionFactory.GetReflectionFactoryAction());
 103 
 104     private static class Caches {
 105         /** cache mapping local classes -&gt; descriptors */
 106         static final ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt; localDescs =
 107             new ConcurrentHashMap&lt;&gt;();
 108 
 109         /** cache mapping field group/local desc pairs -&gt; field reflectors */
 110         static final ConcurrentMap&lt;FieldReflectorKey,Reference&lt;?&gt;&gt; reflectors =
 111             new ConcurrentHashMap&lt;&gt;();
 112 
 113         /** queue for WeakReferences to local classes */
 114         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; localDescsQueue =
 115             new ReferenceQueue&lt;&gt;();
 116         /** queue for WeakReferences to field reflectors keys */
 117         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; reflectorsQueue =
 118             new ReferenceQueue&lt;&gt;();
 119     }
 120 
 121     /** class associated with this descriptor (if any) */
 122     private Class&lt;?&gt; cl;
 123     /** name of class represented by this descriptor */
 124     private String name;
 125     /** serialVersionUID of represented class (null if not computed yet) */
 126     private volatile Long suid;
 127 
 128     /** true if represents dynamic proxy class */
 129     private boolean isProxy;
 130     /** true if represents enum type */
 131     private boolean isEnum;
 132     /** true if represents record type */
 133     private boolean isRecord;
 134     /** true if represented class implements Serializable */
 135     private boolean serializable;
 136     /** true if represented class implements Externalizable */
 137     private boolean externalizable;
 138     /** true if desc has data written by class-defined writeObject method */
 139     private boolean hasWriteObjectData;
 140     /**
 141      * true if desc has externalizable data written in block data format; this
 142      * must be true by default to accommodate ObjectInputStream subclasses which
 143      * override readClassDescriptor() to return class descriptors obtained from
 144      * ObjectStreamClass.lookup() (see 4461737)
 145      */
 146     private boolean hasBlockExternalData = true;
 147 
 148     /**
 149      * Contains information about InvalidClassException instances to be thrown
 150      * when attempting operations on an invalid class. Note that instances of
 151      * this class are immutable and are potentially shared among
 152      * ObjectStreamClass instances.
 153      */
 154     private static class ExceptionInfo {
 155         private final String className;
 156         private final String message;
 157 
 158         ExceptionInfo(String cn, String msg) {
 159             className = cn;
 160             message = msg;
 161         }
 162 
 163         /**
 164          * Returns (does not throw) an InvalidClassException instance created
 165          * from the information in this object, suitable for being thrown by
 166          * the caller.
 167          */
 168         InvalidClassException newInvalidClassException() {
 169             return new InvalidClassException(className, message);
 170         }
 171     }
 172 
 173     /** exception (if any) thrown while attempting to resolve class */
 174     private ClassNotFoundException resolveEx;
 175     /** exception (if any) to throw if non-enum deserialization attempted */
 176     private ExceptionInfo deserializeEx;
 177     /** exception (if any) to throw if non-enum serialization attempted */
 178     private ExceptionInfo serializeEx;
 179     /** exception (if any) to throw if default serialization attempted */
 180     private ExceptionInfo defaultSerializeEx;
 181 
 182     /** serializable fields */
 183     private ObjectStreamField[] fields;
 184     /** aggregate marshalled size of primitive fields */
 185     private int primDataSize;
 186     /** number of non-primitive fields */
 187     private int numObjFields;
 188     /** reflector for setting/getting serializable field values */
 189     private FieldReflector fieldRefl;
 190     /** data layout of serialized objects described by this class desc */
 191     private volatile ClassDataSlot[] dataLayout;
 192 
 193     /** serialization-appropriate constructor, or null if none */
 194     private Constructor&lt;?&gt; cons;
 195     /** record canonical constructor, or null */
 196     private MethodHandle canonicalCtr;
 197     /** protection domains that need to be checked when calling the constructor */
 198     private ProtectionDomain[] domains;
 199 
 200     /** class-defined writeObject method, or null if none */
 201     private Method writeObjectMethod;
 202     /** class-defined readObject method, or null if none */
 203     private Method readObjectMethod;
 204     /** class-defined readObjectNoData method, or null if none */
 205     private Method readObjectNoDataMethod;
 206     /** class-defined writeReplace method, or null if none */
 207     private Method writeReplaceMethod;
 208     /** class-defined readResolve method, or null if none */
 209     private Method readResolveMethod;
 210 
 211     /** local class descriptor for represented class (may point to self) */
 212     private ObjectStreamClass localDesc;
 213     /** superclass descriptor appearing in stream */
 214     private ObjectStreamClass superDesc;
 215 
 216     /** true if, and only if, the object has been correctly initialized */
 217     private boolean initialized;
 218 
 219     /**
 220      * Initializes native code.
 221      */
 222     private static native void initNative();
 223     static {
 224         initNative();
 225     }
 226 
 227     /**
 228      * Find the descriptor for a class that can be serialized.  Creates an
 229      * ObjectStreamClass instance if one does not exist yet for class. Null is
 230      * returned if the specified class does not implement java.io.Serializable
 231      * or java.io.Externalizable.
 232      *
 233      * @param   cl class for which to get the descriptor
 234      * @return  the class descriptor for the specified class
 235      */
 236     public static ObjectStreamClass lookup(Class&lt;?&gt; cl) {
 237         return lookup(cl, false);
 238     }
 239 
 240     /**
 241      * Returns the descriptor for any class, regardless of whether it
 242      * implements {@link Serializable}.
 243      *
 244      * @param        cl class for which to get the descriptor
 245      * @return       the class descriptor for the specified class
 246      * @since 1.6
 247      */
 248     public static ObjectStreamClass lookupAny(Class&lt;?&gt; cl) {
 249         return lookup(cl, true);
 250     }
 251 
 252     /**
 253      * Returns the name of the class described by this descriptor.
 254      * This method returns the name of the class in the format that
 255      * is used by the {@link Class#getName} method.
 256      *
 257      * @return a string representing the name of the class
 258      */
 259     public String getName() {
 260         return name;
 261     }
 262 
 263     /**
 264      * Return the serialVersionUID for this class.  The serialVersionUID
 265      * defines a set of classes all with the same name that have evolved from a
 266      * common root class and agree to be serialized and deserialized using a
 267      * common format.  NonSerializable classes have a serialVersionUID of 0L.
 268      *
 269      * @return  the SUID of the class described by this descriptor
 270      */
 271     public long getSerialVersionUID() {
 272         // REMIND: synchronize instead of relying on volatile?
 273         if (suid == null) {
 274             if (isRecord)
 275                 return 0L;
 276 
 277             suid = AccessController.doPrivileged(
 278                 new PrivilegedAction&lt;Long&gt;() {
 279                     public Long run() {
 280                         return computeDefaultSUID(cl);
 281                     }
 282                 }
 283             );
 284         }
 285         return suid.longValue();
 286     }
 287 
 288     /**
 289      * Return the class in the local VM that this version is mapped to.  Null
 290      * is returned if there is no corresponding local class.
 291      *
 292      * @return  the {@code Class} instance that this descriptor represents
 293      */
 294     @CallerSensitive
 295     public Class&lt;?&gt; forClass() {
 296         if (cl == null) {
 297             return null;
 298         }
 299         requireInitialized();
 300         if (System.getSecurityManager() != null) {
 301             Class&lt;?&gt; caller = Reflection.getCallerClass();
 302             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), cl.getClassLoader())) {
 303                 ReflectUtil.checkPackageAccess(cl);
 304             }
 305         }
 306         return cl;
 307     }
 308 
 309     /**
 310      * Return an array of the fields of this serializable class.
 311      *
 312      * @return  an array containing an element for each persistent field of
 313      *          this class. Returns an array of length zero if there are no
 314      *          fields.
 315      * @since 1.2
 316      */
 317     public ObjectStreamField[] getFields() {
 318         return getFields(true);
 319     }
 320 
 321     /**
 322      * Get the field of this class by name.
 323      *
 324      * @param   name the name of the data field to look for
 325      * @return  The ObjectStreamField object of the named field or null if
 326      *          there is no such named field.
 327      */
 328     public ObjectStreamField getField(String name) {
 329         return getField(name, null);
 330     }
 331 
 332     /**
 333      * Return a string describing this ObjectStreamClass.
 334      */
 335     public String toString() {
 336         return name + &quot;: static final long serialVersionUID = &quot; +
 337             getSerialVersionUID() + &quot;L;&quot;;
 338     }
 339 
 340     /**
 341      * Looks up and returns class descriptor for given class, or null if class
 342      * is non-serializable and &quot;all&quot; is set to false.
 343      *
 344      * @param   cl class to look up
 345      * @param   all if true, return descriptors for all classes; if false, only
 346      *          return descriptors for serializable classes
 347      */
 348     static ObjectStreamClass lookup(Class&lt;?&gt; cl, boolean all) {
 349         if (!(all || Serializable.class.isAssignableFrom(cl))) {
 350             return null;
 351         }
 352         processQueue(Caches.localDescsQueue, Caches.localDescs);
 353         WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);
 354         Reference&lt;?&gt; ref = Caches.localDescs.get(key);
 355         Object entry = null;
 356         if (ref != null) {
 357             entry = ref.get();
 358         }
 359         EntryFuture future = null;
 360         if (entry == null) {
 361             EntryFuture newEntry = new EntryFuture();
 362             Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);
 363             do {
 364                 if (ref != null) {
 365                     Caches.localDescs.remove(key, ref);
 366                 }
 367                 ref = Caches.localDescs.putIfAbsent(key, newRef);
 368                 if (ref != null) {
 369                     entry = ref.get();
 370                 }
 371             } while (ref != null &amp;&amp; entry == null);
 372             if (entry == null) {
 373                 future = newEntry;
 374             }
 375         }
 376 
 377         if (entry instanceof ObjectStreamClass) {  // check common case first
 378             return (ObjectStreamClass) entry;
 379         }
 380         if (entry instanceof EntryFuture) {
 381             future = (EntryFuture) entry;
 382             if (future.getOwner() == Thread.currentThread()) {
 383                 /*
 384                  * Handle nested call situation described by 4803747: waiting
 385                  * for future value to be set by a lookup() call further up the
 386                  * stack will result in deadlock, so calculate and set the
 387                  * future value here instead.
 388                  */
 389                 entry = null;
 390             } else {
 391                 entry = future.get();
 392             }
 393         }
 394         if (entry == null) {
 395             try {
 396                 entry = new ObjectStreamClass(cl);
 397             } catch (Throwable th) {
 398                 entry = th;
 399             }
 400             if (future.set(entry)) {
 401                 Caches.localDescs.put(key, new SoftReference&lt;&gt;(entry));
 402             } else {
 403                 // nested lookup call already set future
 404                 entry = future.get();
 405             }
 406         }
 407 
 408         if (entry instanceof ObjectStreamClass) {
 409             return (ObjectStreamClass) entry;
 410         } else if (entry instanceof RuntimeException) {
 411             throw (RuntimeException) entry;
 412         } else if (entry instanceof Error) {
 413             throw (Error) entry;
 414         } else {
 415             throw new InternalError(&quot;unexpected entry: &quot; + entry);
 416         }
 417     }
 418 
 419     /**
 420      * Placeholder used in class descriptor and field reflector lookup tables
 421      * for an entry in the process of being initialized.  (Internal) callers
 422      * which receive an EntryFuture belonging to another thread as the result
 423      * of a lookup should call the get() method of the EntryFuture; this will
 424      * return the actual entry once it is ready for use and has been set().  To
 425      * conserve objects, EntryFutures synchronize on themselves.
 426      */
 427     private static class EntryFuture {
 428 
 429         private static final Object unset = new Object();
 430         private final Thread owner = Thread.currentThread();
 431         private Object entry = unset;
 432 
 433         /**
 434          * Attempts to set the value contained by this EntryFuture.  If the
 435          * EntryFuture&#39;s value has not been set already, then the value is
 436          * saved, any callers blocked in the get() method are notified, and
 437          * true is returned.  If the value has already been set, then no saving
 438          * or notification occurs, and false is returned.
 439          */
 440         synchronized boolean set(Object entry) {
 441             if (this.entry != unset) {
 442                 return false;
 443             }
 444             this.entry = entry;
 445             notifyAll();
 446             return true;
 447         }
 448 
 449         /**
 450          * Returns the value contained by this EntryFuture, blocking if
 451          * necessary until a value is set.
 452          */
 453         synchronized Object get() {
 454             boolean interrupted = false;
 455             while (entry == unset) {
 456                 try {
 457                     wait();
 458                 } catch (InterruptedException ex) {
 459                     interrupted = true;
 460                 }
 461             }
 462             if (interrupted) {
 463                 AccessController.doPrivileged(
 464                     new PrivilegedAction&lt;&gt;() {
 465                         public Void run() {
 466                             Thread.currentThread().interrupt();
 467                             return null;
 468                         }
 469                     }
 470                 );
 471             }
 472             return entry;
 473         }
 474 
 475         /**
 476          * Returns the thread that created this EntryFuture.
 477          */
 478         Thread getOwner() {
 479             return owner;
 480         }
 481     }
 482 
 483     @SuppressWarnings(&quot;preview&quot;)
 484     private static boolean isRecord(Class&lt;?&gt; cls) {
 485         return cls.isRecord();
 486     }
 487 
 488     /**
 489      * Creates local class descriptor representing given class.
 490      */
 491     private ObjectStreamClass(final Class&lt;?&gt; cl) {
 492         this.cl = cl;
 493         name = cl.getName();
 494         isProxy = Proxy.isProxyClass(cl);
 495         isEnum = Enum.class.isAssignableFrom(cl);
 496         boolean isInlineClass = cl.isInlineClass();
 497         isRecord = isRecord(cl);
 498         serializable = Serializable.class.isAssignableFrom(cl);
 499         externalizable = Externalizable.class.isAssignableFrom(cl);
 500 
 501         Class&lt;?&gt; superCl = cl.getSuperclass();
 502         superDesc = (superCl != null) ? lookup(superCl, false) : null;
 503         localDesc = this;
 504 
 505         if (serializable) {
 506             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 507                 public Void run() {
 508                     if (isEnum) {
 509                         suid = Long.valueOf(0);
 510                         fields = NO_FIELDS;
 511                         return null;
 512                     }
 513                     if (cl.isArray()) {
 514                         fields = NO_FIELDS;
 515                         return null;
 516                     }
 517 
 518                     suid = getDeclaredSUID(cl);
 519                     try {
 520                         fields = getSerialFields(cl);
 521                         computeFieldOffsets();
 522                     } catch (InvalidClassException e) {
 523                         serializeEx = deserializeEx =
 524                             new ExceptionInfo(e.classname, e.getMessage());
 525                         fields = NO_FIELDS;
 526                     }
 527 
 528                     if (isRecord) {
 529                         canonicalCtr = canonicalRecordCtr(cl);
 530                     } else if (externalizable) {
 531                         cons = getExternalizableConstructor(cl);
 532                     } else {
 533                         cons = getSerializableConstructor(cl);
 534                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 535                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 536                             Void.TYPE);
 537                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 538                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 539                             Void.TYPE);
 540                         readObjectNoDataMethod = getPrivateMethod(
 541                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 542                         hasWriteObjectData = (writeObjectMethod != null);
 543                     }
 544                     domains = getProtectionDomains(cons, cl);
 545                     writeReplaceMethod = getInheritableMethod(
 546                         cl, &quot;writeReplace&quot;, null, Object.class);
 547                     readResolveMethod = getInheritableMethod(
 548                         cl, &quot;readResolve&quot;, null, Object.class);
 549                     return null;
 550                 }
 551             });
 552         } else {
 553             suid = Long.valueOf(0);
 554             fields = NO_FIELDS;
 555         }
 556 
 557         try {
 558             fieldRefl = getReflector(fields, this);
 559         } catch (InvalidClassException ex) {
 560             // field mismatches impossible when matching local fields vs. self
 561             throw new InternalError(ex);
 562         }
 563 
 564         if (deserializeEx == null) {
 565             if (isEnum) {
 566                 deserializeEx = new ExceptionInfo(name, &quot;enum type&quot;);
 567             } else if (isInlineClass &amp;&amp; writeReplaceMethod == null) {
 568                 deserializeEx = new ExceptionInfo(name, &quot;inline class&quot;);
 569             } else if (cons == null &amp;&amp; !isRecord) {
 570                 deserializeEx = new ExceptionInfo(name, &quot;no valid constructor&quot;);
 571             }
 572         }
 573         if (isRecord &amp;&amp; canonicalCtr == null) {
 574             deserializeEx = new ExceptionInfo(name, &quot;record canonical constructor not found&quot;);
 575         } else {
 576             for (int i = 0; i &lt; fields.length; i++) {
 577                 if (fields[i].getField() == null) {
 578                     defaultSerializeEx = new ExceptionInfo(
 579                         name, &quot;unmatched serializable field(s) declared&quot;);
 580                 }
 581             }
 582         }
 583         initialized = true;
 584     }
 585 
 586     /**
 587      * Creates blank class descriptor which should be initialized via a
 588      * subsequent call to initProxy(), initNonProxy() or readNonProxy().
 589      */
 590     ObjectStreamClass() {
 591     }
 592 
 593     /**
 594      * Creates a PermissionDomain that grants no permission.
 595      */
 596     private ProtectionDomain noPermissionsDomain() {
 597         PermissionCollection perms = new Permissions();
 598         perms.setReadOnly();
 599         return new ProtectionDomain(null, perms);
 600     }
 601 
 602     /**
 603      * Aggregate the ProtectionDomains of all the classes that separate
 604      * a concrete class {@code cl} from its ancestor&#39;s class declaring
 605      * a constructor {@code cons}.
 606      *
 607      * If {@code cl} is defined by the boot loader, or the constructor
 608      * {@code cons} is declared by {@code cl}, or if there is no security
 609      * manager, then this method does nothing and {@code null} is returned.
 610      *
 611      * @param cons A constructor declared by {@code cl} or one of its
 612      *             ancestors.
 613      * @param cl A concrete class, which is either the class declaring
 614      *           the constructor {@code cons}, or a serializable subclass
 615      *           of that class.
 616      * @return An array of ProtectionDomain representing the set of
 617      *         ProtectionDomain that separate the concrete class {@code cl}
 618      *         from its ancestor&#39;s declaring {@code cons}, or {@code null}.
 619      */
 620     private ProtectionDomain[] getProtectionDomains(Constructor&lt;?&gt; cons,
 621                                                     Class&lt;?&gt; cl) {
 622         ProtectionDomain[] domains = null;
 623         if (cons != null &amp;&amp; cl.getClassLoader() != null
 624                 &amp;&amp; System.getSecurityManager() != null) {
 625             Class&lt;?&gt; cls = cl;
 626             Class&lt;?&gt; fnscl = cons.getDeclaringClass();
 627             Set&lt;ProtectionDomain&gt; pds = null;
 628             while (cls != fnscl) {
 629                 ProtectionDomain pd = cls.getProtectionDomain();
 630                 if (pd != null) {
 631                     if (pds == null) pds = new HashSet&lt;&gt;();
 632                     pds.add(pd);
 633                 }
 634                 cls = cls.getSuperclass();
 635                 if (cls == null) {
 636                     // that&#39;s not supposed to happen
 637                     // make a ProtectionDomain with no permission.
 638                     // should we throw instead?
 639                     if (pds == null) pds = new HashSet&lt;&gt;();
 640                     else pds.clear();
 641                     pds.add(noPermissionsDomain());
 642                     break;
 643                 }
 644             }
 645             if (pds != null) {
 646                 domains = pds.toArray(new ProtectionDomain[0]);
 647             }
 648         }
 649         return domains;
 650     }
 651 
 652     /**
 653      * Initializes class descriptor representing a proxy class.
 654      */
 655     void initProxy(Class&lt;?&gt; cl,
 656                    ClassNotFoundException resolveEx,
 657                    ObjectStreamClass superDesc)
 658         throws InvalidClassException
 659     {
 660         ObjectStreamClass osc = null;
 661         if (cl != null) {
 662             osc = lookup(cl, true);
 663             if (!osc.isProxy) {
 664                 throw new InvalidClassException(
 665                     &quot;cannot bind proxy descriptor to a non-proxy class&quot;);
 666             }
 667         }
 668         this.cl = cl;
 669         this.resolveEx = resolveEx;
 670         this.superDesc = superDesc;
 671         isProxy = true;
 672         serializable = true;
 673         suid = Long.valueOf(0);
 674         fields = NO_FIELDS;
 675         if (osc != null) {
 676             localDesc = osc;
 677             name = localDesc.name;
 678             externalizable = localDesc.externalizable;
 679             writeReplaceMethod = localDesc.writeReplaceMethod;
 680             readResolveMethod = localDesc.readResolveMethod;
 681             deserializeEx = localDesc.deserializeEx;
 682             domains = localDesc.domains;
 683             cons = localDesc.cons;
 684         }
 685         fieldRefl = getReflector(fields, localDesc);
 686         initialized = true;
 687     }
 688 
 689     /**
 690      * Initializes class descriptor representing a non-proxy class.
 691      */
 692     void initNonProxy(ObjectStreamClass model,
 693                       Class&lt;?&gt; cl,
 694                       ClassNotFoundException resolveEx,
 695                       ObjectStreamClass superDesc)
 696         throws InvalidClassException
 697     {
 698         long suid = Long.valueOf(model.getSerialVersionUID());
 699         ObjectStreamClass osc = null;
 700         if (cl != null) {
 701             osc = lookup(cl, true);
 702             if (osc.isProxy) {
 703                 throw new InvalidClassException(
 704                         &quot;cannot bind non-proxy descriptor to a proxy class&quot;);
 705             }
 706             if (model.isEnum != osc.isEnum) {
 707                 throw new InvalidClassException(model.isEnum ?
 708                         &quot;cannot bind enum descriptor to a non-enum class&quot; :
 709                         &quot;cannot bind non-enum descriptor to an enum class&quot;);
 710             }
 711 
 712             if (model.serializable == osc.serializable &amp;&amp;
 713                     !cl.isArray() &amp;&amp; !isRecord(cl) &amp;&amp;
 714                     suid != osc.getSerialVersionUID()) {
 715                 throw new InvalidClassException(osc.name,
 716                         &quot;local class incompatible: &quot; +
 717                                 &quot;stream classdesc serialVersionUID = &quot; + suid +
 718                                 &quot;, local class serialVersionUID = &quot; +
 719                                 osc.getSerialVersionUID());
 720             }
 721 
 722             if (!classNamesEqual(model.name, osc.name)) {
 723                 throw new InvalidClassException(osc.name,
 724                         &quot;local class name incompatible with stream class &quot; +
 725                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 726             }
 727 
 728             if (!model.isEnum) {
 729                 if ((model.serializable == osc.serializable) &amp;&amp;
 730                         (model.externalizable != osc.externalizable)) {
 731                     throw new InvalidClassException(osc.name,
 732                             &quot;Serializable incompatible with Externalizable&quot;);
 733                 }
 734 
 735                 if ((model.serializable != osc.serializable) ||
 736                         (model.externalizable != osc.externalizable) ||
 737                         !(model.serializable || model.externalizable)) {
 738                     deserializeEx = new ExceptionInfo(
 739                             osc.name, &quot;class invalid for deserialization&quot;);
 740                 }
 741             }
 742         }
 743 
 744         this.cl = cl;
 745         if (cl != null) {
 746             this.isRecord = isRecord(cl);
 747             this.canonicalCtr = osc.canonicalCtr;
 748         }
 749         this.resolveEx = resolveEx;
 750         this.superDesc = superDesc;
 751         name = model.name;
 752         this.suid = suid;
 753         isProxy = false;
 754         isEnum = model.isEnum;
 755         serializable = model.serializable;
 756         externalizable = model.externalizable;
 757         hasBlockExternalData = model.hasBlockExternalData;
 758         hasWriteObjectData = model.hasWriteObjectData;
 759         fields = model.fields;
 760         primDataSize = model.primDataSize;
 761         numObjFields = model.numObjFields;
 762 
 763         if (osc != null) {
 764             localDesc = osc;
 765             writeObjectMethod = localDesc.writeObjectMethod;
 766             readObjectMethod = localDesc.readObjectMethod;
 767             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 768             writeReplaceMethod = localDesc.writeReplaceMethod;
 769             readResolveMethod = localDesc.readResolveMethod;
 770             if (deserializeEx == null) {
 771                 deserializeEx = localDesc.deserializeEx;
 772             }
 773             domains = localDesc.domains;
 774             assert isRecord(cl) ? localDesc.cons == null : true;
 775             cons = localDesc.cons;
 776         }
 777 
 778         fieldRefl = getReflector(fields, localDesc);
 779         // reassign to matched fields so as to reflect local unshared settings
 780         fields = fieldRefl.getFields();
 781 
 782         initialized = true;
 783     }
 784 
 785     /**
 786      * Reads non-proxy class descriptor information from given input stream.
 787      * The resulting class descriptor is not fully functional; it can only be
 788      * used as input to the ObjectInputStream.resolveClass() and
 789      * ObjectStreamClass.initNonProxy() methods.
 790      */
 791     void readNonProxy(ObjectInputStream in)
 792         throws IOException, ClassNotFoundException
 793     {
 794         name = in.readUTF();
 795         suid = Long.valueOf(in.readLong());
 796         isProxy = false;
 797 
 798         byte flags = in.readByte();
 799         hasWriteObjectData =
 800             ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);
 801         hasBlockExternalData =
 802             ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != 0);
 803         externalizable =
 804             ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0);
 805         boolean sflag =
 806             ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0);
 807         if (externalizable &amp;&amp; sflag) {
 808             throw new InvalidClassException(
 809                 name, &quot;serializable and externalizable flags conflict&quot;);
 810         }
 811         serializable = externalizable || sflag;
 812         isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != 0);
 813         if (isEnum &amp;&amp; suid.longValue() != 0L) {
 814             throw new InvalidClassException(name,
 815                 &quot;enum descriptor has non-zero serialVersionUID: &quot; + suid);
 816         }
 817 
 818         int numFields = in.readShort();
 819         if (isEnum &amp;&amp; numFields != 0) {
 820             throw new InvalidClassException(name,
 821                 &quot;enum descriptor has non-zero field count: &quot; + numFields);
 822         }
 823         fields = (numFields &gt; 0) ?
 824             new ObjectStreamField[numFields] : NO_FIELDS;
 825         for (int i = 0; i &lt; numFields; i++) {
 826             char tcode = (char) in.readByte();
 827             String fname = in.readUTF();
 828             String signature = ((tcode == &#39;L&#39;) || (tcode == &#39;[&#39;)) ?
 829                 in.readTypeString() : new String(new char[] { tcode });
 830             try {
 831                 fields[i] = new ObjectStreamField(fname, signature, false);
 832             } catch (RuntimeException e) {
 833                 throw (IOException) new InvalidClassException(name,
 834                     &quot;invalid descriptor for field &quot; + fname).initCause(e);
 835             }
 836         }
 837         computeFieldOffsets();
 838     }
 839 
 840     /**
 841      * Writes non-proxy class descriptor information to given output stream.
 842      */
 843     void writeNonProxy(ObjectOutputStream out) throws IOException {
 844         out.writeUTF(name);
 845         out.writeLong(getSerialVersionUID());
 846 
 847         byte flags = 0;
 848         if (externalizable) {
 849             flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;
 850             int protocol = out.getProtocolVersion();
 851             if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) {
 852                 flags |= ObjectStreamConstants.SC_BLOCK_DATA;
 853             }
 854         } else if (serializable) {
 855             flags |= ObjectStreamConstants.SC_SERIALIZABLE;
 856         }
 857         if (hasWriteObjectData) {
 858             flags |= ObjectStreamConstants.SC_WRITE_METHOD;
 859         }
 860         if (isEnum) {
 861             flags |= ObjectStreamConstants.SC_ENUM;
 862         }
 863         out.writeByte(flags);
 864 
 865         out.writeShort(fields.length);
 866         for (int i = 0; i &lt; fields.length; i++) {
 867             ObjectStreamField f = fields[i];
 868             out.writeByte(f.getTypeCode());
 869             out.writeUTF(f.getName());
 870             if (!f.isPrimitive()) {
 871                 out.writeTypeString(f.getTypeString());
 872             }
 873         }
 874     }
 875 
 876     /**
 877      * Returns ClassNotFoundException (if any) thrown while attempting to
 878      * resolve local class corresponding to this class descriptor.
 879      */
 880     ClassNotFoundException getResolveException() {
 881         return resolveEx;
 882     }
 883 
 884     /**
 885      * Throws InternalError if not initialized.
 886      */
 887     private final void requireInitialized() {
 888         if (!initialized)
 889             throw new InternalError(&quot;Unexpected call when not initialized&quot;);
 890     }
 891 
<a name="2" id="anc2"></a>










 892     /**
 893      * Throws an InvalidClassException if object instances referencing this
 894      * class descriptor should not be allowed to deserialize.  This method does
 895      * not apply to deserialization of enum constants.
 896      */
 897     void checkDeserialize() throws InvalidClassException {
 898         requireInitialized();
 899         if (deserializeEx != null) {
 900             throw deserializeEx.newInvalidClassException();
 901         }
 902     }
 903 
 904     /**
 905      * Throws an InvalidClassException if objects whose class is represented by
 906      * this descriptor should not be allowed to serialize.  This method does
 907      * not apply to serialization of enum constants.
 908      */
 909     void checkSerialize() throws InvalidClassException {
 910         requireInitialized();
 911         if (serializeEx != null) {
 912             throw serializeEx.newInvalidClassException();
 913         }
 914     }
 915 
 916     /**
 917      * Throws an InvalidClassException if objects whose class is represented by
 918      * this descriptor should not be permitted to use default serialization
 919      * (e.g., if the class declares serializable fields that do not correspond
 920      * to actual fields, and hence must use the GetField API).  This method
 921      * does not apply to deserialization of enum constants.
 922      */
 923     void checkDefaultSerialize() throws InvalidClassException {
 924         requireInitialized();
 925         if (defaultSerializeEx != null) {
 926             throw defaultSerializeEx.newInvalidClassException();
 927         }
 928     }
 929 
 930     /**
 931      * Returns superclass descriptor.  Note that on the receiving side, the
 932      * superclass descriptor may be bound to a class that is not a superclass
 933      * of the subclass descriptor&#39;s bound class.
 934      */
 935     ObjectStreamClass getSuperDesc() {
 936         requireInitialized();
 937         return superDesc;
 938     }
 939 
 940     /**
 941      * Returns the &quot;local&quot; class descriptor for the class associated with this
 942      * class descriptor (i.e., the result of
 943      * ObjectStreamClass.lookup(this.forClass())) or null if there is no class
 944      * associated with this descriptor.
 945      */
 946     ObjectStreamClass getLocalDesc() {
 947         requireInitialized();
 948         return localDesc;
 949     }
 950 
 951     /**
 952      * Returns arrays of ObjectStreamFields representing the serializable
 953      * fields of the represented class.  If copy is true, a clone of this class
 954      * descriptor&#39;s field array is returned, otherwise the array itself is
 955      * returned.
 956      */
 957     ObjectStreamField[] getFields(boolean copy) {
 958         return copy ? fields.clone() : fields;
 959     }
 960 
 961     /**
 962      * Looks up a serializable field of the represented class by name and type.
 963      * A specified type of null matches all types, Object.class matches all
 964      * non-primitive types, and any other non-null type matches assignable
 965      * types only.  Returns matching field, or null if no match found.
 966      */
 967     ObjectStreamField getField(String name, Class&lt;?&gt; type) {
 968         for (int i = 0; i &lt; fields.length; i++) {
 969             ObjectStreamField f = fields[i];
 970             if (f.getName().equals(name)) {
 971                 if (type == null ||
 972                     (type == Object.class &amp;&amp; !f.isPrimitive()))
 973                 {
 974                     return f;
 975                 }
 976                 Class&lt;?&gt; ftype = f.getType();
 977                 if (ftype != null &amp;&amp; type.isAssignableFrom(ftype)) {
 978                     return f;
 979                 }
 980             }
 981         }
 982         return null;
 983     }
 984 
 985     /**
 986      * Returns true if class descriptor represents a dynamic proxy class, false
 987      * otherwise.
 988      */
 989     boolean isProxy() {
 990         requireInitialized();
 991         return isProxy;
 992     }
 993 
 994     /**
 995      * Returns true if class descriptor represents an enum type, false
 996      * otherwise.
 997      */
 998     boolean isEnum() {
 999         requireInitialized();
1000         return isEnum;
1001     }
1002 
1003     /**
1004      * Returns true if class descriptor represents a record type, false
1005      * otherwise.
1006      */
1007     boolean isRecord() {
1008         requireInitialized();
1009         return isRecord;
1010     }
1011 
1012     /**
1013      * Returns true if represented class implements Externalizable, false
1014      * otherwise.
1015      */
1016     boolean isExternalizable() {
1017         requireInitialized();
1018         return externalizable;
1019     }
1020 
1021     /**
1022      * Returns true if represented class implements Serializable, false
1023      * otherwise.
1024      */
1025     boolean isSerializable() {
1026         requireInitialized();
1027         return serializable;
1028     }
1029 
1030     /**
1031      * Returns true if class descriptor represents externalizable class that
1032      * has written its data in 1.2 (block data) format, false otherwise.
1033      */
1034     boolean hasBlockExternalData() {
1035         requireInitialized();
1036         return hasBlockExternalData;
1037     }
1038 
1039     /**
1040      * Returns true if class descriptor represents serializable (but not
1041      * externalizable) class which has written its data via a custom
1042      * writeObject() method, false otherwise.
1043      */
1044     boolean hasWriteObjectData() {
1045         requireInitialized();
1046         return hasWriteObjectData;
1047     }
1048 
1049     /**
1050      * Returns true if represented class is serializable/externalizable and can
1051      * be instantiated by the serialization runtime--i.e., if it is
1052      * externalizable and defines a public no-arg constructor, or if it is
1053      * non-externalizable and its first non-serializable superclass defines an
1054      * accessible no-arg constructor.  Otherwise, returns false.
1055      */
1056     boolean isInstantiable() {
1057         requireInitialized();
1058         return (cons != null);
1059     }
1060 
1061     /**
1062      * Returns true if represented class is serializable (but not
1063      * externalizable) and defines a conformant writeObject method.  Otherwise,
1064      * returns false.
1065      */
1066     boolean hasWriteObjectMethod() {
1067         requireInitialized();
1068         return (writeObjectMethod != null);
1069     }
1070 
1071     /**
1072      * Returns true if represented class is serializable (but not
1073      * externalizable) and defines a conformant readObject method.  Otherwise,
1074      * returns false.
1075      */
1076     boolean hasReadObjectMethod() {
1077         requireInitialized();
1078         return (readObjectMethod != null);
1079     }
1080 
1081     /**
1082      * Returns true if represented class is serializable (but not
1083      * externalizable) and defines a conformant readObjectNoData method.
1084      * Otherwise, returns false.
1085      */
1086     boolean hasReadObjectNoDataMethod() {
1087         requireInitialized();
1088         return (readObjectNoDataMethod != null);
1089     }
1090 
1091     /**
1092      * Returns true if represented class is serializable or externalizable and
1093      * defines a conformant writeReplace method.  Otherwise, returns false.
1094      */
1095     boolean hasWriteReplaceMethod() {
1096         requireInitialized();
1097         return (writeReplaceMethod != null);
1098     }
1099 
1100     /**
1101      * Returns true if represented class is serializable or externalizable and
1102      * defines a conformant readResolve method.  Otherwise, returns false.
1103      */
1104     boolean hasReadResolveMethod() {
1105         requireInitialized();
1106         return (readResolveMethod != null);
1107     }
1108 
1109     /**
1110      * Creates a new instance of the represented class.  If the class is
1111      * externalizable, invokes its public no-arg constructor; otherwise, if the
1112      * class is serializable, invokes the no-arg constructor of the first
1113      * non-serializable superclass.  Throws UnsupportedOperationException if
1114      * this class descriptor is not associated with a class, if the associated
1115      * class is non-serializable or if the appropriate no-arg constructor is
1116      * inaccessible/unavailable.
1117      */
1118     Object newInstance()
1119         throws InstantiationException, InvocationTargetException,
1120                UnsupportedOperationException
1121     {
1122         requireInitialized();
1123         if (cons != null) {
1124             try {
1125                 if (domains == null || domains.length == 0) {
1126                     return cons.newInstance();
1127                 } else {
1128                     JavaSecurityAccess jsa = SharedSecrets.getJavaSecurityAccess();
1129                     PrivilegedAction&lt;?&gt; pea = () -&gt; {
1130                         try {
1131                             return cons.newInstance();
1132                         } catch (InstantiationException
1133                                  | InvocationTargetException
1134                                  | IllegalAccessException x) {
1135                             throw new UndeclaredThrowableException(x);
1136                         }
1137                     }; // Can&#39;t use PrivilegedExceptionAction with jsa
1138                     try {
1139                         return jsa.doIntersectionPrivilege(pea,
1140                                    AccessController.getContext(),
1141                                    new AccessControlContext(domains));
1142                     } catch (UndeclaredThrowableException x) {
1143                         Throwable cause = x.getCause();
1144                         if (cause instanceof InstantiationException)
1145                             throw (InstantiationException) cause;
1146                         if (cause instanceof InvocationTargetException)
1147                             throw (InvocationTargetException) cause;
1148                         if (cause instanceof IllegalAccessException)
1149                             throw (IllegalAccessException) cause;
1150                         // not supposed to happen
1151                         throw x;
1152                     }
1153                 }
1154             } catch (IllegalAccessException ex) {
1155                 // should not occur, as access checks have been suppressed
1156                 throw new InternalError(ex);
<a name="3" id="anc3"></a>



1157             }
1158         } else {
1159             throw new UnsupportedOperationException();
1160         }
1161     }
1162 
1163     /**
1164      * Invokes the writeObject method of the represented serializable class.
1165      * Throws UnsupportedOperationException if this class descriptor is not
1166      * associated with a class, or if the class is externalizable,
1167      * non-serializable or does not define writeObject.
1168      */
1169     void invokeWriteObject(Object obj, ObjectOutputStream out)
1170         throws IOException, UnsupportedOperationException
1171     {
1172         requireInitialized();
1173         if (writeObjectMethod != null) {
1174             try {
1175                 writeObjectMethod.invoke(obj, new Object[]{ out });
1176             } catch (InvocationTargetException ex) {
1177                 Throwable th = ex.getTargetException();
1178                 if (th instanceof IOException) {
1179                     throw (IOException) th;
1180                 } else {
1181                     throwMiscException(th);
1182                 }
1183             } catch (IllegalAccessException ex) {
1184                 // should not occur, as access checks have been suppressed
1185                 throw new InternalError(ex);
1186             }
1187         } else {
1188             throw new UnsupportedOperationException();
1189         }
1190     }
1191 
1192     /**
1193      * Invokes the readObject method of the represented serializable class.
1194      * Throws UnsupportedOperationException if this class descriptor is not
1195      * associated with a class, or if the class is externalizable,
1196      * non-serializable or does not define readObject.
1197      */
1198     void invokeReadObject(Object obj, ObjectInputStream in)
1199         throws ClassNotFoundException, IOException,
1200                UnsupportedOperationException
1201     {
1202         requireInitialized();
1203         if (readObjectMethod != null) {
1204             try {
1205                 readObjectMethod.invoke(obj, new Object[]{ in });
1206             } catch (InvocationTargetException ex) {
1207                 Throwable th = ex.getTargetException();
1208                 if (th instanceof ClassNotFoundException) {
1209                     throw (ClassNotFoundException) th;
1210                 } else if (th instanceof IOException) {
1211                     throw (IOException) th;
1212                 } else {
1213                     throwMiscException(th);
1214                 }
1215             } catch (IllegalAccessException ex) {
1216                 // should not occur, as access checks have been suppressed
1217                 throw new InternalError(ex);
1218             }
1219         } else {
1220             throw new UnsupportedOperationException();
1221         }
1222     }
1223 
1224     /**
1225      * Invokes the readObjectNoData method of the represented serializable
1226      * class.  Throws UnsupportedOperationException if this class descriptor is
1227      * not associated with a class, or if the class is externalizable,
1228      * non-serializable or does not define readObjectNoData.
1229      */
1230     void invokeReadObjectNoData(Object obj)
1231         throws IOException, UnsupportedOperationException
1232     {
1233         requireInitialized();
1234         if (readObjectNoDataMethod != null) {
1235             try {
1236                 readObjectNoDataMethod.invoke(obj, (Object[]) null);
1237             } catch (InvocationTargetException ex) {
1238                 Throwable th = ex.getTargetException();
1239                 if (th instanceof ObjectStreamException) {
1240                     throw (ObjectStreamException) th;
1241                 } else {
1242                     throwMiscException(th);
1243                 }
1244             } catch (IllegalAccessException ex) {
1245                 // should not occur, as access checks have been suppressed
1246                 throw new InternalError(ex);
1247             }
1248         } else {
1249             throw new UnsupportedOperationException();
1250         }
1251     }
1252 
1253     /**
1254      * Invokes the writeReplace method of the represented serializable class and
1255      * returns the result.  Throws UnsupportedOperationException if this class
1256      * descriptor is not associated with a class, or if the class is
1257      * non-serializable or does not define writeReplace.
1258      */
1259     Object invokeWriteReplace(Object obj)
1260         throws IOException, UnsupportedOperationException
1261     {
1262         requireInitialized();
1263         if (writeReplaceMethod != null) {
1264             try {
1265                 return writeReplaceMethod.invoke(obj, (Object[]) null);
1266             } catch (InvocationTargetException ex) {
1267                 Throwable th = ex.getTargetException();
1268                 if (th instanceof ObjectStreamException) {
1269                     throw (ObjectStreamException) th;
1270                 } else {
1271                     throwMiscException(th);
1272                     throw new InternalError(th);  // never reached
1273                 }
1274             } catch (IllegalAccessException ex) {
1275                 // should not occur, as access checks have been suppressed
1276                 throw new InternalError(ex);
1277             }
1278         } else {
1279             throw new UnsupportedOperationException();
1280         }
1281     }
1282 
1283     /**
1284      * Invokes the readResolve method of the represented serializable class and
1285      * returns the result.  Throws UnsupportedOperationException if this class
1286      * descriptor is not associated with a class, or if the class is
1287      * non-serializable or does not define readResolve.
1288      */
1289     Object invokeReadResolve(Object obj)
1290         throws IOException, UnsupportedOperationException
1291     {
1292         requireInitialized();
1293         if (readResolveMethod != null) {
1294             try {
1295                 return readResolveMethod.invoke(obj, (Object[]) null);
1296             } catch (InvocationTargetException ex) {
1297                 Throwable th = ex.getTargetException();
1298                 if (th instanceof ObjectStreamException) {
1299                     throw (ObjectStreamException) th;
1300                 } else {
1301                     throwMiscException(th);
1302                     throw new InternalError(th);  // never reached
1303                 }
1304             } catch (IllegalAccessException ex) {
1305                 // should not occur, as access checks have been suppressed
1306                 throw new InternalError(ex);
1307             }
1308         } else {
1309             throw new UnsupportedOperationException();
1310         }
1311     }
1312 
1313     /**
1314      * Class representing the portion of an object&#39;s serialized form allotted
1315      * to data described by a given class descriptor.  If &quot;hasData&quot; is false,
1316      * the object&#39;s serialized form does not contain data associated with the
1317      * class descriptor.
1318      */
1319     static class ClassDataSlot {
1320 
1321         /** class descriptor &quot;occupying&quot; this slot */
1322         final ObjectStreamClass desc;
1323         /** true if serialized form includes data for this slot&#39;s descriptor */
1324         final boolean hasData;
1325 
1326         ClassDataSlot(ObjectStreamClass desc, boolean hasData) {
1327             this.desc = desc;
1328             this.hasData = hasData;
1329         }
1330     }
1331 
1332     /**
1333      * Returns array of ClassDataSlot instances representing the data layout
1334      * (including superclass data) for serialized objects described by this
1335      * class descriptor.  ClassDataSlots are ordered by inheritance with those
1336      * containing &quot;higher&quot; superclasses appearing first.  The final
1337      * ClassDataSlot contains a reference to this descriptor.
1338      */
1339     ClassDataSlot[] getClassDataLayout() throws InvalidClassException {
1340         // REMIND: synchronize instead of relying on volatile?
1341         if (dataLayout == null) {
1342             dataLayout = getClassDataLayout0();
1343         }
1344         return dataLayout;
1345     }
1346 
1347     private ClassDataSlot[] getClassDataLayout0()
1348         throws InvalidClassException
1349     {
1350         ArrayList&lt;ClassDataSlot&gt; slots = new ArrayList&lt;&gt;();
1351         Class&lt;?&gt; start = cl, end = cl;
1352 
1353         // locate closest non-serializable superclass
1354         while (end != null &amp;&amp; Serializable.class.isAssignableFrom(end)) {
1355             end = end.getSuperclass();
1356         }
1357 
1358         HashSet&lt;String&gt; oscNames = new HashSet&lt;&gt;(3);
1359 
1360         for (ObjectStreamClass d = this; d != null; d = d.superDesc) {
1361             if (oscNames.contains(d.name)) {
1362                 throw new InvalidClassException(&quot;Circular reference.&quot;);
1363             } else {
1364                 oscNames.add(d.name);
1365             }
1366 
1367             // search up inheritance hierarchy for class with matching name
1368             String searchName = (d.cl != null) ? d.cl.getName() : d.name;
1369             Class&lt;?&gt; match = null;
1370             for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) {
1371                 if (searchName.equals(c.getName())) {
1372                     match = c;
1373                     break;
1374                 }
1375             }
1376 
1377             // add &quot;no data&quot; slot for each unmatched class below match
1378             if (match != null) {
1379                 for (Class&lt;?&gt; c = start; c != match; c = c.getSuperclass()) {
1380                     slots.add(new ClassDataSlot(
1381                         ObjectStreamClass.lookup(c, true), false));
1382                 }
1383                 start = match.getSuperclass();
1384             }
1385 
1386             // record descriptor/class pairing
1387             slots.add(new ClassDataSlot(d.getVariantFor(match), true));
1388         }
1389 
1390         // add &quot;no data&quot; slot for any leftover unmatched classes
1391         for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) {
1392             slots.add(new ClassDataSlot(
1393                 ObjectStreamClass.lookup(c, true), false));
1394         }
1395 
1396         // order slots from superclass -&gt; subclass
1397         Collections.reverse(slots);
1398         return slots.toArray(new ClassDataSlot[slots.size()]);
1399     }
1400 
1401     /**
1402      * Returns aggregate size (in bytes) of marshalled primitive field values
1403      * for represented class.
1404      */
1405     int getPrimDataSize() {
1406         return primDataSize;
1407     }
1408 
1409     /**
1410      * Returns number of non-primitive serializable fields of represented
1411      * class.
1412      */
1413     int getNumObjFields() {
1414         return numObjFields;
1415     }
1416 
1417     /**
1418      * Fetches the serializable primitive field values of object obj and
1419      * marshals them into byte array buf starting at offset 0.  It is the
1420      * responsibility of the caller to ensure that obj is of the proper type if
1421      * non-null.
1422      */
1423     void getPrimFieldValues(Object obj, byte[] buf) {
1424         fieldRefl.getPrimFieldValues(obj, buf);
1425     }
1426 
1427     /**
1428      * Sets the serializable primitive fields of object obj using values
1429      * unmarshalled from byte array buf starting at offset 0.  It is the
1430      * responsibility of the caller to ensure that obj is of the proper type if
1431      * non-null.
1432      */
1433     void setPrimFieldValues(Object obj, byte[] buf) {
1434         fieldRefl.setPrimFieldValues(obj, buf);
1435     }
1436 
1437     /**
1438      * Fetches the serializable object field values of object obj and stores
1439      * them in array vals starting at offset 0.  It is the responsibility of
1440      * the caller to ensure that obj is of the proper type if non-null.
1441      */
1442     void getObjFieldValues(Object obj, Object[] vals) {
1443         fieldRefl.getObjFieldValues(obj, vals);
1444     }
1445 
1446     /**
1447      * Checks that the given values, from array vals starting at offset 0,
1448      * are assignable to the given serializable object fields.
1449      * @throws ClassCastException if any value is not assignable
1450      */
1451     void checkObjFieldValueTypes(Object obj, Object[] vals) {
1452         fieldRefl.checkObjectFieldValueTypes(obj, vals);
1453     }
1454 
1455     /**
1456      * Sets the serializable object fields of object obj using values from
1457      * array vals starting at offset 0.  It is the responsibility of the caller
1458      * to ensure that obj is of the proper type if non-null.
1459      */
1460     void setObjFieldValues(Object obj, Object[] vals) {
1461         fieldRefl.setObjFieldValues(obj, vals);
1462     }
1463 
1464     /**
1465      * Calculates and sets serializable field offsets, as well as primitive
1466      * data size and object field count totals.  Throws InvalidClassException
1467      * if fields are illegally ordered.
1468      */
1469     private void computeFieldOffsets() throws InvalidClassException {
1470         primDataSize = 0;
1471         numObjFields = 0;
1472         int firstObjIndex = -1;
1473 
1474         for (int i = 0; i &lt; fields.length; i++) {
1475             ObjectStreamField f = fields[i];
1476             switch (f.getTypeCode()) {
1477                 case &#39;Z&#39;:
1478                 case &#39;B&#39;:
1479                     f.setOffset(primDataSize++);
1480                     break;
1481 
1482                 case &#39;C&#39;:
1483                 case &#39;S&#39;:
1484                     f.setOffset(primDataSize);
1485                     primDataSize += 2;
1486                     break;
1487 
1488                 case &#39;I&#39;:
1489                 case &#39;F&#39;:
1490                     f.setOffset(primDataSize);
1491                     primDataSize += 4;
1492                     break;
1493 
1494                 case &#39;J&#39;:
1495                 case &#39;D&#39;:
1496                     f.setOffset(primDataSize);
1497                     primDataSize += 8;
1498                     break;
1499 
1500                 case &#39;[&#39;:
1501                 case &#39;L&#39;:
1502                     f.setOffset(numObjFields++);
1503                     if (firstObjIndex == -1) {
1504                         firstObjIndex = i;
1505                     }
1506                     break;
1507 
1508                 default:
1509                     throw new InternalError();
1510             }
1511         }
1512         if (firstObjIndex != -1 &amp;&amp;
1513             firstObjIndex + numObjFields != fields.length)
1514         {
1515             throw new InvalidClassException(name, &quot;illegal field order&quot;);
1516         }
1517     }
1518 
1519     /**
1520      * If given class is the same as the class associated with this class
1521      * descriptor, returns reference to this class descriptor.  Otherwise,
1522      * returns variant of this class descriptor bound to given class.
1523      */
1524     private ObjectStreamClass getVariantFor(Class&lt;?&gt; cl)
1525         throws InvalidClassException
1526     {
1527         if (this.cl == cl) {
1528             return this;
1529         }
1530         ObjectStreamClass desc = new ObjectStreamClass();
1531         if (isProxy) {
1532             desc.initProxy(cl, null, superDesc);
1533         } else {
1534             desc.initNonProxy(this, cl, null, superDesc);
1535         }
1536         return desc;
1537     }
1538 
1539     /**
1540      * Returns public no-arg constructor of given class, or null if none found.
1541      * Access checks are disabled on the returned constructor (if any), since
1542      * the defining class may still be non-public.
1543      */
1544     private static Constructor&lt;?&gt; getExternalizableConstructor(Class&lt;?&gt; cl) {
1545         try {
1546             Constructor&lt;?&gt; cons = cl.getDeclaredConstructor((Class&lt;?&gt;[]) null);
1547             cons.setAccessible(true);
1548             return ((cons.getModifiers() &amp; Modifier.PUBLIC) != 0) ?
1549                 cons : null;
1550         } catch (NoSuchMethodException | InaccessibleObjectException ex) {
1551             return null;
1552         }
1553     }
1554 
1555     /**
1556      * Returns subclass-accessible no-arg constructor of first non-serializable
1557      * superclass, or null if none found.  Access checks are disabled on the
1558      * returned constructor (if any).
1559      */
1560     private static Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) {
1561         return reflFactory.newConstructorForSerialization(cl);
1562     }
1563 
1564     /**
1565      * Returns the canonical constructor for the given record class, or null if
1566      * the not found ( which should never happen for correctly generated record
1567      * classes ).
1568      */
1569     @SuppressWarnings(&quot;preview&quot;)
1570     private static MethodHandle canonicalRecordCtr(Class&lt;?&gt; cls) {
1571         assert isRecord(cls) : &quot;Expected record, got: &quot; + cls;
1572         PrivilegedAction&lt;MethodHandle&gt; pa = () -&gt; {
1573             Class&lt;?&gt;[] paramTypes = Arrays.stream(cls.getRecordComponents())
1574                                           .map(RecordComponent::getType)
1575                                           .toArray(Class&lt;?&gt;[]::new);
1576             try {
1577                 Constructor&lt;?&gt; ctr = cls.getConstructor(paramTypes);
1578                 ctr.setAccessible(true);
1579                 return MethodHandles.lookup().unreflectConstructor(ctr);
1580             } catch (IllegalAccessException | NoSuchMethodException e) {
1581                 return null;
1582             }
1583         };
1584         return AccessController.doPrivileged(pa);
1585     }
1586 
1587     /**
1588      * Returns the canonical constructor, if the local class equivalent of this
1589      * stream class descriptor is a record class, otherwise null.
1590      */
1591     MethodHandle getRecordConstructor() {
1592         return canonicalCtr;
1593     }
1594 
1595     /**
1596      * Returns non-static, non-abstract method with given signature provided it
1597      * is defined by or accessible (via inheritance) by the given class, or
1598      * null if no match found.  Access checks are disabled on the returned
1599      * method (if any).
1600      */
1601     private static Method getInheritableMethod(Class&lt;?&gt; cl, String name,
1602                                                Class&lt;?&gt;[] argTypes,
1603                                                Class&lt;?&gt; returnType)
1604     {
1605         Method meth = null;
1606         Class&lt;?&gt; defCl = cl;
1607         while (defCl != null) {
1608             try {
1609                 meth = defCl.getDeclaredMethod(name, argTypes);
1610                 break;
1611             } catch (NoSuchMethodException ex) {
1612                 defCl = defCl.getSuperclass();
1613             }
1614         }
1615 
1616         if ((meth == null) || (meth.getReturnType() != returnType)) {
1617             return null;
1618         }
1619         meth.setAccessible(true);
1620         int mods = meth.getModifiers();
1621         if ((mods &amp; (Modifier.STATIC | Modifier.ABSTRACT)) != 0) {
1622             return null;
1623         } else if ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) != 0) {
1624             return meth;
1625         } else if ((mods &amp; Modifier.PRIVATE) != 0) {
1626             return (cl == defCl) ? meth : null;
1627         } else {
1628             return packageEquals(cl, defCl) ? meth : null;
1629         }
1630     }
1631 
1632     /**
1633      * Returns non-static private method with given signature defined by given
1634      * class, or null if none found.  Access checks are disabled on the
1635      * returned method (if any).
1636      */
1637     private static Method getPrivateMethod(Class&lt;?&gt; cl, String name,
1638                                            Class&lt;?&gt;[] argTypes,
1639                                            Class&lt;?&gt; returnType)
1640     {
1641         try {
1642             Method meth = cl.getDeclaredMethod(name, argTypes);
1643             meth.setAccessible(true);
1644             int mods = meth.getModifiers();
1645             return ((meth.getReturnType() == returnType) &amp;&amp;
1646                     ((mods &amp; Modifier.STATIC) == 0) &amp;&amp;
1647                     ((mods &amp; Modifier.PRIVATE) != 0)) ? meth : null;
1648         } catch (NoSuchMethodException ex) {
1649             return null;
1650         }
1651     }
1652 
1653     /**
1654      * Returns true if classes are defined in the same runtime package, false
1655      * otherwise.
1656      */
1657     private static boolean packageEquals(Class&lt;?&gt; cl1, Class&lt;?&gt; cl2) {
1658         return (cl1.getClassLoader() == cl2.getClassLoader() &amp;&amp;
1659                 cl1.getPackageName().equals(cl2.getPackageName()));
1660     }
1661 
1662     /**
1663      * Compares class names for equality, ignoring package names.  Returns true
1664      * if class names equal, false otherwise.
1665      */
1666     private static boolean classNamesEqual(String name1, String name2) {
1667         int idx1 = name1.lastIndexOf(&#39;.&#39;) + 1;
1668         int idx2 = name2.lastIndexOf(&#39;.&#39;) + 1;
1669         int len1 = name1.length() - idx1;
1670         int len2 = name2.length() - idx2;
1671         return len1 == len2 &amp;&amp;
1672                 name1.regionMatches(idx1, name2, idx2, len1);
1673     }
1674 
1675     /**
1676      * Returns JVM type signature for given list of parameters and return type.
1677      */
1678     private static String getMethodSignature(Class&lt;?&gt;[] paramTypes,
1679                                              Class&lt;?&gt; retType)
1680     {
1681         StringBuilder sb = new StringBuilder();
1682         sb.append(&#39;(&#39;);
1683         for (int i = 0; i &lt; paramTypes.length; i++) {
1684             appendClassSignature(sb, paramTypes[i]);
1685         }
1686         sb.append(&#39;)&#39;);
1687         appendClassSignature(sb, retType);
1688         return sb.toString();
1689     }
1690 
1691     /**
1692      * Convenience method for throwing an exception that is either a
1693      * RuntimeException, Error, or of some unexpected type (in which case it is
1694      * wrapped inside an IOException).
1695      */
1696     private static void throwMiscException(Throwable th) throws IOException {
1697         if (th instanceof RuntimeException) {
1698             throw (RuntimeException) th;
1699         } else if (th instanceof Error) {
1700             throw (Error) th;
1701         } else {
1702             IOException ex = new IOException(&quot;unexpected exception type&quot;);
1703             ex.initCause(th);
1704             throw ex;
1705         }
1706     }
1707 
1708     /**
1709      * Returns ObjectStreamField array describing the serializable fields of
1710      * the given class.  Serializable fields backed by an actual field of the
1711      * class are represented by ObjectStreamFields with corresponding non-null
1712      * Field objects.  Throws InvalidClassException if the (explicitly
1713      * declared) serializable fields are invalid.
1714      */
1715     private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)
1716         throws InvalidClassException
1717     {
1718         if (!Serializable.class.isAssignableFrom(cl))
1719             return NO_FIELDS;
1720 
1721         ObjectStreamField[] fields;
1722         if (isRecord(cl)) {
1723             fields = getDefaultSerialFields(cl);
1724             Arrays.sort(fields);
1725         } else if (!Externalizable.class.isAssignableFrom(cl) &amp;&amp;
1726             !Proxy.isProxyClass(cl) &amp;&amp;
1727                    !cl.isInterface()) {
1728             if ((fields = getDeclaredSerialFields(cl)) == null) {
1729                 fields = getDefaultSerialFields(cl);
1730             }
1731             Arrays.sort(fields);
1732         } else {
1733             fields = NO_FIELDS;
1734         }
1735         return fields;
1736     }
1737 
1738     /**
1739      * Returns serializable fields of given class as defined explicitly by a
1740      * &quot;serialPersistentFields&quot; field, or null if no appropriate
1741      * &quot;serialPersistentFields&quot; field is defined.  Serializable fields backed
1742      * by an actual field of the class are represented by ObjectStreamFields
1743      * with corresponding non-null Field objects.  For compatibility with past
1744      * releases, a &quot;serialPersistentFields&quot; field with a null value is
1745      * considered equivalent to not declaring &quot;serialPersistentFields&quot;.  Throws
1746      * InvalidClassException if the declared serializable fields are
1747      * invalid--e.g., if multiple fields share the same name.
1748      */
1749     private static ObjectStreamField[] getDeclaredSerialFields(Class&lt;?&gt; cl)
1750         throws InvalidClassException
1751     {
1752         ObjectStreamField[] serialPersistentFields = null;
1753         try {
1754             Field f = cl.getDeclaredField(&quot;serialPersistentFields&quot;);
1755             int mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;
1756             if ((f.getModifiers() &amp; mask) == mask) {
1757                 f.setAccessible(true);
1758                 serialPersistentFields = (ObjectStreamField[]) f.get(null);
1759             }
1760         } catch (Exception ex) {
1761         }
1762         if (serialPersistentFields == null) {
1763             return null;
1764         } else if (serialPersistentFields.length == 0) {
1765             return NO_FIELDS;
1766         }
1767 
1768         ObjectStreamField[] boundFields =
1769             new ObjectStreamField[serialPersistentFields.length];
1770         Set&lt;String&gt; fieldNames = new HashSet&lt;&gt;(serialPersistentFields.length);
1771 
1772         for (int i = 0; i &lt; serialPersistentFields.length; i++) {
1773             ObjectStreamField spf = serialPersistentFields[i];
1774 
1775             String fname = spf.getName();
1776             if (fieldNames.contains(fname)) {
1777                 throw new InvalidClassException(
1778                     &quot;multiple serializable fields named &quot; + fname);
1779             }
1780             fieldNames.add(fname);
1781 
1782             try {
1783                 Field f = cl.getDeclaredField(fname);
1784                 if ((f.getType() == spf.getType()) &amp;&amp;
1785                     ((f.getModifiers() &amp; Modifier.STATIC) == 0))
1786                 {
1787                     boundFields[i] =
1788                         new ObjectStreamField(f, spf.isUnshared(), true);
1789                 }
1790             } catch (NoSuchFieldException ex) {
1791             }
1792             if (boundFields[i] == null) {
1793                 boundFields[i] = new ObjectStreamField(
1794                     fname, spf.getType(), spf.isUnshared());
1795             }
1796         }
1797         return boundFields;
1798     }
1799 
1800     /**
1801      * Returns array of ObjectStreamFields corresponding to all non-static
1802      * non-transient fields declared by given class.  Each ObjectStreamField
1803      * contains a Field object for the field it represents.  If no default
1804      * serializable fields exist, NO_FIELDS is returned.
1805      */
1806     private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) {
1807         Field[] clFields = cl.getDeclaredFields();
1808         ArrayList&lt;ObjectStreamField&gt; list = new ArrayList&lt;&gt;();
1809         int mask = Modifier.STATIC | Modifier.TRANSIENT;
1810 
1811         for (int i = 0; i &lt; clFields.length; i++) {
1812             if ((clFields[i].getModifiers() &amp; mask) == 0) {
1813                 list.add(new ObjectStreamField(clFields[i], false, true));
1814             }
1815         }
1816         int size = list.size();
1817         return (size == 0) ? NO_FIELDS :
1818             list.toArray(new ObjectStreamField[size]);
1819     }
1820 
1821     /**
1822      * Returns explicit serial version UID value declared by given class, or
1823      * null if none.
1824      */
1825     private static Long getDeclaredSUID(Class&lt;?&gt; cl) {
1826         try {
1827             Field f = cl.getDeclaredField(&quot;serialVersionUID&quot;);
1828             int mask = Modifier.STATIC | Modifier.FINAL;
1829             if ((f.getModifiers() &amp; mask) == mask) {
1830                 f.setAccessible(true);
1831                 return Long.valueOf(f.getLong(null));
1832             }
1833         } catch (Exception ex) {
1834         }
1835         return null;
1836     }
1837 
1838     /**
1839      * Computes the default serial version UID value for the given class.
1840      */
1841     private static long computeDefaultSUID(Class&lt;?&gt; cl) {
1842         if (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl))
1843         {
1844             return 0L;
1845         }
1846 
1847         try {
1848             ByteArrayOutputStream bout = new ByteArrayOutputStream();
1849             DataOutputStream dout = new DataOutputStream(bout);
1850 
1851             dout.writeUTF(cl.getName());
1852 
1853             int classMods = cl.getModifiers() &amp;
1854                 (Modifier.PUBLIC | Modifier.FINAL |
1855                  Modifier.INTERFACE | Modifier.ABSTRACT);
1856 
1857             /*
1858              * compensate for javac bug in which ABSTRACT bit was set for an
1859              * interface only if the interface declared methods
1860              */
1861             Method[] methods = cl.getDeclaredMethods();
1862             if ((classMods &amp; Modifier.INTERFACE) != 0) {
1863                 classMods = (methods.length &gt; 0) ?
1864                     (classMods | Modifier.ABSTRACT) :
1865                     (classMods &amp; ~Modifier.ABSTRACT);
1866             }
1867             dout.writeInt(classMods);
1868 
1869             if (!cl.isArray()) {
1870                 /*
1871                  * compensate for change in 1.2FCS in which
1872                  * Class.getInterfaces() was modified to return Cloneable and
1873                  * Serializable for array classes.
1874                  */
1875                 Class&lt;?&gt;[] interfaces = cl.getInterfaces();
1876                 String[] ifaceNames = new String[interfaces.length];
1877                 for (int i = 0; i &lt; interfaces.length; i++) {
1878                     ifaceNames[i] = interfaces[i].getName();
1879                 }
1880                 Arrays.sort(ifaceNames);
1881                 // Skip IdentityObject to keep the computed SVUID the same.
1882                 for (int i = 0; i &lt; ifaceNames.length; i++) {
1883                     if (!&quot;java.lang.IdentityObject&quot;.equals(ifaceNames[i]))
1884                         dout.writeUTF(ifaceNames[i]);
1885                 }
1886             }
1887 
1888             Field[] fields = cl.getDeclaredFields();
1889             MemberSignature[] fieldSigs = new MemberSignature[fields.length];
1890             for (int i = 0; i &lt; fields.length; i++) {
1891                 fieldSigs[i] = new MemberSignature(fields[i]);
1892             }
1893             Arrays.sort(fieldSigs, new Comparator&lt;&gt;() {
1894                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1895                     return ms1.name.compareTo(ms2.name);
1896                 }
1897             });
1898             for (int i = 0; i &lt; fieldSigs.length; i++) {
1899                 MemberSignature sig = fieldSigs[i];
1900                 int mods = sig.member.getModifiers() &amp;
1901                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1902                      Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |
1903                      Modifier.TRANSIENT);
1904                 if (((mods &amp; Modifier.PRIVATE) == 0) ||
1905                     ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == 0))
1906                 {
1907                     dout.writeUTF(sig.name);
1908                     dout.writeInt(mods);
1909                     dout.writeUTF(sig.signature);
1910                 }
1911             }
1912 
1913             if (hasStaticInitializer(cl)) {
1914                 dout.writeUTF(&quot;&lt;clinit&gt;&quot;);
1915                 dout.writeInt(Modifier.STATIC);
1916                 dout.writeUTF(&quot;()V&quot;);
1917             }
1918 
1919             Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();
1920             MemberSignature[] consSigs = new MemberSignature[cons.length];
1921             for (int i = 0; i &lt; cons.length; i++) {
1922                 consSigs[i] = new MemberSignature(cons[i]);
1923             }
1924             Arrays.sort(consSigs, new Comparator&lt;&gt;() {
1925                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1926                     return ms1.signature.compareTo(ms2.signature);
1927                 }
1928             });
1929             for (int i = 0; i &lt; consSigs.length; i++) {
1930                 MemberSignature sig = consSigs[i];
1931                 int mods = sig.member.getModifiers() &amp;
1932                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1933                      Modifier.STATIC | Modifier.FINAL |
1934                      Modifier.SYNCHRONIZED | Modifier.NATIVE |
1935                      Modifier.ABSTRACT | Modifier.STRICT);
1936                 if ((mods &amp; Modifier.PRIVATE) == 0) {
1937                     dout.writeUTF(&quot;&lt;init&gt;&quot;);
1938                     dout.writeInt(mods);
1939                     dout.writeUTF(sig.signature.replace(&#39;/&#39;, &#39;.&#39;));
1940                 }
1941             }
1942 
1943             MemberSignature[] methSigs = new MemberSignature[methods.length];
1944             for (int i = 0; i &lt; methods.length; i++) {
1945                 methSigs[i] = new MemberSignature(methods[i]);
1946             }
1947             Arrays.sort(methSigs, new Comparator&lt;&gt;() {
1948                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1949                     int comp = ms1.name.compareTo(ms2.name);
1950                     if (comp == 0) {
1951                         comp = ms1.signature.compareTo(ms2.signature);
1952                     }
1953                     return comp;
1954                 }
1955             });
1956             for (int i = 0; i &lt; methSigs.length; i++) {
1957                 MemberSignature sig = methSigs[i];
1958                 int mods = sig.member.getModifiers() &amp;
1959                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1960                      Modifier.STATIC | Modifier.FINAL |
1961                      Modifier.SYNCHRONIZED | Modifier.NATIVE |
1962                      Modifier.ABSTRACT | Modifier.STRICT);
1963                 if ((mods &amp; Modifier.PRIVATE) == 0) {
1964                     dout.writeUTF(sig.name);
1965                     dout.writeInt(mods);
1966                     dout.writeUTF(sig.signature.replace(&#39;/&#39;, &#39;.&#39;));
1967                 }
1968             }
1969 
1970             dout.flush();
1971 
1972             MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
1973             byte[] hashBytes = md.digest(bout.toByteArray());
1974             long hash = 0;
1975             for (int i = Math.min(hashBytes.length, 8) - 1; i &gt;= 0; i--) {
1976                 hash = (hash &lt;&lt; 8) | (hashBytes[i] &amp; 0xFF);
1977             }
1978             return hash;
1979         } catch (IOException ex) {
1980             throw new InternalError(ex);
1981         } catch (NoSuchAlgorithmException ex) {
1982             throw new SecurityException(ex.getMessage());
1983         }
1984     }
1985 
1986     /**
1987      * Returns true if the given class defines a static initializer method,
1988      * false otherwise.
1989      */
1990     private static native boolean hasStaticInitializer(Class&lt;?&gt; cl);
1991 
1992     /**
1993      * Class for computing and caching field/constructor/method signatures
1994      * during serialVersionUID calculation.
1995      */
1996     private static class MemberSignature {
1997 
1998         public final Member member;
1999         public final String name;
2000         public final String signature;
2001 
2002         public MemberSignature(Field field) {
2003             member = field;
2004             name = field.getName();
2005             signature = getClassSignature(field.getType());
2006         }
2007 
2008         public MemberSignature(Constructor&lt;?&gt; cons) {
2009             member = cons;
2010             name = cons.getName();
2011             signature = getMethodSignature(
2012                 cons.getParameterTypes(), Void.TYPE);
2013         }
2014 
2015         public MemberSignature(Method meth) {
2016             member = meth;
2017             name = meth.getName();
2018             signature = getMethodSignature(
2019                 meth.getParameterTypes(), meth.getReturnType());
2020         }
2021     }
2022 
2023     /**
2024      * Class for setting and retrieving serializable field values in batch.
2025      */
2026     // REMIND: dynamically generate these?
2027     private static class FieldReflector {
2028 
2029         /** handle for performing unsafe operations */
2030         private static final Unsafe unsafe = Unsafe.getUnsafe();
2031 
2032         /** fields to operate on */
2033         private final ObjectStreamField[] fields;
2034         /** number of primitive fields */
2035         private final int numPrimFields;
2036         /** unsafe field keys for reading fields - may contain dupes */
2037         private final long[] readKeys;
2038         /** unsafe fields keys for writing fields - no dupes */
2039         private final long[] writeKeys;
2040         /** field data offsets */
2041         private final int[] offsets;
2042         /** field type codes */
2043         private final char[] typeCodes;
2044         /** field types */
2045         private final Class&lt;?&gt;[] types;
2046 
2047         /**
2048          * Constructs FieldReflector capable of setting/getting values from the
2049          * subset of fields whose ObjectStreamFields contain non-null
2050          * reflective Field objects.  ObjectStreamFields with null Fields are
2051          * treated as filler, for which get operations return default values
2052          * and set operations discard given values.
2053          */
2054         FieldReflector(ObjectStreamField[] fields) {
2055             this.fields = fields;
2056             int nfields = fields.length;
2057             readKeys = new long[nfields];
2058             writeKeys = new long[nfields];
2059             offsets = new int[nfields];
2060             typeCodes = new char[nfields];
2061             ArrayList&lt;Class&lt;?&gt;&gt; typeList = new ArrayList&lt;&gt;();
2062             Set&lt;Long&gt; usedKeys = new HashSet&lt;&gt;();
2063 
2064 
2065             for (int i = 0; i &lt; nfields; i++) {
2066                 ObjectStreamField f = fields[i];
2067                 Field rf = f.getField();
2068                 long key = (rf != null) ?
2069                     unsafe.objectFieldOffset(rf) : Unsafe.INVALID_FIELD_OFFSET;
2070                 readKeys[i] = key;
2071                 writeKeys[i] = usedKeys.add(key) ?
2072                     key : Unsafe.INVALID_FIELD_OFFSET;
2073                 offsets[i] = f.getOffset();
2074                 typeCodes[i] = f.getTypeCode();
2075                 if (!f.isPrimitive()) {
2076                     typeList.add((rf != null) ? rf.getType() : null);
2077                 }
2078             }
2079 
2080             types = typeList.toArray(new Class&lt;?&gt;[typeList.size()]);
2081             numPrimFields = nfields - types.length;
2082         }
2083 
2084         /**
2085          * Returns list of ObjectStreamFields representing fields operated on
2086          * by this reflector.  The shared/unshared values and Field objects
2087          * contained by ObjectStreamFields in the list reflect their bindings
2088          * to locally defined serializable fields.
2089          */
2090         ObjectStreamField[] getFields() {
2091             return fields;
2092         }
2093 
2094         /**
2095          * Fetches the serializable primitive field values of object obj and
2096          * marshals them into byte array buf starting at offset 0.  The caller
2097          * is responsible for ensuring that obj is of the proper type.
2098          */
2099         void getPrimFieldValues(Object obj, byte[] buf) {
2100             if (obj == null) {
2101                 throw new NullPointerException();
2102             }
2103             /* assuming checkDefaultSerialize() has been called on the class
2104              * descriptor this FieldReflector was obtained from, no field keys
2105              * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.
2106              */
2107             for (int i = 0; i &lt; numPrimFields; i++) {
2108                 long key = readKeys[i];
2109                 int off = offsets[i];
2110                 switch (typeCodes[i]) {
2111                     case &#39;Z&#39;:
2112                         Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));
2113                         break;
2114 
2115                     case &#39;B&#39;:
2116                         buf[off] = unsafe.getByte(obj, key);
2117                         break;
2118 
2119                     case &#39;C&#39;:
2120                         Bits.putChar(buf, off, unsafe.getChar(obj, key));
2121                         break;
2122 
2123                     case &#39;S&#39;:
2124                         Bits.putShort(buf, off, unsafe.getShort(obj, key));
2125                         break;
2126 
2127                     case &#39;I&#39;:
2128                         Bits.putInt(buf, off, unsafe.getInt(obj, key));
2129                         break;
2130 
2131                     case &#39;F&#39;:
2132                         Bits.putFloat(buf, off, unsafe.getFloat(obj, key));
2133                         break;
2134 
2135                     case &#39;J&#39;:
2136                         Bits.putLong(buf, off, unsafe.getLong(obj, key));
2137                         break;
2138 
2139                     case &#39;D&#39;:
2140                         Bits.putDouble(buf, off, unsafe.getDouble(obj, key));
2141                         break;
2142 
2143                     default:
2144                         throw new InternalError();
2145                 }
2146             }
2147         }
2148 
2149         /**
2150          * Sets the serializable primitive fields of object obj using values
2151          * unmarshalled from byte array buf starting at offset 0.  The caller
2152          * is responsible for ensuring that obj is of the proper type.
2153          */
2154         void setPrimFieldValues(Object obj, byte[] buf) {
2155             if (obj == null) {
2156                 throw new NullPointerException();
2157             }
2158             for (int i = 0; i &lt; numPrimFields; i++) {
2159                 long key = writeKeys[i];
2160                 if (key == Unsafe.INVALID_FIELD_OFFSET) {
2161                     continue;           // discard value
2162                 }
2163                 int off = offsets[i];
2164                 switch (typeCodes[i]) {
2165                     case &#39;Z&#39;:
2166                         unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off));
2167                         break;
2168 
2169                     case &#39;B&#39;:
2170                         unsafe.putByte(obj, key, buf[off]);
2171                         break;
2172 
2173                     case &#39;C&#39;:
2174                         unsafe.putChar(obj, key, Bits.getChar(buf, off));
2175                         break;
2176 
2177                     case &#39;S&#39;:
2178                         unsafe.putShort(obj, key, Bits.getShort(buf, off));
2179                         break;
2180 
2181                     case &#39;I&#39;:
2182                         unsafe.putInt(obj, key, Bits.getInt(buf, off));
2183                         break;
2184 
2185                     case &#39;F&#39;:
2186                         unsafe.putFloat(obj, key, Bits.getFloat(buf, off));
2187                         break;
2188 
2189                     case &#39;J&#39;:
2190                         unsafe.putLong(obj, key, Bits.getLong(buf, off));
2191                         break;
2192 
2193                     case &#39;D&#39;:
2194                         unsafe.putDouble(obj, key, Bits.getDouble(buf, off));
2195                         break;
2196 
2197                     default:
2198                         throw new InternalError();
2199                 }
2200             }
2201         }
2202 
2203         /**
2204          * Fetches the serializable object field values of object obj and
2205          * stores them in array vals starting at offset 0.  The caller is
2206          * responsible for ensuring that obj is of the proper type.
2207          */
2208         void getObjFieldValues(Object obj, Object[] vals) {
2209             if (obj == null) {
2210                 throw new NullPointerException();
2211             }
2212             /* assuming checkDefaultSerialize() has been called on the class
2213              * descriptor this FieldReflector was obtained from, no field keys
2214              * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.
2215              */
2216             for (int i = numPrimFields; i &lt; fields.length; i++) {
2217                 switch (typeCodes[i]) {
2218                     case &#39;L&#39;:
2219                     case &#39;[&#39;:
2220                         vals[offsets[i]] = unsafe.getReference(obj, readKeys[i]);
2221                         break;
2222 
2223                     default:
2224                         throw new InternalError();
2225                 }
2226             }
2227         }
2228 
2229         /**
2230          * Checks that the given values, from array vals starting at offset 0,
2231          * are assignable to the given serializable object fields.
2232          * @throws ClassCastException if any value is not assignable
2233          */
2234         void checkObjectFieldValueTypes(Object obj, Object[] vals) {
2235             setObjFieldValues(obj, vals, true);
2236         }
2237 
2238         /**
2239          * Sets the serializable object fields of object obj using values from
2240          * array vals starting at offset 0.  The caller is responsible for
2241          * ensuring that obj is of the proper type; however, attempts to set a
2242          * field with a value of the wrong type will trigger an appropriate
2243          * ClassCastException.
2244          */
2245         void setObjFieldValues(Object obj, Object[] vals) {
2246             setObjFieldValues(obj, vals, false);
2247         }
2248 
2249         private void setObjFieldValues(Object obj, Object[] vals, boolean dryRun) {
2250             if (obj == null) {
2251                 throw new NullPointerException();
2252             }
2253             for (int i = numPrimFields; i &lt; fields.length; i++) {
2254                 long key = writeKeys[i];
2255                 if (key == Unsafe.INVALID_FIELD_OFFSET) {
2256                     continue;           // discard value
2257                 }
2258                 switch (typeCodes[i]) {
2259                     case &#39;L&#39;:
2260                     case &#39;[&#39;:
2261                         Object val = vals[offsets[i]];
2262                         if (val != null &amp;&amp;
2263                             !types[i - numPrimFields].isInstance(val))
2264                         {
2265                             Field f = fields[i].getField();
2266                             throw new ClassCastException(
2267                                 &quot;cannot assign instance of &quot; +
2268                                 val.getClass().getName() + &quot; to field &quot; +
2269                                 f.getDeclaringClass().getName() + &quot;.&quot; +
2270                                 f.getName() + &quot; of type &quot; +
2271                                 f.getType().getName() + &quot; in instance of &quot; +
2272                                 obj.getClass().getName());
2273                         }
2274                         if (!dryRun)
2275                             unsafe.putReference(obj, key, val);
2276                         break;
2277 
2278                     default:
2279                         throw new InternalError();
2280                 }
2281             }
2282         }
2283     }
2284 
2285     /**
2286      * Matches given set of serializable fields with serializable fields
2287      * described by the given local class descriptor, and returns a
2288      * FieldReflector instance capable of setting/getting values from the
2289      * subset of fields that match (non-matching fields are treated as filler,
2290      * for which get operations return default values and set operations
2291      * discard given values).  Throws InvalidClassException if unresolvable
2292      * type conflicts exist between the two sets of fields.
2293      */
2294     private static FieldReflector getReflector(ObjectStreamField[] fields,
2295                                                ObjectStreamClass localDesc)
2296         throws InvalidClassException
2297     {
2298         // class irrelevant if no fields
2299         Class&lt;?&gt; cl = (localDesc != null &amp;&amp; fields.length &gt; 0) ?
2300             localDesc.cl : null;
2301         processQueue(Caches.reflectorsQueue, Caches.reflectors);
2302         FieldReflectorKey key = new FieldReflectorKey(cl, fields,
2303                                                       Caches.reflectorsQueue);
2304         Reference&lt;?&gt; ref = Caches.reflectors.get(key);
2305         Object entry = null;
2306         if (ref != null) {
2307             entry = ref.get();
2308         }
2309         EntryFuture future = null;
2310         if (entry == null) {
2311             EntryFuture newEntry = new EntryFuture();
2312             Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);
2313             do {
2314                 if (ref != null) {
2315                     Caches.reflectors.remove(key, ref);
2316                 }
2317                 ref = Caches.reflectors.putIfAbsent(key, newRef);
2318                 if (ref != null) {
2319                     entry = ref.get();
2320                 }
2321             } while (ref != null &amp;&amp; entry == null);
2322             if (entry == null) {
2323                 future = newEntry;
2324             }
2325         }
2326 
2327         if (entry instanceof FieldReflector) {  // check common case first
2328             return (FieldReflector) entry;
2329         } else if (entry instanceof EntryFuture) {
2330             entry = ((EntryFuture) entry).get();
2331         } else if (entry == null) {
2332             try {
2333                 entry = new FieldReflector(matchFields(fields, localDesc));
2334             } catch (Throwable th) {
2335                 entry = th;
2336             }
2337             future.set(entry);
2338             Caches.reflectors.put(key, new SoftReference&lt;&gt;(entry));
2339         }
2340 
2341         if (entry instanceof FieldReflector) {
2342             return (FieldReflector) entry;
2343         } else if (entry instanceof InvalidClassException) {
2344             throw (InvalidClassException) entry;
2345         } else if (entry instanceof RuntimeException) {
2346             throw (RuntimeException) entry;
2347         } else if (entry instanceof Error) {
2348             throw (Error) entry;
2349         } else {
2350             throw new InternalError(&quot;unexpected entry: &quot; + entry);
2351         }
2352     }
2353 
2354     /**
2355      * FieldReflector cache lookup key.  Keys are considered equal if they
2356      * refer to the same class and equivalent field formats.
2357      */
2358     private static class FieldReflectorKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2359 
2360         private final String[] sigs;
2361         private final int hash;
2362         private final boolean nullClass;
2363 
2364         FieldReflectorKey(Class&lt;?&gt; cl, ObjectStreamField[] fields,
2365                           ReferenceQueue&lt;Class&lt;?&gt;&gt; queue)
2366         {
2367             super(cl, queue);
2368             nullClass = (cl == null);
2369             sigs = new String[2 * fields.length];
2370             for (int i = 0, j = 0; i &lt; fields.length; i++) {
2371                 ObjectStreamField f = fields[i];
2372                 sigs[j++] = f.getName();
2373                 sigs[j++] = f.getSignature();
2374             }
2375             hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);
2376         }
2377 
2378         public int hashCode() {
2379             return hash;
2380         }
2381 
2382         public boolean equals(Object obj) {
2383             if (obj == this) {
2384                 return true;
2385             }
2386 
2387             if (obj instanceof FieldReflectorKey) {
2388                 FieldReflectorKey other = (FieldReflectorKey) obj;
2389                 Class&lt;?&gt; referent;
2390                 return (nullClass ? other.nullClass
2391                                   : ((referent = get()) != null) &amp;&amp;
2392                                     (referent == other.get())) &amp;&amp;
2393                         Arrays.equals(sigs, other.sigs);
2394             } else {
2395                 return false;
2396             }
2397         }
2398     }
2399 
2400     /**
2401      * Matches given set of serializable fields with serializable fields
2402      * obtained from the given local class descriptor (which contain bindings
2403      * to reflective Field objects).  Returns list of ObjectStreamFields in
2404      * which each ObjectStreamField whose signature matches that of a local
2405      * field contains a Field object for that field; unmatched
2406      * ObjectStreamFields contain null Field objects.  Shared/unshared settings
2407      * of the returned ObjectStreamFields also reflect those of matched local
2408      * ObjectStreamFields.  Throws InvalidClassException if unresolvable type
2409      * conflicts exist between the two sets of fields.
2410      */
2411     private static ObjectStreamField[] matchFields(ObjectStreamField[] fields,
2412                                                    ObjectStreamClass localDesc)
2413         throws InvalidClassException
2414     {
2415         ObjectStreamField[] localFields = (localDesc != null) ?
2416             localDesc.fields : NO_FIELDS;
2417 
2418         /*
2419          * Even if fields == localFields, we cannot simply return localFields
2420          * here.  In previous implementations of serialization,
2421          * ObjectStreamField.getType() returned Object.class if the
2422          * ObjectStreamField represented a non-primitive field and belonged to
2423          * a non-local class descriptor.  To preserve this (questionable)
2424          * behavior, the ObjectStreamField instances returned by matchFields
2425          * cannot report non-primitive types other than Object.class; hence
2426          * localFields cannot be returned directly.
2427          */
2428 
2429         ObjectStreamField[] matches = new ObjectStreamField[fields.length];
2430         for (int i = 0; i &lt; fields.length; i++) {
2431             ObjectStreamField f = fields[i], m = null;
2432             for (int j = 0; j &lt; localFields.length; j++) {
2433                 ObjectStreamField lf = localFields[j];
2434                 if (f.getName().equals(lf.getName())) {
2435                     if ((f.isPrimitive() || lf.isPrimitive()) &amp;&amp;
2436                         f.getTypeCode() != lf.getTypeCode())
2437                     {
2438                         throw new InvalidClassException(localDesc.name,
2439                             &quot;incompatible types for field &quot; + f.getName());
2440                     }
2441                     if (lf.getField() != null) {
2442                         m = new ObjectStreamField(
2443                             lf.getField(), lf.isUnshared(), false);
2444                     } else {
2445                         m = new ObjectStreamField(
2446                             lf.getName(), lf.getSignature(), lf.isUnshared());
2447                     }
2448                 }
2449             }
2450             if (m == null) {
2451                 m = new ObjectStreamField(
2452                     f.getName(), f.getSignature(), false);
2453             }
2454             m.setOffset(f.getOffset());
2455             matches[i] = m;
2456         }
2457         return matches;
2458     }
2459 
2460     /**
2461      * Removes from the specified map any keys that have been enqueued
2462      * on the specified reference queue.
2463      */
2464     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2465                              ConcurrentMap&lt;? extends
2466                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2467     {
2468         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2469         while((ref = queue.poll()) != null) {
2470             map.remove(ref);
2471         }
2472     }
2473 
2474     /**
2475      *  Weak key for Class objects.
2476      *
2477      **/
2478     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2479         /**
2480          * saved value of the referent&#39;s identity hash code, to maintain
2481          * a consistent hash code after the referent has been cleared
2482          */
2483         private final int hash;
2484 
2485         /**
2486          * Create a new WeakClassKey to the given object, registered
2487          * with a queue.
2488          */
2489         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2490             super(cl, refQueue);
2491             hash = System.identityHashCode(cl);
2492         }
2493 
2494         /**
2495          * Returns the identity hash code of the original referent.
2496          */
2497         public int hashCode() {
2498             return hash;
2499         }
2500 
2501         /**
2502          * Returns true if the given object is this identical
2503          * WeakClassKey instance, or, if this object&#39;s referent has not
2504          * been cleared, if the given object is another WeakClassKey
2505          * instance with the identical non-null referent as this one.
2506          */
2507         public boolean equals(Object obj) {
2508             if (obj == this) {
2509                 return true;
2510             }
2511 
2512             if (obj instanceof WeakClassKey) {
2513                 Object referent = get();
2514                 return (referent != null) &amp;&amp;
2515                        (referent == ((WeakClassKey) obj).get());
2516             } else {
2517                 return false;
2518             }
2519         }
2520     }
2521 
2522     /** Record specific support for retrieving and binding stream field values. */
2523     static final class RecordSupport {
2524 
2525         /** Binds the given stream field values to the given method handle. */
2526         @SuppressWarnings(&quot;preview&quot;)
2527         static MethodHandle bindCtrValues(MethodHandle ctrMH,
2528                                           ObjectStreamClass desc,
2529                                           ObjectInputStream.FieldValues fieldValues) {
2530             RecordComponent[] recordComponents;
2531             try {
2532                 Class&lt;?&gt; cls = desc.forClass();
2533                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;
2534                 recordComponents = AccessController.doPrivileged(pa);
2535             } catch (PrivilegedActionException e) {
2536                 throw new InternalError(e.getCause());
2537             }
2538 
2539             Object[] args = new Object[recordComponents.length];
2540             for (int i = 0; i &lt; recordComponents.length; i++) {
2541                 String name = recordComponents[i].getName();
2542                 Class&lt;?&gt; type= recordComponents[i].getType();
2543                 Object o = streamFieldValue(name, type, desc, fieldValues);
2544                 args[i] = o;
2545             }
2546 
2547             return MethodHandles.insertArguments(ctrMH, 0, args);
2548         }
2549 
2550         /** Returns the number of primitive fields for the given descriptor. */
2551         private static int numberPrimValues(ObjectStreamClass desc) {
2552             ObjectStreamField[] fields = desc.getFields();
2553             int primValueCount = 0;
2554             for (int i = 0; i &lt; fields.length; i++) {
2555                 if (fields[i].isPrimitive())
2556                     primValueCount++;
2557                 else
2558                     break;  // can be no more
2559             }
2560             return primValueCount;
2561         }
2562 
2563         /** Returns the default value for the given type. */
2564         private static Object defaultValueFor(Class&lt;?&gt; pType) {
2565             if (pType == Integer.TYPE)
2566                 return 0;
2567             else if (pType == Byte.TYPE)
2568                 return (byte)0;
2569             else if (pType == Long.TYPE)
2570                 return 0L;
2571             else if (pType == Float.TYPE)
2572                 return 0.0f;
2573             else if (pType == Double.TYPE)
2574                 return 0.0d;
2575             else if (pType == Short.TYPE)
2576                 return (short)0;
2577             else if (pType == Character.TYPE)
2578                 return &#39;\u0000&#39;;
2579             else if (pType == Boolean.TYPE)
2580                 return false;
2581             else
2582                 return null;
2583         }
2584 
2585         /**
2586          * Returns the stream field value for the given name. The default value
2587          * for the given type is returned if the field value is absent.
2588          */
2589         private static Object streamFieldValue(String pName,
2590                                                Class&lt;?&gt; pType,
2591                                                ObjectStreamClass desc,
2592                                                ObjectInputStream.FieldValues fieldValues) {
2593             ObjectStreamField[] fields = desc.getFields();
2594 
2595             for (int i = 0; i &lt; fields.length; i++) {
2596                 ObjectStreamField f = fields[i];
2597                 String fName = f.getName();
2598                 if (!fName.equals(pName))
2599                     continue;
2600 
2601                 Class&lt;?&gt; fType = f.getField().getType();
2602                 if (!pType.isAssignableFrom(fType))
2603                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);
2604 
2605                 if (f.isPrimitive()) {
2606                     if (pType == Integer.TYPE)
2607                         return Bits.getInt(fieldValues.primValues, f.getOffset());
2608                     else if (fType == Byte.TYPE)
2609                         return fieldValues.primValues[f.getOffset()];
2610                     else if (fType == Long.TYPE)
2611                         return Bits.getLong(fieldValues.primValues, f.getOffset());
2612                     else if (fType == Float.TYPE)
2613                         return Bits.getFloat(fieldValues.primValues, f.getOffset());
2614                     else if (fType == Double.TYPE)
2615                         return Bits.getDouble(fieldValues.primValues, f.getOffset());
2616                     else if (fType == Short.TYPE)
2617                         return Bits.getShort(fieldValues.primValues, f.getOffset());
2618                     else if (fType == Character.TYPE)
2619                         return Bits.getChar(fieldValues.primValues, f.getOffset());
2620                     else if (fType == Boolean.TYPE)
2621                         return Bits.getBoolean(fieldValues.primValues, f.getOffset());
2622                     else
2623                         throw new InternalError(&quot;Unexpected type: &quot; + fType);
2624                 } else { // reference
2625                     return fieldValues.objValues[i - numberPrimValues(desc)];
2626                 }
2627             }
2628 
2629             return defaultValueFor(pType);
2630         }
2631     }
2632 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
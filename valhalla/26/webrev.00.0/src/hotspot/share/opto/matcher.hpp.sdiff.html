<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/matcher.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="matcher.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/io/ObjectStreamClass.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
104   const int *_rightOp;
105 
106   // Map dense opcode number to info on when rule is swallowed constant.
107   const bool *_swallowed;
108 
109   // Map dense rule number to determine if this is an instruction chain rule
110   const uint _begin_inst_chain_rule;
111   const uint _end_inst_chain_rule;
112 
113   // We want to clone constants and possible CmpI-variants.
114   // If we do not clone CmpI, then we can have many instances of
115   // condition codes alive at once.  This is OK on some chips and
116   // bad on others.  Hence the machine-dependent table lookup.
117   const char *_must_clone;
118 
119   // Find shared Nodes, or Nodes that otherwise are Matcher roots
120   void find_shared( Node *n );
121   bool find_shared_visit(MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx);
122   void find_shared_post_visit(Node* n, uint opcode);
123 
<span class="line-removed">124 #ifdef X86</span>
<span class="line-removed">125   bool is_bmi_pattern(Node *n, Node *m);</span>
<span class="line-removed">126 #endif</span>
<span class="line-removed">127 </span>
128   bool is_vshift_con_pattern(Node *n, Node *m);
129 
130   // Debug and profile information for nodes in old space:
131   GrowableArray&lt;Node_Notes*&gt;* _old_node_note_array;
132 
133   // Node labeling iterator for instruction selection
134   Node* Label_Root(const Node* n, State* svec, Node* control, Node*&amp; mem);
135 
136   Node *transform( Node *dummy );
137 
138   Node_List _projection_list;        // For Machine nodes killing many values
139 
140   Node_Array _shared_nodes;
141 
142   debug_only(Node_Array _old2new_map;)   // Map roots of ideal-trees to machine-roots
143   debug_only(Node_Array _new2old_map;)   // Maps machine nodes back to ideal
144 
145   // Accessors for the inherited field PhaseTransform::_nodes:
146   void   grow_new_node_array(uint idx_limit) {
147     _nodes.map(idx_limit-1, NULL);
</pre>
<hr />
<pre>
437   // and so is probably the stack pointer for most machines.  On Intel
438   // it is ESP.  On the PowerPC it is R1.  On Sparc it is SP.
439   OptoReg::Name  c_frame_pointer() const;
440   static RegMask c_frame_ptr_mask;
441 
442   // !!!!! Special stuff for building ScopeDescs
443   virtual int      regnum_to_fpu_offset(int regnum);
444 
445   // Is this branch offset small enough to be addressed by a short branch?
446   bool is_short_branch_offset(int rule, int br_size, int offset);
447 
448   // Optional scaling for the parameter to the ClearArray/CopyArray node.
449   static const bool init_array_count_is_in_bytes;
450 
451   // Some hardware needs 2 CMOV&#39;s for longs.
452   static const int long_cmove_cost();
453 
454   // Some hardware have expensive CMOV for float and double.
455   static const int float_cmove_cost();
456 





457   // Should the Matcher clone shifts on addressing modes, expecting them to
458   // be subsumed into complex addressing expressions or compute them into
459   // registers?  True for Intel but false for most RISCs
<span class="line-modified">460   bool clone_address_expressions(AddPNode* m, MStack&amp; mstack, VectorSet&amp; address_visited);</span>
461   // Clone base + offset address expression
462   bool clone_base_plus_offset_address(AddPNode* m, MStack&amp; mstack, VectorSet&amp; address_visited);
463 
464   static bool narrow_oop_use_complex_address();
465   static bool narrow_klass_use_complex_address();
466 
467   static bool const_oop_prefer_decode();
468   static bool const_klass_prefer_decode();
469 
470   // Generate implicit null check for narrow oops if it can fold
471   // into address expression (x64).
472   //
473   // [R12 + narrow_oop_reg&lt;&lt;3 + offset] // fold into address expression
474   // NullCheck narrow_oop_reg
475   //
476   // When narrow oops can&#39;t fold into address expression (Sparc) and
477   // base is not null use decode_not_null and normal implicit null check.
478   // Note, decode_not_null node can be used here since it is referenced
479   // only on non null path but it requires special handling, see
480   // collect_null_checks():
</pre>
</td>
<td>
<hr />
<pre>
104   const int *_rightOp;
105 
106   // Map dense opcode number to info on when rule is swallowed constant.
107   const bool *_swallowed;
108 
109   // Map dense rule number to determine if this is an instruction chain rule
110   const uint _begin_inst_chain_rule;
111   const uint _end_inst_chain_rule;
112 
113   // We want to clone constants and possible CmpI-variants.
114   // If we do not clone CmpI, then we can have many instances of
115   // condition codes alive at once.  This is OK on some chips and
116   // bad on others.  Hence the machine-dependent table lookup.
117   const char *_must_clone;
118 
119   // Find shared Nodes, or Nodes that otherwise are Matcher roots
120   void find_shared( Node *n );
121   bool find_shared_visit(MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx);
122   void find_shared_post_visit(Node* n, uint opcode);
123 




124   bool is_vshift_con_pattern(Node *n, Node *m);
125 
126   // Debug and profile information for nodes in old space:
127   GrowableArray&lt;Node_Notes*&gt;* _old_node_note_array;
128 
129   // Node labeling iterator for instruction selection
130   Node* Label_Root(const Node* n, State* svec, Node* control, Node*&amp; mem);
131 
132   Node *transform( Node *dummy );
133 
134   Node_List _projection_list;        // For Machine nodes killing many values
135 
136   Node_Array _shared_nodes;
137 
138   debug_only(Node_Array _old2new_map;)   // Map roots of ideal-trees to machine-roots
139   debug_only(Node_Array _new2old_map;)   // Maps machine nodes back to ideal
140 
141   // Accessors for the inherited field PhaseTransform::_nodes:
142   void   grow_new_node_array(uint idx_limit) {
143     _nodes.map(idx_limit-1, NULL);
</pre>
<hr />
<pre>
433   // and so is probably the stack pointer for most machines.  On Intel
434   // it is ESP.  On the PowerPC it is R1.  On Sparc it is SP.
435   OptoReg::Name  c_frame_pointer() const;
436   static RegMask c_frame_ptr_mask;
437 
438   // !!!!! Special stuff for building ScopeDescs
439   virtual int      regnum_to_fpu_offset(int regnum);
440 
441   // Is this branch offset small enough to be addressed by a short branch?
442   bool is_short_branch_offset(int rule, int br_size, int offset);
443 
444   // Optional scaling for the parameter to the ClearArray/CopyArray node.
445   static const bool init_array_count_is_in_bytes;
446 
447   // Some hardware needs 2 CMOV&#39;s for longs.
448   static const int long_cmove_cost();
449 
450   // Some hardware have expensive CMOV for float and double.
451   static const int float_cmove_cost();
452 
<span class="line-added">453   // Should the input &#39;m&#39; of node &#39;n&#39; be cloned during matching?</span>
<span class="line-added">454   // Reports back whether the node was cloned or not.</span>
<span class="line-added">455   bool    clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack);</span>
<span class="line-added">456   bool pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack);</span>
<span class="line-added">457 </span>
458   // Should the Matcher clone shifts on addressing modes, expecting them to
459   // be subsumed into complex addressing expressions or compute them into
460   // registers?  True for Intel but false for most RISCs
<span class="line-modified">461   bool pd_clone_address_expressions(AddPNode* m, MStack&amp; mstack, VectorSet&amp; address_visited);</span>
462   // Clone base + offset address expression
463   bool clone_base_plus_offset_address(AddPNode* m, MStack&amp; mstack, VectorSet&amp; address_visited);
464 
465   static bool narrow_oop_use_complex_address();
466   static bool narrow_klass_use_complex_address();
467 
468   static bool const_oop_prefer_decode();
469   static bool const_klass_prefer_decode();
470 
471   // Generate implicit null check for narrow oops if it can fold
472   // into address expression (x64).
473   //
474   // [R12 + narrow_oop_reg&lt;&lt;3 + offset] // fold into address expression
475   // NullCheck narrow_oop_reg
476   //
477   // When narrow oops can&#39;t fold into address expression (Sparc) and
478   // base is not null use decode_not_null and normal implicit null check.
479   // Note, decode_not_null node can be used here since it is referenced
480   // only on non null path but it requires special handling, see
481   // collect_null_checks():
</pre>
</td>
</tr>
</table>
<center><a href="matcher.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/io/ObjectStreamClass.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.valuetypes;
  25 
  26 import java.lang.invoke.*;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 import jdk.experimental.value.MethodHandleBuilder;
  31 import jdk.test.lib.Asserts;
  32 
  33 /*
  34  * @test
  35  * @summary Test value types in LWorld.
  36  * @modules java.base/jdk.experimental.value
  37  * @library /testlibrary /test/lib /compiler/whitebox /
  38  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  39  * @compile -XDallowEmptyValues TestLWorld.java
  40  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  41  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  42  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  43  *                               compiler.valhalla.valuetypes.ValueTypeTest
  44  *                               compiler.valhalla.valuetypes.TestLWorld
  45  */
  46 public class TestLWorld extends ValueTypeTest {
  47     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
  48     @Override
  49     public String[] getExtraVMParameters(int scenario) {
  50         switch (scenario) {
  51         case 1: return new String[] {&quot;-XX:-UseOptoBiasInlining&quot;};
  52         case 2: return new String[] {&quot;-DVerifyIR=false&quot;, &quot;-XX:-UseBiasedLocking&quot;};
  53         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UseBiasedLocking&quot;, &quot;-XX:FlatArrayElementMaxSize=-1&quot;};
  54         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  55         }
  56         return null;
  57     }
  58 
  59     public static void main(String[] args) throws Throwable {
  60         TestLWorld test = new TestLWorld();
  61         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class,
  62                  MyValue3Inline.class, Test51Value.class);
  63     }
  64 
  65     // Helper methods
  66 
  67     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  68     private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, true);
  69 
  70     protected long hash() {
  71         return testValue1.hash();
  72     }
  73 
  74     // Test passing a value type as an Object
  75     @DontInline
  76     public Object test1_dontinline1(Object o) {
  77         return o;
  78     }
  79 
  80     @DontInline
  81     public MyValue1 test1_dontinline2(Object o) {
  82         return (MyValue1)o;
  83     }
  84 
  85     @ForceInline
  86     public Object test1_inline1(Object o) {
  87         return o;
  88     }
  89 
  90     @ForceInline
  91     public MyValue1 test1_inline2(Object o) {
  92         return (MyValue1)o;
  93     }
  94 
  95     @Test()
  96     public MyValue1 test1() {
  97         MyValue1 vt = testValue1;
  98         vt = (MyValue1)test1_dontinline1(vt);
  99         vt =           test1_dontinline2(vt);
 100         vt = (MyValue1)test1_inline1(vt);
 101         vt =           test1_inline2(vt);
 102         return vt;
 103     }
 104 
 105     @DontCompile
 106     public void test1_verifier(boolean warmup) {
 107         Asserts.assertEQ(test1().hash(), hash());
 108     }
 109 
 110     // Test storing/loading value types to/from Object and value type fields
 111     Object objectField1 = null;
 112     Object objectField2 = null;
 113     Object objectField3 = null;
 114     Object objectField4 = null;
 115     Object objectField5 = null;
 116     Object objectField6 = null;
 117 
 118     MyValue1 valueField1 = testValue1;
 119     MyValue1 valueField2 = testValue1;
 120     MyValue1.ref valueField3 = testValue1;
 121     MyValue1 valueField4;
 122     MyValue1.ref valueField5;
 123 
 124     static MyValue1.ref staticValueField1 = testValue1;
 125     static MyValue1 staticValueField2 = testValue1;
 126     static MyValue1 staticValueField3;
 127     static MyValue1.ref staticValueField4;
 128 
 129     @DontInline
 130     public Object readValueField5() {
 131         return (Object)valueField5;
 132     }
 133 
 134     @DontInline
 135     public Object readStaticValueField4() {
 136         return (Object)staticValueField4;
 137     }
 138 
 139     @Test()
 140     public long test2(MyValue1 vt1, Object vt2) {
 141         objectField1 = vt1;
 142         objectField2 = (MyValue1)vt2;
 143         objectField3 = testValue1;
 144         objectField4 = MyValue1.createWithFieldsDontInline(rI, rL);
 145         objectField5 = valueField1;
 146         objectField6 = valueField3;
 147         valueField1 = (MyValue1)objectField1;
 148         valueField2 = (MyValue1)vt2;
 149         valueField3 = (MyValue1)vt2;
 150         staticValueField1 = (MyValue1)objectField1;
 151         staticValueField2 = (MyValue1)vt1;
 152         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
 153         if (readValueField5() != null || readStaticValueField4() != null) {
 154             throw new RuntimeException(&quot;Should be null&quot;);
 155         }
 156         return ((MyValue1)objectField1).hash() + ((MyValue1)objectField2).hash() +
 157                ((MyValue1)objectField3).hash() + ((MyValue1)objectField4).hash() +
 158                ((MyValue1)objectField5).hash() + ((MyValue1)objectField6).hash() +
 159                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
 160                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
 161     }
 162 
 163     @DontCompile
 164     public void test2_verifier(boolean warmup) {
 165         MyValue1 vt = testValue1;
 166         MyValue1 def = MyValue1.createDefaultDontInline();
 167         long result = test2(vt, vt);
 168         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
 169     }
 170 
 171     // Test merging value types and objects
 172     @Test()
 173     public Object test3(int state) {
 174         Object res = null;
 175         if (state == 0) {
 176             res = new Integer(rI);
 177         } else if (state == 1) {
 178             res = MyValue1.createWithFieldsInline(rI, rL);
 179         } else if (state == 2) {
 180             res = MyValue1.createWithFieldsDontInline(rI, rL);
 181         } else if (state == 3) {
 182             res = (MyValue1)objectField1;
 183         } else if (state == 4) {
 184             res = valueField1;
 185         } else if (state == 5) {
 186             res = null;
 187         } else if (state == 6) {
 188             res = MyValue2.createWithFieldsInline(rI, true);
 189         } else if (state == 7) {
 190             res = testValue2;
 191         }
 192         return res;
 193     }
 194 
 195     @DontCompile
 196     public void test3_verifier(boolean warmup) {
 197         objectField1 = valueField1;
 198         Object result = null;
 199         result = test3(0);
 200         Asserts.assertEQ((Integer)result, rI);
 201         result = test3(1);
 202         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 203         result = test3(2);
 204         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 205         result = test3(3);
 206         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 207         result = test3(4);
 208         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 209         result = test3(5);
 210         Asserts.assertEQ(result, null);
 211         result = test3(6);
 212         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
 213         result = test3(7);
 214         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
 215     }
 216 
 217     // Test merging value types and objects in loops
 218     @Test()
 219     public Object test4(int iters) {
 220         Object res = new Integer(rI);
 221         for (int i = 0; i &lt; iters; ++i) {
 222             if (res instanceof Integer) {
 223                 res = MyValue1.createWithFieldsInline(rI, rL);
 224             } else {
 225                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
 226             }
 227         }
 228         return res;
 229     }
 230 
 231     @DontCompile
 232     public void test4_verifier(boolean warmup) {
 233         Integer result1 = (Integer)test4(0);
 234         Asserts.assertEQ(result1, rI);
 235         int iters = (Math.abs(rI) % 10) + 1;
 236         MyValue1 result2 = (MyValue1)test4(iters);
 237         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
 238         Asserts.assertEQ(result2.hash(), vt.hash());
 239     }
 240 
 241     // Test value types in object variables that are live at safepoint
 242     @Test(failOn = ALLOC + STORE + LOOP)
 243     public long test5(MyValue1 arg, boolean deopt) {
 244         Object vt1 = MyValue1.createWithFieldsInline(rI, rL);
 245         Object vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
 246         Object vt3 = arg;
 247         Object vt4 = valueField1;
 248         if (deopt) {
 249             // uncommon trap
 250             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test5&quot;));
 251         }
 252         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
 253                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
 254     }
 255 
 256     @DontCompile
 257     public void test5_verifier(boolean warmup) {
 258         long result = test5(valueField1, !warmup);
 259         Asserts.assertEQ(result, 4*hash());
 260     }
 261 
 262     // Test comparing value types with objects
 263     @Test(failOn = LOAD + LOOP)
 264     public boolean test6(Object arg) {
 265         Object vt = MyValue1.createWithFieldsInline(rI, rL);
 266         if (vt == arg || vt == (Object)valueField1 || vt == objectField1 || vt == null ||
 267             arg == vt || (Object)valueField1 == vt || objectField1 == vt || null == vt) {
 268             return true;
 269         }
 270         return false;
 271     }
 272 
 273     @DontCompile
 274     public void test6_verifier(boolean warmup) {
 275         boolean result = test6(null);
 276         Asserts.assertFalse(result);
 277     }
 278 
 279     // merge of value and non value
 280     @Test
 281     public Object test7(boolean flag) {
 282         Object res = null;
 283         if (flag) {
 284             res = valueField1;
 285         } else {
 286             res = objectField1;
 287         }
 288         return res;
 289     }
 290 
 291     @DontCompile
 292     public void test7_verifier(boolean warmup) {
 293         test7(true);
 294         test7(false);
 295     }
 296 
 297     @Test
 298     public Object test8(boolean flag) {
 299         Object res = null;
 300         if (flag) {
 301             res = objectField1;
 302         } else {
 303             res = valueField1;
 304         }
 305         return res;
 306     }
 307 
 308     @DontCompile
 309     public void test8_verifier(boolean warmup) {
 310         test8(true);
 311         test8(false);
 312     }
 313 
 314     // merge of values in a loop, stored in an object local
 315     @Test
 316     public Object test9() {
 317         Object o = valueField1;
 318         for (int i = 1; i &lt; 100; i *= 2) {
 319             MyValue1 v = (MyValue1)o;
 320             o = MyValue1.setX(v, v.x + 1);
 321         }
 322         return o;
 323     }
 324 
 325     @DontCompile
 326     public void test9_verifier(boolean warmup) {
 327         test9();
 328     }
 329 
 330     // merge of values in an object local
 331     public Object test10_helper() {
 332         return valueField1;
 333     }
 334 
 335     @Test(failOn = ALLOC + LOAD + STORE)
 336     public void test10(boolean flag) {
 337         Object o = null;
 338         if (flag) {
 339             o = valueField1;
 340         } else {
 341             o = test10_helper();
 342         }
 343         valueField1 = (MyValue1)o;
 344     }
 345 
 346     @DontCompile
 347     public void test10_verifier(boolean warmup) {
 348         test10(true);
 349         test10(false);
 350     }
 351 
 352     // Interface tests
 353 
 354     @DontInline
 355     public MyInterface test11_dontinline1(MyInterface o) {
 356         return o;
 357     }
 358 
 359     @DontInline
 360     public MyValue1 test11_dontinline2(MyInterface o) {
 361         return (MyValue1)o;
 362     }
 363 
 364     @ForceInline
 365     public MyInterface test11_inline1(MyInterface o) {
 366         return o;
 367     }
 368 
 369     @ForceInline
 370     public MyValue1 test11_inline2(MyInterface o) {
 371         return (MyValue1)o;
 372     }
 373 
 374     @Test()
 375     public MyValue1 test11() {
 376         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 377         vt = (MyValue1)test11_dontinline1(vt);
 378         vt =           test11_dontinline2(vt);
 379         vt = (MyValue1)test11_inline1(vt);
 380         vt =           test11_inline2(vt);
 381         return vt;
 382     }
 383 
 384     @DontCompile
 385     public void test11_verifier(boolean warmup) {
 386         Asserts.assertEQ(test11().hash(), hash());
 387     }
 388 
 389     // Test storing/loading value types to/from interface and value type fields
 390     MyInterface interfaceField1 = null;
 391     MyInterface interfaceField2 = null;
 392     MyInterface interfaceField3 = null;
 393     MyInterface interfaceField4 = null;
 394     MyInterface interfaceField5 = null;
 395     MyInterface interfaceField6 = null;
 396 
 397     @DontInline
 398     public MyInterface readValueField5AsInterface() {
 399         return (MyInterface)valueField5;
 400     }
 401 
 402     @DontInline
 403     public MyInterface readStaticValueField4AsInterface() {
 404         return (MyInterface)staticValueField4;
 405     }
 406 
 407     @Test()
 408     public long test12(MyValue1 vt1, MyInterface vt2) {
 409         interfaceField1 = vt1;
 410         interfaceField2 = (MyValue1)vt2;
 411         interfaceField3 = MyValue1.createWithFieldsInline(rI, rL);
 412         interfaceField4 = MyValue1.createWithFieldsDontInline(rI, rL);
 413         interfaceField5 = valueField1;
 414         interfaceField6 = valueField3;
 415         valueField1 = (MyValue1)interfaceField1;
 416         valueField2 = (MyValue1)vt2;
 417         valueField3 = (MyValue1)vt2;
 418         staticValueField1 = (MyValue1)interfaceField1;
 419         staticValueField2 = (MyValue1)vt1;
 420         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
 421         if (readValueField5AsInterface() != null || readStaticValueField4AsInterface() != null) {
 422             throw new RuntimeException(&quot;Should be null&quot;);
 423         }
 424         return ((MyValue1)interfaceField1).hash() + ((MyValue1)interfaceField2).hash() +
 425                ((MyValue1)interfaceField3).hash() + ((MyValue1)interfaceField4).hash() +
 426                ((MyValue1)interfaceField5).hash() + ((MyValue1)interfaceField6).hash() +
 427                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
 428                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
 429     }
 430 
 431     @DontCompile
 432     public void test12_verifier(boolean warmup) {
 433         MyValue1 vt = testValue1;
 434         MyValue1 def = MyValue1.createDefaultDontInline();
 435         long result = test12(vt, vt);
 436         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
 437     }
 438 
 439     class MyObject1 implements MyInterface {
 440         public int x;
 441 
 442         public MyObject1(int x) {
 443             this.x = x;
 444         }
 445 
 446         @ForceInline
 447         public long hash() {
 448             return x;
 449         }
 450     }
 451 
 452     // Test merging value types and interfaces
 453     @Test()
 454     public MyInterface test13(int state) {
 455         MyInterface res = null;
 456         if (state == 0) {
 457             res = new MyObject1(rI);
 458         } else if (state == 1) {
 459             res = MyValue1.createWithFieldsInline(rI, rL);
 460         } else if (state == 2) {
 461             res = MyValue1.createWithFieldsDontInline(rI, rL);
 462         } else if (state == 3) {
 463             res = (MyValue1)objectField1;
 464         } else if (state == 4) {
 465             res = valueField1;
 466         } else if (state == 5) {
 467             res = null;
 468         }
 469         return res;
 470     }
 471 
 472     @DontCompile
 473     public void test13_verifier(boolean warmup) {
 474         objectField1 = valueField1;
 475         MyInterface result = null;
 476         result = test13(0);
 477         Asserts.assertEQ(((MyObject1)result).x, rI);
 478         result = test13(1);
 479         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 480         result = test13(2);
 481         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 482         result = test13(3);
 483         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 484         result = test13(4);
 485         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 486         result = test13(5);
 487         Asserts.assertEQ(result, null);
 488     }
 489 
 490     // Test merging value types and interfaces in loops
 491     @Test()
 492     public MyInterface test14(int iters) {
 493         MyInterface res = new MyObject1(rI);
 494         for (int i = 0; i &lt; iters; ++i) {
 495             if (res instanceof MyObject1) {
 496                 res = MyValue1.createWithFieldsInline(rI, rL);
 497             } else {
 498                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
 499             }
 500         }
 501         return res;
 502     }
 503 
 504     @DontCompile
 505     public void test14_verifier(boolean warmup) {
 506         MyObject1 result1 = (MyObject1)test14(0);
 507         Asserts.assertEQ(result1.x, rI);
 508         int iters = (Math.abs(rI) % 10) + 1;
 509         MyValue1 result2 = (MyValue1)test14(iters);
 510         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
 511         Asserts.assertEQ(result2.hash(), vt.hash());
 512     }
 513 
 514     // Test value types in interface variables that are live at safepoint
 515     @Test(failOn = ALLOC + STORE + LOOP)
 516     public long test15(MyValue1 arg, boolean deopt) {
 517         MyInterface vt1 = MyValue1.createWithFieldsInline(rI, rL);
 518         MyInterface vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
 519         MyInterface vt3 = arg;
 520         MyInterface vt4 = valueField1;
 521         if (deopt) {
 522             // uncommon trap
 523             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test15&quot;));
 524         }
 525         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
 526                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
 527     }
 528 
 529     @DontCompile
 530     public void test15_verifier(boolean warmup) {
 531         long result = test15(valueField1, !warmup);
 532         Asserts.assertEQ(result, 4*hash());
 533     }
 534 
 535     // Test comparing value types with interfaces
 536     @Test(failOn = LOAD + LOOP)
 537     public boolean test16(Object arg) {
 538         MyInterface vt = MyValue1.createWithFieldsInline(rI, rL);
 539         if (vt == arg || vt == (MyInterface)valueField1 || vt == interfaceField1 || vt == null ||
 540             arg == vt || (MyInterface)valueField1 == vt || interfaceField1 == vt || null == vt) {
 541             return true;
 542         }
 543         return false;
 544     }
 545 
 546     @DontCompile
 547     public void test16_verifier(boolean warmup) {
 548         boolean result = test16(null);
 549         Asserts.assertFalse(result);
 550     }
 551 
 552     // Test subtype check when casting to value type
 553     @Test
 554     public MyValue1 test17(MyValue1 vt, Object obj) {
 555         try {
 556             vt = (MyValue1)obj;
 557             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 558         } catch (ClassCastException e) {
 559             // Expected
 560         }
 561         return vt;
 562     }
 563 
 564     @DontCompile
 565     public void test17_verifier(boolean warmup) {
 566         MyValue1 vt = testValue1;
 567         MyValue1 result = test17(vt, new Integer(rI));
 568         Asserts.assertEquals(result.hash(), vt.hash());
 569     }
 570 
 571     @Test
 572     public MyValue1 test18(MyValue1 vt) {
 573         Object obj = vt;
 574         vt = (MyValue1)obj;
 575         return vt;
 576     }
 577 
 578     @DontCompile
 579     public void test18_verifier(boolean warmup) {
 580         MyValue1 vt = testValue1;
 581         MyValue1 result = test18(vt);
 582         Asserts.assertEquals(result.hash(), vt.hash());
 583     }
 584 
 585     @Test
 586     public void test19(MyValue1 vt) {
 587         Object obj = vt;
 588         try {
 589             MyValue2 vt2 = (MyValue2)obj;
 590             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 591         } catch (ClassCastException e) {
 592             // Expected
 593         }
 594     }
 595 
 596     @DontCompile
 597     public void test19_verifier(boolean warmup) {
 598         test19(valueField1);
 599     }
 600 
 601     @Test
 602     public void test20(MyValue1 vt) {
 603         Object obj = vt;
 604         try {
 605             Integer i = (Integer)obj;
 606             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 607         } catch (ClassCastException e) {
 608             // Expected
 609         }
 610     }
 611 
 612     @DontCompile
 613     public void test20_verifier(boolean warmup) {
 614         test20(valueField1);
 615     }
 616 
 617     // Array tests
 618 
 619     private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,
 620                                                                       testValue1,
 621                                                                       testValue1};
 622 
 623     private static final MyValue1[][] testValue1Array2 = new MyValue1[][] {testValue1Array,
 624                                                                            testValue1Array,
 625                                                                            testValue1Array};
 626 
 627     private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2,
 628                                                                       testValue2,
 629                                                                       testValue2};
 630 
 631     private static final Integer[] testIntegerArray = new Integer[42];
 632 
 633     // Test load from (flattened) value type array disguised as object array
 634     @Test()
 635     public Object test21(Object[] oa, int index) {
 636         return oa[index];
 637     }
 638 
 639     @DontCompile
 640     public void test21_verifier(boolean warmup) {
 641         MyValue1 result = (MyValue1)test21(testValue1Array, Math.abs(rI) % 3);
 642         Asserts.assertEQ(result.hash(), hash());
 643     }
 644 
 645     // Test load from (flattened) value type array disguised as interface array
 646     @Test()
 647     public Object test22Interface(MyInterface[] ia, int index) {
 648         return ia[index];
 649     }
 650 
 651     @DontCompile
 652     public void test22Interface_verifier(boolean warmup) {
 653         MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);
 654         Asserts.assertEQ(result.hash(), hash());
 655     }
 656 
 657     // Test load from (flattened) value type array disguised as abstract array
 658     @Test()
 659     public Object test22Abstract(MyAbstract[] ia, int index) {
 660         return ia[index];
 661     }
 662 
 663     @DontCompile
 664     public void test22Abstract_verifier(boolean warmup) {
 665         MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);
 666         Asserts.assertEQ(result.hash(), hash());
 667     }
 668 
 669     // Test value store to (flattened) value type array disguised as object array
 670     @ForceInline
 671     public void test23_inline(Object[] oa, Object o, int index) {
 672         oa[index] = o;
 673     }
 674 
 675     @Test()
 676     public void test23(Object[] oa, MyValue1 vt, int index) {
 677         test23_inline(oa, vt, index);
 678     }
 679 
 680     @DontCompile
 681     public void test23_verifier(boolean warmup) {
 682         int index = Math.abs(rI) % 3;
 683         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 684         test23(testValue1Array, vt, index);
 685         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 686         testValue1Array[index] = testValue1;
 687         try {
 688             test23(testValue2Array, vt, index);
 689             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 690         } catch (ArrayStoreException e) {
 691             // Expected
 692         }
 693         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 694     }
 695 
 696     @ForceInline
 697     public void test24_inline(Object[] oa, Object o, int index) {
 698         oa[index] = o;
 699     }
 700 
 701     @Test()
 702     public void test24(Object[] oa, MyValue1 vt, int index) {
 703         test24_inline(oa, vt, index);
 704     }
 705 
 706     @DontCompile
 707     public void test24_verifier(boolean warmup) {
 708         int index = Math.abs(rI) % 3;
 709         try {
 710             test24(testIntegerArray, testValue1, index);
 711             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 712         } catch (ArrayStoreException e) {
 713             // Expected
 714         }
 715     }
 716 
 717     @ForceInline
 718     public void test25_inline(Object[] oa, Object o, int index) {
 719         oa[index] = o;
 720     }
 721 
 722     @Test()
 723     public void test25(Object[] oa, MyValue1 vt, int index) {
 724         test25_inline(oa, vt, index);
 725     }
 726 
 727     @DontCompile
 728     public void test25_verifier(boolean warmup) {
 729         int index = Math.abs(rI) % 3;
 730         try {
 731             test25(null, testValue1, index);
 732             throw new RuntimeException(&quot;No NPE thrown&quot;);
 733         } catch (NullPointerException e) {
 734             // Expected
 735         }
 736     }
 737 
 738     // Test value store to (flattened) value type array disguised as interface array
 739     @ForceInline
 740     public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 741         ia[index] = i;
 742     }
 743 
 744     @Test()
 745     public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {
 746       test26Interface_inline(ia, vt, index);
 747     }
 748 
 749     @DontCompile
 750     public void test26Interface_verifier(boolean warmup) {
 751         int index = Math.abs(rI) % 3;
 752         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 753         test26Interface(testValue1Array, vt, index);
 754         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 755         testValue1Array[index] = testValue1;
 756         try {
 757             test26Interface(testValue2Array, vt, index);
 758             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 759         } catch (ArrayStoreException e) {
 760             // Expected
 761         }
 762         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 763     }
 764 
 765     @ForceInline
 766     public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 767         ia[index] = i;
 768     }
 769 
 770     @Test()
 771     public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {
 772         test27Interface_inline(ia, vt, index);
 773     }
 774 
 775     @DontCompile
 776     public void test27Interface_verifier(boolean warmup) {
 777         int index = Math.abs(rI) % 3;
 778         try {
 779             test27Interface(null, testValue1, index);
 780             throw new RuntimeException(&quot;No NPE thrown&quot;);
 781         } catch (NullPointerException e) {
 782             // Expected
 783         }
 784     }
 785 
 786     // Test value store to (flattened) value type array disguised as abstract array
 787     @ForceInline
 788     public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 789         ia[index] = i;
 790     }
 791 
 792     @Test()
 793     public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {
 794       test26Abstract_inline(ia, vt, index);
 795     }
 796 
 797     @DontCompile
 798     public void test26Abstract_verifier(boolean warmup) {
 799         int index = Math.abs(rI) % 3;
 800         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 801         test26Abstract(testValue1Array, vt, index);
 802         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 803         testValue1Array[index] = testValue1;
 804         try {
 805             test26Abstract(testValue2Array, vt, index);
 806             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 807         } catch (ArrayStoreException e) {
 808             // Expected
 809         }
 810         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 811     }
 812 
 813     @ForceInline
 814     public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 815         ia[index] = i;
 816     }
 817 
 818     @Test()
 819     public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {
 820         test27Abstract_inline(ia, vt, index);
 821     }
 822 
 823     @DontCompile
 824     public void test27Abstract_verifier(boolean warmup) {
 825         int index = Math.abs(rI) % 3;
 826         try {
 827             test27Abstract(null, testValue1, index);
 828             throw new RuntimeException(&quot;No NPE thrown&quot;);
 829         } catch (NullPointerException e) {
 830             // Expected
 831         }
 832     }
 833 
 834     // Test object store to (flattened) value type array disguised as object array
 835     @ForceInline
 836     public void test28_inline(Object[] oa, Object o, int index) {
 837         oa[index] = o;
 838     }
 839 
 840     @Test()
 841     public void test28(Object[] oa, Object o, int index) {
 842         test28_inline(oa, o, index);
 843     }
 844 
 845     @DontCompile
 846     public void test28_verifier(boolean warmup) {
 847         int index = Math.abs(rI) % 3;
 848         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 849         test28(testValue1Array, vt1, index);
 850         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 851         try {
 852             test28(testValue1Array, testValue2, index);
 853             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 854         } catch (ArrayStoreException e) {
 855             // Expected
 856         }
 857         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 858         testValue1Array[index] = testValue1;
 859     }
 860 
 861     @ForceInline
 862     public void test29_inline(Object[] oa, Object o, int index) {
 863         oa[index] = o;
 864     }
 865 
 866     @Test()
 867     public void test29(Object[] oa, Object o, int index) {
 868         test29_inline(oa, o, index);
 869     }
 870 
 871     @DontCompile
 872     public void test29_verifier(boolean warmup) {
 873         int index = Math.abs(rI) % 3;
 874         try {
 875             test29(testValue2Array, testValue1, index);
 876             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 877         } catch (ArrayStoreException e) {
 878             // Expected
 879         }
 880         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 881     }
 882 
 883     @ForceInline
 884     public void test30_inline(Object[] oa, Object o, int index) {
 885         oa[index] = o;
 886     }
 887 
 888     @Test()
 889     public void test30(Object[] oa, Object o, int index) {
 890         test30_inline(oa, o, index);
 891     }
 892 
 893     @DontCompile
 894     public void test30_verifier(boolean warmup) {
 895         int index = Math.abs(rI) % 3;
 896         try {
 897             test30(testIntegerArray, testValue1, index);
 898             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 899         } catch (ArrayStoreException e) {
 900             // Expected
 901         }
 902     }
 903 
 904     // Test value store to (flattened) value type array disguised as interface array
 905     @ForceInline
 906     public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 907         ia[index] = i;
 908     }
 909 
 910     @Test()
 911     public void test31Interface(MyInterface[] ia, MyInterface i, int index) {
 912         test31Interface_inline(ia, i, index);
 913     }
 914 
 915     @DontCompile
 916     public void test31Interface_verifier(boolean warmup) {
 917         int index = Math.abs(rI) % 3;
 918         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 919         test31Interface(testValue1Array, vt1, index);
 920         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 921         try {
 922             test31Interface(testValue1Array, testValue2, index);
 923             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 924         } catch (ArrayStoreException e) {
 925             // Expected
 926         }
 927         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 928         testValue1Array[index] = testValue1;
 929     }
 930 
 931     @ForceInline
 932     public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 933         ia[index] = i;
 934     }
 935 
 936     @Test()
 937     public void test32Interface(MyInterface[] ia, MyInterface i, int index) {
 938         test32Interface_inline(ia, i, index);
 939     }
 940 
 941     @DontCompile
 942     public void test32Interface_verifier(boolean warmup) {
 943         int index = Math.abs(rI) % 3;
 944         try {
 945             test32Interface(testValue2Array, testValue1, index);
 946             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 947         } catch (ArrayStoreException e) {
 948             // Expected
 949         }
 950     }
 951 
 952     // Test value store to (flattened) value type array disguised as abstract array
 953     @ForceInline
 954     public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 955         ia[index] = i;
 956     }
 957 
 958     @Test()
 959     public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {
 960         test31Abstract_inline(ia, i, index);
 961     }
 962 
 963     @DontCompile
 964     public void test31Abstract_verifier(boolean warmup) {
 965         int index = Math.abs(rI) % 3;
 966         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 967         test31Abstract(testValue1Array, vt1, index);
 968         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 969         try {
 970             test31Abstract(testValue1Array, testValue2, index);
 971             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 972         } catch (ArrayStoreException e) {
 973             // Expected
 974         }
 975         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 976         testValue1Array[index] = testValue1;
 977     }
 978 
 979     @ForceInline
 980     public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 981         ia[index] = i;
 982     }
 983 
 984     @Test()
 985     public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {
 986         test32Abstract_inline(ia, i, index);
 987     }
 988 
 989     @DontCompile
 990     public void test32Abstract_verifier(boolean warmup) {
 991         int index = Math.abs(rI) % 3;
 992         try {
 993             test32Abstract(testValue2Array, testValue1, index);
 994             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 995         } catch (ArrayStoreException e) {
 996             // Expected
 997         }
 998     }
 999 
1000     // Test writing null to a (flattened) value type array disguised as object array
1001     @ForceInline
1002     public void test33_inline(Object[] oa, Object o, int index) {
1003         oa[index] = o;
1004     }
1005 
1006     @Test()
1007     public void test33(Object[] oa, Object o, int index) {
1008         test33_inline(oa, o, index);
1009     }
1010 
1011     @DontCompile
1012     public void test33_verifier(boolean warmup) {
1013         int index = Math.abs(rI) % 3;
1014         try {
1015             test33(testValue1Array, null, index);
1016             throw new RuntimeException(&quot;No NPE thrown&quot;);
1017         } catch (NullPointerException e) {
1018             // Expected
1019         }
1020         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1021     }
1022 
1023     // Test writing constant null to a (flattened) value type array disguised as object array
1024 
1025     @ForceInline
1026     public void test34_inline(Object[] oa, Object o, int index) {
1027         oa[index] = o;
1028     }
1029 
1030     @Test()
1031     public void test34(Object[] oa, int index) {
1032         test34_inline(oa, null, index);
1033     }
1034 
1035     @DontCompile
1036     public void test34_verifier(boolean warmup) {
1037         int index = Math.abs(rI) % 3;
1038         try {
1039             test34(testValue1Array, index);
1040             throw new RuntimeException(&quot;No NPE thrown&quot;);
1041         } catch (NullPointerException e) {
1042             // Expected
1043         }
1044         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1045     }
1046 
1047     // Test writing constant null to a (flattened) value type array
1048 
1049     private static final MethodHandle setArrayElementNull = MethodHandleBuilder.loadCode(MethodHandles.lookup(),
1050         &quot;setArrayElementNull&quot;,
1051         MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class),
1052         CODE -&gt; {
1053             CODE.
1054             aload_1().
1055             iload_2().
1056             aconst_null().
1057             aastore().
1058             return_();
1059         });
1060 
1061     @Test()
1062     public void test35(MyValue1[] va, int index) throws Throwable {
1063         setArrayElementNull.invoke(this, va, index);
1064     }
1065 
1066     @DontCompile
1067     public void test35_verifier(boolean warmup) throws Throwable {
1068         int index = Math.abs(rI) % 3;
1069         try {
1070             test35(testValue1Array, index);
1071             throw new RuntimeException(&quot;No NPE thrown&quot;);
1072         } catch (NullPointerException e) {
1073             // Expected
1074         }
1075         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1076     }
1077 
1078     // Test writing a value type to a null value type array
1079     @Test()
1080     public void test36(MyValue1[] va, MyValue1 vt, int index) {
1081         va[index] = vt;
1082     }
1083 
1084     @DontCompile
1085     public void test36_verifier(boolean warmup) {
1086         int index = Math.abs(rI) % 3;
1087         try {
1088             test36(null, testValue1Array[index], index);
1089             throw new RuntimeException(&quot;No NPE thrown&quot;);
1090         } catch (NullPointerException e) {
1091             // Expected
1092         }
1093     }
1094 
1095     // Test incremental inlining
1096     @ForceInline
1097     public void test37_inline(Object[] oa, Object o, int index) {
1098         oa[index] = o;
1099     }
1100 
1101     @Test()
1102     public void test37(MyValue1[] va, Object o, int index) {
1103         test37_inline(va, o, index);
1104     }
1105 
1106     @DontCompile
1107     public void test37_verifier(boolean warmup) {
1108         int index = Math.abs(rI) % 3;
1109         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
1110         test37(testValue1Array, vt1, index);
1111         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
1112         try {
1113             test37(testValue1Array, testValue2, index);
1114             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1115         } catch (ArrayStoreException e) {
1116             // Expected
1117         }
1118         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
1119         testValue1Array[index] = testValue1;
1120     }
1121 
1122     // Test merging of value type arrays
1123 
1124     @ForceInline
1125     public Object[] test38_inline() {
1126         return new MyValue1[42];
1127     }
1128 
1129     @Test()
1130     public Object[] test38(Object[] oa, Object o, int i1, int i2, int num) {
1131         Object[] result = null;
1132         switch (num) {
1133         case 0:
1134             result = test38_inline();
1135             break;
1136         case 1:
1137             result = oa;
1138             break;
1139         case 2:
1140             result = testValue1Array;
1141             break;
1142         case 3:
1143             result = testValue2Array;
1144             break;
1145         case 4:
1146             result = testIntegerArray;
1147             break;
1148         case 5:
1149             result = null;
1150             break;
1151         case 6:
1152             result = testValue1Array2;
1153             break;
1154         }
1155         result[i1] = result[i2];
1156         result[i2] = o;
1157         return result;
1158     }
1159 
1160     @DontCompile
1161     public void test38_verifier(boolean warmup) {
1162         int index = Math.abs(rI) % 3;
1163         MyValue1[] va = new MyValue1[42];
1164         Object[] result = test38(null, testValue1, index, index, 0);
1165         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1166         result = test38(testValue1Array, testValue1, index, index, 1);
1167         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1168         result = test38(null, testValue1, index, index, 2);
1169         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1170         result = test38(null, testValue2, index, index, 3);
1171         Asserts.assertEQ(((MyValue2)result[index]).hash(), testValue2.hash());
1172         try {
1173             result = test38(null, null, index, index, 3);
1174             throw new RuntimeException(&quot;No NPE thrown&quot;);
1175         } catch (NullPointerException e) {
1176             // Expected
1177         }
1178         result = test38(null, null, index, index, 4);
1179         try {
1180             result = test38(null, testValue1, index, index, 4);
1181             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1182         } catch (ArrayStoreException e) {
1183             // Expected
1184         }
1185         try {
1186             result = test38(null, testValue1, index, index, 5);
1187             throw new RuntimeException(&quot;No NPE thrown&quot;);
1188         } catch (NullPointerException e) {
1189             // Expected
1190         }
1191         result = test38(null, testValue1Array, index, index, 6);
1192         Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());
1193     }
1194 
1195     @ForceInline
1196     public Object test39_inline() {
1197         return new MyValue1[42];
1198     }
1199 
1200     // Same as above but merging into Object instead of Object[]
1201     @Test()
1202     public Object test39(Object oa, Object o, int i1, int i2, int num) {
1203         Object result = null;
1204         switch (num) {
1205         case 0:
1206             result = test39_inline();
1207             break;
1208         case 1:
1209             result = oa;
1210             break;
1211         case 2:
1212             result = testValue1Array;
1213             break;
1214         case 3:
1215             result = testValue2Array;
1216             break;
1217         case 4:
1218             result = testIntegerArray;
1219             break;
1220         case 5:
1221             result = null;
1222             break;
1223         case 6:
1224             result = testValue1;
1225             break;
1226         case 7:
1227             result = testValue2;
1228             break;
1229         case 8:
1230             result = MyValue1.createWithFieldsInline(rI, rL);
1231             break;
1232         case 9:
1233             result = new Integer(42);
1234             break;
1235         case 10:
1236             result = testValue1Array2;
1237             break;
1238         }
1239         if (result instanceof Object[]) {
1240             ((Object[])result)[i1] = ((Object[])result)[i2];
1241             ((Object[])result)[i2] = o;
1242         }
1243         return result;
1244     }
1245 
1246     @DontCompile
1247     public void test39_verifier(boolean warmup) {
1248         if (!ENABLE_VALUE_ARRAY_COVARIANCE) {
1249             return;
1250         }
1251         int index = Math.abs(rI) % 3;
1252         MyValue1[] va = new MyValue1[42];
1253         Object result = test39(null, testValue1, index, index, 0);
1254         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1255         result = test39(testValue1Array, testValue1, index, index, 1);
1256         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1257         result = test39(null, testValue1, index, index, 2);
1258         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1259         result = test39(null, testValue2, index, index, 3);
1260         Asserts.assertEQ(((MyValue2[])result)[index].hash(), testValue2.hash());
1261         try {
1262             result = test39(null, null, index, index, 3);
1263             throw new RuntimeException(&quot;No NPE thrown&quot;);
1264         } catch (NullPointerException e) {
1265             // Expected
1266         }
1267         result = test39(null, null, index, index, 4);
1268         try {
1269             result = test39(null, testValue1, index, index, 4);
1270             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1271         } catch (ArrayStoreException e) {
1272             // Expected
1273         }
1274         result = test39(null, testValue1, index, index, 5);
1275         Asserts.assertEQ(result, null);
1276         result = test39(null, testValue1, index, index, 6);
1277         Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());
1278         result = test39(null, testValue1, index, index, 7);
1279         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
1280         result = test39(null, testValue1, index, index, 8);
1281         Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());
1282         result = test39(null, testValue1, index, index, 9);
1283         Asserts.assertEQ(((Integer)result), 42);
1284         result = test39(null, testValue1Array, index, index, 10);
1285         Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());
1286     }
1287 
1288     // Test instanceof with value types and arrays
1289     @Test()
1290     public long test40(Object o, int index) {
1291         if (o instanceof MyValue1) {
1292           return ((MyValue1)o).hashInterpreted();
1293         } else if (o instanceof MyValue1[]) {
1294           return ((MyValue1[])o)[index].hashInterpreted();
1295         } else if (o instanceof MyValue2) {
1296           return ((MyValue2)o).hash();
1297         } else if (o instanceof MyValue2[]) {
1298           return ((MyValue2[])o)[index].hash();
1299         } else if (o instanceof MyValue1[][]) {
1300           return ((MyValue1[][])o)[index][index].hash();
1301         } else if (o instanceof Long) {
1302           return (long)o;
1303         }
1304         return 0;
1305     }
1306 
1307     @DontCompile
1308     public void test40_verifier(boolean warmup) {
1309         int index = Math.abs(rI) % 3;
1310         long result = test40(testValue1, 0);
1311         Asserts.assertEQ(result, testValue1.hash());
1312         result = test40(testValue1Array, index);
1313         Asserts.assertEQ(result, testValue1.hash());
1314         result = test40(testValue2, index);
1315         Asserts.assertEQ(result, testValue2.hash());
1316         result = test40(testValue2Array, index);
1317         Asserts.assertEQ(result, testValue2.hash());
1318         result = test40(testValue1Array2, index);
1319         Asserts.assertEQ(result, testValue1.hash());
1320         result = test40(new Long(42), index);
1321         Asserts.assertEQ(result, 42L);
1322     }
1323 
1324     // Test for bug in Escape Analysis
1325     @DontInline
1326     public void test41_dontinline(Object o) {
1327         Asserts.assertEQ(o, rI);
1328     }
1329 
1330     @Test()
1331     public void test41() {
1332         MyValue1[] vals = new MyValue1[] {testValue1};
1333         test41_dontinline(vals[0].oa[0]);
1334         test41_dontinline(vals[0].oa[0]);
1335     }
1336 
1337     @DontCompile
1338     public void test41_verifier(boolean warmup) {
1339         test41();
1340     }
1341 
1342     // Test for bug in Escape Analysis
1343     private static final MyValue1.ref test42VT1 = MyValue1.createWithFieldsInline(rI, rL);
1344     private static final MyValue1.ref test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
1345 
1346     @Test()
1347     public void test42() {
1348         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1349         Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
1350         Asserts.assertEQ(vals[1].hash(), test42VT2.hash());
1351     }
1352 
1353     @DontCompile
1354     public void test42_verifier(boolean warmup) {
1355         if (!warmup) test42(); // We need -Xcomp behavior
1356     }
1357 
1358     // Test for bug in Escape Analysis
1359     @Test()
1360     public long test43(boolean deopt) {
1361         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1362 
1363         if (deopt) {
1364             // uncommon trap
1365             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test43&quot;));
1366             Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
1367             Asserts.assertEQ(vals[1].hash(), test42VT2.hash());
1368         }
1369 
1370         return vals[0].hash();
1371     }
1372 
1373     @DontCompile
1374     public void test43_verifier(boolean warmup) {
1375         test43(!warmup);
1376     }
1377 
1378     // Tests writing an array element with a (statically known) incompatible type
1379     private static final MethodHandle setArrayElementIncompatible = MethodHandleBuilder.loadCode(MethodHandles.lookup(),
1380         &quot;setArrayElementIncompatible&quot;,
1381         MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),
1382         CODE -&gt; {
1383             CODE.
1384             aload_1().
1385             iload_2().
1386             aload_3().
1387             aastore().
1388             return_();
1389         });
1390 
1391     @Test()
1392     public void test44(MyValue1[] va, int index, MyValue2 v) throws Throwable {
1393         setArrayElementIncompatible.invoke(this, va, index, v);
1394     }
1395 
1396     @DontCompile
1397     public void test44_verifier(boolean warmup) throws Throwable {
1398         int index = Math.abs(rI) % 3;
1399         try {
1400             test44(testValue1Array, index, testValue2);
1401             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1402         } catch (ArrayStoreException e) {
1403             // Expected
1404         }
1405         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1406     }
1407 
1408     // Tests writing an array element with a (statically known) incompatible type
1409     @ForceInline
1410     public void test45_inline(Object[] oa, Object o, int index) {
1411         oa[index] = o;
1412     }
1413 
1414     @Test()
1415     public void test45(MyValue1[] va, int index, MyValue2 v) throws Throwable {
1416         test45_inline(va, v, index);
1417     }
1418 
1419     @DontCompile
1420     public void test45_verifier(boolean warmup) throws Throwable {
1421         int index = Math.abs(rI) % 3;
1422         try {
1423             test45(testValue1Array, index, testValue2);
1424             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1425         } catch (ArrayStoreException e) {
1426             // Expected
1427         }
1428         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1429     }
1430 
1431     // instanceof tests with values
1432     @Test
1433     public boolean test46(MyValue1 vt) {
1434         Object obj = vt;
1435         return obj instanceof MyValue1;
1436     }
1437 
1438     @DontCompile
1439     public void test46_verifier(boolean warmup) {
1440         MyValue1 vt = testValue1;
1441         boolean result = test46(vt);
1442         Asserts.assertTrue(result);
1443     }
1444 
1445     @Test
1446     public boolean test47(MyValue1 vt) {
1447         Object obj = vt;
1448         return obj instanceof MyValue2;
1449     }
1450 
1451     @DontCompile
1452     public void test47_verifier(boolean warmup) {
1453         MyValue1 vt = testValue1;
1454         boolean result = test47(vt);
1455         Asserts.assertFalse(result);
1456     }
1457 
1458     @Test
1459     public boolean test48(Object obj) {
1460         return obj instanceof MyValue1;
1461     }
1462 
1463     @DontCompile
1464     public void test48_verifier(boolean warmup) {
1465         MyValue1 vt = testValue1;
1466         boolean result = test48(vt);
1467         Asserts.assertTrue(result);
1468     }
1469 
1470     @Test
1471     public boolean test49(Object obj) {
1472         return obj instanceof MyValue2;
1473     }
1474 
1475     @DontCompile
1476     public void test49_verifier(boolean warmup) {
1477         MyValue1 vt = testValue1;
1478         boolean result = test49(vt);
1479         Asserts.assertFalse(result);
1480     }
1481 
1482     @Test
1483     public boolean test50(Object obj) {
1484         return obj instanceof MyValue1;
1485     }
1486 
1487     @DontCompile
1488     public void test50_verifier(boolean warmup) {
1489         boolean result = test49(new Integer(42));
1490         Asserts.assertFalse(result);
1491     }
1492 
1493     // Value type with some non-flattened fields
1494     final inline class Test51Value {
1495         final Object objectField1;
1496         final Object objectField2;
1497         final Object objectField3;
1498         final Object objectField4;
1499         final Object objectField5;
1500         final Object objectField6;
1501 
1502         final MyValue1 valueField1;
1503         final MyValue1 valueField2;
1504         final MyValue1.ref valueField3;
1505         final MyValue1 valueField4;
1506         final MyValue1.ref valueField5;
1507 
1508         public Test51Value() {
1509             objectField1 = null;
1510             objectField2 = null;
1511             objectField3 = null;
1512             objectField4 = null;
1513             objectField5 = null;
1514             objectField6 = null;
1515             valueField1 = testValue1;
1516             valueField2 = testValue1;
1517             valueField3 = testValue1;
1518             valueField4 = MyValue1.createDefaultDontInline();
1519             valueField5 = MyValue1.createDefaultDontInline();
1520         }
1521 
1522         public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,
1523                            MyValue1 vt1, MyValue1 vt2, MyValue1.ref vt3, MyValue1 vt4, MyValue1.ref vt5) {
1524             objectField1 = o1;
1525             objectField2 = o2;
1526             objectField3 = o3;
1527             objectField4 = o4;
1528             objectField5 = o5;
1529             objectField6 = o6;
1530             valueField1 = vt1;
1531             valueField2 = vt2;
1532             valueField3 = vt3;
1533             valueField4 = vt4;
1534             valueField5 = vt5;
1535         }
1536 
1537         @ForceInline
1538         public long test(Test51Value holder, MyValue1 vt1, Object vt2) {
1539             holder = new Test51Value(vt1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1540                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1541             holder = new Test51Value(holder.objectField1, (MyValue1)vt2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1542                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1543             holder = new Test51Value(holder.objectField1, holder.objectField2, testValue1, holder.objectField4, holder.objectField5, holder.objectField6,
1544                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1545             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, MyValue1.createWithFieldsDontInline(rI, rL), holder.objectField5, holder.objectField6,
1546                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1547             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.valueField1, holder.objectField6,
1548                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1549             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.valueField3,
1550                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1551             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1552                                      (MyValue1)holder.objectField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1553             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1554                                      holder.valueField1, (MyValue1)vt2, holder.valueField3, holder.valueField4, holder.valueField5);
1555             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1556                                      holder.valueField1, holder.valueField2, (MyValue1)vt2, holder.valueField4, holder.valueField5);
1557 
1558             return ((MyValue1)holder.objectField1).hash() +
1559                    ((MyValue1)holder.objectField2).hash() +
1560                    ((MyValue1)holder.objectField3).hash() +
1561                    ((MyValue1)holder.objectField4).hash() +
1562                    ((MyValue1)holder.objectField5).hash() +
1563                    ((MyValue1)holder.objectField6).hash() +
1564                    holder.valueField1.hash() +
1565                    holder.valueField2.hash() +
1566                    holder.valueField3.hash() +
1567                    holder.valueField4.hashPrimitive();
1568         }
1569     }
1570 
1571     // Same as test2 but with field holder being a value type
1572     @Test()
1573     public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {
1574         return holder.test(holder, vt1, vt2);
1575     }
1576 
1577     @DontCompile
1578     public void test51_verifier(boolean warmup) {
1579         MyValue1 vt = testValue1;
1580         MyValue1 def = MyValue1.createDefaultDontInline();
1581         Test51Value holder = new Test51Value();
1582         Asserts.assertEQ(testValue1.hash(), vt.hash());
1583         Asserts.assertEQ(holder.valueField1.hash(), vt.hash());
1584         long result = test51(holder, vt, vt);
1585         Asserts.assertEQ(result, 9*vt.hash() + def.hashPrimitive());
1586     }
1587 
1588     // Access non-flattened, uninitialized value type field with value type holder
1589     @Test()
1590     public void test52(Test51Value holder) {
1591         if ((Object)holder.valueField5 != null) {
1592             throw new RuntimeException(&quot;Should be null&quot;);
1593         }
1594     }
1595 
1596     @DontCompile
1597     public void test52_verifier(boolean warmup) {
1598         Test51Value vt = Test51Value.default;
1599         test52(vt);
1600     }
1601 
1602     // Merging value types of different types
1603     @Test()
1604     public Object test53(Object o, boolean b) {
1605         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1606         return b ? vt : o;
1607     }
1608 
1609     @DontCompile
1610     public void test53_verifier(boolean warmup) {
1611         test53(new Object(), false);
1612         MyValue1 result = (MyValue1)test53(new Object(), true);
1613         Asserts.assertEQ(result.hash(), hash());
1614     }
1615 
1616     @Test()
1617     public Object test54(boolean b) {
1618         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1619         return b ? vt : testValue2;
1620     }
1621 
1622     @DontCompile
1623     public void test54_verifier(boolean warmup) {
1624         MyValue1 result1 = (MyValue1)test54(true);
1625         Asserts.assertEQ(result1.hash(), hash());
1626         MyValue2 result2 = (MyValue2)test54(false);
1627         Asserts.assertEQ(result2.hash(), testValue2.hash());
1628     }
1629 
1630     @Test()
1631     public Object test55(boolean b) {
1632         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI, rL);
1633         MyValue2 vt2 = MyValue2.createWithFieldsInline(rI, true);
1634         return b ? vt1 : vt2;
1635     }
1636 
1637     @DontCompile
1638     public void test55_verifier(boolean warmup) {
1639         MyValue1 result1 = (MyValue1)test55(true);
1640         Asserts.assertEQ(result1.hash(), hash());
1641         MyValue2 result2 = (MyValue2)test55(false);
1642         Asserts.assertEQ(result2.hash(), testValue2.hash());
1643     }
1644 
1645     // Test synchronization on value types
1646     @Test()
1647     public void test56(Object vt) {
1648         synchronized (vt) {
1649             throw new RuntimeException(&quot;test56 failed: synchronization on value type should not succeed&quot;);
1650         }
1651     }
1652 
1653     @DontCompile
1654     public void test56_verifier(boolean warmup) {
1655         try {
1656             test56(testValue1);
1657             throw new RuntimeException(&quot;test56 failed: no exception thrown&quot;);
1658         } catch (IllegalMonitorStateException ex) {
1659             // Expected
1660         }
1661     }
1662 
1663     @ForceInline
1664     public void test57_inline(Object vt) {
1665         synchronized (vt) {
1666             throw new RuntimeException(&quot;test57 failed: synchronization on value type should not succeed&quot;);
1667         }
1668     }
1669 
1670     @Test()
1671     public void test57(MyValue1 vt) {
1672         test57_inline(vt);
1673     }
1674 
1675     @DontCompile
1676     public void test57_verifier(boolean warmup) {
1677         try {
1678             test57(testValue1);
1679             throw new RuntimeException(&quot;test57 failed: no exception thrown&quot;);
1680         } catch (IllegalMonitorStateException ex) {
1681             // Expected
1682         }
1683     }
1684 
1685     @ForceInline
1686     public void test58_inline(Object vt) {
1687         synchronized (vt) {
1688             throw new RuntimeException(&quot;test58 failed: synchronization on value type should not succeed&quot;);
1689         }
1690     }
1691 
1692     @Test()
1693     public void test58() {
1694         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1695         test58_inline(vt);
1696     }
1697 
1698     @DontCompile
1699     public void test58_verifier(boolean warmup) {
1700         try {
1701             test58();
1702             throw new RuntimeException(&quot;test58 failed: no exception thrown&quot;);
1703         } catch (IllegalMonitorStateException ex) {
1704             // Expected
1705         }
1706     }
1707 
1708     @Test()
1709     public void test59(Object o, boolean b) {
1710         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1711         Object sync = b ? vt : o;
1712         synchronized (sync) {
1713             if (b) {
1714                 throw new RuntimeException(&quot;test59 failed: synchronization on value type should not succeed&quot;);
1715             }
1716         }
1717     }
1718 
1719     @DontCompile
1720     public void test59_verifier(boolean warmup) {
1721         test59(new Object(), false);
1722         try {
1723             test59(new Object(), true);
1724             throw new RuntimeException(&quot;test59 failed: no exception thrown&quot;);
1725         } catch (IllegalMonitorStateException ex) {
1726             // Expected
1727         }
1728     }
1729 
1730     @Test()
1731     public void test60(boolean b) {
1732         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1733         Object sync = b ? vt : testValue2;
1734         synchronized (sync) {
1735             throw new RuntimeException(&quot;test60 failed: synchronization on value type should not succeed&quot;);
1736         }
1737     }
1738 
1739     @DontCompile
1740     public void test60_verifier(boolean warmup) {
1741         try {
1742             test60(false);
1743             throw new RuntimeException(&quot;test60 failed: no exception thrown&quot;);
1744         } catch (IllegalMonitorStateException ex) {
1745             // Expected
1746         }
1747         try {
1748             test60(true);
1749             throw new RuntimeException(&quot;test60 failed: no exception thrown&quot;);
1750         } catch (IllegalMonitorStateException ex) {
1751             // Expected
1752         }
1753     }
1754 
1755     // Test catching the IllegalMonitorStateException in compiled code
1756     @Test()
1757     public void test61(Object vt) {
1758         boolean thrown = false;
1759         try {
1760             synchronized (vt) {
1761                 throw new RuntimeException(&quot;test61 failed: no exception thrown&quot;);
1762             }
1763         } catch (IllegalMonitorStateException ex) {
1764             thrown = true;
1765         }
1766         if (!thrown) {
1767             throw new RuntimeException(&quot;test61 failed: no exception thrown&quot;);
1768         }
1769     }
1770 
1771     @DontCompile
1772     public void test61_verifier(boolean warmup) {
1773         test61(testValue1);
1774     }
1775 
1776     @Test()
1777     public void test62(Object o) {
1778         try {
1779             synchronized (o) { }
1780         } catch (IllegalMonitorStateException ex) {
1781             // Expected
1782             return;
1783         }
1784         throw new RuntimeException(&quot;test62 failed: no exception thrown&quot;);
1785     }
1786 
1787     @DontCompile
1788     public void test62_verifier(boolean warmup) {
1789         test62(testValue1);
1790     }
1791 
1792     // Test synchronization without any instructions in the synchronized block
1793     @Test()
1794     public void test63(Object o) {
1795         synchronized (o) { }
1796     }
1797 
1798     @DontCompile
1799     public void test63_verifier(boolean warmup) {
1800         try {
1801             test63(testValue1);
1802         } catch (IllegalMonitorStateException ex) {
1803             // Expected
1804             return;
1805         }
1806         throw new RuntimeException(&quot;test63 failed: no exception thrown&quot;);
1807     }
1808 
1809     // type system test with interface and value type
1810     @ForceInline
1811     public MyInterface test64Interface_helper(MyValue1 vt) {
1812         return vt;
1813     }
1814 
1815     @Test()
1816     public MyInterface test64Interface(MyValue1 vt) {
1817         return test64Interface_helper(vt);
1818     }
1819 
1820     @DontCompile
1821     public void test64Interface_verifier(boolean warmup) {
1822         test64Interface(testValue1);
1823     }
1824 
1825     // type system test with abstract and value type
1826     @ForceInline
1827     public MyAbstract test64Abstract_helper(MyValue1 vt) {
1828         return vt;
1829     }
1830 
1831     @Test()
1832     public MyAbstract test64Abstract(MyValue1 vt) {
1833         return test64Abstract_helper(vt);
1834     }
1835 
1836     @DontCompile
1837     public void test64Abstract_verifier(boolean warmup) {
1838         test64Abstract(testValue1);
1839     }
1840 
1841     // Array store tests
1842     @Test()
1843     public void test65(Object[] array, MyValue1 vt) {
1844         array[0] = vt;
1845     }
1846 
1847     @DontCompile
1848     public void test65_verifier(boolean warmup) {
1849         Object[] array = new Object[1];
1850         test65(array, testValue1);
1851         Asserts.assertEQ(((MyValue1)array[0]).hash(), testValue1.hash());
1852     }
1853 
1854     @Test()
1855     public void test66(Object[] array, MyValue1 vt) {
1856         array[0] = vt;
1857     }
1858 
1859     @DontCompile
1860     public void test66_verifier(boolean warmup) {
1861         MyValue1[] array = new MyValue1[1];
1862         test66(array, testValue1);
1863         Asserts.assertEQ(array[0].hash(), testValue1.hash());
1864     }
1865 
1866     @Test()
1867     public void test67(Object[] array, Object vt) {
1868         array[0] = vt;
1869     }
1870 
1871     @DontCompile
1872     public void test67_verifier(boolean warmup) {
1873         MyValue1[] array = new MyValue1[1];
1874         test67(array, testValue1);
1875         Asserts.assertEQ(array[0].hash(), testValue1.hash());
1876     }
1877 
1878     @Test()
1879     public void test68(Object[] array, Integer o) {
1880         array[0] = o;
1881     }
1882 
1883     @DontCompile
1884     public void test68_verifier(boolean warmup) {
1885         Integer[] array = new Integer[1];
1886         test68(array, 1);
1887         Asserts.assertEQ(array[0], Integer.valueOf(1));
1888     }
1889 
1890     // Test convertion between a value type and java.lang.Object without an allocation
1891     @ForceInline
1892     public Object test69_sum(Object a, Object b) {
1893         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1894         return MyValue1.setX(((MyValue1)a), sum);
1895     }
1896 
1897     @Test(failOn = ALLOC + STORE)
1898     public int test69(MyValue1[] array) {
1899         MyValue1 result = MyValue1.createDefaultInline();
1900         for (int i = 0; i &lt; array.length; ++i) {
1901             result = (MyValue1)test69_sum(result, array[i]);
1902         }
1903         return result.x;
1904     }
1905 
1906     @DontCompile
1907     public void test69_verifier(boolean warmup) {
1908         int result = test69(testValue1Array);
1909         Asserts.assertEQ(result, rI * testValue1Array.length);
1910     }
1911 
1912     // Same as test69 but with an Interface
1913     @ForceInline
1914     public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {
1915         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1916         return MyValue1.setX(((MyValue1)a), sum);
1917     }
1918 
1919     @Test(failOn = ALLOC + STORE)
1920     public int test70Interface(MyValue1[] array) {
1921         MyValue1 result = MyValue1.createDefaultInline();
1922         for (int i = 0; i &lt; array.length; ++i) {
1923             result = (MyValue1)test70Interface_sum(result, array[i]);
1924         }
1925         return result.x;
1926     }
1927 
1928     @DontCompile
1929     public void test70Interface_verifier(boolean warmup) {
1930         int result = test70Interface(testValue1Array);
1931         Asserts.assertEQ(result, rI * testValue1Array.length);
1932     }
1933 
1934     // Same as test69 but with an Abstract
1935     @ForceInline
1936     public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {
1937         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1938         return MyValue1.setX(((MyValue1)a), sum);
1939     }
1940 
1941     @Test(failOn = ALLOC + STORE)
1942     public int test70Abstract(MyValue1[] array) {
1943         MyValue1 result = MyValue1.createDefaultInline();
1944         for (int i = 0; i &lt; array.length; ++i) {
1945             result = (MyValue1)test70Abstract_sum(result, array[i]);
1946         }
1947         return result.x;
1948     }
1949 
1950     @DontCompile
1951     public void test70Abstract_verifier(boolean warmup) {
1952         int result = test70Abstract(testValue1Array);
1953         Asserts.assertEQ(result, rI * testValue1Array.length);
1954     }
1955 
1956     // Test that allocated value type is not used in non-dominated path
1957     public MyValue1 test71_inline(Object obj) {
1958         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1959         try {
1960             vt = (MyValue1)obj;
1961             throw new RuntimeException(&quot;NullPointerException expected&quot;);
1962         } catch (NullPointerException e) {
1963             // Expected
1964         }
1965         return vt;
1966     }
1967 
1968     @Test
1969     public MyValue1 test71() {
1970         return test71_inline(null);
1971     }
1972 
1973     @DontCompile
1974     public void test71_verifier(boolean warmup) {
1975         MyValue1 vt = test71();
1976         Asserts.assertEquals(vt.hash(), hash());
1977     }
1978 
1979     // Test calling a method on an uninitialized value type
1980     final inline class Test72Value {
1981         final int x = 42;
1982         public int get() {
1983             return x;
1984         }
1985     }
1986 
1987     // Make sure Test72Value is loaded but not initialized
1988     public void unused(Test72Value vt) { }
1989 
1990     @Test
1991     @Warmup(0)
1992     public int test72() {
1993         Test72Value vt = Test72Value.default;
1994         return vt.get();
1995     }
1996 
1997     @DontCompile
1998     public void test72_verifier(boolean warmup) {
1999         int result = test72();
2000         Asserts.assertEquals(result, 0);
2001     }
2002 
2003     // Tests for loading/storing unkown values
2004     @Test
2005     public Object test73(Object[] va) {
2006         return va[0];
2007     }
2008 
2009     @DontCompile
2010     public void test73_verifier(boolean warmup) {
2011         MyValue1 vt = (MyValue1)test73(testValue1Array);
2012         Asserts.assertEquals(testValue1Array[0].hash(), vt.hash());
2013     }
2014 
2015     @Test
2016     public void test74(Object[] va, Object vt) {
2017         va[0] = vt;
2018     }
2019 
2020     @DontCompile
2021     public void test74_verifier(boolean warmup) {
2022         MyValue1[] va = new MyValue1[1];
2023         test74(va, testValue1);
2024         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2025     }
2026 
2027     // Verify that mixing instances and arrays with the clone api
2028     // doesn&#39;t break anything
2029     @Test
2030     public Object test75(Object o) {
2031         MyValue1[] va = new MyValue1[1];
2032         Object[] next = va;
2033         Object[] arr = va;
2034         for (int i = 0; i &lt; 10; i++) {
2035             arr = next;
2036             next = new Integer[1];
2037         }
2038         return arr[0];
2039     }
2040 
2041     @DontCompile
2042     public void test75_verifier(boolean warmup) {
2043         test75(42);
2044     }
2045 
2046     // Casting a null Integer to a (non-nullable) value type should throw a NullPointerException
2047     @ForceInline
2048     public MyValue1 test76_helper(Object o) {
2049         return (MyValue1)o;
2050     }
2051 
2052     @Test
2053     public MyValue1 test76(Integer i) throws Throwable {
2054         return test76_helper(i);
2055     }
2056 
2057     @DontCompile
2058     public void test76_verifier(boolean warmup) throws Throwable {
2059         try {
2060             test76(null);
2061             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2062         } catch (NullPointerException e) {
2063             // Expected
2064         } catch (Exception e) {
2065             throw new RuntimeException(&quot;test76 failed: unexpected exception&quot;, e);
2066         }
2067     }
2068 
2069     // Casting an Integer to a (non-nullable) value type should throw a ClassCastException
2070     @ForceInline
2071     public MyValue1 test77_helper(Object o) {
2072         return (MyValue1)o;
2073     }
2074 
2075     @Test
2076     public MyValue1 test77(Integer i) throws Throwable {
2077         return test77_helper(i);
2078     }
2079 
2080     @DontCompile
2081     public void test77_verifier(boolean warmup) throws Throwable {
2082         try {
2083             test77(new Integer(42));
2084             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2085         } catch (ClassCastException e) {
2086             // Expected
2087         } catch (Exception e) {
2088             throw new RuntimeException(&quot;test77 failed: unexpected exception&quot;, e);
2089         }
2090     }
2091 
2092     // Casting a null Integer to a nullable value type should not throw
2093     @ForceInline
2094     public MyValue1.ref test78_helper(Object o) {
2095         return (MyValue1.ref)o;
2096     }
2097 
2098     @Test
2099     public MyValue1.ref test78(Integer i) throws Throwable {
2100         return test78_helper(i);
2101     }
2102 
2103     @DontCompile
2104     public void test78_verifier(boolean warmup) throws Throwable {
2105         try {
2106             test78(null); // Should not throw
2107         } catch (Exception e) {
2108             throw new RuntimeException(&quot;test78 failed: unexpected exception&quot;, e);
2109         }
2110     }
2111 
2112     // Casting an Integer to a nullable value type should throw a ClassCastException
2113     @ForceInline
2114     public MyValue1.ref test79_helper(Object o) {
2115         return (MyValue1.ref)o;
2116     }
2117 
2118     @Test
2119     public MyValue1.ref test79(Integer i) throws Throwable {
2120         return test79_helper(i);
2121     }
2122 
2123     @DontCompile
2124     public void test79_verifier(boolean warmup) throws Throwable {
2125         try {
2126             test79(new Integer(42));
2127             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2128         } catch (ClassCastException e) {
2129             // Expected
2130         } catch (Exception e) {
2131             throw new RuntimeException(&quot;test79 failed: unexpected exception&quot;, e);
2132         }
2133     }
2134 
2135     // Test flattened field with non-flattenend (but flattenable) value type field
2136     static inline class Small {
2137         final int i;
2138         final Big big; // Too big to be flattened
2139 
2140         private Small() {
2141             i = rI;
2142             big = new Big();
2143         }
2144     }
2145 
2146     static inline class Big {
2147         long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9;
2148         long l10,l11,l12,l13,l14,l15,l16,l17,l18,l19;
2149         long l20,l21,l22,l23,l24,l25,l26,l27,l28,l29;
2150 
2151         private Big() {
2152             l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = rL;
2153             l10 = l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = rL+1;
2154             l20 = l21 = l22 = l23 = l24 = l25 = l26 = l27 = l28 = l29 = rL+2;
2155         }
2156     }
2157 
2158     Small small = new Small();
2159     Small smallDefault;
2160     Big big = new Big();
2161     Big bigDefault;
2162 
2163     @Test
2164     public long test80() {
2165         return small.i + small.big.l0 + smallDefault.i + smallDefault.big.l29 + big.l0 + bigDefault.l29;
2166     }
2167 
2168     @DontCompile
2169     public void test80_verifier(boolean warmup) throws Throwable {
2170         long result = test80();
2171         Asserts.assertEQ(result, rI + 2*rL);
2172     }
2173 
2174     // Test scalarization with exceptional control flow
2175     public int test81Callee(MyValue1 vt)  {
2176         return vt.x;
2177     }
2178 
2179     @Test(failOn = ALLOC + LOAD + STORE)
2180     public int test81()  {
2181         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2182         int result = 0;
2183         for (int i = 0; i &lt; 10; i++) {
2184             try {
2185                 result += test81Callee(vt);
2186             } catch (NullPointerException npe) {
2187                 result += rI;
2188             }
2189         }
2190         return result;
2191     }
2192 
2193     @DontCompile
2194     public void test81_verifier(boolean warmup) {
2195         int result = test81();
2196         Asserts.assertEQ(result, 10*rI);
2197     }
2198 
2199     // Test check for null free array when storing to value array
2200     @Test
2201     public void test82(Object[] dst, Object v) {
2202         dst[0] = v;
2203     }
2204 
2205     @DontCompile
2206     public void test82_verifier(boolean warmup) {
2207         MyValue2[] dst = new MyValue2[1];
2208         test82(dst, testValue2);
2209         if (!warmup) {
2210             try {
2211                 test82(dst, null);
2212                 throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
2213             } catch (NullPointerException e) {
2214                 // Expected
2215             }
2216         }
2217     }
2218 
2219     @Test
2220     @Warmup(10000)
2221     public void test83(Object[] dst, Object v, boolean flag) {
2222         if (dst == null) { // null check
2223         }
2224         if (flag) {
2225             if (dst.getClass() == MyValue1[].class) { // trigger split if
2226             }
2227         } else {
2228             dst = new MyValue2[1]; // constant null free property
2229         }
2230         dst[0] = v;
2231     }
2232 
2233     @DontCompile
2234     public void test83_verifier(boolean warmup) {
2235         MyValue2[] dst = new MyValue2[1];
2236         test83(dst, testValue2, false);
2237         test83(dst, testValue2, true);
2238         if (!warmup) {
2239             try {
2240                 test83(dst, null, true);
2241                 throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
2242             } catch (NullPointerException e) {
2243                 // Expected
2244             }
2245         }
2246     }
2247 
2248     private void rerun_and_recompile_for(String name, int num, Runnable test) {
2249         Method m = tests.get(name);
2250 
2251         for (int i = 1; i &lt; num; i++) {
2252             test.run();
2253 
2254             if (!WHITE_BOX.isMethodCompiled(m, false)) {
2255                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
2256             }
2257         }
2258     }
2259 
2260     // Tests for the Loop Unswitching optimization
2261     // Should make 2 copies of the loop, one for non flattened arrays, one for other cases.
2262     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2263     @Warmup(0)
2264     public void test84(Object[] src, Object[] dst) {
2265         for (int i = 0; i &lt; src.length; i++) {
2266             dst[i] = src[i];
2267         }
2268     }
2269 
2270     @DontCompile
2271     public void test84_verifier(boolean warmup) {
2272         MyValue2[] src = new MyValue2[100];
2273         Arrays.fill(src, testValue2);
2274         MyValue2[] dst = new MyValue2[100];
2275         Method m = tests.get(&quot;TestLWorld::test84&quot;);
2276 
2277         rerun_and_recompile_for(&quot;TestLWorld::test84&quot;, 10,
2278                                 () -&gt;  { test84(src, dst);
2279                                          Asserts.assertTrue(Arrays.equals(src, dst)); });
2280     }
2281 
2282     @Test(valid = G1GCOn, match = { COUNTEDLOOP, LOAD_UNKNOWN_VALUE }, matchCount = { 2, 1 } )
2283     @Test(valid = G1GCOff, match = { COUNTEDLOOP_MAIN, LOAD_UNKNOWN_VALUE }, matchCount = { 2, 4 } )
2284     @Warmup(0)
2285     public void test85(Object[] src, Object[] dst) {
2286         for (int i = 0; i &lt; src.length; i++) {
2287             dst[i] = src[i];
2288         }
2289     }
2290 
2291     @DontCompile
2292     public void test85_verifier(boolean warmup) {
2293         Object[] src = new Object[100];
2294         Arrays.fill(src, new Object());
2295         src[0] = null;
2296         Object[] dst = new Object[100];
2297         rerun_and_recompile_for(&quot;TestLWorld::test85&quot;, 10,
2298                                 () -&gt; { test85(src, dst);
2299                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2300     }
2301 
2302     @Test(valid = G1GCOn, match = { COUNTEDLOOP }, matchCount = { 2 } )
2303     @Test(valid = G1GCOff, match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2304     @Warmup(0)
2305     public void test86(Object[] src, Object[] dst) {
2306         for (int i = 0; i &lt; src.length; i++) {
2307             dst[i] = src[i];
2308         }
2309     }
2310 
2311     @DontCompile
2312     public void test86_verifier(boolean warmup) {
2313         MyValue2[] src = new MyValue2[100];
2314         Arrays.fill(src, testValue2);
2315         Object[] dst = new Object[100];
2316         rerun_and_recompile_for(&quot;TestLWorld::test86&quot;, 10,
2317                                 () -&gt; { test86(src, dst);
2318                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2319     }
2320 
2321     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2322     @Warmup(0)
2323     public void test87(Object[] src, Object[] dst) {
2324         for (int i = 0; i &lt; src.length; i++) {
2325             dst[i] = src[i];
2326         }
2327     }
2328 
2329     @DontCompile
2330     public void test87_verifier(boolean warmup) {
2331         Object[] src = new Object[100];
2332         Arrays.fill(src, testValue2);
2333         MyValue2[] dst = new MyValue2[100];
2334 
2335         rerun_and_recompile_for(&quot;TestLWorld::test87&quot;, 10,
2336                                 () -&gt; { test87(src, dst);
2337                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2338     }
2339 
2340     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2341     @Warmup(0)
2342     public void test88(Object[] src1, Object[] dst1, Object[] src2, Object[] dst2) {
2343         for (int i = 0; i &lt; src1.length; i++) {
2344             dst1[i] = src1[i];
2345             dst2[i] = src2[i];
2346         }
2347     }
2348 
2349     @DontCompile
2350     public void test88_verifier(boolean warmup) {
2351         MyValue2[] src1 = new MyValue2[100];
2352         Arrays.fill(src1, testValue2);
2353         MyValue2[] dst1 = new MyValue2[100];
2354         Object[] src2 = new Object[100];
2355         Arrays.fill(src2, new Object());
2356         Object[] dst2 = new Object[100];
2357 
2358         rerun_and_recompile_for(&quot;TestLWorld::test88&quot;, 10,
2359                                 () -&gt; { test88(src1, dst1, src2, dst2);
2360                                         Asserts.assertTrue(Arrays.equals(src1, dst1));
2361                                         Asserts.assertTrue(Arrays.equals(src2, dst2)); });
2362     }
2363 
2364     @Test
2365     public boolean test89(Object obj) {
2366         return obj.getClass() == Integer.class;
2367     }
2368 
2369     @DontCompile
2370     public void test89_verifier(boolean warmup) {
2371         Asserts.assertTrue(test89(new Integer(42)));
2372         Asserts.assertFalse(test89(new Object()));
2373     }
2374 
2375     @Test
2376     public Integer test90(Object obj) {
2377         return (Integer)obj;
2378     }
2379 
2380     @DontCompile
2381     public void test90_verifier(boolean warmup) {
2382         test90(new Integer(42));
2383         try {
2384             test90(new Object());
2385             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2386         } catch (ClassCastException e) {
2387             // Expected
2388         }
2389     }
2390 
2391     @Test
2392     public boolean test91(Object obj) {
2393         return obj.getClass() == MyValue2[].class;
2394     }
2395 
2396     @DontCompile
2397     public void test91_verifier(boolean warmup) {
2398         Asserts.assertTrue(test91(new MyValue2[1]));
2399         Asserts.assertFalse(test91(new Object()));
2400     }
2401 
2402     static inline class Test92Value {
2403         final int field;
2404         public Test92Value() {
2405             field = 0x42;
2406         }
2407     }
2408 
2409     @Warmup(10000)
2410     @Test(match = { CLASS_CHECK_TRAP }, matchCount = { 2 }, failOn = LOAD_UNKNOWN_VALUE + ALLOC_G + MEMBAR)
2411     public Object test92(Object[] array) {
2412         // Dummy loops to ensure we run enough passes of split if
2413         for (int i = 0; i &lt; 2; i++) {
2414             for (int j = 0; j &lt; 2; j++) {
2415               for (int k = 0; k &lt; 2; k++) {
2416               }
2417             }
2418         }
2419 
2420         return (Integer)array[0];
2421     }
2422 
2423     @DontCompile
2424     public void test92_verifier(boolean warmup) {
2425         Object[] array = new Object[1];
2426         array[0] = 0x42;
2427         Object result = test92(array);
2428         Asserts.assertEquals(result, 0x42);
2429     }
2430 
2431     // If the class check succeeds, the flattened array check that
2432     // precedes will never succeed and the flat array branch should
2433     // trigger an uncommon trap.
2434     @Test
2435     @Warmup(10000)
2436     public Object test93(Object[] array) {
2437         for (int i = 0; i &lt; 2; i++) {
2438             for (int j = 0; j &lt; 2; j++) {
2439             }
2440         }
2441 
2442         Object v = (Integer)array[0];
2443         return v;
2444     }
2445 
2446     @DontCompile
2447     public void test93_verifier(boolean warmup) {
2448         if (warmup) {
2449             Object[] array = new Object[1];
2450             array[0] = 0x42;
2451             Object result = test93(array);
2452             Asserts.assertEquals(result, 0x42);
2453         } else {
2454             Object[] array = new Test92Value[1];
2455             Method m = tests.get(&quot;TestLWorld::test93&quot;);
2456             int extra = 3;
2457             for (int j = 0; j &lt; extra; j++) {
2458                 for (int i = 0; i &lt; 10; i++) {
2459                     try {
2460                         test93(array);
2461                     } catch (ClassCastException cce) {
2462                     }
2463                 }
2464                 boolean compiled = isCompiledByC2(m);
2465                 Asserts.assertTrue(!USE_COMPILER || XCOMP || STRESS_CC || TEST_C1 || compiled || (j != extra-1));
2466                 if (!compiled) {
2467                     enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
2468                 }
2469             }
2470         }
2471     }
2472 
2473     @Warmup(10000)
2474     @Test(match = { CLASS_CHECK_TRAP, LOOP }, matchCount = { 2, 1 }, failOn = LOAD_UNKNOWN_VALUE + ALLOC_G + MEMBAR)
2475     public int test94(Object[] array) {
2476         int res = 0;
2477         for (int i = 1; i &lt; 4; i *= 2) {
2478             Object v = array[i];
2479             res += (Integer)v;
2480         }
2481         return res;
2482     }
2483 
2484     @DontCompile
2485     public void test94_verifier(boolean warmup) {
2486         Object[] array = new Object[4];
2487         array[0] = 0x42;
2488         array[1] = 0x42;
2489         array[2] = 0x42;
2490         array[3] = 0x42;
2491         int result = test94(array);
2492         Asserts.assertEquals(result, 0x42 * 2);
2493     }
2494 
2495     @Warmup(10000)
2496     @Test
2497     public boolean test95(Object o1, Object o2) {
2498         return o1 == o2;
2499     }
2500 
2501     @DontCompile
2502     public void test95_verifier(boolean warmup) {
2503         Object o1 = new Object();
2504         Object o2 = new Object();
2505         Asserts.assertTrue(test95(o1, o1));
2506         Asserts.assertTrue(test95(null, null));
2507         Asserts.assertFalse(test95(o1, null));
2508         Asserts.assertFalse(test95(o1, o2));
2509     }
2510 
2511     @Warmup(10000)
2512     @Test
2513     public boolean test96(Object o1, Object o2) {
2514         return o1 == o2;
2515     }
2516 
2517     @DontCompile
2518     public void test96_verifier(boolean warmup) {
2519         Object o1 = new Object();
2520         Object o2 = new Object();
2521         Asserts.assertTrue(test96(o1, o1));
2522         Asserts.assertFalse(test96(o1, o2));
2523         if (!warmup) {
2524             Asserts.assertTrue(test96(null, null));
2525             Asserts.assertFalse(test96(o1, null));
2526         }
2527     }
2528 
2529     // Abstract class tests
2530 
2531     @DontInline
2532     public MyAbstract test97_dontinline1(MyAbstract o) {
2533         return o;
2534     }
2535 
2536     @DontInline
2537     public MyValue1 test97_dontinline2(MyAbstract o) {
2538         return (MyValue1)o;
2539     }
2540 
2541     @ForceInline
2542     public MyAbstract test97_inline1(MyAbstract o) {
2543         return o;
2544     }
2545 
2546     @ForceInline
2547     public MyValue1 test97_inline2(MyAbstract o) {
2548         return (MyValue1)o;
2549     }
2550 
2551     @Test()
2552     public MyValue1 test97() {
2553         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2554         vt = (MyValue1)test97_dontinline1(vt);
2555         vt =           test97_dontinline2(vt);
2556         vt = (MyValue1)test97_inline1(vt);
2557         vt =           test97_inline2(vt);
2558         return vt;
2559     }
2560 
2561     @DontCompile
2562     public void test97_verifier(boolean warmup) {
2563         Asserts.assertEQ(test97().hash(), hash());
2564     }
2565 
2566     // Test storing/loading value types to/from abstract and value type fields
2567     MyAbstract abstractField1 = null;
2568     MyAbstract abstractField2 = null;
2569     MyAbstract abstractField3 = null;
2570     MyAbstract abstractField4 = null;
2571     MyAbstract abstractField5 = null;
2572     MyAbstract abstractField6 = null;
2573 
2574     @DontInline
2575     public MyAbstract readValueField5AsAbstract() {
2576         return (MyAbstract)valueField5;
2577     }
2578 
2579     @DontInline
2580     public MyAbstract readStaticValueField4AsAbstract() {
2581         return (MyAbstract)staticValueField4;
2582     }
2583 
2584     @Test()
2585     public long test98(MyValue1 vt1, MyAbstract vt2) {
2586         abstractField1 = vt1;
2587         abstractField2 = (MyValue1)vt2;
2588         abstractField3 = MyValue1.createWithFieldsInline(rI, rL);
2589         abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);
2590         abstractField5 = valueField1;
2591         abstractField6 = valueField3;
2592         valueField1 = (MyValue1)abstractField1;
2593         valueField2 = (MyValue1)vt2;
2594         valueField3 = (MyValue1)vt2;
2595         staticValueField1 = (MyValue1)abstractField1;
2596         staticValueField2 = (MyValue1)vt1;
2597         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
2598         if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {
2599             throw new RuntimeException(&quot;Should be null&quot;);
2600         }
2601         return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +
2602                ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +
2603                ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +
2604                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
2605                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
2606     }
2607 
2608     @DontCompile
2609     public void test98_verifier(boolean warmup) {
2610         MyValue1 vt = testValue1;
2611         MyValue1 def = MyValue1.createDefaultDontInline();
2612         long result = test98(vt, vt);
2613         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
2614     }
2615 
2616     class MyObject2 extends MyAbstract {
2617         public int x;
2618 
2619         public MyObject2(int x) {
2620             this.x = x;
2621         }
2622 
2623         @ForceInline
2624         public long hash() {
2625             return x;
2626         }
2627     }
2628 
2629     // Test merging value types and abstract classes
2630     @Test()
2631     public MyAbstract test99(int state) {
2632         MyAbstract res = null;
2633         if (state == 0) {
2634             res = new MyObject2(rI);
2635         } else if (state == 1) {
2636             res = MyValue1.createWithFieldsInline(rI, rL);
2637         } else if (state == 2) {
2638             res = MyValue1.createWithFieldsDontInline(rI, rL);
2639         } else if (state == 3) {
2640             res = (MyValue1)objectField1;
2641         } else if (state == 4) {
2642             res = valueField1;
2643         } else if (state == 5) {
2644             res = null;
2645         }
2646         return res;
2647     }
2648 
2649     @DontCompile
2650     public void test99_verifier(boolean warmup) {
2651         objectField1 = valueField1;
2652         MyAbstract result = null;
2653         result = test99(0);
2654         Asserts.assertEQ(((MyObject2)result).x, rI);
2655         result = test99(1);
2656         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2657         result = test99(2);
2658         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2659         result = test99(3);
2660         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2661         result = test99(4);
2662         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2663         result = test99(5);
2664         Asserts.assertEQ(result, null);
2665     }
2666 
2667     // Test merging value types and abstract classes in loops
2668     @Test()
2669     public MyAbstract test100(int iters) {
2670         MyAbstract res = new MyObject2(rI);
2671         for (int i = 0; i &lt; iters; ++i) {
2672             if (res instanceof MyObject2) {
2673                 res = MyValue1.createWithFieldsInline(rI, rL);
2674             } else {
2675                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
2676             }
2677         }
2678         return res;
2679     }
2680 
2681     @DontCompile
2682     public void test100_verifier(boolean warmup) {
2683         MyObject2 result1 = (MyObject2)test100(0);
2684         Asserts.assertEQ(result1.x, rI);
2685         int iters = (Math.abs(rI) % 10) + 1;
2686         MyValue1 result2 = (MyValue1)test100(iters);
2687         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
2688         Asserts.assertEQ(result2.hash(), vt.hash());
2689     }
2690 
2691     // Test value types in abstract class variables that are live at safepoint
2692     @Test(failOn = ALLOC + STORE + LOOP)
2693     public long test101(MyValue1 arg, boolean deopt) {
2694         MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);
2695         MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
2696         MyAbstract vt3 = arg;
2697         MyAbstract vt4 = valueField1;
2698         if (deopt) {
2699             // uncommon trap
2700             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test101&quot;));
2701         }
2702         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
2703                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
2704     }
2705 
2706     @DontCompile
2707     public void test101_verifier(boolean warmup) {
2708         long result = test101(valueField1, !warmup);
2709         Asserts.assertEQ(result, 4*hash());
2710     }
2711 
2712     // Test comparing value types with abstract classes
2713     @Test(failOn = LOAD + LOOP)
2714     public boolean test102(Object arg) {
2715         MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);
2716         if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||
2717             arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {
2718             return true;
2719         }
2720         return false;
2721     }
2722 
2723     @DontCompile
2724     public void test102_verifier(boolean warmup) {
2725         boolean result = test102(null);
2726         Asserts.assertFalse(result);
2727     }
2728 
2729     // An abstract class with a non-static field can never be implemented by a value type
2730     abstract class NoValueImplementors1 {
2731         int field = 42;
2732     }
2733 
2734     class MyObject3 extends NoValueImplementors1 {
2735 
2736     }
2737 
2738     class MyObject4 extends NoValueImplementors1 {
2739 
2740     }
2741 
2742     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field
2743     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
2744     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {
2745         return array[i];
2746     }
2747 
2748     @DontCompile
2749     public void test103_verifier(boolean warmup) {
2750         NoValueImplementors1[] array1 = new NoValueImplementors1[3];
2751         MyObject3[] array2 = new MyObject3[3];
2752         MyObject4[] array3 = new MyObject4[3];
2753         NoValueImplementors1 result = test103(array1, 0);
2754         Asserts.assertEquals(result, array1[0]);
2755 
2756         result = test103(array2, 1);
2757         Asserts.assertEquals(result, array1[1]);
2758 
2759         result = test103(array3, 2);
2760         Asserts.assertEquals(result, array1[2]);
2761     }
2762 
2763     // Storing to an abstract class array does not require a flatness/null check if the abstract class has a non-static field
2764     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
2765     public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {
2766         array[0] = v;
2767         array[1] = array[0];
2768         array[2] = o;
2769         return array[i];
2770     }
2771 
2772     @DontCompile
2773     public void test104_verifier(boolean warmup) {
2774         MyObject4 v = new MyObject4();
2775         MyObject3 o = new MyObject3();
2776         NoValueImplementors1[] array1 = new NoValueImplementors1[3];
2777         MyObject3[] array2 = new MyObject3[3];
2778         MyObject4[] array3 = new MyObject4[3];
2779         NoValueImplementors1 result = test104(array1, v, o, 0);
2780         Asserts.assertEquals(array1[0], v);
2781         Asserts.assertEquals(array1[1], v);
2782         Asserts.assertEquals(array1[2], o);
2783         Asserts.assertEquals(result, v);
2784 
2785         result = test104(array2, o, o, 1);
2786         Asserts.assertEquals(array2[0], o);
2787         Asserts.assertEquals(array2[1], o);
2788         Asserts.assertEquals(array2[2], o);
2789         Asserts.assertEquals(result, o);
2790 
2791         result = test104(array3, v, null, 1);
2792         Asserts.assertEquals(array3[0], v);
2793         Asserts.assertEquals(array3[1], v);
2794         Asserts.assertEquals(array3[2], null);
2795         Asserts.assertEquals(result, v);
2796     }
2797 
2798     // An abstract class with a single, non-value implementor
2799     abstract class NoValueImplementors2 {
2800 
2801     }
2802 
2803     class MyObject5 extends NoValueImplementors2 {
2804 
2805     }
2806 
2807     // Loading from an abstract class array does not require a flatness check if the abstract class has no value implementor
2808     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
2809     public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {
2810         return array[i];
2811     }
2812 
2813     @DontCompile
2814     public void test105_verifier(boolean warmup) {
2815         NoValueImplementors2[] array1 = new NoValueImplementors2[3];
2816         MyObject5[] array2 = new MyObject5[3];
2817         NoValueImplementors2 result = test105(array1, 0);
2818         Asserts.assertEquals(result, array1[0]);
2819 
2820         result = test105(array2, 1);
2821         Asserts.assertEquals(result, array1[1]);
2822     }
2823 
2824     // Storing to an abstract class array does not require a flatness/null check if the abstract class has no value implementor
2825     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
2826     public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {
2827         array[0] = v;
2828         array[1] = array[0];
2829         array[2] = o;
2830         return array[i];
2831     }
2832 
2833     @DontCompile
2834     public void test106_verifier(boolean warmup) {
2835         MyObject5 v = new MyObject5();
2836         NoValueImplementors2[] array1 = new NoValueImplementors2[3];
2837         MyObject5[] array2 = new MyObject5[3];
2838         NoValueImplementors2 result = test106(array1, v, null, 0);
2839         Asserts.assertEquals(array1[0], v);
2840         Asserts.assertEquals(array1[1], v);
2841         Asserts.assertEquals(array1[2], null);
2842         Asserts.assertEquals(result, v);
2843 
2844         result = test106(array2, v, v, 1);
2845         Asserts.assertEquals(array2[0], v);
2846         Asserts.assertEquals(array2[1], v);
2847         Asserts.assertEquals(array2[2], v);
2848         Asserts.assertEquals(result, v);
2849     }
2850 
2851     // More tests for the Loop Unswitching optimization (similar to test84 and following)
2852     Object oFld1, oFld2;
2853 
2854     @Test(valid = G1GCOn, failOn = STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, LOAD_UNKNOWN_VALUE }, matchCount = { 2, 2 } )
2855     @Test(valid = G1GCOff, failOn = STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, LOAD_UNKNOWN_VALUE }, matchCount = { 3, 2 } )
2856     @Warmup(0)
2857     public void test107(Object[] src1, Object[] src2) {
2858         for (int i = 0; i &lt; src1.length; i++) {
2859             oFld1 = src1[i];
2860             oFld2 = src2[i];
2861         }
2862     }
2863 
2864     @DontCompile
2865     public void test107_verifier(boolean warmup) {
2866         MyValue2[] src1 = new MyValue2[100];
2867         Arrays.fill(src1, testValue2);
2868         Object[] src2 = new Object[100];
2869         Object obj = new Object();
2870         Arrays.fill(src2, obj);
2871         rerun_and_recompile_for(&quot;TestLWorld::test107&quot;, 10,
2872                                 () -&gt; { test107(src1, src2);
2873                                         Asserts.assertEquals(oFld1, testValue2);
2874                                         Asserts.assertEquals(oFld2, obj);
2875                                         test107(src2, src1);
2876                                         Asserts.assertEquals(oFld1, obj);
2877                                         Asserts.assertEquals(oFld2, testValue2);  });
2878     }
2879 
2880     @Test(valid = G1GCOn, failOn = LOAD_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, STORE_UNKNOWN_VALUE }, matchCount = { 4, 9 } )
2881     @Test(valid = G1GCOff, failOn = LOAD_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, STORE_UNKNOWN_VALUE }, matchCount = { 4, 12 } )
2882     @Warmup(0)
2883     public void test108(Object[] dst1, Object[] dst2, Object o1, Object o2) {
2884         for (int i = 0; i &lt; dst1.length; i++) {
2885             dst1[i] = o1;
2886             dst2[i] = o2;
2887         }
2888     }
2889 
2890     @DontCompile
2891     public void test108_verifier(boolean warmup) {
2892         MyValue2[] dst1 = new MyValue2[100];
2893         Object[] dst2 = new Object[100];
2894         Object o1 = new Object();
2895         rerun_and_recompile_for(&quot;TestLWorld::test108&quot;, 10,
2896                                 () -&gt; { test108(dst1, dst2, testValue2, o1);
2897                                         for (int i = 0; i &lt; dst1.length; i++) {
2898                                             Asserts.assertEquals(dst1[i], testValue2);
2899                                             Asserts.assertEquals(dst2[i], o1);
2900                                         }
2901                                         test108(dst2, dst1, o1, testValue2);
2902                                         for (int i = 0; i &lt; dst1.length; i++) {
2903                                             Asserts.assertEquals(dst1[i], testValue2);
2904                                             Asserts.assertEquals(dst2[i], o1);
2905                                         } });
2906     }
2907 
2908     // Escape analysis tests
2909 
2910     static interface WrapperInterface {
2911         long value();
2912 
2913         final static WrapperInterface ZERO = new LongWrapper(0);
2914 
2915         static WrapperInterface wrap(long val) {
2916             return (val == 0L) ? ZERO : new LongWrapper(val);
2917         }
2918     }
2919 
2920     static inline class LongWrapper implements WrapperInterface {
2921         final static LongWrapper ZERO = new LongWrapper(0);
2922         private long val;
2923 
2924         LongWrapper(long val) {
2925             this.val = val;
2926         }
2927 
2928         static LongWrapper wrap(long val) {
2929             return (val == 0L) ? ZERO : new LongWrapper(val);
2930         }
2931 
2932         public long value() {
2933             return val;
2934         }
2935     }
2936 
2937     static class InterfaceBox {
2938         WrapperInterface content;
2939 
2940         InterfaceBox(WrapperInterface content) {
2941             this.content = content;
2942         }
2943 
2944         static InterfaceBox box_sharp(long val) {
2945             return new InterfaceBox(LongWrapper.wrap(val));
2946         }
2947 
2948         static InterfaceBox box(long val) {
2949             return new InterfaceBox(WrapperInterface.wrap(val));
2950         }
2951     }
2952 
2953     static class ObjectBox {
2954         Object content;
2955 
2956         ObjectBox(Object content) {
2957             this.content = content;
2958         }
2959 
2960         static ObjectBox box_sharp(long val) {
2961             return new ObjectBox(LongWrapper.wrap(val));
2962         }
2963 
2964         static ObjectBox box(long val) {
2965             return new ObjectBox(WrapperInterface.wrap(val));
2966         }
2967     }
2968 
2969     static class RefBox {
2970         LongWrapper.ref content;
2971 
2972         RefBox(LongWrapper.ref content) {
2973             this.content = content;
2974         }
2975 
2976         static RefBox box_sharp(long val) {
2977             return new RefBox(LongWrapper.wrap(val));
2978         }
2979 
2980         static RefBox box(long val) {
2981             return new RefBox((LongWrapper.ref)WrapperInterface.wrap(val));
2982         }
2983     }
2984 
2985     static class InlineBox {
2986         LongWrapper content;
2987 
2988         InlineBox(long val) {
2989             this.content = LongWrapper.wrap(val);
2990         }
2991 
2992         static InlineBox box(long val) {
2993             return new InlineBox(val);
2994         }
2995     }
2996 
2997     static class GenericBox&lt;T&gt; {
2998         T content;
2999 
3000         static GenericBox&lt;LongWrapper.ref&gt; box_sharp(long val) {
3001             GenericBox&lt;LongWrapper.ref&gt; res = new GenericBox&lt;&gt;();
3002             res.content = LongWrapper.wrap(val);
3003             return res;
3004         }
3005 
3006         static GenericBox&lt;WrapperInterface&gt; box(long val) {
3007             GenericBox&lt;WrapperInterface&gt; res = new GenericBox&lt;&gt;();
3008             res.content = WrapperInterface.wrap(val);
3009             return res;
3010         }
3011     }
3012 
3013     long[] lArr = {0L, rL, 0L, rL, 0L, rL, 0L, rL, 0L, rL};
3014 
3015     // Test removal of allocations when inline type instance is wrapped into box object
3016     @Warmup(10000) // Make sure interface calls are inlined
3017     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3018     public long test109() {
3019         long res = 0;
3020         for (int i = 0 ; i &lt; lArr.length; i++) {
3021             res += InterfaceBox.box(lArr[i]).content.value();
3022         }
3023         return res;
3024     }
3025 
3026     @DontCompile
3027     public void test109_verifier(boolean warmup) {
3028         long res = test109();
3029         Asserts.assertEquals(res, 5*rL);
3030     }
3031 
3032     @Warmup(10000) // Make sure interface calls are inlined
3033     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3034     public long test109_sharp() {
3035         long res = 0;
3036         for (int i = 0 ; i &lt; lArr.length; i++) {
3037             res += InterfaceBox.box_sharp(lArr[i]).content.value();
3038         }
3039         return res;
3040     }
3041 
3042     @DontCompile
3043     public void test109_sharp_verifier(boolean warmup) {
3044         long res = test109_sharp();
3045         Asserts.assertEquals(res, 5*rL);
3046     }
3047 
3048     // Same as test109 but with ObjectBox
3049     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3050     @Warmup(10000) // Make sure interface calls are inlined
3051     public long test110() {
3052         long res = 0;
3053         for (int i = 0 ; i &lt; lArr.length; i++) {
3054             res += ((WrapperInterface)ObjectBox.box(lArr[i]).content).value();
3055         }
3056         return res;
3057     }
3058 
3059     @DontCompile
3060     public void test110_verifier(boolean warmup) {
3061         long res = test110();
3062         Asserts.assertEquals(res, 5*rL);
3063     }
3064 
3065     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3066     @Warmup(10000) // Make sure interface calls are inlined
3067     public long test110_sharp() {
3068         long res = 0;
3069         for (int i = 0 ; i &lt; lArr.length; i++) {
3070             res += ((WrapperInterface)ObjectBox.box_sharp(lArr[i]).content).value();
3071         }
3072         return res;
3073     }
3074 
3075     @DontCompile
3076     public void test110_sharp_verifier(boolean warmup) {
3077         long res = test110_sharp();
3078         Asserts.assertEquals(res, 5*rL);
3079     }
3080 
3081     // Same as test109 but with RefBox
3082     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3083     public long test111() {
3084         long res = 0;
3085         for (int i = 0 ; i &lt; lArr.length; i++) {
3086             res += RefBox.box(lArr[i]).content.value();
3087         }
3088         return res;
3089     }
3090 
3091     @DontCompile
3092     public void test111_verifier(boolean warmup) {
3093         long res = test111();
3094         Asserts.assertEquals(res, 5*rL);
3095     }
3096 
3097     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3098     public long test111_sharp() {
3099         long res = 0;
3100         for (int i = 0 ; i &lt; lArr.length; i++) {
3101             res += RefBox.box_sharp(lArr[i]).content.value();
3102         }
3103         return res;
3104     }
3105 
3106     @DontCompile
3107     public void test111_sharp_verifier(boolean warmup) {
3108         long res = test111_sharp();
3109         Asserts.assertEquals(res, 5*rL);
3110     }
3111 
3112     // Same as test109 but with InlineBox
3113     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3114     public long test112() {
3115         long res = 0;
3116         for (int i = 0 ; i &lt; lArr.length; i++) {
3117             res += InlineBox.box(lArr[i]).content.value();
3118         }
3119         return res;
3120     }
3121 
3122     @DontCompile
3123     public void test112_verifier(boolean warmup) {
3124         long res = test112();
3125         Asserts.assertEquals(res, 5*rL);
3126     }
3127 
3128     // Same as test109 but with GenericBox
3129     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3130     @Warmup(10000) // Make sure interface calls are inlined
3131     public long test113() {
3132         long res = 0;
3133         for (int i = 0 ; i &lt; lArr.length; i++) {
3134             res += GenericBox.box(lArr[i]).content.value();
3135         }
3136         return res;
3137     }
3138 
3139     @DontCompile
3140     public void test113_verifier(boolean warmup) {
3141         long res = test113();
3142         Asserts.assertEquals(res, 5*rL);
3143     }
3144 
3145     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3146     @Warmup(10000) // Make sure interface calls are inlined
3147     public long test113_sharp() {
3148         long res = 0;
3149         for (int i = 0 ; i &lt; lArr.length; i++) {
3150             res += GenericBox.box_sharp(lArr[i]).content.value();
3151         }
3152         return res;
3153     }
3154 
3155     @DontCompile
3156     public void test113_sharp_verifier(boolean warmup) {
3157         long res = test113_sharp();
3158         Asserts.assertEquals(res, 5*rL);
3159     }
3160 
3161     static interface WrapperInterface2 {
3162         public long value();
3163 
3164         static final InlineWrapper.ref ZERO = new InlineWrapper(0);
3165 
3166         public static WrapperInterface2 wrap(long val) {
3167             return (val == 0) ? ZERO.content : new LongWrapper2(val);
3168         }
3169 
3170         public static WrapperInterface2 wrap_default(long val) {
3171             return (val == 0) ? LongWrapper2.default : new LongWrapper2(val);
3172         }
3173     }
3174 
3175     static inline class LongWrapper2 implements WrapperInterface2 {
3176         private long val;
3177 
3178         public LongWrapper2(long val) {
3179             this.val = val;
3180         }
3181 
3182         public long value() {
3183             return val;
3184         }
3185     }
3186 
3187     static inline class InlineWrapper {
3188         WrapperInterface2 content;
3189 
3190         public InlineWrapper(long val) {
3191             content = new LongWrapper2(val);
3192         }
3193     }
3194 
3195     static class InterfaceBox2 {
3196         WrapperInterface2 content;
3197 
3198         public InterfaceBox2(long val, boolean def) {
3199             this.content = def ? WrapperInterface2.wrap_default(val) : WrapperInterface2.wrap(val);
3200         }
3201 
3202         static InterfaceBox2 box(long val) {
3203             return new InterfaceBox2(val, false);
3204         }
3205 
3206         static InterfaceBox2 box_default(long val) {
3207             return new InterfaceBox2(val, true);
3208         }
3209     }
3210 
3211     // Same as tests above but with ZERO hidden in field of another inline type
3212     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3213     @Warmup(10000)
3214     public long test114() {
3215         long res = 0;
3216         for (int i = 0; i &lt; lArr.length; i++) {
3217             res += InterfaceBox2.box(lArr[i]).content.value();
3218         }
3219         return res;
3220     }
3221 
3222     @DontCompile
3223     public void test114_verifier(boolean warmup) {
3224         long res = test114();
3225         Asserts.assertEquals(res, 5*rL);
3226     }
3227 
3228     // Same as test114 but with .default instead of ZERO field
3229     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3230     @Warmup(10000)
3231     public long test115() {
3232         long res = 0;
3233         for (int i = 0; i &lt; lArr.length; i++) {
3234             res += InterfaceBox2.box_default(lArr[i]).content.value();
3235         }
3236         return res;
3237     }
3238 
3239     @DontCompile
3240     public void test115_verifier(boolean warmup) {
3241         long res = test115();
3242         Asserts.assertEquals(res, 5*rL);
3243     }
3244 
3245     static MyValueEmpty     fEmpty1;
3246     static MyValueEmpty.ref fEmpty2 = MyValueEmpty.default;
3247            MyValueEmpty     fEmpty3;
3248            MyValueEmpty.ref fEmpty4 = MyValueEmpty.default;
3249 
3250     // Test fields loads/stores with empty inline types
3251     @Test(failOn = ALLOC + ALLOC_G + LOAD + STORE + TRAP)
3252     public void test116() {
3253         fEmpty1 = fEmpty4;
3254         fEmpty2 = fEmpty1;
3255         fEmpty3 = fEmpty2;
3256         fEmpty4 = fEmpty3;
3257     }
3258 
3259     @DontCompile
3260     public void test116_verifier(boolean warmup) {
3261         test116();
3262         Asserts.assertEquals(fEmpty1, fEmpty2);
3263         Asserts.assertEquals(fEmpty2, fEmpty3);
3264         Asserts.assertEquals(fEmpty3, fEmpty4);
3265     }
3266 
3267     // Test array loads/stores with empty inline types
3268     @Test(failOn = ALLOC + ALLOC_G)
3269     public MyValueEmpty test117(MyValueEmpty[] arr1, MyValueEmpty.ref[] arr2) {
3270         arr1[0] = arr2[0];
3271         arr2[0] = new MyValueEmpty();
3272         return arr1[0];
3273     }
3274 
3275     @DontCompile
3276     public void test117_verifier(boolean warmup) {
3277         MyValueEmpty[] arr1 = new MyValueEmpty[]{MyValueEmpty.default};
3278         MyValueEmpty res = test117(arr1, arr1);
3279         Asserts.assertEquals(res, MyValueEmpty.default);
3280         Asserts.assertEquals(arr1[0], MyValueEmpty.default);
3281     }
3282 
3283     // Test acmp with empty inline types
3284     @Test(failOn = ALLOC + ALLOC_G)
3285     public boolean test118(MyValueEmpty v1, MyValueEmpty.ref v2, Object o1) {
3286         return (v1 == v2) &amp;&amp; (v2 == o1);
3287     }
3288 
3289     @DontCompile
3290     public void test118_verifier(boolean warmup) {
3291         boolean res = test118(MyValueEmpty.default, MyValueEmpty.default, new MyValueEmpty());
3292         Asserts.assertTrue(res);
3293     }
3294 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/symbol.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="method.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/addnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/symbol.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
222     if (position + len &gt; utf8_length()) return false;
223     return (memcmp((char*)base() + position, substring, len) == 0);
224   }
225 
226   // Tests if the symbol contains the given byte at the given position.
227   bool contains_byte_at(int position, char code_byte) const {
228     if (position &lt; 0)  return false;  // can happen with ends_with
229     if (position &gt;= utf8_length()) return false;
230     return code_byte == char_at(position);
231   }
232 
233   // True if this is a descriptor for a method with void return.
234   // (Assumes it is a valid descriptor.)
235   bool is_void_method_signature() const {
236     return starts_with(&#39;(&#39;) &amp;&amp; ends_with(&#39;V&#39;);
237   }
238 
239   bool is_Q_signature() const;
240   bool is_Q_array_signature() const;
241   bool is_Q_method_signature() const;
<span class="line-removed">242   bool is_Q_singledim_array_signature() const;</span>
243   Symbol* fundamental_name(TRAPS);
244   bool is_same_fundamental_type(Symbol*) const;
245 
246   // Tests if the symbol starts with the given prefix.
247   int index_of_at(int i, const char* str, int len) const;
248 
249   // Three-way compare for sorting; returns -1/0/1 if receiver is &lt;/==/&gt; than arg
250   // note that the ordering is not alfabetical
251   inline int fast_compare(const Symbol* other) const;
252 
253   // Returns receiver converted to null-terminated UTF-8 string; string is
254   // allocated in resource area, or in the char buffer provided by caller.
255   char* as_C_string() const;
256   char* as_C_string(char* buf, int size) const;
257 
258   // Returns an escaped form of a Java string.
259   char* as_quoted_ascii() const;
260 
261   // Returns a null terminated utf8 string in a resource array
262   char* as_utf8() const { return as_C_string(); }
</pre>
</td>
<td>
<hr />
<pre>
222     if (position + len &gt; utf8_length()) return false;
223     return (memcmp((char*)base() + position, substring, len) == 0);
224   }
225 
226   // Tests if the symbol contains the given byte at the given position.
227   bool contains_byte_at(int position, char code_byte) const {
228     if (position &lt; 0)  return false;  // can happen with ends_with
229     if (position &gt;= utf8_length()) return false;
230     return code_byte == char_at(position);
231   }
232 
233   // True if this is a descriptor for a method with void return.
234   // (Assumes it is a valid descriptor.)
235   bool is_void_method_signature() const {
236     return starts_with(&#39;(&#39;) &amp;&amp; ends_with(&#39;V&#39;);
237   }
238 
239   bool is_Q_signature() const;
240   bool is_Q_array_signature() const;
241   bool is_Q_method_signature() const;

242   Symbol* fundamental_name(TRAPS);
243   bool is_same_fundamental_type(Symbol*) const;
244 
245   // Tests if the symbol starts with the given prefix.
246   int index_of_at(int i, const char* str, int len) const;
247 
248   // Three-way compare for sorting; returns -1/0/1 if receiver is &lt;/==/&gt; than arg
249   // note that the ordering is not alfabetical
250   inline int fast_compare(const Symbol* other) const;
251 
252   // Returns receiver converted to null-terminated UTF-8 string; string is
253   // allocated in resource area, or in the char buffer provided by caller.
254   char* as_C_string() const;
255   char* as_C_string(char* buf, int size) const;
256 
257   // Returns an escaped form of a Java string.
258   char* as_quoted_ascii() const;
259 
260   // Returns a null terminated utf8 string in a resource array
261   char* as_utf8() const { return as_C_string(); }
</pre>
</td>
</tr>
</table>
<center><a href="method.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/addnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
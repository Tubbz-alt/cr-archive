diff a/src/hotspot/share/opto/type.hpp b/src/hotspot/share/opto/type.hpp
--- a/src/hotspot/share/opto/type.hpp
+++ b/src/hotspot/share/opto/type.hpp
@@ -23,11 +23,11 @@
  */
 
 #ifndef SHARE_OPTO_TYPE_HPP
 #define SHARE_OPTO_TYPE_HPP
 
-#include "ci/ciValueKlass.hpp"
+#include "ci/ciInlineKlass.hpp"
 #include "opto/adlcVMDeps.hpp"
 #include "runtime/handles.hpp"
 #include "runtime/sharedRuntime.hpp"
 
 // Portions of code courtesy of Clifford Click
@@ -52,11 +52,11 @@
 class   TypeNarrowPtr;
 class     TypeNarrowOop;
 class     TypeNarrowKlass;
 class   TypeAry;
 class   TypeTuple;
-class   TypeValueType;
+class   TypeInlineType;
 class   TypeVect;
 class     TypeVectS;
 class     TypeVectD;
 class     TypeVectX;
 class     TypeVectY;
@@ -93,11 +93,11 @@
     VectorS,                    //  32bit Vector types
     VectorD,                    //  64bit Vector types
     VectorX,                    // 128bit Vector types
     VectorY,                    // 256bit Vector types
     VectorZ,                    // 512bit Vector types
-    ValueType,                  // Value type
+    InlineType,                  // Inline type
 
     AnyPtr,                     // Any old raw, klass, inst, or array pointer
     RawPtr,                     // Raw (non-oop) pointers
     OopPtr,                     // Any and all Java heap entities
     InstPtr,                    // Instance pointers (non-array objects)
@@ -331,23 +331,23 @@
   const TypeOopPtr   *is_oopptr() const;         // Java-style GC'd pointer
   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
   const TypeInstPtr  *is_instptr() const;        // Instance
   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
   const TypeAryPtr   *is_aryptr() const;         // Array oop
-  const TypeValueType* isa_valuetype() const;    // Returns NULL if not Value Type
-  const TypeValueType* is_valuetype() const;     // Value Type
+  const TypeInlineType* isa_inlinetype() const;    // Returns NULL if not Inline Type
+  const TypeInlineType* is_inlinetype() const;     // Inline Type
 
   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC'd pointer
   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 
   virtual bool      is_finite() const;           // Has a finite value
   virtual bool      is_nan()    const;           // Is not a number (NaN)
 
-  bool is_valuetypeptr() const;
-  virtual ciValueKlass* value_klass() const;
+  bool is_inlinetypeptr() const;
+  virtual ciInlineKlass* inline_klass() const;
 
   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
   const TypePtr* make_ptr() const;
 
   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
@@ -734,11 +734,11 @@
 private:
   const Type *_elem;            // Element type of array
   const TypeInt *_size;         // Elements in array
   const bool _stable;           // Are elements @Stable?
 
-  // Value type array properties
+  // Inline type array properties
   const bool _not_flat;         // Array is never flattened
   const bool _not_null_free;    // Array is never null-free
 
   friend class TypeAryPtr;
 
@@ -761,25 +761,25 @@
 #endif
 };
 
 
 //------------------------------TypeValue---------------------------------------
-// Class of Value Type Types
-class TypeValueType : public Type {
+// Class of Inline Type Types
+class TypeInlineType : public Type {
 private:
-  ciValueKlass* _vk;
+  ciInlineKlass* _vk;
   bool _larval;
 
 protected:
-  TypeValueType(ciValueKlass* vk, bool larval)
-    : Type(ValueType),
+  TypeInlineType(ciInlineKlass* vk, bool larval)
+    : Type(InlineType),
       _vk(vk), _larval(larval) {
   }
 
 public:
-  static const TypeValueType* make(ciValueKlass* vk, bool larval = false);
-  virtual ciValueKlass* value_klass() const { return _vk; }
+  static const TypeInlineType* make(ciInlineKlass* vk, bool larval = false);
+  virtual ciInlineKlass* inline_klass() const { return _vk; }
   bool larval() const { return _larval; }
 
   virtual bool eq(const Type* t) const;
   virtual int  hash() const;             // Type specific hashing
   virtual bool singleton(void) const;    // TRUE if type is a singleton
@@ -789,11 +789,11 @@
   virtual const Type* xdual() const;     // Compute dual right now.
 
   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }
   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }
 
-  static const TypeValueType *BOTTOM;
+  static const TypeInlineType *BOTTOM;
 
 #ifndef PRODUCT
   virtual void dump2(Dict &d, uint, outputStream* st) const; // Specialized per-Type dumping
 #endif
 };
@@ -973,11 +973,11 @@
   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
   virtual const TypePtr* with_inline_depth(int depth) const;
 
   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 
-  virtual bool can_be_value_type() const { return false; }
+  virtual bool can_be_inline_type() const { return false; }
   virtual bool flat_array() const { return false; }
 
   // Tests for relation to centerline of type lattice:
   static bool above_centerline(PTR ptr) { return (ptr <= AnyNull); }
   static bool below_centerline(PTR ptr) { return (ptr >= NotNull); }
@@ -1101,11 +1101,11 @@
   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
   bool is_known_instance()       const { return _instance_id > 0; }
   int  instance_id()             const { return _instance_id; }
   bool is_known_instance_field() const { return is_known_instance() && _offset.get() >= 0; }
 
-  virtual bool can_be_value_type() const { return EnableValhalla && (_klass == NULL || _klass->can_be_value_klass(_klass_is_exact)); }
+  virtual bool can_be_inline_type() const { return EnableValhalla && (_klass == NULL || _klass->can_be_inline_klass(_klass_is_exact)); }
 
   virtual intptr_t get_con() const;
 
   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 
@@ -1155,30 +1155,30 @@
 
   bool  is_loaded() const { return _klass->is_loaded(); }
 
   // Make a pointer to a constant oop.
   static const TypeInstPtr *make(ciObject* o) {
-    return make(TypePtr::Constant, o->klass(), true, o, Offset(0), o->klass()->is_valuetype() && o->klass()->as_value_klass()->flatten_array(), InstanceBot);
+    return make(TypePtr::Constant, o->klass(), true, o, Offset(0), o->klass()->is_inlinetype() && o->klass()->as_inline_klass()->flatten_array(), InstanceBot);
   }
   // Make a pointer to a constant oop with offset.
   static const TypeInstPtr* make(ciObject* o, Offset offset) {
-    return make(TypePtr::Constant, o->klass(), true, o, offset, o->klass()->is_valuetype() && o->klass()->as_value_klass()->flatten_array(), InstanceBot);
+    return make(TypePtr::Constant, o->klass(), true, o, offset, o->klass()->is_inlinetype() && o->klass()->as_inline_klass()->flatten_array(), InstanceBot);
   }
 
   // Make a pointer to some value of type klass.
   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
-    return make(ptr, klass, false, NULL, Offset(0), klass->is_valuetype() && klass->as_value_klass()->flatten_array(), InstanceBot);
+    return make(ptr, klass, false, NULL, Offset(0), klass->is_inlinetype() && klass->as_inline_klass()->flatten_array(), InstanceBot);
   }
 
   // Make a pointer to some non-polymorphic value of exactly type klass.
   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
-    return make(ptr, klass, true, NULL, Offset(0), klass->is_valuetype() && klass->as_value_klass()->flatten_array(), InstanceBot);
+    return make(ptr, klass, true, NULL, Offset(0), klass->is_inlinetype() && klass->as_inline_klass()->flatten_array(), InstanceBot);
   }
 
   // Make a pointer to some value of type klass with offset.
   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
-    return make(ptr, klass, false, NULL, offset, klass->is_valuetype() && klass->as_value_klass()->flatten_array(), InstanceBot);
+    return make(ptr, klass, false, NULL, offset, klass->is_inlinetype() && klass->as_inline_klass()->flatten_array(), InstanceBot);
   }
 
   // Make a pointer to an oop.
   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
                                  bool flat_array,
@@ -1207,12 +1207,12 @@
   virtual const TypePtr* with_inline_depth(int depth) const;
   virtual const TypePtr* with_instance_id(int instance_id) const;
 
   virtual const TypeInstPtr* cast_to_flat_array() const;
   virtual bool flat_array() const {
-    assert(!klass()->is_valuetype() || !klass()->as_value_klass()->flatten_array() || _flat_array, "incorrect value bit");
-    assert(!_flat_array || can_be_value_type(), "incorrect value bit");
+    assert(!klass()->is_inlinetype() || !klass()->as_inline_klass()->flatten_array() || _flat_array, "incorrect value bit");
+    assert(!_flat_array || can_be_inline_type(), "incorrect value bit");
     return _flat_array;
   }
 
   // the core of the computation of the meet of 2 types
   virtual const Type *xmeet_helper(const Type *t) const;
@@ -1260,11 +1260,11 @@
   }
   virtual bool eq( const Type *t ) const;
   virtual int hash() const;     // Type specific hashing
   const TypeAry *_ary;          // Array we point into
   const bool     _is_autobox_cache;
-  // For flattened value type arrays, each field of the value type in
+  // For flattened inline type arrays, each field of the inline type in
   // the array has its own memory slice so we need to keep track of
   // which field is accessed
   const Offset _field_offset;
   Offset meet_field_offset(const Type::Offset offset) const;
   Offset dual_field_offset() const;
@@ -1277,11 +1277,11 @@
   const TypeAry* ary() const  { return _ary; }
   const Type*    elem() const { return _ary->_elem; }
   const TypeInt* size() const { return _ary->_size; }
   bool      is_stable() const { return _ary->_stable; }
 
-  // Value type array properties
+  // Inline type array properties
   bool is_not_flat()      const { return _ary->_not_flat; }
   bool is_not_null_free() const { return _ary->_not_null_free; }
 
   bool is_autobox_cache() const { return _is_autobox_cache; }
 
@@ -1334,11 +1334,11 @@
   const int flattened_offset() const;
   const Offset field_offset() const { return _field_offset; }
   const TypeAryPtr* with_field_offset(int offset) const;
   const TypePtr* add_field_offset_and_offset(intptr_t offset) const;
 
-  virtual bool can_be_value_type() const { return false; }
+  virtual bool can_be_inline_type() const { return false; }
 
   // Convenience common pre-built types.
   static const TypeAryPtr *RANGE;
   static const TypeAryPtr *OOPS;
   static const TypeAryPtr *NARROWOOPS;
@@ -1347,11 +1347,11 @@
   static const TypeAryPtr *CHARS;
   static const TypeAryPtr *INTS;
   static const TypeAryPtr *LONGS;
   static const TypeAryPtr *FLOATS;
   static const TypeAryPtr *DOUBLES;
-  static const TypeAryPtr *VALUES;
+  static const TypeAryPtr *INLINES;
   // selects one of the above:
   static const TypeAryPtr *get_array_body_type(BasicType elem) {
     assert((uint)elem <= T_CONFLICT && _array_body_type[elem] != NULL, "bad elem type");
     return _array_body_type[elem];
   }
@@ -1427,23 +1427,23 @@
 
 public:
   ciKlass* klass() const { return  _klass; }
   bool klass_is_exact()    const { return _klass_is_exact; }
 
-  virtual bool can_be_value_type() const { return EnableValhalla && (_klass == NULL || _klass->can_be_value_klass(_klass_is_exact)); }
+  virtual bool can_be_inline_type() const { return EnableValhalla && (_klass == NULL || _klass->can_be_inline_klass(_klass_is_exact)); }
   virtual bool flat_array() const {
-    assert(!klass()->is_valuetype() || !klass()->as_value_klass()->flatten_array() || _flat_array, "incorrect value bit");
-    assert(!_flat_array || can_be_value_type(), "incorrect value bit");
+    assert(!klass()->is_inlinetype() || !klass()->as_inline_klass()->flatten_array() || _flat_array, "incorrect value bit");
+    assert(!_flat_array || can_be_inline_type(), "incorrect value bit");
     return _flat_array;
   }
 
   bool  is_loaded() const { return klass() != NULL && klass()->is_loaded(); }
 
   // ptr to klass 'k'
-  static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0), k->is_valuetype() && k->as_value_klass()->flatten_array()); }
+  static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0), k->is_inlinetype() && k->as_inline_klass()->flatten_array()); }
   // ptr to klass 'k' with offset
-  static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset, k->is_valuetype() && k->as_value_klass()->flatten_array()); }
+  static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset, k->is_inlinetype() && k->as_inline_klass()->flatten_array()); }
   // ptr to klass 'k' or sub-klass
   static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flat_array);
 
   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 
@@ -1599,19 +1599,19 @@
   virtual bool eq( const Type *t ) const;
   virtual int  hash() const;             // Type specific hashing
   virtual bool singleton(void) const;    // TRUE if type is a singleton
   virtual bool empty(void) const;        // TRUE if type is vacuous
 
-  // Domains of inputs: value type arguments are not passed by
-  // reference, instead each field of the value type is passed as an
+  // Domains of inputs: inline type arguments are not passed by
+  // reference, instead each field of the inline type is passed as an
   // argument. We maintain 2 views of the argument list here: one
-  // based on the signature (with a value type argument as a single
+  // based on the signature (with an inline type argument as a single
   // slot), one based on the actual calling convention (with a value
   // type argument as a list of its fields).
   const TypeTuple* const _domain_sig;
   const TypeTuple* const _domain_cc;
-  // Range of results. Similar to domains: a value type result can be
+  // Range of results. Similar to domains: an inline type result can be
   // returned in registers in which case range_cc lists all fields and
   // is the actual calling convention.
   const TypeTuple* const _range_sig;
   const TypeTuple* const _range_cc;
 
@@ -1640,11 +1640,11 @@
   virtual const Type *xmeet( const Type *t ) const;
   virtual const Type *xdual() const;    // Compute dual right now.
 
   BasicType return_type() const;
 
-  bool returns_value_type_as_fields() const { return range_sig() != range_cc(); }
+  bool returns_inline_type_as_fields() const { return range_sig() != range_cc(); }
 
 #ifndef PRODUCT
   virtual void dump2( Dict &d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
 #endif
   // Convenience common pre-built types.
@@ -1795,17 +1795,17 @@
 inline const TypeAryPtr *Type::is_aryptr() const {
   assert( _base == AryPtr, "Not an array pointer" );
   return (TypeAryPtr*)this;
 }
 
-inline const TypeValueType* Type::isa_valuetype() const {
-  return (_base == ValueType) ? (TypeValueType*)this : NULL;
+inline const TypeInlineType* Type::isa_inlinetype() const {
+  return (_base == InlineType) ? (TypeInlineType*)this : NULL;
 }
 
-inline const TypeValueType* Type::is_valuetype() const {
-  assert(_base == ValueType, "Not a value type");
-  return (TypeValueType*)this;
+inline const TypeInlineType* Type::is_inlinetype() const {
+  assert(_base == InlineType, "Not an inline type");
+  return (TypeInlineType*)this;
 }
 
 inline const TypeNarrowOop *Type::is_narrowoop() const {
   // OopPtr is the first and KlassPtr the last, with no non-oops between.
   assert(_base == NarrowOop, "Not a narrow oop" ) ;
@@ -1870,18 +1870,18 @@
       (_base == DoubleCon) || (_base == DoubleBot) )
     return true;
   return false;
 }
 
-inline bool Type::is_valuetypeptr() const {
-  return isa_instptr() != NULL && is_instptr()->klass()->is_valuetype();
+inline bool Type::is_inlinetypeptr() const {
+  return isa_instptr() != NULL && is_instptr()->klass()->is_inlinetype();
 }
 
 
-inline ciValueKlass* Type::value_klass() const {
-  assert(is_valuetypeptr(), "must be a value type ptr");
-  return is_instptr()->klass()->as_value_klass();
+inline ciInlineKlass* Type::inline_klass() const {
+  assert(is_inlinetypeptr(), "must be an inline type ptr");
+  return is_instptr()->klass()->as_inline_klass();
 }
 
 
 // ===============================================================
 // Things that need to be 64-bits in the 64-bit build but

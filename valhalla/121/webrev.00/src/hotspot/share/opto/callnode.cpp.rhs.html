<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/callnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  27 #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
  28 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  29 #include &quot;compiler/oopMap.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;opto/callGenerator.hpp&quot;
  34 #include &quot;opto/callnode.hpp&quot;
  35 #include &quot;opto/castnode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/escape.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  38 #include &quot;opto/inlinetypenode.hpp&quot;</span>
  39 #include &quot;opto/locknode.hpp&quot;
  40 #include &quot;opto/machnode.hpp&quot;
  41 #include &quot;opto/matcher.hpp&quot;
  42 #include &quot;opto/parse.hpp&quot;
  43 #include &quot;opto/regalloc.hpp&quot;
  44 #include &quot;opto/regmask.hpp&quot;
  45 #include &quot;opto/rootnode.hpp&quot;
  46 #include &quot;opto/runtime.hpp&quot;
<a name="3" id="anc3"></a>
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;utilities/powerOfTwo.hpp&quot;
  49 
  50 // Portions of code courtesy of Clifford Click
  51 
  52 // Optimization - Graph Style
  53 
  54 //=============================================================================
  55 uint StartNode::size_of() const { return sizeof(*this); }
  56 bool StartNode::cmp( const Node &amp;n ) const
  57 { return _domain == ((StartNode&amp;)n)._domain; }
  58 const Type *StartNode::bottom_type() const { return _domain; }
  59 const Type* StartNode::Value(PhaseGVN* phase) const { return _domain; }
  60 #ifndef PRODUCT
  61 void StartNode::dump_spec(outputStream *st) const { st-&gt;print(&quot; #&quot;); _domain-&gt;dump_on(st);}
  62 void StartNode::dump_compact_spec(outputStream *st) const { /* empty */ }
  63 #endif
  64 
  65 //------------------------------Ideal------------------------------------------
  66 Node *StartNode::Ideal(PhaseGVN *phase, bool can_reshape){
  67   return remove_dead_region(phase, can_reshape) ? this : NULL;
  68 }
  69 
  70 //------------------------------calling_convention-----------------------------
  71 void StartNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
  72   Matcher::calling_convention( sig_bt, parm_regs, argcnt, false );
  73 }
  74 
  75 //------------------------------Registers--------------------------------------
  76 const RegMask &amp;StartNode::in_RegMask(uint) const {
  77   return RegMask::Empty;
  78 }
  79 
  80 //------------------------------match------------------------------------------
  81 // Construct projections for incoming parameters, and their RegMask info
  82 Node *StartNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {
  83   switch (proj-&gt;_con) {
  84   case TypeFunc::Control:
  85   case TypeFunc::I_O:
  86   case TypeFunc::Memory:
  87     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
  88   case TypeFunc::FramePtr:
  89     return new MachProjNode(this,proj-&gt;_con,Matcher::c_frame_ptr_mask, Op_RegP);
  90   case TypeFunc::ReturnAdr:
  91     return new MachProjNode(this,proj-&gt;_con,match-&gt;_return_addr_mask,Op_RegP);
  92   case TypeFunc::Parms:
  93   default: {
  94       uint parm_num = proj-&gt;_con - TypeFunc::Parms;
  95       const Type *t = _domain-&gt;field_at(proj-&gt;_con);
  96       if (t-&gt;base() == Type::Half)  // 2nd half of Longs and Doubles
  97         return new ConNode(Type::TOP);
  98       uint ideal_reg = t-&gt;ideal_reg();
  99       RegMask &amp;rm = match-&gt;_calling_convention_mask[parm_num];
 100       return new MachProjNode(this,proj-&gt;_con,rm,ideal_reg);
 101     }
 102   }
 103   return NULL;
 104 }
 105 
 106 //=============================================================================
 107 const char * const ParmNode::names[TypeFunc::Parms+1] = {
 108   &quot;Control&quot;, &quot;I_O&quot;, &quot;Memory&quot;, &quot;FramePtr&quot;, &quot;ReturnAdr&quot;, &quot;Parms&quot;
 109 };
 110 
 111 #ifndef PRODUCT
 112 void ParmNode::dump_spec(outputStream *st) const {
 113   if( _con &lt; TypeFunc::Parms ) {
 114     st-&gt;print(&quot;%s&quot;, names[_con]);
 115   } else {
 116     st-&gt;print(&quot;Parm%d: &quot;,_con-TypeFunc::Parms);
 117     // Verbose and WizardMode dump bottom_type for all nodes
 118     if( !Verbose &amp;&amp; !WizardMode )   bottom_type()-&gt;dump_on(st);
 119   }
 120 }
 121 
 122 void ParmNode::dump_compact_spec(outputStream *st) const {
 123   if (_con &lt; TypeFunc::Parms) {
 124     st-&gt;print(&quot;%s&quot;, names[_con]);
 125   } else {
 126     st-&gt;print(&quot;%d:&quot;, _con-TypeFunc::Parms);
 127     // unconditionally dump bottom_type
 128     bottom_type()-&gt;dump_on(st);
 129   }
 130 }
 131 
 132 // For a ParmNode, all immediate inputs and outputs are considered relevant
 133 // both in compact and standard representation.
 134 void ParmNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
 135   this-&gt;collect_nodes(in_rel, 1, false, false);
 136   this-&gt;collect_nodes(out_rel, -1, false, false);
 137 }
 138 #endif
 139 
 140 uint ParmNode::ideal_reg() const {
 141   switch( _con ) {
 142   case TypeFunc::Control  : // fall through
 143   case TypeFunc::I_O      : // fall through
 144   case TypeFunc::Memory   : return 0;
 145   case TypeFunc::FramePtr : // fall through
 146   case TypeFunc::ReturnAdr: return Op_RegP;
 147   default                 : assert( _con &gt; TypeFunc::Parms, &quot;&quot; );
 148     // fall through
 149   case TypeFunc::Parms    : {
 150     // Type of argument being passed
 151     const Type *t = in(0)-&gt;as_Start()-&gt;_domain-&gt;field_at(_con);
 152     return t-&gt;ideal_reg();
 153   }
 154   }
 155   ShouldNotReachHere();
 156   return 0;
 157 }
 158 
 159 //=============================================================================
 160 ReturnNode::ReturnNode(uint edges, Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *retadr ) : Node(edges) {
 161   init_req(TypeFunc::Control,cntrl);
 162   init_req(TypeFunc::I_O,i_o);
 163   init_req(TypeFunc::Memory,memory);
 164   init_req(TypeFunc::FramePtr,frameptr);
 165   init_req(TypeFunc::ReturnAdr,retadr);
 166 }
 167 
 168 Node *ReturnNode::Ideal(PhaseGVN *phase, bool can_reshape){
 169   return remove_dead_region(phase, can_reshape) ? this : NULL;
 170 }
 171 
 172 const Type* ReturnNode::Value(PhaseGVN* phase) const {
 173   return ( phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 174     ? Type::TOP
 175     : Type::BOTTOM;
 176 }
 177 
 178 // Do we Match on this edge index or not?  No edges on return nodes
 179 uint ReturnNode::match_edge(uint idx) const {
 180   return 0;
 181 }
 182 
 183 
 184 #ifndef PRODUCT
 185 void ReturnNode::dump_req(outputStream *st) const {
 186   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 187   uint i;                       // Exit value of loop
 188   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 189     if (i == TypeFunc::Parms) st-&gt;print(&quot;returns&quot;);
 190     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 191     else st-&gt;print(&quot;_ &quot;);
 192   }
 193 }
 194 #endif
 195 
 196 //=============================================================================
 197 RethrowNode::RethrowNode(
 198   Node* cntrl,
 199   Node* i_o,
 200   Node* memory,
 201   Node* frameptr,
 202   Node* ret_adr,
 203   Node* exception
 204 ) : Node(TypeFunc::Parms + 1) {
 205   init_req(TypeFunc::Control  , cntrl    );
 206   init_req(TypeFunc::I_O      , i_o      );
 207   init_req(TypeFunc::Memory   , memory   );
 208   init_req(TypeFunc::FramePtr , frameptr );
 209   init_req(TypeFunc::ReturnAdr, ret_adr);
 210   init_req(TypeFunc::Parms    , exception);
 211 }
 212 
 213 Node *RethrowNode::Ideal(PhaseGVN *phase, bool can_reshape){
 214   return remove_dead_region(phase, can_reshape) ? this : NULL;
 215 }
 216 
 217 const Type* RethrowNode::Value(PhaseGVN* phase) const {
 218   return (phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 219     ? Type::TOP
 220     : Type::BOTTOM;
 221 }
 222 
 223 uint RethrowNode::match_edge(uint idx) const {
 224   return 0;
 225 }
 226 
 227 #ifndef PRODUCT
 228 void RethrowNode::dump_req(outputStream *st) const {
 229   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 230   uint i;                       // Exit value of loop
 231   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 232     if (i == TypeFunc::Parms) st-&gt;print(&quot;exception&quot;);
 233     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 234     else st-&gt;print(&quot;_ &quot;);
 235   }
 236 }
 237 #endif
 238 
 239 //=============================================================================
 240 // Do we Match on this edge index or not?  Match only target address &amp; method
 241 uint TailCallNode::match_edge(uint idx) const {
 242   return TypeFunc::Parms &lt;= idx  &amp;&amp;  idx &lt;= TypeFunc::Parms+1;
 243 }
 244 
 245 //=============================================================================
 246 // Do we Match on this edge index or not?  Match only target address &amp; oop
 247 uint TailJumpNode::match_edge(uint idx) const {
 248   return TypeFunc::Parms &lt;= idx  &amp;&amp;  idx &lt;= TypeFunc::Parms+1;
 249 }
 250 
 251 //=============================================================================
 252 JVMState::JVMState(ciMethod* method, JVMState* caller) :
 253   _method(method) {
 254   assert(method != NULL, &quot;must be valid call site&quot;);
 255   _bci = InvocationEntryBci;
 256   _reexecute = Reexecute_Undefined;
 257   debug_only(_bci = -99);  // random garbage value
 258   debug_only(_map = (SafePointNode*)-1);
 259   _caller = caller;
 260   _depth  = 1 + (caller == NULL ? 0 : caller-&gt;depth());
 261   _locoff = TypeFunc::Parms;
 262   _stkoff = _locoff + _method-&gt;max_locals();
 263   _monoff = _stkoff + _method-&gt;max_stack();
 264   _scloff = _monoff;
 265   _endoff = _monoff;
 266   _sp = 0;
 267 }
 268 JVMState::JVMState(int stack_size) :
 269   _method(NULL) {
 270   _bci = InvocationEntryBci;
 271   _reexecute = Reexecute_Undefined;
 272   debug_only(_map = (SafePointNode*)-1);
 273   _caller = NULL;
 274   _depth  = 1;
 275   _locoff = TypeFunc::Parms;
 276   _stkoff = _locoff;
 277   _monoff = _stkoff + stack_size;
 278   _scloff = _monoff;
 279   _endoff = _monoff;
 280   _sp = 0;
 281 }
 282 
 283 //--------------------------------of_depth-------------------------------------
 284 JVMState* JVMState::of_depth(int d) const {
 285   const JVMState* jvmp = this;
 286   assert(0 &lt; d &amp;&amp; (uint)d &lt;= depth(), &quot;oob&quot;);
 287   for (int skip = depth() - d; skip &gt; 0; skip--) {
 288     jvmp = jvmp-&gt;caller();
 289   }
 290   assert(jvmp-&gt;depth() == (uint)d, &quot;found the right one&quot;);
 291   return (JVMState*)jvmp;
 292 }
 293 
 294 //-----------------------------same_calls_as-----------------------------------
 295 bool JVMState::same_calls_as(const JVMState* that) const {
 296   if (this == that)                    return true;
 297   if (this-&gt;depth() != that-&gt;depth())  return false;
 298   const JVMState* p = this;
 299   const JVMState* q = that;
 300   for (;;) {
 301     if (p-&gt;_method != q-&gt;_method)    return false;
 302     if (p-&gt;_method == NULL)          return true;   // bci is irrelevant
 303     if (p-&gt;_bci    != q-&gt;_bci)       return false;
 304     if (p-&gt;_reexecute != q-&gt;_reexecute)  return false;
 305     p = p-&gt;caller();
 306     q = q-&gt;caller();
 307     if (p == q)                      return true;
 308     assert(p != NULL &amp;&amp; q != NULL, &quot;depth check ensures we don&#39;t run off end&quot;);
 309   }
 310 }
 311 
 312 //------------------------------debug_start------------------------------------
 313 uint JVMState::debug_start()  const {
 314   debug_only(JVMState* jvmroot = of_depth(1));
 315   assert(jvmroot-&gt;locoff() &lt;= this-&gt;locoff(), &quot;youngest JVMState must be last&quot;);
 316   return of_depth(1)-&gt;locoff();
 317 }
 318 
 319 //-------------------------------debug_end-------------------------------------
 320 uint JVMState::debug_end() const {
 321   debug_only(JVMState* jvmroot = of_depth(1));
 322   assert(jvmroot-&gt;endoff() &lt;= this-&gt;endoff(), &quot;youngest JVMState must be last&quot;);
 323   return endoff();
 324 }
 325 
 326 //------------------------------debug_depth------------------------------------
 327 uint JVMState::debug_depth() const {
 328   uint total = 0;
 329   for (const JVMState* jvmp = this; jvmp != NULL; jvmp = jvmp-&gt;caller()) {
 330     total += jvmp-&gt;debug_size();
 331   }
 332   return total;
 333 }
 334 
 335 #ifndef PRODUCT
 336 
 337 //------------------------------format_helper----------------------------------
 338 // Given an allocation (a Chaitin object) and a Node decide if the Node carries
 339 // any defined value or not.  If it does, print out the register or constant.
 340 static void format_helper( PhaseRegAlloc *regalloc, outputStream* st, Node *n, const char *msg, uint i, GrowableArray&lt;SafePointScalarObjectNode*&gt; *scobjs ) {
 341   if (n == NULL) { st-&gt;print(&quot; NULL&quot;); return; }
 342   if (n-&gt;is_SafePointScalarObject()) {
 343     // Scalar replacement.
 344     SafePointScalarObjectNode* spobj = n-&gt;as_SafePointScalarObject();
 345     scobjs-&gt;append_if_missing(spobj);
 346     int sco_n = scobjs-&gt;find(spobj);
 347     assert(sco_n &gt;= 0, &quot;&quot;);
 348     st-&gt;print(&quot; %s%d]=#ScObj&quot; INT32_FORMAT, msg, i, sco_n);
 349     return;
 350   }
 351   if (regalloc-&gt;node_regs_max_index() &gt; 0 &amp;&amp;
 352       OptoReg::is_valid(regalloc-&gt;get_reg_first(n))) { // Check for undefined
 353     char buf[50];
 354     regalloc-&gt;dump_register(n,buf);
 355     st-&gt;print(&quot; %s%d]=%s&quot;,msg,i,buf);
 356   } else {                      // No register, but might be constant
 357     const Type *t = n-&gt;bottom_type();
 358     switch (t-&gt;base()) {
 359     case Type::Int:
 360       st-&gt;print(&quot; %s%d]=#&quot; INT32_FORMAT,msg,i,t-&gt;is_int()-&gt;get_con());
 361       break;
 362     case Type::AnyPtr:
 363       assert( t == TypePtr::NULL_PTR || n-&gt;in_dump(), &quot;&quot; );
 364       st-&gt;print(&quot; %s%d]=#NULL&quot;,msg,i);
 365       break;
 366     case Type::AryPtr:
 367     case Type::InstPtr:
 368       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;isa_oopptr()-&gt;const_oop()));
 369       break;
 370     case Type::KlassPtr:
 371       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_klassptr()-&gt;klass()));
 372       break;
 373     case Type::MetadataPtr:
 374       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_metadataptr()-&gt;metadata()));
 375       break;
 376     case Type::NarrowOop:
 377       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()));
 378       break;
 379     case Type::RawPtr:
 380       st-&gt;print(&quot; %s%d]=#Raw&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;is_rawptr()));
 381       break;
 382     case Type::DoubleCon:
 383       st-&gt;print(&quot; %s%d]=#%fD&quot;,msg,i,t-&gt;is_double_constant()-&gt;_d);
 384       break;
 385     case Type::FloatCon:
 386       st-&gt;print(&quot; %s%d]=#%fF&quot;,msg,i,t-&gt;is_float_constant()-&gt;_f);
 387       break;
 388     case Type::Long:
 389       st-&gt;print(&quot; %s%d]=#&quot; INT64_FORMAT,msg,i,(int64_t)(t-&gt;is_long()-&gt;get_con()));
 390       break;
 391     case Type::Half:
 392     case Type::Top:
 393       st-&gt;print(&quot; %s%d]=_&quot;,msg,i);
 394       break;
 395     default: ShouldNotReachHere();
 396     }
 397   }
 398 }
 399 
 400 //------------------------------format-----------------------------------------
 401 void JVMState::format(PhaseRegAlloc *regalloc, const Node *n, outputStream* st) const {
 402   st-&gt;print(&quot;        #&quot;);
 403   if (_method) {
 404     _method-&gt;print_short_name(st);
 405     st-&gt;print(&quot; @ bci:%d &quot;,_bci);
 406   } else {
 407     st-&gt;print_cr(&quot; runtime stub &quot;);
 408     return;
 409   }
 410   if (n-&gt;is_MachSafePoint()) {
 411     GrowableArray&lt;SafePointScalarObjectNode*&gt; scobjs;
 412     MachSafePointNode *mcall = n-&gt;as_MachSafePoint();
 413     uint i;
 414     // Print locals
 415     for (i = 0; i &lt; (uint)loc_size(); i++)
 416       format_helper(regalloc, st, mcall-&gt;local(this, i), &quot;L[&quot;, i, &amp;scobjs);
 417     // Print stack
 418     for (i = 0; i &lt; (uint)stk_size(); i++) {
 419       if ((uint)(_stkoff + i) &gt;= mcall-&gt;len())
 420         st-&gt;print(&quot; oob &quot;);
 421       else
 422        format_helper(regalloc, st, mcall-&gt;stack(this, i), &quot;STK[&quot;, i, &amp;scobjs);
 423     }
 424     for (i = 0; (int)i &lt; nof_monitors(); i++) {
 425       Node *box = mcall-&gt;monitor_box(this, i);
 426       Node *obj = mcall-&gt;monitor_obj(this, i);
 427       if (regalloc-&gt;node_regs_max_index() &gt; 0 &amp;&amp;
 428           OptoReg::is_valid(regalloc-&gt;get_reg_first(box))) {
 429         box = BoxLockNode::box_node(box);
 430         format_helper(regalloc, st, box, &quot;MON-BOX[&quot;, i, &amp;scobjs);
 431       } else {
 432         OptoReg::Name box_reg = BoxLockNode::reg(box);
 433         st-&gt;print(&quot; MON-BOX%d=%s+%d&quot;,
 434                    i,
 435                    OptoReg::regname(OptoReg::c_frame_pointer),
 436                    regalloc-&gt;reg2offset(box_reg));
 437       }
 438       const char* obj_msg = &quot;MON-OBJ[&quot;;
 439       if (EliminateLocks) {
 440         if (BoxLockNode::box_node(box)-&gt;is_eliminated())
 441           obj_msg = &quot;MON-OBJ(LOCK ELIMINATED)[&quot;;
 442       }
 443       format_helper(regalloc, st, obj, obj_msg, i, &amp;scobjs);
 444     }
 445 
 446     for (i = 0; i &lt; (uint)scobjs.length(); i++) {
 447       // Scalar replaced objects.
 448       st-&gt;cr();
 449       st-&gt;print(&quot;        # ScObj&quot; INT32_FORMAT &quot; &quot;, i);
 450       SafePointScalarObjectNode* spobj = scobjs.at(i);
 451       ciKlass* cik = spobj-&gt;bottom_type()-&gt;is_oopptr()-&gt;klass();
 452       assert(cik-&gt;is_instance_klass() ||
 453              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 454       ciInstanceKlass *iklass = NULL;
 455       if (cik-&gt;is_instance_klass()) {
 456         cik-&gt;print_name_on(st);
 457         iklass = cik-&gt;as_instance_klass();
 458       } else if (cik-&gt;is_type_array_klass()) {
 459         cik-&gt;as_array_klass()-&gt;base_element_type()-&gt;print_name_on(st);
 460         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 461       } else if (cik-&gt;is_obj_array_klass()) {
 462         ciKlass* cie = cik-&gt;as_obj_array_klass()-&gt;base_element_klass();
 463         if (cie-&gt;is_instance_klass()) {
 464           cie-&gt;print_name_on(st);
 465         } else if (cie-&gt;is_type_array_klass()) {
 466           cie-&gt;as_array_klass()-&gt;base_element_type()-&gt;print_name_on(st);
 467         } else {
 468           ShouldNotReachHere();
 469         }
 470         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 471         int ndim = cik-&gt;as_array_klass()-&gt;dimension() - 1;
 472         while (ndim-- &gt; 0) {
 473           st-&gt;print(&quot;[]&quot;);
 474         }
<a name="4" id="anc4"></a><span class="line-modified"> 475       } else if (cik-&gt;is_flat_array_klass()) {</span>
<span class="line-modified"> 476         ciKlass* cie = cik-&gt;as_flat_array_klass()-&gt;base_element_klass();</span>
 477         cie-&gt;print_name_on(st);
 478         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 479         int ndim = cik-&gt;as_array_klass()-&gt;dimension() - 1;
 480         while (ndim-- &gt; 0) {
 481           st-&gt;print(&quot;[]&quot;);
 482         }
 483       }
 484       st-&gt;print(&quot;={&quot;);
 485       uint nf = spobj-&gt;n_fields();
 486       if (nf &gt; 0) {
 487         uint first_ind = spobj-&gt;first_index(mcall-&gt;jvms());
 488         Node* fld_node = mcall-&gt;in(first_ind);
 489         ciField* cifield;
 490         if (iklass != NULL) {
 491           st-&gt;print(&quot; [&quot;);
 492           cifield = iklass-&gt;nonstatic_field_at(0);
 493           cifield-&gt;print_name_on(st);
 494           format_helper(regalloc, st, fld_node, &quot;:&quot;, 0, &amp;scobjs);
 495         } else {
 496           format_helper(regalloc, st, fld_node, &quot;[&quot;, 0, &amp;scobjs);
 497         }
 498         for (uint j = 1; j &lt; nf; j++) {
 499           fld_node = mcall-&gt;in(first_ind+j);
 500           if (iklass != NULL) {
 501             st-&gt;print(&quot;, [&quot;);
 502             cifield = iklass-&gt;nonstatic_field_at(j);
 503             cifield-&gt;print_name_on(st);
 504             format_helper(regalloc, st, fld_node, &quot;:&quot;, j, &amp;scobjs);
 505           } else {
 506             format_helper(regalloc, st, fld_node, &quot;, [&quot;, j, &amp;scobjs);
 507           }
 508         }
 509       }
 510       st-&gt;print(&quot; }&quot;);
 511     }
 512   }
 513   st-&gt;cr();
 514   if (caller() != NULL) caller()-&gt;format(regalloc, n, st);
 515 }
 516 
 517 
 518 void JVMState::dump_spec(outputStream *st) const {
 519   if (_method != NULL) {
 520     bool printed = false;
 521     if (!Verbose) {
 522       // The JVMS dumps make really, really long lines.
 523       // Take out the most boring parts, which are the package prefixes.
 524       char buf[500];
 525       stringStream namest(buf, sizeof(buf));
 526       _method-&gt;print_short_name(&amp;namest);
 527       if (namest.count() &lt; sizeof(buf)) {
 528         const char* name = namest.base();
 529         if (name[0] == &#39; &#39;)  ++name;
 530         const char* endcn = strchr(name, &#39;:&#39;);  // end of class name
 531         if (endcn == NULL)  endcn = strchr(name, &#39;(&#39;);
 532         if (endcn == NULL)  endcn = name + strlen(name);
 533         while (endcn &gt; name &amp;&amp; endcn[-1] != &#39;.&#39; &amp;&amp; endcn[-1] != &#39;/&#39;)
 534           --endcn;
 535         st-&gt;print(&quot; %s&quot;, endcn);
 536         printed = true;
 537       }
 538     }
 539     if (!printed)
 540       _method-&gt;print_short_name(st);
 541     st-&gt;print(&quot; @ bci:%d&quot;,_bci);
 542     if(_reexecute == Reexecute_True)
 543       st-&gt;print(&quot; reexecute&quot;);
 544   } else {
 545     st-&gt;print(&quot; runtime stub&quot;);
 546   }
 547   if (caller() != NULL)  caller()-&gt;dump_spec(st);
 548 }
 549 
 550 
 551 void JVMState::dump_on(outputStream* st) const {
 552   bool print_map = _map &amp;&amp; !((uintptr_t)_map &amp; 1) &amp;&amp;
 553                   ((caller() == NULL) || (caller()-&gt;map() != _map));
 554   if (print_map) {
 555     if (_map-&gt;len() &gt; _map-&gt;req()) {  // _map-&gt;has_exceptions()
 556       Node* ex = _map-&gt;in(_map-&gt;req());  // _map-&gt;next_exception()
 557       // skip the first one; it&#39;s already being printed
 558       while (ex != NULL &amp;&amp; ex-&gt;len() &gt; ex-&gt;req()) {
 559         ex = ex-&gt;in(ex-&gt;req());  // ex-&gt;next_exception()
 560         ex-&gt;dump(1);
 561       }
 562     }
 563     _map-&gt;dump(Verbose ? 2 : 1);
 564   }
 565   if (caller() != NULL) {
 566     caller()-&gt;dump_on(st);
 567   }
 568   st-&gt;print(&quot;JVMS depth=%d loc=%d stk=%d arg=%d mon=%d scalar=%d end=%d mondepth=%d sp=%d bci=%d reexecute=%s method=&quot;,
 569              depth(), locoff(), stkoff(), argoff(), monoff(), scloff(), endoff(), monitor_depth(), sp(), bci(), should_reexecute()?&quot;true&quot;:&quot;false&quot;);
 570   if (_method == NULL) {
 571     st-&gt;print_cr(&quot;(none)&quot;);
 572   } else {
 573     _method-&gt;print_name(st);
 574     st-&gt;cr();
 575     if (bci() &gt;= 0 &amp;&amp; bci() &lt; _method-&gt;code_size()) {
 576       st-&gt;print(&quot;    bc: &quot;);
 577       _method-&gt;print_codes_on(bci(), bci()+1, st);
 578     }
 579   }
 580 }
 581 
 582 // Extra way to dump a jvms from the debugger,
 583 // to avoid a bug with C++ member function calls.
 584 void dump_jvms(JVMState* jvms) {
 585   jvms-&gt;dump();
 586 }
 587 #endif
 588 
 589 //--------------------------clone_shallow--------------------------------------
 590 JVMState* JVMState::clone_shallow(Compile* C) const {
 591   JVMState* n = has_method() ? new (C) JVMState(_method, _caller) : new (C) JVMState(0);
 592   n-&gt;set_bci(_bci);
 593   n-&gt;_reexecute = _reexecute;
 594   n-&gt;set_locoff(_locoff);
 595   n-&gt;set_stkoff(_stkoff);
 596   n-&gt;set_monoff(_monoff);
 597   n-&gt;set_scloff(_scloff);
 598   n-&gt;set_endoff(_endoff);
 599   n-&gt;set_sp(_sp);
 600   n-&gt;set_map(_map);
 601   return n;
 602 }
 603 
 604 //---------------------------clone_deep----------------------------------------
 605 JVMState* JVMState::clone_deep(Compile* C) const {
 606   JVMState* n = clone_shallow(C);
 607   for (JVMState* p = n; p-&gt;_caller != NULL; p = p-&gt;_caller) {
 608     p-&gt;_caller = p-&gt;_caller-&gt;clone_shallow(C);
 609   }
 610   assert(n-&gt;depth() == depth(), &quot;sanity&quot;);
 611   assert(n-&gt;debug_depth() == debug_depth(), &quot;sanity&quot;);
 612   return n;
 613 }
 614 
 615 /**
 616  * Reset map for all callers
 617  */
 618 void JVMState::set_map_deep(SafePointNode* map) {
 619   for (JVMState* p = this; p-&gt;_caller != NULL; p = p-&gt;_caller) {
 620     p-&gt;set_map(map);
 621   }
 622 }
 623 
 624 // Adapt offsets in in-array after adding or removing an edge.
 625 // Prerequisite is that the JVMState is used by only one node.
 626 void JVMState::adapt_position(int delta) {
 627   for (JVMState* jvms = this; jvms != NULL; jvms = jvms-&gt;caller()) {
 628     jvms-&gt;set_locoff(jvms-&gt;locoff() + delta);
 629     jvms-&gt;set_stkoff(jvms-&gt;stkoff() + delta);
 630     jvms-&gt;set_monoff(jvms-&gt;monoff() + delta);
 631     jvms-&gt;set_scloff(jvms-&gt;scloff() + delta);
 632     jvms-&gt;set_endoff(jvms-&gt;endoff() + delta);
 633   }
 634 }
 635 
 636 // Mirror the stack size calculation in the deopt code
 637 // How much stack space would we need at this point in the program in
 638 // case of deoptimization?
 639 int JVMState::interpreter_frame_size() const {
 640   const JVMState* jvms = this;
 641   int size = 0;
 642   int callee_parameters = 0;
 643   int callee_locals = 0;
 644   int extra_args = method()-&gt;max_stack() - stk_size();
 645 
 646   while (jvms != NULL) {
 647     int locks = jvms-&gt;nof_monitors();
 648     int temps = jvms-&gt;stk_size();
 649     bool is_top_frame = (jvms == this);
 650     ciMethod* method = jvms-&gt;method();
 651 
 652     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
 653                                                                  temps + callee_parameters,
 654                                                                  extra_args,
 655                                                                  locks,
 656                                                                  callee_parameters,
 657                                                                  callee_locals,
 658                                                                  is_top_frame);
 659     size += frame_size;
 660 
 661     callee_parameters = method-&gt;size_of_parameters();
 662     callee_locals = method-&gt;max_locals();
 663     extra_args = 0;
 664     jvms = jvms-&gt;caller();
 665   }
 666   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
 667 }
 668 
 669 //=============================================================================
 670 bool CallNode::cmp( const Node &amp;n ) const
 671 { return _tf == ((CallNode&amp;)n)._tf &amp;&amp; _jvms == ((CallNode&amp;)n)._jvms; }
 672 #ifndef PRODUCT
 673 void CallNode::dump_req(outputStream *st) const {
 674   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 675   uint i;                       // Exit value of loop
 676   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 677     if (i == TypeFunc::Parms) st-&gt;print(&quot;(&quot;);
 678     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 679     else st-&gt;print(&quot;_ &quot;);
 680   }
 681   st-&gt;print(&quot;)&quot;);
 682 }
 683 
 684 void CallNode::dump_spec(outputStream *st) const {
 685   st-&gt;print(&quot; &quot;);
 686   if (tf() != NULL)  tf()-&gt;dump_on(st);
 687   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
 688   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
 689 }
 690 #endif
 691 
 692 const Type *CallNode::bottom_type() const { return tf()-&gt;range_cc(); }
 693 const Type* CallNode::Value(PhaseGVN* phase) const {
 694   if (!in(0) || phase-&gt;type(in(0)) == Type::TOP) {
 695     return Type::TOP;
 696   }
 697   return tf()-&gt;range_cc();
 698 }
 699 
 700 //------------------------------calling_convention-----------------------------
 701 void CallNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {
 702   if (_entry_point == StubRoutines::store_inline_type_fields_to_buf()) {
 703     // The call to that stub is a special case: its inputs are
 704     // multiple values returned from a call and so it should follow
 705     // the return convention.
 706     SharedRuntime::java_return_convention(sig_bt, parm_regs, argcnt);
 707     return;
 708   }
 709   // Use the standard compiler calling convention
 710   Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );
 711 }
 712 
 713 
 714 //------------------------------match------------------------------------------
 715 // Construct projections for control, I/O, memory-fields, ..., and
 716 // return result(s) along with their RegMask info
 717 Node *CallNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {
 718   uint con = proj-&gt;_con;
 719   const TypeTuple *range_cc = tf()-&gt;range_cc();
 720   if (con &gt;= TypeFunc::Parms) {
 721     if (is_CallRuntime()) {
 722       if (con == TypeFunc::Parms) {
 723         uint ideal_reg = range_cc-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 724         OptoRegPair regs = match-&gt;c_return_value(ideal_reg,true);
 725         RegMask rm = RegMask(regs.first());
 726         if (OptoReg::is_valid(regs.second())) {
 727           rm.Insert(regs.second());
 728         }
 729         return new MachProjNode(this,con,rm,ideal_reg);
 730       } else {
 731         assert(con == TypeFunc::Parms+1, &quot;only one return value&quot;);
 732         assert(range_cc-&gt;field_at(TypeFunc::Parms+1) == Type::HALF, &quot;&quot;);
 733         return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);
 734       }
 735     } else {
 736       // The Call may return multiple values (inline type fields): we
<a name="5" id="anc5"></a><span class="line-modified"> 737       // create one projection per returned value.</span>
 738       assert(con &lt;= TypeFunc::Parms+1 || InlineTypeReturnedAsFields, &quot;only for multi value return&quot;);
 739       uint ideal_reg = range_cc-&gt;field_at(con)-&gt;ideal_reg();
 740       return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);
 741     }
 742   }
 743 
 744   switch (con) {
 745   case TypeFunc::Control:
 746   case TypeFunc::I_O:
 747   case TypeFunc::Memory:
 748     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
 749 
 750   case TypeFunc::ReturnAdr:
 751   case TypeFunc::FramePtr:
 752   default:
 753     ShouldNotReachHere();
 754   }
 755   return NULL;
 756 }
 757 
 758 // Do we Match on this edge index or not?  Match no edges
 759 uint CallNode::match_edge(uint idx) const {
 760   return 0;
 761 }
 762 
 763 //
 764 // Determine whether the call could modify the field of the specified
 765 // instance at the specified offset.
 766 //
 767 bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
 768   assert((t_oop != NULL), &quot;sanity&quot;);
 769   if (is_call_to_arraycopystub() &amp;&amp; strcmp(_name, &quot;unsafe_arraycopy&quot;) != 0) {
 770     const TypeTuple* args = _tf-&gt;domain_sig();
 771     Node* dest = NULL;
 772     // Stubs that can be called once an ArrayCopyNode is expanded have
 773     // different signatures. Look for the second pointer argument,
 774     // that is the destination of the copy.
 775     for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
 776       if (args-&gt;field_at(i)-&gt;isa_ptr()) {
 777         j++;
 778         if (j == 2) {
 779           dest = in(i);
 780           break;
 781         }
 782       }
 783     }
 784     guarantee(dest != NULL, &quot;Call had only one ptr in, broken IR!&quot;);
 785     if (!dest-&gt;is_top() &amp;&amp; may_modify_arraycopy_helper(phase-&gt;type(dest)-&gt;is_oopptr(), t_oop, phase)) {
 786       return true;
 787     }
 788     return false;
 789   }
 790   if (t_oop-&gt;is_known_instance()) {
 791     // The instance_id is set only for scalar-replaceable allocations which
 792     // are not passed as arguments according to Escape Analysis.
 793     return false;
 794   }
 795   if (t_oop-&gt;is_ptr_to_boxed_value()) {
 796     ciKlass* boxing_klass = t_oop-&gt;klass();
 797     if (is_CallStaticJava() &amp;&amp; as_CallStaticJava()-&gt;is_boxing_method()) {
 798       // Skip unrelated boxing methods.
 799       Node* proj = proj_out_or_null(TypeFunc::Parms);
 800       if ((proj == NULL) || (phase-&gt;type(proj)-&gt;is_instptr()-&gt;klass() != boxing_klass)) {
 801         return false;
 802       }
 803     }
 804     if (is_CallJava() &amp;&amp; as_CallJava()-&gt;method() != NULL) {
 805       ciMethod* meth = as_CallJava()-&gt;method();
 806       if (meth-&gt;is_getter()) {
 807         return false;
 808       }
 809       // May modify (by reflection) if an boxing object is passed
 810       // as argument or returned.
 811       Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : NULL;
 812       if (proj != NULL) {
 813         const TypeInstPtr* inst_t = phase-&gt;type(proj)-&gt;isa_instptr();
 814         if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
 815                                  (inst_t-&gt;klass() == boxing_klass))) {
 816           return true;
 817         }
 818       }
 819       const TypeTuple* d = tf()-&gt;domain_cc();
 820       for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 821         const TypeInstPtr* inst_t = d-&gt;field_at(i)-&gt;isa_instptr();
 822         if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
 823                                  (inst_t-&gt;klass() == boxing_klass))) {
 824           return true;
 825         }
 826       }
 827       return false;
 828     }
 829   }
 830   return true;
 831 }
 832 
 833 // Does this call have a direct reference to n other than debug information?
 834 bool CallNode::has_non_debug_use(Node *n) {
 835   const TypeTuple * d = tf()-&gt;domain_cc();
 836   for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 837     Node *arg = in(i);
 838     if (arg == n) {
 839       return true;
 840     }
 841   }
 842   return false;
 843 }
 844 
 845 bool CallNode::has_debug_use(Node *n) {
 846   assert(jvms() != NULL, &quot;jvms should not be null&quot;);
 847   for (uint i = jvms()-&gt;debug_start(); i &lt; jvms()-&gt;debug_end(); i++) {
 848     Node *arg = in(i);
 849     if (arg == n) {
 850       return true;
 851     }
 852   }
 853   return false;
 854 }
 855 
 856 // Returns the unique CheckCastPP of a call
 857 // or &#39;this&#39; if there are several CheckCastPP or unexpected uses
 858 // or returns NULL if there is no one.
 859 Node *CallNode::result_cast() {
 860   Node *cast = NULL;
 861 
 862   Node *p = proj_out_or_null(TypeFunc::Parms);
 863   if (p == NULL)
 864     return NULL;
 865 
 866   for (DUIterator_Fast imax, i = p-&gt;fast_outs(imax); i &lt; imax; i++) {
 867     Node *use = p-&gt;fast_out(i);
 868     if (use-&gt;is_CheckCastPP()) {
 869       if (cast != NULL) {
 870         return this;  // more than 1 CheckCastPP
 871       }
 872       cast = use;
 873     } else if (!use-&gt;is_Initialize() &amp;&amp;
 874                !use-&gt;is_AddP() &amp;&amp;
 875                use-&gt;Opcode() != Op_MemBarStoreStore) {
 876       // Expected uses are restricted to a CheckCastPP, an Initialize
 877       // node, a MemBarStoreStore (clone) and AddP nodes. If we
 878       // encounter any other use (a Phi node can be seen in rare
 879       // cases) return this to prevent incorrect optimizations.
 880       return this;
 881     }
 882   }
 883   return cast;
 884 }
 885 
 886 
 887 CallProjections* CallNode::extract_projections(bool separate_io_proj, bool do_asserts) {
 888   uint max_res = TypeFunc::Parms-1;
 889   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 890     ProjNode *pn = fast_out(i)-&gt;as_Proj();
 891     max_res = MAX2(max_res, pn-&gt;_con);
 892   }
 893 
 894   assert(max_res &lt; _tf-&gt;range_cc()-&gt;cnt(), &quot;result out of bounds&quot;);
 895 
 896   uint projs_size = sizeof(CallProjections);
 897   if (max_res &gt; TypeFunc::Parms) {
 898     projs_size += (max_res-TypeFunc::Parms)*sizeof(Node*);
 899   }
 900   char* projs_storage = resource_allocate_bytes(projs_size);
 901   CallProjections* projs = new(projs_storage)CallProjections(max_res - TypeFunc::Parms + 1);
 902 
 903   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 904     ProjNode *pn = fast_out(i)-&gt;as_Proj();
 905     if (pn-&gt;outcnt() == 0) continue;
 906     switch (pn-&gt;_con) {
 907     case TypeFunc::Control:
 908       {
 909         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 910         projs-&gt;fallthrough_proj = pn;
 911         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 912         const Node *cn = pn-&gt;fast_out(j);
 913         if (cn-&gt;is_Catch()) {
 914           ProjNode *cpn = NULL;
 915           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 916             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 917             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 918             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 919               projs-&gt;fallthrough_catchproj = cpn;
 920             else {
 921               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 922               projs-&gt;catchall_catchproj = cpn;
 923             }
 924           }
 925         }
 926         break;
 927       }
 928     case TypeFunc::I_O:
 929       if (pn-&gt;_is_io_use)
 930         projs-&gt;catchall_ioproj = pn;
 931       else
 932         projs-&gt;fallthrough_ioproj = pn;
 933       for (DUIterator j = pn-&gt;outs(); pn-&gt;has_out(j); j++) {
 934         Node* e = pn-&gt;out(j);
 935         if (e-&gt;Opcode() == Op_CreateEx &amp;&amp; e-&gt;in(0)-&gt;is_CatchProj() &amp;&amp; e-&gt;outcnt() &gt; 0) {
 936           assert(projs-&gt;exobj == NULL, &quot;only one&quot;);
 937           projs-&gt;exobj = e;
 938         }
 939       }
 940       break;
 941     case TypeFunc::Memory:
 942       if (pn-&gt;_is_io_use)
 943         projs-&gt;catchall_memproj = pn;
 944       else
 945         projs-&gt;fallthrough_memproj = pn;
 946       break;
 947     case TypeFunc::Parms:
 948       projs-&gt;resproj[0] = pn;
 949       break;
 950     default:
 951       assert(pn-&gt;_con &lt;= max_res, &quot;unexpected projection from allocation node.&quot;);
 952       projs-&gt;resproj[pn-&gt;_con-TypeFunc::Parms] = pn;
 953       break;
 954     }
 955   }
 956 
 957   // The resproj may not exist because the result could be ignored
 958   // and the exception object may not exist if an exception handler
 959   // swallows the exception but all the other must exist and be found.
 960   do_asserts = do_asserts &amp;&amp; !Compile::current()-&gt;inlining_incrementally();
 961   assert(!do_asserts || projs-&gt;fallthrough_proj      != NULL, &quot;must be found&quot;);
 962   assert(!do_asserts || projs-&gt;fallthrough_catchproj != NULL, &quot;must be found&quot;);
 963   assert(!do_asserts || projs-&gt;fallthrough_memproj   != NULL, &quot;must be found&quot;);
 964   assert(!do_asserts || projs-&gt;fallthrough_ioproj    != NULL, &quot;must be found&quot;);
 965   assert(!do_asserts || projs-&gt;catchall_catchproj    != NULL, &quot;must be found&quot;);
 966   if (separate_io_proj) {
 967     assert(!do_asserts || projs-&gt;catchall_memproj    != NULL, &quot;must be found&quot;);
 968     assert(!do_asserts || projs-&gt;catchall_ioproj     != NULL, &quot;must be found&quot;);
 969   }
 970   return projs;
 971 }
 972 
 973 Node *CallNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 974   CallGenerator* cg = generator();
 975   if (can_reshape &amp;&amp; cg != NULL &amp;&amp; cg-&gt;is_mh_late_inline() &amp;&amp; !cg-&gt;already_attempted()) {
 976     // Check whether this MH handle call becomes a candidate for inlining
 977     ciMethod* callee = cg-&gt;method();
 978     vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
 979     if (iid == vmIntrinsics::_invokeBasic) {
 980       if (in(TypeFunc::Parms)-&gt;Opcode() == Op_ConP) {
 981         phase-&gt;C-&gt;prepend_late_inline(cg);
 982         set_generator(NULL);
 983       }
 984     } else {
 985       assert(callee-&gt;has_member_arg(), &quot;wrong type of call?&quot;);
 986       if (in(TypeFunc::Parms + callee-&gt;arg_size() - 1)-&gt;Opcode() == Op_ConP) {
 987         phase-&gt;C-&gt;prepend_late_inline(cg);
 988         set_generator(NULL);
 989       }
 990     }
 991   }
 992   return SafePointNode::Ideal(phase, can_reshape);
 993 }
 994 
 995 bool CallNode::is_call_to_arraycopystub() const {
 996   if (_name != NULL &amp;&amp; strstr(_name, &quot;arraycopy&quot;) != 0) {
 997     return true;
 998   }
 999   return false;
1000 }
1001 
1002 //=============================================================================
1003 uint CallJavaNode::size_of() const { return sizeof(*this); }
1004 bool CallJavaNode::cmp( const Node &amp;n ) const {
1005   CallJavaNode &amp;call = (CallJavaNode&amp;)n;
1006   return CallNode::cmp(call) &amp;&amp; _method == call._method &amp;&amp;
1007          _override_symbolic_info == call._override_symbolic_info;
1008 }
1009 
1010 void CallJavaNode::copy_call_debug_info(PhaseIterGVN* phase, CallNode *oldcall) {
1011   // Copy debug information and adjust JVMState information
1012   uint old_dbg_start = oldcall-&gt;tf()-&gt;domain_sig()-&gt;cnt();
1013   uint new_dbg_start = tf()-&gt;domain_sig()-&gt;cnt();
1014   int jvms_adj  = new_dbg_start - old_dbg_start;
1015   assert (new_dbg_start == req(), &quot;argument count mismatch&quot;);
1016   Compile* C = phase-&gt;C;
1017 
1018   // SafePointScalarObject node could be referenced several times in debug info.
1019   // Use Dict to record cloned nodes.
1020   Dict* sosn_map = new Dict(cmpkey,hashkey);
1021   for (uint i = old_dbg_start; i &lt; oldcall-&gt;req(); i++) {
1022     Node* old_in = oldcall-&gt;in(i);
1023     // Clone old SafePointScalarObjectNodes, adjusting their field contents.
1024     if (old_in != NULL &amp;&amp; old_in-&gt;is_SafePointScalarObject()) {
1025       SafePointScalarObjectNode* old_sosn = old_in-&gt;as_SafePointScalarObject();
1026       uint old_unique = C-&gt;unique();
1027       Node* new_in = old_sosn-&gt;clone(sosn_map);
1028       if (old_unique != C-&gt;unique()) { // New node?
1029         new_in-&gt;set_req(0, C-&gt;root()); // reset control edge
1030         new_in = phase-&gt;transform(new_in); // Register new node.
1031       }
1032       old_in = new_in;
1033     }
1034     add_req(old_in);
1035   }
1036 
1037   // JVMS may be shared so clone it before we modify it
1038   set_jvms(oldcall-&gt;jvms() != NULL ? oldcall-&gt;jvms()-&gt;clone_deep(C) : NULL);
1039   for (JVMState *jvms = this-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
1040     jvms-&gt;set_map(this);
1041     jvms-&gt;set_locoff(jvms-&gt;locoff()+jvms_adj);
1042     jvms-&gt;set_stkoff(jvms-&gt;stkoff()+jvms_adj);
1043     jvms-&gt;set_monoff(jvms-&gt;monoff()+jvms_adj);
1044     jvms-&gt;set_scloff(jvms-&gt;scloff()+jvms_adj);
1045     jvms-&gt;set_endoff(jvms-&gt;endoff()+jvms_adj);
1046   }
1047 }
1048 
1049 #ifdef ASSERT
1050 bool CallJavaNode::validate_symbolic_info() const {
1051   if (method() == NULL) {
1052     return true; // call into runtime or uncommon trap
1053   }
1054   Bytecodes::Code bc = jvms()-&gt;method()-&gt;java_code_at_bci(_bci);
1055   if (EnableValhalla &amp;&amp; (bc == Bytecodes::_if_acmpeq || bc == Bytecodes::_if_acmpne)) {
1056     return true;
1057   }
1058   ciMethod* symbolic_info = jvms()-&gt;method()-&gt;get_method_at_bci(_bci);
1059   ciMethod* callee = method();
1060   if (symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !callee-&gt;is_method_handle_intrinsic()) {
1061     assert(override_symbolic_info(), &quot;should be set&quot;);
1062   }
1063   assert(ciMethod::is_consistent_info(symbolic_info, callee), &quot;inconsistent info&quot;);
1064   return true;
1065 }
1066 #endif
1067 
1068 #ifndef PRODUCT
1069 void CallJavaNode::dump_spec(outputStream *st) const {
1070   if( _method ) _method-&gt;print_short_name(st);
1071   CallNode::dump_spec(st);
1072 }
1073 
1074 void CallJavaNode::dump_compact_spec(outputStream* st) const {
1075   if (_method) {
1076     _method-&gt;print_short_name(st);
1077   } else {
1078     st-&gt;print(&quot;&lt;?&gt;&quot;);
1079   }
1080 }
1081 #endif
1082 
1083 //=============================================================================
1084 uint CallStaticJavaNode::size_of() const { return sizeof(*this); }
1085 bool CallStaticJavaNode::cmp( const Node &amp;n ) const {
1086   CallStaticJavaNode &amp;call = (CallStaticJavaNode&amp;)n;
1087   return CallJavaNode::cmp(call);
1088 }
1089 
1090 //----------------------------uncommon_trap_request----------------------------
1091 // If this is an uncommon trap, return the request code, else zero.
1092 int CallStaticJavaNode::uncommon_trap_request() const {
1093   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
1094     return extract_uncommon_trap_request(this);
1095   }
1096   return 0;
1097 }
1098 int CallStaticJavaNode::extract_uncommon_trap_request(const Node* call) {
1099 #ifndef PRODUCT
1100   if (!(call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
1101         call-&gt;in(TypeFunc::Parms) != NULL &amp;&amp;
1102         call-&gt;in(TypeFunc::Parms)-&gt;is_Con() &amp;&amp;
1103         call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;isa_int())) {
1104     assert(in_dump() != 0, &quot;OK if dumping&quot;);
1105     tty-&gt;print(&quot;[bad uncommon trap]&quot;);
1106     return 0;
1107   }
1108 #endif
1109   return call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
1110 }
1111 
1112 bool CallStaticJavaNode::remove_useless_allocation(PhaseGVN *phase, Node* ctl, Node* mem, Node* unc_arg) {
1113   // Split if can cause the flattened array branch of an array load to
1114   // end in an uncommon trap. In that case, the allocation of the
1115   // loaded value and its initialization is useless. Eliminate it. use
1116   // the jvm state of the allocation to create a new uncommon trap
1117   // call at the load.
1118   if (ctl == NULL || ctl-&gt;is_top() || mem == NULL || mem-&gt;is_top() || !mem-&gt;is_MergeMem()) {
1119     return false;
1120   }
1121   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1122   if (ctl-&gt;is_Region()) {
1123     bool res = false;
1124     for (uint i = 1; i &lt; ctl-&gt;req(); i++) {
1125       MergeMemNode* mm = mem-&gt;clone()-&gt;as_MergeMem();
1126       for (MergeMemStream mms(mm); mms.next_non_empty(); ) {
1127         Node* m = mms.memory();
1128         if (m-&gt;is_Phi() &amp;&amp; m-&gt;in(0) == ctl) {
1129           mms.set_memory(m-&gt;in(i));
1130         }
1131       }
1132       if (remove_useless_allocation(phase, ctl-&gt;in(i), mm, unc_arg)) {
1133         res = true;
1134         if (!ctl-&gt;in(i)-&gt;is_Region()) {
1135           igvn-&gt;replace_input_of(ctl, i, phase-&gt;C-&gt;top());
1136         }
1137       }
1138       igvn-&gt;remove_dead_node(mm);
1139     }
1140     return res;
1141   }
1142   // verify the control flow is ok
1143   Node* c = ctl;
1144   Node* copy = NULL;
1145   Node* alloc = NULL;
1146   for (;;) {
1147     if (c == NULL || c-&gt;is_top()) {
1148       return false;
1149     }
1150     if (c-&gt;is_Proj() || c-&gt;is_Catch() || c-&gt;is_MemBar()) {
1151       c = c-&gt;in(0);
1152     } else if (c-&gt;Opcode() == Op_CallLeaf &amp;&amp;
<a name="6" id="anc6"></a><span class="line-modified">1153                c-&gt;as_Call()-&gt;entry_point() == CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_inline)) {</span>
1154       copy = c;
1155       c = c-&gt;in(0);
1156     } else if (c-&gt;is_Allocate()) {
1157       Node* new_obj = c-&gt;as_Allocate()-&gt;result_cast();
1158       if (copy == NULL || new_obj == NULL) {
1159         return false;
1160       }
1161       Node* copy_dest = copy-&gt;in(TypeFunc::Parms + 2);
1162       if (copy_dest != new_obj) {
1163         return false;
1164       }
1165       alloc = c;
1166       break;
1167     } else {
1168       return false;
1169     }
1170   }
1171 
1172   JVMState* jvms = alloc-&gt;jvms();
1173   if (phase-&gt;C-&gt;too_many_traps(jvms-&gt;method(), jvms-&gt;bci(), Deoptimization::trap_request_reason(uncommon_trap_request()))) {
1174     return false;
1175   }
1176 
1177   Node* alloc_mem = alloc-&gt;in(TypeFunc::Memory);
1178   if (alloc_mem == NULL || alloc_mem-&gt;is_top()) {
1179     return false;
1180   }
1181   if (!alloc_mem-&gt;is_MergeMem()) {
1182     alloc_mem = MergeMemNode::make(alloc_mem);
1183   }
1184 
1185   // and that there&#39;s no unexpected side effect
1186   for (MergeMemStream mms2(mem-&gt;as_MergeMem(), alloc_mem-&gt;as_MergeMem()); mms2.next_non_empty2(); ) {
1187     Node* m1 = mms2.is_empty() ? mms2.base_memory() : mms2.memory();
1188     Node* m2 = mms2.memory2();
1189 
1190     for (uint i = 0; i &lt; 100; i++) {
1191       if (m1 == m2) {
1192         break;
1193       } else if (m1-&gt;is_Proj()) {
1194         m1 = m1-&gt;in(0);
1195       } else if (m1-&gt;is_MemBar()) {
1196         m1 = m1-&gt;in(TypeFunc::Memory);
1197       } else if (m1-&gt;Opcode() == Op_CallLeaf &amp;&amp;
<a name="7" id="anc7"></a><span class="line-modified">1198                  m1-&gt;as_Call()-&gt;entry_point() == CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_inline)) {</span>
1199         if (m1 != copy) {
1200           return false;
1201         }
1202         m1 = m1-&gt;in(TypeFunc::Memory);
1203       } else if (m1-&gt;is_Allocate()) {
1204         if (m1 != alloc) {
1205           return false;
1206         }
1207         break;
1208       } else if (m1-&gt;is_MergeMem()) {
1209         MergeMemNode* mm = m1-&gt;as_MergeMem();
1210         int idx = mms2.alias_idx();
1211         if (idx == Compile::AliasIdxBot) {
1212           m1 = mm-&gt;base_memory();
1213         } else {
1214           m1 = mm-&gt;memory_at(idx);
1215         }
1216       } else {
1217         return false;
1218       }
1219     }
1220   }
1221   if (alloc_mem-&gt;outcnt() == 0) {
1222     igvn-&gt;remove_dead_node(alloc_mem);
1223   }
1224 
1225   address call_addr = SharedRuntime::uncommon_trap_blob()-&gt;entry_point();
1226   CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, &quot;uncommon_trap&quot;,
1227                                          jvms-&gt;bci(), NULL);
1228   unc-&gt;init_req(TypeFunc::Control, alloc-&gt;in(0));
1229   unc-&gt;init_req(TypeFunc::I_O, alloc-&gt;in(TypeFunc::I_O));
1230   unc-&gt;init_req(TypeFunc::Memory, alloc-&gt;in(TypeFunc::Memory));
1231   unc-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));
1232   unc-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1233   unc-&gt;init_req(TypeFunc::Parms+0, unc_arg);
1234   unc-&gt;set_cnt(PROB_UNLIKELY_MAG(4));
1235   unc-&gt;copy_call_debug_info(igvn, alloc-&gt;as_Allocate());
1236 
1237   igvn-&gt;replace_input_of(alloc, 0, phase-&gt;C-&gt;top());
1238 
1239   igvn-&gt;register_new_node_with_optimizer(unc);
1240 
1241   Node* ctrl = phase-&gt;transform(new ProjNode(unc, TypeFunc::Control));
1242   Node* halt = phase-&gt;transform(new HaltNode(ctrl, alloc-&gt;in(TypeFunc::FramePtr), &quot;uncommon trap returned which should never happen&quot;));
1243   phase-&gt;C-&gt;root()-&gt;add_req(halt);
1244 
1245   return true;
1246 }
1247 
1248 
1249 Node* CallStaticJavaNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1250   if (can_reshape &amp;&amp; uncommon_trap_request() != 0) {
1251     if (remove_useless_allocation(phase, in(0), in(TypeFunc::Memory), in(TypeFunc::Parms))) {
1252       if (!in(0)-&gt;is_Region()) {
1253         PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1254         igvn-&gt;replace_input_of(this, 0, phase-&gt;C-&gt;top());
1255       }
1256       return this;
1257     }
1258   }
1259   return CallNode::Ideal(phase, can_reshape);
1260 }
1261 
1262 
1263 #ifndef PRODUCT
1264 void CallStaticJavaNode::dump_spec(outputStream *st) const {
1265   st-&gt;print(&quot;# Static &quot;);
1266   if (_name != NULL) {
1267     st-&gt;print(&quot;%s&quot;, _name);
1268     int trap_req = uncommon_trap_request();
1269     if (trap_req != 0) {
1270       char buf[100];
1271       st-&gt;print(&quot;(%s)&quot;,
1272                  Deoptimization::format_trap_request(buf, sizeof(buf),
1273                                                      trap_req));
1274     }
1275     st-&gt;print(&quot; &quot;);
1276   }
1277   CallJavaNode::dump_spec(st);
1278 }
1279 
1280 void CallStaticJavaNode::dump_compact_spec(outputStream* st) const {
1281   if (_method) {
1282     _method-&gt;print_short_name(st);
1283   } else if (_name) {
1284     st-&gt;print(&quot;%s&quot;, _name);
1285   } else {
1286     st-&gt;print(&quot;&lt;?&gt;&quot;);
1287   }
1288 }
1289 #endif
1290 
1291 //=============================================================================
1292 uint CallDynamicJavaNode::size_of() const { return sizeof(*this); }
1293 bool CallDynamicJavaNode::cmp( const Node &amp;n ) const {
1294   CallDynamicJavaNode &amp;call = (CallDynamicJavaNode&amp;)n;
1295   return CallJavaNode::cmp(call);
1296 }
1297 #ifndef PRODUCT
1298 void CallDynamicJavaNode::dump_spec(outputStream *st) const {
1299   st-&gt;print(&quot;# Dynamic &quot;);
1300   CallJavaNode::dump_spec(st);
1301 }
1302 #endif
1303 
1304 //=============================================================================
1305 uint CallRuntimeNode::size_of() const { return sizeof(*this); }
1306 bool CallRuntimeNode::cmp( const Node &amp;n ) const {
1307   CallRuntimeNode &amp;call = (CallRuntimeNode&amp;)n;
1308   return CallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
1309 }
1310 #ifndef PRODUCT
1311 void CallRuntimeNode::dump_spec(outputStream *st) const {
1312   st-&gt;print(&quot;# &quot;);
1313   st-&gt;print(&quot;%s&quot;, _name);
1314   CallNode::dump_spec(st);
1315 }
1316 #endif
1317 
1318 //------------------------------calling_convention-----------------------------
1319 void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
1320   if (_entry_point == NULL) {
1321     // The call to that stub is a special case: its inputs are
1322     // multiple values returned from a call and so it should follow
1323     // the return convention.
1324     SharedRuntime::java_return_convention(sig_bt, parm_regs, argcnt);
1325     return;
1326   }
1327   Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );
1328 }
1329 
1330 //=============================================================================
1331 //------------------------------calling_convention-----------------------------
1332 
1333 
1334 //=============================================================================
1335 #ifndef PRODUCT
1336 void CallLeafNode::dump_spec(outputStream *st) const {
1337   st-&gt;print(&quot;# &quot;);
1338   st-&gt;print(&quot;%s&quot;, _name);
1339   CallNode::dump_spec(st);
1340 }
1341 #endif
1342 
1343 uint CallLeafNoFPNode::match_edge(uint idx) const {
1344   // Null entry point is a special case for which the target is in a
1345   // register. Need to match that edge.
1346   return entry_point() == NULL &amp;&amp; idx == TypeFunc::Parms;
1347 }
1348 
1349 //=============================================================================
1350 
1351 void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {
1352   assert(verify_jvms(jvms), &quot;jvms must match&quot;);
1353   int loc = jvms-&gt;locoff() + idx;
1354   if (in(loc)-&gt;is_top() &amp;&amp; idx &gt; 0 &amp;&amp; !c-&gt;is_top() ) {
1355     // If current local idx is top then local idx - 1 could
1356     // be a long/double that needs to be killed since top could
1357     // represent the 2nd half ofthe long/double.
1358     uint ideal = in(loc -1)-&gt;ideal_reg();
1359     if (ideal == Op_RegD || ideal == Op_RegL) {
1360       // set other (low index) half to top
1361       set_req(loc - 1, in(loc));
1362     }
1363   }
1364   set_req(loc, c);
1365 }
1366 
1367 uint SafePointNode::size_of() const { return sizeof(*this); }
1368 bool SafePointNode::cmp( const Node &amp;n ) const {
1369   return (&amp;n == this);          // Always fail except on self
1370 }
1371 
1372 //-------------------------set_next_exception----------------------------------
1373 void SafePointNode::set_next_exception(SafePointNode* n) {
1374   assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;correct value for next_exception&quot;);
1375   if (len() == req()) {
1376     if (n != NULL)  add_prec(n);
1377   } else {
1378     set_prec(req(), n);
1379   }
1380 }
1381 
1382 
1383 //----------------------------next_exception-----------------------------------
1384 SafePointNode* SafePointNode::next_exception() const {
1385   if (len() == req()) {
1386     return NULL;
1387   } else {
1388     Node* n = in(req());
1389     assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;no other uses of prec edges&quot;);
1390     return (SafePointNode*) n;
1391   }
1392 }
1393 
1394 
1395 //------------------------------Ideal------------------------------------------
1396 // Skip over any collapsed Regions
1397 Node *SafePointNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1398   return remove_dead_region(phase, can_reshape) ? this : NULL;
1399 }
1400 
1401 //------------------------------Identity---------------------------------------
1402 // Remove obviously duplicate safepoints
1403 Node* SafePointNode::Identity(PhaseGVN* phase) {
1404 
1405   // If you have back to back safepoints, remove one
1406   if( in(TypeFunc::Control)-&gt;is_SafePoint() )
1407     return in(TypeFunc::Control);
1408 
1409   if( in(0)-&gt;is_Proj() ) {
1410     Node *n0 = in(0)-&gt;in(0);
1411     // Check if he is a call projection (except Leaf Call)
1412     if( n0-&gt;is_Catch() ) {
1413       n0 = n0-&gt;in(0)-&gt;in(0);
1414       assert( n0-&gt;is_Call(), &quot;expect a call here&quot; );
1415     }
1416     if( n0-&gt;is_Call() &amp;&amp; n0-&gt;as_Call()-&gt;guaranteed_safepoint() ) {
1417       // Don&#39;t remove a safepoint belonging to an OuterStripMinedLoopEndNode.
1418       // If the loop dies, they will be removed together.
1419       if (has_out_with(Op_OuterStripMinedLoopEnd)) {
1420         return this;
1421       }
1422       // Useless Safepoint, so remove it
1423       return in(TypeFunc::Control);
1424     }
1425   }
1426 
1427   return this;
1428 }
1429 
1430 //------------------------------Value------------------------------------------
1431 const Type* SafePointNode::Value(PhaseGVN* phase) const {
1432   if( phase-&gt;type(in(0)) == Type::TOP ) return Type::TOP;
1433   if( phase-&gt;eqv( in(0), this ) ) return Type::TOP; // Dead infinite loop
1434   return Type::CONTROL;
1435 }
1436 
1437 #ifndef PRODUCT
1438 void SafePointNode::dump_spec(outputStream *st) const {
1439   st-&gt;print(&quot; SafePoint &quot;);
1440   _replaced_nodes.dump(st);
1441 }
1442 
1443 // The related nodes of a SafepointNode are all data inputs, excluding the
1444 // control boundary, as well as all outputs till level 2 (to include projection
1445 // nodes and targets). In compact mode, just include inputs till level 1 and
1446 // outputs as before.
1447 void SafePointNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1448   if (compact) {
1449     this-&gt;collect_nodes(in_rel, 1, false, false);
1450   } else {
1451     this-&gt;collect_nodes_in_all_data(in_rel, false);
1452   }
1453   this-&gt;collect_nodes(out_rel, -2, false, false);
1454 }
1455 #endif
1456 
1457 const RegMask &amp;SafePointNode::in_RegMask(uint idx) const {
1458   if( idx &lt; TypeFunc::Parms ) return RegMask::Empty;
1459   // Values outside the domain represent debug info
1460   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1461 }
1462 const RegMask &amp;SafePointNode::out_RegMask() const {
1463   return RegMask::Empty;
1464 }
1465 
1466 
1467 void SafePointNode::grow_stack(JVMState* jvms, uint grow_by) {
1468   assert((int)grow_by &gt; 0, &quot;sanity&quot;);
1469   int monoff = jvms-&gt;monoff();
1470   int scloff = jvms-&gt;scloff();
1471   int endoff = jvms-&gt;endoff();
1472   assert(endoff == (int)req(), &quot;no other states or debug info after me&quot;);
1473   Node* top = Compile::current()-&gt;top();
1474   for (uint i = 0; i &lt; grow_by; i++) {
1475     ins_req(monoff, top);
1476   }
1477   jvms-&gt;set_monoff(monoff + grow_by);
1478   jvms-&gt;set_scloff(scloff + grow_by);
1479   jvms-&gt;set_endoff(endoff + grow_by);
1480 }
1481 
1482 void SafePointNode::push_monitor(const FastLockNode *lock) {
1483   // Add a LockNode, which points to both the original BoxLockNode (the
1484   // stack space for the monitor) and the Object being locked.
1485   const int MonitorEdges = 2;
1486   assert(JVMState::logMonitorEdges == exact_log2(MonitorEdges), &quot;correct MonitorEdges&quot;);
1487   assert(req() == jvms()-&gt;endoff(), &quot;correct sizing&quot;);
1488   int nextmon = jvms()-&gt;scloff();
1489   if (GenerateSynchronizationCode) {
1490     ins_req(nextmon,   lock-&gt;box_node());
1491     ins_req(nextmon+1, lock-&gt;obj_node());
1492   } else {
1493     Node* top = Compile::current()-&gt;top();
1494     ins_req(nextmon, top);
1495     ins_req(nextmon, top);
1496   }
1497   jvms()-&gt;set_scloff(nextmon + MonitorEdges);
1498   jvms()-&gt;set_endoff(req());
1499 }
1500 
1501 void SafePointNode::pop_monitor() {
1502   // Delete last monitor from debug info
1503   debug_only(int num_before_pop = jvms()-&gt;nof_monitors());
1504   const int MonitorEdges = 2;
1505   assert(JVMState::logMonitorEdges == exact_log2(MonitorEdges), &quot;correct MonitorEdges&quot;);
1506   int scloff = jvms()-&gt;scloff();
1507   int endoff = jvms()-&gt;endoff();
1508   int new_scloff = scloff - MonitorEdges;
1509   int new_endoff = endoff - MonitorEdges;
1510   jvms()-&gt;set_scloff(new_scloff);
1511   jvms()-&gt;set_endoff(new_endoff);
1512   while (scloff &gt; new_scloff)  del_req_ordered(--scloff);
1513   assert(jvms()-&gt;nof_monitors() == num_before_pop-1, &quot;&quot;);
1514 }
1515 
1516 Node *SafePointNode::peek_monitor_box() const {
1517   int mon = jvms()-&gt;nof_monitors() - 1;
1518   assert(mon &gt;= 0, &quot;must have a monitor&quot;);
1519   return monitor_box(jvms(), mon);
1520 }
1521 
1522 Node *SafePointNode::peek_monitor_obj() const {
1523   int mon = jvms()-&gt;nof_monitors() - 1;
1524   assert(mon &gt;= 0, &quot;must have a monitor&quot;);
1525   return monitor_obj(jvms(), mon);
1526 }
1527 
1528 // Do we Match on this edge index or not?  Match no edges
1529 uint SafePointNode::match_edge(uint idx) const {
1530   return (TypeFunc::Parms == idx);
1531 }
1532 
1533 void SafePointNode::disconnect_from_root(PhaseIterGVN *igvn) {
1534   assert(Opcode() == Op_SafePoint, &quot;only value for safepoint in loops&quot;);
1535   int nb = igvn-&gt;C-&gt;root()-&gt;find_prec_edge(this);
1536   if (nb != -1) {
1537     igvn-&gt;C-&gt;root()-&gt;rm_prec(nb);
1538   }
1539 }
1540 
1541 //==============  SafePointScalarObjectNode  ==============
1542 
1543 SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,
1544 #ifdef ASSERT
1545                                                      AllocateNode* alloc,
1546 #endif
1547                                                      uint first_index,
1548                                                      uint n_fields) :
1549   TypeNode(tp, 1), // 1 control input -- seems required.  Get from root.
1550   _first_index(first_index),
1551   _n_fields(n_fields)
1552 #ifdef ASSERT
1553   , _alloc(alloc)
1554 #endif
1555 {
1556   init_class_id(Class_SafePointScalarObject);
1557 }
1558 
1559 // Do not allow value-numbering for SafePointScalarObject node.
1560 uint SafePointScalarObjectNode::hash() const { return NO_HASH; }
1561 bool SafePointScalarObjectNode::cmp( const Node &amp;n ) const {
1562   return (&amp;n == this); // Always fail except on self
1563 }
1564 
1565 uint SafePointScalarObjectNode::ideal_reg() const {
1566   return 0; // No matching to machine instruction
1567 }
1568 
1569 const RegMask &amp;SafePointScalarObjectNode::in_RegMask(uint idx) const {
1570   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1571 }
1572 
1573 const RegMask &amp;SafePointScalarObjectNode::out_RegMask() const {
1574   return RegMask::Empty;
1575 }
1576 
1577 uint SafePointScalarObjectNode::match_edge(uint idx) const {
1578   return 0;
1579 }
1580 
1581 SafePointScalarObjectNode*
1582 SafePointScalarObjectNode::clone(Dict* sosn_map) const {
1583   void* cached = (*sosn_map)[(void*)this];
1584   if (cached != NULL) {
1585     return (SafePointScalarObjectNode*)cached;
1586   }
1587   SafePointScalarObjectNode* res = (SafePointScalarObjectNode*)Node::clone();
1588   sosn_map-&gt;Insert((void*)this, (void*)res);
1589   return res;
1590 }
1591 
1592 
1593 #ifndef PRODUCT
1594 void SafePointScalarObjectNode::dump_spec(outputStream *st) const {
1595   st-&gt;print(&quot; # fields@[%d..%d]&quot;, first_index(),
1596              first_index() + n_fields() - 1);
1597 }
1598 
1599 #endif
1600 
1601 //=============================================================================
1602 uint AllocateNode::size_of() const { return sizeof(*this); }
1603 
1604 AllocateNode::AllocateNode(Compile* C, const TypeFunc *atype,
1605                            Node *ctrl, Node *mem, Node *abio,
1606                            Node *size, Node *klass_node,
1607                            Node* initial_test,
<a name="8" id="anc8"></a><span class="line-modified">1608                            InlineTypeBaseNode* inline_type_node)</span>
1609   : CallNode(atype, NULL, TypeRawPtr::BOTTOM)
1610 {
1611   init_class_id(Class_Allocate);
1612   init_flags(Flag_is_macro);
1613   _is_scalar_replaceable = false;
1614   _is_non_escaping = false;
1615   _is_allocation_MemBar_redundant = false;
1616   _larval = false;
1617   Node *topnode = C-&gt;top();
1618 
1619   init_req( TypeFunc::Control  , ctrl );
1620   init_req( TypeFunc::I_O      , abio );
1621   init_req( TypeFunc::Memory   , mem );
1622   init_req( TypeFunc::ReturnAdr, topnode );
1623   init_req( TypeFunc::FramePtr , topnode );
1624   init_req( AllocSize          , size);
1625   init_req( KlassNode          , klass_node);
1626   init_req( InitialTest        , initial_test);
1627   init_req( ALength            , topnode);
<a name="9" id="anc9"></a><span class="line-modified">1628   init_req( InlineTypeNode     , inline_type_node);</span>
1629   // DefaultValue defaults to NULL
1630   // RawDefaultValue defaults to NULL
1631   C-&gt;add_macro_node(this);
1632 }
1633 
1634 void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)
1635 {
1636   assert(initializer != NULL &amp;&amp;
1637          initializer-&gt;is_object_constructor_or_class_initializer(),
1638          &quot;unexpected initializer method&quot;);
1639   BCEscapeAnalyzer* analyzer = initializer-&gt;get_bcea();
1640   if (analyzer == NULL) {
1641     return;
1642   }
1643 
1644   // Allocation node is first parameter in its initializer
1645   if (analyzer-&gt;is_arg_stack(0) || analyzer-&gt;is_arg_local(0)) {
1646     _is_allocation_MemBar_redundant = true;
1647   }
1648 }
1649 
1650 Node* AllocateNode::make_ideal_mark(PhaseGVN* phase, Node* control, Node* mem) {
1651   Node* mark_node = NULL;
1652   // For now only enable fast locking for non-array types
1653   if ((EnableValhalla || UseBiasedLocking) &amp;&amp; Opcode() == Op_Allocate) {
1654     Node* klass_node = in(AllocateNode::KlassNode);
1655     Node* proto_adr = phase-&gt;transform(new AddPNode(klass_node, klass_node, phase-&gt;MakeConX(in_bytes(Klass::prototype_header_offset()))));
1656     mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
1657   } else {
1658     mark_node = phase-&gt;MakeConX(markWord::prototype().value());
1659   }
1660   mark_node = phase-&gt;transform(mark_node);
1661   // Avoid returning a constant (old node) here because this method is used by LoadNode::Ideal
1662   return new OrXNode(mark_node, phase-&gt;MakeConX(_larval ? markWord::larval_state_pattern : 0));
1663 }
1664 
1665 
1666 //=============================================================================
1667 Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1668   Node* res = SafePointNode::Ideal(phase, can_reshape);
1669   if (res != NULL) {
1670     return res;
1671   }
1672   // Don&#39;t bother trying to transform a dead node
1673   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1674 
1675   const Type* type = phase-&gt;type(Ideal_length());
1676   if (type-&gt;isa_int() &amp;&amp; type-&gt;is_int()-&gt;_hi &lt; 0) {
1677     if (can_reshape) {
1678       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1679       // Unreachable fall through path (negative array length),
1680       // the allocation can only throw so disconnect it.
1681       Node* proj = proj_out_or_null(TypeFunc::Control);
1682       Node* catchproj = NULL;
1683       if (proj != NULL) {
1684         for (DUIterator_Fast imax, i = proj-&gt;fast_outs(imax); i &lt; imax; i++) {
1685           Node *cn = proj-&gt;fast_out(i);
1686           if (cn-&gt;is_Catch()) {
1687             catchproj = cn-&gt;as_Multi()-&gt;proj_out_or_null(CatchProjNode::fall_through_index);
1688             break;
1689           }
1690         }
1691       }
1692       if (catchproj != NULL &amp;&amp; catchproj-&gt;outcnt() &gt; 0 &amp;&amp;
1693           (catchproj-&gt;outcnt() &gt; 1 ||
1694            catchproj-&gt;unique_out()-&gt;Opcode() != Op_Halt)) {
1695         assert(catchproj-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
1696         Node* nproj = catchproj-&gt;clone();
1697         igvn-&gt;register_new_node_with_optimizer(nproj);
1698 
1699         Node *frame = new ParmNode( phase-&gt;C-&gt;start(), TypeFunc::FramePtr );
1700         frame = phase-&gt;transform(frame);
1701         // Halt &amp; Catch Fire
1702         Node* halt = new HaltNode(nproj, frame, &quot;unexpected negative array length&quot;);
1703         phase-&gt;C-&gt;root()-&gt;add_req(halt);
1704         phase-&gt;transform(halt);
1705 
1706         igvn-&gt;replace_node(catchproj, phase-&gt;C-&gt;top());
1707         return this;
1708       }
1709     } else {
1710       // Can&#39;t correct it during regular GVN so register for IGVN
1711       phase-&gt;C-&gt;record_for_igvn(this);
1712     }
1713   }
1714   return NULL;
1715 }
1716 
1717 // Retrieve the length from the AllocateArrayNode. Narrow the type with a
1718 // CastII, if appropriate.  If we are not allowed to create new nodes, and
1719 // a CastII is appropriate, return NULL.
1720 Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {
1721   Node *length = in(AllocateNode::ALength);
1722   assert(length != NULL, &quot;length is not null&quot;);
1723 
1724   const TypeInt* length_type = phase-&gt;find_int_type(length);
1725   const TypeAryPtr* ary_type = oop_type-&gt;isa_aryptr();
1726 
1727   if (ary_type != NULL &amp;&amp; length_type != NULL) {
1728     const TypeInt* narrow_length_type = ary_type-&gt;narrow_size_type(length_type);
1729     if (narrow_length_type != length_type) {
1730       // Assert one of:
1731       //   - the narrow_length is 0
1732       //   - the narrow_length is not wider than length
1733       assert(narrow_length_type == TypeInt::ZERO ||
1734              length_type-&gt;is_con() &amp;&amp; narrow_length_type-&gt;is_con() &amp;&amp;
1735                 (narrow_length_type-&gt;_hi &lt;= length_type-&gt;_lo) ||
1736              (narrow_length_type-&gt;_hi &lt;= length_type-&gt;_hi &amp;&amp;
1737               narrow_length_type-&gt;_lo &gt;= length_type-&gt;_lo),
1738              &quot;narrow type must be narrower than length type&quot;);
1739 
1740       // Return NULL if new nodes are not allowed
1741       if (!allow_new_nodes) return NULL;
1742       // Create a cast which is control dependent on the initialization to
1743       // propagate the fact that the array length must be positive.
1744       InitializeNode* init = initialization();
1745       assert(init != NULL, &quot;initialization not found&quot;);
1746       length = new CastIINode(length, narrow_length_type);
1747       length-&gt;set_req(0, init-&gt;proj_out_or_null(0));
1748     }
1749   }
1750 
1751   return length;
1752 }
1753 
1754 //=============================================================================
1755 uint LockNode::size_of() const { return sizeof(*this); }
1756 
1757 // Redundant lock elimination
1758 //
1759 // There are various patterns of locking where we release and
1760 // immediately reacquire a lock in a piece of code where no operations
1761 // occur in between that would be observable.  In those cases we can
1762 // skip releasing and reacquiring the lock without violating any
1763 // fairness requirements.  Doing this around a loop could cause a lock
1764 // to be held for a very long time so we concentrate on non-looping
1765 // control flow.  We also require that the operations are fully
1766 // redundant meaning that we don&#39;t introduce new lock operations on
1767 // some paths so to be able to eliminate it on others ala PRE.  This
1768 // would probably require some more extensive graph manipulation to
1769 // guarantee that the memory edges were all handled correctly.
1770 //
1771 // Assuming p is a simple predicate which can&#39;t trap in any way and s
1772 // is a synchronized method consider this code:
1773 //
1774 //   s();
1775 //   if (p)
1776 //     s();
1777 //   else
1778 //     s();
1779 //   s();
1780 //
1781 // 1. The unlocks of the first call to s can be eliminated if the
1782 // locks inside the then and else branches are eliminated.
1783 //
1784 // 2. The unlocks of the then and else branches can be eliminated if
1785 // the lock of the final call to s is eliminated.
1786 //
1787 // Either of these cases subsumes the simple case of sequential control flow
1788 //
1789 // Addtionally we can eliminate versions without the else case:
1790 //
1791 //   s();
1792 //   if (p)
1793 //     s();
1794 //   s();
1795 //
1796 // 3. In this case we eliminate the unlock of the first s, the lock
1797 // and unlock in the then case and the lock in the final s.
1798 //
1799 // Note also that in all these cases the then/else pieces don&#39;t have
1800 // to be trivial as long as they begin and end with synchronization
1801 // operations.
1802 //
1803 //   s();
1804 //   if (p)
1805 //     s();
1806 //     f();
1807 //     s();
1808 //   s();
1809 //
1810 // The code will work properly for this case, leaving in the unlock
1811 // before the call to f and the relock after it.
1812 //
1813 // A potentially interesting case which isn&#39;t handled here is when the
1814 // locking is partially redundant.
1815 //
1816 //   s();
1817 //   if (p)
1818 //     s();
1819 //
1820 // This could be eliminated putting unlocking on the else case and
1821 // eliminating the first unlock and the lock in the then side.
1822 // Alternatively the unlock could be moved out of the then side so it
1823 // was after the merge and the first unlock and second lock
1824 // eliminated.  This might require less manipulation of the memory
1825 // state to get correct.
1826 //
1827 // Additionally we might allow work between a unlock and lock before
1828 // giving up eliminating the locks.  The current code disallows any
1829 // conditional control flow between these operations.  A formulation
1830 // similar to partial redundancy elimination computing the
1831 // availability of unlocking and the anticipatability of locking at a
1832 // program point would allow detection of fully redundant locking with
1833 // some amount of work in between.  I&#39;m not sure how often I really
1834 // think that would occur though.  Most of the cases I&#39;ve seen
1835 // indicate it&#39;s likely non-trivial work would occur in between.
1836 // There may be other more complicated constructs where we could
1837 // eliminate locking but I haven&#39;t seen any others appear as hot or
1838 // interesting.
1839 //
1840 // Locking and unlocking have a canonical form in ideal that looks
1841 // roughly like this:
1842 //
1843 //              &lt;obj&gt;
1844 //                | \\------+
1845 //                |  \       \
1846 //                | BoxLock   \
1847 //                |  |   |     \
1848 //                |  |    \     \
1849 //                |  |   FastLock
1850 //                |  |   /
1851 //                |  |  /
1852 //                |  |  |
1853 //
1854 //               Lock
1855 //                |
1856 //            Proj #0
1857 //                |
1858 //            MembarAcquire
1859 //                |
1860 //            Proj #0
1861 //
1862 //            MembarRelease
1863 //                |
1864 //            Proj #0
1865 //                |
1866 //              Unlock
1867 //                |
1868 //            Proj #0
1869 //
1870 //
1871 // This code proceeds by processing Lock nodes during PhaseIterGVN
1872 // and searching back through its control for the proper code
1873 // patterns.  Once it finds a set of lock and unlock operations to
1874 // eliminate they are marked as eliminatable which causes the
1875 // expansion of the Lock and Unlock macro nodes to make the operation a NOP
1876 //
1877 //=============================================================================
1878 
1879 //
1880 // Utility function to skip over uninteresting control nodes.  Nodes skipped are:
1881 //   - copy regions.  (These may not have been optimized away yet.)
1882 //   - eliminated locking nodes
1883 //
1884 static Node *next_control(Node *ctrl) {
1885   if (ctrl == NULL)
1886     return NULL;
1887   while (1) {
1888     if (ctrl-&gt;is_Region()) {
1889       RegionNode *r = ctrl-&gt;as_Region();
1890       Node *n = r-&gt;is_copy();
1891       if (n == NULL)
1892         break;  // hit a region, return it
1893       else
1894         ctrl = n;
1895     } else if (ctrl-&gt;is_Proj()) {
1896       Node *in0 = ctrl-&gt;in(0);
1897       if (in0-&gt;is_AbstractLock() &amp;&amp; in0-&gt;as_AbstractLock()-&gt;is_eliminated()) {
1898         ctrl = in0-&gt;in(0);
1899       } else {
1900         break;
1901       }
1902     } else {
1903       break; // found an interesting control
1904     }
1905   }
1906   return ctrl;
1907 }
1908 //
1909 // Given a control, see if it&#39;s the control projection of an Unlock which
1910 // operating on the same object as lock.
1911 //
1912 bool AbstractLockNode::find_matching_unlock(const Node* ctrl, LockNode* lock,
1913                                             GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1914   ProjNode *ctrl_proj = (ctrl-&gt;is_Proj()) ? ctrl-&gt;as_Proj() : NULL;
1915   if (ctrl_proj != NULL &amp;&amp; ctrl_proj-&gt;_con == TypeFunc::Control) {
1916     Node *n = ctrl_proj-&gt;in(0);
1917     if (n != NULL &amp;&amp; n-&gt;is_Unlock()) {
1918       UnlockNode *unlock = n-&gt;as_Unlock();
1919       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1920       Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1921       Node* unlock_obj = bs-&gt;step_over_gc_barrier(unlock-&gt;obj_node());
1922       if (lock_obj-&gt;eqv_uncast(unlock_obj) &amp;&amp;
1923           BoxLockNode::same_slot(lock-&gt;box_node(), unlock-&gt;box_node()) &amp;&amp;
1924           !unlock-&gt;is_eliminated()) {
1925         lock_ops.append(unlock);
1926         return true;
1927       }
1928     }
1929   }
1930   return false;
1931 }
1932 
1933 //
1934 // Find the lock matching an unlock.  Returns null if a safepoint
1935 // or complicated control is encountered first.
1936 LockNode *AbstractLockNode::find_matching_lock(UnlockNode* unlock) {
1937   LockNode *lock_result = NULL;
1938   // find the matching lock, or an intervening safepoint
1939   Node *ctrl = next_control(unlock-&gt;in(0));
1940   while (1) {
1941     assert(ctrl != NULL, &quot;invalid control graph&quot;);
1942     assert(!ctrl-&gt;is_Start(), &quot;missing lock for unlock&quot;);
1943     if (ctrl-&gt;is_top()) break;  // dead control path
1944     if (ctrl-&gt;is_Proj()) ctrl = ctrl-&gt;in(0);
1945     if (ctrl-&gt;is_SafePoint()) {
1946         break;  // found a safepoint (may be the lock we are searching for)
1947     } else if (ctrl-&gt;is_Region()) {
1948       // Check for a simple diamond pattern.  Punt on anything more complicated
1949       if (ctrl-&gt;req() == 3 &amp;&amp; ctrl-&gt;in(1) != NULL &amp;&amp; ctrl-&gt;in(2) != NULL) {
1950         Node *in1 = next_control(ctrl-&gt;in(1));
1951         Node *in2 = next_control(ctrl-&gt;in(2));
1952         if (((in1-&gt;is_IfTrue() &amp;&amp; in2-&gt;is_IfFalse()) ||
1953              (in2-&gt;is_IfTrue() &amp;&amp; in1-&gt;is_IfFalse())) &amp;&amp; (in1-&gt;in(0) == in2-&gt;in(0))) {
1954           ctrl = next_control(in1-&gt;in(0)-&gt;in(0));
1955         } else {
1956           break;
1957         }
1958       } else {
1959         break;
1960       }
1961     } else {
1962       ctrl = next_control(ctrl-&gt;in(0));  // keep searching
1963     }
1964   }
1965   if (ctrl-&gt;is_Lock()) {
1966     LockNode *lock = ctrl-&gt;as_Lock();
1967     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1968     Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1969     Node* unlock_obj = bs-&gt;step_over_gc_barrier(unlock-&gt;obj_node());
1970     if (lock_obj-&gt;eqv_uncast(unlock_obj) &amp;&amp;
1971         BoxLockNode::same_slot(lock-&gt;box_node(), unlock-&gt;box_node())) {
1972       lock_result = lock;
1973     }
1974   }
1975   return lock_result;
1976 }
1977 
1978 // This code corresponds to case 3 above.
1979 
1980 bool AbstractLockNode::find_lock_and_unlock_through_if(Node* node, LockNode* lock,
1981                                                        GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1982   Node* if_node = node-&gt;in(0);
1983   bool  if_true = node-&gt;is_IfTrue();
1984 
1985   if (if_node-&gt;is_If() &amp;&amp; if_node-&gt;outcnt() == 2 &amp;&amp; (if_true || node-&gt;is_IfFalse())) {
1986     Node *lock_ctrl = next_control(if_node-&gt;in(0));
1987     if (find_matching_unlock(lock_ctrl, lock, lock_ops)) {
1988       Node* lock1_node = NULL;
1989       ProjNode* proj = if_node-&gt;as_If()-&gt;proj_out(!if_true);
1990       if (if_true) {
1991         if (proj-&gt;is_IfFalse() &amp;&amp; proj-&gt;outcnt() == 1) {
1992           lock1_node = proj-&gt;unique_out();
1993         }
1994       } else {
1995         if (proj-&gt;is_IfTrue() &amp;&amp; proj-&gt;outcnt() == 1) {
1996           lock1_node = proj-&gt;unique_out();
1997         }
1998       }
1999       if (lock1_node != NULL &amp;&amp; lock1_node-&gt;is_Lock()) {
2000         LockNode *lock1 = lock1_node-&gt;as_Lock();
2001         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2002         Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
2003         Node* lock1_obj = bs-&gt;step_over_gc_barrier(lock1-&gt;obj_node());
2004         if (lock_obj-&gt;eqv_uncast(lock1_obj) &amp;&amp;
2005             BoxLockNode::same_slot(lock-&gt;box_node(), lock1-&gt;box_node()) &amp;&amp;
2006             !lock1-&gt;is_eliminated()) {
2007           lock_ops.append(lock1);
2008           return true;
2009         }
2010       }
2011     }
2012   }
2013 
2014   lock_ops.trunc_to(0);
2015   return false;
2016 }
2017 
2018 bool AbstractLockNode::find_unlocks_for_region(const RegionNode* region, LockNode* lock,
2019                                GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
2020   // check each control merging at this point for a matching unlock.
2021   // in(0) should be self edge so skip it.
2022   for (int i = 1; i &lt; (int)region-&gt;req(); i++) {
2023     Node *in_node = next_control(region-&gt;in(i));
2024     if (in_node != NULL) {
2025       if (find_matching_unlock(in_node, lock, lock_ops)) {
2026         // found a match so keep on checking.
2027         continue;
2028       } else if (find_lock_and_unlock_through_if(in_node, lock, lock_ops)) {
2029         continue;
2030       }
2031 
2032       // If we fall through to here then it was some kind of node we
2033       // don&#39;t understand or there wasn&#39;t a matching unlock, so give
2034       // up trying to merge locks.
2035       lock_ops.trunc_to(0);
2036       return false;
2037     }
2038   }
2039   return true;
2040 
2041 }
2042 
2043 #ifndef PRODUCT
2044 //
2045 // Create a counter which counts the number of times this lock is acquired
2046 //
2047 void AbstractLockNode::create_lock_counter(JVMState* state) {
2048   _counter = OptoRuntime::new_named_counter(state, NamedCounter::LockCounter);
2049 }
2050 
2051 void AbstractLockNode::set_eliminated_lock_counter() {
2052   if (_counter) {
2053     // Update the counter to indicate that this lock was eliminated.
2054     // The counter update code will stay around even though the
2055     // optimizer will eliminate the lock operation itself.
2056     _counter-&gt;set_tag(NamedCounter::EliminatedLockCounter);
2057   }
2058 }
2059 
2060 const char* AbstractLockNode::_kind_names[] = {&quot;Regular&quot;, &quot;NonEscObj&quot;, &quot;Coarsened&quot;, &quot;Nested&quot;};
2061 
2062 void AbstractLockNode::dump_spec(outputStream* st) const {
2063   st-&gt;print(&quot;%s &quot;, _kind_names[_kind]);
2064   CallNode::dump_spec(st);
2065 }
2066 
2067 void AbstractLockNode::dump_compact_spec(outputStream* st) const {
2068   st-&gt;print(&quot;%s&quot;, _kind_names[_kind]);
2069 }
2070 
2071 // The related set of lock nodes includes the control boundary.
2072 void AbstractLockNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
2073   if (compact) {
2074       this-&gt;collect_nodes(in_rel, 1, false, false);
2075     } else {
2076       this-&gt;collect_nodes_in_all_data(in_rel, true);
2077     }
2078     this-&gt;collect_nodes(out_rel, -2, false, false);
2079 }
2080 #endif
2081 
2082 //=============================================================================
2083 Node *LockNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2084 
2085   // perform any generic optimizations first (returns &#39;this&#39; or NULL)
2086   Node *result = SafePointNode::Ideal(phase, can_reshape);
2087   if (result != NULL)  return result;
2088   // Don&#39;t bother trying to transform a dead node
2089   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
2090 
2091   // Now see if we can optimize away this lock.  We don&#39;t actually
2092   // remove the locking here, we simply set the _eliminate flag which
2093   // prevents macro expansion from expanding the lock.  Since we don&#39;t
2094   // modify the graph, the value returned from this function is the
2095   // one computed above.
2096   const Type* obj_type = phase-&gt;type(obj_node());
2097   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj() &amp;&amp;
<a name="10" id="anc10"></a><span class="line-modified">2098       !obj_type-&gt;isa_inlinetype() &amp;&amp; !obj_type-&gt;is_inlinetypeptr()) {</span>
2099     //
2100     // If we are locking an unescaped object, the lock/unlock is unnecessary
2101     //
2102     ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
2103     if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
2104       assert(!is_eliminated() || is_coarsened(), &quot;sanity&quot;);
2105       // The lock could be marked eliminated by lock coarsening
2106       // code during first IGVN before EA. Replace coarsened flag
2107       // to eliminate all associated locks/unlocks.
2108 #ifdef ASSERT
2109       this-&gt;log_lock_optimization(phase-&gt;C,&quot;eliminate_lock_set_non_esc1&quot;);
2110 #endif
2111       this-&gt;set_non_esc_obj();
2112       return result;
2113     }
2114 
2115     //
2116     // Try lock coarsening
2117     //
2118     PhaseIterGVN* iter = phase-&gt;is_IterGVN();
2119     if (iter != NULL &amp;&amp; !is_eliminated()) {
2120 
2121       GrowableArray&lt;AbstractLockNode*&gt;   lock_ops;
2122 
2123       Node *ctrl = next_control(in(0));
2124 
2125       // now search back for a matching Unlock
2126       if (find_matching_unlock(ctrl, this, lock_ops)) {
2127         // found an unlock directly preceding this lock.  This is the
2128         // case of single unlock directly control dependent on a
2129         // single lock which is the trivial version of case 1 or 2.
2130       } else if (ctrl-&gt;is_Region() ) {
2131         if (find_unlocks_for_region(ctrl-&gt;as_Region(), this, lock_ops)) {
2132         // found lock preceded by multiple unlocks along all paths
2133         // joining at this point which is case 3 in description above.
2134         }
2135       } else {
2136         // see if this lock comes from either half of an if and the
2137         // predecessors merges unlocks and the other half of the if
2138         // performs a lock.
2139         if (find_lock_and_unlock_through_if(ctrl, this, lock_ops)) {
2140           // found unlock splitting to an if with locks on both branches.
2141         }
2142       }
2143 
2144       if (lock_ops.length() &gt; 0) {
2145         // add ourselves to the list of locks to be eliminated.
2146         lock_ops.append(this);
2147 
2148   #ifndef PRODUCT
2149         if (PrintEliminateLocks) {
2150           int locks = 0;
2151           int unlocks = 0;
2152           for (int i = 0; i &lt; lock_ops.length(); i++) {
2153             AbstractLockNode* lock = lock_ops.at(i);
2154             if (lock-&gt;Opcode() == Op_Lock)
2155               locks++;
2156             else
2157               unlocks++;
2158             if (Verbose) {
2159               lock-&gt;dump(1);
2160             }
2161           }
2162           tty-&gt;print_cr(&quot;***Eliminated %d unlocks and %d locks&quot;, unlocks, locks);
2163         }
2164   #endif
2165 
2166         // for each of the identified locks, mark them
2167         // as eliminatable
2168         for (int i = 0; i &lt; lock_ops.length(); i++) {
2169           AbstractLockNode* lock = lock_ops.at(i);
2170 
2171           // Mark it eliminated by coarsening and update any counters
2172 #ifdef ASSERT
2173           lock-&gt;log_lock_optimization(phase-&gt;C, &quot;eliminate_lock_set_coarsened&quot;);
2174 #endif
2175           lock-&gt;set_coarsened();
2176         }
2177       } else if (ctrl-&gt;is_Region() &amp;&amp;
2178                  iter-&gt;_worklist.member(ctrl)) {
2179         // We weren&#39;t able to find any opportunities but the region this
2180         // lock is control dependent on hasn&#39;t been processed yet so put
2181         // this lock back on the worklist so we can check again once any
2182         // region simplification has occurred.
2183         iter-&gt;_worklist.push(this);
2184       }
2185     }
2186   }
2187 
2188   return result;
2189 }
2190 
2191 //=============================================================================
2192 bool LockNode::is_nested_lock_region() {
2193   return is_nested_lock_region(NULL);
2194 }
2195 
2196 // p is used for access to compilation log; no logging if NULL
2197 bool LockNode::is_nested_lock_region(Compile * c) {
2198   BoxLockNode* box = box_node()-&gt;as_BoxLock();
2199   int stk_slot = box-&gt;stack_slot();
2200   if (stk_slot &lt;= 0) {
2201 #ifdef ASSERT
2202     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_1&quot;);
2203 #endif
2204     return false; // External lock or it is not Box (Phi node).
2205   }
2206 
2207   // Ignore complex cases: merged locks or multiple locks.
2208   Node* obj = obj_node();
2209   LockNode* unique_lock = NULL;
2210   if (!box-&gt;is_simple_lock_region(&amp;unique_lock, obj)) {
2211 #ifdef ASSERT
2212     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_2a&quot;);
2213 #endif
2214     return false;
2215   }
2216   if (unique_lock != this) {
2217 #ifdef ASSERT
2218     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_2b&quot;);
2219 #endif
2220     return false;
2221   }
2222 
2223   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2224   obj = bs-&gt;step_over_gc_barrier(obj);
2225   // Look for external lock for the same object.
2226   SafePointNode* sfn = this-&gt;as_SafePoint();
2227   JVMState* youngest_jvms = sfn-&gt;jvms();
2228   int max_depth = youngest_jvms-&gt;depth();
2229   for (int depth = 1; depth &lt;= max_depth; depth++) {
2230     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
2231     int num_mon  = jvms-&gt;nof_monitors();
2232     // Loop over monitors
2233     for (int idx = 0; idx &lt; num_mon; idx++) {
2234       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
2235       obj_node = bs-&gt;step_over_gc_barrier(obj_node);
2236       BoxLockNode* box_node = sfn-&gt;monitor_box(jvms, idx)-&gt;as_BoxLock();
2237       if ((box_node-&gt;stack_slot() &lt; stk_slot) &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
2238         return true;
2239       }
2240     }
2241   }
2242 #ifdef ASSERT
2243   this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_3&quot;);
2244 #endif
2245   return false;
2246 }
2247 
2248 //=============================================================================
2249 uint UnlockNode::size_of() const { return sizeof(*this); }
2250 
2251 //=============================================================================
2252 Node *UnlockNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2253 
2254   // perform any generic optimizations first (returns &#39;this&#39; or NULL)
2255   Node *result = SafePointNode::Ideal(phase, can_reshape);
2256   if (result != NULL)  return result;
2257   // Don&#39;t bother trying to transform a dead node
2258   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
2259 
2260   // Now see if we can optimize away this unlock.  We don&#39;t actually
2261   // remove the unlocking here, we simply set the _eliminate flag which
2262   // prevents macro expansion from expanding the unlock.  Since we don&#39;t
2263   // modify the graph, the value returned from this function is the
2264   // one computed above.
2265   // Escape state is defined after Parse phase.
2266   const Type* obj_type = phase-&gt;type(obj_node());
2267   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj() &amp;&amp;
<a name="11" id="anc11"></a><span class="line-modified">2268       !obj_type-&gt;isa_inlinetype() &amp;&amp; !obj_type-&gt;is_inlinetypeptr()) {</span>
2269     //
2270     // If we are unlocking an unescaped object, the lock/unlock is unnecessary.
2271     //
2272     ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
2273     if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
2274       assert(!is_eliminated() || is_coarsened(), &quot;sanity&quot;);
2275       // The lock could be marked eliminated by lock coarsening
2276       // code during first IGVN before EA. Replace coarsened flag
2277       // to eliminate all associated locks/unlocks.
2278 #ifdef ASSERT
2279       this-&gt;log_lock_optimization(phase-&gt;C, &quot;eliminate_lock_set_non_esc2&quot;);
2280 #endif
2281       this-&gt;set_non_esc_obj();
2282     }
2283   }
2284   return result;
2285 }
2286 
2287 const char * AbstractLockNode::kind_as_string() const {
2288   return is_coarsened()   ? &quot;coarsened&quot; :
2289          is_nested()      ? &quot;nested&quot; :
2290          is_non_esc_obj() ? &quot;non_escaping&quot; :
2291          &quot;?&quot;;
2292 }
2293 
2294 void AbstractLockNode::log_lock_optimization(Compile *C, const char * tag)  const {
2295   if (C == NULL) {
2296     return;
2297   }
2298   CompileLog* log = C-&gt;log();
2299   if (log != NULL) {
2300     log-&gt;begin_head(&quot;%s lock=&#39;%d&#39; compile_id=&#39;%d&#39; class_id=&#39;%s&#39; kind=&#39;%s&#39;&quot;,
2301           tag, is_Lock(), C-&gt;compile_id(),
2302           is_Unlock() ? &quot;unlock&quot; : is_Lock() ? &quot;lock&quot; : &quot;?&quot;,
2303           kind_as_string());
2304     log-&gt;stamp();
2305     log-&gt;end_head();
2306     JVMState* p = is_Unlock() ? (as_Unlock()-&gt;dbg_jvms()) : jvms();
2307     while (p != NULL) {
2308       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
2309       p = p-&gt;caller();
2310     }
2311     log-&gt;tail(tag);
2312   }
2313 }
2314 
2315 bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase) {
2316   if (dest_t-&gt;is_known_instance() &amp;&amp; t_oop-&gt;is_known_instance()) {
2317     return dest_t-&gt;instance_id() == t_oop-&gt;instance_id();
2318   }
2319 
2320   if (dest_t-&gt;isa_instptr() &amp;&amp; !dest_t-&gt;klass()-&gt;equals(phase-&gt;C-&gt;env()-&gt;Object_klass())) {
2321     // clone
2322     if (t_oop-&gt;isa_aryptr()) {
2323       return false;
2324     }
2325     if (!t_oop-&gt;isa_instptr()) {
2326       return true;
2327     }
2328     if (dest_t-&gt;klass()-&gt;is_subtype_of(t_oop-&gt;klass()) || t_oop-&gt;klass()-&gt;is_subtype_of(dest_t-&gt;klass())) {
2329       return true;
2330     }
2331     // unrelated
2332     return false;
2333   }
2334 
2335   if (dest_t-&gt;isa_aryptr()) {
2336     // arraycopy or array clone
2337     if (t_oop-&gt;isa_instptr()) {
2338       return false;
2339     }
2340     if (!t_oop-&gt;isa_aryptr()) {
2341       return true;
2342     }
2343 
2344     const Type* elem = dest_t-&gt;is_aryptr()-&gt;elem();
2345     if (elem == Type::BOTTOM) {
2346       // An array but we don&#39;t know what elements are
2347       return true;
2348     }
2349 
2350     dest_t = dest_t-&gt;is_aryptr()-&gt;with_field_offset(Type::OffsetBot)-&gt;add_offset(Type::OffsetBot)-&gt;is_oopptr();
2351     t_oop = t_oop-&gt;is_aryptr()-&gt;with_field_offset(Type::OffsetBot);
2352     uint dest_alias = phase-&gt;C-&gt;get_alias_index(dest_t);
2353     uint t_oop_alias = phase-&gt;C-&gt;get_alias_index(t_oop);
2354 
2355     return dest_alias == t_oop_alias;
2356   }
2357 
2358   return true;
2359 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
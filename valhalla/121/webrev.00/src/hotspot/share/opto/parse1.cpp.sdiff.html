<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parse1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="output.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;interpreter/linkResolver.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;oops/method.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/c2compiler.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/idealGraphPrinter.hpp&quot;

  34 #include &quot;opto/locknode.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/opaquenode.hpp&quot;
  37 #include &quot;opto/parse.hpp&quot;
  38 #include &quot;opto/rootnode.hpp&quot;
  39 #include &quot;opto/runtime.hpp&quot;
<span class="line-removed">  40 #include &quot;opto/valuetypenode.hpp&quot;</span>
  41 #include &quot;runtime/arguments.hpp&quot;
  42 #include &quot;runtime/handles.inline.hpp&quot;
  43 #include &quot;runtime/safepointMechanism.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;utilities/bitMap.inline.hpp&quot;
  46 #include &quot;utilities/copy.hpp&quot;
  47 
  48 // Static array so we can figure out which bytecodes stop us from compiling
  49 // the most. Some of the non-static variables are needed in bytecodeInfo.cpp
  50 // and eventually should be encapsulated in a proper class (gri 8/18/98).
  51 
  52 #ifndef PRODUCT
  53 int nodes_created              = 0;
  54 int methods_parsed             = 0;
  55 int methods_seen               = 0;
  56 int blocks_parsed              = 0;
  57 int blocks_seen                = 0;
  58 
  59 int explicit_null_checks_inserted = 0;
  60 int explicit_null_checks_elided   = 0;
</pre>
<hr />
<pre>
 139       l = (bt == T_DOUBLE)
 140         ? (Node*)new LoadD_unalignedNode(ctl, mem, adr, TypeRawPtr::BOTTOM, MemNode::unordered)
 141         : (Node*)new LoadL_unalignedNode(ctl, mem, adr, TypeRawPtr::BOTTOM, MemNode::unordered);
 142     }
 143     break;
 144   }
 145   default: ShouldNotReachHere();
 146   }
 147   return _gvn.transform(l);
 148 }
 149 
 150 // Helper routine to prevent the interpreter from handing
 151 // unexpected typestate to an OSR method.
 152 // The Node l is a value newly dug out of the interpreter frame.
 153 // The type is the type predicted by ciTypeFlow.  Note that it is
 154 // not a general type, but can only come from Type::get_typeflow_type.
 155 // The safepoint is a map which will feed an uncommon trap.
 156 Node* Parse::check_interpreter_type(Node* l, const Type* type,
 157                                     SafePointNode* &amp;bad_type_exit) {
 158   const TypeOopPtr* tp = type-&gt;isa_oopptr();
<span class="line-modified"> 159   if (type-&gt;isa_valuetype() != NULL) {</span>
<span class="line-modified"> 160     // The interpreter passes value types as oops</span>
<span class="line-modified"> 161     tp = TypeOopPtr::make_from_klass(type-&gt;value_klass());</span>
 162     tp = tp-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
 163   }
 164 
 165   // TypeFlow may assert null-ness if a type appears unloaded.
 166   if (type == TypePtr::NULL_PTR ||
 167       (tp != NULL &amp;&amp; !tp-&gt;klass()-&gt;is_loaded())) {
 168     // Value must be null, not a real oop.
 169     Node* chk = _gvn.transform( new CmpPNode(l, null()) );
 170     Node* tst = _gvn.transform( new BoolNode(chk, BoolTest::eq) );
 171     IfNode* iff = create_and_map_if(control(), tst, PROB_MAX, COUNT_UNKNOWN);
 172     set_control(_gvn.transform( new IfTrueNode(iff) ));
 173     Node* bad_type = _gvn.transform( new IfFalseNode(iff) );
 174     bad_type_exit-&gt;control()-&gt;add_req(bad_type);
 175     l = null();
 176   }
 177 
 178   // Typeflow can also cut off paths from the CFG, based on
 179   // types which appear unloaded, or call sites which appear unlinked.
 180   // When paths are cut off, values at later merge points can rise
 181   // toward more specific classes.  Make sure these specific classes
 182   // are still in effect.
 183   if (tp != NULL &amp;&amp; tp-&gt;klass() != C-&gt;env()-&gt;Object_klass()) {
 184     // TypeFlow asserted a specific object type.  Value must have that type.
 185     Node* bad_type_ctrl = NULL;
<span class="line-modified"> 186     if (tp-&gt;klass()-&gt;is_valuetype()) {</span>
<span class="line-modified"> 187       // Check value types for null here to prevent checkcast from adding an</span>
 188       // exception state before the bytecode entry (use &#39;bad_type_ctrl&#39; instead).
 189       l = null_check_oop(l, &amp;bad_type_ctrl);
 190       bad_type_exit-&gt;control()-&gt;add_req(bad_type_ctrl);
 191     }
 192     l = gen_checkcast(l, makecon(TypeKlassPtr::make(tp-&gt;klass())), &amp;bad_type_ctrl);
 193     bad_type_exit-&gt;control()-&gt;add_req(bad_type_ctrl);
 194   }
 195   assert(_gvn.type(l)-&gt;higher_equal(type), &quot;must constrain OSR typestate&quot;);
 196   return l;
 197 }
 198 
 199 // Helper routine which sets up elements of the initial parser map when
 200 // performing a parse for on stack replacement.  Add values into map.
 201 // The only parameter contains the address of a interpreter arguments.
 202 void Parse::load_interpreter_state(Node* osr_buf) {
 203   int index;
 204   int max_locals = jvms()-&gt;loc_size();
 205   int max_stack  = jvms()-&gt;stk_size();
 206 
 207   // Mismatch between method and jvms can occur since map briefly held
</pre>
<hr />
<pre>
 586     }
 587   }
 588 
 589   if (depth() == 1 &amp;&amp; !failing()) {
 590     if (C-&gt;clinit_barrier_on_entry()) {
 591       // Add check to deoptimize the nmethod once the holder class is fully initialized
 592       clinit_deopt();
 593     }
 594 
 595     // Add check to deoptimize the nmethod if RTM state was changed
 596     rtm_deopt();
 597   }
 598 
 599   // Check for bailouts during method entry or RTM state check setup.
 600   if (failing()) {
 601     if (log)  log-&gt;done(&quot;parse&quot;);
 602     C-&gt;set_default_node_notes(caller_nn);
 603     return;
 604   }
 605 
<span class="line-modified"> 606   // Handle value type arguments</span>
 607   int arg_size_sig = tf()-&gt;domain_sig()-&gt;cnt();
 608   for (uint i = 0; i &lt; (uint)arg_size_sig; i++) {
 609     Node* parm = map()-&gt;in(i);
 610     const Type* t = _gvn.type(parm);
<span class="line-modified"> 611     if (t-&gt;is_valuetypeptr() &amp;&amp; t-&gt;value_klass()-&gt;is_scalarizable() &amp;&amp; !t-&gt;maybe_null()) {</span>
<span class="line-modified"> 612       // Create ValueTypeNode from the oop and replace the parameter</span>
<span class="line-modified"> 613       Node* vt = ValueTypeNode::make_from_oop(this, parm, t-&gt;value_klass());</span>
 614       map()-&gt;replace_edge(parm, vt);
 615     } else if (UseTypeSpeculation &amp;&amp; (i == (uint)(arg_size_sig - 1)) &amp;&amp; !is_osr_parse() &amp;&amp;
 616                method()-&gt;has_vararg() &amp;&amp; t-&gt;isa_aryptr() != NULL &amp;&amp; !t-&gt;is_aryptr()-&gt;is_not_null_free()) {
 617       // Speculate on varargs Object array being not null-free (and therefore also not flattened)
 618       const TypePtr* spec_type = t-&gt;speculative();
 619       spec_type = (spec_type != NULL &amp;&amp; spec_type-&gt;isa_aryptr() != NULL) ? spec_type : t-&gt;is_aryptr();
 620       spec_type = spec_type-&gt;remove_speculative()-&gt;is_aryptr()-&gt;cast_to_not_null_free();
 621       spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::Offset::bottom, TypeOopPtr::InstanceBot, spec_type);
 622       Node* cast = _gvn.transform(new CheckCastPPNode(control(), parm, t-&gt;join_speculative(spec_type)));
 623       replace_in_map(parm, cast);
 624     }
 625   }
 626 
 627   entry_map = map();  // capture any changes performed by method setup code
 628   assert(jvms()-&gt;endoff() == map()-&gt;req(), &quot;map matches JVMS layout&quot;);
 629 
 630   // We begin parsing as if we have just encountered a jump to the
 631   // method entry.
 632   Block* entry_block = start_block();
 633   assert(entry_block-&gt;start() == (is_osr_parse() ? osr_bci() : 0), &quot;&quot;);
</pre>
<hr />
<pre>
 808   // Add a return value to the exit state.  (Do not push it yet.)
 809   if (tf()-&gt;range_sig()-&gt;cnt() &gt; TypeFunc::Parms) {
 810     const Type* ret_type = tf()-&gt;range_sig()-&gt;field_at(TypeFunc::Parms);
 811     if (ret_type-&gt;isa_int()) {
 812       BasicType ret_bt = method()-&gt;return_type()-&gt;basic_type();
 813       if (ret_bt == T_BOOLEAN ||
 814           ret_bt == T_CHAR ||
 815           ret_bt == T_BYTE ||
 816           ret_bt == T_SHORT) {
 817         ret_type = TypeInt::INT;
 818       }
 819     }
 820 
 821     // Don&#39;t &quot;bind&quot; an unloaded return klass to the ret_phi. If the klass
 822     // becomes loaded during the subsequent parsing, the loaded and unloaded
 823     // types will not join when we transform and push in do_exits().
 824     const TypeOopPtr* ret_oop_type = ret_type-&gt;isa_oopptr();
 825     if (ret_oop_type &amp;&amp; !ret_oop_type-&gt;klass()-&gt;is_loaded()) {
 826       ret_type = TypeOopPtr::BOTTOM;
 827     }
<span class="line-modified"> 828     if ((_caller-&gt;has_method() || tf()-&gt;returns_value_type_as_fields()) &amp;&amp;</span>
<span class="line-modified"> 829         ret_type-&gt;is_valuetypeptr() &amp;&amp; ret_type-&gt;value_klass()-&gt;is_scalarizable() &amp;&amp; !ret_type-&gt;maybe_null()) {</span>
<span class="line-modified"> 830       // Scalarize value type return when inlining or with multiple return values</span>
<span class="line-modified"> 831       ret_type = TypeValueType::make(ret_type-&gt;value_klass());</span>
 832     }
 833     int         ret_size = type2size[ret_type-&gt;basic_type()];
 834     Node*       ret_phi  = new PhiNode(region, ret_type);
 835     gvn().set_type_bottom(ret_phi);
 836     _exits.ensure_stack(ret_size);
 837     assert((int)(tf()-&gt;range_sig()-&gt;cnt() - TypeFunc::Parms) == ret_size, &quot;good tf range&quot;);
 838     assert(method()-&gt;return_type()-&gt;size() == ret_size, &quot;tf agrees w/ method&quot;);
 839     _exits.set_argument(0, ret_phi);  // here is where the parser finds it
 840     // Note:  ret_phi is not yet pushed, until do_exits.
 841   }
 842 }
 843 
 844 //----------------------------build_start_state-------------------------------
 845 // Construct a state which contains only the incoming arguments from an
 846 // unknown caller.  The method &amp; bci will be NULL &amp; InvocationEntryBci.
 847 JVMState* Compile::build_start_state(StartNode* start, const TypeFunc* tf) {
 848   int        arg_size = tf-&gt;domain_sig()-&gt;cnt();
 849   int        max_size = MAX2(arg_size, (int)tf-&gt;range_cc()-&gt;cnt());
 850   JVMState*  jvms     = new (this) JVMState(max_size - TypeFunc::Parms);
 851   SafePointNode* map  = new SafePointNode(max_size, NULL);
 852   map-&gt;set_jvms(jvms);
 853   jvms-&gt;set_map(map);
 854   record_for_igvn(map);
 855   assert(arg_size == TypeFunc::Parms + (is_osr_compilation() ? 1 : method()-&gt;arg_size()), &quot;correct arg_size&quot;);
 856   Node_Notes* old_nn = default_node_notes();
 857   if (old_nn != NULL &amp;&amp; has_method()) {
 858     Node_Notes* entry_nn = old_nn-&gt;clone(this);
 859     JVMState* entry_jvms = new(this) JVMState(method(), old_nn-&gt;jvms());
 860     entry_jvms-&gt;set_offsets(0);
 861     entry_jvms-&gt;set_bci(entry_bci());
 862     entry_nn-&gt;set_jvms(entry_jvms);
 863     set_default_node_notes(entry_nn);
 864   }
 865   PhaseGVN&amp; gvn = *initial_gvn();
 866   uint j = 0;
 867   ExtendedSignature sig_cc = ExtendedSignature(method()-&gt;get_sig_cc(), SigEntryFilter());
 868   for (uint i = 0; i &lt; (uint)arg_size; i++) {
 869     const Type* t = tf-&gt;domain_sig()-&gt;field_at(i);
 870     Node* parm = NULL;
<span class="line-modified"> 871     if (has_scalarized_args() &amp;&amp; t-&gt;is_valuetypeptr() &amp;&amp; !t-&gt;maybe_null()) {</span>
<span class="line-modified"> 872       // Value type arguments are not passed by reference: we get an argument per</span>
<span class="line-modified"> 873       // field of the value type. Build ValueTypeNodes from the value type arguments.</span>
 874       GraphKit kit(jvms, &amp;gvn);
 875       kit.set_control(map-&gt;control());
 876       Node* old_mem = map-&gt;memory();
<span class="line-modified"> 877       // Use immutable memory for value type loads and restore it below</span>
<span class="line-modified"> 878       // TODO make sure value types are always loaded from immutable memory</span>
 879       kit.set_all_memory(C-&gt;immutable_memory());
<span class="line-modified"> 880       parm = ValueTypeNode::make_from_multi(&amp;kit, start, sig_cc, t-&gt;value_klass(), j, true);</span>
 881       map-&gt;set_control(kit.control());
 882       map-&gt;set_memory(old_mem);
 883     } else {
 884       parm = gvn.transform(new ParmNode(start, j++));
 885       BasicType bt = t-&gt;basic_type();
 886       while (i &gt;= TypeFunc::Parms &amp;&amp; !is_osr_compilation() &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt, true)) {
 887         j += type2size[bt]; // Skip reserved arguments
 888       }
 889     }
 890     map-&gt;init_req(i, parm);
 891     // Record all these guys for later GVN.
 892     record_for_igvn(parm);
 893   }
 894   for (; j &lt; map-&gt;req(); j++) {
 895     map-&gt;init_req(j, top());
 896   }
 897   assert(jvms-&gt;argoff() == TypeFunc::Parms, &quot;parser gets arguments here&quot;);
 898   set_default_node_notes(old_nn);
 899   return jvms;
 900 }
</pre>
<hr />
<pre>
 910   nn-&gt;set_jvms(jvms);
 911   return nn;
 912 }
 913 
 914 
 915 //--------------------------return_values--------------------------------------
 916 void Compile::return_values(JVMState* jvms) {
 917   GraphKit kit(jvms);
 918   Node* ret = new ReturnNode(TypeFunc::Parms,
 919                              kit.control(),
 920                              kit.i_o(),
 921                              kit.reset_memory(),
 922                              kit.frameptr(),
 923                              kit.returnadr());
 924   // Add zero or 1 return values
 925   int ret_size = tf()-&gt;range_sig()-&gt;cnt() - TypeFunc::Parms;
 926   if (ret_size &gt; 0) {
 927     kit.inc_sp(-ret_size);  // pop the return value(s)
 928     kit.sync_jvms();
 929     Node* res = kit.argument(0);
<span class="line-modified"> 930     if (tf()-&gt;returns_value_type_as_fields()) {</span>
<span class="line-modified"> 931       // Multiple return values (value type fields): add as many edges</span>
 932       // to the Return node as returned values.
<span class="line-modified"> 933       assert(res-&gt;is_ValueType(), &quot;what else supports multi value return?&quot;);</span>
<span class="line-modified"> 934       ValueTypeNode* vt = res-&gt;as_ValueType();</span>
 935       ret-&gt;add_req_batch(NULL, tf()-&gt;range_cc()-&gt;cnt() - TypeFunc::Parms);
 936       if (vt-&gt;is_allocated(&amp;kit.gvn()) &amp;&amp; !StressInlineTypeReturnedAsFields) {
 937         ret-&gt;init_req(TypeFunc::Parms, vt-&gt;get_oop());
 938       } else {
 939         ret-&gt;init_req(TypeFunc::Parms, vt-&gt;tagged_klass(kit.gvn()));
 940       }
<span class="line-modified"> 941       const Array&lt;SigEntry&gt;* sig_array = vt-&gt;type()-&gt;value_klass()-&gt;extended_sig();</span>
 942       GrowableArray&lt;SigEntry&gt; sig = GrowableArray&lt;SigEntry&gt;(sig_array-&gt;length());
 943       sig.appendAll(sig_array);
 944       ExtendedSignature sig_cc = ExtendedSignature(&amp;sig, SigEntryFilter());
 945       uint idx = TypeFunc::Parms+1;
 946       vt-&gt;pass_fields(&amp;kit, ret, sig_cc, idx);
 947     } else {
 948       ret-&gt;add_req(res);
 949       // Note:  The second dummy edge is not needed by a ReturnNode.
 950     }
 951   }
 952   // bind it to root
 953   root()-&gt;add_req(ret);
 954   record_for_igvn(ret);
 955   initial_gvn()-&gt;transform_no_reclaim(ret);
 956 }
 957 
 958 //------------------------rethrow_exceptions-----------------------------------
 959 // Bind all exception states in the list into a single RethrowNode.
 960 void Compile::rethrow_exceptions(JVMState* jvms) {
 961   GraphKit kit(jvms);
</pre>
<hr />
<pre>
1273 
1274   // If the method is synchronized, we need to construct a lock node, attach
1275   // it to the Start node, and pin it there.
1276   if (method()-&gt;is_synchronized()) {
1277     // Insert a FastLockNode right after the Start which takes as arguments
1278     // the current thread pointer, the &quot;this&quot; pointer &amp; the address of the
1279     // stack slot pair used for the lock.  The &quot;this&quot; pointer is a projection
1280     // off the start node, but the locking spot has to be constructed by
1281     // creating a ConLNode of 0, and boxing it with a BoxLockNode.  The BoxLockNode
1282     // becomes the second argument to the FastLockNode call.  The
1283     // FastLockNode becomes the new control parent to pin it to the start.
1284 
1285     // Setup Object Pointer
1286     Node *lock_obj = NULL;
1287     if(method()-&gt;is_static()) {
1288       ciInstance* mirror = _method-&gt;holder()-&gt;java_mirror();
1289       const TypeInstPtr *t_lock = TypeInstPtr::make(mirror);
1290       lock_obj = makecon(t_lock);
1291     } else {                  // Else pass the &quot;this&quot; pointer,
1292       lock_obj = local(0);    // which is Parm0 from StartNode
<span class="line-modified">1293       assert(!_gvn.type(lock_obj)-&gt;make_oopptr()-&gt;can_be_value_type(), &quot;can&#39;t be an inline type&quot;);</span>
1294     }
1295     // Clear out dead values from the debug info.
1296     kill_dead_locals();
1297     // Build the FastLockNode
1298     _synch_lock = shared_lock(lock_obj);
1299   }
1300 
1301   // Feed profiling data for parameters to the type system so it can
1302   // propagate it as speculative types
1303   record_profiled_parameters_for_speculation();
1304 
1305   if (depth() == 1) {
1306     increment_and_test_invocation_counter(Tier2CompileThreshold);
1307   }
1308 }
1309 
1310 //------------------------------init_blocks------------------------------------
1311 // Initialize our parser map to contain the types/monitors at method entry.
1312 void Parse::init_blocks() {
1313   // Create the blocks.
</pre>
<hr />
<pre>
1684 //--------------------handle_missing_successor---------------------------------
1685 void Parse::handle_missing_successor(int target_bci) {
1686 #ifndef PRODUCT
1687   Block* b = block();
1688   int trap_bci = b-&gt;flow()-&gt;has_trap()? b-&gt;flow()-&gt;trap_bci(): -1;
1689   tty-&gt;print_cr(&quot;### Missing successor at bci:%d for block #%d (trap_bci:%d)&quot;, target_bci, b-&gt;rpo(), trap_bci);
1690 #endif
1691   ShouldNotReachHere();
1692 }
1693 
1694 //--------------------------merge_common---------------------------------------
1695 void Parse::merge_common(Parse::Block* target, int pnum) {
1696   if (TraceOptoParse) {
1697     tty-&gt;print(&quot;Merging state at block #%d bci:%d&quot;, target-&gt;rpo(), target-&gt;start());
1698   }
1699 
1700   // Zap extra stack slots to top
1701   assert(sp() == target-&gt;start_sp(), &quot;&quot;);
1702   clean_stack(sp());
1703 
<span class="line-modified">1704   // Check for merge conflicts involving value types</span>
1705   JVMState* old_jvms = map()-&gt;jvms();
1706   int old_bci = bci();
1707   JVMState* tmp_jvms = old_jvms-&gt;clone_shallow(C);
1708   tmp_jvms-&gt;set_should_reexecute(true);
1709   map()-&gt;set_jvms(tmp_jvms);
1710   // Execution needs to restart a the next bytecode (entry of next
1711   // block)
1712   if (target-&gt;is_merged() ||
1713       pnum &gt; PhiNode::Input ||
1714       target-&gt;is_handler() ||
1715       target-&gt;is_loop_head()) {
1716     set_parse_bci(target-&gt;start());
1717     for (uint j = TypeFunc::Parms; j &lt; map()-&gt;req(); j++) {
1718       Node* n = map()-&gt;in(j);                 // Incoming change to target state.
1719       const Type* t = NULL;
1720       if (tmp_jvms-&gt;is_loc(j)) {
1721         t = target-&gt;local_type_at(j - tmp_jvms-&gt;locoff());
1722       } else if (tmp_jvms-&gt;is_stk(j) &amp;&amp; j &lt; (uint)sp() + tmp_jvms-&gt;stkoff()) {
1723         t = target-&gt;stack_type_at(j - tmp_jvms-&gt;stkoff());
1724       }
1725       if (t != NULL &amp;&amp; t != Type::BOTTOM) {
<span class="line-modified">1726         if (n-&gt;is_ValueType() &amp;&amp; !t-&gt;isa_valuetype()) {</span>
<span class="line-modified">1727           // Allocate value type in src block to be able to merge it with oop in target block</span>
<span class="line-modified">1728           map()-&gt;set_req(j, n-&gt;as_ValueType()-&gt;buffer(this));</span>
1729         }
<span class="line-modified">1730         assert(!t-&gt;isa_valuetype() || n-&gt;is_ValueType(), &quot;inconsistent typeflow info&quot;);</span>
1731       }
1732     }
1733   }
1734   map()-&gt;set_jvms(old_jvms);
1735   set_parse_bci(old_bci);
1736 
1737   if (!target-&gt;is_merged()) {   // No prior mapping at this bci
1738     if (TraceOptoParse) { tty-&gt;print(&quot; with empty state&quot;);  }
1739 
1740     // If this path is dead, do not bother capturing it as a merge.
1741     // It is &quot;as if&quot; we had 1 fewer predecessors from the beginning.
1742     if (stopped()) {
1743       if (TraceOptoParse)  tty-&gt;print_cr(&quot;, but path is dead and doesn&#39;t count&quot;);
1744       return;
1745     }
1746 
1747     // Make a region if we know there are multiple or unpredictable inputs.
1748     // (Also, if this is a plain fall-through, we might see another region,
1749     // which must not be allowed into this block&#39;s map.)
1750     if (pnum &gt; PhiNode::Input         // Known multiple inputs.
</pre>
<hr />
<pre>
1813     if (pnum == 1) {            // Last merge for this Region?
1814       if (!block()-&gt;flow()-&gt;is_irreducible_entry()) {
1815         Node* result = _gvn.transform_no_reclaim(r);
1816         if (r != result &amp;&amp; TraceOptoParse) {
1817           tty-&gt;print_cr(&quot;Block #%d replace %d with %d&quot;, block()-&gt;rpo(), r-&gt;_idx, result-&gt;_idx);
1818         }
1819       }
1820       record_for_igvn(r);
1821     }
1822 
1823     // Update all the non-control inputs to map:
1824     assert(TypeFunc::Parms == newin-&gt;jvms()-&gt;locoff(), &quot;parser map should contain only youngest jvms&quot;);
1825     bool check_elide_phi = target-&gt;is_SEL_backedge(save_block);
1826     bool last_merge = (pnum == PhiNode::Input);
1827     for (uint j = 1; j &lt; newin-&gt;req(); j++) {
1828       Node* m = map()-&gt;in(j);   // Current state of target.
1829       Node* n = newin-&gt;in(j);   // Incoming change to target state.
1830       PhiNode* phi;
1831       if (m-&gt;is_Phi() &amp;&amp; m-&gt;as_Phi()-&gt;region() == r) {
1832         phi = m-&gt;as_Phi();
<span class="line-modified">1833       } else if (m-&gt;is_ValueType() &amp;&amp; m-&gt;as_ValueType()-&gt;has_phi_inputs(r)){</span>
<span class="line-modified">1834         phi = m-&gt;as_ValueType()-&gt;get_oop()-&gt;as_Phi();</span>
1835       } else {
1836         phi = NULL;
1837       }
1838       if (m != n) {             // Different; must merge
1839         switch (j) {
1840         // Frame pointer and Return Address never changes
1841         case TypeFunc::FramePtr:// Drop m, use the original value
1842         case TypeFunc::ReturnAdr:
1843           break;
1844         case TypeFunc::Memory:  // Merge inputs to the MergeMem node
1845           assert(phi == NULL, &quot;the merge contains phis, not vice versa&quot;);
1846           merge_memory_edges(n-&gt;as_MergeMem(), pnum, nophi);
1847           continue;
1848         default:                // All normal stuff
1849           if (phi == NULL) {
1850             const JVMState* jvms = map()-&gt;jvms();
1851             if (EliminateNestedLocks &amp;&amp;
1852                 jvms-&gt;is_mon(j) &amp;&amp; jvms-&gt;is_monitor_box(j)) {
1853               // BoxLock nodes are not commoning.
1854               // Use old BoxLock node as merged box.
1855               assert(newin-&gt;jvms()-&gt;is_monitor_box(j), &quot;sanity&quot;);
1856               // This assert also tests that nodes are BoxLock.
1857               assert(BoxLockNode::same_slot(n, m), &quot;sanity&quot;);
1858               C-&gt;gvn_replace_by(n, m);
1859             } else if (!check_elide_phi || !target-&gt;can_elide_SEL_phi(j)) {
1860               phi = ensure_phi(j, nophi);
1861             }
1862           }
1863           break;
1864         }
1865       }
1866       // At this point, n might be top if:
1867       //  - there is no phi (because TypeFlow detected a conflict), or
1868       //  - the corresponding control edges is top (a dead incoming path)
1869       // It is a bug if we create a phi which sees a garbage value on a live path.
1870 
<span class="line-modified">1871       // Merging two value types?</span>
<span class="line-modified">1872       if (phi != NULL &amp;&amp; n-&gt;is_ValueType()) {</span>
1873         // Reload current state because it may have been updated by ensure_phi
1874         m = map()-&gt;in(j);
<span class="line-modified">1875         ValueTypeNode* vtm = m-&gt;as_ValueType(); // Current value type</span>
<span class="line-modified">1876         ValueTypeNode* vtn = n-&gt;as_ValueType(); // Incoming value type</span>
<span class="line-modified">1877         assert(vtm-&gt;get_oop() == phi, &quot;Value type should have Phi input&quot;);</span>
1878         if (TraceOptoParse) {
1879 #ifdef ASSERT
<span class="line-modified">1880           tty-&gt;print_cr(&quot;\nMerging value types&quot;);</span>
1881           tty-&gt;print_cr(&quot;Current:&quot;);
1882           vtm-&gt;dump(2);
1883           tty-&gt;print_cr(&quot;Incoming:&quot;);
1884           vtn-&gt;dump(2);
1885           tty-&gt;cr();
1886 #endif
1887         }
1888         // Do the merge
1889         vtm-&gt;merge_with(&amp;_gvn, vtn, pnum, last_merge);
1890         if (last_merge) {
1891           map()-&gt;set_req(j, _gvn.transform_no_reclaim(vtm));
1892           record_for_igvn(vtm);
1893         }
1894       } else if (phi != NULL) {
1895         assert(n != top() || r-&gt;in(pnum) == top(), &quot;live value must not be garbage&quot;);
1896         assert(phi-&gt;region() == r, &quot;&quot;);
1897         phi-&gt;set_req(pnum, n);  // Then add &#39;n&#39; to the merge
1898         if (last_merge) {
1899           // Last merge for this Phi.
1900           // So far, Phis have had a reasonable type from ciTypeFlow.
</pre>
<hr />
<pre>
2046 
2047   // Add new path to the region.
2048   uint pnum = r-&gt;req();
2049   r-&gt;add_req(NULL);
2050 
2051   for (uint i = 1; i &lt; map-&gt;req(); i++) {
2052     Node* n = map-&gt;in(i);
2053     if (i == TypeFunc::Memory) {
2054       // Ensure a phi on all currently known memories.
2055       for (MergeMemStream mms(n-&gt;as_MergeMem()); mms.next_non_empty(); ) {
2056         Node* phi = mms.memory();
2057         if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;as_Phi()-&gt;region() == r) {
2058           assert(phi-&gt;req() == pnum, &quot;must be same size as region&quot;);
2059           phi-&gt;add_req(NULL);
2060         }
2061       }
2062     } else {
2063       if (n-&gt;is_Phi() &amp;&amp; n-&gt;as_Phi()-&gt;region() == r) {
2064         assert(n-&gt;req() == pnum, &quot;must be same size as region&quot;);
2065         n-&gt;add_req(NULL);
<span class="line-modified">2066       } else if (n-&gt;is_ValueType() &amp;&amp; n-&gt;as_ValueType()-&gt;has_phi_inputs(r)) {</span>
<span class="line-modified">2067         n-&gt;as_ValueType()-&gt;add_new_path(r);</span>
2068       }
2069     }
2070   }
2071 
2072   return pnum;
2073 }
2074 
2075 //------------------------------ensure_phi-------------------------------------
2076 // Turn the idx&#39;th entry of the current map into a Phi
2077 PhiNode *Parse::ensure_phi(int idx, bool nocreate) {
2078   SafePointNode* map = this-&gt;map();
2079   Node* region = map-&gt;control();
2080   assert(region-&gt;is_Region(), &quot;&quot;);
2081 
2082   Node* o = map-&gt;in(idx);
2083   assert(o != NULL, &quot;&quot;);
2084 
2085   if (o == top())  return NULL; // TOP always merges into TOP
2086 
2087   if (o-&gt;is_Phi() &amp;&amp; o-&gt;as_Phi()-&gt;region() == region) {
2088     return o-&gt;as_Phi();
2089   }
<span class="line-modified">2090   ValueTypeBaseNode* vt = o-&gt;isa_ValueType();</span>
2091   if (vt != NULL &amp;&amp; vt-&gt;has_phi_inputs(region)) {
2092     return vt-&gt;get_oop()-&gt;as_Phi();
2093   }
2094 
2095   // Now use a Phi here for merging
2096   assert(!nocreate, &quot;Cannot build a phi for a block already parsed.&quot;);
2097   const JVMState* jvms = map-&gt;jvms();
2098   const Type* t = NULL;
2099   if (jvms-&gt;is_loc(idx)) {
2100     t = block()-&gt;local_type_at(idx - jvms-&gt;locoff());
2101   } else if (jvms-&gt;is_stk(idx)) {
2102     t = block()-&gt;stack_type_at(idx - jvms-&gt;stkoff());
2103   } else if (jvms-&gt;is_mon(idx)) {
2104     assert(!jvms-&gt;is_monitor_box(idx), &quot;no phis for boxes&quot;);
2105     t = TypeInstPtr::BOTTOM; // this is sufficient for a lock object
2106   } else if ((uint)idx &lt; TypeFunc::Parms) {
2107     t = o-&gt;bottom_type();  // Type::RETURN_ADDRESS or such-like.
2108   } else {
2109     assert(false, &quot;no type information for this phi&quot;);
2110   }
2111 
2112   // If the type falls to bottom, then this must be a local that
2113   // is already dead or is mixing ints and oops or some such.
2114   // Forcing it to top makes it go dead.
2115   if (t == Type::BOTTOM) {
2116     map-&gt;set_req(idx, top());
2117     return NULL;
2118   }
2119 
2120   // Do not create phis for top either.
2121   // A top on a non-null control flow must be an unused even after the.phi.
2122   if (t == Type::TOP || t == Type::HALF) {
2123     map-&gt;set_req(idx, top());
2124     return NULL;
2125   }
2126 
2127   if (vt != NULL) {
<span class="line-modified">2128     // Value types are merged by merging their field values.</span>
<span class="line-modified">2129     // Create a cloned ValueTypeNode with phi inputs that</span>
<span class="line-modified">2130     // represents the merged value type and update the map.</span>
2131     vt = vt-&gt;clone_with_phis(&amp;_gvn, region);
2132     map-&gt;set_req(idx, vt);
2133     return vt-&gt;get_oop()-&gt;as_Phi();
2134   } else {
2135     PhiNode* phi = PhiNode::make(region, o, t);
2136     gvn().set_type(phi, t);
2137     if (C-&gt;do_escape_analysis()) record_for_igvn(phi);
2138     map-&gt;set_req(idx, phi);
2139     return phi;
2140   }
2141 }
2142 
2143 //--------------------------ensure_memory_phi----------------------------------
2144 // Turn the idx&#39;th slice of the current memory into a Phi
2145 PhiNode *Parse::ensure_memory_phi(int idx, bool nocreate) {
2146   MergeMemNode* mem = merged_memory();
2147   Node* region = control();
2148   assert(region-&gt;is_Region(), &quot;&quot;);
2149 
2150   Node *o = (idx == Compile::AliasIdxBot)? mem-&gt;base_memory(): mem-&gt;memory_at(idx);
</pre>
<hr />
<pre>
2328       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
2329     call_register_finalizer();
2330   }
2331 
2332   // Do not set_parse_bci, so that return goo is credited to the return insn.
2333   // vreturn can trigger an allocation so vreturn can throw. Setting
2334   // the bci here breaks exception handling. Commenting this out
2335   // doesn&#39;t seem to break anything.
2336   //  set_bci(InvocationEntryBci);
2337   if (method()-&gt;is_synchronized() &amp;&amp; GenerateSynchronizationCode) {
2338     shared_unlock(_synch_lock-&gt;box_node(), _synch_lock-&gt;obj_node());
2339   }
2340   if (C-&gt;env()-&gt;dtrace_method_probes()) {
2341     make_dtrace_method_exit(method());
2342   }
2343   // frame pointer is always same, already captured
2344   if (value != NULL) {
2345     Node* phi = _exits.argument(0);
2346     const Type* return_type = phi-&gt;bottom_type();
2347     const TypeOopPtr* tr = return_type-&gt;isa_oopptr();
<span class="line-modified">2348     if (return_type-&gt;isa_valuetype() &amp;&amp; !Compile::current()-&gt;inlining_incrementally()) {</span>
<span class="line-modified">2349       // Value type is returned as fields, make sure it is scalarized</span>
<span class="line-modified">2350       if (!value-&gt;is_ValueType()) {</span>
<span class="line-modified">2351         value = ValueTypeNode::make_from_oop(this, value, return_type-&gt;value_klass());</span>
2352       }
2353       if (!_caller-&gt;has_method()) {
<span class="line-modified">2354         // Value type is returned as fields from root method, make sure all non-flattened</span>
2355         // fields are buffered and re-execute if allocation triggers deoptimization.
2356         PreserveReexecuteState preexecs(this);
<span class="line-modified">2357         assert(tf()-&gt;returns_value_type_as_fields(), &quot;must be returned as fields&quot;);</span>
2358         jvms()-&gt;set_should_reexecute(true);
2359         inc_sp(1);
<span class="line-modified">2360         value = value-&gt;as_ValueType()-&gt;allocate_fields(this);</span>
2361       }
<span class="line-modified">2362     } else if (value-&gt;is_ValueType()) {</span>
<span class="line-modified">2363       // Value type is returned as oop, make sure it is buffered and re-execute</span>
2364       // if allocation triggers deoptimization.
2365       PreserveReexecuteState preexecs(this);
2366       jvms()-&gt;set_should_reexecute(true);
2367       inc_sp(1);
<span class="line-modified">2368       value = value-&gt;as_ValueType()-&gt;buffer(this);</span>
2369       if (Compile::current()-&gt;inlining_incrementally()) {
<span class="line-modified">2370         value = value-&gt;as_ValueTypeBase()-&gt;allocate_fields(this);</span>
2371       }
2372     } else if (tr &amp;&amp; tr-&gt;isa_instptr() &amp;&amp; tr-&gt;klass()-&gt;is_loaded() &amp;&amp; tr-&gt;klass()-&gt;is_interface()) {
2373       // If returning oops to an interface-return, there is a silent free
2374       // cast from oop to interface allowed by the Verifier. Make it explicit here.
2375       const TypeInstPtr* tp = value-&gt;bottom_type()-&gt;isa_instptr();
2376       if (tp &amp;&amp; tp-&gt;klass()-&gt;is_loaded() &amp;&amp; !tp-&gt;klass()-&gt;is_interface()) {
2377         // sharpen the type eagerly; this eases certain assert checking
2378         if (tp-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
2379           tr = tr-&gt;join_speculative(TypeInstPtr::NOTNULL)-&gt;is_instptr();
2380         }
2381         value = _gvn.transform(new CheckCastPPNode(0, value, tr));
2382       }
2383     } else {
2384       // Handle returns of oop-arrays to an arrays-of-interface return
2385       const TypeInstPtr* phi_tip;
2386       const TypeInstPtr* val_tip;
2387       Type::get_arrays_base_elements(return_type, value-&gt;bottom_type(), &amp;phi_tip, &amp;val_tip);
2388       if (phi_tip != NULL &amp;&amp; phi_tip-&gt;is_loaded() &amp;&amp; phi_tip-&gt;klass()-&gt;is_interface() &amp;&amp;
2389           val_tip != NULL &amp;&amp; val_tip-&gt;is_loaded() &amp;&amp; !val_tip-&gt;klass()-&gt;is_interface()) {
2390         value = _gvn.transform(new CheckCastPPNode(0, value, return_type));
</pre>
</td>
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;interpreter/linkResolver.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;oops/method.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/c2compiler.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/idealGraphPrinter.hpp&quot;
<span class="line-added">  34 #include &quot;opto/inlinetypenode.hpp&quot;</span>
  35 #include &quot;opto/locknode.hpp&quot;
  36 #include &quot;opto/memnode.hpp&quot;
  37 #include &quot;opto/opaquenode.hpp&quot;
  38 #include &quot;opto/parse.hpp&quot;
  39 #include &quot;opto/rootnode.hpp&quot;
  40 #include &quot;opto/runtime.hpp&quot;

  41 #include &quot;runtime/arguments.hpp&quot;
  42 #include &quot;runtime/handles.inline.hpp&quot;
  43 #include &quot;runtime/safepointMechanism.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;utilities/bitMap.inline.hpp&quot;
  46 #include &quot;utilities/copy.hpp&quot;
  47 
  48 // Static array so we can figure out which bytecodes stop us from compiling
  49 // the most. Some of the non-static variables are needed in bytecodeInfo.cpp
  50 // and eventually should be encapsulated in a proper class (gri 8/18/98).
  51 
  52 #ifndef PRODUCT
  53 int nodes_created              = 0;
  54 int methods_parsed             = 0;
  55 int methods_seen               = 0;
  56 int blocks_parsed              = 0;
  57 int blocks_seen                = 0;
  58 
  59 int explicit_null_checks_inserted = 0;
  60 int explicit_null_checks_elided   = 0;
</pre>
<hr />
<pre>
 139       l = (bt == T_DOUBLE)
 140         ? (Node*)new LoadD_unalignedNode(ctl, mem, adr, TypeRawPtr::BOTTOM, MemNode::unordered)
 141         : (Node*)new LoadL_unalignedNode(ctl, mem, adr, TypeRawPtr::BOTTOM, MemNode::unordered);
 142     }
 143     break;
 144   }
 145   default: ShouldNotReachHere();
 146   }
 147   return _gvn.transform(l);
 148 }
 149 
 150 // Helper routine to prevent the interpreter from handing
 151 // unexpected typestate to an OSR method.
 152 // The Node l is a value newly dug out of the interpreter frame.
 153 // The type is the type predicted by ciTypeFlow.  Note that it is
 154 // not a general type, but can only come from Type::get_typeflow_type.
 155 // The safepoint is a map which will feed an uncommon trap.
 156 Node* Parse::check_interpreter_type(Node* l, const Type* type,
 157                                     SafePointNode* &amp;bad_type_exit) {
 158   const TypeOopPtr* tp = type-&gt;isa_oopptr();
<span class="line-modified"> 159   if (type-&gt;isa_inlinetype() != NULL) {</span>
<span class="line-modified"> 160     // The interpreter passes inline types as oops</span>
<span class="line-modified"> 161     tp = TypeOopPtr::make_from_klass(type-&gt;inline_klass());</span>
 162     tp = tp-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
 163   }
 164 
 165   // TypeFlow may assert null-ness if a type appears unloaded.
 166   if (type == TypePtr::NULL_PTR ||
 167       (tp != NULL &amp;&amp; !tp-&gt;klass()-&gt;is_loaded())) {
 168     // Value must be null, not a real oop.
 169     Node* chk = _gvn.transform( new CmpPNode(l, null()) );
 170     Node* tst = _gvn.transform( new BoolNode(chk, BoolTest::eq) );
 171     IfNode* iff = create_and_map_if(control(), tst, PROB_MAX, COUNT_UNKNOWN);
 172     set_control(_gvn.transform( new IfTrueNode(iff) ));
 173     Node* bad_type = _gvn.transform( new IfFalseNode(iff) );
 174     bad_type_exit-&gt;control()-&gt;add_req(bad_type);
 175     l = null();
 176   }
 177 
 178   // Typeflow can also cut off paths from the CFG, based on
 179   // types which appear unloaded, or call sites which appear unlinked.
 180   // When paths are cut off, values at later merge points can rise
 181   // toward more specific classes.  Make sure these specific classes
 182   // are still in effect.
 183   if (tp != NULL &amp;&amp; tp-&gt;klass() != C-&gt;env()-&gt;Object_klass()) {
 184     // TypeFlow asserted a specific object type.  Value must have that type.
 185     Node* bad_type_ctrl = NULL;
<span class="line-modified"> 186     if (tp-&gt;klass()-&gt;is_inlinetype()) {</span>
<span class="line-modified"> 187       // Check inline types for null here to prevent checkcast from adding an</span>
 188       // exception state before the bytecode entry (use &#39;bad_type_ctrl&#39; instead).
 189       l = null_check_oop(l, &amp;bad_type_ctrl);
 190       bad_type_exit-&gt;control()-&gt;add_req(bad_type_ctrl);
 191     }
 192     l = gen_checkcast(l, makecon(TypeKlassPtr::make(tp-&gt;klass())), &amp;bad_type_ctrl);
 193     bad_type_exit-&gt;control()-&gt;add_req(bad_type_ctrl);
 194   }
 195   assert(_gvn.type(l)-&gt;higher_equal(type), &quot;must constrain OSR typestate&quot;);
 196   return l;
 197 }
 198 
 199 // Helper routine which sets up elements of the initial parser map when
 200 // performing a parse for on stack replacement.  Add values into map.
 201 // The only parameter contains the address of a interpreter arguments.
 202 void Parse::load_interpreter_state(Node* osr_buf) {
 203   int index;
 204   int max_locals = jvms()-&gt;loc_size();
 205   int max_stack  = jvms()-&gt;stk_size();
 206 
 207   // Mismatch between method and jvms can occur since map briefly held
</pre>
<hr />
<pre>
 586     }
 587   }
 588 
 589   if (depth() == 1 &amp;&amp; !failing()) {
 590     if (C-&gt;clinit_barrier_on_entry()) {
 591       // Add check to deoptimize the nmethod once the holder class is fully initialized
 592       clinit_deopt();
 593     }
 594 
 595     // Add check to deoptimize the nmethod if RTM state was changed
 596     rtm_deopt();
 597   }
 598 
 599   // Check for bailouts during method entry or RTM state check setup.
 600   if (failing()) {
 601     if (log)  log-&gt;done(&quot;parse&quot;);
 602     C-&gt;set_default_node_notes(caller_nn);
 603     return;
 604   }
 605 
<span class="line-modified"> 606   // Handle inline type arguments</span>
 607   int arg_size_sig = tf()-&gt;domain_sig()-&gt;cnt();
 608   for (uint i = 0; i &lt; (uint)arg_size_sig; i++) {
 609     Node* parm = map()-&gt;in(i);
 610     const Type* t = _gvn.type(parm);
<span class="line-modified"> 611     if (t-&gt;is_inlinetypeptr() &amp;&amp; t-&gt;inline_klass()-&gt;is_scalarizable() &amp;&amp; !t-&gt;maybe_null()) {</span>
<span class="line-modified"> 612       // Create InlineTypeNode from the oop and replace the parameter</span>
<span class="line-modified"> 613       Node* vt = InlineTypeNode::make_from_oop(this, parm, t-&gt;inline_klass());</span>
 614       map()-&gt;replace_edge(parm, vt);
 615     } else if (UseTypeSpeculation &amp;&amp; (i == (uint)(arg_size_sig - 1)) &amp;&amp; !is_osr_parse() &amp;&amp;
 616                method()-&gt;has_vararg() &amp;&amp; t-&gt;isa_aryptr() != NULL &amp;&amp; !t-&gt;is_aryptr()-&gt;is_not_null_free()) {
 617       // Speculate on varargs Object array being not null-free (and therefore also not flattened)
 618       const TypePtr* spec_type = t-&gt;speculative();
 619       spec_type = (spec_type != NULL &amp;&amp; spec_type-&gt;isa_aryptr() != NULL) ? spec_type : t-&gt;is_aryptr();
 620       spec_type = spec_type-&gt;remove_speculative()-&gt;is_aryptr()-&gt;cast_to_not_null_free();
 621       spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::Offset::bottom, TypeOopPtr::InstanceBot, spec_type);
 622       Node* cast = _gvn.transform(new CheckCastPPNode(control(), parm, t-&gt;join_speculative(spec_type)));
 623       replace_in_map(parm, cast);
 624     }
 625   }
 626 
 627   entry_map = map();  // capture any changes performed by method setup code
 628   assert(jvms()-&gt;endoff() == map()-&gt;req(), &quot;map matches JVMS layout&quot;);
 629 
 630   // We begin parsing as if we have just encountered a jump to the
 631   // method entry.
 632   Block* entry_block = start_block();
 633   assert(entry_block-&gt;start() == (is_osr_parse() ? osr_bci() : 0), &quot;&quot;);
</pre>
<hr />
<pre>
 808   // Add a return value to the exit state.  (Do not push it yet.)
 809   if (tf()-&gt;range_sig()-&gt;cnt() &gt; TypeFunc::Parms) {
 810     const Type* ret_type = tf()-&gt;range_sig()-&gt;field_at(TypeFunc::Parms);
 811     if (ret_type-&gt;isa_int()) {
 812       BasicType ret_bt = method()-&gt;return_type()-&gt;basic_type();
 813       if (ret_bt == T_BOOLEAN ||
 814           ret_bt == T_CHAR ||
 815           ret_bt == T_BYTE ||
 816           ret_bt == T_SHORT) {
 817         ret_type = TypeInt::INT;
 818       }
 819     }
 820 
 821     // Don&#39;t &quot;bind&quot; an unloaded return klass to the ret_phi. If the klass
 822     // becomes loaded during the subsequent parsing, the loaded and unloaded
 823     // types will not join when we transform and push in do_exits().
 824     const TypeOopPtr* ret_oop_type = ret_type-&gt;isa_oopptr();
 825     if (ret_oop_type &amp;&amp; !ret_oop_type-&gt;klass()-&gt;is_loaded()) {
 826       ret_type = TypeOopPtr::BOTTOM;
 827     }
<span class="line-modified"> 828     if ((_caller-&gt;has_method() || tf()-&gt;returns_inline_type_as_fields()) &amp;&amp;</span>
<span class="line-modified"> 829         ret_type-&gt;is_inlinetypeptr() &amp;&amp; ret_type-&gt;inline_klass()-&gt;is_scalarizable() &amp;&amp; !ret_type-&gt;maybe_null()) {</span>
<span class="line-modified"> 830       // Scalarize inline type return when inlining or with multiple return values</span>
<span class="line-modified"> 831       ret_type = TypeInlineType::make(ret_type-&gt;inline_klass());</span>
 832     }
 833     int         ret_size = type2size[ret_type-&gt;basic_type()];
 834     Node*       ret_phi  = new PhiNode(region, ret_type);
 835     gvn().set_type_bottom(ret_phi);
 836     _exits.ensure_stack(ret_size);
 837     assert((int)(tf()-&gt;range_sig()-&gt;cnt() - TypeFunc::Parms) == ret_size, &quot;good tf range&quot;);
 838     assert(method()-&gt;return_type()-&gt;size() == ret_size, &quot;tf agrees w/ method&quot;);
 839     _exits.set_argument(0, ret_phi);  // here is where the parser finds it
 840     // Note:  ret_phi is not yet pushed, until do_exits.
 841   }
 842 }
 843 
 844 //----------------------------build_start_state-------------------------------
 845 // Construct a state which contains only the incoming arguments from an
 846 // unknown caller.  The method &amp; bci will be NULL &amp; InvocationEntryBci.
 847 JVMState* Compile::build_start_state(StartNode* start, const TypeFunc* tf) {
 848   int        arg_size = tf-&gt;domain_sig()-&gt;cnt();
 849   int        max_size = MAX2(arg_size, (int)tf-&gt;range_cc()-&gt;cnt());
 850   JVMState*  jvms     = new (this) JVMState(max_size - TypeFunc::Parms);
 851   SafePointNode* map  = new SafePointNode(max_size, NULL);
 852   map-&gt;set_jvms(jvms);
 853   jvms-&gt;set_map(map);
 854   record_for_igvn(map);
 855   assert(arg_size == TypeFunc::Parms + (is_osr_compilation() ? 1 : method()-&gt;arg_size()), &quot;correct arg_size&quot;);
 856   Node_Notes* old_nn = default_node_notes();
 857   if (old_nn != NULL &amp;&amp; has_method()) {
 858     Node_Notes* entry_nn = old_nn-&gt;clone(this);
 859     JVMState* entry_jvms = new(this) JVMState(method(), old_nn-&gt;jvms());
 860     entry_jvms-&gt;set_offsets(0);
 861     entry_jvms-&gt;set_bci(entry_bci());
 862     entry_nn-&gt;set_jvms(entry_jvms);
 863     set_default_node_notes(entry_nn);
 864   }
 865   PhaseGVN&amp; gvn = *initial_gvn();
 866   uint j = 0;
 867   ExtendedSignature sig_cc = ExtendedSignature(method()-&gt;get_sig_cc(), SigEntryFilter());
 868   for (uint i = 0; i &lt; (uint)arg_size; i++) {
 869     const Type* t = tf-&gt;domain_sig()-&gt;field_at(i);
 870     Node* parm = NULL;
<span class="line-modified"> 871     if (has_scalarized_args() &amp;&amp; t-&gt;is_inlinetypeptr() &amp;&amp; !t-&gt;maybe_null()) {</span>
<span class="line-modified"> 872       // Inline type arguments are not passed by reference: we get an argument per</span>
<span class="line-modified"> 873       // field of the inline type. Build InlineTypeNodes from the inline type arguments.</span>
 874       GraphKit kit(jvms, &amp;gvn);
 875       kit.set_control(map-&gt;control());
 876       Node* old_mem = map-&gt;memory();
<span class="line-modified"> 877       // Use immutable memory for inline type loads and restore it below</span>
<span class="line-modified"> 878       // TODO make sure inline types are always loaded from immutable memory</span>
 879       kit.set_all_memory(C-&gt;immutable_memory());
<span class="line-modified"> 880       parm = InlineTypeNode::make_from_multi(&amp;kit, start, sig_cc, t-&gt;inline_klass(), j, true);</span>
 881       map-&gt;set_control(kit.control());
 882       map-&gt;set_memory(old_mem);
 883     } else {
 884       parm = gvn.transform(new ParmNode(start, j++));
 885       BasicType bt = t-&gt;basic_type();
 886       while (i &gt;= TypeFunc::Parms &amp;&amp; !is_osr_compilation() &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt, true)) {
 887         j += type2size[bt]; // Skip reserved arguments
 888       }
 889     }
 890     map-&gt;init_req(i, parm);
 891     // Record all these guys for later GVN.
 892     record_for_igvn(parm);
 893   }
 894   for (; j &lt; map-&gt;req(); j++) {
 895     map-&gt;init_req(j, top());
 896   }
 897   assert(jvms-&gt;argoff() == TypeFunc::Parms, &quot;parser gets arguments here&quot;);
 898   set_default_node_notes(old_nn);
 899   return jvms;
 900 }
</pre>
<hr />
<pre>
 910   nn-&gt;set_jvms(jvms);
 911   return nn;
 912 }
 913 
 914 
 915 //--------------------------return_values--------------------------------------
 916 void Compile::return_values(JVMState* jvms) {
 917   GraphKit kit(jvms);
 918   Node* ret = new ReturnNode(TypeFunc::Parms,
 919                              kit.control(),
 920                              kit.i_o(),
 921                              kit.reset_memory(),
 922                              kit.frameptr(),
 923                              kit.returnadr());
 924   // Add zero or 1 return values
 925   int ret_size = tf()-&gt;range_sig()-&gt;cnt() - TypeFunc::Parms;
 926   if (ret_size &gt; 0) {
 927     kit.inc_sp(-ret_size);  // pop the return value(s)
 928     kit.sync_jvms();
 929     Node* res = kit.argument(0);
<span class="line-modified"> 930     if (tf()-&gt;returns_inline_type_as_fields()) {</span>
<span class="line-modified"> 931       // Multiple return values (inline type fields): add as many edges</span>
 932       // to the Return node as returned values.
<span class="line-modified"> 933       assert(res-&gt;is_InlineType(), &quot;what else supports multi value return?&quot;);</span>
<span class="line-modified"> 934       InlineTypeNode* vt = res-&gt;as_InlineType();</span>
 935       ret-&gt;add_req_batch(NULL, tf()-&gt;range_cc()-&gt;cnt() - TypeFunc::Parms);
 936       if (vt-&gt;is_allocated(&amp;kit.gvn()) &amp;&amp; !StressInlineTypeReturnedAsFields) {
 937         ret-&gt;init_req(TypeFunc::Parms, vt-&gt;get_oop());
 938       } else {
 939         ret-&gt;init_req(TypeFunc::Parms, vt-&gt;tagged_klass(kit.gvn()));
 940       }
<span class="line-modified"> 941       const Array&lt;SigEntry&gt;* sig_array = vt-&gt;type()-&gt;inline_klass()-&gt;extended_sig();</span>
 942       GrowableArray&lt;SigEntry&gt; sig = GrowableArray&lt;SigEntry&gt;(sig_array-&gt;length());
 943       sig.appendAll(sig_array);
 944       ExtendedSignature sig_cc = ExtendedSignature(&amp;sig, SigEntryFilter());
 945       uint idx = TypeFunc::Parms+1;
 946       vt-&gt;pass_fields(&amp;kit, ret, sig_cc, idx);
 947     } else {
 948       ret-&gt;add_req(res);
 949       // Note:  The second dummy edge is not needed by a ReturnNode.
 950     }
 951   }
 952   // bind it to root
 953   root()-&gt;add_req(ret);
 954   record_for_igvn(ret);
 955   initial_gvn()-&gt;transform_no_reclaim(ret);
 956 }
 957 
 958 //------------------------rethrow_exceptions-----------------------------------
 959 // Bind all exception states in the list into a single RethrowNode.
 960 void Compile::rethrow_exceptions(JVMState* jvms) {
 961   GraphKit kit(jvms);
</pre>
<hr />
<pre>
1273 
1274   // If the method is synchronized, we need to construct a lock node, attach
1275   // it to the Start node, and pin it there.
1276   if (method()-&gt;is_synchronized()) {
1277     // Insert a FastLockNode right after the Start which takes as arguments
1278     // the current thread pointer, the &quot;this&quot; pointer &amp; the address of the
1279     // stack slot pair used for the lock.  The &quot;this&quot; pointer is a projection
1280     // off the start node, but the locking spot has to be constructed by
1281     // creating a ConLNode of 0, and boxing it with a BoxLockNode.  The BoxLockNode
1282     // becomes the second argument to the FastLockNode call.  The
1283     // FastLockNode becomes the new control parent to pin it to the start.
1284 
1285     // Setup Object Pointer
1286     Node *lock_obj = NULL;
1287     if(method()-&gt;is_static()) {
1288       ciInstance* mirror = _method-&gt;holder()-&gt;java_mirror();
1289       const TypeInstPtr *t_lock = TypeInstPtr::make(mirror);
1290       lock_obj = makecon(t_lock);
1291     } else {                  // Else pass the &quot;this&quot; pointer,
1292       lock_obj = local(0);    // which is Parm0 from StartNode
<span class="line-modified">1293       assert(!_gvn.type(lock_obj)-&gt;make_oopptr()-&gt;can_be_inline_type(), &quot;can&#39;t be an inline type&quot;);</span>
1294     }
1295     // Clear out dead values from the debug info.
1296     kill_dead_locals();
1297     // Build the FastLockNode
1298     _synch_lock = shared_lock(lock_obj);
1299   }
1300 
1301   // Feed profiling data for parameters to the type system so it can
1302   // propagate it as speculative types
1303   record_profiled_parameters_for_speculation();
1304 
1305   if (depth() == 1) {
1306     increment_and_test_invocation_counter(Tier2CompileThreshold);
1307   }
1308 }
1309 
1310 //------------------------------init_blocks------------------------------------
1311 // Initialize our parser map to contain the types/monitors at method entry.
1312 void Parse::init_blocks() {
1313   // Create the blocks.
</pre>
<hr />
<pre>
1684 //--------------------handle_missing_successor---------------------------------
1685 void Parse::handle_missing_successor(int target_bci) {
1686 #ifndef PRODUCT
1687   Block* b = block();
1688   int trap_bci = b-&gt;flow()-&gt;has_trap()? b-&gt;flow()-&gt;trap_bci(): -1;
1689   tty-&gt;print_cr(&quot;### Missing successor at bci:%d for block #%d (trap_bci:%d)&quot;, target_bci, b-&gt;rpo(), trap_bci);
1690 #endif
1691   ShouldNotReachHere();
1692 }
1693 
1694 //--------------------------merge_common---------------------------------------
1695 void Parse::merge_common(Parse::Block* target, int pnum) {
1696   if (TraceOptoParse) {
1697     tty-&gt;print(&quot;Merging state at block #%d bci:%d&quot;, target-&gt;rpo(), target-&gt;start());
1698   }
1699 
1700   // Zap extra stack slots to top
1701   assert(sp() == target-&gt;start_sp(), &quot;&quot;);
1702   clean_stack(sp());
1703 
<span class="line-modified">1704   // Check for merge conflicts involving inline types</span>
1705   JVMState* old_jvms = map()-&gt;jvms();
1706   int old_bci = bci();
1707   JVMState* tmp_jvms = old_jvms-&gt;clone_shallow(C);
1708   tmp_jvms-&gt;set_should_reexecute(true);
1709   map()-&gt;set_jvms(tmp_jvms);
1710   // Execution needs to restart a the next bytecode (entry of next
1711   // block)
1712   if (target-&gt;is_merged() ||
1713       pnum &gt; PhiNode::Input ||
1714       target-&gt;is_handler() ||
1715       target-&gt;is_loop_head()) {
1716     set_parse_bci(target-&gt;start());
1717     for (uint j = TypeFunc::Parms; j &lt; map()-&gt;req(); j++) {
1718       Node* n = map()-&gt;in(j);                 // Incoming change to target state.
1719       const Type* t = NULL;
1720       if (tmp_jvms-&gt;is_loc(j)) {
1721         t = target-&gt;local_type_at(j - tmp_jvms-&gt;locoff());
1722       } else if (tmp_jvms-&gt;is_stk(j) &amp;&amp; j &lt; (uint)sp() + tmp_jvms-&gt;stkoff()) {
1723         t = target-&gt;stack_type_at(j - tmp_jvms-&gt;stkoff());
1724       }
1725       if (t != NULL &amp;&amp; t != Type::BOTTOM) {
<span class="line-modified">1726         if (n-&gt;is_InlineType() &amp;&amp; !t-&gt;isa_inlinetype()) {</span>
<span class="line-modified">1727           // Allocate inline type in src block to be able to merge it with oop in target block</span>
<span class="line-modified">1728           map()-&gt;set_req(j, n-&gt;as_InlineType()-&gt;buffer(this));</span>
1729         }
<span class="line-modified">1730         assert(!t-&gt;isa_inlinetype() || n-&gt;is_InlineType(), &quot;inconsistent typeflow info&quot;);</span>
1731       }
1732     }
1733   }
1734   map()-&gt;set_jvms(old_jvms);
1735   set_parse_bci(old_bci);
1736 
1737   if (!target-&gt;is_merged()) {   // No prior mapping at this bci
1738     if (TraceOptoParse) { tty-&gt;print(&quot; with empty state&quot;);  }
1739 
1740     // If this path is dead, do not bother capturing it as a merge.
1741     // It is &quot;as if&quot; we had 1 fewer predecessors from the beginning.
1742     if (stopped()) {
1743       if (TraceOptoParse)  tty-&gt;print_cr(&quot;, but path is dead and doesn&#39;t count&quot;);
1744       return;
1745     }
1746 
1747     // Make a region if we know there are multiple or unpredictable inputs.
1748     // (Also, if this is a plain fall-through, we might see another region,
1749     // which must not be allowed into this block&#39;s map.)
1750     if (pnum &gt; PhiNode::Input         // Known multiple inputs.
</pre>
<hr />
<pre>
1813     if (pnum == 1) {            // Last merge for this Region?
1814       if (!block()-&gt;flow()-&gt;is_irreducible_entry()) {
1815         Node* result = _gvn.transform_no_reclaim(r);
1816         if (r != result &amp;&amp; TraceOptoParse) {
1817           tty-&gt;print_cr(&quot;Block #%d replace %d with %d&quot;, block()-&gt;rpo(), r-&gt;_idx, result-&gt;_idx);
1818         }
1819       }
1820       record_for_igvn(r);
1821     }
1822 
1823     // Update all the non-control inputs to map:
1824     assert(TypeFunc::Parms == newin-&gt;jvms()-&gt;locoff(), &quot;parser map should contain only youngest jvms&quot;);
1825     bool check_elide_phi = target-&gt;is_SEL_backedge(save_block);
1826     bool last_merge = (pnum == PhiNode::Input);
1827     for (uint j = 1; j &lt; newin-&gt;req(); j++) {
1828       Node* m = map()-&gt;in(j);   // Current state of target.
1829       Node* n = newin-&gt;in(j);   // Incoming change to target state.
1830       PhiNode* phi;
1831       if (m-&gt;is_Phi() &amp;&amp; m-&gt;as_Phi()-&gt;region() == r) {
1832         phi = m-&gt;as_Phi();
<span class="line-modified">1833       } else if (m-&gt;is_InlineType() &amp;&amp; m-&gt;as_InlineType()-&gt;has_phi_inputs(r)){</span>
<span class="line-modified">1834         phi = m-&gt;as_InlineType()-&gt;get_oop()-&gt;as_Phi();</span>
1835       } else {
1836         phi = NULL;
1837       }
1838       if (m != n) {             // Different; must merge
1839         switch (j) {
1840         // Frame pointer and Return Address never changes
1841         case TypeFunc::FramePtr:// Drop m, use the original value
1842         case TypeFunc::ReturnAdr:
1843           break;
1844         case TypeFunc::Memory:  // Merge inputs to the MergeMem node
1845           assert(phi == NULL, &quot;the merge contains phis, not vice versa&quot;);
1846           merge_memory_edges(n-&gt;as_MergeMem(), pnum, nophi);
1847           continue;
1848         default:                // All normal stuff
1849           if (phi == NULL) {
1850             const JVMState* jvms = map()-&gt;jvms();
1851             if (EliminateNestedLocks &amp;&amp;
1852                 jvms-&gt;is_mon(j) &amp;&amp; jvms-&gt;is_monitor_box(j)) {
1853               // BoxLock nodes are not commoning.
1854               // Use old BoxLock node as merged box.
1855               assert(newin-&gt;jvms()-&gt;is_monitor_box(j), &quot;sanity&quot;);
1856               // This assert also tests that nodes are BoxLock.
1857               assert(BoxLockNode::same_slot(n, m), &quot;sanity&quot;);
1858               C-&gt;gvn_replace_by(n, m);
1859             } else if (!check_elide_phi || !target-&gt;can_elide_SEL_phi(j)) {
1860               phi = ensure_phi(j, nophi);
1861             }
1862           }
1863           break;
1864         }
1865       }
1866       // At this point, n might be top if:
1867       //  - there is no phi (because TypeFlow detected a conflict), or
1868       //  - the corresponding control edges is top (a dead incoming path)
1869       // It is a bug if we create a phi which sees a garbage value on a live path.
1870 
<span class="line-modified">1871       // Merging two inline types?</span>
<span class="line-modified">1872       if (phi != NULL &amp;&amp; n-&gt;is_InlineType()) {</span>
1873         // Reload current state because it may have been updated by ensure_phi
1874         m = map()-&gt;in(j);
<span class="line-modified">1875         InlineTypeNode* vtm = m-&gt;as_InlineType(); // Current inline type</span>
<span class="line-modified">1876         InlineTypeNode* vtn = n-&gt;as_InlineType(); // Incoming inline type</span>
<span class="line-modified">1877         assert(vtm-&gt;get_oop() == phi, &quot;Inline type should have Phi input&quot;);</span>
1878         if (TraceOptoParse) {
1879 #ifdef ASSERT
<span class="line-modified">1880           tty-&gt;print_cr(&quot;\nMerging inline types&quot;);</span>
1881           tty-&gt;print_cr(&quot;Current:&quot;);
1882           vtm-&gt;dump(2);
1883           tty-&gt;print_cr(&quot;Incoming:&quot;);
1884           vtn-&gt;dump(2);
1885           tty-&gt;cr();
1886 #endif
1887         }
1888         // Do the merge
1889         vtm-&gt;merge_with(&amp;_gvn, vtn, pnum, last_merge);
1890         if (last_merge) {
1891           map()-&gt;set_req(j, _gvn.transform_no_reclaim(vtm));
1892           record_for_igvn(vtm);
1893         }
1894       } else if (phi != NULL) {
1895         assert(n != top() || r-&gt;in(pnum) == top(), &quot;live value must not be garbage&quot;);
1896         assert(phi-&gt;region() == r, &quot;&quot;);
1897         phi-&gt;set_req(pnum, n);  // Then add &#39;n&#39; to the merge
1898         if (last_merge) {
1899           // Last merge for this Phi.
1900           // So far, Phis have had a reasonable type from ciTypeFlow.
</pre>
<hr />
<pre>
2046 
2047   // Add new path to the region.
2048   uint pnum = r-&gt;req();
2049   r-&gt;add_req(NULL);
2050 
2051   for (uint i = 1; i &lt; map-&gt;req(); i++) {
2052     Node* n = map-&gt;in(i);
2053     if (i == TypeFunc::Memory) {
2054       // Ensure a phi on all currently known memories.
2055       for (MergeMemStream mms(n-&gt;as_MergeMem()); mms.next_non_empty(); ) {
2056         Node* phi = mms.memory();
2057         if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;as_Phi()-&gt;region() == r) {
2058           assert(phi-&gt;req() == pnum, &quot;must be same size as region&quot;);
2059           phi-&gt;add_req(NULL);
2060         }
2061       }
2062     } else {
2063       if (n-&gt;is_Phi() &amp;&amp; n-&gt;as_Phi()-&gt;region() == r) {
2064         assert(n-&gt;req() == pnum, &quot;must be same size as region&quot;);
2065         n-&gt;add_req(NULL);
<span class="line-modified">2066       } else if (n-&gt;is_InlineType() &amp;&amp; n-&gt;as_InlineType()-&gt;has_phi_inputs(r)) {</span>
<span class="line-modified">2067         n-&gt;as_InlineType()-&gt;add_new_path(r);</span>
2068       }
2069     }
2070   }
2071 
2072   return pnum;
2073 }
2074 
2075 //------------------------------ensure_phi-------------------------------------
2076 // Turn the idx&#39;th entry of the current map into a Phi
2077 PhiNode *Parse::ensure_phi(int idx, bool nocreate) {
2078   SafePointNode* map = this-&gt;map();
2079   Node* region = map-&gt;control();
2080   assert(region-&gt;is_Region(), &quot;&quot;);
2081 
2082   Node* o = map-&gt;in(idx);
2083   assert(o != NULL, &quot;&quot;);
2084 
2085   if (o == top())  return NULL; // TOP always merges into TOP
2086 
2087   if (o-&gt;is_Phi() &amp;&amp; o-&gt;as_Phi()-&gt;region() == region) {
2088     return o-&gt;as_Phi();
2089   }
<span class="line-modified">2090   InlineTypeBaseNode* vt = o-&gt;isa_InlineType();</span>
2091   if (vt != NULL &amp;&amp; vt-&gt;has_phi_inputs(region)) {
2092     return vt-&gt;get_oop()-&gt;as_Phi();
2093   }
2094 
2095   // Now use a Phi here for merging
2096   assert(!nocreate, &quot;Cannot build a phi for a block already parsed.&quot;);
2097   const JVMState* jvms = map-&gt;jvms();
2098   const Type* t = NULL;
2099   if (jvms-&gt;is_loc(idx)) {
2100     t = block()-&gt;local_type_at(idx - jvms-&gt;locoff());
2101   } else if (jvms-&gt;is_stk(idx)) {
2102     t = block()-&gt;stack_type_at(idx - jvms-&gt;stkoff());
2103   } else if (jvms-&gt;is_mon(idx)) {
2104     assert(!jvms-&gt;is_monitor_box(idx), &quot;no phis for boxes&quot;);
2105     t = TypeInstPtr::BOTTOM; // this is sufficient for a lock object
2106   } else if ((uint)idx &lt; TypeFunc::Parms) {
2107     t = o-&gt;bottom_type();  // Type::RETURN_ADDRESS or such-like.
2108   } else {
2109     assert(false, &quot;no type information for this phi&quot;);
2110   }
2111 
2112   // If the type falls to bottom, then this must be a local that
2113   // is already dead or is mixing ints and oops or some such.
2114   // Forcing it to top makes it go dead.
2115   if (t == Type::BOTTOM) {
2116     map-&gt;set_req(idx, top());
2117     return NULL;
2118   }
2119 
2120   // Do not create phis for top either.
2121   // A top on a non-null control flow must be an unused even after the.phi.
2122   if (t == Type::TOP || t == Type::HALF) {
2123     map-&gt;set_req(idx, top());
2124     return NULL;
2125   }
2126 
2127   if (vt != NULL) {
<span class="line-modified">2128     // Inline types are merged by merging their field values.</span>
<span class="line-modified">2129     // Create a cloned InlineTypeNode with phi inputs that</span>
<span class="line-modified">2130     // represents the merged inline type and update the map.</span>
2131     vt = vt-&gt;clone_with_phis(&amp;_gvn, region);
2132     map-&gt;set_req(idx, vt);
2133     return vt-&gt;get_oop()-&gt;as_Phi();
2134   } else {
2135     PhiNode* phi = PhiNode::make(region, o, t);
2136     gvn().set_type(phi, t);
2137     if (C-&gt;do_escape_analysis()) record_for_igvn(phi);
2138     map-&gt;set_req(idx, phi);
2139     return phi;
2140   }
2141 }
2142 
2143 //--------------------------ensure_memory_phi----------------------------------
2144 // Turn the idx&#39;th slice of the current memory into a Phi
2145 PhiNode *Parse::ensure_memory_phi(int idx, bool nocreate) {
2146   MergeMemNode* mem = merged_memory();
2147   Node* region = control();
2148   assert(region-&gt;is_Region(), &quot;&quot;);
2149 
2150   Node *o = (idx == Compile::AliasIdxBot)? mem-&gt;base_memory(): mem-&gt;memory_at(idx);
</pre>
<hr />
<pre>
2328       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
2329     call_register_finalizer();
2330   }
2331 
2332   // Do not set_parse_bci, so that return goo is credited to the return insn.
2333   // vreturn can trigger an allocation so vreturn can throw. Setting
2334   // the bci here breaks exception handling. Commenting this out
2335   // doesn&#39;t seem to break anything.
2336   //  set_bci(InvocationEntryBci);
2337   if (method()-&gt;is_synchronized() &amp;&amp; GenerateSynchronizationCode) {
2338     shared_unlock(_synch_lock-&gt;box_node(), _synch_lock-&gt;obj_node());
2339   }
2340   if (C-&gt;env()-&gt;dtrace_method_probes()) {
2341     make_dtrace_method_exit(method());
2342   }
2343   // frame pointer is always same, already captured
2344   if (value != NULL) {
2345     Node* phi = _exits.argument(0);
2346     const Type* return_type = phi-&gt;bottom_type();
2347     const TypeOopPtr* tr = return_type-&gt;isa_oopptr();
<span class="line-modified">2348     if (return_type-&gt;isa_inlinetype() &amp;&amp; !Compile::current()-&gt;inlining_incrementally()) {</span>
<span class="line-modified">2349       // Inline type is returned as fields, make sure it is scalarized</span>
<span class="line-modified">2350       if (!value-&gt;is_InlineType()) {</span>
<span class="line-modified">2351         value = InlineTypeNode::make_from_oop(this, value, return_type-&gt;inline_klass());</span>
2352       }
2353       if (!_caller-&gt;has_method()) {
<span class="line-modified">2354         // Inline type is returned as fields from root method, make sure all non-flattened</span>
2355         // fields are buffered and re-execute if allocation triggers deoptimization.
2356         PreserveReexecuteState preexecs(this);
<span class="line-modified">2357         assert(tf()-&gt;returns_inline_type_as_fields(), &quot;must be returned as fields&quot;);</span>
2358         jvms()-&gt;set_should_reexecute(true);
2359         inc_sp(1);
<span class="line-modified">2360         value = value-&gt;as_InlineType()-&gt;allocate_fields(this);</span>
2361       }
<span class="line-modified">2362     } else if (value-&gt;is_InlineType()) {</span>
<span class="line-modified">2363       // Inline type is returned as oop, make sure it is buffered and re-execute</span>
2364       // if allocation triggers deoptimization.
2365       PreserveReexecuteState preexecs(this);
2366       jvms()-&gt;set_should_reexecute(true);
2367       inc_sp(1);
<span class="line-modified">2368       value = value-&gt;as_InlineType()-&gt;buffer(this);</span>
2369       if (Compile::current()-&gt;inlining_incrementally()) {
<span class="line-modified">2370         value = value-&gt;as_InlineTypeBase()-&gt;allocate_fields(this);</span>
2371       }
2372     } else if (tr &amp;&amp; tr-&gt;isa_instptr() &amp;&amp; tr-&gt;klass()-&gt;is_loaded() &amp;&amp; tr-&gt;klass()-&gt;is_interface()) {
2373       // If returning oops to an interface-return, there is a silent free
2374       // cast from oop to interface allowed by the Verifier. Make it explicit here.
2375       const TypeInstPtr* tp = value-&gt;bottom_type()-&gt;isa_instptr();
2376       if (tp &amp;&amp; tp-&gt;klass()-&gt;is_loaded() &amp;&amp; !tp-&gt;klass()-&gt;is_interface()) {
2377         // sharpen the type eagerly; this eases certain assert checking
2378         if (tp-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
2379           tr = tr-&gt;join_speculative(TypeInstPtr::NOTNULL)-&gt;is_instptr();
2380         }
2381         value = _gvn.transform(new CheckCastPPNode(0, value, tr));
2382       }
2383     } else {
2384       // Handle returns of oop-arrays to an arrays-of-interface return
2385       const TypeInstPtr* phi_tip;
2386       const TypeInstPtr* val_tip;
2387       Type::get_arrays_base_elements(return_type, value-&gt;bottom_type(), &amp;phi_tip, &amp;val_tip);
2388       if (phi_tip != NULL &amp;&amp; phi_tip-&gt;is_loaded() &amp;&amp; phi_tip-&gt;klass()-&gt;is_interface() &amp;&amp;
2389           val_tip != NULL &amp;&amp; val_tip-&gt;is_loaded() &amp;&amp; !val_tip-&gt;klass()-&gt;is_interface()) {
2390         value = _gvn.transform(new CheckCastPPNode(0, value, return_type));
</pre>
</td>
</tr>
</table>
<center><a href="output.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
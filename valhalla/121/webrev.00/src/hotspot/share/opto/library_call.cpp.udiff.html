<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="locknode.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/library_call.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -40,10 +40,11 @@</span>
  #include &quot;opto/callGenerator.hpp&quot;
  #include &quot;opto/castnode.hpp&quot;
  #include &quot;opto/cfgnode.hpp&quot;
  #include &quot;opto/convertnode.hpp&quot;
  #include &quot;opto/countbitsnode.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/inlinetypenode.hpp&quot;</span>
  #include &quot;opto/intrinsicnode.hpp&quot;
  #include &quot;opto/idealKit.hpp&quot;
  #include &quot;opto/mathexactnode.hpp&quot;
  #include &quot;opto/movenode.hpp&quot;
  #include &quot;opto/mulnode.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -51,11 +52,10 @@</span>
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/subnode.hpp&quot;
<span class="udiff-line-removed">- #include &quot;opto/valuetypenode.hpp&quot;</span>
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;prims/unsafe.hpp&quot;
  #include &quot;runtime/objectMonitor.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -136,16 +136,16 @@</span>
    void push_result() {
      // Push the result onto the stack.
      Node* res = result();
      if (!stopped() &amp;&amp; res != NULL) {
        BasicType bt = res-&gt;bottom_type()-&gt;basic_type();
<span class="udiff-line-modified-removed">-       if (C-&gt;inlining_incrementally() &amp;&amp; res-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-added">+       if (C-&gt;inlining_incrementally() &amp;&amp; res-&gt;is_InlineType()) {</span>
          // The caller expects an oop when incrementally inlining an intrinsic that returns an
          // inline type. Make sure the call is re-executed if the allocation triggers a deoptimization.
          PreserveReexecuteState preexecs(this);
          jvms()-&gt;set_should_reexecute(true);
<span class="udiff-line-modified-removed">-         res = res-&gt;as_ValueType()-&gt;buffer(this);</span>
<span class="udiff-line-modified-added">+         res = res-&gt;as_InlineType()-&gt;buffer(this);</span>
        }
        push_node(bt, res);
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -200,11 +200,11 @@</span>
      AnyArray,
      NonArray,
      ObjectArray,
      NonObjectArray,
      TypeArray,
<span class="udiff-line-modified-removed">-     ValueArray</span>
<span class="udiff-line-modified-added">+     FlatArray</span>
    };
  
    Node* generate_hidden_class_guard(Node* kls, RegionNode* region);
  
    Node* generate_array_guard(Node* kls, RegionNode* region) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -220,13 +220,13 @@</span>
      return generate_array_guard_common(kls, region, NonObjectArray);
    }
    Node* generate_typeArray_guard(Node* kls, RegionNode* region) {
      return generate_array_guard_common(kls, region, TypeArray);
    }
<span class="udiff-line-modified-removed">-   Node* generate_valueArray_guard(Node* kls, RegionNode* region) {</span>
<span class="udiff-line-modified-added">+   Node* generate_flatArray_guard(Node* kls, RegionNode* region) {</span>
      assert(UseFlatArray, &quot;can never be flattened&quot;);
<span class="udiff-line-modified-removed">-     return generate_array_guard_common(kls, region, ValueArray);</span>
<span class="udiff-line-modified-added">+     return generate_array_guard_common(kls, region, FlatArray);</span>
    }
    Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);
    Node* generate_virtual_guard(Node* obj_klass, RegionNode* slow_region);
    CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,
                                       bool is_virtual = false, bool is_static = false);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2463,11 +2463,11 @@</span>
    // to be plain byte offsets, which are also the same as those accepted
    // by oopDesc::field_addr.
    assert(Unsafe_field_offset_to_byte_offset(11) == 11,
           &quot;fieldOffset must be byte-scaled&quot;);
  
<span class="udiff-line-modified-removed">-   ciValueKlass* value_klass = NULL;</span>
<span class="udiff-line-modified-added">+   ciInlineKlass* inline_klass = NULL;</span>
    if (type == T_INLINE_TYPE) {
      Node* cls = null_check(argument(4));
      if (stopped()) {
        return true;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2475,33 +2475,33 @@</span>
      const TypeKlassPtr* kls_t = _gvn.type(kls)-&gt;isa_klassptr();
      if (!kls_t-&gt;klass_is_exact()) {
        return false;
      }
      ciKlass* klass = kls_t-&gt;klass();
<span class="udiff-line-modified-removed">-     if (!klass-&gt;is_valuetype()) {</span>
<span class="udiff-line-modified-added">+     if (!klass-&gt;is_inlinetype()) {</span>
        return false;
      }
<span class="udiff-line-modified-removed">-     value_klass = klass-&gt;as_value_klass();</span>
<span class="udiff-line-modified-added">+     inline_klass = klass-&gt;as_inline_klass();</span>
    }
  
    receiver = null_check(receiver);
    if (stopped()) {
      return true;
    }
  
<span class="udiff-line-modified-removed">-   if (base-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-removed">-     ValueTypeNode* vt = base-&gt;as_ValueType();</span>
<span class="udiff-line-modified-added">+   if (base-&gt;is_InlineType()) {</span>
<span class="udiff-line-modified-added">+     InlineTypeNode* vt = base-&gt;as_InlineType();</span>
  
      if (is_store) {
<span class="udiff-line-modified-removed">-       if (!vt-&gt;is_allocated(&amp;_gvn) || !_gvn.type(vt)-&gt;is_valuetype()-&gt;larval()) {</span>
<span class="udiff-line-modified-added">+       if (!vt-&gt;is_allocated(&amp;_gvn) || !_gvn.type(vt)-&gt;is_inlinetype()-&gt;larval()) {</span>
          return false;
        }
        base = vt-&gt;get_oop();
      } else {
        if (offset-&gt;is_Con()) {
          long off = find_long_con(offset, 0);
<span class="udiff-line-modified-removed">-         ciValueKlass* vk = vt-&gt;type()-&gt;value_klass();</span>
<span class="udiff-line-modified-added">+         ciInlineKlass* vk = vt-&gt;type()-&gt;inline_klass();</span>
          if ((long)(int)off != off || !vk-&gt;contains_field_offset(off)) {
            return false;
          }
  
          ciField* f = vk-&gt;get_non_flattened_field_by_offset((int)off);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2510,11 +2510,11 @@</span>
            BasicType bt = f-&gt;layout_type();
            if (bt == T_ARRAY || bt == T_NARROWOOP) {
              bt = T_OBJECT;
            }
            if (bt == type) {
<span class="udiff-line-modified-removed">-             if (bt != T_INLINE_TYPE || f-&gt;type() == value_klass) {</span>
<span class="udiff-line-modified-added">+             if (bt != T_INLINE_TYPE || f-&gt;type() == inline_klass) {</span>
                set_result(vt-&gt;field_value_by_offset((int)off, false));
                return true;
              }
            }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2529,11 +2529,11 @@</span>
    // 32-bit machines ignore the high half!
    offset = ConvL2X(offset);
    adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
  
    if (_gvn.type(base)-&gt;isa_ptr() == TypePtr::NULL_PTR) {
<span class="udiff-line-modified-removed">-     if (type != T_OBJECT &amp;&amp; (value_klass == NULL || !value_klass-&gt;has_object_fields())) {</span>
<span class="udiff-line-modified-added">+     if (type != T_OBJECT &amp;&amp; (inline_klass == NULL || !inline_klass-&gt;has_object_fields())) {</span>
        decorators |= IN_NATIVE; // off-heap primitive access
      } else {
        return false; // off-heap oop accesses are not supported
      }
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2609,24 +2609,24 @@</span>
      mismatched = true; // conservatively mark all &quot;wide&quot; on-heap accesses as mismatched
    }
  
    if (type == T_INLINE_TYPE) {
      if (adr_type-&gt;isa_instptr()) {
<span class="udiff-line-modified-removed">-       if (field == NULL || field-&gt;type() != value_klass) {</span>
<span class="udiff-line-modified-added">+       if (field == NULL || field-&gt;type() != inline_klass) {</span>
          mismatched = true;
        }
      } else if (adr_type-&gt;isa_aryptr()) {
        const Type* elem = adr_type-&gt;is_aryptr()-&gt;elem();
<span class="udiff-line-modified-removed">-       if (!elem-&gt;isa_valuetype()) {</span>
<span class="udiff-line-modified-added">+       if (!elem-&gt;isa_inlinetype()) {</span>
          mismatched = true;
<span class="udiff-line-modified-removed">-       } else if (elem-&gt;value_klass() != value_klass) {</span>
<span class="udiff-line-modified-added">+       } else if (elem-&gt;inline_klass() != inline_klass) {</span>
          mismatched = true;
        }
      }
      if (is_store) {
        const Type* val_t = _gvn.type(val);
<span class="udiff-line-modified-removed">-       if (!val_t-&gt;isa_valuetype() || val_t-&gt;value_klass() != value_klass) {</span>
<span class="udiff-line-modified-added">+       if (!val_t-&gt;isa_inlinetype() || val_t-&gt;inline_klass() != inline_klass) {</span>
          return false;
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2670,13 +2670,13 @@</span>
      if (p == NULL) { // Could not constant fold the load
        if (type == T_INLINE_TYPE) {
          if (adr_type-&gt;isa_instptr() &amp;&amp; !mismatched) {
            ciInstanceKlass* holder = adr_type-&gt;is_instptr()-&gt;klass()-&gt;as_instance_klass();
            int offset = adr_type-&gt;is_instptr()-&gt;offset();
<span class="udiff-line-modified-removed">-           p = ValueTypeNode::make_from_flattened(this, value_klass, base, base, holder, offset, decorators);</span>
<span class="udiff-line-modified-added">+           p = InlineTypeNode::make_from_flattened(this, inline_klass, base, base, holder, offset, decorators);</span>
          } else {
<span class="udiff-line-modified-removed">-           p = ValueTypeNode::make_from_flattened(this, value_klass, base, adr, NULL, 0, decorators);</span>
<span class="udiff-line-modified-added">+           p = InlineTypeNode::make_from_flattened(this, inline_klass, base, adr, NULL, 0, decorators);</span>
          }
        } else {
          p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);
        }
        // Normalize the value returned by getBoolean in the following cases
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2703,16 +2703,16 @@</span>
      }
      if (type == T_ADDRESS) {
        p = gvn().transform(new CastP2XNode(NULL, p));
        p = ConvX2UL(p);
      }
<span class="udiff-line-modified-removed">-     if (field != NULL &amp;&amp; field-&gt;type()-&gt;is_valuetype() &amp;&amp; !field-&gt;is_flattened()) {</span>
<span class="udiff-line-modified-removed">-       // Load a non-flattened value type from memory</span>
<span class="udiff-line-modified-removed">-       if (value_type-&gt;value_klass()-&gt;is_scalarizable()) {</span>
<span class="udiff-line-modified-removed">-         p = ValueTypeNode::make_from_oop(this, p, value_type-&gt;value_klass());</span>
<span class="udiff-line-modified-added">+     if (field != NULL &amp;&amp; field-&gt;type()-&gt;is_inlinetype() &amp;&amp; !field-&gt;is_flattened()) {</span>
<span class="udiff-line-modified-added">+       // Load a non-flattened inline type from memory</span>
<span class="udiff-line-modified-added">+       if (value_type-&gt;inline_klass()-&gt;is_scalarizable()) {</span>
<span class="udiff-line-modified-added">+         p = InlineTypeNode::make_from_oop(this, p, value_type-&gt;inline_klass());</span>
        } else {
<span class="udiff-line-modified-removed">-         p = null2default(p, value_type-&gt;value_klass());</span>
<span class="udiff-line-modified-added">+         p = null2default(p, value_type-&gt;inline_klass());</span>
        }
      }
      // The load node has the control of the preceding MemBarCPUOrder.  All
      // following nodes will have the control of the MemBarCPUOrder inserted at
      // the end of this method.  So, pushing the load onto the stack at a later
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2726,22 +2726,22 @@</span>
      }
      if (type == T_INLINE_TYPE) {
        if (adr_type-&gt;isa_instptr() &amp;&amp; !mismatched) {
          ciInstanceKlass* holder = adr_type-&gt;is_instptr()-&gt;klass()-&gt;as_instance_klass();
          int offset = adr_type-&gt;is_instptr()-&gt;offset();
<span class="udiff-line-modified-removed">-         val-&gt;as_ValueType()-&gt;store_flattened(this, base, base, holder, offset, decorators);</span>
<span class="udiff-line-modified-added">+         val-&gt;as_InlineType()-&gt;store_flattened(this, base, base, holder, offset, decorators);</span>
        } else {
<span class="udiff-line-modified-removed">-         val-&gt;as_ValueType()-&gt;store_flattened(this, base, adr, NULL, 0, decorators);</span>
<span class="udiff-line-modified-added">+         val-&gt;as_InlineType()-&gt;store_flattened(this, base, adr, NULL, 0, decorators);</span>
        }
      } else {
        access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);
      }
    }
  
<span class="udiff-line-modified-removed">-   if (argument(1)-&gt;is_ValueType() &amp;&amp; is_store) {</span>
<span class="udiff-line-modified-removed">-     Node* value = ValueTypeNode::make_from_oop(this, base, _gvn.type(base)-&gt;value_klass());</span>
<span class="udiff-line-modified-removed">-     value = value-&gt;as_ValueType()-&gt;make_larval(this, false);</span>
<span class="udiff-line-modified-added">+   if (argument(1)-&gt;is_InlineType() &amp;&amp; is_store) {</span>
<span class="udiff-line-modified-added">+     Node* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(base)-&gt;inline_klass());</span>
<span class="udiff-line-modified-added">+     value = value-&gt;as_InlineType()-&gt;make_larval(this, false);</span>
      replace_in_map(argument(1), value);
    }
  
    return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2753,15 +2753,15 @@</span>
    receiver = null_check(receiver);
    if (stopped()) {
      return true;
    }
  
<span class="udiff-line-modified-removed">-   if (!value-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-added">+   if (!value-&gt;is_InlineType()) {</span>
      return false;
    }
  
<span class="udiff-line-modified-removed">-   set_result(value-&gt;as_ValueType()-&gt;make_larval(this, true));</span>
<span class="udiff-line-modified-added">+   set_result(value-&gt;as_InlineType()-&gt;make_larval(this, true));</span>
  
    return true;
  }
  
  bool LibraryCallKit::inline_unsafe_finish_private_buffer() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2771,16 +2771,16 @@</span>
    receiver = null_check(receiver);
    if (stopped()) {
      return true;
    }
  
<span class="udiff-line-modified-removed">-   if (!buffer-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-added">+   if (!buffer-&gt;is_InlineType()) {</span>
      return false;
    }
  
<span class="udiff-line-modified-removed">-   ValueTypeNode* vt = buffer-&gt;as_ValueType();</span>
<span class="udiff-line-modified-removed">-   if (!vt-&gt;is_allocated(&amp;_gvn) || !_gvn.type(vt)-&gt;is_valuetype()-&gt;larval()) {</span>
<span class="udiff-line-modified-added">+   InlineTypeNode* vt = buffer-&gt;as_InlineType();</span>
<span class="udiff-line-modified-added">+   if (!vt-&gt;is_allocated(&amp;_gvn) || !_gvn.type(vt)-&gt;is_inlinetype()-&gt;larval()) {</span>
      return false;
    }
  
    set_result(vt-&gt;finish_larval(this));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3497,12 +3497,12 @@</span>
    if (obj == NULL || obj-&gt;is_top()) {
      return false;  // dead path
    }
    ciKlass* obj_klass = NULL;
    const Type* obj_t = _gvn.type(obj);
<span class="udiff-line-modified-removed">-   if (obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-removed">-     obj_klass = obj_t-&gt;value_klass();</span>
<span class="udiff-line-modified-added">+   if (obj-&gt;is_InlineType()) {</span>
<span class="udiff-line-modified-added">+     obj_klass = obj_t-&gt;inline_klass();</span>
    } else if (obj_t-&gt;isa_oopptr()) {
      obj_klass = obj_t-&gt;is_oopptr()-&gt;klass();
    }
  
    // First, see if Class.cast() can be folded statically.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3511,11 +3511,11 @@</span>
    if (tm != NULL &amp;&amp; tm-&gt;is_klass() &amp;&amp; obj_klass != NULL) {
      if (!obj_klass-&gt;is_loaded()) {
        // Don&#39;t use intrinsic when class is not loaded.
        return false;
      } else {
<span class="udiff-line-modified-removed">-       if (!obj-&gt;is_ValueType() &amp;&amp; tm-&gt;as_klass()-&gt;is_valuetype()) {</span>
<span class="udiff-line-modified-added">+       if (!obj-&gt;is_InlineType() &amp;&amp; tm-&gt;as_klass()-&gt;is_inlinetype()) {</span>
          // Casting to .val, check for null
          obj = null_check(obj);
          if (stopped()) {
            return true;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3559,11 +3559,11 @@</span>
    // nothing is an instance of a primitive type.
    Node* kls = load_klass_from_mirror(mirror, false, region, _prim_path);
  
    Node* res = top();
    if (!stopped()) {
<span class="udiff-line-modified-removed">-     if (EnableValhalla &amp;&amp; !obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-added">+     if (EnableValhalla &amp;&amp; !obj-&gt;is_InlineType()) {</span>
        // Check if we are casting to .val
        Node* is_val_kls = generate_value_guard(kls, NULL);
        if (is_val_kls != NULL) {
          RegionNode* r = new RegionNode(3);
          record_for_igvn(r);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3723,11 +3723,11 @@</span>
      bool query = 0;
      switch(kind) {
        case ObjectArray:    query = Klass::layout_helper_is_objArray(layout_con); break;
        case NonObjectArray: query = !Klass::layout_helper_is_objArray(layout_con); break;
        case TypeArray:      query = Klass::layout_helper_is_typeArray(layout_con); break;
<span class="udiff-line-modified-removed">-       case ValueArray:     query = Klass::layout_helper_is_flatArray(layout_con); break;</span>
<span class="udiff-line-modified-added">+       case FlatArray:     query = Klass::layout_helper_is_flatArray(layout_con); break;</span>
        case AnyArray:       query = Klass::layout_helper_is_array(layout_con); break;
        case NonArray:       query = !Klass::layout_helper_is_array(layout_con); break;
        default:
          ShouldNotReachHere();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3755,11 +3755,11 @@</span>
        value = Klass::_lh_array_tag_type_value;
        layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
        btest = BoolTest::eq;
        break;
      }
<span class="udiff-line-modified-removed">-     case ValueArray: {</span>
<span class="udiff-line-modified-added">+     case FlatArray: {</span>
        value = Klass::_lh_array_tag_vt_value;
        layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
        btest = BoolTest::eq;
        break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3896,13 +3896,13 @@</span>
    const TypeAryPtr* original_t = _gvn.type(original)-&gt;isa_aryptr();
    const TypeInstPtr* mirror_t = _gvn.type(array_type_mirror)-&gt;isa_instptr();
    if (EnableValhalla &amp;&amp; UseFlatArray &amp;&amp;
        (original_t == NULL || mirror_t == NULL ||
         (mirror_t-&gt;java_mirror_type() == NULL &amp;&amp;
<span class="udiff-line-modified-removed">-         (original_t-&gt;elem()-&gt;isa_valuetype() ||</span>
<span class="udiff-line-modified-added">+         (original_t-&gt;elem()-&gt;isa_inlinetype() ||</span>
           (original_t-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp;
<span class="udiff-line-modified-removed">-           original_t-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()))))) {</span>
<span class="udiff-line-modified-added">+           original_t-&gt;elem()-&gt;make_oopptr()-&gt;can_be_inline_type()))))) {</span>
      // We need to know statically if the copy is to a flattened array
      // or not but can&#39;t tell.
      return false;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3927,11 +3927,11 @@</span>
      RegionNode* bailout = new RegionNode(1);
      record_for_igvn(bailout);
  
      // Despite the generic type of Arrays.copyOf, the mirror might be int, int[], etc.
      // Bail out if that is so.
<span class="udiff-line-modified-removed">-     // Value type array may have object field that would require a</span>
<span class="udiff-line-modified-added">+     // Inline type array may have object field that would require a</span>
      // write barrier. Conservatively, go to slow path.
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
      Node* not_objArray = !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing) ?
          generate_typeArray_guard(klass_node, bailout) : generate_non_objArray_guard(klass_node, bailout);
      if (not_objArray != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3966,21 +3966,21 @@</span>
      }
  
      if (UseFlatArray) {
        // Either both or neither new array klass and original array
        // klass must be flattened
<span class="udiff-line-modified-removed">-       Node* is_flat = generate_valueArray_guard(klass_node, NULL);</span>
<span class="udiff-line-modified-added">+       Node* is_flat = generate_flatArray_guard(klass_node, NULL);</span>
        if (!original_t-&gt;is_not_flat()) {
<span class="udiff-line-modified-removed">-         generate_valueArray_guard(original_kls, bailout);</span>
<span class="udiff-line-modified-added">+         generate_flatArray_guard(original_kls, bailout);</span>
        }
        if (is_flat != NULL) {
          RegionNode* r = new RegionNode(2);
          record_for_igvn(r);
          r-&gt;init_req(1, control());
          set_control(is_flat);
          if (!original_t-&gt;is_not_flat()) {
<span class="udiff-line-modified-removed">-           generate_valueArray_guard(original_kls, r);</span>
<span class="udiff-line-modified-added">+           generate_flatArray_guard(original_kls, r);</span>
          }
          bailout-&gt;add_req(control());
          set_control(_gvn.transform(r));
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4163,11 +4163,11 @@</span>
    PhiNode*    result_val = new PhiNode(result_reg, TypeInt::INT);
    PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
    PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
    Node* obj = argument(0);
  
<span class="udiff-line-modified-removed">-   if (obj-&gt;is_ValueType() || gvn().type(obj)-&gt;is_valuetypeptr()) {</span>
<span class="udiff-line-modified-added">+   if (obj-&gt;is_InlineType() || gvn().type(obj)-&gt;is_inlinetypeptr()) {</span>
      return false;
    }
  
    if (!is_static) {
      // Check for hashing null object
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4215,11 +4215,11 @@</span>
    // the null check after castPP removal.
    Node* no_ctrl = NULL;
    Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
  
    // Test the header to see if it is unlocked.
<span class="udiff-line-modified-removed">-   // This also serves as guard against value types (they have the always_locked_pattern set).</span>
<span class="udiff-line-modified-added">+   // This also serves as guard against inline types (they have the always_locked_pattern set).</span>
    Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);
    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
    Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);
    Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
    Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4283,12 +4283,12 @@</span>
  // public final native Class&lt;?&gt; java.lang.Object.getClass();
  //
  // Build special case code for calls to getClass on an object.
  bool LibraryCallKit::inline_native_getClass() {
    Node* obj = argument(0);
<span class="udiff-line-modified-removed">-   if (obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-removed">-     ciKlass* vk = _gvn.type(obj)-&gt;value_klass();</span>
<span class="udiff-line-modified-added">+   if (obj-&gt;is_InlineType()) {</span>
<span class="udiff-line-modified-added">+     ciKlass* vk = _gvn.type(obj)-&gt;inline_klass();</span>
      set_result(makecon(TypeInstPtr::make(vk-&gt;java_mirror())));
      return true;
    }
    obj = null_check_receiver();
    if (stopped())  return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4601,11 +4601,11 @@</span>
    // the bytecode that invokes Object.clone if deoptimization happens.
    { PreserveReexecuteState preexecs(this);
      jvms()-&gt;set_should_reexecute(true);
  
      Node* obj = argument(0);
<span class="udiff-line-modified-removed">-     if (obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-added">+     if (obj-&gt;is_InlineType()) {</span>
        return false;
      }
  
      obj = null_check_receiver();
      if (stopped())  return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4616,11 +4616,11 @@</span>
      // know the number and types of fields to convert the clone to
      // loads/stores. Maybe a speculative type can help us.
      if (!obj_type-&gt;klass_is_exact() &amp;&amp;
          obj_type-&gt;speculative_type() != NULL &amp;&amp;
          obj_type-&gt;speculative_type()-&gt;is_instance_klass() &amp;&amp;
<span class="udiff-line-modified-removed">-         !obj_type-&gt;speculative_type()-&gt;is_valuetype()) {</span>
<span class="udiff-line-modified-added">+         !obj_type-&gt;speculative_type()-&gt;is_inlinetype()) {</span>
        ciInstanceKlass* spec_ik = obj_type-&gt;speculative_type()-&gt;as_instance_klass();
        if (spec_ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem &amp;&amp;
            !spec_ik-&gt;has_injected_fields()) {
          ciKlass* k = obj_type-&gt;klass();
          if (!k-&gt;is_instance_klass() ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4662,13 +4662,13 @@</span>
        set_control(array_ctl);
  
        BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
        if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing) &amp;&amp;
            (!obj_type-&gt;isa_aryptr() || !obj_type-&gt;is_aryptr()-&gt;is_not_flat())) {
<span class="udiff-line-modified-removed">-         // Flattened value type array may have object field that would require a</span>
<span class="udiff-line-modified-added">+         // Flattened inline type array may have object field that would require a</span>
          // write barrier. Conservatively, go to slow path.
<span class="udiff-line-modified-removed">-         generate_valueArray_guard(obj_klass, slow_region);</span>
<span class="udiff-line-modified-added">+         generate_flatArray_guard(obj_klass, slow_region);</span>
        }
  
        if (!stopped()) {
          Node* obj_length = load_array_length(obj);
          Node* obj_size  = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5141,17 +5141,17 @@</span>
      const Type* toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
      src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
      src_type = _gvn.type(src);
      top_src  = src_type-&gt;isa_aryptr();
  
<span class="udiff-line-modified-removed">-     if (top_dest != NULL &amp;&amp; !top_dest-&gt;elem()-&gt;isa_valuetype() &amp;&amp; !top_dest-&gt;is_not_flat()) {</span>
<span class="udiff-line-modified-removed">-       generate_valueArray_guard(dest_klass, slow_region);</span>
<span class="udiff-line-modified-added">+     if (top_dest != NULL &amp;&amp; !top_dest-&gt;elem()-&gt;isa_inlinetype() &amp;&amp; !top_dest-&gt;is_not_flat()) {</span>
<span class="udiff-line-modified-added">+       generate_flatArray_guard(dest_klass, slow_region);</span>
      }
  
<span class="udiff-line-modified-removed">-     if (top_src != NULL &amp;&amp; !top_src-&gt;elem()-&gt;isa_valuetype() &amp;&amp; !top_src-&gt;is_not_flat()) {</span>
<span class="udiff-line-modified-added">+     if (top_src != NULL &amp;&amp; !top_src-&gt;elem()-&gt;isa_inlinetype() &amp;&amp; !top_src-&gt;is_not_flat()) {</span>
        Node* src_klass = load_object_klass(src);
<span class="udiff-line-modified-removed">-       generate_valueArray_guard(src_klass, slow_region);</span>
<span class="udiff-line-modified-added">+       generate_flatArray_guard(src_klass, slow_region);</span>
      }
  
      {
        PreserveJVMState pjvms(this);
        set_control(_gvn.transform(slow_region));
</pre>
<center><a href="graphKit.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="locknode.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
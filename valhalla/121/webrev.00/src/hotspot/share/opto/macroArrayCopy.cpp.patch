diff a/src/hotspot/share/opto/macroArrayCopy.cpp b/src/hotspot/share/opto/macroArrayCopy.cpp
--- a/src/hotspot/share/opto/macroArrayCopy.cpp
+++ b/src/hotspot/share/opto/macroArrayCopy.cpp
@@ -21,10 +21,11 @@
  * questions.
  *
  */
 
 #include "precompiled.hpp"
+#include "ci/ciFlatArrayKlass.hpp"
 #include "gc/shared/barrierSet.hpp"
 #include "opto/arraycopynode.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "opto/convertnode.hpp"
 #include "opto/graphKit.hpp"
@@ -1155,12 +1156,12 @@
 }
 
 const TypePtr* PhaseMacroExpand::adjust_parameters_for_vt(const TypeAryPtr* top_dest, Node*& src_offset,
                                                           Node*& dest_offset, Node*& length, BasicType& dest_elem,
                                                           Node*& dest_length) {
-  assert(top_dest->klass()->is_value_array_klass(), "inconsistent");
-  int elem_size = ((ciValueArrayKlass*)top_dest->klass())->element_byte_size();
+  assert(top_dest->klass()->is_flat_array_klass(), "inconsistent");
+  int elem_size = ((ciFlatArrayKlass*)top_dest->klass())->element_byte_size();
   if (elem_size >= 8) {
     if (elem_size > 8) {
       // treat as array of long but scale length, src offset and dest offset
       assert((elem_size % 8) == 0, "not a power of 2?");
       int factor = elem_size / 8;
@@ -1274,21 +1275,21 @@
     src_elem = T_OBJECT;
   } else if (src_elem == T_INLINE_TYPE && top_src->klass()->is_obj_array_klass()) {
     if (top_src->klass_is_exact()) {
       src_elem = T_OBJECT;
     } else {
-      assert(!top_src->klass()->is_valuetype(), "klass should be exact");
+      assert(!top_src->klass()->is_inlinetype(), "klass should be exact");
       src_elem = T_CONFLICT; // either flattened or not
     }
   }
   if (dest_elem == T_ARRAY) {
     dest_elem = T_OBJECT;
   } else if (dest_elem == T_INLINE_TYPE && top_dest->klass()->is_obj_array_klass()) {
     if (top_dest->klass_is_exact()) {
       dest_elem = T_OBJECT;
     } else {
-      assert(!top_dest->klass()->is_valuetype(), "klass should be exact");
+      assert(!top_dest->klass()->is_inlinetype(), "klass should be exact");
       dest_elem = T_CONFLICT; // either flattened or not
     }
   }
 
   if (ac->is_arraycopy_validated() &&
@@ -1331,11 +1332,11 @@
   assert(!ac->is_arraycopy_validated() || (src_elem == dest_elem && dest_elem != T_VOID), "validated but different basic types");
 
   // (2) src and dest arrays must have elements of the same BasicType
   // Figure out the size and type of the elements we will be copying.
   //
-  // We have no stub to copy flattened value type arrays with oop
+  // We have no stub to copy flattened inline type arrays with oop
   // fields if we need to emit write barriers.
   //
   BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
   if (src_elem != dest_elem || dest_elem == T_VOID) {
     // The component types are not the same or are not recognized.  Punt.
@@ -1411,15 +1412,15 @@
                          slow_region);
 
     // (9) each element of an oop array must be assignable
     // The generate_arraycopy subroutine checks this.
 
-    if (dest_elem == T_OBJECT && !top_dest->elem()->isa_valuetype() && !top_dest->is_not_flat()) {
+    if (dest_elem == T_OBJECT && !top_dest->elem()->isa_inlinetype() && !top_dest->is_not_flat()) {
       generate_flattened_array_guard(&ctrl, merge_mem, dest, slow_region);
     }
 
-    if (src_elem == T_OBJECT && !top_src->elem()->isa_valuetype() && !top_src->is_not_flat()) {
+    if (src_elem == T_OBJECT && !top_src->elem()->isa_inlinetype() && !top_src->is_not_flat()) {
       generate_flattened_array_guard(&ctrl, merge_mem, src, slow_region);
     }
   }
 
   // This is where the memory effects are placed:

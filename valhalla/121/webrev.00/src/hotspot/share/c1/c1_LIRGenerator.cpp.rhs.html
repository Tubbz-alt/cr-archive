<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_Defs.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  32 </span>
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;ci/ciArrayKlass.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  35 #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
<span class="line-added">  36 #include &quot;ci/ciInlineKlass.hpp&quot;</span>
  37 #include &quot;ci/ciInstance.hpp&quot;
  38 #include &quot;ci/ciObjArray.hpp&quot;
  39 #include &quot;ci/ciUtilities.hpp&quot;
<a name="3" id="anc3"></a>

  40 #include &quot;gc/shared/barrierSet.hpp&quot;
  41 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  42 #include &quot;oops/klass.inline.hpp&quot;
  43 #include &quot;runtime/arguments.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;runtime/stubRoutines.hpp&quot;
  46 #include &quot;runtime/vm_version.hpp&quot;
  47 #include &quot;utilities/bitMap.inline.hpp&quot;
  48 #include &quot;utilities/macros.hpp&quot;
  49 #include &quot;utilities/powerOfTwo.hpp&quot;
  50 
  51 #ifdef ASSERT
  52 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  53 #else
  54 #define __ gen()-&gt;lir()-&gt;
  55 #endif
  56 
  57 #ifndef PATCHED_ADDR
  58 #define PATCHED_ADDR  (max_jint)
  59 #endif
  60 
  61 void PhiResolverState::reset() {
  62   _virtual_operands.clear();
  63   _other_operands.clear();
  64   _vreg_table.clear();
  65 }
  66 
  67 
  68 //--------------------------------------------------------------
  69 // PhiResolver
  70 
  71 // Resolves cycles:
  72 //
  73 //  r1 := r2  becomes  temp := r1
  74 //  r2 := r1           r1 := r2
  75 //                     r2 := temp
  76 // and orders moves:
  77 //
  78 //  r2 := r3  becomes  r1 := r2
  79 //  r1 := r2           r2 := r3
  80 
  81 PhiResolver::PhiResolver(LIRGenerator* gen)
  82  : _gen(gen)
  83  , _state(gen-&gt;resolver_state())
  84  , _temp(LIR_OprFact::illegalOpr)
  85 {
  86   // reinitialize the shared state arrays
  87   _state.reset();
  88 }
  89 
  90 
  91 void PhiResolver::emit_move(LIR_Opr src, LIR_Opr dest) {
  92   assert(src-&gt;is_valid(), &quot;&quot;);
  93   assert(dest-&gt;is_valid(), &quot;&quot;);
  94   __ move(src, dest);
  95 }
  96 
  97 
  98 void PhiResolver::move_temp_to(LIR_Opr dest) {
  99   assert(_temp-&gt;is_valid(), &quot;&quot;);
 100   emit_move(_temp, dest);
 101   NOT_PRODUCT(_temp = LIR_OprFact::illegalOpr);
 102 }
 103 
 104 
 105 void PhiResolver::move_to_temp(LIR_Opr src) {
 106   assert(_temp-&gt;is_illegal(), &quot;&quot;);
 107   _temp = _gen-&gt;new_register(src-&gt;type());
 108   emit_move(src, _temp);
 109 }
 110 
 111 
 112 // Traverse assignment graph in depth first order and generate moves in post order
 113 // ie. two assignments: b := c, a := b start with node c:
 114 // Call graph: move(NULL, c) -&gt; move(c, b) -&gt; move(b, a)
 115 // Generates moves in this order: move b to a and move c to b
 116 // ie. cycle a := b, b := a start with node a
 117 // Call graph: move(NULL, a) -&gt; move(a, b) -&gt; move(b, a)
 118 // Generates moves in this order: move b to temp, move a to b, move temp to a
 119 void PhiResolver::move(ResolveNode* src, ResolveNode* dest) {
 120   if (!dest-&gt;visited()) {
 121     dest-&gt;set_visited();
 122     for (int i = dest-&gt;no_of_destinations()-1; i &gt;= 0; i --) {
 123       move(dest, dest-&gt;destination_at(i));
 124     }
 125   } else if (!dest-&gt;start_node()) {
 126     // cylce in graph detected
 127     assert(_loop == NULL, &quot;only one loop valid!&quot;);
 128     _loop = dest;
 129     move_to_temp(src-&gt;operand());
 130     return;
 131   } // else dest is a start node
 132 
 133   if (!dest-&gt;assigned()) {
 134     if (_loop == dest) {
 135       move_temp_to(dest-&gt;operand());
 136       dest-&gt;set_assigned();
 137     } else if (src != NULL) {
 138       emit_move(src-&gt;operand(), dest-&gt;operand());
 139       dest-&gt;set_assigned();
 140     }
 141   }
 142 }
 143 
 144 
 145 PhiResolver::~PhiResolver() {
 146   int i;
 147   // resolve any cycles in moves from and to virtual registers
 148   for (i = virtual_operands().length() - 1; i &gt;= 0; i --) {
 149     ResolveNode* node = virtual_operands().at(i);
 150     if (!node-&gt;visited()) {
 151       _loop = NULL;
 152       move(NULL, node);
 153       node-&gt;set_start_node();
 154       assert(_temp-&gt;is_illegal(), &quot;move_temp_to() call missing&quot;);
 155     }
 156   }
 157 
 158   // generate move for move from non virtual register to abitrary destination
 159   for (i = other_operands().length() - 1; i &gt;= 0; i --) {
 160     ResolveNode* node = other_operands().at(i);
 161     for (int j = node-&gt;no_of_destinations() - 1; j &gt;= 0; j --) {
 162       emit_move(node-&gt;operand(), node-&gt;destination_at(j)-&gt;operand());
 163     }
 164   }
 165 }
 166 
 167 
 168 ResolveNode* PhiResolver::create_node(LIR_Opr opr, bool source) {
 169   ResolveNode* node;
 170   if (opr-&gt;is_virtual()) {
 171     int vreg_num = opr-&gt;vreg_number();
 172     node = vreg_table().at_grow(vreg_num, NULL);
 173     assert(node == NULL || node-&gt;operand() == opr, &quot;&quot;);
 174     if (node == NULL) {
 175       node = new ResolveNode(opr);
 176       vreg_table().at_put(vreg_num, node);
 177     }
 178     // Make sure that all virtual operands show up in the list when
 179     // they are used as the source of a move.
 180     if (source &amp;&amp; !virtual_operands().contains(node)) {
 181       virtual_operands().append(node);
 182     }
 183   } else {
 184     assert(source, &quot;&quot;);
 185     node = new ResolveNode(opr);
 186     other_operands().append(node);
 187   }
 188   return node;
 189 }
 190 
 191 
 192 void PhiResolver::move(LIR_Opr src, LIR_Opr dest) {
 193   assert(dest-&gt;is_virtual(), &quot;&quot;);
 194   // tty-&gt;print(&quot;move &quot;); src-&gt;print(); tty-&gt;print(&quot; to &quot;); dest-&gt;print(); tty-&gt;cr();
 195   assert(src-&gt;is_valid(), &quot;&quot;);
 196   assert(dest-&gt;is_valid(), &quot;&quot;);
 197   ResolveNode* source = source_node(src);
 198   source-&gt;append(destination_node(dest));
 199 }
 200 
 201 
 202 //--------------------------------------------------------------
 203 // LIRItem
 204 
 205 void LIRItem::set_result(LIR_Opr opr) {
 206   assert(value()-&gt;operand()-&gt;is_illegal() || value()-&gt;operand()-&gt;is_constant(), &quot;operand should never change&quot;);
 207   value()-&gt;set_operand(opr);
 208 
 209   if (opr-&gt;is_virtual()) {
 210     _gen-&gt;_instruction_for_operand.at_put_grow(opr-&gt;vreg_number(), value(), NULL);
 211   }
 212 
 213   _result = opr;
 214 }
 215 
 216 void LIRItem::load_item() {
 217   assert(!_gen-&gt;in_conditional_code(), &quot;LIRItem cannot be loaded in conditional code&quot;);
 218 
 219   if (result()-&gt;is_illegal()) {
 220     // update the items result
 221     _result = value()-&gt;operand();
 222   }
 223   if (!result()-&gt;is_register()) {
 224     LIR_Opr reg = _gen-&gt;new_register(value()-&gt;type());
 225     __ move(result(), reg);
 226     if (result()-&gt;is_constant()) {
 227       _result = reg;
 228     } else {
 229       set_result(reg);
 230     }
 231   }
 232 }
 233 
 234 
 235 void LIRItem::load_for_store(BasicType type) {
 236   if (_gen-&gt;can_store_as_constant(value(), type)) {
 237     _result = value()-&gt;operand();
 238     if (!_result-&gt;is_constant()) {
 239       _result = LIR_OprFact::value_type(value()-&gt;type());
 240     }
 241   } else if (type == T_BYTE || type == T_BOOLEAN) {
 242     load_byte_item();
 243   } else {
 244     load_item();
 245   }
 246 }
 247 
 248 void LIRItem::load_item_force(LIR_Opr reg) {
 249   LIR_Opr r = result();
 250   if (r != reg) {
 251 #if !defined(ARM) &amp;&amp; !defined(E500V2)
 252     if (r-&gt;type() != reg-&gt;type()) {
 253       // moves between different types need an intervening spill slot
 254       r = _gen-&gt;force_to_spill(r, reg-&gt;type());
 255     }
 256 #endif
 257     __ move(r, reg);
 258     _result = reg;
 259   }
 260 }
 261 
 262 ciObject* LIRItem::get_jobject_constant() const {
 263   ObjectType* oc = type()-&gt;as_ObjectType();
 264   if (oc) {
 265     return oc-&gt;constant_value();
 266   }
 267   return NULL;
 268 }
 269 
 270 
 271 jint LIRItem::get_jint_constant() const {
 272   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 273   assert(type()-&gt;as_IntConstant() != NULL, &quot;type check&quot;);
 274   return type()-&gt;as_IntConstant()-&gt;value();
 275 }
 276 
 277 
 278 jint LIRItem::get_address_constant() const {
 279   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 280   assert(type()-&gt;as_AddressConstant() != NULL, &quot;type check&quot;);
 281   return type()-&gt;as_AddressConstant()-&gt;value();
 282 }
 283 
 284 
 285 jfloat LIRItem::get_jfloat_constant() const {
 286   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 287   assert(type()-&gt;as_FloatConstant() != NULL, &quot;type check&quot;);
 288   return type()-&gt;as_FloatConstant()-&gt;value();
 289 }
 290 
 291 
 292 jdouble LIRItem::get_jdouble_constant() const {
 293   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 294   assert(type()-&gt;as_DoubleConstant() != NULL, &quot;type check&quot;);
 295   return type()-&gt;as_DoubleConstant()-&gt;value();
 296 }
 297 
 298 
 299 jlong LIRItem::get_jlong_constant() const {
 300   assert(is_constant() &amp;&amp; value() != NULL, &quot;&quot;);
 301   assert(type()-&gt;as_LongConstant() != NULL, &quot;type check&quot;);
 302   return type()-&gt;as_LongConstant()-&gt;value();
 303 }
 304 
 305 
 306 
 307 //--------------------------------------------------------------
 308 
 309 
 310 void LIRGenerator::block_do_prolog(BlockBegin* block) {
 311 #ifndef PRODUCT
 312   if (PrintIRWithLIR) {
 313     block-&gt;print();
 314   }
 315 #endif
 316 
 317   // set up the list of LIR instructions
 318   assert(block-&gt;lir() == NULL, &quot;LIR list already computed for this block&quot;);
 319   _lir = new LIR_List(compilation(), block);
 320   block-&gt;set_lir(_lir);
 321 
 322   __ branch_destination(block-&gt;label());
 323 
 324   if (LIRTraceExecution &amp;&amp;
 325       Compilation::current()-&gt;hir()-&gt;start()-&gt;block_id() != block-&gt;block_id() &amp;&amp;
 326       !block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 327     assert(block-&gt;lir()-&gt;instructions_list()-&gt;length() == 1, &quot;should come right after br_dst&quot;);
 328     trace_block_entry(block);
 329   }
 330 }
 331 
 332 
 333 void LIRGenerator::block_do_epilog(BlockBegin* block) {
 334 #ifndef PRODUCT
 335   if (PrintIRWithLIR) {
 336     tty-&gt;cr();
 337   }
 338 #endif
 339 
 340   // LIR_Opr for unpinned constants shouldn&#39;t be referenced by other
 341   // blocks so clear them out after processing the block.
 342   for (int i = 0; i &lt; _unpinned_constants.length(); i++) {
 343     _unpinned_constants.at(i)-&gt;clear_operand();
 344   }
 345   _unpinned_constants.trunc_to(0);
 346 
 347   // clear our any registers for other local constants
 348   _constants.trunc_to(0);
 349   _reg_for_constants.trunc_to(0);
 350 }
 351 
 352 
 353 void LIRGenerator::block_do(BlockBegin* block) {
 354   CHECK_BAILOUT();
 355 
 356   block_do_prolog(block);
 357   set_block(block);
 358 
 359   for (Instruction* instr = block; instr != NULL; instr = instr-&gt;next()) {
 360     if (instr-&gt;is_pinned()) do_root(instr);
 361   }
 362 
 363   set_block(NULL);
 364   block_do_epilog(block);
 365 }
 366 
 367 
 368 //-------------------------LIRGenerator-----------------------------
 369 
 370 // This is where the tree-walk starts; instr must be root;
 371 void LIRGenerator::do_root(Value instr) {
 372   CHECK_BAILOUT();
 373 
 374   InstructionMark im(compilation(), instr);
 375 
 376   assert(instr-&gt;is_pinned(), &quot;use only with roots&quot;);
 377   assert(instr-&gt;subst() == instr, &quot;shouldn&#39;t have missed substitution&quot;);
 378 
 379   instr-&gt;visit(this);
 380 
 381   assert(!instr-&gt;has_uses() || instr-&gt;operand()-&gt;is_valid() ||
 382          instr-&gt;as_Constant() != NULL || bailed_out(), &quot;invalid item set&quot;);
 383 }
 384 
 385 
 386 // This is called for each node in tree; the walk stops if a root is reached
 387 void LIRGenerator::walk(Value instr) {
 388   InstructionMark im(compilation(), instr);
 389   //stop walk when encounter a root
 390   if ((instr-&gt;is_pinned() &amp;&amp; instr-&gt;as_Phi() == NULL) || instr-&gt;operand()-&gt;is_valid()) {
 391     assert(instr-&gt;operand() != LIR_OprFact::illegalOpr || instr-&gt;as_Constant() != NULL, &quot;this root has not yet been visited&quot;);
 392   } else {
 393     assert(instr-&gt;subst() == instr, &quot;shouldn&#39;t have missed substitution&quot;);
 394     instr-&gt;visit(this);
 395     // assert(instr-&gt;use_count() &gt; 0 || instr-&gt;as_Phi() != NULL, &quot;leaf instruction must have a use&quot;);
 396   }
 397 }
 398 
 399 
 400 CodeEmitInfo* LIRGenerator::state_for(Instruction* x, ValueStack* state, bool ignore_xhandler) {
 401   assert(state != NULL, &quot;state must be defined&quot;);
 402 
 403 #ifndef PRODUCT
 404   state-&gt;verify();
 405 #endif
 406 
 407   ValueStack* s = state;
 408   for_each_state(s) {
 409     if (s-&gt;kind() == ValueStack::EmptyExceptionState) {
 410       assert(s-&gt;stack_size() == 0 &amp;&amp; s-&gt;locals_size() == 0 &amp;&amp; (s-&gt;locks_size() == 0 || s-&gt;locks_size() == 1), &quot;state must be empty&quot;);
 411       continue;
 412     }
 413 
 414     int index;
 415     Value value;
 416     for_each_stack_value(s, index, value) {
 417       assert(value-&gt;subst() == value, &quot;missed substitution&quot;);
 418       if (!value-&gt;is_pinned() &amp;&amp; value-&gt;as_Constant() == NULL &amp;&amp; value-&gt;as_Local() == NULL) {
 419         walk(value);
 420         assert(value-&gt;operand()-&gt;is_valid(), &quot;must be evaluated now&quot;);
 421       }
 422     }
 423 
 424     int bci = s-&gt;bci();
 425     IRScope* scope = s-&gt;scope();
 426     ciMethod* method = scope-&gt;method();
 427 
 428     MethodLivenessResult liveness = method-&gt;liveness_at_bci(bci);
 429     if (bci == SynchronizationEntryBCI) {
 430       if (x-&gt;as_ExceptionObject() || x-&gt;as_Throw()) {
 431         // all locals are dead on exit from the synthetic unlocker
 432         liveness.clear();
 433       } else {
 434         assert(x-&gt;as_MonitorEnter() || x-&gt;as_ProfileInvoke(), &quot;only other cases are MonitorEnter and ProfileInvoke&quot;);
 435       }
 436     }
 437     if (!liveness.is_valid()) {
 438       // Degenerate or breakpointed method.
 439       bailout(&quot;Degenerate or breakpointed method&quot;);
 440     } else {
 441       assert((int)liveness.size() == s-&gt;locals_size(), &quot;error in use of liveness&quot;);
 442       for_each_local_value(s, index, value) {
 443         assert(value-&gt;subst() == value, &quot;missed substition&quot;);
 444         if (liveness.at(index) &amp;&amp; !value-&gt;type()-&gt;is_illegal()) {
 445           if (!value-&gt;is_pinned() &amp;&amp; value-&gt;as_Constant() == NULL &amp;&amp; value-&gt;as_Local() == NULL) {
 446             walk(value);
 447             assert(value-&gt;operand()-&gt;is_valid(), &quot;must be evaluated now&quot;);
 448           }
 449         } else {
 450           // NULL out this local so that linear scan can assume that all non-NULL values are live.
 451           s-&gt;invalidate_local(index);
 452         }
 453       }
 454     }
 455   }
 456 
 457   return new CodeEmitInfo(state, ignore_xhandler ? NULL : x-&gt;exception_handlers(), x-&gt;check_flag(Instruction::DeoptimizeOnException));
 458 }
 459 
 460 
 461 CodeEmitInfo* LIRGenerator::state_for(Instruction* x) {
 462   return state_for(x, x-&gt;exception_state());
 463 }
 464 
 465 
 466 void LIRGenerator::klass2reg_with_patching(LIR_Opr r, ciMetadata* obj, CodeEmitInfo* info, bool need_resolve) {
 467   /* C2 relies on constant pool entries being resolved (ciTypeFlow), so if TieredCompilation
 468    * is active and the class hasn&#39;t yet been resolved we need to emit a patch that resolves
 469    * the class. */
 470   if ((TieredCompilation &amp;&amp; need_resolve) || !obj-&gt;is_loaded() || PatchALot) {
 471     assert(info != NULL, &quot;info must be set if class is not loaded&quot;);
 472     __ klass2reg_patch(NULL, r, info);
 473   } else {
 474     // no patching needed
 475     __ metadata2reg(obj-&gt;constant_encoding(), r);
 476   }
 477 }
 478 
 479 
 480 void LIRGenerator::array_range_check(LIR_Opr array, LIR_Opr index,
 481                                     CodeEmitInfo* null_check_info, CodeEmitInfo* range_check_info) {
 482   CodeStub* stub = new RangeCheckStub(range_check_info, index, array);
 483   if (index-&gt;is_constant()) {
 484     cmp_mem_int(lir_cond_belowEqual, array, arrayOopDesc::length_offset_in_bytes(),
 485                 index-&gt;as_jint(), null_check_info);
 486     __ branch(lir_cond_belowEqual, stub); // forward branch
 487   } else {
 488     cmp_reg_mem(lir_cond_aboveEqual, index, array,
 489                 arrayOopDesc::length_offset_in_bytes(), T_INT, null_check_info);
 490     __ branch(lir_cond_aboveEqual, stub); // forward branch
 491   }
 492 }
 493 
 494 
 495 void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {
 496   CodeStub* stub = new RangeCheckStub(info, index);
 497   if (index-&gt;is_constant()) {
 498     cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index-&gt;as_jint(), info);
 499     __ branch(lir_cond_belowEqual, stub); // forward branch
 500   } else {
 501     cmp_reg_mem(lir_cond_aboveEqual, index, buffer,
 502                 java_nio_Buffer::limit_offset(), T_INT, info);
 503     __ branch(lir_cond_aboveEqual, stub); // forward branch
 504   }
 505   __ move(index, result);
 506 }
 507 
 508 
 509 
 510 void LIRGenerator::arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp_op, CodeEmitInfo* info) {
 511   LIR_Opr result_op = result;
 512   LIR_Opr left_op   = left;
 513   LIR_Opr right_op  = right;
 514 
 515   if (TwoOperandLIRForm &amp;&amp; left_op != result_op) {
 516     assert(right_op != result_op, &quot;malformed&quot;);
 517     __ move(left_op, result_op);
 518     left_op = result_op;
 519   }
 520 
 521   switch(code) {
 522     case Bytecodes::_dadd:
 523     case Bytecodes::_fadd:
 524     case Bytecodes::_ladd:
 525     case Bytecodes::_iadd:  __ add(left_op, right_op, result_op); break;
 526     case Bytecodes::_fmul:
 527     case Bytecodes::_lmul:  __ mul(left_op, right_op, result_op); break;
 528 
 529     case Bytecodes::_dmul:
 530       {
 531         if (is_strictfp) {
 532           __ mul_strictfp(left_op, right_op, result_op, tmp_op); break;
 533         } else {
 534           __ mul(left_op, right_op, result_op); break;
 535         }
 536       }
 537       break;
 538 
 539     case Bytecodes::_imul:
 540       {
 541         bool did_strength_reduce = false;
 542 
 543         if (right-&gt;is_constant()) {
 544           jint c = right-&gt;as_jint();
 545           if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 546             // do not need tmp here
 547             __ shift_left(left_op, exact_log2(c), result_op);
 548             did_strength_reduce = true;
 549           } else {
 550             did_strength_reduce = strength_reduce_multiply(left_op, c, result_op, tmp_op);
 551           }
 552         }
 553         // we couldn&#39;t strength reduce so just emit the multiply
 554         if (!did_strength_reduce) {
 555           __ mul(left_op, right_op, result_op);
 556         }
 557       }
 558       break;
 559 
 560     case Bytecodes::_dsub:
 561     case Bytecodes::_fsub:
 562     case Bytecodes::_lsub:
 563     case Bytecodes::_isub: __ sub(left_op, right_op, result_op); break;
 564 
 565     case Bytecodes::_fdiv: __ div (left_op, right_op, result_op); break;
 566     // ldiv and lrem are implemented with a direct runtime call
 567 
 568     case Bytecodes::_ddiv:
 569       {
 570         if (is_strictfp) {
 571           __ div_strictfp (left_op, right_op, result_op, tmp_op); break;
 572         } else {
 573           __ div (left_op, right_op, result_op); break;
 574         }
 575       }
 576       break;
 577 
 578     case Bytecodes::_drem:
 579     case Bytecodes::_frem: __ rem (left_op, right_op, result_op); break;
 580 
 581     default: ShouldNotReachHere();
 582   }
 583 }
 584 
 585 
 586 void LIRGenerator::arithmetic_op_int(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp) {
 587   arithmetic_op(code, result, left, right, false, tmp);
 588 }
 589 
 590 
 591 void LIRGenerator::arithmetic_op_long(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info) {
 592   arithmetic_op(code, result, left, right, false, LIR_OprFact::illegalOpr, info);
 593 }
 594 
 595 
 596 void LIRGenerator::arithmetic_op_fpu(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp) {
 597   arithmetic_op(code, result, left, right, is_strictfp, tmp);
 598 }
 599 
 600 
 601 void LIRGenerator::shift_op(Bytecodes::Code code, LIR_Opr result_op, LIR_Opr value, LIR_Opr count, LIR_Opr tmp) {
 602 
 603   if (TwoOperandLIRForm &amp;&amp; value != result_op
 604       // Only 32bit right shifts require two operand form on S390.
 605       S390_ONLY(&amp;&amp; (code == Bytecodes::_ishr || code == Bytecodes::_iushr))) {
 606     assert(count != result_op, &quot;malformed&quot;);
 607     __ move(value, result_op);
 608     value = result_op;
 609   }
 610 
 611   assert(count-&gt;is_constant() || count-&gt;is_register(), &quot;must be&quot;);
 612   switch(code) {
 613   case Bytecodes::_ishl:
 614   case Bytecodes::_lshl: __ shift_left(value, count, result_op, tmp); break;
 615   case Bytecodes::_ishr:
 616   case Bytecodes::_lshr: __ shift_right(value, count, result_op, tmp); break;
 617   case Bytecodes::_iushr:
 618   case Bytecodes::_lushr: __ unsigned_shift_right(value, count, result_op, tmp); break;
 619   default: ShouldNotReachHere();
 620   }
 621 }
 622 
 623 
 624 void LIRGenerator::logic_op (Bytecodes::Code code, LIR_Opr result_op, LIR_Opr left_op, LIR_Opr right_op) {
 625   if (TwoOperandLIRForm &amp;&amp; left_op != result_op) {
 626     assert(right_op != result_op, &quot;malformed&quot;);
 627     __ move(left_op, result_op);
 628     left_op = result_op;
 629   }
 630 
 631   switch(code) {
 632     case Bytecodes::_iand:
 633     case Bytecodes::_land:  __ logical_and(left_op, right_op, result_op); break;
 634 
 635     case Bytecodes::_ior:
 636     case Bytecodes::_lor:   __ logical_or(left_op, right_op, result_op);  break;
 637 
 638     case Bytecodes::_ixor:
 639     case Bytecodes::_lxor:  __ logical_xor(left_op, right_op, result_op); break;
 640 
 641     default: ShouldNotReachHere();
 642   }
 643 }
 644 
 645 
 646 void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no,
 647                                  CodeEmitInfo* info_for_exception, CodeEmitInfo* info, CodeStub* throw_imse_stub) {
 648   if (!GenerateSynchronizationCode) return;
 649   // for slow path, use debug info for state after successful locking
 650   CodeStub* slow_path = new MonitorEnterStub(object, lock, info, throw_imse_stub, scratch);
 651   __ load_stack_address_monitor(monitor_no, lock);
 652   // for handling NullPointerException, use debug info representing just the lock stack before this monitorenter
 653   __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception, throw_imse_stub);
 654 }
 655 
 656 
 657 void LIRGenerator::monitor_exit(LIR_Opr object, LIR_Opr lock, LIR_Opr new_hdr, LIR_Opr scratch, int monitor_no) {
 658   if (!GenerateSynchronizationCode) return;
 659   // setup registers
 660   LIR_Opr hdr = lock;
 661   lock = new_hdr;
 662   CodeStub* slow_path = new MonitorExitStub(lock, UseFastLocking, monitor_no);
 663   __ load_stack_address_monitor(monitor_no, lock);
 664   __ unlock_object(hdr, object, lock, scratch, slow_path);
 665 }
 666 
 667 #ifndef PRODUCT
 668 void LIRGenerator::print_if_not_loaded(const NewInstance* new_instance) {
 669   if (PrintNotLoaded &amp;&amp; !new_instance-&gt;klass()-&gt;is_loaded()) {
 670     tty-&gt;print_cr(&quot;   ###class not loaded at new bci %d&quot;, new_instance-&gt;printable_bci());
 671   } else if (PrintNotLoaded &amp;&amp; (TieredCompilation &amp;&amp; new_instance-&gt;is_unresolved())) {
 672     tty-&gt;print_cr(&quot;   ###class not resolved at new bci %d&quot;, new_instance-&gt;printable_bci());
 673   }
 674 }
 675 #endif
 676 
 677 void LIRGenerator::new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info) {
 678   klass2reg_with_patching(klass_reg, klass, info, is_unresolved);
 679   // If klass is not loaded we do not know if the klass has finalizers:
 680   if (UseFastNewInstance &amp;&amp; klass-&gt;is_loaded()
 681       &amp;&amp; !Klass::layout_helper_needs_slow_path(klass-&gt;layout_helper())) {
 682 
 683     Runtime1::StubID stub_id = klass-&gt;is_initialized() ? Runtime1::fast_new_instance_id : Runtime1::fast_new_instance_init_check_id;
 684 
 685     CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, stub_id);
 686 
 687     assert(klass-&gt;is_loaded(), &quot;must be loaded&quot;);
 688     // allocate space for instance
 689     assert(klass-&gt;size_helper() &gt;= 0, &quot;illegal instance size&quot;);
 690     const int instance_size = align_object_size(klass-&gt;size_helper());
 691     __ allocate_object(dst, scratch1, scratch2, scratch3, scratch4,
 692                        oopDesc::header_size(), instance_size, klass_reg, !klass-&gt;is_initialized(), slow_path);
 693   } else {
 694     CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);
 695     __ branch(lir_cond_always, slow_path);
 696     __ branch_destination(slow_path-&gt;continuation());
 697   }
 698 }
 699 
 700 
 701 static bool is_constant_zero(Instruction* inst) {
 702   IntConstant* c = inst-&gt;type()-&gt;as_IntConstant();
 703   if (c) {
 704     return (c-&gt;value() == 0);
 705   }
 706   return false;
 707 }
 708 
 709 
 710 static bool positive_constant(Instruction* inst) {
 711   IntConstant* c = inst-&gt;type()-&gt;as_IntConstant();
 712   if (c) {
 713     return (c-&gt;value() &gt;= 0);
 714   }
 715   return false;
 716 }
 717 
 718 
 719 static ciArrayKlass* as_array_klass(ciType* type) {
 720   if (type != NULL &amp;&amp; type-&gt;is_array_klass() &amp;&amp; type-&gt;is_loaded()) {
 721     return (ciArrayKlass*)type;
 722   } else {
 723     return NULL;
 724   }
 725 }
 726 
 727 static ciType* phi_declared_type(Phi* phi) {
 728   ciType* t = phi-&gt;operand_at(0)-&gt;declared_type();
 729   if (t == NULL) {
 730     return NULL;
 731   }
 732   for(int i = 1; i &lt; phi-&gt;operand_count(); i++) {
 733     if (t != phi-&gt;operand_at(i)-&gt;declared_type()) {
 734       return NULL;
 735     }
 736   }
 737   return t;
 738 }
 739 
 740 void LIRGenerator::arraycopy_helper(Intrinsic* x, int* flagsp, ciArrayKlass** expected_typep) {
 741   Instruction* src     = x-&gt;argument_at(0);
 742   Instruction* src_pos = x-&gt;argument_at(1);
 743   Instruction* dst     = x-&gt;argument_at(2);
 744   Instruction* dst_pos = x-&gt;argument_at(3);
 745   Instruction* length  = x-&gt;argument_at(4);
 746 
 747   // first try to identify the likely type of the arrays involved
 748   ciArrayKlass* expected_type = NULL;
 749   bool is_exact = false, src_objarray = false, dst_objarray = false;
 750   {
 751     ciArrayKlass* src_exact_type    = as_array_klass(src-&gt;exact_type());
 752     ciArrayKlass* src_declared_type = as_array_klass(src-&gt;declared_type());
 753     Phi* phi;
 754     if (src_declared_type == NULL &amp;&amp; (phi = src-&gt;as_Phi()) != NULL) {
 755       src_declared_type = as_array_klass(phi_declared_type(phi));
 756     }
 757     ciArrayKlass* dst_exact_type    = as_array_klass(dst-&gt;exact_type());
 758     ciArrayKlass* dst_declared_type = as_array_klass(dst-&gt;declared_type());
 759     if (dst_declared_type == NULL &amp;&amp; (phi = dst-&gt;as_Phi()) != NULL) {
 760       dst_declared_type = as_array_klass(phi_declared_type(phi));
 761     }
 762 
 763     if (src_exact_type != NULL &amp;&amp; src_exact_type == dst_exact_type) {
 764       // the types exactly match so the type is fully known
 765       is_exact = true;
 766       expected_type = src_exact_type;
 767     } else if (dst_exact_type != NULL &amp;&amp; dst_exact_type-&gt;is_obj_array_klass()) {
 768       ciArrayKlass* dst_type = (ciArrayKlass*) dst_exact_type;
 769       ciArrayKlass* src_type = NULL;
 770       if (src_exact_type != NULL &amp;&amp; src_exact_type-&gt;is_obj_array_klass()) {
 771         src_type = (ciArrayKlass*) src_exact_type;
 772       } else if (src_declared_type != NULL &amp;&amp; src_declared_type-&gt;is_obj_array_klass()) {
 773         src_type = (ciArrayKlass*) src_declared_type;
 774       }
 775       if (src_type != NULL) {
 776         if (src_type-&gt;element_type()-&gt;is_subtype_of(dst_type-&gt;element_type())) {
 777           is_exact = true;
 778           expected_type = dst_type;
 779         }
 780       }
 781     }
 782     // at least pass along a good guess
 783     if (expected_type == NULL) expected_type = dst_exact_type;
 784     if (expected_type == NULL) expected_type = src_declared_type;
 785     if (expected_type == NULL) expected_type = dst_declared_type;
 786 
 787     src_objarray = (src_exact_type &amp;&amp; src_exact_type-&gt;is_obj_array_klass()) || (src_declared_type &amp;&amp; src_declared_type-&gt;is_obj_array_klass());
 788     dst_objarray = (dst_exact_type &amp;&amp; dst_exact_type-&gt;is_obj_array_klass()) || (dst_declared_type &amp;&amp; dst_declared_type-&gt;is_obj_array_klass());
 789   }
 790 
 791   // if a probable array type has been identified, figure out if any
 792   // of the required checks for a fast case can be elided.
 793   int flags = LIR_OpArrayCopy::all_flags;
 794 
 795   if (!src-&gt;is_loaded_flattened_array() &amp;&amp; !dst-&gt;is_loaded_flattened_array()) {
 796     flags &amp;= ~LIR_OpArrayCopy::always_slow_path;
 797   }
 798   if (!src-&gt;maybe_flattened_array()) {
<a name="4" id="anc4"></a><span class="line-modified"> 799     flags &amp;= ~LIR_OpArrayCopy::src_inlinetype_check;</span>
 800   }
 801   if (!dst-&gt;maybe_flattened_array() &amp;&amp; !dst-&gt;maybe_null_free_array()) {
<a name="5" id="anc5"></a><span class="line-modified"> 802     flags &amp;= ~LIR_OpArrayCopy::dst_inlinetype_check;</span>
 803   }
 804 
 805   if (!src_objarray)
 806     flags &amp;= ~LIR_OpArrayCopy::src_objarray;
 807   if (!dst_objarray)
 808     flags &amp;= ~LIR_OpArrayCopy::dst_objarray;
 809 
 810   if (!x-&gt;arg_needs_null_check(0))
 811     flags &amp;= ~LIR_OpArrayCopy::src_null_check;
 812   if (!x-&gt;arg_needs_null_check(2))
 813     flags &amp;= ~LIR_OpArrayCopy::dst_null_check;
 814 
 815 
 816   if (expected_type != NULL) {
 817     Value length_limit = NULL;
 818 
 819     IfOp* ifop = length-&gt;as_IfOp();
 820     if (ifop != NULL) {
 821       // look for expressions like min(v, a.length) which ends up as
 822       //   x &gt; y ? y : x  or  x &gt;= y ? y : x
 823       if ((ifop-&gt;cond() == If::gtr || ifop-&gt;cond() == If::geq) &amp;&amp;
 824           ifop-&gt;x() == ifop-&gt;fval() &amp;&amp;
 825           ifop-&gt;y() == ifop-&gt;tval()) {
 826         length_limit = ifop-&gt;y();
 827       }
 828     }
 829 
 830     // try to skip null checks and range checks
 831     NewArray* src_array = src-&gt;as_NewArray();
 832     if (src_array != NULL) {
 833       flags &amp;= ~LIR_OpArrayCopy::src_null_check;
 834       if (length_limit != NULL &amp;&amp;
 835           src_array-&gt;length() == length_limit &amp;&amp;
 836           is_constant_zero(src_pos)) {
 837         flags &amp;= ~LIR_OpArrayCopy::src_range_check;
 838       }
 839     }
 840 
 841     NewArray* dst_array = dst-&gt;as_NewArray();
 842     if (dst_array != NULL) {
 843       flags &amp;= ~LIR_OpArrayCopy::dst_null_check;
 844       if (length_limit != NULL &amp;&amp;
 845           dst_array-&gt;length() == length_limit &amp;&amp;
 846           is_constant_zero(dst_pos)) {
 847         flags &amp;= ~LIR_OpArrayCopy::dst_range_check;
 848       }
 849     }
 850 
 851     // check from incoming constant values
 852     if (positive_constant(src_pos))
 853       flags &amp;= ~LIR_OpArrayCopy::src_pos_positive_check;
 854     if (positive_constant(dst_pos))
 855       flags &amp;= ~LIR_OpArrayCopy::dst_pos_positive_check;
 856     if (positive_constant(length))
 857       flags &amp;= ~LIR_OpArrayCopy::length_positive_check;
 858 
 859     // see if the range check can be elided, which might also imply
 860     // that src or dst is non-null.
 861     ArrayLength* al = length-&gt;as_ArrayLength();
 862     if (al != NULL) {
 863       if (al-&gt;array() == src) {
 864         // it&#39;s the length of the source array
 865         flags &amp;= ~LIR_OpArrayCopy::length_positive_check;
 866         flags &amp;= ~LIR_OpArrayCopy::src_null_check;
 867         if (is_constant_zero(src_pos))
 868           flags &amp;= ~LIR_OpArrayCopy::src_range_check;
 869       }
 870       if (al-&gt;array() == dst) {
 871         // it&#39;s the length of the destination array
 872         flags &amp;= ~LIR_OpArrayCopy::length_positive_check;
 873         flags &amp;= ~LIR_OpArrayCopy::dst_null_check;
 874         if (is_constant_zero(dst_pos))
 875           flags &amp;= ~LIR_OpArrayCopy::dst_range_check;
 876       }
 877     }
 878     if (is_exact) {
 879       flags &amp;= ~LIR_OpArrayCopy::type_check;
 880     }
 881   }
 882 
 883   IntConstant* src_int = src_pos-&gt;type()-&gt;as_IntConstant();
 884   IntConstant* dst_int = dst_pos-&gt;type()-&gt;as_IntConstant();
 885   if (src_int &amp;&amp; dst_int) {
 886     int s_offs = src_int-&gt;value();
 887     int d_offs = dst_int-&gt;value();
 888     if (src_int-&gt;value() &gt;= dst_int-&gt;value()) {
 889       flags &amp;= ~LIR_OpArrayCopy::overlapping;
 890     }
 891     if (expected_type != NULL) {
 892       BasicType t = expected_type-&gt;element_type()-&gt;basic_type();
 893       int element_size = type2aelembytes(t);
 894       if (((arrayOopDesc::base_offset_in_bytes(t) + s_offs * element_size) % HeapWordSize == 0) &amp;&amp;
 895           ((arrayOopDesc::base_offset_in_bytes(t) + d_offs * element_size) % HeapWordSize == 0)) {
 896         flags &amp;= ~LIR_OpArrayCopy::unaligned;
 897       }
 898     }
 899   } else if (src_pos == dst_pos || is_constant_zero(dst_pos)) {
 900     // src and dest positions are the same, or dst is zero so assume
 901     // nonoverlapping copy.
 902     flags &amp;= ~LIR_OpArrayCopy::overlapping;
 903   }
 904 
 905   if (src == dst) {
 906     // moving within a single array so no type checks are needed
 907     if (flags &amp; LIR_OpArrayCopy::type_check) {
 908       flags &amp;= ~LIR_OpArrayCopy::type_check;
 909     }
 910   }
 911   *flagsp = flags;
 912   *expected_typep = (ciArrayKlass*)expected_type;
 913 }
 914 
 915 
 916 LIR_Opr LIRGenerator::round_item(LIR_Opr opr) {
 917   assert(opr-&gt;is_register(), &quot;why spill if item is not register?&quot;);
 918 
 919   if (strict_fp_requires_explicit_rounding) {
 920 #ifdef IA32
 921     if (UseSSE &lt; 1 &amp;&amp; opr-&gt;is_single_fpu()) {
 922       LIR_Opr result = new_register(T_FLOAT);
 923       set_vreg_flag(result, must_start_in_memory);
 924       assert(opr-&gt;is_register(), &quot;only a register can be spilled&quot;);
 925       assert(opr-&gt;value_type()-&gt;is_float(), &quot;rounding only for floats available&quot;);
 926       __ roundfp(opr, LIR_OprFact::illegalOpr, result);
 927       return result;
 928     }
 929 #else
 930     Unimplemented();
 931 #endif // IA32
 932   }
 933   return opr;
 934 }
 935 
 936 
 937 LIR_Opr LIRGenerator::force_to_spill(LIR_Opr value, BasicType t) {
 938   assert(type2size[t] == type2size[value-&gt;type()],
 939          &quot;size mismatch: t=%s, value-&gt;type()=%s&quot;, type2name(t), type2name(value-&gt;type()));
 940   if (!value-&gt;is_register()) {
 941     // force into a register
 942     LIR_Opr r = new_register(value-&gt;type());
 943     __ move(value, r);
 944     value = r;
 945   }
 946 
 947   // create a spill location
 948   LIR_Opr tmp = new_register(t);
 949   set_vreg_flag(tmp, LIRGenerator::must_start_in_memory);
 950 
 951   // move from register to spill
 952   __ move(value, tmp);
 953   return tmp;
 954 }
 955 
 956 void LIRGenerator::profile_branch(If* if_instr, If::Condition cond) {
 957   if (if_instr-&gt;should_profile()) {
 958     ciMethod* method = if_instr-&gt;profiled_method();
 959     assert(method != NULL, &quot;method should be set if branch is profiled&quot;);
 960     ciMethodData* md = method-&gt;method_data_or_null();
 961     assert(md != NULL, &quot;Sanity&quot;);
 962     ciProfileData* data = md-&gt;bci_to_data(if_instr-&gt;profiled_bci());
 963     assert(data != NULL, &quot;must have profiling data&quot;);
 964     assert(data-&gt;is_BranchData(), &quot;need BranchData for two-way branches&quot;);
 965     int taken_count_offset     = md-&gt;byte_offset_of_slot(data, BranchData::taken_offset());
 966     int not_taken_count_offset = md-&gt;byte_offset_of_slot(data, BranchData::not_taken_offset());
 967     if (if_instr-&gt;is_swapped()) {
 968       int t = taken_count_offset;
 969       taken_count_offset = not_taken_count_offset;
 970       not_taken_count_offset = t;
 971     }
 972 
 973     LIR_Opr md_reg = new_register(T_METADATA);
 974     __ metadata2reg(md-&gt;constant_encoding(), md_reg);
 975 
 976     LIR_Opr data_offset_reg = new_pointer_register();
 977     __ cmove(lir_cond(cond),
 978              LIR_OprFact::intptrConst(taken_count_offset),
 979              LIR_OprFact::intptrConst(not_taken_count_offset),
 980              data_offset_reg, as_BasicType(if_instr-&gt;x()-&gt;type()));
 981 
 982     // MDO cells are intptr_t, so the data_reg width is arch-dependent.
 983     LIR_Opr data_reg = new_pointer_register();
 984     LIR_Address* data_addr = new LIR_Address(md_reg, data_offset_reg, data_reg-&gt;type());
 985     __ move(data_addr, data_reg);
 986     // Use leal instead of add to avoid destroying condition codes on x86
 987     LIR_Address* fake_incr_value = new LIR_Address(data_reg, DataLayout::counter_increment, T_INT);
 988     __ leal(LIR_OprFact::address(fake_incr_value), data_reg);
 989     __ move(data_reg, data_addr);
 990   }
 991 }
 992 
 993 // Phi technique:
 994 // This is about passing live values from one basic block to the other.
 995 // In code generated with Java it is rather rare that more than one
 996 // value is on the stack from one basic block to the other.
 997 // We optimize our technique for efficient passing of one value
 998 // (of type long, int, double..) but it can be extended.
 999 // When entering or leaving a basic block, all registers and all spill
1000 // slots are release and empty. We use the released registers
1001 // and spill slots to pass the live values from one block
1002 // to the other. The topmost value, i.e., the value on TOS of expression
1003 // stack is passed in registers. All other values are stored in spilling
1004 // area. Every Phi has an index which designates its spill slot
1005 // At exit of a basic block, we fill the register(s) and spill slots.
1006 // At entry of a basic block, the block_prolog sets up the content of phi nodes
1007 // and locks necessary registers and spilling slots.
1008 
1009 
1010 // move current value to referenced phi function
1011 void LIRGenerator::move_to_phi(PhiResolver* resolver, Value cur_val, Value sux_val) {
1012   Phi* phi = sux_val-&gt;as_Phi();
1013   // cur_val can be null without phi being null in conjunction with inlining
1014   if (phi != NULL &amp;&amp; cur_val != NULL &amp;&amp; cur_val != phi &amp;&amp; !phi-&gt;is_illegal()) {
1015     Phi* cur_phi = cur_val-&gt;as_Phi();
1016     if (cur_phi != NULL &amp;&amp; cur_phi-&gt;is_illegal()) {
1017       // Phi and local would need to get invalidated
1018       // (which is unexpected for Linear Scan).
1019       // But this case is very rare so we simply bail out.
1020       bailout(&quot;propagation of illegal phi&quot;);
1021       return;
1022     }
1023     LIR_Opr operand = cur_val-&gt;operand();
1024     if (operand-&gt;is_illegal()) {
1025       assert(cur_val-&gt;as_Constant() != NULL || cur_val-&gt;as_Local() != NULL,
1026              &quot;these can be produced lazily&quot;);
1027       operand = operand_for_instruction(cur_val);
1028     }
1029     resolver-&gt;move(operand, operand_for_instruction(phi));
1030   }
1031 }
1032 
1033 
1034 // Moves all stack values into their PHI position
1035 void LIRGenerator::move_to_phi(ValueStack* cur_state) {
1036   BlockBegin* bb = block();
1037   if (bb-&gt;number_of_sux() == 1) {
1038     BlockBegin* sux = bb-&gt;sux_at(0);
1039     assert(sux-&gt;number_of_preds() &gt; 0, &quot;invalid CFG&quot;);
1040 
1041     // a block with only one predecessor never has phi functions
1042     if (sux-&gt;number_of_preds() &gt; 1) {
1043       PhiResolver resolver(this);
1044 
1045       ValueStack* sux_state = sux-&gt;state();
1046       Value sux_value;
1047       int index;
1048 
1049       assert(cur_state-&gt;scope() == sux_state-&gt;scope(), &quot;not matching&quot;);
1050       assert(cur_state-&gt;locals_size() == sux_state-&gt;locals_size(), &quot;not matching&quot;);
1051       assert(cur_state-&gt;stack_size() == sux_state-&gt;stack_size(), &quot;not matching&quot;);
1052 
1053       for_each_stack_value(sux_state, index, sux_value) {
1054         move_to_phi(&amp;resolver, cur_state-&gt;stack_at(index), sux_value);
1055       }
1056 
1057       for_each_local_value(sux_state, index, sux_value) {
1058         move_to_phi(&amp;resolver, cur_state-&gt;local_at(index), sux_value);
1059       }
1060 
1061       assert(cur_state-&gt;caller_state() == sux_state-&gt;caller_state(), &quot;caller states must be equal&quot;);
1062     }
1063   }
1064 }
1065 
1066 
1067 LIR_Opr LIRGenerator::new_register(BasicType type) {
1068   int vreg = _virtual_register_number;
1069   // add a little fudge factor for the bailout, since the bailout is
1070   // only checked periodically.  This gives a few extra registers to
1071   // hand out before we really run out, which helps us keep from
1072   // tripping over assertions.
1073   if (vreg + 20 &gt;= LIR_OprDesc::vreg_max) {
1074     bailout(&quot;out of virtual registers&quot;);
1075     if (vreg + 2 &gt;= LIR_OprDesc::vreg_max) {
1076       // wrap it around
1077       _virtual_register_number = LIR_OprDesc::vreg_base;
1078     }
1079   }
1080   _virtual_register_number += 1;
1081   return LIR_OprFact::virtual_register(vreg, type);
1082 }
1083 
1084 
1085 // Try to lock using register in hint
1086 LIR_Opr LIRGenerator::rlock(Value instr) {
1087   return new_register(instr-&gt;type());
1088 }
1089 
1090 
1091 // does an rlock and sets result
1092 LIR_Opr LIRGenerator::rlock_result(Value x) {
1093   LIR_Opr reg = rlock(x);
1094   set_result(x, reg);
1095   return reg;
1096 }
1097 
1098 
1099 // does an rlock and sets result
1100 LIR_Opr LIRGenerator::rlock_result(Value x, BasicType type) {
1101   LIR_Opr reg;
1102   switch (type) {
1103   case T_BYTE:
1104   case T_BOOLEAN:
1105     reg = rlock_byte(type);
1106     break;
1107   default:
1108     reg = rlock(x);
1109     break;
1110   }
1111 
1112   set_result(x, reg);
1113   return reg;
1114 }
1115 
1116 
1117 //---------------------------------------------------------------------
1118 ciObject* LIRGenerator::get_jobject_constant(Value value) {
1119   ObjectType* oc = value-&gt;type()-&gt;as_ObjectType();
1120   if (oc) {
1121     return oc-&gt;constant_value();
1122   }
1123   return NULL;
1124 }
1125 
1126 
1127 void LIRGenerator::do_ExceptionObject(ExceptionObject* x) {
1128   assert(block()-&gt;is_set(BlockBegin::exception_entry_flag), &quot;ExceptionObject only allowed in exception handler block&quot;);
1129   assert(block()-&gt;next() == x, &quot;ExceptionObject must be first instruction of block&quot;);
1130 
1131   // no moves are created for phi functions at the begin of exception
1132   // handlers, so assign operands manually here
1133   for_each_phi_fun(block(), phi,
1134                    if (!phi-&gt;is_illegal()) { operand_for_instruction(phi); });
1135 
1136   LIR_Opr thread_reg = getThreadPointer();
1137   __ move_wide(new LIR_Address(thread_reg, in_bytes(JavaThread::exception_oop_offset()), T_OBJECT),
1138                exceptionOopOpr());
1139   __ move_wide(LIR_OprFact::oopConst(NULL),
1140                new LIR_Address(thread_reg, in_bytes(JavaThread::exception_oop_offset()), T_OBJECT));
1141   __ move_wide(LIR_OprFact::oopConst(NULL),
1142                new LIR_Address(thread_reg, in_bytes(JavaThread::exception_pc_offset()), T_OBJECT));
1143 
1144   LIR_Opr result = new_register(T_OBJECT);
1145   __ move(exceptionOopOpr(), result);
1146   set_result(x, result);
1147 }
1148 
1149 
1150 //----------------------------------------------------------------------
1151 //----------------------------------------------------------------------
1152 //----------------------------------------------------------------------
1153 //----------------------------------------------------------------------
1154 //                        visitor functions
1155 //----------------------------------------------------------------------
1156 //----------------------------------------------------------------------
1157 //----------------------------------------------------------------------
1158 //----------------------------------------------------------------------
1159 
1160 void LIRGenerator::do_Phi(Phi* x) {
1161   // phi functions are never visited directly
1162   ShouldNotReachHere();
1163 }
1164 
1165 
1166 // Code for a constant is generated lazily unless the constant is frequently used and can&#39;t be inlined.
1167 void LIRGenerator::do_Constant(Constant* x) {
1168   if (x-&gt;state_before() != NULL) {
1169     // Any constant with a ValueStack requires patching so emit the patch here
1170     LIR_Opr reg = rlock_result(x);
1171     CodeEmitInfo* info = state_for(x, x-&gt;state_before());
1172     __ oop2reg_patch(NULL, reg, info);
1173   } else if (x-&gt;use_count() &gt; 1 &amp;&amp; !can_inline_as_constant(x)) {
1174     if (!x-&gt;is_pinned()) {
1175       // unpinned constants are handled specially so that they can be
1176       // put into registers when they are used multiple times within a
1177       // block.  After the block completes their operand will be
1178       // cleared so that other blocks can&#39;t refer to that register.
1179       set_result(x, load_constant(x));
1180     } else {
1181       LIR_Opr res = x-&gt;operand();
1182       if (!res-&gt;is_valid()) {
1183         res = LIR_OprFact::value_type(x-&gt;type());
1184       }
1185       if (res-&gt;is_constant()) {
1186         LIR_Opr reg = rlock_result(x);
1187         __ move(res, reg);
1188       } else {
1189         set_result(x, res);
1190       }
1191     }
1192   } else {
1193     set_result(x, LIR_OprFact::value_type(x-&gt;type()));
1194   }
1195 }
1196 
1197 
1198 void LIRGenerator::do_Local(Local* x) {
1199   // operand_for_instruction has the side effect of setting the result
1200   // so there&#39;s no need to do it here.
1201   operand_for_instruction(x);
1202 }
1203 
1204 
1205 void LIRGenerator::do_IfInstanceOf(IfInstanceOf* x) {
1206   Unimplemented();
1207 }
1208 
1209 
1210 void LIRGenerator::do_Return(Return* x) {
1211   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
1212     BasicTypeList signature;
1213     signature.append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    // thread
1214     signature.append(T_METADATA); // Method*
1215     LIR_OprList* args = new LIR_OprList();
1216     args-&gt;append(getThreadPointer());
1217     LIR_Opr meth = new_register(T_METADATA);
1218     __ metadata2reg(method()-&gt;constant_encoding(), meth);
1219     args-&gt;append(meth);
1220     call_runtime(&amp;signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), voidType, NULL);
1221   }
1222 
1223   if (x-&gt;type()-&gt;is_void()) {
1224     __ return_op(LIR_OprFact::illegalOpr);
1225   } else {
1226     LIR_Opr reg = result_register_for(x-&gt;type(), /*callee=*/true);
1227     LIRItem result(x-&gt;result(), this);
1228 
1229     result.load_item_force(reg);
1230     __ return_op(result.result());
1231   }
1232   set_no_result(x);
1233 }
1234 
1235 // Examble: ref.get()
1236 // Combination of LoadField and g1 pre-write barrier
1237 void LIRGenerator::do_Reference_get(Intrinsic* x) {
1238 
1239   const int referent_offset = java_lang_ref_Reference::referent_offset();
1240 
1241   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1242 
1243   LIRItem reference(x-&gt;argument_at(0), this);
1244   reference.load_item();
1245 
1246   // need to perform the null check on the reference objecy
1247   CodeEmitInfo* info = NULL;
1248   if (x-&gt;needs_null_check()) {
1249     info = state_for(x);
1250   }
1251 
1252   LIR_Opr result = rlock_result(x, T_OBJECT);
1253   access_load_at(IN_HEAP | ON_WEAK_OOP_REF, T_OBJECT,
1254                  reference, LIR_OprFact::intConst(referent_offset), result);
1255 }
1256 
1257 // Example: clazz.isInstance(object)
1258 void LIRGenerator::do_isInstance(Intrinsic* x) {
1259   assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
1260 
1261   // TODO could try to substitute this node with an equivalent InstanceOf
1262   // if clazz is known to be a constant Class. This will pick up newly found
1263   // constants after HIR construction. I&#39;ll leave this to a future change.
1264 
1265   // as a first cut, make a simple leaf call to runtime to stay platform independent.
1266   // could follow the aastore example in a future change.
1267 
1268   LIRItem clazz(x-&gt;argument_at(0), this);
1269   LIRItem object(x-&gt;argument_at(1), this);
1270   clazz.load_item();
1271   object.load_item();
1272   LIR_Opr result = rlock_result(x);
1273 
1274   // need to perform null check on clazz
1275   if (x-&gt;needs_null_check()) {
1276     CodeEmitInfo* info = state_for(x);
1277     __ null_check(clazz.result(), info);
1278   }
1279 
1280   LIR_Opr call_result = call_runtime(clazz.value(), object.value(),
1281                                      CAST_FROM_FN_PTR(address, Runtime1::is_instance_of),
1282                                      x-&gt;type(),
1283                                      NULL); // NULL CodeEmitInfo results in a leaf call
1284   __ move(call_result, result);
1285 }
1286 
1287 // Example: object.getClass ()
1288 void LIRGenerator::do_getClass(Intrinsic* x) {
1289   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1290 
1291   LIRItem rcvr(x-&gt;argument_at(0), this);
1292   rcvr.load_item();
1293   LIR_Opr temp = new_register(T_METADATA);
1294   LIR_Opr result = rlock_result(x);
1295 
1296   // need to perform the null check on the rcvr
1297   CodeEmitInfo* info = NULL;
1298   if (x-&gt;needs_null_check()) {
1299     info = state_for(x);
1300   }
1301 
1302   // FIXME T_ADDRESS should actually be T_METADATA but it can&#39;t because the
1303   // meaning of these two is mixed up (see JDK-8026837).
1304   __ move(new LIR_Address(rcvr.result(), oopDesc::klass_offset_in_bytes(), T_ADDRESS), temp, info);
1305   __ move_wide(new LIR_Address(temp, in_bytes(Klass::java_mirror_offset()), T_ADDRESS), temp);
1306   // mirror = ((OopHandle)mirror)-&gt;resolve();
1307   access_load(IN_NATIVE, T_OBJECT,
1308               LIR_OprFact::address(new LIR_Address(temp, T_OBJECT)), result);
1309 }
1310 
1311 // java.lang.Class::isPrimitive()
1312 void LIRGenerator::do_isPrimitive(Intrinsic* x) {
1313   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1314 
1315   LIRItem rcvr(x-&gt;argument_at(0), this);
1316   rcvr.load_item();
1317   LIR_Opr temp = new_register(T_METADATA);
1318   LIR_Opr result = rlock_result(x);
1319 
1320   CodeEmitInfo* info = NULL;
1321   if (x-&gt;needs_null_check()) {
1322     info = state_for(x);
1323   }
1324 
1325   __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset(), T_ADDRESS), temp, info);
1326   __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));
1327   __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);
1328 }
1329 
1330 
1331 // Example: Thread.currentThread()
1332 void LIRGenerator::do_currentThread(Intrinsic* x) {
1333   assert(x-&gt;number_of_arguments() == 0, &quot;wrong type&quot;);
1334   LIR_Opr reg = rlock_result(x);
1335   __ move_wide(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::threadObj_offset()), T_OBJECT), reg);
1336 }
1337 
1338 
1339 void LIRGenerator::do_RegisterFinalizer(Intrinsic* x) {
1340   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
1341   LIRItem receiver(x-&gt;argument_at(0), this);
1342 
1343   receiver.load_item();
1344   BasicTypeList signature;
1345   signature.append(T_OBJECT); // receiver
1346   LIR_OprList* args = new LIR_OprList();
1347   args-&gt;append(receiver.result());
1348   CodeEmitInfo* info = state_for(x, x-&gt;state());
1349   call_runtime(&amp;signature, args,
1350                CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::register_finalizer_id)),
1351                voidType, info);
1352 
1353   set_no_result(x);
1354 }
1355 
1356 
1357 //------------------------local access--------------------------------------
1358 
1359 LIR_Opr LIRGenerator::operand_for_instruction(Instruction* x) {
1360   if (x-&gt;operand()-&gt;is_illegal()) {
1361     Constant* c = x-&gt;as_Constant();
1362     if (c != NULL) {
1363       x-&gt;set_operand(LIR_OprFact::value_type(c-&gt;type()));
1364     } else {
1365       assert(x-&gt;as_Phi() || x-&gt;as_Local() != NULL, &quot;only for Phi and Local&quot;);
1366       // allocate a virtual register for this local or phi
1367       x-&gt;set_operand(rlock(x));
1368       _instruction_for_operand.at_put_grow(x-&gt;operand()-&gt;vreg_number(), x, NULL);
1369     }
1370   }
1371   return x-&gt;operand();
1372 }
1373 
1374 
1375 Instruction* LIRGenerator::instruction_for_opr(LIR_Opr opr) {
1376   if (opr-&gt;is_virtual()) {
1377     return instruction_for_vreg(opr-&gt;vreg_number());
1378   }
1379   return NULL;
1380 }
1381 
1382 
1383 Instruction* LIRGenerator::instruction_for_vreg(int reg_num) {
1384   if (reg_num &lt; _instruction_for_operand.length()) {
1385     return _instruction_for_operand.at(reg_num);
1386   }
1387   return NULL;
1388 }
1389 
1390 
1391 void LIRGenerator::set_vreg_flag(int vreg_num, VregFlag f) {
1392   if (_vreg_flags.size_in_bits() == 0) {
1393     BitMap2D temp(100, num_vreg_flags);
1394     _vreg_flags = temp;
1395   }
1396   _vreg_flags.at_put_grow(vreg_num, f, true);
1397 }
1398 
1399 bool LIRGenerator::is_vreg_flag_set(int vreg_num, VregFlag f) {
1400   if (!_vreg_flags.is_valid_index(vreg_num, f)) {
1401     return false;
1402   }
1403   return _vreg_flags.at(vreg_num, f);
1404 }
1405 
1406 
1407 // Block local constant handling.  This code is useful for keeping
1408 // unpinned constants and constants which aren&#39;t exposed in the IR in
1409 // registers.  Unpinned Constant instructions have their operands
1410 // cleared when the block is finished so that other blocks can&#39;t end
1411 // up referring to their registers.
1412 
1413 LIR_Opr LIRGenerator::load_constant(Constant* x) {
1414   assert(!x-&gt;is_pinned(), &quot;only for unpinned constants&quot;);
1415   _unpinned_constants.append(x);
1416   return load_constant(LIR_OprFact::value_type(x-&gt;type())-&gt;as_constant_ptr());
1417 }
1418 
1419 
1420 LIR_Opr LIRGenerator::load_constant(LIR_Const* c) {
1421   BasicType t = c-&gt;type();
1422   for (int i = 0; i &lt; _constants.length(); i++) {
1423     LIR_Const* other = _constants.at(i);
1424     if (t == other-&gt;type()) {
1425       switch (t) {
1426       case T_INT:
1427       case T_FLOAT:
1428         if (c-&gt;as_jint_bits() != other-&gt;as_jint_bits()) continue;
1429         break;
1430       case T_LONG:
1431       case T_DOUBLE:
1432         if (c-&gt;as_jint_hi_bits() != other-&gt;as_jint_hi_bits()) continue;
1433         if (c-&gt;as_jint_lo_bits() != other-&gt;as_jint_lo_bits()) continue;
1434         break;
1435       case T_OBJECT:
1436         if (c-&gt;as_jobject() != other-&gt;as_jobject()) continue;
1437         break;
1438       default:
1439         break;
1440       }
1441       return _reg_for_constants.at(i);
1442     }
1443   }
1444 
1445   LIR_Opr result = new_register(t);
1446   __ move((LIR_Opr)c, result);
1447   if (!in_conditional_code()) {
1448     _constants.append(c);
1449     _reg_for_constants.append(result);
1450   }
1451   return result;
1452 }
1453 
1454 void LIRGenerator::set_in_conditional_code(bool v) {
1455   assert(v != _in_conditional_code, &quot;must change state&quot;);
1456   _in_conditional_code = v;
1457 }
1458 
1459 
1460 //------------------------field access--------------------------------------
1461 
1462 void LIRGenerator::do_CompareAndSwap(Intrinsic* x, ValueType* type) {
1463   assert(x-&gt;number_of_arguments() == 4, &quot;wrong type&quot;);
1464   LIRItem obj   (x-&gt;argument_at(0), this);  // object
1465   LIRItem offset(x-&gt;argument_at(1), this);  // offset of field
1466   LIRItem cmp   (x-&gt;argument_at(2), this);  // value to compare with field
1467   LIRItem val   (x-&gt;argument_at(3), this);  // replace field with val if matches cmp
1468   assert(obj.type()-&gt;tag() == objectTag, &quot;invalid type&quot;);
1469 
1470   // In 64bit the type can be long, sparc doesn&#39;t have this assert
1471   // assert(offset.type()-&gt;tag() == intTag, &quot;invalid type&quot;);
1472 
1473   assert(cmp.type()-&gt;tag() == type-&gt;tag(), &quot;invalid type&quot;);
1474   assert(val.type()-&gt;tag() == type-&gt;tag(), &quot;invalid type&quot;);
1475 
1476   LIR_Opr result = access_atomic_cmpxchg_at(IN_HEAP, as_BasicType(type),
1477                                             obj, offset, cmp, val);
1478   set_result(x, result);
1479 }
1480 
1481 // Comment copied form templateTable_i486.cpp
1482 // ----------------------------------------------------------------------------
1483 // Volatile variables demand their effects be made known to all CPU&#39;s in
1484 // order.  Store buffers on most chips allow reads &amp; writes to reorder; the
1485 // JMM&#39;s ReadAfterWrite.java test fails in -Xint mode without some kind of
1486 // memory barrier (i.e., it&#39;s not sufficient that the interpreter does not
1487 // reorder volatile references, the hardware also must not reorder them).
1488 //
1489 // According to the new Java Memory Model (JMM):
1490 // (1) All volatiles are serialized wrt to each other.
1491 // ALSO reads &amp; writes act as aquire &amp; release, so:
1492 // (2) A read cannot let unrelated NON-volatile memory refs that happen after
1493 // the read float up to before the read.  It&#39;s OK for non-volatile memory refs
1494 // that happen before the volatile read to float down below it.
1495 // (3) Similar a volatile write cannot let unrelated NON-volatile memory refs
1496 // that happen BEFORE the write float down to after the write.  It&#39;s OK for
1497 // non-volatile memory refs that happen after the volatile write to float up
1498 // before it.
1499 //
1500 // We only put in barriers around volatile refs (they are expensive), not
1501 // _between_ memory refs (that would require us to track the flavor of the
1502 // previous memory refs).  Requirements (2) and (3) require some barriers
1503 // before volatile stores and after volatile loads.  These nearly cover
1504 // requirement (1) but miss the volatile-store-volatile-load case.  This final
1505 // case is placed after volatile-stores although it could just as well go
1506 // before volatile-loads.
1507 
1508 
1509 void LIRGenerator::do_StoreField(StoreField* x) {
1510   bool needs_patching = x-&gt;needs_patching();
1511   bool is_volatile = x-&gt;field()-&gt;is_volatile();
1512   BasicType field_type = x-&gt;field_type();
1513 
1514   CodeEmitInfo* info = NULL;
1515   if (needs_patching) {
1516     assert(x-&gt;explicit_null_check() == NULL, &quot;can&#39;t fold null check into patching field access&quot;);
1517     info = state_for(x, x-&gt;state_before());
1518   } else if (x-&gt;needs_null_check()) {
1519     NullCheck* nc = x-&gt;explicit_null_check();
1520     if (nc == NULL) {
1521       info = state_for(x);
1522     } else {
1523       info = state_for(nc);
1524     }
1525   }
1526 
1527   LIRItem object(x-&gt;obj(), this);
1528   LIRItem value(x-&gt;value(),  this);
1529 
1530   object.load_item();
1531 
1532   if (is_volatile || needs_patching) {
1533     // load item if field is volatile (fewer special cases for volatiles)
1534     // load item if field not initialized
1535     // load item if field not constant
1536     // because of code patching we cannot inline constants
1537     if (field_type == T_BYTE || field_type == T_BOOLEAN) {
1538       value.load_byte_item();
1539     } else  {
1540       value.load_item();
1541     }
1542   } else {
1543     value.load_for_store(field_type);
1544   }
1545 
1546   set_no_result(x);
1547 
1548 #ifndef PRODUCT
1549   if (PrintNotLoaded &amp;&amp; needs_patching) {
1550     tty-&gt;print_cr(&quot;   ###class not loaded at store_%s bci %d&quot;,
1551                   x-&gt;is_static() ?  &quot;static&quot; : &quot;field&quot;, x-&gt;printable_bci());
1552   }
1553 #endif
1554 
1555   if (x-&gt;needs_null_check() &amp;&amp;
1556       (needs_patching ||
1557        MacroAssembler::needs_explicit_null_check(x-&gt;offset()))) {
1558     if (needs_patching &amp;&amp; x-&gt;field()-&gt;signature()-&gt;is_Q_signature()) {
1559       // We are storing a field of type &quot;QT;&quot; into holder class H, but H is not yet
1560       // loaded. (If H had been loaded, then T must also have already been loaded
1561       // due to the &quot;Q&quot; signature, and needs_patching would be false).
1562       assert(!x-&gt;field()-&gt;holder()-&gt;is_loaded(), &quot;must be&quot;);
1563       // We don&#39;t know the offset of this field. Let&#39;s deopt and recompile.
1564       CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
1565                                           Deoptimization::Reason_unloaded,
1566                                           Deoptimization::Action_make_not_entrant);
1567       __ branch(lir_cond_always, stub);
1568     } else {
1569       // Emit an explicit null check because the offset is too large.
1570       // If the class is not loaded and the object is NULL, we need to deoptimize to throw a
1571       // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.
1572       __ null_check(object.result(), new CodeEmitInfo(info), /* deoptimize */ needs_patching);
1573     }
1574   }
1575 
1576   DecoratorSet decorators = IN_HEAP;
1577   if (is_volatile) {
1578     decorators |= MO_SEQ_CST;
1579   }
1580   if (needs_patching) {
1581     decorators |= C1_NEEDS_PATCHING;
1582   }
1583 
1584   access_store_at(decorators, field_type, object, LIR_OprFact::intConst(x-&gt;offset()),
1585                   value.result(), info != NULL ? new CodeEmitInfo(info) : NULL, info);
1586 }
1587 
1588 // FIXME -- I can&#39;t find any other way to pass an address to access_load_at().
1589 class TempResolvedAddress: public Instruction {
1590  public:
1591   TempResolvedAddress(ValueType* type, LIR_Opr addr) : Instruction(type) {
1592     set_operand(addr);
1593   }
1594   virtual void input_values_do(ValueVisitor*) {}
1595   virtual void visit(InstructionVisitor* v)   {}
1596   virtual const char* name() const  { return &quot;TempResolvedAddress&quot;; }
1597 };
1598 
1599 void LIRGenerator::access_flattened_array(bool is_load, LIRItem&amp; array, LIRItem&amp; index, LIRItem&amp; obj_item) {
1600   // Find the starting address of the source (inside the array)
1601   ciType* array_type = array.value()-&gt;declared_type();
<a name="6" id="anc6"></a><span class="line-modified">1602   ciFlatArrayKlass* flat_array_klass = array_type-&gt;as_flat_array_klass();</span>
<span class="line-modified">1603   assert(flat_array_klass-&gt;is_loaded(), &quot;must be&quot;);</span>
1604 
<a name="7" id="anc7"></a><span class="line-modified">1605   ciInlineKlass* elem_klass = flat_array_klass-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-modified">1606   int array_header_size = flat_array_klass-&gt;array_header_in_bytes();</span>
<span class="line-modified">1607   int shift = flat_array_klass-&gt;log2_element_size();</span>
1608 
1609 #ifndef _LP64
1610   LIR_Opr index_op = new_register(T_INT);
1611   // FIXME -- on 32-bit, the shift below can overflow, so we need to check that
1612   // the top (shift+1) bits of index_op must be zero, or
1613   // else throw ArrayIndexOutOfBoundsException
1614   if (index.result()-&gt;is_constant()) {
1615     jint const_index = index.result()-&gt;as_jint();
1616     __ move(LIR_OprFact::intConst(const_index &lt;&lt; shift), index_op);
1617   } else {
1618     __ shift_left(index_op, shift, index.result());
1619   }
1620 #else
1621   LIR_Opr index_op = new_register(T_LONG);
1622   if (index.result()-&gt;is_constant()) {
1623     jint const_index = index.result()-&gt;as_jint();
1624     __ move(LIR_OprFact::longConst(const_index &lt;&lt; shift), index_op);
1625   } else {
1626     __ convert(Bytecodes::_i2l, index.result(), index_op);
1627     // Need to shift manually, as LIR_Address can scale only up to 3.
1628     __ shift_left(index_op, shift, index_op);
1629   }
1630 #endif
1631 
1632   LIR_Opr elm_op = new_pointer_register();
1633   LIR_Address* elm_address = new LIR_Address(array.result(), index_op, array_header_size, T_ADDRESS);
1634   __ leal(LIR_OprFact::address(elm_address), elm_op);
1635 
1636   for (int i = 0; i &lt; elem_klass-&gt;nof_nonstatic_fields(); i++) {
1637     ciField* inner_field = elem_klass-&gt;nonstatic_field_at(i);
1638     assert(!inner_field-&gt;is_flattened(), &quot;flattened fields must have been expanded&quot;);
1639     int obj_offset = inner_field-&gt;offset();
1640     int elm_offset = obj_offset - elem_klass-&gt;first_field_offset(); // object header is not stored in array.
1641 
1642     BasicType field_type = inner_field-&gt;type()-&gt;basic_type();
1643     switch (field_type) {
1644     case T_BYTE:
1645     case T_BOOLEAN:
1646     case T_SHORT:
1647     case T_CHAR:
1648      field_type = T_INT;
1649       break;
1650     default:
1651       break;
1652     }
1653 
1654     LIR_Opr temp = new_register(field_type);
1655     TempResolvedAddress* elm_resolved_addr = new TempResolvedAddress(as_ValueType(field_type), elm_op);
1656     LIRItem elm_item(elm_resolved_addr, this);
1657 
1658     DecoratorSet decorators = IN_HEAP;
1659     if (is_load) {
1660       access_load_at(decorators, field_type,
1661                      elm_item, LIR_OprFact::intConst(elm_offset), temp,
1662                      NULL, NULL);
1663       access_store_at(decorators, field_type,
1664                       obj_item, LIR_OprFact::intConst(obj_offset), temp,
1665                       NULL, NULL);
1666     } else {
1667       access_load_at(decorators, field_type,
1668                      obj_item, LIR_OprFact::intConst(obj_offset), temp,
1669                      NULL, NULL);
1670       access_store_at(decorators, field_type,
1671                       elm_item, LIR_OprFact::intConst(elm_offset), temp,
1672                       NULL, NULL);
1673     }
1674   }
1675 }
1676 
1677 void LIRGenerator::check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path) {
1678   LIR_Opr tmp = new_register(T_METADATA);
1679   __ check_flattened_array(array, value, tmp, slow_path);
1680 }
1681 
1682 void LIRGenerator::check_null_free_array(LIRItem&amp; array, LIRItem&amp; value, CodeEmitInfo* info) {
1683   LabelObj* L_end = new LabelObj();
1684   LIR_Opr tmp = new_register(T_METADATA);
1685   __ check_null_free_array(array.result(), tmp);
1686   __ branch(lir_cond_equal, L_end-&gt;label());
1687   __ null_check(value.result(), info);
1688   __ branch_destination(L_end-&gt;label());
1689 }
1690 
1691 bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {
1692   if (x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_flattened_array()) {
1693     ciType* type = x-&gt;value()-&gt;declared_type();
1694     if (type != NULL &amp;&amp; type-&gt;is_klass()) {
1695       ciKlass* klass = type-&gt;as_klass();
<a name="8" id="anc8"></a><span class="line-modified">1696       if (!klass-&gt;can_be_inline_klass() || (klass-&gt;is_inlinetype() &amp;&amp; !klass-&gt;as_inline_klass()-&gt;flatten_array())) {</span>
1697         // This is known to be a non-flattened object. If the array is flattened,
1698         // it will be caught by the code generated by array_store_check().
1699         return false;
1700       }
1701     }
1702     // We&#39;re not 100% sure, so let&#39;s do the flattened_array_store_check.
1703     return true;
1704   }
1705   return false;
1706 }
1707 
1708 bool LIRGenerator::needs_null_free_array_store_check(StoreIndexed* x) {
1709   return x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_null_free_array();
1710 }
1711 
1712 void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
1713   assert(x-&gt;is_pinned(),&quot;&quot;);
1714   assert(x-&gt;elt_type() != T_ARRAY, &quot;never used&quot;);
1715   bool is_loaded_flattened_array = x-&gt;array()-&gt;is_loaded_flattened_array();
1716   bool needs_range_check = x-&gt;compute_needs_range_check();
1717   bool use_length = x-&gt;length() != NULL;
1718   bool obj_store = is_reference_type(x-&gt;elt_type());
1719   bool needs_store_check = obj_store &amp;&amp; !(is_loaded_flattened_array &amp;&amp; x-&gt;is_exact_flattened_array_store()) &amp;&amp;
1720                                         (x-&gt;value()-&gt;as_Constant() == NULL ||
1721                                          !get_jobject_constant(x-&gt;value())-&gt;is_null_object());
1722 
1723   LIRItem array(x-&gt;array(), this);
1724   LIRItem index(x-&gt;index(), this);
1725   LIRItem value(x-&gt;value(), this);
1726   LIRItem length(this);
1727 
1728   array.load_item();
1729   index.load_nonconstant();
1730 
1731   if (use_length &amp;&amp; needs_range_check) {
1732     length.set_instruction(x-&gt;length());
1733     length.load_item();
1734   }
1735 
1736   if (needs_store_check || x-&gt;check_boolean()
1737       || is_loaded_flattened_array || needs_flattened_array_store_check(x) || needs_null_free_array_store_check(x)) {
1738     value.load_item();
1739   } else {
1740     value.load_for_store(x-&gt;elt_type());
1741   }
1742 
1743   set_no_result(x);
1744 
1745   // the CodeEmitInfo must be duplicated for each different
1746   // LIR-instruction because spilling can occur anywhere between two
1747   // instructions and so the debug information must be different
1748   CodeEmitInfo* range_check_info = state_for(x);
1749   CodeEmitInfo* null_check_info = NULL;
1750   if (x-&gt;needs_null_check()) {
1751     null_check_info = new CodeEmitInfo(range_check_info);
1752   }
1753 
1754   if (GenerateRangeChecks &amp;&amp; needs_range_check) {
1755     if (use_length) {
1756       __ cmp(lir_cond_belowEqual, length.result(), index.result());
1757       __ branch(lir_cond_belowEqual, new RangeCheckStub(range_check_info, index.result(), array.result()));
1758     } else {
1759       array_range_check(array.result(), index.result(), null_check_info, range_check_info);
1760       // range_check also does the null check
1761       null_check_info = NULL;
1762     }
1763   }
1764 
1765   if (x-&gt;should_profile()) {
1766     ciMethodData* md = NULL;
1767     ciArrayLoadStoreData* load_store = NULL;
1768     profile_array_type(x, md, load_store);
1769     if (is_loaded_flattened_array) {
1770       int flag = ArrayLoadStoreData::flat_array_byte_constant() | ArrayLoadStoreData::null_free_array_byte_constant();
1771       assert(md != NULL, &quot;should have been initialized&quot;);
1772       profile_array_load_store_flags(md, load_store, flag);
1773     } else if (x-&gt;array()-&gt;maybe_null_free_array()) {
1774       profile_null_free_array(array, md, load_store);
1775     }
1776     profile_element_type(x-&gt;value(), md, load_store);
1777   }
1778 
1779   if (GenerateArrayStoreCheck &amp;&amp; needs_store_check) {
1780     CodeEmitInfo* store_check_info = new CodeEmitInfo(range_check_info);
1781     array_store_check(value.result(), array.result(), store_check_info, NULL, -1);
1782   }
1783 
1784   if (is_loaded_flattened_array) {
1785     if (!x-&gt;value()-&gt;is_never_null()) {
1786       __ null_check(value.result(), new CodeEmitInfo(range_check_info));
1787     }
1788     access_flattened_array(false, array, index, value);
1789   } else {
1790     StoreFlattenedArrayStub* slow_path = NULL;
1791 
1792     if (needs_flattened_array_store_check(x)) {
1793       // Check if we indeed have a flattened array
1794       index.load_item();
1795       slow_path = new StoreFlattenedArrayStub(array.result(), index.result(), value.result(), state_for(x, x-&gt;state_before()));
1796       check_flattened_array(array.result(), value.result(), slow_path);
1797       set_in_conditional_code(true);
1798     } else if (needs_null_free_array_store_check(x)) {
1799       CodeEmitInfo* info = new CodeEmitInfo(range_check_info);
1800       check_null_free_array(array, value, info);
1801     }
1802 
1803     DecoratorSet decorators = IN_HEAP | IS_ARRAY;
1804     if (x-&gt;check_boolean()) {
1805       decorators |= C1_MASK_BOOLEAN;
1806     }
1807 
1808     access_store_at(decorators, x-&gt;elt_type(), array, index.result(), value.result(),
1809                     NULL, null_check_info);
1810     if (slow_path != NULL) {
1811       __ branch_destination(slow_path-&gt;continuation());
1812       set_in_conditional_code(false);
1813     }
1814   }
1815 }
1816 
1817 void LIRGenerator::access_load_at(DecoratorSet decorators, BasicType type,
1818                                   LIRItem&amp; base, LIR_Opr offset, LIR_Opr result,
1819                                   CodeEmitInfo* patch_info, CodeEmitInfo* load_emit_info) {
1820   decorators |= ACCESS_READ;
1821   LIRAccess access(this, decorators, base, offset, type, patch_info, load_emit_info);
1822   if (access.is_raw()) {
1823     _barrier_set-&gt;BarrierSetC1::load_at(access, result);
1824   } else {
1825     _barrier_set-&gt;load_at(access, result);
1826   }
1827 }
1828 
1829 void LIRGenerator::access_load(DecoratorSet decorators, BasicType type,
1830                                LIR_Opr addr, LIR_Opr result) {
1831   decorators |= ACCESS_READ;
1832   LIRAccess access(this, decorators, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, type);
1833   access.set_resolved_addr(addr);
1834   if (access.is_raw()) {
1835     _barrier_set-&gt;BarrierSetC1::load(access, result);
1836   } else {
1837     _barrier_set-&gt;load(access, result);
1838   }
1839 }
1840 
1841 void LIRGenerator::access_store_at(DecoratorSet decorators, BasicType type,
1842                                    LIRItem&amp; base, LIR_Opr offset, LIR_Opr value,
1843                                    CodeEmitInfo* patch_info, CodeEmitInfo* store_emit_info) {
1844   decorators |= ACCESS_WRITE;
1845   LIRAccess access(this, decorators, base, offset, type, patch_info, store_emit_info);
1846   if (access.is_raw()) {
1847     _barrier_set-&gt;BarrierSetC1::store_at(access, value);
1848   } else {
1849     _barrier_set-&gt;store_at(access, value);
1850   }
1851 }
1852 
1853 LIR_Opr LIRGenerator::access_atomic_cmpxchg_at(DecoratorSet decorators, BasicType type,
1854                                                LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
1855   decorators |= ACCESS_READ;
1856   decorators |= ACCESS_WRITE;
1857   // Atomic operations are SEQ_CST by default
1858   decorators |= ((decorators &amp; MO_DECORATOR_MASK) == 0) ? MO_SEQ_CST : 0;
1859   LIRAccess access(this, decorators, base, offset, type);
1860   if (access.is_raw()) {
1861     return _barrier_set-&gt;BarrierSetC1::atomic_cmpxchg_at(access, cmp_value, new_value);
1862   } else {
1863     return _barrier_set-&gt;atomic_cmpxchg_at(access, cmp_value, new_value);
1864   }
1865 }
1866 
1867 LIR_Opr LIRGenerator::access_atomic_xchg_at(DecoratorSet decorators, BasicType type,
1868                                             LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; value) {
1869   decorators |= ACCESS_READ;
1870   decorators |= ACCESS_WRITE;
1871   // Atomic operations are SEQ_CST by default
1872   decorators |= ((decorators &amp; MO_DECORATOR_MASK) == 0) ? MO_SEQ_CST : 0;
1873   LIRAccess access(this, decorators, base, offset, type);
1874   if (access.is_raw()) {
1875     return _barrier_set-&gt;BarrierSetC1::atomic_xchg_at(access, value);
1876   } else {
1877     return _barrier_set-&gt;atomic_xchg_at(access, value);
1878   }
1879 }
1880 
1881 LIR_Opr LIRGenerator::access_atomic_add_at(DecoratorSet decorators, BasicType type,
1882                                            LIRItem&amp; base, LIRItem&amp; offset, LIRItem&amp; value) {
1883   decorators |= ACCESS_READ;
1884   decorators |= ACCESS_WRITE;
1885   // Atomic operations are SEQ_CST by default
1886   decorators |= ((decorators &amp; MO_DECORATOR_MASK) == 0) ? MO_SEQ_CST : 0;
1887   LIRAccess access(this, decorators, base, offset, type);
1888   if (access.is_raw()) {
1889     return _barrier_set-&gt;BarrierSetC1::atomic_add_at(access, value);
1890   } else {
1891     return _barrier_set-&gt;atomic_add_at(access, value);
1892   }
1893 }
1894 
1895 LIR_Opr LIRGenerator::access_resolve(DecoratorSet decorators, LIR_Opr obj) {
1896   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
1897   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
1898     decorators |= ACCESS_READ | ACCESS_WRITE;
1899   }
1900 
1901   return _barrier_set-&gt;resolve(this, decorators, obj);
1902 }
1903 
1904 Constant* LIRGenerator::flattened_field_load_prolog(LoadField* x, CodeEmitInfo* info) {
1905   ciField* field = x-&gt;field();
1906   ciInstanceKlass* holder = field-&gt;holder();
1907   Constant* default_value = NULL;
1908 
1909   // Unloaded &quot;QV;&quot; klasses are represented by a ciInstanceKlass
1910   bool field_type_unloaded = field-&gt;type()-&gt;is_instance_klass() &amp;&amp; !field-&gt;type()-&gt;as_instance_klass()-&gt;is_loaded();
1911 
1912   // Check for edge cases (1), (2) and (3) for getstatic and getfield
1913   bool deopt = false;
1914   bool need_default = false;
1915   if (field-&gt;is_static()) {
1916       // (1) holder is unloaded -- no problem: it will be loaded by patching, and field offset will be determined.
1917       // No check needed here.
1918 
1919     if (field_type_unloaded) {
1920       // (2) field type is unloaded -- problem: we don&#39;t know what the default value is. Let&#39;s deopt.
1921       //                               FIXME: consider getting the default value in patching code.
1922       deopt = true;
1923     } else {
1924       need_default = true;
1925     }
1926 
1927       // (3) field is not flattened -- we don&#39;t care: static fields are never flattened.
1928       // No check needed here.
1929   } else {
1930     if (!holder-&gt;is_loaded()) {
1931       // (1) holder is unloaded -- problem: we needed the field offset back in GraphBuilder::access_field()
1932       //                           FIXME: consider getting field offset in patching code (but only if the field
1933       //                           type was loaded at compilation time).
1934       deopt = true;
1935     } else if (field_type_unloaded) {
1936       // (2) field type is unloaded -- problem: we don&#39;t know whether it&#39;s flattened or not. Let&#39;s deopt
1937       deopt = true;
1938     } else if (!field-&gt;is_flattened()) {
1939       // (3) field is not flattened -- need default value in cases of uninitialized field
1940       need_default = true;
1941     }
1942   }
1943 
1944   if (deopt) {
1945     assert(!need_default, &quot;deopt and need_default cannot both be true&quot;);
1946     assert(x-&gt;needs_patching(), &quot;must be&quot;);
1947     assert(info != NULL, &quot;must be&quot;);
1948     CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
1949                                         Deoptimization::Reason_unloaded,
1950                                         Deoptimization::Action_make_not_entrant);
1951     __ branch(lir_cond_always, stub);
1952   } else if (need_default) {
1953     assert(!field_type_unloaded, &quot;must be&quot;);
<a name="9" id="anc9"></a><span class="line-modified">1954     assert(field-&gt;type()-&gt;is_inlinetype(), &quot;must be&quot;);</span>
<span class="line-modified">1955     ciInlineKlass* inline_klass = field-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">1956     assert(inline_klass-&gt;is_loaded(), &quot;must be&quot;);</span>
1957 
1958     if (field-&gt;is_static() &amp;&amp; holder-&gt;is_loaded()) {
1959       ciInstance* mirror = field-&gt;holder()-&gt;java_mirror();
1960       ciObject* val = mirror-&gt;field_value(field).as_object();
1961       if (val-&gt;is_null_object()) {
1962         // This is a non-nullable static field, but it&#39;s not initialized.
1963         // We need to do a null check, and replace it with the default value.
1964       } else {
1965         // No need to perform null check on this static field
1966         need_default = false;
1967       }
1968     }
1969 
1970     if (need_default) {
<a name="10" id="anc10"></a><span class="line-modified">1971       default_value = new Constant(new InstanceConstant(inline_klass-&gt;default_instance()));</span>
1972     }
1973   }
1974 
1975   return default_value;
1976 }
1977 
1978 void LIRGenerator::do_LoadField(LoadField* x) {
1979   bool needs_patching = x-&gt;needs_patching();
1980   bool is_volatile = x-&gt;field()-&gt;is_volatile();
1981   BasicType field_type = x-&gt;field_type();
1982 
1983   CodeEmitInfo* info = NULL;
1984   if (needs_patching) {
1985     assert(x-&gt;explicit_null_check() == NULL, &quot;can&#39;t fold null check into patching field access&quot;);
1986     info = state_for(x, x-&gt;state_before());
1987   } else if (x-&gt;needs_null_check()) {
1988     NullCheck* nc = x-&gt;explicit_null_check();
1989     if (nc == NULL) {
1990       info = state_for(x);
1991     } else {
1992       info = state_for(nc);
1993     }
1994   }
1995 
1996   LIRItem object(x-&gt;obj(), this);
1997 
1998   object.load_item();
1999 
2000 #ifndef PRODUCT
2001   if (PrintNotLoaded &amp;&amp; needs_patching) {
2002     tty-&gt;print_cr(&quot;   ###class not loaded at load_%s bci %d&quot;,
2003                   x-&gt;is_static() ?  &quot;static&quot; : &quot;field&quot;, x-&gt;printable_bci());
2004   }
2005 #endif
2006 
2007   Constant* default_value = NULL;
2008   if (x-&gt;field()-&gt;signature()-&gt;is_Q_signature()) {
2009     default_value = flattened_field_load_prolog(x, info);
2010   }
2011 
2012   bool stress_deopt = StressLoopInvariantCodeMotion &amp;&amp; info &amp;&amp; info-&gt;deoptimize_on_exception();
2013   if (x-&gt;needs_null_check() &amp;&amp;
2014       (needs_patching ||
2015        MacroAssembler::needs_explicit_null_check(x-&gt;offset()) ||
2016        stress_deopt)) {
2017     LIR_Opr obj = object.result();
2018     if (stress_deopt) {
2019       obj = new_register(T_OBJECT);
2020       __ move(LIR_OprFact::oopConst(NULL), obj);
2021     }
2022     // Emit an explicit null check because the offset is too large.
2023     // If the class is not loaded and the object is NULL, we need to deoptimize to throw a
2024     // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.
2025     __ null_check(obj, new CodeEmitInfo(info), /* deoptimize */ needs_patching);
2026   }
2027 
2028   DecoratorSet decorators = IN_HEAP;
2029   if (is_volatile) {
2030     decorators |= MO_SEQ_CST;
2031   }
2032   if (needs_patching) {
2033     decorators |= C1_NEEDS_PATCHING;
2034   }
2035 
2036   LIR_Opr result = rlock_result(x, field_type);
2037   access_load_at(decorators, field_type,
2038                  object, LIR_OprFact::intConst(x-&gt;offset()), result,
2039                  info ? new CodeEmitInfo(info) : NULL, info);
2040 
2041   if (default_value != NULL) {
2042     LabelObj* L_end = new LabelObj();
2043     __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));
2044     __ branch(lir_cond_notEqual, L_end-&gt;label());
2045     set_in_conditional_code(true);
2046     __ move(load_constant(default_value), result);
2047     __ branch_destination(L_end-&gt;label());
2048     set_in_conditional_code(false);
2049   }
2050 }
2051 
2052 
2053 //------------------------java.nio.Buffer.checkIndex------------------------
2054 
2055 // int java.nio.Buffer.checkIndex(int)
2056 void LIRGenerator::do_NIOCheckIndex(Intrinsic* x) {
2057   // NOTE: by the time we are in checkIndex() we are guaranteed that
2058   // the buffer is non-null (because checkIndex is package-private and
2059   // only called from within other methods in the buffer).
2060   assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
2061   LIRItem buf  (x-&gt;argument_at(0), this);
2062   LIRItem index(x-&gt;argument_at(1), this);
2063   buf.load_item();
2064   index.load_item();
2065 
2066   LIR_Opr result = rlock_result(x);
2067   if (GenerateRangeChecks) {
2068     CodeEmitInfo* info = state_for(x);
2069     CodeStub* stub = new RangeCheckStub(info, index.result());
2070     LIR_Opr buf_obj = access_resolve(IS_NOT_NULL | ACCESS_READ, buf.result());
2071     if (index.result()-&gt;is_constant()) {
2072       cmp_mem_int(lir_cond_belowEqual, buf_obj, java_nio_Buffer::limit_offset(), index.result()-&gt;as_jint(), info);
2073       __ branch(lir_cond_belowEqual, stub);
2074     } else {
2075       cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf_obj,
2076                   java_nio_Buffer::limit_offset(), T_INT, info);
2077       __ branch(lir_cond_aboveEqual, stub);
2078     }
2079     __ move(index.result(), result);
2080   } else {
2081     // Just load the index into the result register
2082     __ move(index.result(), result);
2083   }
2084 }
2085 
2086 
2087 //------------------------array access--------------------------------------
2088 
2089 
2090 void LIRGenerator::do_ArrayLength(ArrayLength* x) {
2091   LIRItem array(x-&gt;array(), this);
2092   array.load_item();
2093   LIR_Opr reg = rlock_result(x);
2094 
2095   CodeEmitInfo* info = NULL;
2096   if (x-&gt;needs_null_check()) {
2097     NullCheck* nc = x-&gt;explicit_null_check();
2098     if (nc == NULL) {
2099       info = state_for(x);
2100     } else {
2101       info = state_for(nc);
2102     }
2103     if (StressLoopInvariantCodeMotion &amp;&amp; info-&gt;deoptimize_on_exception()) {
2104       LIR_Opr obj = new_register(T_OBJECT);
2105       __ move(LIR_OprFact::oopConst(NULL), obj);
2106       __ null_check(obj, new CodeEmitInfo(info));
2107     }
2108   }
2109   __ load(new LIR_Address(array.result(), arrayOopDesc::length_offset_in_bytes(), T_INT), reg, info, lir_patch_none);
2110 }
2111 
2112 
2113 void LIRGenerator::do_LoadIndexed(LoadIndexed* x) {
2114   bool use_length = x-&gt;length() != NULL;
2115   LIRItem array(x-&gt;array(), this);
2116   LIRItem index(x-&gt;index(), this);
2117   LIRItem length(this);
2118   bool needs_range_check = x-&gt;compute_needs_range_check();
2119 
2120   if (use_length &amp;&amp; needs_range_check) {
2121     length.set_instruction(x-&gt;length());
2122     length.load_item();
2123   }
2124 
2125   array.load_item();
2126   if (index.is_constant() &amp;&amp; can_inline_as_constant(x-&gt;index())) {
2127     // let it be a constant
2128     index.dont_load_item();
2129   } else {
2130     index.load_item();
2131   }
2132 
2133   CodeEmitInfo* range_check_info = state_for(x);
2134   CodeEmitInfo* null_check_info = NULL;
2135   if (x-&gt;needs_null_check()) {
2136     NullCheck* nc = x-&gt;explicit_null_check();
2137     if (nc != NULL) {
2138       null_check_info = state_for(nc);
2139     } else {
2140       null_check_info = range_check_info;
2141     }
2142     if (StressLoopInvariantCodeMotion &amp;&amp; null_check_info-&gt;deoptimize_on_exception()) {
2143       LIR_Opr obj = new_register(T_OBJECT);
2144       __ move(LIR_OprFact::oopConst(NULL), obj);
2145       __ null_check(obj, new CodeEmitInfo(null_check_info));
2146     }
2147   }
2148 
2149   if (GenerateRangeChecks &amp;&amp; needs_range_check) {
2150     if (StressLoopInvariantCodeMotion &amp;&amp; range_check_info-&gt;deoptimize_on_exception()) {
2151       __ branch(lir_cond_always, new RangeCheckStub(range_check_info, index.result(), array.result()));
2152     } else if (use_length) {
2153       // TODO: use a (modified) version of array_range_check that does not require a
2154       //       constant length to be loaded to a register
2155       __ cmp(lir_cond_belowEqual, length.result(), index.result());
2156       __ branch(lir_cond_belowEqual, new RangeCheckStub(range_check_info, index.result(), array.result()));
2157     } else {
2158       array_range_check(array.result(), index.result(), null_check_info, range_check_info);
2159       // The range check performs the null check, so clear it out for the load
2160       null_check_info = NULL;
2161     }
2162   }
2163 
2164   ciMethodData* md = NULL;
2165   ciArrayLoadStoreData* load_store = NULL;
2166   if (x-&gt;should_profile()) {
2167     profile_array_type(x, md, load_store);
2168   }
2169 
2170   Value element;
2171   if (x-&gt;vt() != NULL) {
2172     assert(x-&gt;array()-&gt;is_loaded_flattened_array(), &quot;must be&quot;);
<a name="11" id="anc11"></a><span class="line-modified">2173     // Find the destination address (of the NewInlineTypeInstance).</span>
2174     LIR_Opr obj = x-&gt;vt()-&gt;operand();
2175     LIRItem obj_item(x-&gt;vt(), this);
2176 
2177     access_flattened_array(true, array, index, obj_item);
2178     set_no_result(x);
2179     element = x-&gt;vt();
2180     if (x-&gt;should_profile()) {
2181       int flag = ArrayLoadStoreData::flat_array_byte_constant() | ArrayLoadStoreData::null_free_array_byte_constant();
2182       profile_array_load_store_flags(md, load_store, flag);
2183     }
2184   } else {
2185     LIR_Opr result = rlock_result(x, x-&gt;elt_type());
2186     LoadFlattenedArrayStub* slow_path = NULL;
2187 
2188     if (x-&gt;should_profile() &amp;&amp; x-&gt;array()-&gt;maybe_null_free_array()) {
2189       profile_null_free_array(array, md, load_store);
2190     }
2191 
2192     if (x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_flattened_array()) {
2193       index.load_item();
2194       // if we are loading from flattened array, load it using a runtime call
2195       slow_path = new LoadFlattenedArrayStub(array.result(), index.result(), result, state_for(x, x-&gt;state_before()));
2196       check_flattened_array(array.result(), LIR_OprFact::illegalOpr, slow_path);
2197       set_in_conditional_code(true);
2198     }
2199 
2200     DecoratorSet decorators = IN_HEAP | IS_ARRAY;
2201     access_load_at(decorators, x-&gt;elt_type(),
2202                    array, index.result(), result,
2203                    NULL, null_check_info);
2204 
2205     if (slow_path != NULL) {
2206       __ branch_destination(slow_path-&gt;continuation());
2207       set_in_conditional_code(false);
2208     }
2209 
2210     element = x;
2211   }
2212 
2213   if (x-&gt;should_profile()) {
2214     profile_element_type(element, md, load_store);
2215   }
2216 }
2217 
2218 void LIRGenerator::do_WithField(WithField* x) {
2219   // This happens only when a class X uses the withfield bytecode to refer to
2220   // an inline class V, where V has not yet been loaded. This is not a common
2221   // case. Let&#39;s just deoptimize.
2222   CodeEmitInfo* info = state_for(x, x-&gt;state_before());
2223   CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
2224                                       Deoptimization::Reason_unloaded,
2225                                       Deoptimization::Action_make_not_entrant);
2226   __ branch(lir_cond_always, stub);
2227   LIR_Opr reg = rlock_result(x, T_OBJECT);
2228   __ move(LIR_OprFact::oopConst(NULL), reg);
2229 }
2230 
2231 void LIRGenerator::do_DefaultValue(DefaultValue* x) {
2232   // Same as withfield above. Let&#39;s deoptimize.
2233   CodeEmitInfo* info = state_for(x, x-&gt;state_before());
2234   CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
2235                                       Deoptimization::Reason_unloaded,
2236                                       Deoptimization::Action_make_not_entrant);
2237   __ branch(lir_cond_always, stub);
2238   LIR_Opr reg = rlock_result(x, T_OBJECT);
2239   __ move(LIR_OprFact::oopConst(NULL), reg);
2240 }
2241 
2242 void LIRGenerator::do_NullCheck(NullCheck* x) {
2243   if (x-&gt;can_trap()) {
2244     LIRItem value(x-&gt;obj(), this);
2245     value.load_item();
2246     CodeEmitInfo* info = state_for(x);
2247     __ null_check(value.result(), info);
2248   }
2249 }
2250 
2251 
2252 void LIRGenerator::do_TypeCast(TypeCast* x) {
2253   LIRItem value(x-&gt;obj(), this);
2254   value.load_item();
2255   // the result is the same as from the node we are casting
2256   set_result(x, value.result());
2257 }
2258 
2259 
2260 void LIRGenerator::do_Throw(Throw* x) {
2261   LIRItem exception(x-&gt;exception(), this);
2262   exception.load_item();
2263   set_no_result(x);
2264   LIR_Opr exception_opr = exception.result();
2265   CodeEmitInfo* info = state_for(x, x-&gt;state());
2266 
2267 #ifndef PRODUCT
2268   if (PrintC1Statistics) {
2269     increment_counter(Runtime1::throw_count_address(), T_INT);
2270   }
2271 #endif
2272 
2273   // check if the instruction has an xhandler in any of the nested scopes
2274   bool unwind = false;
2275   if (info-&gt;exception_handlers()-&gt;length() == 0) {
2276     // this throw is not inside an xhandler
2277     unwind = true;
2278   } else {
2279     // get some idea of the throw type
2280     bool type_is_exact = true;
2281     ciType* throw_type = x-&gt;exception()-&gt;exact_type();
2282     if (throw_type == NULL) {
2283       type_is_exact = false;
2284       throw_type = x-&gt;exception()-&gt;declared_type();
2285     }
2286     if (throw_type != NULL &amp;&amp; throw_type-&gt;is_instance_klass()) {
2287       ciInstanceKlass* throw_klass = (ciInstanceKlass*)throw_type;
2288       unwind = !x-&gt;exception_handlers()-&gt;could_catch(throw_klass, type_is_exact);
2289     }
2290   }
2291 
2292   // do null check before moving exception oop into fixed register
2293   // to avoid a fixed interval with an oop during the null check.
2294   // Use a copy of the CodeEmitInfo because debug information is
2295   // different for null_check and throw.
2296   if (x-&gt;exception()-&gt;as_NewInstance() == NULL &amp;&amp; x-&gt;exception()-&gt;as_ExceptionObject() == NULL) {
2297     // if the exception object wasn&#39;t created using new then it might be null.
2298     __ null_check(exception_opr, new CodeEmitInfo(info, x-&gt;state()-&gt;copy(ValueStack::ExceptionState, x-&gt;state()-&gt;bci())));
2299   }
2300 
2301   if (compilation()-&gt;env()-&gt;jvmti_can_post_on_exceptions()) {
2302     // we need to go through the exception lookup path to get JVMTI
2303     // notification done
2304     unwind = false;
2305   }
2306 
2307   // move exception oop into fixed register
2308   __ move(exception_opr, exceptionOopOpr());
2309 
2310   if (unwind) {
2311     __ unwind_exception(exceptionOopOpr());
2312   } else {
2313     __ throw_exception(exceptionPcOpr(), exceptionOopOpr(), info);
2314   }
2315 }
2316 
2317 
2318 void LIRGenerator::do_RoundFP(RoundFP* x) {
2319   assert(strict_fp_requires_explicit_rounding, &quot;not required&quot;);
2320 
2321   LIRItem input(x-&gt;input(), this);
2322   input.load_item();
2323   LIR_Opr input_opr = input.result();
2324   assert(input_opr-&gt;is_register(), &quot;why round if value is not in a register?&quot;);
2325   assert(input_opr-&gt;is_single_fpu() || input_opr-&gt;is_double_fpu(), &quot;input should be floating-point value&quot;);
2326   if (input_opr-&gt;is_single_fpu()) {
2327     set_result(x, round_item(input_opr)); // This code path not currently taken
2328   } else {
2329     LIR_Opr result = new_register(T_DOUBLE);
2330     set_vreg_flag(result, must_start_in_memory);
2331     __ roundfp(input_opr, LIR_OprFact::illegalOpr, result);
2332     set_result(x, result);
2333   }
2334 }
2335 
2336 // Here UnsafeGetRaw may have x-&gt;base() and x-&gt;index() be int or long
2337 // on both 64 and 32 bits. Expecting x-&gt;base() to be always long on 64bit.
2338 void LIRGenerator::do_UnsafeGetRaw(UnsafeGetRaw* x) {
2339   LIRItem base(x-&gt;base(), this);
2340   LIRItem idx(this);
2341 
2342   base.load_item();
2343   if (x-&gt;has_index()) {
2344     idx.set_instruction(x-&gt;index());
2345     idx.load_nonconstant();
2346   }
2347 
2348   LIR_Opr reg = rlock_result(x, x-&gt;basic_type());
2349 
2350   int   log2_scale = 0;
2351   if (x-&gt;has_index()) {
2352     log2_scale = x-&gt;log2_scale();
2353   }
2354 
2355   assert(!x-&gt;has_index() || idx.value() == x-&gt;index(), &quot;should match&quot;);
2356 
2357   LIR_Opr base_op = base.result();
2358   LIR_Opr index_op = idx.result();
2359 #ifndef _LP64
2360   if (base_op-&gt;type() == T_LONG) {
2361     base_op = new_register(T_INT);
2362     __ convert(Bytecodes::_l2i, base.result(), base_op);
2363   }
2364   if (x-&gt;has_index()) {
2365     if (index_op-&gt;type() == T_LONG) {
2366       LIR_Opr long_index_op = index_op;
2367       if (index_op-&gt;is_constant()) {
2368         long_index_op = new_register(T_LONG);
2369         __ move(index_op, long_index_op);
2370       }
2371       index_op = new_register(T_INT);
2372       __ convert(Bytecodes::_l2i, long_index_op, index_op);
2373     } else {
2374       assert(x-&gt;index()-&gt;type()-&gt;tag() == intTag, &quot;must be&quot;);
2375     }
2376   }
2377   // At this point base and index should be all ints.
2378   assert(base_op-&gt;type() == T_INT &amp;&amp; !base_op-&gt;is_constant(), &quot;base should be an non-constant int&quot;);
2379   assert(!x-&gt;has_index() || index_op-&gt;type() == T_INT, &quot;index should be an int&quot;);
2380 #else
2381   if (x-&gt;has_index()) {
2382     if (index_op-&gt;type() == T_INT) {
2383       if (!index_op-&gt;is_constant()) {
2384         index_op = new_register(T_LONG);
2385         __ convert(Bytecodes::_i2l, idx.result(), index_op);
2386       }
2387     } else {
2388       assert(index_op-&gt;type() == T_LONG, &quot;must be&quot;);
2389       if (index_op-&gt;is_constant()) {
2390         index_op = new_register(T_LONG);
2391         __ move(idx.result(), index_op);
2392       }
2393     }
2394   }
2395   // At this point base is a long non-constant
2396   // Index is a long register or a int constant.
2397   // We allow the constant to stay an int because that would allow us a more compact encoding by
2398   // embedding an immediate offset in the address expression. If we have a long constant, we have to
2399   // move it into a register first.
2400   assert(base_op-&gt;type() == T_LONG &amp;&amp; !base_op-&gt;is_constant(), &quot;base must be a long non-constant&quot;);
2401   assert(!x-&gt;has_index() || (index_op-&gt;type() == T_INT &amp;&amp; index_op-&gt;is_constant()) ||
2402                             (index_op-&gt;type() == T_LONG &amp;&amp; !index_op-&gt;is_constant()), &quot;unexpected index type&quot;);
2403 #endif
2404 
2405   BasicType dst_type = x-&gt;basic_type();
2406 
2407   LIR_Address* addr;
2408   if (index_op-&gt;is_constant()) {
2409     assert(log2_scale == 0, &quot;must not have a scale&quot;);
2410     assert(index_op-&gt;type() == T_INT, &quot;only int constants supported&quot;);
2411     addr = new LIR_Address(base_op, index_op-&gt;as_jint(), dst_type);
2412   } else {
2413 #ifdef X86
2414     addr = new LIR_Address(base_op, index_op, LIR_Address::Scale(log2_scale), 0, dst_type);
2415 #elif defined(GENERATE_ADDRESS_IS_PREFERRED)
2416     addr = generate_address(base_op, index_op, log2_scale, 0, dst_type);
2417 #else
2418     if (index_op-&gt;is_illegal() || log2_scale == 0) {
2419       addr = new LIR_Address(base_op, index_op, dst_type);
2420     } else {
2421       LIR_Opr tmp = new_pointer_register();
2422       __ shift_left(index_op, log2_scale, tmp);
2423       addr = new LIR_Address(base_op, tmp, dst_type);
2424     }
2425 #endif
2426   }
2427 
2428   if (x-&gt;may_be_unaligned() &amp;&amp; (dst_type == T_LONG || dst_type == T_DOUBLE)) {
2429     __ unaligned_move(addr, reg);
2430   } else {
2431     if (dst_type == T_OBJECT &amp;&amp; x-&gt;is_wide()) {
2432       __ move_wide(addr, reg);
2433     } else {
2434       __ move(addr, reg);
2435     }
2436   }
2437 }
2438 
2439 
2440 void LIRGenerator::do_UnsafePutRaw(UnsafePutRaw* x) {
2441   int  log2_scale = 0;
2442   BasicType type = x-&gt;basic_type();
2443 
2444   if (x-&gt;has_index()) {
2445     log2_scale = x-&gt;log2_scale();
2446   }
2447 
2448   LIRItem base(x-&gt;base(), this);
2449   LIRItem value(x-&gt;value(), this);
2450   LIRItem idx(this);
2451 
2452   base.load_item();
2453   if (x-&gt;has_index()) {
2454     idx.set_instruction(x-&gt;index());
2455     idx.load_item();
2456   }
2457 
2458   if (type == T_BYTE || type == T_BOOLEAN) {
2459     value.load_byte_item();
2460   } else {
2461     value.load_item();
2462   }
2463 
2464   set_no_result(x);
2465 
2466   LIR_Opr base_op = base.result();
2467   LIR_Opr index_op = idx.result();
2468 
2469 #ifdef GENERATE_ADDRESS_IS_PREFERRED
2470   LIR_Address* addr = generate_address(base_op, index_op, log2_scale, 0, x-&gt;basic_type());
2471 #else
2472 #ifndef _LP64
2473   if (base_op-&gt;type() == T_LONG) {
2474     base_op = new_register(T_INT);
2475     __ convert(Bytecodes::_l2i, base.result(), base_op);
2476   }
2477   if (x-&gt;has_index()) {
2478     if (index_op-&gt;type() == T_LONG) {
2479       index_op = new_register(T_INT);
2480       __ convert(Bytecodes::_l2i, idx.result(), index_op);
2481     }
2482   }
2483   // At this point base and index should be all ints and not constants
2484   assert(base_op-&gt;type() == T_INT &amp;&amp; !base_op-&gt;is_constant(), &quot;base should be an non-constant int&quot;);
2485   assert(!x-&gt;has_index() || (index_op-&gt;type() == T_INT &amp;&amp; !index_op-&gt;is_constant()), &quot;index should be an non-constant int&quot;);
2486 #else
2487   if (x-&gt;has_index()) {
2488     if (index_op-&gt;type() == T_INT) {
2489       index_op = new_register(T_LONG);
2490       __ convert(Bytecodes::_i2l, idx.result(), index_op);
2491     }
2492   }
2493   // At this point base and index are long and non-constant
2494   assert(base_op-&gt;type() == T_LONG &amp;&amp; !base_op-&gt;is_constant(), &quot;base must be a non-constant long&quot;);
2495   assert(!x-&gt;has_index() || (index_op-&gt;type() == T_LONG &amp;&amp; !index_op-&gt;is_constant()), &quot;index must be a non-constant long&quot;);
2496 #endif
2497 
2498   if (log2_scale != 0) {
2499     // temporary fix (platform dependent code without shift on Intel would be better)
2500     // TODO: ARM also allows embedded shift in the address
2501     LIR_Opr tmp = new_pointer_register();
2502     if (TwoOperandLIRForm) {
2503       __ move(index_op, tmp);
2504       index_op = tmp;
2505     }
2506     __ shift_left(index_op, log2_scale, tmp);
2507     if (!TwoOperandLIRForm) {
2508       index_op = tmp;
2509     }
2510   }
2511 
2512   LIR_Address* addr = new LIR_Address(base_op, index_op, x-&gt;basic_type());
2513 #endif // !GENERATE_ADDRESS_IS_PREFERRED
2514   __ move(value.result(), addr);
2515 }
2516 
2517 
2518 void LIRGenerator::do_UnsafeGetObject(UnsafeGetObject* x) {
2519   BasicType type = x-&gt;basic_type();
2520   LIRItem src(x-&gt;object(), this);
2521   LIRItem off(x-&gt;offset(), this);
2522 
2523   off.load_item();
2524   src.load_item();
2525 
2526   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
2527 
2528   if (x-&gt;is_volatile()) {
2529     decorators |= MO_SEQ_CST;
2530   }
2531   if (type == T_BOOLEAN) {
2532     decorators |= C1_MASK_BOOLEAN;
2533   }
2534   if (is_reference_type(type)) {
2535     decorators |= ON_UNKNOWN_OOP_REF;
2536   }
2537 
2538   LIR_Opr result = rlock_result(x, type);
2539   access_load_at(decorators, type,
2540                  src, off.result(), result);
2541 }
2542 
2543 
2544 void LIRGenerator::do_UnsafePutObject(UnsafePutObject* x) {
2545   BasicType type = x-&gt;basic_type();
2546   LIRItem src(x-&gt;object(), this);
2547   LIRItem off(x-&gt;offset(), this);
2548   LIRItem data(x-&gt;value(), this);
2549 
2550   src.load_item();
2551   if (type == T_BOOLEAN || type == T_BYTE) {
2552     data.load_byte_item();
2553   } else {
2554     data.load_item();
2555   }
2556   off.load_item();
2557 
2558   set_no_result(x);
2559 
2560   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS;
2561   if (is_reference_type(type)) {
2562     decorators |= ON_UNKNOWN_OOP_REF;
2563   }
2564   if (x-&gt;is_volatile()) {
2565     decorators |= MO_SEQ_CST;
2566   }
2567   access_store_at(decorators, type, src, off.result(), data.result());
2568 }
2569 
2570 void LIRGenerator::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {
2571   BasicType type = x-&gt;basic_type();
2572   LIRItem src(x-&gt;object(), this);
2573   LIRItem off(x-&gt;offset(), this);
2574   LIRItem value(x-&gt;value(), this);
2575 
2576   DecoratorSet decorators = IN_HEAP | C1_UNSAFE_ACCESS | MO_SEQ_CST;
2577 
2578   if (is_reference_type(type)) {
2579     decorators |= ON_UNKNOWN_OOP_REF;
2580   }
2581 
2582   LIR_Opr result;
2583   if (x-&gt;is_add()) {
2584     result = access_atomic_add_at(decorators, type, src, off, value);
2585   } else {
2586     result = access_atomic_xchg_at(decorators, type, src, off, value);
2587   }
2588   set_result(x, result);
2589 }
2590 
2591 void LIRGenerator::do_SwitchRanges(SwitchRangeArray* x, LIR_Opr value, BlockBegin* default_sux) {
2592   int lng = x-&gt;length();
2593 
2594   for (int i = 0; i &lt; lng; i++) {
2595     C1SwitchRange* one_range = x-&gt;at(i);
2596     int low_key = one_range-&gt;low_key();
2597     int high_key = one_range-&gt;high_key();
2598     BlockBegin* dest = one_range-&gt;sux();
2599     if (low_key == high_key) {
2600       __ cmp(lir_cond_equal, value, low_key);
2601       __ branch(lir_cond_equal, dest);
2602     } else if (high_key - low_key == 1) {
2603       __ cmp(lir_cond_equal, value, low_key);
2604       __ branch(lir_cond_equal, dest);
2605       __ cmp(lir_cond_equal, value, high_key);
2606       __ branch(lir_cond_equal, dest);
2607     } else {
2608       LabelObj* L = new LabelObj();
2609       __ cmp(lir_cond_less, value, low_key);
2610       __ branch(lir_cond_less, L-&gt;label());
2611       __ cmp(lir_cond_lessEqual, value, high_key);
2612       __ branch(lir_cond_lessEqual, dest);
2613       __ branch_destination(L-&gt;label());
2614     }
2615   }
2616   __ jump(default_sux);
2617 }
2618 
2619 
2620 SwitchRangeArray* LIRGenerator::create_lookup_ranges(TableSwitch* x) {
2621   SwitchRangeList* res = new SwitchRangeList();
2622   int len = x-&gt;length();
2623   if (len &gt; 0) {
2624     BlockBegin* sux = x-&gt;sux_at(0);
2625     int key = x-&gt;lo_key();
2626     BlockBegin* default_sux = x-&gt;default_sux();
2627     C1SwitchRange* range = new C1SwitchRange(key, sux);
2628     for (int i = 0; i &lt; len; i++, key++) {
2629       BlockBegin* new_sux = x-&gt;sux_at(i);
2630       if (sux == new_sux) {
2631         // still in same range
2632         range-&gt;set_high_key(key);
2633       } else {
2634         // skip tests which explicitly dispatch to the default
2635         if (sux != default_sux) {
2636           res-&gt;append(range);
2637         }
2638         range = new C1SwitchRange(key, new_sux);
2639       }
2640       sux = new_sux;
2641     }
2642     if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
2643   }
2644   return res;
2645 }
2646 
2647 
2648 // we expect the keys to be sorted by increasing value
2649 SwitchRangeArray* LIRGenerator::create_lookup_ranges(LookupSwitch* x) {
2650   SwitchRangeList* res = new SwitchRangeList();
2651   int len = x-&gt;length();
2652   if (len &gt; 0) {
2653     BlockBegin* default_sux = x-&gt;default_sux();
2654     int key = x-&gt;key_at(0);
2655     BlockBegin* sux = x-&gt;sux_at(0);
2656     C1SwitchRange* range = new C1SwitchRange(key, sux);
2657     for (int i = 1; i &lt; len; i++) {
2658       int new_key = x-&gt;key_at(i);
2659       BlockBegin* new_sux = x-&gt;sux_at(i);
2660       if (key+1 == new_key &amp;&amp; sux == new_sux) {
2661         // still in same range
2662         range-&gt;set_high_key(new_key);
2663       } else {
2664         // skip tests which explicitly dispatch to the default
2665         if (range-&gt;sux() != default_sux) {
2666           res-&gt;append(range);
2667         }
2668         range = new C1SwitchRange(new_key, new_sux);
2669       }
2670       key = new_key;
2671       sux = new_sux;
2672     }
2673     if (res-&gt;length() == 0 || res-&gt;last() != range)  res-&gt;append(range);
2674   }
2675   return res;
2676 }
2677 
2678 
2679 void LIRGenerator::do_TableSwitch(TableSwitch* x) {
2680   LIRItem tag(x-&gt;tag(), this);
2681   tag.load_item();
2682   set_no_result(x);
2683 
2684   if (x-&gt;is_safepoint()) {
2685     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
2686   }
2687 
2688   // move values into phi locations
2689   move_to_phi(x-&gt;state());
2690 
2691   int lo_key = x-&gt;lo_key();
2692   int len = x-&gt;length();
2693   assert(lo_key &lt;= (lo_key + (len - 1)), &quot;integer overflow&quot;);
2694   LIR_Opr value = tag.result();
2695 
2696   if (compilation()-&gt;env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp; UseSwitchProfiling) {
2697     ciMethod* method = x-&gt;state()-&gt;scope()-&gt;method();
2698     ciMethodData* md = method-&gt;method_data_or_null();
2699     assert(md != NULL, &quot;Sanity&quot;);
2700     ciProfileData* data = md-&gt;bci_to_data(x-&gt;state()-&gt;bci());
2701     assert(data != NULL, &quot;must have profiling data&quot;);
2702     assert(data-&gt;is_MultiBranchData(), &quot;bad profile data?&quot;);
2703     int default_count_offset = md-&gt;byte_offset_of_slot(data, MultiBranchData::default_count_offset());
2704     LIR_Opr md_reg = new_register(T_METADATA);
2705     __ metadata2reg(md-&gt;constant_encoding(), md_reg);
2706     LIR_Opr data_offset_reg = new_pointer_register();
2707     LIR_Opr tmp_reg = new_pointer_register();
2708 
2709     __ move(LIR_OprFact::intptrConst(default_count_offset), data_offset_reg);
2710     for (int i = 0; i &lt; len; i++) {
2711       int count_offset = md-&gt;byte_offset_of_slot(data, MultiBranchData::case_count_offset(i));
2712       __ cmp(lir_cond_equal, value, i + lo_key);
2713       __ move(data_offset_reg, tmp_reg);
2714       __ cmove(lir_cond_equal,
2715                LIR_OprFact::intptrConst(count_offset),
2716                tmp_reg,
2717                data_offset_reg, T_INT);
2718     }
2719 
2720     LIR_Opr data_reg = new_pointer_register();
2721     LIR_Address* data_addr = new LIR_Address(md_reg, data_offset_reg, data_reg-&gt;type());
2722     __ move(data_addr, data_reg);
2723     __ add(data_reg, LIR_OprFact::intptrConst(1), data_reg);
2724     __ move(data_reg, data_addr);
2725   }
2726 
2727   if (UseTableRanges) {
2728     do_SwitchRanges(create_lookup_ranges(x), value, x-&gt;default_sux());
2729   } else {
2730     for (int i = 0; i &lt; len; i++) {
2731       __ cmp(lir_cond_equal, value, i + lo_key);
2732       __ branch(lir_cond_equal, x-&gt;sux_at(i));
2733     }
2734     __ jump(x-&gt;default_sux());
2735   }
2736 }
2737 
2738 
2739 void LIRGenerator::do_LookupSwitch(LookupSwitch* x) {
2740   LIRItem tag(x-&gt;tag(), this);
2741   tag.load_item();
2742   set_no_result(x);
2743 
2744   if (x-&gt;is_safepoint()) {
2745     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
2746   }
2747 
2748   // move values into phi locations
2749   move_to_phi(x-&gt;state());
2750 
2751   LIR_Opr value = tag.result();
2752   int len = x-&gt;length();
2753 
2754   if (compilation()-&gt;env()-&gt;comp_level() == CompLevel_full_profile &amp;&amp; UseSwitchProfiling) {
2755     ciMethod* method = x-&gt;state()-&gt;scope()-&gt;method();
2756     ciMethodData* md = method-&gt;method_data_or_null();
2757     assert(md != NULL, &quot;Sanity&quot;);
2758     ciProfileData* data = md-&gt;bci_to_data(x-&gt;state()-&gt;bci());
2759     assert(data != NULL, &quot;must have profiling data&quot;);
2760     assert(data-&gt;is_MultiBranchData(), &quot;bad profile data?&quot;);
2761     int default_count_offset = md-&gt;byte_offset_of_slot(data, MultiBranchData::default_count_offset());
2762     LIR_Opr md_reg = new_register(T_METADATA);
2763     __ metadata2reg(md-&gt;constant_encoding(), md_reg);
2764     LIR_Opr data_offset_reg = new_pointer_register();
2765     LIR_Opr tmp_reg = new_pointer_register();
2766 
2767     __ move(LIR_OprFact::intptrConst(default_count_offset), data_offset_reg);
2768     for (int i = 0; i &lt; len; i++) {
2769       int count_offset = md-&gt;byte_offset_of_slot(data, MultiBranchData::case_count_offset(i));
2770       __ cmp(lir_cond_equal, value, x-&gt;key_at(i));
2771       __ move(data_offset_reg, tmp_reg);
2772       __ cmove(lir_cond_equal,
2773                LIR_OprFact::intptrConst(count_offset),
2774                tmp_reg,
2775                data_offset_reg, T_INT);
2776     }
2777 
2778     LIR_Opr data_reg = new_pointer_register();
2779     LIR_Address* data_addr = new LIR_Address(md_reg, data_offset_reg, data_reg-&gt;type());
2780     __ move(data_addr, data_reg);
2781     __ add(data_reg, LIR_OprFact::intptrConst(1), data_reg);
2782     __ move(data_reg, data_addr);
2783   }
2784 
2785   if (UseTableRanges) {
2786     do_SwitchRanges(create_lookup_ranges(x), value, x-&gt;default_sux());
2787   } else {
2788     int len = x-&gt;length();
2789     for (int i = 0; i &lt; len; i++) {
2790       __ cmp(lir_cond_equal, value, x-&gt;key_at(i));
2791       __ branch(lir_cond_equal, x-&gt;sux_at(i));
2792     }
2793     __ jump(x-&gt;default_sux());
2794   }
2795 }
2796 
2797 
2798 void LIRGenerator::do_Goto(Goto* x) {
2799   set_no_result(x);
2800 
2801   if (block()-&gt;next()-&gt;as_OsrEntry()) {
2802     // need to free up storage used for OSR entry point
2803     LIR_Opr osrBuffer = block()-&gt;next()-&gt;operand();
2804     BasicTypeList signature;
2805     signature.append(NOT_LP64(T_INT) LP64_ONLY(T_LONG)); // pass a pointer to osrBuffer
2806     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
2807     __ move(osrBuffer, cc-&gt;args()-&gt;at(0));
2808     __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_end),
2809                          getThreadTemp(), LIR_OprFact::illegalOpr, cc-&gt;args());
2810   }
2811 
2812   if (x-&gt;is_safepoint()) {
2813     ValueStack* state = x-&gt;state_before() ? x-&gt;state_before() : x-&gt;state();
2814 
2815     // increment backedge counter if needed
2816     CodeEmitInfo* info = state_for(x, state);
2817     increment_backedge_counter(info, x-&gt;profiled_bci());
2818     CodeEmitInfo* safepoint_info = state_for(x, state);
2819     __ safepoint(safepoint_poll_register(), safepoint_info);
2820   }
2821 
2822   // Gotos can be folded Ifs, handle this case.
2823   if (x-&gt;should_profile()) {
2824     ciMethod* method = x-&gt;profiled_method();
2825     assert(method != NULL, &quot;method should be set if branch is profiled&quot;);
2826     ciMethodData* md = method-&gt;method_data_or_null();
2827     assert(md != NULL, &quot;Sanity&quot;);
2828     ciProfileData* data = md-&gt;bci_to_data(x-&gt;profiled_bci());
2829     assert(data != NULL, &quot;must have profiling data&quot;);
2830     int offset;
2831     if (x-&gt;direction() == Goto::taken) {
2832       assert(data-&gt;is_BranchData(), &quot;need BranchData for two-way branches&quot;);
2833       offset = md-&gt;byte_offset_of_slot(data, BranchData::taken_offset());
2834     } else if (x-&gt;direction() == Goto::not_taken) {
2835       assert(data-&gt;is_BranchData(), &quot;need BranchData for two-way branches&quot;);
2836       offset = md-&gt;byte_offset_of_slot(data, BranchData::not_taken_offset());
2837     } else {
2838       assert(data-&gt;is_JumpData(), &quot;need JumpData for branches&quot;);
2839       offset = md-&gt;byte_offset_of_slot(data, JumpData::taken_offset());
2840     }
2841     LIR_Opr md_reg = new_register(T_METADATA);
2842     __ metadata2reg(md-&gt;constant_encoding(), md_reg);
2843 
2844     increment_counter(new LIR_Address(md_reg, offset,
2845                                       NOT_LP64(T_INT) LP64_ONLY(T_LONG)), DataLayout::counter_increment);
2846   }
2847 
2848   // emit phi-instruction move after safepoint since this simplifies
2849   // describing the state as the safepoint.
2850   move_to_phi(x-&gt;state());
2851 
2852   __ jump(x-&gt;default_sux());
2853 }
2854 
2855 /**
2856  * Emit profiling code if needed for arguments, parameters, return value types
2857  *
2858  * @param md                    MDO the code will update at runtime
2859  * @param md_base_offset        common offset in the MDO for this profile and subsequent ones
2860  * @param md_offset             offset in the MDO (on top of md_base_offset) for this profile
2861  * @param profiled_k            current profile
2862  * @param obj                   IR node for the object to be profiled
2863  * @param mdp                   register to hold the pointer inside the MDO (md + md_base_offset).
2864  *                              Set once we find an update to make and use for next ones.
2865  * @param not_null              true if we know obj cannot be null
2866  * @param signature_at_call_k   signature at call for obj
2867  * @param callee_signature_k    signature of callee for obj
2868  *                              at call and callee signatures differ at method handle call
2869  * @return                      the only klass we know will ever be seen at this profile point
2870  */
2871 ciKlass* LIRGenerator::profile_type(ciMethodData* md, int md_base_offset, int md_offset, intptr_t profiled_k,
2872                                     Value obj, LIR_Opr&amp; mdp, bool not_null, ciKlass* signature_at_call_k,
2873                                     ciKlass* callee_signature_k) {
2874   ciKlass* result = NULL;
2875   bool do_null = !not_null &amp;&amp; !TypeEntries::was_null_seen(profiled_k);
2876   bool do_update = !TypeEntries::is_type_unknown(profiled_k);
2877   // known not to be null or null bit already set and already set to
2878   // unknown: nothing we can do to improve profiling
2879   if (!do_null &amp;&amp; !do_update) {
2880     return result;
2881   }
2882 
2883   ciKlass* exact_klass = NULL;
2884   Compilation* comp = Compilation::current();
2885   if (do_update) {
2886     // try to find exact type, using CHA if possible, so that loading
2887     // the klass from the object can be avoided
2888     ciType* type = obj-&gt;exact_type();
2889     if (type == NULL) {
2890       type = obj-&gt;declared_type();
2891       type = comp-&gt;cha_exact_type(type);
2892     }
2893     assert(type == NULL || type-&gt;is_klass(), &quot;type should be class&quot;);
2894     exact_klass = (type != NULL &amp;&amp; type-&gt;is_loaded()) ? (ciKlass*)type : NULL;
2895 
2896     do_update = exact_klass == NULL || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;
2897   }
2898 
2899   if (!do_null &amp;&amp; !do_update) {
2900     return result;
2901   }
2902 
2903   ciKlass* exact_signature_k = NULL;
2904   if (do_update &amp;&amp; signature_at_call_k != NULL) {
2905     // Is the type from the signature exact (the only one possible)?
2906     exact_signature_k = signature_at_call_k-&gt;exact_klass();
2907     if (exact_signature_k == NULL) {
2908       exact_signature_k = comp-&gt;cha_exact_type(signature_at_call_k);
2909     } else {
2910       result = exact_signature_k;
2911       // Known statically. No need to emit any code: prevent
2912       // LIR_Assembler::emit_profile_type() from emitting useless code
2913       profiled_k = ciTypeEntries::with_status(result, profiled_k);
2914     }
2915     // exact_klass and exact_signature_k can be both non NULL but
2916     // different if exact_klass is loaded after the ciObject for
2917     // exact_signature_k is created.
2918     if (exact_klass == NULL &amp;&amp; exact_signature_k != NULL &amp;&amp; exact_klass != exact_signature_k) {
2919       // sometimes the type of the signature is better than the best type
2920       // the compiler has
2921       exact_klass = exact_signature_k;
2922     }
2923     if (callee_signature_k != NULL &amp;&amp;
2924         callee_signature_k != signature_at_call_k) {
2925       ciKlass* improved_klass = callee_signature_k-&gt;exact_klass();
2926       if (improved_klass == NULL) {
2927         improved_klass = comp-&gt;cha_exact_type(callee_signature_k);
2928       }
2929       if (exact_klass == NULL &amp;&amp; improved_klass != NULL &amp;&amp; exact_klass != improved_klass) {
2930         exact_klass = exact_signature_k;
2931       }
2932     }
2933     do_update = exact_klass == NULL || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;
2934   }
2935 
2936   if (!do_null &amp;&amp; !do_update) {
2937     return result;
2938   }
2939 
2940   if (mdp == LIR_OprFact::illegalOpr) {
2941     mdp = new_register(T_METADATA);
2942     __ metadata2reg(md-&gt;constant_encoding(), mdp);
2943     if (md_base_offset != 0) {
2944       LIR_Address* base_type_address = new LIR_Address(mdp, md_base_offset, T_ADDRESS);
2945       mdp = new_pointer_register();
2946       __ leal(LIR_OprFact::address(base_type_address), mdp);
2947     }
2948   }
2949   LIRItem value(obj, this);
2950   value.load_item();
2951   __ profile_type(new LIR_Address(mdp, md_offset, T_METADATA),
2952                   value.result(), exact_klass, profiled_k, new_pointer_register(), not_null, exact_signature_k != NULL);
2953   return result;
2954 }
2955 
2956 // profile parameters on entry to the root of the compilation
2957 void LIRGenerator::profile_parameters(Base* x) {
2958   if (compilation()-&gt;profile_parameters()) {
2959     CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
2960     ciMethodData* md = scope()-&gt;method()-&gt;method_data_or_null();
2961     assert(md != NULL, &quot;Sanity&quot;);
2962 
2963     if (md-&gt;parameters_type_data() != NULL) {
2964       ciParametersTypeData* parameters_type_data = md-&gt;parameters_type_data();
2965       ciTypeStackSlotEntries* parameters =  parameters_type_data-&gt;parameters();
2966       LIR_Opr mdp = LIR_OprFact::illegalOpr;
2967       for (int java_index = 0, i = 0, j = 0; j &lt; parameters_type_data-&gt;number_of_parameters(); i++) {
2968         LIR_Opr src = args-&gt;at(i);
2969         assert(!src-&gt;is_illegal(), &quot;check&quot;);
2970         BasicType t = src-&gt;type();
2971         if (is_reference_type(t)) {
2972           intptr_t profiled_k = parameters-&gt;type(j);
2973           Local* local = x-&gt;state()-&gt;local_at(java_index)-&gt;as_Local();
2974           ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(parameters_type_data, ParametersTypeData::type_offset(0)),
2975                                         in_bytes(ParametersTypeData::type_offset(j)) - in_bytes(ParametersTypeData::type_offset(0)),
2976                                         profiled_k, local, mdp, false, local-&gt;declared_type()-&gt;as_klass(), NULL);
2977           // If the profile is known statically set it once for all and do not emit any code
2978           if (exact != NULL) {
2979             md-&gt;set_parameter_type(j, exact);
2980           }
2981           j++;
2982         }
2983         java_index += type2size[t];
2984       }
2985     }
2986   }
2987 }
2988 
2989 void LIRGenerator::profile_array_load_store_flags(ciMethodData* md, ciArrayLoadStoreData* load_store, int flag, LIR_Opr mdp) {
2990   assert(md != NULL &amp;&amp; load_store != NULL, &quot;should have been initialized&quot;);
2991   if (mdp == NULL) {
2992     mdp = new_register(T_METADATA);
2993     __ metadata2reg(md-&gt;constant_encoding(), mdp);
2994   }
2995   LIR_Address* addr = new LIR_Address(mdp, md-&gt;byte_offset_of_slot(load_store, DataLayout::flags_offset()), T_BYTE);
2996   LIR_Opr id = new_register(T_INT);
2997   __ move(addr, id);
2998   __ logical_or(id, LIR_OprFact::intConst(flag), id);
2999   __ store(id, addr);
3000 }
3001 
3002 void LIRGenerator::profile_null_free_array(LIRItem array, ciMethodData* md, ciArrayLoadStoreData* load_store) {
3003   LabelObj* L_end = new LabelObj();
3004   LIR_Opr tmp = new_register(T_METADATA);
3005   LIR_Opr mdp = new_register(T_METADATA);
3006   assert(md != NULL, &quot;should have been initialized&quot;);
3007   __ metadata2reg(md-&gt;constant_encoding(), mdp);
3008   __ check_null_free_array(array.result(), tmp);
3009   __ branch(lir_cond_equal, L_end-&gt;label());
3010 
3011   profile_array_load_store_flags(md, load_store, ArrayLoadStoreData::null_free_array_byte_constant(), mdp);
3012 
3013   __ branch_destination(L_end-&gt;label());
3014 }
3015 
3016 void LIRGenerator::profile_array_type(AccessIndexed* x, ciMethodData*&amp; md, ciArrayLoadStoreData*&amp; load_store) {
3017   int bci = x-&gt;profiled_bci();
3018   md = x-&gt;profiled_method()-&gt;method_data();
3019   assert(md != NULL, &quot;Sanity&quot;);
3020   ciProfileData* data = md-&gt;bci_to_data(bci);
3021   assert(data != NULL &amp;&amp; data-&gt;is_ArrayLoadStoreData(), &quot;incorrect profiling entry&quot;);
3022   load_store = (ciArrayLoadStoreData*)data;
3023   LIR_Opr mdp = LIR_OprFact::illegalOpr;
3024   profile_type(md, md-&gt;byte_offset_of_slot(load_store, ArrayLoadStoreData::array_offset()), 0,
3025                load_store-&gt;array()-&gt;type(), x-&gt;array(), mdp, true, NULL, NULL);
3026 }
3027 
3028 void LIRGenerator::profile_element_type(Value element, ciMethodData* md, ciArrayLoadStoreData* load_store) {
3029   assert(md != NULL &amp;&amp; load_store != NULL, &quot;should have been initialized&quot;);
3030   LIR_Opr mdp = LIR_OprFact::illegalOpr;
3031   profile_type(md, md-&gt;byte_offset_of_slot(load_store, ArrayLoadStoreData::element_offset()), 0,
3032                load_store-&gt;element()-&gt;type(), element, mdp, false, NULL, NULL);
3033 }
3034 
3035 
3036 void LIRGenerator::do_Base(Base* x) {
3037   __ std_entry(LIR_OprFact::illegalOpr);
3038   // Emit moves from physical registers / stack slots to virtual registers
3039   CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
3040   IRScope* irScope = compilation()-&gt;hir()-&gt;top_scope();
3041   int java_index = 0;
3042   for (int i = 0; i &lt; args-&gt;length(); i++) {
3043     LIR_Opr src = args-&gt;at(i);
3044     assert(!src-&gt;is_illegal(), &quot;check&quot;);
3045     BasicType t = src-&gt;type();
3046 
3047     // Types which are smaller than int are passed as int, so
3048     // correct the type which passed.
3049     switch (t) {
3050     case T_BYTE:
3051     case T_BOOLEAN:
3052     case T_SHORT:
3053     case T_CHAR:
3054       t = T_INT;
3055       break;
3056     default:
3057       break;
3058     }
3059 
3060     LIR_Opr dest = new_register(t);
3061     __ move(src, dest);
3062 
3063     // Assign new location to Local instruction for this local
3064     Local* local = x-&gt;state()-&gt;local_at(java_index)-&gt;as_Local();
3065     assert(local != NULL, &quot;Locals for incoming arguments must have been created&quot;);
3066 #ifndef __SOFTFP__
3067     // The java calling convention passes double as long and float as int.
3068     assert(as_ValueType(t)-&gt;tag() == local-&gt;type()-&gt;tag(), &quot;check&quot;);
3069 #endif // __SOFTFP__
3070     local-&gt;set_operand(dest);
3071     _instruction_for_operand.at_put_grow(dest-&gt;vreg_number(), local, NULL);
3072     java_index += type2size[t];
3073   }
3074 
3075   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
3076     BasicTypeList signature;
3077     signature.append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    // thread
3078     signature.append(T_METADATA); // Method*
3079     LIR_OprList* args = new LIR_OprList();
3080     args-&gt;append(getThreadPointer());
3081     LIR_Opr meth = new_register(T_METADATA);
3082     __ metadata2reg(method()-&gt;constant_encoding(), meth);
3083     args-&gt;append(meth);
3084     call_runtime(&amp;signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), voidType, NULL);
3085   }
3086 
3087   if (method()-&gt;is_synchronized()) {
3088     LIR_Opr obj;
3089     if (method()-&gt;is_static()) {
3090       obj = new_register(T_OBJECT);
3091       __ oop2reg(method()-&gt;holder()-&gt;java_mirror()-&gt;constant_encoding(), obj);
3092     } else {
3093       Local* receiver = x-&gt;state()-&gt;local_at(0)-&gt;as_Local();
3094       assert(receiver != NULL, &quot;must already exist&quot;);
3095       obj = receiver-&gt;operand();
3096     }
3097     assert(obj-&gt;is_valid(), &quot;must be valid&quot;);
3098 
3099     if (method()-&gt;is_synchronized() &amp;&amp; GenerateSynchronizationCode) {
3100       LIR_Opr lock = syncLockOpr();
3101       __ load_stack_address_monitor(0, lock);
3102 
3103       CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, x-&gt;check_flag(Instruction::DeoptimizeOnException));
3104       CodeStub* slow_path = new MonitorEnterStub(obj, lock, info);
3105 
3106       // receiver is guaranteed non-NULL so don&#39;t need CodeEmitInfo
3107       __ lock_object(syncTempOpr(), obj, lock, new_register(T_OBJECT), slow_path, NULL);
3108     }
3109   }
3110   if (compilation()-&gt;age_code()) {
3111     CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, 0), NULL, false);
3112     decrement_age(info);
3113   }
3114   // increment invocation counters if needed
3115   if (!method()-&gt;is_accessor()) { // Accessors do not have MDOs, so no counting.
3116     profile_parameters(x);
3117     CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, false);
3118     increment_invocation_counter(info);
3119   }
3120   if (method()-&gt;has_scalarized_args()) {
<a name="12" id="anc12"></a><span class="line-modified">3121     // Check if deoptimization was triggered (i.e. orig_pc was set) while buffering scalarized inline type arguments</span>
3122     // in the entry point (see comments in frame::deoptimize). If so, deoptimize only now that we have the right state.
3123     CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, 0), NULL, false);
3124     CodeStub* deopt_stub = new DeoptimizeStub(info, Deoptimization::Reason_none, Deoptimization::Action_none);
3125     __ append(new LIR_Op0(lir_check_orig_pc));
3126     __ branch(lir_cond_notEqual, deopt_stub);
3127   }
3128 
3129   // all blocks with a successor must end with an unconditional jump
3130   // to the successor even if they are consecutive
3131   __ jump(x-&gt;default_sux());
3132 }
3133 
3134 
3135 void LIRGenerator::do_OsrEntry(OsrEntry* x) {
3136   // construct our frame and model the production of incoming pointer
3137   // to the OSR buffer.
3138   __ osr_entry(LIR_Assembler::osrBufferPointer());
3139   LIR_Opr result = rlock_result(x);
3140   __ move(LIR_Assembler::osrBufferPointer(), result);
3141 }
3142 
3143 void LIRGenerator::invoke_load_one_argument(LIRItem* param, LIR_Opr loc) {
3144   if (loc-&gt;is_register()) {
3145     param-&gt;load_item_force(loc);
3146   } else {
3147     LIR_Address* addr = loc-&gt;as_address_ptr();
3148     param-&gt;load_for_store(addr-&gt;type());
3149     assert(addr-&gt;type() != T_INLINE_TYPE, &quot;not supported yet&quot;);
3150     if (addr-&gt;type() == T_OBJECT) {
3151       __ move_wide(param-&gt;result(), addr);
3152     } else {
3153       if (addr-&gt;type() == T_LONG || addr-&gt;type() == T_DOUBLE) {
3154         __ unaligned_move(param-&gt;result(), addr);
3155       } else {
3156         __ move(param-&gt;result(), addr);
3157       }
3158     }
3159   }
3160 }
3161 
3162 void LIRGenerator::invoke_load_arguments(Invoke* x, LIRItemList* args, const LIR_OprList* arg_list) {
3163   assert(args-&gt;length() == arg_list-&gt;length(),
3164          &quot;args=%d, arg_list=%d&quot;, args-&gt;length(), arg_list-&gt;length());
3165   for (int i = x-&gt;has_receiver() ? 1 : 0; i &lt; args-&gt;length(); i++) {
3166     LIRItem* param = args-&gt;at(i);
3167     LIR_Opr loc = arg_list-&gt;at(i);
3168     invoke_load_one_argument(param, loc);
3169   }
3170 
3171   if (x-&gt;has_receiver()) {
3172     LIRItem* receiver = args-&gt;at(0);
3173     LIR_Opr loc = arg_list-&gt;at(0);
3174     if (loc-&gt;is_register()) {
3175       receiver-&gt;load_item_force(loc);
3176     } else {
3177       assert(loc-&gt;is_address(), &quot;just checking&quot;);
3178       receiver-&gt;load_for_store(T_OBJECT);
3179       __ move_wide(receiver-&gt;result(), loc-&gt;as_address_ptr());
3180     }
3181   }
3182 }
3183 
3184 
3185 // Visits all arguments, returns appropriate items without loading them
3186 LIRItemList* LIRGenerator::invoke_visit_arguments(Invoke* x) {
3187   LIRItemList* argument_items = new LIRItemList();
3188   if (x-&gt;has_receiver()) {
3189     LIRItem* receiver = new LIRItem(x-&gt;receiver(), this);
3190     argument_items-&gt;append(receiver);
3191   }
3192   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
3193     LIRItem* param = new LIRItem(x-&gt;argument_at(i), this);
3194     argument_items-&gt;append(param);
3195   }
3196   return argument_items;
3197 }
3198 
3199 
3200 // The invoke with receiver has following phases:
3201 //   a) traverse and load/lock receiver;
3202 //   b) traverse all arguments -&gt; item-array (invoke_visit_argument)
3203 //   c) push receiver on stack
3204 //   d) load each of the items and push on stack
3205 //   e) unlock receiver
3206 //   f) move receiver into receiver-register %o0
3207 //   g) lock result registers and emit call operation
3208 //
3209 // Before issuing a call, we must spill-save all values on stack
3210 // that are in caller-save register. &quot;spill-save&quot; moves those registers
3211 // either in a free callee-save register or spills them if no free
3212 // callee save register is available.
3213 //
3214 // The problem is where to invoke spill-save.
3215 // - if invoked between e) and f), we may lock callee save
3216 //   register in &quot;spill-save&quot; that destroys the receiver register
3217 //   before f) is executed
3218 // - if we rearrange f) to be earlier (by loading %o0) it
3219 //   may destroy a value on the stack that is currently in %o0
3220 //   and is waiting to be spilled
3221 // - if we keep the receiver locked while doing spill-save,
3222 //   we cannot spill it as it is spill-locked
3223 //
3224 void LIRGenerator::do_Invoke(Invoke* x) {
3225   CallingConvention* cc = frame_map()-&gt;java_calling_convention(x-&gt;signature(), true);
3226 
3227   LIR_OprList* arg_list = cc-&gt;args();
3228   LIRItemList* args = invoke_visit_arguments(x);
3229   LIR_Opr receiver = LIR_OprFact::illegalOpr;
3230 
3231   // setup result register
3232   LIR_Opr result_register = LIR_OprFact::illegalOpr;
3233   if (x-&gt;type() != voidType) {
3234     result_register = result_register_for(x-&gt;type());
3235   }
3236 
3237   CodeEmitInfo* info = state_for(x, x-&gt;state());
3238 
3239   invoke_load_arguments(x, args, arg_list);
3240 
3241   if (x-&gt;has_receiver()) {
3242     args-&gt;at(0)-&gt;load_item_force(LIR_Assembler::receiverOpr());
3243     receiver = args-&gt;at(0)-&gt;result();
3244   }
3245 
3246   // emit invoke code
3247   assert(receiver-&gt;is_illegal() || receiver-&gt;is_equal(LIR_Assembler::receiverOpr()), &quot;must match&quot;);
3248 
3249   // JSR 292
3250   // Preserve the SP over MethodHandle call sites, if needed.
3251   ciMethod* target = x-&gt;target();
3252   bool is_method_handle_invoke = (// %%% FIXME: Are both of these relevant?
3253                                   target-&gt;is_method_handle_intrinsic() ||
3254                                   target-&gt;is_compiled_lambda_form());
3255   if (is_method_handle_invoke) {
3256     info-&gt;set_is_method_handle_invoke(true);
3257     if(FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {
3258         __ move(FrameMap::stack_pointer(), FrameMap::method_handle_invoke_SP_save_opr());
3259     }
3260   }
3261 
3262   switch (x-&gt;code()) {
3263     case Bytecodes::_invokestatic:
3264       __ call_static(target, result_register,
3265                      SharedRuntime::get_resolve_static_call_stub(),
3266                      arg_list, info);
3267       break;
3268     case Bytecodes::_invokespecial:
3269     case Bytecodes::_invokevirtual:
3270     case Bytecodes::_invokeinterface:
3271       // for loaded and final (method or class) target we still produce an inline cache,
3272       // in order to be able to call mixed mode
3273       if (x-&gt;code() == Bytecodes::_invokespecial || x-&gt;target_is_final()) {
3274         __ call_opt_virtual(target, receiver, result_register,
3275                             SharedRuntime::get_resolve_opt_virtual_call_stub(),
3276                             arg_list, info);
3277       } else if (x-&gt;vtable_index() &lt; 0) {
3278         __ call_icvirtual(target, receiver, result_register,
3279                           SharedRuntime::get_resolve_virtual_call_stub(),
3280                           arg_list, info);
3281       } else {
3282         int entry_offset = in_bytes(Klass::vtable_start_offset()) + x-&gt;vtable_index() * vtableEntry::size_in_bytes();
3283         int vtable_offset = entry_offset + vtableEntry::method_offset_in_bytes();
3284         __ call_virtual(target, receiver, result_register, vtable_offset, arg_list, info);
3285       }
3286       break;
3287     case Bytecodes::_invokedynamic: {
3288       __ call_dynamic(target, receiver, result_register,
3289                       SharedRuntime::get_resolve_static_call_stub(),
3290                       arg_list, info);
3291       break;
3292     }
3293     default:
3294       fatal(&quot;unexpected bytecode: %s&quot;, Bytecodes::name(x-&gt;code()));
3295       break;
3296   }
3297 
3298   // JSR 292
3299   // Restore the SP after MethodHandle call sites, if needed.
3300   if (is_method_handle_invoke
3301       &amp;&amp; FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {
3302     __ move(FrameMap::method_handle_invoke_SP_save_opr(), FrameMap::stack_pointer());
3303   }
3304 
3305   if (x-&gt;type()-&gt;is_float() || x-&gt;type()-&gt;is_double()) {
3306     // Force rounding of results from non-strictfp when in strictfp
3307     // scope (or when we don&#39;t know the strictness of the callee, to
3308     // be safe.)
3309     if (method()-&gt;is_strict()) {
3310       if (!x-&gt;target_is_loaded() || !x-&gt;target_is_strictfp()) {
3311         result_register = round_item(result_register);
3312       }
3313     }
3314   }
3315 
3316   if (result_register-&gt;is_valid()) {
3317     LIR_Opr result = rlock_result(x);
3318     __ move(result_register, result);
3319   }
3320 }
3321 
3322 
3323 void LIRGenerator::do_FPIntrinsics(Intrinsic* x) {
3324   assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
3325   LIRItem value       (x-&gt;argument_at(0), this);
3326   LIR_Opr reg = rlock_result(x);
3327   value.load_item();
3328   LIR_Opr tmp = force_to_spill(value.result(), as_BasicType(x-&gt;type()));
3329   __ move(tmp, reg);
3330 }
3331 
3332 
3333 
3334 // Code for  :  x-&gt;x() {x-&gt;cond()} x-&gt;y() ? x-&gt;tval() : x-&gt;fval()
3335 void LIRGenerator::do_IfOp(IfOp* x) {
3336 #ifdef ASSERT
3337   {
3338     ValueTag xtag = x-&gt;x()-&gt;type()-&gt;tag();
3339     ValueTag ttag = x-&gt;tval()-&gt;type()-&gt;tag();
3340     assert(xtag == intTag || xtag == objectTag, &quot;cannot handle others&quot;);
3341     assert(ttag == addressTag || ttag == intTag || ttag == objectTag || ttag == longTag, &quot;cannot handle others&quot;);
3342     assert(ttag == x-&gt;fval()-&gt;type()-&gt;tag(), &quot;cannot handle others&quot;);
3343   }
3344 #endif
3345 
3346   LIRItem left(x-&gt;x(), this);
3347   LIRItem right(x-&gt;y(), this);
3348   left.load_item();
3349   if (can_inline_as_constant(right.value()) &amp;&amp; !x-&gt;substitutability_check()) {
3350     right.dont_load_item();
3351   } else {
3352     // substitutability_check() needs to use right as a base register.
3353     right.load_item();
3354   }
3355 
3356   LIRItem t_val(x-&gt;tval(), this);
3357   LIRItem f_val(x-&gt;fval(), this);
3358   t_val.dont_load_item();
3359   f_val.dont_load_item();
3360 
3361   if (x-&gt;substitutability_check()) {
3362     substitutability_check(x, left, right, t_val, f_val);
3363   } else {
3364     LIR_Opr reg = rlock_result(x);
3365     __ cmp(lir_cond(x-&gt;cond()), left.result(), right.result());
3366     __ cmove(lir_cond(x-&gt;cond()), t_val.result(), f_val.result(), reg, as_BasicType(x-&gt;x()-&gt;type()));
3367   }
3368 }
3369 
3370 void LIRGenerator::substitutability_check(IfOp* x, LIRItem&amp; left, LIRItem&amp; right, LIRItem&amp; t_val, LIRItem&amp; f_val) {
3371   assert(x-&gt;cond() == If::eql || x-&gt;cond() == If::neq, &quot;must be&quot;);
3372   bool is_acmpeq = (x-&gt;cond() == If::eql);
3373   LIR_Opr equal_result     = is_acmpeq ? t_val.result() : f_val.result();
3374   LIR_Opr not_equal_result = is_acmpeq ? f_val.result() : t_val.result();
3375   LIR_Opr result = rlock_result(x);
3376   CodeEmitInfo* info = state_for(x, x-&gt;state_before());
3377 
3378   substitutability_check_common(x-&gt;x(), x-&gt;y(), left, right, equal_result, not_equal_result, result, info);
3379 }
3380 
3381 void LIRGenerator::substitutability_check(If* x, LIRItem&amp; left, LIRItem&amp; right) {
3382   LIR_Opr equal_result     = LIR_OprFact::intConst(1);
3383   LIR_Opr not_equal_result = LIR_OprFact::intConst(0);
3384   LIR_Opr result = new_register(T_INT);
3385   CodeEmitInfo* info = state_for(x, x-&gt;state_before());
3386 
3387   substitutability_check_common(x-&gt;x(), x-&gt;y(), left, right, equal_result, not_equal_result, result, info);
3388 
3389   assert(x-&gt;cond() == If::eql || x-&gt;cond() == If::neq, &quot;must be&quot;);
3390   __ cmp(lir_cond(x-&gt;cond()), result, equal_result);
3391 }
3392 
3393 void LIRGenerator::substitutability_check_common(Value left_val, Value right_val, LIRItem&amp; left, LIRItem&amp; right,
3394                                                  LIR_Opr equal_result, LIR_Opr not_equal_result, LIR_Opr result,
3395                                                  CodeEmitInfo* info) {
3396   LIR_Opr tmp1 = LIR_OprFact::illegalOpr;
3397   LIR_Opr tmp2 = LIR_OprFact::illegalOpr;
3398   LIR_Opr left_klass_op = LIR_OprFact::illegalOpr;
3399   LIR_Opr right_klass_op = LIR_OprFact::illegalOpr;
3400 
3401   ciKlass* left_klass  = left_val -&gt;as_loaded_klass_or_null();
3402   ciKlass* right_klass = right_val-&gt;as_loaded_klass_or_null();
3403 
3404   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.
<a name="13" id="anc13"></a><span class="line-modified">3405       !left_klass-&gt;is_inlinetype() || !right_klass-&gt;is_inlinetype()) {</span>
3406     init_temps_for_substitutability_check(tmp1, tmp2);
3407   }
3408 
<a name="14" id="anc14"></a><span class="line-modified">3409   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_inlinetype() &amp;&amp; left_klass == right_klass) {</span>
<span class="line-modified">3410     // No need to load klass -- the operands are statically known to be the same inline klass.</span>
3411   } else {
3412     BasicType t_klass = UseCompressedOops ? T_INT : T_METADATA;
3413     left_klass_op = new_register(t_klass);
3414     right_klass_op = new_register(t_klass);
3415   }
3416 
3417   CodeStub* slow_path = new SubstitutabilityCheckStub(left.result(), right.result(), info);
3418   __ substitutability_check(result, left.result(), right.result(), equal_result, not_equal_result,
3419                             tmp1, tmp2,
3420                             left_klass, right_klass, left_klass_op, right_klass_op, info, slow_path);
3421 }
3422 
3423 #ifdef JFR_HAVE_INTRINSICS
3424 void LIRGenerator::do_ClassIDIntrinsic(Intrinsic* x) {
3425   CodeEmitInfo* info = state_for(x);
3426   CodeEmitInfo* info2 = new CodeEmitInfo(info); // Clone for the second null check
3427 
3428   assert(info != NULL, &quot;must have info&quot;);
3429   LIRItem arg(x-&gt;argument_at(0), this);
3430 
3431   arg.load_item();
3432   LIR_Opr klass = new_register(T_METADATA);
3433   __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);
3434   LIR_Opr id = new_register(T_LONG);
3435   ByteSize offset = KLASS_TRACE_ID_OFFSET;
3436   LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);
3437 
3438   __ move(trace_id_addr, id);
3439   __ logical_or(id, LIR_OprFact::longConst(0x01l), id);
3440   __ store(id, trace_id_addr);
3441 
3442 #ifdef TRACE_ID_META_BITS
3443   __ logical_and(id, LIR_OprFact::longConst(~TRACE_ID_META_BITS), id);
3444 #endif
3445 #ifdef TRACE_ID_SHIFT
3446   __ unsigned_shift_right(id, TRACE_ID_SHIFT, id);
3447 #endif
3448 
3449   __ move(id, rlock_result(x));
3450 }
3451 
3452 void LIRGenerator::do_getEventWriter(Intrinsic* x) {
3453   LabelObj* L_end = new LabelObj();
3454 
3455   // FIXME T_ADDRESS should actually be T_METADATA but it can&#39;t because the
3456   // meaning of these two is mixed up (see JDK-8026837).
3457   LIR_Address* jobj_addr = new LIR_Address(getThreadPointer(),
3458                                            in_bytes(THREAD_LOCAL_WRITER_OFFSET_JFR),
3459                                            T_ADDRESS);
3460   LIR_Opr result = rlock_result(x);
3461   __ move(LIR_OprFact::oopConst(NULL), result);
3462   LIR_Opr jobj = new_register(T_METADATA);
3463   __ move_wide(jobj_addr, jobj);
3464   __ cmp(lir_cond_equal, jobj, LIR_OprFact::metadataConst(0));
3465   __ branch(lir_cond_equal, L_end-&gt;label());
3466 
3467   access_load(IN_NATIVE, T_OBJECT, LIR_OprFact::address(new LIR_Address(jobj, T_OBJECT)), result);
3468 
3469   __ branch_destination(L_end-&gt;label());
3470 }
3471 
3472 #endif
3473 
3474 
3475 void LIRGenerator::do_RuntimeCall(address routine, Intrinsic* x) {
3476   assert(x-&gt;number_of_arguments() == 0, &quot;wrong type&quot;);
3477   // Enforce computation of _reserved_argument_area_size which is required on some platforms.
3478   BasicTypeList signature;
3479   CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
3480   LIR_Opr reg = result_register_for(x-&gt;type());
3481   __ call_runtime_leaf(routine, getThreadTemp(),
3482                        reg, new LIR_OprList());
3483   LIR_Opr result = rlock_result(x);
3484   __ move(reg, result);
3485 }
3486 
3487 
3488 
3489 void LIRGenerator::do_Intrinsic(Intrinsic* x) {
3490   switch (x-&gt;id()) {
3491   case vmIntrinsics::_intBitsToFloat      :
3492   case vmIntrinsics::_doubleToRawLongBits :
3493   case vmIntrinsics::_longBitsToDouble    :
3494   case vmIntrinsics::_floatToRawIntBits   : {
3495     do_FPIntrinsics(x);
3496     break;
3497   }
3498 
3499 #ifdef JFR_HAVE_INTRINSICS
3500   case vmIntrinsics::_getClassId:
3501     do_ClassIDIntrinsic(x);
3502     break;
3503   case vmIntrinsics::_getEventWriter:
3504     do_getEventWriter(x);
3505     break;
3506   case vmIntrinsics::_counterTime:
3507     do_RuntimeCall(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), x);
3508     break;
3509 #endif
3510 
3511   case vmIntrinsics::_currentTimeMillis:
3512     do_RuntimeCall(CAST_FROM_FN_PTR(address, os::javaTimeMillis), x);
3513     break;
3514 
3515   case vmIntrinsics::_nanoTime:
3516     do_RuntimeCall(CAST_FROM_FN_PTR(address, os::javaTimeNanos), x);
3517     break;
3518 
3519   case vmIntrinsics::_Object_init:    do_RegisterFinalizer(x); break;
3520   case vmIntrinsics::_isInstance:     do_isInstance(x);    break;
3521   case vmIntrinsics::_isPrimitive:    do_isPrimitive(x);   break;
3522   case vmIntrinsics::_getClass:       do_getClass(x);      break;
3523   case vmIntrinsics::_currentThread:  do_currentThread(x); break;
3524 
3525   case vmIntrinsics::_dlog:           // fall through
3526   case vmIntrinsics::_dlog10:         // fall through
3527   case vmIntrinsics::_dabs:           // fall through
3528   case vmIntrinsics::_dsqrt:          // fall through
3529   case vmIntrinsics::_dtan:           // fall through
3530   case vmIntrinsics::_dsin :          // fall through
3531   case vmIntrinsics::_dcos :          // fall through
3532   case vmIntrinsics::_dexp :          // fall through
3533   case vmIntrinsics::_dpow :          do_MathIntrinsic(x); break;
3534   case vmIntrinsics::_arraycopy:      do_ArrayCopy(x);     break;
3535 
3536   case vmIntrinsics::_fmaD:           do_FmaIntrinsic(x); break;
3537   case vmIntrinsics::_fmaF:           do_FmaIntrinsic(x); break;
3538 
3539   // java.nio.Buffer.checkIndex
3540   case vmIntrinsics::_checkIndex:     do_NIOCheckIndex(x); break;
3541 
3542   case vmIntrinsics::_compareAndSetReference:
3543     do_CompareAndSwap(x, objectType);
3544     break;
3545   case vmIntrinsics::_compareAndSetInt:
3546     do_CompareAndSwap(x, intType);
3547     break;
3548   case vmIntrinsics::_compareAndSetLong:
3549     do_CompareAndSwap(x, longType);
3550     break;
3551 
3552   case vmIntrinsics::_loadFence :
3553     __ membar_acquire();
3554     break;
3555   case vmIntrinsics::_storeFence:
3556     __ membar_release();
3557     break;
3558   case vmIntrinsics::_fullFence :
3559     __ membar();
3560     break;
3561   case vmIntrinsics::_onSpinWait:
3562     __ on_spin_wait();
3563     break;
3564   case vmIntrinsics::_Reference_get:
3565     do_Reference_get(x);
3566     break;
3567 
3568   case vmIntrinsics::_updateCRC32:
3569   case vmIntrinsics::_updateBytesCRC32:
3570   case vmIntrinsics::_updateByteBufferCRC32:
3571     do_update_CRC32(x);
3572     break;
3573 
3574   case vmIntrinsics::_updateBytesCRC32C:
3575   case vmIntrinsics::_updateDirectByteBufferCRC32C:
3576     do_update_CRC32C(x);
3577     break;
3578 
3579   case vmIntrinsics::_vectorizedMismatch:
3580     do_vectorizedMismatch(x);
3581     break;
3582 
3583   default: ShouldNotReachHere(); break;
3584   }
3585 }
3586 
3587 void LIRGenerator::profile_arguments(ProfileCall* x) {
3588   if (compilation()-&gt;profile_arguments()) {
3589     int bci = x-&gt;bci_of_invoke();
3590     ciMethodData* md = x-&gt;method()-&gt;method_data_or_null();
3591     assert(md != NULL, &quot;Sanity&quot;);
3592     ciProfileData* data = md-&gt;bci_to_data(bci);
3593     if (data != NULL) {
3594       if ((data-&gt;is_CallTypeData() &amp;&amp; data-&gt;as_CallTypeData()-&gt;has_arguments()) ||
3595           (data-&gt;is_VirtualCallTypeData() &amp;&amp; data-&gt;as_VirtualCallTypeData()-&gt;has_arguments())) {
3596         ByteSize extra = data-&gt;is_CallTypeData() ? CallTypeData::args_data_offset() : VirtualCallTypeData::args_data_offset();
3597         int base_offset = md-&gt;byte_offset_of_slot(data, extra);
3598         LIR_Opr mdp = LIR_OprFact::illegalOpr;
3599         ciTypeStackSlotEntries* args = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;args() : ((ciVirtualCallTypeData*)data)-&gt;args();
3600 
3601         Bytecodes::Code bc = x-&gt;method()-&gt;java_code_at_bci(bci);
3602         int start = 0;
3603         int stop = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;number_of_arguments() : ((ciVirtualCallTypeData*)data)-&gt;number_of_arguments();
3604         if (x-&gt;callee()-&gt;is_loaded() &amp;&amp; x-&gt;callee()-&gt;is_static() &amp;&amp; Bytecodes::has_receiver(bc)) {
3605           // first argument is not profiled at call (method handle invoke)
3606           assert(x-&gt;method()-&gt;raw_code_at_bci(bci) == Bytecodes::_invokehandle, &quot;invokehandle expected&quot;);
3607           start = 1;
3608         }
3609         ciSignature* callee_signature = x-&gt;callee()-&gt;signature();
3610         // method handle call to virtual method
3611         bool has_receiver = x-&gt;callee()-&gt;is_loaded() &amp;&amp; !x-&gt;callee()-&gt;is_static() &amp;&amp; !Bytecodes::has_receiver(bc);
3612         ciSignatureStream callee_signature_stream(callee_signature, has_receiver ? x-&gt;callee()-&gt;holder() : NULL);
3613 
3614         bool ignored_will_link;
3615         ciSignature* signature_at_call = NULL;
3616         x-&gt;method()-&gt;get_method_at_bci(bci, ignored_will_link, &amp;signature_at_call);
3617         ciSignatureStream signature_at_call_stream(signature_at_call);
3618 
3619         // if called through method handle invoke, some arguments may have been popped
3620         for (int i = 0; i &lt; stop &amp;&amp; i+start &lt; x-&gt;nb_profiled_args(); i++) {
3621           int off = in_bytes(TypeEntriesAtCall::argument_type_offset(i)) - in_bytes(TypeEntriesAtCall::args_data_offset());
3622           ciKlass* exact = profile_type(md, base_offset, off,
3623               args-&gt;type(i), x-&gt;profiled_arg_at(i+start), mdp,
3624               !x-&gt;arg_needs_null_check(i+start),
3625               signature_at_call_stream.next_klass(), callee_signature_stream.next_klass());
3626           if (exact != NULL) {
3627             md-&gt;set_argument_type(bci, i, exact);
3628           }
3629         }
3630       } else {
3631 #ifdef ASSERT
3632         Bytecodes::Code code = x-&gt;method()-&gt;raw_code_at_bci(x-&gt;bci_of_invoke());
3633         int n = x-&gt;nb_profiled_args();
3634         assert(MethodData::profile_parameters() &amp;&amp; (MethodData::profile_arguments_jsr292_only() ||
3635             (x-&gt;inlined() &amp;&amp; ((code == Bytecodes::_invokedynamic &amp;&amp; n &lt;= 1) || (code == Bytecodes::_invokehandle &amp;&amp; n &lt;= 2)))),
3636             &quot;only at JSR292 bytecodes&quot;);
3637 #endif
3638       }
3639     }
3640   }
3641 }
3642 
3643 // profile parameters on entry to an inlined method
3644 void LIRGenerator::profile_parameters_at_call(ProfileCall* x) {
3645   if (compilation()-&gt;profile_parameters() &amp;&amp; x-&gt;inlined()) {
3646     ciMethodData* md = x-&gt;callee()-&gt;method_data_or_null();
3647     if (md != NULL) {
3648       ciParametersTypeData* parameters_type_data = md-&gt;parameters_type_data();
3649       if (parameters_type_data != NULL) {
3650         ciTypeStackSlotEntries* parameters =  parameters_type_data-&gt;parameters();
3651         LIR_Opr mdp = LIR_OprFact::illegalOpr;
3652         bool has_receiver = !x-&gt;callee()-&gt;is_static();
3653         ciSignature* sig = x-&gt;callee()-&gt;signature();
3654         ciSignatureStream sig_stream(sig, has_receiver ? x-&gt;callee()-&gt;holder() : NULL);
3655         int i = 0; // to iterate on the Instructions
3656         Value arg = x-&gt;recv();
3657         bool not_null = false;
3658         int bci = x-&gt;bci_of_invoke();
3659         Bytecodes::Code bc = x-&gt;method()-&gt;java_code_at_bci(bci);
3660         // The first parameter is the receiver so that&#39;s what we start
3661         // with if it exists. One exception is method handle call to
3662         // virtual method: the receiver is in the args list
3663         if (arg == NULL || !Bytecodes::has_receiver(bc)) {
3664           i = 1;
3665           arg = x-&gt;profiled_arg_at(0);
3666           not_null = !x-&gt;arg_needs_null_check(0);
3667         }
3668         int k = 0; // to iterate on the profile data
3669         for (;;) {
3670           intptr_t profiled_k = parameters-&gt;type(k);
3671           ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(parameters_type_data, ParametersTypeData::type_offset(0)),
3672                                         in_bytes(ParametersTypeData::type_offset(k)) - in_bytes(ParametersTypeData::type_offset(0)),
3673                                         profiled_k, arg, mdp, not_null, sig_stream.next_klass(), NULL);
3674           // If the profile is known statically set it once for all and do not emit any code
3675           if (exact != NULL) {
3676             md-&gt;set_parameter_type(k, exact);
3677           }
3678           k++;
3679           if (k &gt;= parameters_type_data-&gt;number_of_parameters()) {
3680 #ifdef ASSERT
3681             int extra = 0;
3682             if (MethodData::profile_arguments() &amp;&amp; TypeProfileParmsLimit != -1 &amp;&amp;
3683                 x-&gt;nb_profiled_args() &gt;= TypeProfileParmsLimit &amp;&amp;
3684                 x-&gt;recv() != NULL &amp;&amp; Bytecodes::has_receiver(bc)) {
3685               extra += 1;
3686             }
3687             assert(i == x-&gt;nb_profiled_args() - extra || (TypeProfileParmsLimit != -1 &amp;&amp; TypeProfileArgsLimit &gt; TypeProfileParmsLimit), &quot;unused parameters?&quot;);
3688 #endif
3689             break;
3690           }
3691           arg = x-&gt;profiled_arg_at(i);
3692           not_null = !x-&gt;arg_needs_null_check(i);
3693           i++;
3694         }
3695       }
3696     }
3697   }
3698 }
3699 
3700 void LIRGenerator::do_ProfileCall(ProfileCall* x) {
3701   // Need recv in a temporary register so it interferes with the other temporaries
3702   LIR_Opr recv = LIR_OprFact::illegalOpr;
3703   LIR_Opr mdo = new_register(T_METADATA);
3704   // tmp is used to hold the counters on SPARC
3705   LIR_Opr tmp = new_pointer_register();
3706 
3707   if (x-&gt;nb_profiled_args() &gt; 0) {
3708     profile_arguments(x);
3709   }
3710 
3711   // profile parameters on inlined method entry including receiver
3712   if (x-&gt;recv() != NULL || x-&gt;nb_profiled_args() &gt; 0) {
3713     profile_parameters_at_call(x);
3714   }
3715 
3716   if (x-&gt;recv() != NULL) {
3717     LIRItem value(x-&gt;recv(), this);
3718     value.load_item();
3719     recv = new_register(T_OBJECT);
3720     __ move(value.result(), recv);
3721   }
3722   __ profile_call(x-&gt;method(), x-&gt;bci_of_invoke(), x-&gt;callee(), mdo, recv, tmp, x-&gt;known_holder());
3723 }
3724 
3725 void LIRGenerator::do_ProfileReturnType(ProfileReturnType* x) {
3726   int bci = x-&gt;bci_of_invoke();
3727   ciMethodData* md = x-&gt;method()-&gt;method_data_or_null();
3728   assert(md != NULL, &quot;Sanity&quot;);
3729   ciProfileData* data = md-&gt;bci_to_data(bci);
3730   if (data != NULL) {
3731     assert(data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData(), &quot;wrong profile data type&quot;);
3732     ciSingleTypeEntry* ret = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;ret() : ((ciVirtualCallTypeData*)data)-&gt;ret();
3733     LIR_Opr mdp = LIR_OprFact::illegalOpr;
3734 
3735     bool ignored_will_link;
3736     ciSignature* signature_at_call = NULL;
3737     x-&gt;method()-&gt;get_method_at_bci(bci, ignored_will_link, &amp;signature_at_call);
3738 
3739     // The offset within the MDO of the entry to update may be too large
3740     // to be used in load/store instructions on some platforms. So have
3741     // profile_type() compute the address of the profile in a register.
3742     ciKlass* exact = profile_type(md, md-&gt;byte_offset_of_slot(data, ret-&gt;type_offset()), 0,
3743         ret-&gt;type(), x-&gt;ret(), mdp,
3744         !x-&gt;needs_null_check(),
3745         signature_at_call-&gt;return_type()-&gt;as_klass(),
3746         x-&gt;callee()-&gt;signature()-&gt;return_type()-&gt;as_klass());
3747     if (exact != NULL) {
3748       md-&gt;set_return_type(bci, exact);
3749     }
3750   }
3751 }
3752 
3753 void LIRGenerator::do_ProfileInvoke(ProfileInvoke* x) {
3754   // We can safely ignore accessors here, since c2 will inline them anyway,
3755   // accessors are also always mature.
3756   if (!x-&gt;inlinee()-&gt;is_accessor()) {
3757     CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
3758     // Notify the runtime very infrequently only to take care of counter overflows
3759     int freq_log = Tier23InlineeNotifyFreqLog;
3760     double scale;
3761     if (_method-&gt;has_option_value(&quot;CompileThresholdScaling&quot;, scale)) {
3762       freq_log = CompilerConfig::scaled_freq_log(freq_log, scale);
3763     }
3764     increment_event_counter_impl(info, x-&gt;inlinee(), LIR_OprFact::intConst(InvocationCounter::count_increment), right_n_bits(freq_log), InvocationEntryBci, false, true);
3765   }
3766 }
3767 
3768 void LIRGenerator::increment_backedge_counter_conditionally(LIR_Condition cond, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info, int left_bci, int right_bci, int bci) {
3769   if (compilation()-&gt;count_backedges()) {
3770 #if defined(X86) &amp;&amp; !defined(_LP64)
3771     // BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.
3772     LIR_Opr left_copy = new_register(left-&gt;type());
3773     __ move(left, left_copy);
3774     __ cmp(cond, left_copy, right);
3775 #else
3776     __ cmp(cond, left, right);
3777 #endif
3778     LIR_Opr step = new_register(T_INT);
3779     LIR_Opr plus_one = LIR_OprFact::intConst(InvocationCounter::count_increment);
3780     LIR_Opr zero = LIR_OprFact::intConst(0);
3781     __ cmove(cond,
3782         (left_bci &lt; bci) ? plus_one : zero,
3783         (right_bci &lt; bci) ? plus_one : zero,
3784         step, left-&gt;type());
3785     increment_backedge_counter(info, step, bci);
3786   }
3787 }
3788 
3789 
3790 void LIRGenerator::increment_event_counter(CodeEmitInfo* info, LIR_Opr step, int bci, bool backedge) {
3791   int freq_log = 0;
3792   int level = compilation()-&gt;env()-&gt;comp_level();
3793   if (level == CompLevel_limited_profile) {
3794     freq_log = (backedge ? Tier2BackedgeNotifyFreqLog : Tier2InvokeNotifyFreqLog);
3795   } else if (level == CompLevel_full_profile) {
3796     freq_log = (backedge ? Tier3BackedgeNotifyFreqLog : Tier3InvokeNotifyFreqLog);
3797   } else {
3798     ShouldNotReachHere();
3799   }
3800   // Increment the appropriate invocation/backedge counter and notify the runtime.
3801   double scale;
3802   if (_method-&gt;has_option_value(&quot;CompileThresholdScaling&quot;, scale)) {
3803     freq_log = CompilerConfig::scaled_freq_log(freq_log, scale);
3804   }
3805   increment_event_counter_impl(info, info-&gt;scope()-&gt;method(), step, right_n_bits(freq_log), bci, backedge, true);
3806 }
3807 
3808 void LIRGenerator::decrement_age(CodeEmitInfo* info) {
3809   ciMethod* method = info-&gt;scope()-&gt;method();
3810   MethodCounters* mc_adr = method-&gt;ensure_method_counters();
3811   if (mc_adr != NULL) {
3812     LIR_Opr mc = new_pointer_register();
3813     __ move(LIR_OprFact::intptrConst(mc_adr), mc);
3814     int offset = in_bytes(MethodCounters::nmethod_age_offset());
3815     LIR_Address* counter = new LIR_Address(mc, offset, T_INT);
3816     LIR_Opr result = new_register(T_INT);
3817     __ load(counter, result);
3818     __ sub(result, LIR_OprFact::intConst(1), result);
3819     __ store(result, counter);
3820     // DeoptimizeStub will reexecute from the current state in code info.
3821     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_tenured,
3822                                          Deoptimization::Action_make_not_entrant);
3823     __ cmp(lir_cond_lessEqual, result, LIR_OprFact::intConst(0));
3824     __ branch(lir_cond_lessEqual, deopt);
3825   }
3826 }
3827 
3828 
3829 void LIRGenerator::increment_event_counter_impl(CodeEmitInfo* info,
3830                                                 ciMethod *method, LIR_Opr step, int frequency,
3831                                                 int bci, bool backedge, bool notify) {
3832   assert(frequency == 0 || is_power_of_2(frequency + 1), &quot;Frequency must be x^2 - 1 or 0&quot;);
3833   int level = _compilation-&gt;env()-&gt;comp_level();
3834   assert(level &gt; CompLevel_simple, &quot;Shouldn&#39;t be here&quot;);
3835 
3836   int offset = -1;
3837   LIR_Opr counter_holder = NULL;
3838   if (level == CompLevel_limited_profile) {
3839     MethodCounters* counters_adr = method-&gt;ensure_method_counters();
3840     if (counters_adr == NULL) {
3841       bailout(&quot;method counters allocation failed&quot;);
3842       return;
3843     }
3844     counter_holder = new_pointer_register();
3845     __ move(LIR_OprFact::intptrConst(counters_adr), counter_holder);
3846     offset = in_bytes(backedge ? MethodCounters::backedge_counter_offset() :
3847                                  MethodCounters::invocation_counter_offset());
3848   } else if (level == CompLevel_full_profile) {
3849     counter_holder = new_register(T_METADATA);
3850     offset = in_bytes(backedge ? MethodData::backedge_counter_offset() :
3851                                  MethodData::invocation_counter_offset());
3852     ciMethodData* md = method-&gt;method_data_or_null();
3853     assert(md != NULL, &quot;Sanity&quot;);
3854     __ metadata2reg(md-&gt;constant_encoding(), counter_holder);
3855   } else {
3856     ShouldNotReachHere();
3857   }
3858   LIR_Address* counter = new LIR_Address(counter_holder, offset, T_INT);
3859   LIR_Opr result = new_register(T_INT);
3860   __ load(counter, result);
3861   __ add(result, step, result);
3862   __ store(result, counter);
3863   if (notify &amp;&amp; (!backedge || UseOnStackReplacement)) {
3864     LIR_Opr meth = LIR_OprFact::metadataConst(method-&gt;constant_encoding());
3865     // The bci for info can point to cmp for if&#39;s we want the if bci
3866     CodeStub* overflow = new CounterOverflowStub(info, bci, meth);
3867     int freq = frequency &lt;&lt; InvocationCounter::count_shift;
3868     if (freq == 0) {
3869       if (!step-&gt;is_constant()) {
3870         __ cmp(lir_cond_notEqual, step, LIR_OprFact::intConst(0));
3871         __ branch(lir_cond_notEqual, overflow);
3872       } else {
3873         __ branch(lir_cond_always, overflow);
3874       }
3875     } else {
3876       LIR_Opr mask = load_immediate(freq, T_INT);
3877       if (!step-&gt;is_constant()) {
3878         // If step is 0, make sure the overflow check below always fails
3879         __ cmp(lir_cond_notEqual, step, LIR_OprFact::intConst(0));
3880         __ cmove(lir_cond_notEqual, result, LIR_OprFact::intConst(InvocationCounter::count_increment), result, T_INT);
3881       }
3882       __ logical_and(result, mask, result);
3883       __ cmp(lir_cond_equal, result, LIR_OprFact::intConst(0));
3884       __ branch(lir_cond_equal, overflow);
3885     }
3886     __ branch_destination(overflow-&gt;continuation());
3887   }
3888 }
3889 
3890 void LIRGenerator::do_RuntimeCall(RuntimeCall* x) {
3891   LIR_OprList* args = new LIR_OprList(x-&gt;number_of_arguments());
3892   BasicTypeList* signature = new BasicTypeList(x-&gt;number_of_arguments());
3893 
3894   if (x-&gt;pass_thread()) {
3895     signature-&gt;append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    // thread
3896     args-&gt;append(getThreadPointer());
3897   }
3898 
3899   for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
3900     Value a = x-&gt;argument_at(i);
3901     LIRItem* item = new LIRItem(a, this);
3902     item-&gt;load_item();
3903     args-&gt;append(item-&gt;result());
3904     signature-&gt;append(as_BasicType(a-&gt;type()));
3905   }
3906 
3907   LIR_Opr result = call_runtime(signature, args, x-&gt;entry(), x-&gt;type(), NULL);
3908   if (x-&gt;type() == voidType) {
3909     set_no_result(x);
3910   } else {
3911     __ move(result, rlock_result(x));
3912   }
3913 }
3914 
3915 #ifdef ASSERT
3916 void LIRGenerator::do_Assert(Assert *x) {
3917   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
3918   If::Condition cond = x-&gt;cond();
3919 
3920   LIRItem xitem(x-&gt;x(), this);
3921   LIRItem yitem(x-&gt;y(), this);
3922   LIRItem* xin = &amp;xitem;
3923   LIRItem* yin = &amp;yitem;
3924 
3925   assert(tag == intTag, &quot;Only integer assertions are valid!&quot;);
3926 
3927   xin-&gt;load_item();
3928   yin-&gt;dont_load_item();
3929 
3930   set_no_result(x);
3931 
3932   LIR_Opr left = xin-&gt;result();
3933   LIR_Opr right = yin-&gt;result();
3934 
3935   __ lir_assert(lir_cond(x-&gt;cond()), left, right, x-&gt;message(), true);
3936 }
3937 #endif
3938 
3939 void LIRGenerator::do_RangeCheckPredicate(RangeCheckPredicate *x) {
3940 
3941 
3942   Instruction *a = x-&gt;x();
3943   Instruction *b = x-&gt;y();
3944   if (!a || StressRangeCheckElimination) {
3945     assert(!b || StressRangeCheckElimination, &quot;B must also be null&quot;);
3946 
3947     CodeEmitInfo *info = state_for(x, x-&gt;state());
3948     CodeStub* stub = new PredicateFailedStub(info);
3949 
3950     __ jump(stub);
3951   } else if (a-&gt;type()-&gt;as_IntConstant() &amp;&amp; b-&gt;type()-&gt;as_IntConstant()) {
3952     int a_int = a-&gt;type()-&gt;as_IntConstant()-&gt;value();
3953     int b_int = b-&gt;type()-&gt;as_IntConstant()-&gt;value();
3954 
3955     bool ok = false;
3956 
3957     switch(x-&gt;cond()) {
3958       case Instruction::eql: ok = (a_int == b_int); break;
3959       case Instruction::neq: ok = (a_int != b_int); break;
3960       case Instruction::lss: ok = (a_int &lt; b_int); break;
3961       case Instruction::leq: ok = (a_int &lt;= b_int); break;
3962       case Instruction::gtr: ok = (a_int &gt; b_int); break;
3963       case Instruction::geq: ok = (a_int &gt;= b_int); break;
3964       case Instruction::aeq: ok = ((unsigned int)a_int &gt;= (unsigned int)b_int); break;
3965       case Instruction::beq: ok = ((unsigned int)a_int &lt;= (unsigned int)b_int); break;
3966       default: ShouldNotReachHere();
3967     }
3968 
3969     if (ok) {
3970 
3971       CodeEmitInfo *info = state_for(x, x-&gt;state());
3972       CodeStub* stub = new PredicateFailedStub(info);
3973 
3974       __ jump(stub);
3975     }
3976   } else {
3977 
3978     ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
3979     If::Condition cond = x-&gt;cond();
3980     LIRItem xitem(x-&gt;x(), this);
3981     LIRItem yitem(x-&gt;y(), this);
3982     LIRItem* xin = &amp;xitem;
3983     LIRItem* yin = &amp;yitem;
3984 
3985     assert(tag == intTag, &quot;Only integer deoptimizations are valid!&quot;);
3986 
3987     xin-&gt;load_item();
3988     yin-&gt;dont_load_item();
3989     set_no_result(x);
3990 
3991     LIR_Opr left = xin-&gt;result();
3992     LIR_Opr right = yin-&gt;result();
3993 
3994     CodeEmitInfo *info = state_for(x, x-&gt;state());
3995     CodeStub* stub = new PredicateFailedStub(info);
3996 
3997     __ cmp(lir_cond(cond), left, right);
3998     __ branch(lir_cond(cond), stub);
3999   }
4000 }
4001 
4002 
4003 LIR_Opr LIRGenerator::call_runtime(Value arg1, address entry, ValueType* result_type, CodeEmitInfo* info) {
4004   LIRItemList args(1);
4005   LIRItem value(arg1, this);
4006   args.append(&amp;value);
4007   BasicTypeList signature;
4008   signature.append(as_BasicType(arg1-&gt;type()));
4009 
4010   return call_runtime(&amp;signature, &amp;args, entry, result_type, info);
4011 }
4012 
4013 
4014 LIR_Opr LIRGenerator::call_runtime(Value arg1, Value arg2, address entry, ValueType* result_type, CodeEmitInfo* info) {
4015   LIRItemList args(2);
4016   LIRItem value1(arg1, this);
4017   LIRItem value2(arg2, this);
4018   args.append(&amp;value1);
4019   args.append(&amp;value2);
4020   BasicTypeList signature;
4021   signature.append(as_BasicType(arg1-&gt;type()));
4022   signature.append(as_BasicType(arg2-&gt;type()));
4023 
4024   return call_runtime(&amp;signature, &amp;args, entry, result_type, info);
4025 }
4026 
4027 
4028 LIR_Opr LIRGenerator::call_runtime(BasicTypeArray* signature, LIR_OprList* args,
4029                                    address entry, ValueType* result_type, CodeEmitInfo* info) {
4030   // get a result register
4031   LIR_Opr phys_reg = LIR_OprFact::illegalOpr;
4032   LIR_Opr result = LIR_OprFact::illegalOpr;
4033   if (result_type-&gt;tag() != voidTag) {
4034     result = new_register(result_type);
4035     phys_reg = result_register_for(result_type);
4036   }
4037 
4038   // move the arguments into the correct location
4039   CallingConvention* cc = frame_map()-&gt;c_calling_convention(signature);
4040   assert(cc-&gt;length() == args-&gt;length(), &quot;argument mismatch&quot;);
4041   for (int i = 0; i &lt; args-&gt;length(); i++) {
4042     LIR_Opr arg = args-&gt;at(i);
4043     LIR_Opr loc = cc-&gt;at(i);
4044     if (loc-&gt;is_register()) {
4045       __ move(arg, loc);
4046     } else {
4047       LIR_Address* addr = loc-&gt;as_address_ptr();
4048 //           if (!can_store_as_constant(arg)) {
4049 //             LIR_Opr tmp = new_register(arg-&gt;type());
4050 //             __ move(arg, tmp);
4051 //             arg = tmp;
4052 //           }
4053       if (addr-&gt;type() == T_LONG || addr-&gt;type() == T_DOUBLE) {
4054         __ unaligned_move(arg, addr);
4055       } else {
4056         __ move(arg, addr);
4057       }
4058     }
4059   }
4060 
4061   if (info) {
4062     __ call_runtime(entry, getThreadTemp(), phys_reg, cc-&gt;args(), info);
4063   } else {
4064     __ call_runtime_leaf(entry, getThreadTemp(), phys_reg, cc-&gt;args());
4065   }
4066   if (result-&gt;is_valid()) {
4067     __ move(phys_reg, result);
4068   }
4069   return result;
4070 }
4071 
4072 
4073 LIR_Opr LIRGenerator::call_runtime(BasicTypeArray* signature, LIRItemList* args,
4074                                    address entry, ValueType* result_type, CodeEmitInfo* info) {
4075   // get a result register
4076   LIR_Opr phys_reg = LIR_OprFact::illegalOpr;
4077   LIR_Opr result = LIR_OprFact::illegalOpr;
4078   if (result_type-&gt;tag() != voidTag) {
4079     result = new_register(result_type);
4080     phys_reg = result_register_for(result_type);
4081   }
4082 
4083   // move the arguments into the correct location
4084   CallingConvention* cc = frame_map()-&gt;c_calling_convention(signature);
4085 
4086   assert(cc-&gt;length() == args-&gt;length(), &quot;argument mismatch&quot;);
4087   for (int i = 0; i &lt; args-&gt;length(); i++) {
4088     LIRItem* arg = args-&gt;at(i);
4089     LIR_Opr loc = cc-&gt;at(i);
4090     if (loc-&gt;is_register()) {
4091       arg-&gt;load_item_force(loc);
4092     } else {
4093       LIR_Address* addr = loc-&gt;as_address_ptr();
4094       arg-&gt;load_for_store(addr-&gt;type());
4095       if (addr-&gt;type() == T_LONG || addr-&gt;type() == T_DOUBLE) {
4096         __ unaligned_move(arg-&gt;result(), addr);
4097       } else {
4098         __ move(arg-&gt;result(), addr);
4099       }
4100     }
4101   }
4102 
4103   if (info) {
4104     __ call_runtime(entry, getThreadTemp(), phys_reg, cc-&gt;args(), info);
4105   } else {
4106     __ call_runtime_leaf(entry, getThreadTemp(), phys_reg, cc-&gt;args());
4107   }
4108   if (result-&gt;is_valid()) {
4109     __ move(phys_reg, result);
4110   }
4111   return result;
4112 }
4113 
4114 void LIRGenerator::do_MemBar(MemBar* x) {
4115   LIR_Code code = x-&gt;code();
4116   switch(code) {
4117   case lir_membar_acquire   : __ membar_acquire(); break;
4118   case lir_membar_release   : __ membar_release(); break;
4119   case lir_membar           : __ membar(); break;
4120   case lir_membar_loadload  : __ membar_loadload(); break;
4121   case lir_membar_storestore: __ membar_storestore(); break;
4122   case lir_membar_loadstore : __ membar_loadstore(); break;
4123   case lir_membar_storeload : __ membar_storeload(); break;
4124   default                   : ShouldNotReachHere(); break;
4125   }
4126 }
4127 
4128 LIR_Opr LIRGenerator::mask_boolean(LIR_Opr array, LIR_Opr value, CodeEmitInfo*&amp; null_check_info) {
4129   LIR_Opr value_fixed = rlock_byte(T_BYTE);
4130   if (TwoOperandLIRForm) {
4131     __ move(value, value_fixed);
4132     __ logical_and(value_fixed, LIR_OprFact::intConst(1), value_fixed);
4133   } else {
4134     __ logical_and(value, LIR_OprFact::intConst(1), value_fixed);
4135   }
4136   LIR_Opr klass = new_register(T_METADATA);
4137   __ move(new LIR_Address(array, oopDesc::klass_offset_in_bytes(), T_ADDRESS), klass, null_check_info);
4138   null_check_info = NULL;
4139   LIR_Opr layout = new_register(T_INT);
4140   __ move(new LIR_Address(klass, in_bytes(Klass::layout_helper_offset()), T_INT), layout);
4141   int diffbit = Klass::layout_helper_boolean_diffbit();
4142   __ logical_and(layout, LIR_OprFact::intConst(diffbit), layout);
4143   __ cmp(lir_cond_notEqual, layout, LIR_OprFact::intConst(0));
4144   __ cmove(lir_cond_notEqual, value_fixed, value, value_fixed, T_BYTE);
4145   value = value_fixed;
4146   return value;
4147 }
4148 
4149 LIR_Opr LIRGenerator::maybe_mask_boolean(StoreIndexed* x, LIR_Opr array, LIR_Opr value, CodeEmitInfo*&amp; null_check_info) {
4150   if (x-&gt;check_boolean()) {
4151     value = mask_boolean(array, value, null_check_info);
4152   }
4153   return value;
4154 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
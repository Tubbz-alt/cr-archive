<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_ValueStack.hpp&quot;
  31 #include &quot;ci/ciInlineKlass.hpp&quot;
  32 #include &quot;ci/ciInstance.hpp&quot;
  33 #include &quot;runtime/sharedRuntime.hpp&quot;
  34 
  35 Register LIR_OprDesc::as_register() const {
  36   return FrameMap::cpu_rnr2reg(cpu_regnr());
  37 }
  38 
  39 Register LIR_OprDesc::as_register_lo() const {
  40   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  41 }
  42 
  43 Register LIR_OprDesc::as_register_hi() const {
  44   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  45 }
  46 
  47 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  48 
  49 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  50   ValueTag tag = type-&gt;tag();
  51   switch (tag) {
  52   case metaDataTag : {
  53     ClassConstant* c = type-&gt;as_ClassConstant();
  54     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_loaded()) {
  55       return LIR_OprFact::metadataConst(NULL);
  56     } else if (c != NULL) {
  57       return LIR_OprFact::metadataConst(c-&gt;value()-&gt;constant_encoding());
  58     } else {
  59       MethodConstant* m = type-&gt;as_MethodConstant();
  60       assert (m != NULL, &quot;not a class or a method?&quot;);
  61       return LIR_OprFact::metadataConst(m-&gt;value()-&gt;constant_encoding());
  62     }
  63   }
  64   case objectTag : {
  65       return LIR_OprFact::oopConst(type-&gt;as_ObjectType()-&gt;encoding());
  66     }
  67   case addressTag: return LIR_OprFact::addressConst(type-&gt;as_AddressConstant()-&gt;value());
  68   case intTag    : return LIR_OprFact::intConst(type-&gt;as_IntConstant()-&gt;value());
  69   case floatTag  : return LIR_OprFact::floatConst(type-&gt;as_FloatConstant()-&gt;value());
  70   case longTag   : return LIR_OprFact::longConst(type-&gt;as_LongConstant()-&gt;value());
  71   case doubleTag : return LIR_OprFact::doubleConst(type-&gt;as_DoubleConstant()-&gt;value());
  72   default: ShouldNotReachHere(); return LIR_OprFact::intConst(-1);
  73   }
  74 }
  75 
  76 
  77 //---------------------------------------------------
  78 
  79 
  80 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  81   int elem_size = type2aelembytes(type);
  82   switch (elem_size) {
  83   case 1: return LIR_Address::times_1;
  84   case 2: return LIR_Address::times_2;
  85   case 4: return LIR_Address::times_4;
  86   case 8: return LIR_Address::times_8;
  87   }
  88   ShouldNotReachHere();
  89   return LIR_Address::times_1;
  90 }
  91 
  92 //---------------------------------------------------
  93 
  94 char LIR_OprDesc::type_char(BasicType t) {
  95   switch (t) {
  96     case T_ARRAY:
  97     case T_INLINE_TYPE:
  98       t = T_OBJECT;
  99     case T_BOOLEAN:
 100     case T_CHAR:
 101     case T_FLOAT:
 102     case T_DOUBLE:
 103     case T_BYTE:
 104     case T_SHORT:
 105     case T_INT:
 106     case T_LONG:
 107     case T_OBJECT:
 108     case T_ADDRESS:
 109     case T_VOID:
 110       return ::type2char(t);
 111     case T_METADATA:
 112       return &#39;M&#39;;
 113     case T_ILLEGAL:
 114       return &#39;?&#39;;
 115 
 116     default:
 117       ShouldNotReachHere();
 118       return &#39;?&#39;;
 119   }
 120 }
 121 
 122 #ifndef PRODUCT
 123 void LIR_OprDesc::validate_type() const {
 124 
 125 #ifdef ASSERT
 126   if (!is_pointer() &amp;&amp; !is_illegal()) {
 127     OprKind kindfield = kind_field(); // Factored out because of compiler bug, see 8002160
 128     switch (as_BasicType(type_field())) {
 129     case T_LONG:
 130       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 131              size_field() == double_size, &quot;must match&quot;);
 132       break;
 133     case T_FLOAT:
 134       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 135       assert((kindfield == fpu_register || kindfield == stack_value
 136              ARM_ONLY(|| kindfield == cpu_register)
 137              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 138              size_field() == single_size, &quot;must match&quot;);
 139       break;
 140     case T_DOUBLE:
 141       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 142       assert((kindfield == fpu_register || kindfield == stack_value
 143              ARM_ONLY(|| kindfield == cpu_register)
 144              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 145              size_field() == double_size, &quot;must match&quot;);
 146       break;
 147     case T_BOOLEAN:
 148     case T_CHAR:
 149     case T_BYTE:
 150     case T_SHORT:
 151     case T_INT:
 152     case T_ADDRESS:
 153     case T_OBJECT:
 154     case T_METADATA:
 155     case T_ARRAY:
 156     case T_INLINE_TYPE:
 157       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 158              size_field() == single_size, &quot;must match&quot;);
 159       break;
 160 
 161     case T_ILLEGAL:
 162       // XXX TKR also means unknown right now
 163       // assert(is_illegal(), &quot;must match&quot;);
 164       break;
 165 
 166     default:
 167       ShouldNotReachHere();
 168     }
 169   }
 170 #endif
 171 
 172 }
 173 #endif // PRODUCT
 174 
 175 
 176 bool LIR_OprDesc::is_oop() const {
 177   if (is_pointer()) {
 178     return pointer()-&gt;is_oop_pointer();
 179   } else {
 180     OprType t= type_field();
 181     assert(t != unknown_type, &quot;not set&quot;);
 182     return t == object_type;
 183   }
 184 }
 185 
 186 
 187 
 188 void LIR_Op2::verify() const {
 189 #ifdef ASSERT
 190   switch (code()) {
 191     case lir_cmove:
 192     case lir_xchg:
 193       break;
 194 
 195     default:
 196       assert(!result_opr()-&gt;is_register() || !result_opr()-&gt;is_oop_register(),
 197              &quot;can&#39;t produce oops from arith&quot;);
 198   }
 199 
 200   if (TwoOperandLIRForm) {
 201 
 202 #ifdef ASSERT
 203     bool threeOperandForm = false;
 204 #ifdef S390
 205     // There are 3 operand shifts on S390 (see LIR_Assembler::shift_op()).
 206     threeOperandForm =
 207       code() == lir_shl ||
 208       ((code() == lir_shr || code() == lir_ushr) &amp;&amp; (result_opr()-&gt;is_double_cpu() || in_opr1()-&gt;type() == T_OBJECT));
 209 #endif
 210 #endif
 211 
 212     switch (code()) {
 213     case lir_add:
 214     case lir_sub:
 215     case lir_mul:
 216     case lir_mul_strictfp:
 217     case lir_div:
 218     case lir_div_strictfp:
 219     case lir_rem:
 220     case lir_logic_and:
 221     case lir_logic_or:
 222     case lir_logic_xor:
 223     case lir_shl:
 224     case lir_shr:
 225       assert(in_opr1() == result_opr() || threeOperandForm, &quot;opr1 and result must match&quot;);
 226       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 227       break;
 228 
 229     // special handling for lir_ushr because of write barriers
 230     case lir_ushr:
 231       assert(in_opr1() == result_opr() || in_opr2()-&gt;is_constant() || threeOperandForm, &quot;opr1 and result must match or shift count is constant&quot;);
 232       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 233       break;
 234 
 235     default:
 236       break;
 237     }
 238   }
 239 #endif
 240 }
 241 
 242 
 243 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BlockBegin* block)
 244   : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 245   , _cond(cond)
 246   , _label(block-&gt;label())
 247   , _block(block)
 248   , _ublock(NULL)
 249   , _stub(NULL) {
 250 }
 251 
 252 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, CodeStub* stub) :
 253   LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 254   , _cond(cond)
 255   , _label(stub-&gt;entry())
 256   , _block(NULL)
 257   , _ublock(NULL)
 258   , _stub(stub) {
 259 }
 260 
 261 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BlockBegin* block, BlockBegin* ublock)
 262   : LIR_Op(lir_cond_float_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 263   , _cond(cond)
 264   , _label(block-&gt;label())
 265   , _block(block)
 266   , _ublock(ublock)
 267   , _stub(NULL)
 268 {
 269 }
 270 
 271 void LIR_OpBranch::change_block(BlockBegin* b) {
 272   assert(_block != NULL, &quot;must have old block&quot;);
 273   assert(_block-&gt;label() == label(), &quot;must be equal&quot;);
 274 
 275   _block = b;
 276   _label = b-&gt;label();
 277 }
 278 
 279 void LIR_OpBranch::change_ublock(BlockBegin* b) {
 280   assert(_ublock != NULL, &quot;must have old block&quot;);
 281   _ublock = b;
 282 }
 283 
 284 void LIR_OpBranch::negate_cond() {
 285   switch (_cond) {
 286     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 287     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 288     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 289     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 290     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 291     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 292     default: ShouldNotReachHere();
 293   }
 294 }
 295 
 296 
 297 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 298                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 299                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
 300                                  CodeStub* stub, bool need_null_check)
 301 
 302   : LIR_Op(code, result, NULL)
 303   , _object(object)
 304   , _array(LIR_OprFact::illegalOpr)
 305   , _klass(klass)
 306   , _tmp1(tmp1)
 307   , _tmp2(tmp2)
 308   , _tmp3(tmp3)
 309   , _fast_check(fast_check)
 310   , _info_for_patch(info_for_patch)
 311   , _info_for_exception(info_for_exception)
 312   , _stub(stub)
 313   , _profiled_method(NULL)
 314   , _profiled_bci(-1)
 315   , _should_profile(false)
 316   , _need_null_check(need_null_check)
 317 {
 318   if (code == lir_checkcast) {
 319     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 320   } else if (code == lir_instanceof) {
 321     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 322   } else {
 323     ShouldNotReachHere();
 324   }
 325 }
 326 
 327 
 328 
 329 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 330   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 331   , _object(object)
 332   , _array(array)
 333   , _klass(NULL)
 334   , _tmp1(tmp1)
 335   , _tmp2(tmp2)
 336   , _tmp3(tmp3)
 337   , _fast_check(false)
 338   , _info_for_patch(NULL)
 339   , _info_for_exception(info_for_exception)
 340   , _stub(NULL)
 341   , _profiled_method(NULL)
 342   , _profiled_bci(-1)
 343   , _should_profile(false)
 344   , _need_null_check(true)
 345 {
 346   if (code == lir_store_check) {
 347     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 348     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 349   } else {
 350     ShouldNotReachHere();
 351   }
 352 }
 353 
 354 LIR_OpFlattenedArrayCheck::LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub)
 355   : LIR_Op(lir_flattened_array_check, LIR_OprFact::illegalOpr, NULL)
 356   , _array(array)
 357   , _value(value)
 358   , _tmp(tmp)
 359   , _stub(stub) {}
 360 
 361 
 362 LIR_OpNullFreeArrayCheck::LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp)
 363   : LIR_Op(lir_null_free_array_check, LIR_OprFact::illegalOpr, NULL)
 364   , _array(array)
 365   , _tmp(tmp) {}
 366 
 367 
 368 LIR_OpSubstitutabilityCheck::LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,
 369                                                          LIR_Opr tmp1, LIR_Opr tmp2,
 370                                                          ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,
 371                                                          CodeEmitInfo* info, CodeStub* stub)
 372   : LIR_Op(lir_substitutability_check, result, info)
 373   , _left(left)
 374   , _right(right)
 375   , _equal_result(equal_result)
 376   , _not_equal_result(not_equal_result)
 377   , _tmp1(tmp1)
 378   , _tmp2(tmp2)
 379   , _left_klass(left_klass)
 380   , _right_klass(right_klass)
 381   , _left_klass_op(left_klass_op)
 382   , _right_klass_op(right_klass_op)
 383   , _stub(stub) {}
 384 
 385 
 386 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 387                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 388   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 389   , _src(src)
 390   , _src_pos(src_pos)
 391   , _dst(dst)
 392   , _dst_pos(dst_pos)
 393   , _length(length)
 394   , _tmp(tmp)
 395   , _expected_type(expected_type)
 396   , _flags(flags) {
 397   _stub = new ArrayCopyStub(this);
 398 }
 399 
 400 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 401   : LIR_Op(lir_updatecrc32, res, NULL)
 402   , _crc(crc)
 403   , _val(val) {
 404 }
 405 
 406 //-------------------verify--------------------------
 407 
 408 void LIR_Op1::verify() const {
 409   switch(code()) {
 410   case lir_move:
 411     assert(in_opr()-&gt;is_valid() &amp;&amp; result_opr()-&gt;is_valid(), &quot;must be&quot;);
 412     break;
 413   case lir_null_check:
 414     assert(in_opr()-&gt;is_register(), &quot;must be&quot;);
 415     break;
 416   case lir_return:
 417     assert(in_opr()-&gt;is_register() || in_opr()-&gt;is_illegal(), &quot;must be&quot;);
 418     break;
 419   default:
 420     break;
 421   }
 422 }
 423 
 424 void LIR_OpRTCall::verify() const {
 425   assert(strcmp(Runtime1::name_for_address(addr()), &quot;&lt;unknown function&gt;&quot;) != 0, &quot;unknown function&quot;);
 426 }
 427 
 428 //-------------------visits--------------------------
 429 
 430 // complete rework of LIR instruction visitor.
 431 // The virtual call for each instruction type is replaced by a big
 432 // switch that adds the operands for each instruction
 433 
 434 void LIR_OpVisitState::visit(LIR_Op* op) {
 435   // copy information from the LIR_Op
 436   reset();
 437   set_op(op);
 438 
 439   switch (op-&gt;code()) {
 440 
 441 // LIR_Op0
 442     case lir_backwardbranch_target:    // result and info always invalid
 443     case lir_fpop_raw:                 // result and info always invalid
 444     case lir_breakpoint:               // result and info always invalid
 445     case lir_membar:                   // result and info always invalid
 446     case lir_membar_acquire:           // result and info always invalid
 447     case lir_membar_release:           // result and info always invalid
 448     case lir_membar_loadload:          // result and info always invalid
 449     case lir_membar_storestore:        // result and info always invalid
 450     case lir_membar_loadstore:         // result and info always invalid
 451     case lir_membar_storeload:         // result and info always invalid
 452     case lir_check_orig_pc:            // result and info always invalid
 453     case lir_on_spin_wait:
 454     {
 455       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 456       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 457       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 458       break;
 459     }
 460 
 461     case lir_nop:                      // may have info, result always invalid
 462     case lir_std_entry:                // may have result, info always invalid
 463     case lir_osr_entry:                // may have result, info always invalid
 464     case lir_get_thread:               // may have result, info always invalid
 465     {
 466       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 467       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 468       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 469       break;
 470     }
 471 
 472 
 473 // LIR_OpLabel
 474     case lir_label:                    // result and info always invalid
 475     {
 476       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 477       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 478       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 479       break;
 480     }
 481 
 482 
 483 // LIR_Op1
 484     case lir_fxch:           // input always valid, result and info always invalid
 485     case lir_fld:            // input always valid, result and info always invalid
 486     case lir_push:           // input always valid, result and info always invalid
 487     case lir_pop:            // input always valid, result and info always invalid
 488     case lir_return:         // input always valid, result and info always invalid
 489     case lir_leal:           // input and result always valid, info always invalid
 490     case lir_monaddr:        // input and result always valid, info always invalid
 491     case lir_null_check:     // input and info always valid, result always invalid
 492     case lir_move:           // input and result always valid, may have info
 493     {
 494       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 495       LIR_Op1* op1 = (LIR_Op1*)op;
 496 
 497       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 498       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 499       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 500 
 501       break;
 502     }
 503 
 504     case lir_safepoint:
 505     {
 506       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 507       LIR_Op1* op1 = (LIR_Op1*)op;
 508 
 509       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 510       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 511       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 512 
 513       break;
 514     }
 515 
 516 // LIR_OpConvert;
 517     case lir_convert:        // input and result always valid, info always invalid
 518     {
 519       assert(op-&gt;as_OpConvert() != NULL, &quot;must be&quot;);
 520       LIR_OpConvert* opConvert = (LIR_OpConvert*)op;
 521 
 522       assert(opConvert-&gt;_info == NULL, &quot;must be&quot;);
 523       if (opConvert-&gt;_opr-&gt;is_valid())       do_input(opConvert-&gt;_opr);
 524       if (opConvert-&gt;_result-&gt;is_valid())    do_output(opConvert-&gt;_result);
 525 #ifdef PPC32
 526       if (opConvert-&gt;_tmp1-&gt;is_valid())      do_temp(opConvert-&gt;_tmp1);
 527       if (opConvert-&gt;_tmp2-&gt;is_valid())      do_temp(opConvert-&gt;_tmp2);
 528 #endif
 529       do_stub(opConvert-&gt;_stub);
 530 
 531       break;
 532     }
 533 
 534 // LIR_OpBranch;
 535     case lir_branch:                   // may have info, input and result register always invalid
 536     case lir_cond_float_branch:        // may have info, input and result register always invalid
 537     {
 538       assert(op-&gt;as_OpBranch() != NULL, &quot;must be&quot;);
 539       LIR_OpBranch* opBranch = (LIR_OpBranch*)op;
 540 
 541       if (opBranch-&gt;_info != NULL)     do_info(opBranch-&gt;_info);
 542       assert(opBranch-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 543       if (opBranch-&gt;_stub != NULL)     opBranch-&gt;stub()-&gt;visit(this);
 544 
 545       break;
 546     }
 547 
 548 
 549 // LIR_OpAllocObj
 550     case lir_alloc_object:
 551     {
 552       assert(op-&gt;as_OpAllocObj() != NULL, &quot;must be&quot;);
 553       LIR_OpAllocObj* opAllocObj = (LIR_OpAllocObj*)op;
 554 
 555       if (opAllocObj-&gt;_info)                     do_info(opAllocObj-&gt;_info);
 556       if (opAllocObj-&gt;_opr-&gt;is_valid()) {        do_input(opAllocObj-&gt;_opr);
 557                                                  do_temp(opAllocObj-&gt;_opr);
 558                                         }
 559       if (opAllocObj-&gt;_tmp1-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp1);
 560       if (opAllocObj-&gt;_tmp2-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp2);
 561       if (opAllocObj-&gt;_tmp3-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp3);
 562       if (opAllocObj-&gt;_tmp4-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp4);
 563       if (opAllocObj-&gt;_result-&gt;is_valid())       do_output(opAllocObj-&gt;_result);
 564                                                  do_stub(opAllocObj-&gt;_stub);
 565       break;
 566     }
 567 
 568 
 569 // LIR_OpRoundFP;
 570     case lir_roundfp: {
 571       assert(op-&gt;as_OpRoundFP() != NULL, &quot;must be&quot;);
 572       LIR_OpRoundFP* opRoundFP = (LIR_OpRoundFP*)op;
 573 
 574       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 575       assert(opRoundFP-&gt;_tmp-&gt;is_illegal(), &quot;not used&quot;);
 576       do_input(opRoundFP-&gt;_opr);
 577       do_output(opRoundFP-&gt;_result);
 578 
 579       break;
 580     }
 581 
 582 
 583 // LIR_Op2
 584     case lir_cmp:
 585     case lir_cmp_l2i:
 586     case lir_ucmp_fd2i:
 587     case lir_cmp_fd2i:
 588     case lir_add:
 589     case lir_sub:
 590     case lir_mul:
 591     case lir_div:
 592     case lir_rem:
 593     case lir_sqrt:
 594     case lir_abs:
 595     case lir_neg:
 596     case lir_logic_and:
 597     case lir_logic_or:
 598     case lir_logic_xor:
 599     case lir_shl:
 600     case lir_shr:
 601     case lir_ushr:
 602     case lir_xadd:
 603     case lir_xchg:
 604     case lir_assert:
 605     {
 606       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 607       LIR_Op2* op2 = (LIR_Op2*)op;
 608       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 609              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 610 
 611       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 612       if (op2-&gt;_opr1-&gt;is_valid())         do_input(op2-&gt;_opr1);
 613       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2);
 614       if (op2-&gt;_tmp1-&gt;is_valid())         do_temp(op2-&gt;_tmp1);
 615       if (op2-&gt;_result-&gt;is_valid())       do_output(op2-&gt;_result);
 616       if (op-&gt;code() == lir_xchg || op-&gt;code() == lir_xadd) {
 617         // on ARM and PPC, return value is loaded first so could
 618         // destroy inputs. On other platforms that implement those
 619         // (x86, sparc), the extra constrainsts are harmless.
 620         if (op2-&gt;_opr1-&gt;is_valid())       do_temp(op2-&gt;_opr1);
 621         if (op2-&gt;_opr2-&gt;is_valid())       do_temp(op2-&gt;_opr2);
 622       }
 623 
 624       break;
 625     }
 626 
 627     // special handling for cmove: right input operand must not be equal
 628     // to the result operand, otherwise the backend fails
 629     case lir_cmove:
 630     {
 631       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 632       LIR_Op2* op2 = (LIR_Op2*)op;
 633 
 634       assert(op2-&gt;_info == NULL &amp;&amp; op2-&gt;_tmp1-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp;
 635              op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 636       assert(op2-&gt;_opr1-&gt;is_valid() &amp;&amp; op2-&gt;_opr2-&gt;is_valid() &amp;&amp; op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 637 
 638       do_input(op2-&gt;_opr1);
 639       do_input(op2-&gt;_opr2);
 640       do_temp(op2-&gt;_opr2);
 641       do_output(op2-&gt;_result);
 642 
 643       break;
 644     }
 645 
 646     // vspecial handling for strict operations: register input operands
 647     // as temp to guarantee that they do not overlap with other
 648     // registers
 649     case lir_mul_strictfp:
 650     case lir_div_strictfp:
 651     {
 652       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 653       LIR_Op2* op2 = (LIR_Op2*)op;
 654 
 655       assert(op2-&gt;_info == NULL, &quot;not used&quot;);
 656       assert(op2-&gt;_opr1-&gt;is_valid(), &quot;used&quot;);
 657       assert(op2-&gt;_opr2-&gt;is_valid(), &quot;used&quot;);
 658       assert(op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 659       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 660              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 661 
 662       do_input(op2-&gt;_opr1); do_temp(op2-&gt;_opr1);
 663       do_input(op2-&gt;_opr2); do_temp(op2-&gt;_opr2);
 664       if (op2-&gt;_tmp1-&gt;is_valid()) do_temp(op2-&gt;_tmp1);
 665       do_output(op2-&gt;_result);
 666 
 667       break;
 668     }
 669 
 670     case lir_throw: {
 671       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 672       LIR_Op2* op2 = (LIR_Op2*)op;
 673 
 674       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 675       if (op2-&gt;_opr1-&gt;is_valid())         do_temp(op2-&gt;_opr1);
 676       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2); // exception object is input parameter
 677       assert(op2-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 678       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 679              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 680 
 681       break;
 682     }
 683 
 684     case lir_unwind: {
 685       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 686       LIR_Op1* op1 = (LIR_Op1*)op;
 687 
 688       assert(op1-&gt;_info == NULL, &quot;no info&quot;);
 689       assert(op1-&gt;_opr-&gt;is_valid(), &quot;exception oop&quot;);         do_input(op1-&gt;_opr);
 690       assert(op1-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 691 
 692       break;
 693     }
 694 
 695 // LIR_Op3
 696     case lir_idiv:
 697     case lir_irem: {
 698       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 699       LIR_Op3* op3= (LIR_Op3*)op;
 700 
 701       if (op3-&gt;_info)                     do_info(op3-&gt;_info);
 702       if (op3-&gt;_opr1-&gt;is_valid())         do_input(op3-&gt;_opr1);
 703 
 704       // second operand is input and temp, so ensure that second operand
 705       // and third operand get not the same register
 706       if (op3-&gt;_opr2-&gt;is_valid())         do_input(op3-&gt;_opr2);
 707       if (op3-&gt;_opr2-&gt;is_valid())         do_temp(op3-&gt;_opr2);
 708       if (op3-&gt;_opr3-&gt;is_valid())         do_temp(op3-&gt;_opr3);
 709 
 710       if (op3-&gt;_result-&gt;is_valid())       do_output(op3-&gt;_result);
 711 
 712       break;
 713     }
 714 
 715     case lir_fmad:
 716     case lir_fmaf: {
 717       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 718       LIR_Op3* op3= (LIR_Op3*)op;
 719       assert(op3-&gt;_info == NULL, &quot;no info&quot;);
 720       do_input(op3-&gt;_opr1);
 721       do_input(op3-&gt;_opr2);
 722       do_input(op3-&gt;_opr3);
 723       do_output(op3-&gt;_result);
 724       break;
 725     }
 726 
 727 // LIR_OpJavaCall
 728     case lir_static_call:
 729     case lir_optvirtual_call:
 730     case lir_icvirtual_call:
 731     case lir_virtual_call:
 732     case lir_dynamic_call: {
 733       LIR_OpJavaCall* opJavaCall = op-&gt;as_OpJavaCall();
 734       assert(opJavaCall != NULL, &quot;must be&quot;);
 735 
 736       if (opJavaCall-&gt;_receiver-&gt;is_valid())     do_input(opJavaCall-&gt;_receiver);
 737 
 738       // only visit register parameters
 739       int n = opJavaCall-&gt;_arguments-&gt;length();
 740       for (int i = opJavaCall-&gt;_receiver-&gt;is_valid() ? 1 : 0; i &lt; n; i++) {
 741         if (!opJavaCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 742           do_input(*opJavaCall-&gt;_arguments-&gt;adr_at(i));
 743         }
 744       }
 745 
 746       if (opJavaCall-&gt;_info)                     do_info(opJavaCall-&gt;_info);
 747       if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &amp;&amp;
 748           opJavaCall-&gt;is_method_handle_invoke()) {
 749         opJavaCall-&gt;_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();
 750         do_temp(opJavaCall-&gt;_method_handle_invoke_SP_save_opr);
 751       }
 752       do_call();
 753       if (opJavaCall-&gt;_result-&gt;is_valid())       do_output(opJavaCall-&gt;_result);
 754 
 755       break;
 756     }
 757 
 758 
 759 // LIR_OpRTCall
 760     case lir_rtcall: {
 761       assert(op-&gt;as_OpRTCall() != NULL, &quot;must be&quot;);
 762       LIR_OpRTCall* opRTCall = (LIR_OpRTCall*)op;
 763 
 764       // only visit register parameters
 765       int n = opRTCall-&gt;_arguments-&gt;length();
 766       for (int i = 0; i &lt; n; i++) {
 767         if (!opRTCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 768           do_input(*opRTCall-&gt;_arguments-&gt;adr_at(i));
 769         }
 770       }
 771       if (opRTCall-&gt;_info)                     do_info(opRTCall-&gt;_info);
 772       if (opRTCall-&gt;_tmp-&gt;is_valid())          do_temp(opRTCall-&gt;_tmp);
 773       do_call();
 774       if (opRTCall-&gt;_result-&gt;is_valid())       do_output(opRTCall-&gt;_result);
 775 
 776       break;
 777     }
 778 
 779 
 780 // LIR_OpArrayCopy
 781     case lir_arraycopy: {
 782       assert(op-&gt;as_OpArrayCopy() != NULL, &quot;must be&quot;);
 783       LIR_OpArrayCopy* opArrayCopy = (LIR_OpArrayCopy*)op;
 784 
 785       assert(opArrayCopy-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 786       assert(opArrayCopy-&gt;_src-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_src);     do_temp(opArrayCopy-&gt;_src);
 787       assert(opArrayCopy-&gt;_src_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_src_pos); do_temp(opArrayCopy-&gt;_src_pos);
 788       assert(opArrayCopy-&gt;_dst-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_dst);     do_temp(opArrayCopy-&gt;_dst);
 789       assert(opArrayCopy-&gt;_dst_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_dst_pos); do_temp(opArrayCopy-&gt;_dst_pos);
 790       assert(opArrayCopy-&gt;_length-&gt;is_valid(), &quot;used&quot;);       do_input(opArrayCopy-&gt;_length);  do_temp(opArrayCopy-&gt;_length);
 791       assert(opArrayCopy-&gt;_tmp-&gt;is_valid(), &quot;used&quot;);          do_temp(opArrayCopy-&gt;_tmp);
 792       if (opArrayCopy-&gt;_info)                     do_info(opArrayCopy-&gt;_info);
 793 
 794       // the implementation of arraycopy always has a call into the runtime
 795       do_call();
 796 
 797       break;
 798     }
 799 
 800 
 801 // LIR_OpUpdateCRC32
 802     case lir_updatecrc32: {
 803       assert(op-&gt;as_OpUpdateCRC32() != NULL, &quot;must be&quot;);
 804       LIR_OpUpdateCRC32* opUp = (LIR_OpUpdateCRC32*)op;
 805 
 806       assert(opUp-&gt;_crc-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_crc);     do_temp(opUp-&gt;_crc);
 807       assert(opUp-&gt;_val-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_val);     do_temp(opUp-&gt;_val);
 808       assert(opUp-&gt;_result-&gt;is_valid(), &quot;used&quot;);       do_output(opUp-&gt;_result);
 809       assert(opUp-&gt;_info == NULL, &quot;no info for LIR_OpUpdateCRC32&quot;);
 810 
 811       break;
 812     }
 813 
 814 
 815 // LIR_OpLock
 816     case lir_lock:
 817     case lir_unlock: {
 818       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 819       LIR_OpLock* opLock = (LIR_OpLock*)op;
 820 
 821       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 822 
 823       // TODO: check if these operands really have to be temp
 824       // (or if input is sufficient). This may have influence on the oop map!
 825       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 826       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 827       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 828 
 829       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 830       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 831 
 832       do_stub(opLock-&gt;_stub);
 833       do_stub(opLock-&gt;_throw_imse_stub);
 834 
 835       break;
 836     }
 837 
 838 
 839 // LIR_OpDelay
 840     case lir_delay_slot: {
 841       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 842       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 843 
 844       visit(opDelay-&gt;delay_op());
 845       break;
 846     }
 847 
 848 // LIR_OpTypeCheck
 849     case lir_instanceof:
 850     case lir_checkcast:
 851     case lir_store_check: {
 852       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 853       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 854 
 855       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 856       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 857       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 858       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 859         do_temp(opTypeCheck-&gt;_object);
 860       }
 861       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 862       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 863       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 864       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 865       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 866                                                   do_stub(opTypeCheck-&gt;_stub);
 867       break;
 868     }
 869 
 870 // LIR_OpFlattenedArrayCheck
 871     case lir_flattened_array_check: {
 872       assert(op-&gt;as_OpFlattenedArrayCheck() != NULL, &quot;must be&quot;);
 873       LIR_OpFlattenedArrayCheck* opFlattenedArrayCheck = (LIR_OpFlattenedArrayCheck*)op;
 874 
 875       if (opFlattenedArrayCheck-&gt;_array-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_array);
 876       if (opFlattenedArrayCheck-&gt;_value-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_value);
 877       if (opFlattenedArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opFlattenedArrayCheck-&gt;_tmp);
 878                                                      do_stub(opFlattenedArrayCheck-&gt;_stub);
 879 
 880       break;
 881     }
 882 
 883 // LIR_OpNullFreeArrayCheck
 884     case lir_null_free_array_check: {
 885       assert(op-&gt;as_OpNullFreeArrayCheck() != NULL, &quot;must be&quot;);
 886       LIR_OpNullFreeArrayCheck* opNullFreeArrayCheck = (LIR_OpNullFreeArrayCheck*)op;
 887 
 888       if (opNullFreeArrayCheck-&gt;_array-&gt;is_valid()) do_input(opNullFreeArrayCheck-&gt;_array);
 889       if (opNullFreeArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opNullFreeArrayCheck-&gt;_tmp);
 890       break;
 891     }
 892 
 893 // LIR_OpSubstitutabilityCheck
 894     case lir_substitutability_check: {
 895       assert(op-&gt;as_OpSubstitutabilityCheck() != NULL, &quot;must be&quot;);
 896       LIR_OpSubstitutabilityCheck* opSubstitutabilityCheck = (LIR_OpSubstitutabilityCheck*)op;
 897                                                                 do_input(opSubstitutabilityCheck-&gt;_left);
 898                                                                 do_temp (opSubstitutabilityCheck-&gt;_left);
 899                                                                 do_input(opSubstitutabilityCheck-&gt;_right);
 900                                                                 do_temp (opSubstitutabilityCheck-&gt;_right);
 901                                                                 do_input(opSubstitutabilityCheck-&gt;_equal_result);
 902                                                                 do_temp (opSubstitutabilityCheck-&gt;_equal_result);
 903                                                                 do_input(opSubstitutabilityCheck-&gt;_not_equal_result);
 904                                                                 do_temp (opSubstitutabilityCheck-&gt;_not_equal_result);
 905       if (opSubstitutabilityCheck-&gt;_tmp1-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp1);
 906       if (opSubstitutabilityCheck-&gt;_tmp2-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp2);
 907       if (opSubstitutabilityCheck-&gt;_left_klass_op-&gt;is_valid())  do_temp(opSubstitutabilityCheck-&gt;_left_klass_op);
 908       if (opSubstitutabilityCheck-&gt;_right_klass_op-&gt;is_valid()) do_temp(opSubstitutabilityCheck-&gt;_right_klass_op);
 909       if (opSubstitutabilityCheck-&gt;_result-&gt;is_valid())         do_output(opSubstitutabilityCheck-&gt;_result);
 910                                                                 do_info(opSubstitutabilityCheck-&gt;_info);
 911                                                                 do_stub(opSubstitutabilityCheck-&gt;_stub);
 912       break;
 913     }
 914 
 915 // LIR_OpCompareAndSwap
 916     case lir_cas_long:
 917     case lir_cas_obj:
 918     case lir_cas_int: {
 919       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 920       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 921 
 922       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 923       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 924       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 925       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 926                                                       do_input(opCompareAndSwap-&gt;_addr);
 927                                                       do_temp(opCompareAndSwap-&gt;_addr);
 928                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 929                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 930                                                       do_input(opCompareAndSwap-&gt;_new_value);
 931                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 932       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 933       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 934       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
 935 
 936       break;
 937     }
 938 
 939 
 940 // LIR_OpAllocArray;
 941     case lir_alloc_array: {
 942       assert(op-&gt;as_OpAllocArray() != NULL, &quot;must be&quot;);
 943       LIR_OpAllocArray* opAllocArray = (LIR_OpAllocArray*)op;
 944 
 945       if (opAllocArray-&gt;_info)                        do_info(opAllocArray-&gt;_info);
 946       if (opAllocArray-&gt;_klass-&gt;is_valid())           do_input(opAllocArray-&gt;_klass); do_temp(opAllocArray-&gt;_klass);
 947       if (opAllocArray-&gt;_len-&gt;is_valid())             do_input(opAllocArray-&gt;_len);   do_temp(opAllocArray-&gt;_len);
 948       if (opAllocArray-&gt;_tmp1-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp1);
 949       if (opAllocArray-&gt;_tmp2-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp2);
 950       if (opAllocArray-&gt;_tmp3-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp3);
 951       if (opAllocArray-&gt;_tmp4-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp4);
 952       if (opAllocArray-&gt;_result-&gt;is_valid())          do_output(opAllocArray-&gt;_result);
 953                                                       do_stub(opAllocArray-&gt;_stub);
 954       break;
 955     }
 956 
 957 // LIR_OpProfileCall:
 958     case lir_profile_call: {
 959       assert(op-&gt;as_OpProfileCall() != NULL, &quot;must be&quot;);
 960       LIR_OpProfileCall* opProfileCall = (LIR_OpProfileCall*)op;
 961 
 962       if (opProfileCall-&gt;_recv-&gt;is_valid())              do_temp(opProfileCall-&gt;_recv);
 963       assert(opProfileCall-&gt;_mdo-&gt;is_valid(), &quot;used&quot;);   do_temp(opProfileCall-&gt;_mdo);
 964       assert(opProfileCall-&gt;_tmp1-&gt;is_valid(), &quot;used&quot;);  do_temp(opProfileCall-&gt;_tmp1);
 965       break;
 966     }
 967 
 968 // LIR_OpProfileType:
 969     case lir_profile_type: {
 970       assert(op-&gt;as_OpProfileType() != NULL, &quot;must be&quot;);
 971       LIR_OpProfileType* opProfileType = (LIR_OpProfileType*)op;
 972 
 973       do_input(opProfileType-&gt;_mdp); do_temp(opProfileType-&gt;_mdp);
 974       do_input(opProfileType-&gt;_obj);
 975       do_temp(opProfileType-&gt;_tmp);
 976       break;
 977     }
 978   default:
 979     op-&gt;visit(this);
 980   }
 981 }
 982 
 983 void LIR_Op::visit(LIR_OpVisitState* state) {
 984   ShouldNotReachHere();
 985 }
 986 
 987 void LIR_OpVisitState::do_stub(CodeStub* stub) {
 988   if (stub != NULL) {
 989     stub-&gt;visit(this);
 990   }
 991 }
 992 
 993 XHandlers* LIR_OpVisitState::all_xhandler() {
 994   XHandlers* result = NULL;
 995 
 996   int i;
 997   for (i = 0; i &lt; info_count(); i++) {
 998     if (info_at(i)-&gt;exception_handlers() != NULL) {
 999       result = info_at(i)-&gt;exception_handlers();
1000       break;
1001     }
1002   }
1003 
1004 #ifdef ASSERT
1005   for (i = 0; i &lt; info_count(); i++) {
1006     assert(info_at(i)-&gt;exception_handlers() == NULL ||
1007            info_at(i)-&gt;exception_handlers() == result,
1008            &quot;only one xhandler list allowed per LIR-operation&quot;);
1009   }
1010 #endif
1011 
1012   if (result != NULL) {
1013     return result;
1014   } else {
1015     return new XHandlers();
1016   }
1017 
1018   return result;
1019 }
1020 
1021 
1022 #ifdef ASSERT
1023 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
1024   visit(op);
1025 
1026   return opr_count(inputMode) == 0 &amp;&amp;
1027          opr_count(outputMode) == 0 &amp;&amp;
1028          opr_count(tempMode) == 0 &amp;&amp;
1029          info_count() == 0 &amp;&amp;
1030          !has_call() &amp;&amp;
1031          !has_slow_case();
1032 }
1033 #endif
1034 
1035 //---------------------------------------------------
1036 
1037 
1038 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
1039   masm-&gt;emit_call(this);
1040 }
1041 
1042 bool LIR_OpJavaCall::maybe_return_as_fields(ciInlineKlass** vk_ret) const {
1043   if (InlineTypeReturnedAsFields) {
1044     if (method()-&gt;signature()-&gt;maybe_returns_inline_type()) {
1045       ciType* return_type = method()-&gt;return_type();
1046       if (return_type-&gt;is_inlinetype()) {
1047         ciInlineKlass* vk = return_type-&gt;as_inline_klass();
1048         if (vk-&gt;can_be_returned_as_fields()) {
1049           if (vk_ret != NULL) {
1050             *vk_ret = vk;
1051           }
1052           return true;
1053         }
1054       } else {
1055         assert(return_type-&gt;is_instance_klass() &amp;&amp; !return_type-&gt;as_instance_klass()-&gt;is_loaded(), &quot;must be&quot;);
1056         if (vk_ret != NULL) {
1057           *vk_ret = NULL;
1058         }
1059         return true;
1060       }
1061     } else if (is_method_handle_invoke()) {
1062       BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1063       if (bt == T_OBJECT || bt == T_INLINE_TYPE) {
1064         // An inline type might be returned from the call but we don&#39;t know its
1065         // type. Either we get a buffered inline type (and nothing needs to be done)
1066         // or one of the inlines being returned is the klass of the inline type
1067         // (RAX on x64, with LSB set to 1) and we need to allocate an inline
1068         // type instance of that type and initialize it with other values being
1069         // returned (in other registers).
1070         // type.
1071         if (vk_ret != NULL) {
1072           *vk_ret = NULL;
1073         }
1074         return true;
1075       }
1076     }
1077   }
1078   return false;
1079 }
1080 
1081 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
1082   masm-&gt;emit_rtcall(this);
1083 }
1084 
1085 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
1086   masm-&gt;emit_opLabel(this);
1087 }
1088 
1089 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
1090   masm-&gt;emit_arraycopy(this);
1091   masm-&gt;append_code_stub(stub());
1092 }
1093 
1094 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
1095   masm-&gt;emit_updatecrc32(this);
1096 }
1097 
1098 void LIR_Op0::emit_code(LIR_Assembler* masm) {
1099   masm-&gt;emit_op0(this);
1100 }
1101 
1102 void LIR_Op1::emit_code(LIR_Assembler* masm) {
1103   masm-&gt;emit_op1(this);
1104 }
1105 
1106 void LIR_OpAllocObj::emit_code(LIR_Assembler* masm) {
1107   masm-&gt;emit_alloc_obj(this);
1108   masm-&gt;append_code_stub(stub());
1109 }
1110 
1111 void LIR_OpBranch::emit_code(LIR_Assembler* masm) {
1112   masm-&gt;emit_opBranch(this);
1113   if (stub()) {
1114     masm-&gt;append_code_stub(stub());
1115   }
1116 }
1117 
1118 void LIR_OpConvert::emit_code(LIR_Assembler* masm) {
1119   masm-&gt;emit_opConvert(this);
1120   if (stub() != NULL) {
1121     masm-&gt;append_code_stub(stub());
1122   }
1123 }
1124 
1125 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1126   masm-&gt;emit_op2(this);
1127 }
1128 
1129 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1130   masm-&gt;emit_alloc_array(this);
1131   masm-&gt;append_code_stub(stub());
1132 }
1133 
1134 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1135   masm-&gt;emit_opTypeCheck(this);
1136   if (stub()) {
1137     masm-&gt;append_code_stub(stub());
1138   }
1139 }
1140 
1141 void LIR_OpFlattenedArrayCheck::emit_code(LIR_Assembler* masm) {
1142   masm-&gt;emit_opFlattenedArrayCheck(this);
1143   if (stub() != NULL) {
1144     masm-&gt;append_code_stub(stub());
1145   }
1146 }
1147 
1148 void LIR_OpNullFreeArrayCheck::emit_code(LIR_Assembler* masm) {
1149   masm-&gt;emit_opNullFreeArrayCheck(this);
1150 }
1151 
1152 void LIR_OpSubstitutabilityCheck::emit_code(LIR_Assembler* masm) {
1153   masm-&gt;emit_opSubstitutabilityCheck(this);
1154   if (stub() != NULL) {
1155     masm-&gt;append_code_stub(stub());
1156   }
1157 }
1158 
1159 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1160   masm-&gt;emit_compare_and_swap(this);
1161 }
1162 
1163 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1164   masm-&gt;emit_op3(this);
1165 }
1166 
1167 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1168   masm-&gt;emit_lock(this);
1169   if (stub()) {
1170     masm-&gt;append_code_stub(stub());
1171   }
1172   if (throw_imse_stub()) {
1173     masm-&gt;append_code_stub(throw_imse_stub());
1174   }
1175 }
1176 
1177 #ifdef ASSERT
1178 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1179   masm-&gt;emit_assert(this);
1180 }
1181 #endif
1182 
1183 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1184   masm-&gt;emit_delay(this);
1185 }
1186 
1187 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1188   masm-&gt;emit_profile_call(this);
1189 }
1190 
1191 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1192   masm-&gt;emit_profile_type(this);
1193 }
1194 
1195 // LIR_List
1196 LIR_List::LIR_List(Compilation* compilation, BlockBegin* block)
1197   : _operations(8)
1198   , _compilation(compilation)
1199 #ifndef PRODUCT
1200   , _block(block)
1201 #endif
1202 #ifdef ASSERT
1203   , _file(NULL)
1204   , _line(0)
1205 #endif
1206 { }
1207 
1208 
1209 #ifdef ASSERT
1210 void LIR_List::set_file_and_line(const char * file, int line) {
1211   const char * f = strrchr(file, &#39;/&#39;);
1212   if (f == NULL) f = strrchr(file, &#39;\\&#39;);
1213   if (f == NULL) {
1214     f = file;
1215   } else {
1216     f++;
1217   }
1218   _file = f;
1219   _line = line;
1220 }
1221 #endif
1222 
1223 
1224 void LIR_List::append(LIR_InsertionBuffer* buffer) {
1225   assert(this == buffer-&gt;lir_list(), &quot;wrong lir list&quot;);
1226   const int n = _operations.length();
1227 
1228   if (buffer-&gt;number_of_ops() &gt; 0) {
1229     // increase size of instructions list
1230     _operations.at_grow(n + buffer-&gt;number_of_ops() - 1, NULL);
1231     // insert ops from buffer into instructions list
1232     int op_index = buffer-&gt;number_of_ops() - 1;
1233     int ip_index = buffer-&gt;number_of_insertion_points() - 1;
1234     int from_index = n - 1;
1235     int to_index = _operations.length() - 1;
1236     for (; ip_index &gt;= 0; ip_index --) {
1237       int index = buffer-&gt;index_at(ip_index);
1238       // make room after insertion point
1239       while (index &lt; from_index) {
1240         _operations.at_put(to_index --, _operations.at(from_index --));
1241       }
1242       // insert ops from buffer
1243       for (int i = buffer-&gt;count_at(ip_index); i &gt; 0; i --) {
1244         _operations.at_put(to_index --, buffer-&gt;op_at(op_index --));
1245       }
1246     }
1247   }
1248 
1249   buffer-&gt;finish();
1250 }
1251 
1252 
1253 void LIR_List::oop2reg_patch(jobject o, LIR_Opr reg, CodeEmitInfo* info) {
1254   assert(reg-&gt;type() == T_OBJECT, &quot;bad reg&quot;);
1255   append(new LIR_Op1(lir_move, LIR_OprFact::oopConst(o),  reg, T_OBJECT, lir_patch_normal, info));
1256 }
1257 
1258 void LIR_List::klass2reg_patch(Metadata* o, LIR_Opr reg, CodeEmitInfo* info) {
1259   assert(reg-&gt;type() == T_METADATA, &quot;bad reg&quot;);
1260   append(new LIR_Op1(lir_move, LIR_OprFact::metadataConst(o), reg, T_METADATA, lir_patch_normal, info));
1261 }
1262 
1263 void LIR_List::load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1264   append(new LIR_Op1(
1265             lir_move,
1266             LIR_OprFact::address(addr),
1267             src,
1268             addr-&gt;type(),
1269             patch_code,
1270             info));
1271 }
1272 
1273 
1274 void LIR_List::volatile_load_mem_reg(LIR_Address* address, LIR_Opr dst, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1275   append(new LIR_Op1(
1276             lir_move,
1277             LIR_OprFact::address(address),
1278             dst,
1279             address-&gt;type(),
1280             patch_code,
1281             info, lir_move_volatile));
1282 }
1283 
1284 void LIR_List::volatile_load_unsafe_reg(LIR_Opr base, LIR_Opr offset, LIR_Opr dst, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1285   append(new LIR_Op1(
1286             lir_move,
1287             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1288             dst,
1289             type,
1290             patch_code,
1291             info, lir_move_volatile));
1292 }
1293 
1294 
1295 void LIR_List::store_mem_int(jint v, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1296   append(new LIR_Op1(
1297             lir_move,
1298             LIR_OprFact::intConst(v),
1299             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1300             type,
1301             patch_code,
1302             info));
1303 }
1304 
1305 
1306 void LIR_List::store_mem_oop(jobject o, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1307   append(new LIR_Op1(
1308             lir_move,
1309             LIR_OprFact::oopConst(o),
1310             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1311             type,
1312             patch_code,
1313             info));
1314 }
1315 
1316 
1317 void LIR_List::store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1318   append(new LIR_Op1(
1319             lir_move,
1320             src,
1321             LIR_OprFact::address(addr),
1322             addr-&gt;type(),
1323             patch_code,
1324             info));
1325 }
1326 
1327 
1328 void LIR_List::volatile_store_mem_reg(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1329   append(new LIR_Op1(
1330             lir_move,
1331             src,
1332             LIR_OprFact::address(addr),
1333             addr-&gt;type(),
1334             patch_code,
1335             info,
1336             lir_move_volatile));
1337 }
1338 
1339 void LIR_List::volatile_store_unsafe_reg(LIR_Opr src, LIR_Opr base, LIR_Opr offset, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1340   append(new LIR_Op1(
1341             lir_move,
1342             src,
1343             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1344             type,
1345             patch_code,
1346             info, lir_move_volatile));
1347 }
1348 
1349 
1350 void LIR_List::idiv(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1351   append(new LIR_Op3(
1352                     lir_idiv,
1353                     left,
1354                     right,
1355                     tmp,
1356                     res,
1357                     info));
1358 }
1359 
1360 
1361 void LIR_List::idiv(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1362   append(new LIR_Op3(
1363                     lir_idiv,
1364                     left,
1365                     LIR_OprFact::intConst(right),
1366                     tmp,
1367                     res,
1368                     info));
1369 }
1370 
1371 
1372 void LIR_List::irem(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1373   append(new LIR_Op3(
1374                     lir_irem,
1375                     left,
1376                     right,
1377                     tmp,
1378                     res,
1379                     info));
1380 }
1381 
1382 
1383 void LIR_List::irem(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1384   append(new LIR_Op3(
1385                     lir_irem,
1386                     left,
1387                     LIR_OprFact::intConst(right),
1388                     tmp,
1389                     res,
1390                     info));
1391 }
1392 
1393 
1394 void LIR_List::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
1395   append(new LIR_Op2(
1396                     lir_cmp,
1397                     condition,
1398                     LIR_OprFact::address(new LIR_Address(base, disp, T_INT)),
1399                     LIR_OprFact::intConst(c),
1400                     info));
1401 }
1402 
1403 
1404 void LIR_List::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Address* addr, CodeEmitInfo* info) {
1405   append(new LIR_Op2(
1406                     lir_cmp,
1407                     condition,
1408                     reg,
1409                     LIR_OprFact::address(addr),
1410                     info));
1411 }
1412 
1413 void LIR_List::allocate_object(LIR_Opr dst, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4,
1414                                int header_size, int object_size, LIR_Opr klass, bool init_check, CodeStub* stub) {
1415   append(new LIR_OpAllocObj(
1416                            klass,
1417                            dst,
1418                            t1,
1419                            t2,
1420                            t3,
1421                            t4,
1422                            header_size,
1423                            object_size,
1424                            init_check,
1425                            stub));
1426 }
1427 
1428 void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {
1429   append(new LIR_OpAllocArray(
1430                            klass,
1431                            len,
1432                            dst,
1433                            t1,
1434                            t2,
1435                            t3,
1436                            t4,
1437                            type,
1438                            stub));
1439 }
1440 
1441 void LIR_List::shift_left(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1442  append(new LIR_Op2(
1443                     lir_shl,
1444                     value,
1445                     count,
1446                     dst,
1447                     tmp));
1448 }
1449 
1450 void LIR_List::shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1451  append(new LIR_Op2(
1452                     lir_shr,
1453                     value,
1454                     count,
1455                     dst,
1456                     tmp));
1457 }
1458 
1459 
1460 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1461  append(new LIR_Op2(
1462                     lir_ushr,
1463                     value,
1464                     count,
1465                     dst,
1466                     tmp));
1467 }
1468 
1469 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1470   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1471                      left,
1472                      right,
1473                      dst));
1474 }
1475 
1476 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub) {
1477   append(new LIR_OpLock(
1478                     lir_lock,
1479                     hdr,
1480                     obj,
1481                     lock,
1482                     scratch,
1483                     stub,
1484                     info,
1485                     throw_imse_stub));
1486 }
1487 
1488 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1489   append(new LIR_OpLock(
1490                     lir_unlock,
1491                     hdr,
1492                     obj,
1493                     lock,
1494                     scratch,
1495                     stub,
1496                     NULL));
1497 }
1498 
1499 
1500 void check_LIR() {
1501   // cannot do the proper checking as PRODUCT and other modes return different results
1502   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1503 }
1504 
1505 
1506 
1507 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1508                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1509                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
1510                           ciMethod* profiled_method, int profiled_bci, bool is_never_null) {
1511   // If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check
1512   // on the object.
1513   bool need_null_check = !is_never_null;
1514   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
1515                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,
1516                                            need_null_check);
1517   if (profiled_method != NULL) {
1518     c-&gt;set_profiled_method(profiled_method);
1519     c-&gt;set_profiled_bci(profiled_bci);
1520     c-&gt;set_should_profile(true);
1521   }
1522   append(c);
1523 }
1524 
1525 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1526   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1527   if (profiled_method != NULL) {
1528     c-&gt;set_profiled_method(profiled_method);
1529     c-&gt;set_profiled_bci(profiled_bci);
1530     c-&gt;set_should_profile(true);
1531   }
1532   append(c);
1533 }
1534 
1535 
1536 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1537                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
1538   // FIXME -- if the types of the array and/or the object are known statically, we can avoid loading the klass
1539   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1540   if (profiled_method != NULL) {
1541     c-&gt;set_profiled_method(profiled_method);
1542     c-&gt;set_profiled_bci(profiled_bci);
1543     c-&gt;set_should_profile(true);
1544   }
1545   append(c);
1546 }
1547 
1548 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1549   if (deoptimize_on_null) {
1550     // Emit an explicit null check and deoptimize if opr is null
1551     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1552     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1553     branch(lir_cond_equal, deopt);
1554   } else {
1555     // Emit an implicit null check
1556     append(new LIR_Op1(lir_null_check, opr, info));
1557   }
1558 }
1559 
1560 void LIR_List::check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {
1561   LIR_OpFlattenedArrayCheck* c = new LIR_OpFlattenedArrayCheck(array, value, tmp, stub);
1562   append(c);
1563 }
1564 
1565 void LIR_List::check_null_free_array(LIR_Opr array, LIR_Opr tmp) {
1566   LIR_OpNullFreeArrayCheck* c = new LIR_OpNullFreeArrayCheck(array, tmp);
1567   append(c);
1568 }
1569 
1570 void LIR_List::substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,
1571                                       LIR_Opr tmp1, LIR_Opr tmp2,
1572                                       ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,
1573                                       CodeEmitInfo* info, CodeStub* stub) {
1574   LIR_OpSubstitutabilityCheck* c = new LIR_OpSubstitutabilityCheck(result, left, right, equal_result, not_equal_result,
1575                                                                    tmp1, tmp2,
1576                                                                    left_klass, right_klass, left_klass_op, right_klass_op,
1577                                                                    info, stub);
1578   append(c);
1579 }
1580 
1581 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1582                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1583   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1584 }
1585 
1586 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1587                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1588   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1589 }
1590 
1591 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1592                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1593   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1594 }
1595 
1596 
1597 #ifdef PRODUCT
1598 
1599 void print_LIR(BlockList* blocks) {
1600 }
1601 
1602 #else
1603 // LIR_OprDesc
1604 void LIR_OprDesc::print() const {
1605   print(tty);
1606 }
1607 
1608 void LIR_OprDesc::print(outputStream* out) const {
1609   if (is_illegal()) {
1610     return;
1611   }
1612 
1613   out-&gt;print(&quot;[&quot;);
1614   if (is_pointer()) {
1615     pointer()-&gt;print_value_on(out);
1616   } else if (is_single_stack()) {
1617     out-&gt;print(&quot;stack:%d&quot;, single_stack_ix());
1618   } else if (is_double_stack()) {
1619     out-&gt;print(&quot;dbl_stack:%d&quot;,double_stack_ix());
1620   } else if (is_virtual()) {
1621     out-&gt;print(&quot;R%d&quot;, vreg_number());
1622   } else if (is_single_cpu()) {
1623     out-&gt;print(&quot;%s&quot;, as_register()-&gt;name());
1624   } else if (is_double_cpu()) {
1625     out-&gt;print(&quot;%s&quot;, as_register_hi()-&gt;name());
1626     out-&gt;print(&quot;%s&quot;, as_register_lo()-&gt;name());
1627 #if defined(X86)
1628   } else if (is_single_xmm()) {
1629     out-&gt;print(&quot;%s&quot;, as_xmm_float_reg()-&gt;name());
1630   } else if (is_double_xmm()) {
1631     out-&gt;print(&quot;%s&quot;, as_xmm_double_reg()-&gt;name());
1632   } else if (is_single_fpu()) {
1633     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1634   } else if (is_double_fpu()) {
1635     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1636 #elif defined(AARCH64)
1637   } else if (is_single_fpu()) {
1638     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1639   } else if (is_double_fpu()) {
1640     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1641 #elif defined(ARM)
1642   } else if (is_single_fpu()) {
1643     out-&gt;print(&quot;s%d&quot;, fpu_regnr());
1644   } else if (is_double_fpu()) {
1645     out-&gt;print(&quot;d%d&quot;, fpu_regnrLo() &gt;&gt; 1);
1646 #else
1647   } else if (is_single_fpu()) {
1648     out-&gt;print(&quot;%s&quot;, as_float_reg()-&gt;name());
1649   } else if (is_double_fpu()) {
1650     out-&gt;print(&quot;%s&quot;, as_double_reg()-&gt;name());
1651 #endif
1652 
1653   } else if (is_illegal()) {
1654     out-&gt;print(&quot;-&quot;);
1655   } else {
1656     out-&gt;print(&quot;Unknown Operand&quot;);
1657   }
1658   if (!is_illegal()) {
1659     out-&gt;print(&quot;|%c&quot;, type_char());
1660   }
1661   if (is_register() &amp;&amp; is_last_use()) {
1662     out-&gt;print(&quot;(last_use)&quot;);
1663   }
1664   out-&gt;print(&quot;]&quot;);
1665 }
1666 
1667 
1668 // LIR_Address
1669 void LIR_Const::print_value_on(outputStream* out) const {
1670   switch (type()) {
1671     case T_ADDRESS:out-&gt;print(&quot;address:%d&quot;,as_jint());          break;
1672     case T_INT:    out-&gt;print(&quot;int:%d&quot;,   as_jint());           break;
1673     case T_LONG:   out-&gt;print(&quot;lng:&quot; JLONG_FORMAT, as_jlong()); break;
1674     case T_FLOAT:  out-&gt;print(&quot;flt:%f&quot;,   as_jfloat());         break;
1675     case T_DOUBLE: out-&gt;print(&quot;dbl:%f&quot;,   as_jdouble());        break;
1676     case T_OBJECT: out-&gt;print(&quot;obj:&quot; INTPTR_FORMAT, p2i(as_jobject()));        break;
1677     case T_METADATA: out-&gt;print(&quot;metadata:&quot; INTPTR_FORMAT, p2i(as_metadata()));break;
1678     default:       out-&gt;print(&quot;%3d:0x&quot; UINT64_FORMAT_X, type(), (uint64_t)as_jlong()); break;
1679   }
1680 }
1681 
1682 // LIR_Address
1683 void LIR_Address::print_value_on(outputStream* out) const {
1684   out-&gt;print(&quot;Base:&quot;); _base-&gt;print(out);
1685   if (!_index-&gt;is_illegal()) {
1686     out-&gt;print(&quot; Index:&quot;); _index-&gt;print(out);
1687     switch (scale()) {
1688     case times_1: break;
1689     case times_2: out-&gt;print(&quot; * 2&quot;); break;
1690     case times_4: out-&gt;print(&quot; * 4&quot;); break;
1691     case times_8: out-&gt;print(&quot; * 8&quot;); break;
1692     }
1693   }
1694   out-&gt;print(&quot; Disp: &quot; INTX_FORMAT, _disp);
1695 }
1696 
1697 // debug output of block header without InstructionPrinter
1698 //       (because phi functions are not necessary for LIR)
1699 static void print_block(BlockBegin* x) {
1700   // print block id
1701   BlockEnd* end = x-&gt;end();
1702   tty-&gt;print(&quot;B%d &quot;, x-&gt;block_id());
1703 
1704   // print flags
1705   if (x-&gt;is_set(BlockBegin::std_entry_flag))               tty-&gt;print(&quot;std &quot;);
1706   if (x-&gt;is_set(BlockBegin::osr_entry_flag))               tty-&gt;print(&quot;osr &quot;);
1707   if (x-&gt;is_set(BlockBegin::exception_entry_flag))         tty-&gt;print(&quot;ex &quot;);
1708   if (x-&gt;is_set(BlockBegin::subroutine_entry_flag))        tty-&gt;print(&quot;jsr &quot;);
1709   if (x-&gt;is_set(BlockBegin::backward_branch_target_flag))  tty-&gt;print(&quot;bb &quot;);
1710   if (x-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) tty-&gt;print(&quot;lh &quot;);
1711   if (x-&gt;is_set(BlockBegin::linear_scan_loop_end_flag))    tty-&gt;print(&quot;le &quot;);
1712 
1713   // print block bci range
1714   tty-&gt;print(&quot;[%d, %d] &quot;, x-&gt;bci(), (end == NULL ? -1 : end-&gt;printable_bci()));
1715 
1716   // print predecessors and successors
1717   if (x-&gt;number_of_preds() &gt; 0) {
1718     tty-&gt;print(&quot;preds: &quot;);
1719     for (int i = 0; i &lt; x-&gt;number_of_preds(); i ++) {
1720       tty-&gt;print(&quot;B%d &quot;, x-&gt;pred_at(i)-&gt;block_id());
1721     }
1722   }
1723 
1724   if (x-&gt;number_of_sux() &gt; 0) {
1725     tty-&gt;print(&quot;sux: &quot;);
1726     for (int i = 0; i &lt; x-&gt;number_of_sux(); i ++) {
1727       tty-&gt;print(&quot;B%d &quot;, x-&gt;sux_at(i)-&gt;block_id());
1728     }
1729   }
1730 
1731   // print exception handlers
1732   if (x-&gt;number_of_exception_handlers() &gt; 0) {
1733     tty-&gt;print(&quot;xhandler: &quot;);
1734     for (int i = 0; i &lt; x-&gt;number_of_exception_handlers();  i++) {
1735       tty-&gt;print(&quot;B%d &quot;, x-&gt;exception_handler_at(i)-&gt;block_id());
1736     }
1737   }
1738 
1739   tty-&gt;cr();
1740 }
1741 
1742 void print_LIR(BlockList* blocks) {
1743   tty-&gt;print_cr(&quot;LIR:&quot;);
1744   int i;
1745   for (i = 0; i &lt; blocks-&gt;length(); i++) {
1746     BlockBegin* bb = blocks-&gt;at(i);
1747     print_block(bb);
1748     tty-&gt;print(&quot;__id_Instruction___________________________________________&quot;); tty-&gt;cr();
1749     bb-&gt;lir()-&gt;print_instructions();
1750   }
1751 }
1752 
1753 void LIR_List::print_instructions() {
1754   for (int i = 0; i &lt; _operations.length(); i++) {
1755     _operations.at(i)-&gt;print(); tty-&gt;cr();
1756   }
1757   tty-&gt;cr();
1758 }
1759 
1760 // LIR_Ops printing routines
1761 // LIR_Op
1762 void LIR_Op::print_on(outputStream* out) const {
1763   if (id() != -1 || PrintCFGToFile) {
1764     out-&gt;print(&quot;%4d &quot;, id());
1765   } else {
1766     out-&gt;print(&quot;     &quot;);
1767   }
1768   out-&gt;print(&quot;%s &quot;, name());
1769   print_instr(out);
1770   if (info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info()-&gt;stack()-&gt;bci());
1771 #ifdef ASSERT
1772   if (Verbose &amp;&amp; _file != NULL) {
1773     out-&gt;print(&quot; (%s:%d)&quot;, _file, _line);
1774   }
1775 #endif
1776 }
1777 
1778 const char * LIR_Op::name() const {
1779   const char* s = NULL;
1780   switch(code()) {
1781      // LIR_Op0
1782      case lir_membar:                s = &quot;membar&quot;;        break;
1783      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1784      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1785      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1786      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1787      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1788      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1789      case lir_label:                 s = &quot;label&quot;;         break;
1790      case lir_nop:                   s = &quot;nop&quot;;           break;
1791      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1792      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1793      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1794      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1795      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1796      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1797      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
1798      case lir_check_orig_pc:         s = &quot;check_orig_pc&quot;; break;
1799      // LIR_Op1
1800      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1801      case lir_fld:                   s = &quot;fld&quot;;           break;
1802      case lir_push:                  s = &quot;push&quot;;          break;
1803      case lir_pop:                   s = &quot;pop&quot;;           break;
1804      case lir_null_check:            s = &quot;null_check&quot;;    break;
1805      case lir_return:                s = &quot;return&quot;;        break;
1806      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1807      case lir_leal:                  s = &quot;leal&quot;;          break;
1808      case lir_branch:                s = &quot;branch&quot;;        break;
1809      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1810      case lir_move:                  s = &quot;move&quot;;          break;
1811      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1812      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1813      case lir_throw:                 s = &quot;throw&quot;;         break;
1814      case lir_unwind:                s = &quot;unwind&quot;;        break;
1815      case lir_convert:               s = &quot;convert&quot;;       break;
1816      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1817      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1818      // LIR_Op2
1819      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1820      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1821      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1822      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1823      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1824      case lir_add:                   s = &quot;add&quot;;           break;
1825      case lir_sub:                   s = &quot;sub&quot;;           break;
1826      case lir_mul:                   s = &quot;mul&quot;;           break;
1827      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1828      case lir_div:                   s = &quot;div&quot;;           break;
1829      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1830      case lir_rem:                   s = &quot;rem&quot;;           break;
1831      case lir_abs:                   s = &quot;abs&quot;;           break;
1832      case lir_neg:                   s = &quot;neg&quot;;           break;
1833      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1834      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1835      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1836      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1837      case lir_shl:                   s = &quot;shift_left&quot;;    break;
1838      case lir_shr:                   s = &quot;shift_right&quot;;   break;
1839      case lir_ushr:                  s = &quot;ushift_right&quot;;  break;
1840      case lir_alloc_array:           s = &quot;alloc_array&quot;;   break;
1841      case lir_xadd:                  s = &quot;xadd&quot;;          break;
1842      case lir_xchg:                  s = &quot;xchg&quot;;          break;
1843      // LIR_Op3
1844      case lir_idiv:                  s = &quot;idiv&quot;;          break;
1845      case lir_irem:                  s = &quot;irem&quot;;          break;
1846      case lir_fmad:                  s = &quot;fmad&quot;;          break;
1847      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1848      // LIR_OpJavaCall
1849      case lir_static_call:           s = &quot;static&quot;;        break;
1850      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1851      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1852      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1853      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1854      // LIR_OpArrayCopy
1855      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1856      // LIR_OpUpdateCRC32
1857      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1858      // LIR_OpLock
1859      case lir_lock:                  s = &quot;lock&quot;;          break;
1860      case lir_unlock:                s = &quot;unlock&quot;;        break;
1861      // LIR_OpDelay
1862      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1863      // LIR_OpTypeCheck
1864      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1865      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1866      case lir_store_check:           s = &quot;store_check&quot;;   break;
1867      // LIR_OpFlattenedArrayCheck
1868      case lir_flattened_array_check: s = &quot;flattened_array_check&quot;; break;
1869      // LIR_OpNullFreeArrayCheck
1870      case lir_null_free_array_check: s = &quot;null_free_array_check&quot;; break;
1871      // LIR_OpSubstitutabilityCheck
1872      case lir_substitutability_check: s = &quot;substitutability_check&quot;; break;
1873      // LIR_OpCompareAndSwap
1874      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1875      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1876      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1877      // LIR_OpProfileCall
1878      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1879      // LIR_OpProfileType
1880      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1881      // LIR_OpAssert
1882 #ifdef ASSERT
1883      case lir_assert:                s = &quot;assert&quot;;        break;
1884 #endif
1885      case lir_none:                  ShouldNotReachHere();break;
1886     default:                         s = &quot;illegal_op&quot;;    break;
1887   }
1888   return s;
1889 }
1890 
1891 // LIR_OpJavaCall
1892 void LIR_OpJavaCall::print_instr(outputStream* out) const {
1893   out-&gt;print(&quot;call: &quot;);
1894   out-&gt;print(&quot;[addr: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(address()));
1895   if (receiver()-&gt;is_valid()) {
1896     out-&gt;print(&quot; [recv: &quot;);   receiver()-&gt;print(out);   out-&gt;print(&quot;]&quot;);
1897   }
1898   if (result_opr()-&gt;is_valid()) {
1899     out-&gt;print(&quot; [result: &quot;); result_opr()-&gt;print(out); out-&gt;print(&quot;]&quot;);
1900   }
1901 }
1902 
1903 // LIR_OpLabel
1904 void LIR_OpLabel::print_instr(outputStream* out) const {
1905   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(_label));
1906 }
1907 
1908 // LIR_OpArrayCopy
1909 void LIR_OpArrayCopy::print_instr(outputStream* out) const {
1910   src()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1911   src_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1912   dst()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1913   dst_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1914   length()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1915   tmp()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1916 }
1917 
1918 // LIR_OpUpdateCRC32
1919 void LIR_OpUpdateCRC32::print_instr(outputStream* out) const {
1920   crc()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1921   val()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1922   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1923 }
1924 
1925 // LIR_OpCompareAndSwap
1926 void LIR_OpCompareAndSwap::print_instr(outputStream* out) const {
1927   addr()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1928   cmp_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1929   new_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1930   tmp1()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1931   tmp2()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1932 
1933 }
1934 
1935 // LIR_Op0
1936 void LIR_Op0::print_instr(outputStream* out) const {
1937   result_opr()-&gt;print(out);
1938 }
1939 
1940 // LIR_Op1
1941 const char * LIR_Op1::name() const {
1942   if (code() == lir_move) {
1943     switch (move_kind()) {
1944     case lir_move_normal:
1945       return &quot;move&quot;;
1946     case lir_move_unaligned:
1947       return &quot;unaligned move&quot;;
1948     case lir_move_volatile:
1949       return &quot;volatile_move&quot;;
1950     case lir_move_wide:
1951       return &quot;wide_move&quot;;
1952     default:
1953       ShouldNotReachHere();
1954     return &quot;illegal_op&quot;;
1955     }
1956   } else {
1957     return LIR_Op::name();
1958   }
1959 }
1960 
1961 
1962 void LIR_Op1::print_instr(outputStream* out) const {
1963   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
1964   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1965   print_patch_code(out, patch_code());
1966 }
1967 
1968 
1969 // LIR_Op1
1970 void LIR_OpRTCall::print_instr(outputStream* out) const {
1971   intx a = (intx)addr();
1972   out-&gt;print(&quot;%s&quot;, Runtime1::name_for_address(addr()));
1973   out-&gt;print(&quot; &quot;);
1974   tmp()-&gt;print(out);
1975 }
1976 
1977 void LIR_Op1::print_patch_code(outputStream* out, LIR_PatchCode code) {
1978   switch(code) {
1979     case lir_patch_none:                                 break;
1980     case lir_patch_low:    out-&gt;print(&quot;[patch_low]&quot;);    break;
1981     case lir_patch_high:   out-&gt;print(&quot;[patch_high]&quot;);   break;
1982     case lir_patch_normal: out-&gt;print(&quot;[patch_normal]&quot;); break;
1983     default: ShouldNotReachHere();
1984   }
1985 }
1986 
1987 // LIR_OpBranch
1988 void LIR_OpBranch::print_instr(outputStream* out) const {
1989   print_condition(out, cond());             out-&gt;print(&quot; &quot;);
1990   if (block() != NULL) {
1991     out-&gt;print(&quot;[B%d] &quot;, block()-&gt;block_id());
1992   } else if (stub() != NULL) {
1993     out-&gt;print(&quot;[&quot;);
1994     stub()-&gt;print_name(out);
1995     out-&gt;print(&quot;: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()));
1996     if (stub()-&gt;info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, stub()-&gt;info()-&gt;stack()-&gt;bci());
1997   } else {
1998     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;] &quot;, p2i(label()));
1999   }
2000   if (ublock() != NULL) {
2001     out-&gt;print(&quot;unordered: [B%d] &quot;, ublock()-&gt;block_id());
2002   }
2003 }
2004 
2005 void LIR_Op::print_condition(outputStream* out, LIR_Condition cond) {
2006   switch(cond) {
2007     case lir_cond_equal:           out-&gt;print(&quot;[EQ]&quot;);      break;
2008     case lir_cond_notEqual:        out-&gt;print(&quot;[NE]&quot;);      break;
2009     case lir_cond_less:            out-&gt;print(&quot;[LT]&quot;);      break;
2010     case lir_cond_lessEqual:       out-&gt;print(&quot;[LE]&quot;);      break;
2011     case lir_cond_greaterEqual:    out-&gt;print(&quot;[GE]&quot;);      break;
2012     case lir_cond_greater:         out-&gt;print(&quot;[GT]&quot;);      break;
2013     case lir_cond_belowEqual:      out-&gt;print(&quot;[BE]&quot;);      break;
2014     case lir_cond_aboveEqual:      out-&gt;print(&quot;[AE]&quot;);      break;
2015     case lir_cond_always:          out-&gt;print(&quot;[AL]&quot;);      break;
2016     default:                       out-&gt;print(&quot;[%d]&quot;,cond); break;
2017   }
2018 }
2019 
2020 // LIR_OpConvert
2021 void LIR_OpConvert::print_instr(outputStream* out) const {
2022   print_bytecode(out, bytecode());
2023   in_opr()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2024   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2025 #ifdef PPC32
2026   if(tmp1()-&gt;is_valid()) {
2027     tmp1()-&gt;print(out); out-&gt;print(&quot; &quot;);
2028     tmp2()-&gt;print(out); out-&gt;print(&quot; &quot;);
2029   }
2030 #endif
2031 }
2032 
2033 void LIR_OpConvert::print_bytecode(outputStream* out, Bytecodes::Code code) {
2034   switch(code) {
2035     case Bytecodes::_d2f: out-&gt;print(&quot;[d2f] &quot;); break;
2036     case Bytecodes::_d2i: out-&gt;print(&quot;[d2i] &quot;); break;
2037     case Bytecodes::_d2l: out-&gt;print(&quot;[d2l] &quot;); break;
2038     case Bytecodes::_f2d: out-&gt;print(&quot;[f2d] &quot;); break;
2039     case Bytecodes::_f2i: out-&gt;print(&quot;[f2i] &quot;); break;
2040     case Bytecodes::_f2l: out-&gt;print(&quot;[f2l] &quot;); break;
2041     case Bytecodes::_i2b: out-&gt;print(&quot;[i2b] &quot;); break;
2042     case Bytecodes::_i2c: out-&gt;print(&quot;[i2c] &quot;); break;
2043     case Bytecodes::_i2d: out-&gt;print(&quot;[i2d] &quot;); break;
2044     case Bytecodes::_i2f: out-&gt;print(&quot;[i2f] &quot;); break;
2045     case Bytecodes::_i2l: out-&gt;print(&quot;[i2l] &quot;); break;
2046     case Bytecodes::_i2s: out-&gt;print(&quot;[i2s] &quot;); break;
2047     case Bytecodes::_l2i: out-&gt;print(&quot;[l2i] &quot;); break;
2048     case Bytecodes::_l2f: out-&gt;print(&quot;[l2f] &quot;); break;
2049     case Bytecodes::_l2d: out-&gt;print(&quot;[l2d] &quot;); break;
2050     default:
2051       out-&gt;print(&quot;[?%d]&quot;,code);
2052     break;
2053   }
2054 }
2055 
2056 void LIR_OpAllocObj::print_instr(outputStream* out) const {
2057   klass()-&gt;print(out);                      out-&gt;print(&quot; &quot;);
2058   obj()-&gt;print(out);                        out-&gt;print(&quot; &quot;);
2059   tmp1()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2060   tmp2()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2061   tmp3()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2062   tmp4()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2063   out-&gt;print(&quot;[hdr:%d]&quot;, header_size()); out-&gt;print(&quot; &quot;);
2064   out-&gt;print(&quot;[obj:%d]&quot;, object_size()); out-&gt;print(&quot; &quot;);
2065   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2066 }
2067 
2068 void LIR_OpRoundFP::print_instr(outputStream* out) const {
2069   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
2070   tmp()-&gt;print(out);        out-&gt;print(&quot; &quot;);
2071   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
2072 }
2073 
2074 // LIR_Op2
2075 void LIR_Op2::print_instr(outputStream* out) const {
2076   if (code() == lir_cmove || code() == lir_cmp) {
2077     print_condition(out, condition());         out-&gt;print(&quot; &quot;);
2078   }
2079   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2080   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2081   if (tmp1_opr()-&gt;is_valid()) { tmp1_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2082   if (tmp2_opr()-&gt;is_valid()) { tmp2_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2083   if (tmp3_opr()-&gt;is_valid()) { tmp3_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2084   if (tmp4_opr()-&gt;is_valid()) { tmp4_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2085   if (tmp5_opr()-&gt;is_valid()) { tmp5_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2086   result_opr()-&gt;print(out);
2087 }
2088 
2089 void LIR_OpAllocArray::print_instr(outputStream* out) const {
2090   klass()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2091   len()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2092   obj()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2093   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2094   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2095   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2096   tmp4()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2097   out-&gt;print(&quot;[type:0x%x]&quot;, type());     out-&gt;print(&quot; &quot;);
2098   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2099 }
2100 
2101 
2102 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
2103   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2104   if (code() == lir_store_check) {
2105     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
2106   }
2107   if (code() != lir_store_check) {
2108     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
2109     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
2110   }
2111   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2112   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2113   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2114   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2115   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
2116 }
2117 
2118 void LIR_OpFlattenedArrayCheck::print_instr(outputStream* out) const {
2119   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2120   value()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2121   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2122   if (stub() != NULL) {
2123     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2124   }
2125 }
2126 
2127 void LIR_OpNullFreeArrayCheck::print_instr(outputStream* out) const {
2128   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2129   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2130 }
2131 
2132 void LIR_OpSubstitutabilityCheck::print_instr(outputStream* out) const {
2133   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2134   left()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2135   right()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2136   equal_result()-&gt;print(out);            out-&gt;print(&quot; &quot;);
2137   not_equal_result()-&gt;print(out);        out-&gt;print(&quot; &quot;);
2138   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2139   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2140   left_klass()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2141   right_klass()-&gt;print(out);             out-&gt;print(&quot; &quot;);
2142   left_klass_op()-&gt;print(out);           out-&gt;print(&quot; &quot;);
2143   right_klass_op()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2144   if (stub() != NULL) {
2145     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2146   }
2147 }
2148 
2149 // LIR_Op3
2150 void LIR_Op3::print_instr(outputStream* out) const {
2151   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2152   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2153   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2154   result_opr()-&gt;print(out);
2155 }
2156 
2157 
2158 void LIR_OpLock::print_instr(outputStream* out) const {
2159   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2160   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2161   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
2162   if (_scratch-&gt;is_valid()) {
2163     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
2164   }
2165   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2166 }
2167 
2168 #ifdef ASSERT
2169 void LIR_OpAssert::print_instr(outputStream* out) const {
2170   print_condition(out, condition()); out-&gt;print(&quot; &quot;);
2171   in_opr1()-&gt;print(out);             out-&gt;print(&quot; &quot;);
2172   in_opr2()-&gt;print(out);             out-&gt;print(&quot;, \&quot;&quot;);
2173   out-&gt;print(&quot;%s&quot;, msg());          out-&gt;print(&quot;\&quot;&quot;);
2174 }
2175 #endif
2176 
2177 
2178 void LIR_OpDelay::print_instr(outputStream* out) const {
2179   _op-&gt;print_on(out);
2180 }
2181 
2182 
2183 // LIR_OpProfileCall
2184 void LIR_OpProfileCall::print_instr(outputStream* out) const {
2185   profiled_method()-&gt;name()-&gt;print_symbol_on(out);
2186   out-&gt;print(&quot;.&quot;);
2187   profiled_method()-&gt;holder()-&gt;name()-&gt;print_symbol_on(out);
2188   out-&gt;print(&quot; @ %d &quot;, profiled_bci());
2189   mdo()-&gt;print(out);           out-&gt;print(&quot; &quot;);
2190   recv()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2191   tmp1()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2192 }
2193 
2194 // LIR_OpProfileType
2195 void LIR_OpProfileType::print_instr(outputStream* out) const {
2196   out-&gt;print(&quot;exact = &quot;);
2197   if  (exact_klass() == NULL) {
2198     out-&gt;print(&quot;unknown&quot;);
2199   } else {
2200     exact_klass()-&gt;print_name_on(out);
2201   }
2202   out-&gt;print(&quot; current = &quot;); ciTypeEntries::print_ciklass(out, current_klass());
2203   out-&gt;print(&quot; &quot;);
2204   mdp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2205   obj()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2206   tmp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2207 }
2208 
2209 #endif // PRODUCT
2210 
2211 // Implementation of LIR_InsertionBuffer
2212 
2213 void LIR_InsertionBuffer::append(int index, LIR_Op* op) {
2214   assert(_index_and_count.length() % 2 == 0, &quot;must have a count for each index&quot;);
2215 
2216   int i = number_of_insertion_points() - 1;
2217   if (i &lt; 0 || index_at(i) &lt; index) {
2218     append_new(index, 1);
2219   } else {
2220     assert(index_at(i) == index, &quot;can append LIR_Ops in ascending order only&quot;);
2221     assert(count_at(i) &gt; 0, &quot;check&quot;);
2222     set_count_at(i, count_at(i) + 1);
2223   }
2224   _ops.push(op);
2225 
2226   DEBUG_ONLY(verify());
2227 }
2228 
2229 #ifdef ASSERT
2230 void LIR_InsertionBuffer::verify() {
2231   int sum = 0;
2232   int prev_idx = -1;
2233 
2234   for (int i = 0; i &lt; number_of_insertion_points(); i++) {
2235     assert(prev_idx &lt; index_at(i), &quot;index must be ordered ascending&quot;);
2236     sum += count_at(i);
2237   }
2238   assert(sum == number_of_ops(), &quot;wrong total sum&quot;);
2239 }
2240 #endif
    </pre>
  </body>
</html>
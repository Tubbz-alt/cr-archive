<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_CodeStubs.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;

  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;


  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-removed">  36 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  37 #include &quot;compiler/compilationPolicy.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/compilerEvent.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;runtime/vm_version.hpp&quot;
  46 #include &quot;utilities/bitMap.inline.hpp&quot;
  47 #include &quot;utilities/powerOfTwo.hpp&quot;
  48 
  49 class BlockListBuilder {
  50  private:
  51   Compilation* _compilation;
  52   IRScope*     _scope;
  53 
  54   BlockList    _blocks;                // internal list of all blocks
  55   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  56 
</pre>
<hr />
<pre>
 641 #endif
 642         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 643         return result;
 644       }
 645     }
 646     return load;
 647   }
 648 
 649   // Record this newly allocated object
 650   void new_instance(NewInstance* object) {
 651     int index = _newobjects.length();
 652     _newobjects.append(object);
 653     if (_fields.at_grow(index, NULL) == NULL) {
 654       _fields.at_put(index, new FieldBuffer());
 655     } else {
 656       _fields.at(index)-&gt;kill();
 657     }
 658   }
 659 
 660   // Record this newly allocated object
<span class="line-modified"> 661   void new_instance(NewValueTypeInstance* object) {</span>
 662     int index = _newobjects.length();
 663     _newobjects.append(object);
 664     if (_fields.at_grow(index, NULL) == NULL) {
 665       _fields.at_put(index, new FieldBuffer());
 666     } else {
 667       _fields.at(index)-&gt;kill();
 668     }
 669   }
 670 
 671   void store_value(Value value) {
 672     int index = _newobjects.find(value);
 673     if (index != -1) {
 674       // stored a newly allocated object into another object.
 675       // Assume we&#39;ve lost track of it as separate slice of memory.
 676       // We could do better by keeping track of whether individual
 677       // fields could alias each other.
 678       _newobjects.remove_at(index);
 679       // pull out the field info and store it at the end up the list
 680       // of field info list to be reused later.
 681       _fields.append(_fields.at(index));
</pre>
<hr />
<pre>
 996     // Save the entire state and re-execute on deopt when accessing flattened arrays
 997     state_before = copy_state_before();
 998     state_before-&gt;set_should_reexecute(true);
 999   } else {
1000     state_before = copy_state_indexed_access();
1001   }
1002   compilation()-&gt;set_has_access_indexed(true);
1003   Value index = ipop();
1004   Value array = apop();
1005   Value length = NULL;
1006   if (CSEArrayLength ||
1007       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1008       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1009     length = append(new ArrayLength(array, state_before));
1010   }
1011 
1012   LoadIndexed* load_indexed = NULL;
1013   Instruction* result = NULL;
1014   if (array-&gt;is_loaded_flattened_array()) {
1015     ciType* array_type = array-&gt;declared_type();
<span class="line-modified">1016     ciValueKlass* elem_klass = array_type-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-modified">1017     NewValueTypeInstance* new_instance = new NewValueTypeInstance(elem_klass, state_before, false);</span>
1018     _memory-&gt;new_instance(new_instance);
1019     apush(append_split(new_instance));
1020     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1021     load_indexed-&gt;set_vt(new_instance);
1022   } else {
1023     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1024   }
1025   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1026     compilation()-&gt;set_would_profile(true);
1027     load_indexed-&gt;set_should_profile(true);
1028     load_indexed-&gt;set_profiled_method(method());
1029     load_indexed-&gt;set_profiled_bci(bci());
1030   }
1031   result = append(load_indexed);
1032   assert(!(profile_array_accesses() &amp;&amp; is_reference_type(type)) || load_indexed == result, &quot;should not be optimized out&quot;);
1033   if (!array-&gt;is_loaded_flattened_array()) {
1034     push(as_ValueType(type), result);
1035   }
1036 }
1037 
</pre>
<hr />
<pre>
1276   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1277   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1278   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
1279 
1280   bool subst_check = false;
1281   if (EnableValhalla &amp;&amp; (stream()-&gt;cur_bc() == Bytecodes::_if_acmpeq || stream()-&gt;cur_bc() == Bytecodes::_if_acmpne) &amp;&amp;
1282       method() != ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature())) {
1283     // If current method is ValueBootstrapMethods::isSubstitutable(),
1284     // compile the acmp as a regular pointer comparison otherwise we
1285     // could call ValueBootstrapMethods::isSubstitutable() back
1286     ValueType* left_vt = x-&gt;type();
1287     ValueType* right_vt = y-&gt;type();
1288     if (left_vt-&gt;is_object()) {
1289       assert(right_vt-&gt;is_object(), &quot;must be&quot;);
1290       ciKlass* left_klass = x-&gt;as_loaded_klass_or_null();
1291       ciKlass* right_klass = y-&gt;as_loaded_klass_or_null();
1292 
1293       if (left_klass == NULL || right_klass == NULL) {
1294         // The klass is still unloaded, or came from a Phi node. Go slow case;
1295         subst_check = true;
<span class="line-modified">1296       } else if (left_klass-&gt;can_be_value_klass() || right_klass-&gt;can_be_value_klass()) {</span>
1297         // Either operand may be a value object, but we&#39;re not sure. Go slow case;
1298         subst_check = true;
1299       } else {
1300         // No need to do substitutability check
1301       }
1302     }
1303   }
1304 
1305   // In case of loop invariant code motion or predicate insertion
1306   // before the body of a loop the state is needed
1307   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));
1308 
1309   assert(i-&gt;as_Goto() == NULL ||
1310          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1311          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1312          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1313 
1314   if (is_profiling()) {
1315     If* if_node = i-&gt;as_If();
1316     if (if_node != NULL) {
</pre>
<hr />
<pre>
1689   // Attach dimension info to stable arrays.
1690   if (FoldStableValues &amp;&amp;
1691       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1692     ciArray* array = field_value.as_object()-&gt;as_array();
1693     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1694     value = new StableArrayConstant(array, dimension);
1695   }
1696 
1697   switch (field_type) {
1698     case T_ARRAY:
1699     case T_OBJECT:
1700       if (field_value.as_object()-&gt;should_be_constant()) {
1701         return new Constant(value);
1702       }
1703       return NULL; // Not a constant.
1704     default:
1705       return new Constant(value);
1706   }
1707 }
1708 
<span class="line-modified">1709 void GraphBuilder::copy_value_content(ciValueKlass* vk, Value src, int src_off, Value dest, int dest_off,</span>
<span class="line-modified">1710     ValueStack* state_before, bool needs_patching) {</span>
1711   src-&gt;set_escaped();
1712   for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); i++) {
1713     ciField* inner_field = vk-&gt;nonstatic_field_at(i);
1714     assert(!inner_field-&gt;is_flattened(), &quot;the iteration over nested fields is handled by the loop itself&quot;);
1715     int off = inner_field-&gt;offset() - vk-&gt;first_field_offset();
1716     LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);
1717     Value replacement = append(load);
1718     StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);
1719     append(store);
1720   }
1721 }
1722 
1723 void GraphBuilder::access_field(Bytecodes::Code code) {
1724   bool will_link;
1725   ciField* field = stream()-&gt;get_field(will_link);
1726   ciInstanceKlass* holder = field-&gt;holder();
1727   BasicType field_type = field-&gt;type()-&gt;basic_type();
1728   ValueType* type = as_ValueType(field_type);
1729 
1730   // call will_link again to determine if the field is valid.
</pre>
<hr />
<pre>
1796       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1797       break;
1798     }
1799     case Bytecodes::_getfield: {
1800       // Check for compile-time constants, i.e., trusted final non-static fields.
1801       Value constant = NULL;
1802       if (state_before == NULL &amp;&amp; field-&gt;is_flattened()) {
1803         // Save the entire state and re-execute on deopt when accessing flattened fields
1804         assert(Interpreter::bytecode_should_reexecute(code), &quot;should reexecute&quot;);
1805         state_before = copy_state_before();
1806       }
1807       obj = apop();
1808       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
1809       if (field-&gt;is_constant() &amp;&amp; !field-&gt;is_flattened() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {
1810         ciObject* const_oop = obj_type-&gt;constant_value();
1811         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1812           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1813           if (field_value.is_valid()) {
1814             if (field-&gt;signature()-&gt;is_Q_signature() &amp;&amp; field_value.is_null_or_zero()) {
1815               // Non-flattened inline type field. Replace null by the default value.
<span class="line-modified">1816               constant = new Constant(new InstanceConstant(field-&gt;type()-&gt;as_value_klass()-&gt;default_value_instance()));</span>
1817             } else {
1818               constant = make_constant(field_value, field);
1819             }
1820             // For CallSite objects add a dependency for invalidation of the optimization.
1821             if (field-&gt;is_call_site_target()) {
1822               ciCallSite* call_site = const_oop-&gt;as_call_site();
1823               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
1824                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1825                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1826               }
1827             }
1828           }
1829         }
1830       }
1831       if (constant != NULL) {
1832         push(type, append(constant));
1833       } else {
1834         if (state_before == NULL) {
1835           state_before = copy_state_for_exception();
1836         }
</pre>
<hr />
<pre>
1844             BasicType bt = field-&gt;type()-&gt;basic_type();
1845             switch (bt) {
1846             case T_BOOLEAN:
1847             case T_BYTE:
1848               replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));
1849               break;
1850             case T_CHAR:
1851               replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));
1852               break;
1853             case T_SHORT:
1854               replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));
1855               break;
1856             default:
1857               break;
1858             }
1859             push(type, replacement);
1860           } else {
1861             push(type, append(load));
1862           }
1863         } else { // flattened field, not optimized solution: re-instantiate the flattened value
<span class="line-modified">1864           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1865           ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-modified">1866           int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();</span>
<span class="line-modified">1867           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
1868           scope()-&gt;set_wrote_final();
1869           scope()-&gt;set_wrote_fields();
<span class="line-modified">1870           NewValueTypeInstance* new_instance = new NewValueTypeInstance(value_klass, state_before, false);</span>
1871           _memory-&gt;new_instance(new_instance);
1872           apush(append_split(new_instance));
<span class="line-modified">1873           copy_value_content(value_klass, obj, field-&gt;offset(), new_instance, value_klass-&gt;first_field_offset(),</span>
1874                        state_before, needs_patching);
1875         }
1876       }
1877       break;
1878     }
1879     case Bytecodes::_withfield:
1880     case Bytecodes::_putfield: {
1881       Value val = pop(type);
1882       val-&gt;set_escaped();
1883       obj = apop();
1884       if (state_before == NULL) {
1885         state_before = copy_state_for_exception();
1886       }
1887       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1888         Value mask = append(new Constant(new IntConstant(1)));
1889         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1890       }
1891 
1892       if (!field-&gt;is_flattened()) {
1893         StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1894         if (!needs_patching) store = _memory-&gt;store(store);
1895         if (store != NULL) {
1896           append(store);
1897         }
1898       } else {
<span class="line-modified">1899         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1900         ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-modified">1901         int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();</span>
<span class="line-modified">1902         copy_value_content(value_klass, val, value_klass-&gt;first_field_offset(), obj, field-&gt;offset(),</span>
1903                    state_before, needs_patching);
1904       }
1905       break;
1906     }
1907     default:
1908       ShouldNotReachHere();
1909       break;
1910   }
1911 }
1912 
1913 // Baseline version of withfield, allocate every time
1914 void GraphBuilder::withfield(int field_index)
1915 {
1916   bool will_link;
1917   ciField* field_modify = stream()-&gt;get_field(will_link);
1918   ciInstanceKlass* holder = field_modify-&gt;holder();
1919   BasicType field_type = field_modify-&gt;type()-&gt;basic_type();
1920   ValueType* type = as_ValueType(field_type);
1921 
1922   // call will_link again to determine if the field is valid.
</pre>
<hr />
<pre>
1943 
1944   Value val = pop(type);
1945   Value obj = apop();
1946 
1947   if (!needs_patching &amp;&amp; obj-&gt;is_optimizable_for_withfield()) {
1948     int astore_index;
1949     ciBytecodeStream s(method());
1950     s.force_bci(bci());
1951     s.next();
1952     switch (s.cur_bc()) {
1953     case Bytecodes::_astore:    astore_index = s.get_index(); break;
1954     case Bytecodes::_astore_0:  astore_index = 0; break;
1955     case Bytecodes::_astore_1:  astore_index = 1; break;
1956     case Bytecodes::_astore_2:  astore_index = 2; break;
1957     case Bytecodes::_astore_3:  astore_index = 3; break;
1958     default: astore_index = -1;
1959     }
1960 
1961     if (astore_index &gt;= 0 &amp;&amp; obj == state()-&gt;local_at(astore_index)) {
1962       // We have a sequence like this, where we load a value object from a local slot,
<span class="line-modified">1963       // and overwrite the same local slot with a modified copy of the value object.</span>
1964       //      defaultvalue #1 // class compiler/valhalla/valuetypes/MyValue1
1965       //      astore 9
1966       //      ...
1967       //      iload_0
1968       //      aload 9
1969       //      swap
1970       //      withfield #7 // Field x:I
1971       //      astore 9
1972       // If this object was created by defaultvalue, and has not escaped, and is not stored
1973       // in any other local slots, we can effectively treat the withfield/astore
1974       // sequence as a single putfield bytecode.
1975       push(objectType, obj);
1976       push(type, val);
1977       access_field(Bytecodes::_withfield);
1978       stream()-&gt;next(); // skip the next astore/astore_n bytecode.
1979       return;
1980     }
1981   }
1982 
<span class="line-modified">1983   assert(holder-&gt;is_valuetype(), &quot;must be a value klass&quot;);</span>
1984   // Save the entire state and re-execute on deopt when executing withfield
1985   state_before-&gt;set_should_reexecute(true);
<span class="line-modified">1986   NewValueTypeInstance* new_instance = new NewValueTypeInstance(holder-&gt;as_value_klass(), state_before, false);</span>
1987   _memory-&gt;new_instance(new_instance);
1988   apush(append_split(new_instance));
1989 
1990   for (int i = 0; i &lt; holder-&gt;nof_nonstatic_fields(); i++) {
1991     ciField* field = holder-&gt;nonstatic_field_at(i);
1992     int off = field-&gt;offset();
1993 
1994     if (field-&gt;offset() != offset) {
1995       if (field-&gt;is_flattened()) {
<span class="line-modified">1996         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1997         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);</span>
<span class="line-modified">1998         ciValueKlass* vk = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-modified">1999         copy_value_content(vk, obj, off, new_instance, vk-&gt;first_field_offset(), state_before, needs_patching);</span>
2000       } else {
2001         // Only load those fields who are not modified
2002         LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);
2003         Value replacement = append(load);
2004         StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);
2005         append(store);
2006       }
2007     }
2008   }
2009 
2010   // Field to modify
2011   if (field_modify-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
2012     Value mask = append(new Constant(new IntConstant(1)));
2013     val = append(new LogicOp(Bytecodes::_iand, val, mask));
2014   }
2015   if (field_modify-&gt;is_flattened()) {
<span class="line-modified">2016     assert(field_modify-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);</span>
<span class="line-modified">2017     ciValueKlass* vk = field_modify-&gt;type()-&gt;as_value_klass();</span>
<span class="line-modified">2018     copy_value_content(vk, val, vk-&gt;first_field_offset(), new_instance, field_modify-&gt;offset(), state_before, needs_patching);</span>
2019   } else {
2020     StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);
2021     append(store);
2022   }
2023 }
2024 
2025 Dependencies* GraphBuilder::dependency_recorder() const {
2026   assert(DeoptC1, &quot;need debug information&quot;);
2027   return compilation()-&gt;dependency_recorder();
2028 }
2029 
2030 // How many arguments do we want to profile?
2031 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
2032   int n = 0;
2033   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
2034   start = has_receiver ? 1 : 0;
2035   if (profile_arguments()) {
2036     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2037     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
2038       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
</pre>
<hr />
<pre>
2352         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2353         ciKlass* target_klass = NULL;
2354         if (cha_monomorphic_target != NULL) {
2355           target_klass = cha_monomorphic_target-&gt;holder();
2356         } else if (exact_target != NULL) {
2357           target_klass = exact_target-&gt;holder();
2358         }
2359         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2360       }
2361     }
2362   }
2363 
2364   if (recv != NULL) {
2365     recv-&gt;set_escaped();
2366   }
2367   for (int i=0; i&lt;args-&gt;length(); i++) {
2368     args-&gt;at(0)-&gt;set_escaped();
2369   }
2370 
2371   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,
<span class="line-modified">2372                               declared_signature-&gt;return_type()-&gt;is_valuetype());</span>
2373   // push result
2374   append_split(result);
2375 
2376   if (result_type != voidType) {
2377     if (method()-&gt;is_strict()) {
2378       push(result_type, round_fp(result));
2379     } else {
2380       push(result_type, result);
2381     }
2382   }
2383   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2384     profile_return_type(result, target);
2385   }
2386 }
2387 
2388 
2389 void GraphBuilder::new_instance(int klass_index) {
2390   ValueStack* state_before = copy_state_exhandling();
2391   bool will_link;
2392   ciKlass* klass = stream()-&gt;get_klass(will_link);
2393   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
<span class="line-modified">2394   assert(!klass-&gt;is_valuetype(), &quot;must not be a value klass&quot;);</span>
2395   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2396   _memory-&gt;new_instance(new_instance);
2397   apush(append_split(new_instance));
2398 }
2399 
2400 void GraphBuilder::default_value(int klass_index) {
2401   bool will_link;
2402   if (!stream()-&gt;is_unresolved_klass()) {
<span class="line-modified">2403     ciValueKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_value_klass();</span>
<span class="line-modified">2404     apush(append(new Constant(new InstanceConstant(vk-&gt;default_value_instance()))));</span>
2405   } else {
2406     ValueStack* state_before = copy_state_before();
2407     apush(append_split(new DefaultValue(state_before)));
2408   }
2409 }
2410 
2411 void GraphBuilder::new_type_array() {
2412   ValueStack* state_before = copy_state_exhandling();
2413   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2414 }
2415 
2416 
2417 void GraphBuilder::new_object_array() {
2418   bool will_link;
2419   ciKlass* klass = stream()-&gt;get_klass(will_link);
2420   bool never_null = stream()-&gt;is_inline_klass();
2421   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2422   NewArray* n = new NewObjectArray(klass, ipop(), state_before, never_null);
2423   apush(append_split(n));
2424 }
</pre>
<hr />
<pre>
2468   ciKlass* klass = stream()-&gt;get_klass(will_link);
2469   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2470   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2471   ipush(append_split(i));
2472   i-&gt;set_direct_compare(direct_compare(klass));
2473 
2474   if (is_profiling()) {
2475     // Note that we&#39;d collect profile data in this method if we wanted it.
2476     compilation()-&gt;set_would_profile(true);
2477 
2478     if (profile_checkcasts()) {
2479       i-&gt;set_profiled_method(method());
2480       i-&gt;set_profiled_bci(bci());
2481       i-&gt;set_should_profile(true);
2482     }
2483   }
2484 }
2485 
2486 
2487 void GraphBuilder::monitorenter(Value x, int bci) {
<span class="line-modified">2488   bool maybe_valuetype = false;</span>
2489   if (bci == InvocationEntryBci) {
2490     // Called by GraphBuilder::inline_sync_entry.
2491 #ifdef ASSERT
2492     ciType* obj_type = x-&gt;declared_type();
<span class="line-modified">2493     assert(obj_type == NULL || !obj_type-&gt;is_valuetype(), &quot;valuetypes cannot have synchronized methods&quot;);</span>
2494 #endif
2495   } else {
2496     // We are compiling a monitorenter bytecode
2497     if (EnableValhalla) {
2498       ciType* obj_type = x-&gt;declared_type();
<span class="line-modified">2499       if (obj_type == NULL || obj_type-&gt;as_klass()-&gt;can_be_value_klass()) {</span>
<span class="line-modified">2500         // If we&#39;re (possibly) locking on a valuetype, check for markWord::always_locked_pattern</span>
2501         // and throw IMSE. (obj_type is null for Phi nodes, so let&#39;s just be conservative).
<span class="line-modified">2502         maybe_valuetype = true;</span>
2503       }
2504     }
2505   }
2506 
2507   // save state before locking in case of deoptimization after a NullPointerException
2508   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
<span class="line-modified">2509   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before, maybe_valuetype), bci);</span>
2510   kill_all();
2511 }
2512 
2513 
2514 void GraphBuilder::monitorexit(Value x, int bci) {
2515   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2516   kill_all();
2517 }
2518 
2519 
2520 void GraphBuilder::new_multi_array(int dimensions) {
2521   bool will_link;
2522   ciKlass* klass = stream()-&gt;get_klass(will_link);
2523   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2524 
2525   Values* dims = new Values(dimensions, dimensions, NULL);
2526   // fill in all dimensions
2527   int i = dimensions;
2528   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2529   // create array
</pre>
<hr />
<pre>
3439 
3440   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3441   state-&gt;clear_locals();
3442   Goto* g = new Goto(target, false);
3443   append(g);
3444   _osr_entry-&gt;set_end(g);
3445   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3446 
3447   scope_data()-&gt;set_stream(NULL);
3448 }
3449 
3450 
3451 ValueStack* GraphBuilder::state_at_entry() {
3452   ValueStack* state = new ValueStack(scope(), NULL);
3453 
3454   // Set up locals for receiver
3455   int idx = 0;
3456   if (!method()-&gt;is_static()) {
3457     // we should always see the receiver
3458     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,
<span class="line-modified">3459              /*receiver*/ true, /*never_null*/ method()-&gt;holder()-&gt;is_value_array_klass()));</span>
3460     idx = 1;
3461   }
3462 
3463   // Set up locals for incoming arguments
3464   ciSignature* sig = method()-&gt;signature();
3465   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3466     ciType* type = sig-&gt;type_at(i);
3467     BasicType basic_type = type-&gt;basic_type();
3468     // don&#39;t allow T_ARRAY to propagate into locals types
3469     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3470     ValueType* vt = as_ValueType(basic_type);
<span class="line-modified">3471     state-&gt;store_local(idx, new Local(type, vt, idx, false, type-&gt;is_valuetype()));</span>
3472     idx += type-&gt;size();
3473   }
3474 
3475   // lock synchronized method
3476   if (method()-&gt;is_synchronized()) {
3477     state-&gt;lock(NULL);
3478   }
3479 
3480   return state;
3481 }
3482 
3483 
3484 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3485   : _scope_data(NULL)
3486   , _compilation(compilation)
3487   , _memory(new MemoryBuffer())
3488   , _inline_bailout_msg(NULL)
3489   , _instruction_count(0)
3490   , _osr_entry(NULL)
3491 {
</pre>
</td>
<td>
<hr />
<pre>
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
<span class="line-added">  30 </span>
  31 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  32 #include &quot;ci/ciCallSite.hpp&quot;
  33 #include &quot;ci/ciField.hpp&quot;
<span class="line-added">  34 #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
<span class="line-added">  35 #include &quot;ci/ciInlineKlass.hpp&quot;</span>
  36 #include &quot;ci/ciKlass.hpp&quot;
  37 #include &quot;ci/ciMemberName.hpp&quot;
  38 #include &quot;ci/ciUtilities.inline.hpp&quot;

  39 #include &quot;compiler/compilationPolicy.hpp&quot;
  40 #include &quot;compiler/compileBroker.hpp&quot;
  41 #include &quot;compiler/compilerEvent.hpp&quot;
  42 #include &quot;interpreter/bytecode.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;memory/resourceArea.hpp&quot;
  45 #include &quot;oops/oop.inline.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/vm_version.hpp&quot;
  48 #include &quot;utilities/bitMap.inline.hpp&quot;
  49 #include &quot;utilities/powerOfTwo.hpp&quot;
  50 
  51 class BlockListBuilder {
  52  private:
  53   Compilation* _compilation;
  54   IRScope*     _scope;
  55 
  56   BlockList    _blocks;                // internal list of all blocks
  57   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  58 
</pre>
<hr />
<pre>
 643 #endif
 644         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 645         return result;
 646       }
 647     }
 648     return load;
 649   }
 650 
 651   // Record this newly allocated object
 652   void new_instance(NewInstance* object) {
 653     int index = _newobjects.length();
 654     _newobjects.append(object);
 655     if (_fields.at_grow(index, NULL) == NULL) {
 656       _fields.at_put(index, new FieldBuffer());
 657     } else {
 658       _fields.at(index)-&gt;kill();
 659     }
 660   }
 661 
 662   // Record this newly allocated object
<span class="line-modified"> 663   void new_instance(NewInlineTypeInstance* object) {</span>
 664     int index = _newobjects.length();
 665     _newobjects.append(object);
 666     if (_fields.at_grow(index, NULL) == NULL) {
 667       _fields.at_put(index, new FieldBuffer());
 668     } else {
 669       _fields.at(index)-&gt;kill();
 670     }
 671   }
 672 
 673   void store_value(Value value) {
 674     int index = _newobjects.find(value);
 675     if (index != -1) {
 676       // stored a newly allocated object into another object.
 677       // Assume we&#39;ve lost track of it as separate slice of memory.
 678       // We could do better by keeping track of whether individual
 679       // fields could alias each other.
 680       _newobjects.remove_at(index);
 681       // pull out the field info and store it at the end up the list
 682       // of field info list to be reused later.
 683       _fields.append(_fields.at(index));
</pre>
<hr />
<pre>
 998     // Save the entire state and re-execute on deopt when accessing flattened arrays
 999     state_before = copy_state_before();
1000     state_before-&gt;set_should_reexecute(true);
1001   } else {
1002     state_before = copy_state_indexed_access();
1003   }
1004   compilation()-&gt;set_has_access_indexed(true);
1005   Value index = ipop();
1006   Value array = apop();
1007   Value length = NULL;
1008   if (CSEArrayLength ||
1009       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1010       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1011     length = append(new ArrayLength(array, state_before));
1012   }
1013 
1014   LoadIndexed* load_indexed = NULL;
1015   Instruction* result = NULL;
1016   if (array-&gt;is_loaded_flattened_array()) {
1017     ciType* array_type = array-&gt;declared_type();
<span class="line-modified">1018     ciInlineKlass* elem_klass = array_type-&gt;as_flat_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-modified">1019     NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before, false);</span>
1020     _memory-&gt;new_instance(new_instance);
1021     apush(append_split(new_instance));
1022     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1023     load_indexed-&gt;set_vt(new_instance);
1024   } else {
1025     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1026   }
1027   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1028     compilation()-&gt;set_would_profile(true);
1029     load_indexed-&gt;set_should_profile(true);
1030     load_indexed-&gt;set_profiled_method(method());
1031     load_indexed-&gt;set_profiled_bci(bci());
1032   }
1033   result = append(load_indexed);
1034   assert(!(profile_array_accesses() &amp;&amp; is_reference_type(type)) || load_indexed == result, &quot;should not be optimized out&quot;);
1035   if (!array-&gt;is_loaded_flattened_array()) {
1036     push(as_ValueType(type), result);
1037   }
1038 }
1039 
</pre>
<hr />
<pre>
1278   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1279   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1280   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
1281 
1282   bool subst_check = false;
1283   if (EnableValhalla &amp;&amp; (stream()-&gt;cur_bc() == Bytecodes::_if_acmpeq || stream()-&gt;cur_bc() == Bytecodes::_if_acmpne) &amp;&amp;
1284       method() != ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature())) {
1285     // If current method is ValueBootstrapMethods::isSubstitutable(),
1286     // compile the acmp as a regular pointer comparison otherwise we
1287     // could call ValueBootstrapMethods::isSubstitutable() back
1288     ValueType* left_vt = x-&gt;type();
1289     ValueType* right_vt = y-&gt;type();
1290     if (left_vt-&gt;is_object()) {
1291       assert(right_vt-&gt;is_object(), &quot;must be&quot;);
1292       ciKlass* left_klass = x-&gt;as_loaded_klass_or_null();
1293       ciKlass* right_klass = y-&gt;as_loaded_klass_or_null();
1294 
1295       if (left_klass == NULL || right_klass == NULL) {
1296         // The klass is still unloaded, or came from a Phi node. Go slow case;
1297         subst_check = true;
<span class="line-modified">1298       } else if (left_klass-&gt;can_be_inline_klass() || right_klass-&gt;can_be_inline_klass()) {</span>
1299         // Either operand may be a value object, but we&#39;re not sure. Go slow case;
1300         subst_check = true;
1301       } else {
1302         // No need to do substitutability check
1303       }
1304     }
1305   }
1306 
1307   // In case of loop invariant code motion or predicate insertion
1308   // before the body of a loop the state is needed
1309   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));
1310 
1311   assert(i-&gt;as_Goto() == NULL ||
1312          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1313          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1314          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1315 
1316   if (is_profiling()) {
1317     If* if_node = i-&gt;as_If();
1318     if (if_node != NULL) {
</pre>
<hr />
<pre>
1691   // Attach dimension info to stable arrays.
1692   if (FoldStableValues &amp;&amp;
1693       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1694     ciArray* array = field_value.as_object()-&gt;as_array();
1695     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1696     value = new StableArrayConstant(array, dimension);
1697   }
1698 
1699   switch (field_type) {
1700     case T_ARRAY:
1701     case T_OBJECT:
1702       if (field_value.as_object()-&gt;should_be_constant()) {
1703         return new Constant(value);
1704       }
1705       return NULL; // Not a constant.
1706     default:
1707       return new Constant(value);
1708   }
1709 }
1710 
<span class="line-modified">1711 void GraphBuilder::copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off,</span>
<span class="line-modified">1712                                        ValueStack* state_before, bool needs_patching) {</span>
1713   src-&gt;set_escaped();
1714   for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); i++) {
1715     ciField* inner_field = vk-&gt;nonstatic_field_at(i);
1716     assert(!inner_field-&gt;is_flattened(), &quot;the iteration over nested fields is handled by the loop itself&quot;);
1717     int off = inner_field-&gt;offset() - vk-&gt;first_field_offset();
1718     LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);
1719     Value replacement = append(load);
1720     StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);
1721     append(store);
1722   }
1723 }
1724 
1725 void GraphBuilder::access_field(Bytecodes::Code code) {
1726   bool will_link;
1727   ciField* field = stream()-&gt;get_field(will_link);
1728   ciInstanceKlass* holder = field-&gt;holder();
1729   BasicType field_type = field-&gt;type()-&gt;basic_type();
1730   ValueType* type = as_ValueType(field_type);
1731 
1732   // call will_link again to determine if the field is valid.
</pre>
<hr />
<pre>
1798       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1799       break;
1800     }
1801     case Bytecodes::_getfield: {
1802       // Check for compile-time constants, i.e., trusted final non-static fields.
1803       Value constant = NULL;
1804       if (state_before == NULL &amp;&amp; field-&gt;is_flattened()) {
1805         // Save the entire state and re-execute on deopt when accessing flattened fields
1806         assert(Interpreter::bytecode_should_reexecute(code), &quot;should reexecute&quot;);
1807         state_before = copy_state_before();
1808       }
1809       obj = apop();
1810       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
1811       if (field-&gt;is_constant() &amp;&amp; !field-&gt;is_flattened() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {
1812         ciObject* const_oop = obj_type-&gt;constant_value();
1813         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1814           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1815           if (field_value.is_valid()) {
1816             if (field-&gt;signature()-&gt;is_Q_signature() &amp;&amp; field_value.is_null_or_zero()) {
1817               // Non-flattened inline type field. Replace null by the default value.
<span class="line-modified">1818               constant = new Constant(new InstanceConstant(field-&gt;type()-&gt;as_inline_klass()-&gt;default_instance()));</span>
1819             } else {
1820               constant = make_constant(field_value, field);
1821             }
1822             // For CallSite objects add a dependency for invalidation of the optimization.
1823             if (field-&gt;is_call_site_target()) {
1824               ciCallSite* call_site = const_oop-&gt;as_call_site();
1825               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
1826                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1827                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1828               }
1829             }
1830           }
1831         }
1832       }
1833       if (constant != NULL) {
1834         push(type, append(constant));
1835       } else {
1836         if (state_before == NULL) {
1837           state_before = copy_state_for_exception();
1838         }
</pre>
<hr />
<pre>
1846             BasicType bt = field-&gt;type()-&gt;basic_type();
1847             switch (bt) {
1848             case T_BOOLEAN:
1849             case T_BYTE:
1850               replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));
1851               break;
1852             case T_CHAR:
1853               replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));
1854               break;
1855             case T_SHORT:
1856               replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));
1857               break;
1858             default:
1859               break;
1860             }
1861             push(type, replacement);
1862           } else {
1863             push(type, append(load));
1864           }
1865         } else { // flattened field, not optimized solution: re-instantiate the flattened value
<span class="line-modified">1866           assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1867           ciInlineKlass* inline_klass = field-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">1868           int flattening_offset = field-&gt;offset() - inline_klass-&gt;first_field_offset();</span>
<span class="line-modified">1869           assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
1870           scope()-&gt;set_wrote_final();
1871           scope()-&gt;set_wrote_fields();
<span class="line-modified">1872           NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before, false);</span>
1873           _memory-&gt;new_instance(new_instance);
1874           apush(append_split(new_instance));
<span class="line-modified">1875           copy_inline_content(inline_klass, obj, field-&gt;offset(), new_instance, inline_klass-&gt;first_field_offset(),</span>
1876                        state_before, needs_patching);
1877         }
1878       }
1879       break;
1880     }
1881     case Bytecodes::_withfield:
1882     case Bytecodes::_putfield: {
1883       Value val = pop(type);
1884       val-&gt;set_escaped();
1885       obj = apop();
1886       if (state_before == NULL) {
1887         state_before = copy_state_for_exception();
1888       }
1889       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1890         Value mask = append(new Constant(new IntConstant(1)));
1891         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1892       }
1893 
1894       if (!field-&gt;is_flattened()) {
1895         StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1896         if (!needs_patching) store = _memory-&gt;store(store);
1897         if (store != NULL) {
1898           append(store);
1899         }
1900       } else {
<span class="line-modified">1901         assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1902         ciInlineKlass* inline_klass = field-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">1903         int flattening_offset = field-&gt;offset() - inline_klass-&gt;first_field_offset();</span>
<span class="line-modified">1904         copy_inline_content(inline_klass, val, inline_klass-&gt;first_field_offset(), obj, field-&gt;offset(),</span>
1905                    state_before, needs_patching);
1906       }
1907       break;
1908     }
1909     default:
1910       ShouldNotReachHere();
1911       break;
1912   }
1913 }
1914 
1915 // Baseline version of withfield, allocate every time
1916 void GraphBuilder::withfield(int field_index)
1917 {
1918   bool will_link;
1919   ciField* field_modify = stream()-&gt;get_field(will_link);
1920   ciInstanceKlass* holder = field_modify-&gt;holder();
1921   BasicType field_type = field_modify-&gt;type()-&gt;basic_type();
1922   ValueType* type = as_ValueType(field_type);
1923 
1924   // call will_link again to determine if the field is valid.
</pre>
<hr />
<pre>
1945 
1946   Value val = pop(type);
1947   Value obj = apop();
1948 
1949   if (!needs_patching &amp;&amp; obj-&gt;is_optimizable_for_withfield()) {
1950     int astore_index;
1951     ciBytecodeStream s(method());
1952     s.force_bci(bci());
1953     s.next();
1954     switch (s.cur_bc()) {
1955     case Bytecodes::_astore:    astore_index = s.get_index(); break;
1956     case Bytecodes::_astore_0:  astore_index = 0; break;
1957     case Bytecodes::_astore_1:  astore_index = 1; break;
1958     case Bytecodes::_astore_2:  astore_index = 2; break;
1959     case Bytecodes::_astore_3:  astore_index = 3; break;
1960     default: astore_index = -1;
1961     }
1962 
1963     if (astore_index &gt;= 0 &amp;&amp; obj == state()-&gt;local_at(astore_index)) {
1964       // We have a sequence like this, where we load a value object from a local slot,
<span class="line-modified">1965       // and overwrite the same local slot with a modified copy of the inline object.</span>
1966       //      defaultvalue #1 // class compiler/valhalla/valuetypes/MyValue1
1967       //      astore 9
1968       //      ...
1969       //      iload_0
1970       //      aload 9
1971       //      swap
1972       //      withfield #7 // Field x:I
1973       //      astore 9
1974       // If this object was created by defaultvalue, and has not escaped, and is not stored
1975       // in any other local slots, we can effectively treat the withfield/astore
1976       // sequence as a single putfield bytecode.
1977       push(objectType, obj);
1978       push(type, val);
1979       access_field(Bytecodes::_withfield);
1980       stream()-&gt;next(); // skip the next astore/astore_n bytecode.
1981       return;
1982     }
1983   }
1984 
<span class="line-modified">1985   assert(holder-&gt;is_inlinetype(), &quot;must be an inline klass&quot;);</span>
1986   // Save the entire state and re-execute on deopt when executing withfield
1987   state_before-&gt;set_should_reexecute(true);
<span class="line-modified">1988   NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(holder-&gt;as_inline_klass(), state_before, false);</span>
1989   _memory-&gt;new_instance(new_instance);
1990   apush(append_split(new_instance));
1991 
1992   for (int i = 0; i &lt; holder-&gt;nof_nonstatic_fields(); i++) {
1993     ciField* field = holder-&gt;nonstatic_field_at(i);
1994     int off = field-&gt;offset();
1995 
1996     if (field-&gt;offset() != offset) {
1997       if (field-&gt;is_flattened()) {
<span class="line-modified">1998         assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1999         assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Only inline types can be flattened&quot;);</span>
<span class="line-modified">2000         ciInlineKlass* vk = field-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">2001         copy_inline_content(vk, obj, off, new_instance, vk-&gt;first_field_offset(), state_before, needs_patching);</span>
2002       } else {
2003         // Only load those fields who are not modified
2004         LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);
2005         Value replacement = append(load);
2006         StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);
2007         append(store);
2008       }
2009     }
2010   }
2011 
2012   // Field to modify
2013   if (field_modify-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
2014     Value mask = append(new Constant(new IntConstant(1)));
2015     val = append(new LogicOp(Bytecodes::_iand, val, mask));
2016   }
2017   if (field_modify-&gt;is_flattened()) {
<span class="line-modified">2018     assert(field_modify-&gt;type()-&gt;is_inlinetype(), &quot;Only inline types can be flattened&quot;);</span>
<span class="line-modified">2019     ciInlineKlass* vk = field_modify-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">2020     copy_inline_content(vk, val, vk-&gt;first_field_offset(), new_instance, field_modify-&gt;offset(), state_before, needs_patching);</span>
2021   } else {
2022     StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);
2023     append(store);
2024   }
2025 }
2026 
2027 Dependencies* GraphBuilder::dependency_recorder() const {
2028   assert(DeoptC1, &quot;need debug information&quot;);
2029   return compilation()-&gt;dependency_recorder();
2030 }
2031 
2032 // How many arguments do we want to profile?
2033 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
2034   int n = 0;
2035   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
2036   start = has_receiver ? 1 : 0;
2037   if (profile_arguments()) {
2038     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2039     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
2040       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
</pre>
<hr />
<pre>
2354         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2355         ciKlass* target_klass = NULL;
2356         if (cha_monomorphic_target != NULL) {
2357           target_klass = cha_monomorphic_target-&gt;holder();
2358         } else if (exact_target != NULL) {
2359           target_klass = exact_target-&gt;holder();
2360         }
2361         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2362       }
2363     }
2364   }
2365 
2366   if (recv != NULL) {
2367     recv-&gt;set_escaped();
2368   }
2369   for (int i=0; i&lt;args-&gt;length(); i++) {
2370     args-&gt;at(0)-&gt;set_escaped();
2371   }
2372 
2373   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,
<span class="line-modified">2374                               declared_signature-&gt;return_type()-&gt;is_inlinetype());</span>
2375   // push result
2376   append_split(result);
2377 
2378   if (result_type != voidType) {
2379     if (method()-&gt;is_strict()) {
2380       push(result_type, round_fp(result));
2381     } else {
2382       push(result_type, result);
2383     }
2384   }
2385   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2386     profile_return_type(result, target);
2387   }
2388 }
2389 
2390 
2391 void GraphBuilder::new_instance(int klass_index) {
2392   ValueStack* state_before = copy_state_exhandling();
2393   bool will_link;
2394   ciKlass* klass = stream()-&gt;get_klass(will_link);
2395   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
<span class="line-modified">2396   assert(!klass-&gt;is_inlinetype(), &quot;must not be an inline klass&quot;);</span>
2397   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2398   _memory-&gt;new_instance(new_instance);
2399   apush(append_split(new_instance));
2400 }
2401 
2402 void GraphBuilder::default_value(int klass_index) {
2403   bool will_link;
2404   if (!stream()-&gt;is_unresolved_klass()) {
<span class="line-modified">2405     ciInlineKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_inline_klass();</span>
<span class="line-modified">2406     apush(append(new Constant(new InstanceConstant(vk-&gt;default_instance()))));</span>
2407   } else {
2408     ValueStack* state_before = copy_state_before();
2409     apush(append_split(new DefaultValue(state_before)));
2410   }
2411 }
2412 
2413 void GraphBuilder::new_type_array() {
2414   ValueStack* state_before = copy_state_exhandling();
2415   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2416 }
2417 
2418 
2419 void GraphBuilder::new_object_array() {
2420   bool will_link;
2421   ciKlass* klass = stream()-&gt;get_klass(will_link);
2422   bool never_null = stream()-&gt;is_inline_klass();
2423   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2424   NewArray* n = new NewObjectArray(klass, ipop(), state_before, never_null);
2425   apush(append_split(n));
2426 }
</pre>
<hr />
<pre>
2470   ciKlass* klass = stream()-&gt;get_klass(will_link);
2471   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2472   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2473   ipush(append_split(i));
2474   i-&gt;set_direct_compare(direct_compare(klass));
2475 
2476   if (is_profiling()) {
2477     // Note that we&#39;d collect profile data in this method if we wanted it.
2478     compilation()-&gt;set_would_profile(true);
2479 
2480     if (profile_checkcasts()) {
2481       i-&gt;set_profiled_method(method());
2482       i-&gt;set_profiled_bci(bci());
2483       i-&gt;set_should_profile(true);
2484     }
2485   }
2486 }
2487 
2488 
2489 void GraphBuilder::monitorenter(Value x, int bci) {
<span class="line-modified">2490   bool maybe_inlinetype = false;</span>
2491   if (bci == InvocationEntryBci) {
2492     // Called by GraphBuilder::inline_sync_entry.
2493 #ifdef ASSERT
2494     ciType* obj_type = x-&gt;declared_type();
<span class="line-modified">2495     assert(obj_type == NULL || !obj_type-&gt;is_inlinetype(), &quot;inline types cannot have synchronized methods&quot;);</span>
2496 #endif
2497   } else {
2498     // We are compiling a monitorenter bytecode
2499     if (EnableValhalla) {
2500       ciType* obj_type = x-&gt;declared_type();
<span class="line-modified">2501       if (obj_type == NULL || obj_type-&gt;as_klass()-&gt;can_be_inline_klass()) {</span>
<span class="line-modified">2502         // If we&#39;re (possibly) locking on an inline type, check for markWord::always_locked_pattern</span>
2503         // and throw IMSE. (obj_type is null for Phi nodes, so let&#39;s just be conservative).
<span class="line-modified">2504         maybe_inlinetype = true;</span>
2505       }
2506     }
2507   }
2508 
2509   // save state before locking in case of deoptimization after a NullPointerException
2510   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
<span class="line-modified">2511   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before, maybe_inlinetype), bci);</span>
2512   kill_all();
2513 }
2514 
2515 
2516 void GraphBuilder::monitorexit(Value x, int bci) {
2517   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2518   kill_all();
2519 }
2520 
2521 
2522 void GraphBuilder::new_multi_array(int dimensions) {
2523   bool will_link;
2524   ciKlass* klass = stream()-&gt;get_klass(will_link);
2525   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2526 
2527   Values* dims = new Values(dimensions, dimensions, NULL);
2528   // fill in all dimensions
2529   int i = dimensions;
2530   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2531   // create array
</pre>
<hr />
<pre>
3441 
3442   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3443   state-&gt;clear_locals();
3444   Goto* g = new Goto(target, false);
3445   append(g);
3446   _osr_entry-&gt;set_end(g);
3447   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3448 
3449   scope_data()-&gt;set_stream(NULL);
3450 }
3451 
3452 
3453 ValueStack* GraphBuilder::state_at_entry() {
3454   ValueStack* state = new ValueStack(scope(), NULL);
3455 
3456   // Set up locals for receiver
3457   int idx = 0;
3458   if (!method()-&gt;is_static()) {
3459     // we should always see the receiver
3460     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,
<span class="line-modified">3461              /*receiver*/ true, /*never_null*/ method()-&gt;holder()-&gt;is_flat_array_klass()));</span>
3462     idx = 1;
3463   }
3464 
3465   // Set up locals for incoming arguments
3466   ciSignature* sig = method()-&gt;signature();
3467   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3468     ciType* type = sig-&gt;type_at(i);
3469     BasicType basic_type = type-&gt;basic_type();
3470     // don&#39;t allow T_ARRAY to propagate into locals types
3471     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3472     ValueType* vt = as_ValueType(basic_type);
<span class="line-modified">3473     state-&gt;store_local(idx, new Local(type, vt, idx, false, type-&gt;is_inlinetype()));</span>
3474     idx += type-&gt;size();
3475   }
3476 
3477   // lock synchronized method
3478   if (method()-&gt;is_synchronized()) {
3479     state-&gt;lock(NULL);
3480   }
3481 
3482   return state;
3483 }
3484 
3485 
3486 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3487   : _scope_data(NULL)
3488   , _compilation(compilation)
3489   , _memory(new MemoryBuffer())
3490   , _inline_bailout_msg(NULL)
3491   , _instruction_count(0)
3492   , _osr_entry(NULL)
3493 {
</pre>
</td>
</tr>
</table>
<center><a href="c1_CodeStubs.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
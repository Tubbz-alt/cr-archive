<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_Instruction.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_IR.hpp&quot;
  27 #include &quot;c1/c1_Instruction.hpp&quot;
  28 
  29 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  30 #include &quot;c1/c1_ValueStack.hpp&quot;
  31 #include &quot;ci/ciFlatArrayKlass.hpp&quot;
  32 #include &quot;ci/ciInlineKlass.hpp&quot;
  33 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  34 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  35 #include &quot;utilities/bitMap.inline.hpp&quot;
  36 
  37 
  38 // Implementation of Instruction
  39 
  40 
  41 int Instruction::dominator_depth() {
  42   int result = -1;
  43   if (block()) {
  44     result = block()-&gt;dominator_depth();
  45   }
  46   assert(result != -1 || this-&gt;as_Local(), &quot;Only locals have dominator depth -1&quot;);
  47   return result;
  48 }
  49 
  50 Instruction::Condition Instruction::mirror(Condition cond) {
  51   switch (cond) {
  52     case eql: return eql;
  53     case neq: return neq;
  54     case lss: return gtr;
  55     case leq: return geq;
  56     case gtr: return lss;
  57     case geq: return leq;
  58     case aeq: return beq;
  59     case beq: return aeq;
  60   }
  61   ShouldNotReachHere();
  62   return eql;
  63 }
  64 
  65 
  66 Instruction::Condition Instruction::negate(Condition cond) {
  67   switch (cond) {
  68     case eql: return neq;
  69     case neq: return eql;
  70     case lss: return geq;
  71     case leq: return gtr;
  72     case gtr: return leq;
  73     case geq: return lss;
  74     case aeq: assert(false, &quot;Above equal cannot be negated&quot;);
  75     case beq: assert(false, &quot;Below equal cannot be negated&quot;);
  76   }
  77   ShouldNotReachHere();
  78   return eql;
  79 }
  80 
  81 void Instruction::update_exception_state(ValueStack* state) {
  82   if (state != NULL &amp;&amp; (state-&gt;kind() == ValueStack::EmptyExceptionState || state-&gt;kind() == ValueStack::ExceptionState)) {
  83     assert(state-&gt;kind() == ValueStack::EmptyExceptionState || Compilation::current()-&gt;env()-&gt;should_retain_local_variables(), &quot;unexpected state kind&quot;);
  84     _exception_state = state;
  85   } else {
  86     _exception_state = NULL;
  87   }
  88 }
  89 
  90 // Prev without need to have BlockBegin
  91 Instruction* Instruction::prev() {
  92   Instruction* p = NULL;
  93   Instruction* q = block();
  94   while (q != this) {
  95     assert(q != NULL, &quot;this is not in the block&#39;s instruction list&quot;);
  96     p = q; q = q-&gt;next();
  97   }
  98   return p;
  99 }
 100 
 101 
 102 void Instruction::state_values_do(ValueVisitor* f) {
 103   if (state_before() != NULL) {
 104     state_before()-&gt;values_do(f);
 105   }
 106   if (exception_state() != NULL){
 107     exception_state()-&gt;values_do(f);
 108   }
 109 }
 110 
 111 ciType* Instruction::exact_type() const {
 112   ciType* t =  declared_type();
 113   if (t != NULL &amp;&amp; t-&gt;is_klass()) {
 114     return t-&gt;as_klass()-&gt;exact_klass();
 115   }
 116   return NULL;
 117 }
 118 
 119 ciKlass* Instruction::as_loaded_klass_or_null() const {
 120   ciType* type = declared_type();
 121   if (type != NULL &amp;&amp; type-&gt;is_klass()) {
 122     ciKlass* klass = type-&gt;as_klass();
 123     if (klass-&gt;is_loaded()) {
 124       return klass;
 125     }
 126   }
 127   return NULL;
 128 }
 129 
 130 bool Instruction::is_loaded_flattened_array() const {
 131   if (UseFlatArray) {
 132     ciType* type = declared_type();
 133     return type != NULL &amp;&amp; type-&gt;is_flat_array_klass();
 134   }
 135   return false;
 136 }
 137 
 138 bool Instruction::maybe_flattened_array() {
 139   if (UseFlatArray) {
 140     ciType* type = declared_type();
 141     if (type != NULL) {
 142       if (type-&gt;is_obj_array_klass()) {
 143         // Due to array covariance, the runtime type might be a flattened array.
 144         ciKlass* element_klass = type-&gt;as_obj_array_klass()-&gt;element_klass();
 145         if (element_klass-&gt;can_be_inline_klass() &amp;&amp; (!element_klass-&gt;is_inlinetype() || element_klass-&gt;as_inline_klass()-&gt;flatten_array())) {
 146           return true;
 147         }
 148       } else if (type-&gt;is_flat_array_klass()) {
 149         ciKlass* element_klass = type-&gt;as_flat_array_klass()-&gt;element_klass();
 150         assert(!element_klass-&gt;is_loaded() || element_klass-&gt;as_inline_klass()-&gt;flatten_array(), &quot;must be flattened&quot;);
 151         return true;
 152       } else if (type-&gt;is_klass() &amp;&amp; type-&gt;as_klass()-&gt;is_java_lang_Object()) {
 153         // This can happen as a parameter to System.arraycopy()
 154         return true;
 155       }
 156     } else {
 157       // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
 158       // flattened array, so we should do a runtime check.
 159       return true;
 160     }
 161   }
 162   return false;
 163 }
 164 
 165 bool Instruction::maybe_null_free_array() {
 166   ciType* type = declared_type();
 167   if (type != NULL) {
 168     if (type-&gt;is_obj_array_klass()) {
 169       // Due to array covariance, the runtime type might be a null-free array.
 170       ciKlass* element_klass = type-&gt;as_obj_array_klass()-&gt;element_klass();
 171       if (element_klass-&gt;can_be_inline_klass()) {
 172         return true;
 173       }
 174     }
 175   } else {
 176     // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
 177     // null-free array, so we should do a runtime check.
 178     return true;
 179   }
 180   return false;
 181 }
 182 
 183 #ifndef PRODUCT
 184 void Instruction::check_state(ValueStack* state) {
 185   if (state != NULL) {
 186     state-&gt;verify();
 187   }
 188 }
 189 
 190 
 191 void Instruction::print() {
 192   InstructionPrinter ip;
 193   print(ip);
 194 }
 195 
 196 
 197 void Instruction::print_line() {
 198   InstructionPrinter ip;
 199   ip.print_line(this);
 200 }
 201 
 202 
 203 void Instruction::print(InstructionPrinter&amp; ip) {
 204   ip.print_head();
 205   ip.print_line(this);
 206   tty-&gt;cr();
 207 }
 208 #endif // PRODUCT
 209 
 210 
 211 // perform constant and interval tests on index value
 212 bool AccessIndexed::compute_needs_range_check() {
 213   if (length()) {
 214     Constant* clength = length()-&gt;as_Constant();
 215     Constant* cindex = index()-&gt;as_Constant();
 216     if (clength &amp;&amp; cindex) {
 217       IntConstant* l = clength-&gt;type()-&gt;as_IntConstant();
 218       IntConstant* i = cindex-&gt;type()-&gt;as_IntConstant();
 219       if (l &amp;&amp; i &amp;&amp; i-&gt;value() &lt; l-&gt;value() &amp;&amp; i-&gt;value() &gt;= 0) {
 220         return false;
 221       }
 222     }
 223   }
 224 
 225   if (!this-&gt;check_flag(NeedsRangeCheckFlag)) {
 226     return false;
 227   }
 228 
 229   return true;
 230 }
 231 
 232 
 233 ciType* Constant::exact_type() const {
 234   if (type()-&gt;is_object() &amp;&amp; type()-&gt;as_ObjectType()-&gt;is_loaded()) {
 235     return type()-&gt;as_ObjectType()-&gt;exact_type();
 236   }
 237   return NULL;
 238 }
 239 
 240 ciType* LoadIndexed::exact_type() const {
 241   ciType* array_type = array()-&gt;exact_type();
 242   if (array_type != NULL) {
 243     assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 244     ciArrayKlass* ak = (ciArrayKlass*)array_type;
 245 
 246     if (ak-&gt;element_type()-&gt;is_instance_klass()) {
 247       ciInstanceKlass* ik = (ciInstanceKlass*)ak-&gt;element_type();
 248       if (ik-&gt;is_loaded() &amp;&amp; ik-&gt;is_final()) {
 249         return ik;
 250       }
 251     }
 252   }
 253   return Instruction::exact_type();
 254 }
 255 
 256 
 257 ciType* LoadIndexed::declared_type() const {
 258   ciType* array_type = array()-&gt;declared_type();
 259   if (array_type == NULL || !array_type-&gt;is_loaded()) {
 260     return NULL;
 261   }
 262   assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 263   ciArrayKlass* ak = (ciArrayKlass*)array_type;
 264   return ak-&gt;element_type();
 265 }
 266 
 267 bool StoreIndexed::is_exact_flattened_array_store() const {
 268   if (array()-&gt;is_loaded_flattened_array() &amp;&amp; value()-&gt;as_Constant() == NULL &amp;&amp; value()-&gt;declared_type() != NULL) {
 269     ciKlass* element_klass = array()-&gt;declared_type()-&gt;as_flat_array_klass()-&gt;element_klass();
 270     ciKlass* actual_klass = value()-&gt;declared_type()-&gt;as_klass();
 271 
 272     // The following check can fail with inlining:
 273     //     void test45_inline(Object[] oa, Object o, int index) { oa[index] = o; }
 274     //     void test45(MyValue1[] va, int index, MyValue2 v) { test45_inline(va, v, index); }
 275     if (element_klass == actual_klass) {
 276       return true;
 277     }
 278   }
 279   return false;
 280 }
 281 
 282 ciType* LoadField::declared_type() const {
 283   return field()-&gt;type();
 284 }
 285 
 286 
 287 ciType* NewTypeArray::exact_type() const {
 288   return ciTypeArrayKlass::make(elt_type());
 289 }
 290 
 291 ciType* NewObjectArray::exact_type() const {
 292   return ciArrayKlass::make(klass());
 293 }
 294 
 295 ciType* NewMultiArray::exact_type() const {
 296   return _klass;
 297 }
 298 
 299 ciType* NewArray::declared_type() const {
 300   return exact_type();
 301 }
 302 
 303 ciType* NewInstance::exact_type() const {
 304   return klass();
 305 }
 306 
 307 ciType* NewInstance::declared_type() const {
 308   return exact_type();
 309 }
 310 
 311 Value NewInlineTypeInstance::depends_on() {
 312   if (_depends_on != this) {
 313     if (_depends_on-&gt;as_NewInlineTypeInstance() != NULL) {
 314       return _depends_on-&gt;as_NewInlineTypeInstance()-&gt;depends_on();
 315     }
 316   }
 317   return _depends_on;
 318 }
 319 
 320 ciType* NewInlineTypeInstance::exact_type() const {
 321   return klass();
 322 }
 323 
 324 ciType* NewInlineTypeInstance::declared_type() const {
 325   return exact_type();
 326 }
 327 
 328 ciType* CheckCast::declared_type() const {
 329   return klass();
 330 }
 331 
 332 // Implementation of ArithmeticOp
 333 
 334 bool ArithmeticOp::is_commutative() const {
 335   switch (op()) {
 336     case Bytecodes::_iadd: // fall through
 337     case Bytecodes::_ladd: // fall through
 338     case Bytecodes::_fadd: // fall through
 339     case Bytecodes::_dadd: // fall through
 340     case Bytecodes::_imul: // fall through
 341     case Bytecodes::_lmul: // fall through
 342     case Bytecodes::_fmul: // fall through
 343     case Bytecodes::_dmul: return true;
 344     default              : return false;
 345   }
 346 }
 347 
 348 
 349 bool ArithmeticOp::can_trap() const {
 350   switch (op()) {
 351     case Bytecodes::_idiv: // fall through
 352     case Bytecodes::_ldiv: // fall through
 353     case Bytecodes::_irem: // fall through
 354     case Bytecodes::_lrem: return true;
 355     default              : return false;
 356   }
 357 }
 358 
 359 
 360 // Implementation of LogicOp
 361 
 362 bool LogicOp::is_commutative() const {
 363 #ifdef ASSERT
 364   switch (op()) {
 365     case Bytecodes::_iand: // fall through
 366     case Bytecodes::_land: // fall through
 367     case Bytecodes::_ior : // fall through
 368     case Bytecodes::_lor : // fall through
 369     case Bytecodes::_ixor: // fall through
 370     case Bytecodes::_lxor: break;
 371     default              : ShouldNotReachHere(); break;
 372   }
 373 #endif
 374   // all LogicOps are commutative
 375   return true;
 376 }
 377 
 378 
 379 // Implementation of IfOp
 380 
 381 bool IfOp::is_commutative() const {
 382   return cond() == eql || cond() == neq;
 383 }
 384 
 385 
 386 // Implementation of StateSplit
 387 
 388 void StateSplit::substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block) {
 389   NOT_PRODUCT(bool assigned = false;)
 390   for (int i = 0; i &lt; list.length(); i++) {
 391     BlockBegin** b = list.adr_at(i);
 392     if (*b == old_block) {
 393       *b = new_block;
 394       NOT_PRODUCT(assigned = true;)
 395     }
 396   }
 397   assert(assigned == true, &quot;should have assigned at least once&quot;);
 398 }
 399 
 400 
 401 IRScope* StateSplit::scope() const {
 402   return _state-&gt;scope();
 403 }
 404 
 405 
 406 void StateSplit::state_values_do(ValueVisitor* f) {
 407   Instruction::state_values_do(f);
 408   if (state() != NULL) state()-&gt;values_do(f);
 409 }
 410 
 411 
 412 void BlockBegin::state_values_do(ValueVisitor* f) {
 413   StateSplit::state_values_do(f);
 414 
 415   if (is_set(BlockBegin::exception_entry_flag)) {
 416     for (int i = 0; i &lt; number_of_exception_states(); i++) {
 417       exception_state_at(i)-&gt;values_do(f);
 418     }
 419   }
 420 }
 421 
 422 
 423 // Implementation of Invoke
 424 
 425 
 426 Invoke::Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
 427                int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null)
 428   : StateSplit(result_type, state_before)
 429   , _code(code)
 430   , _recv(recv)
 431   , _args(args)
 432   , _vtable_index(vtable_index)
 433   , _target(target)
 434 {
 435   set_flag(TargetIsLoadedFlag,   target-&gt;is_loaded());
 436   set_flag(TargetIsFinalFlag,    target_is_loaded() &amp;&amp; target-&gt;is_final_method());
 437   set_flag(TargetIsStrictfpFlag, target_is_loaded() &amp;&amp; target-&gt;is_strict());
 438   set_never_null(never_null);
 439 
 440   assert(args != NULL, &quot;args must exist&quot;);
 441 #ifdef ASSERT
 442   AssertValues assert_value;
 443   values_do(&amp;assert_value);
 444 #endif
 445 
 446   // provide an initial guess of signature size.
 447   _signature = new BasicTypeList(number_of_arguments() + (has_receiver() ? 1 : 0));
 448   if (has_receiver()) {
 449     _signature-&gt;append(as_BasicType(receiver()-&gt;type()));
 450   }
 451   for (int i = 0; i &lt; number_of_arguments(); i++) {
 452     ValueType* t = argument_at(i)-&gt;type();
 453     BasicType bt = as_BasicType(t);
 454     _signature-&gt;append(bt);
 455   }
 456 }
 457 
 458 
 459 void Invoke::state_values_do(ValueVisitor* f) {
 460   StateSplit::state_values_do(f);
 461   if (state_before() != NULL) state_before()-&gt;values_do(f);
 462   if (state()        != NULL) state()-&gt;values_do(f);
 463 }
 464 
 465 ciType* Invoke::declared_type() const {
 466   ciSignature* declared_signature = state()-&gt;scope()-&gt;method()-&gt;get_declared_signature_at_bci(state()-&gt;bci());
 467   ciType *t = declared_signature-&gt;return_type();
 468   assert(t-&gt;basic_type() != T_VOID, &quot;need return value of void method?&quot;);
 469   return t;
 470 }
 471 
 472 // Implementation of Contant
 473 intx Constant::hash() const {
 474   if (state_before() == NULL) {
 475     switch (type()-&gt;tag()) {
 476     case intTag:
 477       return HASH2(name(), type()-&gt;as_IntConstant()-&gt;value());
 478     case addressTag:
 479       return HASH2(name(), type()-&gt;as_AddressConstant()-&gt;value());
 480     case longTag:
 481       {
 482         jlong temp = type()-&gt;as_LongConstant()-&gt;value();
 483         return HASH3(name(), high(temp), low(temp));
 484       }
 485     case floatTag:
 486       return HASH2(name(), jint_cast(type()-&gt;as_FloatConstant()-&gt;value()));
 487     case doubleTag:
 488       {
 489         jlong temp = jlong_cast(type()-&gt;as_DoubleConstant()-&gt;value());
 490         return HASH3(name(), high(temp), low(temp));
 491       }
 492     case objectTag:
 493       assert(type()-&gt;as_ObjectType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 494       return HASH2(name(), type()-&gt;as_ObjectType()-&gt;constant_value());
 495     case metaDataTag:
 496       assert(type()-&gt;as_MetadataType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 497       return HASH2(name(), type()-&gt;as_MetadataType()-&gt;constant_value());
 498     default:
 499       ShouldNotReachHere();
 500     }
 501   }
 502   return 0;
 503 }
 504 
 505 bool Constant::is_equal(Value v) const {
 506   if (v-&gt;as_Constant() == NULL) return false;
 507 
 508   switch (type()-&gt;tag()) {
 509     case intTag:
 510       {
 511         IntConstant* t1 =    type()-&gt;as_IntConstant();
 512         IntConstant* t2 = v-&gt;type()-&gt;as_IntConstant();
 513         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 514                 t1-&gt;value() == t2-&gt;value());
 515       }
 516     case longTag:
 517       {
 518         LongConstant* t1 =    type()-&gt;as_LongConstant();
 519         LongConstant* t2 = v-&gt;type()-&gt;as_LongConstant();
 520         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 521                 t1-&gt;value() == t2-&gt;value());
 522       }
 523     case floatTag:
 524       {
 525         FloatConstant* t1 =    type()-&gt;as_FloatConstant();
 526         FloatConstant* t2 = v-&gt;type()-&gt;as_FloatConstant();
 527         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 528                 jint_cast(t1-&gt;value()) == jint_cast(t2-&gt;value()));
 529       }
 530     case doubleTag:
 531       {
 532         DoubleConstant* t1 =    type()-&gt;as_DoubleConstant();
 533         DoubleConstant* t2 = v-&gt;type()-&gt;as_DoubleConstant();
 534         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 535                 jlong_cast(t1-&gt;value()) == jlong_cast(t2-&gt;value()));
 536       }
 537     case objectTag:
 538       {
 539         ObjectType* t1 =    type()-&gt;as_ObjectType();
 540         ObjectType* t2 = v-&gt;type()-&gt;as_ObjectType();
 541         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 542                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 543                 t1-&gt;constant_value() == t2-&gt;constant_value());
 544       }
 545     case metaDataTag:
 546       {
 547         MetadataType* t1 =    type()-&gt;as_MetadataType();
 548         MetadataType* t2 = v-&gt;type()-&gt;as_MetadataType();
 549         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 550                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 551                 t1-&gt;constant_value() == t2-&gt;constant_value());
 552       }
 553     default:
 554       return false;
 555   }
 556 }
 557 
 558 Constant::CompareResult Constant::compare(Instruction::Condition cond, Value right) const {
 559   Constant* rc = right-&gt;as_Constant();
 560   // other is not a constant
 561   if (rc == NULL) return not_comparable;
 562 
 563   ValueType* lt = type();
 564   ValueType* rt = rc-&gt;type();
 565   // different types
 566   if (lt-&gt;base() != rt-&gt;base()) return not_comparable;
 567   switch (lt-&gt;tag()) {
 568   case intTag: {
 569     int x = lt-&gt;as_IntConstant()-&gt;value();
 570     int y = rt-&gt;as_IntConstant()-&gt;value();
 571     switch (cond) {
 572     case If::eql: return x == y ? cond_true : cond_false;
 573     case If::neq: return x != y ? cond_true : cond_false;
 574     case If::lss: return x &lt;  y ? cond_true : cond_false;
 575     case If::leq: return x &lt;= y ? cond_true : cond_false;
 576     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 577     case If::geq: return x &gt;= y ? cond_true : cond_false;
 578     default     : break;
 579     }
 580     break;
 581   }
 582   case longTag: {
 583     jlong x = lt-&gt;as_LongConstant()-&gt;value();
 584     jlong y = rt-&gt;as_LongConstant()-&gt;value();
 585     switch (cond) {
 586     case If::eql: return x == y ? cond_true : cond_false;
 587     case If::neq: return x != y ? cond_true : cond_false;
 588     case If::lss: return x &lt;  y ? cond_true : cond_false;
 589     case If::leq: return x &lt;= y ? cond_true : cond_false;
 590     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 591     case If::geq: return x &gt;= y ? cond_true : cond_false;
 592     default     : break;
 593     }
 594     break;
 595   }
 596   case objectTag: {
 597     ciObject* xvalue = lt-&gt;as_ObjectType()-&gt;constant_value();
 598     ciObject* yvalue = rt-&gt;as_ObjectType()-&gt;constant_value();
 599     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 600     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 601       switch (cond) {
 602       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 603       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 604       default     : break;
 605       }
 606     }
 607     break;
 608   }
 609   case metaDataTag: {
 610     ciMetadata* xvalue = lt-&gt;as_MetadataType()-&gt;constant_value();
 611     ciMetadata* yvalue = rt-&gt;as_MetadataType()-&gt;constant_value();
 612     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 613     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 614       switch (cond) {
 615       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 616       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 617       default     : break;
 618       }
 619     }
 620     break;
 621   }
 622   default:
 623     break;
 624   }
 625   return not_comparable;
 626 }
 627 
 628 
 629 // Implementation of BlockBegin
 630 
 631 void BlockBegin::set_end(BlockEnd* end) {
 632   assert(end != NULL, &quot;should not reset block end to NULL&quot;);
 633   if (end == _end) {
 634     return;
 635   }
 636   clear_end();
 637 
 638   // Set the new end
 639   _end = end;
 640 
 641   _successors.clear();
 642   // Now reset successors list based on BlockEnd
 643   for (int i = 0; i &lt; end-&gt;number_of_sux(); i++) {
 644     BlockBegin* sux = end-&gt;sux_at(i);
 645     _successors.append(sux);
 646     sux-&gt;_predecessors.append(this);
 647   }
 648   _end-&gt;set_begin(this);
 649 }
 650 
 651 
 652 void BlockBegin::clear_end() {
 653   // Must make the predecessors/successors match up with the
 654   // BlockEnd&#39;s notion.
 655   if (_end != NULL) {
 656     // disconnect from the old end
 657     _end-&gt;set_begin(NULL);
 658 
 659     // disconnect this block from it&#39;s current successors
 660     for (int i = 0; i &lt; _successors.length(); i++) {
 661       _successors.at(i)-&gt;remove_predecessor(this);
 662     }
 663     _end = NULL;
 664   }
 665 }
 666 
 667 
 668 void BlockBegin::disconnect_edge(BlockBegin* from, BlockBegin* to) {
 669   // disconnect any edges between from and to
 670 #ifndef PRODUCT
 671   if (PrintIR &amp;&amp; Verbose) {
 672     tty-&gt;print_cr(&quot;Disconnected edge B%d -&gt; B%d&quot;, from-&gt;block_id(), to-&gt;block_id());
 673   }
 674 #endif
 675   for (int s = 0; s &lt; from-&gt;number_of_sux();) {
 676     BlockBegin* sux = from-&gt;sux_at(s);
 677     if (sux == to) {
 678       int index = sux-&gt;_predecessors.find(from);
 679       if (index &gt;= 0) {
 680         sux-&gt;_predecessors.remove_at(index);
 681       }
 682       from-&gt;_successors.remove_at(s);
 683     } else {
 684       s++;
 685     }
 686   }
 687 }
 688 
 689 
 690 void BlockBegin::disconnect_from_graph() {
 691   // disconnect this block from all other blocks
 692   for (int p = 0; p &lt; number_of_preds(); p++) {
 693     pred_at(p)-&gt;remove_successor(this);
 694   }
 695   for (int s = 0; s &lt; number_of_sux(); s++) {
 696     sux_at(s)-&gt;remove_predecessor(this);
 697   }
 698 }
 699 
 700 void BlockBegin::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
 701   // modify predecessors before substituting successors
 702   for (int i = 0; i &lt; number_of_sux(); i++) {
 703     if (sux_at(i) == old_sux) {
 704       // remove old predecessor before adding new predecessor
 705       // otherwise there is a dead predecessor in the list
 706       new_sux-&gt;remove_predecessor(old_sux);
 707       new_sux-&gt;add_predecessor(this);
 708     }
 709   }
 710   old_sux-&gt;remove_predecessor(this);
 711   end()-&gt;substitute_sux(old_sux, new_sux);
 712 }
 713 
 714 
 715 
 716 // In general it is not possible to calculate a value for the field &quot;depth_first_number&quot;
 717 // of the inserted block, without recomputing the values of the other blocks
 718 // in the CFG. Therefore the value of &quot;depth_first_number&quot; in BlockBegin becomes meaningless.
 719 BlockBegin* BlockBegin::insert_block_between(BlockBegin* sux) {
 720   int bci = sux-&gt;bci();
 721   // critical edge splitting may introduce a goto after a if and array
 722   // bound check elimination may insert a predicate between the if and
 723   // goto. The bci of the goto can&#39;t be the one of the if otherwise
 724   // the state and bci are inconsistent and a deoptimization triggered
 725   // by the predicate would lead to incorrect execution/a crash.
 726   BlockBegin* new_sux = new BlockBegin(bci);
 727 
 728   // mark this block (special treatment when block order is computed)
 729   new_sux-&gt;set(critical_edge_split_flag);
 730 
 731   // This goto is not a safepoint.
 732   Goto* e = new Goto(sux, false);
 733   new_sux-&gt;set_next(e, bci);
 734   new_sux-&gt;set_end(e);
 735   // setup states
 736   ValueStack* s = end()-&gt;state();
 737   new_sux-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 738   e-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 739   assert(new_sux-&gt;state()-&gt;locals_size() == s-&gt;locals_size(), &quot;local size mismatch!&quot;);
 740   assert(new_sux-&gt;state()-&gt;stack_size() == s-&gt;stack_size(), &quot;stack size mismatch!&quot;);
 741   assert(new_sux-&gt;state()-&gt;locks_size() == s-&gt;locks_size(), &quot;locks size mismatch!&quot;);
 742 
 743   // link predecessor to new block
 744   end()-&gt;substitute_sux(sux, new_sux);
 745 
 746   // The ordering needs to be the same, so remove the link that the
 747   // set_end call above added and substitute the new_sux for this
 748   // block.
 749   sux-&gt;remove_predecessor(new_sux);
 750 
 751   // the successor could be the target of a switch so it might have
 752   // multiple copies of this predecessor, so substitute the new_sux
 753   // for the first and delete the rest.
 754   bool assigned = false;
 755   BlockList&amp; list = sux-&gt;_predecessors;
 756   for (int i = 0; i &lt; list.length(); i++) {
 757     BlockBegin** b = list.adr_at(i);
 758     if (*b == this) {
 759       if (assigned) {
 760         list.remove_at(i);
 761         // reprocess this index
 762         i--;
 763       } else {
 764         assigned = true;
 765         *b = new_sux;
 766       }
 767       // link the new block back to it&#39;s predecessors.
 768       new_sux-&gt;add_predecessor(this);
 769     }
 770   }
 771   assert(assigned == true, &quot;should have assigned at least once&quot;);
 772   return new_sux;
 773 }
 774 
 775 
 776 void BlockBegin::remove_successor(BlockBegin* pred) {
 777   int idx;
 778   while ((idx = _successors.find(pred)) &gt;= 0) {
 779     _successors.remove_at(idx);
 780   }
 781 }
 782 
 783 
 784 void BlockBegin::add_predecessor(BlockBegin* pred) {
 785   _predecessors.append(pred);
 786 }
 787 
 788 
 789 void BlockBegin::remove_predecessor(BlockBegin* pred) {
 790   int idx;
 791   while ((idx = _predecessors.find(pred)) &gt;= 0) {
 792     _predecessors.remove_at(idx);
 793   }
 794 }
 795 
 796 
 797 void BlockBegin::add_exception_handler(BlockBegin* b) {
 798   assert(b != NULL &amp;&amp; (b-&gt;is_set(exception_entry_flag)), &quot;exception handler must exist&quot;);
 799   // add only if not in the list already
 800   if (!_exception_handlers.contains(b)) _exception_handlers.append(b);
 801 }
 802 
 803 int BlockBegin::add_exception_state(ValueStack* state) {
 804   assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;);
 805   if (_exception_states == NULL) {
 806     _exception_states = new ValueStackStack(4);
 807   }
 808   _exception_states-&gt;append(state);
 809   return _exception_states-&gt;length() - 1;
 810 }
 811 
 812 
 813 void BlockBegin::iterate_preorder(boolArray&amp; mark, BlockClosure* closure) {
 814   if (!mark.at(block_id())) {
 815     mark.at_put(block_id(), true);
 816     closure-&gt;block_do(this);
 817     BlockEnd* e = end(); // must do this after block_do because block_do may change it!
 818     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_preorder(mark, closure); }
 819     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_preorder(mark, closure); }
 820   }
 821 }
 822 
 823 
 824 void BlockBegin::iterate_postorder(boolArray&amp; mark, BlockClosure* closure) {
 825   if (!mark.at(block_id())) {
 826     mark.at_put(block_id(), true);
 827     BlockEnd* e = end();
 828     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_postorder(mark, closure); }
 829     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_postorder(mark, closure); }
 830     closure-&gt;block_do(this);
 831   }
 832 }
 833 
 834 
 835 void BlockBegin::iterate_preorder(BlockClosure* closure) {
 836   int mark_len = number_of_blocks();
 837   boolArray mark(mark_len, mark_len, false);
 838   iterate_preorder(mark, closure);
 839 }
 840 
 841 
 842 void BlockBegin::iterate_postorder(BlockClosure* closure) {
 843   int mark_len = number_of_blocks();
 844   boolArray mark(mark_len, mark_len, false);
 845   iterate_postorder(mark, closure);
 846 }
 847 
 848 
 849 void BlockBegin::block_values_do(ValueVisitor* f) {
 850   for (Instruction* n = this; n != NULL; n = n-&gt;next()) n-&gt;values_do(f);
 851 }
 852 
 853 
 854 #ifndef PRODUCT
 855    #define TRACE_PHI(code) if (PrintPhiFunctions) { code; }
 856 #else
 857    #define TRACE_PHI(coce)
 858 #endif
 859 
 860 
 861 bool BlockBegin::try_merge(ValueStack* new_state) {
 862   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d&quot;, block_id()));
 863 
 864   // local variables used for state iteration
 865   int index;
 866   Value new_value, existing_value;
 867 
 868   ValueStack* existing_state = state();
 869   if (existing_state == NULL) {
 870     TRACE_PHI(tty-&gt;print_cr(&quot;first call of try_merge for this block&quot;));
 871 
 872     if (is_set(BlockBegin::was_visited_flag)) {
 873       // this actually happens for complicated jsr/ret structures
 874       return false; // BAILOUT in caller
 875     }
 876 
 877     // copy state because it is altered
 878     new_state = new_state-&gt;copy(ValueStack::BlockBeginState, bci());
 879 
 880     // Use method liveness to invalidate dead locals
 881     MethodLivenessResult liveness = new_state-&gt;scope()-&gt;method()-&gt;liveness_at_bci(bci());
 882     if (liveness.is_valid()) {
 883       assert((int)liveness.size() == new_state-&gt;locals_size(), &quot;error in use of liveness&quot;);
 884 
 885       for_each_local_value(new_state, index, new_value) {
 886         if (!liveness.at(index) || new_value-&gt;type()-&gt;is_illegal()) {
 887           new_state-&gt;invalidate_local(index);
 888           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating dead local %d&quot;, index));
 889         }
 890       }
 891     }
 892 
 893     if (is_set(BlockBegin::parser_loop_header_flag)) {
 894       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, initializing phi functions&quot;));
 895 
 896       for_each_stack_value(new_state, index, new_value) {
 897         new_state-&gt;setup_phi_for_stack(this, index);
 898         TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, new_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;stack_at(index)-&gt;id(), index));
 899       }
 900 
 901       BitMap&amp; requires_phi_function = new_state-&gt;scope()-&gt;requires_phi_function();
 902 
 903       for_each_local_value(new_state, index, new_value) {
 904         bool requires_phi = requires_phi_function.at(index) || (new_value-&gt;type()-&gt;is_double_word() &amp;&amp; requires_phi_function.at(index + 1));
 905         if (requires_phi || !SelectivePhiFunctions) {
 906           new_state-&gt;setup_phi_for_local(this, index);
 907           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, new_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;local_at(index)-&gt;id(), index));
 908         }
 909       }
 910     }
 911 
 912     // initialize state of block
 913     set_state(new_state);
 914 
 915   } else if (existing_state-&gt;is_same(new_state)) {
 916     TRACE_PHI(tty-&gt;print_cr(&quot;exisiting state found&quot;));
 917 
 918     assert(existing_state-&gt;scope() == new_state-&gt;scope(), &quot;not matching&quot;);
 919     assert(existing_state-&gt;locals_size() == new_state-&gt;locals_size(), &quot;not matching&quot;);
 920     assert(existing_state-&gt;stack_size() == new_state-&gt;stack_size(), &quot;not matching&quot;);
 921 
 922     if (is_set(BlockBegin::was_visited_flag)) {
 923       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, phis must be present&quot;));
 924 
 925       if (!is_set(BlockBegin::parser_loop_header_flag)) {
 926         // this actually happens for complicated jsr/ret structures
 927         return false; // BAILOUT in caller
 928       }
 929 
 930       for_each_local_value(existing_state, index, existing_value) {
 931         Value new_value = new_state-&gt;local_at(index);
 932         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
 933           Phi* existing_phi = existing_value-&gt;as_Phi();
 934           if (existing_phi == NULL) {
 935             return false; // BAILOUT in caller
 936           }
 937           // Invalidate the phi function here. This case is very rare except for
 938           // JVMTI capability &quot;can_access_local_variables&quot;.
 939           // In really rare cases we will bail out in LIRGenerator::move_to_phi.
 940           existing_phi-&gt;make_illegal();
 941           existing_state-&gt;invalidate_local(index);
 942           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
 943         }
 944       }
 945 
 946 #ifdef ASSERT
 947       // check that all necessary phi functions are present
 948       for_each_stack_value(existing_state, index, existing_value) {
 949         assert(existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;block() == this, &quot;phi function required&quot;);
 950       }
 951       for_each_local_value(existing_state, index, existing_value) {
 952         assert(existing_value == new_state-&gt;local_at(index) || (existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;as_Phi()-&gt;block() == this), &quot;phi function required&quot;);
 953       }
 954 #endif
 955 
 956     } else {
 957       TRACE_PHI(tty-&gt;print_cr(&quot;creating phi functions on demand&quot;));
 958 
 959       // create necessary phi functions for stack
 960       for_each_stack_value(existing_state, index, existing_value) {
 961         Value new_value = new_state-&gt;stack_at(index);
 962         Phi* existing_phi = existing_value-&gt;as_Phi();
 963 
 964         if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
 965           existing_state-&gt;setup_phi_for_stack(this, index);
 966           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, existing_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;stack_at(index)-&gt;id(), index));
 967         }
 968       }
 969 
 970       // create necessary phi functions for locals
 971       for_each_local_value(existing_state, index, existing_value) {
 972         Value new_value = new_state-&gt;local_at(index);
 973         Phi* existing_phi = existing_value-&gt;as_Phi();
 974 
 975         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
 976           existing_state-&gt;invalidate_local(index);
 977           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
 978         } else if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
 979           existing_state-&gt;setup_phi_for_local(this, index);
 980           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, existing_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;local_at(index)-&gt;id(), index));
 981         }
 982       }
 983     }
 984 
 985     assert(existing_state-&gt;caller_state() == new_state-&gt;caller_state(), &quot;caller states must be equal&quot;);
 986 
 987   } else {
 988     assert(false, &quot;stack or locks not matching (invalid bytecodes)&quot;);
 989     return false;
 990   }
 991 
 992   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d successful&quot;, block_id()));
 993 
 994   return true;
 995 }
 996 
 997 
 998 #ifndef PRODUCT
 999 void BlockBegin::print_block() {
1000   InstructionPrinter ip;
1001   print_block(ip, false);
1002 }
1003 
1004 
1005 void BlockBegin::print_block(InstructionPrinter&amp; ip, bool live_only) {
1006   ip.print_instr(this); tty-&gt;cr();
1007   ip.print_stack(this-&gt;state()); tty-&gt;cr();
1008   ip.print_inline_level(this);
1009   ip.print_head();
1010   for (Instruction* n = next(); n != NULL; n = n-&gt;next()) {
1011     if (!live_only || n-&gt;is_pinned() || n-&gt;use_count() &gt; 0) {
1012       ip.print_line(n);
1013     }
1014   }
1015   tty-&gt;cr();
1016 }
1017 #endif // PRODUCT
1018 
1019 
1020 // Implementation of BlockList
1021 
1022 void BlockList::iterate_forward (BlockClosure* closure) {
1023   const int l = length();
1024   for (int i = 0; i &lt; l; i++) closure-&gt;block_do(at(i));
1025 }
1026 
1027 
1028 void BlockList::iterate_backward(BlockClosure* closure) {
1029   for (int i = length() - 1; i &gt;= 0; i--) closure-&gt;block_do(at(i));
1030 }
1031 
1032 
1033 void BlockList::blocks_do(void f(BlockBegin*)) {
1034   for (int i = length() - 1; i &gt;= 0; i--) f(at(i));
1035 }
1036 
1037 
1038 void BlockList::values_do(ValueVisitor* f) {
1039   for (int i = length() - 1; i &gt;= 0; i--) at(i)-&gt;block_values_do(f);
1040 }
1041 
1042 
1043 #ifndef PRODUCT
1044 void BlockList::print(bool cfg_only, bool live_only) {
1045   InstructionPrinter ip;
1046   for (int i = 0; i &lt; length(); i++) {
1047     BlockBegin* block = at(i);
1048     if (cfg_only) {
1049       ip.print_instr(block); tty-&gt;cr();
1050     } else {
1051       block-&gt;print_block(ip, live_only);
1052     }
1053   }
1054 }
1055 #endif // PRODUCT
1056 
1057 
1058 // Implementation of BlockEnd
1059 
1060 void BlockEnd::set_begin(BlockBegin* begin) {
1061   BlockList* sux = NULL;
1062   if (begin != NULL) {
1063     sux = begin-&gt;successors();
1064   } else if (this-&gt;begin() != NULL) {
1065     // copy our sux list
1066     BlockList* sux = new BlockList(this-&gt;begin()-&gt;number_of_sux());
1067     for (int i = 0; i &lt; this-&gt;begin()-&gt;number_of_sux(); i++) {
1068       sux-&gt;append(this-&gt;begin()-&gt;sux_at(i));
1069     }
1070   }
1071   _sux = sux;
1072 }
1073 
1074 
1075 void BlockEnd::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
1076   substitute(*_sux, old_sux, new_sux);
1077 }
1078 
1079 
1080 // Implementation of Phi
1081 
1082 // Normal phi functions take their operands from the last instruction of the
1083 // predecessor. Special handling is needed for xhanlder entries because there
1084 // the state of arbitrary instructions are needed.
1085 
1086 Value Phi::operand_at(int i) const {
1087   ValueStack* state;
1088   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1089     state = _block-&gt;exception_state_at(i);
1090   } else {
1091     state = _block-&gt;pred_at(i)-&gt;end()-&gt;state();
1092   }
1093   assert(state != NULL, &quot;&quot;);
1094 
1095   if (is_local()) {
1096     return state-&gt;local_at(local_index());
1097   } else {
1098     return state-&gt;stack_at(stack_index());
1099   }
1100 }
1101 
1102 
1103 int Phi::operand_count() const {
1104   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1105     return _block-&gt;number_of_exception_states();
1106   } else {
1107     return _block-&gt;number_of_preds();
1108   }
1109 }
1110 
1111 #ifdef ASSERT
1112 // Constructor of Assert
1113 Assert::Assert(Value x, Condition cond, bool unordered_is_true, Value y) : Instruction(illegalType)
1114   , _x(x)
1115   , _cond(cond)
1116   , _y(y)
1117 {
1118   set_flag(UnorderedIsTrueFlag, unordered_is_true);
1119   assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1120   pin();
1121 
1122   stringStream strStream;
1123   Compilation::current()-&gt;method()-&gt;print_name(&amp;strStream);
1124 
1125   stringStream strStream1;
1126   InstructionPrinter ip1(1, &amp;strStream1);
1127   ip1.print_instr(x);
1128 
1129   stringStream strStream2;
1130   InstructionPrinter ip2(1, &amp;strStream2);
1131   ip2.print_instr(y);
1132 
1133   stringStream ss;
1134   ss.print(&quot;Assertion %s %s %s in method %s&quot;, strStream1.as_string(), ip2.cond_name(cond), strStream2.as_string(), strStream.as_string());
1135 
1136   _message = ss.as_string();
1137 }
1138 #endif
1139 
1140 void RangeCheckPredicate::check_state() {
1141   assert(state()-&gt;kind() != ValueStack::EmptyExceptionState &amp;&amp; state()-&gt;kind() != ValueStack::ExceptionState, &quot;will deopt with empty state&quot;);
1142 }
1143 
1144 void ProfileInvoke::state_values_do(ValueVisitor* f) {
1145   if (state() != NULL) state()-&gt;values_do(f);
1146 }
    </pre>
  </body>
</html>
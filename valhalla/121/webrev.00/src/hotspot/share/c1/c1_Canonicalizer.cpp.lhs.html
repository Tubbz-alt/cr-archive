<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Canonicalizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  27 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  28 #include &quot;c1/c1_ValueStack.hpp&quot;
  29 #include &quot;ci/ciArray.hpp&quot;
  30 #include &quot;runtime/sharedRuntime.hpp&quot;
  31 
  32 
  33 class PrintValueVisitor: public ValueVisitor {
  34   void visit(Value* vp) {
  35     (*vp)-&gt;print_line();
  36   }
  37 };
  38 
  39 void Canonicalizer::set_canonical(Value x) {
  40   assert(x != NULL, &quot;value must exist&quot;);
  41   // Note: we can not currently substitute root nodes which show up in
  42   // the instruction stream (because the instruction list is embedded
  43   // in the instructions).
  44   if (canonical() != x) {
  45 #ifndef PRODUCT
  46     if (!x-&gt;has_printable_bci()) {
  47       x-&gt;set_printable_bci(bci());
  48     }
  49 #endif
  50     if (PrintCanonicalization) {
  51       PrintValueVisitor do_print_value;
  52       canonical()-&gt;input_values_do(&amp;do_print_value);
  53       canonical()-&gt;print_line();
  54       tty-&gt;print_cr(&quot;canonicalized to:&quot;);
  55       x-&gt;input_values_do(&amp;do_print_value);
  56       x-&gt;print_line();
  57       tty-&gt;cr();
  58     }
  59     assert(_canonical-&gt;type()-&gt;tag() == x-&gt;type()-&gt;tag(), &quot;types must match&quot;);
  60     _canonical = x;
  61   }
  62 }
  63 
  64 
  65 void Canonicalizer::move_const_to_right(Op2* x) {
  66   if (x-&gt;x()-&gt;type()-&gt;is_constant() &amp;&amp; x-&gt;is_commutative()) x-&gt;swap_operands();
  67 }
  68 
  69 
  70 void Canonicalizer::do_Op2(Op2* x) {
  71   if (x-&gt;x() == x-&gt;y()) {
  72     switch (x-&gt;op()) {
  73     case Bytecodes::_isub: set_constant(0); return;
  74     case Bytecodes::_lsub: set_constant(jlong_cast(0)); return;
  75     case Bytecodes::_iand: // fall through
  76     case Bytecodes::_land: // fall through
  77     case Bytecodes::_ior : // fall through
  78     case Bytecodes::_lor : set_canonical(x-&gt;x()); return;
  79     case Bytecodes::_ixor: set_constant(0); return;
  80     case Bytecodes::_lxor: set_constant(jlong_cast(0)); return;
  81     default              : break;
  82     }
  83   }
  84 
  85   if (x-&gt;x()-&gt;type()-&gt;is_constant() &amp;&amp; x-&gt;y()-&gt;type()-&gt;is_constant()) {
  86     // do constant folding for selected operations
  87     switch (x-&gt;type()-&gt;tag()) {
  88       case intTag:
  89         { jint a = x-&gt;x()-&gt;type()-&gt;as_IntConstant()-&gt;value();
  90           jint b = x-&gt;y()-&gt;type()-&gt;as_IntConstant()-&gt;value();
  91           switch (x-&gt;op()) {
  92             case Bytecodes::_iadd: set_constant(a + b); return;
  93             case Bytecodes::_isub: set_constant(a - b); return;
  94             case Bytecodes::_imul: set_constant(a * b); return;
  95             case Bytecodes::_idiv:
  96               if (b != 0) {
  97                 if (a == min_jint &amp;&amp; b == -1) {
  98                   set_constant(min_jint);
  99                 } else {
 100                   set_constant(a / b);
 101                 }
 102                 return;
 103               }
 104               break;
 105             case Bytecodes::_irem:
 106               if (b != 0) {
 107                 if (a == min_jint &amp;&amp; b == -1) {
 108                   set_constant(0);
 109                 } else {
 110                   set_constant(a % b);
 111                 }
 112                 return;
 113               }
 114               break;
 115             case Bytecodes::_iand: set_constant(a &amp; b); return;
 116             case Bytecodes::_ior : set_constant(a | b); return;
 117             case Bytecodes::_ixor: set_constant(a ^ b); return;
 118             default              : break;
 119           }
 120         }
 121         break;
 122       case longTag:
 123         { jlong a = x-&gt;x()-&gt;type()-&gt;as_LongConstant()-&gt;value();
 124           jlong b = x-&gt;y()-&gt;type()-&gt;as_LongConstant()-&gt;value();
 125           switch (x-&gt;op()) {
 126             case Bytecodes::_ladd: set_constant(a + b); return;
 127             case Bytecodes::_lsub: set_constant(a - b); return;
 128             case Bytecodes::_lmul: set_constant(a * b); return;
 129             case Bytecodes::_ldiv:
 130               if (b != 0) {
 131                 set_constant(SharedRuntime::ldiv(b, a));
 132                 return;
 133               }
 134               break;
 135             case Bytecodes::_lrem:
 136               if (b != 0) {
 137                 set_constant(SharedRuntime::lrem(b, a));
 138                 return;
 139               }
 140               break;
 141             case Bytecodes::_land: set_constant(a &amp; b); return;
 142             case Bytecodes::_lor : set_constant(a | b); return;
 143             case Bytecodes::_lxor: set_constant(a ^ b); return;
 144             default              : break;
 145           }
 146         }
 147         break;
 148       default:
 149         // other cases not implemented (must be extremely careful with floats &amp; doubles!)
 150         break;
 151     }
 152   }
 153   // make sure constant is on the right side, if any
 154   move_const_to_right(x);
 155 
 156   if (x-&gt;y()-&gt;type()-&gt;is_constant()) {
 157     // do constant folding for selected operations
 158     switch (x-&gt;type()-&gt;tag()) {
 159       case intTag:
 160         if (x-&gt;y()-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0) {
 161           switch (x-&gt;op()) {
 162             case Bytecodes::_iadd: set_canonical(x-&gt;x()); return;
 163             case Bytecodes::_isub: set_canonical(x-&gt;x()); return;
 164             case Bytecodes::_imul: set_constant(0); return;
 165               // Note: for div and rem, make sure that C semantics
 166               //       corresponds to Java semantics!
 167             case Bytecodes::_iand: set_constant(0); return;
 168             case Bytecodes::_ior : set_canonical(x-&gt;x()); return;
 169             default              : break;
 170           }
 171         }
 172         break;
 173       case longTag:
 174         if (x-&gt;y()-&gt;type()-&gt;as_LongConstant()-&gt;value() == (jlong)0) {
 175           switch (x-&gt;op()) {
 176             case Bytecodes::_ladd: set_canonical(x-&gt;x()); return;
 177             case Bytecodes::_lsub: set_canonical(x-&gt;x()); return;
 178             case Bytecodes::_lmul: set_constant((jlong)0); return;
 179               // Note: for div and rem, make sure that C semantics
 180               //       corresponds to Java semantics!
 181             case Bytecodes::_land: set_constant((jlong)0); return;
 182             case Bytecodes::_lor : set_canonical(x-&gt;x()); return;
 183             default              : break;
 184           }
 185         }
 186         break;
 187       default:
 188         break;
 189     }
 190   }
 191 }
 192 
 193 
 194 void Canonicalizer::do_Phi            (Phi*             x) {}
 195 void Canonicalizer::do_Constant       (Constant*        x) {}
 196 void Canonicalizer::do_Local          (Local*           x) {}
 197 void Canonicalizer::do_LoadField      (LoadField*       x) {}
 198 
 199 // checks if v is in the block that is currently processed by
 200 // GraphBuilder. This is the only block that has not BlockEnd yet.
 201 static bool in_current_block(Value v) {
 202   int max_distance = 4;
 203   while (max_distance &gt; 0 &amp;&amp; v != NULL &amp;&amp; v-&gt;as_BlockEnd() == NULL) {
 204     v = v-&gt;next();
 205     max_distance--;
 206   }
 207   return v == NULL;
 208 }
 209 
 210 void Canonicalizer::do_StoreField     (StoreField*      x) {
 211   // If a value is going to be stored into a field or array some of
 212   // the conversions emitted by javac are unneeded because the fields
 213   // are packed to their natural size.
 214   Convert* conv = x-&gt;value()-&gt;as_Convert();
 215   if (conv) {
 216     Value value = NULL;
 217     BasicType type = x-&gt;field()-&gt;type()-&gt;basic_type();
 218     switch (conv-&gt;op()) {
 219     case Bytecodes::_i2b: if (type == T_BYTE)  value = conv-&gt;value(); break;
 220     case Bytecodes::_i2s: if (type == T_SHORT || type == T_BYTE) value = conv-&gt;value(); break;
 221     case Bytecodes::_i2c: if (type == T_CHAR  || type == T_BYTE)  value = conv-&gt;value(); break;
 222     default             : break;
 223     }
 224     // limit this optimization to current block
 225     if (value != NULL &amp;&amp; in_current_block(conv)) {
 226       set_canonical(new StoreField(x-&gt;obj(), x-&gt;offset(), x-&gt;field(), value, x-&gt;is_static(),
 227                                    x-&gt;state_before(), x-&gt;needs_patching()));
 228       return;
 229     }
 230   }
 231 
 232 }
 233 
 234 void Canonicalizer::do_ArrayLength    (ArrayLength*     x) {
 235   NewArray*  na;
 236   Constant*  ct;
 237   LoadField* lf;
 238 
 239   if ((na = x-&gt;array()-&gt;as_NewArray()) != NULL) {
 240     // New arrays might have the known length.
 241     // Do not use the Constant itself, but create a new Constant
 242     // with same value Otherwise a Constant is live over multiple
 243     // blocks without being registered in a state array.
 244     Constant* length;
 245     if (na-&gt;length() != NULL &amp;&amp;
 246         (length = na-&gt;length()-&gt;as_Constant()) != NULL) {
 247       assert(length-&gt;type()-&gt;as_IntConstant() != NULL, &quot;array length must be integer&quot;);
 248       set_constant(length-&gt;type()-&gt;as_IntConstant()-&gt;value());
 249     }
 250 
 251   } else if ((ct = x-&gt;array()-&gt;as_Constant()) != NULL) {
 252     // Constant arrays have constant lengths.
 253     ArrayConstant* cnst = ct-&gt;type()-&gt;as_ArrayConstant();
 254     if (cnst != NULL) {
 255       set_constant(cnst-&gt;value()-&gt;length());
 256     }
 257 
 258   } else if ((lf = x-&gt;array()-&gt;as_LoadField()) != NULL) {
 259     ciField* field = lf-&gt;field();
 260     if (field-&gt;is_static_constant()) {
 261       // Constant field loads are usually folded during parsing.
 262       // But it doesn&#39;t happen with PatchALot, ScavengeRootsInCode &lt; 2, or when
 263       // holder class is being initialized during parsing (for static fields).
 264       ciObject* c = field-&gt;constant_value().as_object();
 265       if (!c-&gt;is_null_object()) {
 266         set_constant(c-&gt;as_array()-&gt;length());
 267       }
 268     }
 269   }
 270 }
 271 
 272 void Canonicalizer::do_LoadIndexed    (LoadIndexed*     x) {
 273   StableArrayConstant* array = x-&gt;array()-&gt;type()-&gt;as_StableArrayConstant();
 274   IntConstant* index = x-&gt;index()-&gt;type()-&gt;as_IntConstant();
 275 
 276   assert(array == NULL || FoldStableValues, &quot;not enabled&quot;);
 277 
 278   // Constant fold loads from stable arrays.
 279   if (!x-&gt;should_profile() &amp;&amp; !x-&gt;mismatched() &amp;&amp; array != NULL &amp;&amp; index != NULL) {
 280     jint idx = index-&gt;value();
 281     if (idx &lt; 0 || idx &gt;= array-&gt;value()-&gt;length()) {
 282       // Leave the load as is. The range check will handle it.
 283       return;
 284     }
 285 
 286     ciConstant field_val = array-&gt;value()-&gt;element_value(idx);
 287     if (!field_val.is_null_or_zero()) {
 288       jint dimension = array-&gt;dimension();
 289       assert(dimension &lt;= array-&gt;value()-&gt;array_type()-&gt;dimension(), &quot;inconsistent info&quot;);
 290       ValueType* value = NULL;
 291       if (dimension &gt; 1) {
 292         // Preserve information about the dimension for the element.
 293         assert(field_val.as_object()-&gt;is_array(), &quot;not an array&quot;);
 294         value = new StableArrayConstant(field_val.as_object()-&gt;as_array(), dimension - 1);
 295       } else {
 296         assert(dimension == 1, &quot;sanity&quot;);
 297         value = as_ValueType(field_val);
 298       }
 299       set_canonical(new Constant(value));
 300     }
 301   }
 302 }
 303 
 304 void Canonicalizer::do_StoreIndexed   (StoreIndexed*    x) {
 305   // If a value is going to be stored into a field or array some of
 306   // the conversions emitted by javac are unneeded because the fields
 307   // are packed to their natural size.
 308   Convert* conv = x-&gt;value()-&gt;as_Convert();
 309   if (conv) {
 310     Value value = NULL;
 311     BasicType type = x-&gt;elt_type();
 312     switch (conv-&gt;op()) {
 313     case Bytecodes::_i2b: if (type == T_BYTE)  value = conv-&gt;value(); break;
 314     case Bytecodes::_i2s: if (type == T_SHORT || type == T_BYTE) value = conv-&gt;value(); break;
 315     case Bytecodes::_i2c: if (type == T_CHAR  || type == T_BYTE) value = conv-&gt;value(); break;
 316     default             : break;
 317     }
 318     // limit this optimization to current block
 319     if (value != NULL &amp;&amp; in_current_block(conv)) {
 320       set_canonical(new StoreIndexed(x-&gt;array(), x-&gt;index(), x-&gt;length(),
 321                                      x-&gt;elt_type(), value, x-&gt;state_before(),
 322                                      x-&gt;check_boolean()));
 323       return;
 324     }
 325   }
 326 }
 327 
 328 
 329 void Canonicalizer::do_NegateOp(NegateOp* x) {
 330   ValueType* t = x-&gt;x()-&gt;type();
 331   if (t-&gt;is_constant()) {
 332     switch (t-&gt;tag()) {
 333       case intTag   : set_constant(-t-&gt;as_IntConstant   ()-&gt;value()); return;
 334       case longTag  : set_constant(-t-&gt;as_LongConstant  ()-&gt;value()); return;
 335       case floatTag : set_constant(-t-&gt;as_FloatConstant ()-&gt;value()); return;
 336       case doubleTag: set_constant(-t-&gt;as_DoubleConstant()-&gt;value()); return;
 337       default       : ShouldNotReachHere();
 338     }
 339   }
 340 }
 341 
 342 
 343 void Canonicalizer::do_ArithmeticOp   (ArithmeticOp*    x) { do_Op2(x); }
 344 
 345 
 346 void Canonicalizer::do_ShiftOp        (ShiftOp*         x) {
 347   ValueType* t = x-&gt;x()-&gt;type();
 348   ValueType* t2 = x-&gt;y()-&gt;type();
 349   if (t-&gt;is_constant()) {
 350     switch (t-&gt;tag()) {
 351     case intTag   : if (t-&gt;as_IntConstant()-&gt;value() == 0)         { set_constant(0); return; } break;
 352     case longTag  : if (t-&gt;as_LongConstant()-&gt;value() == (jlong)0) { set_constant(jlong_cast(0)); return; } break;
 353     default       : ShouldNotReachHere();
 354     }
 355     if (t2-&gt;is_constant()) {
 356       if (t-&gt;tag() == intTag) {
 357         jint value = t-&gt;as_IntConstant()-&gt;value();
 358         jint shift = t2-&gt;as_IntConstant()-&gt;value();
 359         switch (x-&gt;op()) {
 360           case Bytecodes::_ishl:  set_constant(java_shift_left(value, shift)); return;
 361           case Bytecodes::_ishr:  set_constant(java_shift_right(value, shift)); return;
 362           case Bytecodes::_iushr: set_constant(java_shift_right_unsigned(value, shift)); return;
 363           default:                break;
 364         }
 365       } else if (t-&gt;tag() == longTag) {
 366         jlong value = t-&gt;as_LongConstant()-&gt;value();
 367         jint shift = t2-&gt;as_IntConstant()-&gt;value();
 368         switch (x-&gt;op()) {
 369           case Bytecodes::_lshl:  set_constant(java_shift_left(value, shift)); return;
 370           case Bytecodes::_lshr:  set_constant(java_shift_right(value, shift)); return;
 371           case Bytecodes::_lushr: set_constant(java_shift_right_unsigned(value, shift)); return;
 372           default:                break;
 373         }
 374       }
 375     }
 376   }
 377   if (t2-&gt;is_constant()) {
 378     switch (t2-&gt;tag()) {
 379       case intTag   : if (t2-&gt;as_IntConstant()-&gt;value() == 0)  set_canonical(x-&gt;x()); return;
 380       case longTag  : if (t2-&gt;as_LongConstant()-&gt;value() == (jlong)0)  set_canonical(x-&gt;x()); return;
 381       default       : ShouldNotReachHere(); return;
 382     }
 383   }
 384 }
 385 
 386 
 387 void Canonicalizer::do_LogicOp        (LogicOp*         x) { do_Op2(x); }
 388 void Canonicalizer::do_CompareOp      (CompareOp*       x) {
 389   if (x-&gt;x() == x-&gt;y()) {
 390     switch (x-&gt;x()-&gt;type()-&gt;tag()) {
 391       case longTag: set_constant(0); break;
 392       case floatTag: {
 393         FloatConstant* fc = x-&gt;x()-&gt;type()-&gt;as_FloatConstant();
 394         if (fc) {
 395           if (g_isnan(fc-&gt;value())) {
 396             set_constant(x-&gt;op() == Bytecodes::_fcmpl ? -1 : 1);
 397           } else {
 398             set_constant(0);
 399           }
 400         }
 401         break;
 402       }
 403       case doubleTag: {
 404         DoubleConstant* dc = x-&gt;x()-&gt;type()-&gt;as_DoubleConstant();
 405         if (dc) {
 406           if (g_isnan(dc-&gt;value())) {
 407             set_constant(x-&gt;op() == Bytecodes::_dcmpl ? -1 : 1);
 408           } else {
 409             set_constant(0);
 410           }
 411         }
 412         break;
 413       }
 414       default:
 415         break;
 416     }
 417   } else if (x-&gt;x()-&gt;type()-&gt;is_constant() &amp;&amp; x-&gt;y()-&gt;type()-&gt;is_constant()) {
 418     switch (x-&gt;x()-&gt;type()-&gt;tag()) {
 419       case longTag: {
 420         jlong vx = x-&gt;x()-&gt;type()-&gt;as_LongConstant()-&gt;value();
 421         jlong vy = x-&gt;y()-&gt;type()-&gt;as_LongConstant()-&gt;value();
 422         if (vx == vy)
 423           set_constant(0);
 424         else if (vx &lt; vy)
 425           set_constant(-1);
 426         else
 427           set_constant(1);
 428         break;
 429       }
 430 
 431       case floatTag: {
 432         float vx = x-&gt;x()-&gt;type()-&gt;as_FloatConstant()-&gt;value();
 433         float vy = x-&gt;y()-&gt;type()-&gt;as_FloatConstant()-&gt;value();
 434         if (g_isnan(vx) || g_isnan(vy))
 435           set_constant(x-&gt;op() == Bytecodes::_fcmpl ? -1 : 1);
 436         else if (vx == vy)
 437           set_constant(0);
 438         else if (vx &lt; vy)
 439           set_constant(-1);
 440         else
 441           set_constant(1);
 442         break;
 443       }
 444 
 445       case doubleTag: {
 446         double vx = x-&gt;x()-&gt;type()-&gt;as_DoubleConstant()-&gt;value();
 447         double vy = x-&gt;y()-&gt;type()-&gt;as_DoubleConstant()-&gt;value();
 448         if (g_isnan(vx) || g_isnan(vy))
 449           set_constant(x-&gt;op() == Bytecodes::_dcmpl ? -1 : 1);
 450         else if (vx == vy)
 451           set_constant(0);
 452         else if (vx &lt; vy)
 453           set_constant(-1);
 454         else
 455           set_constant(1);
 456         break;
 457       }
 458 
 459       default:
 460         break;
 461     }
 462   }
 463 }
 464 
 465 
 466 void Canonicalizer::do_IfInstanceOf(IfInstanceOf*    x) {}
 467 
 468 void Canonicalizer::do_IfOp(IfOp* x) {
 469   // Caution: do not use do_Op2(x) here for now since
 470   //          we map the condition to the op for now!
 471   move_const_to_right(x);
 472 }
 473 
 474 
 475 void Canonicalizer::do_Intrinsic      (Intrinsic*       x) {
 476   switch (x-&gt;id()) {
 477   case vmIntrinsics::_floatToRawIntBits   : {
 478     FloatConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_FloatConstant();
 479     if (c != NULL) {
 480       JavaValue v;
 481       v.set_jfloat(c-&gt;value());
 482       set_constant(v.get_jint());
 483     }
 484     break;
 485   }
 486   case vmIntrinsics::_intBitsToFloat      : {
 487     IntConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_IntConstant();
 488     if (c != NULL) {
 489       JavaValue v;
 490       v.set_jint(c-&gt;value());
 491       set_constant(v.get_jfloat());
 492     }
 493     break;
 494   }
 495   case vmIntrinsics::_doubleToRawLongBits : {
 496     DoubleConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_DoubleConstant();
 497     if (c != NULL) {
 498       JavaValue v;
 499       v.set_jdouble(c-&gt;value());
 500       set_constant(v.get_jlong());
 501     }
 502     break;
 503   }
 504   case vmIntrinsics::_longBitsToDouble    : {
 505     LongConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_LongConstant();
 506     if (c != NULL) {
 507       JavaValue v;
 508       v.set_jlong(c-&gt;value());
 509       set_constant(v.get_jdouble());
 510     }
 511     break;
 512   }
 513   case vmIntrinsics::_isInstance          : {
 514     assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
 515 
 516     InstanceConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_InstanceConstant();
 517     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_null_object()) {
 518       // ciInstance::java_mirror_type() returns non-NULL only for Java mirrors
 519       ciType* t = c-&gt;value()-&gt;java_mirror_type();
 520       if (t-&gt;is_klass()) {
 521         // substitute cls.isInstance(obj) of a constant Class into
 522         // an InstantOf instruction
 523         InstanceOf* i = new InstanceOf(t-&gt;as_klass(), x-&gt;argument_at(1), x-&gt;state_before());
 524         set_canonical(i);
 525         // and try to canonicalize even further
 526         do_InstanceOf(i);
 527       } else {
 528         assert(t-&gt;is_primitive_type(), &quot;should be a primitive type&quot;);
 529         // cls.isInstance(obj) always returns false for primitive classes
 530         set_constant(0);
 531       }
 532     }
 533     break;
 534   }
 535   case vmIntrinsics::_isPrimitive        : {
 536     assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 537 
 538     // Class.isPrimitive is known on constant classes:
 539     InstanceConstant* c = x-&gt;argument_at(0)-&gt;type()-&gt;as_InstanceConstant();
 540     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_null_object()) {
 541       ciType* t = c-&gt;value()-&gt;java_mirror_type();
 542       set_constant(t-&gt;is_primitive_type());
 543     }
 544     break;
 545   }
 546   default:
 547     break;
 548   }
 549 }
 550 
 551 void Canonicalizer::do_Convert        (Convert*         x) {
 552   if (x-&gt;value()-&gt;type()-&gt;is_constant()) {
 553     switch (x-&gt;op()) {
 554     case Bytecodes::_i2b:  set_constant((int)((x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value() &lt;&lt; 24) &gt;&gt; 24)); break;
 555     case Bytecodes::_i2s:  set_constant((int)((x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value() &lt;&lt; 16) &gt;&gt; 16)); break;
 556     case Bytecodes::_i2c:  set_constant((int)(x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value() &amp; ((1&lt;&lt;16)-1))); break;
 557     case Bytecodes::_i2l:  set_constant((jlong)(x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value()));             break;
 558     case Bytecodes::_i2f:  set_constant((float)(x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value()));             break;
 559     case Bytecodes::_i2d:  set_constant((double)(x-&gt;value()-&gt;type()-&gt;as_IntConstant()-&gt;value()));            break;
 560     case Bytecodes::_l2i:  set_constant((int)(x-&gt;value()-&gt;type()-&gt;as_LongConstant()-&gt;value()));              break;
 561     case Bytecodes::_l2f:  set_constant(SharedRuntime::l2f(x-&gt;value()-&gt;type()-&gt;as_LongConstant()-&gt;value())); break;
 562     case Bytecodes::_l2d:  set_constant(SharedRuntime::l2d(x-&gt;value()-&gt;type()-&gt;as_LongConstant()-&gt;value())); break;
 563     case Bytecodes::_f2d:  set_constant((double)(x-&gt;value()-&gt;type()-&gt;as_FloatConstant()-&gt;value()));          break;
 564     case Bytecodes::_f2i:  set_constant(SharedRuntime::f2i(x-&gt;value()-&gt;type()-&gt;as_FloatConstant()-&gt;value())); break;
 565     case Bytecodes::_f2l:  set_constant(SharedRuntime::f2l(x-&gt;value()-&gt;type()-&gt;as_FloatConstant()-&gt;value())); break;
 566     case Bytecodes::_d2f:  set_constant((float)(x-&gt;value()-&gt;type()-&gt;as_DoubleConstant()-&gt;value()));          break;
 567     case Bytecodes::_d2i:  set_constant(SharedRuntime::d2i(x-&gt;value()-&gt;type()-&gt;as_DoubleConstant()-&gt;value())); break;
 568     case Bytecodes::_d2l:  set_constant(SharedRuntime::d2l(x-&gt;value()-&gt;type()-&gt;as_DoubleConstant()-&gt;value())); break;
 569     default:
 570       ShouldNotReachHere();
 571     }
 572   }
 573 
 574   Value value = x-&gt;value();
 575   BasicType type = T_ILLEGAL;
 576   LoadField* lf = value-&gt;as_LoadField();
 577   if (lf) {
 578     type = lf-&gt;field_type();
 579   } else {
 580     LoadIndexed* li = value-&gt;as_LoadIndexed();
 581     if (li) {
 582       type = li-&gt;elt_type();
 583     } else {
 584       Convert* conv = value-&gt;as_Convert();
 585       if (conv) {
 586         switch (conv-&gt;op()) {
 587           case Bytecodes::_i2b: type = T_BYTE;  break;
 588           case Bytecodes::_i2s: type = T_SHORT; break;
 589           case Bytecodes::_i2c: type = T_CHAR;  break;
 590           default             :                 break;
 591         }
 592       }
 593     }
 594   }
 595   if (type != T_ILLEGAL) {
 596     switch (x-&gt;op()) {
 597       case Bytecodes::_i2b: if (type == T_BYTE)                    set_canonical(x-&gt;value()); break;
 598       case Bytecodes::_i2s: if (type == T_SHORT || type == T_BYTE) set_canonical(x-&gt;value()); break;
 599       case Bytecodes::_i2c: if (type == T_CHAR)                    set_canonical(x-&gt;value()); break;
 600       default             :                                                                   break;
 601     }
 602   } else {
 603     Op2* op2 = x-&gt;value()-&gt;as_Op2();
 604     if (op2 &amp;&amp; op2-&gt;op() == Bytecodes::_iand &amp;&amp; op2-&gt;y()-&gt;type()-&gt;is_constant()) {
 605       jint safebits = 0;
 606       jint mask = op2-&gt;y()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 607       switch (x-&gt;op()) {
 608         case Bytecodes::_i2b: safebits = 0x7f;   break;
 609         case Bytecodes::_i2s: safebits = 0x7fff; break;
 610         case Bytecodes::_i2c: safebits = 0xffff; break;
 611         default             :                    break;
 612       }
 613       // When casting a masked integer to a smaller signed type, if
 614       // the mask doesn&#39;t include the sign bit the cast isn&#39;t needed.
 615       if (safebits &amp;&amp; (mask &amp; ~safebits) == 0) {
 616         set_canonical(x-&gt;value());
 617       }
 618     }
 619   }
 620 
 621 }
 622 
 623 void Canonicalizer::do_NullCheck      (NullCheck*       x) {
 624   if (x-&gt;obj()-&gt;as_NewArray() != NULL || x-&gt;obj()-&gt;as_NewInstance() != NULL) {
 625     set_canonical(x-&gt;obj());
 626   } else {
 627     Constant* con = x-&gt;obj()-&gt;as_Constant();
 628     if (con) {
 629       ObjectType* c = con-&gt;type()-&gt;as_ObjectType();
 630       if (c &amp;&amp; c-&gt;is_loaded()) {
 631         ObjectConstant* oc = c-&gt;as_ObjectConstant();
 632         if (!oc || !oc-&gt;value()-&gt;is_null_object()) {
 633           set_canonical(con);
 634         }
 635       }
 636     }
 637   }
 638 }
 639 
 640 void Canonicalizer::do_TypeCast       (TypeCast*        x) {}
 641 void Canonicalizer::do_Invoke         (Invoke*          x) {}
 642 void Canonicalizer::do_NewInstance    (NewInstance*     x) {}
<a name="1" id="anc1"></a><span class="line-modified"> 643 void Canonicalizer::do_NewValueTypeInstance(NewValueTypeInstance* x) {}</span>
 644 void Canonicalizer::do_NewTypeArray   (NewTypeArray*    x) {}
 645 void Canonicalizer::do_NewObjectArray (NewObjectArray*  x) {}
 646 void Canonicalizer::do_NewMultiArray  (NewMultiArray*   x) {}
 647 void Canonicalizer::do_WithField      (WithField*       x) {}
 648 void Canonicalizer::do_DefaultValue   (DefaultValue*    x) {}
 649 void Canonicalizer::do_CheckCast      (CheckCast*       x) {
<a name="2" id="anc2"></a><span class="line-modified"> 650   if (x-&gt;klass()-&gt;is_loaded() &amp;&amp; !x-&gt;klass()-&gt;is_valuetype()) {</span>
 651     // Don&#39;t canonicalize for non-nullable types -- we need to throw NPE.
 652     Value obj = x-&gt;obj();
 653     ciType* klass = obj-&gt;exact_type();
 654     if (klass == NULL) {
 655       klass = obj-&gt;declared_type();
 656     }
 657     if (klass != NULL &amp;&amp; klass-&gt;is_loaded()) {
 658       bool is_interface = klass-&gt;is_instance_klass() &amp;&amp;
 659                           klass-&gt;as_instance_klass()-&gt;is_interface();
 660       // Interface casts can&#39;t be statically optimized away since verifier doesn&#39;t
 661       // enforce interface types in bytecode.
 662       if (!is_interface &amp;&amp; klass-&gt;is_subtype_of(x-&gt;klass())) {
 663         set_canonical(obj);
 664         return;
 665       }
 666     }
 667     // checkcast of null returns null
 668     if (obj-&gt;as_Constant() &amp;&amp; obj-&gt;type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object()) {
 669       set_canonical(obj);
 670     }
 671   }
 672 }
 673 void Canonicalizer::do_InstanceOf     (InstanceOf*      x) {
 674   if (x-&gt;klass()-&gt;is_loaded()) {
 675     Value obj = x-&gt;obj();
 676     ciType* exact = obj-&gt;exact_type();
 677     if (exact != NULL &amp;&amp; exact-&gt;is_loaded() &amp;&amp; (obj-&gt;as_NewInstance() || obj-&gt;as_NewArray())) {
 678       set_constant(exact-&gt;is_subtype_of(x-&gt;klass()) ? 1 : 0);
 679       return;
 680     }
 681     // instanceof null returns false
 682     if (obj-&gt;as_Constant() &amp;&amp; obj-&gt;type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object()) {
 683       set_constant(0);
 684     }
 685   }
 686 
 687 }
 688 void Canonicalizer::do_MonitorEnter   (MonitorEnter*    x) {}
 689 void Canonicalizer::do_MonitorExit    (MonitorExit*     x) {}
 690 void Canonicalizer::do_BlockBegin     (BlockBegin*      x) {}
 691 void Canonicalizer::do_Goto           (Goto*            x) {}
 692 
 693 
 694 static bool is_true(jlong x, If::Condition cond, jlong y) {
 695   switch (cond) {
 696     case If::eql: return x == y;
 697     case If::neq: return x != y;
 698     case If::lss: return x &lt;  y;
 699     case If::leq: return x &lt;= y;
 700     case If::gtr: return x &gt;  y;
 701     case If::geq: return x &gt;= y;
 702     default:
 703       ShouldNotReachHere();
 704       return false;
 705   }
 706 }
 707 
 708 static bool is_safepoint(BlockEnd* x, BlockBegin* sux) {
 709   // An Instruction with multiple successors, x, is replaced by a Goto
 710   // to a single successor, sux. Is a safepoint check needed = was the
 711   // instruction being replaced a safepoint and the single remaining
 712   // successor a back branch?
 713   return x-&gt;is_safepoint() &amp;&amp; (sux-&gt;bci() &lt; x-&gt;state_before()-&gt;bci());
 714 }
 715 
 716 void Canonicalizer::do_If(If* x) {
 717   // move const to right
 718   if (x-&gt;x()-&gt;type()-&gt;is_constant()) x-&gt;swap_operands();
 719   // simplify
 720   const Value l = x-&gt;x(); ValueType* lt = l-&gt;type();
 721   const Value r = x-&gt;y(); ValueType* rt = r-&gt;type();
 722 
 723   if (l == r &amp;&amp; !lt-&gt;is_float_kind()) {
 724     // pattern: If (a cond a) =&gt; simplify to Goto
 725     BlockBegin* sux = NULL;
 726     switch (x-&gt;cond()) {
 727     case If::eql: sux = x-&gt;sux_for(true);  break;
 728     case If::neq: sux = x-&gt;sux_for(false); break;
 729     case If::lss: sux = x-&gt;sux_for(false); break;
 730     case If::leq: sux = x-&gt;sux_for(true);  break;
 731     case If::gtr: sux = x-&gt;sux_for(false); break;
 732     case If::geq: sux = x-&gt;sux_for(true);  break;
 733     default: ShouldNotReachHere();
 734     }
 735     // If is a safepoint then the debug information should come from the state_before of the If.
 736     set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 737     return;
 738   }
 739 
 740   if (lt-&gt;is_constant() &amp;&amp; rt-&gt;is_constant()) {
 741     if (x-&gt;x()-&gt;as_Constant() != NULL) {
 742       // pattern: If (lc cond rc) =&gt; simplify to: Goto
 743       BlockBegin* sux = x-&gt;x()-&gt;as_Constant()-&gt;compare(x-&gt;cond(), x-&gt;y(),
 744                                                        x-&gt;sux_for(true),
 745                                                        x-&gt;sux_for(false));
 746       if (sux != NULL) {
 747         // If is a safepoint then the debug information should come from the state_before of the If.
 748         set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 749       }
 750     }
 751   } else if (rt-&gt;as_IntConstant() != NULL) {
 752     // pattern: If (l cond rc) =&gt; investigate further
 753     const jint rc = rt-&gt;as_IntConstant()-&gt;value();
 754     if (l-&gt;as_CompareOp() != NULL) {
 755       // pattern: If ((a cmp b) cond rc) =&gt; simplify to: If (x cond y) or: Goto
 756       CompareOp* cmp = l-&gt;as_CompareOp();
 757       bool unordered_is_less = cmp-&gt;op() == Bytecodes::_fcmpl || cmp-&gt;op() == Bytecodes::_dcmpl;
 758       BlockBegin* lss_sux = x-&gt;sux_for(is_true(-1, x-&gt;cond(), rc)); // successor for a &lt; b
 759       BlockBegin* eql_sux = x-&gt;sux_for(is_true( 0, x-&gt;cond(), rc)); // successor for a = b
 760       BlockBegin* gtr_sux = x-&gt;sux_for(is_true(+1, x-&gt;cond(), rc)); // successor for a &gt; b
 761       BlockBegin* nan_sux = unordered_is_less ? lss_sux : gtr_sux ; // successor for unordered
 762       // Note: At this point all successors (lss_sux, eql_sux, gtr_sux, nan_sux) are
 763       //       equal to x-&gt;tsux() or x-&gt;fsux(). Furthermore, nan_sux equals either
 764       //       lss_sux or gtr_sux.
 765       if (lss_sux == eql_sux &amp;&amp; eql_sux == gtr_sux) {
 766         // all successors identical =&gt; simplify to: Goto
 767         set_canonical(new Goto(lss_sux, x-&gt;state_before(), x-&gt;is_safepoint()));
 768       } else {
 769         // two successors differ and two successors are the same =&gt; simplify to: If (x cmp y)
 770         // determine new condition &amp; successors
 771         If::Condition cond = If::eql;
 772         BlockBegin* tsux = NULL;
 773         BlockBegin* fsux = NULL;
 774              if (lss_sux == eql_sux) { cond = If::leq; tsux = lss_sux; fsux = gtr_sux; }
 775         else if (lss_sux == gtr_sux) { cond = If::neq; tsux = lss_sux; fsux = eql_sux; }
 776         else if (eql_sux == gtr_sux) { cond = If::geq; tsux = eql_sux; fsux = lss_sux; }
 777         else                         { ShouldNotReachHere();                           }
 778         If* canon = new If(cmp-&gt;x(), cond, nan_sux == tsux, cmp-&gt;y(), tsux, fsux, cmp-&gt;state_before(), x-&gt;is_safepoint());
 779         if (cmp-&gt;x() == cmp-&gt;y()) {
 780           do_If(canon);
 781         } else {
 782           if (compilation()-&gt;profile_branches() || compilation()-&gt;count_backedges()) {
 783             // TODO: If profiling, leave floating point comparisons unoptimized.
 784             // We currently do not support profiling of the unordered case.
 785             switch(cmp-&gt;op()) {
 786               case Bytecodes::_fcmpl: case Bytecodes::_fcmpg:
 787               case Bytecodes::_dcmpl: case Bytecodes::_dcmpg:
 788                 set_canonical(x);
 789                 return;
 790               default:
 791                 break;
 792             }
 793           }
 794           set_bci(cmp-&gt;state_before()-&gt;bci());
 795           set_canonical(canon);
 796         }
 797       }
 798     } else if (l-&gt;as_InstanceOf() != NULL) {
 799       // NOTE: Code permanently disabled for now since it leaves the old InstanceOf
 800       //       instruction in the graph (it is pinned). Need to fix this at some point.
 801       //       It should also be left in the graph when generating a profiled method version or Goto
 802       //       has to know that it was an InstanceOf.
 803       return;
 804       // pattern: If ((obj instanceof klass) cond rc) =&gt; simplify to: IfInstanceOf or: Goto
 805       InstanceOf* inst = l-&gt;as_InstanceOf();
 806       BlockBegin* is_inst_sux = x-&gt;sux_for(is_true(1, x-&gt;cond(), rc)); // successor for instanceof == 1
 807       BlockBegin* no_inst_sux = x-&gt;sux_for(is_true(0, x-&gt;cond(), rc)); // successor for instanceof == 0
 808       if (is_inst_sux == no_inst_sux &amp;&amp; inst-&gt;is_loaded()) {
 809         // both successors identical and klass is loaded =&gt; simplify to: Goto
 810         set_canonical(new Goto(is_inst_sux, x-&gt;state_before(), x-&gt;is_safepoint()));
 811       } else {
 812         // successors differ =&gt; simplify to: IfInstanceOf
 813         set_canonical(new IfInstanceOf(inst-&gt;klass(), inst-&gt;obj(), true, inst-&gt;state_before()-&gt;bci(), is_inst_sux, no_inst_sux));
 814       }
 815     }
 816   } else if (rt == objectNull &amp;&amp;
 817            (l-&gt;as_NewInstance() || l-&gt;as_NewArray() ||
 818              (l-&gt;as_Local() &amp;&amp; l-&gt;as_Local()-&gt;is_receiver()))) {
 819     if (x-&gt;cond() == Instruction::eql) {
 820       BlockBegin* sux = x-&gt;fsux();
 821       set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 822     } else {
 823       assert(x-&gt;cond() == Instruction::neq, &quot;only other valid case&quot;);
 824       BlockBegin* sux = x-&gt;tsux();
 825       set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 826     }
 827   }
 828 }
 829 
 830 
 831 void Canonicalizer::do_TableSwitch(TableSwitch* x) {
 832   if (x-&gt;tag()-&gt;type()-&gt;is_constant()) {
 833     int v = x-&gt;tag()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 834     BlockBegin* sux = x-&gt;default_sux();
 835     if (v &gt;= x-&gt;lo_key() &amp;&amp; v &lt;= x-&gt;hi_key()) {
 836       sux = x-&gt;sux_at(v - x-&gt;lo_key());
 837     }
 838     set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 839   } else if (x-&gt;number_of_sux() == 1) {
 840     // NOTE: Code permanently disabled for now since the switch statement&#39;s
 841     //       tag expression may produce side-effects in which case it must
 842     //       be executed.
 843     return;
 844     // simplify to Goto
 845     set_canonical(new Goto(x-&gt;default_sux(), x-&gt;state_before(), x-&gt;is_safepoint()));
 846   } else if (x-&gt;number_of_sux() == 2) {
 847     // NOTE: Code permanently disabled for now since it produces two new nodes
 848     //       (Constant &amp; If) and the Canonicalizer cannot return them correctly
 849     //       yet. For now we copied the corresponding code directly into the
 850     //       GraphBuilder (i.e., we should never reach here).
 851     return;
 852     // simplify to If
 853     assert(x-&gt;lo_key() == x-&gt;hi_key(), &quot;keys must be the same&quot;);
 854     Constant* key = new Constant(new IntConstant(x-&gt;lo_key()));
 855     set_canonical(new If(x-&gt;tag(), If::eql, true, key, x-&gt;sux_at(0), x-&gt;default_sux(), x-&gt;state_before(), x-&gt;is_safepoint()));
 856   }
 857 }
 858 
 859 
 860 void Canonicalizer::do_LookupSwitch(LookupSwitch* x) {
 861   if (x-&gt;tag()-&gt;type()-&gt;is_constant()) {
 862     int v = x-&gt;tag()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 863     BlockBegin* sux = x-&gt;default_sux();
 864     for (int i = 0; i &lt; x-&gt;length(); i++) {
 865       if (v == x-&gt;key_at(i)) {
 866         sux = x-&gt;sux_at(i);
 867       }
 868     }
 869     set_canonical(new Goto(sux, x-&gt;state_before(), is_safepoint(x, sux)));
 870   } else if (x-&gt;number_of_sux() == 1) {
 871     // NOTE: Code permanently disabled for now since the switch statement&#39;s
 872     //       tag expression may produce side-effects in which case it must
 873     //       be executed.
 874     return;
 875     // simplify to Goto
 876     set_canonical(new Goto(x-&gt;default_sux(), x-&gt;state_before(), x-&gt;is_safepoint()));
 877   } else if (x-&gt;number_of_sux() == 2) {
 878     // NOTE: Code permanently disabled for now since it produces two new nodes
 879     //       (Constant &amp; If) and the Canonicalizer cannot return them correctly
 880     //       yet. For now we copied the corresponding code directly into the
 881     //       GraphBuilder (i.e., we should never reach here).
 882     return;
 883     // simplify to If
 884     assert(x-&gt;length() == 1, &quot;length must be the same&quot;);
 885     Constant* key = new Constant(new IntConstant(x-&gt;key_at(0)));
 886     set_canonical(new If(x-&gt;tag(), If::eql, true, key, x-&gt;sux_at(0), x-&gt;default_sux(), x-&gt;state_before(), x-&gt;is_safepoint()));
 887   }
 888 }
 889 
 890 
 891 void Canonicalizer::do_Return         (Return*          x) {}
 892 void Canonicalizer::do_Throw          (Throw*           x) {}
 893 void Canonicalizer::do_Base           (Base*            x) {}
 894 void Canonicalizer::do_OsrEntry       (OsrEntry*        x) {}
 895 void Canonicalizer::do_ExceptionObject(ExceptionObject* x) {}
 896 
 897 static bool match_index_and_scale(Instruction*  instr,
 898                                   Instruction** index,
 899                                   int*          log2_scale) {
 900   // Skip conversion ops. This works only on 32bit because of the implicit l2i that the
 901   // unsafe performs.
 902 #ifndef _LP64
 903   Convert* convert = instr-&gt;as_Convert();
 904   if (convert != NULL &amp;&amp; convert-&gt;op() == Bytecodes::_i2l) {
 905     assert(convert-&gt;value()-&gt;type() == intType, &quot;invalid input type&quot;);
 906     instr = convert-&gt;value();
 907   }
 908 #endif
 909 
 910   ShiftOp* shift = instr-&gt;as_ShiftOp();
 911   if (shift != NULL) {
 912     if (shift-&gt;op() == Bytecodes::_lshl) {
 913       assert(shift-&gt;x()-&gt;type() == longType, &quot;invalid input type&quot;);
 914     } else {
 915 #ifndef _LP64
 916       if (shift-&gt;op() == Bytecodes::_ishl) {
 917         assert(shift-&gt;x()-&gt;type() == intType, &quot;invalid input type&quot;);
 918       } else {
 919         return false;
 920       }
 921 #else
 922       return false;
 923 #endif
 924     }
 925 
 926 
 927     // Constant shift value?
 928     Constant* con = shift-&gt;y()-&gt;as_Constant();
 929     if (con == NULL) return false;
 930     // Well-known type and value?
 931     IntConstant* val = con-&gt;type()-&gt;as_IntConstant();
 932     assert(val != NULL, &quot;Should be an int constant&quot;);
 933 
 934     *index = shift-&gt;x();
 935     int tmp_scale = val-&gt;value();
 936     if (tmp_scale &gt;= 0 &amp;&amp; tmp_scale &lt; 4) {
 937       *log2_scale = tmp_scale;
 938       return true;
 939     } else {
 940       return false;
 941     }
 942   }
 943 
 944   ArithmeticOp* arith = instr-&gt;as_ArithmeticOp();
 945   if (arith != NULL) {
 946     // See if either arg is a known constant
 947     Constant* con = arith-&gt;x()-&gt;as_Constant();
 948     if (con != NULL) {
 949       *index = arith-&gt;y();
 950     } else {
 951       con = arith-&gt;y()-&gt;as_Constant();
 952       if (con == NULL) return false;
 953       *index = arith-&gt;x();
 954     }
 955     long const_value;
 956     // Check for integer multiply
 957     if (arith-&gt;op() == Bytecodes::_lmul) {
 958       assert((*index)-&gt;type() == longType, &quot;invalid input type&quot;);
 959       LongConstant* val = con-&gt;type()-&gt;as_LongConstant();
 960       assert(val != NULL, &quot;expecting a long constant&quot;);
 961       const_value = val-&gt;value();
 962     } else {
 963 #ifndef _LP64
 964       if (arith-&gt;op() == Bytecodes::_imul) {
 965         assert((*index)-&gt;type() == intType, &quot;invalid input type&quot;);
 966         IntConstant* val = con-&gt;type()-&gt;as_IntConstant();
 967         assert(val != NULL, &quot;expecting an int constant&quot;);
 968         const_value = val-&gt;value();
 969       } else {
 970         return false;
 971       }
 972 #else
 973       return false;
 974 #endif
 975     }
 976     switch (const_value) {
 977     case 1: *log2_scale = 0; return true;
 978     case 2: *log2_scale = 1; return true;
 979     case 4: *log2_scale = 2; return true;
 980     case 8: *log2_scale = 3; return true;
 981     default:            return false;
 982     }
 983   }
 984 
 985   // Unknown instruction sequence; don&#39;t touch it
 986   return false;
 987 }
 988 
 989 
 990 static bool match(UnsafeRawOp* x,
 991                   Instruction** base,
 992                   Instruction** index,
 993                   int*          log2_scale) {
 994   ArithmeticOp* root = x-&gt;base()-&gt;as_ArithmeticOp();
 995   if (root == NULL) return false;
 996   // Limit ourselves to addition for now
 997   if (root-&gt;op() != Bytecodes::_ladd) return false;
 998 
 999   bool match_found = false;
1000   // Try to find shift or scale op
1001   if (match_index_and_scale(root-&gt;y(), index, log2_scale)) {
1002     *base = root-&gt;x();
1003     match_found = true;
1004   } else if (match_index_and_scale(root-&gt;x(), index, log2_scale)) {
1005     *base = root-&gt;y();
1006     match_found = true;
1007   } else if (NOT_LP64(root-&gt;y()-&gt;as_Convert() != NULL) LP64_ONLY(false)) {
1008     // Skipping i2l works only on 32bit because of the implicit l2i that the unsafe performs.
1009     // 64bit needs a real sign-extending conversion.
1010     Convert* convert = root-&gt;y()-&gt;as_Convert();
1011     if (convert-&gt;op() == Bytecodes::_i2l) {
1012       assert(convert-&gt;value()-&gt;type() == intType, &quot;should be an int&quot;);
1013       // pick base and index, setting scale at 1
1014       *base  = root-&gt;x();
1015       *index = convert-&gt;value();
1016       *log2_scale = 0;
1017       match_found = true;
1018     }
1019   }
1020   // The default solution
1021   if (!match_found) {
1022     *base = root-&gt;x();
1023     *index = root-&gt;y();
1024     *log2_scale = 0;
1025   }
1026 
1027   // If the value is pinned then it will be always be computed so
1028   // there&#39;s no profit to reshaping the expression.
1029   return !root-&gt;is_pinned();
1030 }
1031 
1032 
1033 void Canonicalizer::do_UnsafeRawOp(UnsafeRawOp* x) {
1034   Instruction* base = NULL;
1035   Instruction* index = NULL;
1036   int          log2_scale;
1037 
1038   if (match(x, &amp;base, &amp;index, &amp;log2_scale)) {
1039     x-&gt;set_base(base);
1040     x-&gt;set_index(index);
1041     x-&gt;set_log2_scale(log2_scale);
1042     if (PrintUnsafeOptimization) {
1043       tty-&gt;print_cr(&quot;Canonicalizer: UnsafeRawOp id %d: base = id %d, index = id %d, log2_scale = %d&quot;,
1044                     x-&gt;id(), x-&gt;base()-&gt;id(), x-&gt;index()-&gt;id(), x-&gt;log2_scale());
1045     }
1046   }
1047 }
1048 
1049 void Canonicalizer::do_RoundFP(RoundFP* x) {}
1050 void Canonicalizer::do_UnsafeGetRaw(UnsafeGetRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }
1051 void Canonicalizer::do_UnsafePutRaw(UnsafePutRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }
1052 void Canonicalizer::do_UnsafeGetObject(UnsafeGetObject* x) {}
1053 void Canonicalizer::do_UnsafePutObject(UnsafePutObject* x) {}
1054 void Canonicalizer::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {}
1055 void Canonicalizer::do_ProfileCall(ProfileCall* x) {}
1056 void Canonicalizer::do_ProfileReturnType(ProfileReturnType* x) {}
1057 void Canonicalizer::do_ProfileInvoke(ProfileInvoke* x) {}
1058 void Canonicalizer::do_RuntimeCall(RuntimeCall* x) {}
1059 void Canonicalizer::do_RangeCheckPredicate(RangeCheckPredicate* x) {}
1060 #ifdef ASSERT
1061 void Canonicalizer::do_Assert(Assert* x) {}
1062 #endif
1063 void Canonicalizer::do_MemBar(MemBar* x) {}
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
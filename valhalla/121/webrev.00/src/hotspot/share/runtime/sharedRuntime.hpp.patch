diff a/src/hotspot/share/runtime/sharedRuntime.hpp b/src/hotspot/share/runtime/sharedRuntime.hpp
--- a/src/hotspot/share/runtime/sharedRuntime.hpp
+++ b/src/hotspot/share/runtime/sharedRuntime.hpp
@@ -348,18 +348,18 @@
 
   static void monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
 
   static address entry_for_handle_wrong_method(methodHandle callee_method, bool is_static_call, bool is_optimized, bool caller_is_c1) {
     assert(callee_method->verified_code_entry() != NULL, "Jump to zero!");
-    assert(callee_method->verified_value_code_entry() != NULL, "Jump to zero!");
-    assert(callee_method->verified_value_ro_code_entry() != NULL, "Jump to zero!");
+    assert(callee_method->verified_inline_code_entry() != NULL, "Jump to zero!");
+    assert(callee_method->verified_inline_ro_code_entry() != NULL, "Jump to zero!");
     if (caller_is_c1) {
-      return callee_method->verified_value_code_entry();
+      return callee_method->verified_inline_code_entry();
     } else if (is_static_call || is_optimized) {
       return callee_method->verified_code_entry();
     } else {
-      return callee_method->verified_value_ro_code_entry();
+      return callee_method->verified_inline_ro_code_entry();
     }
   }
 
  private:
   static Handle find_callee_info(JavaThread* thread,
@@ -546,17 +546,17 @@
   // handle ic miss with caller being compiled code
   // wrong method handling (inline cache misses, zombie methods)
   static address handle_wrong_method(JavaThread* thread);
   static address handle_wrong_method_abstract(JavaThread* thread);
   static address handle_wrong_method_ic_miss(JavaThread* thread);
-  static void allocate_value_types(JavaThread* thread, Method* callee, bool allocate_receiver);
-  static oop allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS);
+  static void allocate_inline_types(JavaThread* thread, Method* callee, bool allocate_receiver);
+  static oop allocate_inline_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS);
   static void apply_post_barriers(JavaThread* thread, objArrayOopDesc* array);
 
   static address handle_unsafe_access(JavaThread* thread, address next_pc);
 
-  static BufferedValueTypeBlob* generate_buffered_inline_type_adapter(const InlineKlass* vk);
+  static BufferedInlineTypeBlob* generate_buffered_inline_type_adapter(const InlineKlass* vk);
 #ifndef PRODUCT
 
   // Collect and print inline cache miss statistics
  private:
   enum { maxICmiss_count = 100 };
@@ -667,35 +667,35 @@
 
  private:
   AdapterFingerPrint* _fingerprint;
   address _i2c_entry;
   address _c2i_entry;
-  address _c2i_value_entry;
-  address _c2i_value_ro_entry;
+  address _c2i_inline_entry;
+  address _c2i_inline_ro_entry;
   address _c2i_unverified_entry;
-  address _c2i_unverified_value_entry;
+  address _c2i_unverified_inline_entry;
   address _c2i_no_clinit_check_entry;
 
-  // Support for scalarized value type calling convention
+  // Support for scalarized inline type calling convention
   const GrowableArray<SigEntry>* _sig_cc;
 
 #ifdef ASSERT
   // Captures code and signature used to generate this adapter when
   // verifying adapter equivalence.
   unsigned char* _saved_code;
   int            _saved_code_length;
 #endif
 
-  void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_value_entry,
-            address c2i_value_ro_entry, address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry) {
+  void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_inline_entry,
+            address c2i_inline_ro_entry, address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry) {
     _fingerprint = fingerprint;
     _i2c_entry = i2c_entry;
     _c2i_entry = c2i_entry;
-    _c2i_value_entry = c2i_value_entry;
-    _c2i_value_ro_entry = c2i_value_ro_entry;
+    _c2i_inline_entry = c2i_inline_entry;
+    _c2i_inline_ro_entry = c2i_inline_ro_entry;
     _c2i_unverified_entry = c2i_unverified_entry;
-    _c2i_unverified_value_entry = c2i_unverified_value_entry;
+    _c2i_unverified_inline_entry = c2i_unverified_inline_entry;
     _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;
     _sig_cc = NULL;
 #ifdef ASSERT
     _saved_code = NULL;
     _saved_code_length = 0;
@@ -708,20 +708,20 @@
   AdapterHandlerEntry();
 
  public:
   address get_i2c_entry()                  const { return _i2c_entry; }
   address get_c2i_entry()                  const { return _c2i_entry; }
-  address get_c2i_value_entry()            const { return _c2i_value_entry; }
-  address get_c2i_value_ro_entry()         const { return _c2i_value_ro_entry; }
+  address get_c2i_inline_entry()            const { return _c2i_inline_entry; }
+  address get_c2i_inline_ro_entry()         const { return _c2i_inline_ro_entry; }
   address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }
-  address get_c2i_unverified_value_entry() const { return _c2i_unverified_value_entry; }
+  address get_c2i_unverified_inline_entry() const { return _c2i_unverified_inline_entry; }
   address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }
 
   address base_address();
   void relocate(address new_base);
 
-  // Support for scalarized value type calling convention
+  // Support for scalarized inline type calling convention
   void set_sig_cc(const GrowableArray<SigEntry>* sig)  { _sig_cc = sig; }
   const GrowableArray<SigEntry>* get_sig_cc()    const { return _sig_cc; }
 
   AdapterFingerPrint* fingerprint() const { return _fingerprint; }
 
@@ -742,18 +742,18 @@
 // This class is used only with DumpSharedSpaces==true. It holds extra information
 // that's used only during CDS dump time.
 // For details, see comments around Method::link_method()
 class CDSAdapterHandlerEntry: public AdapterHandlerEntry {
   address               _c2i_entry_trampoline;           // allocated from shared spaces "MC" region
-  address               _c2i_value_ro_entry_trampoline;  // allocated from shared spaces "MC" region
-  address               _c2i_value_entry_trampoline;     // allocated from shared spaces "MC" region
+  address               _c2i_inline_ro_entry_trampoline;  // allocated from shared spaces "MC" region
+  address               _c2i_inline_entry_trampoline;     // allocated from shared spaces "MC" region
   AdapterHandlerEntry** _adapter_trampoline;             // allocated from shared spaces "MD" region
 
 public:
   address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }
-  address get_c2i_value_ro_entry_trampoline()    const { return _c2i_value_ro_entry_trampoline; }
-  address get_c2i_value_entry_trampoline()       const { return _c2i_value_entry_trampoline; }
+  address get_c2i_inline_ro_entry_trampoline()    const { return _c2i_inline_ro_entry_trampoline; }
+  address get_c2i_inline_entry_trampoline()       const { return _c2i_inline_entry_trampoline; }
   AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }
   void init() NOT_CDS_RETURN;
 };
 
 
@@ -767,12 +767,12 @@
   static AdapterHandlerEntry* get_adapter0(const methodHandle& method);
 
  public:
 
   static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint,
-                                        address i2c_entry, address c2i_entry, address c2i_value_entry, address c2i_value_ro_entry,
-                                        address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry = NULL);
+                                        address i2c_entry, address c2i_entry, address c2i_inline_entry, address c2i_inline_ro_entry,
+                                        address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry = NULL);
   static void create_native_wrapper(const methodHandle& method);
   static AdapterHandlerEntry* get_adapter(const methodHandle& method);
 
   static void print_handler(const CodeBlob* b) { print_handler_on(tty, b); }
   static void print_handler_on(outputStream* st, const CodeBlob* b);
@@ -784,16 +784,16 @@
 };
 
 // Utility class for computing the calling convention of the 3 types
 // of compiled method entries:
 //     Method::_from_compiled_entry               - sig_cc
-//     Method::_from_compiled_value_ro_entry      - sig_cc_ro
-//     Method::_from_compiled_value_entry         - sig
+//     Method::_from_compiled_inline_ro_entry      - sig_cc_ro
+//     Method::_from_compiled_inline_entry         - sig
 class CompiledEntrySignature : public StackObj {
   Method* _method;
-  int  _num_value_args;
-  bool _has_value_recv;
+  int  _num_inline_args;
+  bool _has_inline_recv;
   GrowableArray<SigEntry> *_sig;
   GrowableArray<SigEntry> *_sig_cc;
   GrowableArray<SigEntry> *_sig_cc_ro;
   VMRegPair* _regs;
   VMRegPair* _regs_cc;
@@ -809,35 +809,35 @@
   bool _has_reserved_entries;
 
 public:
   Method* method()                     const { return _method; }
 
-  // Used by Method::_from_compiled_value_entry
+  // Used by Method::_from_compiled_inline_entry
   GrowableArray<SigEntry>& sig()       const { return *_sig; }
 
   // Used by Method::_from_compiled_entry
   GrowableArray<SigEntry>& sig_cc()    const { return *_sig_cc; }
 
-  // Used by Method::_from_compiled_value_ro_entry
+  // Used by Method::_from_compiled_inline_ro_entry
   GrowableArray<SigEntry>& sig_cc_ro() const { return *_sig_cc_ro; }
 
   VMRegPair* regs()                    const { return _regs; }
   VMRegPair* regs_cc()                 const { return _regs_cc; }
   VMRegPair* regs_cc_ro()              const { return _regs_cc_ro; }
 
   int args_on_stack()                  const { return _args_on_stack; }
   int args_on_stack_cc()               const { return _args_on_stack_cc; }
   int args_on_stack_cc_ro()            const { return _args_on_stack_cc_ro; }
 
-  int  num_value_args()                const { return _num_value_args; }
-  bool has_value_arg()                 const { return _num_value_args > 0;  }
-  bool has_value_recv()                const { return _has_value_recv; }
+  int  num_inline_args()               const { return _num_inline_args; }
+  bool has_inline_arg()                const { return _num_inline_args > 0;  }
+  bool has_inline_recv()               const { return _has_inline_recv; }
 
   bool has_scalarized_args()           const { return _has_scalarized_args; }
   bool c1_needs_stack_repair()         const { return _c1_needs_stack_repair; }
   bool c2_needs_stack_repair()         const { return _c2_needs_stack_repair; }
-  CodeOffsets::Entries c1_value_ro_entry_type() const;
+  CodeOffsets::Entries c1_inline_ro_entry_type() const;
 
   CompiledEntrySignature(Method* method);
   void compute_calling_conventions();
 
 private:

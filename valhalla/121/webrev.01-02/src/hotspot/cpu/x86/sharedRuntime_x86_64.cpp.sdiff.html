<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Runtime1_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_Optimizer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 870       size_t size_in_bytes = reg_pair.second()-&gt;is_valid() ? 8 : 4;
 871       gen_c2i_adapter_helper(masm, bt, next_arg_comp &gt; 0 ? sig_extended-&gt;at(next_arg_comp-1)._bt : T_ILLEGAL,
 872                              size_in_bytes, reg_pair, Address(rsp, offset), extraspace, false);
 873       next_arg_int++;
 874 #ifdef ASSERT
 875       if (bt == T_LONG || bt == T_DOUBLE) {
 876         // Overwrite the unused slot with known junk
 877         __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 878         __ movptr(Address(rsp, st_off), rax);
 879       }
 880 #endif /* ASSERT */
 881     } else {
 882       ignored++;
 883       // get the buffer from the just allocated pool of buffers
 884       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);
 885       __ load_heap_oop(r14, Address(rscratch2, index));
 886       next_vt_arg++; next_arg_int++;
 887       int vt = 1;
 888       // write fields we get from compiled code in registers/stack
 889       // slots to the buffer: we know we are done with that inline type
<span class="line-modified"> 890       // argument when we hit the T_VOID that acts as an end of value</span>
 891       // type delimiter for this inline type. Inline types are flattened
 892       // so we might encounter embedded inline types. Each entry in
 893       // sig_extended contains a field offset in the buffer.
 894       do {
 895         next_arg_comp++;
 896         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 897         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp-1)._bt;
 898         if (bt == T_INLINE_TYPE) {
 899           vt++;
 900           ignored++;
 901         } else if (bt == T_VOID &amp;&amp;
 902                    prev_bt != T_LONG &amp;&amp;
 903                    prev_bt != T_DOUBLE) {
 904           vt--;
 905           ignored++;
 906         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 907           // Ignore reserved entry
 908         } else {
 909           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 910           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 870       size_t size_in_bytes = reg_pair.second()-&gt;is_valid() ? 8 : 4;
 871       gen_c2i_adapter_helper(masm, bt, next_arg_comp &gt; 0 ? sig_extended-&gt;at(next_arg_comp-1)._bt : T_ILLEGAL,
 872                              size_in_bytes, reg_pair, Address(rsp, offset), extraspace, false);
 873       next_arg_int++;
 874 #ifdef ASSERT
 875       if (bt == T_LONG || bt == T_DOUBLE) {
 876         // Overwrite the unused slot with known junk
 877         __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 878         __ movptr(Address(rsp, st_off), rax);
 879       }
 880 #endif /* ASSERT */
 881     } else {
 882       ignored++;
 883       // get the buffer from the just allocated pool of buffers
 884       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);
 885       __ load_heap_oop(r14, Address(rscratch2, index));
 886       next_vt_arg++; next_arg_int++;
 887       int vt = 1;
 888       // write fields we get from compiled code in registers/stack
 889       // slots to the buffer: we know we are done with that inline type
<span class="line-modified"> 890       // argument when we hit the T_VOID that acts as an end of inline</span>
 891       // type delimiter for this inline type. Inline types are flattened
 892       // so we might encounter embedded inline types. Each entry in
 893       // sig_extended contains a field offset in the buffer.
 894       do {
 895         next_arg_comp++;
 896         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 897         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp-1)._bt;
 898         if (bt == T_INLINE_TYPE) {
 899           vt++;
 900           ignored++;
 901         } else if (bt == T_VOID &amp;&amp;
 902                    prev_bt != T_LONG &amp;&amp;
 903                    prev_bt != T_DOUBLE) {
 904           vt--;
 905           ignored++;
 906         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 907           // Ignore reserved entry
 908         } else {
 909           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 910           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="c1_Runtime1_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_Optimizer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/inlinetypenode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="callnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/inlinetypenode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
516   vt = gvn.transform(vt)-&gt;as_InlineType();
517   assert(vt-&gt;is_default(gvn), &quot;must be the default inline type&quot;);
518   return vt;
519 }
520 
521 bool InlineTypeNode::is_default(PhaseGVN&amp; gvn) const {
522   for (uint i = 0; i &lt; field_count(); ++i) {
523     Node* value = field_value(i);
524     if (!gvn.type(value)-&gt;is_zero_type() &amp;&amp;
525         !(value-&gt;is_InlineType() &amp;&amp; value-&gt;as_InlineType()-&gt;is_default(gvn)) &amp;&amp;
526         !(field_type(i)-&gt;is_inlinetype() &amp;&amp; value == default_oop(gvn, field_type(i)-&gt;as_inline_klass()))) {
527       return false;
528     }
529   }
530   return true;
531 }
532 
533 InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk) {
534   PhaseGVN&amp; gvn = kit-&gt;gvn();
535 
<span class="line-modified">536   // Create and initialize a InlineTypeNode by loading all field</span>
537   // values from a heap-allocated version and also save the oop.
538   InlineTypeNode* vt = new InlineTypeNode(vk, oop);
539 
540   if (oop-&gt;isa_InlineTypePtr()) {
541     // Can happen with late inlining
542     InlineTypePtrNode* vtptr = oop-&gt;as_InlineTypePtr();
543     vt-&gt;set_oop(vtptr-&gt;get_oop());
544     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
545       vt-&gt;init_req(i, vtptr-&gt;in(i));
546     }
547   } else if (gvn.type(oop)-&gt;maybe_null()) {
548     // Add a null check because the oop may be null
549     Node* null_ctl = kit-&gt;top();
550     Node* not_null_oop = kit-&gt;null_check_oop(oop, &amp;null_ctl);
551     if (kit-&gt;stopped()) {
552       // Constant null
553       kit-&gt;set_control(null_ctl);
554       return make_default(gvn, vk);
555     }
556     vt-&gt;set_oop(not_null_oop);
</pre>
<hr />
<pre>
564       region-&gt;init_req(2, null_ctl);
565 
566       vt = vt-&gt;clone_with_phis(&amp;gvn, region)-&gt;as_InlineType();
567       vt-&gt;merge_with(&amp;gvn, def, 2, true);
568       kit-&gt;set_control(gvn.transform(region));
569     }
570   } else {
571     // Oop can never be null
572     Node* init_ctl = kit-&gt;control();
573     vt-&gt;load(kit, oop, oop, vk, /* holder_offset */ 0);
574     assert(init_ctl != kit-&gt;control() || !gvn.type(oop)-&gt;is_inlinetypeptr() || oop-&gt;is_Con() || oop-&gt;Opcode() == Op_InlineTypePtr ||
575            AllocateNode::Ideal_allocation(oop, &amp;gvn) != NULL || vt-&gt;is_loaded(&amp;gvn) == oop, &quot;inline type should be loaded&quot;);
576   }
577 
578   assert(vt-&gt;is_allocated(&amp;gvn), &quot;inline type should be allocated&quot;);
579   return gvn.transform(vt)-&gt;as_InlineType();
580 }
581 
582 // GraphKit wrapper for the &#39;make_from_flattened&#39; method
583 InlineTypeNode* InlineTypeNode::make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
<span class="line-modified">584   // Create and initialize a InlineTypeNode by loading all field values from</span>
585   // a flattened inline type field at &#39;holder_offset&#39; or from an inline type array.
586   InlineTypeNode* vt = make_uninitialized(kit-&gt;gvn(), vk);
587   // The inline type is flattened into the object without an oop header. Subtract the
588   // offset of the first field to account for the missing header when loading the values.
589   holder_offset -= vk-&gt;first_field_offset();
590   vt-&gt;load(kit, obj, ptr, holder, holder_offset, decorators);
591   assert(vt-&gt;is_loaded(&amp;kit-&gt;gvn()) != obj, &quot;holder oop should not be used as flattened inline type oop&quot;);
592   return kit-&gt;gvn().transform(vt)-&gt;as_InlineType();
593 }
594 
595 InlineTypeNode* InlineTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, ciInlineKlass* vk, uint&amp; base_input, bool in) {
596   InlineTypeNode* vt = InlineTypeNode::make_uninitialized(kit-&gt;gvn(), vk);
597   vt-&gt;initialize_fields(kit, multi, sig, base_input, 0, in);
598   return kit-&gt;gvn().transform(vt)-&gt;as_InlineType();
599 }
600 
601 InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {
602   ciInlineKlass* vk = inline_klass();
603   InlineTypeNode* res = clone()-&gt;as_InlineType();
604   if (allocate) {
</pre>
</td>
<td>
<hr />
<pre>
516   vt = gvn.transform(vt)-&gt;as_InlineType();
517   assert(vt-&gt;is_default(gvn), &quot;must be the default inline type&quot;);
518   return vt;
519 }
520 
521 bool InlineTypeNode::is_default(PhaseGVN&amp; gvn) const {
522   for (uint i = 0; i &lt; field_count(); ++i) {
523     Node* value = field_value(i);
524     if (!gvn.type(value)-&gt;is_zero_type() &amp;&amp;
525         !(value-&gt;is_InlineType() &amp;&amp; value-&gt;as_InlineType()-&gt;is_default(gvn)) &amp;&amp;
526         !(field_type(i)-&gt;is_inlinetype() &amp;&amp; value == default_oop(gvn, field_type(i)-&gt;as_inline_klass()))) {
527       return false;
528     }
529   }
530   return true;
531 }
532 
533 InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk) {
534   PhaseGVN&amp; gvn = kit-&gt;gvn();
535 
<span class="line-modified">536   // Create and initialize an InlineTypeNode by loading all field</span>
537   // values from a heap-allocated version and also save the oop.
538   InlineTypeNode* vt = new InlineTypeNode(vk, oop);
539 
540   if (oop-&gt;isa_InlineTypePtr()) {
541     // Can happen with late inlining
542     InlineTypePtrNode* vtptr = oop-&gt;as_InlineTypePtr();
543     vt-&gt;set_oop(vtptr-&gt;get_oop());
544     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
545       vt-&gt;init_req(i, vtptr-&gt;in(i));
546     }
547   } else if (gvn.type(oop)-&gt;maybe_null()) {
548     // Add a null check because the oop may be null
549     Node* null_ctl = kit-&gt;top();
550     Node* not_null_oop = kit-&gt;null_check_oop(oop, &amp;null_ctl);
551     if (kit-&gt;stopped()) {
552       // Constant null
553       kit-&gt;set_control(null_ctl);
554       return make_default(gvn, vk);
555     }
556     vt-&gt;set_oop(not_null_oop);
</pre>
<hr />
<pre>
564       region-&gt;init_req(2, null_ctl);
565 
566       vt = vt-&gt;clone_with_phis(&amp;gvn, region)-&gt;as_InlineType();
567       vt-&gt;merge_with(&amp;gvn, def, 2, true);
568       kit-&gt;set_control(gvn.transform(region));
569     }
570   } else {
571     // Oop can never be null
572     Node* init_ctl = kit-&gt;control();
573     vt-&gt;load(kit, oop, oop, vk, /* holder_offset */ 0);
574     assert(init_ctl != kit-&gt;control() || !gvn.type(oop)-&gt;is_inlinetypeptr() || oop-&gt;is_Con() || oop-&gt;Opcode() == Op_InlineTypePtr ||
575            AllocateNode::Ideal_allocation(oop, &amp;gvn) != NULL || vt-&gt;is_loaded(&amp;gvn) == oop, &quot;inline type should be loaded&quot;);
576   }
577 
578   assert(vt-&gt;is_allocated(&amp;gvn), &quot;inline type should be allocated&quot;);
579   return gvn.transform(vt)-&gt;as_InlineType();
580 }
581 
582 // GraphKit wrapper for the &#39;make_from_flattened&#39; method
583 InlineTypeNode* InlineTypeNode::make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
<span class="line-modified">584   // Create and initialize an InlineTypeNode by loading all field values from</span>
585   // a flattened inline type field at &#39;holder_offset&#39; or from an inline type array.
586   InlineTypeNode* vt = make_uninitialized(kit-&gt;gvn(), vk);
587   // The inline type is flattened into the object without an oop header. Subtract the
588   // offset of the first field to account for the missing header when loading the values.
589   holder_offset -= vk-&gt;first_field_offset();
590   vt-&gt;load(kit, obj, ptr, holder, holder_offset, decorators);
591   assert(vt-&gt;is_loaded(&amp;kit-&gt;gvn()) != obj, &quot;holder oop should not be used as flattened inline type oop&quot;);
592   return kit-&gt;gvn().transform(vt)-&gt;as_InlineType();
593 }
594 
595 InlineTypeNode* InlineTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, ciInlineKlass* vk, uint&amp; base_input, bool in) {
596   InlineTypeNode* vt = InlineTypeNode::make_uninitialized(kit-&gt;gvn(), vk);
597   vt-&gt;initialize_fields(kit, multi, sig, base_input, 0, in);
598   return kit-&gt;gvn().transform(vt)-&gt;as_InlineType();
599 }
600 
601 InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {
602   ciInlineKlass* vk = inline_klass();
603   InlineTypeNode* res = clone()-&gt;as_InlineType();
604   if (allocate) {
</pre>
</td>
</tr>
</table>
<center><a href="callnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
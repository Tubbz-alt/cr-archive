<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/callnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="inlinetypenode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/callnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 863 // High-level memory allocation
 864 //
 865 //  AllocateNode and AllocateArrayNode are subclasses of CallNode because they will
 866 //  get expanded into a code sequence containing a call.  Unlike other CallNodes,
 867 //  they have 2 memory projections and 2 i_o projections (which are distinguished by
 868 //  the _is_io_use flag in the projection.)  This is needed when expanding the node in
 869 //  order to differentiate the uses of the projection on the normal control path from
 870 //  those on the exception return path.
 871 //
 872 class AllocateNode : public CallNode {
 873 public:
 874   enum {
 875     // Output:
 876     RawAddress  = TypeFunc::Parms,    // the newly-allocated raw address
 877     // Inputs:
 878     AllocSize   = TypeFunc::Parms,    // size (in bytes) of the new object
 879     KlassNode,                        // type (maybe dynamic) of the obj.
 880     InitialTest,                      // slow-path test (may be constant)
 881     ALength,                          // array length (or TOP if none)
 882     InlineTypeNode,                   // InlineTypeNode if this is an inline type allocation
<span class="line-modified"> 883     DefaultValue,                     // default value in case of non-flattened inline array</span>
 884     RawDefaultValue,                  // same as above but as raw machine word
 885     ParmLimit
 886   };
 887 
 888   static const TypeFunc* alloc_type(const Type* t) {
 889     const Type** fields = TypeTuple::fields(ParmLimit - TypeFunc::Parms);
 890     fields[AllocSize]   = TypeInt::POS;
 891     fields[KlassNode]   = TypeInstPtr::NOTNULL;
 892     fields[InitialTest] = TypeInt::BOOL;
 893     fields[ALength]     = t;  // length (can be a bad length)
 894     fields[InlineTypeNode] = Type::BOTTOM;
 895     fields[DefaultValue] = TypeInstPtr::NOTNULL;
 896     fields[RawDefaultValue] = TypeX_X;
 897 
 898     const TypeTuple *domain = TypeTuple::make(ParmLimit, fields);
 899 
 900     // create result type (range)
 901     fields = TypeTuple::fields(1);
 902     fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 903 
</pre>
</td>
<td>
<hr />
<pre>
 863 // High-level memory allocation
 864 //
 865 //  AllocateNode and AllocateArrayNode are subclasses of CallNode because they will
 866 //  get expanded into a code sequence containing a call.  Unlike other CallNodes,
 867 //  they have 2 memory projections and 2 i_o projections (which are distinguished by
 868 //  the _is_io_use flag in the projection.)  This is needed when expanding the node in
 869 //  order to differentiate the uses of the projection on the normal control path from
 870 //  those on the exception return path.
 871 //
 872 class AllocateNode : public CallNode {
 873 public:
 874   enum {
 875     // Output:
 876     RawAddress  = TypeFunc::Parms,    // the newly-allocated raw address
 877     // Inputs:
 878     AllocSize   = TypeFunc::Parms,    // size (in bytes) of the new object
 879     KlassNode,                        // type (maybe dynamic) of the obj.
 880     InitialTest,                      // slow-path test (may be constant)
 881     ALength,                          // array length (or TOP if none)
 882     InlineTypeNode,                   // InlineTypeNode if this is an inline type allocation
<span class="line-modified"> 883     DefaultValue,                     // default value in case of non-flattened inline type array</span>
 884     RawDefaultValue,                  // same as above but as raw machine word
 885     ParmLimit
 886   };
 887 
 888   static const TypeFunc* alloc_type(const Type* t) {
 889     const Type** fields = TypeTuple::fields(ParmLimit - TypeFunc::Parms);
 890     fields[AllocSize]   = TypeInt::POS;
 891     fields[KlassNode]   = TypeInstPtr::NOTNULL;
 892     fields[InitialTest] = TypeInt::BOOL;
 893     fields[ALength]     = t;  // length (can be a bad length)
 894     fields[InlineTypeNode] = Type::BOTTOM;
 895     fields[DefaultValue] = TypeInstPtr::NOTNULL;
 896     fields[RawDefaultValue] = TypeX_X;
 897 
 898     const TypeTuple *domain = TypeTuple::make(ParmLimit, fields);
 899 
 900     // create result type (range)
 901     fields = TypeTuple::fields(1);
 902     fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 903 
</pre>
</td>
</tr>
</table>
<center><a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="inlinetypenode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/memnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="inlinetypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phasetype.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/memnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1142 //----------------------is_instance_field_load_with_local_phi------------------
1143 bool LoadNode::is_instance_field_load_with_local_phi(Node* ctrl) {
1144   if( in(Memory)-&gt;is_Phi() &amp;&amp; in(Memory)-&gt;in(0) == ctrl &amp;&amp;
1145       in(Address)-&gt;is_AddP() ) {
1146     const TypeOopPtr* t_oop = in(Address)-&gt;bottom_type()-&gt;isa_oopptr();
1147     // Only instances and boxed values.
1148     if( t_oop != NULL &amp;&amp;
1149         (t_oop-&gt;is_ptr_to_boxed_value() ||
1150          t_oop-&gt;is_known_instance_field()) &amp;&amp;
1151         t_oop-&gt;offset() != Type::OffsetBot &amp;&amp;
1152         t_oop-&gt;offset() != Type::OffsetTop) {
1153       return true;
1154     }
1155   }
1156   return false;
1157 }
1158 
1159 //------------------------------Identity---------------------------------------
1160 // Loads are identity if previous store is to same address
1161 Node* LoadNode::Identity(PhaseGVN* phase) {
<span class="line-modified">1162   // Loading from a InlineTypePtr? The InlineTypePtr has the values of</span>
1163   // all fields as input. Look for the field with matching offset.
1164   Node* addr = in(Address);
1165   intptr_t offset;
1166   Node* base = AddPNode::Ideal_base_and_offset(addr, phase, offset);
1167   if (base != NULL &amp;&amp; base-&gt;is_InlineTypePtr() &amp;&amp; offset &gt; oopDesc::klass_offset_in_bytes()) {
1168     Node* value = base-&gt;as_InlineTypePtr()-&gt;field_value_by_offset((int)offset, true);
1169     if (value-&gt;is_InlineType()) {
1170       // Non-flattened inline type field
1171       InlineTypeNode* vt = value-&gt;as_InlineType();
1172       if (vt-&gt;is_allocated(phase)) {
1173         value = vt-&gt;get_oop();
1174       } else {
1175         // Not yet allocated, bail out
1176         value = NULL;
1177       }
1178     }
1179     if (value != NULL) {
1180       if (Opcode() == Op_LoadN) {
1181         // Encode oop value if we are loading a narrow oop
1182         assert(!phase-&gt;type(value)-&gt;isa_narrowoop(), &quot;should already be decoded&quot;);
</pre>
</td>
<td>
<hr />
<pre>
1142 //----------------------is_instance_field_load_with_local_phi------------------
1143 bool LoadNode::is_instance_field_load_with_local_phi(Node* ctrl) {
1144   if( in(Memory)-&gt;is_Phi() &amp;&amp; in(Memory)-&gt;in(0) == ctrl &amp;&amp;
1145       in(Address)-&gt;is_AddP() ) {
1146     const TypeOopPtr* t_oop = in(Address)-&gt;bottom_type()-&gt;isa_oopptr();
1147     // Only instances and boxed values.
1148     if( t_oop != NULL &amp;&amp;
1149         (t_oop-&gt;is_ptr_to_boxed_value() ||
1150          t_oop-&gt;is_known_instance_field()) &amp;&amp;
1151         t_oop-&gt;offset() != Type::OffsetBot &amp;&amp;
1152         t_oop-&gt;offset() != Type::OffsetTop) {
1153       return true;
1154     }
1155   }
1156   return false;
1157 }
1158 
1159 //------------------------------Identity---------------------------------------
1160 // Loads are identity if previous store is to same address
1161 Node* LoadNode::Identity(PhaseGVN* phase) {
<span class="line-modified">1162   // Loading from an InlineTypePtr? The InlineTypePtr has the values of</span>
1163   // all fields as input. Look for the field with matching offset.
1164   Node* addr = in(Address);
1165   intptr_t offset;
1166   Node* base = AddPNode::Ideal_base_and_offset(addr, phase, offset);
1167   if (base != NULL &amp;&amp; base-&gt;is_InlineTypePtr() &amp;&amp; offset &gt; oopDesc::klass_offset_in_bytes()) {
1168     Node* value = base-&gt;as_InlineTypePtr()-&gt;field_value_by_offset((int)offset, true);
1169     if (value-&gt;is_InlineType()) {
1170       // Non-flattened inline type field
1171       InlineTypeNode* vt = value-&gt;as_InlineType();
1172       if (vt-&gt;is_allocated(phase)) {
1173         value = vt-&gt;get_oop();
1174       } else {
1175         // Not yet allocated, bail out
1176         value = NULL;
1177       }
1178     }
1179     if (value != NULL) {
1180       if (Opcode() == Op_LoadN) {
1181         // Encode oop value if we are loading a narrow oop
1182         assert(!phase-&gt;type(value)-&gt;isa_narrowoop(), &quot;should already be decoded&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="inlinetypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phasetype.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp
@@ -1164,11 +1164,11 @@
                        FrameMap::r3_metadata_opr, info);
   LIR_Opr result = rlock_result(x);
   __ move(reg, result);
 }
 
-void LIRGenerator::do_NewInlineTypeInstance  (NewInlineTypeInstance* x) {
+void LIRGenerator::do_NewInlineTypeInstance(NewInlineTypeInstance* x) {
   // Mapping to do_NewInstance (same code)
   CodeEmitInfo* info = state_for(x, x->state());
   x->set_to_object_type();
   LIR_Opr reg = result_register_for(x->type());
   new_instance(reg, x->klass(), x->is_unresolved(),
diff a/src/hotspot/cpu/x86/c1_Runtime1_x86.cpp b/src/hotspot/cpu/x86/c1_Runtime1_x86.cpp
--- a/src/hotspot/cpu/x86/c1_Runtime1_x86.cpp
+++ b/src/hotspot/cpu/x86/c1_Runtime1_x86.cpp
@@ -1151,19 +1151,19 @@
           case new_object_array_id:
             __ cmpl(t0, Klass::_lh_array_tag_obj_value); // new "[Ljava/lang/Object;"
             __ jcc(Assembler::equal, ok);
             __ cmpl(t0, Klass::_lh_array_tag_vt_value);  // new "[LVT;"
             __ jcc(Assembler::equal, ok);
-            __ stop("assert(is an object or inline array klass)");
+            __ stop("assert(is an object or inline type array klass)");
             break;
           case new_flat_array_id:
             // new "[QVT;"
             __ cmpl(t0, Klass::_lh_array_tag_vt_value);  // the array can be flattened.
             __ jcc(Assembler::equal, ok);
             __ cmpl(t0, Klass::_lh_array_tag_obj_value); // the array cannot be flattened (due to InlineArrayElementMaxFlatSize, etc)
             __ jcc(Assembler::equal, ok);
-            __ stop("assert(is an object or inline array klass)");
+            __ stop("assert(is an object or inline type array klass)");
             break;
           default:  ShouldNotReachHere();
           }
           __ should_not_reach_here();
           __ bind(ok);
diff a/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp b/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
--- a/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
+++ b/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
@@ -885,11 +885,11 @@
       __ load_heap_oop(r14, Address(rscratch2, index));
       next_vt_arg++; next_arg_int++;
       int vt = 1;
       // write fields we get from compiled code in registers/stack
       // slots to the buffer: we know we are done with that inline type
-      // argument when we hit the T_VOID that acts as an end of value
+      // argument when we hit the T_VOID that acts as an end of inline
       // type delimiter for this inline type. Inline types are flattened
       // so we might encounter embedded inline types. Each entry in
       // sig_extended contains a field offset in the buffer.
       do {
         next_arg_comp++;
diff a/src/hotspot/share/c1/c1_Optimizer.cpp b/src/hotspot/share/c1/c1_Optimizer.cpp
--- a/src/hotspot/share/c1/c1_Optimizer.cpp
+++ b/src/hotspot/share/c1/c1_Optimizer.cpp
@@ -701,11 +701,11 @@
 void NullCheckVisitor::do_Convert        (Convert*         x) {}
 void NullCheckVisitor::do_NullCheck      (NullCheck*       x) { nce()->handle_NullCheck(x); }
 void NullCheckVisitor::do_TypeCast       (TypeCast*        x) {}
 void NullCheckVisitor::do_Invoke         (Invoke*          x) { nce()->handle_Invoke(x); }
 void NullCheckVisitor::do_NewInstance    (NewInstance*     x) { nce()->handle_NewInstance(x); }
-void NullCheckVisitor::do_NewInlineTypeInstance(NewInlineTypeInstance*     x) { nce()->handle_NewInlineTypeInstance(x); }
+void NullCheckVisitor::do_NewInlineTypeInstance(NewInlineTypeInstance* x) { nce()->handle_NewInlineTypeInstance(x); }
 void NullCheckVisitor::do_NewTypeArray   (NewTypeArray*    x) { nce()->handle_NewArray(x); }
 void NullCheckVisitor::do_NewObjectArray (NewObjectArray*  x) { nce()->handle_NewArray(x); }
 void NullCheckVisitor::do_NewMultiArray  (NewMultiArray*   x) { nce()->handle_NewArray(x); }
 void NullCheckVisitor::do_WithField      (WithField*       x) {}
 void NullCheckVisitor::do_DefaultValue   (DefaultValue*    x) {}
diff a/src/hotspot/share/c1/c1_RangeCheckElimination.hpp b/src/hotspot/share/c1/c1_RangeCheckElimination.hpp
--- a/src/hotspot/share/c1/c1_RangeCheckElimination.hpp
+++ b/src/hotspot/share/c1/c1_RangeCheckElimination.hpp
@@ -145,11 +145,11 @@
     void do_CompareOp      (CompareOp*       x) { /* nothing to do */ };
     void do_Convert        (Convert*         x) { /* nothing to do */ };
     void do_NullCheck      (NullCheck*       x) { /* nothing to do */ };
     void do_TypeCast       (TypeCast*        x) { /* nothing to do */ };
     void do_NewInstance    (NewInstance*     x) { /* nothing to do */ };
-    void do_NewInlineTypeInstance  (NewInlineTypeInstance*   x) { /* nothing to do */ };
+    void do_NewInlineTypeInstance(NewInlineTypeInstance* x) { /* nothing to do */ };
     void do_NewTypeArray   (NewTypeArray*    x) { /* nothing to do */ };
     void do_NewObjectArray (NewObjectArray*  x) { /* nothing to do */ };
     void do_NewMultiArray  (NewMultiArray*   x) { /* nothing to do */ };
     void do_WithField      (WithField*       x) { /* nothing to do */ };
     void do_DefaultValue   (DefaultValue*    x) { /* nothing to do */ };
diff a/src/hotspot/share/c1/c1_ValueMap.hpp b/src/hotspot/share/c1/c1_ValueMap.hpp
--- a/src/hotspot/share/c1/c1_ValueMap.hpp
+++ b/src/hotspot/share/c1/c1_ValueMap.hpp
@@ -184,11 +184,11 @@
   void do_IfOp           (IfOp*            x) { /* nothing to do */ }
   void do_Convert        (Convert*         x) { /* nothing to do */ }
   void do_NullCheck      (NullCheck*       x) { /* nothing to do */ }
   void do_TypeCast       (TypeCast*        x) { /* nothing to do */ }
   void do_NewInstance    (NewInstance*     x) { /* nothing to do */ }
-  void do_NewInlineTypeInstance (NewInlineTypeInstance* x) { /* nothing to do */ }
+  void do_NewInlineTypeInstance(NewInlineTypeInstance* x) { /* nothing to do */ }
   void do_NewTypeArray   (NewTypeArray*    x) { /* nothing to do */ }
   void do_NewObjectArray (NewObjectArray*  x) { /* nothing to do */ }
   void do_NewMultiArray  (NewMultiArray*   x) { /* nothing to do */ }
   void do_WithField      (WithField*       x) { /* nothing to do */ }
   void do_DefaultValue   (DefaultValue*    x) { /* nothing to do */ }
diff a/src/hotspot/share/ci/ciFlatArrayKlass.cpp b/src/hotspot/share/ci/ciFlatArrayKlass.cpp
--- a/src/hotspot/share/ci/ciFlatArrayKlass.cpp
+++ b/src/hotspot/share/ci/ciFlatArrayKlass.cpp
@@ -37,11 +37,11 @@
 // whose Klass part is a FlatArrayKlass.
 
 // ------------------------------------------------------------------
 // ciFlatArrayKlass::ciFlatArrayKlass
 //
-// Constructor for loaded inline array klasses.
+// Constructor for loaded inline type array klasses.
 ciFlatArrayKlass::ciFlatArrayKlass(Klass* h_k) : ciArrayKlass(h_k) {
   assert(get_Klass()->is_flatArray_klass(), "wrong type");
   InlineKlass* element_Klass = get_FlatArrayKlass()->element_klass();
   _base_element_klass = CURRENT_ENV->get_klass(element_Klass);
   assert(_base_element_klass->is_inlinetype(), "bad base klass");
diff a/src/hotspot/share/ci/ciInlineKlass.cpp b/src/hotspot/share/ci/ciInlineKlass.cpp
--- a/src/hotspot/share/ci/ciInlineKlass.cpp
+++ b/src/hotspot/share/ci/ciInlineKlass.cpp
@@ -65,11 +65,11 @@
       best_offset = field_offset;
       best_index = i;
     }
   }
   assert(best_index >= 0, "field not found");
-  assert(best_offset == offset || _declared_nonstatic_fields->at(best_index)->type()->is_inlinetype(), "offset should match for non-VTs");
+  assert(best_offset == offset || _declared_nonstatic_fields->at(best_index)->type()->is_inlinetype(), "offset should match for non-inline types");
   return best_index;
 }
 
 // Are arrays containing this inline type flattened?
 bool ciInlineKlass::flatten_array() const {
diff a/src/hotspot/share/ci/ciMetadata.hpp b/src/hotspot/share/ci/ciMetadata.hpp
--- a/src/hotspot/share/ci/ciMetadata.hpp
+++ b/src/hotspot/share/ci/ciMetadata.hpp
@@ -54,13 +54,13 @@
   virtual bool is_return_address() const    { return false; }
   virtual bool is_method() const            { return false; }
   virtual bool is_method_data() const       { return false; }
   virtual bool is_klass() const             { return false; }
   virtual bool is_instance_klass() const    { return false; }
-  virtual bool is_inlinetype() const         { return false; }
+  virtual bool is_inlinetype() const        { return false; }
   virtual bool is_array_klass() const       { return false; }
-  virtual bool is_flat_array_klass() const { return false; }
+  virtual bool is_flat_array_klass() const  { return false; }
   virtual bool is_obj_array_klass() const   { return false; }
   virtual bool is_type_array_klass() const  { return false; }
   virtual bool flatten_array() const        { return false; }
   virtual void dump_replay_data(outputStream* st) { /* do nothing */ }
 
@@ -94,11 +94,11 @@
   }
   ciArrayKlass*            as_array_klass() {
     assert(is_array_klass(), "bad cast");
     return (ciArrayKlass*)this;
   }
-  ciFlatArrayKlass*       as_flat_array_klass() {
+  ciFlatArrayKlass*        as_flat_array_klass() {
     assert(is_flat_array_klass(), "bad cast");
     return (ciFlatArrayKlass*)this;
   }
   ciObjArrayKlass*         as_obj_array_klass() {
     assert(is_obj_array_klass(), "bad cast");
@@ -106,11 +106,11 @@
   }
   ciTypeArrayKlass*        as_type_array_klass() {
     assert(is_type_array_klass(), "bad cast");
     return (ciTypeArrayKlass*)this;
   }
-  ciInlineKlass*            as_inline_klass() {
+  ciInlineKlass*           as_inline_klass() {
     assert(is_inlinetype(), "bad cast");
     return (ciInlineKlass*)this;
   }
 
   Metadata* constant_encoding() { return _metadata; }
diff a/src/hotspot/share/code/codeBlob.hpp b/src/hotspot/share/code/codeBlob.hpp
--- a/src/hotspot/share/code/codeBlob.hpp
+++ b/src/hotspot/share/code/codeBlob.hpp
@@ -140,11 +140,11 @@
   virtual bool is_adapter_blob() const                { return false; }
   virtual bool is_vtable_blob() const                 { return false; }
   virtual bool is_method_handles_adapter_blob() const { return false; }
   virtual bool is_aot() const                         { return false; }
   virtual bool is_compiled() const                    { return false; }
-  virtual bool is_buffered_inline_type_blob() const    { return false; }
+  virtual bool is_buffered_inline_type_blob() const   { return false; }
 
   inline bool is_compiled_by_c1() const    { return _type == compiler_c1; };
   inline bool is_compiled_by_c2() const    { return _type == compiler_c2; };
   inline bool is_compiled_by_jvmci() const { return _type == compiler_jvmci; };
   const char* compiler_name() const;
diff a/src/hotspot/share/code/nmethod.cpp b/src/hotspot/share/code/nmethod.cpp
--- a/src/hotspot/share/code/nmethod.cpp
+++ b/src/hotspot/share/code/nmethod.cpp
@@ -3090,14 +3090,14 @@
 
 const char* nmethod::nmethod_section_label(address pos) const {
   const char* label = NULL;
   if (pos == code_begin())                                              label = "[Instructions begin]";
   if (pos == entry_point())                                             label = "[Entry Point]";
-  if (pos == inline_entry_point())                                      label = "[Value Entry Point]";
+  if (pos == inline_entry_point())                                      label = "[Inline Entry Point]";
   if (pos == verified_entry_point())                                    label = "[Verified Entry Point]";
-  if (pos == verified_inline_entry_point())                             label = "[Verified Value Entry Point]";
-  if (pos == verified_inline_ro_entry_point())                          label = "[Verified Value Entry Point (RO)]";
+  if (pos == verified_inline_entry_point())                             label = "[Verified Inline Entry Point]";
+  if (pos == verified_inline_ro_entry_point())                          label = "[Verified Inline Entry Point (RO)]";
   if (has_method_handle_invokes() && (pos == deopt_mh_handler_begin())) label = "[Deopt MH Handler Code]";
   if (pos == consts_begin() && pos != insts_begin())                    label = "[Constants]";
   // Check stub_code before checking exception_handler or deopt_handler.
   if (pos == this->stub_begin())                                        label = "[Stub Code]";
   if (JVMCI_ONLY(_exception_offset >= 0 &&) pos == exception_begin())           label = "[Exception Handler]";
@@ -3118,14 +3118,14 @@
 void nmethod::print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels) const {
   if (print_section_labels) {
     int n = 0;
     // Multiple entry points may be at the same position. Print them all.
     n += maybe_print_entry_label(stream, block_begin, entry_point(),                    "[Entry Point]");
-    n += maybe_print_entry_label(stream, block_begin, inline_entry_point(),             "[Value Entry Point]");
+    n += maybe_print_entry_label(stream, block_begin, inline_entry_point(),             "[Inline Entry Point]");
     n += maybe_print_entry_label(stream, block_begin, verified_entry_point(),           "[Verified Entry Point]");
-    n += maybe_print_entry_label(stream, block_begin, verified_inline_entry_point(),    "[Verified Value Entry Point]");
-    n += maybe_print_entry_label(stream, block_begin, verified_inline_ro_entry_point(), "[Verified Value Entry Point (RO)]");
+    n += maybe_print_entry_label(stream, block_begin, verified_inline_entry_point(),    "[Verified Inline Entry Point]");
+    n += maybe_print_entry_label(stream, block_begin, verified_inline_ro_entry_point(), "[Verified Inline Entry Point (RO)]");
     if (n == 0) {
       const char* label = nmethod_section_label(block_begin);
       if (label != NULL) {
         stream->bol();
         stream->print_cr("%s", label);
diff a/src/hotspot/share/oops/inlineKlass.cpp b/src/hotspot/share/oops/inlineKlass.cpp
--- a/src/hotspot/share/oops/inlineKlass.cpp
+++ b/src/hotspot/share/oops/inlineKlass.cpp
@@ -536,21 +536,21 @@
   assert(j == regs->length(), "missed a field?");
   assert(k == handles.length(), "missed an oop?");
   return new_vt;
 }
 
-// Check the return register for a InlineKlass oop
+// Check the return register for an InlineKlass oop
 InlineKlass* InlineKlass::returned_inline_klass(const RegisterMap& map) {
   BasicType bt = T_METADATA;
   VMRegPair pair;
   int nb = SharedRuntime::java_return_convention(&bt, &pair, 1);
   assert(nb == 1, "broken");
 
   address loc = map.location(pair.first());
   intptr_t ptr = *(intptr_t*)loc;
   if (is_set_nth_bit(ptr, 0)) {
-    // Oop is tagged, must be a InlineKlass oop
+    // Oop is tagged, must be an InlineKlass oop
     clear_nth_bit(ptr, 0);
     assert(Metaspace::contains((void*)ptr), "should be klass");
     InlineKlass* vk = (InlineKlass*)ptr;
     assert(vk->can_be_returned_as_fields(), "must be able to return as fields");
     return vk;
diff a/src/hotspot/share/oops/instanceKlass.hpp b/src/hotspot/share/oops/instanceKlass.hpp
--- a/src/hotspot/share/oops/instanceKlass.hpp
+++ b/src/hotspot/share/oops/instanceKlass.hpp
@@ -54,11 +54,11 @@
 //      indicating where oops are located in instances of this klass.
 //    [EMBEDDED implementor of the interface] only exist for interface
 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
 //    [EMBEDDED inline_type_field_klasses] only if has_inline_fields() == true
-//    [EMBEDDED InlineKlassFixedBlock] only if is a InlineKlass instance
+//    [EMBEDDED InlineKlassFixedBlock] only if is an InlineKlass instance
 
 
 // forward declaration for class -- see below for definition
 #if INCLUDE_JVMTI
 class BreakpointInfo;
@@ -1297,19 +1297,19 @@
   Klass* get_inline_type_field_klass(int idx) const {
     assert(has_inline_type_fields(), "Sanity checking");
     assert(idx < java_fields_count(), "IOOB");
     Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];
     assert(k != NULL, "Should always be set before being read");
-    assert(k->is_inline_klass(), "Must be a inline type");
+    assert(k->is_inline_klass(), "Must be an inline type");
     return k;
   }
 
   Klass* get_inline_type_field_klass_or_null(int idx) const {
     assert(has_inline_type_fields(), "Sanity checking");
     assert(idx < java_fields_count(), "IOOB");
     Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];
-    assert(k == NULL || k->is_inline_klass(), "Must be a inline type");
+    assert(k == NULL || k->is_inline_klass(), "Must be an inline type");
     return k;
   }
 
   void set_inline_type_field_klass(int idx, Klass* k) {
     assert(has_inline_type_fields(), "Sanity checking");
diff a/src/hotspot/share/opto/callnode.hpp b/src/hotspot/share/opto/callnode.hpp
--- a/src/hotspot/share/opto/callnode.hpp
+++ b/src/hotspot/share/opto/callnode.hpp
@@ -878,11 +878,11 @@
     AllocSize   = TypeFunc::Parms,    // size (in bytes) of the new object
     KlassNode,                        // type (maybe dynamic) of the obj.
     InitialTest,                      // slow-path test (may be constant)
     ALength,                          // array length (or TOP if none)
     InlineTypeNode,                   // InlineTypeNode if this is an inline type allocation
-    DefaultValue,                     // default value in case of non-flattened inline array
+    DefaultValue,                     // default value in case of non-flattened inline type array
     RawDefaultValue,                  // same as above but as raw machine word
     ParmLimit
   };
 
   static const TypeFunc* alloc_type(const Type* t) {
diff a/src/hotspot/share/opto/inlinetypenode.cpp b/src/hotspot/share/opto/inlinetypenode.cpp
--- a/src/hotspot/share/opto/inlinetypenode.cpp
+++ b/src/hotspot/share/opto/inlinetypenode.cpp
@@ -531,11 +531,11 @@
 }
 
 InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk) {
   PhaseGVN& gvn = kit->gvn();
 
-  // Create and initialize a InlineTypeNode by loading all field
+  // Create and initialize an InlineTypeNode by loading all field
   // values from a heap-allocated version and also save the oop.
   InlineTypeNode* vt = new InlineTypeNode(vk, oop);
 
   if (oop->isa_InlineTypePtr()) {
     // Can happen with late inlining
@@ -579,11 +579,11 @@
   return gvn.transform(vt)->as_InlineType();
 }
 
 // GraphKit wrapper for the 'make_from_flattened' method
 InlineTypeNode* InlineTypeNode::make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
-  // Create and initialize a InlineTypeNode by loading all field values from
+  // Create and initialize an InlineTypeNode by loading all field values from
   // a flattened inline type field at 'holder_offset' or from an inline type array.
   InlineTypeNode* vt = make_uninitialized(kit->gvn(), vk);
   // The inline type is flattened into the object without an oop header. Subtract the
   // offset of the first field to account for the missing header when loading the values.
   holder_offset -= vk->first_field_offset();
diff a/src/hotspot/share/opto/memnode.cpp b/src/hotspot/share/opto/memnode.cpp
--- a/src/hotspot/share/opto/memnode.cpp
+++ b/src/hotspot/share/opto/memnode.cpp
@@ -1157,11 +1157,11 @@
 }
 
 //------------------------------Identity---------------------------------------
 // Loads are identity if previous store is to same address
 Node* LoadNode::Identity(PhaseGVN* phase) {
-  // Loading from a InlineTypePtr? The InlineTypePtr has the values of
+  // Loading from an InlineTypePtr? The InlineTypePtr has the values of
   // all fields as input. Look for the field with matching offset.
   Node* addr = in(Address);
   intptr_t offset;
   Node* base = AddPNode::Ideal_base_and_offset(addr, phase, offset);
   if (base != NULL && base->is_InlineTypePtr() && offset > oopDesc::klass_offset_in_bytes()) {
diff a/src/hotspot/share/opto/phasetype.hpp b/src/hotspot/share/opto/phasetype.hpp
--- a/src/hotspot/share/opto/phasetype.hpp
+++ b/src/hotspot/share/opto/phasetype.hpp
@@ -100,12 +100,12 @@
       case PHASE_MACRO_EXPANSION:            return "Macro expand";
       case PHASE_BARRIER_EXPANSION:          return "Barrier expand";
       case PHASE_ADD_UNSAFE_BARRIER:         return "Add barrier to unsafe op";
       case PHASE_END:                        return "End";
       case PHASE_FAILURE:                    return "Failure";
-      case PHASE_SPLIT_INLINES_ARRAY:         return "Split values array";
-      case PHASE_SPLIT_INLINES_ARRAY_IGVN:    return "IGVN after split values array";
+      case PHASE_SPLIT_INLINES_ARRAY:        return "Split inlines array";
+      case PHASE_SPLIT_INLINES_ARRAY_IGVN:   return "IGVN after split inlines array";
       case PHASE_DEBUG:                      return "Debug";
       default:
         ShouldNotReachHere();
         return NULL;
     }
diff a/src/hotspot/share/opto/runtime.cpp b/src/hotspot/share/opto/runtime.cpp
--- a/src/hotspot/share/opto/runtime.cpp
+++ b/src/hotspot/share/opto/runtime.cpp
@@ -1771,13 +1771,13 @@
 {
   array->value_copy_from_index(index, buffer);
 }
 JRT_END
 
-const TypeFunc *OptoRuntime::load_unknown_inline_type() {
+const TypeFunc* OptoRuntime::load_unknown_inline_type() {
   // create input type (domain)
-  const Type **fields = TypeTuple::fields(3);
+  const Type** fields = TypeTuple::fields(3);
   // We don't know the number of returned values and their
   // types. Assume all registers available to the return convention
   // are used.
   fields[TypeFunc::Parms] = TypeOopPtr::NOTNULL;
   fields[TypeFunc::Parms+1] = TypeInt::POS;
@@ -1785,11 +1785,11 @@
 
   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);
 
   // create result type (range)
   fields = TypeTuple::fields(0);
-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+0, fields);
 
   return TypeFunc::make(domain, range);
 }
 
 JRT_LEAF(void, OptoRuntime::store_unknown_inline(instanceOopDesc* buffer, flatArrayOopDesc* array, int index))
@@ -1797,13 +1797,13 @@
   assert(buffer != NULL, "can't store null into flat array");
   array->value_copy_to_index(buffer, index);
 }
 JRT_END
 
-const TypeFunc *OptoRuntime::store_unknown_inline_type() {
+const TypeFunc* OptoRuntime::store_unknown_inline_type() {
   // create input type (domain)
-  const Type **fields = TypeTuple::fields(3);
+  const Type** fields = TypeTuple::fields(3);
   // We don't know the number of returned values and their
   // types. Assume all registers available to the return convention
   // are used.
   fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;
   fields[TypeFunc::Parms+1] = TypeOopPtr::NOTNULL;
@@ -1811,9 +1811,9 @@
 
   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);
 
   // create result type (range)
   fields = TypeTuple::fields(0);
-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+0, fields);
 
   return TypeFunc::make(domain, range);
 }
diff a/src/hotspot/share/opto/runtime.hpp b/src/hotspot/share/opto/runtime.hpp
--- a/src/hotspot/share/opto/runtime.hpp
+++ b/src/hotspot/share/opto/runtime.hpp
@@ -323,13 +323,13 @@
 
   static const TypeFunc* store_inline_type_fields_Type();
   static const TypeFunc* pack_inline_type_Type();
 
   static void load_unknown_inline(flatArrayOopDesc* array, int index, instanceOopDesc* buffer);
-  static const TypeFunc *load_unknown_inline_type();
+  static const TypeFunc* load_unknown_inline_type();
   static void store_unknown_inline(instanceOopDesc* buffer, flatArrayOopDesc* array, int index);
-  static const TypeFunc *store_unknown_inline_type();
+  static const TypeFunc* store_unknown_inline_type();
 
  private:
  static NamedCounter * volatile _named_counters;
 
  public:
diff a/src/hotspot/share/opto/type.cpp b/src/hotspot/share/opto/type.cpp
--- a/src/hotspot/share/opto/type.cpp
+++ b/src/hotspot/share/opto/type.cpp
@@ -2397,11 +2397,11 @@
   return false;
 }
 
 //==============================TypeInlineType=======================================
 
-const TypeInlineType *TypeInlineType::BOTTOM;
+const TypeInlineType* TypeInlineType::BOTTOM;
 
 //------------------------------make-------------------------------------------
 const TypeInlineType* TypeInlineType::make(ciInlineKlass* vk, bool larval) {
   return (TypeInlineType*)(new TypeInlineType(vk, larval))->hashcons();
 }
diff a/src/hotspot/share/opto/type.hpp b/src/hotspot/share/opto/type.hpp
--- a/src/hotspot/share/opto/type.hpp
+++ b/src/hotspot/share/opto/type.hpp
@@ -789,11 +789,11 @@
   virtual const Type* xdual() const;     // Compute dual right now.
 
   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }
   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }
 
-  static const TypeInlineType *BOTTOM;
+  static const TypeInlineType* BOTTOM;
 
 #ifndef PRODUCT
   virtual void dump2(Dict &d, uint, outputStream* st) const; // Specialized per-Type dumping
 #endif
 };
diff a/src/hotspot/share/runtime/sharedRuntime.cpp b/src/hotspot/share/runtime/sharedRuntime.cpp
--- a/src/hotspot/share/runtime/sharedRuntime.cpp
+++ b/src/hotspot/share/runtime/sharedRuntime.cpp
@@ -2805,11 +2805,11 @@
   }
 
   if (has_inline_recv()) {
     if (num_inline_args() == 1) {
       // Share same entry for VIEP and VIEP(RO).
-      // This is quite common: we have an instance method in a InlineKlass that has
+      // This is quite common: we have an instance method in an InlineKlass that has
       // no inline type args other than <this>.
       return CodeOffsets::Verified_Inline_Entry;
     } else {
       assert(num_inline_args() > 1, "must be");
       // No sharing:
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
@@ -117,11 +117,11 @@
     public void test2_verifier(boolean warmup) {
         long result = test2();
         Asserts.assertEQ(result, hash());
     }
 
-    // Test receiving a inline type array from the interpreter,
+    // Test receiving an inline type array from the interpreter,
     // updating its elements in a loop and computing a hash.
     @Test(failOn = ALLOCA)
     public long test3(MyValue1[] va) {
         long result = 0;
         for (int i = 0; i < 10; ++i) {
@@ -146,11 +146,11 @@
                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
             }
         }
     }
 
-    // Test returning a inline type array received from the interpreter
+    // Test returning an inline type array received from the interpreter
     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
     public MyValue1[] test4(MyValue1[] va) {
         return va;
     }
 
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestBasicFunctionality.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestBasicFunctionality.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestBasicFunctionality.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestBasicFunctionality.java
@@ -102,11 +102,11 @@
         MyValue1 v2 = test3(v1);
         Asserts.assertEQ(v1.x, v2.x);
         Asserts.assertEQ(v1.y, v2.y);
     }
 
-    // Create a inline type in compiled code and only use fields.
+    // Create an inline type in compiled code and only use fields.
     // Allocation should go away because inline type does not escape.
     @Test(failOn = ALLOC + LOAD + STORE + TRAP)
     public long test4() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         return v.hash();
@@ -116,11 +116,11 @@
     public void test4_verifier(boolean warmup) {
         long result = test4();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type in compiled code and pass it to
+    // Create an inline type in compiled code and pass it to
     // an inlined compiled method via a call.
     @Test(failOn = ALLOC + LOAD + STORE + TRAP)
     public long test5() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         return test5Inline(v);
@@ -135,11 +135,11 @@
     public void test5_verifier(boolean warmup) {
         long result = test5();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type in compiled code and pass it to
+    // Create an inline type in compiled code and pass it to
     // the interpreter via a call.
     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = LOAD + TRAP + ALLOC)
     @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
     public long test6() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
@@ -151,11 +151,11 @@
     public void test6_verifier(boolean warmup) {
         long result = test6();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type in compiled code and pass it to
+    // Create an inline type in compiled code and pass it to
     // the interpreter by returning.
     @Test(match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
     public MyValue1 test7(int x, long y) {
         return MyValue1.createWithFieldsInline(x, y);
     }
@@ -250,11 +250,11 @@
     public void test11_verifier(boolean warmup) {
         long result = test11(rI, rL);
         Asserts.assertEQ(result, hash(rI + 10, rL + 10));
     }
 
-    // Test loop with uncommon trap referencing a inline type
+    // Test loop with uncommon trap referencing an inline type
     @Test(match = {SCOBJ}, matchCount = {-1 /* at least 1 */}, failOn = LOAD)
     public long test12(boolean b) {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         MyValue1[] va = new MyValue1[Math.abs(rI) % 10];
         for (int i = 0; i < va.length; ++i) {
@@ -280,11 +280,11 @@
     public void test12_verifier(boolean warmup) {
         long result = test12(warmup);
         Asserts.assertEQ(result, warmup ? rL + (1000 * rI) : ((Math.abs(rI) % 10) + 1) * hash());
     }
 
-    // Test loop with uncommon trap referencing a inline type
+    // Test loop with uncommon trap referencing an inline type
     @Test
     public long test13(boolean b) {
         MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);
         MyValue1[] va = new MyValue1[Math.abs(rI) % 10];
         for (int i = 0; i < va.length; ++i) {
@@ -310,11 +310,11 @@
     public void test13_verifier(boolean warmup) {
         long result = test13(warmup);
         Asserts.assertEQ(result, warmup ? rL + (1000 * rI) : ((Math.abs(rI) % 10) + 1) * hash());
     }
 
-    // Create a inline type in a non-inlined method and then call a
+    // Create an inline type in a non-inlined method and then call a
     // non-inlined method on that inline type.
     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = (ALLOC + STORE + TRAP), match = {LOAD}, matchCount = {12})
     @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = (ALLOC + LOAD + STORE + TRAP))
     public long test14() {
         MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);
@@ -325,11 +325,11 @@
     public void test14_verifier(boolean b) {
         long result = test14();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type in an inlined method and then call a
+    // Create an inline type in an inlined method and then call a
     // non-inlined method on that inline type.
     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = (LOAD + TRAP + ALLOC))
     @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = (LOAD + TRAP), match = {ALLOC}, matchCount = {1})
     public long test15() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
@@ -340,11 +340,11 @@
     public void test15_verifier(boolean b) {
         long result = test15();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type in a non-inlined method and then call an
+    // Create an inline type in a non-inlined method and then call an
     // inlined method on that inline type.
     @Test(failOn = (ALLOC + STORE + TRAP))
     public long test16() {
         MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);
         return v.hash();
@@ -354,11 +354,11 @@
     public void test16_verifier(boolean b) {
         long result = test16();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type in an inlined method and then call an
+    // Create an inline type in an inlined method and then call an
     // inlined method on that inline type.
     @Test(failOn = (ALLOC + LOAD + STORE + TRAP))
     public long test17() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         return v.hash();
@@ -368,11 +368,11 @@
     public void test17_verifier(boolean b) {
         long result = test17();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type in compiled code and pass it to the
+    // Create an inline type in compiled code and pass it to the
     // interpreter via a call. The inline type is live at the first call so
     // debug info should include a reference to all its fields.
     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = ALLOC + LOAD + TRAP)
     @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
     public long test18() {
@@ -385,11 +385,11 @@
     public void test18_verifier(boolean warmup) {
         long result = test18();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type in compiled code and pass it to the
+    // Create an inline type in compiled code and pass it to the
     // interpreter via a call. The inline type is passed twice but
     // should only be allocated once.
     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = ALLOC + LOAD + TRAP)
     @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
     public long test19() {
@@ -406,11 +406,11 @@
     public void test19_verifier(boolean warmup) {
         long result = test19();
         Asserts.assertEQ(result, hash());
     }
 
-    // Create a inline type (array) in compiled code and pass it to the
+    // Create an inline type (array) in compiled code and pass it to the
     // interpreter via a call. The inline type is live at the uncommon
     // trap: verify that deoptimization causes the inline type to be
     // correctly allocated.
     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = LOAD + ALLOC + STORE)
     @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD)
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConvention.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConvention.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConvention.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConvention.java
@@ -358,11 +358,11 @@
         }
         test17();
         test17_vt.verify(test17_vt2);
     }
 
-    // Same tests as above but with a inline type that cannot be returned in registers
+    // Same tests as above but with an inline type that cannot be returned in registers
 
     // Return inline types in registers from interpreter -> compiled
     final MyValue4 test18_vt = MyValue4.create();
     @DontCompile
     public MyValue4 test18_interp() {
@@ -590,11 +590,11 @@
     @DontCompile
     public void test28_verifier(boolean warmup) {
         String result = test28();
     }
 
-    // Test calling a method returning a inline type as fields via reflection
+    // Test calling a method returning an inline type as fields via reflection
     MyValue3 test29_vt = MyValue3.create();
 
     @Test
     public MyValue3 test29() {
         return test29_vt;
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConventionC1.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConventionC1.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConventionC1.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConventionC1.java
@@ -1819,14 +1819,14 @@
 
     //----------------------------------------------------------------------------------
     // Tests for unverified entries: there are 6 cases:
     // C1 -> Unverified Value Entry compiled by C1
     // C1 -> Unverified Value Entry compiled by C2
-    // C2 -> Unverified Entry compiled by C1 (target is NOT a inline type)
-    // C2 -> Unverified Entry compiled by C2 (target is NOT a inline type)
-    // C2 -> Unverified Entry compiled by C1 (target IS a inline type, i.e., has VVEP_RO)
-    // C2 -> Unverified Entry compiled by C2 (target IS a inline type, i.e., has VVEP_RO)
+    // C2 -> Unverified Entry compiled by C1 (target is NOT an inline type)
+    // C2 -> Unverified Entry compiled by C2 (target is NOT an inline type)
+    // C2 -> Unverified Entry compiled by C1 (target IS an inline type, i.e., has VVEP_RO)
+    // C2 -> Unverified Entry compiled by C2 (target IS an inline type, i.e., has VVEP_RO)
     //----------------------------------------------------------------------------------
 
     // C1->C1 invokeinterface -- call Unverified Value Entry of MyImplPojo1.func2 (compiled by C1)
     @Test(compLevel = C1)
     public int test90(Intf intf, int a, int b) {
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestJNICalls.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestJNICalls.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestJNICalls.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestJNICalls.java
@@ -56,11 +56,11 @@
     }
 
     public native Object testMethod1(MyValue1 o);
     public native long testMethod2(MyValue1 o);
 
-    // Pass a inline type to a native method that calls back into Java code and returns an inline type
+    // Pass an inline type to a native method that calls back into Java code and returns an inline type
     @Test
     @Warmup(10000) // Make sure native method is compiled
     public MyValue1 test1(MyValue1 vt, boolean callback) {
         if (!callback) {
           return (MyValue1)testMethod1(vt);
@@ -76,11 +76,11 @@
         Asserts.assertEQ(result.hash(), vt.hash());
         result = test1(vt, true);
         Asserts.assertEQ(result.hash(), vt.hash());
     }
 
-    // Pass a inline type to a native method that calls the hash method and returns the result
+    // Pass an inline type to a native method that calls the hash method and returns the result
     @Test
     @Warmup(10000) // Make sure native method is compiled
     public long test2(MyValue1 vt) {
         return testMethod2(vt);
     }
@@ -100,11 +100,11 @@
         }
 
         public native int testMethod3();
     }
 
-    // Call a native method with a inline type receiver
+    // Call a native method with an inline type receiver
     @Test
     @Warmup(10000) // Make sure native method is compiled
     public int test3(MyValueWithNative vt) {
         return vt.testMethod3();
     }
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java
@@ -69,11 +69,11 @@
 
     protected long hash() {
         return testValue1.hash();
     }
 
-    // Test passing a inline type as an Object
+    // Test passing an inline type as an Object
     @DontInline
     public Object test1_dontinline1(Object o) {
         return o;
     }
 
@@ -1073,11 +1073,11 @@
             // Expected
         }
         Asserts.assertEQ(testValue1Array[index].hash(), hash());
     }
 
-    // Test writing a inline type to a null inline type array
+    // Test writing an inline type to a null inline type array
     @Test()
     public void test36(MyValue1[] va, MyValue1 vt, int index) {
         va[index] = vt;
     }
 
@@ -1563,11 +1563,11 @@
                    holder.valueField3.hash() +
                    holder.valueField4.hashPrimitive();
         }
     }
 
-    // Same as test2 but with field holder being a inline type
+    // Same as test2 but with field holder being an inline type
     @Test()
     public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {
         return holder.test(holder, vt1, vt2);
     }
 
@@ -1882,11 +1882,11 @@
         Integer[] array = new Integer[1];
         test68(array, 1);
         Asserts.assertEQ(array[0], Integer.valueOf(1));
     }
 
-    // Test convertion between a inline type and java.lang.Object without an allocation
+    // Test convertion between an inline type and java.lang.Object without an allocation
     @ForceInline
     public Object test69_sum(Object a, Object b) {
         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
         return MyValue1.setX(((MyValue1)a), sum);
     }
@@ -2721,11 +2721,11 @@
     public void test102_verifier(boolean warmup) {
         boolean result = test102(null);
         Asserts.assertFalse(result);
     }
 
-    // An abstract class with a non-static field can never be implemented by a inline type
+    // An abstract class with a non-static field can never be implemented by an inline type
     abstract class NoValueImplementors1 {
         int field = 42;
     }
 
     class MyObject3 extends NoValueImplementors1 {
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
@@ -101,11 +101,11 @@
         for (int i = 1; i < len; ++i) {
             Asserts.assertEQ(va[i].hash(), hash());
         }
     }
 
-    // Test creation of a inline type array and element access
+    // Test creation of an inline type array and element access
     @Test
     // TODO 8227588
     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public long test2() {
         MyValue1.ref[] va = new MyValue1.ref[1];
@@ -117,11 +117,11 @@
     public void test2_verifier(boolean warmup) {
         long result = test2();
         Asserts.assertEQ(result, hash());
     }
 
-    // Test receiving a inline type array from the interpreter,
+    // Test receiving an inline type array from the interpreter,
     // updating its elements in a loop and computing a hash.
     @Test(failOn = ALLOCA)
     public long test3(MyValue1.ref[] va) {
         long result = 0;
         for (int i = 0; i < 10; ++i) {
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableInlineTypes.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableInlineTypes.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableInlineTypes.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableInlineTypes.java
@@ -461,11 +461,11 @@
     @DontInline
     public boolean test16_dontinline(MyValue1.ref vt) {
         return (Object)vt == null;
     }
 
-    // Test c2c call passing null for a inline type
+    // Test c2c call passing null for an inline type
     @Test
     @Warmup(10000) // Warmup to make sure 'test17_dontinline' is compiled
     public boolean test16(Object arg) throws Exception {
         Method test16method = getClass().getMethod("test16_dontinline", MyValue1.ref.class);
         return (boolean)test16method.invoke(this, arg);
@@ -516,11 +516,11 @@
     @ForceInline
     static void test18_target2(MyValue1.ref vt) {
         nullValue = vt;
     }
 
-    // Test passing null for a inline type
+    // Test passing null for an inline type
     @Test
     @Warmup(11000) // Make sure lambda forms get compiled
     public void test18() throws Throwable {
         test18_mh1.invokeExact(nullValue);
         test18_mh2.invokeExact(nullValue);
@@ -582,11 +582,11 @@
         } catch (Throwable t) {
             throw new RuntimeException("test20 failed", t);
         }
     }
 
-    // Test writing null to a flattenable/non-flattenable inline type field in a inline type
+    // Test writing null to a flattenable/non-flattenable inline type field in an inline type
     final inline class Test21Value {
         final MyValue1.ref valueField1;
         final MyValue1 valueField2;
         final MyValue1.ref alwaysNull = null;
 
@@ -897,11 +897,11 @@
     public void test35_verifier(boolean warmup) {
         test35(true);
         test35(false);
     }
 
-    // Test that when explicitly null checking a inline type, we keep
+    // Test that when explicitly null checking an inline type, we keep
     // track of the information that the inline type can never be null.
     @Test(failOn = ALLOC + STORE)
     public int test37(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
         if (vt1 == null) {
             return 0;
@@ -918,11 +918,11 @@
         Asserts.assertEquals(res, testValue1.x);
         res = test37(false, testValue1, testValue1);
         Asserts.assertEquals(res, testValue1.x);
     }
 
-    // Test that when explicitly null checking a inline type receiver,
+    // Test that when explicitly null checking an inline type receiver,
     // we keep track of the information that the inline type can never be null.
     @Test(failOn = ALLOC + STORE)
     public int test38(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
         vt1.hash(); // Inlined - Explicit null check
         // vt1 should be scalarized because it's always non-null
@@ -937,11 +937,11 @@
         Asserts.assertEquals(res, testValue1.x);
         res = test38(false, testValue1, testValue1);
         Asserts.assertEquals(res, testValue1.x);
     }
 
-    // Test that when implicitly null checking a inline type receiver,
+    // Test that when implicitly null checking an inline type receiver,
     // we keep track of the information that the inline type can never be null.
     @Test(failOn = ALLOC + STORE)
     public int test39(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
         vt1.hashInterpreted(); // Not inlined - Implicit null check
         // vt1 should be scalarized because it's always non-null
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestUnresolvedInlineClass.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestUnresolvedInlineClass.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestUnresolvedInlineClass.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestUnresolvedInlineClass.java
@@ -22,11 +22,11 @@
  */
 
 /**
  * @test
  * @bug 8187679
- * @summary The VM should exit gracefully when unable to resolve a inline type argument
+ * @summary The VM should exit gracefully when unable to resolve an inline type argument
  * @library /test/lib
  * @build SimpleInlineType
  * @run main/othervm TestUnresolvedInlineClass
  */
 

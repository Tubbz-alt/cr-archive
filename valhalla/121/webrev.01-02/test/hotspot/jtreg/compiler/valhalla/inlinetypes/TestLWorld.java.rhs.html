<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import java.lang.invoke.*;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 import jdk.experimental.value.MethodHandleBuilder;
  31 import jdk.test.lib.Asserts;
  32 
  33 /*
  34  * @test
  35  * @summary Test inline types in LWorld.
  36  * @modules java.base/jdk.experimental.value
  37  * @library /testlibrary /test/lib /compiler/whitebox /
  38  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  39  * @compile -XDallowEmptyValues TestLWorld.java
  40  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  41  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  42  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  43  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  44  *                               compiler.valhalla.inlinetypes.TestLWorld
  45  */
  46 public class TestLWorld extends InlineTypeTest {
  47     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  48     @Override
  49     public String[] getExtraVMParameters(int scenario) {
  50         switch (scenario) {
  51         case 1: return new String[] {&quot;-XX:-UseOptoBiasInlining&quot;};
  52         case 2: return new String[] {&quot;-DVerifyIR=false&quot;, &quot;-XX:-UseBiasedLocking&quot;};
  53         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UseBiasedLocking&quot;, &quot;-XX:FlatArrayElementMaxSize=-1&quot;};
  54         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  55         }
  56         return null;
  57     }
  58 
  59     public static void main(String[] args) throws Throwable {
  60         TestLWorld test = new TestLWorld();
  61         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class,
  62                  MyValue3Inline.class, Test51Value.class);
  63     }
  64 
  65     // Helper methods
  66 
  67     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  68     private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, true);
  69 
  70     protected long hash() {
  71         return testValue1.hash();
  72     }
  73 
<a name="1" id="anc1"></a><span class="line-modified">  74     // Test passing an inline type as an Object</span>
  75     @DontInline
  76     public Object test1_dontinline1(Object o) {
  77         return o;
  78     }
  79 
  80     @DontInline
  81     public MyValue1 test1_dontinline2(Object o) {
  82         return (MyValue1)o;
  83     }
  84 
  85     @ForceInline
  86     public Object test1_inline1(Object o) {
  87         return o;
  88     }
  89 
  90     @ForceInline
  91     public MyValue1 test1_inline2(Object o) {
  92         return (MyValue1)o;
  93     }
  94 
  95     @Test()
  96     public MyValue1 test1() {
  97         MyValue1 vt = testValue1;
  98         vt = (MyValue1)test1_dontinline1(vt);
  99         vt =           test1_dontinline2(vt);
 100         vt = (MyValue1)test1_inline1(vt);
 101         vt =           test1_inline2(vt);
 102         return vt;
 103     }
 104 
 105     @DontCompile
 106     public void test1_verifier(boolean warmup) {
 107         Asserts.assertEQ(test1().hash(), hash());
 108     }
 109 
 110     // Test storing/loading inline types to/from Object and inline type fields
 111     Object objectField1 = null;
 112     Object objectField2 = null;
 113     Object objectField3 = null;
 114     Object objectField4 = null;
 115     Object objectField5 = null;
 116     Object objectField6 = null;
 117 
 118     MyValue1 valueField1 = testValue1;
 119     MyValue1 valueField2 = testValue1;
 120     MyValue1.ref valueField3 = testValue1;
 121     MyValue1 valueField4;
 122     MyValue1.ref valueField5;
 123 
 124     static MyValue1.ref staticValueField1 = testValue1;
 125     static MyValue1 staticValueField2 = testValue1;
 126     static MyValue1 staticValueField3;
 127     static MyValue1.ref staticValueField4;
 128 
 129     @DontInline
 130     public Object readValueField5() {
 131         return (Object)valueField5;
 132     }
 133 
 134     @DontInline
 135     public Object readStaticValueField4() {
 136         return (Object)staticValueField4;
 137     }
 138 
 139     @Test()
 140     public long test2(MyValue1 vt1, Object vt2) {
 141         objectField1 = vt1;
 142         objectField2 = (MyValue1)vt2;
 143         objectField3 = testValue1;
 144         objectField4 = MyValue1.createWithFieldsDontInline(rI, rL);
 145         objectField5 = valueField1;
 146         objectField6 = valueField3;
 147         valueField1 = (MyValue1)objectField1;
 148         valueField2 = (MyValue1)vt2;
 149         valueField3 = (MyValue1)vt2;
 150         staticValueField1 = (MyValue1)objectField1;
 151         staticValueField2 = (MyValue1)vt1;
 152         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
 153         if (readValueField5() != null || readStaticValueField4() != null) {
 154             throw new RuntimeException(&quot;Should be null&quot;);
 155         }
 156         return ((MyValue1)objectField1).hash() + ((MyValue1)objectField2).hash() +
 157                ((MyValue1)objectField3).hash() + ((MyValue1)objectField4).hash() +
 158                ((MyValue1)objectField5).hash() + ((MyValue1)objectField6).hash() +
 159                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
 160                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
 161     }
 162 
 163     @DontCompile
 164     public void test2_verifier(boolean warmup) {
 165         MyValue1 vt = testValue1;
 166         MyValue1 def = MyValue1.createDefaultDontInline();
 167         long result = test2(vt, vt);
 168         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
 169     }
 170 
 171     // Test merging inline types and objects
 172     @Test()
 173     public Object test3(int state) {
 174         Object res = null;
 175         if (state == 0) {
 176             res = new Integer(rI);
 177         } else if (state == 1) {
 178             res = MyValue1.createWithFieldsInline(rI, rL);
 179         } else if (state == 2) {
 180             res = MyValue1.createWithFieldsDontInline(rI, rL);
 181         } else if (state == 3) {
 182             res = (MyValue1)objectField1;
 183         } else if (state == 4) {
 184             res = valueField1;
 185         } else if (state == 5) {
 186             res = null;
 187         } else if (state == 6) {
 188             res = MyValue2.createWithFieldsInline(rI, true);
 189         } else if (state == 7) {
 190             res = testValue2;
 191         }
 192         return res;
 193     }
 194 
 195     @DontCompile
 196     public void test3_verifier(boolean warmup) {
 197         objectField1 = valueField1;
 198         Object result = null;
 199         result = test3(0);
 200         Asserts.assertEQ((Integer)result, rI);
 201         result = test3(1);
 202         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 203         result = test3(2);
 204         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 205         result = test3(3);
 206         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 207         result = test3(4);
 208         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 209         result = test3(5);
 210         Asserts.assertEQ(result, null);
 211         result = test3(6);
 212         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
 213         result = test3(7);
 214         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
 215     }
 216 
 217     // Test merging inline types and objects in loops
 218     @Test()
 219     public Object test4(int iters) {
 220         Object res = new Integer(rI);
 221         for (int i = 0; i &lt; iters; ++i) {
 222             if (res instanceof Integer) {
 223                 res = MyValue1.createWithFieldsInline(rI, rL);
 224             } else {
 225                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
 226             }
 227         }
 228         return res;
 229     }
 230 
 231     @DontCompile
 232     public void test4_verifier(boolean warmup) {
 233         Integer result1 = (Integer)test4(0);
 234         Asserts.assertEQ(result1, rI);
 235         int iters = (Math.abs(rI) % 10) + 1;
 236         MyValue1 result2 = (MyValue1)test4(iters);
 237         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
 238         Asserts.assertEQ(result2.hash(), vt.hash());
 239     }
 240 
 241     // Test inline types in object variables that are live at safepoint
 242     @Test(failOn = ALLOC + STORE + LOOP)
 243     public long test5(MyValue1 arg, boolean deopt) {
 244         Object vt1 = MyValue1.createWithFieldsInline(rI, rL);
 245         Object vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
 246         Object vt3 = arg;
 247         Object vt4 = valueField1;
 248         if (deopt) {
 249             // uncommon trap
 250             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test5&quot;));
 251         }
 252         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
 253                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
 254     }
 255 
 256     @DontCompile
 257     public void test5_verifier(boolean warmup) {
 258         long result = test5(valueField1, !warmup);
 259         Asserts.assertEQ(result, 4*hash());
 260     }
 261 
 262     // Test comparing inline types with objects
 263     @Test(failOn = LOAD + LOOP)
 264     public boolean test6(Object arg) {
 265         Object vt = MyValue1.createWithFieldsInline(rI, rL);
 266         if (vt == arg || vt == (Object)valueField1 || vt == objectField1 || vt == null ||
 267             arg == vt || (Object)valueField1 == vt || objectField1 == vt || null == vt) {
 268             return true;
 269         }
 270         return false;
 271     }
 272 
 273     @DontCompile
 274     public void test6_verifier(boolean warmup) {
 275         boolean result = test6(null);
 276         Asserts.assertFalse(result);
 277     }
 278 
 279     // merge of inline type and non-inline type
 280     @Test
 281     public Object test7(boolean flag) {
 282         Object res = null;
 283         if (flag) {
 284             res = valueField1;
 285         } else {
 286             res = objectField1;
 287         }
 288         return res;
 289     }
 290 
 291     @DontCompile
 292     public void test7_verifier(boolean warmup) {
 293         test7(true);
 294         test7(false);
 295     }
 296 
 297     @Test
 298     public Object test8(boolean flag) {
 299         Object res = null;
 300         if (flag) {
 301             res = objectField1;
 302         } else {
 303             res = valueField1;
 304         }
 305         return res;
 306     }
 307 
 308     @DontCompile
 309     public void test8_verifier(boolean warmup) {
 310         test8(true);
 311         test8(false);
 312     }
 313 
 314     // merge of inline types in a loop, stored in an object local
 315     @Test
 316     public Object test9() {
 317         Object o = valueField1;
 318         for (int i = 1; i &lt; 100; i *= 2) {
 319             MyValue1 v = (MyValue1)o;
 320             o = MyValue1.setX(v, v.x + 1);
 321         }
 322         return o;
 323     }
 324 
 325     @DontCompile
 326     public void test9_verifier(boolean warmup) {
 327         test9();
 328     }
 329 
 330     // merge of inline types in an object local
 331     public Object test10_helper() {
 332         return valueField1;
 333     }
 334 
 335     @Test(failOn = ALLOC + LOAD + STORE)
 336     public void test10(boolean flag) {
 337         Object o = null;
 338         if (flag) {
 339             o = valueField1;
 340         } else {
 341             o = test10_helper();
 342         }
 343         valueField1 = (MyValue1)o;
 344     }
 345 
 346     @DontCompile
 347     public void test10_verifier(boolean warmup) {
 348         test10(true);
 349         test10(false);
 350     }
 351 
 352     // Interface tests
 353 
 354     @DontInline
 355     public MyInterface test11_dontinline1(MyInterface o) {
 356         return o;
 357     }
 358 
 359     @DontInline
 360     public MyValue1 test11_dontinline2(MyInterface o) {
 361         return (MyValue1)o;
 362     }
 363 
 364     @ForceInline
 365     public MyInterface test11_inline1(MyInterface o) {
 366         return o;
 367     }
 368 
 369     @ForceInline
 370     public MyValue1 test11_inline2(MyInterface o) {
 371         return (MyValue1)o;
 372     }
 373 
 374     @Test()
 375     public MyValue1 test11() {
 376         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 377         vt = (MyValue1)test11_dontinline1(vt);
 378         vt =           test11_dontinline2(vt);
 379         vt = (MyValue1)test11_inline1(vt);
 380         vt =           test11_inline2(vt);
 381         return vt;
 382     }
 383 
 384     @DontCompile
 385     public void test11_verifier(boolean warmup) {
 386         Asserts.assertEQ(test11().hash(), hash());
 387     }
 388 
 389     // Test storing/loading inline types to/from interface and inline type fields
 390     MyInterface interfaceField1 = null;
 391     MyInterface interfaceField2 = null;
 392     MyInterface interfaceField3 = null;
 393     MyInterface interfaceField4 = null;
 394     MyInterface interfaceField5 = null;
 395     MyInterface interfaceField6 = null;
 396 
 397     @DontInline
 398     public MyInterface readValueField5AsInterface() {
 399         return (MyInterface)valueField5;
 400     }
 401 
 402     @DontInline
 403     public MyInterface readStaticValueField4AsInterface() {
 404         return (MyInterface)staticValueField4;
 405     }
 406 
 407     @Test()
 408     public long test12(MyValue1 vt1, MyInterface vt2) {
 409         interfaceField1 = vt1;
 410         interfaceField2 = (MyValue1)vt2;
 411         interfaceField3 = MyValue1.createWithFieldsInline(rI, rL);
 412         interfaceField4 = MyValue1.createWithFieldsDontInline(rI, rL);
 413         interfaceField5 = valueField1;
 414         interfaceField6 = valueField3;
 415         valueField1 = (MyValue1)interfaceField1;
 416         valueField2 = (MyValue1)vt2;
 417         valueField3 = (MyValue1)vt2;
 418         staticValueField1 = (MyValue1)interfaceField1;
 419         staticValueField2 = (MyValue1)vt1;
 420         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
 421         if (readValueField5AsInterface() != null || readStaticValueField4AsInterface() != null) {
 422             throw new RuntimeException(&quot;Should be null&quot;);
 423         }
 424         return ((MyValue1)interfaceField1).hash() + ((MyValue1)interfaceField2).hash() +
 425                ((MyValue1)interfaceField3).hash() + ((MyValue1)interfaceField4).hash() +
 426                ((MyValue1)interfaceField5).hash() + ((MyValue1)interfaceField6).hash() +
 427                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
 428                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
 429     }
 430 
 431     @DontCompile
 432     public void test12_verifier(boolean warmup) {
 433         MyValue1 vt = testValue1;
 434         MyValue1 def = MyValue1.createDefaultDontInline();
 435         long result = test12(vt, vt);
 436         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
 437     }
 438 
 439     class MyObject1 implements MyInterface {
 440         public int x;
 441 
 442         public MyObject1(int x) {
 443             this.x = x;
 444         }
 445 
 446         @ForceInline
 447         public long hash() {
 448             return x;
 449         }
 450     }
 451 
 452     // Test merging inline types and interfaces
 453     @Test()
 454     public MyInterface test13(int state) {
 455         MyInterface res = null;
 456         if (state == 0) {
 457             res = new MyObject1(rI);
 458         } else if (state == 1) {
 459             res = MyValue1.createWithFieldsInline(rI, rL);
 460         } else if (state == 2) {
 461             res = MyValue1.createWithFieldsDontInline(rI, rL);
 462         } else if (state == 3) {
 463             res = (MyValue1)objectField1;
 464         } else if (state == 4) {
 465             res = valueField1;
 466         } else if (state == 5) {
 467             res = null;
 468         }
 469         return res;
 470     }
 471 
 472     @DontCompile
 473     public void test13_verifier(boolean warmup) {
 474         objectField1 = valueField1;
 475         MyInterface result = null;
 476         result = test13(0);
 477         Asserts.assertEQ(((MyObject1)result).x, rI);
 478         result = test13(1);
 479         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 480         result = test13(2);
 481         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 482         result = test13(3);
 483         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 484         result = test13(4);
 485         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 486         result = test13(5);
 487         Asserts.assertEQ(result, null);
 488     }
 489 
 490     // Test merging inline types and interfaces in loops
 491     @Test()
 492     public MyInterface test14(int iters) {
 493         MyInterface res = new MyObject1(rI);
 494         for (int i = 0; i &lt; iters; ++i) {
 495             if (res instanceof MyObject1) {
 496                 res = MyValue1.createWithFieldsInline(rI, rL);
 497             } else {
 498                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
 499             }
 500         }
 501         return res;
 502     }
 503 
 504     @DontCompile
 505     public void test14_verifier(boolean warmup) {
 506         MyObject1 result1 = (MyObject1)test14(0);
 507         Asserts.assertEQ(result1.x, rI);
 508         int iters = (Math.abs(rI) % 10) + 1;
 509         MyValue1 result2 = (MyValue1)test14(iters);
 510         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
 511         Asserts.assertEQ(result2.hash(), vt.hash());
 512     }
 513 
 514     // Test inline types in interface variables that are live at safepoint
 515     @Test(failOn = ALLOC + STORE + LOOP)
 516     public long test15(MyValue1 arg, boolean deopt) {
 517         MyInterface vt1 = MyValue1.createWithFieldsInline(rI, rL);
 518         MyInterface vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
 519         MyInterface vt3 = arg;
 520         MyInterface vt4 = valueField1;
 521         if (deopt) {
 522             // uncommon trap
 523             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test15&quot;));
 524         }
 525         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
 526                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
 527     }
 528 
 529     @DontCompile
 530     public void test15_verifier(boolean warmup) {
 531         long result = test15(valueField1, !warmup);
 532         Asserts.assertEQ(result, 4*hash());
 533     }
 534 
 535     // Test comparing inline types with interfaces
 536     @Test(failOn = LOAD + LOOP)
 537     public boolean test16(Object arg) {
 538         MyInterface vt = MyValue1.createWithFieldsInline(rI, rL);
 539         if (vt == arg || vt == (MyInterface)valueField1 || vt == interfaceField1 || vt == null ||
 540             arg == vt || (MyInterface)valueField1 == vt || interfaceField1 == vt || null == vt) {
 541             return true;
 542         }
 543         return false;
 544     }
 545 
 546     @DontCompile
 547     public void test16_verifier(boolean warmup) {
 548         boolean result = test16(null);
 549         Asserts.assertFalse(result);
 550     }
 551 
 552     // Test subtype check when casting to inline type
 553     @Test
 554     public MyValue1 test17(MyValue1 vt, Object obj) {
 555         try {
 556             vt = (MyValue1)obj;
 557             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 558         } catch (ClassCastException e) {
 559             // Expected
 560         }
 561         return vt;
 562     }
 563 
 564     @DontCompile
 565     public void test17_verifier(boolean warmup) {
 566         MyValue1 vt = testValue1;
 567         MyValue1 result = test17(vt, new Integer(rI));
 568         Asserts.assertEquals(result.hash(), vt.hash());
 569     }
 570 
 571     @Test
 572     public MyValue1 test18(MyValue1 vt) {
 573         Object obj = vt;
 574         vt = (MyValue1)obj;
 575         return vt;
 576     }
 577 
 578     @DontCompile
 579     public void test18_verifier(boolean warmup) {
 580         MyValue1 vt = testValue1;
 581         MyValue1 result = test18(vt);
 582         Asserts.assertEquals(result.hash(), vt.hash());
 583     }
 584 
 585     @Test
 586     public void test19(MyValue1 vt) {
 587         Object obj = vt;
 588         try {
 589             MyValue2 vt2 = (MyValue2)obj;
 590             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 591         } catch (ClassCastException e) {
 592             // Expected
 593         }
 594     }
 595 
 596     @DontCompile
 597     public void test19_verifier(boolean warmup) {
 598         test19(valueField1);
 599     }
 600 
 601     @Test
 602     public void test20(MyValue1 vt) {
 603         Object obj = vt;
 604         try {
 605             Integer i = (Integer)obj;
 606             throw new RuntimeException(&quot;ClassCastException expected&quot;);
 607         } catch (ClassCastException e) {
 608             // Expected
 609         }
 610     }
 611 
 612     @DontCompile
 613     public void test20_verifier(boolean warmup) {
 614         test20(valueField1);
 615     }
 616 
 617     // Array tests
 618 
 619     private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,
 620                                                                       testValue1,
 621                                                                       testValue1};
 622 
 623     private static final MyValue1[][] testValue1Array2 = new MyValue1[][] {testValue1Array,
 624                                                                            testValue1Array,
 625                                                                            testValue1Array};
 626 
 627     private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2,
 628                                                                       testValue2,
 629                                                                       testValue2};
 630 
 631     private static final Integer[] testIntegerArray = new Integer[42];
 632 
 633     // Test load from (flattened) inline type array disguised as object array
 634     @Test()
 635     public Object test21(Object[] oa, int index) {
 636         return oa[index];
 637     }
 638 
 639     @DontCompile
 640     public void test21_verifier(boolean warmup) {
 641         MyValue1 result = (MyValue1)test21(testValue1Array, Math.abs(rI) % 3);
 642         Asserts.assertEQ(result.hash(), hash());
 643     }
 644 
 645     // Test load from (flattened) inline type array disguised as interface array
 646     @Test()
 647     public Object test22Interface(MyInterface[] ia, int index) {
 648         return ia[index];
 649     }
 650 
 651     @DontCompile
 652     public void test22Interface_verifier(boolean warmup) {
 653         MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);
 654         Asserts.assertEQ(result.hash(), hash());
 655     }
 656 
 657     // Test load from (flattened) inline type array disguised as abstract array
 658     @Test()
 659     public Object test22Abstract(MyAbstract[] ia, int index) {
 660         return ia[index];
 661     }
 662 
 663     @DontCompile
 664     public void test22Abstract_verifier(boolean warmup) {
 665         MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);
 666         Asserts.assertEQ(result.hash(), hash());
 667     }
 668 
 669     // Test inline store to (flattened) inline type array disguised as object array
 670     @ForceInline
 671     public void test23_inline(Object[] oa, Object o, int index) {
 672         oa[index] = o;
 673     }
 674 
 675     @Test()
 676     public void test23(Object[] oa, MyValue1 vt, int index) {
 677         test23_inline(oa, vt, index);
 678     }
 679 
 680     @DontCompile
 681     public void test23_verifier(boolean warmup) {
 682         int index = Math.abs(rI) % 3;
 683         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 684         test23(testValue1Array, vt, index);
 685         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 686         testValue1Array[index] = testValue1;
 687         try {
 688             test23(testValue2Array, vt, index);
 689             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 690         } catch (ArrayStoreException e) {
 691             // Expected
 692         }
 693         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 694     }
 695 
 696     @ForceInline
 697     public void test24_inline(Object[] oa, Object o, int index) {
 698         oa[index] = o;
 699     }
 700 
 701     @Test()
 702     public void test24(Object[] oa, MyValue1 vt, int index) {
 703         test24_inline(oa, vt, index);
 704     }
 705 
 706     @DontCompile
 707     public void test24_verifier(boolean warmup) {
 708         int index = Math.abs(rI) % 3;
 709         try {
 710             test24(testIntegerArray, testValue1, index);
 711             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 712         } catch (ArrayStoreException e) {
 713             // Expected
 714         }
 715     }
 716 
 717     @ForceInline
 718     public void test25_inline(Object[] oa, Object o, int index) {
 719         oa[index] = o;
 720     }
 721 
 722     @Test()
 723     public void test25(Object[] oa, MyValue1 vt, int index) {
 724         test25_inline(oa, vt, index);
 725     }
 726 
 727     @DontCompile
 728     public void test25_verifier(boolean warmup) {
 729         int index = Math.abs(rI) % 3;
 730         try {
 731             test25(null, testValue1, index);
 732             throw new RuntimeException(&quot;No NPE thrown&quot;);
 733         } catch (NullPointerException e) {
 734             // Expected
 735         }
 736     }
 737 
 738     // Test inline store to (flattened) inline type array disguised as interface array
 739     @ForceInline
 740     public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 741         ia[index] = i;
 742     }
 743 
 744     @Test()
 745     public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {
 746       test26Interface_inline(ia, vt, index);
 747     }
 748 
 749     @DontCompile
 750     public void test26Interface_verifier(boolean warmup) {
 751         int index = Math.abs(rI) % 3;
 752         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 753         test26Interface(testValue1Array, vt, index);
 754         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 755         testValue1Array[index] = testValue1;
 756         try {
 757             test26Interface(testValue2Array, vt, index);
 758             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 759         } catch (ArrayStoreException e) {
 760             // Expected
 761         }
 762         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 763     }
 764 
 765     @ForceInline
 766     public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 767         ia[index] = i;
 768     }
 769 
 770     @Test()
 771     public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {
 772         test27Interface_inline(ia, vt, index);
 773     }
 774 
 775     @DontCompile
 776     public void test27Interface_verifier(boolean warmup) {
 777         int index = Math.abs(rI) % 3;
 778         try {
 779             test27Interface(null, testValue1, index);
 780             throw new RuntimeException(&quot;No NPE thrown&quot;);
 781         } catch (NullPointerException e) {
 782             // Expected
 783         }
 784     }
 785 
 786     // Test inline store to (flattened) inline type array disguised as abstract array
 787     @ForceInline
 788     public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 789         ia[index] = i;
 790     }
 791 
 792     @Test()
 793     public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {
 794       test26Abstract_inline(ia, vt, index);
 795     }
 796 
 797     @DontCompile
 798     public void test26Abstract_verifier(boolean warmup) {
 799         int index = Math.abs(rI) % 3;
 800         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 801         test26Abstract(testValue1Array, vt, index);
 802         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 803         testValue1Array[index] = testValue1;
 804         try {
 805             test26Abstract(testValue2Array, vt, index);
 806             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 807         } catch (ArrayStoreException e) {
 808             // Expected
 809         }
 810         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 811     }
 812 
 813     @ForceInline
 814     public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 815         ia[index] = i;
 816     }
 817 
 818     @Test()
 819     public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {
 820         test27Abstract_inline(ia, vt, index);
 821     }
 822 
 823     @DontCompile
 824     public void test27Abstract_verifier(boolean warmup) {
 825         int index = Math.abs(rI) % 3;
 826         try {
 827             test27Abstract(null, testValue1, index);
 828             throw new RuntimeException(&quot;No NPE thrown&quot;);
 829         } catch (NullPointerException e) {
 830             // Expected
 831         }
 832     }
 833 
 834     // Test object store to (flattened) inline type array disguised as object array
 835     @ForceInline
 836     public void test28_inline(Object[] oa, Object o, int index) {
 837         oa[index] = o;
 838     }
 839 
 840     @Test()
 841     public void test28(Object[] oa, Object o, int index) {
 842         test28_inline(oa, o, index);
 843     }
 844 
 845     @DontCompile
 846     public void test28_verifier(boolean warmup) {
 847         int index = Math.abs(rI) % 3;
 848         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 849         test28(testValue1Array, vt1, index);
 850         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 851         try {
 852             test28(testValue1Array, testValue2, index);
 853             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 854         } catch (ArrayStoreException e) {
 855             // Expected
 856         }
 857         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 858         testValue1Array[index] = testValue1;
 859     }
 860 
 861     @ForceInline
 862     public void test29_inline(Object[] oa, Object o, int index) {
 863         oa[index] = o;
 864     }
 865 
 866     @Test()
 867     public void test29(Object[] oa, Object o, int index) {
 868         test29_inline(oa, o, index);
 869     }
 870 
 871     @DontCompile
 872     public void test29_verifier(boolean warmup) {
 873         int index = Math.abs(rI) % 3;
 874         try {
 875             test29(testValue2Array, testValue1, index);
 876             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 877         } catch (ArrayStoreException e) {
 878             // Expected
 879         }
 880         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 881     }
 882 
 883     @ForceInline
 884     public void test30_inline(Object[] oa, Object o, int index) {
 885         oa[index] = o;
 886     }
 887 
 888     @Test()
 889     public void test30(Object[] oa, Object o, int index) {
 890         test30_inline(oa, o, index);
 891     }
 892 
 893     @DontCompile
 894     public void test30_verifier(boolean warmup) {
 895         int index = Math.abs(rI) % 3;
 896         try {
 897             test30(testIntegerArray, testValue1, index);
 898             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 899         } catch (ArrayStoreException e) {
 900             // Expected
 901         }
 902     }
 903 
 904     // Test inline store to (flattened) inline type array disguised as interface array
 905     @ForceInline
 906     public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 907         ia[index] = i;
 908     }
 909 
 910     @Test()
 911     public void test31Interface(MyInterface[] ia, MyInterface i, int index) {
 912         test31Interface_inline(ia, i, index);
 913     }
 914 
 915     @DontCompile
 916     public void test31Interface_verifier(boolean warmup) {
 917         int index = Math.abs(rI) % 3;
 918         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 919         test31Interface(testValue1Array, vt1, index);
 920         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 921         try {
 922             test31Interface(testValue1Array, testValue2, index);
 923             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 924         } catch (ArrayStoreException e) {
 925             // Expected
 926         }
 927         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 928         testValue1Array[index] = testValue1;
 929     }
 930 
 931     @ForceInline
 932     public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {
 933         ia[index] = i;
 934     }
 935 
 936     @Test()
 937     public void test32Interface(MyInterface[] ia, MyInterface i, int index) {
 938         test32Interface_inline(ia, i, index);
 939     }
 940 
 941     @DontCompile
 942     public void test32Interface_verifier(boolean warmup) {
 943         int index = Math.abs(rI) % 3;
 944         try {
 945             test32Interface(testValue2Array, testValue1, index);
 946             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 947         } catch (ArrayStoreException e) {
 948             // Expected
 949         }
 950     }
 951 
 952     // Test inline store to (flattened) inline type array disguised as abstract array
 953     @ForceInline
 954     public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 955         ia[index] = i;
 956     }
 957 
 958     @Test()
 959     public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {
 960         test31Abstract_inline(ia, i, index);
 961     }
 962 
 963     @DontCompile
 964     public void test31Abstract_verifier(boolean warmup) {
 965         int index = Math.abs(rI) % 3;
 966         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 967         test31Abstract(testValue1Array, vt1, index);
 968         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 969         try {
 970             test31Abstract(testValue1Array, testValue2, index);
 971             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 972         } catch (ArrayStoreException e) {
 973             // Expected
 974         }
 975         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 976         testValue1Array[index] = testValue1;
 977     }
 978 
 979     @ForceInline
 980     public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
 981         ia[index] = i;
 982     }
 983 
 984     @Test()
 985     public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {
 986         test32Abstract_inline(ia, i, index);
 987     }
 988 
 989     @DontCompile
 990     public void test32Abstract_verifier(boolean warmup) {
 991         int index = Math.abs(rI) % 3;
 992         try {
 993             test32Abstract(testValue2Array, testValue1, index);
 994             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 995         } catch (ArrayStoreException e) {
 996             // Expected
 997         }
 998     }
 999 
1000     // Test writing null to a (flattened) inline type array disguised as object array
1001     @ForceInline
1002     public void test33_inline(Object[] oa, Object o, int index) {
1003         oa[index] = o;
1004     }
1005 
1006     @Test()
1007     public void test33(Object[] oa, Object o, int index) {
1008         test33_inline(oa, o, index);
1009     }
1010 
1011     @DontCompile
1012     public void test33_verifier(boolean warmup) {
1013         int index = Math.abs(rI) % 3;
1014         try {
1015             test33(testValue1Array, null, index);
1016             throw new RuntimeException(&quot;No NPE thrown&quot;);
1017         } catch (NullPointerException e) {
1018             // Expected
1019         }
1020         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1021     }
1022 
1023     // Test writing constant null to a (flattened) inline type array disguised as object array
1024 
1025     @ForceInline
1026     public void test34_inline(Object[] oa, Object o, int index) {
1027         oa[index] = o;
1028     }
1029 
1030     @Test()
1031     public void test34(Object[] oa, int index) {
1032         test34_inline(oa, null, index);
1033     }
1034 
1035     @DontCompile
1036     public void test34_verifier(boolean warmup) {
1037         int index = Math.abs(rI) % 3;
1038         try {
1039             test34(testValue1Array, index);
1040             throw new RuntimeException(&quot;No NPE thrown&quot;);
1041         } catch (NullPointerException e) {
1042             // Expected
1043         }
1044         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1045     }
1046 
1047     // Test writing constant null to a (flattened) inline type array
1048 
1049     private static final MethodHandle setArrayElementNull = MethodHandleBuilder.loadCode(MethodHandles.lookup(),
1050         &quot;setArrayElementNull&quot;,
1051         MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class),
1052         CODE -&gt; {
1053             CODE.
1054             aload_1().
1055             iload_2().
1056             aconst_null().
1057             aastore().
1058             return_();
1059         });
1060 
1061     @Test()
1062     public void test35(MyValue1[] va, int index) throws Throwable {
1063         setArrayElementNull.invoke(this, va, index);
1064     }
1065 
1066     @DontCompile
1067     public void test35_verifier(boolean warmup) throws Throwable {
1068         int index = Math.abs(rI) % 3;
1069         try {
1070             test35(testValue1Array, index);
1071             throw new RuntimeException(&quot;No NPE thrown&quot;);
1072         } catch (NullPointerException e) {
1073             // Expected
1074         }
1075         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1076     }
1077 
<a name="2" id="anc2"></a><span class="line-modified">1078     // Test writing an inline type to a null inline type array</span>
1079     @Test()
1080     public void test36(MyValue1[] va, MyValue1 vt, int index) {
1081         va[index] = vt;
1082     }
1083 
1084     @DontCompile
1085     public void test36_verifier(boolean warmup) {
1086         int index = Math.abs(rI) % 3;
1087         try {
1088             test36(null, testValue1Array[index], index);
1089             throw new RuntimeException(&quot;No NPE thrown&quot;);
1090         } catch (NullPointerException e) {
1091             // Expected
1092         }
1093     }
1094 
1095     // Test incremental inlining
1096     @ForceInline
1097     public void test37_inline(Object[] oa, Object o, int index) {
1098         oa[index] = o;
1099     }
1100 
1101     @Test()
1102     public void test37(MyValue1[] va, Object o, int index) {
1103         test37_inline(va, o, index);
1104     }
1105 
1106     @DontCompile
1107     public void test37_verifier(boolean warmup) {
1108         int index = Math.abs(rI) % 3;
1109         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
1110         test37(testValue1Array, vt1, index);
1111         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
1112         try {
1113             test37(testValue1Array, testValue2, index);
1114             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1115         } catch (ArrayStoreException e) {
1116             // Expected
1117         }
1118         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
1119         testValue1Array[index] = testValue1;
1120     }
1121 
1122     // Test merging of inline type arrays
1123 
1124     @ForceInline
1125     public Object[] test38_inline() {
1126         return new MyValue1[42];
1127     }
1128 
1129     @Test()
1130     public Object[] test38(Object[] oa, Object o, int i1, int i2, int num) {
1131         Object[] result = null;
1132         switch (num) {
1133         case 0:
1134             result = test38_inline();
1135             break;
1136         case 1:
1137             result = oa;
1138             break;
1139         case 2:
1140             result = testValue1Array;
1141             break;
1142         case 3:
1143             result = testValue2Array;
1144             break;
1145         case 4:
1146             result = testIntegerArray;
1147             break;
1148         case 5:
1149             result = null;
1150             break;
1151         case 6:
1152             result = testValue1Array2;
1153             break;
1154         }
1155         result[i1] = result[i2];
1156         result[i2] = o;
1157         return result;
1158     }
1159 
1160     @DontCompile
1161     public void test38_verifier(boolean warmup) {
1162         int index = Math.abs(rI) % 3;
1163         MyValue1[] va = new MyValue1[42];
1164         Object[] result = test38(null, testValue1, index, index, 0);
1165         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1166         result = test38(testValue1Array, testValue1, index, index, 1);
1167         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1168         result = test38(null, testValue1, index, index, 2);
1169         Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());
1170         result = test38(null, testValue2, index, index, 3);
1171         Asserts.assertEQ(((MyValue2)result[index]).hash(), testValue2.hash());
1172         try {
1173             result = test38(null, null, index, index, 3);
1174             throw new RuntimeException(&quot;No NPE thrown&quot;);
1175         } catch (NullPointerException e) {
1176             // Expected
1177         }
1178         result = test38(null, null, index, index, 4);
1179         try {
1180             result = test38(null, testValue1, index, index, 4);
1181             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1182         } catch (ArrayStoreException e) {
1183             // Expected
1184         }
1185         try {
1186             result = test38(null, testValue1, index, index, 5);
1187             throw new RuntimeException(&quot;No NPE thrown&quot;);
1188         } catch (NullPointerException e) {
1189             // Expected
1190         }
1191         result = test38(null, testValue1Array, index, index, 6);
1192         Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());
1193     }
1194 
1195     @ForceInline
1196     public Object test39_inline() {
1197         return new MyValue1[42];
1198     }
1199 
1200     // Same as above but merging into Object instead of Object[]
1201     @Test()
1202     public Object test39(Object oa, Object o, int i1, int i2, int num) {
1203         Object result = null;
1204         switch (num) {
1205         case 0:
1206             result = test39_inline();
1207             break;
1208         case 1:
1209             result = oa;
1210             break;
1211         case 2:
1212             result = testValue1Array;
1213             break;
1214         case 3:
1215             result = testValue2Array;
1216             break;
1217         case 4:
1218             result = testIntegerArray;
1219             break;
1220         case 5:
1221             result = null;
1222             break;
1223         case 6:
1224             result = testValue1;
1225             break;
1226         case 7:
1227             result = testValue2;
1228             break;
1229         case 8:
1230             result = MyValue1.createWithFieldsInline(rI, rL);
1231             break;
1232         case 9:
1233             result = new Integer(42);
1234             break;
1235         case 10:
1236             result = testValue1Array2;
1237             break;
1238         }
1239         if (result instanceof Object[]) {
1240             ((Object[])result)[i1] = ((Object[])result)[i2];
1241             ((Object[])result)[i2] = o;
1242         }
1243         return result;
1244     }
1245 
1246     @DontCompile
1247     public void test39_verifier(boolean warmup) {
1248         int index = Math.abs(rI) % 3;
1249         MyValue1[] va = new MyValue1[42];
1250         Object result = test39(null, testValue1, index, index, 0);
1251         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1252         result = test39(testValue1Array, testValue1, index, index, 1);
1253         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1254         result = test39(null, testValue1, index, index, 2);
1255         Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());
1256         result = test39(null, testValue2, index, index, 3);
1257         Asserts.assertEQ(((MyValue2[])result)[index].hash(), testValue2.hash());
1258         try {
1259             result = test39(null, null, index, index, 3);
1260             throw new RuntimeException(&quot;No NPE thrown&quot;);
1261         } catch (NullPointerException e) {
1262             // Expected
1263         }
1264         result = test39(null, null, index, index, 4);
1265         try {
1266             result = test39(null, testValue1, index, index, 4);
1267             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1268         } catch (ArrayStoreException e) {
1269             // Expected
1270         }
1271         result = test39(null, testValue1, index, index, 5);
1272         Asserts.assertEQ(result, null);
1273         result = test39(null, testValue1, index, index, 6);
1274         Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());
1275         result = test39(null, testValue1, index, index, 7);
1276         Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());
1277         result = test39(null, testValue1, index, index, 8);
1278         Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());
1279         result = test39(null, testValue1, index, index, 9);
1280         Asserts.assertEQ(((Integer)result), 42);
1281         result = test39(null, testValue1Array, index, index, 10);
1282         Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());
1283     }
1284 
1285     // Test instanceof with inline types and arrays
1286     @Test()
1287     public long test40(Object o, int index) {
1288         if (o instanceof MyValue1) {
1289           return ((MyValue1)o).hashInterpreted();
1290         } else if (o instanceof MyValue1[]) {
1291           return ((MyValue1[])o)[index].hashInterpreted();
1292         } else if (o instanceof MyValue2) {
1293           return ((MyValue2)o).hash();
1294         } else if (o instanceof MyValue2[]) {
1295           return ((MyValue2[])o)[index].hash();
1296         } else if (o instanceof MyValue1[][]) {
1297           return ((MyValue1[][])o)[index][index].hash();
1298         } else if (o instanceof Long) {
1299           return (long)o;
1300         }
1301         return 0;
1302     }
1303 
1304     @DontCompile
1305     public void test40_verifier(boolean warmup) {
1306         int index = Math.abs(rI) % 3;
1307         long result = test40(testValue1, 0);
1308         Asserts.assertEQ(result, testValue1.hash());
1309         result = test40(testValue1Array, index);
1310         Asserts.assertEQ(result, testValue1.hash());
1311         result = test40(testValue2, index);
1312         Asserts.assertEQ(result, testValue2.hash());
1313         result = test40(testValue2Array, index);
1314         Asserts.assertEQ(result, testValue2.hash());
1315         result = test40(testValue1Array2, index);
1316         Asserts.assertEQ(result, testValue1.hash());
1317         result = test40(new Long(42), index);
1318         Asserts.assertEQ(result, 42L);
1319     }
1320 
1321     // Test for bug in Escape Analysis
1322     @DontInline
1323     public void test41_dontinline(Object o) {
1324         Asserts.assertEQ(o, rI);
1325     }
1326 
1327     @Test()
1328     public void test41() {
1329         MyValue1[] vals = new MyValue1[] {testValue1};
1330         test41_dontinline(vals[0].oa[0]);
1331         test41_dontinline(vals[0].oa[0]);
1332     }
1333 
1334     @DontCompile
1335     public void test41_verifier(boolean warmup) {
1336         test41();
1337     }
1338 
1339     // Test for bug in Escape Analysis
1340     private static final MyValue1.ref test42VT1 = MyValue1.createWithFieldsInline(rI, rL);
1341     private static final MyValue1.ref test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
1342 
1343     @Test()
1344     public void test42() {
1345         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1346         Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
1347         Asserts.assertEQ(vals[1].hash(), test42VT2.hash());
1348     }
1349 
1350     @DontCompile
1351     public void test42_verifier(boolean warmup) {
1352         if (!warmup) test42(); // We need -Xcomp behavior
1353     }
1354 
1355     // Test for bug in Escape Analysis
1356     @Test()
1357     public long test43(boolean deopt) {
1358         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1359 
1360         if (deopt) {
1361             // uncommon trap
1362             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test43&quot;));
1363             Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
1364             Asserts.assertEQ(vals[1].hash(), test42VT2.hash());
1365         }
1366 
1367         return vals[0].hash();
1368     }
1369 
1370     @DontCompile
1371     public void test43_verifier(boolean warmup) {
1372         test43(!warmup);
1373     }
1374 
1375     // Tests writing an array element with a (statically known) incompatible type
1376     private static final MethodHandle setArrayElementIncompatible = MethodHandleBuilder.loadCode(MethodHandles.lookup(),
1377         &quot;setArrayElementIncompatible&quot;,
1378         MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),
1379         CODE -&gt; {
1380             CODE.
1381             aload_1().
1382             iload_2().
1383             aload_3().
1384             aastore().
1385             return_();
1386         });
1387 
1388     @Test()
1389     public void test44(MyValue1[] va, int index, MyValue2 v) throws Throwable {
1390         setArrayElementIncompatible.invoke(this, va, index, v);
1391     }
1392 
1393     @DontCompile
1394     public void test44_verifier(boolean warmup) throws Throwable {
1395         int index = Math.abs(rI) % 3;
1396         try {
1397             test44(testValue1Array, index, testValue2);
1398             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1399         } catch (ArrayStoreException e) {
1400             // Expected
1401         }
1402         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1403     }
1404 
1405     // Tests writing an array element with a (statically known) incompatible type
1406     @ForceInline
1407     public void test45_inline(Object[] oa, Object o, int index) {
1408         oa[index] = o;
1409     }
1410 
1411     @Test()
1412     public void test45(MyValue1[] va, int index, MyValue2 v) throws Throwable {
1413         test45_inline(va, v, index);
1414     }
1415 
1416     @DontCompile
1417     public void test45_verifier(boolean warmup) throws Throwable {
1418         int index = Math.abs(rI) % 3;
1419         try {
1420             test45(testValue1Array, index, testValue2);
1421             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
1422         } catch (ArrayStoreException e) {
1423             // Expected
1424         }
1425         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1426     }
1427 
1428     // instanceof tests with inline types
1429     @Test
1430     public boolean test46(MyValue1 vt) {
1431         Object obj = vt;
1432         return obj instanceof MyValue1;
1433     }
1434 
1435     @DontCompile
1436     public void test46_verifier(boolean warmup) {
1437         MyValue1 vt = testValue1;
1438         boolean result = test46(vt);
1439         Asserts.assertTrue(result);
1440     }
1441 
1442     @Test
1443     public boolean test47(MyValue1 vt) {
1444         Object obj = vt;
1445         return obj instanceof MyValue2;
1446     }
1447 
1448     @DontCompile
1449     public void test47_verifier(boolean warmup) {
1450         MyValue1 vt = testValue1;
1451         boolean result = test47(vt);
1452         Asserts.assertFalse(result);
1453     }
1454 
1455     @Test
1456     public boolean test48(Object obj) {
1457         return obj instanceof MyValue1;
1458     }
1459 
1460     @DontCompile
1461     public void test48_verifier(boolean warmup) {
1462         MyValue1 vt = testValue1;
1463         boolean result = test48(vt);
1464         Asserts.assertTrue(result);
1465     }
1466 
1467     @Test
1468     public boolean test49(Object obj) {
1469         return obj instanceof MyValue2;
1470     }
1471 
1472     @DontCompile
1473     public void test49_verifier(boolean warmup) {
1474         MyValue1 vt = testValue1;
1475         boolean result = test49(vt);
1476         Asserts.assertFalse(result);
1477     }
1478 
1479     @Test
1480     public boolean test50(Object obj) {
1481         return obj instanceof MyValue1;
1482     }
1483 
1484     @DontCompile
1485     public void test50_verifier(boolean warmup) {
1486         boolean result = test49(new Integer(42));
1487         Asserts.assertFalse(result);
1488     }
1489 
1490     // Inline type with some non-flattened fields
1491     final inline class Test51Value {
1492         final Object objectField1;
1493         final Object objectField2;
1494         final Object objectField3;
1495         final Object objectField4;
1496         final Object objectField5;
1497         final Object objectField6;
1498 
1499         final MyValue1 valueField1;
1500         final MyValue1 valueField2;
1501         final MyValue1.ref valueField3;
1502         final MyValue1 valueField4;
1503         final MyValue1.ref valueField5;
1504 
1505         public Test51Value() {
1506             objectField1 = null;
1507             objectField2 = null;
1508             objectField3 = null;
1509             objectField4 = null;
1510             objectField5 = null;
1511             objectField6 = null;
1512             valueField1 = testValue1;
1513             valueField2 = testValue1;
1514             valueField3 = testValue1;
1515             valueField4 = MyValue1.createDefaultDontInline();
1516             valueField5 = MyValue1.createDefaultDontInline();
1517         }
1518 
1519         public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,
1520                            MyValue1 vt1, MyValue1 vt2, MyValue1.ref vt3, MyValue1 vt4, MyValue1.ref vt5) {
1521             objectField1 = o1;
1522             objectField2 = o2;
1523             objectField3 = o3;
1524             objectField4 = o4;
1525             objectField5 = o5;
1526             objectField6 = o6;
1527             valueField1 = vt1;
1528             valueField2 = vt2;
1529             valueField3 = vt3;
1530             valueField4 = vt4;
1531             valueField5 = vt5;
1532         }
1533 
1534         @ForceInline
1535         public long test(Test51Value holder, MyValue1 vt1, Object vt2) {
1536             holder = new Test51Value(vt1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1537                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1538             holder = new Test51Value(holder.objectField1, (MyValue1)vt2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1539                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1540             holder = new Test51Value(holder.objectField1, holder.objectField2, testValue1, holder.objectField4, holder.objectField5, holder.objectField6,
1541                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1542             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, MyValue1.createWithFieldsDontInline(rI, rL), holder.objectField5, holder.objectField6,
1543                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1544             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.valueField1, holder.objectField6,
1545                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1546             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.valueField3,
1547                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1548             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1549                                      (MyValue1)holder.objectField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1550             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1551                                      holder.valueField1, (MyValue1)vt2, holder.valueField3, holder.valueField4, holder.valueField5);
1552             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1553                                      holder.valueField1, holder.valueField2, (MyValue1)vt2, holder.valueField4, holder.valueField5);
1554 
1555             return ((MyValue1)holder.objectField1).hash() +
1556                    ((MyValue1)holder.objectField2).hash() +
1557                    ((MyValue1)holder.objectField3).hash() +
1558                    ((MyValue1)holder.objectField4).hash() +
1559                    ((MyValue1)holder.objectField5).hash() +
1560                    ((MyValue1)holder.objectField6).hash() +
1561                    holder.valueField1.hash() +
1562                    holder.valueField2.hash() +
1563                    holder.valueField3.hash() +
1564                    holder.valueField4.hashPrimitive();
1565         }
1566     }
1567 
<a name="3" id="anc3"></a><span class="line-modified">1568     // Same as test2 but with field holder being an inline type</span>
1569     @Test()
1570     public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {
1571         return holder.test(holder, vt1, vt2);
1572     }
1573 
1574     @DontCompile
1575     public void test51_verifier(boolean warmup) {
1576         MyValue1 vt = testValue1;
1577         MyValue1 def = MyValue1.createDefaultDontInline();
1578         Test51Value holder = new Test51Value();
1579         Asserts.assertEQ(testValue1.hash(), vt.hash());
1580         Asserts.assertEQ(holder.valueField1.hash(), vt.hash());
1581         long result = test51(holder, vt, vt);
1582         Asserts.assertEQ(result, 9*vt.hash() + def.hashPrimitive());
1583     }
1584 
1585     // Access non-flattened, uninitialized inline type field with inline type holder
1586     @Test()
1587     public void test52(Test51Value holder) {
1588         if ((Object)holder.valueField5 != null) {
1589             throw new RuntimeException(&quot;Should be null&quot;);
1590         }
1591     }
1592 
1593     @DontCompile
1594     public void test52_verifier(boolean warmup) {
1595         Test51Value vt = Test51Value.default;
1596         test52(vt);
1597     }
1598 
1599     // Merging inline types of different types
1600     @Test()
1601     public Object test53(Object o, boolean b) {
1602         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1603         return b ? vt : o;
1604     }
1605 
1606     @DontCompile
1607     public void test53_verifier(boolean warmup) {
1608         test53(new Object(), false);
1609         MyValue1 result = (MyValue1)test53(new Object(), true);
1610         Asserts.assertEQ(result.hash(), hash());
1611     }
1612 
1613     @Test()
1614     public Object test54(boolean b) {
1615         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1616         return b ? vt : testValue2;
1617     }
1618 
1619     @DontCompile
1620     public void test54_verifier(boolean warmup) {
1621         MyValue1 result1 = (MyValue1)test54(true);
1622         Asserts.assertEQ(result1.hash(), hash());
1623         MyValue2 result2 = (MyValue2)test54(false);
1624         Asserts.assertEQ(result2.hash(), testValue2.hash());
1625     }
1626 
1627     @Test()
1628     public Object test55(boolean b) {
1629         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI, rL);
1630         MyValue2 vt2 = MyValue2.createWithFieldsInline(rI, true);
1631         return b ? vt1 : vt2;
1632     }
1633 
1634     @DontCompile
1635     public void test55_verifier(boolean warmup) {
1636         MyValue1 result1 = (MyValue1)test55(true);
1637         Asserts.assertEQ(result1.hash(), hash());
1638         MyValue2 result2 = (MyValue2)test55(false);
1639         Asserts.assertEQ(result2.hash(), testValue2.hash());
1640     }
1641 
1642     // Test synchronization on inline types
1643     @Test()
1644     public void test56(Object vt) {
1645         synchronized (vt) {
1646             throw new RuntimeException(&quot;test56 failed: synchronization on inline type should not succeed&quot;);
1647         }
1648     }
1649 
1650     @DontCompile
1651     public void test56_verifier(boolean warmup) {
1652         try {
1653             test56(testValue1);
1654             throw new RuntimeException(&quot;test56 failed: no exception thrown&quot;);
1655         } catch (IllegalMonitorStateException ex) {
1656             // Expected
1657         }
1658     }
1659 
1660     @ForceInline
1661     public void test57_inline(Object vt) {
1662         synchronized (vt) {
1663             throw new RuntimeException(&quot;test57 failed: synchronization on inline type should not succeed&quot;);
1664         }
1665     }
1666 
1667     @Test()
1668     public void test57(MyValue1 vt) {
1669         test57_inline(vt);
1670     }
1671 
1672     @DontCompile
1673     public void test57_verifier(boolean warmup) {
1674         try {
1675             test57(testValue1);
1676             throw new RuntimeException(&quot;test57 failed: no exception thrown&quot;);
1677         } catch (IllegalMonitorStateException ex) {
1678             // Expected
1679         }
1680     }
1681 
1682     @ForceInline
1683     public void test58_inline(Object vt) {
1684         synchronized (vt) {
1685             throw new RuntimeException(&quot;test58 failed: synchronization on inline type should not succeed&quot;);
1686         }
1687     }
1688 
1689     @Test()
1690     public void test58() {
1691         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1692         test58_inline(vt);
1693     }
1694 
1695     @DontCompile
1696     public void test58_verifier(boolean warmup) {
1697         try {
1698             test58();
1699             throw new RuntimeException(&quot;test58 failed: no exception thrown&quot;);
1700         } catch (IllegalMonitorStateException ex) {
1701             // Expected
1702         }
1703     }
1704 
1705     @Test()
1706     public void test59(Object o, boolean b) {
1707         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1708         Object sync = b ? vt : o;
1709         synchronized (sync) {
1710             if (b) {
1711                 throw new RuntimeException(&quot;test59 failed: synchronization on inline type should not succeed&quot;);
1712             }
1713         }
1714     }
1715 
1716     @DontCompile
1717     public void test59_verifier(boolean warmup) {
1718         test59(new Object(), false);
1719         try {
1720             test59(new Object(), true);
1721             throw new RuntimeException(&quot;test59 failed: no exception thrown&quot;);
1722         } catch (IllegalMonitorStateException ex) {
1723             // Expected
1724         }
1725     }
1726 
1727     @Test()
1728     public void test60(boolean b) {
1729         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1730         Object sync = b ? vt : testValue2;
1731         synchronized (sync) {
1732             throw new RuntimeException(&quot;test60 failed: synchronization on inline type should not succeed&quot;);
1733         }
1734     }
1735 
1736     @DontCompile
1737     public void test60_verifier(boolean warmup) {
1738         try {
1739             test60(false);
1740             throw new RuntimeException(&quot;test60 failed: no exception thrown&quot;);
1741         } catch (IllegalMonitorStateException ex) {
1742             // Expected
1743         }
1744         try {
1745             test60(true);
1746             throw new RuntimeException(&quot;test60 failed: no exception thrown&quot;);
1747         } catch (IllegalMonitorStateException ex) {
1748             // Expected
1749         }
1750     }
1751 
1752     // Test catching the IllegalMonitorStateException in compiled code
1753     @Test()
1754     public void test61(Object vt) {
1755         boolean thrown = false;
1756         try {
1757             synchronized (vt) {
1758                 throw new RuntimeException(&quot;test61 failed: no exception thrown&quot;);
1759             }
1760         } catch (IllegalMonitorStateException ex) {
1761             thrown = true;
1762         }
1763         if (!thrown) {
1764             throw new RuntimeException(&quot;test61 failed: no exception thrown&quot;);
1765         }
1766     }
1767 
1768     @DontCompile
1769     public void test61_verifier(boolean warmup) {
1770         test61(testValue1);
1771     }
1772 
1773     @Test()
1774     public void test62(Object o) {
1775         try {
1776             synchronized (o) { }
1777         } catch (IllegalMonitorStateException ex) {
1778             // Expected
1779             return;
1780         }
1781         throw new RuntimeException(&quot;test62 failed: no exception thrown&quot;);
1782     }
1783 
1784     @DontCompile
1785     public void test62_verifier(boolean warmup) {
1786         test62(testValue1);
1787     }
1788 
1789     // Test synchronization without any instructions in the synchronized block
1790     @Test()
1791     public void test63(Object o) {
1792         synchronized (o) { }
1793     }
1794 
1795     @DontCompile
1796     public void test63_verifier(boolean warmup) {
1797         try {
1798             test63(testValue1);
1799         } catch (IllegalMonitorStateException ex) {
1800             // Expected
1801             return;
1802         }
1803         throw new RuntimeException(&quot;test63 failed: no exception thrown&quot;);
1804     }
1805 
1806     // type system test with interface and inline type
1807     @ForceInline
1808     public MyInterface test64Interface_helper(MyValue1 vt) {
1809         return vt;
1810     }
1811 
1812     @Test()
1813     public MyInterface test64Interface(MyValue1 vt) {
1814         return test64Interface_helper(vt);
1815     }
1816 
1817     @DontCompile
1818     public void test64Interface_verifier(boolean warmup) {
1819         test64Interface(testValue1);
1820     }
1821 
1822     // type system test with abstract and inline type
1823     @ForceInline
1824     public MyAbstract test64Abstract_helper(MyValue1 vt) {
1825         return vt;
1826     }
1827 
1828     @Test()
1829     public MyAbstract test64Abstract(MyValue1 vt) {
1830         return test64Abstract_helper(vt);
1831     }
1832 
1833     @DontCompile
1834     public void test64Abstract_verifier(boolean warmup) {
1835         test64Abstract(testValue1);
1836     }
1837 
1838     // Array store tests
1839     @Test()
1840     public void test65(Object[] array, MyValue1 vt) {
1841         array[0] = vt;
1842     }
1843 
1844     @DontCompile
1845     public void test65_verifier(boolean warmup) {
1846         Object[] array = new Object[1];
1847         test65(array, testValue1);
1848         Asserts.assertEQ(((MyValue1)array[0]).hash(), testValue1.hash());
1849     }
1850 
1851     @Test()
1852     public void test66(Object[] array, MyValue1 vt) {
1853         array[0] = vt;
1854     }
1855 
1856     @DontCompile
1857     public void test66_verifier(boolean warmup) {
1858         MyValue1[] array = new MyValue1[1];
1859         test66(array, testValue1);
1860         Asserts.assertEQ(array[0].hash(), testValue1.hash());
1861     }
1862 
1863     @Test()
1864     public void test67(Object[] array, Object vt) {
1865         array[0] = vt;
1866     }
1867 
1868     @DontCompile
1869     public void test67_verifier(boolean warmup) {
1870         MyValue1[] array = new MyValue1[1];
1871         test67(array, testValue1);
1872         Asserts.assertEQ(array[0].hash(), testValue1.hash());
1873     }
1874 
1875     @Test()
1876     public void test68(Object[] array, Integer o) {
1877         array[0] = o;
1878     }
1879 
1880     @DontCompile
1881     public void test68_verifier(boolean warmup) {
1882         Integer[] array = new Integer[1];
1883         test68(array, 1);
1884         Asserts.assertEQ(array[0], Integer.valueOf(1));
1885     }
1886 
<a name="4" id="anc4"></a><span class="line-modified">1887     // Test convertion between an inline type and java.lang.Object without an allocation</span>
1888     @ForceInline
1889     public Object test69_sum(Object a, Object b) {
1890         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1891         return MyValue1.setX(((MyValue1)a), sum);
1892     }
1893 
1894     @Test(failOn = ALLOC + STORE)
1895     public int test69(MyValue1[] array) {
1896         MyValue1 result = MyValue1.createDefaultInline();
1897         for (int i = 0; i &lt; array.length; ++i) {
1898             result = (MyValue1)test69_sum(result, array[i]);
1899         }
1900         return result.x;
1901     }
1902 
1903     @DontCompile
1904     public void test69_verifier(boolean warmup) {
1905         int result = test69(testValue1Array);
1906         Asserts.assertEQ(result, rI * testValue1Array.length);
1907     }
1908 
1909     // Same as test69 but with an Interface
1910     @ForceInline
1911     public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {
1912         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1913         return MyValue1.setX(((MyValue1)a), sum);
1914     }
1915 
1916     @Test(failOn = ALLOC + STORE)
1917     public int test70Interface(MyValue1[] array) {
1918         MyValue1 result = MyValue1.createDefaultInline();
1919         for (int i = 0; i &lt; array.length; ++i) {
1920             result = (MyValue1)test70Interface_sum(result, array[i]);
1921         }
1922         return result.x;
1923     }
1924 
1925     @DontCompile
1926     public void test70Interface_verifier(boolean warmup) {
1927         int result = test70Interface(testValue1Array);
1928         Asserts.assertEQ(result, rI * testValue1Array.length);
1929     }
1930 
1931     // Same as test69 but with an Abstract
1932     @ForceInline
1933     public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {
1934         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1935         return MyValue1.setX(((MyValue1)a), sum);
1936     }
1937 
1938     @Test(failOn = ALLOC + STORE)
1939     public int test70Abstract(MyValue1[] array) {
1940         MyValue1 result = MyValue1.createDefaultInline();
1941         for (int i = 0; i &lt; array.length; ++i) {
1942             result = (MyValue1)test70Abstract_sum(result, array[i]);
1943         }
1944         return result.x;
1945     }
1946 
1947     @DontCompile
1948     public void test70Abstract_verifier(boolean warmup) {
1949         int result = test70Abstract(testValue1Array);
1950         Asserts.assertEQ(result, rI * testValue1Array.length);
1951     }
1952 
1953     // Test that allocated inline type is not used in non-dominated path
1954     public MyValue1 test71_inline(Object obj) {
1955         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1956         try {
1957             vt = (MyValue1)obj;
1958             throw new RuntimeException(&quot;NullPointerException expected&quot;);
1959         } catch (NullPointerException e) {
1960             // Expected
1961         }
1962         return vt;
1963     }
1964 
1965     @Test
1966     public MyValue1 test71() {
1967         return test71_inline(null);
1968     }
1969 
1970     @DontCompile
1971     public void test71_verifier(boolean warmup) {
1972         MyValue1 vt = test71();
1973         Asserts.assertEquals(vt.hash(), hash());
1974     }
1975 
1976     // Test calling a method on an uninitialized inline type
1977     final inline class Test72Value {
1978         final int x = 42;
1979         public int get() {
1980             return x;
1981         }
1982     }
1983 
1984     // Make sure Test72Value is loaded but not initialized
1985     public void unused(Test72Value vt) { }
1986 
1987     @Test
1988     @Warmup(0)
1989     public int test72() {
1990         Test72Value vt = Test72Value.default;
1991         return vt.get();
1992     }
1993 
1994     @DontCompile
1995     public void test72_verifier(boolean warmup) {
1996         int result = test72();
1997         Asserts.assertEquals(result, 0);
1998     }
1999 
2000     // Tests for loading/storing unkown values
2001     @Test
2002     public Object test73(Object[] va) {
2003         return va[0];
2004     }
2005 
2006     @DontCompile
2007     public void test73_verifier(boolean warmup) {
2008         MyValue1 vt = (MyValue1)test73(testValue1Array);
2009         Asserts.assertEquals(testValue1Array[0].hash(), vt.hash());
2010     }
2011 
2012     @Test
2013     public void test74(Object[] va, Object vt) {
2014         va[0] = vt;
2015     }
2016 
2017     @DontCompile
2018     public void test74_verifier(boolean warmup) {
2019         MyValue1[] va = new MyValue1[1];
2020         test74(va, testValue1);
2021         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2022     }
2023 
2024     // Verify that mixing instances and arrays with the clone api
2025     // doesn&#39;t break anything
2026     @Test
2027     public Object test75(Object o) {
2028         MyValue1[] va = new MyValue1[1];
2029         Object[] next = va;
2030         Object[] arr = va;
2031         for (int i = 0; i &lt; 10; i++) {
2032             arr = next;
2033             next = new Integer[1];
2034         }
2035         return arr[0];
2036     }
2037 
2038     @DontCompile
2039     public void test75_verifier(boolean warmup) {
2040         test75(42);
2041     }
2042 
2043     // Casting a null Integer to a (non-nullable) inline type should throw a NullPointerException
2044     @ForceInline
2045     public MyValue1 test76_helper(Object o) {
2046         return (MyValue1)o;
2047     }
2048 
2049     @Test
2050     public MyValue1 test76(Integer i) throws Throwable {
2051         return test76_helper(i);
2052     }
2053 
2054     @DontCompile
2055     public void test76_verifier(boolean warmup) throws Throwable {
2056         try {
2057             test76(null);
2058             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2059         } catch (NullPointerException e) {
2060             // Expected
2061         } catch (Exception e) {
2062             throw new RuntimeException(&quot;test76 failed: unexpected exception&quot;, e);
2063         }
2064     }
2065 
2066     // Casting an Integer to a (non-nullable) inline type should throw a ClassCastException
2067     @ForceInline
2068     public MyValue1 test77_helper(Object o) {
2069         return (MyValue1)o;
2070     }
2071 
2072     @Test
2073     public MyValue1 test77(Integer i) throws Throwable {
2074         return test77_helper(i);
2075     }
2076 
2077     @DontCompile
2078     public void test77_verifier(boolean warmup) throws Throwable {
2079         try {
2080             test77(new Integer(42));
2081             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2082         } catch (ClassCastException e) {
2083             // Expected
2084         } catch (Exception e) {
2085             throw new RuntimeException(&quot;test77 failed: unexpected exception&quot;, e);
2086         }
2087     }
2088 
2089     // Casting a null Integer to a nullable inline type should not throw
2090     @ForceInline
2091     public MyValue1.ref test78_helper(Object o) {
2092         return (MyValue1.ref)o;
2093     }
2094 
2095     @Test
2096     public MyValue1.ref test78(Integer i) throws Throwable {
2097         return test78_helper(i);
2098     }
2099 
2100     @DontCompile
2101     public void test78_verifier(boolean warmup) throws Throwable {
2102         try {
2103             test78(null); // Should not throw
2104         } catch (Exception e) {
2105             throw new RuntimeException(&quot;test78 failed: unexpected exception&quot;, e);
2106         }
2107     }
2108 
2109     // Casting an Integer to a nullable inline type should throw a ClassCastException
2110     @ForceInline
2111     public MyValue1.ref test79_helper(Object o) {
2112         return (MyValue1.ref)o;
2113     }
2114 
2115     @Test
2116     public MyValue1.ref test79(Integer i) throws Throwable {
2117         return test79_helper(i);
2118     }
2119 
2120     @DontCompile
2121     public void test79_verifier(boolean warmup) throws Throwable {
2122         try {
2123             test79(new Integer(42));
2124             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2125         } catch (ClassCastException e) {
2126             // Expected
2127         } catch (Exception e) {
2128             throw new RuntimeException(&quot;test79 failed: unexpected exception&quot;, e);
2129         }
2130     }
2131 
2132     // Test flattened field with non-flattenend (but flattenable) inline type field
2133     static inline class Small {
2134         final int i;
2135         final Big big; // Too big to be flattened
2136 
2137         private Small() {
2138             i = rI;
2139             big = new Big();
2140         }
2141     }
2142 
2143     static inline class Big {
2144         long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9;
2145         long l10,l11,l12,l13,l14,l15,l16,l17,l18,l19;
2146         long l20,l21,l22,l23,l24,l25,l26,l27,l28,l29;
2147 
2148         private Big() {
2149             l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = rL;
2150             l10 = l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = rL+1;
2151             l20 = l21 = l22 = l23 = l24 = l25 = l26 = l27 = l28 = l29 = rL+2;
2152         }
2153     }
2154 
2155     Small small = new Small();
2156     Small smallDefault;
2157     Big big = new Big();
2158     Big bigDefault;
2159 
2160     @Test
2161     public long test80() {
2162         return small.i + small.big.l0 + smallDefault.i + smallDefault.big.l29 + big.l0 + bigDefault.l29;
2163     }
2164 
2165     @DontCompile
2166     public void test80_verifier(boolean warmup) throws Throwable {
2167         long result = test80();
2168         Asserts.assertEQ(result, rI + 2*rL);
2169     }
2170 
2171     // Test scalarization with exceptional control flow
2172     public int test81Callee(MyValue1 vt)  {
2173         return vt.x;
2174     }
2175 
2176     @Test(failOn = ALLOC + LOAD + STORE)
2177     public int test81()  {
2178         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2179         int result = 0;
2180         for (int i = 0; i &lt; 10; i++) {
2181             try {
2182                 result += test81Callee(vt);
2183             } catch (NullPointerException npe) {
2184                 result += rI;
2185             }
2186         }
2187         return result;
2188     }
2189 
2190     @DontCompile
2191     public void test81_verifier(boolean warmup) {
2192         int result = test81();
2193         Asserts.assertEQ(result, 10*rI);
2194     }
2195 
2196     // Test check for null free array when storing to inline tpye array
2197     @Test
2198     public void test82(Object[] dst, Object v) {
2199         dst[0] = v;
2200     }
2201 
2202     @DontCompile
2203     public void test82_verifier(boolean warmup) {
2204         MyValue2[] dst = new MyValue2[1];
2205         test82(dst, testValue2);
2206         if (!warmup) {
2207             try {
2208                 test82(dst, null);
2209                 throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
2210             } catch (NullPointerException e) {
2211                 // Expected
2212             }
2213         }
2214     }
2215 
2216     @Test
2217     @Warmup(10000)
2218     public void test83(Object[] dst, Object v, boolean flag) {
2219         if (dst == null) { // null check
2220         }
2221         if (flag) {
2222             if (dst.getClass() == MyValue1[].class) { // trigger split if
2223             }
2224         } else {
2225             dst = new MyValue2[1]; // constant null free property
2226         }
2227         dst[0] = v;
2228     }
2229 
2230     @DontCompile
2231     public void test83_verifier(boolean warmup) {
2232         MyValue2[] dst = new MyValue2[1];
2233         test83(dst, testValue2, false);
2234         test83(dst, testValue2, true);
2235         if (!warmup) {
2236             try {
2237                 test83(dst, null, true);
2238                 throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
2239             } catch (NullPointerException e) {
2240                 // Expected
2241             }
2242         }
2243     }
2244 
2245     private void rerun_and_recompile_for(String name, int num, Runnable test) {
2246         Method m = tests.get(name);
2247 
2248         for (int i = 1; i &lt; num; i++) {
2249             test.run();
2250 
2251             if (!WHITE_BOX.isMethodCompiled(m, false)) {
2252                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
2253             }
2254         }
2255     }
2256 
2257     // Tests for the Loop Unswitching optimization
2258     // Should make 2 copies of the loop, one for non flattened arrays, one for other cases.
2259     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2260     @Warmup(0)
2261     public void test84(Object[] src, Object[] dst) {
2262         for (int i = 0; i &lt; src.length; i++) {
2263             dst[i] = src[i];
2264         }
2265     }
2266 
2267     @DontCompile
2268     public void test84_verifier(boolean warmup) {
2269         MyValue2[] src = new MyValue2[100];
2270         Arrays.fill(src, testValue2);
2271         MyValue2[] dst = new MyValue2[100];
2272         Method m = tests.get(&quot;TestLWorld::test84&quot;);
2273 
2274         rerun_and_recompile_for(&quot;TestLWorld::test84&quot;, 10,
2275                                 () -&gt;  { test84(src, dst);
2276                                          Asserts.assertTrue(Arrays.equals(src, dst)); });
2277     }
2278 
2279     @Test(valid = G1GCOn, match = { COUNTEDLOOP, LOAD_UNKNOWN_INLINE }, matchCount = { 2, 1 } )
2280     @Test(valid = G1GCOff, match = { COUNTEDLOOP_MAIN, LOAD_UNKNOWN_INLINE }, matchCount = { 2, 4 } )
2281     @Warmup(0)
2282     public void test85(Object[] src, Object[] dst) {
2283         for (int i = 0; i &lt; src.length; i++) {
2284             dst[i] = src[i];
2285         }
2286     }
2287 
2288     @DontCompile
2289     public void test85_verifier(boolean warmup) {
2290         Object[] src = new Object[100];
2291         Arrays.fill(src, new Object());
2292         src[0] = null;
2293         Object[] dst = new Object[100];
2294         rerun_and_recompile_for(&quot;TestLWorld::test85&quot;, 10,
2295                                 () -&gt; { test85(src, dst);
2296                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2297     }
2298 
2299     @Test(valid = G1GCOn, match = { COUNTEDLOOP }, matchCount = { 2 } )
2300     @Test(valid = G1GCOff, match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2301     @Warmup(0)
2302     public void test86(Object[] src, Object[] dst) {
2303         for (int i = 0; i &lt; src.length; i++) {
2304             dst[i] = src[i];
2305         }
2306     }
2307 
2308     @DontCompile
2309     public void test86_verifier(boolean warmup) {
2310         MyValue2[] src = new MyValue2[100];
2311         Arrays.fill(src, testValue2);
2312         Object[] dst = new Object[100];
2313         rerun_and_recompile_for(&quot;TestLWorld::test86&quot;, 10,
2314                                 () -&gt; { test86(src, dst);
2315                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2316     }
2317 
2318     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2319     @Warmup(0)
2320     public void test87(Object[] src, Object[] dst) {
2321         for (int i = 0; i &lt; src.length; i++) {
2322             dst[i] = src[i];
2323         }
2324     }
2325 
2326     @DontCompile
2327     public void test87_verifier(boolean warmup) {
2328         Object[] src = new Object[100];
2329         Arrays.fill(src, testValue2);
2330         MyValue2[] dst = new MyValue2[100];
2331 
2332         rerun_and_recompile_for(&quot;TestLWorld::test87&quot;, 10,
2333                                 () -&gt; { test87(src, dst);
2334                                         Asserts.assertTrue(Arrays.equals(src, dst)); });
2335     }
2336 
2337     @Test(match = { COUNTEDLOOP_MAIN }, matchCount = { 2 } )
2338     @Warmup(0)
2339     public void test88(Object[] src1, Object[] dst1, Object[] src2, Object[] dst2) {
2340         for (int i = 0; i &lt; src1.length; i++) {
2341             dst1[i] = src1[i];
2342             dst2[i] = src2[i];
2343         }
2344     }
2345 
2346     @DontCompile
2347     public void test88_verifier(boolean warmup) {
2348         MyValue2[] src1 = new MyValue2[100];
2349         Arrays.fill(src1, testValue2);
2350         MyValue2[] dst1 = new MyValue2[100];
2351         Object[] src2 = new Object[100];
2352         Arrays.fill(src2, new Object());
2353         Object[] dst2 = new Object[100];
2354 
2355         rerun_and_recompile_for(&quot;TestLWorld::test88&quot;, 10,
2356                                 () -&gt; { test88(src1, dst1, src2, dst2);
2357                                         Asserts.assertTrue(Arrays.equals(src1, dst1));
2358                                         Asserts.assertTrue(Arrays.equals(src2, dst2)); });
2359     }
2360 
2361     @Test
2362     public boolean test89(Object obj) {
2363         return obj.getClass() == Integer.class;
2364     }
2365 
2366     @DontCompile
2367     public void test89_verifier(boolean warmup) {
2368         Asserts.assertTrue(test89(new Integer(42)));
2369         Asserts.assertFalse(test89(new Object()));
2370     }
2371 
2372     @Test
2373     public Integer test90(Object obj) {
2374         return (Integer)obj;
2375     }
2376 
2377     @DontCompile
2378     public void test90_verifier(boolean warmup) {
2379         test90(new Integer(42));
2380         try {
2381             test90(new Object());
2382             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2383         } catch (ClassCastException e) {
2384             // Expected
2385         }
2386     }
2387 
2388     @Test
2389     public boolean test91(Object obj) {
2390         return obj.getClass() == MyValue2[].class;
2391     }
2392 
2393     @DontCompile
2394     public void test91_verifier(boolean warmup) {
2395         Asserts.assertTrue(test91(new MyValue2[1]));
2396         Asserts.assertFalse(test91(new Object()));
2397     }
2398 
2399     static inline class Test92Value {
2400         final int field;
2401         public Test92Value() {
2402             field = 0x42;
2403         }
2404     }
2405 
2406     @Warmup(10000)
2407     @Test(match = { CLASS_CHECK_TRAP }, matchCount = { 2 }, failOn = LOAD_UNKNOWN_INLINE + ALLOC_G + MEMBAR)
2408     public Object test92(Object[] array) {
2409         // Dummy loops to ensure we run enough passes of split if
2410         for (int i = 0; i &lt; 2; i++) {
2411             for (int j = 0; j &lt; 2; j++) {
2412               for (int k = 0; k &lt; 2; k++) {
2413               }
2414             }
2415         }
2416 
2417         return (Integer)array[0];
2418     }
2419 
2420     @DontCompile
2421     public void test92_verifier(boolean warmup) {
2422         Object[] array = new Object[1];
2423         array[0] = 0x42;
2424         Object result = test92(array);
2425         Asserts.assertEquals(result, 0x42);
2426     }
2427 
2428     // If the class check succeeds, the flattened array check that
2429     // precedes will never succeed and the flat array branch should
2430     // trigger an uncommon trap.
2431     @Test
2432     @Warmup(10000)
2433     public Object test93(Object[] array) {
2434         for (int i = 0; i &lt; 2; i++) {
2435             for (int j = 0; j &lt; 2; j++) {
2436             }
2437         }
2438 
2439         Object v = (Integer)array[0];
2440         return v;
2441     }
2442 
2443     @DontCompile
2444     public void test93_verifier(boolean warmup) {
2445         if (warmup) {
2446             Object[] array = new Object[1];
2447             array[0] = 0x42;
2448             Object result = test93(array);
2449             Asserts.assertEquals(result, 0x42);
2450         } else {
2451             Object[] array = new Test92Value[1];
2452             Method m = tests.get(&quot;TestLWorld::test93&quot;);
2453             int extra = 3;
2454             for (int j = 0; j &lt; extra; j++) {
2455                 for (int i = 0; i &lt; 10; i++) {
2456                     try {
2457                         test93(array);
2458                     } catch (ClassCastException cce) {
2459                     }
2460                 }
2461                 boolean compiled = isCompiledByC2(m);
2462                 Asserts.assertTrue(!USE_COMPILER || XCOMP || STRESS_CC || TEST_C1 || compiled || (j != extra-1));
2463                 if (!compiled) {
2464                     enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
2465                 }
2466             }
2467         }
2468     }
2469 
2470     @Warmup(10000)
2471     @Test(match = { CLASS_CHECK_TRAP, LOOP }, matchCount = { 2, 1 }, failOn = LOAD_UNKNOWN_INLINE + ALLOC_G + MEMBAR)
2472     public int test94(Object[] array) {
2473         int res = 0;
2474         for (int i = 1; i &lt; 4; i *= 2) {
2475             Object v = array[i];
2476             res += (Integer)v;
2477         }
2478         return res;
2479     }
2480 
2481     @DontCompile
2482     public void test94_verifier(boolean warmup) {
2483         Object[] array = new Object[4];
2484         array[0] = 0x42;
2485         array[1] = 0x42;
2486         array[2] = 0x42;
2487         array[3] = 0x42;
2488         int result = test94(array);
2489         Asserts.assertEquals(result, 0x42 * 2);
2490     }
2491 
2492     @Warmup(10000)
2493     @Test
2494     public boolean test95(Object o1, Object o2) {
2495         return o1 == o2;
2496     }
2497 
2498     @DontCompile
2499     public void test95_verifier(boolean warmup) {
2500         Object o1 = new Object();
2501         Object o2 = new Object();
2502         Asserts.assertTrue(test95(o1, o1));
2503         Asserts.assertTrue(test95(null, null));
2504         Asserts.assertFalse(test95(o1, null));
2505         Asserts.assertFalse(test95(o1, o2));
2506     }
2507 
2508     @Warmup(10000)
2509     @Test
2510     public boolean test96(Object o1, Object o2) {
2511         return o1 == o2;
2512     }
2513 
2514     @DontCompile
2515     public void test96_verifier(boolean warmup) {
2516         Object o1 = new Object();
2517         Object o2 = new Object();
2518         Asserts.assertTrue(test96(o1, o1));
2519         Asserts.assertFalse(test96(o1, o2));
2520         if (!warmup) {
2521             Asserts.assertTrue(test96(null, null));
2522             Asserts.assertFalse(test96(o1, null));
2523         }
2524     }
2525 
2526     // Abstract class tests
2527 
2528     @DontInline
2529     public MyAbstract test97_dontinline1(MyAbstract o) {
2530         return o;
2531     }
2532 
2533     @DontInline
2534     public MyValue1 test97_dontinline2(MyAbstract o) {
2535         return (MyValue1)o;
2536     }
2537 
2538     @ForceInline
2539     public MyAbstract test97_inline1(MyAbstract o) {
2540         return o;
2541     }
2542 
2543     @ForceInline
2544     public MyValue1 test97_inline2(MyAbstract o) {
2545         return (MyValue1)o;
2546     }
2547 
2548     @Test()
2549     public MyValue1 test97() {
2550         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2551         vt = (MyValue1)test97_dontinline1(vt);
2552         vt =           test97_dontinline2(vt);
2553         vt = (MyValue1)test97_inline1(vt);
2554         vt =           test97_inline2(vt);
2555         return vt;
2556     }
2557 
2558     @DontCompile
2559     public void test97_verifier(boolean warmup) {
2560         Asserts.assertEQ(test97().hash(), hash());
2561     }
2562 
2563     // Test storing/loading inline types to/from abstract and inline type fields
2564     MyAbstract abstractField1 = null;
2565     MyAbstract abstractField2 = null;
2566     MyAbstract abstractField3 = null;
2567     MyAbstract abstractField4 = null;
2568     MyAbstract abstractField5 = null;
2569     MyAbstract abstractField6 = null;
2570 
2571     @DontInline
2572     public MyAbstract readValueField5AsAbstract() {
2573         return (MyAbstract)valueField5;
2574     }
2575 
2576     @DontInline
2577     public MyAbstract readStaticValueField4AsAbstract() {
2578         return (MyAbstract)staticValueField4;
2579     }
2580 
2581     @Test()
2582     public long test98(MyValue1 vt1, MyAbstract vt2) {
2583         abstractField1 = vt1;
2584         abstractField2 = (MyValue1)vt2;
2585         abstractField3 = MyValue1.createWithFieldsInline(rI, rL);
2586         abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);
2587         abstractField5 = valueField1;
2588         abstractField6 = valueField3;
2589         valueField1 = (MyValue1)abstractField1;
2590         valueField2 = (MyValue1)vt2;
2591         valueField3 = (MyValue1)vt2;
2592         staticValueField1 = (MyValue1)abstractField1;
2593         staticValueField2 = (MyValue1)vt1;
2594         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
2595         if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {
2596             throw new RuntimeException(&quot;Should be null&quot;);
2597         }
2598         return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +
2599                ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +
2600                ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +
2601                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
2602                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
2603     }
2604 
2605     @DontCompile
2606     public void test98_verifier(boolean warmup) {
2607         MyValue1 vt = testValue1;
2608         MyValue1 def = MyValue1.createDefaultDontInline();
2609         long result = test98(vt, vt);
2610         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
2611     }
2612 
2613     class MyObject2 extends MyAbstract {
2614         public int x;
2615 
2616         public MyObject2(int x) {
2617             this.x = x;
2618         }
2619 
2620         @ForceInline
2621         public long hash() {
2622             return x;
2623         }
2624     }
2625 
2626     // Test merging inline types and abstract classes
2627     @Test()
2628     public MyAbstract test99(int state) {
2629         MyAbstract res = null;
2630         if (state == 0) {
2631             res = new MyObject2(rI);
2632         } else if (state == 1) {
2633             res = MyValue1.createWithFieldsInline(rI, rL);
2634         } else if (state == 2) {
2635             res = MyValue1.createWithFieldsDontInline(rI, rL);
2636         } else if (state == 3) {
2637             res = (MyValue1)objectField1;
2638         } else if (state == 4) {
2639             res = valueField1;
2640         } else if (state == 5) {
2641             res = null;
2642         }
2643         return res;
2644     }
2645 
2646     @DontCompile
2647     public void test99_verifier(boolean warmup) {
2648         objectField1 = valueField1;
2649         MyAbstract result = null;
2650         result = test99(0);
2651         Asserts.assertEQ(((MyObject2)result).x, rI);
2652         result = test99(1);
2653         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2654         result = test99(2);
2655         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2656         result = test99(3);
2657         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2658         result = test99(4);
2659         Asserts.assertEQ(((MyValue1)result).hash(), hash());
2660         result = test99(5);
2661         Asserts.assertEQ(result, null);
2662     }
2663 
2664     // Test merging inline types and abstract classes in loops
2665     @Test()
2666     public MyAbstract test100(int iters) {
2667         MyAbstract res = new MyObject2(rI);
2668         for (int i = 0; i &lt; iters; ++i) {
2669             if (res instanceof MyObject2) {
2670                 res = MyValue1.createWithFieldsInline(rI, rL);
2671             } else {
2672                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
2673             }
2674         }
2675         return res;
2676     }
2677 
2678     @DontCompile
2679     public void test100_verifier(boolean warmup) {
2680         MyObject2 result1 = (MyObject2)test100(0);
2681         Asserts.assertEQ(result1.x, rI);
2682         int iters = (Math.abs(rI) % 10) + 1;
2683         MyValue1 result2 = (MyValue1)test100(iters);
2684         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
2685         Asserts.assertEQ(result2.hash(), vt.hash());
2686     }
2687 
2688     // Test inline types in abstract class variables that are live at safepoint
2689     @Test(failOn = ALLOC + STORE + LOOP)
2690     public long test101(MyValue1 arg, boolean deopt) {
2691         MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);
2692         MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
2693         MyAbstract vt3 = arg;
2694         MyAbstract vt4 = valueField1;
2695         if (deopt) {
2696             // uncommon trap
2697             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test101&quot;));
2698         }
2699         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
2700                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
2701     }
2702 
2703     @DontCompile
2704     public void test101_verifier(boolean warmup) {
2705         long result = test101(valueField1, !warmup);
2706         Asserts.assertEQ(result, 4*hash());
2707     }
2708 
2709     // Test comparing inline types with abstract classes
2710     @Test(failOn = LOAD + LOOP)
2711     public boolean test102(Object arg) {
2712         MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);
2713         if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||
2714             arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {
2715             return true;
2716         }
2717         return false;
2718     }
2719 
2720     @DontCompile
2721     public void test102_verifier(boolean warmup) {
2722         boolean result = test102(null);
2723         Asserts.assertFalse(result);
2724     }
2725 
<a name="5" id="anc5"></a><span class="line-modified">2726     // An abstract class with a non-static field can never be implemented by an inline type</span>
2727     abstract class NoValueImplementors1 {
2728         int field = 42;
2729     }
2730 
2731     class MyObject3 extends NoValueImplementors1 {
2732 
2733     }
2734 
2735     class MyObject4 extends NoValueImplementors1 {
2736 
2737     }
2738 
2739     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field
2740     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2741     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {
2742         return array[i];
2743     }
2744 
2745     @DontCompile
2746     public void test103_verifier(boolean warmup) {
2747         NoValueImplementors1[] array1 = new NoValueImplementors1[3];
2748         MyObject3[] array2 = new MyObject3[3];
2749         MyObject4[] array3 = new MyObject4[3];
2750         NoValueImplementors1 result = test103(array1, 0);
2751         Asserts.assertEquals(result, array1[0]);
2752 
2753         result = test103(array2, 1);
2754         Asserts.assertEquals(result, array1[1]);
2755 
2756         result = test103(array3, 2);
2757         Asserts.assertEquals(result, array1[2]);
2758     }
2759 
2760     // Storing to an abstract class array does not require a flatness/null check if the abstract class has a non-static field
2761     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2762     public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {
2763         array[0] = v;
2764         array[1] = array[0];
2765         array[2] = o;
2766         return array[i];
2767     }
2768 
2769     @DontCompile
2770     public void test104_verifier(boolean warmup) {
2771         MyObject4 v = new MyObject4();
2772         MyObject3 o = new MyObject3();
2773         NoValueImplementors1[] array1 = new NoValueImplementors1[3];
2774         MyObject3[] array2 = new MyObject3[3];
2775         MyObject4[] array3 = new MyObject4[3];
2776         NoValueImplementors1 result = test104(array1, v, o, 0);
2777         Asserts.assertEquals(array1[0], v);
2778         Asserts.assertEquals(array1[1], v);
2779         Asserts.assertEquals(array1[2], o);
2780         Asserts.assertEquals(result, v);
2781 
2782         result = test104(array2, o, o, 1);
2783         Asserts.assertEquals(array2[0], o);
2784         Asserts.assertEquals(array2[1], o);
2785         Asserts.assertEquals(array2[2], o);
2786         Asserts.assertEquals(result, o);
2787 
2788         result = test104(array3, v, null, 1);
2789         Asserts.assertEquals(array3[0], v);
2790         Asserts.assertEquals(array3[1], v);
2791         Asserts.assertEquals(array3[2], null);
2792         Asserts.assertEquals(result, v);
2793     }
2794 
2795     // An abstract class with a single, non-inline implementor
2796     abstract class NoValueImplementors2 {
2797 
2798     }
2799 
2800     class MyObject5 extends NoValueImplementors2 {
2801 
2802     }
2803 
2804     // Loading from an abstract class array does not require a flatness check if the abstract class has no inline implementor
2805     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2806     public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {
2807         return array[i];
2808     }
2809 
2810     @DontCompile
2811     public void test105_verifier(boolean warmup) {
2812         NoValueImplementors2[] array1 = new NoValueImplementors2[3];
2813         MyObject5[] array2 = new MyObject5[3];
2814         NoValueImplementors2 result = test105(array1, 0);
2815         Asserts.assertEquals(result, array1[0]);
2816 
2817         result = test105(array2, 1);
2818         Asserts.assertEquals(result, array1[1]);
2819     }
2820 
2821     // Storing to an abstract class array does not require a flatness/null check if the abstract class has no inline implementor
2822     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2823     public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {
2824         array[0] = v;
2825         array[1] = array[0];
2826         array[2] = o;
2827         return array[i];
2828     }
2829 
2830     @DontCompile
2831     public void test106_verifier(boolean warmup) {
2832         MyObject5 v = new MyObject5();
2833         NoValueImplementors2[] array1 = new NoValueImplementors2[3];
2834         MyObject5[] array2 = new MyObject5[3];
2835         NoValueImplementors2 result = test106(array1, v, null, 0);
2836         Asserts.assertEquals(array1[0], v);
2837         Asserts.assertEquals(array1[1], v);
2838         Asserts.assertEquals(array1[2], null);
2839         Asserts.assertEquals(result, v);
2840 
2841         result = test106(array2, v, v, 1);
2842         Asserts.assertEquals(array2[0], v);
2843         Asserts.assertEquals(array2[1], v);
2844         Asserts.assertEquals(array2[2], v);
2845         Asserts.assertEquals(result, v);
2846     }
2847 
2848     // More tests for the Loop Unswitching optimization (similar to test84 and following)
2849     Object oFld1, oFld2;
2850 
2851     @Test(valid = G1GCOn, failOn = STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, LOAD_UNKNOWN_INLINE }, matchCount = { 2, 2 } )
2852     @Test(valid = G1GCOff, failOn = STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, LOAD_UNKNOWN_INLINE }, matchCount = { 3, 2 } )
2853     @Warmup(0)
2854     public void test107(Object[] src1, Object[] src2) {
2855         for (int i = 0; i &lt; src1.length; i++) {
2856             oFld1 = src1[i];
2857             oFld2 = src2[i];
2858         }
2859     }
2860 
2861     @DontCompile
2862     public void test107_verifier(boolean warmup) {
2863         MyValue2[] src1 = new MyValue2[100];
2864         Arrays.fill(src1, testValue2);
2865         Object[] src2 = new Object[100];
2866         Object obj = new Object();
2867         Arrays.fill(src2, obj);
2868         rerun_and_recompile_for(&quot;TestLWorld::test107&quot;, 10,
2869                                 () -&gt; { test107(src1, src2);
2870                                         Asserts.assertEquals(oFld1, testValue2);
2871                                         Asserts.assertEquals(oFld2, obj);
2872                                         test107(src2, src1);
2873                                         Asserts.assertEquals(oFld1, obj);
2874                                         Asserts.assertEquals(oFld2, testValue2);  });
2875     }
2876 
2877     @Test(valid = G1GCOn, failOn = LOAD_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, STORE_UNKNOWN_INLINE }, matchCount = { 4, 9 } )
2878     @Test(valid = G1GCOff, failOn = LOAD_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD, match = { COUNTEDLOOP, STORE_UNKNOWN_INLINE }, matchCount = { 4, 12 } )
2879     @Warmup(0)
2880     public void test108(Object[] dst1, Object[] dst2, Object o1, Object o2) {
2881         for (int i = 0; i &lt; dst1.length; i++) {
2882             dst1[i] = o1;
2883             dst2[i] = o2;
2884         }
2885     }
2886 
2887     @DontCompile
2888     public void test108_verifier(boolean warmup) {
2889         MyValue2[] dst1 = new MyValue2[100];
2890         Object[] dst2 = new Object[100];
2891         Object o1 = new Object();
2892         rerun_and_recompile_for(&quot;TestLWorld::test108&quot;, 10,
2893                                 () -&gt; { test108(dst1, dst2, testValue2, o1);
2894                                         for (int i = 0; i &lt; dst1.length; i++) {
2895                                             Asserts.assertEquals(dst1[i], testValue2);
2896                                             Asserts.assertEquals(dst2[i], o1);
2897                                         }
2898                                         test108(dst2, dst1, o1, testValue2);
2899                                         for (int i = 0; i &lt; dst1.length; i++) {
2900                                             Asserts.assertEquals(dst1[i], testValue2);
2901                                             Asserts.assertEquals(dst2[i], o1);
2902                                         } });
2903     }
2904 
2905     // Escape analysis tests
2906 
2907     static interface WrapperInterface {
2908         long value();
2909 
2910         final static WrapperInterface ZERO = new LongWrapper(0);
2911 
2912         static WrapperInterface wrap(long val) {
2913             return (val == 0L) ? ZERO : new LongWrapper(val);
2914         }
2915     }
2916 
2917     static inline class LongWrapper implements WrapperInterface {
2918         final static LongWrapper ZERO = new LongWrapper(0);
2919         private long val;
2920 
2921         LongWrapper(long val) {
2922             this.val = val;
2923         }
2924 
2925         static LongWrapper wrap(long val) {
2926             return (val == 0L) ? ZERO : new LongWrapper(val);
2927         }
2928 
2929         public long value() {
2930             return val;
2931         }
2932     }
2933 
2934     static class InterfaceBox {
2935         WrapperInterface content;
2936 
2937         InterfaceBox(WrapperInterface content) {
2938             this.content = content;
2939         }
2940 
2941         static InterfaceBox box_sharp(long val) {
2942             return new InterfaceBox(LongWrapper.wrap(val));
2943         }
2944 
2945         static InterfaceBox box(long val) {
2946             return new InterfaceBox(WrapperInterface.wrap(val));
2947         }
2948     }
2949 
2950     static class ObjectBox {
2951         Object content;
2952 
2953         ObjectBox(Object content) {
2954             this.content = content;
2955         }
2956 
2957         static ObjectBox box_sharp(long val) {
2958             return new ObjectBox(LongWrapper.wrap(val));
2959         }
2960 
2961         static ObjectBox box(long val) {
2962             return new ObjectBox(WrapperInterface.wrap(val));
2963         }
2964     }
2965 
2966     static class RefBox {
2967         LongWrapper.ref content;
2968 
2969         RefBox(LongWrapper.ref content) {
2970             this.content = content;
2971         }
2972 
2973         static RefBox box_sharp(long val) {
2974             return new RefBox(LongWrapper.wrap(val));
2975         }
2976 
2977         static RefBox box(long val) {
2978             return new RefBox((LongWrapper.ref)WrapperInterface.wrap(val));
2979         }
2980     }
2981 
2982     static class InlineBox {
2983         LongWrapper content;
2984 
2985         InlineBox(long val) {
2986             this.content = LongWrapper.wrap(val);
2987         }
2988 
2989         static InlineBox box(long val) {
2990             return new InlineBox(val);
2991         }
2992     }
2993 
2994     static class GenericBox&lt;T&gt; {
2995         T content;
2996 
2997         static GenericBox&lt;LongWrapper.ref&gt; box_sharp(long val) {
2998             GenericBox&lt;LongWrapper.ref&gt; res = new GenericBox&lt;&gt;();
2999             res.content = LongWrapper.wrap(val);
3000             return res;
3001         }
3002 
3003         static GenericBox&lt;WrapperInterface&gt; box(long val) {
3004             GenericBox&lt;WrapperInterface&gt; res = new GenericBox&lt;&gt;();
3005             res.content = WrapperInterface.wrap(val);
3006             return res;
3007         }
3008     }
3009 
3010     long[] lArr = {0L, rL, 0L, rL, 0L, rL, 0L, rL, 0L, rL};
3011 
3012     // Test removal of allocations when inline type instance is wrapped into box object
3013     @Warmup(10000) // Make sure interface calls are inlined
3014     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3015     public long test109() {
3016         long res = 0;
3017         for (int i = 0 ; i &lt; lArr.length; i++) {
3018             res += InterfaceBox.box(lArr[i]).content.value();
3019         }
3020         return res;
3021     }
3022 
3023     @DontCompile
3024     public void test109_verifier(boolean warmup) {
3025         long res = test109();
3026         Asserts.assertEquals(res, 5*rL);
3027     }
3028 
3029     @Warmup(10000) // Make sure interface calls are inlined
3030     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3031     public long test109_sharp() {
3032         long res = 0;
3033         for (int i = 0 ; i &lt; lArr.length; i++) {
3034             res += InterfaceBox.box_sharp(lArr[i]).content.value();
3035         }
3036         return res;
3037     }
3038 
3039     @DontCompile
3040     public void test109_sharp_verifier(boolean warmup) {
3041         long res = test109_sharp();
3042         Asserts.assertEquals(res, 5*rL);
3043     }
3044 
3045     // Same as test109 but with ObjectBox
3046     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3047     @Warmup(10000) // Make sure interface calls are inlined
3048     public long test110() {
3049         long res = 0;
3050         for (int i = 0 ; i &lt; lArr.length; i++) {
3051             res += ((WrapperInterface)ObjectBox.box(lArr[i]).content).value();
3052         }
3053         return res;
3054     }
3055 
3056     @DontCompile
3057     public void test110_verifier(boolean warmup) {
3058         long res = test110();
3059         Asserts.assertEquals(res, 5*rL);
3060     }
3061 
3062     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3063     @Warmup(10000) // Make sure interface calls are inlined
3064     public long test110_sharp() {
3065         long res = 0;
3066         for (int i = 0 ; i &lt; lArr.length; i++) {
3067             res += ((WrapperInterface)ObjectBox.box_sharp(lArr[i]).content).value();
3068         }
3069         return res;
3070     }
3071 
3072     @DontCompile
3073     public void test110_sharp_verifier(boolean warmup) {
3074         long res = test110_sharp();
3075         Asserts.assertEquals(res, 5*rL);
3076     }
3077 
3078     // Same as test109 but with RefBox
3079     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3080     public long test111() {
3081         long res = 0;
3082         for (int i = 0 ; i &lt; lArr.length; i++) {
3083             res += RefBox.box(lArr[i]).content.value();
3084         }
3085         return res;
3086     }
3087 
3088     @DontCompile
3089     public void test111_verifier(boolean warmup) {
3090         long res = test111();
3091         Asserts.assertEquals(res, 5*rL);
3092     }
3093 
3094     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3095     public long test111_sharp() {
3096         long res = 0;
3097         for (int i = 0 ; i &lt; lArr.length; i++) {
3098             res += RefBox.box_sharp(lArr[i]).content.value();
3099         }
3100         return res;
3101     }
3102 
3103     @DontCompile
3104     public void test111_sharp_verifier(boolean warmup) {
3105         long res = test111_sharp();
3106         Asserts.assertEquals(res, 5*rL);
3107     }
3108 
3109     // Same as test109 but with InlineBox
3110     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3111     public long test112() {
3112         long res = 0;
3113         for (int i = 0 ; i &lt; lArr.length; i++) {
3114             res += InlineBox.box(lArr[i]).content.value();
3115         }
3116         return res;
3117     }
3118 
3119     @DontCompile
3120     public void test112_verifier(boolean warmup) {
3121         long res = test112();
3122         Asserts.assertEquals(res, 5*rL);
3123     }
3124 
3125     // Same as test109 but with GenericBox
3126     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3127     @Warmup(10000) // Make sure interface calls are inlined
3128     public long test113() {
3129         long res = 0;
3130         for (int i = 0 ; i &lt; lArr.length; i++) {
3131             res += GenericBox.box(lArr[i]).content.value();
3132         }
3133         return res;
3134     }
3135 
3136     @DontCompile
3137     public void test113_verifier(boolean warmup) {
3138         long res = test113();
3139         Asserts.assertEquals(res, 5*rL);
3140     }
3141 
3142     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3143     @Warmup(10000) // Make sure interface calls are inlined
3144     public long test113_sharp() {
3145         long res = 0;
3146         for (int i = 0 ; i &lt; lArr.length; i++) {
3147             res += GenericBox.box_sharp(lArr[i]).content.value();
3148         }
3149         return res;
3150     }
3151 
3152     @DontCompile
3153     public void test113_sharp_verifier(boolean warmup) {
3154         long res = test113_sharp();
3155         Asserts.assertEquals(res, 5*rL);
3156     }
3157 
3158     static interface WrapperInterface2 {
3159         public long value();
3160 
3161         static final InlineWrapper.ref ZERO = new InlineWrapper(0);
3162 
3163         public static WrapperInterface2 wrap(long val) {
3164             return (val == 0) ? ZERO.content : new LongWrapper2(val);
3165         }
3166 
3167         public static WrapperInterface2 wrap_default(long val) {
3168             return (val == 0) ? LongWrapper2.default : new LongWrapper2(val);
3169         }
3170     }
3171 
3172     static inline class LongWrapper2 implements WrapperInterface2 {
3173         private long val;
3174 
3175         public LongWrapper2(long val) {
3176             this.val = val;
3177         }
3178 
3179         public long value() {
3180             return val;
3181         }
3182     }
3183 
3184     static inline class InlineWrapper {
3185         WrapperInterface2 content;
3186 
3187         public InlineWrapper(long val) {
3188             content = new LongWrapper2(val);
3189         }
3190     }
3191 
3192     static class InterfaceBox2 {
3193         WrapperInterface2 content;
3194 
3195         public InterfaceBox2(long val, boolean def) {
3196             this.content = def ? WrapperInterface2.wrap_default(val) : WrapperInterface2.wrap(val);
3197         }
3198 
3199         static InterfaceBox2 box(long val) {
3200             return new InterfaceBox2(val, false);
3201         }
3202 
3203         static InterfaceBox2 box_default(long val) {
3204             return new InterfaceBox2(val, true);
3205         }
3206     }
3207 
3208     // Same as tests above but with ZERO hidden in field of another inline type
3209     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3210     @Warmup(10000)
3211     public long test114() {
3212         long res = 0;
3213         for (int i = 0; i &lt; lArr.length; i++) {
3214             res += InterfaceBox2.box(lArr[i]).content.value();
3215         }
3216         return res;
3217     }
3218 
3219     @DontCompile
3220     public void test114_verifier(boolean warmup) {
3221         long res = test114();
3222         Asserts.assertEquals(res, 5*rL);
3223     }
3224 
3225     // Same as test114 but with .default instead of ZERO field
3226     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })
3227     @Warmup(10000)
3228     public long test115() {
3229         long res = 0;
3230         for (int i = 0; i &lt; lArr.length; i++) {
3231             res += InterfaceBox2.box_default(lArr[i]).content.value();
3232         }
3233         return res;
3234     }
3235 
3236     @DontCompile
3237     public void test115_verifier(boolean warmup) {
3238         long res = test115();
3239         Asserts.assertEquals(res, 5*rL);
3240     }
3241 
3242     static MyValueEmpty     fEmpty1;
3243     static MyValueEmpty.ref fEmpty2 = MyValueEmpty.default;
3244            MyValueEmpty     fEmpty3;
3245            MyValueEmpty.ref fEmpty4 = MyValueEmpty.default;
3246 
3247     // Test fields loads/stores with empty inline types
3248     @Test(failOn = ALLOC + ALLOC_G + LOAD + STORE + TRAP)
3249     public void test116() {
3250         fEmpty1 = fEmpty4;
3251         fEmpty2 = fEmpty1;
3252         fEmpty3 = fEmpty2;
3253         fEmpty4 = fEmpty3;
3254     }
3255 
3256     @DontCompile
3257     public void test116_verifier(boolean warmup) {
3258         test116();
3259         Asserts.assertEquals(fEmpty1, fEmpty2);
3260         Asserts.assertEquals(fEmpty2, fEmpty3);
3261         Asserts.assertEquals(fEmpty3, fEmpty4);
3262     }
3263 
3264     // Test array loads/stores with empty inline types
3265     @Test(failOn = ALLOC + ALLOC_G)
3266     public MyValueEmpty test117(MyValueEmpty[] arr1, MyValueEmpty.ref[] arr2) {
3267         arr1[0] = arr2[0];
3268         arr2[0] = new MyValueEmpty();
3269         return arr1[0];
3270     }
3271 
3272     @DontCompile
3273     public void test117_verifier(boolean warmup) {
3274         MyValueEmpty[] arr1 = new MyValueEmpty[]{MyValueEmpty.default};
3275         MyValueEmpty res = test117(arr1, arr1);
3276         Asserts.assertEquals(res, MyValueEmpty.default);
3277         Asserts.assertEquals(arr1[0], MyValueEmpty.default);
3278     }
3279 
3280     // Test acmp with empty inline types
3281     @Test(failOn = ALLOC + ALLOC_G)
3282     public boolean test118(MyValueEmpty v1, MyValueEmpty.ref v2, Object o1) {
3283         return (v1 == v2) &amp;&amp; (v2 == o1);
3284     }
3285 
3286     @DontCompile
3287     public void test118_verifier(boolean warmup) {
3288         boolean res = test118(MyValueEmpty.default, MyValueEmpty.default, new MyValueEmpty());
3289         Asserts.assertTrue(res);
3290     }
3291 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
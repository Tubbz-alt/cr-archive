<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestJNICalls.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestNullableArrays.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  54         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  55         }
  56         return null;
  57     }
  58 
  59     public static void main(String[] args) throws Throwable {
  60         TestLWorld test = new TestLWorld();
  61         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class,
  62                  MyValue3Inline.class, Test51Value.class);
  63     }
  64 
  65     // Helper methods
  66 
  67     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  68     private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, true);
  69 
  70     protected long hash() {
  71         return testValue1.hash();
  72     }
  73 
<span class="line-modified">  74     // Test passing a inline type as an Object</span>
  75     @DontInline
  76     public Object test1_dontinline1(Object o) {
  77         return o;
  78     }
  79 
  80     @DontInline
  81     public MyValue1 test1_dontinline2(Object o) {
  82         return (MyValue1)o;
  83     }
  84 
  85     @ForceInline
  86     public Object test1_inline1(Object o) {
  87         return o;
  88     }
  89 
  90     @ForceInline
  91     public MyValue1 test1_inline2(Object o) {
  92         return (MyValue1)o;
  93     }
  94 
</pre>
<hr />
<pre>
1058             return_();
1059         });
1060 
1061     @Test()
1062     public void test35(MyValue1[] va, int index) throws Throwable {
1063         setArrayElementNull.invoke(this, va, index);
1064     }
1065 
1066     @DontCompile
1067     public void test35_verifier(boolean warmup) throws Throwable {
1068         int index = Math.abs(rI) % 3;
1069         try {
1070             test35(testValue1Array, index);
1071             throw new RuntimeException(&quot;No NPE thrown&quot;);
1072         } catch (NullPointerException e) {
1073             // Expected
1074         }
1075         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1076     }
1077 
<span class="line-modified">1078     // Test writing a inline type to a null inline type array</span>
1079     @Test()
1080     public void test36(MyValue1[] va, MyValue1 vt, int index) {
1081         va[index] = vt;
1082     }
1083 
1084     @DontCompile
1085     public void test36_verifier(boolean warmup) {
1086         int index = Math.abs(rI) % 3;
1087         try {
1088             test36(null, testValue1Array[index], index);
1089             throw new RuntimeException(&quot;No NPE thrown&quot;);
1090         } catch (NullPointerException e) {
1091             // Expected
1092         }
1093     }
1094 
1095     // Test incremental inlining
1096     @ForceInline
1097     public void test37_inline(Object[] oa, Object o, int index) {
1098         oa[index] = o;
</pre>
<hr />
<pre>
1548             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1549                                      (MyValue1)holder.objectField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1550             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1551                                      holder.valueField1, (MyValue1)vt2, holder.valueField3, holder.valueField4, holder.valueField5);
1552             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1553                                      holder.valueField1, holder.valueField2, (MyValue1)vt2, holder.valueField4, holder.valueField5);
1554 
1555             return ((MyValue1)holder.objectField1).hash() +
1556                    ((MyValue1)holder.objectField2).hash() +
1557                    ((MyValue1)holder.objectField3).hash() +
1558                    ((MyValue1)holder.objectField4).hash() +
1559                    ((MyValue1)holder.objectField5).hash() +
1560                    ((MyValue1)holder.objectField6).hash() +
1561                    holder.valueField1.hash() +
1562                    holder.valueField2.hash() +
1563                    holder.valueField3.hash() +
1564                    holder.valueField4.hashPrimitive();
1565         }
1566     }
1567 
<span class="line-modified">1568     // Same as test2 but with field holder being a inline type</span>
1569     @Test()
1570     public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {
1571         return holder.test(holder, vt1, vt2);
1572     }
1573 
1574     @DontCompile
1575     public void test51_verifier(boolean warmup) {
1576         MyValue1 vt = testValue1;
1577         MyValue1 def = MyValue1.createDefaultDontInline();
1578         Test51Value holder = new Test51Value();
1579         Asserts.assertEQ(testValue1.hash(), vt.hash());
1580         Asserts.assertEQ(holder.valueField1.hash(), vt.hash());
1581         long result = test51(holder, vt, vt);
1582         Asserts.assertEQ(result, 9*vt.hash() + def.hashPrimitive());
1583     }
1584 
1585     // Access non-flattened, uninitialized inline type field with inline type holder
1586     @Test()
1587     public void test52(Test51Value holder) {
1588         if ((Object)holder.valueField5 != null) {
</pre>
<hr />
<pre>
1867 
1868     @DontCompile
1869     public void test67_verifier(boolean warmup) {
1870         MyValue1[] array = new MyValue1[1];
1871         test67(array, testValue1);
1872         Asserts.assertEQ(array[0].hash(), testValue1.hash());
1873     }
1874 
1875     @Test()
1876     public void test68(Object[] array, Integer o) {
1877         array[0] = o;
1878     }
1879 
1880     @DontCompile
1881     public void test68_verifier(boolean warmup) {
1882         Integer[] array = new Integer[1];
1883         test68(array, 1);
1884         Asserts.assertEQ(array[0], Integer.valueOf(1));
1885     }
1886 
<span class="line-modified">1887     // Test convertion between a inline type and java.lang.Object without an allocation</span>
1888     @ForceInline
1889     public Object test69_sum(Object a, Object b) {
1890         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1891         return MyValue1.setX(((MyValue1)a), sum);
1892     }
1893 
1894     @Test(failOn = ALLOC + STORE)
1895     public int test69(MyValue1[] array) {
1896         MyValue1 result = MyValue1.createDefaultInline();
1897         for (int i = 0; i &lt; array.length; ++i) {
1898             result = (MyValue1)test69_sum(result, array[i]);
1899         }
1900         return result.x;
1901     }
1902 
1903     @DontCompile
1904     public void test69_verifier(boolean warmup) {
1905         int result = test69(testValue1Array);
1906         Asserts.assertEQ(result, rI * testValue1Array.length);
1907     }
</pre>
<hr />
<pre>
2706         Asserts.assertEQ(result, 4*hash());
2707     }
2708 
2709     // Test comparing inline types with abstract classes
2710     @Test(failOn = LOAD + LOOP)
2711     public boolean test102(Object arg) {
2712         MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);
2713         if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||
2714             arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {
2715             return true;
2716         }
2717         return false;
2718     }
2719 
2720     @DontCompile
2721     public void test102_verifier(boolean warmup) {
2722         boolean result = test102(null);
2723         Asserts.assertFalse(result);
2724     }
2725 
<span class="line-modified">2726     // An abstract class with a non-static field can never be implemented by a inline type</span>
2727     abstract class NoValueImplementors1 {
2728         int field = 42;
2729     }
2730 
2731     class MyObject3 extends NoValueImplementors1 {
2732 
2733     }
2734 
2735     class MyObject4 extends NoValueImplementors1 {
2736 
2737     }
2738 
2739     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field
2740     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2741     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {
2742         return array[i];
2743     }
2744 
2745     @DontCompile
2746     public void test103_verifier(boolean warmup) {
</pre>
</td>
<td>
<hr />
<pre>
  54         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  55         }
  56         return null;
  57     }
  58 
  59     public static void main(String[] args) throws Throwable {
  60         TestLWorld test = new TestLWorld();
  61         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class,
  62                  MyValue3Inline.class, Test51Value.class);
  63     }
  64 
  65     // Helper methods
  66 
  67     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  68     private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, true);
  69 
  70     protected long hash() {
  71         return testValue1.hash();
  72     }
  73 
<span class="line-modified">  74     // Test passing an inline type as an Object</span>
  75     @DontInline
  76     public Object test1_dontinline1(Object o) {
  77         return o;
  78     }
  79 
  80     @DontInline
  81     public MyValue1 test1_dontinline2(Object o) {
  82         return (MyValue1)o;
  83     }
  84 
  85     @ForceInline
  86     public Object test1_inline1(Object o) {
  87         return o;
  88     }
  89 
  90     @ForceInline
  91     public MyValue1 test1_inline2(Object o) {
  92         return (MyValue1)o;
  93     }
  94 
</pre>
<hr />
<pre>
1058             return_();
1059         });
1060 
1061     @Test()
1062     public void test35(MyValue1[] va, int index) throws Throwable {
1063         setArrayElementNull.invoke(this, va, index);
1064     }
1065 
1066     @DontCompile
1067     public void test35_verifier(boolean warmup) throws Throwable {
1068         int index = Math.abs(rI) % 3;
1069         try {
1070             test35(testValue1Array, index);
1071             throw new RuntimeException(&quot;No NPE thrown&quot;);
1072         } catch (NullPointerException e) {
1073             // Expected
1074         }
1075         Asserts.assertEQ(testValue1Array[index].hash(), hash());
1076     }
1077 
<span class="line-modified">1078     // Test writing an inline type to a null inline type array</span>
1079     @Test()
1080     public void test36(MyValue1[] va, MyValue1 vt, int index) {
1081         va[index] = vt;
1082     }
1083 
1084     @DontCompile
1085     public void test36_verifier(boolean warmup) {
1086         int index = Math.abs(rI) % 3;
1087         try {
1088             test36(null, testValue1Array[index], index);
1089             throw new RuntimeException(&quot;No NPE thrown&quot;);
1090         } catch (NullPointerException e) {
1091             // Expected
1092         }
1093     }
1094 
1095     // Test incremental inlining
1096     @ForceInline
1097     public void test37_inline(Object[] oa, Object o, int index) {
1098         oa[index] = o;
</pre>
<hr />
<pre>
1548             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1549                                      (MyValue1)holder.objectField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1550             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1551                                      holder.valueField1, (MyValue1)vt2, holder.valueField3, holder.valueField4, holder.valueField5);
1552             holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1553                                      holder.valueField1, holder.valueField2, (MyValue1)vt2, holder.valueField4, holder.valueField5);
1554 
1555             return ((MyValue1)holder.objectField1).hash() +
1556                    ((MyValue1)holder.objectField2).hash() +
1557                    ((MyValue1)holder.objectField3).hash() +
1558                    ((MyValue1)holder.objectField4).hash() +
1559                    ((MyValue1)holder.objectField5).hash() +
1560                    ((MyValue1)holder.objectField6).hash() +
1561                    holder.valueField1.hash() +
1562                    holder.valueField2.hash() +
1563                    holder.valueField3.hash() +
1564                    holder.valueField4.hashPrimitive();
1565         }
1566     }
1567 
<span class="line-modified">1568     // Same as test2 but with field holder being an inline type</span>
1569     @Test()
1570     public long test51(Test51Value holder, MyValue1 vt1, Object vt2) {
1571         return holder.test(holder, vt1, vt2);
1572     }
1573 
1574     @DontCompile
1575     public void test51_verifier(boolean warmup) {
1576         MyValue1 vt = testValue1;
1577         MyValue1 def = MyValue1.createDefaultDontInline();
1578         Test51Value holder = new Test51Value();
1579         Asserts.assertEQ(testValue1.hash(), vt.hash());
1580         Asserts.assertEQ(holder.valueField1.hash(), vt.hash());
1581         long result = test51(holder, vt, vt);
1582         Asserts.assertEQ(result, 9*vt.hash() + def.hashPrimitive());
1583     }
1584 
1585     // Access non-flattened, uninitialized inline type field with inline type holder
1586     @Test()
1587     public void test52(Test51Value holder) {
1588         if ((Object)holder.valueField5 != null) {
</pre>
<hr />
<pre>
1867 
1868     @DontCompile
1869     public void test67_verifier(boolean warmup) {
1870         MyValue1[] array = new MyValue1[1];
1871         test67(array, testValue1);
1872         Asserts.assertEQ(array[0].hash(), testValue1.hash());
1873     }
1874 
1875     @Test()
1876     public void test68(Object[] array, Integer o) {
1877         array[0] = o;
1878     }
1879 
1880     @DontCompile
1881     public void test68_verifier(boolean warmup) {
1882         Integer[] array = new Integer[1];
1883         test68(array, 1);
1884         Asserts.assertEQ(array[0], Integer.valueOf(1));
1885     }
1886 
<span class="line-modified">1887     // Test convertion between an inline type and java.lang.Object without an allocation</span>
1888     @ForceInline
1889     public Object test69_sum(Object a, Object b) {
1890         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1891         return MyValue1.setX(((MyValue1)a), sum);
1892     }
1893 
1894     @Test(failOn = ALLOC + STORE)
1895     public int test69(MyValue1[] array) {
1896         MyValue1 result = MyValue1.createDefaultInline();
1897         for (int i = 0; i &lt; array.length; ++i) {
1898             result = (MyValue1)test69_sum(result, array[i]);
1899         }
1900         return result.x;
1901     }
1902 
1903     @DontCompile
1904     public void test69_verifier(boolean warmup) {
1905         int result = test69(testValue1Array);
1906         Asserts.assertEQ(result, rI * testValue1Array.length);
1907     }
</pre>
<hr />
<pre>
2706         Asserts.assertEQ(result, 4*hash());
2707     }
2708 
2709     // Test comparing inline types with abstract classes
2710     @Test(failOn = LOAD + LOOP)
2711     public boolean test102(Object arg) {
2712         MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);
2713         if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||
2714             arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {
2715             return true;
2716         }
2717         return false;
2718     }
2719 
2720     @DontCompile
2721     public void test102_verifier(boolean warmup) {
2722         boolean result = test102(null);
2723         Asserts.assertFalse(result);
2724     }
2725 
<span class="line-modified">2726     // An abstract class with a non-static field can never be implemented by an inline type</span>
2727     abstract class NoValueImplementors1 {
2728         int field = 42;
2729     }
2730 
2731     class MyObject3 extends NoValueImplementors1 {
2732 
2733     }
2734 
2735     class MyObject4 extends NoValueImplementors1 {
2736 
2737     }
2738 
2739     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field
2740     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
2741     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {
2742         return array[i];
2743     }
2744 
2745     @DontCompile
2746     public void test103_verifier(boolean warmup) {
</pre>
</td>
</tr>
</table>
<center><a href="TestJNICalls.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestNullableArrays.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableInlineTypes.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestNullableArrays.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestUnresolvedInlineClass.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableInlineTypes.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 461,11 ***</span>
      @DontInline
      public boolean test16_dontinline(MyValue1.ref vt) {
          return (Object)vt == null;
      }
  
<span class="line-modified">!     // Test c2c call passing null for a inline type</span>
      @Test
      @Warmup(10000) // Warmup to make sure &#39;test17_dontinline&#39; is compiled
      public boolean test16(Object arg) throws Exception {
          Method test16method = getClass().getMethod(&quot;test16_dontinline&quot;, MyValue1.ref.class);
          return (boolean)test16method.invoke(this, arg);
<span class="line-new-header">--- 461,11 ---</span>
      @DontInline
      public boolean test16_dontinline(MyValue1.ref vt) {
          return (Object)vt == null;
      }
  
<span class="line-modified">!     // Test c2c call passing null for an inline type</span>
      @Test
      @Warmup(10000) // Warmup to make sure &#39;test17_dontinline&#39; is compiled
      public boolean test16(Object arg) throws Exception {
          Method test16method = getClass().getMethod(&quot;test16_dontinline&quot;, MyValue1.ref.class);
          return (boolean)test16method.invoke(this, arg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 516,11 ***</span>
      @ForceInline
      static void test18_target2(MyValue1.ref vt) {
          nullValue = vt;
      }
  
<span class="line-modified">!     // Test passing null for a inline type</span>
      @Test
      @Warmup(11000) // Make sure lambda forms get compiled
      public void test18() throws Throwable {
          test18_mh1.invokeExact(nullValue);
          test18_mh2.invokeExact(nullValue);
<span class="line-new-header">--- 516,11 ---</span>
      @ForceInline
      static void test18_target2(MyValue1.ref vt) {
          nullValue = vt;
      }
  
<span class="line-modified">!     // Test passing null for an inline type</span>
      @Test
      @Warmup(11000) // Make sure lambda forms get compiled
      public void test18() throws Throwable {
          test18_mh1.invokeExact(nullValue);
          test18_mh2.invokeExact(nullValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 582,11 ***</span>
          } catch (Throwable t) {
              throw new RuntimeException(&quot;test20 failed&quot;, t);
          }
      }
  
<span class="line-modified">!     // Test writing null to a flattenable/non-flattenable inline type field in a inline type</span>
      final inline class Test21Value {
          final MyValue1.ref valueField1;
          final MyValue1 valueField2;
          final MyValue1.ref alwaysNull = null;
  
<span class="line-new-header">--- 582,11 ---</span>
          } catch (Throwable t) {
              throw new RuntimeException(&quot;test20 failed&quot;, t);
          }
      }
  
<span class="line-modified">!     // Test writing null to a flattenable/non-flattenable inline type field in an inline type</span>
      final inline class Test21Value {
          final MyValue1.ref valueField1;
          final MyValue1 valueField2;
          final MyValue1.ref alwaysNull = null;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 897,11 ***</span>
      public void test35_verifier(boolean warmup) {
          test35(true);
          test35(false);
      }
  
<span class="line-modified">!     // Test that when explicitly null checking a inline type, we keep</span>
      // track of the information that the inline type can never be null.
      @Test(failOn = ALLOC + STORE)
      public int test37(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
          if (vt1 == null) {
              return 0;
<span class="line-new-header">--- 897,11 ---</span>
      public void test35_verifier(boolean warmup) {
          test35(true);
          test35(false);
      }
  
<span class="line-modified">!     // Test that when explicitly null checking an inline type, we keep</span>
      // track of the information that the inline type can never be null.
      @Test(failOn = ALLOC + STORE)
      public int test37(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
          if (vt1 == null) {
              return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,11 ***</span>
          Asserts.assertEquals(res, testValue1.x);
          res = test37(false, testValue1, testValue1);
          Asserts.assertEquals(res, testValue1.x);
      }
  
<span class="line-modified">!     // Test that when explicitly null checking a inline type receiver,</span>
      // we keep track of the information that the inline type can never be null.
      @Test(failOn = ALLOC + STORE)
      public int test38(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
          vt1.hash(); // Inlined - Explicit null check
          // vt1 should be scalarized because it&#39;s always non-null
<span class="line-new-header">--- 918,11 ---</span>
          Asserts.assertEquals(res, testValue1.x);
          res = test37(false, testValue1, testValue1);
          Asserts.assertEquals(res, testValue1.x);
      }
  
<span class="line-modified">!     // Test that when explicitly null checking an inline type receiver,</span>
      // we keep track of the information that the inline type can never be null.
      @Test(failOn = ALLOC + STORE)
      public int test38(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
          vt1.hash(); // Inlined - Explicit null check
          // vt1 should be scalarized because it&#39;s always non-null
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,11 ***</span>
          Asserts.assertEquals(res, testValue1.x);
          res = test38(false, testValue1, testValue1);
          Asserts.assertEquals(res, testValue1.x);
      }
  
<span class="line-modified">!     // Test that when implicitly null checking a inline type receiver,</span>
      // we keep track of the information that the inline type can never be null.
      @Test(failOn = ALLOC + STORE)
      public int test39(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
          vt1.hashInterpreted(); // Not inlined - Implicit null check
          // vt1 should be scalarized because it&#39;s always non-null
<span class="line-new-header">--- 937,11 ---</span>
          Asserts.assertEquals(res, testValue1.x);
          res = test38(false, testValue1, testValue1);
          Asserts.assertEquals(res, testValue1.x);
      }
  
<span class="line-modified">!     // Test that when implicitly null checking an inline type receiver,</span>
      // we keep track of the information that the inline type can never be null.
      @Test(failOn = ALLOC + STORE)
      public int test39(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {
          vt1.hashInterpreted(); // Not inlined - Implicit null check
          // vt1 should be scalarized because it&#39;s always non-null
</pre>
<center><a href="TestNullableArrays.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestUnresolvedInlineClass.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 /*
  31  * @test
  32  * @summary Test nullable inline type arrays
  33  * @library /testlibrary /test/lib /compiler/whitebox /
  34  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  35  * @compile TestNullableArrays.java
  36  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  37  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  38  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  39  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  40  *                               compiler.valhalla.inlinetypes.TestNullableArrays
  41  */
  42 public class TestNullableArrays extends InlineTypeTest {
  43     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  44     // a normal method invocation when encountering flattened arrays.
  45     private static void assertDeoptimizedByC2(Method m) {
  46         if (isCompiledByC2(m)) {
  47             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  48         }
  49     }
  50 
  51     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  52     @Override
  53     public String[] getExtraVMParameters(int scenario) {
  54         switch (scenario) {
  55         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  56         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  57         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  58         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  59         }
  60         return null;
  61     }
  62 
  63     public static void main(String[] args) throws Throwable {
  64         TestNullableArrays test = new TestNullableArrays();
  65         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  66     }
  67 
  68     // Helper methods
  69 
  70     protected long hash() {
  71         return hash(rI, rL);
  72     }
  73 
  74     protected long hash(int x, long y) {
  75         return MyValue1.createWithFieldsInline(x, y).hash();
  76     }
  77 
  78     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  79 
  80     // Test nullable inline type array creation and initialization
  81     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  82     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  83     public MyValue1.ref[] test1(int len) {
  84         MyValue1.ref[] va = new MyValue1.ref[len];
  85         if (len &gt; 0) {
  86             va[0] = null;
  87         }
  88         for (int i = 1; i &lt; len; ++i) {
  89             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  90         }
  91         return va;
  92     }
  93 
  94     @DontCompile
  95     public void test1_verifier(boolean warmup) {
  96         int len = Math.abs(rI % 10);
  97         MyValue1.ref[] va = test1(len);
  98         if (len &gt; 0) {
  99             Asserts.assertEQ(va[0], null);
 100         }
 101         for (int i = 1; i &lt; len; ++i) {
 102             Asserts.assertEQ(va[i].hash(), hash());
 103         }
 104     }
 105 
 106     // Test creation of a inline type array and element access
 107     @Test
 108     // TODO 8227588
 109     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 110     public long test2() {
 111         MyValue1.ref[] va = new MyValue1.ref[1];
 112         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 113         return va[0].hash();
 114     }
 115 
 116     @DontCompile
 117     public void test2_verifier(boolean warmup) {
 118         long result = test2();
 119         Asserts.assertEQ(result, hash());
 120     }
 121 
 122     // Test receiving a inline type array from the interpreter,
 123     // updating its elements in a loop and computing a hash.
 124     @Test(failOn = ALLOCA)
 125     public long test3(MyValue1.ref[] va) {
 126         long result = 0;
 127         for (int i = 0; i &lt; 10; ++i) {
 128             if (va[i] != null) {
 129                 result += va[i].hash();
 130             }
 131             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 132         }
 133         va[0] = null;
 134         return result;
 135     }
 136 
 137     @DontCompile
 138     public void test3_verifier(boolean warmup) {
 139         MyValue1.ref[] va = new MyValue1.ref[10];
 140         long expected = 0;
 141         for (int i = 1; i &lt; 10; ++i) {
 142             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 143             expected += va[i].hash();
 144         }
 145         long result = test3(va);
 146         Asserts.assertEQ(expected, result);
 147         Asserts.assertEQ(va[0], null);
 148         for (int i = 1; i &lt; 10; ++i) {
 149             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 150                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 151             }
 152         }
 153     }
 154 
 155     // Test returning an inline type array received from the interpreter
 156     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 157     public MyValue1.ref[] test4(MyValue1.ref[] va) {
 158         return va;
 159     }
 160 
 161     @DontCompile
 162     public void test4_verifier(boolean warmup) {
 163         MyValue1.ref[] va = new MyValue1.ref[10];
 164         for (int i = 0; i &lt; 10; ++i) {
 165             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 166         }
 167         va = test4(va);
 168         for (int i = 0; i &lt; 10; ++i) {
 169             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 170         }
 171     }
 172 
 173     // Merge inline type arrays created from two branches
 174     @Test
 175     public MyValue1.ref[] test5(boolean b) {
 176         MyValue1.ref[] va;
 177         if (b) {
 178             va = new MyValue1.ref[5];
 179             for (int i = 0; i &lt; 5; ++i) {
 180                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 181             }
 182             va[4] = null;
 183         } else {
 184             va = new MyValue1.ref[10];
 185             for (int i = 0; i &lt; 10; ++i) {
 186                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 187             }
 188             va[9] = null;
 189         }
 190         long sum = va[0].hashInterpreted();
 191         if (b) {
 192             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 193         } else {
 194             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
 195         }
 196         return va;
 197     }
 198 
 199     @DontCompile
 200     public void test5_verifier(boolean warmup) {
 201         MyValue1.ref[] va = test5(true);
 202         Asserts.assertEQ(va.length, 5);
 203         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 204         for (int i = 1; i &lt; 4; ++i) {
 205             Asserts.assertEQ(va[i].hash(), hash());
 206         }
 207         Asserts.assertEQ(va[4], null);
 208         va = test5(false);
 209         Asserts.assertEQ(va.length, 10);
 210         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 211         for (int i = 1; i &lt; 9; ++i) {
 212             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 213         }
 214         Asserts.assertEQ(va[9], null);
 215     }
 216 
 217     // Test creation of inline type array with single element
 218     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 219     public MyValue1.ref test6() {
 220         MyValue1.ref[] va = new MyValue1.ref[1];
 221         return va[0];
 222     }
 223 
 224     @DontCompile
 225     public void test6_verifier(boolean warmup) {
 226         MyValue1.ref[] va = new MyValue1.ref[1];
 227         MyValue1.ref v = test6();
 228         Asserts.assertEQ(v, null);
 229     }
 230 
 231     // Test default initialization of inline type arrays
 232     @Test(failOn = LOAD)
 233     public MyValue1.ref[] test7(int len) {
 234         return new MyValue1.ref[len];
 235     }
 236 
 237     @DontCompile
 238     public void test7_verifier(boolean warmup) {
 239         int len = Math.abs(rI % 10);
 240         MyValue1.ref[] va = test7(len);
 241         for (int i = 0; i &lt; len; ++i) {
 242             Asserts.assertEQ(va[i], null);
 243             va[i] = null;
 244         }
 245     }
 246 
 247     // Test creation of inline type array with zero length
 248     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 249     public MyValue1.ref[] test8() {
 250         return new MyValue1.ref[0];
 251     }
 252 
 253     @DontCompile
 254     public void test8_verifier(boolean warmup) {
 255         MyValue1.ref[] va = test8();
 256         Asserts.assertEQ(va.length, 0);
 257     }
 258 
 259     static MyValue1.ref[] test9_va;
 260 
 261     // Test that inline type array loaded from field has correct type
 262     @Test(failOn = LOOP)
 263     public long test9() {
 264         return test9_va[0].hash();
 265     }
 266 
 267     @DontCompile
 268     public void test9_verifier(boolean warmup) {
 269         test9_va = new MyValue1.ref[1];
 270         test9_va[0] = testValue1;
 271         long result = test9();
 272         Asserts.assertEQ(result, hash());
 273     }
 274 
 275     // Multi-dimensional arrays
 276     @Test
 277     public MyValue1.ref[][][] test10(int len1, int len2, int len3) {
 278         MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];
 279         for (int i = 0; i &lt; len1; i++) {
 280             for (int j = 0; j &lt; len2; j++) {
 281                 for (int k = 0; k &lt; len3; k++) {
 282                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
 283                     if (k == 0) {
 284                         arr[i][j][k] = null;
 285                     }
 286                 }
 287             }
 288         }
 289         return arr;
 290     }
 291 
 292     @DontCompile
 293     public void test10_verifier(boolean warmup) {
 294         MyValue1.ref[][][] arr = test10(2, 3, 4);
 295         for (int i = 0; i &lt; 2; i++) {
 296             for (int j = 0; j &lt; 3; j++) {
 297                 for (int k = 0; k &lt; 4; k++) {
 298                     if (k == 0) {
 299                         Asserts.assertEQ(arr[i][j][k], null);
 300                     } else {
 301                         Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());
 302                     }
 303                     arr[i][j][k] = null;
 304                 }
 305             }
 306         }
 307     }
 308 
 309     @Test
 310     public void test11(MyValue1.ref[][][] arr, long[] res) {
 311         int l = 0;
 312         for (int i = 0; i &lt; arr.length; i++) {
 313             for (int j = 0; j &lt; arr[i].length; j++) {
 314                 for (int k = 0; k &lt; arr[i][j].length; k++) {
 315                     if (arr[i][j][k] != null) {
 316                         res[l] = arr[i][j][k].hash();
 317                     }
 318                     arr[i][j][k] = null;
 319                     l++;
 320                 }
 321             }
 322         }
 323     }
 324 
 325     @DontCompile
 326     public void test11_verifier(boolean warmup) {
 327         MyValue1.ref[][][] arr = new MyValue1.ref[2][3][4];
 328         long[] res = new long[2*3*4];
 329         long[] verif = new long[2*3*4];
 330         int l = 0;
 331         for (int i = 0; i &lt; 2; i++) {
 332             for (int j = 0; j &lt; 3; j++) {
 333                 for (int k = 0; k &lt; 4; k++) {
 334                     if (j != 2) {
 335                         arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);
 336                         verif[l] = arr[i][j][k].hash();
 337                     }
 338                     l++;
 339                 }
 340             }
 341         }
 342         test11(arr, res);
 343         for (int i = 0; i &lt; verif.length; i++) {
 344             Asserts.assertEQ(res[i], verif[i]);
 345         }
 346     }
 347 
 348     // Array load out of bounds (upper bound) at compile time
 349     @Test
 350     public int test12() {
 351         int arraySize = Math.abs(rI) % 10;
 352         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 353 
 354         for (int i = 0; i &lt; arraySize; i++) {
 355             va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 356         }
 357 
 358         try {
 359             return va[arraySize + 1].x;
 360         } catch (ArrayIndexOutOfBoundsException e) {
 361             return rI;
 362         }
 363     }
 364 
 365     public void test12_verifier(boolean warmup) {
 366         Asserts.assertEQ(test12(), rI);
 367     }
 368 
 369     // Array load  out of bounds (lower bound) at compile time
 370     @Test
 371     public int test13() {
 372         int arraySize = Math.abs(rI) % 10;
 373         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 374 
 375         for (int i = 0; i &lt; arraySize; i++) {
 376             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
 377         }
 378 
 379         try {
 380             return va[-arraySize].x;
 381         } catch (ArrayIndexOutOfBoundsException e) {
 382             return rI;
 383         }
 384     }
 385 
 386     public void test13_verifier(boolean warmup) {
 387         Asserts.assertEQ(test13(), rI);
 388     }
 389 
 390     // Array load out of bound not known to compiler (both lower and upper bound)
 391     @Test
 392     public int test14(MyValue1.ref[] va, int index)  {
 393         return va[index].x;
 394     }
 395 
 396     public void test14_verifier(boolean warmup) {
 397         int arraySize = Math.abs(rI) % 10;
 398         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 399 
 400         for (int i = 0; i &lt; arraySize; i++) {
 401             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 402         }
 403 
 404         int result;
 405         for (int i = -20; i &lt; 20; i++) {
 406             try {
 407                 result = test14(va, i);
 408             } catch (ArrayIndexOutOfBoundsException e) {
 409                 result = rI;
 410             }
 411             Asserts.assertEQ(result, rI);
 412         }
 413     }
 414 
 415     // Array store out of bounds (upper bound) at compile time
 416     @Test
 417     public int test15() {
 418         int arraySize = Math.abs(rI) % 10;
 419         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 420 
 421         try {
 422             for (int i = 0; i &lt;= arraySize; i++) {
 423                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 424             }
 425             return rI - 1;
 426         } catch (ArrayIndexOutOfBoundsException e) {
 427             return rI;
 428         }
 429     }
 430 
 431     public void test15_verifier(boolean warmup) {
 432         Asserts.assertEQ(test15(), rI);
 433     }
 434 
 435     // Array store out of bounds (lower bound) at compile time
 436     @Test
 437     public int test16() {
 438         int arraySize = Math.abs(rI) % 10;
 439         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 440 
 441         try {
 442             for (int i = -1; i &lt;= arraySize; i++) {
 443                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 444             }
 445             return rI - 1;
 446         } catch (ArrayIndexOutOfBoundsException e) {
 447             return rI;
 448         }
 449     }
 450 
 451     public void test16_verifier(boolean warmup) {
 452         Asserts.assertEQ(test16(), rI);
 453     }
 454 
 455     // Array store out of bound not known to compiler (both lower and upper bound)
 456     @Test
 457     public int test17(MyValue1.ref[] va, int index, MyValue1 vt)  {
 458         va[index] = vt;
 459         return va[index].x;
 460     }
 461 
 462     @DontCompile
 463     public void test17_verifier(boolean warmup) {
 464         int arraySize = Math.abs(rI) % 10;
 465         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 466 
 467         for (int i = 0; i &lt; arraySize; i++) {
 468             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 469         }
 470 
 471         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 472         int result;
 473         for (int i = -20; i &lt; 20; i++) {
 474             try {
 475                 result = test17(va, i, vt);
 476             } catch (ArrayIndexOutOfBoundsException e) {
 477                 result = rI + 1;
 478             }
 479             Asserts.assertEQ(result, rI + 1);
 480         }
 481 
 482         for (int i = 0; i &lt; arraySize; i++) {
 483             Asserts.assertEQ(va[i].x, rI + 1);
 484         }
 485     }
 486 
 487     // clone() as stub call
 488     @Test
 489     public MyValue1.ref[] test18(MyValue1.ref[] va) {
 490         return va.clone();
 491     }
 492 
 493     @DontCompile
 494     public void test18_verifier(boolean warmup) {
 495         int len = Math.abs(rI) % 10;
 496         MyValue1.ref[] va1 = new MyValue1.ref[len];
 497         MyValue1[]  va2 = new MyValue1[len];
 498         for (int i = 1; i &lt; len; ++i) {
 499             va1[i] = testValue1;
 500             va2[i] = testValue1;
 501         }
 502         MyValue1.ref[] result1 = test18(va1);
 503         if (len &gt; 0) {
 504             Asserts.assertEQ(result1[0], null);
 505         }
 506         for (int i = 1; i &lt; len; ++i) {
 507             Asserts.assertEQ(result1[i].hash(), va1[i].hash());
 508         }
 509         // make sure we do deopt: GraphKit::new_array assumes an
 510         // array of references
 511         for (int j = 0; j &lt; 10; j++) {
 512             MyValue1.ref[] result2 = test18(va2);
 513 
 514             for (int i = 0; i &lt; len; ++i) {
 515                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
 516             }
 517         }
 518         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test18&quot;)) {
 519             MyValue1.ref[] result2 = test18(va2);
 520             for (int i = 0; i &lt; len; ++i) {
 521                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
 522             }
 523         }
 524     }
 525 
 526     // clone() as series of loads/stores
 527     static MyValue1.ref[] test19_orig = null;
 528 
 529     @Test
 530     public MyValue1.ref[] test19() {
 531         MyValue1.ref[] va = new MyValue1.ref[8];
 532         for (int i = 1; i &lt; va.length; ++i) {
 533             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 534         }
 535         test19_orig = va;
 536 
 537         return va.clone();
 538     }
 539 
 540     @DontCompile
 541     public void test19_verifier(boolean warmup) {
 542         MyValue1.ref[] result = test19();
 543         Asserts.assertEQ(result[0], null);
 544         for (int i = 1; i &lt; test19_orig.length; ++i) {
 545             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 546         }
 547     }
 548 
 549     // arraycopy() of inline type array with oop fields
 550     @Test
 551     public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {
 552         System.arraycopy(src, 0, dst, 0, src.length);
 553     }
 554 
 555     @DontCompile
 556     public void test20_verifier(boolean warmup) {
 557         int len = Math.abs(rI) % 10;
 558         MyValue1.ref[] src1 = new MyValue1.ref[len];
 559         MyValue1.ref[] src2 = new MyValue1.ref[len];
 560         MyValue1[]  src3 = new MyValue1[len];
 561         MyValue1[]  src4 = new MyValue1[len];
 562         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 563         MyValue1[]  dst2 = new MyValue1[len];
 564         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 565         MyValue1[]  dst4 = new MyValue1[len];
 566         if (len &gt; 0) {
 567             src2[0] = testValue1;
 568         }
 569         for (int i = 1; i &lt; len; ++i) {
 570             src1[i] = testValue1;
 571             src2[i] = testValue1;
 572             src3[i] = testValue1;
 573             src4[i] = testValue1;
 574         }
 575         test20(src1, dst1);
 576         test20(src2, dst2);
 577         test20(src3, dst3);
 578         test20(src4, dst4);
 579         if (len &gt; 0) {
 580             Asserts.assertEQ(dst1[0], null);
 581             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 582             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 583             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 584         }
 585         for (int i = 1; i &lt; len; ++i) {
 586             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 587             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 588             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 589             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 590         }
 591     }
 592 
 593     // arraycopy() of inline type array with no oop field
 594     @Test
 595     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
 596         System.arraycopy(src, 0, dst, 0, src.length);
 597     }
 598 
 599     @DontCompile
 600     public void test21_verifier(boolean warmup) {
 601         int len = Math.abs(rI) % 10;
 602         MyValue2.ref[] src1 = new MyValue2.ref[len];
 603         MyValue2.ref[] src2 = new MyValue2.ref[len];
 604         MyValue2[]  src3 = new MyValue2[len];
 605         MyValue2[]  src4 = new MyValue2[len];
 606         MyValue2.ref[] dst1 = new MyValue2.ref[len];
 607         MyValue2[]  dst2 = new MyValue2[len];
 608         MyValue2.ref[] dst3 = new MyValue2.ref[len];
 609         MyValue2[]  dst4 = new MyValue2[len];
 610         if (len &gt; 0) {
 611             src2[0] = MyValue2.createWithFieldsInline(rI, true);
 612         }
 613         for (int i = 1; i &lt; len; ++i) {
 614             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 615             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 616             src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 617             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 618         }
 619         test21(src1, dst1);
 620         test21(src2, dst2);
 621         test21(src3, dst3);
 622         test21(src4, dst4);
 623         if (len &gt; 0) {
 624             Asserts.assertEQ(dst1[0], null);
 625             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 626             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 627             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 628         }
 629         for (int i = 1; i &lt; len; ++i) {
 630             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 631             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 632             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 633             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 634         }
 635     }
 636 
 637     // arraycopy() of inline type array with oop field and tightly
 638     // coupled allocation as dest
 639     @Test
 640     public MyValue1.ref[] test22(MyValue1.ref[] src) {
 641         MyValue1.ref[] dst = new MyValue1.ref[src.length];
 642         System.arraycopy(src, 0, dst, 0, src.length);
 643         return dst;
 644     }
 645 
 646     @DontCompile
 647     public void test22_verifier(boolean warmup) {
 648         int len = Math.abs(rI) % 10;
 649         MyValue1.ref[] src1 = new MyValue1.ref[len];
 650         MyValue1[]  src2 = new MyValue1[len];
 651         for (int i = 1; i &lt; len; ++i) {
 652             src1[i] = testValue1;
 653             src2[i] = testValue1;
 654         }
 655         MyValue1.ref[] dst1 = test22(src1);
 656         MyValue1.ref[] dst2 = test22(src2);
 657         if (len &gt; 0) {
 658             Asserts.assertEQ(dst1[0], null);
 659             Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
 660         }
 661         for (int i = 1; i &lt; len; ++i) {
 662             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 663             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 664         }
 665     }
 666 
 667     // arraycopy() of inline type array with oop fields and tightly
 668     // coupled allocation as dest
 669     @Test
 670     public MyValue1.ref[] test23(MyValue1.ref[] src) {
 671         MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];
 672         System.arraycopy(src, 0, dst, 5, src.length);
 673         return dst;
 674     }
 675 
 676     @DontCompile
 677     public void test23_verifier(boolean warmup) {
 678         int len = Math.abs(rI) % 10;
 679         MyValue1.ref[] src1 = new MyValue1.ref[len];
 680         MyValue1[] src2 = new MyValue1[len];
 681         for (int i = 0; i &lt; len; ++i) {
 682             src1[i] = testValue1;
 683             src2[i] = testValue1;
 684         }
 685         MyValue1.ref[] dst1 = test23(src1);
 686         MyValue1.ref[] dst2 = test23(src2);
 687         for (int i = 0; i &lt; 5; ++i) {
 688             Asserts.assertEQ(dst1[i], null);
 689             Asserts.assertEQ(dst2[i], null);
 690         }
 691         for (int i = 5; i &lt; len; ++i) {
 692             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 693             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 694         }
 695     }
 696 
 697     // arraycopy() of inline type array passed as Object
 698     @Test
 699     public void test24(MyValue1.ref[] src, Object dst) {
 700         System.arraycopy(src, 0, dst, 0, src.length);
 701     }
 702 
 703     @DontCompile
 704     public void test24_verifier(boolean warmup) {
 705         int len = Math.abs(rI) % 10;
 706         MyValue1.ref[] src1 = new MyValue1.ref[len];
 707         MyValue1.ref[] src2 = new MyValue1.ref[len];
 708         MyValue1[]  src3 = new MyValue1[len];
 709         MyValue1[]  src4 = new MyValue1[len];
 710         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 711         MyValue1[]  dst2 = new MyValue1[len];
 712         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 713         MyValue1[]  dst4 = new MyValue1[len];
 714         if (len &gt; 0) {
 715             src2[0] = testValue1;
 716         }
 717         for (int i = 1; i &lt; len; ++i) {
 718             src1[i] = testValue1;
 719             src2[i] = testValue1;
 720             src3[i] = testValue1;
 721             src4[i] = testValue1;
 722         }
 723         test24(src1, dst1);
 724         test24(src2, dst2);
 725         test24(src3, dst3);
 726         test24(src4, dst4);
 727         if (len &gt; 0) {
 728             Asserts.assertEQ(dst1[0], null);
 729             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 730             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 731             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 732         }
 733         for (int i = 1; i &lt; len; ++i) {
 734             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 735             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 736             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 737             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 738         }
 739     }
 740 
 741     // short arraycopy() with no oop field
 742     @Test
 743     public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {
 744         System.arraycopy(src, 0, dst, 0, 8);
 745     }
 746 
 747     @DontCompile
 748     public void test25_verifier(boolean warmup) {
 749         MyValue2.ref[] src1 = new MyValue2.ref[8];
 750         MyValue2.ref[] src2 = new MyValue2.ref[8];
 751         MyValue2[]  src3 = new MyValue2[8];
 752         MyValue2[]  src4 = new MyValue2[8];
 753         MyValue2.ref[] dst1 = new MyValue2.ref[8];
 754         MyValue2[]  dst2 = new MyValue2[8];
 755         MyValue2.ref[] dst3 = new MyValue2.ref[8];
 756         MyValue2[]  dst4 = new MyValue2[8];
 757         src2[0] = MyValue2.createWithFieldsInline(rI, true);
 758         for (int i = 1; i &lt; 8; ++i) {
 759             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 760             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 761             src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 762             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 763         }
 764         test25(src1, dst1);
 765         test25(src2, dst2);
 766         test25(src3, dst3);
 767         test25(src4, dst4);
 768         Asserts.assertEQ(dst1[0], null);
 769         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 770         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 771         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 772         for (int i = 1; i &lt; 8; ++i) {
 773             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 774             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 775             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 776             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 777         }
 778     }
 779 
 780     // short arraycopy() with oop fields
 781     @Test
 782     public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {
 783         System.arraycopy(src, 0, dst, 0, 8);
 784     }
 785 
 786     @DontCompile
 787     public void test26_verifier(boolean warmup) {
 788         MyValue1.ref[] src1 = new MyValue1.ref[8];
 789         MyValue1.ref[] src2 = new MyValue1.ref[8];
 790         MyValue1[]  src3 = new MyValue1[8];
 791         MyValue1[]  src4 = new MyValue1[8];
 792         MyValue1.ref[] dst1 = new MyValue1.ref[8];
 793         MyValue1[]  dst2 = new MyValue1[8];
 794         MyValue1.ref[] dst3 = new MyValue1.ref[8];
 795         MyValue1[]  dst4 = new MyValue1[8];
 796         src2[0] = testValue1;
 797         for (int i = 1; i &lt; 8 ; ++i) {
 798             src1[i] = testValue1;
 799             src2[i] = testValue1;
 800             src3[i] = testValue1;
 801             src4[i] = testValue1;
 802         }
 803         test26(src1, dst1);
 804         test26(src2, dst2);
 805         test26(src3, dst3);
 806         test26(src4, dst4);
 807         Asserts.assertEQ(dst1[0], null);
 808         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 809         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 810         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 811         for (int i = 1; i &lt; 8; ++i) {
 812             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 813             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 814             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 815             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 816         }
 817     }
 818 
 819     // short arraycopy() with oop fields and offsets
 820     @Test
 821     public void test27(MyValue1.ref[] src, MyValue1.ref[] dst) {
 822         System.arraycopy(src, 1, dst, 2, 6);
 823     }
 824 
 825     @DontCompile
 826     public void test27_verifier(boolean warmup) {
 827         MyValue1.ref[] src1 = new MyValue1.ref[8];
 828         MyValue1.ref[] src2 = new MyValue1.ref[8];
 829         MyValue1[]  src3 = new MyValue1[8];
 830         MyValue1[]  src4 = new MyValue1[8];
 831         MyValue1.ref[] dst1 = new MyValue1.ref[8];
 832         MyValue1[]  dst2 = new MyValue1[8];
 833         MyValue1.ref[] dst3 = new MyValue1.ref[8];
 834         MyValue1[]  dst4 = new MyValue1[8];
 835         for (int i = 1; i &lt; 8; ++i) {
 836             src1[i] = testValue1;
 837             src2[i] = testValue1;
 838             src3[i] = testValue1;
 839             src4[i] = testValue1;
 840         }
 841         test27(src1, dst1);
 842         test27(src2, dst2);
 843         test27(src3, dst3);
 844         test27(src4, dst4);
 845         for (int i = 0; i &lt; 2; ++i) {
 846             Asserts.assertEQ(dst1[i], null);
 847             Asserts.assertEQ(dst2[i].hash(), MyValue1.default.hash());
 848             Asserts.assertEQ(dst3[i], null);
 849             Asserts.assertEQ(dst4[i].hash(), MyValue1.default.hash());
 850         }
 851         for (int i = 2; i &lt; 8; ++i) {
 852             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 853             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 854             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 855             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 856         }
 857     }
 858 
 859     // non escaping allocations
 860     // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
 861     @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 862     @Test(valid = ZGCOn)
 863     public MyValue2.ref test28() {
 864         MyValue2.ref[] src = new MyValue2.ref[10];
 865         src[0] = null;
 866         MyValue2.ref[] dst = (MyValue2.ref[])src.clone();
 867         return dst[0];
 868     }
 869 
 870     @DontCompile
 871     public void test28_verifier(boolean warmup) {
 872         MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
 873         MyValue2.ref result = test28();
 874         Asserts.assertEQ(result, null);
 875     }
 876 
 877     // non escaping allocations
 878     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 879     @Test(failOn = ALLOCA + LOOP + TRAP)
 880     public MyValue2.ref test29(MyValue2.ref[] src) {
 881         MyValue2.ref[] dst = new MyValue2.ref[10];
 882         System.arraycopy(src, 0, dst, 0, 10);
 883         return dst[0];
 884     }
 885 
 886     @DontCompile
 887     public void test29_verifier(boolean warmup) {
 888         MyValue2.ref[] src = new MyValue2.ref[10];
 889         for (int i = 0; i &lt; 10; ++i) {
 890             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 891         }
 892         MyValue2.ref v = test29(src);
 893         Asserts.assertEQ(src[0].hash(), v.hash());
 894     }
 895 
 896     // non escaping allocation with uncommon trap that needs
 897     // eliminated inline type array element as debug info
 898     @Test
 899     @Warmup(10000)
 900     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
 901         MyValue2.ref[] dst = new MyValue2.ref[10];
 902         System.arraycopy(src, 0, dst, 0, 10);
 903         if (flag) { }
 904         return dst[0];
 905     }
 906 
 907     @DontCompile
 908     public void test30_verifier(boolean warmup) {
 909         MyValue2.ref[] src = new MyValue2.ref[10];
 910         for (int i = 0; i &lt; 10; ++i) {
 911             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 912         }
 913         MyValue2.ref v = test30(src, !warmup);
 914         Asserts.assertEQ(src[0].hash(), v.hash());
 915     }
 916 
 917     // non escaping allocation with memory phi
 918     @Test()
 919     // TODO 8227588
 920     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 921     public long test31(boolean b, boolean deopt) {
 922         MyValue2.ref[] src = new MyValue2.ref[1];
 923         if (b) {
 924             src[0] = MyValue2.createWithFieldsInline(rI, true);
 925         } else {
 926             src[0] = MyValue2.createWithFieldsInline(rI, false);
 927         }
 928         if (deopt) {
 929             // uncommon trap
 930             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 931         }
 932         return src[0].hash();
 933     }
 934 
 935     @DontCompile
 936     public void test31_verifier(boolean warmup) {
 937         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);
 938         long result1 = test31(true, !warmup);
 939         Asserts.assertEQ(result1, v1.hash());
 940         MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);
 941         long result2 = test31(false, !warmup);
 942         Asserts.assertEQ(result2, v2.hash());
 943     }
 944 
 945     // Tests with Object arrays and clone/arraycopy
 946     // clone() as stub call
 947     @Test
 948     public Object[] test32(Object[] va) {
 949         return va.clone();
 950     }
 951 
 952     @DontCompile
 953     public void test32_verifier(boolean warmup) {
 954         int len = Math.abs(rI) % 10;
 955         MyValue1.ref[] va1 = new MyValue1.ref[len];
 956         MyValue1[] va2 = new MyValue1[len];
 957         for (int i = 1; i &lt; len; ++i) {
 958             va1[i] = testValue1;
 959             va2[i] = testValue1;
 960         }
 961         MyValue1.ref[] result1 = (MyValue1.ref[])test32(va1);
 962         MyValue1.ref[] result2 = (MyValue1.ref[])test32(va2);
 963         if (len &gt; 0) {
 964             Asserts.assertEQ(result1[0], null);
 965             Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());
 966         }
 967         for (int i = 1; i &lt; len; ++i) {
 968             Asserts.assertEQ(((MyValue1)result1[i]).hash(), ((MyValue1)va1[i]).hash());
 969             Asserts.assertEQ(((MyValue1)result2[i]).hash(), ((MyValue1)va2[i]).hash());
 970         }
 971     }
 972 
 973     @Test
 974     public Object[] test33(Object[] va) {
 975         return va.clone();
 976     }
 977 
 978     @DontCompile
 979     public void test33_verifier(boolean warmup) {
 980         int len = Math.abs(rI) % 10;
 981         Object[] va = new Object[len];
 982         for (int i = 0; i &lt; len; ++i) {
 983             va[i] = testValue1;
 984         }
 985         Object[] result = test33(va);
 986         for (int i = 0; i &lt; len; ++i) {
 987             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 988         }
 989     }
 990 
 991     // clone() as series of loads/stores
 992     static Object[] test34_orig = null;
 993 
 994     @ForceInline
 995     public Object[] test34_helper(boolean flag) {
 996         Object[] va = null;
 997         if (flag) {
 998             va = new MyValue1.ref[8];
 999             for (int i = 0; i &lt; va.length; ++i) {
1000                 va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
1001             }
1002         } else {
1003             va = new Object[8];
1004         }
1005         return va;
1006     }
1007 
1008     @Test
1009     public Object[] test34(boolean flag) {
1010         Object[] va = test34_helper(flag);
1011         test34_orig = va;
1012         return va.clone();
1013     }
1014 
1015     @DontCompile
1016     public void test34_verifier(boolean warmup) {
1017         test34(false);
1018         for (int i = 0; i &lt; 10; i++) { // make sure we do deopt
1019             Object[] result = test34(true);
1020             verify(test34_orig, result);
1021         }
1022         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test34&quot;)) {
1023             Object[] result = test34(true);
1024             verify(test34_orig, result);
1025         }
1026     }
1027 
1028     static void verify(Object[] src, Object[] dst) {
1029         for (int i = 0; i &lt; src.length; ++i) {
1030             if (src[i] != null) {
1031                 Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());
1032             } else {
1033                 Asserts.assertEQ(dst[i], null);
1034             }
1035         }
1036     }
1037 
1038     static void verify(MyValue1.ref[] src, MyValue1.ref[] dst) {
1039         for (int i = 0; i &lt; src.length; ++i) {
1040             if (src[i] != null) {
1041                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1042             } else {
1043                 Asserts.assertEQ(dst[i], null);
1044             }
1045         }
1046     }
1047 
1048     static void verify(MyValue1.ref[] src, Object[] dst) {
1049         for (int i = 0; i &lt; src.length; ++i) {
1050             if (src[i] != null) {
1051                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1052             } else {
1053                 Asserts.assertEQ(dst[i], null);
1054             }
1055         }
1056     }
1057 
1058     static void verify(MyValue2.ref[] src, MyValue2.ref[] dst) {
1059         for (int i = 0; i &lt; src.length; ++i) {
1060             if (src[i] != null) {
1061                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1062             } else {
1063                 Asserts.assertEQ(dst[i], null);
1064             }
1065         }
1066     }
1067 
1068     static void verify(MyValue2.ref[] src, Object[] dst) {
1069         for (int i = 0; i &lt; src.length; ++i) {
1070             if (src[i] != null) {
1071                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1072             } else {
1073                 Asserts.assertEQ(dst[i], null);
1074             }
1075         }
1076     }
1077 
1078     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
1079         if (!warmup) {
1080             Method m = tests.get(test);
1081             if (USE_COMPILER &amp;&amp;  !WHITE_BOX.isMethodCompiled(m, false)) {
1082                 if (!InlineTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1083                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
1084                 }
1085                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1086                 return true;
1087             }
1088         }
1089         return false;
1090     }
1091 
1092     // arraycopy() of inline type array of unknown size
1093     @Test
1094     public void test35(Object src, Object dst, int len) {
1095         System.arraycopy(src, 0, dst, 0, len);
1096     }
1097 
1098     @DontCompile
1099     public void test35_verifier(boolean warmup) {
1100         int len = Math.abs(rI) % 10;
1101         MyValue1.ref[] src = new MyValue1.ref[len];
1102         MyValue1.ref[] dst = new MyValue1.ref[len];
1103         for (int i = 1; i &lt; len; ++i) {
1104             src[i] = testValue1;
1105         }
1106         test35(src, dst, src.length);
1107         verify(src, dst);
1108         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test35&quot;)) {
1109             test35(src, dst, src.length);
1110             verify(src, dst);
1111         }
1112     }
1113 
1114     @Test
1115     public void test36(Object src, MyValue2.ref[] dst) {
1116         System.arraycopy(src, 0, dst, 0, dst.length);
1117     }
1118 
1119     @DontCompile
1120     public void test36_verifier(boolean warmup) {
1121         int len = Math.abs(rI) % 10;
1122         MyValue2.ref[] src = new MyValue2.ref[len];
1123         MyValue2.ref[] dst = new MyValue2.ref[len];
1124         for (int i = 1; i &lt; len; ++i) {
1125             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1126         }
1127         test36(src, dst);
1128         verify(src, dst);
1129         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test36&quot;)) {
1130             test36(src, dst);
1131             verify(src, dst);
1132         }
1133     }
1134 
1135     @Test
1136     public void test37(MyValue2.ref[] src, Object dst) {
1137         System.arraycopy(src, 0, dst, 0, src.length);
1138     }
1139 
1140     @DontCompile
1141     public void test37_verifier(boolean warmup) {
1142         int len = Math.abs(rI) % 10;
1143         MyValue2.ref[] src = new MyValue2.ref[len];
1144         MyValue2.ref[] dst = new MyValue2.ref[len];
1145         for (int i = 1; i &lt; len; ++i) {
1146             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1147         }
1148         test37(src, dst);
1149         verify(src, dst);
1150         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test37&quot;)) {
1151             test37(src, dst);
1152             verify(src, dst);
1153         }
1154     }
1155 
1156     @Test
1157     @Warmup(1) // Avoid early compilation
1158     public void test38(Object src, MyValue2.ref[] dst) {
1159         System.arraycopy(src, 0, dst, 0, dst.length);
1160     }
1161 
1162     @DontCompile
1163     public void test38_verifier(boolean warmup) {
1164         int len = Math.abs(rI) % 10;
1165         Object[] src = new Object[len];
1166         MyValue2.ref[] dst = new MyValue2.ref[len];
1167         for (int i = 1; i &lt; len; ++i) {
1168             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1169         }
1170         test38(src, dst);
1171         verify(dst, src);
1172         if (!warmup) {
1173             Method m = tests.get(&quot;TestNullableArrays::test38&quot;);
1174             assertDeoptimizedByC2(m);
1175             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1176             test38(src, dst);
1177             verify(dst, src);
1178             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1179                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1180             }
1181         }
1182     }
1183 
1184     @Test
1185     public void test39(MyValue2.ref[] src, Object dst) {
1186         System.arraycopy(src, 0, dst, 0, src.length);
1187     }
1188 
1189     @DontCompile
1190     public void test39_verifier(boolean warmup) {
1191         int len = Math.abs(rI) % 10;
1192         MyValue2.ref[] src = new MyValue2.ref[len];
1193         Object[] dst = new Object[len];
1194         for (int i = 1; i &lt; len; ++i) {
1195             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1196         }
1197         test39(src, dst);
1198         verify(src, dst);
1199         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test39&quot;)) {
1200             test39(src, dst);
1201             verify(src, dst);
1202         }
1203     }
1204 
1205     @Test
1206     @Warmup(1) // Avoid early compilation
1207     public void test40(Object[] src, Object dst) {
1208         System.arraycopy(src, 0, dst, 0, src.length);
1209     }
1210 
1211     @DontCompile
1212     public void test40_verifier(boolean warmup) {
1213         int len = Math.abs(rI) % 10;
1214         Object[] src = new Object[len];
1215         MyValue2.ref[] dst = new MyValue2.ref[len];
1216         for (int i = 1; i &lt; len; ++i) {
1217             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1218         }
1219         test40(src, dst);
1220         verify(dst, src);
1221         if (!warmup) {
1222             Method m = tests.get(&quot;TestNullableArrays::test40&quot;);
1223             assertDeoptimizedByC2(m);
1224             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1225             test40(src, dst);
1226             verify(dst, src);
1227             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1228                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1229             }
1230         }
1231     }
1232 
1233     @Test
1234     public void test41(Object src, Object[] dst) {
1235         System.arraycopy(src, 0, dst, 0, dst.length);
1236     }
1237 
1238     @DontCompile
1239     public void test41_verifier(boolean warmup) {
1240         int len = Math.abs(rI) % 10;
1241         MyValue2.ref[] src = new MyValue2.ref[len];
1242         Object[] dst = new Object[len];
1243         for (int i = 1; i &lt; len; ++i) {
1244             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1245         }
1246         test41(src, dst);
1247         verify(src, dst);
1248         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test41&quot;)) {
1249             test41(src, dst);
1250             verify(src, dst);
1251         }
1252     }
1253 
1254     @Test
1255     public void test42(Object[] src, Object[] dst) {
1256         System.arraycopy(src, 0, dst, 0, src.length);
1257     }
1258 
1259     @DontCompile
1260     public void test42_verifier(boolean warmup) {
1261         int len = Math.abs(rI) % 10;
1262         Object[] src = new Object[len];
1263         Object[] dst = new Object[len];
1264         for (int i = 1; i &lt; len; ++i) {
1265             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1266         }
1267         test42(src, dst);
1268         verify(src, dst);
1269         if (!warmup) {
1270             Method m = tests.get(&quot;TestNullableArrays::test42&quot;);
1271             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1272                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1273             }
1274         }
1275     }
1276 
1277     // short arraycopy()&#39;s
1278     @Test
1279     public void test43(Object src, Object dst) {
1280         System.arraycopy(src, 0, dst, 0, 8);
1281     }
1282 
1283     @DontCompile
1284     public void test43_verifier(boolean warmup) {
1285         MyValue1.ref[] src = new MyValue1.ref[8];
1286         MyValue1.ref[] dst = new MyValue1.ref[8];
1287         for (int i = 1; i &lt; 8; ++i) {
1288             src[i] = testValue1;
1289         }
1290         test43(src, dst);
1291         verify(src, dst);
1292         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test43&quot;)) {
1293             test43(src, dst);
1294             verify(src, dst);
1295         }
1296     }
1297 
1298     @Test
1299     public void test44(Object src, MyValue2.ref[] dst) {
1300         System.arraycopy(src, 0, dst, 0, 8);
1301     }
1302 
1303     @DontCompile
1304     public void test44_verifier(boolean warmup) {
1305         MyValue2.ref[] src = new MyValue2.ref[8];
1306         MyValue2.ref[] dst = new MyValue2.ref[8];
1307         for (int i = 1; i &lt; 8; ++i) {
1308             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1309         }
1310         test44(src, dst);
1311         verify(src, dst);
1312         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test44&quot;)) {
1313             test44(src, dst);
1314             verify(src, dst);
1315         }
1316     }
1317 
1318     @Test
1319     public void test45(MyValue2.ref[] src, Object dst) {
1320         System.arraycopy(src, 0, dst, 0, 8);
1321     }
1322 
1323     @DontCompile
1324     public void test45_verifier(boolean warmup) {
1325         MyValue2.ref[] src = new MyValue2.ref[8];
1326         MyValue2.ref[] dst = new MyValue2.ref[8];
1327         for (int i = 1; i &lt; 8; ++i) {
1328             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1329         }
1330         test45(src, dst);
1331         verify(src, dst);
1332         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test45&quot;)) {
1333             test45(src, dst);
1334             verify(src, dst);
1335         }
1336     }
1337 
1338     @Test
1339     @Warmup(1) // Avoid early compilation
1340     public void test46(Object[] src, MyValue2.ref[] dst) {
1341         System.arraycopy(src, 0, dst, 0, 8);
1342     }
1343 
1344     @DontCompile
1345     public void test46_verifier(boolean warmup) {
1346         Object[] src = new Object[8];
1347         MyValue2.ref[] dst = new MyValue2.ref[8];
1348         for (int i = 1; i &lt; 8; ++i) {
1349             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1350         }
1351         test46(src, dst);
1352         verify(dst, src);
1353         if (!warmup) {
1354             Method m = tests.get(&quot;TestNullableArrays::test46&quot;);
1355             assertDeoptimizedByC2(m);
1356             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1357             test46(src, dst);
1358             verify(dst, src);
1359             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1360                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1361             }
1362         }
1363     }
1364 
1365     @Test
1366     public void test47(MyValue2.ref[] src, Object[] dst) {
1367         System.arraycopy(src, 0, dst, 0, 8);
1368     }
1369 
1370     @DontCompile
1371     public void test47_verifier(boolean warmup) {
1372         MyValue2.ref[] src = new MyValue2.ref[8];
1373         Object[] dst = new Object[8];
1374         for (int i = 1; i &lt; 8; ++i) {
1375             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1376         }
1377         test47(src, dst);
1378         verify(src, dst);
1379         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test47&quot;)) {
1380             test47(src, dst);
1381             verify(src, dst);
1382         }
1383     }
1384 
1385     @Test
1386     @Warmup(1) // Avoid early compilation
1387     public void test48(Object[] src, Object dst) {
1388         System.arraycopy(src, 0, dst, 0, 8);
1389     }
1390 
1391     @DontCompile
1392     public void test48_verifier(boolean warmup) {
1393         Object[] src = new Object[8];
1394         MyValue2.ref[] dst = new MyValue2.ref[8];
1395         for (int i = 1; i &lt; 8; ++i) {
1396             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1397         }
1398         test48(src, dst);
1399         verify(dst, src);
1400         if (!warmup) {
1401             Method m = tests.get(&quot;TestNullableArrays::test48&quot;);
1402             assertDeoptimizedByC2(m);
1403             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1404             test48(src, dst);
1405             verify(dst, src);
1406             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1407                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1408             }
1409         }
1410     }
1411 
1412     @Test
1413     public void test49(Object src, Object[] dst) {
1414         System.arraycopy(src, 0, dst, 0, 8);
1415     }
1416 
1417     @DontCompile
1418     public void test49_verifier(boolean warmup) {
1419         MyValue2.ref[] src = new MyValue2.ref[8];
1420         Object[] dst = new Object[8];
1421         for (int i = 1; i &lt; 8; ++i) {
1422             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1423         }
1424         test49(src, dst);
1425         verify(src, dst);
1426         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test49&quot;)) {
1427             test49(src, dst);
1428             verify(src, dst);
1429         }
1430     }
1431 
1432     @Test
1433     public void test50(Object[] src, Object[] dst) {
1434         System.arraycopy(src, 0, dst, 0, 8);
1435     }
1436 
1437     @DontCompile
1438     public void test50_verifier(boolean warmup) {
1439         Object[] src = new Object[8];
1440         Object[] dst = new Object[8];
1441         for (int i = 1; i &lt; 8; ++i) {
1442             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1443         }
1444         test50(src, dst);
1445         verify(src, dst);
1446         if (!warmup) {
1447             Method m = tests.get(&quot;TestNullableArrays::test50&quot;);
1448             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1449                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1450             }
1451         }
1452     }
1453 
1454     @Test
1455     public MyValue1.ref[] test51(MyValue1.ref[] va) {
1456         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1457     }
1458 
1459     @DontCompile
1460     public void test51_verifier(boolean warmup) {
1461         int len = Math.abs(rI) % 10;
1462         MyValue1.ref[] va = new MyValue1.ref[len];
1463         for (int i = 1; i &lt; len; ++i) {
1464             va[i] = testValue1;
1465         }
1466         MyValue1.ref[] result = test51(va);
1467         verify(va, result);
1468     }
1469 
1470     static final MyValue1.ref[] test52_va = new MyValue1.ref[8];
1471 
1472     @Test
1473     public MyValue1.ref[] test52() {
1474         return Arrays.copyOf(test52_va, 8, MyValue1.ref[].class);
1475     }
1476 
1477     @DontCompile
1478     public void test52_verifier(boolean warmup) {
1479         for (int i = 1; i &lt; 8; ++i) {
1480             test52_va[i] = testValue1;
1481         }
1482         MyValue1.ref[] result = test52();
1483         verify(test52_va, result);
1484     }
1485 
1486     @Test
1487     public MyValue1.ref[] test53(Object[] va) {
1488         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1489     }
1490 
1491     @DontCompile
1492     public void test53_verifier(boolean warmup) {
1493         int len = Math.abs(rI) % 10;
1494         MyValue1.ref[] va = new MyValue1.ref[len];
1495         for (int i = 1; i &lt; len; ++i) {
1496             va[i] = testValue1;
1497         }
1498         MyValue1.ref[] result = test53(va);
1499         verify(result, va);
1500     }
1501 
1502     @Test
1503     public Object[] test54(MyValue1.ref[] va) {
1504         return Arrays.copyOf(va, va.length, Object[].class);
1505     }
1506 
1507     @DontCompile
1508     public void test54_verifier(boolean warmup) {
1509         int len = Math.abs(rI) % 10;
1510         MyValue1.ref[] va = new MyValue1.ref[len];
1511         for (int i = 1; i &lt; len; ++i) {
1512             va[i] = testValue1;
1513         }
1514         Object[] result = test54(va);
1515         verify(va, result);
1516     }
1517 
1518     @Test
1519     public Object[] test55(Object[] va) {
1520         return Arrays.copyOf(va, va.length, Object[].class);
1521     }
1522 
1523     @DontCompile
1524     public void test55_verifier(boolean warmup) {
1525         int len = Math.abs(rI) % 10;
1526         MyValue1.ref[] va = new MyValue1.ref[len];
1527         for (int i = 1; i &lt; len; ++i) {
1528             va[i] = testValue1;
1529         }
1530         Object[] result = test55(va);
1531         verify(va, result);
1532     }
1533 
1534     @Test
1535     public MyValue1.ref[] test56(Object[] va) {
1536         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1537     }
1538 
1539     @DontCompile
1540     public void test56_verifier(boolean warmup) {
1541         int len = Math.abs(rI) % 10;
1542         Object[] va = new Object[len];
1543         for (int i = 1; i &lt; len; ++i) {
1544             va[i] = testValue1;
1545         }
1546         MyValue1.ref[] result = test56(va);
1547         verify(result, va);
1548     }
1549 
1550    @Test
1551     public Object[] test57(Object[] va, Class klass) {
1552         return Arrays.copyOf(va, va.length, klass);
1553     }
1554 
1555     @DontCompile
1556     public void test57_verifier(boolean warmup) {
1557         int len = Math.abs(rI) % 10;
1558         Object[] va = new MyValue1.ref[len];
1559         for (int i = 1; i &lt; len; ++i) {
1560             va[i] = testValue1;
1561         }
1562         Object[] result = test57(va, MyValue1.ref[].class);
1563         verify(va, result);
1564     }
1565 
1566     @Test
1567     public Object[] test58(MyValue1.ref[] va, Class klass) {
1568         return Arrays.copyOf(va, va.length, klass);
1569     }
1570 
1571     @DontCompile
1572     public void test58_verifier(boolean warmup) {
1573         int len = Math.abs(rI) % 10;
1574         MyValue1.ref[] va = new MyValue1.ref[len];
1575         for (int i = 1; i &lt; len; ++i) {
1576             va[i] = testValue1;
1577         }
1578         for (int i = 1; i &lt; 10; i++) {
1579             Object[] result = test58(va, MyValue1.ref[].class);
1580             verify(va, result);
1581         }
1582         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test58&quot;)) {
1583             Object[] result = test58(va, MyValue1.ref[].class);
1584             verify(va, result);
1585         }
1586     }
1587 
1588     @Test
1589     public Object[] test59(MyValue1.ref[] va) {
1590         return Arrays.copyOf(va, va.length+1, MyValue1.ref[].class);
1591     }
1592 
1593     @DontCompile
1594     public void test59_verifier(boolean warmup) {
1595         int len = Math.abs(rI) % 10;
1596         MyValue1.ref[] va = new MyValue1.ref[len];
1597         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1598         for (int i = 1; i &lt; len; ++i) {
1599             va[i] = testValue1;
1600             verif[i] = va[i];
1601         }
1602         Object[] result = test59(va);
1603         verify(verif, result);
1604     }
1605 
1606     @Test
1607     public Object[] test60(Object[] va, Class klass) {
1608         return Arrays.copyOf(va, va.length+1, klass);
1609     }
1610 
1611     @DontCompile
1612     public void test60_verifier(boolean warmup) {
1613         int len = Math.abs(rI) % 10;
1614         MyValue1.ref[] va = new MyValue1.ref[len];
1615         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1616         for (int i = 1; i &lt; len; ++i) {
1617             va[i] = testValue1;
1618             verif[i] = (MyValue1)va[i];
1619         }
1620         Object[] result = test60(va, MyValue1.ref[].class);
1621         verify(verif, result);
1622     }
1623 
1624     @Test
1625     public Object[] test61(Object[] va, Class klass) {
1626         return Arrays.copyOf(va, va.length+1, klass);
1627     }
1628 
1629     @DontCompile
1630     public void test61_verifier(boolean warmup) {
1631         int len = Math.abs(rI) % 10;
1632         Object[] va = new Integer[len];
1633         for (int i = 1; i &lt; len; ++i) {
1634             va[i] = new Integer(rI);
1635         }
1636         Object[] result = test61(va, Integer[].class);
1637         for (int i = 0; i &lt; va.length; ++i) {
1638             Asserts.assertEQ(va[i], result[i]);
1639         }
1640     }
1641 
1642     @ForceInline
1643     public Object[] test62_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1644         Object[] arr = null;
1645         if (i == 10) {
1646             arr = oa;
1647         } else {
1648             arr = va;
1649         }
1650         return arr;
1651     }
1652 
1653     @Test
1654     public Object[] test62(MyValue1.ref[] va, Integer[] oa) {
1655         int i = 0;
1656         for (; i &lt; 10; i++);
1657 
1658         Object[] arr = test62_helper(i, va, oa);
1659 
1660         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1661     }
1662 
1663     @DontCompile
1664     public void test62_verifier(boolean warmup) {
1665         int len = Math.abs(rI) % 10;
1666         MyValue1.ref[] va = new MyValue1.ref[len];
1667         Integer[] oa = new Integer[len];
1668         for (int i = 1; i &lt; len; ++i) {
1669             oa[i] = new Integer(rI);
1670         }
1671         test62_helper(42, va, oa);
1672         Object[] result = test62(va, oa);
1673         for (int i = 0; i &lt; va.length; ++i) {
1674             Asserts.assertEQ(oa[i], result[i]);
1675         }
1676     }
1677 
1678     @ForceInline
1679     public Object[] test63_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1680         Object[] arr = null;
1681         if (i == 10) {
1682             arr = va;
1683         } else {
1684             arr = oa;
1685         }
1686         return arr;
1687     }
1688 
1689     @Test
1690     public Object[] test63(MyValue1.ref[] va, Integer[] oa) {
1691         int i = 0;
1692         for (; i &lt; 10; i++);
1693 
1694         Object[] arr = test63_helper(i, va, oa);
1695 
1696         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1697     }
1698 
1699     @DontCompile
1700     public void test63_verifier(boolean warmup) {
1701         int len = Math.abs(rI) % 10;
1702         MyValue1.ref[] va = new MyValue1.ref[len];
1703         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1704         for (int i = 1; i &lt; len; ++i) {
1705             va[i] = testValue1;
1706             verif[i] = va[i];
1707         }
1708         Integer[] oa = new Integer[len];
1709         test63_helper(42, va, oa);
1710         Object[] result = test63(va, oa);
1711         verify(verif, result);
1712     }
1713 
1714     // Test default initialization of inline type arrays: small array
1715     @Test
1716     public MyValue1.ref[] test64() {
1717         return new MyValue1.ref[8];
1718     }
1719 
1720     @DontCompile
1721     public void test64_verifier(boolean warmup) {
1722         MyValue1.ref[] va = test64();
1723         for (int i = 0; i &lt; 8; ++i) {
1724             Asserts.assertEQ(va[i], null);
1725         }
1726     }
1727 
1728     // Test default initialization of inline type arrays: large array
1729     @Test
1730     public MyValue1.ref[] test65() {
1731         return new MyValue1.ref[32];
1732     }
1733 
1734     @DontCompile
1735     public void test65_verifier(boolean warmup) {
1736         MyValue1.ref[] va = test65();
1737         for (int i = 0; i &lt; 32; ++i) {
1738             Asserts.assertEQ(va[i], null);
1739         }
1740     }
1741 
1742     // Check init store elimination
1743     @Test(match = { ALLOCA }, matchCount = { 1 })
1744     public MyValue1.ref[] test66(MyValue1.ref vt) {
1745         MyValue1.ref[] va = new MyValue1.ref[1];
1746         va[0] = vt;
1747         return va;
1748     }
1749 
1750     @DontCompile
1751     public void test66_verifier(boolean warmup) {
1752         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
1753         MyValue1.ref[] va = test66(vt);
1754         Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
1755     }
1756 
1757     // Zeroing elimination and arraycopy
1758     @Test
1759     public MyValue1.ref[] test67(MyValue1.ref[] src) {
1760         MyValue1.ref[] dst = new MyValue1.ref[16];
1761         System.arraycopy(src, 0, dst, 0, 13);
1762         return dst;
1763     }
1764 
1765     @DontCompile
1766     public void test67_verifier(boolean warmup) {
1767         MyValue1.ref[] va = new MyValue1.ref[16];
1768         MyValue1.ref[] var = test67(va);
1769         for (int i = 0; i &lt; 16; ++i) {
1770             Asserts.assertEQ(var[i], null);
1771         }
1772     }
1773 
1774     // A store with a default value can be eliminated
1775     @Test
1776     public MyValue1.ref[] test68() {
1777         MyValue1.ref[] va = new MyValue1.ref[2];
1778         va[0] = va[1];
1779         return va;
1780     }
1781 
1782     @DontCompile
1783     public void test68_verifier(boolean warmup) {
1784         MyValue1.ref[] va = test68();
1785         for (int i = 0; i &lt; 2; ++i) {
1786             Asserts.assertEQ(va[i], null);
1787         }
1788     }
1789 
1790     // Requires individual stores to init array
1791     @Test
1792     public MyValue1.ref[] test69(MyValue1.ref vt) {
1793         MyValue1.ref[] va = new MyValue1.ref[4];
1794         va[0] = vt;
1795         va[3] = vt;
1796         return va;
1797     }
1798 
1799     @DontCompile
1800     public void test69_verifier(boolean warmup) {
1801         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
1802         MyValue1.ref[] va = new MyValue1.ref[4];
1803         va[0] = vt;
1804         va[3] = vt;
1805         MyValue1.ref[] var = test69(vt);
1806         for (int i = 0; i &lt; va.length; ++i) {
1807             Asserts.assertEQ(va[i], var[i]);
1808         }
1809     }
1810 
1811     // A store with a default value can be eliminated: same as test68
1812     // but store is farther away from allocation
1813     @Test
1814     public MyValue1.ref[] test70(MyValue1.ref[] other) {
1815         other[1] = other[0];
1816         MyValue1.ref[] va = new MyValue1.ref[2];
1817         other[0] = va[1];
1818         va[0] = va[1];
1819         return va;
1820     }
1821 
1822     @DontCompile
1823     public void test70_verifier(boolean warmup) {
1824         MyValue1.ref[] va = new MyValue1.ref[2];
1825         MyValue1.ref[] var = test70(va);
1826         for (int i = 0; i &lt; 2; ++i) {
1827             Asserts.assertEQ(va[i], var[i]);
1828         }
1829     }
1830 
1831     // EA needs to consider oop fields in flattened arrays
1832     @Test
1833     public void test71() {
1834         int len = 10;
1835         MyValue2.ref[] src = new MyValue2.ref[len];
1836         MyValue2.ref[] dst = new MyValue2.ref[len];
1837         for (int i = 1; i &lt; len; ++i) {
1838             src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
1839         }
1840         System.arraycopy(src, 0, dst, 0, src.length);
1841         for (int i = 0; i &lt; len; ++i) {
1842             if (src[i] == null) {
1843                 Asserts.assertEQ(dst[i], null);
1844             } else {
1845                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1846             }
1847         }
1848     }
1849 
1850     @DontCompile
1851     public void test71_verifier(boolean warmup) {
1852         test71();
1853     }
1854 
1855     // Test EA with leaf call to &#39;store_unknown_value&#39;
1856     @Test
1857     public void test72(Object[] o, boolean b, Object element) {
1858         Object[] arr1 = new Object[10];
1859         Object[] arr2 = new Object[10];
1860         if (b) {
1861             arr1 = o;
1862         }
1863         arr1[0] = element;
1864         arr2[0] = element;
1865     }
1866 
1867     @DontCompile
1868     public void test72_verifier(boolean warmup) {
1869         Object[] arr = new Object[1];
1870         Object elem = new Object();
1871         test72(arr, true, elem);
1872         test72(arr, false, elem);
1873     }
1874 
1875     @Test
1876     public void test73(Object[] oa, MyValue1.ref v, Object o) {
1877         // TestLWorld.test38 use a C1 Phi node for the array. This test
1878         // adds the case where the stored value is a C1 Phi node.
1879         Object o2 = (o == null) ? v : o;
1880         oa[0] = v;  // The stored value is known to be flattenable
1881         oa[1] = o;  // The stored value may be flattenable
1882         oa[2] = o2; // The stored value may be flattenable (a C1 Phi node)
1883         oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
1884     }
1885 
1886     @DontCompile
1887     public void test73_verifier(boolean warmup) {
1888         MyValue1.ref v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1889         MyValue1.ref v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1890         MyValue1.ref[] arr = new MyValue1.ref[3];
1891         try {
1892             test73(arr, v0, v1);
1893             throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
1894         } catch (ArrayStoreException t) {
1895             // expected
1896         }
1897         Asserts.assertEQ(arr[0].hash(), v0.hash());
1898         Asserts.assertEQ(arr[1].hash(), v1.hash());
1899         Asserts.assertEQ(arr[2].hash(), v1.hash());
1900     }
1901 
1902     // Some more array clone tests
1903     @ForceInline
1904     public Object[] test74_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1905         Object[] arr = null;
1906         if (i == 10) {
1907             arr = oa;
1908         } else {
1909             arr = va;
1910         }
1911         return arr;
1912     }
1913 
1914     @Test
1915     public Object[] test74(MyValue1.ref[] va, Integer[] oa) {
1916         int i = 0;
1917         for (; i &lt; 10; i++);
1918 
1919         Object[] arr = test74_helper(i, va, oa);
1920         return arr.clone();
1921     }
1922 
1923     @DontCompile
1924     public void test74_verifier(boolean warmup) {
1925         int len = Math.abs(rI) % 10;
1926         MyValue1.ref[] va = new MyValue1.ref[len];
1927         Integer[] oa = new Integer[len];
1928         for (int i = 1; i &lt; len; ++i) {
1929             oa[i] = new Integer(rI);
1930         }
1931         test74_helper(42, va, oa);
1932         Object[] result = test74(va, oa);
1933 
1934         for (int i = 0; i &lt; va.length; ++i) {
1935             Asserts.assertEQ(oa[i], result[i]);
1936             // Check that array has correct properties (null-ok)
1937             result[i] = null;
1938         }
1939     }
1940 
1941     @ForceInline
1942     public Object[] test75_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1943         Object[] arr = null;
1944         if (i == 10) {
1945             arr = va;
1946         } else {
1947             arr = oa;
1948         }
1949         return arr;
1950     }
1951 
1952     @Test
1953     public Object[] test75(MyValue1.ref[] va, Integer[] oa) {
1954         int i = 0;
1955         for (; i &lt; 10; i++);
1956 
1957         Object[] arr = test75_helper(i, va, oa);
1958         return arr.clone();
1959     }
1960 
1961     @DontCompile
1962     public void test75_verifier(boolean warmup) {
1963         int len = Math.abs(rI) % 10;
1964         MyValue1.ref[] va = new MyValue1.ref[len];
1965         MyValue1.ref[] verif = new MyValue1.ref[len];
1966         for (int i = 1; i &lt; len; ++i) {
1967             va[i] = testValue1;
1968             verif[i] = va[i];
1969         }
1970         Integer[] oa = new Integer[len];
1971         test75_helper(42, va, oa);
1972         Object[] result = test75(va, oa);
1973         verify(verif, result);
1974         if (len &gt; 0) {
1975             // Check that array has correct properties (null-ok)
1976             result[0] = null;
1977         }
1978     }
1979 
1980     // Test mixing nullable and non-nullable arrays
1981     @Test
1982     public Object[] test76(MyValue1[] vva, MyValue1.ref[] vba, MyValue1 vt, Object[] out, int n) {
1983         Object[] result = null;
1984         if (n == 0) {
1985             result = vva;
1986         } else if (n == 1) {
1987             result = vba;
1988         } else if (n == 2) {
1989             result = new MyValue1[42];
1990         } else if (n == 3) {
1991             result = new MyValue1.ref[42];
1992         }
1993         result[0] = vt;
1994         out[0] = result[1];
1995         return result;
1996     }
1997 
1998     @DontCompile
1999     public void test76_verifier(boolean warmup) {
2000         MyValue1 vt = testValue1;
2001         Object[] out = new Object[1];
2002         MyValue1[] vva = new MyValue1[42];
2003         MyValue1[] vva_r = new MyValue1[42];
2004         vva_r[0] = vt;
2005         MyValue1.ref[] vba = new MyValue1.ref[42];
2006         MyValue1.ref[] vba_r = new MyValue1.ref[42];
2007         vba_r[0] = vt;
2008         Object[] result = test76(vva, vba, vt, out, 0);
2009         verify(result, vva_r);
2010         Asserts.assertEQ(out[0], vva_r[1]);
2011         result = test76(vva, vba, vt, out, 1);
2012         verify(result, vba_r);
2013         Asserts.assertEQ(out[0], vba_r[1]);
2014         result = test76(vva, vba, vt, out, 2);
2015         verify(result, vva_r);
2016         Asserts.assertEQ(out[0], vva_r[1]);
2017         result = test76(vva, vba, vt, out, 3);
2018         verify(result, vba_r);
2019         Asserts.assertEQ(out[0], vba_r[1]);
2020     }
2021 
2022     @Test
2023     public Object[] test77(boolean b) {
2024         Object[] va;
2025         if (b) {
2026             va = new MyValue1.ref[5];
2027             for (int i = 0; i &lt; 5; ++i) {
2028                 va[i] = testValue1;
2029             }
2030         } else {
2031             va = new MyValue1[10];
2032             for (int i = 0; i &lt; 10; ++i) {
2033                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
2034             }
2035         }
2036         long sum = ((MyValue1)va[0]).hashInterpreted();
2037         if (b) {
2038             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
2039         } else {
2040             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
2041         }
2042         return va;
2043     }
2044 
2045     @DontCompile
2046     public void test77_verifier(boolean warmup) {
2047         Object[] va = test77(true);
2048         Asserts.assertEQ(va.length, 5);
2049         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI, hash()));
2050         for (int i = 1; i &lt; 5; ++i) {
2051             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash());
2052         }
2053         va = test77(false);
2054         Asserts.assertEQ(va.length, 10);
2055         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI + 1, hash(rI, rL) + 1));
2056         for (int i = 1; i &lt; 10; ++i) {
2057             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));
2058         }
2059     }
2060 
2061     // Same as test76 but with non inline type array cases
2062     @Test
2063     public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {
2064         Object[] result = null;
2065         if (n == 0) {
2066             result = vva;
2067         } else if (n == 1) {
2068             result = vba;
2069         } else if (n == 2) {
2070             result = new MyValue1[42];
2071         } else if (n == 3) {
2072             result = new MyValue1.ref[42];
2073         } else if (n == 4) {
2074             result = new Integer[42];
2075         }
2076         result[0] = val;
2077         out[0] = result[1];
2078         return result;
2079     }
2080 
2081     @DontCompile
2082     public void test78_verifier(boolean warmup) {
2083         MyValue1 vt = testValue1;
2084         Integer i = new Integer(42);
2085         Object[] out = new Object[1];
2086         MyValue1[] vva = new MyValue1[42];
2087         MyValue1[] vva_r = new MyValue1[42];
2088         vva_r[0] = vt;
2089         MyValue1.ref[] vba = new MyValue1.ref[42];
2090         MyValue1.ref[] vba_r = new MyValue1.ref[42];
2091         vba_r[0] = vt;
2092         Object[] result = test78(vva, vba, vt, out, 0);
2093         verify(result, vva_r);
2094         Asserts.assertEQ(out[0], vva_r[1]);
2095         result = test78(vva, vba, vt, out, 1);
2096         verify(result, vba_r);
2097         Asserts.assertEQ(out[0], vba_r[1]);
2098         result = test78(vva, vba, vt, out, 2);
2099         verify(result, vva_r);
2100         Asserts.assertEQ(out[0], vva_r[1]);
2101         result = test78(vva, vba, vt, out, 3);
2102         verify(result, vba_r);
2103         Asserts.assertEQ(out[0], vba_r[1]);
2104         result = test78(vva, vba, i, out, 4);
2105         Asserts.assertEQ(result[0], i);
2106         Asserts.assertEQ(out[0], null);
2107     }
2108 
2109     // Test widening conversions from [Q to [L
2110     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2111     public static MyValue1.ref[] test79(MyValue1[] va) {
2112         return va;
2113     }
2114 
2115     @DontCompile
2116     public void test79_verifier(boolean warmup) {
2117         MyValue1[] va = new MyValue1[1];
2118         va[0] = testValue1;
2119         MyValue1.ref[] res = test79(va);
2120         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2121         try {
2122             res[0] = null;
2123             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2124         } catch (NullPointerException npe) {
2125             // Expected
2126         }
2127         res[0] = testValue1;
2128         test79(null); // Should not throw NPE
2129     }
2130 
2131     // Same as test79 but with explicit cast and Object return
2132     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2133     public static Object[] test80(MyValue1[] va) {
2134         return (MyValue1.ref[])va;
2135     }
2136 
2137     @DontCompile
2138     public void test80_verifier(boolean warmup) {
2139         MyValue1[] va = new MyValue1[1];
2140         va[0] = testValue1;
2141         Object[] res = test80(va);
2142         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
2143         try {
2144             res[0] = null;
2145             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2146         } catch (NullPointerException npe) {
2147             // Expected
2148         }
2149         res[0] = testValue1;
2150         test80(null); // Should not throw NPE
2151     }
2152 
2153     // Test mixing widened and boxed array type
2154     @Test()
2155     public static long test81(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {
2156         MyValue1.ref[] result = b ? va1 : va2;
2157         try {
2158             result[0] = vt;
2159         } catch (NullPointerException npe) {
2160             // Ignored
2161         }
2162         return result[1].hash();
2163     }
2164 
2165     @DontCompile
2166     public void test81_verifier(boolean warmup) {
2167         MyValue1[] va = new MyValue1[2];
2168         MyValue1.ref[] vaB = new MyValue1.ref[2];
2169         va[1] = testValue1;
2170         vaB[1] = testValue1;
2171         long res = test81(va, vaB, testValue1, true, true);
2172         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2173         Asserts.assertEquals(res, testValue1.hash());
2174         res = test81(va, vaB, testValue1, false, false);
2175         Asserts.assertEquals(vaB[0].hash(), testValue1.hash());
2176         Asserts.assertEquals(res, testValue1.hash());
2177         res = test81(va, va, testValue1, false, true);
2178         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2179         Asserts.assertEquals(res, testValue1.hash());
2180     }
2181 
2182     // Same as test81 but more cases and null writes
2183     @Test()
2184     public static long test82(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt1, MyValue1.ref vt2, int i, boolean shouldThrow) {
2185         MyValue1.ref[] result = null;
2186         if (i == 0) {
2187             result = va1;
2188         } else if (i == 1) {
2189             result = va2;
2190         } else if (i == 2) {
2191             result = new MyValue1.ref[2];
2192             result[1] = vt1;
2193         } else if (i == 3) {
2194             result = new MyValue1[2];
2195             result[1] = vt1;
2196         }
2197         try {
2198             result[0] = (i &lt;= 1) ? null : vt2;
2199             if (shouldThrow) {
2200                 throw new RuntimeException(&quot;NullPointerException expected&quot;);
2201             }
2202         } catch (NullPointerException npe) {
2203             Asserts.assertTrue(shouldThrow, &quot;NullPointerException thrown&quot;);
2204         }
2205         result[0] = vt1;
2206         return result[1].hash();
2207     }
2208 
2209     @DontCompile
2210     public void test82_verifier(boolean warmup) {
2211         MyValue1[] va = new MyValue1[2];
2212         MyValue1.ref[] vaB = new MyValue1.ref[2];
2213         va[1] = testValue1;
2214         vaB[1] = testValue1;
2215         long res = test82(va, vaB, testValue1, testValue1, 0, true);
2216         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2217         Asserts.assertEquals(res, testValue1.hash());
2218         res = test82(va, vaB, testValue1, testValue1, 1, false);
2219         Asserts.assertEquals(vaB[0].hash(), testValue1.hash());
2220         Asserts.assertEquals(res, testValue1.hash());
2221         res = test82(va, va, testValue1, testValue1, 1, true);
2222         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2223         Asserts.assertEquals(res, testValue1.hash());
2224         res = test82(va, va, testValue1, null, 2, false);
2225         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2226         Asserts.assertEquals(res, testValue1.hash());
2227         res = test82(va, va, testValue1, null, 3, true);
2228         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2229         Asserts.assertEquals(res, testValue1.hash());
2230     }
2231 
2232     @Test(failOn = ALLOC + ALLOCA + STORE)
2233     public static long test83(MyValue1[] va) {
2234         MyValue1.ref[] result = va;
2235         return result[0].hash();
2236     }
2237 
2238     @DontCompile
2239     public void test83_verifier(boolean warmup) {
2240         MyValue1[] va = new MyValue1[42];
2241         va[0] = testValue1;
2242         long res = test83(va);
2243         Asserts.assertEquals(res, testValue1.hash());
2244     }
2245 
2246     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
2247     @Test(valid = InlineTypeArrayFlattenOff)
2248     public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {
2249         MyValue1.ref[] result = new MyValue1[2];
2250         result[0] = vt1;
2251         result[1] = vt2;
2252         return result;
2253     }
2254 
2255     @DontCompile
2256     public void test84_verifier(boolean warmup) {
2257         MyValue1.ref[] res = test84(testValue1, testValue1);
2258         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2259         Asserts.assertEquals(res[1].hash(), testValue1.hash());
2260         try {
2261             test84(testValue1, null);
2262             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2263         } catch (NullPointerException npe) {
2264             // Expected
2265         }
2266     }
2267 
2268     @Test()
2269     public static long test85(MyValue1.ref[] va, MyValue1 val) {
2270         va[0] = val;
2271         return va[1].hash();
2272     }
2273 
2274     @DontCompile
2275     public void test85_verifier(boolean warmup) {
2276         MyValue1[] va = new MyValue1[2];
2277         MyValue1.ref[] vab = new MyValue1.ref[2];
2278         va[1] = testValue1;
2279         vab[1] = testValue1;
2280         long res = test85(va, testValue1);
2281         Asserts.assertEquals(res, testValue1.hash());
2282         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2283         res = test85(vab, testValue1);
2284         Asserts.assertEquals(res, testValue1.hash());
2285         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2286     }
2287 
2288     // Same as test85 but with ref value
2289     @Test()
2290     public static long test86(MyValue1.ref[] va, MyValue1.ref val) {
2291         va[0] = val;
2292         return va[1].hash();
2293     }
2294 
2295     @DontCompile
2296     public void test86_verifier(boolean warmup) {
2297         MyValue1[] va = new MyValue1[2];
2298         MyValue1.ref[] vab = new MyValue1.ref[2];
2299         va[1] = testValue1;
2300         vab[1] = testValue1;
2301         long res = test86(va, testValue1);
2302         Asserts.assertEquals(res, testValue1.hash());
2303         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2304         try {
2305             test86(va, null);
2306             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2307         } catch (NullPointerException npe) {
2308             // Expected
2309         }
2310         res = test86(vab, testValue1);
2311         Asserts.assertEquals(res, testValue1.hash());
2312         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2313         res = test86(vab, null);
2314         Asserts.assertEquals(res, testValue1.hash());
2315         Asserts.assertEquals(vab[0], null);
2316     }
2317 
2318     // Test initialization of nullable array with constant
2319     @Test()
2320     public long test87() {
2321         MyValue1.ref[] va = new MyValue1.ref[1];
2322         va[0] = testValue1;
2323         return va[0].hash();
2324     }
2325 
2326     @DontCompile
2327     public void test87_verifier(boolean warmup) {
2328         long result = test87();
2329         Asserts.assertEQ(result, hash());
2330     }
2331 
2332     // Test narrowing conversion from [L to [Q
2333     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2334     public static MyValue1[] test88(MyValue1.ref[] va) {
2335         return (MyValue1[])va;
2336     }
2337 
2338     @DontCompile
2339     public void test88_verifier(boolean warmup) {
2340         MyValue1[] va = new MyValue1[1];
2341         va[0] = testValue1;
2342         MyValue1[] res = test88(va);
2343         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2344         res[0] = testValue1;
2345         test88(null); // Should not throw NPE
2346         try {
2347             test88(new MyValue1.ref[1]);
2348             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2349         } catch (ClassCastException cce) {
2350             // Expected
2351         }
2352     }
2353 
2354     // Same as test88 but with explicit cast and Object argument
2355     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2356     public static MyValue1[] test89(Object[] va) {
2357         return (MyValue1[])va;
2358     }
2359 
2360     @DontCompile
2361     public void test89_verifier(boolean warmup) {
2362         MyValue1[] va = new MyValue1[1];
2363         va[0] = testValue1;
2364         MyValue1[] res = test89(va);
2365         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
2366         res[0] = testValue1;
2367         test89(null); // Should not throw NPE
2368         try {
2369             test89(new MyValue1.ref[1]);
2370             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2371         } catch (ClassCastException cce) {
2372             // Expected
2373         }
2374     }
2375 
2376     // More cast tests
2377     @Test()
2378     public static MyValue1.ref[] test90(Object va) {
2379         return (MyValue1.ref[])va;
2380     }
2381 
2382     @DontCompile
2383     public void test90_verifier(boolean warmup) {
2384         MyValue1[] va = new MyValue1[1];
2385         MyValue1.ref[] vab = new MyValue1.ref[1];
2386         try {
2387           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
2388           test90(new Integer[0]);
2389         } catch (ClassCastException cce) {
2390           // Expected
2391         }
2392         test90(va);
2393         test90(vab);
2394         test90(null);
2395     }
2396 
2397     @Test()
2398     public static MyValue1.ref[] test91(Object[] va) {
2399         return (MyValue1.ref[])va;
2400     }
2401 
2402     @DontCompile
2403     public void test91_verifier(boolean warmup) {
2404         MyValue1[] va = new MyValue1[1];
2405         MyValue1.ref[] vab = new MyValue1.ref[1];
2406         try {
2407           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
2408           test91(new Integer[0]);
2409         } catch (ClassCastException cce) {
2410           // Expected
2411         }
2412         test91(va);
2413         test91(vab);
2414         test91(null);
2415     }
2416 
2417     // Test if arraycopy intrinsic correctly checks for flattened source array
2418     @Test()
2419     public static void test92(MyValue1.ref[] src, MyValue1.ref[] dst) {
2420         System.arraycopy(src, 0, dst, 0, 2);
2421     }
2422 
2423     @DontCompile
2424     public void test92_verifier(boolean warmup) {
2425         MyValue1[]  va = new MyValue1[2];
2426         MyValue1.ref[] vab = new MyValue1.ref[2];
2427         va[0] = testValue1;
2428         vab[0] = testValue1;
2429         test92(va, vab);
2430         Asserts.assertEquals(va[0], vab[0]);
2431         Asserts.assertEquals(va[1], vab[1]);
2432     }
2433 
2434     @Test()
2435     public static void test93(Object src, MyValue1.ref[] dst) {
2436         System.arraycopy(src, 0, dst, 0, 2);
2437     }
2438 
2439     @DontCompile
2440     public void test93_verifier(boolean warmup) {
2441         MyValue1[]  va = new MyValue1[2];
2442         MyValue1.ref[] vab = new MyValue1.ref[2];
2443         va[0] = testValue1;
2444         vab[0] = testValue1;
2445         test93(va, vab);
2446         Asserts.assertEquals(va[0], vab[0]);
2447         Asserts.assertEquals(va[1], vab[1]);
2448     }
2449 
2450     // Test non-escaping allocation with arraycopy
2451     // that does not modify loaded array element.
2452     @Test()
2453     public static long test94() {
2454         MyValue1.ref[] src = new MyValue1.ref[8];
2455         MyValue1[]  dst = new MyValue1[8];
2456         for (int i = 1; i &lt; 8; ++i) {
2457             src[i] = testValue1;
2458         }
2459         System.arraycopy(src, 1, dst, 2, 6);
2460         return dst[0].hash();
2461     }
2462 
2463     @DontCompile
2464     public static void test94_verifier(boolean warmup) {
2465         long result = test94();
2466         Asserts.assertEquals(result, MyValue1.default.hash());
2467     }
2468 
2469     // Test meeting constant TypeInstPtr with InlineTypeNode
2470     @ForceInline
2471     public long test95_callee() {
2472         MyValue1.ref[] va = new MyValue1.ref[1];
2473         va[0] = testValue1;
2474         return va[0].hashInterpreted();
2475     }
2476 
2477     @Test()
2478     @Warmup(0)
2479     public long test95() {
2480         return test95_callee();
2481     }
2482 
2483     @DontCompile
2484     public void test95_verifier(boolean warmup) {
2485         long result = test95();
2486         Asserts.assertEQ(result, hash());
2487     }
2488 
2489     // Matrix multiplication test to exercise type flow analysis with nullable inline type arrays
2490     inline static class Complex {
2491         private final double re;
2492         private final double im;
2493 
2494         Complex(double re, double im) {
2495             this.re = re;
2496             this.im = im;
2497         }
2498 
2499         public Complex add(Complex that) {
2500             return new Complex(this.re + that.re, this.im + that.im);
2501         }
2502 
2503         public Complex mul(Complex that) {
2504             return new Complex(this.re * that.re - this.im * that.im,
2505                                this.re * that.im + this.im * that.re);
2506         }
2507     }
2508 
2509     @Test()
2510     public Complex.ref[][] test96(Complex.ref[][] A, Complex.ref[][] B) {
2511         int size = A.length;
2512         Complex.ref[][] R = new Complex.ref[size][size];
2513         for (int i = 0; i &lt; size; i++) {
2514             for (int k = 0; k &lt; size; k++) {
2515                 Complex.ref aik = A[i][k];
2516                 for (int j = 0; j &lt; size; j++) {
2517                     R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));
2518                 }
2519             }
2520         }
2521         return R;
2522     }
2523 
2524     static Complex.ref[][] test96_A = new Complex.ref[10][10];
2525     static Complex.ref[][] test96_B = new Complex.ref[10][10];
2526     static Complex.ref[][] test96_R;
2527 
2528     static {
2529         for (int i = 0; i &lt; 10; i++) {
2530             for (int j = 0; j &lt; 10; j++) {
2531                 test96_A[i][j] = new Complex(rI, rI);
2532                 test96_B[i][j] = new Complex(rI, rI);
2533             }
2534         }
2535     }
2536 
2537     @DontCompile
2538     public void test96_verifier(boolean warmup) {
2539         Complex.ref[][] result = test96(test96_A, test96_B);
2540         if (test96_R == null) {
2541             test96_R = result;
2542         }
2543         for (int i = 0; i &lt; 10; i++) {
2544             for (int j = 0; j &lt; 10; j++) {
2545                 Asserts.assertEQ(result[i][j], test96_R[i][j]);
2546             }
2547         }
2548     }
2549 
2550     // Test loads from vararg arrays
2551     @Test(failOn = LOAD_UNKNOWN_INLINE)
2552     public static Object test97(Object... args) {
2553         return args[0];
2554     }
2555 
2556     @DontCompile
2557     public static void test97_verifier(boolean warmup) {
2558         Object obj = new Object();
2559         Object result = test97(obj);
2560         Asserts.assertEquals(result, obj);
2561         Integer[] myInt = new Integer[1];
2562         myInt[0] = rI;
2563         result = test97((Object[])myInt);
2564         Asserts.assertEquals(result, rI);
2565     }
2566 
2567     @Test()
2568     public static Object test98(Object... args) {
2569         return args[0];
2570     }
2571 
2572     @DontCompile
2573     public static void test98_verifier(boolean warmup) {
2574         Object obj = new Object();
2575         Object result = test98(obj);
2576         Asserts.assertEquals(result, obj);
2577         Integer[] myInt = new Integer[1];
2578         myInt[0] = rI;
2579         result = test98((Object[])myInt);
2580         Asserts.assertEquals(result, rI);
2581         if (!warmup) {
2582             MyValue1[] va = new MyValue1[1];
2583             MyValue1.ref[] vab = new MyValue1.ref[1];
2584             result = test98((Object[])va);
2585             Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());
2586             result = test98((Object[])vab);
2587             Asserts.assertEquals(result, null);
2588         }
2589     }
2590 
2591     @Test()
2592     public static Object test99(Object... args) {
2593         return args[0];
2594     }
2595 
2596     @DontCompile
2597     public static void test99_verifier(boolean warmup) {
2598         Object obj = new Object();
2599         Object result = test99(obj);
2600         Asserts.assertEquals(result, obj);
2601         Integer[] myInt = new Integer[1];
2602         myInt[0] = rI;
2603         result = test99((Object[])myInt);
2604         Asserts.assertEquals(result, rI);
2605         if (!warmup) {
2606             try {
2607                 test99((Object[])null);
2608                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2609             } catch (NullPointerException npe) {
2610                 // Expected
2611             }
2612         }
2613     }
2614 
2615     @Test()
2616     public static Object test100(Object... args) {
2617         return args[0];
2618     }
2619 
2620     @DontCompile
2621     public static void test100_verifier(boolean warmup) {
2622         Object obj = new Object();
2623         Object result = test100(obj);
2624         Asserts.assertEquals(result, obj);
2625         Integer[] myInt = new Integer[1];
2626         myInt[0] = rI;
2627         result = test100((Object[])myInt);
2628         Asserts.assertEquals(result, rI);
2629         if (!warmup) {
2630             try {
2631                 test100();
2632                 throw new RuntimeException(&quot;No AIOOBE thrown&quot;);
2633             } catch (ArrayIndexOutOfBoundsException aioobe) {
2634                 // Expected
2635             }
2636         }
2637     }
2638 
2639     // Test stores to varag arrays
2640     @Test(failOn = STORE_UNKNOWN_INLINE)
2641     public static void test101(Object val, Object... args) {
2642         args[0] = val;
2643     }
2644 
2645     @DontCompile
2646     public static void test101_verifier(boolean warmup) {
2647         Object obj = new Object();
2648         test101(obj, obj);
2649         Integer[] myInt = new Integer[1];
2650         test101(rI, (Object[])myInt);
2651         Asserts.assertEquals(myInt[0], rI);
2652         test101(null, (Object[])myInt);
2653         Asserts.assertEquals(myInt[0], null);
2654     }
2655 
2656     @Test()
2657     public static void test102(Object val, Object... args) {
2658         args[0] = val;
2659     }
2660 
2661     @DontCompile
2662     public static void test102_verifier(boolean warmup) {
2663         Object obj = new Object();
2664         test102(obj, obj);
2665         Integer[] myInt = new Integer[1];
2666         test102(rI, (Object[])myInt);
2667         Asserts.assertEquals(myInt[0], rI);
2668         test102(null, (Object[])myInt);
2669         Asserts.assertEquals(myInt[0], null);
2670         if (!warmup) {
2671             MyValue1[] va = new MyValue1[1];
2672             MyValue1.ref[] vab = new MyValue1.ref[1];
2673             test102(testValue1, (Object[])va);
2674             Asserts.assertEquals(va[0].hash(), testValue1.hash());
2675             test102(testValue1, (Object[])vab);
2676             Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2677             test102(null, (Object[])vab);
2678             Asserts.assertEquals(vab[0], null);
2679         }
2680     }
2681 
2682     @Test()
2683     public static void test103(Object val, Object... args) {
2684         args[0] = val;
2685     }
2686 
2687     @DontCompile
2688     public static void test103_verifier(boolean warmup) {
2689         Object obj = new Object();
2690         test103(obj, obj);
2691         Integer[] myInt = new Integer[1];
2692         test103(rI, (Object[])myInt);
2693         Asserts.assertEquals(myInt[0], rI);
2694         test103(null, (Object[])myInt);
2695         Asserts.assertEquals(myInt[0], null);
2696         if (!warmup) {
2697             MyValue1[] va = new MyValue1[1];
2698             try {
2699                 test103(null, (Object[])va);
2700                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2701             } catch (NullPointerException npe) {
2702                 // Expected
2703             }
2704         }
2705     }
2706 
2707     @Test()
2708     public static void test104(Object val, Object... args) {
2709         args[0] = val;
2710     }
2711 
2712     @DontCompile
2713     public static void test104_verifier(boolean warmup) {
2714         Object obj = new Object();
2715         test104(obj, obj);
2716         Integer[] myInt = new Integer[1];
2717         test104(rI, (Object[])myInt);
2718         Asserts.assertEquals(myInt[0], rI);
2719         test104(null, (Object[])myInt);
2720         Asserts.assertEquals(myInt[0], null);
2721         if (!warmup) {
2722             try {
2723                 test104(testValue1);
2724                 throw new RuntimeException(&quot;No AIOOBE thrown&quot;);
2725             } catch (ArrayIndexOutOfBoundsException aioobe) {
2726                 // Expected
2727             }
2728         }
2729     }
2730 
2731     @Test()
2732     public static void test105(Object val, Object... args) {
2733         args[0] = val;
2734     }
2735 
2736     @DontCompile
2737     public static void test105_verifier(boolean warmup) {
2738         Object obj = new Object();
2739         test105(obj, obj);
2740         Integer[] myInt = new Integer[1];
2741         test105(rI, (Object[])myInt);
2742         Asserts.assertEquals(myInt[0], rI);
2743         test105(null, (Object[])myInt);
2744         Asserts.assertEquals(myInt[0], null);
2745         if (!warmup) {
2746             try {
2747                 test105(testValue1, (Object[])null);
2748                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2749             } catch (NullPointerException npe) {
2750                 // Expected
2751             }
2752         }
2753     }
2754 
2755     @Test()
2756     public static Object[] test106(Object[] dst, Object... args) {
2757         // Access array to speculate on non-flatness
2758         if (args[0] == null) {
2759             args[0] = testValue1;
2760         }
2761         System.arraycopy(args, 0, dst, 0, args.length);
2762         System.arraycopy(dst, 0, args, 0, dst.length);
2763         Object[] clone = args.clone();
2764         if (clone[0] == null) {
2765             throw new RuntimeException(&quot;Unexpected null&quot;);
2766         }
2767         return Arrays.copyOf(args, args.length, Object[].class);
2768     }
2769 
2770     @DontCompile
2771     public static void test106_verifier(boolean warmup) {
2772         Object[] dst = new Object[1];
2773         Object obj = new Object();
2774         Object[] result = test106(dst, obj);
2775         Asserts.assertEquals(result[0], obj);
2776         Integer[] myInt = new Integer[1];
2777         myInt[0] = rI;
2778         result = test106(myInt, (Object[])myInt);
2779         Asserts.assertEquals(result[0], rI);
2780         if (!warmup) {
2781             MyValue1[] va = new MyValue1[1];
2782             MyValue1.ref[] vab = new MyValue1.ref[1];
2783             result = test106(va, (Object[])va);
2784             Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());
2785             result = test106(vab, (Object[])vab);
2786             Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());
2787         }
2788     }
2789 
2790     // Test that allocation is not replaced by non-dominating allocation
2791     public long test107_helper(MyValue1.ref[] va, MyValue1 vt) {
2792         try {
2793             va[0] = vt;
2794         } catch (NullPointerException npe) { }
2795         return va[1].hash();
2796     }
2797 
2798     @Test()
2799     public void test107() {
2800         MyValue1[] va = new MyValue1[2];
2801         MyValue1.ref[] tmp = new MyValue1.ref[2];
2802         long res1 = test107_helper(va, testValue1);
2803         long res2 = test107_helper(va, testValue1);
2804         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2805         Asserts.assertEquals(res1, MyValue1.default.hash());
2806         Asserts.assertEquals(res2, MyValue1.default.hash());
2807     }
2808 
2809     @DontCompile
2810     public void test107_verifier(boolean warmup) {
2811         test107();
2812     }
2813 
2814 
2815     @Test
2816     @Warmup(10000)
2817     public Object test108(MyValue1.ref[] src, boolean flag) {
2818         MyValue1.ref[] dst = new MyValue1.ref[8];
2819         System.arraycopy(src, 1, dst, 2, 6);
2820         if (flag) {} // uncommon trap
2821         return dst[2];
2822     }
2823 
2824     @DontCompile
2825     public void test108_verifier(boolean warmup) {
2826         MyValue1.ref[] src = new MyValue1.ref[8];
2827         test108(src, !warmup);
2828     }
2829 
2830 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciTypeFlow.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciConstant.hpp&quot;
  27 #include &quot;ci/ciField.hpp&quot;
<a name="1" id="anc1"></a>
  28 #include &quot;ci/ciMethod.hpp&quot;
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciStreams.hpp&quot;
  32 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  33 #include &quot;ci/ciTypeFlow.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed">  34 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  35 #include &quot;compiler/compileLog.hpp&quot;
  36 #include &quot;interpreter/bytecode.hpp&quot;
  37 #include &quot;interpreter/bytecodes.hpp&quot;
  38 #include &quot;memory/allocation.inline.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;opto/compile.hpp&quot;
  42 #include &quot;opto/node.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;utilities/growableArray.hpp&quot;
  45 
  46 // ciTypeFlow::JsrSet
  47 //
  48 // A JsrSet represents some set of JsrRecords.  This class
  49 // is used to record a set of all jsr routines which we permit
  50 // execution to return (ret) from.
  51 //
  52 // During abstract interpretation, JsrSets are used to determine
  53 // whether two paths which reach a given block are unique, and
  54 // should be cloned apart, or are compatible, and should merge
  55 // together.
  56 
  57 // ------------------------------------------------------------------
  58 // ciTypeFlow::JsrSet::JsrSet
  59 ciTypeFlow::JsrSet::JsrSet(Arena* arena, int default_len) {
  60   if (arena != NULL) {
  61     // Allocate growable array in Arena.
  62     _set = new (arena) GrowableArray&lt;JsrRecord*&gt;(arena, default_len, 0, NULL);
  63   } else {
  64     // Allocate growable array in current ResourceArea.
  65     _set = new GrowableArray&lt;JsrRecord*&gt;(4, 0, NULL);
  66   }
  67 }
  68 
  69 // ------------------------------------------------------------------
  70 // ciTypeFlow::JsrSet::copy_into
  71 void ciTypeFlow::JsrSet::copy_into(JsrSet* jsrs) {
  72   int len = size();
  73   jsrs-&gt;_set-&gt;clear();
  74   for (int i = 0; i &lt; len; i++) {
  75     jsrs-&gt;_set-&gt;append(_set-&gt;at(i));
  76   }
  77 }
  78 
  79 // ------------------------------------------------------------------
  80 // ciTypeFlow::JsrSet::is_compatible_with
  81 //
  82 // !!!! MISGIVINGS ABOUT THIS... disregard
  83 //
  84 // Is this JsrSet compatible with some other JsrSet?
  85 //
  86 // In set-theoretic terms, a JsrSet can be viewed as a partial function
  87 // from entry addresses to return addresses.  Two JsrSets A and B are
  88 // compatible iff
  89 //
  90 //   For any x,
  91 //   A(x) defined and B(x) defined implies A(x) == B(x)
  92 //
  93 // Less formally, two JsrSets are compatible when they have identical
  94 // return addresses for any entry addresses they share in common.
  95 bool ciTypeFlow::JsrSet::is_compatible_with(JsrSet* other) {
  96   // Walk through both sets in parallel.  If the same entry address
  97   // appears in both sets, then the return address must match for
  98   // the sets to be compatible.
  99   int size1 = size();
 100   int size2 = other-&gt;size();
 101 
 102   // Special case.  If nothing is on the jsr stack, then there can
 103   // be no ret.
 104   if (size2 == 0) {
 105     return true;
 106   } else if (size1 != size2) {
 107     return false;
 108   } else {
 109     for (int i = 0; i &lt; size1; i++) {
 110       JsrRecord* record1 = record_at(i);
 111       JsrRecord* record2 = other-&gt;record_at(i);
 112       if (record1-&gt;entry_address() != record2-&gt;entry_address() ||
 113           record1-&gt;return_address() != record2-&gt;return_address()) {
 114         return false;
 115       }
 116     }
 117     return true;
 118   }
 119 
 120 #if 0
 121   int pos1 = 0;
 122   int pos2 = 0;
 123   int size1 = size();
 124   int size2 = other-&gt;size();
 125   while (pos1 &lt; size1 &amp;&amp; pos2 &lt; size2) {
 126     JsrRecord* record1 = record_at(pos1);
 127     JsrRecord* record2 = other-&gt;record_at(pos2);
 128     int entry1 = record1-&gt;entry_address();
 129     int entry2 = record2-&gt;entry_address();
 130     if (entry1 &lt; entry2) {
 131       pos1++;
 132     } else if (entry1 &gt; entry2) {
 133       pos2++;
 134     } else {
 135       if (record1-&gt;return_address() == record2-&gt;return_address()) {
 136         pos1++;
 137         pos2++;
 138       } else {
 139         // These two JsrSets are incompatible.
 140         return false;
 141       }
 142     }
 143   }
 144   // The two JsrSets agree.
 145   return true;
 146 #endif
 147 }
 148 
 149 // ------------------------------------------------------------------
 150 // ciTypeFlow::JsrSet::insert_jsr_record
 151 //
 152 // Insert the given JsrRecord into the JsrSet, maintaining the order
 153 // of the set and replacing any element with the same entry address.
 154 void ciTypeFlow::JsrSet::insert_jsr_record(JsrRecord* record) {
 155   int len = size();
 156   int entry = record-&gt;entry_address();
 157   int pos = 0;
 158   for ( ; pos &lt; len; pos++) {
 159     JsrRecord* current = record_at(pos);
 160     if (entry == current-&gt;entry_address()) {
 161       // Stomp over this entry.
 162       _set-&gt;at_put(pos, record);
 163       assert(size() == len, &quot;must be same size&quot;);
 164       return;
 165     } else if (entry &lt; current-&gt;entry_address()) {
 166       break;
 167     }
 168   }
 169 
 170   // Insert the record into the list.
 171   JsrRecord* swap = record;
 172   JsrRecord* temp = NULL;
 173   for ( ; pos &lt; len; pos++) {
 174     temp = _set-&gt;at(pos);
 175     _set-&gt;at_put(pos, swap);
 176     swap = temp;
 177   }
 178   _set-&gt;append(swap);
 179   assert(size() == len+1, &quot;must be larger&quot;);
 180 }
 181 
 182 // ------------------------------------------------------------------
 183 // ciTypeFlow::JsrSet::remove_jsr_record
 184 //
 185 // Remove the JsrRecord with the given return address from the JsrSet.
 186 void ciTypeFlow::JsrSet::remove_jsr_record(int return_address) {
 187   int len = size();
 188   for (int i = 0; i &lt; len; i++) {
 189     if (record_at(i)-&gt;return_address() == return_address) {
 190       // We have found the proper entry.  Remove it from the
 191       // JsrSet and exit.
 192       for (int j = i+1; j &lt; len ; j++) {
 193         _set-&gt;at_put(j-1, _set-&gt;at(j));
 194       }
 195       _set-&gt;trunc_to(len-1);
 196       assert(size() == len-1, &quot;must be smaller&quot;);
 197       return;
 198     }
 199   }
 200   assert(false, &quot;verify: returning from invalid subroutine&quot;);
 201 }
 202 
 203 // ------------------------------------------------------------------
 204 // ciTypeFlow::JsrSet::apply_control
 205 //
 206 // Apply the effect of a control-flow bytecode on the JsrSet.  The
 207 // only bytecodes that modify the JsrSet are jsr and ret.
 208 void ciTypeFlow::JsrSet::apply_control(ciTypeFlow* analyzer,
 209                                        ciBytecodeStream* str,
 210                                        ciTypeFlow::StateVector* state) {
 211   Bytecodes::Code code = str-&gt;cur_bc();
 212   if (code == Bytecodes::_jsr) {
 213     JsrRecord* record =
 214       analyzer-&gt;make_jsr_record(str-&gt;get_dest(), str-&gt;next_bci());
 215     insert_jsr_record(record);
 216   } else if (code == Bytecodes::_jsr_w) {
 217     JsrRecord* record =
 218       analyzer-&gt;make_jsr_record(str-&gt;get_far_dest(), str-&gt;next_bci());
 219     insert_jsr_record(record);
 220   } else if (code == Bytecodes::_ret) {
 221     Cell local = state-&gt;local(str-&gt;get_index());
 222     ciType* return_address = state-&gt;type_at(local);
 223     assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
 224     if (size() == 0) {
 225       // Ret-state underflow:  Hit a ret w/o any previous jsrs.  Bail out.
 226       // This can happen when a loop is inside a finally clause (4614060).
 227       analyzer-&gt;record_failure(&quot;OSR in finally clause&quot;);
 228       return;
 229     }
 230     remove_jsr_record(return_address-&gt;as_return_address()-&gt;bci());
 231   }
 232 }
 233 
 234 #ifndef PRODUCT
 235 // ------------------------------------------------------------------
 236 // ciTypeFlow::JsrSet::print_on
 237 void ciTypeFlow::JsrSet::print_on(outputStream* st) const {
 238   st-&gt;print(&quot;{ &quot;);
 239   int num_elements = size();
 240   if (num_elements &gt; 0) {
 241     int i = 0;
 242     for( ; i &lt; num_elements - 1; i++) {
 243       _set-&gt;at(i)-&gt;print_on(st);
 244       st-&gt;print(&quot;, &quot;);
 245     }
 246     _set-&gt;at(i)-&gt;print_on(st);
 247     st-&gt;print(&quot; &quot;);
 248   }
 249   st-&gt;print(&quot;}&quot;);
 250 }
 251 #endif
 252 
 253 // ciTypeFlow::StateVector
 254 //
 255 // A StateVector summarizes the type information at some point in
 256 // the program.
 257 
 258 // ------------------------------------------------------------------
 259 // ciTypeFlow::StateVector::type_meet
 260 //
 261 // Meet two types.
 262 //
 263 // The semi-lattice of types use by this analysis are modeled on those
 264 // of the verifier.  The lattice is as follows:
 265 //
 266 //        top_type() &gt;= all non-extremal types &gt;= bottom_type
 267 //                             and
 268 //   Every primitive type is comparable only with itself.  The meet of
 269 //   reference types is determined by their kind: instance class,
 270 //   interface, or array class.  The meet of two types of the same
 271 //   kind is their least common ancestor.  The meet of two types of
 272 //   different kinds is always java.lang.Object.
 273 ciType* ciTypeFlow::StateVector::type_meet_internal(ciType* t1, ciType* t2, ciTypeFlow* analyzer) {
 274   assert(t1 != t2, &quot;checked in caller&quot;);
 275   if (t1-&gt;equals(top_type())) {
 276     return t2;
 277   } else if (t2-&gt;equals(top_type())) {
 278     return t1;
 279   } else if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {
 280     // Special case null_type.  null_type meet any reference type T
 281     // is T (except for inline types).  null_type meet null_type is null_type.
 282     if (t1-&gt;equals(null_type())) {
<a name="3" id="anc3"></a><span class="line-modified"> 283       if (t2-&gt;is_valuetype()) {</span>
 284         // Inline types are null-free, return the super type
<a name="4" id="anc4"></a><span class="line-modified"> 285         return t2-&gt;as_value_klass()-&gt;super();</span>
 286       } else if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {
 287         return t2;
 288       }
 289     } else if (t2-&gt;equals(null_type())) {
<a name="5" id="anc5"></a><span class="line-modified"> 290       if (t1-&gt;is_valuetype()) {</span>
 291         // Inline types are null-free, return the super type
<a name="6" id="anc6"></a><span class="line-modified"> 292         return t1-&gt;as_value_klass()-&gt;super();</span>
 293       } else if (!t1-&gt;is_primitive_type()) {
 294         return t1;
 295       }
 296     }
 297 
 298     // At least one of the two types is a non-top primitive type.
 299     // The other type is not equal to it.  Fall to bottom.
 300     return bottom_type();
 301   }
 302 
 303   // Both types are non-top non-primitive types.  That is,
 304   // both types are either instanceKlasses or arrayKlasses.
 305   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();
 306   ciKlass* k1 = t1-&gt;as_klass();
 307   ciKlass* k2 = t2-&gt;as_klass();
 308   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {
 309     return object_klass;
 310   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {
 311     // Unloaded classes fall to java.lang.Object at a merge.
 312     return object_klass;
 313   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {
 314     // When an interface meets a non-interface, we get Object;
 315     // This is what the verifier does.
 316     return object_klass;
 317   } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {
 318     // When an array meets a non-array, we get Object.
<a name="7" id="anc7"></a><span class="line-modified"> 319     // When (obj/value)Array meets typeArray, we also get Object.</span>
 320     // And when typeArray meets different typeArray, we again get Object.
<a name="8" id="anc8"></a><span class="line-modified"> 321     // But when (obj/value)Array meets (obj/value)Array, we look carefully at element types.</span>
<span class="line-modified"> 322     if ((k1-&gt;is_obj_array_klass() || k1-&gt;is_value_array_klass()) &amp;&amp;</span>
<span class="line-modified"> 323         (k2-&gt;is_obj_array_klass() || k2-&gt;is_value_array_klass())) {</span>
 324       ciType* elem1 = k1-&gt;as_array_klass()-&gt;element_klass();
 325       ciType* elem2 = k2-&gt;as_array_klass()-&gt;element_klass();
 326       ciType* elem = elem1;
 327       if (elem1 != elem2) {
 328         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();
 329       }
 330       // Do an easy shortcut if one type is a super of the other.
 331       if (elem == elem1) {
 332         assert(k1 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 333         return k1;
 334       } else if (elem == elem2) {
 335         assert(k2 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 336         return k2;
 337       } else {
 338         return ciArrayKlass::make(elem);
 339       }
 340     } else {
 341       return object_klass;
 342     }
 343   } else {
 344     // Must be two plain old instance klasses.
 345     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 346     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 347     return k1-&gt;least_common_ancestor(k2);
 348   }
 349 }
 350 
 351 
 352 // ------------------------------------------------------------------
 353 // ciTypeFlow::StateVector::StateVector
 354 //
 355 // Build a new state vector
 356 ciTypeFlow::StateVector::StateVector(ciTypeFlow* analyzer) {
 357   _outer = analyzer;
 358   _stack_size = -1;
 359   _monitor_count = -1;
 360   // Allocate the _types array
 361   int max_cells = analyzer-&gt;max_cells();
 362   _types = (ciType**)analyzer-&gt;arena()-&gt;Amalloc(sizeof(ciType*) * max_cells);
 363   for (int i=0; i&lt;max_cells; i++) {
 364     _types[i] = top_type();
 365   }
 366   _trap_bci = -1;
 367   _trap_index = 0;
 368   _def_locals.clear();
 369 }
 370 
 371 
 372 // ------------------------------------------------------------------
 373 // ciTypeFlow::get_start_state
 374 //
 375 // Set this vector to the method entry state.
 376 const ciTypeFlow::StateVector* ciTypeFlow::get_start_state() {
 377   StateVector* state = new StateVector(this);
 378   if (is_osr_flow()) {
 379     ciTypeFlow* non_osr_flow = method()-&gt;get_flow_analysis();
 380     if (non_osr_flow-&gt;failing()) {
 381       record_failure(non_osr_flow-&gt;failure_reason());
 382       return NULL;
 383     }
 384     JsrSet* jsrs = new JsrSet(NULL, 16);
 385     Block* non_osr_block = non_osr_flow-&gt;existing_block_at(start_bci(), jsrs);
 386     if (non_osr_block == NULL) {
 387       record_failure(&quot;cannot reach OSR point&quot;);
 388       return NULL;
 389     }
 390     // load up the non-OSR state at this point
 391     non_osr_block-&gt;copy_state_into(state);
 392     int non_osr_start = non_osr_block-&gt;start();
 393     if (non_osr_start != start_bci()) {
 394       // must flow forward from it
 395       if (CITraceTypeFlow) {
 396         tty-&gt;print_cr(&quot;&gt;&gt; Interpreting pre-OSR block %d:&quot;, non_osr_start);
 397       }
 398       Block* block = block_at(non_osr_start, jsrs);
 399       assert(block-&gt;limit() == start_bci(), &quot;must flow forward to start&quot;);
 400       flow_block(block, state, jsrs);
 401     }
 402     return state;
 403     // Note:  The code below would be an incorrect for an OSR flow,
 404     // even if it were possible for an OSR entry point to be at bci zero.
 405   }
 406   // &quot;Push&quot; the method signature into the first few locals.
 407   state-&gt;set_stack_size(-max_locals());
 408   if (!method()-&gt;is_static()) {
 409     state-&gt;push(method()-&gt;holder());
 410     assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
 411   }
 412   for (ciSignatureStream str(method()-&gt;signature());
 413        !str.at_return_type();
 414        str.next()) {
 415     state-&gt;push_translate(str.type());
 416   }
 417   // Set the rest of the locals to bottom.
 418   Cell cell = state-&gt;next_cell(state-&gt;tos());
 419   state-&gt;set_stack_size(0);
 420   int limit = state-&gt;limit_cell();
 421   for (; cell &lt; limit; cell = state-&gt;next_cell(cell)) {
 422     state-&gt;set_type_at(cell, state-&gt;bottom_type());
 423   }
 424   // Lock an object, if necessary.
 425   state-&gt;set_monitor_count(method()-&gt;is_synchronized() ? 1 : 0);
 426   return state;
 427 }
 428 
 429 // ------------------------------------------------------------------
 430 // ciTypeFlow::StateVector::copy_into
 431 //
 432 // Copy our value into some other StateVector
 433 void ciTypeFlow::StateVector::copy_into(ciTypeFlow::StateVector* copy)
 434 const {
 435   copy-&gt;set_stack_size(stack_size());
 436   copy-&gt;set_monitor_count(monitor_count());
 437   Cell limit = limit_cell();
 438   for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 439     copy-&gt;set_type_at(c, type_at(c));
 440   }
 441 }
 442 
 443 // ------------------------------------------------------------------
 444 // ciTypeFlow::StateVector::meet
 445 //
 446 // Meets this StateVector with another, destructively modifying this
 447 // one.  Returns true if any modification takes place.
 448 bool ciTypeFlow::StateVector::meet(const ciTypeFlow::StateVector* incoming) {
 449   if (monitor_count() == -1) {
 450     set_monitor_count(incoming-&gt;monitor_count());
 451   }
 452   assert(monitor_count() == incoming-&gt;monitor_count(), &quot;monitors must match&quot;);
 453 
 454   if (stack_size() == -1) {
 455     set_stack_size(incoming-&gt;stack_size());
 456     Cell limit = limit_cell();
 457     #ifdef ASSERT
 458     { for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 459         assert(type_at(c) == top_type(), &quot;&quot;);
 460     } }
 461     #endif
 462     // Make a simple copy of the incoming state.
 463     for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 464       set_type_at(c, incoming-&gt;type_at(c));
 465     }
 466     return true;  // it is always different the first time
 467   }
 468 #ifdef ASSERT
 469   if (stack_size() != incoming-&gt;stack_size()) {
 470     _outer-&gt;method()-&gt;print_codes();
 471     tty-&gt;print_cr(&quot;!!!! Stack size conflict&quot;);
 472     tty-&gt;print_cr(&quot;Current state:&quot;);
 473     print_on(tty);
 474     tty-&gt;print_cr(&quot;Incoming state:&quot;);
 475     ((StateVector*)incoming)-&gt;print_on(tty);
 476   }
 477 #endif
 478   assert(stack_size() == incoming-&gt;stack_size(), &quot;sanity&quot;);
 479 
 480   bool different = false;
 481   Cell limit = limit_cell();
 482   for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 483     ciType* t1 = type_at(c);
 484     ciType* t2 = incoming-&gt;type_at(c);
 485     if (!t1-&gt;equals(t2)) {
 486       ciType* new_type = type_meet(t1, t2);
 487       if (!t1-&gt;equals(new_type)) {
 488         set_type_at(c, new_type);
 489         different = true;
 490       }
 491     }
 492   }
 493   return different;
 494 }
 495 
 496 // ------------------------------------------------------------------
 497 // ciTypeFlow::StateVector::meet_exception
 498 //
 499 // Meets this StateVector with another, destructively modifying this
 500 // one.  The incoming state is coming via an exception.  Returns true
 501 // if any modification takes place.
 502 bool ciTypeFlow::StateVector::meet_exception(ciInstanceKlass* exc,
 503                                      const ciTypeFlow::StateVector* incoming) {
 504   if (monitor_count() == -1) {
 505     set_monitor_count(incoming-&gt;monitor_count());
 506   }
 507   assert(monitor_count() == incoming-&gt;monitor_count(), &quot;monitors must match&quot;);
 508 
 509   if (stack_size() == -1) {
 510     set_stack_size(1);
 511   }
 512 
 513   assert(stack_size() ==  1, &quot;must have one-element stack&quot;);
 514 
 515   bool different = false;
 516 
 517   // Meet locals from incoming array.
 518   Cell limit = local(_outer-&gt;max_locals()-1);
 519   for (Cell c = start_cell(); c &lt;= limit; c = next_cell(c)) {
 520     ciType* t1 = type_at(c);
 521     ciType* t2 = incoming-&gt;type_at(c);
 522     if (!t1-&gt;equals(t2)) {
 523       ciType* new_type = type_meet(t1, t2);
 524       if (!t1-&gt;equals(new_type)) {
 525         set_type_at(c, new_type);
 526         different = true;
 527       }
 528     }
 529   }
 530 
 531   // Handle stack separately.  When an exception occurs, the
 532   // only stack entry is the exception instance.
 533   ciType* tos_type = type_at_tos();
 534   if (!tos_type-&gt;equals(exc)) {
 535     ciType* new_type = type_meet(tos_type, exc);
 536     if (!tos_type-&gt;equals(new_type)) {
 537       set_type_at_tos(new_type);
 538       different = true;
 539     }
 540   }
 541 
 542   return different;
 543 }
 544 
 545 // ------------------------------------------------------------------
 546 // ciTypeFlow::StateVector::push_translate
 547 void ciTypeFlow::StateVector::push_translate(ciType* type) {
 548   BasicType basic_type = type-&gt;basic_type();
 549   if (basic_type == T_BOOLEAN || basic_type == T_CHAR ||
 550       basic_type == T_BYTE    || basic_type == T_SHORT) {
 551     push_int();
 552   } else {
 553     push(type);
 554     if (type-&gt;is_two_word()) {
 555       push(half_type(type));
 556     }
 557   }
 558 }
 559 
 560 // ------------------------------------------------------------------
 561 // ciTypeFlow::StateVector::do_aload
 562 void ciTypeFlow::StateVector::do_aload(ciBytecodeStream* str) {
 563   pop_int();
<a name="9" id="anc9"></a><span class="line-modified"> 564   ciArrayKlass* array_klass = pop_objOrValueArray();</span>
 565   if (array_klass == NULL) {
 566     // Did aload on a null reference; push a null and ignore the exception.
 567     // This instruction will never continue normally.  All we have to do
 568     // is report a value that will meet correctly with any downstream
 569     // reference types on paths that will truly be executed.  This null type
 570     // meets with any reference type to yield that same reference type.
 571     // (The compiler will generate an unconditional exception here.)
 572     push(null_type());
 573     return;
 574   }
 575   if (!array_klass-&gt;is_loaded()) {
 576     // Only fails for some -Xcomp runs
 577     trap(str, array_klass,
 578          Deoptimization::make_trap_request
 579          (Deoptimization::Reason_unloaded,
 580           Deoptimization::Action_reinterpret));
 581     return;
 582   }
 583   ciKlass* element_klass = array_klass-&gt;element_klass();
 584   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 585     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 586     trap(str, element_klass,
 587          Deoptimization::make_trap_request
 588          (Deoptimization::Reason_unloaded,
 589           Deoptimization::Action_reinterpret));
 590   } else {
 591     push_object(element_klass);
 592   }
 593 }
 594 
 595 
 596 // ------------------------------------------------------------------
 597 // ciTypeFlow::StateVector::do_checkcast
 598 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 599   bool will_link;
 600   ciKlass* klass = str-&gt;get_klass(will_link);
 601   if (!will_link) {
 602     if (str-&gt;is_inline_klass()) {
 603       trap(str, klass,
 604            Deoptimization::make_trap_request
 605            (Deoptimization::Reason_unloaded,
 606             Deoptimization::Action_reinterpret));
 607     } else {
 608       // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.
 609       // Type flow after this block may still be needed in two situations:
 610       // 1) C2 uses do_null_assert() and continues compilation for later blocks
 611       // 2) C2 does an OSR compile in a later block (see bug 4778368).
 612       pop_object();
 613       do_null_assert(klass);
 614     }
 615   } else {
 616     pop_object();
 617     push_object(klass);
 618   }
 619 }
 620 
 621 // ------------------------------------------------------------------
 622 // ciTypeFlow::StateVector::do_getfield
 623 void ciTypeFlow::StateVector::do_getfield(ciBytecodeStream* str) {
 624   // could add assert here for type of object.
 625   pop_object();
 626   do_getstatic(str);
 627 }
 628 
 629 // ------------------------------------------------------------------
 630 // ciTypeFlow::StateVector::do_getstatic
 631 void ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream* str) {
 632   bool will_link;
 633   ciField* field = str-&gt;get_field(will_link);
 634   if (!will_link) {
 635     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 636   } else {
 637     ciType* field_type = field-&gt;type();
 638     if (!field_type-&gt;is_loaded()) {
 639       // Normally, we need the field&#39;s type to be loaded if we are to
 640       // do anything interesting with its value.
 641       // We used to do this:  trap(str, str-&gt;get_field_signature_index());
 642       //
 643       // There is one good reason not to trap here.  Execution can
 644       // get past this &quot;getfield&quot; or &quot;getstatic&quot; if the value of
 645       // the field is null.  As long as the value is null, the class
 646       // does not need to be loaded!  The compiler must assume that
 647       // the value of the unloaded class reference is null; if the code
 648       // ever sees a non-null value, loading has occurred.
 649       //
 650       // This actually happens often enough to be annoying.  If the
 651       // compiler throws an uncommon trap at this bytecode, you can
 652       // get an endless loop of recompilations, when all the code
 653       // needs to do is load a series of null values.  Also, a trap
 654       // here can make an OSR entry point unreachable, triggering the
 655       // assert on non_osr_block in ciTypeFlow::get_start_state.
 656       // (See bug 4379915.)
 657       do_null_assert(field_type-&gt;as_klass());
 658     } else {
 659       push_translate(field_type);
 660     }
 661   }
 662 }
 663 
 664 // ------------------------------------------------------------------
 665 // ciTypeFlow::StateVector::do_invoke
 666 void ciTypeFlow::StateVector::do_invoke(ciBytecodeStream* str,
 667                                         bool has_receiver) {
 668   bool will_link;
 669   ciSignature* declared_signature = NULL;
 670   ciMethod* callee = str-&gt;get_method(will_link, &amp;declared_signature);
 671   assert(declared_signature != NULL, &quot;cannot be null&quot;);
 672   if (!will_link) {
 673     // We weren&#39;t able to find the method.
 674     if (str-&gt;cur_bc() == Bytecodes::_invokedynamic) {
 675       trap(str, NULL,
 676            Deoptimization::make_trap_request
 677            (Deoptimization::Reason_uninitialized,
 678             Deoptimization::Action_reinterpret));
 679     } else {
 680       ciKlass* unloaded_holder = callee-&gt;holder();
 681       trap(str, unloaded_holder, str-&gt;get_method_holder_index());
 682     }
 683   } else {
 684     // We are using the declared signature here because it might be
 685     // different from the callee signature (Cf. invokedynamic and
 686     // invokehandle).
 687     ciSignatureStream sigstr(declared_signature);
 688     const int arg_size = declared_signature-&gt;size();
 689     const int stack_base = stack_size() - arg_size;
 690     int i = 0;
 691     for( ; !sigstr.at_return_type(); sigstr.next()) {
 692       ciType* type = sigstr.type();
 693       ciType* stack_type = type_at(stack(stack_base + i++));
 694       // Do I want to check this type?
 695       // assert(stack_type-&gt;is_subtype_of(type), &quot;bad type for field value&quot;);
 696       if (type-&gt;is_two_word()) {
 697         ciType* stack_type2 = type_at(stack(stack_base + i++));
 698         assert(stack_type2-&gt;equals(half_type(type)), &quot;must be 2nd half&quot;);
 699       }
 700     }
 701     assert(arg_size == i, &quot;must match&quot;);
 702     for (int j = 0; j &lt; arg_size; j++) {
 703       pop();
 704     }
 705     if (has_receiver) {
 706       // Check this?
 707       pop_object();
 708     }
 709     assert(!sigstr.is_done(), &quot;must have return type&quot;);
 710     ciType* return_type = sigstr.type();
 711     if (!return_type-&gt;is_void()) {
 712       if (!return_type-&gt;is_loaded()) {
 713         // As in do_getstatic(), generally speaking, we need the return type to
 714         // be loaded if we are to do anything interesting with its value.
 715         // We used to do this:  trap(str, str-&gt;get_method_signature_index());
 716         //
 717         // We do not trap here since execution can get past this invoke if
 718         // the return value is null.  As long as the value is null, the class
 719         // does not need to be loaded!  The compiler must assume that
 720         // the value of the unloaded class reference is null; if the code
 721         // ever sees a non-null value, loading has occurred.
 722         //
 723         // See do_getstatic() for similar explanation, as well as bug 4684993.
 724         do_null_assert(return_type-&gt;as_klass());
 725       } else {
 726         push_translate(return_type);
 727       }
 728     }
 729   }
 730 }
 731 
 732 // ------------------------------------------------------------------
 733 // ciTypeFlow::StateVector::do_jsr
 734 void ciTypeFlow::StateVector::do_jsr(ciBytecodeStream* str) {
 735   push(ciReturnAddress::make(str-&gt;next_bci()));
 736 }
 737 
 738 // ------------------------------------------------------------------
 739 // ciTypeFlow::StateVector::do_ldc
 740 void ciTypeFlow::StateVector::do_ldc(ciBytecodeStream* str) {
 741   ciConstant con = str-&gt;get_constant();
 742   BasicType basic_type = con.basic_type();
 743   if (basic_type == T_ILLEGAL) {
 744     // OutOfMemoryError in the CI while loading constant
 745     push_null();
 746     outer()-&gt;record_failure(&quot;ldc did not link&quot;);
 747     return;
 748   }
 749   if (is_reference_type(basic_type)) {
 750     ciObject* obj = con.as_object();
 751     if (obj-&gt;is_null_object()) {
 752       push_null();
 753     } else {
 754       assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
 755       push_object(obj-&gt;klass());
 756     }
 757   } else {
 758     push_translate(ciType::make(basic_type));
 759   }
 760 }
 761 
 762 // ------------------------------------------------------------------
 763 // ciTypeFlow::StateVector::do_multianewarray
 764 void ciTypeFlow::StateVector::do_multianewarray(ciBytecodeStream* str) {
 765   int dimensions = str-&gt;get_dimensions();
 766   bool will_link;
 767   ciArrayKlass* array_klass = str-&gt;get_klass(will_link)-&gt;as_array_klass();
 768   if (!will_link) {
 769     trap(str, array_klass, str-&gt;get_klass_index());
 770   } else {
 771     for (int i = 0; i &lt; dimensions; i++) {
 772       pop_int();
 773     }
 774     push_object(array_klass);
 775   }
 776 }
 777 
 778 // ------------------------------------------------------------------
 779 // ciTypeFlow::StateVector::do_new
 780 void ciTypeFlow::StateVector::do_new(ciBytecodeStream* str) {
 781   bool will_link;
 782   ciKlass* klass = str-&gt;get_klass(will_link);
 783   if (!will_link || str-&gt;is_unresolved_klass()) {
 784     trap(str, klass, str-&gt;get_klass_index());
 785   } else {
 786     push_object(klass);
 787   }
 788 }
 789 
 790 // ------------------------------------------------------------------
 791 // ciTypeFlow::StateVector::do_defaultvalue
 792 void ciTypeFlow::StateVector::do_defaultvalue(ciBytecodeStream* str) {
 793   bool will_link;
 794   ciKlass* klass = str-&gt;get_klass(will_link);
 795   if (!will_link) {
 796     trap(str, klass, str-&gt;get_klass_index());
 797   } else {
<a name="10" id="anc10"></a><span class="line-modified"> 798     assert(klass-&gt;is_valuetype(), &quot;should be value type&quot;);</span>
 799     push_object(klass);
 800   }
 801 }
 802 
 803 // ------------------------------------------------------------------
 804 // ciTypeFlow::StateVector::do_withfield
 805 void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {
 806   bool will_link;
 807   ciField* field = str-&gt;get_field(will_link);
 808   ciKlass* klass = field-&gt;holder();
 809   if (!will_link) {
 810     trap(str, klass, str-&gt;get_field_holder_index());
 811   } else {
 812     ciType* type = pop_value();
 813     ciType* field_type = field-&gt;type();
 814     assert(field_type-&gt;is_loaded(), &quot;field type must be loaded&quot;);
 815     if (field_type-&gt;is_two_word()) {
 816       ciType* type2 = pop_value();
 817       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 818       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 819     }
 820     pop_object();
<a name="11" id="anc11"></a><span class="line-modified"> 821     assert(klass-&gt;is_valuetype(), &quot;should be value type&quot;);</span>
 822     push_object(klass);
 823   }
 824 }
 825 
 826 // ------------------------------------------------------------------
 827 // ciTypeFlow::StateVector::do_newarray
 828 void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
 829   pop_int();
 830   ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
 831   push_object(klass);
 832 }
 833 
 834 // ------------------------------------------------------------------
 835 // ciTypeFlow::StateVector::do_putfield
 836 void ciTypeFlow::StateVector::do_putfield(ciBytecodeStream* str) {
 837   do_putstatic(str);
 838   if (_trap_bci != -1)  return;  // unloaded field holder, etc.
 839   // could add assert here for type of object.
 840   pop_object();
 841 }
 842 
 843 // ------------------------------------------------------------------
 844 // ciTypeFlow::StateVector::do_putstatic
 845 void ciTypeFlow::StateVector::do_putstatic(ciBytecodeStream* str) {
 846   bool will_link;
 847   ciField* field = str-&gt;get_field(will_link);
 848   if (!will_link) {
 849     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 850   } else {
 851     ciType* field_type = field-&gt;type();
 852     ciType* type = pop_value();
 853     // Do I want to check this type?
 854     //      assert(type-&gt;is_subtype_of(field_type), &quot;bad type for field value&quot;);
 855     if (field_type-&gt;is_two_word()) {
 856       ciType* type2 = pop_value();
 857       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 858       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 859     }
 860   }
 861 }
 862 
 863 // ------------------------------------------------------------------
 864 // ciTypeFlow::StateVector::do_ret
 865 void ciTypeFlow::StateVector::do_ret(ciBytecodeStream* str) {
 866   Cell index = local(str-&gt;get_index());
 867 
 868   ciType* address = type_at(index);
 869   assert(address-&gt;is_return_address(), &quot;bad return address&quot;);
 870   set_type_at(index, bottom_type());
 871 }
 872 
 873 // ------------------------------------------------------------------
 874 // ciTypeFlow::StateVector::trap
 875 //
 876 // Stop interpretation of this path with a trap.
 877 void ciTypeFlow::StateVector::trap(ciBytecodeStream* str, ciKlass* klass, int index) {
 878   _trap_bci = str-&gt;cur_bci();
 879   _trap_index = index;
 880 
 881   // Log information about this trap:
 882   CompileLog* log = outer()-&gt;env()-&gt;log();
 883   if (log != NULL) {
 884     int mid = log-&gt;identify(outer()-&gt;method());
 885     int kid = (klass == NULL)? -1: log-&gt;identify(klass);
 886     log-&gt;begin_elem(&quot;uncommon_trap method=&#39;%d&#39; bci=&#39;%d&#39;&quot;, mid, str-&gt;cur_bci());
 887     char buf[100];
 888     log-&gt;print(&quot; %s&quot;, Deoptimization::format_trap_request(buf, sizeof(buf),
 889                                                           index));
 890     if (kid &gt;= 0)
 891       log-&gt;print(&quot; klass=&#39;%d&#39;&quot;, kid);
 892     log-&gt;end_elem();
 893   }
 894 }
 895 
 896 // ------------------------------------------------------------------
 897 // ciTypeFlow::StateVector::do_null_assert
 898 // Corresponds to graphKit::do_null_assert.
 899 void ciTypeFlow::StateVector::do_null_assert(ciKlass* unloaded_klass) {
 900   if (unloaded_klass-&gt;is_loaded()) {
 901     // We failed to link, but we can still compute with this class,
 902     // since it is loaded somewhere.  The compiler will uncommon_trap
 903     // if the object is not null, but the typeflow pass can not assume
 904     // that the object will be null, otherwise it may incorrectly tell
 905     // the parser that an object is known to be null. 4761344, 4807707
 906     push_object(unloaded_klass);
 907   } else {
 908     // The class is not loaded anywhere.  It is safe to model the
 909     // null in the typestates, because we can compile in a null check
 910     // which will deoptimize us if someone manages to load the
 911     // class later.
 912     push_null();
 913   }
 914 }
 915 
 916 
 917 // ------------------------------------------------------------------
 918 // ciTypeFlow::StateVector::apply_one_bytecode
 919 //
 920 // Apply the effect of one bytecode to this StateVector
 921 bool ciTypeFlow::StateVector::apply_one_bytecode(ciBytecodeStream* str) {
 922   _trap_bci = -1;
 923   _trap_index = 0;
 924 
 925   if (CITraceTypeFlow) {
 926     tty-&gt;print_cr(&quot;&gt;&gt; Interpreting bytecode %d:%s&quot;, str-&gt;cur_bci(),
 927                   Bytecodes::name(str-&gt;cur_bc()));
 928   }
 929 
 930   switch(str-&gt;cur_bc()) {
 931   case Bytecodes::_aaload: do_aload(str);                           break;
 932 
 933   case Bytecodes::_aastore:
 934     {
 935       pop_object();
 936       pop_int();
<a name="12" id="anc12"></a><span class="line-modified"> 937       pop_objOrValueArray();</span>
 938       break;
 939     }
 940   case Bytecodes::_aconst_null:
 941     {
 942       push_null();
 943       break;
 944     }
 945   case Bytecodes::_aload:   load_local_object(str-&gt;get_index());    break;
 946   case Bytecodes::_aload_0: load_local_object(0);                   break;
 947   case Bytecodes::_aload_1: load_local_object(1);                   break;
 948   case Bytecodes::_aload_2: load_local_object(2);                   break;
 949   case Bytecodes::_aload_3: load_local_object(3);                   break;
 950 
 951   case Bytecodes::_anewarray:
 952     {
 953       pop_int();
 954       bool will_link;
 955       ciKlass* element_klass = str-&gt;get_klass(will_link);
 956       if (!will_link) {
 957         trap(str, element_klass, str-&gt;get_klass_index());
 958       } else {
 959         push_object(ciArrayKlass::make(element_klass));
 960       }
 961       break;
 962     }
 963   case Bytecodes::_areturn:
 964   case Bytecodes::_ifnonnull:
 965   case Bytecodes::_ifnull:
 966     {
 967       pop_object();
 968       break;
 969     }
 970   case Bytecodes::_monitorenter:
 971     {
 972       pop_object();
 973       set_monitor_count(monitor_count() + 1);
 974       break;
 975     }
 976   case Bytecodes::_monitorexit:
 977     {
 978       pop_object();
 979       assert(monitor_count() &gt; 0, &quot;must be a monitor to exit from&quot;);
 980       set_monitor_count(monitor_count() - 1);
 981       break;
 982     }
 983   case Bytecodes::_arraylength:
 984     {
 985       pop_array();
 986       push_int();
 987       break;
 988     }
 989   case Bytecodes::_astore:   store_local_object(str-&gt;get_index());  break;
 990   case Bytecodes::_astore_0: store_local_object(0);                 break;
 991   case Bytecodes::_astore_1: store_local_object(1);                 break;
 992   case Bytecodes::_astore_2: store_local_object(2);                 break;
 993   case Bytecodes::_astore_3: store_local_object(3);                 break;
 994 
 995   case Bytecodes::_athrow:
 996     {
 997       NEEDS_CLEANUP;
 998       pop_object();
 999       break;
1000     }
1001   case Bytecodes::_baload:
1002   case Bytecodes::_caload:
1003   case Bytecodes::_iaload:
1004   case Bytecodes::_saload:
1005     {
1006       pop_int();
1007       ciTypeArrayKlass* array_klass = pop_typeArray();
1008       // Put assert here for right type?
1009       push_int();
1010       break;
1011     }
1012   case Bytecodes::_bastore:
1013   case Bytecodes::_castore:
1014   case Bytecodes::_iastore:
1015   case Bytecodes::_sastore:
1016     {
1017       pop_int();
1018       pop_int();
1019       pop_typeArray();
1020       // assert here?
1021       break;
1022     }
1023   case Bytecodes::_bipush:
1024   case Bytecodes::_iconst_m1:
1025   case Bytecodes::_iconst_0:
1026   case Bytecodes::_iconst_1:
1027   case Bytecodes::_iconst_2:
1028   case Bytecodes::_iconst_3:
1029   case Bytecodes::_iconst_4:
1030   case Bytecodes::_iconst_5:
1031   case Bytecodes::_sipush:
1032     {
1033       push_int();
1034       break;
1035     }
1036   case Bytecodes::_checkcast: do_checkcast(str);                  break;
1037 
1038   case Bytecodes::_d2f:
1039     {
1040       pop_double();
1041       push_float();
1042       break;
1043     }
1044   case Bytecodes::_d2i:
1045     {
1046       pop_double();
1047       push_int();
1048       break;
1049     }
1050   case Bytecodes::_d2l:
1051     {
1052       pop_double();
1053       push_long();
1054       break;
1055     }
1056   case Bytecodes::_dadd:
1057   case Bytecodes::_ddiv:
1058   case Bytecodes::_dmul:
1059   case Bytecodes::_drem:
1060   case Bytecodes::_dsub:
1061     {
1062       pop_double();
1063       pop_double();
1064       push_double();
1065       break;
1066     }
1067   case Bytecodes::_daload:
1068     {
1069       pop_int();
1070       ciTypeArrayKlass* array_klass = pop_typeArray();
1071       // Put assert here for right type?
1072       push_double();
1073       break;
1074     }
1075   case Bytecodes::_dastore:
1076     {
1077       pop_double();
1078       pop_int();
1079       pop_typeArray();
1080       // assert here?
1081       break;
1082     }
1083   case Bytecodes::_dcmpg:
1084   case Bytecodes::_dcmpl:
1085     {
1086       pop_double();
1087       pop_double();
1088       push_int();
1089       break;
1090     }
1091   case Bytecodes::_dconst_0:
1092   case Bytecodes::_dconst_1:
1093     {
1094       push_double();
1095       break;
1096     }
1097   case Bytecodes::_dload:   load_local_double(str-&gt;get_index());    break;
1098   case Bytecodes::_dload_0: load_local_double(0);                   break;
1099   case Bytecodes::_dload_1: load_local_double(1);                   break;
1100   case Bytecodes::_dload_2: load_local_double(2);                   break;
1101   case Bytecodes::_dload_3: load_local_double(3);                   break;
1102 
1103   case Bytecodes::_dneg:
1104     {
1105       pop_double();
1106       push_double();
1107       break;
1108     }
1109   case Bytecodes::_dreturn:
1110     {
1111       pop_double();
1112       break;
1113     }
1114   case Bytecodes::_dstore:   store_local_double(str-&gt;get_index());  break;
1115   case Bytecodes::_dstore_0: store_local_double(0);                 break;
1116   case Bytecodes::_dstore_1: store_local_double(1);                 break;
1117   case Bytecodes::_dstore_2: store_local_double(2);                 break;
1118   case Bytecodes::_dstore_3: store_local_double(3);                 break;
1119 
1120   case Bytecodes::_dup:
1121     {
1122       push(type_at_tos());
1123       break;
1124     }
1125   case Bytecodes::_dup_x1:
1126     {
1127       ciType* value1 = pop_value();
1128       ciType* value2 = pop_value();
1129       push(value1);
1130       push(value2);
1131       push(value1);
1132       break;
1133     }
1134   case Bytecodes::_dup_x2:
1135     {
1136       ciType* value1 = pop_value();
1137       ciType* value2 = pop_value();
1138       ciType* value3 = pop_value();
1139       push(value1);
1140       push(value3);
1141       push(value2);
1142       push(value1);
1143       break;
1144     }
1145   case Bytecodes::_dup2:
1146     {
1147       ciType* value1 = pop_value();
1148       ciType* value2 = pop_value();
1149       push(value2);
1150       push(value1);
1151       push(value2);
1152       push(value1);
1153       break;
1154     }
1155   case Bytecodes::_dup2_x1:
1156     {
1157       ciType* value1 = pop_value();
1158       ciType* value2 = pop_value();
1159       ciType* value3 = pop_value();
1160       push(value2);
1161       push(value1);
1162       push(value3);
1163       push(value2);
1164       push(value1);
1165       break;
1166     }
1167   case Bytecodes::_dup2_x2:
1168     {
1169       ciType* value1 = pop_value();
1170       ciType* value2 = pop_value();
1171       ciType* value3 = pop_value();
1172       ciType* value4 = pop_value();
1173       push(value2);
1174       push(value1);
1175       push(value4);
1176       push(value3);
1177       push(value2);
1178       push(value1);
1179       break;
1180     }
1181   case Bytecodes::_f2d:
1182     {
1183       pop_float();
1184       push_double();
1185       break;
1186     }
1187   case Bytecodes::_f2i:
1188     {
1189       pop_float();
1190       push_int();
1191       break;
1192     }
1193   case Bytecodes::_f2l:
1194     {
1195       pop_float();
1196       push_long();
1197       break;
1198     }
1199   case Bytecodes::_fadd:
1200   case Bytecodes::_fdiv:
1201   case Bytecodes::_fmul:
1202   case Bytecodes::_frem:
1203   case Bytecodes::_fsub:
1204     {
1205       pop_float();
1206       pop_float();
1207       push_float();
1208       break;
1209     }
1210   case Bytecodes::_faload:
1211     {
1212       pop_int();
1213       ciTypeArrayKlass* array_klass = pop_typeArray();
1214       // Put assert here.
1215       push_float();
1216       break;
1217     }
1218   case Bytecodes::_fastore:
1219     {
1220       pop_float();
1221       pop_int();
1222       ciTypeArrayKlass* array_klass = pop_typeArray();
1223       // Put assert here.
1224       break;
1225     }
1226   case Bytecodes::_fcmpg:
1227   case Bytecodes::_fcmpl:
1228     {
1229       pop_float();
1230       pop_float();
1231       push_int();
1232       break;
1233     }
1234   case Bytecodes::_fconst_0:
1235   case Bytecodes::_fconst_1:
1236   case Bytecodes::_fconst_2:
1237     {
1238       push_float();
1239       break;
1240     }
1241   case Bytecodes::_fload:   load_local_float(str-&gt;get_index());     break;
1242   case Bytecodes::_fload_0: load_local_float(0);                    break;
1243   case Bytecodes::_fload_1: load_local_float(1);                    break;
1244   case Bytecodes::_fload_2: load_local_float(2);                    break;
1245   case Bytecodes::_fload_3: load_local_float(3);                    break;
1246 
1247   case Bytecodes::_fneg:
1248     {
1249       pop_float();
1250       push_float();
1251       break;
1252     }
1253   case Bytecodes::_freturn:
1254     {
1255       pop_float();
1256       break;
1257     }
1258   case Bytecodes::_fstore:    store_local_float(str-&gt;get_index());   break;
1259   case Bytecodes::_fstore_0:  store_local_float(0);                  break;
1260   case Bytecodes::_fstore_1:  store_local_float(1);                  break;
1261   case Bytecodes::_fstore_2:  store_local_float(2);                  break;
1262   case Bytecodes::_fstore_3:  store_local_float(3);                  break;
1263 
1264   case Bytecodes::_getfield:  do_getfield(str);                      break;
1265   case Bytecodes::_getstatic: do_getstatic(str);                     break;
1266 
1267   case Bytecodes::_goto:
1268   case Bytecodes::_goto_w:
1269   case Bytecodes::_nop:
1270   case Bytecodes::_return:
1271     {
1272       // do nothing.
1273       break;
1274     }
1275   case Bytecodes::_i2b:
1276   case Bytecodes::_i2c:
1277   case Bytecodes::_i2s:
1278   case Bytecodes::_ineg:
1279     {
1280       pop_int();
1281       push_int();
1282       break;
1283     }
1284   case Bytecodes::_i2d:
1285     {
1286       pop_int();
1287       push_double();
1288       break;
1289     }
1290   case Bytecodes::_i2f:
1291     {
1292       pop_int();
1293       push_float();
1294       break;
1295     }
1296   case Bytecodes::_i2l:
1297     {
1298       pop_int();
1299       push_long();
1300       break;
1301     }
1302   case Bytecodes::_iadd:
1303   case Bytecodes::_iand:
1304   case Bytecodes::_idiv:
1305   case Bytecodes::_imul:
1306   case Bytecodes::_ior:
1307   case Bytecodes::_irem:
1308   case Bytecodes::_ishl:
1309   case Bytecodes::_ishr:
1310   case Bytecodes::_isub:
1311   case Bytecodes::_iushr:
1312   case Bytecodes::_ixor:
1313     {
1314       pop_int();
1315       pop_int();
1316       push_int();
1317       break;
1318     }
1319   case Bytecodes::_if_acmpeq:
1320   case Bytecodes::_if_acmpne:
1321     {
1322       pop_object();
1323       pop_object();
1324       break;
1325     }
1326   case Bytecodes::_if_icmpeq:
1327   case Bytecodes::_if_icmpge:
1328   case Bytecodes::_if_icmpgt:
1329   case Bytecodes::_if_icmple:
1330   case Bytecodes::_if_icmplt:
1331   case Bytecodes::_if_icmpne:
1332     {
1333       pop_int();
1334       pop_int();
1335       break;
1336     }
1337   case Bytecodes::_ifeq:
1338   case Bytecodes::_ifle:
1339   case Bytecodes::_iflt:
1340   case Bytecodes::_ifge:
1341   case Bytecodes::_ifgt:
1342   case Bytecodes::_ifne:
1343   case Bytecodes::_ireturn:
1344   case Bytecodes::_lookupswitch:
1345   case Bytecodes::_tableswitch:
1346     {
1347       pop_int();
1348       break;
1349     }
1350   case Bytecodes::_iinc:
1351     {
1352       int lnum = str-&gt;get_index();
1353       check_int(local(lnum));
1354       store_to_local(lnum);
1355       break;
1356     }
1357   case Bytecodes::_iload:   load_local_int(str-&gt;get_index()); break;
1358   case Bytecodes::_iload_0: load_local_int(0);                      break;
1359   case Bytecodes::_iload_1: load_local_int(1);                      break;
1360   case Bytecodes::_iload_2: load_local_int(2);                      break;
1361   case Bytecodes::_iload_3: load_local_int(3);                      break;
1362 
1363   case Bytecodes::_instanceof:
1364     {
1365       // Check for uncommon trap:
1366       do_checkcast(str);
1367       pop_object();
1368       push_int();
1369       break;
1370     }
1371   case Bytecodes::_invokeinterface: do_invoke(str, true);           break;
1372   case Bytecodes::_invokespecial:   do_invoke(str, true);           break;
1373   case Bytecodes::_invokestatic:    do_invoke(str, false);          break;
1374   case Bytecodes::_invokevirtual:   do_invoke(str, true);           break;
1375   case Bytecodes::_invokedynamic:   do_invoke(str, false);          break;
1376 
1377   case Bytecodes::_istore:   store_local_int(str-&gt;get_index());     break;
1378   case Bytecodes::_istore_0: store_local_int(0);                    break;
1379   case Bytecodes::_istore_1: store_local_int(1);                    break;
1380   case Bytecodes::_istore_2: store_local_int(2);                    break;
1381   case Bytecodes::_istore_3: store_local_int(3);                    break;
1382 
1383   case Bytecodes::_jsr:
1384   case Bytecodes::_jsr_w: do_jsr(str);                              break;
1385 
1386   case Bytecodes::_l2d:
1387     {
1388       pop_long();
1389       push_double();
1390       break;
1391     }
1392   case Bytecodes::_l2f:
1393     {
1394       pop_long();
1395       push_float();
1396       break;
1397     }
1398   case Bytecodes::_l2i:
1399     {
1400       pop_long();
1401       push_int();
1402       break;
1403     }
1404   case Bytecodes::_ladd:
1405   case Bytecodes::_land:
1406   case Bytecodes::_ldiv:
1407   case Bytecodes::_lmul:
1408   case Bytecodes::_lor:
1409   case Bytecodes::_lrem:
1410   case Bytecodes::_lsub:
1411   case Bytecodes::_lxor:
1412     {
1413       pop_long();
1414       pop_long();
1415       push_long();
1416       break;
1417     }
1418   case Bytecodes::_laload:
1419     {
1420       pop_int();
1421       ciTypeArrayKlass* array_klass = pop_typeArray();
1422       // Put assert here for right type?
1423       push_long();
1424       break;
1425     }
1426   case Bytecodes::_lastore:
1427     {
1428       pop_long();
1429       pop_int();
1430       pop_typeArray();
1431       // assert here?
1432       break;
1433     }
1434   case Bytecodes::_lcmp:
1435     {
1436       pop_long();
1437       pop_long();
1438       push_int();
1439       break;
1440     }
1441   case Bytecodes::_lconst_0:
1442   case Bytecodes::_lconst_1:
1443     {
1444       push_long();
1445       break;
1446     }
1447   case Bytecodes::_ldc:
1448   case Bytecodes::_ldc_w:
1449   case Bytecodes::_ldc2_w:
1450     {
1451       do_ldc(str);
1452       break;
1453     }
1454 
1455   case Bytecodes::_lload:   load_local_long(str-&gt;get_index());      break;
1456   case Bytecodes::_lload_0: load_local_long(0);                     break;
1457   case Bytecodes::_lload_1: load_local_long(1);                     break;
1458   case Bytecodes::_lload_2: load_local_long(2);                     break;
1459   case Bytecodes::_lload_3: load_local_long(3);                     break;
1460 
1461   case Bytecodes::_lneg:
1462     {
1463       pop_long();
1464       push_long();
1465       break;
1466     }
1467   case Bytecodes::_lreturn:
1468     {
1469       pop_long();
1470       break;
1471     }
1472   case Bytecodes::_lshl:
1473   case Bytecodes::_lshr:
1474   case Bytecodes::_lushr:
1475     {
1476       pop_int();
1477       pop_long();
1478       push_long();
1479       break;
1480     }
1481   case Bytecodes::_lstore:   store_local_long(str-&gt;get_index());    break;
1482   case Bytecodes::_lstore_0: store_local_long(0);                   break;
1483   case Bytecodes::_lstore_1: store_local_long(1);                   break;
1484   case Bytecodes::_lstore_2: store_local_long(2);                   break;
1485   case Bytecodes::_lstore_3: store_local_long(3);                   break;
1486 
1487   case Bytecodes::_multianewarray: do_multianewarray(str);          break;
1488 
1489   case Bytecodes::_new:      do_new(str);                           break;
1490 
1491   case Bytecodes::_defaultvalue: do_defaultvalue(str);              break;
1492   case Bytecodes::_withfield: do_withfield(str);                    break;
1493 
1494   case Bytecodes::_newarray: do_newarray(str);                      break;
1495 
1496   case Bytecodes::_pop:
1497     {
1498       pop();
1499       break;
1500     }
1501   case Bytecodes::_pop2:
1502     {
1503       pop();
1504       pop();
1505       break;
1506     }
1507 
1508   case Bytecodes::_putfield:       do_putfield(str);                 break;
1509   case Bytecodes::_putstatic:      do_putstatic(str);                break;
1510 
1511   case Bytecodes::_ret: do_ret(str);                                 break;
1512 
1513   case Bytecodes::_swap:
1514     {
1515       ciType* value1 = pop_value();
1516       ciType* value2 = pop_value();
1517       push(value1);
1518       push(value2);
1519       break;
1520     }
1521 
1522   case Bytecodes::_wide:
1523   default:
1524     {
1525       // The iterator should skip this.
1526       ShouldNotReachHere();
1527       break;
1528     }
1529   }
1530 
1531   if (CITraceTypeFlow) {
1532     print_on(tty);
1533   }
1534 
1535   return (_trap_bci != -1);
1536 }
1537 
1538 #ifndef PRODUCT
1539 // ------------------------------------------------------------------
1540 // ciTypeFlow::StateVector::print_cell_on
1541 void ciTypeFlow::StateVector::print_cell_on(outputStream* st, Cell c) const {
1542   ciType* type = type_at(c);
1543   if (type == top_type()) {
1544     st-&gt;print(&quot;top&quot;);
1545   } else if (type == bottom_type()) {
1546     st-&gt;print(&quot;bottom&quot;);
1547   } else if (type == null_type()) {
1548     st-&gt;print(&quot;null&quot;);
1549   } else if (type == long2_type()) {
1550     st-&gt;print(&quot;long2&quot;);
1551   } else if (type == double2_type()) {
1552     st-&gt;print(&quot;double2&quot;);
1553   } else if (is_int(type)) {
1554     st-&gt;print(&quot;int&quot;);
1555   } else if (is_long(type)) {
1556     st-&gt;print(&quot;long&quot;);
1557   } else if (is_float(type)) {
1558     st-&gt;print(&quot;float&quot;);
1559   } else if (is_double(type)) {
1560     st-&gt;print(&quot;double&quot;);
1561   } else if (type-&gt;is_return_address()) {
1562     st-&gt;print(&quot;address(%d)&quot;, type-&gt;as_return_address()-&gt;bci());
1563   } else {
1564     if (type-&gt;is_klass()) {
1565       type-&gt;as_klass()-&gt;name()-&gt;print_symbol_on(st);
1566     } else {
1567       st-&gt;print(&quot;UNEXPECTED TYPE&quot;);
1568       type-&gt;print();
1569     }
1570   }
1571 }
1572 
1573 // ------------------------------------------------------------------
1574 // ciTypeFlow::StateVector::print_on
1575 void ciTypeFlow::StateVector::print_on(outputStream* st) const {
1576   int num_locals   = _outer-&gt;max_locals();
1577   int num_stack    = stack_size();
1578   int num_monitors = monitor_count();
1579   st-&gt;print_cr(&quot;  State : locals %d, stack %d, monitors %d&quot;, num_locals, num_stack, num_monitors);
1580   if (num_stack &gt;= 0) {
1581     int i;
1582     for (i = 0; i &lt; num_locals; i++) {
1583       st-&gt;print(&quot;    local %2d : &quot;, i);
1584       print_cell_on(st, local(i));
1585       st-&gt;cr();
1586     }
1587     for (i = 0; i &lt; num_stack; i++) {
1588       st-&gt;print(&quot;    stack %2d : &quot;, i);
1589       print_cell_on(st, stack(i));
1590       st-&gt;cr();
1591     }
1592   }
1593 }
1594 #endif
1595 
1596 
1597 // ------------------------------------------------------------------
1598 // ciTypeFlow::SuccIter::next
1599 //
1600 void ciTypeFlow::SuccIter::next() {
1601   int succ_ct = _pred-&gt;successors()-&gt;length();
1602   int next = _index + 1;
1603   if (next &lt; succ_ct) {
1604     _index = next;
1605     _succ = _pred-&gt;successors()-&gt;at(next);
1606     return;
1607   }
1608   for (int i = next - succ_ct; i &lt; _pred-&gt;exceptions()-&gt;length(); i++) {
1609     // Do not compile any code for unloaded exception types.
1610     // Following compiler passes are responsible for doing this also.
1611     ciInstanceKlass* exception_klass = _pred-&gt;exc_klasses()-&gt;at(i);
1612     if (exception_klass-&gt;is_loaded()) {
1613       _index = next;
1614       _succ = _pred-&gt;exceptions()-&gt;at(i);
1615       return;
1616     }
1617     next++;
1618   }
1619   _index = -1;
1620   _succ = NULL;
1621 }
1622 
1623 // ------------------------------------------------------------------
1624 // ciTypeFlow::SuccIter::set_succ
1625 //
1626 void ciTypeFlow::SuccIter::set_succ(Block* succ) {
1627   int succ_ct = _pred-&gt;successors()-&gt;length();
1628   if (_index &lt; succ_ct) {
1629     _pred-&gt;successors()-&gt;at_put(_index, succ);
1630   } else {
1631     int idx = _index - succ_ct;
1632     _pred-&gt;exceptions()-&gt;at_put(idx, succ);
1633   }
1634 }
1635 
1636 // ciTypeFlow::Block
1637 //
1638 // A basic block.
1639 
1640 // ------------------------------------------------------------------
1641 // ciTypeFlow::Block::Block
1642 ciTypeFlow::Block::Block(ciTypeFlow* outer,
1643                          ciBlock *ciblk,
1644                          ciTypeFlow::JsrSet* jsrs) {
1645   _ciblock = ciblk;
1646   _exceptions = NULL;
1647   _exc_klasses = NULL;
1648   _successors = NULL;
1649   _predecessors = new (outer-&gt;arena()) GrowableArray&lt;Block*&gt;(outer-&gt;arena(), 1, 0, NULL);
1650   _state = new (outer-&gt;arena()) StateVector(outer);
1651   JsrSet* new_jsrs =
1652     new (outer-&gt;arena()) JsrSet(outer-&gt;arena(), jsrs-&gt;size());
1653   jsrs-&gt;copy_into(new_jsrs);
1654   _jsrs = new_jsrs;
1655   _next = NULL;
1656   _on_work_list = false;
1657   _backedge_copy = false;
1658   _has_monitorenter = false;
1659   _trap_bci = -1;
1660   _trap_index = 0;
1661   df_init();
1662 
1663   if (CITraceTypeFlow) {
1664     tty-&gt;print_cr(&quot;&gt;&gt; Created new block&quot;);
1665     print_on(tty);
1666   }
1667 
1668   assert(this-&gt;outer() == outer, &quot;outer link set up&quot;);
1669   assert(!outer-&gt;have_block_count(), &quot;must not have mapped blocks yet&quot;);
1670 }
1671 
1672 // ------------------------------------------------------------------
1673 // ciTypeFlow::Block::df_init
1674 void ciTypeFlow::Block::df_init() {
1675   _pre_order = -1; assert(!has_pre_order(), &quot;&quot;);
1676   _post_order = -1; assert(!has_post_order(), &quot;&quot;);
1677   _loop = NULL;
1678   _irreducible_entry = false;
1679   _rpo_next = NULL;
1680 }
1681 
1682 // ------------------------------------------------------------------
1683 // ciTypeFlow::Block::successors
1684 //
1685 // Get the successors for this Block.
1686 GrowableArray&lt;ciTypeFlow::Block*&gt;*
1687 ciTypeFlow::Block::successors(ciBytecodeStream* str,
1688                               ciTypeFlow::StateVector* state,
1689                               ciTypeFlow::JsrSet* jsrs) {
1690   if (_successors == NULL) {
1691     if (CITraceTypeFlow) {
1692       tty-&gt;print(&quot;&gt;&gt; Computing successors for block &quot;);
1693       print_value_on(tty);
1694       tty-&gt;cr();
1695     }
1696 
1697     ciTypeFlow* analyzer = outer();
1698     Arena* arena = analyzer-&gt;arena();
1699     Block* block = NULL;
1700     bool has_successor = !has_trap() &amp;&amp;
1701                          (control() != ciBlock::fall_through_bci || limit() &lt; analyzer-&gt;code_size());
1702     if (!has_successor) {
1703       _successors =
1704         new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1705       // No successors
1706     } else if (control() == ciBlock::fall_through_bci) {
1707       assert(str-&gt;cur_bci() == limit(), &quot;bad block end&quot;);
1708       // This block simply falls through to the next.
1709       _successors =
1710         new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1711 
1712       Block* block = analyzer-&gt;block_at(limit(), _jsrs);
1713       assert(_successors-&gt;length() == FALL_THROUGH, &quot;&quot;);
1714       _successors-&gt;append(block);
1715     } else {
1716       int current_bci = str-&gt;cur_bci();
1717       int next_bci = str-&gt;next_bci();
1718       int branch_bci = -1;
1719       Block* target = NULL;
1720       assert(str-&gt;next_bci() == limit(), &quot;bad block end&quot;);
1721       // This block is not a simple fall-though.  Interpret
1722       // the current bytecode to find our successors.
1723       switch (str-&gt;cur_bc()) {
1724       case Bytecodes::_ifeq:         case Bytecodes::_ifne:
1725       case Bytecodes::_iflt:         case Bytecodes::_ifge:
1726       case Bytecodes::_ifgt:         case Bytecodes::_ifle:
1727       case Bytecodes::_if_icmpeq:    case Bytecodes::_if_icmpne:
1728       case Bytecodes::_if_icmplt:    case Bytecodes::_if_icmpge:
1729       case Bytecodes::_if_icmpgt:    case Bytecodes::_if_icmple:
1730       case Bytecodes::_if_acmpeq:    case Bytecodes::_if_acmpne:
1731       case Bytecodes::_ifnull:       case Bytecodes::_ifnonnull:
1732         // Our successors are the branch target and the next bci.
1733         branch_bci = str-&gt;get_dest();
1734         _successors =
1735           new (arena) GrowableArray&lt;Block*&gt;(arena, 2, 0, NULL);
1736         assert(_successors-&gt;length() == IF_NOT_TAKEN, &quot;&quot;);
1737         _successors-&gt;append(analyzer-&gt;block_at(next_bci, jsrs));
1738         assert(_successors-&gt;length() == IF_TAKEN, &quot;&quot;);
1739         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1740         break;
1741 
1742       case Bytecodes::_goto:
1743         branch_bci = str-&gt;get_dest();
1744         _successors =
1745           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1746         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1747         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1748         break;
1749 
1750       case Bytecodes::_jsr:
1751         branch_bci = str-&gt;get_dest();
1752         _successors =
1753           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1754         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1755         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1756         break;
1757 
1758       case Bytecodes::_goto_w:
1759       case Bytecodes::_jsr_w:
1760         _successors =
1761           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1762         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1763         _successors-&gt;append(analyzer-&gt;block_at(str-&gt;get_far_dest(), jsrs));
1764         break;
1765 
1766       case Bytecodes::_tableswitch:  {
1767         Bytecode_tableswitch tableswitch(str);
1768 
1769         int len = tableswitch.length();
1770         _successors =
1771           new (arena) GrowableArray&lt;Block*&gt;(arena, len+1, 0, NULL);
1772         int bci = current_bci + tableswitch.default_offset();
1773         Block* block = analyzer-&gt;block_at(bci, jsrs);
1774         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1775         _successors-&gt;append(block);
1776         while (--len &gt;= 0) {
1777           int bci = current_bci + tableswitch.dest_offset_at(len);
1778           block = analyzer-&gt;block_at(bci, jsrs);
1779           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1780           _successors-&gt;append_if_missing(block);
1781         }
1782         break;
1783       }
1784 
1785       case Bytecodes::_lookupswitch: {
1786         Bytecode_lookupswitch lookupswitch(str);
1787 
1788         int npairs = lookupswitch.number_of_pairs();
1789         _successors =
1790           new (arena) GrowableArray&lt;Block*&gt;(arena, npairs+1, 0, NULL);
1791         int bci = current_bci + lookupswitch.default_offset();
1792         Block* block = analyzer-&gt;block_at(bci, jsrs);
1793         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1794         _successors-&gt;append(block);
1795         while(--npairs &gt;= 0) {
1796           LookupswitchPair pair = lookupswitch.pair_at(npairs);
1797           int bci = current_bci + pair.offset();
1798           Block* block = analyzer-&gt;block_at(bci, jsrs);
1799           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1800           _successors-&gt;append_if_missing(block);
1801         }
1802         break;
1803       }
1804 
1805       case Bytecodes::_athrow:
1806       case Bytecodes::_ireturn:
1807       case Bytecodes::_lreturn:
1808       case Bytecodes::_freturn:
1809       case Bytecodes::_dreturn:
1810       case Bytecodes::_areturn:
1811       case Bytecodes::_return:
1812         _successors =
1813           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1814         // No successors
1815         break;
1816 
1817       case Bytecodes::_ret: {
1818         _successors =
1819           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1820 
1821         Cell local = state-&gt;local(str-&gt;get_index());
1822         ciType* return_address = state-&gt;type_at(local);
1823         assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
1824         int bci = return_address-&gt;as_return_address()-&gt;bci();
1825         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1826         _successors-&gt;append(analyzer-&gt;block_at(bci, jsrs));
1827         break;
1828       }
1829 
1830       case Bytecodes::_wide:
1831       default:
1832         ShouldNotReachHere();
1833         break;
1834       }
1835     }
1836 
1837     // Set predecessor information
1838     for (int i = 0; i &lt; _successors-&gt;length(); i++) {
1839       Block* block = _successors-&gt;at(i);
1840       block-&gt;predecessors()-&gt;append(this);
1841     }
1842   }
1843   return _successors;
1844 }
1845 
1846 // ------------------------------------------------------------------
1847 // ciTypeFlow::Block:compute_exceptions
1848 //
1849 // Compute the exceptional successors and types for this Block.
1850 void ciTypeFlow::Block::compute_exceptions() {
1851   assert(_exceptions == NULL &amp;&amp; _exc_klasses == NULL, &quot;repeat&quot;);
1852 
1853   if (CITraceTypeFlow) {
1854     tty-&gt;print(&quot;&gt;&gt; Computing exceptions for block &quot;);
1855     print_value_on(tty);
1856     tty-&gt;cr();
1857   }
1858 
1859   ciTypeFlow* analyzer = outer();
1860   Arena* arena = analyzer-&gt;arena();
1861 
1862   // Any bci in the block will do.
1863   ciExceptionHandlerStream str(analyzer-&gt;method(), start());
1864 
1865   // Allocate our growable arrays.
1866   int exc_count = str.count();
1867   _exceptions = new (arena) GrowableArray&lt;Block*&gt;(arena, exc_count, 0, NULL);
1868   _exc_klasses = new (arena) GrowableArray&lt;ciInstanceKlass*&gt;(arena, exc_count,
1869                                                              0, NULL);
1870 
1871   for ( ; !str.is_done(); str.next()) {
1872     ciExceptionHandler* handler = str.handler();
1873     int bci = handler-&gt;handler_bci();
1874     ciInstanceKlass* klass = NULL;
1875     if (bci == -1) {
1876       // There is no catch all.  It is possible to exit the method.
1877       break;
1878     }
1879     if (handler-&gt;is_catch_all()) {
1880       klass = analyzer-&gt;env()-&gt;Throwable_klass();
1881     } else {
1882       klass = handler-&gt;catch_klass();
1883     }
1884     Block* block = analyzer-&gt;block_at(bci, _jsrs);
1885     _exceptions-&gt;append(block);
1886     block-&gt;predecessors()-&gt;append(this);
1887     _exc_klasses-&gt;append(klass);
1888   }
1889 }
1890 
1891 // ------------------------------------------------------------------
1892 // ciTypeFlow::Block::set_backedge_copy
1893 // Use this only to make a pre-existing public block into a backedge copy.
1894 void ciTypeFlow::Block::set_backedge_copy(bool z) {
1895   assert(z || (z == is_backedge_copy()), &quot;cannot make a backedge copy public&quot;);
1896   _backedge_copy = z;
1897 }
1898 
1899 // ------------------------------------------------------------------
1900 // ciTypeFlow::Block::is_clonable_exit
1901 //
1902 // At most 2 normal successors, one of which continues looping,
1903 // and all exceptional successors must exit.
1904 bool ciTypeFlow::Block::is_clonable_exit(ciTypeFlow::Loop* lp) {
1905   int normal_cnt  = 0;
1906   int in_loop_cnt = 0;
1907   for (SuccIter iter(this); !iter.done(); iter.next()) {
1908     Block* succ = iter.succ();
1909     if (iter.is_normal_ctrl()) {
1910       if (++normal_cnt &gt; 2) return false;
1911       if (lp-&gt;contains(succ-&gt;loop())) {
1912         if (++in_loop_cnt &gt; 1) return false;
1913       }
1914     } else {
1915       if (lp-&gt;contains(succ-&gt;loop())) return false;
1916     }
1917   }
1918   return in_loop_cnt == 1;
1919 }
1920 
1921 // ------------------------------------------------------------------
1922 // ciTypeFlow::Block::looping_succ
1923 //
1924 ciTypeFlow::Block* ciTypeFlow::Block::looping_succ(ciTypeFlow::Loop* lp) {
1925   assert(successors()-&gt;length() &lt;= 2, &quot;at most 2 normal successors&quot;);
1926   for (SuccIter iter(this); !iter.done(); iter.next()) {
1927     Block* succ = iter.succ();
1928     if (lp-&gt;contains(succ-&gt;loop())) {
1929       return succ;
1930     }
1931   }
1932   return NULL;
1933 }
1934 
1935 #ifndef PRODUCT
1936 // ------------------------------------------------------------------
1937 // ciTypeFlow::Block::print_value_on
1938 void ciTypeFlow::Block::print_value_on(outputStream* st) const {
1939   if (has_pre_order()) st-&gt;print(&quot;#%-2d &quot;, pre_order());
1940   if (has_rpo())       st-&gt;print(&quot;rpo#%-2d &quot;, rpo());
1941   st-&gt;print(&quot;[%d - %d)&quot;, start(), limit());
1942   if (is_loop_head()) st-&gt;print(&quot; lphd&quot;);
1943   if (is_irreducible_entry()) st-&gt;print(&quot; irred&quot;);
1944   if (_jsrs-&gt;size() &gt; 0) { st-&gt;print(&quot;/&quot;);  _jsrs-&gt;print_on(st); }
1945   if (is_backedge_copy())  st-&gt;print(&quot;/backedge_copy&quot;);
1946 }
1947 
1948 // ------------------------------------------------------------------
1949 // ciTypeFlow::Block::print_on
1950 void ciTypeFlow::Block::print_on(outputStream* st) const {
1951   if ((Verbose || WizardMode) &amp;&amp; (limit() &gt;= 0)) {
1952     // Don&#39;t print &#39;dummy&#39; blocks (i.e. blocks with limit() &#39;-1&#39;)
1953     outer()-&gt;method()-&gt;print_codes_on(start(), limit(), st);
1954   }
1955   st-&gt;print_cr(&quot;  ====================================================  &quot;);
1956   st-&gt;print (&quot;  &quot;);
1957   print_value_on(st);
1958   st-&gt;print(&quot; Stored locals: &quot;); def_locals()-&gt;print_on(st, outer()-&gt;method()-&gt;max_locals()); tty-&gt;cr();
1959   if (loop() &amp;&amp; loop()-&gt;parent() != NULL) {
1960     st-&gt;print(&quot; loops:&quot;);
1961     Loop* lp = loop();
1962     do {
1963       st-&gt;print(&quot; %d&lt;-%d&quot;, lp-&gt;head()-&gt;pre_order(),lp-&gt;tail()-&gt;pre_order());
1964       if (lp-&gt;is_irreducible()) st-&gt;print(&quot;(ir)&quot;);
1965       lp = lp-&gt;parent();
1966     } while (lp-&gt;parent() != NULL);
1967   }
1968   st-&gt;cr();
1969   _state-&gt;print_on(st);
1970   if (_successors == NULL) {
1971     st-&gt;print_cr(&quot;  No successor information&quot;);
1972   } else {
1973     int num_successors = _successors-&gt;length();
1974     st-&gt;print_cr(&quot;  Successors : %d&quot;, num_successors);
1975     for (int i = 0; i &lt; num_successors; i++) {
1976       Block* successor = _successors-&gt;at(i);
1977       st-&gt;print(&quot;    &quot;);
1978       successor-&gt;print_value_on(st);
1979       st-&gt;cr();
1980     }
1981   }
1982   if (_predecessors == NULL) {
1983     st-&gt;print_cr(&quot;  No predecessor information&quot;);
1984   } else {
1985     int num_predecessors = _predecessors-&gt;length();
1986     st-&gt;print_cr(&quot;  Predecessors : %d&quot;, num_predecessors);
1987     for (int i = 0; i &lt; num_predecessors; i++) {
1988       Block* predecessor = _predecessors-&gt;at(i);
1989       st-&gt;print(&quot;    &quot;);
1990       predecessor-&gt;print_value_on(st);
1991       st-&gt;cr();
1992     }
1993   }
1994   if (_exceptions == NULL) {
1995     st-&gt;print_cr(&quot;  No exception information&quot;);
1996   } else {
1997     int num_exceptions = _exceptions-&gt;length();
1998     st-&gt;print_cr(&quot;  Exceptions : %d&quot;, num_exceptions);
1999     for (int i = 0; i &lt; num_exceptions; i++) {
2000       Block* exc_succ = _exceptions-&gt;at(i);
2001       ciInstanceKlass* exc_klass = _exc_klasses-&gt;at(i);
2002       st-&gt;print(&quot;    &quot;);
2003       exc_succ-&gt;print_value_on(st);
2004       st-&gt;print(&quot; -- &quot;);
2005       exc_klass-&gt;name()-&gt;print_symbol_on(st);
2006       st-&gt;cr();
2007     }
2008   }
2009   if (has_trap()) {
2010     st-&gt;print_cr(&quot;  Traps on %d with trap index %d&quot;, trap_bci(), trap_index());
2011   }
2012   st-&gt;print_cr(&quot;  ====================================================  &quot;);
2013 }
2014 #endif
2015 
2016 #ifndef PRODUCT
2017 // ------------------------------------------------------------------
2018 // ciTypeFlow::LocalSet::print_on
2019 void ciTypeFlow::LocalSet::print_on(outputStream* st, int limit) const {
2020   st-&gt;print(&quot;{&quot;);
2021   for (int i = 0; i &lt; max; i++) {
2022     if (test(i)) st-&gt;print(&quot; %d&quot;, i);
2023   }
2024   if (limit &gt; max) {
2025     st-&gt;print(&quot; %d..%d &quot;, max, limit);
2026   }
2027   st-&gt;print(&quot; }&quot;);
2028 }
2029 #endif
2030 
2031 // ciTypeFlow
2032 //
2033 // This is a pass over the bytecodes which computes the following:
2034 //   basic block structure
2035 //   interpreter type-states (a la the verifier)
2036 
2037 // ------------------------------------------------------------------
2038 // ciTypeFlow::ciTypeFlow
2039 ciTypeFlow::ciTypeFlow(ciEnv* env, ciMethod* method, int osr_bci) {
2040   _env = env;
2041   _method = method;
2042   _methodBlocks = method-&gt;get_method_blocks();
2043   _max_locals = method-&gt;max_locals();
2044   _max_stack = method-&gt;max_stack();
2045   _code_size = method-&gt;code_size();
2046   _has_irreducible_entry = false;
2047   _osr_bci = osr_bci;
2048   _failure_reason = NULL;
2049   assert(0 &lt;= start_bci() &amp;&amp; start_bci() &lt; code_size() , &quot;correct osr_bci argument: 0 &lt;= %d &lt; %d&quot;, start_bci(), code_size());
2050   _work_list = NULL;
2051 
2052   _ciblock_count = _methodBlocks-&gt;num_blocks();
2053   _idx_to_blocklist = NEW_ARENA_ARRAY(arena(), GrowableArray&lt;Block*&gt;*, _ciblock_count);
2054   for (int i = 0; i &lt; _ciblock_count; i++) {
2055     _idx_to_blocklist[i] = NULL;
2056   }
2057   _block_map = NULL;  // until all blocks are seen
2058   _jsr_count = 0;
2059   _jsr_records = NULL;
2060 }
2061 
2062 // ------------------------------------------------------------------
2063 // ciTypeFlow::work_list_next
2064 //
2065 // Get the next basic block from our work list.
2066 ciTypeFlow::Block* ciTypeFlow::work_list_next() {
2067   assert(!work_list_empty(), &quot;work list must not be empty&quot;);
2068   Block* next_block = _work_list;
2069   _work_list = next_block-&gt;next();
2070   next_block-&gt;set_next(NULL);
2071   next_block-&gt;set_on_work_list(false);
2072   return next_block;
2073 }
2074 
2075 // ------------------------------------------------------------------
2076 // ciTypeFlow::add_to_work_list
2077 //
2078 // Add a basic block to our work list.
2079 // List is sorted by decreasing postorder sort (same as increasing RPO)
2080 void ciTypeFlow::add_to_work_list(ciTypeFlow::Block* block) {
2081   assert(!block-&gt;is_on_work_list(), &quot;must not already be on work list&quot;);
2082 
2083   if (CITraceTypeFlow) {
2084     tty-&gt;print(&quot;&gt;&gt; Adding block &quot;);
2085     block-&gt;print_value_on(tty);
2086     tty-&gt;print_cr(&quot; to the work list : &quot;);
2087   }
2088 
2089   block-&gt;set_on_work_list(true);
2090 
2091   // decreasing post order sort
2092 
2093   Block* prev = NULL;
2094   Block* current = _work_list;
2095   int po = block-&gt;post_order();
2096   while (current != NULL) {
2097     if (!current-&gt;has_post_order() || po &gt; current-&gt;post_order())
2098       break;
2099     prev = current;
2100     current = current-&gt;next();
2101   }
2102   if (prev == NULL) {
2103     block-&gt;set_next(_work_list);
2104     _work_list = block;
2105   } else {
2106     block-&gt;set_next(current);
2107     prev-&gt;set_next(block);
2108   }
2109 
2110   if (CITraceTypeFlow) {
2111     tty-&gt;cr();
2112   }
2113 }
2114 
2115 // ------------------------------------------------------------------
2116 // ciTypeFlow::block_at
2117 //
2118 // Return the block beginning at bci which has a JsrSet compatible
2119 // with jsrs.
2120 ciTypeFlow::Block* ciTypeFlow::block_at(int bci, ciTypeFlow::JsrSet* jsrs, CreateOption option) {
2121   // First find the right ciBlock.
2122   if (CITraceTypeFlow) {
2123     tty-&gt;print(&quot;&gt;&gt; Requesting block for %d/&quot;, bci);
2124     jsrs-&gt;print_on(tty);
2125     tty-&gt;cr();
2126   }
2127 
2128   ciBlock* ciblk = _methodBlocks-&gt;block_containing(bci);
2129   assert(ciblk-&gt;start_bci() == bci, &quot;bad ciBlock boundaries&quot;);
2130   Block* block = get_block_for(ciblk-&gt;index(), jsrs, option);
2131 
2132   assert(block == NULL? (option == no_create): block-&gt;is_backedge_copy() == (option == create_backedge_copy), &quot;create option consistent with result&quot;);
2133 
2134   if (CITraceTypeFlow) {
2135     if (block != NULL) {
2136       tty-&gt;print(&quot;&gt;&gt; Found block &quot;);
2137       block-&gt;print_value_on(tty);
2138       tty-&gt;cr();
2139     } else {
2140       tty-&gt;print_cr(&quot;&gt;&gt; No such block.&quot;);
2141     }
2142   }
2143 
2144   return block;
2145 }
2146 
2147 // ------------------------------------------------------------------
2148 // ciTypeFlow::make_jsr_record
2149 //
2150 // Make a JsrRecord for a given (entry, return) pair, if such a record
2151 // does not already exist.
2152 ciTypeFlow::JsrRecord* ciTypeFlow::make_jsr_record(int entry_address,
2153                                                    int return_address) {
2154   if (_jsr_records == NULL) {
2155     _jsr_records = new (arena()) GrowableArray&lt;JsrRecord*&gt;(arena(),
2156                                                            _jsr_count,
2157                                                            0,
2158                                                            NULL);
2159   }
2160   JsrRecord* record = NULL;
2161   int len = _jsr_records-&gt;length();
2162   for (int i = 0; i &lt; len; i++) {
2163     JsrRecord* record = _jsr_records-&gt;at(i);
2164     if (record-&gt;entry_address() == entry_address &amp;&amp;
2165         record-&gt;return_address() == return_address) {
2166       return record;
2167     }
2168   }
2169 
2170   record = new (arena()) JsrRecord(entry_address, return_address);
2171   _jsr_records-&gt;append(record);
2172   return record;
2173 }
2174 
2175 // ------------------------------------------------------------------
2176 // ciTypeFlow::flow_exceptions
2177 //
2178 // Merge the current state into all exceptional successors at the
2179 // current point in the code.
2180 void ciTypeFlow::flow_exceptions(GrowableArray&lt;ciTypeFlow::Block*&gt;* exceptions,
2181                                  GrowableArray&lt;ciInstanceKlass*&gt;* exc_klasses,
2182                                  ciTypeFlow::StateVector* state) {
2183   int len = exceptions-&gt;length();
2184   assert(exc_klasses-&gt;length() == len, &quot;must have same length&quot;);
2185   for (int i = 0; i &lt; len; i++) {
2186     Block* block = exceptions-&gt;at(i);
2187     ciInstanceKlass* exception_klass = exc_klasses-&gt;at(i);
2188 
2189     if (!exception_klass-&gt;is_loaded()) {
2190       // Do not compile any code for unloaded exception types.
2191       // Following compiler passes are responsible for doing this also.
2192       continue;
2193     }
2194 
2195     if (block-&gt;meet_exception(exception_klass, state)) {
2196       // Block was modified and has PO.  Add it to the work list.
2197       if (block-&gt;has_post_order() &amp;&amp;
2198           !block-&gt;is_on_work_list()) {
2199         add_to_work_list(block);
2200       }
2201     }
2202   }
2203 }
2204 
2205 // ------------------------------------------------------------------
2206 // ciTypeFlow::flow_successors
2207 //
2208 // Merge the current state into all successors at the current point
2209 // in the code.
2210 void ciTypeFlow::flow_successors(GrowableArray&lt;ciTypeFlow::Block*&gt;* successors,
2211                                  ciTypeFlow::StateVector* state) {
2212   int len = successors-&gt;length();
2213   for (int i = 0; i &lt; len; i++) {
2214     Block* block = successors-&gt;at(i);
2215     if (block-&gt;meet(state)) {
2216       // Block was modified and has PO.  Add it to the work list.
2217       if (block-&gt;has_post_order() &amp;&amp;
2218           !block-&gt;is_on_work_list()) {
2219         add_to_work_list(block);
2220       }
2221     }
2222   }
2223 }
2224 
2225 // ------------------------------------------------------------------
2226 // ciTypeFlow::can_trap
2227 //
2228 // Tells if a given instruction is able to generate an exception edge.
2229 bool ciTypeFlow::can_trap(ciBytecodeStream&amp; str) {
2230   // Cf. GenerateOopMap::do_exception_edge.
2231   if (!Bytecodes::can_trap(str.cur_bc()))  return false;
2232 
2233   switch (str.cur_bc()) {
2234     // %%% FIXME: ldc of Class can generate an exception
2235     case Bytecodes::_ldc:
2236     case Bytecodes::_ldc_w:
2237     case Bytecodes::_ldc2_w:
2238     case Bytecodes::_aload_0:
2239       // These bytecodes can trap for rewriting.  We need to assume that
2240       // they do not throw exceptions to make the monitor analysis work.
2241       return false;
2242 
2243     case Bytecodes::_ireturn:
2244     case Bytecodes::_lreturn:
2245     case Bytecodes::_freturn:
2246     case Bytecodes::_dreturn:
2247     case Bytecodes::_areturn:
2248     case Bytecodes::_return:
2249       // We can assume the monitor stack is empty in this analysis.
2250       return false;
2251 
2252     case Bytecodes::_monitorexit:
2253       // We can assume monitors are matched in this analysis.
2254       return false;
2255 
2256     default:
2257       return true;
2258   }
2259 }
2260 
2261 // ------------------------------------------------------------------
2262 // ciTypeFlow::clone_loop_heads
2263 //
2264 // Clone the loop heads
2265 bool ciTypeFlow::clone_loop_heads(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {
2266   bool rslt = false;
2267   for (PreorderLoops iter(loop_tree_root()); !iter.done(); iter.next()) {
2268     lp = iter.current();
2269     Block* head = lp-&gt;head();
2270     if (lp == loop_tree_root() ||
2271         lp-&gt;is_irreducible() ||
2272         !head-&gt;is_clonable_exit(lp))
2273       continue;
2274 
2275     // Avoid BoxLock merge.
2276     if (EliminateNestedLocks &amp;&amp; head-&gt;has_monitorenter())
2277       continue;
2278 
2279     // check not already cloned
2280     if (head-&gt;backedge_copy_count() != 0)
2281       continue;
2282 
2283     // Don&#39;t clone head of OSR loop to get correct types in start block.
2284     if (is_osr_flow() &amp;&amp; head-&gt;start() == start_bci())
2285       continue;
2286 
2287     // check _no_ shared head below us
2288     Loop* ch;
2289     for (ch = lp-&gt;child(); ch != NULL &amp;&amp; ch-&gt;head() != head; ch = ch-&gt;sibling());
2290     if (ch != NULL)
2291       continue;
2292 
2293     // Clone head
2294     Block* new_head = head-&gt;looping_succ(lp);
2295     Block* clone = clone_loop_head(lp, temp_vector, temp_set);
2296     // Update lp&#39;s info
2297     clone-&gt;set_loop(lp);
2298     lp-&gt;set_head(new_head);
2299     lp-&gt;set_tail(clone);
2300     // And move original head into outer loop
2301     head-&gt;set_loop(lp-&gt;parent());
2302 
2303     rslt = true;
2304   }
2305   return rslt;
2306 }
2307 
2308 // ------------------------------------------------------------------
2309 // ciTypeFlow::clone_loop_head
2310 //
2311 // Clone lp&#39;s head and replace tail&#39;s successors with clone.
2312 //
2313 //  |
2314 //  v
2315 // head &lt;-&gt; body
2316 //  |
2317 //  v
2318 // exit
2319 //
2320 // new_head
2321 //
2322 //  |
2323 //  v
2324 // head ----------\
2325 //  |             |
2326 //  |             v
2327 //  |  clone &lt;-&gt; body
2328 //  |    |
2329 //  | /--/
2330 //  | |
2331 //  v v
2332 // exit
2333 //
2334 ciTypeFlow::Block* ciTypeFlow::clone_loop_head(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {
2335   Block* head = lp-&gt;head();
2336   Block* tail = lp-&gt;tail();
2337   if (CITraceTypeFlow) {
2338     tty-&gt;print(&quot;&gt;&gt; Requesting clone of loop head &quot;); head-&gt;print_value_on(tty);
2339     tty-&gt;print(&quot;  for predecessor &quot;);                tail-&gt;print_value_on(tty);
2340     tty-&gt;cr();
2341   }
2342   Block* clone = block_at(head-&gt;start(), head-&gt;jsrs(), create_backedge_copy);
2343   assert(clone-&gt;backedge_copy_count() == 1, &quot;one backedge copy for all back edges&quot;);
2344 
2345   assert(!clone-&gt;has_pre_order(), &quot;just created&quot;);
2346   clone-&gt;set_next_pre_order();
2347 
2348   // Insert clone after (orig) tail in reverse post order
2349   clone-&gt;set_rpo_next(tail-&gt;rpo_next());
2350   tail-&gt;set_rpo_next(clone);
2351 
2352   // tail-&gt;head becomes tail-&gt;clone
2353   for (SuccIter iter(tail); !iter.done(); iter.next()) {
2354     if (iter.succ() == head) {
2355       iter.set_succ(clone);
2356       // Update predecessor information
2357       head-&gt;predecessors()-&gt;remove(tail);
2358       clone-&gt;predecessors()-&gt;append(tail);
2359     }
2360   }
2361   flow_block(tail, temp_vector, temp_set);
2362   if (head == tail) {
2363     // For self-loops, clone-&gt;head becomes clone-&gt;clone
2364     flow_block(clone, temp_vector, temp_set);
2365     for (SuccIter iter(clone); !iter.done(); iter.next()) {
2366       if (iter.succ() == head) {
2367         iter.set_succ(clone);
2368         // Update predecessor information
2369         head-&gt;predecessors()-&gt;remove(clone);
2370         clone-&gt;predecessors()-&gt;append(clone);
2371         break;
2372       }
2373     }
2374   }
2375   flow_block(clone, temp_vector, temp_set);
2376 
2377   return clone;
2378 }
2379 
2380 // ------------------------------------------------------------------
2381 // ciTypeFlow::flow_block
2382 //
2383 // Interpret the effects of the bytecodes on the incoming state
2384 // vector of a basic block.  Push the changed state to succeeding
2385 // basic blocks.
2386 void ciTypeFlow::flow_block(ciTypeFlow::Block* block,
2387                             ciTypeFlow::StateVector* state,
2388                             ciTypeFlow::JsrSet* jsrs) {
2389   if (CITraceTypeFlow) {
2390     tty-&gt;print(&quot;\n&gt;&gt; ANALYZING BLOCK : &quot;);
2391     tty-&gt;cr();
2392     block-&gt;print_on(tty);
2393   }
2394   assert(block-&gt;has_pre_order(), &quot;pre-order is assigned before 1st flow&quot;);
2395 
2396   int start = block-&gt;start();
2397   int limit = block-&gt;limit();
2398   int control = block-&gt;control();
2399   if (control != ciBlock::fall_through_bci) {
2400     limit = control;
2401   }
2402 
2403   // Grab the state from the current block.
2404   block-&gt;copy_state_into(state);
2405   state-&gt;def_locals()-&gt;clear();
2406 
2407   GrowableArray&lt;Block*&gt;*           exceptions = block-&gt;exceptions();
2408   GrowableArray&lt;ciInstanceKlass*&gt;* exc_klasses = block-&gt;exc_klasses();
2409   bool has_exceptions = exceptions-&gt;length() &gt; 0;
2410 
2411   bool exceptions_used = false;
2412 
2413   ciBytecodeStream str(method());
2414   str.reset_to_bci(start);
2415   Bytecodes::Code code;
2416   while ((code = str.next()) != ciBytecodeStream::EOBC() &amp;&amp;
2417          str.cur_bci() &lt; limit) {
2418     // Check for exceptional control flow from this point.
2419     if (has_exceptions &amp;&amp; can_trap(str)) {
2420       flow_exceptions(exceptions, exc_klasses, state);
2421       exceptions_used = true;
2422     }
2423     // Apply the effects of the current bytecode to our state.
2424     bool res = state-&gt;apply_one_bytecode(&amp;str);
2425 
2426     // Watch for bailouts.
2427     if (failing())  return;
2428 
2429     if (str.cur_bc() == Bytecodes::_monitorenter) {
2430       block-&gt;set_has_monitorenter();
2431     }
2432 
2433     if (res) {
2434 
2435       // We have encountered a trap.  Record it in this block.
2436       block-&gt;set_trap(state-&gt;trap_bci(), state-&gt;trap_index());
2437 
2438       if (CITraceTypeFlow) {
2439         tty-&gt;print_cr(&quot;&gt;&gt; Found trap&quot;);
2440         block-&gt;print_on(tty);
2441       }
2442 
2443       // Save set of locals defined in this block
2444       block-&gt;def_locals()-&gt;add(state-&gt;def_locals());
2445 
2446       // Record (no) successors.
2447       block-&gt;successors(&amp;str, state, jsrs);
2448 
2449       assert(!has_exceptions || exceptions_used, &quot;Not removing exceptions&quot;);
2450 
2451       // Discontinue interpretation of this Block.
2452       return;
2453     }
2454   }
2455 
2456   GrowableArray&lt;Block*&gt;* successors = NULL;
2457   if (control != ciBlock::fall_through_bci) {
2458     // Check for exceptional control flow from this point.
2459     if (has_exceptions &amp;&amp; can_trap(str)) {
2460       flow_exceptions(exceptions, exc_klasses, state);
2461       exceptions_used = true;
2462     }
2463 
2464     // Fix the JsrSet to reflect effect of the bytecode.
2465     block-&gt;copy_jsrs_into(jsrs);
2466     jsrs-&gt;apply_control(this, &amp;str, state);
2467 
2468     // Find successor edges based on old state and new JsrSet.
2469     successors = block-&gt;successors(&amp;str, state, jsrs);
2470 
2471     // Apply the control changes to the state.
2472     state-&gt;apply_one_bytecode(&amp;str);
2473   } else {
2474     // Fall through control
2475     successors = block-&gt;successors(&amp;str, NULL, NULL);
2476   }
2477 
2478   // Save set of locals defined in this block
2479   block-&gt;def_locals()-&gt;add(state-&gt;def_locals());
2480 
2481   // Remove untaken exception paths
2482   if (!exceptions_used)
2483     exceptions-&gt;clear();
2484 
2485   // Pass our state to successors.
2486   flow_successors(successors, state);
2487 }
2488 
2489 // ------------------------------------------------------------------
2490 // ciTypeFlow::PreOrderLoops::next
2491 //
2492 // Advance to next loop tree using a preorder, left-to-right traversal.
2493 void ciTypeFlow::PreorderLoops::next() {
2494   assert(!done(), &quot;must not be done.&quot;);
2495   if (_current-&gt;child() != NULL) {
2496     _current = _current-&gt;child();
2497   } else if (_current-&gt;sibling() != NULL) {
2498     _current = _current-&gt;sibling();
2499   } else {
2500     while (_current != _root &amp;&amp; _current-&gt;sibling() == NULL) {
2501       _current = _current-&gt;parent();
2502     }
2503     if (_current == _root) {
2504       _current = NULL;
2505       assert(done(), &quot;must be done.&quot;);
2506     } else {
2507       assert(_current-&gt;sibling() != NULL, &quot;must be more to do&quot;);
2508       _current = _current-&gt;sibling();
2509     }
2510   }
2511 }
2512 
2513 // ------------------------------------------------------------------
2514 // ciTypeFlow::Loop::sorted_merge
2515 //
2516 // Merge the branch lp into this branch, sorting on the loop head
2517 // pre_orders. Returns the leaf of the merged branch.
2518 // Child and sibling pointers will be setup later.
2519 // Sort is (looking from leaf towards the root)
2520 //  descending on primary key: loop head&#39;s pre_order, and
2521 //  ascending  on secondary key: loop tail&#39;s pre_order.
2522 ciTypeFlow::Loop* ciTypeFlow::Loop::sorted_merge(Loop* lp) {
2523   Loop* leaf = this;
2524   Loop* prev = NULL;
2525   Loop* current = leaf;
2526   while (lp != NULL) {
2527     int lp_pre_order = lp-&gt;head()-&gt;pre_order();
2528     // Find insertion point for &quot;lp&quot;
2529     while (current != NULL) {
2530       if (current == lp)
2531         return leaf; // Already in list
2532       if (current-&gt;head()-&gt;pre_order() &lt; lp_pre_order)
2533         break;
2534       if (current-&gt;head()-&gt;pre_order() == lp_pre_order &amp;&amp;
2535           current-&gt;tail()-&gt;pre_order() &gt; lp-&gt;tail()-&gt;pre_order()) {
2536         break;
2537       }
2538       prev = current;
2539       current = current-&gt;parent();
2540     }
2541     Loop* next_lp = lp-&gt;parent(); // Save future list of items to insert
2542     // Insert lp before current
2543     lp-&gt;set_parent(current);
2544     if (prev != NULL) {
2545       prev-&gt;set_parent(lp);
2546     } else {
2547       leaf = lp;
2548     }
2549     prev = lp;     // Inserted item is new prev[ious]
2550     lp = next_lp;  // Next item to insert
2551   }
2552   return leaf;
2553 }
2554 
2555 // ------------------------------------------------------------------
2556 // ciTypeFlow::build_loop_tree
2557 //
2558 // Incrementally build loop tree.
2559 void ciTypeFlow::build_loop_tree(Block* blk) {
2560   assert(!blk-&gt;is_post_visited(), &quot;precondition&quot;);
2561   Loop* innermost = NULL; // merge of loop tree branches over all successors
2562 
2563   for (SuccIter iter(blk); !iter.done(); iter.next()) {
2564     Loop*  lp   = NULL;
2565     Block* succ = iter.succ();
2566     if (!succ-&gt;is_post_visited()) {
2567       // Found backedge since predecessor post visited, but successor is not
2568       assert(succ-&gt;pre_order() &lt;= blk-&gt;pre_order(), &quot;should be backedge&quot;);
2569 
2570       // Create a LoopNode to mark this loop.
2571       lp = new (arena()) Loop(succ, blk);
2572       if (succ-&gt;loop() == NULL)
2573         succ-&gt;set_loop(lp);
2574       // succ-&gt;loop will be updated to innermost loop on a later call, when blk==succ
2575 
2576     } else {  // Nested loop
2577       lp = succ-&gt;loop();
2578 
2579       // If succ is loop head, find outer loop.
2580       while (lp != NULL &amp;&amp; lp-&gt;head() == succ) {
2581         lp = lp-&gt;parent();
2582       }
2583       if (lp == NULL) {
2584         // Infinite loop, it&#39;s parent is the root
2585         lp = loop_tree_root();
2586       }
2587     }
2588 
2589     // Check for irreducible loop.
2590     // Successor has already been visited. If the successor&#39;s loop head
2591     // has already been post-visited, then this is another entry into the loop.
2592     while (lp-&gt;head()-&gt;is_post_visited() &amp;&amp; lp != loop_tree_root()) {
2593       _has_irreducible_entry = true;
2594       lp-&gt;set_irreducible(succ);
2595       if (!succ-&gt;is_on_work_list()) {
2596         // Assume irreducible entries need more data flow
2597         add_to_work_list(succ);
2598       }
2599       Loop* plp = lp-&gt;parent();
2600       if (plp == NULL) {
2601         // This only happens for some irreducible cases.  The parent
2602         // will be updated during a later pass.
2603         break;
2604       }
2605       lp = plp;
2606     }
2607 
2608     // Merge loop tree branch for all successors.
2609     innermost = innermost == NULL ? lp : innermost-&gt;sorted_merge(lp);
2610 
2611   } // end loop
2612 
2613   if (innermost == NULL) {
2614     assert(blk-&gt;successors()-&gt;length() == 0, &quot;CFG exit&quot;);
2615     blk-&gt;set_loop(loop_tree_root());
2616   } else if (innermost-&gt;head() == blk) {
2617     // If loop header, complete the tree pointers
2618     if (blk-&gt;loop() != innermost) {
2619 #ifdef ASSERT
2620       assert(blk-&gt;loop()-&gt;head() == innermost-&gt;head(), &quot;same head&quot;);
2621       Loop* dl;
2622       for (dl = innermost; dl != NULL &amp;&amp; dl != blk-&gt;loop(); dl = dl-&gt;parent());
2623       assert(dl == blk-&gt;loop(), &quot;blk-&gt;loop() already in innermost list&quot;);
2624 #endif
2625       blk-&gt;set_loop(innermost);
2626     }
2627     innermost-&gt;def_locals()-&gt;add(blk-&gt;def_locals());
2628     Loop* l = innermost;
2629     Loop* p = l-&gt;parent();
2630     while (p &amp;&amp; l-&gt;head() == blk) {
2631       l-&gt;set_sibling(p-&gt;child());  // Put self on parents &#39;next child&#39;
2632       p-&gt;set_child(l);             // Make self the first child of parent
2633       p-&gt;def_locals()-&gt;add(l-&gt;def_locals());
2634       l = p;                       // Walk up the parent chain
2635       p = l-&gt;parent();
2636     }
2637   } else {
2638     blk-&gt;set_loop(innermost);
2639     innermost-&gt;def_locals()-&gt;add(blk-&gt;def_locals());
2640   }
2641 }
2642 
2643 // ------------------------------------------------------------------
2644 // ciTypeFlow::Loop::contains
2645 //
2646 // Returns true if lp is nested loop.
2647 bool ciTypeFlow::Loop::contains(ciTypeFlow::Loop* lp) const {
2648   assert(lp != NULL, &quot;&quot;);
2649   if (this == lp || head() == lp-&gt;head()) return true;
2650   int depth1 = depth();
2651   int depth2 = lp-&gt;depth();
2652   if (depth1 &gt; depth2)
2653     return false;
2654   while (depth1 &lt; depth2) {
2655     depth2--;
2656     lp = lp-&gt;parent();
2657   }
2658   return this == lp;
2659 }
2660 
2661 // ------------------------------------------------------------------
2662 // ciTypeFlow::Loop::depth
2663 //
2664 // Loop depth
2665 int ciTypeFlow::Loop::depth() const {
2666   int dp = 0;
2667   for (Loop* lp = this-&gt;parent(); lp != NULL; lp = lp-&gt;parent())
2668     dp++;
2669   return dp;
2670 }
2671 
2672 #ifndef PRODUCT
2673 // ------------------------------------------------------------------
2674 // ciTypeFlow::Loop::print
2675 void ciTypeFlow::Loop::print(outputStream* st, int indent) const {
2676   for (int i = 0; i &lt; indent; i++) st-&gt;print(&quot; &quot;);
2677   st-&gt;print(&quot;%d&lt;-%d %s&quot;,
2678             is_root() ? 0 : this-&gt;head()-&gt;pre_order(),
2679             is_root() ? 0 : this-&gt;tail()-&gt;pre_order(),
2680             is_irreducible()?&quot; irr&quot;:&quot;&quot;);
2681   st-&gt;print(&quot; defs: &quot;);
2682   def_locals()-&gt;print_on(st, _head-&gt;outer()-&gt;method()-&gt;max_locals());
2683   st-&gt;cr();
2684   for (Loop* ch = child(); ch != NULL; ch = ch-&gt;sibling())
2685     ch-&gt;print(st, indent+2);
2686 }
2687 #endif
2688 
2689 // ------------------------------------------------------------------
2690 // ciTypeFlow::df_flow_types
2691 //
2692 // Perform the depth first type flow analysis. Helper for flow_types.
2693 void ciTypeFlow::df_flow_types(Block* start,
2694                                bool do_flow,
2695                                StateVector* temp_vector,
2696                                JsrSet* temp_set) {
2697   int dft_len = 100;
2698   GrowableArray&lt;Block*&gt; stk(dft_len);
2699 
2700   ciBlock* dummy = _methodBlocks-&gt;make_dummy_block();
2701   JsrSet* root_set = new JsrSet(NULL, 0);
2702   Block* root_head = new (arena()) Block(this, dummy, root_set);
2703   Block* root_tail = new (arena()) Block(this, dummy, root_set);
2704   root_head-&gt;set_pre_order(0);
2705   root_head-&gt;set_post_order(0);
2706   root_tail-&gt;set_pre_order(max_jint);
2707   root_tail-&gt;set_post_order(max_jint);
2708   set_loop_tree_root(new (arena()) Loop(root_head, root_tail));
2709 
2710   stk.push(start);
2711 
2712   _next_pre_order = 0;  // initialize pre_order counter
2713   _rpo_list = NULL;
2714   int next_po = 0;      // initialize post_order counter
2715 
2716   // Compute RPO and the control flow graph
2717   int size;
2718   while ((size = stk.length()) &gt; 0) {
2719     Block* blk = stk.top(); // Leave node on stack
2720     if (!blk-&gt;is_visited()) {
2721       // forward arc in graph
2722       assert (!blk-&gt;has_pre_order(), &quot;&quot;);
2723       blk-&gt;set_next_pre_order();
2724 
2725       if (_next_pre_order &gt;= (int)Compile::current()-&gt;max_node_limit() / 2) {
2726         // Too many basic blocks.  Bail out.
2727         // This can happen when try/finally constructs are nested to depth N,
2728         // and there is O(2**N) cloning of jsr bodies.  See bug 4697245!
2729         // &quot;MaxNodeLimit / 2&quot; is used because probably the parser will
2730         // generate at least twice that many nodes and bail out.
2731         record_failure(&quot;too many basic blocks&quot;);
2732         return;
2733       }
2734       if (do_flow) {
2735         flow_block(blk, temp_vector, temp_set);
2736         if (failing()) return; // Watch for bailouts.
2737       }
2738     } else if (!blk-&gt;is_post_visited()) {
2739       // cross or back arc
2740       for (SuccIter iter(blk); !iter.done(); iter.next()) {
2741         Block* succ = iter.succ();
2742         if (!succ-&gt;is_visited()) {
2743           stk.push(succ);
2744         }
2745       }
2746       if (stk.length() == size) {
2747         // There were no additional children, post visit node now
2748         stk.pop(); // Remove node from stack
2749 
2750         build_loop_tree(blk);
2751         blk-&gt;set_post_order(next_po++);   // Assign post order
2752         prepend_to_rpo_list(blk);
2753         assert(blk-&gt;is_post_visited(), &quot;&quot;);
2754 
2755         if (blk-&gt;is_loop_head() &amp;&amp; !blk-&gt;is_on_work_list()) {
2756           // Assume loop heads need more data flow
2757           add_to_work_list(blk);
2758         }
2759       }
2760     } else {
2761       stk.pop(); // Remove post-visited node from stack
2762     }
2763   }
2764 }
2765 
2766 // ------------------------------------------------------------------
2767 // ciTypeFlow::flow_types
2768 //
2769 // Perform the type flow analysis, creating and cloning Blocks as
2770 // necessary.
2771 void ciTypeFlow::flow_types() {
2772   ResourceMark rm;
2773   StateVector* temp_vector = new StateVector(this);
2774   JsrSet* temp_set = new JsrSet(NULL, 16);
2775 
2776   // Create the method entry block.
2777   Block* start = block_at(start_bci(), temp_set);
2778 
2779   // Load the initial state into it.
2780   const StateVector* start_state = get_start_state();
2781   if (failing())  return;
2782   start-&gt;meet(start_state);
2783 
2784   // Depth first visit
2785   df_flow_types(start, true /*do flow*/, temp_vector, temp_set);
2786 
2787   if (failing())  return;
2788   assert(_rpo_list == start, &quot;must be start&quot;);
2789 
2790   // Any loops found?
2791   if (loop_tree_root()-&gt;child() != NULL &amp;&amp;
2792       env()-&gt;comp_level() &gt;= CompLevel_full_optimization) {
2793       // Loop optimizations are not performed on Tier1 compiles.
2794 
2795     bool changed = clone_loop_heads(loop_tree_root(), temp_vector, temp_set);
2796 
2797     // If some loop heads were cloned, recompute postorder and loop tree
2798     if (changed) {
2799       loop_tree_root()-&gt;set_child(NULL);
2800       for (Block* blk = _rpo_list; blk != NULL;) {
2801         Block* next = blk-&gt;rpo_next();
2802         blk-&gt;df_init();
2803         blk = next;
2804       }
2805       df_flow_types(start, false /*no flow*/, temp_vector, temp_set);
2806     }
2807   }
2808 
2809   if (CITraceTypeFlow) {
2810     tty-&gt;print_cr(&quot;\nLoop tree&quot;);
2811     loop_tree_root()-&gt;print();
2812   }
2813 
2814   // Continue flow analysis until fixed point reached
2815 
2816   debug_only(int max_block = _next_pre_order;)
2817 
2818   while (!work_list_empty()) {
2819     Block* blk = work_list_next();
2820     assert (blk-&gt;has_post_order(), &quot;post order assigned above&quot;);
2821 
2822     flow_block(blk, temp_vector, temp_set);
2823 
2824     assert (max_block == _next_pre_order, &quot;no new blocks&quot;);
2825     assert (!failing(), &quot;no more bailouts&quot;);
2826   }
2827 }
2828 
2829 // ------------------------------------------------------------------
2830 // ciTypeFlow::map_blocks
2831 //
2832 // Create the block map, which indexes blocks in reverse post-order.
2833 void ciTypeFlow::map_blocks() {
2834   assert(_block_map == NULL, &quot;single initialization&quot;);
2835   int block_ct = _next_pre_order;
2836   _block_map = NEW_ARENA_ARRAY(arena(), Block*, block_ct);
2837   assert(block_ct == block_count(), &quot;&quot;);
2838 
2839   Block* blk = _rpo_list;
2840   for (int m = 0; m &lt; block_ct; m++) {
2841     int rpo = blk-&gt;rpo();
2842     assert(rpo == m, &quot;should be sequential&quot;);
2843     _block_map[rpo] = blk;
2844     blk = blk-&gt;rpo_next();
2845   }
2846   assert(blk == NULL, &quot;should be done&quot;);
2847 
2848   for (int j = 0; j &lt; block_ct; j++) {
2849     assert(_block_map[j] != NULL, &quot;must not drop any blocks&quot;);
2850     Block* block = _block_map[j];
2851     // Remove dead blocks from successor lists:
2852     for (int e = 0; e &lt;= 1; e++) {
2853       GrowableArray&lt;Block*&gt;* l = e? block-&gt;exceptions(): block-&gt;successors();
2854       for (int k = 0; k &lt; l-&gt;length(); k++) {
2855         Block* s = l-&gt;at(k);
2856         if (!s-&gt;has_post_order()) {
2857           if (CITraceTypeFlow) {
2858             tty-&gt;print(&quot;Removing dead %s successor of #%d: &quot;, (e? &quot;exceptional&quot;:  &quot;normal&quot;), block-&gt;pre_order());
2859             s-&gt;print_value_on(tty);
2860             tty-&gt;cr();
2861           }
2862           l-&gt;remove(s);
2863           --k;
2864         }
2865       }
2866     }
2867   }
2868 }
2869 
2870 // ------------------------------------------------------------------
2871 // ciTypeFlow::get_block_for
2872 //
2873 // Find a block with this ciBlock which has a compatible JsrSet.
2874 // If no such block exists, create it, unless the option is no_create.
2875 // If the option is create_backedge_copy, always create a fresh backedge copy.
2876 ciTypeFlow::Block* ciTypeFlow::get_block_for(int ciBlockIndex, ciTypeFlow::JsrSet* jsrs, CreateOption option) {
2877   Arena* a = arena();
2878   GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[ciBlockIndex];
2879   if (blocks == NULL) {
2880     // Query only?
2881     if (option == no_create)  return NULL;
2882 
2883     // Allocate the growable array.
2884     blocks = new (a) GrowableArray&lt;Block*&gt;(a, 4, 0, NULL);
2885     _idx_to_blocklist[ciBlockIndex] = blocks;
2886   }
2887 
2888   if (option != create_backedge_copy) {
2889     int len = blocks-&gt;length();
2890     for (int i = 0; i &lt; len; i++) {
2891       Block* block = blocks-&gt;at(i);
2892       if (!block-&gt;is_backedge_copy() &amp;&amp; block-&gt;is_compatible_with(jsrs)) {
2893         return block;
2894       }
2895     }
2896   }
2897 
2898   // Query only?
2899   if (option == no_create)  return NULL;
2900 
2901   // We did not find a compatible block.  Create one.
2902   Block* new_block = new (a) Block(this, _methodBlocks-&gt;block(ciBlockIndex), jsrs);
2903   if (option == create_backedge_copy)  new_block-&gt;set_backedge_copy(true);
2904   blocks-&gt;append(new_block);
2905   return new_block;
2906 }
2907 
2908 // ------------------------------------------------------------------
2909 // ciTypeFlow::backedge_copy_count
2910 //
2911 int ciTypeFlow::backedge_copy_count(int ciBlockIndex, ciTypeFlow::JsrSet* jsrs) const {
2912   GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[ciBlockIndex];
2913 
2914   if (blocks == NULL) {
2915     return 0;
2916   }
2917 
2918   int count = 0;
2919   int len = blocks-&gt;length();
2920   for (int i = 0; i &lt; len; i++) {
2921     Block* block = blocks-&gt;at(i);
2922     if (block-&gt;is_backedge_copy() &amp;&amp; block-&gt;is_compatible_with(jsrs)) {
2923       count++;
2924     }
2925   }
2926 
2927   return count;
2928 }
2929 
2930 // ------------------------------------------------------------------
2931 // ciTypeFlow::do_flow
2932 //
2933 // Perform type inference flow analysis.
2934 void ciTypeFlow::do_flow() {
2935   if (CITraceTypeFlow) {
2936     tty-&gt;print_cr(&quot;\nPerforming flow analysis on method&quot;);
2937     method()-&gt;print();
2938     if (is_osr_flow())  tty-&gt;print(&quot; at OSR bci %d&quot;, start_bci());
2939     tty-&gt;cr();
2940     method()-&gt;print_codes();
2941   }
2942   if (CITraceTypeFlow) {
2943     tty-&gt;print_cr(&quot;Initial CI Blocks&quot;);
2944     print_on(tty);
2945   }
2946   flow_types();
2947   // Watch for bailouts.
2948   if (failing()) {
2949     return;
2950   }
2951 
2952   map_blocks();
2953 
2954   if (CIPrintTypeFlow || CITraceTypeFlow) {
2955     rpo_print_on(tty);
2956   }
2957 }
2958 
2959 // ------------------------------------------------------------------
2960 // ciTypeFlow::is_dominated_by
2961 //
2962 // Determine if the instruction at bci is dominated by the instruction at dom_bci.
2963 bool ciTypeFlow::is_dominated_by(int bci, int dom_bci) {
2964   assert(!method()-&gt;has_jsrs(), &quot;jsrs are not supported&quot;);
2965 
2966   ResourceMark rm;
2967   JsrSet* jsrs = new ciTypeFlow::JsrSet(NULL);
2968   int        index = _methodBlocks-&gt;block_containing(bci)-&gt;index();
2969   int    dom_index = _methodBlocks-&gt;block_containing(dom_bci)-&gt;index();
2970   Block*     block = get_block_for(index, jsrs, ciTypeFlow::no_create);
2971   Block* dom_block = get_block_for(dom_index, jsrs, ciTypeFlow::no_create);
2972 
2973   // Start block dominates all other blocks
2974   if (start_block()-&gt;rpo() == dom_block-&gt;rpo()) {
2975     return true;
2976   }
2977 
2978   // Dominated[i] is true if block i is dominated by dom_block
2979   int num_blocks = block_count();
2980   bool* dominated = NEW_RESOURCE_ARRAY(bool, num_blocks);
2981   for (int i = 0; i &lt; num_blocks; ++i) {
2982     dominated[i] = true;
2983   }
2984   dominated[start_block()-&gt;rpo()] = false;
2985 
2986   // Iterative dominator algorithm
2987   bool changed = true;
2988   while (changed) {
2989     changed = false;
2990     // Use reverse postorder iteration
2991     for (Block* blk = _rpo_list; blk != NULL; blk = blk-&gt;rpo_next()) {
2992       if (blk-&gt;is_start()) {
2993         // Ignore start block
2994         continue;
2995       }
2996       // The block is dominated if it is the dominating block
2997       // itself or if all predecessors are dominated.
2998       int index = blk-&gt;rpo();
2999       bool dom = (index == dom_block-&gt;rpo());
3000       if (!dom) {
3001         // Check if all predecessors are dominated
3002         dom = true;
3003         for (int i = 0; i &lt; blk-&gt;predecessors()-&gt;length(); ++i) {
3004           Block* pred = blk-&gt;predecessors()-&gt;at(i);
3005           if (!dominated[pred-&gt;rpo()]) {
3006             dom = false;
3007             break;
3008           }
3009         }
3010       }
3011       // Update dominator information
3012       if (dominated[index] != dom) {
3013         changed = true;
3014         dominated[index] = dom;
3015       }
3016     }
3017   }
3018   // block dominated by dom_block?
3019   return dominated[block-&gt;rpo()];
3020 }
3021 
3022 // ------------------------------------------------------------------
3023 // ciTypeFlow::record_failure()
3024 // The ciTypeFlow object keeps track of failure reasons separately from the ciEnv.
3025 // This is required because there is not a 1-1 relation between the ciEnv and
3026 // the TypeFlow passes within a compilation task.  For example, if the compiler
3027 // is considering inlining a method, it will request a TypeFlow.  If that fails,
3028 // the compilation as a whole may continue without the inlining.  Some TypeFlow
3029 // requests are not optional; if they fail the requestor is responsible for
3030 // copying the failure reason up to the ciEnv.  (See Parse::Parse.)
3031 void ciTypeFlow::record_failure(const char* reason) {
3032   if (env()-&gt;log() != NULL) {
3033     env()-&gt;log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;typeflow&#39;&quot;, reason);
3034   }
3035   if (_failure_reason == NULL) {
3036     // Record the first failure reason.
3037     _failure_reason = reason;
3038   }
3039 }
3040 
3041 #ifndef PRODUCT
3042 // ------------------------------------------------------------------
3043 // ciTypeFlow::print_on
3044 void ciTypeFlow::print_on(outputStream* st) const {
3045   // Walk through CI blocks
3046   st-&gt;print_cr(&quot;********************************************************&quot;);
3047   st-&gt;print   (&quot;TypeFlow for &quot;);
3048   method()-&gt;name()-&gt;print_symbol_on(st);
3049   int limit_bci = code_size();
3050   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3051   ciMethodBlocks  *mblks = _methodBlocks;
3052   ciBlock* current = NULL;
3053   for (int bci = 0; bci &lt; limit_bci; bci++) {
3054     ciBlock* blk = mblks-&gt;block_containing(bci);
3055     if (blk != NULL &amp;&amp; blk != current) {
3056       current = blk;
3057       current-&gt;print_on(st);
3058 
3059       GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[blk-&gt;index()];
3060       int num_blocks = (blocks == NULL) ? 0 : blocks-&gt;length();
3061 
3062       if (num_blocks == 0) {
3063         st-&gt;print_cr(&quot;  No Blocks&quot;);
3064       } else {
3065         for (int i = 0; i &lt; num_blocks; i++) {
3066           Block* block = blocks-&gt;at(i);
3067           block-&gt;print_on(st);
3068         }
3069       }
3070       st-&gt;print_cr(&quot;--------------------------------------------------------&quot;);
3071       st-&gt;cr();
3072     }
3073   }
3074   st-&gt;print_cr(&quot;********************************************************&quot;);
3075   st-&gt;cr();
3076 }
3077 
3078 void ciTypeFlow::rpo_print_on(outputStream* st) const {
3079   st-&gt;print_cr(&quot;********************************************************&quot;);
3080   st-&gt;print   (&quot;TypeFlow for &quot;);
3081   method()-&gt;name()-&gt;print_symbol_on(st);
3082   int limit_bci = code_size();
3083   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3084   for (Block* blk = _rpo_list; blk != NULL; blk = blk-&gt;rpo_next()) {
3085     blk-&gt;print_on(st);
3086     st-&gt;print_cr(&quot;--------------------------------------------------------&quot;);
3087     st-&gt;cr();
3088   }
3089   st-&gt;print_cr(&quot;********************************************************&quot;);
3090   st-&gt;cr();
3091 }
3092 #endif
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
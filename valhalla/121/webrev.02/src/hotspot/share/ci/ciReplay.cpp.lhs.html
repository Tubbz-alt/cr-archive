<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciReplay.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;ci/ciSymbol.hpp&quot;
  30 #include &quot;ci/ciKlass.hpp&quot;
  31 #include &quot;ci/ciUtilities.inline.hpp&quot;
  32 #include &quot;classfile/symbolTable.hpp&quot;
  33 #include &quot;compiler/compileBroker.hpp&quot;
  34 #include &quot;memory/allocation.inline.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/constantPool.hpp&quot;
  38 #include &quot;oops/inlineKlass.inline.hpp&quot;
  39 #include &quot;oops/method.inline.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  42 #include &quot;runtime/handles.inline.hpp&quot;
  43 #include &quot;utilities/copy.hpp&quot;
  44 #include &quot;utilities/macros.hpp&quot;
  45 #include &quot;utilities/utf8.hpp&quot;
  46 
  47 #ifndef PRODUCT
  48 
  49 // ciReplay
  50 
  51 typedef struct _ciMethodDataRecord {
  52   const char* _klass_name;
  53   const char* _method_name;
  54   const char* _signature;
  55 
  56   int _state;
  57   int _current_mileage;
  58 
  59   intptr_t* _data;
  60   char*     _orig_data;
  61   Klass**   _classes;
  62   Method**  _methods;
  63   int*      _classes_offsets;
  64   int*      _methods_offsets;
  65   int       _data_length;
  66   int       _orig_data_length;
  67   int       _classes_length;
  68   int       _methods_length;
  69 } ciMethodDataRecord;
  70 
  71 typedef struct _ciMethodRecord {
  72   const char* _klass_name;
  73   const char* _method_name;
  74   const char* _signature;
  75 
  76   int _instructions_size;
  77   int _interpreter_invocation_count;
  78   int _interpreter_throwout_count;
  79   int _invocation_counter;
  80   int _backedge_counter;
  81 } ciMethodRecord;
  82 
  83 typedef struct _ciInlineRecord {
  84   const char* _klass_name;
  85   const char* _method_name;
  86   const char* _signature;
  87 
  88   int _inline_depth;
  89   int _inline_bci;
  90 } ciInlineRecord;
  91 
  92 class  CompileReplay;
  93 static CompileReplay* replay_state;
  94 
  95 class CompileReplay : public StackObj {
  96  private:
  97   FILE*   _stream;
  98   Thread* _thread;
  99   Handle  _protection_domain;
 100   Handle  _loader;
 101 
 102   GrowableArray&lt;ciMethodRecord*&gt;     _ci_method_records;
 103   GrowableArray&lt;ciMethodDataRecord*&gt; _ci_method_data_records;
 104 
 105   // Use pointer because we may need to return inline records
 106   // without destroying them.
 107   GrowableArray&lt;ciInlineRecord*&gt;*    _ci_inline_records;
 108 
 109   const char* _error_message;
 110 
 111   char* _bufptr;
 112   char* _buffer;
 113   int   _buffer_length;
 114   int   _buffer_pos;
 115 
 116   // &quot;compile&quot; data
 117   ciKlass* _iklass;
 118   Method*  _imethod;
 119   int      _entry_bci;
 120   int      _comp_level;
 121 
 122  public:
 123   CompileReplay(const char* filename, TRAPS) {
 124     _thread = THREAD;
 125     _loader = Handle(_thread, SystemDictionary::java_system_loader());
 126     _protection_domain = Handle();
 127 
 128     _stream = fopen(filename, &quot;rt&quot;);
 129     if (_stream == NULL) {
 130       fprintf(stderr, &quot;ERROR: Can&#39;t open replay file %s\n&quot;, filename);
 131     }
 132 
 133     _ci_inline_records = NULL;
 134     _error_message = NULL;
 135 
 136     _buffer_length = 32;
 137     _buffer = NEW_RESOURCE_ARRAY(char, _buffer_length);
 138     _bufptr = _buffer;
 139     _buffer_pos = 0;
 140 
 141     _imethod = NULL;
 142     _iklass  = NULL;
 143     _entry_bci  = 0;
 144     _comp_level = 0;
 145 
 146     test();
 147   }
 148 
 149   ~CompileReplay() {
 150     if (_stream != NULL) fclose(_stream);
 151   }
 152 
 153   void test() {
 154     strcpy(_buffer, &quot;1 2 foo 4 bar 0x9 \&quot;this is it\&quot;&quot;);
 155     _bufptr = _buffer;
 156     assert(parse_int(&quot;test&quot;) == 1, &quot;what&quot;);
 157     assert(parse_int(&quot;test&quot;) == 2, &quot;what&quot;);
 158     assert(strcmp(parse_string(), &quot;foo&quot;) == 0, &quot;what&quot;);
 159     assert(parse_int(&quot;test&quot;) == 4, &quot;what&quot;);
 160     assert(strcmp(parse_string(), &quot;bar&quot;) == 0, &quot;what&quot;);
 161     assert(parse_intptr_t(&quot;test&quot;) == 9, &quot;what&quot;);
 162     assert(strcmp(parse_quoted_string(), &quot;this is it&quot;) == 0, &quot;what&quot;);
 163   }
 164 
 165   bool had_error() {
 166     return _error_message != NULL || _thread-&gt;has_pending_exception();
 167   }
 168 
 169   bool can_replay() {
 170     return !(_stream == NULL || had_error());
 171   }
 172 
 173   void report_error(const char* msg) {
 174     _error_message = msg;
 175     // Restore the _buffer contents for error reporting
 176     for (int i = 0; i &lt; _buffer_pos; i++) {
 177       if (_buffer[i] == &#39;\0&#39;) _buffer[i] = &#39; &#39;;
 178     }
 179   }
 180 
 181   int parse_int(const char* label) {
 182     if (had_error()) {
 183       return 0;
 184     }
 185 
 186     int v = 0;
 187     int read;
 188     if (sscanf(_bufptr, &quot;%i%n&quot;, &amp;v, &amp;read) != 1) {
 189       report_error(label);
 190     } else {
 191       _bufptr += read;
 192     }
 193     return v;
 194   }
 195 
 196   intptr_t parse_intptr_t(const char* label) {
 197     if (had_error()) {
 198       return 0;
 199     }
 200 
 201     intptr_t v = 0;
 202     int read;
 203     if (sscanf(_bufptr, INTPTR_FORMAT &quot;%n&quot;, &amp;v, &amp;read) != 1) {
 204       report_error(label);
 205     } else {
 206       _bufptr += read;
 207     }
 208     return v;
 209   }
 210 
 211   void skip_ws() {
 212     // Skip any leading whitespace
 213     while (*_bufptr == &#39; &#39; || *_bufptr == &#39;\t&#39;) {
 214       _bufptr++;
 215     }
 216   }
 217 
 218 
 219   char* scan_and_terminate(char delim) {
 220     char* str = _bufptr;
 221     while (*_bufptr != delim &amp;&amp; *_bufptr != &#39;\0&#39;) {
 222       _bufptr++;
 223     }
 224     if (*_bufptr != &#39;\0&#39;) {
 225       *_bufptr++ = &#39;\0&#39;;
 226     }
 227     if (_bufptr == str) {
 228       // nothing here
 229       return NULL;
 230     }
 231     return str;
 232   }
 233 
 234   char* parse_string() {
 235     if (had_error()) return NULL;
 236 
 237     skip_ws();
 238     return scan_and_terminate(&#39; &#39;);
 239   }
 240 
 241   char* parse_quoted_string() {
 242     if (had_error()) return NULL;
 243 
 244     skip_ws();
 245 
 246     if (*_bufptr == &#39;&quot;&#39;) {
 247       _bufptr++;
 248       return scan_and_terminate(&#39;&quot;&#39;);
 249     } else {
 250       return scan_and_terminate(&#39; &#39;);
 251     }
 252   }
 253 
 254   const char* parse_escaped_string() {
 255     char* result = parse_quoted_string();
 256     if (result != NULL) {
 257       unescape_string(result);
 258     }
 259     return result;
 260   }
 261 
 262   // Look for the tag &#39;tag&#39; followed by an
 263   bool parse_tag_and_count(const char* tag, int&amp; length) {
 264     const char* t = parse_string();
 265     if (t == NULL) {
 266       return false;
 267     }
 268 
 269     if (strcmp(tag, t) != 0) {
 270       report_error(tag);
 271       return false;
 272     }
 273     length = parse_int(&quot;parse_tag_and_count&quot;);
 274     return !had_error();
 275   }
 276 
 277   // Parse a sequence of raw data encoded as bytes and return the
 278   // resulting data.
 279   char* parse_data(const char* tag, int&amp; length) {
 280     int read_size = 0;
 281     if (!parse_tag_and_count(tag, read_size)) {
 282       return NULL;
 283     }
 284 
 285     int actual_size = sizeof(MethodData);
 286     char *result = NEW_RESOURCE_ARRAY(char, actual_size);
 287     int i = 0;
 288     if (read_size != actual_size) {
 289       tty-&gt;print_cr(&quot;Warning: ciMethodData parsing sees MethodData size %i in file, current is %i&quot;, read_size,
 290                     actual_size);
 291       // Replay serializes the entire MethodData, but the data is at the end.
 292       // If the MethodData instance size has changed, we can pad or truncate in the beginning
 293       int padding = actual_size - read_size;
 294       if (padding &gt; 0) {
 295         // pad missing data with zeros
 296         tty-&gt;print_cr(&quot;- Padding MethodData&quot;);
 297         for (; i &lt; padding; i++) {
 298           result[i] = 0;
 299         }
 300       } else if (padding &lt; 0) {
 301         // drop some data
 302         tty-&gt;print_cr(&quot;- Truncating MethodData&quot;);
 303         for (int j = 0; j &lt; -padding; j++) {
 304           int val = parse_int(&quot;data&quot;);
 305           // discard val
 306         }
 307       }
 308     }
 309 
 310     assert(i &lt; actual_size, &quot;At least some data must remain to be copied&quot;);
 311     for (; i &lt; actual_size; i++) {
 312       int val = parse_int(&quot;data&quot;);
 313       result[i] = val;
 314     }
 315     length = actual_size;
 316     return result;
 317   }
 318 
 319   // Parse a standard chunk of data emitted as:
 320   //   &#39;tag&#39; &lt;length&gt; # # ...
 321   // Where each # is an intptr_t item
 322   intptr_t* parse_intptr_data(const char* tag, int&amp; length) {
 323     if (!parse_tag_and_count(tag, length)) {
 324       return NULL;
 325     }
 326 
 327     intptr_t* result = NEW_RESOURCE_ARRAY(intptr_t, length);
 328     for (int i = 0; i &lt; length; i++) {
 329       skip_ws();
 330       intptr_t val = parse_intptr_t(&quot;data&quot;);
 331       result[i] = val;
 332     }
 333     return result;
 334   }
 335 
 336   // Parse a possibly quoted version of a symbol into a symbolOop
 337   Symbol* parse_symbol(TRAPS) {
 338     const char* str = parse_escaped_string();
 339     if (str != NULL) {
 340       Symbol* sym = SymbolTable::new_symbol(str);
 341       return sym;
 342     }
 343     return NULL;
 344   }
 345 
 346   // Parse a valid klass name and look it up
 347   Klass* parse_klass(TRAPS) {
 348     const char* str = parse_escaped_string();
 349     Symbol* klass_name = SymbolTable::new_symbol(str);
 350     if (klass_name != NULL) {
 351       Klass* k = NULL;
 352       if (_iklass != NULL) {
 353         k = (Klass*)_iklass-&gt;find_klass(ciSymbol::make(klass_name-&gt;as_C_string()))-&gt;constant_encoding();
 354       } else {
 355         k = SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 356       }
 357       if (HAS_PENDING_EXCEPTION) {
 358         oop throwable = PENDING_EXCEPTION;
 359         java_lang_Throwable::print(throwable, tty);
 360         tty-&gt;cr();
 361         report_error(str);
 362         if (ReplayIgnoreInitErrors) {
 363           CLEAR_PENDING_EXCEPTION;
 364           _error_message = NULL;
 365         }
 366         return NULL;
 367       }
 368       return k;
 369     }
 370     return NULL;
 371   }
 372 
 373   // Lookup a klass
 374   Klass* resolve_klass(const char* klass, TRAPS) {
 375     Symbol* klass_name = SymbolTable::new_symbol(klass);
 376     return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 377   }
 378 
 379   // Parse the standard tuple of &lt;klass&gt; &lt;name&gt; &lt;signature&gt;
 380   Method* parse_method(TRAPS) {
 381     InstanceKlass* k = (InstanceKlass*)parse_klass(CHECK_NULL);
 382     if (k == NULL) {
 383       report_error(&quot;Can&#39;t find holder klass&quot;);
 384       return NULL;
 385     }
 386     Symbol* method_name = parse_symbol(CHECK_NULL);
 387     Symbol* method_signature = parse_symbol(CHECK_NULL);
 388     Method* m = k-&gt;find_method(method_name, method_signature);
 389     if (m == NULL) {
 390       report_error(&quot;Can&#39;t find method&quot;);
 391     }
 392     return m;
 393   }
 394 
 395   int get_line(int c) {
 396     while(c != EOF) {
 397       if (_buffer_pos + 1 &gt;= _buffer_length) {
 398         int new_length = _buffer_length * 2;
 399         // Next call will throw error in case of OOM.
 400         _buffer = REALLOC_RESOURCE_ARRAY(char, _buffer, _buffer_length, new_length);
 401         _buffer_length = new_length;
 402       }
 403       if (c == &#39;\n&#39;) {
 404         c = getc(_stream); // get next char
 405         break;
 406       } else if (c == &#39;\r&#39;) {
 407         // skip LF
 408       } else {
 409         _buffer[_buffer_pos++] = c;
 410       }
 411       c = getc(_stream);
 412     }
 413     // null terminate it, reset the pointer
 414     _buffer[_buffer_pos] = &#39;\0&#39;; // NL or EOF
 415     _buffer_pos = 0;
 416     _bufptr = _buffer;
 417     return c;
 418   }
 419 
 420   // Process each line of the replay file executing each command until
 421   // the file ends.
 422   void process(TRAPS) {
 423     int line_no = 1;
 424     int c = getc(_stream);
 425     while(c != EOF) {
 426       c = get_line(c);
 427       process_command(THREAD);
 428       if (had_error()) {
 429         tty-&gt;print_cr(&quot;Error while parsing line %d: %s\n&quot;, line_no, _error_message);
 430         if (ReplayIgnoreInitErrors) {
 431           CLEAR_PENDING_EXCEPTION;
 432           _error_message = NULL;
 433         } else {
 434           return;
 435         }
 436       }
 437       line_no++;
 438     }
 439   }
 440 
 441   void process_command(TRAPS) {
 442     char* cmd = parse_string();
 443     if (cmd == NULL) {
 444       return;
 445     }
 446     if (strcmp(&quot;#&quot;, cmd) == 0) {
 447       // ignore
 448     } else if (strcmp(&quot;compile&quot;, cmd) == 0) {
 449       process_compile(CHECK);
 450     } else if (strcmp(&quot;ciMethod&quot;, cmd) == 0) {
 451       process_ciMethod(CHECK);
 452     } else if (strcmp(&quot;ciMethodData&quot;, cmd) == 0) {
 453       process_ciMethodData(CHECK);
 454     } else if (strcmp(&quot;staticfield&quot;, cmd) == 0) {
 455       process_staticfield(CHECK);
 456     } else if (strcmp(&quot;ciInstanceKlass&quot;, cmd) == 0) {
 457       process_ciInstanceKlass(CHECK);
 458     } else if (strcmp(&quot;instanceKlass&quot;, cmd) == 0) {
 459       process_instanceKlass(CHECK);
 460 #if INCLUDE_JVMTI
 461     } else if (strcmp(&quot;JvmtiExport&quot;, cmd) == 0) {
 462       process_JvmtiExport(CHECK);
 463 #endif // INCLUDE_JVMTI
 464     } else {
 465       report_error(&quot;unknown command&quot;);
 466     }
 467   }
 468 
 469   // validation of comp_level
 470   bool is_valid_comp_level(int comp_level) {
 471     const int msg_len = 256;
 472     char* msg = NULL;
 473     if (!is_compile(comp_level)) {
 474       msg = NEW_RESOURCE_ARRAY(char, msg_len);
 475       jio_snprintf(msg, msg_len, &quot;%d isn&#39;t compilation level&quot;, comp_level);
 476     } else if (!TieredCompilation &amp;&amp; (comp_level != CompLevel_highest_tier)) {
 477       msg = NEW_RESOURCE_ARRAY(char, msg_len);
 478       switch (comp_level) {
 479         case CompLevel_simple:
 480           jio_snprintf(msg, msg_len, &quot;compilation level %d requires Client VM or TieredCompilation&quot;, comp_level);
 481           break;
 482         case CompLevel_full_optimization:
 483           jio_snprintf(msg, msg_len, &quot;compilation level %d requires Server VM&quot;, comp_level);
 484           break;
 485         default:
 486           jio_snprintf(msg, msg_len, &quot;compilation level %d requires TieredCompilation&quot;, comp_level);
 487       }
 488     }
 489     if (msg != NULL) {
 490       report_error(msg);
 491       return false;
 492     }
 493     return true;
 494   }
 495 
 496   // compile &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;entry_bci&gt; &lt;comp_level&gt; inline &lt;count&gt; &lt;depth&gt; &lt;bci&gt; &lt;klass&gt; &lt;name&gt; &lt;signature&gt; ...
 497   void* process_inline(ciMethod* imethod, Method* m, int entry_bci, int comp_level, TRAPS) {
 498     _imethod    = m;
 499     _iklass     = imethod-&gt;holder();
 500     _entry_bci  = entry_bci;
 501     _comp_level = comp_level;
 502     int line_no = 1;
 503     int c = getc(_stream);
 504     while(c != EOF) {
 505       c = get_line(c);
 506       // Expecting only lines with &quot;compile&quot; command in inline replay file.
 507       char* cmd = parse_string();
 508       if (cmd == NULL || strcmp(&quot;compile&quot;, cmd) != 0) {
 509         return NULL;
 510       }
 511       process_compile(CHECK_NULL);
 512       if (had_error()) {
 513         tty-&gt;print_cr(&quot;Error while parsing line %d: %s\n&quot;, line_no, _error_message);
 514         tty-&gt;print_cr(&quot;%s&quot;, _buffer);
 515         return NULL;
 516       }
 517       if (_ci_inline_records != NULL &amp;&amp; _ci_inline_records-&gt;length() &gt; 0) {
 518         // Found inlining record for the requested method.
 519         return _ci_inline_records;
 520       }
 521       line_no++;
 522     }
 523     return NULL;
 524   }
 525 
 526   // compile &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;entry_bci&gt; &lt;comp_level&gt; inline &lt;count&gt; &lt;depth&gt; &lt;bci&gt; &lt;klass&gt; &lt;name&gt; &lt;signature&gt; ...
 527   void process_compile(TRAPS) {
 528     Method* method = parse_method(CHECK);
 529     if (had_error()) return;
 530     int entry_bci = parse_int(&quot;entry_bci&quot;);
 531     const char* comp_level_label = &quot;comp_level&quot;;
 532     int comp_level = parse_int(comp_level_label);
 533     // old version w/o comp_level
 534     if (had_error() &amp;&amp; (error_message() == comp_level_label)) {
 535       // use highest available tier
 536       if (TieredCompilation) {
 537         comp_level = TieredStopAtLevel;
 538       } else {
 539         comp_level = CompLevel_highest_tier;
 540       }
 541     }
 542     if (!is_valid_comp_level(comp_level)) {
 543       return;
 544     }
 545     if (_imethod != NULL) {
 546       // Replay Inlining
 547       if (entry_bci != _entry_bci || comp_level != _comp_level) {
 548         return;
 549       }
 550       const char* iklass_name  = _imethod-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 551       const char* imethod_name = _imethod-&gt;name()-&gt;as_utf8();
 552       const char* isignature   = _imethod-&gt;signature()-&gt;as_utf8();
 553       const char* klass_name   = method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 554       const char* method_name  = method-&gt;name()-&gt;as_utf8();
 555       const char* signature    = method-&gt;signature()-&gt;as_utf8();
 556       if (strcmp(iklass_name,  klass_name)  != 0 ||
 557           strcmp(imethod_name, method_name) != 0 ||
 558           strcmp(isignature,   signature)   != 0) {
 559         return;
 560       }
 561     }
 562     int inline_count = 0;
 563     if (parse_tag_and_count(&quot;inline&quot;, inline_count)) {
 564       // Record inlining data
 565       _ci_inline_records = new GrowableArray&lt;ciInlineRecord*&gt;();
 566       for (int i = 0; i &lt; inline_count; i++) {
 567         int depth = parse_int(&quot;inline_depth&quot;);
 568         int bci = parse_int(&quot;inline_bci&quot;);
 569         if (had_error()) {
 570           break;
 571         }
 572         Method* inl_method = parse_method(CHECK);
 573         if (had_error()) {
 574           break;
 575         }
 576         new_ciInlineRecord(inl_method, bci, depth);
 577       }
 578     }
 579     if (_imethod != NULL) {
 580       return; // Replay Inlining
 581     }
 582     InstanceKlass* ik = method-&gt;method_holder();
 583     ik-&gt;initialize(THREAD);
 584     if (HAS_PENDING_EXCEPTION) {
 585       oop throwable = PENDING_EXCEPTION;
 586       java_lang_Throwable::print(throwable, tty);
 587       tty-&gt;cr();
 588       if (ReplayIgnoreInitErrors) {
 589         CLEAR_PENDING_EXCEPTION;
 590         ik-&gt;set_init_state(InstanceKlass::fully_initialized);
 591       } else {
 592         return;
 593       }
 594     }
 595     // Make sure the existence of a prior compile doesn&#39;t stop this one
 596     CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) : method-&gt;code();
 597     if (nm != NULL) {
 598       nm-&gt;make_not_entrant();
 599     }
 600     replay_state = this;
 601     CompileBroker::compile_method(methodHandle(THREAD, method), entry_bci, comp_level,
 602                                   methodHandle(), 0, CompileTask::Reason_Replay, THREAD);
 603     replay_state = NULL;
 604     reset();
 605   }
 606 
 607   // ciMethod &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;invocation_counter&gt; &lt;backedge_counter&gt; &lt;interpreter_invocation_count&gt; &lt;interpreter_throwout_count&gt; &lt;instructions_size&gt;
 608   //
 609   //
 610   void process_ciMethod(TRAPS) {
 611     Method* method = parse_method(CHECK);
 612     if (had_error()) return;
 613     ciMethodRecord* rec = new_ciMethod(method);
 614     rec-&gt;_invocation_counter = parse_int(&quot;invocation_counter&quot;);
 615     rec-&gt;_backedge_counter = parse_int(&quot;backedge_counter&quot;);
 616     rec-&gt;_interpreter_invocation_count = parse_int(&quot;interpreter_invocation_count&quot;);
 617     rec-&gt;_interpreter_throwout_count = parse_int(&quot;interpreter_throwout_count&quot;);
 618     rec-&gt;_instructions_size = parse_int(&quot;instructions_size&quot;);
 619   }
 620 
 621   // ciMethodData &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;state&gt; &lt;current mileage&gt; orig &lt;length&gt; # # ... data &lt;length&gt; # # ... oops &lt;length&gt; # ... methods &lt;length&gt;
 622   void process_ciMethodData(TRAPS) {
 623     Method* method = parse_method(CHECK);
 624     if (had_error()) return;
 625     /* just copied from Method, to build interpret data*/
 626 
 627     // To be properly initialized, some profiling in the MDO needs the
 628     // method to be rewritten (number of arguments at a call for
 629     // instance)
 630     method-&gt;method_holder()-&gt;link_class(CHECK);
 631     // methodOopDesc::build_interpreter_method_data(method, CHECK);
 632     {
 633       // Grab a lock here to prevent multiple
 634       // MethodData*s from being created.
 635       MutexLocker ml(THREAD, MethodData_lock);
 636       if (method-&gt;method_data() == NULL) {
 637         ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
 638         MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);
 639         method-&gt;set_method_data(method_data);
 640       }
 641     }
 642 
 643     // collect and record all the needed information for later
 644     ciMethodDataRecord* rec = new_ciMethodData(method);
 645     rec-&gt;_state = parse_int(&quot;state&quot;);
 646     rec-&gt;_current_mileage = parse_int(&quot;current_mileage&quot;);
 647 
 648     rec-&gt;_orig_data = parse_data(&quot;orig&quot;, rec-&gt;_orig_data_length);
 649     if (rec-&gt;_orig_data == NULL) {
 650       return;
 651     }
 652     rec-&gt;_data = parse_intptr_data(&quot;data&quot;, rec-&gt;_data_length);
 653     if (rec-&gt;_data == NULL) {
 654       return;
 655     }
 656     if (!parse_tag_and_count(&quot;oops&quot;, rec-&gt;_classes_length)) {
 657       return;
 658     }
 659     rec-&gt;_classes = NEW_RESOURCE_ARRAY(Klass*, rec-&gt;_classes_length);
 660     rec-&gt;_classes_offsets = NEW_RESOURCE_ARRAY(int, rec-&gt;_classes_length);
 661     for (int i = 0; i &lt; rec-&gt;_classes_length; i++) {
 662       int offset = parse_int(&quot;offset&quot;);
 663       if (had_error()) {
 664         return;
 665       }
 666       Klass* k = parse_klass(CHECK);
 667       rec-&gt;_classes_offsets[i] = offset;
 668       rec-&gt;_classes[i] = k;
 669     }
 670 
 671     if (!parse_tag_and_count(&quot;methods&quot;, rec-&gt;_methods_length)) {
 672       return;
 673     }
 674     rec-&gt;_methods = NEW_RESOURCE_ARRAY(Method*, rec-&gt;_methods_length);
 675     rec-&gt;_methods_offsets = NEW_RESOURCE_ARRAY(int, rec-&gt;_methods_length);
 676     for (int i = 0; i &lt; rec-&gt;_methods_length; i++) {
 677       int offset = parse_int(&quot;offset&quot;);
 678       if (had_error()) {
 679         return;
 680       }
 681       Method* m = parse_method(CHECK);
 682       rec-&gt;_methods_offsets[i] = offset;
 683       rec-&gt;_methods[i] = m;
 684     }
 685   }
 686 
 687   // instanceKlass &lt;name&gt;
 688   //
 689   // Loads and initializes the klass &#39;name&#39;.  This can be used to
 690   // create particular class loading environments
 691   void process_instanceKlass(TRAPS) {
 692     // just load the referenced class
 693     Klass* k = parse_klass(CHECK);
 694   }
 695 
 696   // ciInstanceKlass &lt;name&gt; &lt;is_linked&gt; &lt;is_initialized&gt; &lt;length&gt; tag # # # ...
 697   //
 698   // Load the klass &#39;name&#39; and link or initialize it.  Verify that the
 699   // constant pool is the same length as &#39;length&#39; and make sure the
 700   // constant pool tags are in the same state.
 701   void process_ciInstanceKlass(TRAPS) {
 702     InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
 703     if (k == NULL) {
 704       return;
 705     }
 706     int is_linked = parse_int(&quot;is_linked&quot;);
 707     int is_initialized = parse_int(&quot;is_initialized&quot;);
 708     int length = parse_int(&quot;length&quot;);
 709     if (is_initialized) {
 710       k-&gt;initialize(THREAD);
 711       if (HAS_PENDING_EXCEPTION) {
 712         oop throwable = PENDING_EXCEPTION;
 713         java_lang_Throwable::print(throwable, tty);
 714         tty-&gt;cr();
 715         if (ReplayIgnoreInitErrors) {
 716           CLEAR_PENDING_EXCEPTION;
 717           k-&gt;set_init_state(InstanceKlass::fully_initialized);
 718         } else {
 719           return;
 720         }
 721       }
 722     } else if (is_linked) {
 723       k-&gt;link_class(CHECK);
 724     }
 725     ConstantPool* cp = k-&gt;constants();
 726     if (length != cp-&gt;length()) {
 727       report_error(&quot;constant pool length mismatch: wrong class files?&quot;);
 728       return;
 729     }
 730 
 731     int parsed_two_word = 0;
 732     for (int i = 1; i &lt; length; i++) {
 733       int tag = parse_int(&quot;tag&quot;);
 734       if (had_error()) {
 735         return;
 736       }
 737       switch (cp-&gt;tag_at(i).value()) {
 738         case JVM_CONSTANT_UnresolvedClass: {
 739           if (tag == JVM_CONSTANT_Class) {
 740             tty-&gt;print_cr(&quot;Resolving klass %s at %d&quot;, cp-&gt;klass_name_at(i)-&gt;as_utf8(), i);
 741             Klass* k = cp-&gt;klass_at(i, CHECK);
 742           }
 743           break;
 744         }
 745 
 746         case JVM_CONSTANT_Long:
 747         case JVM_CONSTANT_Double:
 748           parsed_two_word = i + 1;
 749 
 750         case JVM_CONSTANT_ClassIndex:
 751         case JVM_CONSTANT_StringIndex:
 752         case JVM_CONSTANT_String:
 753         case JVM_CONSTANT_UnresolvedClassInError:
 754         case JVM_CONSTANT_Fieldref:
 755         case JVM_CONSTANT_Methodref:
 756         case JVM_CONSTANT_InterfaceMethodref:
 757         case JVM_CONSTANT_NameAndType:
 758         case JVM_CONSTANT_Utf8:
 759         case JVM_CONSTANT_Integer:
 760         case JVM_CONSTANT_Float:
 761         case JVM_CONSTANT_MethodHandle:
 762         case JVM_CONSTANT_MethodType:
 763         case JVM_CONSTANT_Dynamic:
 764         case JVM_CONSTANT_InvokeDynamic:
 765           if (tag != cp-&gt;tag_at(i).value()) {
 766             report_error(&quot;tag mismatch: wrong class files?&quot;);
 767             return;
 768           }
 769           break;
 770 
 771         case JVM_CONSTANT_Class:
 772           if (tag == JVM_CONSTANT_Class) {
 773           } else if (tag == JVM_CONSTANT_UnresolvedClass) {
 774             tty-&gt;print_cr(&quot;Warning: entry was unresolved in the replay data&quot;);
 775           } else {
 776             report_error(&quot;Unexpected tag&quot;);
 777             return;
 778           }
 779           break;
 780 
 781         case 0:
 782           if (parsed_two_word == i) continue;
 783 
 784         default:
 785           fatal(&quot;Unexpected tag: %d&quot;, cp-&gt;tag_at(i).value());
 786           break;
 787       }
 788 
 789     }
 790   }
 791 
<a name="1" id="anc1"></a><span class="line-modified"> 792   class ValueTypeFieldInitializer : public FieldClosure {</span>
 793     oop _vt;
 794     CompileReplay* _replay;
 795   public:
<a name="2" id="anc2"></a><span class="line-modified"> 796     ValueTypeFieldInitializer(oop vt, CompileReplay* replay)</span>
 797   : _vt(vt), _replay(replay) {}
 798 
 799     void do_field(fieldDescriptor* fd) {
 800       BasicType bt = fd-&gt;field_type();
 801       const char* string_value = bt != T_INLINE_TYPE ? _replay-&gt;parse_escaped_string() : NULL;
 802       switch (bt) {
 803       case T_BYTE: {
 804         int value = atoi(string_value);
 805         _vt-&gt;byte_field_put(fd-&gt;offset(), value);
 806         break;
 807       }
 808       case T_BOOLEAN: {
 809         int value = atoi(string_value);
 810         _vt-&gt;bool_field_put(fd-&gt;offset(), value);
 811         break;
 812       }
 813       case T_SHORT: {
 814         int value = atoi(string_value);
 815         _vt-&gt;short_field_put(fd-&gt;offset(), value);
 816         break;
 817       }
 818       case T_CHAR: {
 819         int value = atoi(string_value);
 820         _vt-&gt;char_field_put(fd-&gt;offset(), value);
 821         break;
 822       }
 823       case T_INT: {
 824         int value = atoi(string_value);
 825         _vt-&gt;int_field_put(fd-&gt;offset(), value);
 826         break;
 827       }
 828       case T_LONG: {
 829         jlong value;
 830         if (sscanf(string_value, JLONG_FORMAT, &amp;value) != 1) {
 831           fprintf(stderr, &quot;Error parsing long: %s\n&quot;, string_value);
 832           break;
 833         }
 834         _vt-&gt;long_field_put(fd-&gt;offset(), value);
 835         break;
 836       }
 837       case T_FLOAT: {
 838         float value = atof(string_value);
 839         _vt-&gt;float_field_put(fd-&gt;offset(), value);
 840         break;
 841       }
 842       case T_DOUBLE: {
 843         double value = atof(string_value);
 844         _vt-&gt;double_field_put(fd-&gt;offset(), value);
 845         break;
 846       }
 847       case T_ARRAY:
 848       case T_OBJECT: {
 849         Thread* THREAD = Thread::current();
 850         bool res = _replay-&gt;process_staticfield_reference(string_value, _vt, fd, THREAD);
 851         assert(res, &quot;should succeed for arrays &amp; objects&quot;);
 852         break;
 853       }
 854       case T_INLINE_TYPE: {
 855         InlineKlass* vk = InlineKlass::cast(fd-&gt;field_holder()-&gt;get_inline_type_field_klass(fd-&gt;index()));
 856         if (fd-&gt;is_inlined()) {
 857           int field_offset = fd-&gt;offset() - vk-&gt;first_field_offset();
 858           oop obj = (oop)(cast_from_oop&lt;address&gt;(_vt) + field_offset);
<a name="3" id="anc3"></a><span class="line-modified"> 859           ValueTypeFieldInitializer init_fields(obj, _replay);</span>
 860           vk-&gt;do_nonstatic_fields(&amp;init_fields);
 861         } else {
 862           oop value = vk-&gt;allocate_instance(Thread::current());
 863           _vt-&gt;obj_field_put(fd-&gt;offset(), value);
 864         }
 865         break;
 866       }
 867       default: {
 868         fatal(&quot;Unhandled type: %s&quot;, type2name(bt));
 869       }
 870       }
 871     }
 872   };
 873 
 874   bool process_staticfield_reference(const char* field_signature, oop java_mirror, fieldDescriptor* fd, TRAPS) {
 875     if (field_signature[0] == JVM_SIGNATURE_ARRAY) {
 876       int length = parse_int(&quot;array length&quot;);
 877       oop value = NULL;
 878 
 879       if (field_signature[1] == JVM_SIGNATURE_ARRAY) {
 880         // multi dimensional array
 881         Klass* k = resolve_klass(field_signature, CHECK_(true));
 882         ArrayKlass* kelem = (ArrayKlass *)k;
 883         int rank = 0;
 884         while (field_signature[rank] == JVM_SIGNATURE_ARRAY) {
 885           rank++;
 886         }
 887         jint* dims = NEW_RESOURCE_ARRAY(jint, rank);
 888         dims[0] = length;
 889         for (int i = 1; i &lt; rank; i++) {
 890           dims[i] = 1; // These aren&#39;t relevant to the compiler
 891         }
 892         value = kelem-&gt;multi_allocate(rank, dims, CHECK_(true));
 893       } else {
 894         if (strcmp(field_signature, &quot;[B&quot;) == 0) {
 895           value = oopFactory::new_byteArray(length, CHECK_(true));
 896         } else if (strcmp(field_signature, &quot;[Z&quot;) == 0) {
 897           value = oopFactory::new_boolArray(length, CHECK_(true));
 898         } else if (strcmp(field_signature, &quot;[C&quot;) == 0) {
 899           value = oopFactory::new_charArray(length, CHECK_(true));
 900         } else if (strcmp(field_signature, &quot;[S&quot;) == 0) {
 901           value = oopFactory::new_shortArray(length, CHECK_(true));
 902         } else if (strcmp(field_signature, &quot;[F&quot;) == 0) {
 903           value = oopFactory::new_floatArray(length, CHECK_(true));
 904         } else if (strcmp(field_signature, &quot;[D&quot;) == 0) {
 905           value = oopFactory::new_doubleArray(length, CHECK_(true));
 906         } else if (strcmp(field_signature, &quot;[I&quot;) == 0) {
 907           value = oopFactory::new_intArray(length, CHECK_(true));
 908         } else if (strcmp(field_signature, &quot;[J&quot;) == 0) {
 909           value = oopFactory::new_longArray(length, CHECK_(true));
 910         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &amp;&amp;
 911                    field_signature[1] == JVM_SIGNATURE_CLASS) {
 912           Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));
 913           value = oopFactory::new_objArray(kelem, length, CHECK_(true));
 914         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &amp;&amp;
 915                    field_signature[1] == JVM_SIGNATURE_INLINE_TYPE) {
 916           Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));
 917           value = oopFactory::new_flatArray(kelem, length, CHECK_(true));
 918         } else {
 919           report_error(&quot;unhandled array staticfield&quot;);
 920         }
 921       }
 922       java_mirror-&gt;obj_field_put(fd-&gt;offset(), value);
 923       return true;
 924     } else if (strcmp(field_signature, &quot;Ljava/lang/String;&quot;) == 0) {
 925       const char* string_value = parse_escaped_string();
 926       Handle value = java_lang_String::create_from_str(string_value, CHECK_(true));
 927       java_mirror-&gt;obj_field_put(fd-&gt;offset(), value());
 928       return true;
 929     } else if (field_signature[0] == &#39;L&#39;) {
 930       const char* instance = parse_escaped_string();
 931       Klass* k = resolve_klass(instance, CHECK_(true));
 932       oop value = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_(true));
 933       java_mirror-&gt;obj_field_put(fd-&gt;offset(), value);
 934       return true;
 935     }
 936     return false;
 937   }
 938 
 939   // Initialize a class and fill in the value for a static field.
 940   // This is useful when the compile was dependent on the value of
 941   // static fields but it&#39;s impossible to properly rerun the static
 942   // initializer.
 943   void process_staticfield(TRAPS) {
 944     InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
 945 
 946     if (k == NULL || ReplaySuppressInitializers == 0 ||
 947         (ReplaySuppressInitializers == 2 &amp;&amp; k-&gt;class_loader() == NULL)) {
 948       return;
 949     }
 950 
 951     assert(k-&gt;is_initialized(), &quot;must be&quot;);
 952 
 953     const char* field_name = parse_escaped_string();
 954     const char* field_signature = parse_string();
 955     fieldDescriptor fd;
 956     Symbol* name = SymbolTable::new_symbol(field_name);
 957     Symbol* sig = SymbolTable::new_symbol(field_signature);
 958     if (!k-&gt;find_local_field(name, sig, &amp;fd) ||
 959         !fd.is_static() ||
 960         fd.has_initial_value()) {
 961       report_error(field_name);
 962       return;
 963     }
 964 
 965     oop java_mirror = k-&gt;java_mirror();
 966     if (strcmp(field_signature, &quot;I&quot;) == 0) {
 967       const char* string_value = parse_escaped_string();
 968       int value = atoi(string_value);
 969       java_mirror-&gt;int_field_put(fd.offset(), value);
 970     } else if (strcmp(field_signature, &quot;B&quot;) == 0) {
 971       const char* string_value = parse_escaped_string();
 972       int value = atoi(string_value);
 973       java_mirror-&gt;byte_field_put(fd.offset(), value);
 974     } else if (strcmp(field_signature, &quot;C&quot;) == 0) {
 975       const char* string_value = parse_escaped_string();
 976       int value = atoi(string_value);
 977       java_mirror-&gt;char_field_put(fd.offset(), value);
 978     } else if (strcmp(field_signature, &quot;S&quot;) == 0) {
 979       const char* string_value = parse_escaped_string();
 980       int value = atoi(string_value);
 981       java_mirror-&gt;short_field_put(fd.offset(), value);
 982     } else if (strcmp(field_signature, &quot;Z&quot;) == 0) {
 983       const char* string_value = parse_escaped_string();
 984       int value = atoi(string_value);
 985       java_mirror-&gt;bool_field_put(fd.offset(), value);
 986     } else if (strcmp(field_signature, &quot;J&quot;) == 0) {
 987       const char* string_value = parse_escaped_string();
 988       jlong value;
 989       if (sscanf(string_value, JLONG_FORMAT, &amp;value) != 1) {
 990         fprintf(stderr, &quot;Error parsing long: %s\n&quot;, string_value);
 991         return;
 992       }
 993       java_mirror-&gt;long_field_put(fd.offset(), value);
 994     } else if (strcmp(field_signature, &quot;F&quot;) == 0) {
 995       const char* string_value = parse_escaped_string();
 996       float value = atof(string_value);
 997       java_mirror-&gt;float_field_put(fd.offset(), value);
 998     } else if (strcmp(field_signature, &quot;D&quot;) == 0) {
 999       const char* string_value = parse_escaped_string();
1000       double value = atof(string_value);
1001       java_mirror-&gt;double_field_put(fd.offset(), value);
1002     } else if (field_signature[0] == JVM_SIGNATURE_INLINE_TYPE) {
1003       Klass* kelem = resolve_klass(field_signature, CHECK);
1004       InlineKlass* vk = InlineKlass::cast(kelem);
1005       oop value = vk-&gt;allocate_instance(CHECK);
<a name="4" id="anc4"></a><span class="line-modified">1006       ValueTypeFieldInitializer init_fields(value, this);</span>
1007       vk-&gt;do_nonstatic_fields(&amp;init_fields);
1008       java_mirror-&gt;obj_field_put(fd.offset(), value);
1009     } else {
1010       bool res = process_staticfield_reference(field_signature, java_mirror, &amp;fd, CHECK);
1011       if (!res)  {
1012         report_error(&quot;unhandled staticfield&quot;);
1013       }
1014     }
1015   }
1016 
1017 #if INCLUDE_JVMTI
1018   void process_JvmtiExport(TRAPS) {
1019     const char* field = parse_string();
1020     bool value = parse_int(&quot;JvmtiExport flag&quot;) != 0;
1021     if (strcmp(field, &quot;can_access_local_variables&quot;) == 0) {
1022       JvmtiExport::set_can_access_local_variables(value);
1023     } else if (strcmp(field, &quot;can_hotswap_or_post_breakpoint&quot;) == 0) {
1024       JvmtiExport::set_can_hotswap_or_post_breakpoint(value);
1025     } else if (strcmp(field, &quot;can_post_on_exceptions&quot;) == 0) {
1026       JvmtiExport::set_can_post_on_exceptions(value);
1027     } else {
1028       report_error(&quot;Unrecognized JvmtiExport directive&quot;);
1029     }
1030   }
1031 #endif // INCLUDE_JVMTI
1032 
1033   // Create and initialize a record for a ciMethod
1034   ciMethodRecord* new_ciMethod(Method* method) {
1035     ciMethodRecord* rec = NEW_RESOURCE_OBJ(ciMethodRecord);
1036     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1037     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
1038     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
1039     _ci_method_records.append(rec);
1040     return rec;
1041   }
1042 
1043   // Lookup data for a ciMethod
1044   ciMethodRecord* find_ciMethodRecord(Method* method) {
1045     const char* klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1046     const char* method_name = method-&gt;name()-&gt;as_utf8();
1047     const char* signature = method-&gt;signature()-&gt;as_utf8();
1048     for (int i = 0; i &lt; _ci_method_records.length(); i++) {
1049       ciMethodRecord* rec = _ci_method_records.at(i);
1050       if (strcmp(rec-&gt;_klass_name, klass_name) == 0 &amp;&amp;
1051           strcmp(rec-&gt;_method_name, method_name) == 0 &amp;&amp;
1052           strcmp(rec-&gt;_signature, signature) == 0) {
1053         return rec;
1054       }
1055     }
1056     return NULL;
1057   }
1058 
1059   // Create and initialize a record for a ciMethodData
1060   ciMethodDataRecord* new_ciMethodData(Method* method) {
1061     ciMethodDataRecord* rec = NEW_RESOURCE_OBJ(ciMethodDataRecord);
1062     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1063     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
1064     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
1065     _ci_method_data_records.append(rec);
1066     return rec;
1067   }
1068 
1069   // Lookup data for a ciMethodData
1070   ciMethodDataRecord* find_ciMethodDataRecord(Method* method) {
1071     const char* klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1072     const char* method_name = method-&gt;name()-&gt;as_utf8();
1073     const char* signature = method-&gt;signature()-&gt;as_utf8();
1074     for (int i = 0; i &lt; _ci_method_data_records.length(); i++) {
1075       ciMethodDataRecord* rec = _ci_method_data_records.at(i);
1076       if (strcmp(rec-&gt;_klass_name, klass_name) == 0 &amp;&amp;
1077           strcmp(rec-&gt;_method_name, method_name) == 0 &amp;&amp;
1078           strcmp(rec-&gt;_signature, signature) == 0) {
1079         return rec;
1080       }
1081     }
1082     return NULL;
1083   }
1084 
1085   // Create and initialize a record for a ciInlineRecord
1086   ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth) {
1087     ciInlineRecord* rec = NEW_RESOURCE_OBJ(ciInlineRecord);
1088     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1089     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
1090     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
1091     rec-&gt;_inline_bci = bci;
1092     rec-&gt;_inline_depth = depth;
1093     _ci_inline_records-&gt;append(rec);
1094     return rec;
1095   }
1096 
1097   // Lookup inlining data for a ciMethod
1098   ciInlineRecord* find_ciInlineRecord(Method* method, int bci, int depth) {
1099     if (_ci_inline_records != NULL) {
1100       return find_ciInlineRecord(_ci_inline_records, method, bci, depth);
1101     }
1102     return NULL;
1103   }
1104 
1105   static ciInlineRecord* find_ciInlineRecord(GrowableArray&lt;ciInlineRecord*&gt;*  records,
1106                                       Method* method, int bci, int depth) {
1107     if (records != NULL) {
1108       const char* klass_name  = method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1109       const char* method_name = method-&gt;name()-&gt;as_utf8();
1110       const char* signature   = method-&gt;signature()-&gt;as_utf8();
1111       for (int i = 0; i &lt; records-&gt;length(); i++) {
1112         ciInlineRecord* rec = records-&gt;at(i);
1113         if ((rec-&gt;_inline_bci == bci) &amp;&amp;
1114             (rec-&gt;_inline_depth == depth) &amp;&amp;
1115             (strcmp(rec-&gt;_klass_name, klass_name) == 0) &amp;&amp;
1116             (strcmp(rec-&gt;_method_name, method_name) == 0) &amp;&amp;
1117             (strcmp(rec-&gt;_signature, signature) == 0)) {
1118           return rec;
1119         }
1120       }
1121     }
1122     return NULL;
1123   }
1124 
1125   const char* error_message() {
1126     return _error_message;
1127   }
1128 
1129   void reset() {
1130     _error_message = NULL;
1131     _ci_method_records.clear();
1132     _ci_method_data_records.clear();
1133   }
1134 
1135   // Take an ascii string contain \u#### escapes and convert it to utf8
1136   // in place.
1137   static void unescape_string(char* value) {
1138     char* from = value;
1139     char* to = value;
1140     while (*from != &#39;\0&#39;) {
1141       if (*from != &#39;\\&#39;) {
1142         *from++ = *to++;
1143       } else {
1144         switch (from[1]) {
1145           case &#39;u&#39;: {
1146             from += 2;
1147             jchar value=0;
1148             for (int i=0; i&lt;4; i++) {
1149               char c = *from++;
1150               switch (c) {
1151                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
1152                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
1153                   value = (value &lt;&lt; 4) + c - &#39;0&#39;;
1154                   break;
1155                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;:
1156                 case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
1157                   value = (value &lt;&lt; 4) + 10 + c - &#39;a&#39;;
1158                   break;
1159                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;:
1160                 case &#39;D&#39;: case &#39;E&#39;: case &#39;F&#39;:
1161                   value = (value &lt;&lt; 4) + 10 + c - &#39;A&#39;;
1162                   break;
1163                 default:
1164                   ShouldNotReachHere();
1165               }
1166             }
1167             UNICODE::convert_to_utf8(&amp;value, 1, to);
1168             to++;
1169             break;
1170           }
1171           case &#39;t&#39;: *to++ = &#39;\t&#39;; from += 2; break;
1172           case &#39;n&#39;: *to++ = &#39;\n&#39;; from += 2; break;
1173           case &#39;r&#39;: *to++ = &#39;\r&#39;; from += 2; break;
1174           case &#39;f&#39;: *to++ = &#39;\f&#39;; from += 2; break;
1175           default:
1176             ShouldNotReachHere();
1177         }
1178       }
1179     }
1180     *from = *to;
1181   }
1182 };
1183 
1184 void ciReplay::replay(TRAPS) {
1185   int exit_code = replay_impl(THREAD);
1186 
1187   Threads::destroy_vm();
1188 
1189   vm_exit(exit_code);
1190 }
1191 
1192 void* ciReplay::load_inline_data(ciMethod* method, int entry_bci, int comp_level) {
1193   if (FLAG_IS_DEFAULT(InlineDataFile)) {
1194     tty-&gt;print_cr(&quot;ERROR: no inline replay data file specified (use -XX:InlineDataFile=inline_pid12345.txt).&quot;);
1195     return NULL;
1196   }
1197 
1198   VM_ENTRY_MARK;
1199   // Load and parse the replay data
1200   CompileReplay rp(InlineDataFile, THREAD);
1201   if (!rp.can_replay()) {
1202     tty-&gt;print_cr(&quot;ciReplay: !rp.can_replay()&quot;);
1203     return NULL;
1204   }
1205   void* data = rp.process_inline(method, method-&gt;get_Method(), entry_bci, comp_level, THREAD);
1206   if (HAS_PENDING_EXCEPTION) {
1207     Handle throwable(THREAD, PENDING_EXCEPTION);
1208     CLEAR_PENDING_EXCEPTION;
1209     java_lang_Throwable::print_stack_trace(throwable, tty);
1210     tty-&gt;cr();
1211     return NULL;
1212   }
1213 
1214   if (rp.had_error()) {
1215     tty-&gt;print_cr(&quot;ciReplay: Failed on %s&quot;, rp.error_message());
1216     return NULL;
1217   }
1218   return data;
1219 }
1220 
1221 int ciReplay::replay_impl(TRAPS) {
1222   HandleMark hm;
1223   ResourceMark rm;
1224 
1225   if (ReplaySuppressInitializers &gt; 2) {
1226     // ReplaySuppressInitializers &gt; 2 means that we want to allow
1227     // normal VM bootstrap but once we get into the replay itself
1228     // don&#39;t allow any intializers to be run.
1229     ReplaySuppressInitializers = 1;
1230   }
1231 
1232   if (FLAG_IS_DEFAULT(ReplayDataFile)) {
1233     tty-&gt;print_cr(&quot;ERROR: no compiler replay data file specified (use -XX:ReplayDataFile=replay_pid12345.txt).&quot;);
1234     return 1;
1235   }
1236 
1237   // Load and parse the replay data
1238   CompileReplay rp(ReplayDataFile, THREAD);
1239   int exit_code = 0;
1240   if (rp.can_replay()) {
1241     rp.process(THREAD);
1242   } else {
1243     exit_code = 1;
1244     return exit_code;
1245   }
1246 
1247   if (HAS_PENDING_EXCEPTION) {
1248     Handle throwable(THREAD, PENDING_EXCEPTION);
1249     CLEAR_PENDING_EXCEPTION;
1250     java_lang_Throwable::print_stack_trace(throwable, tty);
1251     tty-&gt;cr();
1252     exit_code = 2;
1253   }
1254 
1255   if (rp.had_error()) {
1256     tty-&gt;print_cr(&quot;Failed on %s&quot;, rp.error_message());
1257     exit_code = 1;
1258   }
1259   return exit_code;
1260 }
1261 
1262 void ciReplay::initialize(ciMethodData* m) {
1263   if (replay_state == NULL) {
1264     return;
1265   }
1266 
1267   ASSERT_IN_VM;
1268   ResourceMark rm;
1269 
1270   Method* method = m-&gt;get_MethodData()-&gt;method();
1271   ciMethodDataRecord* rec = replay_state-&gt;find_ciMethodDataRecord(method);
1272   if (rec == NULL) {
1273     // This indicates some mismatch with the original environment and
1274     // the replay environment though it&#39;s not always enough to
1275     // interfere with reproducing a bug
1276     tty-&gt;print_cr(&quot;Warning: requesting ciMethodData record for method with no data: &quot;);
1277     method-&gt;print_name(tty);
1278     tty-&gt;cr();
1279   } else {
1280     m-&gt;_state = rec-&gt;_state;
1281     m-&gt;_current_mileage = rec-&gt;_current_mileage;
1282     if (rec-&gt;_data_length != 0) {
1283       assert(m-&gt;_data_size + m-&gt;_extra_data_size == rec-&gt;_data_length * (int)sizeof(rec-&gt;_data[0]) ||
1284              m-&gt;_data_size == rec-&gt;_data_length * (int)sizeof(rec-&gt;_data[0]), &quot;must agree&quot;);
1285 
1286       // Write the correct ciObjects back into the profile data
1287       ciEnv* env = ciEnv::current();
1288       for (int i = 0; i &lt; rec-&gt;_classes_length; i++) {
1289         Klass *k = rec-&gt;_classes[i];
1290         // In case this class pointer is is tagged, preserve the tag bits
1291         intptr_t status = 0;
1292         if (k != NULL) {
1293           status = ciTypeEntries::with_status(env-&gt;get_metadata(k)-&gt;as_klass(), rec-&gt;_data[rec-&gt;_classes_offsets[i]]);
1294         }
1295         rec-&gt;_data[rec-&gt;_classes_offsets[i]] = status;
1296       }
1297       for (int i = 0; i &lt; rec-&gt;_methods_length; i++) {
1298         Method *m = rec-&gt;_methods[i];
1299         *(ciMetadata**)(rec-&gt;_data + rec-&gt;_methods_offsets[i]) =
1300           env-&gt;get_metadata(m);
1301       }
1302       // Copy the updated profile data into place as intptr_ts
1303 #ifdef _LP64
1304       Copy::conjoint_jlongs_atomic((jlong *)rec-&gt;_data, (jlong *)m-&gt;_data, rec-&gt;_data_length);
1305 #else
1306       Copy::conjoint_jints_atomic((jint *)rec-&gt;_data, (jint *)m-&gt;_data, rec-&gt;_data_length);
1307 #endif
1308     }
1309 
1310     // copy in the original header
1311     Copy::conjoint_jbytes(rec-&gt;_orig_data, (char*)&amp;m-&gt;_orig, rec-&gt;_orig_data_length);
1312   }
1313 }
1314 
1315 
1316 bool ciReplay::should_not_inline(ciMethod* method) {
1317   if (replay_state == NULL) {
1318     return false;
1319   }
1320   VM_ENTRY_MARK;
1321   // ciMethod without a record shouldn&#39;t be inlined.
1322   return replay_state-&gt;find_ciMethodRecord(method-&gt;get_Method()) == NULL;
1323 }
1324 
1325 bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth) {
1326   if (data != NULL) {
1327     GrowableArray&lt;ciInlineRecord*&gt;*  records = (GrowableArray&lt;ciInlineRecord*&gt;*)data;
1328     VM_ENTRY_MARK;
1329     // Inline record are ordered by bci and depth.
1330     return CompileReplay::find_ciInlineRecord(records, method-&gt;get_Method(), bci, inline_depth) != NULL;
1331   } else if (replay_state != NULL) {
1332     VM_ENTRY_MARK;
1333     // Inline record are ordered by bci and depth.
1334     return replay_state-&gt;find_ciInlineRecord(method-&gt;get_Method(), bci, inline_depth) != NULL;
1335   }
1336   return false;
1337 }
1338 
1339 bool ciReplay::should_not_inline(void* data, ciMethod* method, int bci, int inline_depth) {
1340   if (data != NULL) {
1341     GrowableArray&lt;ciInlineRecord*&gt;*  records = (GrowableArray&lt;ciInlineRecord*&gt;*)data;
1342     VM_ENTRY_MARK;
1343     // Inline record are ordered by bci and depth.
1344     return CompileReplay::find_ciInlineRecord(records, method-&gt;get_Method(), bci, inline_depth) == NULL;
1345   } else if (replay_state != NULL) {
1346     VM_ENTRY_MARK;
1347     // Inline record are ordered by bci and depth.
1348     return replay_state-&gt;find_ciInlineRecord(method-&gt;get_Method(), bci, inline_depth) == NULL;
1349   }
1350   return false;
1351 }
1352 
1353 void ciReplay::initialize(ciMethod* m) {
1354   if (replay_state == NULL) {
1355     return;
1356   }
1357 
1358   ASSERT_IN_VM;
1359   ResourceMark rm;
1360 
1361   Method* method = m-&gt;get_Method();
1362   ciMethodRecord* rec = replay_state-&gt;find_ciMethodRecord(method);
1363   if (rec == NULL) {
1364     // This indicates some mismatch with the original environment and
1365     // the replay environment though it&#39;s not always enough to
1366     // interfere with reproducing a bug
1367     tty-&gt;print_cr(&quot;Warning: requesting ciMethod record for method with no data: &quot;);
1368     method-&gt;print_name(tty);
1369     tty-&gt;cr();
1370   } else {
1371     EXCEPTION_CONTEXT;
1372     // m-&gt;_instructions_size = rec-&gt;_instructions_size;
1373     m-&gt;_instructions_size = -1;
1374     m-&gt;_interpreter_invocation_count = rec-&gt;_interpreter_invocation_count;
1375     m-&gt;_interpreter_throwout_count = rec-&gt;_interpreter_throwout_count;
1376     MethodCounters* mcs = method-&gt;get_method_counters(CHECK_AND_CLEAR);
1377     guarantee(mcs != NULL, &quot;method counters allocation failed&quot;);
1378     mcs-&gt;invocation_counter()-&gt;_counter = rec-&gt;_invocation_counter;
1379     mcs-&gt;backedge_counter()-&gt;_counter = rec-&gt;_backedge_counter;
1380   }
1381 }
1382 
1383 bool ciReplay::is_loaded(Method* method) {
1384   if (replay_state == NULL) {
1385     return true;
1386   }
1387 
1388   ASSERT_IN_VM;
1389   ResourceMark rm;
1390 
1391   ciMethodRecord* rec = replay_state-&gt;find_ciMethodRecord(method);
1392   return rec != NULL;
1393 }
1394 #endif // PRODUCT
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
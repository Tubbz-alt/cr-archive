<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Optimizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  27 #include &quot;c1/c1_Optimizer.hpp&quot;
  28 #include &quot;c1/c1_ValueMap.hpp&quot;
  29 #include &quot;c1/c1_ValueSet.inline.hpp&quot;
  30 #include &quot;c1/c1_ValueStack.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;utilities/bitMap.inline.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 
  35 typedef GrowableArray&lt;ValueSet*&gt; ValueSetList;
  36 
  37 Optimizer::Optimizer(IR* ir) {
  38   assert(ir-&gt;is_valid(), &quot;IR must be valid&quot;);
  39   _ir = ir;
  40 }
  41 
  42 class CE_Eliminator: public BlockClosure {
  43  private:
  44   IR* _hir;
  45   int _cee_count;                                // the number of CEs successfully eliminated
  46   int _ifop_count;                               // the number of IfOps successfully simplified
  47   int _has_substitution;
  48 
  49  public:
  50   CE_Eliminator(IR* hir) : _hir(hir), _cee_count(0), _ifop_count(0) {
  51     _has_substitution = false;
  52     _hir-&gt;iterate_preorder(this);
  53     if (_has_substitution) {
  54       // substituted some ifops/phis, so resolve the substitution
  55       SubstitutionResolver sr(_hir);
  56     }
  57 
  58     CompileLog* log = _hir-&gt;compilation()-&gt;log();
  59     if (log != NULL)
  60       log-&gt;set_context(&quot;optimize name=&#39;cee&#39;&quot;);
  61   }
  62 
  63   ~CE_Eliminator() {
  64     CompileLog* log = _hir-&gt;compilation()-&gt;log();
  65     if (log != NULL)
  66       log-&gt;clear_context(); // skip marker if nothing was printed
  67   }
  68 
  69   int cee_count() const                          { return _cee_count; }
  70   int ifop_count() const                         { return _ifop_count; }
  71 
  72   void adjust_exception_edges(BlockBegin* block, BlockBegin* sux) {
  73     int e = sux-&gt;number_of_exception_handlers();
  74     for (int i = 0; i &lt; e; i++) {
  75       BlockBegin* xhandler = sux-&gt;exception_handler_at(i);
  76       block-&gt;add_exception_handler(xhandler);
  77 
  78       assert(xhandler-&gt;is_predecessor(sux), &quot;missing predecessor&quot;);
  79       if (sux-&gt;number_of_preds() == 0) {
  80         // sux is disconnected from graph so disconnect from exception handlers
  81         xhandler-&gt;remove_predecessor(sux);
  82       }
  83       if (!xhandler-&gt;is_predecessor(block)) {
  84         xhandler-&gt;add_predecessor(block);
  85       }
  86     }
  87   }
  88 
  89   virtual void block_do(BlockBegin* block);
  90 
  91  private:
  92   Value make_ifop(Value x, Instruction::Condition cond, Value y, Value tval, Value fval,
  93                   ValueStack* state_before, bool substitutability_check);
  94 };
  95 
  96 void CE_Eliminator::block_do(BlockBegin* block) {
  97   // 1) find conditional expression
  98   // check if block ends with an If
  99   If* if_ = block-&gt;end()-&gt;as_If();
 100   if (if_ == NULL) return;
 101 
 102   // check if If works on int or object types
 103   // (we cannot handle If&#39;s working on long, float or doubles yet,
 104   // since IfOp doesn&#39;t support them - these If&#39;s show up if cmp
 105   // operations followed by If&#39;s are eliminated)
 106   ValueType* if_type = if_-&gt;x()-&gt;type();
 107   if (!if_type-&gt;is_int() &amp;&amp; !if_type-&gt;is_object()) return;
 108 
 109   BlockBegin* t_block = if_-&gt;tsux();
 110   BlockBegin* f_block = if_-&gt;fsux();
 111   Instruction* t_cur = t_block-&gt;next();
 112   Instruction* f_cur = f_block-&gt;next();
 113 
 114   // one Constant may be present between BlockBegin and BlockEnd
 115   Value t_const = NULL;
 116   Value f_const = NULL;
 117   if (t_cur-&gt;as_Constant() != NULL &amp;&amp; !t_cur-&gt;can_trap()) {
 118     t_const = t_cur;
 119     t_cur = t_cur-&gt;next();
 120   }
 121   if (f_cur-&gt;as_Constant() != NULL &amp;&amp; !f_cur-&gt;can_trap()) {
 122     f_const = f_cur;
 123     f_cur = f_cur-&gt;next();
 124   }
 125 
 126   // check if both branches end with a goto
 127   Goto* t_goto = t_cur-&gt;as_Goto();
 128   if (t_goto == NULL) return;
 129   Goto* f_goto = f_cur-&gt;as_Goto();
 130   if (f_goto == NULL) return;
 131 
 132   // check if both gotos merge into the same block
 133   BlockBegin* sux = t_goto-&gt;default_sux();
 134   if (sux != f_goto-&gt;default_sux()) return;
 135 
 136   // check if at least one word was pushed on sux_state
 137   // inlining depths must match
 138   ValueStack* if_state = if_-&gt;state();
 139   ValueStack* sux_state = sux-&gt;state();
 140   if (if_state-&gt;scope()-&gt;level() &gt; sux_state-&gt;scope()-&gt;level()) {
 141     while (sux_state-&gt;scope() != if_state-&gt;scope()) {
 142       if_state = if_state-&gt;caller_state();
 143       assert(if_state != NULL, &quot;states do not match up&quot;);
 144     }
 145   } else if (if_state-&gt;scope()-&gt;level() &lt; sux_state-&gt;scope()-&gt;level()) {
 146     while (sux_state-&gt;scope() != if_state-&gt;scope()) {
 147       sux_state = sux_state-&gt;caller_state();
 148       assert(sux_state != NULL, &quot;states do not match up&quot;);
 149     }
 150   }
 151 
 152   if (sux_state-&gt;stack_size() &lt;= if_state-&gt;stack_size()) return;
 153 
 154   // check if phi function is present at end of successor stack and that
 155   // only this phi was pushed on the stack
 156   Value sux_phi = sux_state-&gt;stack_at(if_state-&gt;stack_size());
 157   if (sux_phi == NULL || sux_phi-&gt;as_Phi() == NULL || sux_phi-&gt;as_Phi()-&gt;block() != sux) return;
 158   if (sux_phi-&gt;type()-&gt;size() != sux_state-&gt;stack_size() - if_state-&gt;stack_size()) return;
 159 
 160   // get the values that were pushed in the true- and false-branch
 161   Value t_value = t_goto-&gt;state()-&gt;stack_at(if_state-&gt;stack_size());
 162   Value f_value = f_goto-&gt;state()-&gt;stack_at(if_state-&gt;stack_size());
 163 
 164   // backend does not support floats
 165   assert(t_value-&gt;type()-&gt;base() == f_value-&gt;type()-&gt;base(), &quot;incompatible types&quot;);
 166   if (t_value-&gt;type()-&gt;is_float_kind()) return;
 167 
 168   // check that successor has no other phi functions but sux_phi
 169   // this can happen when t_block or f_block contained additonal stores to local variables
 170   // that are no longer represented by explicit instructions
 171   for_each_phi_fun(sux, phi,
 172                    if (phi != sux_phi) return;
 173                    );
 174   // true and false blocks can&#39;t have phis
 175   for_each_phi_fun(t_block, phi, return; );
 176   for_each_phi_fun(f_block, phi, return; );
 177 
 178   // Only replace safepoint gotos if state_before information is available (if is a safepoint)
 179   bool is_safepoint = if_-&gt;is_safepoint();
 180   if (!is_safepoint &amp;&amp; (t_goto-&gt;is_safepoint() || f_goto-&gt;is_safepoint())) {
 181     return;
 182   }
 183 
 184   // 2) substitute conditional expression
 185   //    with an IfOp followed by a Goto
 186   // cut if_ away and get node before
 187   Instruction* cur_end = if_-&gt;prev();
 188 
 189   // append constants of true- and false-block if necessary
 190   // clone constants because original block must not be destroyed
 191   assert((t_value != f_const &amp;&amp; f_value != t_const) || t_const == f_const, &quot;mismatch&quot;);
 192   if (t_value == t_const) {
 193     t_value = new Constant(t_const-&gt;type());
 194     NOT_PRODUCT(t_value-&gt;set_printable_bci(if_-&gt;printable_bci()));
 195     cur_end = cur_end-&gt;set_next(t_value);
 196   }
 197   if (f_value == f_const) {
 198     f_value = new Constant(f_const-&gt;type());
 199     NOT_PRODUCT(f_value-&gt;set_printable_bci(if_-&gt;printable_bci()));
 200     cur_end = cur_end-&gt;set_next(f_value);
 201   }
 202 
 203   Value result = make_ifop(if_-&gt;x(), if_-&gt;cond(), if_-&gt;y(), t_value, f_value,
 204                            if_-&gt;state_before(), if_-&gt;substitutability_check());
 205   assert(result != NULL, &quot;make_ifop must return a non-null instruction&quot;);
 206   if (!result-&gt;is_linked() &amp;&amp; result-&gt;can_be_linked()) {
 207     NOT_PRODUCT(result-&gt;set_printable_bci(if_-&gt;printable_bci()));
 208     cur_end = cur_end-&gt;set_next(result);
 209   }
 210 
 211   // append Goto to successor
 212   ValueStack* state_before = if_-&gt;state_before();
 213   Goto* goto_ = new Goto(sux, state_before, is_safepoint);
 214 
 215   // prepare state for Goto
 216   ValueStack* goto_state = if_state;
 217   goto_state = goto_state-&gt;copy(ValueStack::StateAfter, goto_state-&gt;bci());
 218   goto_state-&gt;push(result-&gt;type(), result);
 219   assert(goto_state-&gt;is_same(sux_state), &quot;states must match now&quot;);
 220   goto_-&gt;set_state(goto_state);
 221 
 222   cur_end = cur_end-&gt;set_next(goto_, goto_state-&gt;bci());
 223 
 224   // Adjust control flow graph
 225   BlockBegin::disconnect_edge(block, t_block);
 226   BlockBegin::disconnect_edge(block, f_block);
 227   if (t_block-&gt;number_of_preds() == 0) {
 228     BlockBegin::disconnect_edge(t_block, sux);
 229   }
 230   adjust_exception_edges(block, t_block);
 231   if (f_block-&gt;number_of_preds() == 0) {
 232     BlockBegin::disconnect_edge(f_block, sux);
 233   }
 234   adjust_exception_edges(block, f_block);
 235 
 236   // update block end
 237   block-&gt;set_end(goto_);
 238 
 239   // substitute the phi if possible
 240   if (sux_phi-&gt;as_Phi()-&gt;operand_count() == 1) {
 241     assert(sux_phi-&gt;as_Phi()-&gt;operand_at(0) == result, &quot;screwed up phi&quot;);
 242     sux_phi-&gt;set_subst(result);
 243     _has_substitution = true;
 244   }
 245 
 246   // 3) successfully eliminated a conditional expression
 247   _cee_count++;
 248   if (PrintCEE) {
 249     tty-&gt;print_cr(&quot;%d. CEE in B%d (B%d B%d)&quot;, cee_count(), block-&gt;block_id(), t_block-&gt;block_id(), f_block-&gt;block_id());
 250     tty-&gt;print_cr(&quot;%d. IfOp in B%d&quot;, ifop_count(), block-&gt;block_id());
 251   }
 252 
 253   _hir-&gt;verify();
 254 }
 255 
 256 Value CE_Eliminator::make_ifop(Value x, Instruction::Condition cond, Value y, Value tval, Value fval,
 257                                ValueStack* state_before, bool substitutability_check) {
 258   if (!OptimizeIfOps) {
 259     return new IfOp(x, cond, y, tval, fval, state_before, substitutability_check);
 260   }
 261 
 262   tval = tval-&gt;subst();
 263   fval = fval-&gt;subst();
 264   if (tval == fval) {
 265     _ifop_count++;
 266     return tval;
 267   }
 268 
 269   x = x-&gt;subst();
 270   y = y-&gt;subst();
 271 
 272   Constant* y_const = y-&gt;as_Constant();
 273   if (y_const != NULL) {
 274     IfOp* x_ifop = x-&gt;as_IfOp();
 275     if (x_ifop != NULL) {                 // x is an ifop, y is a constant
 276       Constant* x_tval_const = x_ifop-&gt;tval()-&gt;subst()-&gt;as_Constant();
 277       Constant* x_fval_const = x_ifop-&gt;fval()-&gt;subst()-&gt;as_Constant();
 278 
 279       if (x_tval_const != NULL &amp;&amp; x_fval_const != NULL) {
 280         Instruction::Condition x_ifop_cond = x_ifop-&gt;cond();
 281 
 282         Constant::CompareResult t_compare_res = x_tval_const-&gt;compare(cond, y_const);
 283         Constant::CompareResult f_compare_res = x_fval_const-&gt;compare(cond, y_const);
 284 
 285         // not_comparable here is a valid return in case we&#39;re comparing unloaded oop constants
 286         if (t_compare_res != Constant::not_comparable &amp;&amp; f_compare_res != Constant::not_comparable) {
 287           Value new_tval = t_compare_res == Constant::cond_true ? tval : fval;
 288           Value new_fval = f_compare_res == Constant::cond_true ? tval : fval;
 289 
 290           _ifop_count++;
 291           if (new_tval == new_fval) {
 292             return new_tval;
 293           } else {
 294             return new IfOp(x_ifop-&gt;x(), x_ifop_cond, x_ifop-&gt;y(), new_tval, new_fval, state_before, substitutability_check);
 295           }
 296         }
 297       }
 298     } else {
 299       Constant* x_const = x-&gt;as_Constant();
 300       if (x_const != NULL) {         // x and y are constants
 301         Constant::CompareResult x_compare_res = x_const-&gt;compare(cond, y_const);
 302         // not_comparable here is a valid return in case we&#39;re comparing unloaded oop constants
 303         if (x_compare_res != Constant::not_comparable) {
 304           _ifop_count++;
 305           return x_compare_res == Constant::cond_true ? tval : fval;
 306         }
 307       }
 308     }
 309   }
 310   return new IfOp(x, cond, y, tval, fval, state_before, substitutability_check);
 311 }
 312 
 313 void Optimizer::eliminate_conditional_expressions() {
 314   // find conditional expressions &amp; replace them with IfOps
 315   CE_Eliminator ce(ir());
 316 }
 317 
 318 class BlockMerger: public BlockClosure {
 319  private:
 320   IR* _hir;
 321   int _merge_count;              // the number of block pairs successfully merged
 322 
 323  public:
 324   BlockMerger(IR* hir)
 325   : _hir(hir)
 326   , _merge_count(0)
 327   {
 328     _hir-&gt;iterate_preorder(this);
 329     CompileLog* log = _hir-&gt;compilation()-&gt;log();
 330     if (log != NULL)
 331       log-&gt;set_context(&quot;optimize name=&#39;eliminate_blocks&#39;&quot;);
 332   }
 333 
 334   ~BlockMerger() {
 335     CompileLog* log = _hir-&gt;compilation()-&gt;log();
 336     if (log != NULL)
 337       log-&gt;clear_context(); // skip marker if nothing was printed
 338   }
 339 
 340   bool try_merge(BlockBegin* block) {
 341     BlockEnd* end = block-&gt;end();
 342     if (end-&gt;as_Goto() != NULL) {
 343       assert(end-&gt;number_of_sux() == 1, &quot;end must have exactly one successor&quot;);
 344       // Note: It would be sufficient to check for the number of successors (= 1)
 345       //       in order to decide if this block can be merged potentially. That
 346       //       would then also include switch statements w/ only a default case.
 347       //       However, in that case we would need to make sure the switch tag
 348       //       expression is executed if it can produce observable side effects.
 349       //       We should probably have the canonicalizer simplifying such switch
 350       //       statements and then we are sure we don&#39;t miss these merge opportunities
 351       //       here (was bug - gri 7/7/99).
 352       BlockBegin* sux = end-&gt;default_sux();
 353       if (sux-&gt;number_of_preds() == 1 &amp;&amp; !sux-&gt;is_entry_block() &amp;&amp; !end-&gt;is_safepoint()) {
 354         // merge the two blocks
 355 
 356 #ifdef ASSERT
 357         // verify that state at the end of block and at the beginning of sux are equal
 358         // no phi functions must be present at beginning of sux
 359         ValueStack* sux_state = sux-&gt;state();
 360         ValueStack* end_state = end-&gt;state();
 361 
 362         assert(end_state-&gt;scope() == sux_state-&gt;scope(), &quot;scopes must match&quot;);
 363         assert(end_state-&gt;stack_size() == sux_state-&gt;stack_size(), &quot;stack not equal&quot;);
 364         assert(end_state-&gt;locals_size() == sux_state-&gt;locals_size(), &quot;locals not equal&quot;);
 365 
 366         int index;
 367         Value sux_value;
 368         for_each_stack_value(sux_state, index, sux_value) {
 369           assert(sux_value == end_state-&gt;stack_at(index), &quot;stack not equal&quot;);
 370         }
 371         for_each_local_value(sux_state, index, sux_value) {
 372           Phi* sux_phi = sux_value-&gt;as_Phi();
 373           if (sux_phi != NULL &amp;&amp; sux_phi-&gt;is_illegal()) continue;
 374           assert(sux_value == end_state-&gt;local_at(index), &quot;locals not equal&quot;);
 375         }
 376         assert(sux_state-&gt;caller_state() == end_state-&gt;caller_state(), &quot;caller not equal&quot;);
 377 #endif
 378 
 379         // find instruction before end &amp; append first instruction of sux block
 380         Instruction* prev = end-&gt;prev();
 381         Instruction* next = sux-&gt;next();
 382         assert(prev-&gt;as_BlockEnd() == NULL, &quot;must not be a BlockEnd&quot;);
 383         prev-&gt;set_next(next);
 384         prev-&gt;fixup_block_pointers();
 385         sux-&gt;disconnect_from_graph();
 386         block-&gt;set_end(sux-&gt;end());
 387         // add exception handlers of deleted block, if any
 388         for (int k = 0; k &lt; sux-&gt;number_of_exception_handlers(); k++) {
 389           BlockBegin* xhandler = sux-&gt;exception_handler_at(k);
 390           block-&gt;add_exception_handler(xhandler);
 391 
 392           // also substitute predecessor of exception handler
 393           assert(xhandler-&gt;is_predecessor(sux), &quot;missing predecessor&quot;);
 394           xhandler-&gt;remove_predecessor(sux);
 395           if (!xhandler-&gt;is_predecessor(block)) {
 396             xhandler-&gt;add_predecessor(block);
 397           }
 398         }
 399 
 400         // debugging output
 401         _merge_count++;
 402         if (PrintBlockElimination) {
 403           tty-&gt;print_cr(&quot;%d. merged B%d &amp; B%d (stack size = %d)&quot;,
 404                         _merge_count, block-&gt;block_id(), sux-&gt;block_id(), sux-&gt;state()-&gt;stack_size());
 405         }
 406 
 407         _hir-&gt;verify();
 408 
 409         If* if_ = block-&gt;end()-&gt;as_If();
 410         if (if_) {
 411           IfOp* ifop    = if_-&gt;x()-&gt;as_IfOp();
 412           Constant* con = if_-&gt;y()-&gt;as_Constant();
 413           bool swapped = false;
 414           if (!con || !ifop) {
 415             ifop = if_-&gt;y()-&gt;as_IfOp();
 416             con  = if_-&gt;x()-&gt;as_Constant();
 417             swapped = true;
 418           }
 419           if (con &amp;&amp; ifop) {
 420             Constant* tval = ifop-&gt;tval()-&gt;as_Constant();
 421             Constant* fval = ifop-&gt;fval()-&gt;as_Constant();
 422             if (tval &amp;&amp; fval) {
 423               // Find the instruction before if_, starting with ifop.
 424               // When if_ and ifop are not in the same block, prev
 425               // becomes NULL In such (rare) cases it is not
 426               // profitable to perform the optimization.
 427               Value prev = ifop;
 428               while (prev != NULL &amp;&amp; prev-&gt;next() != if_) {
 429                 prev = prev-&gt;next();
 430               }
 431 
 432               if (prev != NULL) {
 433                 Instruction::Condition cond = if_-&gt;cond();
 434                 BlockBegin* tsux = if_-&gt;tsux();
 435                 BlockBegin* fsux = if_-&gt;fsux();
 436                 if (swapped) {
 437                   cond = Instruction::mirror(cond);
 438                 }
 439 
 440                 BlockBegin* tblock = tval-&gt;compare(cond, con, tsux, fsux);
 441                 BlockBegin* fblock = fval-&gt;compare(cond, con, tsux, fsux);
 442                 if (tblock != fblock &amp;&amp; !if_-&gt;is_safepoint()) {
 443                   If* newif = new If(ifop-&gt;x(), ifop-&gt;cond(), false, ifop-&gt;y(),
 444                                      tblock, fblock, if_-&gt;state_before(), if_-&gt;is_safepoint(), if_-&gt;substitutability_check());
 445                   newif-&gt;set_state(if_-&gt;state()-&gt;copy());
 446 
 447                   assert(prev-&gt;next() == if_, &quot;must be guaranteed by above search&quot;);
 448                   NOT_PRODUCT(newif-&gt;set_printable_bci(if_-&gt;printable_bci()));
 449                   prev-&gt;set_next(newif);
 450                   block-&gt;set_end(newif);
 451 
 452                   _merge_count++;
 453                   if (PrintBlockElimination) {
 454                     tty-&gt;print_cr(&quot;%d. replaced If and IfOp at end of B%d with single If&quot;, _merge_count, block-&gt;block_id());
 455                   }
 456 
 457                   _hir-&gt;verify();
 458                 }
 459               }
 460             }
 461           }
 462         }
 463 
 464         return true;
 465       }
 466     }
 467     return false;
 468   }
 469 
 470   virtual void block_do(BlockBegin* block) {
 471     _hir-&gt;verify();
 472     // repeat since the same block may merge again
 473     while (try_merge(block)) {
 474       _hir-&gt;verify();
 475     }
 476   }
 477 };
 478 
 479 
 480 void Optimizer::eliminate_blocks() {
 481   // merge blocks if possible
 482   BlockMerger bm(ir());
 483 }
 484 
 485 
 486 class NullCheckEliminator;
 487 class NullCheckVisitor: public InstructionVisitor {
 488 private:
 489   NullCheckEliminator* _nce;
 490   NullCheckEliminator* nce() { return _nce; }
 491 
 492 public:
 493   NullCheckVisitor() {}
 494 
 495   void set_eliminator(NullCheckEliminator* nce) { _nce = nce; }
 496 
 497   void do_Phi            (Phi*             x);
 498   void do_Local          (Local*           x);
 499   void do_Constant       (Constant*        x);
 500   void do_LoadField      (LoadField*       x);
 501   void do_StoreField     (StoreField*      x);
 502   void do_ArrayLength    (ArrayLength*     x);
 503   void do_LoadIndexed    (LoadIndexed*     x);
 504   void do_StoreIndexed   (StoreIndexed*    x);
 505   void do_NegateOp       (NegateOp*        x);
 506   void do_ArithmeticOp   (ArithmeticOp*    x);
 507   void do_ShiftOp        (ShiftOp*         x);
 508   void do_LogicOp        (LogicOp*         x);
 509   void do_CompareOp      (CompareOp*       x);
 510   void do_IfOp           (IfOp*            x);
 511   void do_Convert        (Convert*         x);
 512   void do_NullCheck      (NullCheck*       x);
 513   void do_TypeCast       (TypeCast*        x);
 514   void do_Invoke         (Invoke*          x);
 515   void do_NewInstance    (NewInstance*     x);
<a name="1" id="anc1"></a><span class="line-modified"> 516   void do_NewValueTypeInstance(NewValueTypeInstance* x);</span>
 517   void do_NewTypeArray   (NewTypeArray*    x);
 518   void do_NewObjectArray (NewObjectArray*  x);
 519   void do_NewMultiArray  (NewMultiArray*   x);
 520   void do_WithField      (WithField*       x);
 521   void do_DefaultValue   (DefaultValue*    x);
 522   void do_CheckCast      (CheckCast*       x);
 523   void do_InstanceOf     (InstanceOf*      x);
 524   void do_MonitorEnter   (MonitorEnter*    x);
 525   void do_MonitorExit    (MonitorExit*     x);
 526   void do_Intrinsic      (Intrinsic*       x);
 527   void do_BlockBegin     (BlockBegin*      x);
 528   void do_Goto           (Goto*            x);
 529   void do_If             (If*              x);
 530   void do_IfInstanceOf   (IfInstanceOf*    x);
 531   void do_TableSwitch    (TableSwitch*     x);
 532   void do_LookupSwitch   (LookupSwitch*    x);
 533   void do_Return         (Return*          x);
 534   void do_Throw          (Throw*           x);
 535   void do_Base           (Base*            x);
 536   void do_OsrEntry       (OsrEntry*        x);
 537   void do_ExceptionObject(ExceptionObject* x);
 538   void do_RoundFP        (RoundFP*         x);
 539   void do_UnsafeGetRaw   (UnsafeGetRaw*    x);
 540   void do_UnsafePutRaw   (UnsafePutRaw*    x);
 541   void do_UnsafeGetObject(UnsafeGetObject* x);
 542   void do_UnsafePutObject(UnsafePutObject* x);
 543   void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);
 544   void do_ProfileCall    (ProfileCall*     x);
 545   void do_ProfileReturnType (ProfileReturnType*  x);
 546   void do_ProfileInvoke  (ProfileInvoke*   x);
 547   void do_RuntimeCall    (RuntimeCall*     x);
 548   void do_MemBar         (MemBar*          x);
 549   void do_RangeCheckPredicate(RangeCheckPredicate* x);
 550 #ifdef ASSERT
 551   void do_Assert         (Assert*          x);
 552 #endif
 553 };
 554 
 555 
 556 // Because of a static contained within (for the purpose of iteration
 557 // over instructions), it is only valid to have one of these active at
 558 // a time
 559 class NullCheckEliminator: public ValueVisitor {
 560  private:
 561   Optimizer*        _opt;
 562 
 563   ValueSet*         _visitable_instructions;        // Visit each instruction only once per basic block
 564   BlockList*        _work_list;                   // Basic blocks to visit
 565 
 566   bool visitable(Value x) {
 567     assert(_visitable_instructions != NULL, &quot;check&quot;);
 568     return _visitable_instructions-&gt;contains(x);
 569   }
 570   void mark_visited(Value x) {
 571     assert(_visitable_instructions != NULL, &quot;check&quot;);
 572     _visitable_instructions-&gt;remove(x);
 573   }
 574   void mark_visitable(Value x) {
 575     assert(_visitable_instructions != NULL, &quot;check&quot;);
 576     _visitable_instructions-&gt;put(x);
 577   }
 578   void clear_visitable_state() {
 579     assert(_visitable_instructions != NULL, &quot;check&quot;);
 580     _visitable_instructions-&gt;clear();
 581   }
 582 
 583   ValueSet*         _set;                         // current state, propagated to subsequent BlockBegins
 584   ValueSetList      _block_states;                // BlockBegin null-check states for all processed blocks
 585   NullCheckVisitor  _visitor;
 586   NullCheck*        _last_explicit_null_check;
 587 
 588   bool set_contains(Value x)                      { assert(_set != NULL, &quot;check&quot;); return _set-&gt;contains(x); }
 589   void set_put     (Value x)                      { assert(_set != NULL, &quot;check&quot;); _set-&gt;put(x); }
 590   void set_remove  (Value x)                      { assert(_set != NULL, &quot;check&quot;); _set-&gt;remove(x); }
 591 
 592   BlockList* work_list()                          { return _work_list; }
 593 
 594   void iterate_all();
 595   void iterate_one(BlockBegin* block);
 596 
 597   ValueSet* state()                               { return _set; }
 598   void      set_state_from (ValueSet* state)      { _set-&gt;set_from(state); }
 599   ValueSet* state_for      (BlockBegin* block)    { return _block_states.at(block-&gt;block_id()); }
 600   void      set_state_for  (BlockBegin* block, ValueSet* stack) { _block_states.at_put(block-&gt;block_id(), stack); }
 601   // Returns true if caused a change in the block&#39;s state.
 602   bool      merge_state_for(BlockBegin* block,
 603                             ValueSet*   incoming_state);
 604 
 605  public:
 606   // constructor
 607   NullCheckEliminator(Optimizer* opt)
 608     : _opt(opt)
 609     , _work_list(new BlockList())
 610     , _set(new ValueSet())
 611     , _block_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)
 612     , _last_explicit_null_check(NULL) {
 613     _visitable_instructions = new ValueSet();
 614     _visitor.set_eliminator(this);
 615     CompileLog* log = _opt-&gt;ir()-&gt;compilation()-&gt;log();
 616     if (log != NULL)
 617       log-&gt;set_context(&quot;optimize name=&#39;null_check_elimination&#39;&quot;);
 618   }
 619 
 620   ~NullCheckEliminator() {
 621     CompileLog* log = _opt-&gt;ir()-&gt;compilation()-&gt;log();
 622     if (log != NULL)
 623       log-&gt;clear_context(); // skip marker if nothing was printed
 624   }
 625 
 626   Optimizer*  opt()                               { return _opt; }
 627   IR*         ir ()                               { return opt()-&gt;ir(); }
 628 
 629   // Process a graph
 630   void iterate(BlockBegin* root);
 631 
 632   void visit(Value* f);
 633 
 634   // In some situations (like NullCheck(x); getfield(x)) the debug
 635   // information from the explicit NullCheck can be used to populate
 636   // the getfield, even if the two instructions are in different
 637   // scopes; this allows implicit null checks to be used but the
 638   // correct exception information to be generated. We must clear the
 639   // last-traversed NullCheck when we reach a potentially-exception-
 640   // throwing instruction, as well as in some other cases.
 641   void        set_last_explicit_null_check(NullCheck* check) { _last_explicit_null_check = check; }
 642   NullCheck*  last_explicit_null_check()                     { return _last_explicit_null_check; }
 643   Value       last_explicit_null_check_obj()                 { return (_last_explicit_null_check
 644                                                                          ? _last_explicit_null_check-&gt;obj()
 645                                                                          : NULL); }
 646   NullCheck*  consume_last_explicit_null_check() {
 647     _last_explicit_null_check-&gt;unpin(Instruction::PinExplicitNullCheck);
 648     _last_explicit_null_check-&gt;set_can_trap(false);
 649     return _last_explicit_null_check;
 650   }
 651   void        clear_last_explicit_null_check()               { _last_explicit_null_check = NULL; }
 652 
 653   // Handlers for relevant instructions
 654   // (separated out from NullCheckVisitor for clarity)
 655 
 656   // The basic contract is that these must leave the instruction in
 657   // the desired state; must not assume anything about the state of
 658   // the instruction. We make multiple passes over some basic blocks
 659   // and the last pass is the only one whose result is valid.
 660   void handle_AccessField     (AccessField* x);
 661   void handle_ArrayLength     (ArrayLength* x);
 662   void handle_LoadIndexed     (LoadIndexed* x);
 663   void handle_StoreIndexed    (StoreIndexed* x);
 664   void handle_NullCheck       (NullCheck* x);
 665   void handle_Invoke          (Invoke* x);
 666   void handle_NewInstance     (NewInstance* x);
<a name="2" id="anc2"></a><span class="line-modified"> 667   void handle_NewValueTypeInstance(NewValueTypeInstance* x);</span>
 668   void handle_NewArray        (NewArray* x);
 669   void handle_AccessMonitor   (AccessMonitor* x);
 670   void handle_Intrinsic       (Intrinsic* x);
 671   void handle_ExceptionObject (ExceptionObject* x);
 672   void handle_Phi             (Phi* x);
 673   void handle_ProfileCall     (ProfileCall* x);
 674   void handle_ProfileReturnType (ProfileReturnType* x);
 675 };
 676 
 677 
 678 // NEEDS_CLEANUP
 679 // There may be other instructions which need to clear the last
 680 // explicit null check. Anything across which we can not hoist the
 681 // debug information for a NullCheck instruction must clear it. It
 682 // might be safer to pattern match &quot;NullCheck ; {AccessField,
 683 // ArrayLength, LoadIndexed}&quot; but it is more easily structured this way.
 684 // Should test to see performance hit of clearing it for all handlers
 685 // with empty bodies below. If it is negligible then we should leave
 686 // that in for safety, otherwise should think more about it.
 687 void NullCheckVisitor::do_Phi            (Phi*             x) { nce()-&gt;handle_Phi(x);      }
 688 void NullCheckVisitor::do_Local          (Local*           x) {}
 689 void NullCheckVisitor::do_Constant       (Constant*        x) { /* FIXME: handle object constants */ }
 690 void NullCheckVisitor::do_LoadField      (LoadField*       x) { nce()-&gt;handle_AccessField(x); }
 691 void NullCheckVisitor::do_StoreField     (StoreField*      x) { nce()-&gt;handle_AccessField(x); }
 692 void NullCheckVisitor::do_ArrayLength    (ArrayLength*     x) { nce()-&gt;handle_ArrayLength(x); }
 693 void NullCheckVisitor::do_LoadIndexed    (LoadIndexed*     x) { nce()-&gt;handle_LoadIndexed(x); }
 694 void NullCheckVisitor::do_StoreIndexed   (StoreIndexed*    x) { nce()-&gt;handle_StoreIndexed(x); }
 695 void NullCheckVisitor::do_NegateOp       (NegateOp*        x) {}
 696 void NullCheckVisitor::do_ArithmeticOp   (ArithmeticOp*    x) { if (x-&gt;can_trap()) nce()-&gt;clear_last_explicit_null_check(); }
 697 void NullCheckVisitor::do_ShiftOp        (ShiftOp*         x) {}
 698 void NullCheckVisitor::do_LogicOp        (LogicOp*         x) {}
 699 void NullCheckVisitor::do_CompareOp      (CompareOp*       x) {}
 700 void NullCheckVisitor::do_IfOp           (IfOp*            x) {}
 701 void NullCheckVisitor::do_Convert        (Convert*         x) {}
 702 void NullCheckVisitor::do_NullCheck      (NullCheck*       x) { nce()-&gt;handle_NullCheck(x); }
 703 void NullCheckVisitor::do_TypeCast       (TypeCast*        x) {}
 704 void NullCheckVisitor::do_Invoke         (Invoke*          x) { nce()-&gt;handle_Invoke(x); }
 705 void NullCheckVisitor::do_NewInstance    (NewInstance*     x) { nce()-&gt;handle_NewInstance(x); }
<a name="3" id="anc3"></a><span class="line-modified"> 706 void NullCheckVisitor::do_NewValueTypeInstance(NewValueTypeInstance*     x) { nce()-&gt;handle_NewValueTypeInstance(x); }</span>
 707 void NullCheckVisitor::do_NewTypeArray   (NewTypeArray*    x) { nce()-&gt;handle_NewArray(x); }
 708 void NullCheckVisitor::do_NewObjectArray (NewObjectArray*  x) { nce()-&gt;handle_NewArray(x); }
 709 void NullCheckVisitor::do_NewMultiArray  (NewMultiArray*   x) { nce()-&gt;handle_NewArray(x); }
 710 void NullCheckVisitor::do_WithField      (WithField*       x) {}
 711 void NullCheckVisitor::do_DefaultValue   (DefaultValue*    x) {}
 712 void NullCheckVisitor::do_CheckCast      (CheckCast*       x) { nce()-&gt;clear_last_explicit_null_check(); }
 713 void NullCheckVisitor::do_InstanceOf     (InstanceOf*      x) {}
 714 void NullCheckVisitor::do_MonitorEnter   (MonitorEnter*    x) { nce()-&gt;handle_AccessMonitor(x); }
 715 void NullCheckVisitor::do_MonitorExit    (MonitorExit*     x) { nce()-&gt;handle_AccessMonitor(x); }
 716 void NullCheckVisitor::do_Intrinsic      (Intrinsic*       x) { nce()-&gt;handle_Intrinsic(x);     }
 717 void NullCheckVisitor::do_BlockBegin     (BlockBegin*      x) {}
 718 void NullCheckVisitor::do_Goto           (Goto*            x) {}
 719 void NullCheckVisitor::do_If             (If*              x) {}
 720 void NullCheckVisitor::do_IfInstanceOf   (IfInstanceOf*    x) {}
 721 void NullCheckVisitor::do_TableSwitch    (TableSwitch*     x) {}
 722 void NullCheckVisitor::do_LookupSwitch   (LookupSwitch*    x) {}
 723 void NullCheckVisitor::do_Return         (Return*          x) {}
 724 void NullCheckVisitor::do_Throw          (Throw*           x) { nce()-&gt;clear_last_explicit_null_check(); }
 725 void NullCheckVisitor::do_Base           (Base*            x) {}
 726 void NullCheckVisitor::do_OsrEntry       (OsrEntry*        x) {}
 727 void NullCheckVisitor::do_ExceptionObject(ExceptionObject* x) { nce()-&gt;handle_ExceptionObject(x); }
 728 void NullCheckVisitor::do_RoundFP        (RoundFP*         x) {}
 729 void NullCheckVisitor::do_UnsafeGetRaw   (UnsafeGetRaw*    x) {}
 730 void NullCheckVisitor::do_UnsafePutRaw   (UnsafePutRaw*    x) {}
 731 void NullCheckVisitor::do_UnsafeGetObject(UnsafeGetObject* x) {}
 732 void NullCheckVisitor::do_UnsafePutObject(UnsafePutObject* x) {}
 733 void NullCheckVisitor::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {}
 734 void NullCheckVisitor::do_ProfileCall    (ProfileCall*     x) { nce()-&gt;clear_last_explicit_null_check();
 735                                                                 nce()-&gt;handle_ProfileCall(x); }
 736 void NullCheckVisitor::do_ProfileReturnType (ProfileReturnType* x) { nce()-&gt;handle_ProfileReturnType(x); }
 737 void NullCheckVisitor::do_ProfileInvoke  (ProfileInvoke*   x) {}
 738 void NullCheckVisitor::do_RuntimeCall    (RuntimeCall*     x) {}
 739 void NullCheckVisitor::do_MemBar         (MemBar*          x) {}
 740 void NullCheckVisitor::do_RangeCheckPredicate(RangeCheckPredicate* x) {}
 741 #ifdef ASSERT
 742 void NullCheckVisitor::do_Assert         (Assert*          x) {}
 743 #endif
 744 
 745 void NullCheckEliminator::visit(Value* p) {
 746   assert(*p != NULL, &quot;should not find NULL instructions&quot;);
 747   if (visitable(*p)) {
 748     mark_visited(*p);
 749     (*p)-&gt;visit(&amp;_visitor);
 750   }
 751 }
 752 
 753 bool NullCheckEliminator::merge_state_for(BlockBegin* block, ValueSet* incoming_state) {
 754   ValueSet* state = state_for(block);
 755   if (state == NULL) {
 756     state = incoming_state-&gt;copy();
 757     set_state_for(block, state);
 758     return true;
 759   } else {
 760     bool changed = state-&gt;set_intersect(incoming_state);
 761     if (PrintNullCheckElimination &amp;&amp; changed) {
 762       tty-&gt;print_cr(&quot;Block %d&#39;s null check state changed&quot;, block-&gt;block_id());
 763     }
 764     return changed;
 765   }
 766 }
 767 
 768 
 769 void NullCheckEliminator::iterate_all() {
 770   while (work_list()-&gt;length() &gt; 0) {
 771     iterate_one(work_list()-&gt;pop());
 772   }
 773 }
 774 
 775 
 776 void NullCheckEliminator::iterate_one(BlockBegin* block) {
 777   clear_visitable_state();
 778   // clear out an old explicit null checks
 779   set_last_explicit_null_check(NULL);
 780 
 781   if (PrintNullCheckElimination) {
 782     tty-&gt;print_cr(&quot; ...iterating block %d in null check elimination for %s::%s%s&quot;,
 783                   block-&gt;block_id(),
 784                   ir()-&gt;method()-&gt;holder()-&gt;name()-&gt;as_utf8(),
 785                   ir()-&gt;method()-&gt;name()-&gt;as_utf8(),
 786                   ir()-&gt;method()-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());
 787   }
 788 
 789   // Create new state if none present (only happens at root)
 790   if (state_for(block) == NULL) {
 791     ValueSet* tmp_state = new ValueSet();
 792     set_state_for(block, tmp_state);
 793     // Initial state is that local 0 (receiver) is non-null for
 794     // non-static methods
 795     ValueStack* stack  = block-&gt;state();
 796     IRScope*    scope  = stack-&gt;scope();
 797     ciMethod*   method = scope-&gt;method();
 798     if (!method-&gt;is_static()) {
 799       Local* local0 = stack-&gt;local_at(0)-&gt;as_Local();
 800       assert(local0 != NULL, &quot;must be&quot;);
 801       assert(local0-&gt;type() == objectType, &quot;invalid type of receiver&quot;);
 802 
 803       if (local0 != NULL) {
 804         // Local 0 is used in this scope
 805         tmp_state-&gt;put(local0);
 806         if (PrintNullCheckElimination) {
 807           tty-&gt;print_cr(&quot;Local 0 (value %d) proven non-null upon entry&quot;, local0-&gt;id());
 808         }
 809       }
 810     }
 811   }
 812 
 813   // Must copy block&#39;s state to avoid mutating it during iteration
 814   // through the block -- otherwise &quot;not-null&quot; states can accidentally
 815   // propagate &quot;up&quot; through the block during processing of backward
 816   // branches and algorithm is incorrect (and does not converge)
 817   set_state_from(state_for(block));
 818 
 819   // allow visiting of Phis belonging to this block
 820   for_each_phi_fun(block, phi,
 821                    mark_visitable(phi);
 822                    );
 823 
 824   BlockEnd* e = block-&gt;end();
 825   assert(e != NULL, &quot;incomplete graph&quot;);
 826   int i;
 827 
 828   // Propagate the state before this block into the exception
 829   // handlers.  They aren&#39;t true successors since we aren&#39;t guaranteed
 830   // to execute the whole block before executing them.  Also putting
 831   // them on first seems to help reduce the amount of iteration to
 832   // reach a fixed point.
 833   for (i = 0; i &lt; block-&gt;number_of_exception_handlers(); i++) {
 834     BlockBegin* next = block-&gt;exception_handler_at(i);
 835     if (merge_state_for(next, state())) {
 836       if (!work_list()-&gt;contains(next)) {
 837         work_list()-&gt;push(next);
 838       }
 839     }
 840   }
 841 
 842   // Iterate through block, updating state.
 843   for (Instruction* instr = block; instr != NULL; instr = instr-&gt;next()) {
 844     // Mark instructions in this block as visitable as they are seen
 845     // in the instruction list.  This keeps the iteration from
 846     // visiting instructions which are references in other blocks or
 847     // visiting instructions more than once.
 848     mark_visitable(instr);
 849     if (instr-&gt;is_pinned() || instr-&gt;can_trap() || (instr-&gt;as_NullCheck() != NULL)) {
 850       mark_visited(instr);
 851       instr-&gt;input_values_do(this);
 852       instr-&gt;visit(&amp;_visitor);
 853     }
 854   }
 855 
 856   // Propagate state to successors if necessary
 857   for (i = 0; i &lt; e-&gt;number_of_sux(); i++) {
 858     BlockBegin* next = e-&gt;sux_at(i);
 859     if (merge_state_for(next, state())) {
 860       if (!work_list()-&gt;contains(next)) {
 861         work_list()-&gt;push(next);
 862       }
 863     }
 864   }
 865 }
 866 
 867 
 868 void NullCheckEliminator::iterate(BlockBegin* block) {
 869   work_list()-&gt;push(block);
 870   iterate_all();
 871 }
 872 
 873 void NullCheckEliminator::handle_AccessField(AccessField* x) {
 874   if (x-&gt;is_static()) {
 875     if (x-&gt;as_LoadField() != NULL) {
 876       // If the field is a non-null static final object field (as is
 877       // often the case for sun.misc.Unsafe), put this LoadField into
 878       // the non-null map
 879       ciField* field = x-&gt;field();
 880       if (field-&gt;is_constant()) {
 881         ciConstant field_val = field-&gt;constant_value();
 882         BasicType field_type = field_val.basic_type();
 883         if (is_reference_type(field_type)) {
 884           ciObject* obj_val = field_val.as_object();
 885           if (!obj_val-&gt;is_null_object()) {
 886             if (PrintNullCheckElimination) {
 887               tty-&gt;print_cr(&quot;AccessField %d proven non-null by static final non-null oop check&quot;,
 888                             x-&gt;id());
 889             }
 890             set_put(x);
 891           }
 892         }
 893       }
 894     }
 895     // Be conservative
 896     clear_last_explicit_null_check();
 897     return;
 898   }
 899 
 900   Value obj = x-&gt;obj();
 901   if (set_contains(obj)) {
 902     // Value is non-null =&gt; update AccessField
 903     if (last_explicit_null_check_obj() == obj &amp;&amp; !x-&gt;needs_patching()) {
 904       x-&gt;set_explicit_null_check(consume_last_explicit_null_check());
 905       x-&gt;set_needs_null_check(true);
 906       if (PrintNullCheckElimination) {
 907         tty-&gt;print_cr(&quot;Folded NullCheck %d into AccessField %d&#39;s null check for value %d&quot;,
 908                       x-&gt;explicit_null_check()-&gt;id(), x-&gt;id(), obj-&gt;id());
 909       }
 910     } else {
 911       x-&gt;set_explicit_null_check(NULL);
 912       x-&gt;set_needs_null_check(false);
 913       if (PrintNullCheckElimination) {
 914         tty-&gt;print_cr(&quot;Eliminated AccessField %d&#39;s null check for value %d&quot;, x-&gt;id(), obj-&gt;id());
 915       }
 916     }
 917   } else {
 918     set_put(obj);
 919     if (PrintNullCheckElimination) {
 920       tty-&gt;print_cr(&quot;AccessField %d of value %d proves value to be non-null&quot;, x-&gt;id(), obj-&gt;id());
 921     }
 922     // Ensure previous passes do not cause wrong state
 923     x-&gt;set_needs_null_check(true);
 924     x-&gt;set_explicit_null_check(NULL);
 925   }
 926   clear_last_explicit_null_check();
 927 }
 928 
 929 
 930 void NullCheckEliminator::handle_ArrayLength(ArrayLength* x) {
 931   Value array = x-&gt;array();
 932   if (set_contains(array)) {
 933     // Value is non-null =&gt; update AccessArray
 934     if (last_explicit_null_check_obj() == array) {
 935       x-&gt;set_explicit_null_check(consume_last_explicit_null_check());
 936       x-&gt;set_needs_null_check(true);
 937       if (PrintNullCheckElimination) {
 938         tty-&gt;print_cr(&quot;Folded NullCheck %d into ArrayLength %d&#39;s null check for value %d&quot;,
 939                       x-&gt;explicit_null_check()-&gt;id(), x-&gt;id(), array-&gt;id());
 940       }
 941     } else {
 942       x-&gt;set_explicit_null_check(NULL);
 943       x-&gt;set_needs_null_check(false);
 944       if (PrintNullCheckElimination) {
 945         tty-&gt;print_cr(&quot;Eliminated ArrayLength %d&#39;s null check for value %d&quot;, x-&gt;id(), array-&gt;id());
 946       }
 947     }
 948   } else {
 949     set_put(array);
 950     if (PrintNullCheckElimination) {
 951       tty-&gt;print_cr(&quot;ArrayLength %d of value %d proves value to be non-null&quot;, x-&gt;id(), array-&gt;id());
 952     }
 953     // Ensure previous passes do not cause wrong state
 954     x-&gt;set_needs_null_check(true);
 955     x-&gt;set_explicit_null_check(NULL);
 956   }
 957   clear_last_explicit_null_check();
 958 }
 959 
 960 
 961 void NullCheckEliminator::handle_LoadIndexed(LoadIndexed* x) {
 962   Value array = x-&gt;array();
 963   if (set_contains(array)) {
 964     // Value is non-null =&gt; update AccessArray
 965     if (last_explicit_null_check_obj() == array) {
 966       x-&gt;set_explicit_null_check(consume_last_explicit_null_check());
 967       x-&gt;set_needs_null_check(true);
 968       if (PrintNullCheckElimination) {
 969         tty-&gt;print_cr(&quot;Folded NullCheck %d into LoadIndexed %d&#39;s null check for value %d&quot;,
 970                       x-&gt;explicit_null_check()-&gt;id(), x-&gt;id(), array-&gt;id());
 971       }
 972     } else {
 973       x-&gt;set_explicit_null_check(NULL);
 974       x-&gt;set_needs_null_check(false);
 975       if (PrintNullCheckElimination) {
 976         tty-&gt;print_cr(&quot;Eliminated LoadIndexed %d&#39;s null check for value %d&quot;, x-&gt;id(), array-&gt;id());
 977       }
 978     }
 979   } else {
 980     set_put(array);
 981     if (PrintNullCheckElimination) {
 982       tty-&gt;print_cr(&quot;LoadIndexed %d of value %d proves value to be non-null&quot;, x-&gt;id(), array-&gt;id());
 983     }
 984     // Ensure previous passes do not cause wrong state
 985     x-&gt;set_needs_null_check(true);
 986     x-&gt;set_explicit_null_check(NULL);
 987   }
 988   clear_last_explicit_null_check();
 989 }
 990 
 991 
 992 void NullCheckEliminator::handle_StoreIndexed(StoreIndexed* x) {
 993   Value array = x-&gt;array();
 994   if (set_contains(array)) {
 995     // Value is non-null =&gt; update AccessArray
 996     if (PrintNullCheckElimination) {
 997       tty-&gt;print_cr(&quot;Eliminated StoreIndexed %d&#39;s null check for value %d&quot;, x-&gt;id(), array-&gt;id());
 998     }
 999     x-&gt;set_needs_null_check(false);
1000   } else {
1001     set_put(array);
1002     if (PrintNullCheckElimination) {
1003       tty-&gt;print_cr(&quot;StoreIndexed %d of value %d proves value to be non-null&quot;, x-&gt;id(), array-&gt;id());
1004     }
1005     // Ensure previous passes do not cause wrong state
1006     x-&gt;set_needs_null_check(true);
1007   }
1008   clear_last_explicit_null_check();
1009 }
1010 
1011 
1012 void NullCheckEliminator::handle_NullCheck(NullCheck* x) {
1013   Value obj = x-&gt;obj();
1014   if (set_contains(obj)) {
1015     // Already proven to be non-null =&gt; this NullCheck is useless
1016     if (PrintNullCheckElimination) {
1017       tty-&gt;print_cr(&quot;Eliminated NullCheck %d for value %d&quot;, x-&gt;id(), obj-&gt;id());
1018     }
1019     // Don&#39;t unpin since that may shrink obj&#39;s live range and make it unavailable for debug info.
1020     // The code generator won&#39;t emit LIR for a NullCheck that cannot trap.
1021     x-&gt;set_can_trap(false);
1022   } else {
1023     // May be null =&gt; add to map and set last explicit NullCheck
1024     x-&gt;set_can_trap(true);
1025     // make sure it&#39;s pinned if it can trap
1026     x-&gt;pin(Instruction::PinExplicitNullCheck);
1027     set_put(obj);
1028     set_last_explicit_null_check(x);
1029     if (PrintNullCheckElimination) {
1030       tty-&gt;print_cr(&quot;NullCheck %d of value %d proves value to be non-null&quot;, x-&gt;id(), obj-&gt;id());
1031     }
1032   }
1033 }
1034 
1035 
1036 void NullCheckEliminator::handle_Invoke(Invoke* x) {
1037   if (!x-&gt;has_receiver()) {
1038     // Be conservative
1039     clear_last_explicit_null_check();
1040     return;
1041   }
1042 
1043   Value recv = x-&gt;receiver();
1044   if (!set_contains(recv)) {
1045     set_put(recv);
1046     if (PrintNullCheckElimination) {
1047       tty-&gt;print_cr(&quot;Invoke %d of value %d proves value to be non-null&quot;, x-&gt;id(), recv-&gt;id());
1048     }
1049   }
1050   clear_last_explicit_null_check();
1051 }
1052 
1053 
1054 void NullCheckEliminator::handle_NewInstance(NewInstance* x) {
1055   set_put(x);
1056   if (PrintNullCheckElimination) {
1057     tty-&gt;print_cr(&quot;NewInstance %d is non-null&quot;, x-&gt;id());
1058   }
1059 }
1060 
<a name="4" id="anc4"></a><span class="line-modified">1061 void NullCheckEliminator::handle_NewValueTypeInstance(NewValueTypeInstance* x) {</span>
1062   set_put(x);
1063   if (PrintNullCheckElimination) {
<a name="5" id="anc5"></a><span class="line-modified">1064     tty-&gt;print_cr(&quot;NewValueTypeInstance %d is non-null&quot;, x-&gt;id());</span>
1065   }
1066 }
1067 
1068 
1069 void NullCheckEliminator::handle_NewArray(NewArray* x) {
1070   set_put(x);
1071   if (PrintNullCheckElimination) {
1072     tty-&gt;print_cr(&quot;NewArray %d is non-null&quot;, x-&gt;id());
1073   }
1074 }
1075 
1076 
1077 void NullCheckEliminator::handle_ExceptionObject(ExceptionObject* x) {
1078   set_put(x);
1079   if (PrintNullCheckElimination) {
1080     tty-&gt;print_cr(&quot;ExceptionObject %d is non-null&quot;, x-&gt;id());
1081   }
1082 }
1083 
1084 
1085 void NullCheckEliminator::handle_AccessMonitor(AccessMonitor* x) {
1086   Value obj = x-&gt;obj();
1087   if (set_contains(obj)) {
1088     // Value is non-null =&gt; update AccessMonitor
1089     if (PrintNullCheckElimination) {
1090       tty-&gt;print_cr(&quot;Eliminated AccessMonitor %d&#39;s null check for value %d&quot;, x-&gt;id(), obj-&gt;id());
1091     }
1092     x-&gt;set_needs_null_check(false);
1093   } else {
1094     set_put(obj);
1095     if (PrintNullCheckElimination) {
1096       tty-&gt;print_cr(&quot;AccessMonitor %d of value %d proves value to be non-null&quot;, x-&gt;id(), obj-&gt;id());
1097     }
1098     // Ensure previous passes do not cause wrong state
1099     x-&gt;set_needs_null_check(true);
1100   }
1101   clear_last_explicit_null_check();
1102 }
1103 
1104 
1105 void NullCheckEliminator::handle_Intrinsic(Intrinsic* x) {
1106   if (!x-&gt;has_receiver()) {
1107     if (x-&gt;id() == vmIntrinsics::_arraycopy) {
1108       for (int i = 0; i &lt; x-&gt;number_of_arguments(); i++) {
1109         x-&gt;set_arg_needs_null_check(i, !set_contains(x-&gt;argument_at(i)));
1110       }
1111     }
1112 
1113     // Be conservative
1114     clear_last_explicit_null_check();
1115     return;
1116   }
1117 
1118   Value recv = x-&gt;receiver();
1119   if (set_contains(recv)) {
1120     // Value is non-null =&gt; update Intrinsic
1121     if (PrintNullCheckElimination) {
1122       tty-&gt;print_cr(&quot;Eliminated Intrinsic %d&#39;s null check for value %d&quot;, x-&gt;id(), recv-&gt;id());
1123     }
1124     x-&gt;set_needs_null_check(false);
1125   } else {
1126     set_put(recv);
1127     if (PrintNullCheckElimination) {
1128       tty-&gt;print_cr(&quot;Intrinsic %d of value %d proves value to be non-null&quot;, x-&gt;id(), recv-&gt;id());
1129     }
1130     // Ensure previous passes do not cause wrong state
1131     x-&gt;set_needs_null_check(true);
1132   }
1133   clear_last_explicit_null_check();
1134 }
1135 
1136 
1137 void NullCheckEliminator::handle_Phi(Phi* x) {
1138   int i;
1139   bool all_non_null = true;
1140   if (x-&gt;is_illegal()) {
1141     all_non_null = false;
1142   } else {
1143     for (i = 0; i &lt; x-&gt;operand_count(); i++) {
1144       Value input = x-&gt;operand_at(i);
1145       if (!set_contains(input)) {
1146         all_non_null = false;
1147       }
1148     }
1149   }
1150 
1151   if (all_non_null) {
1152     // Value is non-null =&gt; update Phi
1153     if (PrintNullCheckElimination) {
1154       tty-&gt;print_cr(&quot;Eliminated Phi %d&#39;s null check for phifun because all inputs are non-null&quot;, x-&gt;id());
1155     }
1156     x-&gt;set_needs_null_check(false);
1157   } else if (set_contains(x)) {
1158     set_remove(x);
1159   }
1160 }
1161 
1162 void NullCheckEliminator::handle_ProfileCall(ProfileCall* x) {
1163   for (int i = 0; i &lt; x-&gt;nb_profiled_args(); i++) {
1164     x-&gt;set_arg_needs_null_check(i, !set_contains(x-&gt;profiled_arg_at(i)));
1165   }
1166 }
1167 
1168 void NullCheckEliminator::handle_ProfileReturnType(ProfileReturnType* x) {
1169   x-&gt;set_needs_null_check(!set_contains(x-&gt;ret()));
1170 }
1171 
1172 void Optimizer::eliminate_null_checks() {
1173   ResourceMark rm;
1174 
1175   NullCheckEliminator nce(this);
1176 
1177   if (PrintNullCheckElimination) {
1178     tty-&gt;print_cr(&quot;Starting null check elimination for method %s::%s%s&quot;,
1179                   ir()-&gt;method()-&gt;holder()-&gt;name()-&gt;as_utf8(),
1180                   ir()-&gt;method()-&gt;name()-&gt;as_utf8(),
1181                   ir()-&gt;method()-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());
1182   }
1183 
1184   // Apply to graph
1185   nce.iterate(ir()-&gt;start());
1186 
1187   // walk over the graph looking for exception
1188   // handlers and iterate over them as well
1189   int nblocks = BlockBegin::number_of_blocks();
1190   BlockList blocks(nblocks);
1191   boolArray visited_block(nblocks, nblocks, false);
1192 
1193   blocks.push(ir()-&gt;start());
1194   visited_block.at_put(ir()-&gt;start()-&gt;block_id(), true);
1195   for (int i = 0; i &lt; blocks.length(); i++) {
1196     BlockBegin* b = blocks.at(i);
1197     // exception handlers need to be treated as additional roots
1198     for (int e = b-&gt;number_of_exception_handlers(); e-- &gt; 0; ) {
1199       BlockBegin* excp = b-&gt;exception_handler_at(e);
1200       int id = excp-&gt;block_id();
1201       if (!visited_block.at(id)) {
1202         blocks.push(excp);
1203         visited_block.at_put(id, true);
1204         nce.iterate(excp);
1205       }
1206     }
1207     // traverse successors
1208     BlockEnd *end = b-&gt;end();
1209     for (int s = end-&gt;number_of_sux(); s-- &gt; 0; ) {
1210       BlockBegin* next = end-&gt;sux_at(s);
1211       int id = next-&gt;block_id();
1212       if (!visited_block.at(id)) {
1213         blocks.push(next);
1214         visited_block.at_put(id, true);
1215       }
1216     }
1217   }
1218 
1219 
1220   if (PrintNullCheckElimination) {
1221     tty-&gt;print_cr(&quot;Done with null check elimination for method %s::%s%s&quot;,
1222                   ir()-&gt;method()-&gt;holder()-&gt;name()-&gt;as_utf8(),
1223                   ir()-&gt;method()-&gt;name()-&gt;as_utf8(),
1224                   ir()-&gt;method()-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());
1225   }
1226 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
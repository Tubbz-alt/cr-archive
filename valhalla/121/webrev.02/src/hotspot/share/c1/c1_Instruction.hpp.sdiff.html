<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Instruction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_InstructionPrinter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Instruction.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
<span class="line-modified">  75 class     NewValueTypeInstance;</span>
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
</pre>
<hr />
<pre>
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
<span class="line-modified"> 183   virtual void do_NewValueTypeInstance(NewValueTypeInstance* x) = 0;</span>
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
</pre>
<hr />
<pre>
 569   virtual LoadField*        as_LoadField()       { return NULL; }
 570   virtual StoreField*       as_StoreField()      { return NULL; }
 571   virtual AccessArray*      as_AccessArray()     { return NULL; }
 572   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 573   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 574   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 575   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 576   virtual NegateOp*         as_NegateOp()        { return NULL; }
 577   virtual Op2*              as_Op2()             { return NULL; }
 578   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 579   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 580   virtual LogicOp*          as_LogicOp()         { return NULL; }
 581   virtual CompareOp*        as_CompareOp()       { return NULL; }
 582   virtual IfOp*             as_IfOp()            { return NULL; }
 583   virtual Convert*          as_Convert()         { return NULL; }
 584   virtual NullCheck*        as_NullCheck()       { return NULL; }
 585   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 586   virtual StateSplit*       as_StateSplit()      { return NULL; }
 587   virtual Invoke*           as_Invoke()          { return NULL; }
 588   virtual NewInstance*      as_NewInstance()     { return NULL; }
<span class="line-modified"> 589   virtual NewValueTypeInstance* as_NewValueTypeInstance() { return NULL; }</span>
 590   virtual NewArray*         as_NewArray()        { return NULL; }
 591   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 592   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 593   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 594   virtual WithField*        as_WithField()       { return NULL; }
 595   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 596   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 597   virtual CheckCast*        as_CheckCast()       { return NULL; }
 598   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 599   virtual TypeCast*         as_TypeCast()        { return NULL; }
 600   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 601   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 602   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 603   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 604   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 605   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 606   virtual Goto*             as_Goto()            { return NULL; }
 607   virtual If*               as_If()              { return NULL; }
 608   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 609   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
</pre>
<hr />
<pre>
 852   // manipulation
 853 
 854   // Under certain circumstances, if a previous NullCheck instruction
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
 871             ValueStack* state_before, bool needs_patching,
<span class="line-modified"> 872             ciValueKlass* value_klass = NULL, Value default_value = NULL )</span>
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 874   {
 875     set_never_null(field-&gt;signature()-&gt;is_Q_signature());
 876   }
 877 
 878   ciType* declared_type() const;
 879 
 880   // generic; cannot be eliminated if needs patching or if volatile.
 881   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 882 };
 883 
 884 
 885 LEAF(StoreField, AccessField)
 886  private:
 887   Value _value;
 888 
 889  public:
 890   // creation
 891   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 892              ValueStack* state_before, bool needs_patching)
</pre>
<hr />
<pre>
 985   // perform elimination of range checks involving constants
 986   bool compute_needs_range_check();
 987 
 988   // Helpers for MethodData* profiling
 989   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 990   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 991   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 992   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 993   ciMethod* profiled_method() const                  { return _profiled_method;     }
 994   int       profiled_bci() const                     { return _profiled_bci;        }
 995 
 996 
 997 // generic
 998   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 999 };
1000 
1001 
1002 LEAF(LoadIndexed, AccessIndexed)
1003  private:
1004   NullCheck*  _explicit_null_check;              // For explicit null check elimination
<span class="line-modified">1005   NewValueTypeInstance* _vt;</span>
1006 
1007  public:
1008   // creation
1009   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
1010   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1011   , _explicit_null_check(NULL), _vt(NULL) {}
1012 
1013   // accessors
1014   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
1015 
1016   // setters
1017   // See LoadField::set_explicit_null_check for documentation
1018   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1019 
1020   ciType* exact_type() const;
1021   ciType* declared_type() const;
1022 
<span class="line-modified">1023   NewValueTypeInstance* vt() const { return _vt; }</span>
<span class="line-modified">1024   void set_vt(NewValueTypeInstance* vt) { _vt = vt; }</span>
1025 
1026   // generic
1027   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())
1028 };
1029 
1030 
1031 LEAF(StoreIndexed, AccessIndexed)
1032  private:
1033   Value       _value;
1034 
1035   bool      _check_boolean;
1036 
1037  public:
1038   // creation
1039   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1040                bool check_boolean, bool mismatched = false)
1041   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1042   , _value(value), _check_boolean(check_boolean)
1043   {
1044     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
</pre>
<hr />
<pre>
1354 
1355  public:
1356   // creation
1357   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1358   : StateSplit(instanceType, state_before)
1359   , _klass(klass), _is_unresolved(is_unresolved)
1360   {}
1361 
1362   // accessors
1363   ciInstanceKlass* klass() const                 { return _klass; }
1364   bool is_unresolved() const                     { return _is_unresolved; }
1365 
1366   virtual bool needs_exception_state() const     { return false; }
1367 
1368   // generic
1369   virtual bool can_trap() const                  { return true; }
1370   ciType* exact_type() const;
1371   ciType* declared_type() const;
1372 };
1373 
<span class="line-modified">1374 LEAF(NewValueTypeInstance, StateSplit)</span>
1375   bool _is_unresolved;
<span class="line-modified">1376   ciValueKlass* _klass;</span>
1377   Value _depends_on;      // Link to instance on with withfield was called on
1378   bool _is_optimizable_for_withfield;
1379   int _first_local_index;
1380 public:
1381 
1382   // Default creation, always allocated for now
<span class="line-modified">1383   NewValueTypeInstance(ciValueKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)</span>
1384   : StateSplit(instanceType, state_before)
1385    , _is_unresolved(is_unresolved)
1386    , _klass(klass)
1387    , _is_optimizable_for_withfield(from_default_value)
1388    , _first_local_index(-1)
1389   {
1390     if (depends_on == NULL) {
1391       _depends_on = this;
1392     } else {
1393       _depends_on = depends_on;
1394     }
1395     set_never_null(true);
1396   }
1397 
1398   // accessors
1399   bool is_unresolved() const                     { return _is_unresolved; }
1400   Value depends_on();
1401 
<span class="line-modified">1402   ciValueKlass* klass() const { return _klass; }</span>
1403 
1404   virtual bool needs_exception_state() const     { return false; }
1405 
1406   // generic
1407   virtual bool can_trap() const                  { return true; }
1408   ciType* exact_type() const;
1409   ciType* declared_type() const;
1410 
1411   // Only done in LIR Generator -&gt; map everything to object
1412   void set_to_object_type() { set_type(instanceType); }
1413 
1414   // withfield optimization
1415   virtual void set_escaped() {
1416     _is_optimizable_for_withfield = false;
1417   }
1418   virtual void set_local_index(int index) {
1419     if (_first_local_index != index) {
1420       if (_first_local_index == -1) {
1421         _first_local_index = index;
1422       } else {
</pre>
<hr />
<pre>
1620   // creation
1621   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1622   : StateSplit(illegalType, state_before)
1623   , _obj(obj)
1624   , _monitor_no(monitor_no)
1625   {
1626     set_needs_null_check(true);
1627     ASSERT_VALUES
1628   }
1629 
1630   // accessors
1631   Value obj() const                              { return _obj; }
1632   int monitor_no() const                         { return _monitor_no; }
1633 
1634   // generic
1635   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1636 };
1637 
1638 
1639 LEAF(MonitorEnter, AccessMonitor)
<span class="line-modified">1640   bool _maybe_valuetype;</span>
1641  public:
1642   // creation
<span class="line-modified">1643   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_valuetype)</span>
1644   : AccessMonitor(obj, monitor_no, state_before)
<span class="line-modified">1645   , _maybe_valuetype(maybe_valuetype)</span>
1646   {
1647     ASSERT_VALUES
1648   }
1649 
1650   // accessors
<span class="line-modified">1651   bool maybe_valuetype() const                   { return _maybe_valuetype; }</span>
1652 
1653   // generic
1654   virtual bool can_trap() const                  { return true; }
1655 };
1656 
1657 
1658 LEAF(MonitorExit, AccessMonitor)
1659  public:
1660   // creation
1661   MonitorExit(Value obj, int monitor_no)
1662   : AccessMonitor(obj, monitor_no, NULL)
1663   {
1664     ASSERT_VALUES
1665   }
1666 };
1667 
1668 
1669 LEAF(Intrinsic, StateSplit)
1670  private:
1671   vmIntrinsics::ID _id;
</pre>
</td>
<td>
<hr />
<pre>
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
<span class="line-modified">  75 class     NewInlineTypeInstance;</span>
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
</pre>
<hr />
<pre>
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
<span class="line-modified"> 183   virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x) = 0;</span>
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
</pre>
<hr />
<pre>
 569   virtual LoadField*        as_LoadField()       { return NULL; }
 570   virtual StoreField*       as_StoreField()      { return NULL; }
 571   virtual AccessArray*      as_AccessArray()     { return NULL; }
 572   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 573   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 574   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 575   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 576   virtual NegateOp*         as_NegateOp()        { return NULL; }
 577   virtual Op2*              as_Op2()             { return NULL; }
 578   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 579   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 580   virtual LogicOp*          as_LogicOp()         { return NULL; }
 581   virtual CompareOp*        as_CompareOp()       { return NULL; }
 582   virtual IfOp*             as_IfOp()            { return NULL; }
 583   virtual Convert*          as_Convert()         { return NULL; }
 584   virtual NullCheck*        as_NullCheck()       { return NULL; }
 585   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 586   virtual StateSplit*       as_StateSplit()      { return NULL; }
 587   virtual Invoke*           as_Invoke()          { return NULL; }
 588   virtual NewInstance*      as_NewInstance()     { return NULL; }
<span class="line-modified"> 589   virtual NewInlineTypeInstance* as_NewInlineTypeInstance() { return NULL; }</span>
 590   virtual NewArray*         as_NewArray()        { return NULL; }
 591   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 592   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 593   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 594   virtual WithField*        as_WithField()       { return NULL; }
 595   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 596   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 597   virtual CheckCast*        as_CheckCast()       { return NULL; }
 598   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 599   virtual TypeCast*         as_TypeCast()        { return NULL; }
 600   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 601   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 602   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 603   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 604   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 605   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 606   virtual Goto*             as_Goto()            { return NULL; }
 607   virtual If*               as_If()              { return NULL; }
 608   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 609   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
</pre>
<hr />
<pre>
 852   // manipulation
 853 
 854   // Under certain circumstances, if a previous NullCheck instruction
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
 871             ValueStack* state_before, bool needs_patching,
<span class="line-modified"> 872             ciInlineKlass* inline_klass = NULL, Value default_value = NULL )</span>
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 874   {
 875     set_never_null(field-&gt;signature()-&gt;is_Q_signature());
 876   }
 877 
 878   ciType* declared_type() const;
 879 
 880   // generic; cannot be eliminated if needs patching or if volatile.
 881   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 882 };
 883 
 884 
 885 LEAF(StoreField, AccessField)
 886  private:
 887   Value _value;
 888 
 889  public:
 890   // creation
 891   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 892              ValueStack* state_before, bool needs_patching)
</pre>
<hr />
<pre>
 985   // perform elimination of range checks involving constants
 986   bool compute_needs_range_check();
 987 
 988   // Helpers for MethodData* profiling
 989   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 990   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 991   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 992   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 993   ciMethod* profiled_method() const                  { return _profiled_method;     }
 994   int       profiled_bci() const                     { return _profiled_bci;        }
 995 
 996 
 997 // generic
 998   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 999 };
1000 
1001 
1002 LEAF(LoadIndexed, AccessIndexed)
1003  private:
1004   NullCheck*  _explicit_null_check;              // For explicit null check elimination
<span class="line-modified">1005   NewInlineTypeInstance* _vt;</span>
1006 
1007  public:
1008   // creation
1009   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
1010   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1011   , _explicit_null_check(NULL), _vt(NULL) {}
1012 
1013   // accessors
1014   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
1015 
1016   // setters
1017   // See LoadField::set_explicit_null_check for documentation
1018   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1019 
1020   ciType* exact_type() const;
1021   ciType* declared_type() const;
1022 
<span class="line-modified">1023   NewInlineTypeInstance* vt() const { return _vt; }</span>
<span class="line-modified">1024   void set_vt(NewInlineTypeInstance* vt) { _vt = vt; }</span>
1025 
1026   // generic
1027   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())
1028 };
1029 
1030 
1031 LEAF(StoreIndexed, AccessIndexed)
1032  private:
1033   Value       _value;
1034 
1035   bool      _check_boolean;
1036 
1037  public:
1038   // creation
1039   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1040                bool check_boolean, bool mismatched = false)
1041   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1042   , _value(value), _check_boolean(check_boolean)
1043   {
1044     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
</pre>
<hr />
<pre>
1354 
1355  public:
1356   // creation
1357   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1358   : StateSplit(instanceType, state_before)
1359   , _klass(klass), _is_unresolved(is_unresolved)
1360   {}
1361 
1362   // accessors
1363   ciInstanceKlass* klass() const                 { return _klass; }
1364   bool is_unresolved() const                     { return _is_unresolved; }
1365 
1366   virtual bool needs_exception_state() const     { return false; }
1367 
1368   // generic
1369   virtual bool can_trap() const                  { return true; }
1370   ciType* exact_type() const;
1371   ciType* declared_type() const;
1372 };
1373 
<span class="line-modified">1374 LEAF(NewInlineTypeInstance, StateSplit)</span>
1375   bool _is_unresolved;
<span class="line-modified">1376   ciInlineKlass* _klass;</span>
1377   Value _depends_on;      // Link to instance on with withfield was called on
1378   bool _is_optimizable_for_withfield;
1379   int _first_local_index;
1380 public:
1381 
1382   // Default creation, always allocated for now
<span class="line-modified">1383   NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)</span>
1384   : StateSplit(instanceType, state_before)
1385    , _is_unresolved(is_unresolved)
1386    , _klass(klass)
1387    , _is_optimizable_for_withfield(from_default_value)
1388    , _first_local_index(-1)
1389   {
1390     if (depends_on == NULL) {
1391       _depends_on = this;
1392     } else {
1393       _depends_on = depends_on;
1394     }
1395     set_never_null(true);
1396   }
1397 
1398   // accessors
1399   bool is_unresolved() const                     { return _is_unresolved; }
1400   Value depends_on();
1401 
<span class="line-modified">1402   ciInlineKlass* klass() const { return _klass; }</span>
1403 
1404   virtual bool needs_exception_state() const     { return false; }
1405 
1406   // generic
1407   virtual bool can_trap() const                  { return true; }
1408   ciType* exact_type() const;
1409   ciType* declared_type() const;
1410 
1411   // Only done in LIR Generator -&gt; map everything to object
1412   void set_to_object_type() { set_type(instanceType); }
1413 
1414   // withfield optimization
1415   virtual void set_escaped() {
1416     _is_optimizable_for_withfield = false;
1417   }
1418   virtual void set_local_index(int index) {
1419     if (_first_local_index != index) {
1420       if (_first_local_index == -1) {
1421         _first_local_index = index;
1422       } else {
</pre>
<hr />
<pre>
1620   // creation
1621   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1622   : StateSplit(illegalType, state_before)
1623   , _obj(obj)
1624   , _monitor_no(monitor_no)
1625   {
1626     set_needs_null_check(true);
1627     ASSERT_VALUES
1628   }
1629 
1630   // accessors
1631   Value obj() const                              { return _obj; }
1632   int monitor_no() const                         { return _monitor_no; }
1633 
1634   // generic
1635   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1636 };
1637 
1638 
1639 LEAF(MonitorEnter, AccessMonitor)
<span class="line-modified">1640   bool _maybe_inlinetype;</span>
1641  public:
1642   // creation
<span class="line-modified">1643   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_inlinetype)</span>
1644   : AccessMonitor(obj, monitor_no, state_before)
<span class="line-modified">1645   , _maybe_inlinetype(maybe_inlinetype)</span>
1646   {
1647     ASSERT_VALUES
1648   }
1649 
1650   // accessors
<span class="line-modified">1651   bool maybe_inlinetype() const                   { return _maybe_inlinetype; }</span>
1652 
1653   // generic
1654   virtual bool can_trap() const                  { return true; }
1655 };
1656 
1657 
1658 LEAF(MonitorExit, AccessMonitor)
1659  public:
1660   // creation
1661   MonitorExit(Value obj, int monitor_no)
1662   : AccessMonitor(obj, monitor_no, NULL)
1663   {
1664     ASSERT_VALUES
1665   }
1666 };
1667 
1668 
1669 LEAF(Intrinsic, StateSplit)
1670  private:
1671   vmIntrinsics::ID _id;
</pre>
</td>
</tr>
</table>
<center><a href="c1_Instruction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_InstructionPrinter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
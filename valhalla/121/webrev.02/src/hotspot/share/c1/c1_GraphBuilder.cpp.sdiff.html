<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_CodeStubs.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;


  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-removed">  36 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  37 #include &quot;compiler/compilationPolicy.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/compilerEvent.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;runtime/vm_version.hpp&quot;
  46 #include &quot;utilities/bitMap.inline.hpp&quot;
  47 #include &quot;utilities/powerOfTwo.hpp&quot;
  48 
  49 class BlockListBuilder {
  50  private:
  51   Compilation* _compilation;
  52   IRScope*     _scope;
  53 
  54   BlockList    _blocks;                // internal list of all blocks
  55   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  56 
</pre>
<hr />
<pre>
 641 #endif
 642         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 643         return result;
 644       }
 645     }
 646     return load;
 647   }
 648 
 649   // Record this newly allocated object
 650   void new_instance(NewInstance* object) {
 651     int index = _newobjects.length();
 652     _newobjects.append(object);
 653     if (_fields.at_grow(index, NULL) == NULL) {
 654       _fields.at_put(index, new FieldBuffer());
 655     } else {
 656       _fields.at(index)-&gt;kill();
 657     }
 658   }
 659 
 660   // Record this newly allocated object
<span class="line-modified"> 661   void new_instance(NewValueTypeInstance* object) {</span>
 662     int index = _newobjects.length();
 663     _newobjects.append(object);
 664     if (_fields.at_grow(index, NULL) == NULL) {
 665       _fields.at_put(index, new FieldBuffer());
 666     } else {
 667       _fields.at(index)-&gt;kill();
 668     }
 669   }
 670 
 671   void store_value(Value value) {
 672     int index = _newobjects.find(value);
 673     if (index != -1) {
 674       // stored a newly allocated object into another object.
 675       // Assume we&#39;ve lost track of it as separate slice of memory.
 676       // We could do better by keeping track of whether individual
 677       // fields could alias each other.
 678       _newobjects.remove_at(index);
 679       // pull out the field info and store it at the end up the list
 680       // of field info list to be reused later.
 681       _fields.append(_fields.at(index));
</pre>
<hr />
<pre>
 996     // Save the entire state and re-execute on deopt when accessing flattened arrays
 997     state_before = copy_state_before();
 998     state_before-&gt;set_should_reexecute(true);
 999   } else {
1000     state_before = copy_state_indexed_access();
1001   }
1002   compilation()-&gt;set_has_access_indexed(true);
1003   Value index = ipop();
1004   Value array = apop();
1005   Value length = NULL;
1006   if (CSEArrayLength ||
1007       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1008       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1009     length = append(new ArrayLength(array, state_before));
1010   }
1011 
1012   LoadIndexed* load_indexed = NULL;
1013   Instruction* result = NULL;
1014   if (array-&gt;is_loaded_flattened_array()) {
1015     ciType* array_type = array-&gt;declared_type();
<span class="line-modified">1016     ciValueKlass* elem_klass = array_type-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-modified">1017     NewValueTypeInstance* new_instance = new NewValueTypeInstance(elem_klass, state_before, false);</span>
1018     _memory-&gt;new_instance(new_instance);
1019     apush(append_split(new_instance));
1020     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1021     load_indexed-&gt;set_vt(new_instance);
1022   } else {
1023     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1024   }
1025   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1026     compilation()-&gt;set_would_profile(true);
1027     load_indexed-&gt;set_should_profile(true);
1028     load_indexed-&gt;set_profiled_method(method());
1029     load_indexed-&gt;set_profiled_bci(bci());
1030   }
1031   result = append(load_indexed);
1032   assert(!(profile_array_accesses() &amp;&amp; is_reference_type(type)) || load_indexed == result, &quot;should not be optimized out&quot;);
1033   if (!array-&gt;is_loaded_flattened_array()) {
1034     push(as_ValueType(type), result);
1035   }
1036 }
1037 
</pre>
<hr />
<pre>
1276   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1277   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1278   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
1279 
1280   bool subst_check = false;
1281   if (EnableValhalla &amp;&amp; (stream()-&gt;cur_bc() == Bytecodes::_if_acmpeq || stream()-&gt;cur_bc() == Bytecodes::_if_acmpne) &amp;&amp;
1282       method() != ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature())) {
1283     // If current method is ValueBootstrapMethods::isSubstitutable(),
1284     // compile the acmp as a regular pointer comparison otherwise we
1285     // could call ValueBootstrapMethods::isSubstitutable() back
1286     ValueType* left_vt = x-&gt;type();
1287     ValueType* right_vt = y-&gt;type();
1288     if (left_vt-&gt;is_object()) {
1289       assert(right_vt-&gt;is_object(), &quot;must be&quot;);
1290       ciKlass* left_klass = x-&gt;as_loaded_klass_or_null();
1291       ciKlass* right_klass = y-&gt;as_loaded_klass_or_null();
1292 
1293       if (left_klass == NULL || right_klass == NULL) {
1294         // The klass is still unloaded, or came from a Phi node. Go slow case;
1295         subst_check = true;
<span class="line-modified">1296       } else if (left_klass-&gt;can_be_value_klass() || right_klass-&gt;can_be_value_klass()) {</span>
1297         // Either operand may be a value object, but we&#39;re not sure. Go slow case;
1298         subst_check = true;
1299       } else {
1300         // No need to do substitutability check
1301       }
1302     }
1303   }
1304 
1305   // In case of loop invariant code motion or predicate insertion
1306   // before the body of a loop the state is needed
1307   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));
1308 
1309   assert(i-&gt;as_Goto() == NULL ||
1310          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1311          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1312          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1313 
1314   if (is_profiling()) {
1315     If* if_node = i-&gt;as_If();
1316     if (if_node != NULL) {
</pre>
<hr />
<pre>
1689   // Attach dimension info to stable arrays.
1690   if (FoldStableValues &amp;&amp;
1691       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1692     ciArray* array = field_value.as_object()-&gt;as_array();
1693     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1694     value = new StableArrayConstant(array, dimension);
1695   }
1696 
1697   switch (field_type) {
1698     case T_ARRAY:
1699     case T_OBJECT:
1700       if (field_value.as_object()-&gt;should_be_constant()) {
1701         return new Constant(value);
1702       }
1703       return NULL; // Not a constant.
1704     default:
1705       return new Constant(value);
1706   }
1707 }
1708 
<span class="line-modified">1709 void GraphBuilder::copy_value_content(ciValueKlass* vk, Value src, int src_off, Value dest, int dest_off,</span>
<span class="line-modified">1710     ValueStack* state_before, bool needs_patching) {</span>
1711   src-&gt;set_escaped();
1712   for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); i++) {
1713     ciField* inner_field = vk-&gt;nonstatic_field_at(i);
1714     assert(!inner_field-&gt;is_flattened(), &quot;the iteration over nested fields is handled by the loop itself&quot;);
1715     int off = inner_field-&gt;offset() - vk-&gt;first_field_offset();
1716     LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);
1717     Value replacement = append(load);
1718     StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);
1719     append(store);
1720   }
1721 }
1722 
1723 void GraphBuilder::access_field(Bytecodes::Code code) {
1724   bool will_link;
1725   ciField* field = stream()-&gt;get_field(will_link);
1726   ciInstanceKlass* holder = field-&gt;holder();
1727   BasicType field_type = field-&gt;type()-&gt;basic_type();
1728   ValueType* type = as_ValueType(field_type);
1729 
1730   // call will_link again to determine if the field is valid.
</pre>
<hr />
<pre>
1796       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1797       break;
1798     }
1799     case Bytecodes::_getfield: {
1800       // Check for compile-time constants, i.e., trusted final non-static fields.
1801       Value constant = NULL;
1802       if (state_before == NULL &amp;&amp; field-&gt;is_flattened()) {
1803         // Save the entire state and re-execute on deopt when accessing flattened fields
1804         assert(Interpreter::bytecode_should_reexecute(code), &quot;should reexecute&quot;);
1805         state_before = copy_state_before();
1806       }
1807       obj = apop();
1808       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
1809       if (field-&gt;is_constant() &amp;&amp; !field-&gt;is_flattened() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {
1810         ciObject* const_oop = obj_type-&gt;constant_value();
1811         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1812           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1813           if (field_value.is_valid()) {
1814             if (field-&gt;signature()-&gt;is_Q_signature() &amp;&amp; field_value.is_null_or_zero()) {
1815               // Non-flattened inline type field. Replace null by the default value.
<span class="line-modified">1816               constant = new Constant(new InstanceConstant(field-&gt;type()-&gt;as_value_klass()-&gt;default_value_instance()));</span>
1817             } else {
1818               constant = make_constant(field_value, field);
1819             }
1820             // For CallSite objects add a dependency for invalidation of the optimization.
1821             if (field-&gt;is_call_site_target()) {
1822               ciCallSite* call_site = const_oop-&gt;as_call_site();
1823               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
1824                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1825                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1826               }
1827             }
1828           }
1829         }
1830       }
1831       if (constant != NULL) {
1832         push(type, append(constant));
1833       } else {
1834         if (state_before == NULL) {
1835           state_before = copy_state_for_exception();
1836         }
</pre>
<hr />
<pre>
1844             BasicType bt = field-&gt;type()-&gt;basic_type();
1845             switch (bt) {
1846             case T_BOOLEAN:
1847             case T_BYTE:
1848               replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));
1849               break;
1850             case T_CHAR:
1851               replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));
1852               break;
1853             case T_SHORT:
1854               replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));
1855               break;
1856             default:
1857               break;
1858             }
1859             push(type, replacement);
1860           } else {
1861             push(type, append(load));
1862           }
1863         } else { // flattened field, not optimized solution: re-instantiate the flattened value
<span class="line-modified">1864           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1865           ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-modified">1866           int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();</span>
<span class="line-modified">1867           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
1868           scope()-&gt;set_wrote_final();
1869           scope()-&gt;set_wrote_fields();
<span class="line-modified">1870           NewValueTypeInstance* new_instance = new NewValueTypeInstance(value_klass, state_before, false);</span>
1871           _memory-&gt;new_instance(new_instance);
1872           apush(append_split(new_instance));
<span class="line-modified">1873           copy_value_content(value_klass, obj, field-&gt;offset(), new_instance, value_klass-&gt;first_field_offset(),</span>
1874                        state_before, needs_patching);
1875         }
1876       }
1877       break;
1878     }
1879     case Bytecodes::_withfield:
1880     case Bytecodes::_putfield: {
1881       Value val = pop(type);
1882       val-&gt;set_escaped();
1883       obj = apop();
1884       if (state_before == NULL) {
1885         state_before = copy_state_for_exception();
1886       }
1887       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1888         Value mask = append(new Constant(new IntConstant(1)));
1889         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1890       }
1891 
1892       if (!field-&gt;is_flattened()) {
1893         StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1894         if (!needs_patching) store = _memory-&gt;store(store);
1895         if (store != NULL) {
1896           append(store);
1897         }
1898       } else {
<span class="line-modified">1899         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1900         ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-modified">1901         int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();</span>
<span class="line-modified">1902         copy_value_content(value_klass, val, value_klass-&gt;first_field_offset(), obj, field-&gt;offset(),</span>
1903                    state_before, needs_patching);
1904       }
1905       break;
1906     }
1907     default:
1908       ShouldNotReachHere();
1909       break;
1910   }
1911 }
1912 
1913 // Baseline version of withfield, allocate every time
1914 void GraphBuilder::withfield(int field_index)
1915 {
1916   bool will_link;
1917   ciField* field_modify = stream()-&gt;get_field(will_link);
1918   ciInstanceKlass* holder = field_modify-&gt;holder();
1919   BasicType field_type = field_modify-&gt;type()-&gt;basic_type();
1920   ValueType* type = as_ValueType(field_type);
1921 
1922   // call will_link again to determine if the field is valid.
</pre>
<hr />
<pre>
1943 
1944   Value val = pop(type);
1945   Value obj = apop();
1946 
1947   if (!needs_patching &amp;&amp; obj-&gt;is_optimizable_for_withfield()) {
1948     int astore_index;
1949     ciBytecodeStream s(method());
1950     s.force_bci(bci());
1951     s.next();
1952     switch (s.cur_bc()) {
1953     case Bytecodes::_astore:    astore_index = s.get_index(); break;
1954     case Bytecodes::_astore_0:  astore_index = 0; break;
1955     case Bytecodes::_astore_1:  astore_index = 1; break;
1956     case Bytecodes::_astore_2:  astore_index = 2; break;
1957     case Bytecodes::_astore_3:  astore_index = 3; break;
1958     default: astore_index = -1;
1959     }
1960 
1961     if (astore_index &gt;= 0 &amp;&amp; obj == state()-&gt;local_at(astore_index)) {
1962       // We have a sequence like this, where we load a value object from a local slot,
<span class="line-modified">1963       // and overwrite the same local slot with a modified copy of the value object.</span>
1964       //      defaultvalue #1 // class compiler/valhalla/valuetypes/MyValue1
1965       //      astore 9
1966       //      ...
1967       //      iload_0
1968       //      aload 9
1969       //      swap
1970       //      withfield #7 // Field x:I
1971       //      astore 9
1972       // If this object was created by defaultvalue, and has not escaped, and is not stored
1973       // in any other local slots, we can effectively treat the withfield/astore
1974       // sequence as a single putfield bytecode.
1975       push(objectType, obj);
1976       push(type, val);
1977       access_field(Bytecodes::_withfield);
1978       stream()-&gt;next(); // skip the next astore/astore_n bytecode.
1979       return;
1980     }
1981   }
1982 
<span class="line-modified">1983   assert(holder-&gt;is_valuetype(), &quot;must be a value klass&quot;);</span>
1984   // Save the entire state and re-execute on deopt when executing withfield
1985   state_before-&gt;set_should_reexecute(true);
<span class="line-modified">1986   NewValueTypeInstance* new_instance = new NewValueTypeInstance(holder-&gt;as_value_klass(), state_before, false);</span>
1987   _memory-&gt;new_instance(new_instance);
1988   apush(append_split(new_instance));
1989 
1990   for (int i = 0; i &lt; holder-&gt;nof_nonstatic_fields(); i++) {
1991     ciField* field = holder-&gt;nonstatic_field_at(i);
1992     int off = field-&gt;offset();
1993 
1994     if (field-&gt;offset() != offset) {
1995       if (field-&gt;is_flattened()) {
<span class="line-modified">1996         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1997         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);</span>
<span class="line-modified">1998         ciValueKlass* vk = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-modified">1999         copy_value_content(vk, obj, off, new_instance, vk-&gt;first_field_offset(), state_before, needs_patching);</span>
2000       } else {
2001         // Only load those fields who are not modified
2002         LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);
2003         Value replacement = append(load);
2004         StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);
2005         append(store);
2006       }
2007     }
2008   }
2009 
2010   // Field to modify
2011   if (field_modify-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
2012     Value mask = append(new Constant(new IntConstant(1)));
2013     val = append(new LogicOp(Bytecodes::_iand, val, mask));
2014   }
2015   if (field_modify-&gt;is_flattened()) {
<span class="line-modified">2016     assert(field_modify-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);</span>
<span class="line-modified">2017     ciValueKlass* vk = field_modify-&gt;type()-&gt;as_value_klass();</span>
<span class="line-modified">2018     copy_value_content(vk, val, vk-&gt;first_field_offset(), new_instance, field_modify-&gt;offset(), state_before, needs_patching);</span>
2019   } else {
2020     StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);
2021     append(store);
2022   }
2023 }
2024 
2025 Dependencies* GraphBuilder::dependency_recorder() const {
2026   assert(DeoptC1, &quot;need debug information&quot;);
2027   return compilation()-&gt;dependency_recorder();
2028 }
2029 
2030 // How many arguments do we want to profile?
2031 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
2032   int n = 0;
2033   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
2034   start = has_receiver ? 1 : 0;
2035   if (profile_arguments()) {
2036     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2037     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
2038       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
</pre>
<hr />
<pre>
2352         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2353         ciKlass* target_klass = NULL;
2354         if (cha_monomorphic_target != NULL) {
2355           target_klass = cha_monomorphic_target-&gt;holder();
2356         } else if (exact_target != NULL) {
2357           target_klass = exact_target-&gt;holder();
2358         }
2359         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2360       }
2361     }
2362   }
2363 
2364   if (recv != NULL) {
2365     recv-&gt;set_escaped();
2366   }
2367   for (int i=0; i&lt;args-&gt;length(); i++) {
2368     args-&gt;at(0)-&gt;set_escaped();
2369   }
2370 
2371   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,
<span class="line-modified">2372                               declared_signature-&gt;return_type()-&gt;is_valuetype());</span>
2373   // push result
2374   append_split(result);
2375 
2376   if (result_type != voidType) {
2377     if (method()-&gt;is_strict()) {
2378       push(result_type, round_fp(result));
2379     } else {
2380       push(result_type, result);
2381     }
2382   }
2383   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2384     profile_return_type(result, target);
2385   }
2386 }
2387 
2388 
2389 void GraphBuilder::new_instance(int klass_index) {
2390   ValueStack* state_before = copy_state_exhandling();
2391   bool will_link;
2392   ciKlass* klass = stream()-&gt;get_klass(will_link);
2393   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
<span class="line-modified">2394   assert(!klass-&gt;is_valuetype(), &quot;must not be a value klass&quot;);</span>
2395   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2396   _memory-&gt;new_instance(new_instance);
2397   apush(append_split(new_instance));
2398 }
2399 
2400 void GraphBuilder::default_value(int klass_index) {
2401   bool will_link;
2402   if (!stream()-&gt;is_unresolved_klass()) {
<span class="line-modified">2403     ciValueKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_value_klass();</span>
<span class="line-modified">2404     apush(append(new Constant(new InstanceConstant(vk-&gt;default_value_instance()))));</span>
2405   } else {
2406     ValueStack* state_before = copy_state_before();
2407     apush(append_split(new DefaultValue(state_before)));
2408   }
2409 }
2410 
2411 void GraphBuilder::new_type_array() {
2412   ValueStack* state_before = copy_state_exhandling();
2413   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2414 }
2415 
2416 
2417 void GraphBuilder::new_object_array() {
2418   bool will_link;
2419   ciKlass* klass = stream()-&gt;get_klass(will_link);
2420   bool never_null = stream()-&gt;is_inline_klass();
2421   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2422   NewArray* n = new NewObjectArray(klass, ipop(), state_before, never_null);
2423   apush(append_split(n));
2424 }
</pre>
<hr />
<pre>
2468   ciKlass* klass = stream()-&gt;get_klass(will_link);
2469   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2470   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2471   ipush(append_split(i));
2472   i-&gt;set_direct_compare(direct_compare(klass));
2473 
2474   if (is_profiling()) {
2475     // Note that we&#39;d collect profile data in this method if we wanted it.
2476     compilation()-&gt;set_would_profile(true);
2477 
2478     if (profile_checkcasts()) {
2479       i-&gt;set_profiled_method(method());
2480       i-&gt;set_profiled_bci(bci());
2481       i-&gt;set_should_profile(true);
2482     }
2483   }
2484 }
2485 
2486 
2487 void GraphBuilder::monitorenter(Value x, int bci) {
<span class="line-modified">2488   bool maybe_valuetype = false;</span>
2489   if (bci == InvocationEntryBci) {
2490     // Called by GraphBuilder::inline_sync_entry.
2491 #ifdef ASSERT
2492     ciType* obj_type = x-&gt;declared_type();
<span class="line-modified">2493     assert(obj_type == NULL || !obj_type-&gt;is_valuetype(), &quot;valuetypes cannot have synchronized methods&quot;);</span>
2494 #endif
2495   } else {
2496     // We are compiling a monitorenter bytecode
2497     if (EnableValhalla) {
2498       ciType* obj_type = x-&gt;declared_type();
<span class="line-modified">2499       if (obj_type == NULL || obj_type-&gt;as_klass()-&gt;can_be_value_klass()) {</span>
<span class="line-modified">2500         // If we&#39;re (possibly) locking on a valuetype, check for markWord::always_locked_pattern</span>
2501         // and throw IMSE. (obj_type is null for Phi nodes, so let&#39;s just be conservative).
<span class="line-modified">2502         maybe_valuetype = true;</span>
2503       }
2504     }
2505   }
2506 
2507   // save state before locking in case of deoptimization after a NullPointerException
2508   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
<span class="line-modified">2509   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before, maybe_valuetype), bci);</span>
2510   kill_all();
2511 }
2512 
2513 
2514 void GraphBuilder::monitorexit(Value x, int bci) {
2515   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2516   kill_all();
2517 }
2518 
2519 
2520 void GraphBuilder::new_multi_array(int dimensions) {
2521   bool will_link;
2522   ciKlass* klass = stream()-&gt;get_klass(will_link);
2523   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2524 
2525   Values* dims = new Values(dimensions, dimensions, NULL);
2526   // fill in all dimensions
2527   int i = dimensions;
2528   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2529   // create array
</pre>
<hr />
<pre>
3439 
3440   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3441   state-&gt;clear_locals();
3442   Goto* g = new Goto(target, false);
3443   append(g);
3444   _osr_entry-&gt;set_end(g);
3445   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3446 
3447   scope_data()-&gt;set_stream(NULL);
3448 }
3449 
3450 
3451 ValueStack* GraphBuilder::state_at_entry() {
3452   ValueStack* state = new ValueStack(scope(), NULL);
3453 
3454   // Set up locals for receiver
3455   int idx = 0;
3456   if (!method()-&gt;is_static()) {
3457     // we should always see the receiver
3458     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,
<span class="line-modified">3459              /*receiver*/ true, /*never_null*/ method()-&gt;holder()-&gt;is_value_array_klass()));</span>
3460     idx = 1;
3461   }
3462 
3463   // Set up locals for incoming arguments
3464   ciSignature* sig = method()-&gt;signature();
3465   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3466     ciType* type = sig-&gt;type_at(i);
3467     BasicType basic_type = type-&gt;basic_type();
3468     // don&#39;t allow T_ARRAY to propagate into locals types
3469     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3470     ValueType* vt = as_ValueType(basic_type);
<span class="line-modified">3471     state-&gt;store_local(idx, new Local(type, vt, idx, false, type-&gt;is_valuetype()));</span>
3472     idx += type-&gt;size();
3473   }
3474 
3475   // lock synchronized method
3476   if (method()-&gt;is_synchronized()) {
3477     state-&gt;lock(NULL);
3478   }
3479 
3480   return state;
3481 }
3482 
3483 
3484 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3485   : _scope_data(NULL)
3486   , _compilation(compilation)
3487   , _memory(new MemoryBuffer())
3488   , _inline_bailout_msg(NULL)
3489   , _instruction_count(0)
3490   , _osr_entry(NULL)
3491 {
</pre>
</td>
<td>
<hr />
<pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
<span class="line-added">  33 #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
<span class="line-added">  34 #include &quot;ci/ciInlineKlass.hpp&quot;</span>
  35 #include &quot;ci/ciKlass.hpp&quot;
  36 #include &quot;ci/ciMemberName.hpp&quot;
  37 #include &quot;ci/ciUtilities.inline.hpp&quot;

  38 #include &quot;compiler/compilationPolicy.hpp&quot;
  39 #include &quot;compiler/compileBroker.hpp&quot;
  40 #include &quot;compiler/compilerEvent.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;oops/oop.inline.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;runtime/vm_version.hpp&quot;
  47 #include &quot;utilities/bitMap.inline.hpp&quot;
  48 #include &quot;utilities/powerOfTwo.hpp&quot;
  49 
  50 class BlockListBuilder {
  51  private:
  52   Compilation* _compilation;
  53   IRScope*     _scope;
  54 
  55   BlockList    _blocks;                // internal list of all blocks
  56   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  57 
</pre>
<hr />
<pre>
 642 #endif
 643         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 644         return result;
 645       }
 646     }
 647     return load;
 648   }
 649 
 650   // Record this newly allocated object
 651   void new_instance(NewInstance* object) {
 652     int index = _newobjects.length();
 653     _newobjects.append(object);
 654     if (_fields.at_grow(index, NULL) == NULL) {
 655       _fields.at_put(index, new FieldBuffer());
 656     } else {
 657       _fields.at(index)-&gt;kill();
 658     }
 659   }
 660 
 661   // Record this newly allocated object
<span class="line-modified"> 662   void new_instance(NewInlineTypeInstance* object) {</span>
 663     int index = _newobjects.length();
 664     _newobjects.append(object);
 665     if (_fields.at_grow(index, NULL) == NULL) {
 666       _fields.at_put(index, new FieldBuffer());
 667     } else {
 668       _fields.at(index)-&gt;kill();
 669     }
 670   }
 671 
 672   void store_value(Value value) {
 673     int index = _newobjects.find(value);
 674     if (index != -1) {
 675       // stored a newly allocated object into another object.
 676       // Assume we&#39;ve lost track of it as separate slice of memory.
 677       // We could do better by keeping track of whether individual
 678       // fields could alias each other.
 679       _newobjects.remove_at(index);
 680       // pull out the field info and store it at the end up the list
 681       // of field info list to be reused later.
 682       _fields.append(_fields.at(index));
</pre>
<hr />
<pre>
 997     // Save the entire state and re-execute on deopt when accessing flattened arrays
 998     state_before = copy_state_before();
 999     state_before-&gt;set_should_reexecute(true);
1000   } else {
1001     state_before = copy_state_indexed_access();
1002   }
1003   compilation()-&gt;set_has_access_indexed(true);
1004   Value index = ipop();
1005   Value array = apop();
1006   Value length = NULL;
1007   if (CSEArrayLength ||
1008       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1009       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1010     length = append(new ArrayLength(array, state_before));
1011   }
1012 
1013   LoadIndexed* load_indexed = NULL;
1014   Instruction* result = NULL;
1015   if (array-&gt;is_loaded_flattened_array()) {
1016     ciType* array_type = array-&gt;declared_type();
<span class="line-modified">1017     ciInlineKlass* elem_klass = array_type-&gt;as_flat_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-modified">1018     NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before, false);</span>
1019     _memory-&gt;new_instance(new_instance);
1020     apush(append_split(new_instance));
1021     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1022     load_indexed-&gt;set_vt(new_instance);
1023   } else {
1024     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1025   }
1026   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1027     compilation()-&gt;set_would_profile(true);
1028     load_indexed-&gt;set_should_profile(true);
1029     load_indexed-&gt;set_profiled_method(method());
1030     load_indexed-&gt;set_profiled_bci(bci());
1031   }
1032   result = append(load_indexed);
1033   assert(!(profile_array_accesses() &amp;&amp; is_reference_type(type)) || load_indexed == result, &quot;should not be optimized out&quot;);
1034   if (!array-&gt;is_loaded_flattened_array()) {
1035     push(as_ValueType(type), result);
1036   }
1037 }
1038 
</pre>
<hr />
<pre>
1277   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1278   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1279   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
1280 
1281   bool subst_check = false;
1282   if (EnableValhalla &amp;&amp; (stream()-&gt;cur_bc() == Bytecodes::_if_acmpeq || stream()-&gt;cur_bc() == Bytecodes::_if_acmpne) &amp;&amp;
1283       method() != ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature())) {
1284     // If current method is ValueBootstrapMethods::isSubstitutable(),
1285     // compile the acmp as a regular pointer comparison otherwise we
1286     // could call ValueBootstrapMethods::isSubstitutable() back
1287     ValueType* left_vt = x-&gt;type();
1288     ValueType* right_vt = y-&gt;type();
1289     if (left_vt-&gt;is_object()) {
1290       assert(right_vt-&gt;is_object(), &quot;must be&quot;);
1291       ciKlass* left_klass = x-&gt;as_loaded_klass_or_null();
1292       ciKlass* right_klass = y-&gt;as_loaded_klass_or_null();
1293 
1294       if (left_klass == NULL || right_klass == NULL) {
1295         // The klass is still unloaded, or came from a Phi node. Go slow case;
1296         subst_check = true;
<span class="line-modified">1297       } else if (left_klass-&gt;can_be_inline_klass() || right_klass-&gt;can_be_inline_klass()) {</span>
1298         // Either operand may be a value object, but we&#39;re not sure. Go slow case;
1299         subst_check = true;
1300       } else {
1301         // No need to do substitutability check
1302       }
1303     }
1304   }
1305 
1306   // In case of loop invariant code motion or predicate insertion
1307   // before the body of a loop the state is needed
1308   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));
1309 
1310   assert(i-&gt;as_Goto() == NULL ||
1311          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1312          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1313          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1314 
1315   if (is_profiling()) {
1316     If* if_node = i-&gt;as_If();
1317     if (if_node != NULL) {
</pre>
<hr />
<pre>
1690   // Attach dimension info to stable arrays.
1691   if (FoldStableValues &amp;&amp;
1692       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1693     ciArray* array = field_value.as_object()-&gt;as_array();
1694     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1695     value = new StableArrayConstant(array, dimension);
1696   }
1697 
1698   switch (field_type) {
1699     case T_ARRAY:
1700     case T_OBJECT:
1701       if (field_value.as_object()-&gt;should_be_constant()) {
1702         return new Constant(value);
1703       }
1704       return NULL; // Not a constant.
1705     default:
1706       return new Constant(value);
1707   }
1708 }
1709 
<span class="line-modified">1710 void GraphBuilder::copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off,</span>
<span class="line-modified">1711                                        ValueStack* state_before, bool needs_patching) {</span>
1712   src-&gt;set_escaped();
1713   for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); i++) {
1714     ciField* inner_field = vk-&gt;nonstatic_field_at(i);
1715     assert(!inner_field-&gt;is_flattened(), &quot;the iteration over nested fields is handled by the loop itself&quot;);
1716     int off = inner_field-&gt;offset() - vk-&gt;first_field_offset();
1717     LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);
1718     Value replacement = append(load);
1719     StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);
1720     append(store);
1721   }
1722 }
1723 
1724 void GraphBuilder::access_field(Bytecodes::Code code) {
1725   bool will_link;
1726   ciField* field = stream()-&gt;get_field(will_link);
1727   ciInstanceKlass* holder = field-&gt;holder();
1728   BasicType field_type = field-&gt;type()-&gt;basic_type();
1729   ValueType* type = as_ValueType(field_type);
1730 
1731   // call will_link again to determine if the field is valid.
</pre>
<hr />
<pre>
1797       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1798       break;
1799     }
1800     case Bytecodes::_getfield: {
1801       // Check for compile-time constants, i.e., trusted final non-static fields.
1802       Value constant = NULL;
1803       if (state_before == NULL &amp;&amp; field-&gt;is_flattened()) {
1804         // Save the entire state and re-execute on deopt when accessing flattened fields
1805         assert(Interpreter::bytecode_should_reexecute(code), &quot;should reexecute&quot;);
1806         state_before = copy_state_before();
1807       }
1808       obj = apop();
1809       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
1810       if (field-&gt;is_constant() &amp;&amp; !field-&gt;is_flattened() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {
1811         ciObject* const_oop = obj_type-&gt;constant_value();
1812         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1813           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1814           if (field_value.is_valid()) {
1815             if (field-&gt;signature()-&gt;is_Q_signature() &amp;&amp; field_value.is_null_or_zero()) {
1816               // Non-flattened inline type field. Replace null by the default value.
<span class="line-modified">1817               constant = new Constant(new InstanceConstant(field-&gt;type()-&gt;as_inline_klass()-&gt;default_instance()));</span>
1818             } else {
1819               constant = make_constant(field_value, field);
1820             }
1821             // For CallSite objects add a dependency for invalidation of the optimization.
1822             if (field-&gt;is_call_site_target()) {
1823               ciCallSite* call_site = const_oop-&gt;as_call_site();
1824               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
1825                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1826                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1827               }
1828             }
1829           }
1830         }
1831       }
1832       if (constant != NULL) {
1833         push(type, append(constant));
1834       } else {
1835         if (state_before == NULL) {
1836           state_before = copy_state_for_exception();
1837         }
</pre>
<hr />
<pre>
1845             BasicType bt = field-&gt;type()-&gt;basic_type();
1846             switch (bt) {
1847             case T_BOOLEAN:
1848             case T_BYTE:
1849               replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));
1850               break;
1851             case T_CHAR:
1852               replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));
1853               break;
1854             case T_SHORT:
1855               replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));
1856               break;
1857             default:
1858               break;
1859             }
1860             push(type, replacement);
1861           } else {
1862             push(type, append(load));
1863           }
1864         } else { // flattened field, not optimized solution: re-instantiate the flattened value
<span class="line-modified">1865           assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1866           ciInlineKlass* inline_klass = field-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">1867           int flattening_offset = field-&gt;offset() - inline_klass-&gt;first_field_offset();</span>
<span class="line-modified">1868           assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
1869           scope()-&gt;set_wrote_final();
1870           scope()-&gt;set_wrote_fields();
<span class="line-modified">1871           NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before, false);</span>
1872           _memory-&gt;new_instance(new_instance);
1873           apush(append_split(new_instance));
<span class="line-modified">1874           copy_inline_content(inline_klass, obj, field-&gt;offset(), new_instance, inline_klass-&gt;first_field_offset(),</span>
1875                        state_before, needs_patching);
1876         }
1877       }
1878       break;
1879     }
1880     case Bytecodes::_withfield:
1881     case Bytecodes::_putfield: {
1882       Value val = pop(type);
1883       val-&gt;set_escaped();
1884       obj = apop();
1885       if (state_before == NULL) {
1886         state_before = copy_state_for_exception();
1887       }
1888       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1889         Value mask = append(new Constant(new IntConstant(1)));
1890         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1891       }
1892 
1893       if (!field-&gt;is_flattened()) {
1894         StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1895         if (!needs_patching) store = _memory-&gt;store(store);
1896         if (store != NULL) {
1897           append(store);
1898         }
1899       } else {
<span class="line-modified">1900         assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1901         ciInlineKlass* inline_klass = field-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">1902         int flattening_offset = field-&gt;offset() - inline_klass-&gt;first_field_offset();</span>
<span class="line-modified">1903         copy_inline_content(inline_klass, val, inline_klass-&gt;first_field_offset(), obj, field-&gt;offset(),</span>
1904                    state_before, needs_patching);
1905       }
1906       break;
1907     }
1908     default:
1909       ShouldNotReachHere();
1910       break;
1911   }
1912 }
1913 
1914 // Baseline version of withfield, allocate every time
1915 void GraphBuilder::withfield(int field_index)
1916 {
1917   bool will_link;
1918   ciField* field_modify = stream()-&gt;get_field(will_link);
1919   ciInstanceKlass* holder = field_modify-&gt;holder();
1920   BasicType field_type = field_modify-&gt;type()-&gt;basic_type();
1921   ValueType* type = as_ValueType(field_type);
1922 
1923   // call will_link again to determine if the field is valid.
</pre>
<hr />
<pre>
1944 
1945   Value val = pop(type);
1946   Value obj = apop();
1947 
1948   if (!needs_patching &amp;&amp; obj-&gt;is_optimizable_for_withfield()) {
1949     int astore_index;
1950     ciBytecodeStream s(method());
1951     s.force_bci(bci());
1952     s.next();
1953     switch (s.cur_bc()) {
1954     case Bytecodes::_astore:    astore_index = s.get_index(); break;
1955     case Bytecodes::_astore_0:  astore_index = 0; break;
1956     case Bytecodes::_astore_1:  astore_index = 1; break;
1957     case Bytecodes::_astore_2:  astore_index = 2; break;
1958     case Bytecodes::_astore_3:  astore_index = 3; break;
1959     default: astore_index = -1;
1960     }
1961 
1962     if (astore_index &gt;= 0 &amp;&amp; obj == state()-&gt;local_at(astore_index)) {
1963       // We have a sequence like this, where we load a value object from a local slot,
<span class="line-modified">1964       // and overwrite the same local slot with a modified copy of the inline object.</span>
1965       //      defaultvalue #1 // class compiler/valhalla/valuetypes/MyValue1
1966       //      astore 9
1967       //      ...
1968       //      iload_0
1969       //      aload 9
1970       //      swap
1971       //      withfield #7 // Field x:I
1972       //      astore 9
1973       // If this object was created by defaultvalue, and has not escaped, and is not stored
1974       // in any other local slots, we can effectively treat the withfield/astore
1975       // sequence as a single putfield bytecode.
1976       push(objectType, obj);
1977       push(type, val);
1978       access_field(Bytecodes::_withfield);
1979       stream()-&gt;next(); // skip the next astore/astore_n bytecode.
1980       return;
1981     }
1982   }
1983 
<span class="line-modified">1984   assert(holder-&gt;is_inlinetype(), &quot;must be an inline klass&quot;);</span>
1985   // Save the entire state and re-execute on deopt when executing withfield
1986   state_before-&gt;set_should_reexecute(true);
<span class="line-modified">1987   NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(holder-&gt;as_inline_klass(), state_before, false);</span>
1988   _memory-&gt;new_instance(new_instance);
1989   apush(append_split(new_instance));
1990 
1991   for (int i = 0; i &lt; holder-&gt;nof_nonstatic_fields(); i++) {
1992     ciField* field = holder-&gt;nonstatic_field_at(i);
1993     int off = field-&gt;offset();
1994 
1995     if (field-&gt;offset() != offset) {
1996       if (field-&gt;is_flattened()) {
<span class="line-modified">1997         assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1998         assert(field-&gt;type()-&gt;is_inlinetype(), &quot;Only inline types can be flattened&quot;);</span>
<span class="line-modified">1999         ciInlineKlass* vk = field-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">2000         copy_inline_content(vk, obj, off, new_instance, vk-&gt;first_field_offset(), state_before, needs_patching);</span>
2001       } else {
2002         // Only load those fields who are not modified
2003         LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);
2004         Value replacement = append(load);
2005         StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);
2006         append(store);
2007       }
2008     }
2009   }
2010 
2011   // Field to modify
2012   if (field_modify-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
2013     Value mask = append(new Constant(new IntConstant(1)));
2014     val = append(new LogicOp(Bytecodes::_iand, val, mask));
2015   }
2016   if (field_modify-&gt;is_flattened()) {
<span class="line-modified">2017     assert(field_modify-&gt;type()-&gt;is_inlinetype(), &quot;Only inline types can be flattened&quot;);</span>
<span class="line-modified">2018     ciInlineKlass* vk = field_modify-&gt;type()-&gt;as_inline_klass();</span>
<span class="line-modified">2019     copy_inline_content(vk, val, vk-&gt;first_field_offset(), new_instance, field_modify-&gt;offset(), state_before, needs_patching);</span>
2020   } else {
2021     StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);
2022     append(store);
2023   }
2024 }
2025 
2026 Dependencies* GraphBuilder::dependency_recorder() const {
2027   assert(DeoptC1, &quot;need debug information&quot;);
2028   return compilation()-&gt;dependency_recorder();
2029 }
2030 
2031 // How many arguments do we want to profile?
2032 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
2033   int n = 0;
2034   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
2035   start = has_receiver ? 1 : 0;
2036   if (profile_arguments()) {
2037     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2038     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
2039       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
</pre>
<hr />
<pre>
2353         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2354         ciKlass* target_klass = NULL;
2355         if (cha_monomorphic_target != NULL) {
2356           target_klass = cha_monomorphic_target-&gt;holder();
2357         } else if (exact_target != NULL) {
2358           target_klass = exact_target-&gt;holder();
2359         }
2360         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2361       }
2362     }
2363   }
2364 
2365   if (recv != NULL) {
2366     recv-&gt;set_escaped();
2367   }
2368   for (int i=0; i&lt;args-&gt;length(); i++) {
2369     args-&gt;at(0)-&gt;set_escaped();
2370   }
2371 
2372   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,
<span class="line-modified">2373                               declared_signature-&gt;return_type()-&gt;is_inlinetype());</span>
2374   // push result
2375   append_split(result);
2376 
2377   if (result_type != voidType) {
2378     if (method()-&gt;is_strict()) {
2379       push(result_type, round_fp(result));
2380     } else {
2381       push(result_type, result);
2382     }
2383   }
2384   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2385     profile_return_type(result, target);
2386   }
2387 }
2388 
2389 
2390 void GraphBuilder::new_instance(int klass_index) {
2391   ValueStack* state_before = copy_state_exhandling();
2392   bool will_link;
2393   ciKlass* klass = stream()-&gt;get_klass(will_link);
2394   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
<span class="line-modified">2395   assert(!klass-&gt;is_inlinetype(), &quot;must not be an inline klass&quot;);</span>
2396   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2397   _memory-&gt;new_instance(new_instance);
2398   apush(append_split(new_instance));
2399 }
2400 
2401 void GraphBuilder::default_value(int klass_index) {
2402   bool will_link;
2403   if (!stream()-&gt;is_unresolved_klass()) {
<span class="line-modified">2404     ciInlineKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_inline_klass();</span>
<span class="line-modified">2405     apush(append(new Constant(new InstanceConstant(vk-&gt;default_instance()))));</span>
2406   } else {
2407     ValueStack* state_before = copy_state_before();
2408     apush(append_split(new DefaultValue(state_before)));
2409   }
2410 }
2411 
2412 void GraphBuilder::new_type_array() {
2413   ValueStack* state_before = copy_state_exhandling();
2414   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2415 }
2416 
2417 
2418 void GraphBuilder::new_object_array() {
2419   bool will_link;
2420   ciKlass* klass = stream()-&gt;get_klass(will_link);
2421   bool never_null = stream()-&gt;is_inline_klass();
2422   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2423   NewArray* n = new NewObjectArray(klass, ipop(), state_before, never_null);
2424   apush(append_split(n));
2425 }
</pre>
<hr />
<pre>
2469   ciKlass* klass = stream()-&gt;get_klass(will_link);
2470   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2471   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2472   ipush(append_split(i));
2473   i-&gt;set_direct_compare(direct_compare(klass));
2474 
2475   if (is_profiling()) {
2476     // Note that we&#39;d collect profile data in this method if we wanted it.
2477     compilation()-&gt;set_would_profile(true);
2478 
2479     if (profile_checkcasts()) {
2480       i-&gt;set_profiled_method(method());
2481       i-&gt;set_profiled_bci(bci());
2482       i-&gt;set_should_profile(true);
2483     }
2484   }
2485 }
2486 
2487 
2488 void GraphBuilder::monitorenter(Value x, int bci) {
<span class="line-modified">2489   bool maybe_inlinetype = false;</span>
2490   if (bci == InvocationEntryBci) {
2491     // Called by GraphBuilder::inline_sync_entry.
2492 #ifdef ASSERT
2493     ciType* obj_type = x-&gt;declared_type();
<span class="line-modified">2494     assert(obj_type == NULL || !obj_type-&gt;is_inlinetype(), &quot;inline types cannot have synchronized methods&quot;);</span>
2495 #endif
2496   } else {
2497     // We are compiling a monitorenter bytecode
2498     if (EnableValhalla) {
2499       ciType* obj_type = x-&gt;declared_type();
<span class="line-modified">2500       if (obj_type == NULL || obj_type-&gt;as_klass()-&gt;can_be_inline_klass()) {</span>
<span class="line-modified">2501         // If we&#39;re (possibly) locking on an inline type, check for markWord::always_locked_pattern</span>
2502         // and throw IMSE. (obj_type is null for Phi nodes, so let&#39;s just be conservative).
<span class="line-modified">2503         maybe_inlinetype = true;</span>
2504       }
2505     }
2506   }
2507 
2508   // save state before locking in case of deoptimization after a NullPointerException
2509   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
<span class="line-modified">2510   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before, maybe_inlinetype), bci);</span>
2511   kill_all();
2512 }
2513 
2514 
2515 void GraphBuilder::monitorexit(Value x, int bci) {
2516   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2517   kill_all();
2518 }
2519 
2520 
2521 void GraphBuilder::new_multi_array(int dimensions) {
2522   bool will_link;
2523   ciKlass* klass = stream()-&gt;get_klass(will_link);
2524   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2525 
2526   Values* dims = new Values(dimensions, dimensions, NULL);
2527   // fill in all dimensions
2528   int i = dimensions;
2529   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2530   // create array
</pre>
<hr />
<pre>
3440 
3441   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3442   state-&gt;clear_locals();
3443   Goto* g = new Goto(target, false);
3444   append(g);
3445   _osr_entry-&gt;set_end(g);
3446   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3447 
3448   scope_data()-&gt;set_stream(NULL);
3449 }
3450 
3451 
3452 ValueStack* GraphBuilder::state_at_entry() {
3453   ValueStack* state = new ValueStack(scope(), NULL);
3454 
3455   // Set up locals for receiver
3456   int idx = 0;
3457   if (!method()-&gt;is_static()) {
3458     // we should always see the receiver
3459     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,
<span class="line-modified">3460              /*receiver*/ true, /*never_null*/ method()-&gt;holder()-&gt;is_flat_array_klass()));</span>
3461     idx = 1;
3462   }
3463 
3464   // Set up locals for incoming arguments
3465   ciSignature* sig = method()-&gt;signature();
3466   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3467     ciType* type = sig-&gt;type_at(i);
3468     BasicType basic_type = type-&gt;basic_type();
3469     // don&#39;t allow T_ARRAY to propagate into locals types
3470     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3471     ValueType* vt = as_ValueType(basic_type);
<span class="line-modified">3472     state-&gt;store_local(idx, new Local(type, vt, idx, false, type-&gt;is_inlinetype()));</span>
3473     idx += type-&gt;size();
3474   }
3475 
3476   // lock synchronized method
3477   if (method()-&gt;is_synchronized()) {
3478     state-&gt;lock(NULL);
3479   }
3480 
3481   return state;
3482 }
3483 
3484 
3485 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3486   : _scope_data(NULL)
3487   , _compilation(compilation)
3488   , _memory(new MemoryBuffer())
3489   , _inline_bailout_msg(NULL)
3490   , _instruction_count(0)
3491   , _osr_entry(NULL)
3492 {
</pre>
</td>
</tr>
</table>
<center><a href="c1_CodeStubs.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_GraphBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
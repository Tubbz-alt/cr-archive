<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subtypenode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,14 ***</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;ci/ciField.hpp&quot;
  #include &quot;ci/ciMethodData.hpp&quot;
  #include &quot;ci/ciTypeFlow.hpp&quot;
<span class="line-removed">- #include &quot;ci/ciValueKlass.hpp&quot;</span>
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;compiler/compileLog.hpp&quot;
  #include &quot;libadt/dict.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
<span class="line-new-header">--- 21,15 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
  #include &quot;ci/ciField.hpp&quot;
<span class="line-added">+ #include &quot;ci/ciInlineKlass.hpp&quot;</span>
  #include &quot;ci/ciMethodData.hpp&quot;
  #include &quot;ci/ciTypeFlow.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;compiler/compileLog.hpp&quot;
  #include &quot;libadt/dict.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,11 ***</span>
    { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
    { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
    { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
    { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  #endif
<span class="line-modified">!   { Bad,             T_INLINE_TYPE, &quot;value:&quot;,       false, Node::NotAMachineReg, relocInfo::none          },  // ValueType</span>
    { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
    { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
    { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
    { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
    { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
<span class="line-new-header">--- 127,11 ---</span>
    { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
    { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
    { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
    { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  #endif
<span class="line-modified">!   { Bad,             T_INLINE_TYPE, &quot;inline:&quot;,      false, Node::NotAMachineReg, relocInfo::none          },  // InlineType</span>
    { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
    { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
    { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
    { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
    { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,13 ***</span>
    case T_ADDRESS:
      assert(type-&gt;is_return_address(), &quot;&quot;);
      return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
  
    case T_INLINE_TYPE: {
<span class="line-modified">!     ciValueKlass* vk = type-&gt;as_value_klass();</span>
      if (vk-&gt;is_scalarizable()) {
<span class="line-modified">!       return TypeValueType::make(vk);</span>
      } else {
        return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(TypePtr::NOTNULL);
      }
    }
  
<span class="line-new-header">--- 259,13 ---</span>
    case T_ADDRESS:
      assert(type-&gt;is_return_address(), &quot;&quot;);
      return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
  
    case T_INLINE_TYPE: {
<span class="line-modified">!     ciInlineKlass* vk = type-&gt;as_inline_klass();</span>
      if (vk-&gt;is_scalarizable()) {
<span class="line-modified">!       return TypeInlineType::make(vk);</span>
      } else {
        return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(TypePtr::NOTNULL);
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,11 ***</span>
                                             false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
    TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
  
    TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
  
<span class="line-modified">!   TypeValueType::BOTTOM = TypeValueType::make(NULL);</span>
  
    TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
    TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
  
    TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
<span class="line-new-header">--- 594,11 ---</span>
                                             false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
    TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
  
    TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
  
<span class="line-modified">!   TypeInlineType::BOTTOM = TypeInlineType::make(NULL);</span>
  
    TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
    TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
  
    TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,11 ***</span>
    TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
    TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
    TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
    TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
    TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
<span class="line-modified">!   TypeAryPtr::VALUES  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeValueType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);</span>
  
    // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
    TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
    TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
    TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;
<span class="line-new-header">--- 632,11 ---</span>
    TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
    TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
    TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
    TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
    TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
<span class="line-modified">!   TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);</span>
  
    // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
    TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
    TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
    TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 984,11 ***</span>
      return t-&gt;xmeet(this);
  
    case NarrowKlass:
      return t-&gt;xmeet(this);
  
<span class="line-modified">!   case ValueType:</span>
      return t-&gt;xmeet(this);
  
    case Bad:                     // Type check
    default:                      // Bogus type not in lattice
      typerr(t);
<span class="line-new-header">--- 985,11 ---</span>
      return t-&gt;xmeet(this);
  
    case NarrowKlass:
      return t-&gt;xmeet(this);
  
<span class="line-modified">!   case InlineType:</span>
      return t-&gt;xmeet(this);
  
    case Bad:                     // Type check
    default:                      // Bogus type not in lattice
      typerr(t);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1054,11 ***</span>
    Bad,          // VectorS - handled in v-call
    Bad,          // VectorD - handled in v-call
    Bad,          // VectorX - handled in v-call
    Bad,          // VectorY - handled in v-call
    Bad,          // VectorZ - handled in v-call
<span class="line-modified">!   Bad,          // ValueType - handled in v-call</span>
  
    Bad,          // AnyPtr - handled in v-call
    Bad,          // RawPtr - handled in v-call
    Bad,          // OopPtr - handled in v-call
    Bad,          // InstPtr - handled in v-call
<span class="line-new-header">--- 1055,11 ---</span>
    Bad,          // VectorS - handled in v-call
    Bad,          // VectorD - handled in v-call
    Bad,          // VectorX - handled in v-call
    Bad,          // VectorY - handled in v-call
    Bad,          // VectorZ - handled in v-call
<span class="line-modified">!   Bad,          // InlineType - handled in v-call</span>
  
    Bad,          // AnyPtr - handled in v-call
    Bad,          // RawPtr - handled in v-call
    Bad,          // OopPtr - handled in v-call
    Bad,          // InstPtr - handled in v-call
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1950,11 ***</span>
  const TypeTuple *TypeTuple::INT_PAIR;
  const TypeTuple *TypeTuple::LONG_PAIR;
  const TypeTuple *TypeTuple::INT_CC_PAIR;
  const TypeTuple *TypeTuple::LONG_CC_PAIR;
  
<span class="line-modified">! static void collect_value_fields(ciValueKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {</span>
    for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
      ciField* field = vk-&gt;nonstatic_field_at(j);
      BasicType bt = field-&gt;type()-&gt;basic_type();
      const Type* ft = Type::get_const_type(field-&gt;type());
      field_array[pos++] = ft;
<span class="line-new-header">--- 1951,11 ---</span>
  const TypeTuple *TypeTuple::INT_PAIR;
  const TypeTuple *TypeTuple::LONG_PAIR;
  const TypeTuple *TypeTuple::INT_CC_PAIR;
  const TypeTuple *TypeTuple::LONG_CC_PAIR;
  
<span class="line-modified">! static void collect_inline_fields(ciInlineKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {</span>
    for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
      ciField* field = vk-&gt;nonstatic_field_at(j);
      BasicType bt = field-&gt;type()-&gt;basic_type();
      const Type* ft = Type::get_const_type(field-&gt;type());
      field_array[pos++] = ft;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1975,11 ***</span>
  // Make a TypeTuple from the range of a method signature
  const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {
    ciType* return_type = sig-&gt;return_type();
    uint arg_cnt = return_type-&gt;size();
    if (ret_vt_fields) {
<span class="line-modified">!     arg_cnt = return_type-&gt;as_value_klass()-&gt;value_arg_slots() + 1;</span>
    }
  
    const Type **field_array = fields(arg_cnt);
    switch (return_type-&gt;basic_type()) {
    case T_LONG:
<span class="line-new-header">--- 1976,11 ---</span>
  // Make a TypeTuple from the range of a method signature
  const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {
    ciType* return_type = sig-&gt;return_type();
    uint arg_cnt = return_type-&gt;size();
    if (ret_vt_fields) {
<span class="line-modified">!     arg_cnt = return_type-&gt;as_inline_klass()-&gt;inline_arg_slots() + 1;</span>
    }
  
    const Type **field_array = fields(arg_cnt);
    switch (return_type-&gt;basic_type()) {
    case T_LONG:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2004,11 ***</span>
      if (ret_vt_fields) {
        uint pos = TypeFunc::Parms;
        field_array[pos] = TypePtr::BOTTOM;
        pos++;
        ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
<span class="line-modified">!       collect_value_fields(return_type-&gt;as_value_klass(), field_array, pos, sig);</span>
      } else {
        field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(TypePtr::NOTNULL);
      }
      break;
    case T_VOID:
<span class="line-new-header">--- 2005,11 ---</span>
      if (ret_vt_fields) {
        uint pos = TypeFunc::Parms;
        field_array[pos] = TypePtr::BOTTOM;
        pos++;
        ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
<span class="line-modified">!       collect_inline_fields(return_type-&gt;as_inline_klass(), field_array, pos, sig);</span>
      } else {
        field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(TypePtr::NOTNULL);
      }
      break;
    case T_VOID:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2034,12 ***</span>
  
    uint pos = TypeFunc::Parms;
    const Type** field_array = fields(arg_cnt);
    if (!method-&gt;is_static()) {
      ciInstanceKlass* recv = method-&gt;holder();
<span class="line-modified">!     if (vt_fields_as_args &amp;&amp; recv-&gt;is_valuetype() &amp;&amp; recv-&gt;as_value_klass()-&gt;can_be_passed_as_fields()) {</span>
<span class="line-modified">!       collect_value_fields(recv-&gt;as_value_klass(), field_array, pos, sig_cc);</span>
      } else {
        field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
        if (vt_fields_as_args) {
          ++sig_cc;
        }
<span class="line-new-header">--- 2035,12 ---</span>
  
    uint pos = TypeFunc::Parms;
    const Type** field_array = fields(arg_cnt);
    if (!method-&gt;is_static()) {
      ciInstanceKlass* recv = method-&gt;holder();
<span class="line-modified">!     if (vt_fields_as_args &amp;&amp; recv-&gt;is_inlinetype() &amp;&amp; recv-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {</span>
<span class="line-modified">!       collect_inline_fields(recv-&gt;as_inline_klass(), field_array, pos, sig_cc);</span>
      } else {
        field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
        if (vt_fields_as_args) {
          ++sig_cc;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2072,13 ***</span>
      case T_BYTE:
      case T_SHORT:
        field_array[pos++] = TypeInt::INT;
        break;
      case T_INLINE_TYPE: {
<span class="line-modified">!       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;can_be_passed_as_fields()) {</span>
          is_flattened = true;
<span class="line-modified">!         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);</span>
        } else {
          field_array[pos++] = get_const_type(type)-&gt;join_speculative(TypePtr::NOTNULL);
        }
        break;
      }
<span class="line-new-header">--- 2073,13 ---</span>
      case T_BYTE:
      case T_SHORT:
        field_array[pos++] = TypeInt::INT;
        break;
      case T_INLINE_TYPE: {
<span class="line-modified">!       if (vt_fields_as_args &amp;&amp; type-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {</span>
          is_flattened = true;
<span class="line-modified">!         collect_inline_fields(type-&gt;as_inline_klass(), field_array, pos, sig_cc);</span>
        } else {
          field_array[pos++] = get_const_type(type)-&gt;join_speculative(TypePtr::NOTNULL);
        }
        break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2394,26 ***</span>
    if (tap)
      return tap-&gt;ary()-&gt;ary_must_be_exact();
    return false;
  }
  
<span class="line-modified">! //==============================TypeValueType=======================================</span>
  
<span class="line-modified">! const TypeValueType *TypeValueType::BOTTOM;</span>
  
  //------------------------------make-------------------------------------------
<span class="line-modified">! const TypeValueType* TypeValueType::make(ciValueKlass* vk, bool larval) {</span>
<span class="line-modified">!   return (TypeValueType*)(new TypeValueType(vk, larval))-&gt;hashcons();</span>
  }
  
  //------------------------------meet-------------------------------------------
  // Compute the MEET of two types.  It returns a new Type object.
<span class="line-modified">! const Type* TypeValueType::xmeet(const Type* t) const {</span>
    // Perform a fast test for common case; meeting the same types together.
    if(this == t) return this;  // Meeting same type-rep?
  
<span class="line-modified">!   // Current &quot;this-&gt;_base&quot; is ValueType</span>
    switch (t-&gt;base()) {          // switch on original type
  
    case Int:
    case Long:
    case FloatTop:
<span class="line-new-header">--- 2395,26 ---</span>
    if (tap)
      return tap-&gt;ary()-&gt;ary_must_be_exact();
    return false;
  }
  
<span class="line-modified">! //==============================TypeInlineType=======================================</span>
  
<span class="line-modified">! const TypeInlineType* TypeInlineType::BOTTOM;</span>
  
  //------------------------------make-------------------------------------------
<span class="line-modified">! const TypeInlineType* TypeInlineType::make(ciInlineKlass* vk, bool larval) {</span>
<span class="line-modified">!   return (TypeInlineType*)(new TypeInlineType(vk, larval))-&gt;hashcons();</span>
  }
  
  //------------------------------meet-------------------------------------------
  // Compute the MEET of two types.  It returns a new Type object.
<span class="line-modified">! const Type* TypeInlineType::xmeet(const Type* t) const {</span>
    // Perform a fast test for common case; meeting the same types together.
    if(this == t) return this;  // Meeting same type-rep?
  
<span class="line-modified">!   // Current &quot;this-&gt;_base&quot; is InlineType</span>
    switch (t-&gt;base()) {          // switch on original type
  
    case Int:
    case Long:
    case FloatTop:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2446,13 ***</span>
    case AryPtr:
    case InstPtr: {
      return t-&gt;xmeet(this);
    }
  
<span class="line-modified">!   case ValueType: {</span>
<span class="line-modified">!     // All value types inherit from Object</span>
<span class="line-modified">!     const TypeValueType* other = t-&gt;is_valuetype();</span>
      if (_vk == NULL) {
        return this;
      } else if (other-&gt;_vk == NULL) {
        return other;
      } else if (_vk == other-&gt;_vk) {
<span class="line-new-header">--- 2447,13 ---</span>
    case AryPtr:
    case InstPtr: {
      return t-&gt;xmeet(this);
    }
  
<span class="line-modified">!   case InlineType: {</span>
<span class="line-modified">!     // All inline types inherit from Object</span>
<span class="line-modified">!     const TypeInlineType* other = t-&gt;is_inlinetype();</span>
      if (_vk == NULL) {
        return this;
      } else if (other-&gt;_vk == NULL) {
        return other;
      } else if (_vk == other-&gt;_vk) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2472,48 ***</span>
    }
    return this;
  }
  
  //------------------------------xdual------------------------------------------
<span class="line-modified">! const Type* TypeValueType::xdual() const {</span>
    return this;
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
<span class="line-modified">! bool TypeValueType::eq(const Type* t) const {</span>
<span class="line-modified">!   const TypeValueType* vt = t-&gt;is_valuetype();</span>
<span class="line-modified">!   return (_vk == vt-&gt;value_klass() &amp;&amp; _larval == vt-&gt;larval());</span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
<span class="line-modified">! int TypeValueType::hash(void) const {</span>
    return (intptr_t)_vk;
  }
  
  //------------------------------singleton--------------------------------------
  // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.
<span class="line-modified">! bool TypeValueType::singleton(void) const {</span>
    return false;
  }
  
  //------------------------------empty------------------------------------------
  // TRUE if Type is a type with no values, FALSE otherwise.
<span class="line-modified">! bool TypeValueType::empty(void) const {</span>
    return false;
  }
  
  //------------------------------dump2------------------------------------------
  #ifndef PRODUCT
<span class="line-modified">! void TypeValueType::dump2(Dict &amp;d, uint depth, outputStream* st) const {</span>
    if (_vk == NULL) {
<span class="line-modified">!     st-&gt;print(&quot;BOTTOM valuetype&quot;);</span>
      return;
    }
    int count = _vk-&gt;nof_declared_nonstatic_fields();
<span class="line-modified">!   st-&gt;print(&quot;valuetype[%d]:{&quot;, count);</span>
    st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);
    for (int i = 1; i &lt; count; ++i) {
      st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());
    }
    st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);
<span class="line-new-header">--- 2473,48 ---</span>
    }
    return this;
  }
  
  //------------------------------xdual------------------------------------------
<span class="line-modified">! const Type* TypeInlineType::xdual() const {</span>
    return this;
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
<span class="line-modified">! bool TypeInlineType::eq(const Type* t) const {</span>
<span class="line-modified">!   const TypeInlineType* vt = t-&gt;is_inlinetype();</span>
<span class="line-modified">!   return (_vk == vt-&gt;inline_klass() &amp;&amp; _larval == vt-&gt;larval());</span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
<span class="line-modified">! int TypeInlineType::hash(void) const {</span>
    return (intptr_t)_vk;
  }
  
  //------------------------------singleton--------------------------------------
  // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.
<span class="line-modified">! bool TypeInlineType::singleton(void) const {</span>
    return false;
  }
  
  //------------------------------empty------------------------------------------
  // TRUE if Type is a type with no values, FALSE otherwise.
<span class="line-modified">! bool TypeInlineType::empty(void) const {</span>
    return false;
  }
  
  //------------------------------dump2------------------------------------------
  #ifndef PRODUCT
<span class="line-modified">! void TypeInlineType::dump2(Dict &amp;d, uint depth, outputStream* st) const {</span>
    if (_vk == NULL) {
<span class="line-modified">!     st-&gt;print(&quot;BOTTOM inlinetype&quot;);</span>
      return;
    }
    int count = _vk-&gt;nof_declared_nonstatic_fields();
<span class="line-modified">!   st-&gt;print(&quot;inlinetype[%d]:{&quot;, count);</span>
    st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);
    for (int i = 1; i &lt; count; ++i) {
      st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());
    }
    st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3245,13 ***</span>
        assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
        _is_ptr_to_narrowoop = UseCompressedOops;
      } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
        if (klass()-&gt;is_obj_array_klass()) {
          _is_ptr_to_narrowoop = true;
<span class="line-modified">!       } else if (klass()-&gt;is_value_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {</span>
<span class="line-modified">!         // Check if the field of the value type array element contains oops</span>
<span class="line-modified">!         ciValueKlass* vk = klass()-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
          int foffset = field_offset.get() + vk-&gt;first_field_offset();
          ciField* field = vk-&gt;get_field_by_offset(foffset, false);
          assert(field != NULL, &quot;missing field&quot;);
          BasicType bt = field-&gt;layout_type();
          _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);
<span class="line-new-header">--- 3246,13 ---</span>
        assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
        _is_ptr_to_narrowoop = UseCompressedOops;
      } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
        if (klass()-&gt;is_obj_array_klass()) {
          _is_ptr_to_narrowoop = true;
<span class="line-modified">!       } else if (klass()-&gt;is_flat_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {</span>
<span class="line-modified">!         // Check if the field of the inline type array element contains oops</span>
<span class="line-modified">!         ciInlineKlass* vk = klass()-&gt;as_flat_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
          int foffset = field_offset.get() + vk-&gt;first_field_offset();
          ciField* field = vk-&gt;get_field_by_offset(foffset, false);
          assert(field != NULL, &quot;missing field&quot;);
          BasicType bt = field-&gt;layout_type();
          _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3274,12 ***</span>
                     this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
            // Static fields
            assert(o != NULL, &quot;must be constant&quot;);
            ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
            BasicType basic_elem_type;
<span class="line-modified">!           if (ik-&gt;is_valuetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_value_klass()-&gt;default_value_offset()) {</span>
<span class="line-modified">!             // Special hidden field that contains the oop of the default value type</span>
              basic_elem_type = T_INLINE_TYPE;
            } else {
              ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
              assert(field != NULL, &quot;missing field&quot;);
              basic_elem_type = field-&gt;layout_type();
<span class="line-new-header">--- 3275,12 ---</span>
                     this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
            // Static fields
            assert(o != NULL, &quot;must be constant&quot;);
            ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
            BasicType basic_elem_type;
<span class="line-modified">!           if (ik-&gt;is_inlinetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_inline_klass()-&gt;default_value_offset()) {</span>
<span class="line-modified">!             // Special hidden field that contains the oop of the default inline type</span>
              basic_elem_type = T_INLINE_TYPE;
            } else {
              ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
              assert(field != NULL, &quot;missing field&quot;);
              basic_elem_type = field-&gt;layout_type();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3433,11 ***</span>
  }
  
  //--------------------------make_from_klass_common-----------------------------
  // Computes the element-type given a klass.
  const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="line-modified">!   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {</span>
      Compile* C = Compile::current();
      Dependencies* deps = C-&gt;dependencies();
      assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
      // Element is an instance
      bool klass_is_exact = false;
<span class="line-new-header">--- 3434,11 ---</span>
  }
  
  //--------------------------make_from_klass_common-----------------------------
  // Computes the element-type given a klass.
  const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="line-modified">!   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {</span>
      Compile* C = Compile::current();
      Dependencies* deps = C-&gt;dependencies();
      assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
      // Element is an instance
      bool klass_is_exact = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3463,23 ***</span>
          }
        }
      }
      return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
    } else if (klass-&gt;is_obj_array_klass()) {
<span class="line-modified">!     // Element is an object or value array. Recursively call ourself.</span>
      const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
<span class="line-modified">!     if (etype-&gt;is_valuetypeptr()) {</span>
        etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
      }
      // Determine null-free/flattened properties
      const TypeOopPtr* exact_etype = etype;
<span class="line-modified">!     if (etype-&gt;can_be_value_type()) {</span>
<span class="line-modified">!       // Use exact type if element can be a value type</span>
        exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
      }
<span class="line-modified">!     bool not_null_free = !exact_etype-&gt;can_be_value_type();</span>
<span class="line-modified">!     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_valuetypeptr() &amp;&amp; !exact_etype-&gt;value_klass()-&gt;flatten_array());</span>
  
      bool xk = etype-&gt;klass_is_exact();
      const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
      // We used to pass NotNull in here, asserting that the sub-arrays
      // are all not-null.  This is not true in generally, as code can
<span class="line-new-header">--- 3464,23 ---</span>
          }
        }
      }
      return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
    } else if (klass-&gt;is_obj_array_klass()) {
<span class="line-modified">!     // Element is an object or inline type array. Recursively call ourself.</span>
      const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
<span class="line-modified">!     if (etype-&gt;is_inlinetypeptr()) {</span>
        etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
      }
      // Determine null-free/flattened properties
      const TypeOopPtr* exact_etype = etype;
<span class="line-modified">!     if (etype-&gt;can_be_inline_type()) {</span>
<span class="line-modified">!       // Use exact type if element can be an inline type</span>
        exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
      }
<span class="line-modified">!     bool not_null_free = !exact_etype-&gt;can_be_inline_type();</span>
<span class="line-modified">!     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_inlinetypeptr() &amp;&amp; !exact_etype-&gt;inline_klass()-&gt;flatten_array());</span>
  
      bool xk = etype-&gt;klass_is_exact();
      const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
      // We used to pass NotNull in here, asserting that the sub-arrays
      // are all not-null.  This is not true in generally, as code can
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3493,13 ***</span>
                                          /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
      // We used to pass NotNull in here, asserting that the array pointer
      // is not-null. That was not true in general.
      const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
      return arr;
<span class="line-modified">!   } else if (klass-&gt;is_value_array_klass()) {</span>
<span class="line-modified">!     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-modified">!     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::POS);</span>
      const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
      return arr;
    } else {
      ShouldNotReachHere();
      return NULL;
<span class="line-new-header">--- 3494,13 ---</span>
                                          /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
      // We used to pass NotNull in here, asserting that the array pointer
      // is not-null. That was not true in general.
      const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
      return arr;
<span class="line-modified">!   } else if (klass-&gt;is_flat_array_klass()) {</span>
<span class="line-modified">!     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-modified">!     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::POS);</span>
      const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
      return arr;
    } else {
      ShouldNotReachHere();
      return NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3512,22 ***</span>
    assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
  
    const bool make_constant = require_constant || o-&gt;should_be_constant();
  
    ciKlass* klass = o-&gt;klass();
<span class="line-modified">!   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {</span>
<span class="line-modified">!     // Element is an instance or value type</span>
      if (make_constant) {
        return TypeInstPtr::make(o);
      } else {
        return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
      }
    } else if (klass-&gt;is_obj_array_klass()) {
      // Element is an object array. Recursively call ourself.
      const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
      bool null_free = false;
<span class="line-modified">!     if (etype-&gt;is_valuetypeptr()) {</span>
        null_free = true;
        etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
      }
      const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
                                          /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
<span class="line-new-header">--- 3513,22 ---</span>
    assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
  
    const bool make_constant = require_constant || o-&gt;should_be_constant();
  
    ciKlass* klass = o-&gt;klass();
<span class="line-modified">!   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {</span>
<span class="line-modified">!     // Element is an instance or inline type</span>
      if (make_constant) {
        return TypeInstPtr::make(o);
      } else {
        return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
      }
    } else if (klass-&gt;is_obj_array_klass()) {
      // Element is an object array. Recursively call ourself.
      const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
      bool null_free = false;
<span class="line-modified">!     if (etype-&gt;is_inlinetypeptr()) {</span>
        null_free = true;
        etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
      }
      const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
                                          /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3549,13 ***</span>
      if (make_constant) {
        return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
      } else {
        return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
      }
<span class="line-modified">!   } else if (klass-&gt;is_value_array_klass()) {</span>
<span class="line-modified">!     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-modified">!     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
      // We used to pass NotNull in here, asserting that the sub-arrays
      // are all not-null.  This is not true in generally, as code can
      // slam NULLs down in the subarrays.
      if (make_constant) {
        return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
<span class="line-new-header">--- 3550,13 ---</span>
      if (make_constant) {
        return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
      } else {
        return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
      }
<span class="line-modified">!   } else if (klass-&gt;is_flat_array_klass()) {</span>
<span class="line-modified">!     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-modified">!     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
      // We used to pass NotNull in here, asserting that the sub-arrays
      // are all not-null.  This is not true in generally, as code can
      // slam NULLs down in the subarrays.
      if (make_constant) {
        return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3781,12 ***</span>
    : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
      _name(k-&gt;name()), _flat_array(flat_array) {
     assert(k != NULL &amp;&amp;
            (k-&gt;is_loaded() || o == NULL),
            &quot;cannot have constants with non-loaded klass&quot;);
<span class="line-modified">!    assert(!klass()-&gt;is_valuetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">!    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);</span>
  };
  
  //------------------------------make-------------------------------------------
  const TypeInstPtr *TypeInstPtr::make(PTR ptr,
                                       ciKlass* k,
<span class="line-new-header">--- 3782,12 ---</span>
    : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
      _name(k-&gt;name()), _flat_array(flat_array) {
     assert(k != NULL &amp;&amp;
            (k-&gt;is_loaded() || o == NULL),
            &quot;cannot have constants with non-loaded klass&quot;);
<span class="line-modified">!    assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">!    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
  };
  
  //------------------------------make-------------------------------------------
  const TypeInstPtr *TypeInstPtr::make(PTR ptr,
                                       ciKlass* k,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4248,24 ***</span>
      // Now we find the LCA of Java classes
      ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
      return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
    } // End of case InstPtr
  
<span class="line-modified">!   case ValueType: {</span>
<span class="line-modified">!     const TypeValueType* tv = t-&gt;is_valuetype();</span>
      if (above_centerline(ptr())) {
<span class="line-modified">!       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {</span>
          return t;
        } else {
          return TypeInstPtr::NOTNULL;
        }
      } else {
        PTR ptr = this-&gt;_ptr;
        if (ptr == Constant) {
          ptr = NotNull;
        }
<span class="line-modified">!       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {</span>
          return TypeInstPtr::make(ptr, _klass);
        } else {
          return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
        }
      }
<span class="line-new-header">--- 4249,24 ---</span>
      // Now we find the LCA of Java classes
      ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
      return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
    } // End of case InstPtr
  
<span class="line-modified">!   case InlineType: {</span>
<span class="line-modified">!     const TypeInlineType* tv = t-&gt;is_inlinetype();</span>
      if (above_centerline(ptr())) {
<span class="line-modified">!       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {</span>
          return t;
        } else {
          return TypeInstPtr::NOTNULL;
        }
      } else {
        PTR ptr = this-&gt;_ptr;
        if (ptr == Constant) {
          ptr = NotNull;
        }
<span class="line-modified">!       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {</span>
          return TypeInstPtr::make(ptr, _klass);
        } else {
          return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
        }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4341,11 ***</span>
  
    _offset.dump2(st);
  
    st-&gt;print(&quot; *&quot;);
  
<span class="line-modified">!   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {</span>
      st-&gt;print(&quot; (flatten array)&quot;);
    }
  
    if (_instance_id == InstanceTop)
      st-&gt;print(&quot;,iid=top&quot;);
<span class="line-new-header">--- 4342,11 ---</span>
  
    _offset.dump2(st);
  
    st-&gt;print(&quot; *&quot;);
  
<span class="line-modified">!   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
      st-&gt;print(&quot; (flatten array)&quot;);
    }
  
    if (_instance_id == InstanceTop)
      st-&gt;print(&quot;,iid=top&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4399,11 ***</span>
  const TypeAryPtr *TypeAryPtr::CHARS;
  const TypeAryPtr *TypeAryPtr::INTS;
  const TypeAryPtr *TypeAryPtr::LONGS;
  const TypeAryPtr *TypeAryPtr::FLOATS;
  const TypeAryPtr *TypeAryPtr::DOUBLES;
<span class="line-modified">! const TypeAryPtr *TypeAryPtr::VALUES;</span>
  
  //------------------------------make-------------------------------------------
  const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
                                     int instance_id, const TypePtr* speculative, int inline_depth) {
    assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
<span class="line-new-header">--- 4400,11 ---</span>
  const TypeAryPtr *TypeAryPtr::CHARS;
  const TypeAryPtr *TypeAryPtr::INTS;
  const TypeAryPtr *TypeAryPtr::LONGS;
  const TypeAryPtr *TypeAryPtr::FLOATS;
  const TypeAryPtr *TypeAryPtr::DOUBLES;
<span class="line-modified">! const TypeAryPtr *TypeAryPtr::INLINES;</span>
  
  //------------------------------make-------------------------------------------
  const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
                                     int instance_id, const TypePtr* speculative, int inline_depth) {
    assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4702,16 ***</span>
             (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
        if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
          tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
        }
        return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
<span class="line-modified">!     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_value_array_klass() != tap-&gt;klass()-&gt;is_value_array_klass()) {</span>
<span class="line-modified">!       // Meeting flattened value type array with non-flattened array. Adjust (field) offset accordingly.</span>
<span class="line-modified">!       if (tary-&gt;_elem-&gt;isa_valuetype()) {</span>
          // Result is flattened
<span class="line-modified">!         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());</span>
<span class="line-modified">!         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();</span>
        } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
          // Result is non-flattened
          off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
          field_off = Offset::bottom;
        }
<span class="line-new-header">--- 4703,16 ---</span>
             (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
        if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
          tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
        }
        return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
<span class="line-modified">!     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {</span>
<span class="line-modified">!       // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.</span>
<span class="line-modified">!       if (tary-&gt;_elem-&gt;isa_inlinetype()) {</span>
          // Result is flattened
<span class="line-modified">!         off = Offset(elem()-&gt;isa_inlinetype() ? offset() : tap-&gt;offset());</span>
<span class="line-modified">!         field_off = elem()-&gt;isa_inlinetype() ? field_offset() : tap-&gt;field_offset();</span>
        } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
          // Result is non-flattened
          off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
          field_off = Offset::bottom;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4806,12 ***</span>
        return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
      default: typerr(t);
      }
    }
  
<span class="line-modified">!   case ValueType: {</span>
<span class="line-modified">!     const TypeValueType* tv = t-&gt;is_valuetype();</span>
      if (above_centerline(ptr())) {
        return TypeInstPtr::NOTNULL;
      } else {
        PTR ptr = this-&gt;_ptr;
        if (ptr == Constant) {
<span class="line-new-header">--- 4807,12 ---</span>
        return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
      default: typerr(t);
      }
    }
  
<span class="line-modified">!   case InlineType: {</span>
<span class="line-modified">!     const TypeInlineType* tv = t-&gt;is_inlinetype();</span>
      if (above_centerline(ptr())) {
        return TypeInstPtr::NOTNULL;
      } else {
        PTR ptr = this-&gt;_ptr;
        if (ptr == Constant) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4871,11 ***</span>
      break;
    default:
      break;
    }
  
<span class="line-modified">!   if (elem()-&gt;isa_valuetype()) {</span>
      st-&gt;print(&quot;(&quot;);
      _field_offset.dump2(st);
      st-&gt;print(&quot;)&quot;);
    }
    if (offset() != 0) {
<span class="line-new-header">--- 4872,11 ---</span>
      break;
    default:
      break;
    }
  
<span class="line-modified">!   if (elem()-&gt;isa_inlinetype()) {</span>
      st-&gt;print(&quot;(&quot;);
      _field_offset.dump2(st);
      st-&gt;print(&quot;)&quot;);
    }
    if (offset() != 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4944,11 ***</span>
  
  const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {
    int adj = 0;
    if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {
      const Type* elemtype = elem();
<span class="line-modified">!     if (elemtype-&gt;isa_valuetype()) {</span>
        if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {
          adj = _offset.get();
          offset += _offset.get();
        }
        uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
<span class="line-new-header">--- 4945,11 ---</span>
  
  const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {
    int adj = 0;
    if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {
      const Type* elemtype = elem();
<span class="line-modified">!     if (elemtype-&gt;isa_inlinetype()) {</span>
        if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {
          adj = _offset.get();
          offset += _offset.get();
        }
        uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4957,14 ***</span>
          if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {
            offset += header;
          }
        }
        if (offset &gt;= (intptr_t)header || offset &lt; 0) {
<span class="line-modified">!         // Try to get the field of the value type array element we are pointing to</span>
          ciKlass* arytype_klass = klass();
<span class="line-modified">!         ciValueArrayKlass* vak = arytype_klass-&gt;as_value_array_klass();</span>
<span class="line-modified">!         ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();</span>
          int shift = vak-&gt;log2_element_size();
          int mask = (1 &lt;&lt; shift) - 1;
          intptr_t field_offset = ((offset - header) &amp; mask);
          ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);
          if (field == NULL) {
<span class="line-new-header">--- 4958,14 ---</span>
          if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {
            offset += header;
          }
        }
        if (offset &gt;= (intptr_t)header || offset &lt; 0) {
<span class="line-modified">!         // Try to get the field of the inline type array element we are pointing to</span>
          ciKlass* arytype_klass = klass();
<span class="line-modified">!         ciFlatArrayKlass* vak = arytype_klass-&gt;as_flat_array_klass();</span>
<span class="line-modified">!         ciInlineKlass* vk = vak-&gt;element_klass()-&gt;as_inline_klass();</span>
          int shift = vak-&gt;log2_element_size();
          int mask = (1 &lt;&lt; shift) - 1;
          intptr_t field_offset = ((offset - header) &amp; mask);
          ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);
          if (field == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4977,11 ***</span>
      }
    }
    return add_offset(offset - adj);
  }
  
<span class="line-modified">! // Return offset incremented by field_offset for flattened value type arrays</span>
  const int TypeAryPtr::flattened_offset() const {
    int offset = _offset.get();
    if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;
        _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {
      offset += _field_offset.get();
<span class="line-new-header">--- 4978,11 ---</span>
      }
    }
    return add_offset(offset - adj);
  }
  
<span class="line-modified">! // Return offset incremented by field_offset for flattened inline type arrays</span>
  const int TypeAryPtr::flattened_offset() const {
    int offset = _offset.get();
    if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;
        _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {
      offset += _field_offset.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5088,11 ***</span>
    case Bottom:                  // Ye Olde Default
      return Type::BOTTOM;
    case Top:
      return this;
  
<span class="line-modified">!   case ValueType:</span>
      return t-&gt;xmeet(this);
  
    default:                      // All else is a mistake
      typerr(t);
  
<span class="line-new-header">--- 5089,11 ---</span>
    case Bottom:                  // Ye Olde Default
      return Type::BOTTOM;
    case Top:
      return this;
  
<span class="line-modified">!   case InlineType:</span>
      return t-&gt;xmeet(this);
  
    default:                      // All else is a mistake
      typerr(t);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5344,12 ***</span>
  const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
  
  //------------------------------TypeKlassPtr-----------------------------------
  TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
    : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
<span class="line-modified">!    assert(!klass-&gt;is_valuetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">!    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);</span>
  }
  
  //------------------------------make-------------------------------------------
  // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
  const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
<span class="line-new-header">--- 5345,12 ---</span>
  const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
  
  //------------------------------TypeKlassPtr-----------------------------------
  TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
    : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
<span class="line-modified">!    assert(!klass-&gt;is_inlinetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">!    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
  }
  
  //------------------------------make-------------------------------------------
  // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
  const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5419,14 ***</span>
  
    // Get element klass
    if (el-&gt;isa_instptr()) {
      // Compute object array klass from element klass
      k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());
<span class="line-modified">!   } else if (el-&gt;isa_valuetype()) {</span>
<span class="line-modified">!     // If element type is TypeValueType::BOTTOM, value_klass() will be null.</span>
<span class="line-modified">!     if (el-&gt;value_klass() != NULL) {</span>
<span class="line-modified">!       k_ary = ciArrayKlass::make(el-&gt;value_klass());</span>
      }
    } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
      // Compute array klass from element klass
      ciKlass* k_elem = tary-&gt;klass();
      // If element type is something like bottom[], k_elem will be null.
<span class="line-new-header">--- 5420,14 ---</span>
  
    // Get element klass
    if (el-&gt;isa_instptr()) {
      // Compute object array klass from element klass
      k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());
<span class="line-modified">!   } else if (el-&gt;isa_inlinetype()) {</span>
<span class="line-modified">!     // If element type is TypeInlineType::BOTTOM, inline_klass() will be null.</span>
<span class="line-modified">!     if (el-&gt;inline_klass() != NULL) {</span>
<span class="line-modified">!       k_ary = ciArrayKlass::make(el-&gt;inline_klass());</span>
      }
    } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
      // Compute array klass from element klass
      ciKlass* k_elem = tary-&gt;klass();
      // If element type is something like bottom[], k_elem will be null.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5529,11 ***</span>
    bool    xk = klass_is_exact();
    //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
    const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
    guarantee(toop != NULL, &quot;need type for given klass&quot;);
    toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">!   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {</span>
      toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();
    }
    return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
  }
  
<span class="line-new-header">--- 5530,11 ---</span>
    bool    xk = klass_is_exact();
    //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
    const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
    guarantee(toop != NULL, &quot;need type for given klass&quot;);
    toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">!   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
      toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();
    }
    return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5670,11 ***</span>
      // class hierarchy - which means we have to fall to at least NotNull.
      if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
        ptr = NotNull;
      // Now we find the LCA of Java classes
      ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">!     return   make(ptr, k, off, k-&gt;is_valuetype() &amp;&amp; k-&gt;flatten_array());</span>
    } // End of case KlassPtr
  
    } // End of switch
    return this;                  // Return the double constant
  }
<span class="line-new-header">--- 5671,11 ---</span>
      // class hierarchy - which means we have to fall to at least NotNull.
      if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
        ptr = NotNull;
      // Now we find the LCA of Java classes
      ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">!     return   make(ptr, k, off, k-&gt;is_inlinetype() &amp;&amp; k-&gt;flatten_array());</span>
    } // End of case KlassPtr
  
    } // End of switch
    return this;                  // Return the double constant
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5765,20 ***</span>
    const TypeFunc* tf = NULL;
    if (!is_osr_compilation) {
      tf = C-&gt;last_tf(method); // check cache
      if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
    }
<span class="line-modified">!   // Value types are not passed/returned by reference, instead each field of</span>
<span class="line-modified">!   // the value type is passed/returned as an argument. We maintain two views of</span>
<span class="line-modified">!   // the argument/return list here: one based on the signature (with a value</span>
    // type argument/return as a single slot), one based on the actual calling
<span class="line-modified">!   // convention (with a value type argument/return as a list of its fields).</span>
    bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;
    const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);
    const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;
    ciSignature* sig = method-&gt;signature();
<span class="line-modified">!   bool has_scalar_ret = sig-&gt;return_type()-&gt;is_valuetype() &amp;&amp; sig-&gt;return_type()-&gt;as_value_klass()-&gt;can_be_returned_as_fields();</span>
    const TypeTuple* range_sig = TypeTuple::make_range(sig, false);
    const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;
    tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);
    if (!is_osr_compilation) {
      C-&gt;set_last_tf(method, tf);  // fill cache
<span class="line-new-header">--- 5766,20 ---</span>
    const TypeFunc* tf = NULL;
    if (!is_osr_compilation) {
      tf = C-&gt;last_tf(method); // check cache
      if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
    }
<span class="line-modified">!   // Inline types are not passed/returned by reference, instead each field of</span>
<span class="line-modified">!   // the inline type is passed/returned as an argument. We maintain two views of</span>
<span class="line-modified">!   // the argument/return list here: one based on the signature (with an inline</span>
    // type argument/return as a single slot), one based on the actual calling
<span class="line-modified">!   // convention (with an inline type argument/return as a list of its fields).</span>
    bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;
    const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);
    const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;
    ciSignature* sig = method-&gt;signature();
<span class="line-modified">!   bool has_scalar_ret = sig-&gt;return_type()-&gt;is_inlinetype() &amp;&amp; sig-&gt;return_type()-&gt;as_inline_klass()-&gt;can_be_returned_as_fields();</span>
    const TypeTuple* range_sig = TypeTuple::make_range(sig, false);
    const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;
    tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);
    if (!is_osr_compilation) {
      C-&gt;set_last_tf(method, tf);  // fill cache
</pre>
<center><a href="subtypenode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
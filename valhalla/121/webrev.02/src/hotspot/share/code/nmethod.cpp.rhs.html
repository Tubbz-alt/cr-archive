<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/nmethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.inline.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/compiledIC.hpp&quot;
  30 #include &quot;code/compiledMethod.inline.hpp&quot;
  31 #include &quot;code/dependencies.hpp&quot;
  32 #include &quot;code/nativeInst.hpp&quot;
  33 #include &quot;code/nmethod.hpp&quot;
  34 #include &quot;code/scopeDesc.hpp&quot;
  35 #include &quot;compiler/abstractCompiler.hpp&quot;
  36 #include &quot;compiler/compileBroker.hpp&quot;
  37 #include &quot;compiler/compileLog.hpp&quot;
  38 #include &quot;compiler/compilerDirectives.hpp&quot;
  39 #include &quot;compiler/directivesParser.hpp&quot;
  40 #include &quot;compiler/disassembler.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.inline.hpp&quot;
  45 #include &quot;memory/resourceArea.hpp&quot;
  46 #include &quot;memory/universe.hpp&quot;
  47 #include &quot;oops/access.inline.hpp&quot;
  48 #include &quot;oops/method.inline.hpp&quot;
  49 #include &quot;oops/methodData.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;prims/jvmtiImpl.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.hpp&quot;
  53 #include &quot;runtime/atomic.hpp&quot;
  54 #include &quot;runtime/deoptimization.hpp&quot;
  55 #include &quot;runtime/flags/flagSetting.hpp&quot;
  56 #include &quot;runtime/frame.inline.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/orderAccess.hpp&quot;
  60 #include &quot;runtime/os.hpp&quot;
  61 #include &quot;runtime/safepointVerifiers.hpp&quot;
  62 #include &quot;runtime/serviceThread.hpp&quot;
  63 #include &quot;runtime/sharedRuntime.hpp&quot;
  64 #include &quot;runtime/sweeper.hpp&quot;
  65 #include &quot;runtime/vmThread.hpp&quot;
  66 #include &quot;utilities/align.hpp&quot;
  67 #include &quot;utilities/dtrace.hpp&quot;
  68 #include &quot;utilities/events.hpp&quot;
  69 #include &quot;utilities/resourceHash.hpp&quot;
  70 #include &quot;utilities/xmlstream.hpp&quot;
  71 #if INCLUDE_JVMCI
  72 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  73 #endif
  74 
  75 #ifdef DTRACE_ENABLED
  76 
  77 // Only bother with this argument setup if dtrace is available
  78 
  79 #define DTRACE_METHOD_UNLOAD_PROBE(method)                                \
  80   {                                                                       \
  81     Method* m = (method);                                                 \
  82     if (m != NULL) {                                                      \
  83       Symbol* klass_name = m-&gt;klass_name();                               \
  84       Symbol* name = m-&gt;name();                                           \
  85       Symbol* signature = m-&gt;signature();                                 \
  86       HOTSPOT_COMPILED_METHOD_UNLOAD(                                     \
  87         (char *) klass_name-&gt;bytes(), klass_name-&gt;utf8_length(),                   \
  88         (char *) name-&gt;bytes(), name-&gt;utf8_length(),                               \
  89         (char *) signature-&gt;bytes(), signature-&gt;utf8_length());                    \
  90     }                                                                     \
  91   }
  92 
  93 #else //  ndef DTRACE_ENABLED
  94 
  95 #define DTRACE_METHOD_UNLOAD_PROBE(method)
  96 
  97 #endif
  98 
  99 //---------------------------------------------------------------------------------
 100 // NMethod statistics
 101 // They are printed under various flags, including:
 102 //   PrintC1Statistics, PrintOptoStatistics, LogVMOutput, and LogCompilation.
 103 // (In the latter two cases, they like other stats are printed to the log only.)
 104 
 105 #ifndef PRODUCT
 106 // These variables are put into one block to reduce relocations
 107 // and make it simpler to print from the debugger.
 108 struct java_nmethod_stats_struct {
 109   int nmethod_count;
 110   int total_size;
 111   int relocation_size;
 112   int consts_size;
 113   int insts_size;
 114   int stub_size;
 115   int scopes_data_size;
 116   int scopes_pcs_size;
 117   int dependencies_size;
 118   int handler_table_size;
 119   int nul_chk_table_size;
 120 #if INCLUDE_JVMCI
 121   int speculations_size;
 122   int jvmci_data_size;
 123 #endif
 124   int oops_size;
 125   int metadata_size;
 126 
 127   void note_nmethod(nmethod* nm) {
 128     nmethod_count += 1;
 129     total_size          += nm-&gt;size();
 130     relocation_size     += nm-&gt;relocation_size();
 131     consts_size         += nm-&gt;consts_size();
 132     insts_size          += nm-&gt;insts_size();
 133     stub_size           += nm-&gt;stub_size();
 134     oops_size           += nm-&gt;oops_size();
 135     metadata_size       += nm-&gt;metadata_size();
 136     scopes_data_size    += nm-&gt;scopes_data_size();
 137     scopes_pcs_size     += nm-&gt;scopes_pcs_size();
 138     dependencies_size   += nm-&gt;dependencies_size();
 139     handler_table_size  += nm-&gt;handler_table_size();
 140     nul_chk_table_size  += nm-&gt;nul_chk_table_size();
 141 #if INCLUDE_JVMCI
 142     speculations_size   += nm-&gt;speculations_size();
 143     jvmci_data_size     += nm-&gt;jvmci_data_size();
 144 #endif
 145   }
 146   void print_nmethod_stats(const char* name) {
 147     if (nmethod_count == 0)  return;
 148     tty-&gt;print_cr(&quot;Statistics for %d bytecoded nmethods for %s:&quot;, nmethod_count, name);
 149     if (total_size != 0)          tty-&gt;print_cr(&quot; total in heap  = %d&quot;, total_size);
 150     if (nmethod_count != 0)       tty-&gt;print_cr(&quot; header         = &quot; SIZE_FORMAT, nmethod_count * sizeof(nmethod));
 151     if (relocation_size != 0)     tty-&gt;print_cr(&quot; relocation     = %d&quot;, relocation_size);
 152     if (consts_size != 0)         tty-&gt;print_cr(&quot; constants      = %d&quot;, consts_size);
 153     if (insts_size != 0)          tty-&gt;print_cr(&quot; main code      = %d&quot;, insts_size);
 154     if (stub_size != 0)           tty-&gt;print_cr(&quot; stub code      = %d&quot;, stub_size);
 155     if (oops_size != 0)           tty-&gt;print_cr(&quot; oops           = %d&quot;, oops_size);
 156     if (metadata_size != 0)       tty-&gt;print_cr(&quot; metadata       = %d&quot;, metadata_size);
 157     if (scopes_data_size != 0)    tty-&gt;print_cr(&quot; scopes data    = %d&quot;, scopes_data_size);
 158     if (scopes_pcs_size != 0)     tty-&gt;print_cr(&quot; scopes pcs     = %d&quot;, scopes_pcs_size);
 159     if (dependencies_size != 0)   tty-&gt;print_cr(&quot; dependencies   = %d&quot;, dependencies_size);
 160     if (handler_table_size != 0)  tty-&gt;print_cr(&quot; handler table  = %d&quot;, handler_table_size);
 161     if (nul_chk_table_size != 0)  tty-&gt;print_cr(&quot; nul chk table  = %d&quot;, nul_chk_table_size);
 162 #if INCLUDE_JVMCI
 163     if (speculations_size != 0)   tty-&gt;print_cr(&quot; speculations   = %d&quot;, speculations_size);
 164     if (jvmci_data_size != 0)     tty-&gt;print_cr(&quot; JVMCI data     = %d&quot;, jvmci_data_size);
 165 #endif
 166   }
 167 };
 168 
 169 struct native_nmethod_stats_struct {
 170   int native_nmethod_count;
 171   int native_total_size;
 172   int native_relocation_size;
 173   int native_insts_size;
 174   int native_oops_size;
 175   int native_metadata_size;
 176   void note_native_nmethod(nmethod* nm) {
 177     native_nmethod_count += 1;
 178     native_total_size       += nm-&gt;size();
 179     native_relocation_size  += nm-&gt;relocation_size();
 180     native_insts_size       += nm-&gt;insts_size();
 181     native_oops_size        += nm-&gt;oops_size();
 182     native_metadata_size    += nm-&gt;metadata_size();
 183   }
 184   void print_native_nmethod_stats() {
 185     if (native_nmethod_count == 0)  return;
 186     tty-&gt;print_cr(&quot;Statistics for %d native nmethods:&quot;, native_nmethod_count);
 187     if (native_total_size != 0)       tty-&gt;print_cr(&quot; N. total size  = %d&quot;, native_total_size);
 188     if (native_relocation_size != 0)  tty-&gt;print_cr(&quot; N. relocation  = %d&quot;, native_relocation_size);
 189     if (native_insts_size != 0)       tty-&gt;print_cr(&quot; N. main code   = %d&quot;, native_insts_size);
 190     if (native_oops_size != 0)        tty-&gt;print_cr(&quot; N. oops        = %d&quot;, native_oops_size);
 191     if (native_metadata_size != 0)    tty-&gt;print_cr(&quot; N. metadata    = %d&quot;, native_metadata_size);
 192   }
 193 };
 194 
 195 struct pc_nmethod_stats_struct {
 196   int pc_desc_resets;   // number of resets (= number of caches)
 197   int pc_desc_queries;  // queries to nmethod::find_pc_desc
 198   int pc_desc_approx;   // number of those which have approximate true
 199   int pc_desc_repeats;  // number of _pc_descs[0] hits
 200   int pc_desc_hits;     // number of LRU cache hits
 201   int pc_desc_tests;    // total number of PcDesc examinations
 202   int pc_desc_searches; // total number of quasi-binary search steps
 203   int pc_desc_adds;     // number of LUR cache insertions
 204 
 205   void print_pc_stats() {
 206     tty-&gt;print_cr(&quot;PcDesc Statistics:  %d queries, %.2f comparisons per query&quot;,
 207                   pc_desc_queries,
 208                   (double)(pc_desc_tests + pc_desc_searches)
 209                   / pc_desc_queries);
 210     tty-&gt;print_cr(&quot;  caches=%d queries=%d/%d, hits=%d+%d, tests=%d+%d, adds=%d&quot;,
 211                   pc_desc_resets,
 212                   pc_desc_queries, pc_desc_approx,
 213                   pc_desc_repeats, pc_desc_hits,
 214                   pc_desc_tests, pc_desc_searches, pc_desc_adds);
 215   }
 216 };
 217 
 218 #ifdef COMPILER1
 219 static java_nmethod_stats_struct c1_java_nmethod_stats;
 220 #endif
 221 #ifdef COMPILER2
 222 static java_nmethod_stats_struct c2_java_nmethod_stats;
 223 #endif
 224 #if INCLUDE_JVMCI
 225 static java_nmethod_stats_struct jvmci_java_nmethod_stats;
 226 #endif
 227 static java_nmethod_stats_struct unknown_java_nmethod_stats;
 228 
 229 static native_nmethod_stats_struct native_nmethod_stats;
 230 static pc_nmethod_stats_struct pc_nmethod_stats;
 231 
 232 static void note_java_nmethod(nmethod* nm) {
 233 #ifdef COMPILER1
 234   if (nm-&gt;is_compiled_by_c1()) {
 235     c1_java_nmethod_stats.note_nmethod(nm);
 236   } else
 237 #endif
 238 #ifdef COMPILER2
 239   if (nm-&gt;is_compiled_by_c2()) {
 240     c2_java_nmethod_stats.note_nmethod(nm);
 241   } else
 242 #endif
 243 #if INCLUDE_JVMCI
 244   if (nm-&gt;is_compiled_by_jvmci()) {
 245     jvmci_java_nmethod_stats.note_nmethod(nm);
 246   } else
 247 #endif
 248   {
 249     unknown_java_nmethod_stats.note_nmethod(nm);
 250   }
 251 }
 252 #endif // !PRODUCT
 253 
 254 //---------------------------------------------------------------------------------
 255 
 256 
 257 ExceptionCache::ExceptionCache(Handle exception, address pc, address handler) {
 258   assert(pc != NULL, &quot;Must be non null&quot;);
 259   assert(exception.not_null(), &quot;Must be non null&quot;);
 260   assert(handler != NULL, &quot;Must be non null&quot;);
 261 
 262   _count = 0;
 263   _exception_type = exception-&gt;klass();
 264   _next = NULL;
 265   _purge_list_next = NULL;
 266 
 267   add_address_and_handler(pc,handler);
 268 }
 269 
 270 
 271 address ExceptionCache::match(Handle exception, address pc) {
 272   assert(pc != NULL,&quot;Must be non null&quot;);
 273   assert(exception.not_null(),&quot;Must be non null&quot;);
 274   if (exception-&gt;klass() == exception_type()) {
 275     return (test_address(pc));
 276   }
 277 
 278   return NULL;
 279 }
 280 
 281 
 282 bool ExceptionCache::match_exception_with_space(Handle exception) {
 283   assert(exception.not_null(),&quot;Must be non null&quot;);
 284   if (exception-&gt;klass() == exception_type() &amp;&amp; count() &lt; cache_size) {
 285     return true;
 286   }
 287   return false;
 288 }
 289 
 290 
 291 address ExceptionCache::test_address(address addr) {
 292   int limit = count();
 293   for (int i = 0; i &lt; limit; i++) {
 294     if (pc_at(i) == addr) {
 295       return handler_at(i);
 296     }
 297   }
 298   return NULL;
 299 }
 300 
 301 
 302 bool ExceptionCache::add_address_and_handler(address addr, address handler) {
 303   if (test_address(addr) == handler) return true;
 304 
 305   int index = count();
 306   if (index &lt; cache_size) {
 307     set_pc_at(index, addr);
 308     set_handler_at(index, handler);
 309     increment_count();
 310     return true;
 311   }
 312   return false;
 313 }
 314 
 315 ExceptionCache* ExceptionCache::next() {
 316   return Atomic::load(&amp;_next);
 317 }
 318 
 319 void ExceptionCache::set_next(ExceptionCache *ec) {
 320   Atomic::store(&amp;_next, ec);
 321 }
 322 
 323 //-----------------------------------------------------------------------------
 324 
 325 
 326 // Helper used by both find_pc_desc methods.
 327 static inline bool match_desc(PcDesc* pc, int pc_offset, bool approximate) {
 328   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_tests);
 329   if (!approximate)
 330     return pc-&gt;pc_offset() == pc_offset;
 331   else
 332     return (pc-1)-&gt;pc_offset() &lt; pc_offset &amp;&amp; pc_offset &lt;= pc-&gt;pc_offset();
 333 }
 334 
 335 void PcDescCache::reset_to(PcDesc* initial_pc_desc) {
 336   if (initial_pc_desc == NULL) {
 337     _pc_descs[0] = NULL; // native method; no PcDescs at all
 338     return;
 339   }
 340   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_resets);
 341   // reset the cache by filling it with benign (non-null) values
 342   assert(initial_pc_desc-&gt;pc_offset() &lt; 0, &quot;must be sentinel&quot;);
 343   for (int i = 0; i &lt; cache_size; i++)
 344     _pc_descs[i] = initial_pc_desc;
 345 }
 346 
 347 PcDesc* PcDescCache::find_pc_desc(int pc_offset, bool approximate) {
 348   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_queries);
 349   NOT_PRODUCT(if (approximate) ++pc_nmethod_stats.pc_desc_approx);
 350 
 351   // Note: one might think that caching the most recently
 352   // read value separately would be a win, but one would be
 353   // wrong.  When many threads are updating it, the cache
 354   // line it&#39;s in would bounce between caches, negating
 355   // any benefit.
 356 
 357   // In order to prevent race conditions do not load cache elements
 358   // repeatedly, but use a local copy:
 359   PcDesc* res;
 360 
 361   // Step one:  Check the most recently added value.
 362   res = _pc_descs[0];
 363   if (res == NULL) return NULL;  // native method; no PcDescs at all
 364   if (match_desc(res, pc_offset, approximate)) {
 365     NOT_PRODUCT(++pc_nmethod_stats.pc_desc_repeats);
 366     return res;
 367   }
 368 
 369   // Step two:  Check the rest of the LRU cache.
 370   for (int i = 1; i &lt; cache_size; ++i) {
 371     res = _pc_descs[i];
 372     if (res-&gt;pc_offset() &lt; 0) break;  // optimization: skip empty cache
 373     if (match_desc(res, pc_offset, approximate)) {
 374       NOT_PRODUCT(++pc_nmethod_stats.pc_desc_hits);
 375       return res;
 376     }
 377   }
 378 
 379   // Report failure.
 380   return NULL;
 381 }
 382 
 383 void PcDescCache::add_pc_desc(PcDesc* pc_desc) {
 384   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_adds);
 385   // Update the LRU cache by shifting pc_desc forward.
 386   for (int i = 0; i &lt; cache_size; i++)  {
 387     PcDesc* next = _pc_descs[i];
 388     _pc_descs[i] = pc_desc;
 389     pc_desc = next;
 390   }
 391 }
 392 
 393 // adjust pcs_size so that it is a multiple of both oopSize and
 394 // sizeof(PcDesc) (assumes that if sizeof(PcDesc) is not a multiple
 395 // of oopSize, then 2*sizeof(PcDesc) is)
 396 static int adjust_pcs_size(int pcs_size) {
 397   int nsize = align_up(pcs_size,   oopSize);
 398   if ((nsize % sizeof(PcDesc)) != 0) {
 399     nsize = pcs_size + sizeof(PcDesc);
 400   }
 401   assert((nsize % oopSize) == 0, &quot;correct alignment&quot;);
 402   return nsize;
 403 }
 404 
 405 
 406 int nmethod::total_size() const {
 407   return
 408     consts_size()        +
 409     insts_size()         +
 410     stub_size()          +
 411     scopes_data_size()   +
 412     scopes_pcs_size()    +
 413     handler_table_size() +
 414     nul_chk_table_size();
 415 }
 416 
 417 address* nmethod::orig_pc_addr(const frame* fr) {
 418   return (address*) ((address)fr-&gt;unextended_sp() + _orig_pc_offset);
 419 }
 420 
 421 const char* nmethod::compile_kind() const {
 422   if (is_osr_method())     return &quot;osr&quot;;
 423   if (method() != NULL &amp;&amp; is_native_method())  return &quot;c2n&quot;;
 424   return NULL;
 425 }
 426 
 427 // Fill in default values for various flag fields
 428 void nmethod::init_defaults() {
 429   _state                      = not_installed;
 430   _has_flushed_dependencies   = 0;
 431   _lock_count                 = 0;
 432   _stack_traversal_mark       = 0;
 433   _load_reported              = false; // jvmti state
 434   _unload_reported            = false;
 435   _is_far_code                = false; // nmethods are located in CodeCache
 436 
 437 #ifdef ASSERT
 438   _oops_are_stale             = false;
 439 #endif
 440 
 441   _oops_do_mark_link       = NULL;
 442   _osr_link                = NULL;
 443 #if INCLUDE_RTM_OPT
 444   _rtm_state               = NoRTM;
 445 #endif
 446 }
 447 
 448 nmethod* nmethod::new_native_nmethod(const methodHandle&amp; method,
 449   int compile_id,
 450   CodeBuffer *code_buffer,
 451   int vep_offset,
 452   int frame_complete,
 453   int frame_size,
 454   ByteSize basic_lock_owner_sp_offset,
 455   ByteSize basic_lock_sp_offset,
 456   OopMapSet* oop_maps) {
 457   code_buffer-&gt;finalize_oop_references(method);
 458   // create nmethod
 459   nmethod* nm = NULL;
 460   {
 461     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 462     int native_nmethod_size = CodeBlob::allocation_size(code_buffer, sizeof(nmethod));
 463 
 464     CodeOffsets offsets;
 465     offsets.set_value(CodeOffsets::Verified_Entry, vep_offset);
 466     offsets.set_value(CodeOffsets::Frame_Complete, frame_complete);
 467     nm = new (native_nmethod_size, CompLevel_none)
 468     nmethod(method(), compiler_none, native_nmethod_size,
 469             compile_id, &amp;offsets,
 470             code_buffer, frame_size,
 471             basic_lock_owner_sp_offset,
 472             basic_lock_sp_offset,
 473             oop_maps);
 474     NOT_PRODUCT(if (nm != NULL)  native_nmethod_stats.note_native_nmethod(nm));
 475   }
 476 
 477   if (nm != NULL) {
 478     // verify nmethod
 479     debug_only(nm-&gt;verify();) // might block
 480 
 481     nm-&gt;log_new_nmethod();
 482   }
 483   return nm;
 484 }
 485 
 486 nmethod* nmethod::new_nmethod(const methodHandle&amp; method,
 487   int compile_id,
 488   int entry_bci,
 489   CodeOffsets* offsets,
 490   int orig_pc_offset,
 491   DebugInformationRecorder* debug_info,
 492   Dependencies* dependencies,
 493   CodeBuffer* code_buffer, int frame_size,
 494   OopMapSet* oop_maps,
 495   ExceptionHandlerTable* handler_table,
 496   ImplicitExceptionTable* nul_chk_table,
 497   AbstractCompiler* compiler,
 498   int comp_level
 499 #if INCLUDE_JVMCI
 500   , char* speculations,
 501   int speculations_len,
 502   int nmethod_mirror_index,
 503   const char* nmethod_mirror_name,
 504   FailedSpeculation** failed_speculations
 505 #endif
 506 )
 507 {
 508   assert(debug_info-&gt;oop_recorder() == code_buffer-&gt;oop_recorder(), &quot;shared OR&quot;);
 509   code_buffer-&gt;finalize_oop_references(method);
 510   // create nmethod
 511   nmethod* nm = NULL;
 512   { MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 513 #if INCLUDE_JVMCI
 514     int jvmci_data_size = !compiler-&gt;is_jvmci() ? 0 : JVMCINMethodData::compute_size(nmethod_mirror_name);
 515 #endif
 516     int nmethod_size =
 517       CodeBlob::allocation_size(code_buffer, sizeof(nmethod))
 518       + adjust_pcs_size(debug_info-&gt;pcs_size())
 519       + align_up((int)dependencies-&gt;size_in_bytes(), oopSize)
 520       + align_up(handler_table-&gt;size_in_bytes()    , oopSize)
 521       + align_up(nul_chk_table-&gt;size_in_bytes()    , oopSize)
 522 #if INCLUDE_JVMCI
 523       + align_up(speculations_len                  , oopSize)
 524       + align_up(jvmci_data_size                   , oopSize)
 525 #endif
 526       + align_up(debug_info-&gt;data_size()           , oopSize);
 527 
 528     nm = new (nmethod_size, comp_level)
 529     nmethod(method(), compiler-&gt;type(), nmethod_size, compile_id, entry_bci, offsets,
 530             orig_pc_offset, debug_info, dependencies, code_buffer, frame_size,
 531             oop_maps,
 532             handler_table,
 533             nul_chk_table,
 534             compiler,
 535             comp_level
 536 #if INCLUDE_JVMCI
 537             , speculations,
 538             speculations_len,
 539             jvmci_data_size
 540 #endif
 541             );
 542 
 543     if (nm != NULL) {
 544 #if INCLUDE_JVMCI
 545       if (compiler-&gt;is_jvmci()) {
 546         // Initialize the JVMCINMethodData object inlined into nm
 547         nm-&gt;jvmci_nmethod_data()-&gt;initialize(nmethod_mirror_index, nmethod_mirror_name, failed_speculations);
 548       }
 549 #endif
 550       // To make dependency checking during class loading fast, record
 551       // the nmethod dependencies in the classes it is dependent on.
 552       // This allows the dependency checking code to simply walk the
 553       // class hierarchy above the loaded class, checking only nmethods
 554       // which are dependent on those classes.  The slow way is to
 555       // check every nmethod for dependencies which makes it linear in
 556       // the number of methods compiled.  For applications with a lot
 557       // classes the slow way is too slow.
 558       for (Dependencies::DepStream deps(nm); deps.next(); ) {
 559         if (deps.type() == Dependencies::call_site_target_value) {
 560           // CallSite dependencies are managed on per-CallSite instance basis.
 561           oop call_site = deps.argument_oop(0);
 562           MethodHandles::add_dependent_nmethod(call_site, nm);
 563         } else {
 564           Klass* klass = deps.context_type();
 565           if (klass == NULL) {
 566             continue;  // ignore things like evol_method
 567           }
 568           // record this nmethod as dependent on this klass
 569           InstanceKlass::cast(klass)-&gt;add_dependent_nmethod(nm);
 570         }
 571       }
 572       NOT_PRODUCT(if (nm != NULL)  note_java_nmethod(nm));
 573     }
 574   }
 575   // Do verification and logging outside CodeCache_lock.
 576   if (nm != NULL) {
 577     // Safepoints in nmethod::verify aren&#39;t allowed because nm hasn&#39;t been installed yet.
 578     DEBUG_ONLY(nm-&gt;verify();)
 579     nm-&gt;log_new_nmethod();
 580   }
 581   return nm;
 582 }
 583 
 584 // For native wrappers
 585 nmethod::nmethod(
 586   Method* method,
 587   CompilerType type,
 588   int nmethod_size,
 589   int compile_id,
 590   CodeOffsets* offsets,
 591   CodeBuffer* code_buffer,
 592   int frame_size,
 593   ByteSize basic_lock_owner_sp_offset,
 594   ByteSize basic_lock_sp_offset,
 595   OopMapSet* oop_maps )
 596   : CompiledMethod(method, &quot;native nmethod&quot;, type, nmethod_size, sizeof(nmethod), code_buffer, offsets-&gt;value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
 597   _is_unloading_state(0),
 598   _native_receiver_sp_offset(basic_lock_owner_sp_offset),
 599   _native_basic_lock_sp_offset(basic_lock_sp_offset)
 600 {
 601   {
 602     int scopes_data_offset   = 0;
 603     int deoptimize_offset    = 0;
 604     int deoptimize_mh_offset = 0;
 605 
 606     debug_only(NoSafepointVerifier nsv;)
 607     assert_locked_or_safepoint(CodeCache_lock);
 608 
 609     init_defaults();
 610     _entry_bci               = InvocationEntryBci;
 611     // We have no exception handler or deopt handler make the
 612     // values something that will never match a pc like the nmethod vtable entry
 613     _exception_offset        = 0;
 614     _orig_pc_offset          = 0;
 615 
 616     _consts_offset           = data_offset();
 617     _stub_offset             = data_offset();
 618     _oops_offset             = data_offset();
 619     _metadata_offset         = _oops_offset         + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 620     scopes_data_offset       = _metadata_offset     + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 621     _scopes_pcs_offset       = scopes_data_offset;
 622     _dependencies_offset     = _scopes_pcs_offset;
 623     _handler_table_offset    = _dependencies_offset;
 624     _nul_chk_table_offset    = _handler_table_offset;
 625 #if INCLUDE_JVMCI
 626     _speculations_offset     = _nul_chk_table_offset;
 627     _jvmci_data_offset       = _speculations_offset;
 628     _nmethod_end_offset      = _jvmci_data_offset;
 629 #else
 630     _nmethod_end_offset      = _nul_chk_table_offset;
 631 #endif
 632     _compile_id              = compile_id;
 633     _comp_level              = CompLevel_none;
 634     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 635     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
 636 
 637     assert(!method-&gt;has_scalarized_args(), &quot;scalarized native wrappers not supported yet&quot;); // for the next 3 fields
<a name="1" id="anc1"></a><span class="line-modified"> 638     _inline_entry_point       = _entry_point;</span>
<span class="line-modified"> 639     _verified_inline_entry_point = _verified_entry_point;</span>
<span class="line-modified"> 640     _verified_inline_ro_entry_point = _verified_entry_point;</span>
 641 
 642     _osr_entry_point         = NULL;
 643     _exception_cache         = NULL;
 644     _pc_desc_container.reset_to(NULL);
 645     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 646 
 647     _scopes_data_begin = (address) this + scopes_data_offset;
 648     _deopt_handler_begin = (address) this + deoptimize_offset;
 649     _deopt_mh_handler_begin = (address) this + deoptimize_mh_offset;
 650 
 651     code_buffer-&gt;copy_code_and_locs_to(this);
 652     code_buffer-&gt;copy_values_to(this);
 653 
 654     clear_unloading_state();
 655 
 656     Universe::heap()-&gt;register_nmethod(this);
 657     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 658 
 659     CodeCache::commit(this);
 660   }
 661 
 662   if (PrintNativeNMethods || PrintDebugInfo || PrintRelocations || PrintDependencies) {
 663     ttyLocker ttyl;  // keep the following output all in one block
 664     // This output goes directly to the tty, not the compiler log.
 665     // To enable tools to match it up with the compilation activity,
 666     // be sure to tag this tty output with the compile ID.
 667     if (xtty != NULL) {
 668       xtty-&gt;begin_head(&quot;print_native_nmethod&quot;);
 669       xtty-&gt;method(_method);
 670       xtty-&gt;stamp();
 671       xtty-&gt;end_head(&quot; address=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;, (intptr_t) this);
 672     }
 673     // Print the header part, then print the requested information.
 674     // This is both handled in decode2(), called via print_code() -&gt; decode()
 675     if (PrintNativeNMethods) {
 676       tty-&gt;print_cr(&quot;-------------------------- Assembly (native nmethod) ---------------------------&quot;);
 677       print_code();
 678       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 679 #if defined(SUPPORT_DATA_STRUCTS)
 680       if (AbstractDisassembler::show_structs()) {
 681         if (oop_maps != NULL) {
 682           tty-&gt;print(&quot;oop maps:&quot;); // oop_maps-&gt;print_on(tty) outputs a cr() at the beginning
 683           oop_maps-&gt;print_on(tty);
 684           tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 685         }
 686       }
 687 #endif
 688     } else {
 689       print(); // print the header part only.
 690     }
 691 #if defined(SUPPORT_DATA_STRUCTS)
 692     if (AbstractDisassembler::show_structs()) {
 693       if (PrintRelocations) {
 694         print_relocations();
 695         tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 696       }
 697     }
 698 #endif
 699     if (xtty != NULL) {
 700       xtty-&gt;tail(&quot;print_native_nmethod&quot;);
 701     }
 702   }
 703 }
 704 
 705 void* nmethod::operator new(size_t size, int nmethod_size, int comp_level) throw () {
 706   return CodeCache::allocate(nmethod_size, CodeCache::get_code_blob_type(comp_level));
 707 }
 708 
 709 nmethod::nmethod(
 710   Method* method,
 711   CompilerType type,
 712   int nmethod_size,
 713   int compile_id,
 714   int entry_bci,
 715   CodeOffsets* offsets,
 716   int orig_pc_offset,
 717   DebugInformationRecorder* debug_info,
 718   Dependencies* dependencies,
 719   CodeBuffer *code_buffer,
 720   int frame_size,
 721   OopMapSet* oop_maps,
 722   ExceptionHandlerTable* handler_table,
 723   ImplicitExceptionTable* nul_chk_table,
 724   AbstractCompiler* compiler,
 725   int comp_level
 726 #if INCLUDE_JVMCI
 727   , char* speculations,
 728   int speculations_len,
 729   int jvmci_data_size
 730 #endif
 731   )
 732   : CompiledMethod(method, &quot;nmethod&quot;, type, nmethod_size, sizeof(nmethod), code_buffer, offsets-&gt;value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
 733   _is_unloading_state(0),
 734   _native_receiver_sp_offset(in_ByteSize(-1)),
 735   _native_basic_lock_sp_offset(in_ByteSize(-1))
 736 {
 737   assert(debug_info-&gt;oop_recorder() == code_buffer-&gt;oop_recorder(), &quot;shared OR&quot;);
 738   {
 739     debug_only(NoSafepointVerifier nsv;)
 740     assert_locked_or_safepoint(CodeCache_lock);
 741 
 742     _deopt_handler_begin = (address) this;
 743     _deopt_mh_handler_begin = (address) this;
 744 
 745     init_defaults();
 746     _entry_bci               = entry_bci;
 747     _compile_id              = compile_id;
 748     _comp_level              = comp_level;
 749     _orig_pc_offset          = orig_pc_offset;
 750     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 751 
 752     // Section offsets
 753     _consts_offset           = content_offset()      + code_buffer-&gt;total_offset_of(code_buffer-&gt;consts());
 754     _stub_offset             = content_offset()      + code_buffer-&gt;total_offset_of(code_buffer-&gt;stubs());
 755     set_ctable_begin(header_begin() + _consts_offset);
 756 
 757 #if INCLUDE_JVMCI
 758     if (compiler-&gt;is_jvmci()) {
 759       // JVMCI might not produce any stub sections
 760       if (offsets-&gt;value(CodeOffsets::Exceptions) != -1) {
 761         _exception_offset        = code_offset()          + offsets-&gt;value(CodeOffsets::Exceptions);
 762       } else {
 763         _exception_offset = -1;
 764       }
 765       if (offsets-&gt;value(CodeOffsets::Deopt) != -1) {
 766         _deopt_handler_begin       = (address) this + code_offset()          + offsets-&gt;value(CodeOffsets::Deopt);
 767       } else {
 768         _deopt_handler_begin = NULL;
 769       }
 770       if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {
 771         _deopt_mh_handler_begin  = (address) this + code_offset()          + offsets-&gt;value(CodeOffsets::DeoptMH);
 772       } else {
 773         _deopt_mh_handler_begin = NULL;
 774       }
 775     } else
 776 #endif
 777     {
 778       // Exception handler and deopt handler are in the stub section
 779       assert(offsets-&gt;value(CodeOffsets::Exceptions) != -1, &quot;must be set&quot;);
 780       assert(offsets-&gt;value(CodeOffsets::Deopt     ) != -1, &quot;must be set&quot;);
 781 
 782       _exception_offset       = _stub_offset          + offsets-&gt;value(CodeOffsets::Exceptions);
 783       _deopt_handler_begin    = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::Deopt);
 784       if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {
 785         _deopt_mh_handler_begin  = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::DeoptMH);
 786       } else {
 787         _deopt_mh_handler_begin  = NULL;
 788       }
 789     }
 790     if (offsets-&gt;value(CodeOffsets::UnwindHandler) != -1) {
 791       _unwind_handler_offset = code_offset()         + offsets-&gt;value(CodeOffsets::UnwindHandler);
 792     } else {
 793       _unwind_handler_offset = -1;
 794     }
 795 
 796     _oops_offset             = data_offset();
 797     _metadata_offset         = _oops_offset          + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 798     int scopes_data_offset   = _metadata_offset      + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 799 
 800     _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info-&gt;data_size       (), oopSize);
 801     _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info-&gt;pcs_size());
 802     _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies-&gt;size_in_bytes (), oopSize);
 803     _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table-&gt;size_in_bytes(), oopSize);
 804 #if INCLUDE_JVMCI
 805     _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 806     _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);
 807     _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);
 808 #else
 809     _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 810 #endif
 811     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 812     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
<a name="2" id="anc2"></a><span class="line-modified"> 813     _inline_entry_point       = code_begin()         + offsets-&gt;value(CodeOffsets::Inline_Entry);</span>
<span class="line-modified"> 814     _verified_inline_entry_point = code_begin()      + offsets-&gt;value(CodeOffsets::Verified_Inline_Entry);</span>
<span class="line-modified"> 815     _verified_inline_ro_entry_point = code_begin()   + offsets-&gt;value(CodeOffsets::Verified_Inline_Entry_RO);</span>
 816     _osr_entry_point         = code_begin()          + offsets-&gt;value(CodeOffsets::OSR_Entry);
 817     _exception_cache         = NULL;
 818     _scopes_data_begin       = (address) this + scopes_data_offset;
 819 
 820     _pc_desc_container.reset_to(scopes_pcs_begin());
 821 
 822     code_buffer-&gt;copy_code_and_locs_to(this);
 823     // Copy contents of ScopeDescRecorder to nmethod
 824     code_buffer-&gt;copy_values_to(this);
 825     debug_info-&gt;copy_to(this);
 826     dependencies-&gt;copy_to(this);
 827     clear_unloading_state();
 828 
 829     Universe::heap()-&gt;register_nmethod(this);
 830     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 831 
 832     CodeCache::commit(this);
 833 
 834     // Copy contents of ExceptionHandlerTable to nmethod
 835     handler_table-&gt;copy_to(this);
 836     nul_chk_table-&gt;copy_to(this);
 837 
 838 #if INCLUDE_JVMCI
 839     // Copy speculations to nmethod
 840     if (speculations_size() != 0) {
 841       memcpy(speculations_begin(), speculations, speculations_len);
 842     }
 843 #endif
 844 
 845     // we use the information of entry points to find out if a method is
 846     // static or non static
 847     assert(compiler-&gt;is_c2() || compiler-&gt;is_jvmci() ||
 848            _method-&gt;is_static() == (entry_point() == _verified_entry_point),
 849            &quot; entry points must be same for static methods and vice versa&quot;);
 850   }
 851 }
 852 
 853 // Print a short set of xml attributes to identify this nmethod.  The
 854 // output should be embedded in some other element.
 855 void nmethod::log_identity(xmlStream* log) const {
 856   log-&gt;print(&quot; compile_id=&#39;%d&#39;&quot;, compile_id());
 857   const char* nm_kind = compile_kind();
 858   if (nm_kind != NULL)  log-&gt;print(&quot; compile_kind=&#39;%s&#39;&quot;, nm_kind);
 859   log-&gt;print(&quot; compiler=&#39;%s&#39;&quot;, compiler_name());
 860   if (TieredCompilation) {
 861     log-&gt;print(&quot; level=&#39;%d&#39;&quot;, comp_level());
 862   }
 863 #if INCLUDE_JVMCI
 864   if (jvmci_nmethod_data() != NULL) {
 865     const char* jvmci_name = jvmci_nmethod_data()-&gt;name();
 866     if (jvmci_name != NULL) {
 867       log-&gt;print(&quot; jvmci_mirror_name=&#39;&quot;);
 868       log-&gt;text(&quot;%s&quot;, jvmci_name);
 869       log-&gt;print(&quot;&#39;&quot;);
 870     }
 871   }
 872 #endif
 873 }
 874 
 875 
 876 #define LOG_OFFSET(log, name)                    \
 877   if (p2i(name##_end()) - p2i(name##_begin())) \
 878     log-&gt;print(&quot; &quot; XSTR(name) &quot;_offset=&#39;&quot; INTX_FORMAT &quot;&#39;&quot;    , \
 879                p2i(name##_begin()) - p2i(this))
 880 
 881 
 882 void nmethod::log_new_nmethod() const {
 883   if (LogCompilation &amp;&amp; xtty != NULL) {
 884     ttyLocker ttyl;
 885     HandleMark hm;
 886     xtty-&gt;begin_elem(&quot;nmethod&quot;);
 887     log_identity(xtty);
 888     xtty-&gt;print(&quot; entry=&#39;&quot; INTPTR_FORMAT &quot;&#39; size=&#39;%d&#39;&quot;, p2i(code_begin()), size());
 889     xtty-&gt;print(&quot; address=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;, p2i(this));
 890 
 891     LOG_OFFSET(xtty, relocation);
 892     LOG_OFFSET(xtty, consts);
 893     LOG_OFFSET(xtty, insts);
 894     LOG_OFFSET(xtty, stub);
 895     LOG_OFFSET(xtty, scopes_data);
 896     LOG_OFFSET(xtty, scopes_pcs);
 897     LOG_OFFSET(xtty, dependencies);
 898     LOG_OFFSET(xtty, handler_table);
 899     LOG_OFFSET(xtty, nul_chk_table);
 900     LOG_OFFSET(xtty, oops);
 901     LOG_OFFSET(xtty, metadata);
 902 
 903     xtty-&gt;method(method());
 904     xtty-&gt;stamp();
 905     xtty-&gt;end_elem();
 906   }
 907 }
 908 
 909 #undef LOG_OFFSET
 910 
 911 
 912 // Print out more verbose output usually for a newly created nmethod.
 913 void nmethod::print_on(outputStream* st, const char* msg) const {
 914   if (st != NULL) {
 915     ttyLocker ttyl;
 916     if (WizardMode) {
 917       CompileTask::print(st, this, msg, /*short_form:*/ true);
 918       st-&gt;print_cr(&quot; (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
 919     } else {
 920       CompileTask::print(st, this, msg, /*short_form:*/ false);
 921     }
 922   }
 923 }
 924 
 925 void nmethod::maybe_print_nmethod(DirectiveSet* directive) {
 926   bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;
 927   if (printnmethods || PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers) {
 928     print_nmethod(printnmethods);
 929   }
 930 }
 931 
 932 static nmethod* _nmethod_to_print = NULL;
 933 static const CompiledEntrySignature* _nmethod_to_print_ces = NULL;
 934 
 935 void nmethod::print_nmethod(bool printmethod) {
 936   ResourceMark rm;
 937   CompiledEntrySignature ces(method());
 938   ces.compute_calling_conventions();
 939   // ces.compute_calling_conventions() needs to grab the ProtectionDomainSet_lock, so we
 940   // can&#39;t do that (inside nmethod::print_entry_parameters) while holding the ttyLocker.
 941   // Hence we have do compute it here and pass via a global. Yuck.
 942   ttyLocker ttyl;  // keep the following output all in one block
 943   assert(_nmethod_to_print == NULL &amp;&amp; _nmethod_to_print_ces == NULL, &quot;no nesting&quot;);
 944   _nmethod_to_print = this;
 945   _nmethod_to_print_ces = &amp;ces;
 946   if (xtty != NULL) {
 947     xtty-&gt;begin_head(&quot;print_nmethod&quot;);
 948     log_identity(xtty);
 949     xtty-&gt;stamp();
 950     xtty-&gt;end_head();
 951   }
 952   // Print the header part, then print the requested information.
 953   // This is both handled in decode2().
 954   if (printmethod) {
 955     HandleMark hm;
 956     ResourceMark m;
 957     if (is_compiled_by_c1()) {
 958       tty-&gt;cr();
 959       tty-&gt;print_cr(&quot;============================= C1-compiled nmethod ==============================&quot;);
 960     }
 961     if (is_compiled_by_jvmci()) {
 962       tty-&gt;cr();
 963       tty-&gt;print_cr(&quot;=========================== JVMCI-compiled nmethod =============================&quot;);
 964     }
 965     tty-&gt;print_cr(&quot;----------------------------------- Assembly -----------------------------------&quot;);
 966     decode2(tty);
 967 #if defined(SUPPORT_DATA_STRUCTS)
 968     if (AbstractDisassembler::show_structs()) {
 969       // Print the oops from the underlying CodeBlob as well.
 970       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 971       print_oops(tty);
 972       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 973       print_metadata(tty);
 974       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 975       print_pcs();
 976       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 977       if (oop_maps() != NULL) {
 978         tty-&gt;print(&quot;oop maps:&quot;); // oop_maps()-&gt;print_on(tty) outputs a cr() at the beginning
 979         oop_maps()-&gt;print_on(tty);
 980         tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 981       }
 982     }
 983 #endif
 984   } else {
 985     print(); // print the header part only.
 986   }
 987 
 988 #if defined(SUPPORT_DATA_STRUCTS)
 989   if (AbstractDisassembler::show_structs()) {
 990     methodHandle mh(Thread::current(), _method);
 991     if (printmethod || PrintDebugInfo || CompilerOracle::has_option_string(mh, &quot;PrintDebugInfo&quot;)) {
 992       print_scopes();
 993       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 994     }
 995     if (printmethod || PrintRelocations || CompilerOracle::has_option_string(mh, &quot;PrintRelocations&quot;)) {
 996       print_relocations();
 997       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 998     }
 999     if (printmethod || PrintDependencies || CompilerOracle::has_option_string(mh, &quot;PrintDependencies&quot;)) {
1000       print_dependencies();
1001       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1002     }
1003     if (printmethod || PrintExceptionHandlers) {
1004       print_handler_table();
1005       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1006       print_nul_chk_table();
1007       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1008     }
1009 
1010     if (printmethod) {
1011       print_recorded_oops();
1012       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1013       print_recorded_metadata();
1014       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1015     }
1016   }
1017 #endif
1018 
1019   if (xtty != NULL) {
1020     xtty-&gt;tail(&quot;print_nmethod&quot;);
1021   }
1022 
1023   _nmethod_to_print = NULL;
1024   _nmethod_to_print_ces = NULL;
1025 }
1026 
1027 
1028 // Promote one word from an assembly-time handle to a live embedded oop.
1029 inline void nmethod::initialize_immediate_oop(oop* dest, jobject handle) {
1030   if (handle == NULL ||
1031       // As a special case, IC oops are initialized to 1 or -1.
1032       handle == (jobject) Universe::non_oop_word()) {
1033     (*dest) = (oop) handle;
1034   } else {
1035     (*dest) = JNIHandles::resolve_non_null(handle);
1036   }
1037 }
1038 
1039 
1040 // Have to have the same name because it&#39;s called by a template
1041 void nmethod::copy_values(GrowableArray&lt;jobject&gt;* array) {
1042   int length = array-&gt;length();
1043   assert((address)(oops_begin() + length) &lt;= (address)oops_end(), &quot;oops big enough&quot;);
1044   oop* dest = oops_begin();
1045   for (int index = 0 ; index &lt; length; index++) {
1046     initialize_immediate_oop(&amp;dest[index], array-&gt;at(index));
1047   }
1048 
1049   // Now we can fix up all the oops in the code.  We need to do this
1050   // in the code because the assembler uses jobjects as placeholders.
1051   // The code and relocations have already been initialized by the
1052   // CodeBlob constructor, so it is valid even at this early point to
1053   // iterate over relocations and patch the code.
1054   fix_oop_relocations(NULL, NULL, /*initialize_immediates=*/ true);
1055 }
1056 
1057 void nmethod::copy_values(GrowableArray&lt;Metadata*&gt;* array) {
1058   int length = array-&gt;length();
1059   assert((address)(metadata_begin() + length) &lt;= (address)metadata_end(), &quot;big enough&quot;);
1060   Metadata** dest = metadata_begin();
1061   for (int index = 0 ; index &lt; length; index++) {
1062     dest[index] = array-&gt;at(index);
1063   }
1064 }
1065 
1066 void nmethod::fix_oop_relocations(address begin, address end, bool initialize_immediates) {
1067   // re-patch all oop-bearing instructions, just in case some oops moved
1068   RelocIterator iter(this, begin, end);
1069   while (iter.next()) {
1070     if (iter.type() == relocInfo::oop_type) {
1071       oop_Relocation* reloc = iter.oop_reloc();
1072       if (initialize_immediates &amp;&amp; reloc-&gt;oop_is_immediate()) {
1073         oop* dest = reloc-&gt;oop_addr();
1074         initialize_immediate_oop(dest, cast_from_oop&lt;jobject&gt;(*dest));
1075       }
1076       // Refresh the oop-related bits of this instruction.
1077       reloc-&gt;fix_oop_relocation();
1078     } else if (iter.type() == relocInfo::metadata_type) {
1079       metadata_Relocation* reloc = iter.metadata_reloc();
1080       reloc-&gt;fix_metadata_relocation();
1081     }
1082   }
1083 }
1084 
1085 
1086 void nmethod::verify_clean_inline_caches() {
1087   assert(CompiledICLocker::is_safe(this), &quot;mt unsafe call&quot;);
1088 
1089   ResourceMark rm;
1090   RelocIterator iter(this, oops_reloc_begin());
1091   while(iter.next()) {
1092     switch(iter.type()) {
1093       case relocInfo::virtual_call_type:
1094       case relocInfo::opt_virtual_call_type: {
1095         CompiledIC *ic = CompiledIC_at(&amp;iter);
1096         // Ok, to lookup references to zombies here
1097         CodeBlob *cb = CodeCache::find_blob_unsafe(ic-&gt;ic_destination());
1098         assert(cb != NULL, &quot;destination not in CodeBlob?&quot;);
1099         nmethod* nm = cb-&gt;as_nmethod_or_null();
1100         if( nm != NULL ) {
1101           // Verify that inline caches pointing to both zombie and not_entrant methods are clean
1102           if (!nm-&gt;is_in_use() || (nm-&gt;method()-&gt;code() != nm)) {
1103             assert(ic-&gt;is_clean(), &quot;IC should be clean&quot;);
1104           }
1105         }
1106         break;
1107       }
1108       case relocInfo::static_call_type: {
1109         CompiledStaticCall *csc = compiledStaticCall_at(iter.reloc());
1110         CodeBlob *cb = CodeCache::find_blob_unsafe(csc-&gt;destination());
1111         assert(cb != NULL, &quot;destination not in CodeBlob?&quot;);
1112         nmethod* nm = cb-&gt;as_nmethod_or_null();
1113         if( nm != NULL ) {
1114           // Verify that inline caches pointing to both zombie and not_entrant methods are clean
1115           if (!nm-&gt;is_in_use() || (nm-&gt;method()-&gt;code() != nm)) {
1116             assert(csc-&gt;is_clean(), &quot;IC should be clean&quot;);
1117           }
1118         }
1119         break;
1120       }
1121       default:
1122         break;
1123     }
1124   }
1125 }
1126 
1127 // This is a private interface with the sweeper.
1128 void nmethod::mark_as_seen_on_stack() {
1129   assert(is_alive(), &quot;Must be an alive method&quot;);
1130   // Set the traversal mark to ensure that the sweeper does 2
1131   // cleaning passes before moving to zombie.
1132   set_stack_traversal_mark(NMethodSweeper::traversal_count());
1133 }
1134 
1135 // Tell if a non-entrant method can be converted to a zombie (i.e.,
1136 // there are no activations on the stack, not in use by the VM,
1137 // and not in use by the ServiceThread)
1138 bool nmethod::can_convert_to_zombie() {
1139   // Note that this is called when the sweeper has observed the nmethod to be
1140   // not_entrant. However, with concurrent code cache unloading, the state
1141   // might have moved on to unloaded if it is_unloading(), due to racing
1142   // concurrent GC threads.
1143   assert(is_not_entrant() || is_unloading() ||
1144          !Thread::current()-&gt;is_Code_cache_sweeper_thread(),
1145          &quot;must be a non-entrant method if called from sweeper&quot;);
1146 
1147   // Since the nmethod sweeper only does partial sweep the sweeper&#39;s traversal
1148   // count can be greater than the stack traversal count before it hits the
1149   // nmethod for the second time.
1150   // If an is_unloading() nmethod is still not_entrant, then it is not safe to
1151   // convert it to zombie due to GC unloading interactions. However, if it
1152   // has become unloaded, then it is okay to convert such nmethods to zombie.
1153   return stack_traversal_mark() + 1 &lt; NMethodSweeper::traversal_count() &amp;&amp;
1154          !is_locked_by_vm() &amp;&amp; (!is_unloading() || is_unloaded());
1155 }
1156 
1157 void nmethod::inc_decompile_count() {
1158   if (!is_compiled_by_c2() &amp;&amp; !is_compiled_by_jvmci()) return;
1159   // Could be gated by ProfileTraps, but do not bother...
1160   Method* m = method();
1161   if (m == NULL)  return;
1162   MethodData* mdo = m-&gt;method_data();
1163   if (mdo == NULL)  return;
1164   // There is a benign race here.  See comments in methodData.hpp.
1165   mdo-&gt;inc_decompile_count();
1166 }
1167 
1168 bool nmethod::try_transition(int new_state_int) {
1169   signed char new_state = new_state_int;
1170 #ifdef DEBUG
1171   if (new_state != unloaded) {
1172     assert_lock_strong(CompiledMethod_lock);
1173   }
1174 #endif
1175   for (;;) {
1176     signed char old_state = Atomic::load(&amp;_state);
1177     if (old_state &gt;= new_state) {
1178       // Ensure monotonicity of transitions.
1179       return false;
1180     }
1181     if (Atomic::cmpxchg(&amp;_state, old_state, new_state) == old_state) {
1182       return true;
1183     }
1184   }
1185 }
1186 
1187 void nmethod::make_unloaded() {
1188   post_compiled_method_unload();
1189 
1190   // This nmethod is being unloaded, make sure that dependencies
1191   // recorded in instanceKlasses get flushed.
1192   // Since this work is being done during a GC, defer deleting dependencies from the
1193   // InstanceKlass.
1194   assert(Universe::heap()-&gt;is_gc_active() || Thread::current()-&gt;is_ConcurrentGC_thread(),
1195          &quot;should only be called during gc&quot;);
1196   flush_dependencies(/*delete_immediately*/false);
1197 
1198   // Break cycle between nmethod &amp; method
1199   LogTarget(Trace, class, unload, nmethod) lt;
1200   if (lt.is_enabled()) {
1201     LogStream ls(lt);
1202     ls.print(&quot;making nmethod &quot; INTPTR_FORMAT
1203              &quot; unloadable, Method*(&quot; INTPTR_FORMAT
1204              &quot;) &quot;,
1205              p2i(this), p2i(_method));
1206      ls.cr();
1207   }
1208   // Unlink the osr method, so we do not look this up again
1209   if (is_osr_method()) {
1210     // Invalidate the osr nmethod only once. Note that with concurrent
1211     // code cache unloading, OSR nmethods are invalidated before they
1212     // are made unloaded. Therefore, this becomes a no-op then.
1213     if (is_in_use()) {
1214       invalidate_osr_method();
1215     }
1216 #ifdef ASSERT
1217     if (method() != NULL) {
1218       // Make sure osr nmethod is invalidated, i.e. not on the list
1219       bool found = method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1220       assert(!found, &quot;osr nmethod should have been invalidated&quot;);
1221     }
1222 #endif
1223   }
1224 
1225   // If _method is already NULL the Method* is about to be unloaded,
1226   // so we don&#39;t have to break the cycle. Note that it is possible to
1227   // have the Method* live here, in case we unload the nmethod because
1228   // it is pointing to some oop (other than the Method*) being unloaded.
1229   if (_method != NULL) {
1230     _method-&gt;unlink_code(this);
1231   }
1232 
1233   // Make the class unloaded - i.e., change state and notify sweeper
1234   assert(SafepointSynchronize::is_at_safepoint() || Thread::current()-&gt;is_ConcurrentGC_thread(),
1235          &quot;must be at safepoint&quot;);
1236 
1237   {
1238     // Clear ICStubs and release any CompiledICHolders.
1239     CompiledICLocker ml(this);
1240     clear_ic_callsites();
1241   }
1242 
1243   // Unregister must be done before the state change
1244   {
1245     MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock,
1246                      Mutex::_no_safepoint_check_flag);
1247     Universe::heap()-&gt;unregister_nmethod(this);
1248   }
1249 
1250   // Clear the method of this dead nmethod
1251   set_method(NULL);
1252 
1253   // Log the unloading.
1254   log_state_change();
1255 
1256   // The Method* is gone at this point
1257   assert(_method == NULL, &quot;Tautology&quot;);
1258 
1259   set_osr_link(NULL);
1260   NMethodSweeper::report_state_change(this);
1261 
1262   bool transition_success = try_transition(unloaded);
1263 
1264   // It is an important invariant that there exists no race between
1265   // the sweeper and GC thread competing for making the same nmethod
1266   // zombie and unloaded respectively. This is ensured by
1267   // can_convert_to_zombie() returning false for any is_unloading()
1268   // nmethod, informing the sweeper not to step on any GC toes.
1269   assert(transition_success, &quot;Invalid nmethod transition to unloaded&quot;);
1270 
1271 #if INCLUDE_JVMCI
1272   // Clear the link between this nmethod and a HotSpotNmethod mirror
1273   JVMCINMethodData* nmethod_data = jvmci_nmethod_data();
1274   if (nmethod_data != NULL) {
1275     nmethod_data-&gt;invalidate_nmethod_mirror(this);
1276     nmethod_data-&gt;clear_nmethod_mirror(this);
1277   }
1278 #endif
1279 }
1280 
1281 void nmethod::invalidate_osr_method() {
1282   assert(_entry_bci != InvocationEntryBci, &quot;wrong kind of nmethod&quot;);
1283   // Remove from list of active nmethods
1284   if (method() != NULL) {
1285     method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1286   }
1287 }
1288 
1289 void nmethod::log_state_change() const {
1290   if (LogCompilation) {
1291     if (xtty != NULL) {
1292       ttyLocker ttyl;  // keep the following output all in one block
1293       if (_state == unloaded) {
1294         xtty-&gt;begin_elem(&quot;make_unloaded thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
1295                          os::current_thread_id());
1296       } else {
1297         xtty-&gt;begin_elem(&quot;make_not_entrant thread=&#39;&quot; UINTX_FORMAT &quot;&#39;%s&quot;,
1298                          os::current_thread_id(),
1299                          (_state == zombie ? &quot; zombie=&#39;1&#39;&quot; : &quot;&quot;));
1300       }
1301       log_identity(xtty);
1302       xtty-&gt;stamp();
1303       xtty-&gt;end_elem();
1304     }
1305   }
1306 
1307   const char *state_msg = _state == zombie ? &quot;made zombie&quot; : &quot;made not entrant&quot;;
1308   CompileTask::print_ul(this, state_msg);
1309   if (PrintCompilation &amp;&amp; _state != unloaded) {
1310     print_on(tty, state_msg);
1311   }
1312 }
1313 
1314 void nmethod::unlink_from_method() {
1315   if (method() != NULL) {
1316     method()-&gt;unlink_code(this);
1317   }
1318 }
1319 
1320 /**
1321  * Common functionality for both make_not_entrant and make_zombie
1322  */
1323 bool nmethod::make_not_entrant_or_zombie(int state) {
1324   assert(state == zombie || state == not_entrant, &quot;must be zombie or not_entrant&quot;);
1325 
1326   if (Atomic::load(&amp;_state) &gt;= state) {
1327     // Avoid taking the lock if already in required state.
1328     // This is safe from races because the state is an end-state,
1329     // which the nmethod cannot back out of once entered.
1330     // No need for fencing either.
1331     return false;
1332   }
1333 
1334   // Make sure the nmethod is not flushed.
1335   nmethodLocker nml(this);
1336   // This can be called while the system is already at a safepoint which is ok
1337   NoSafepointVerifier nsv;
1338 
1339   // during patching, depending on the nmethod state we must notify the GC that
1340   // code has been unloaded, unregistering it. We cannot do this right while
1341   // holding the CompiledMethod_lock because we need to use the CodeCache_lock. This
1342   // would be prone to deadlocks.
1343   // This flag is used to remember whether we need to later lock and unregister.
1344   bool nmethod_needs_unregister = false;
1345 
1346   {
1347     // Enter critical section.  Does not block for safepoint.
1348     MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1349 
1350     // This logic is equivalent to the logic below for patching the
1351     // verified entry point of regular methods. We check that the
1352     // nmethod is in use to ensure that it is invalidated only once.
1353     if (is_osr_method() &amp;&amp; is_in_use()) {
1354       // this effectively makes the osr nmethod not entrant
1355       invalidate_osr_method();
1356     }
1357 
1358     if (Atomic::load(&amp;_state) &gt;= state) {
1359       // another thread already performed this transition so nothing
1360       // to do, but return false to indicate this.
1361       return false;
1362     }
1363 
1364     // The caller can be calling the method statically or through an inline
1365     // cache call.
1366     if (!is_osr_method() &amp;&amp; !is_not_entrant()) {
1367       NativeJump::patch_verified_entry(entry_point(), verified_entry_point(),
1368                   SharedRuntime::get_handle_wrong_method_stub());
1369     }
1370 
1371     if (is_in_use() &amp;&amp; update_recompile_counts()) {
1372       // It&#39;s a true state change, so mark the method as decompiled.
1373       // Do it only for transition from alive.
1374       inc_decompile_count();
1375     }
1376 
1377     // If the state is becoming a zombie, signal to unregister the nmethod with
1378     // the heap.
1379     // This nmethod may have already been unloaded during a full GC.
1380     if ((state == zombie) &amp;&amp; !is_unloaded()) {
1381       nmethod_needs_unregister = true;
1382     }
1383 
1384     // Must happen before state change. Otherwise we have a race condition in
1385     // nmethod::can_convert_to_zombie(). I.e., a method can immediately
1386     // transition its state from &#39;not_entrant&#39; to &#39;zombie&#39; without having to wait
1387     // for stack scanning.
1388     if (state == not_entrant) {
1389       mark_as_seen_on_stack();
1390       OrderAccess::storestore(); // _stack_traversal_mark and _state
1391     }
1392 
1393     // Change state
1394     if (!try_transition(state)) {
1395       // If the transition fails, it is due to another thread making the nmethod more
1396       // dead. In particular, one thread might be making the nmethod unloaded concurrently.
1397       // If so, having patched in the jump in the verified entry unnecessarily is fine.
1398       // The nmethod is no longer possible to call by Java threads.
1399       // Incrementing the decompile count is also fine as the caller of make_not_entrant()
1400       // had a valid reason to deoptimize the nmethod.
1401       // Marking the nmethod as seen on stack also has no effect, as the nmethod is now
1402       // !is_alive(), and the seen on stack value is only used to convert not_entrant
1403       // nmethods to zombie in can_convert_to_zombie().
1404       return false;
1405     }
1406 
1407     // Log the transition once
1408     log_state_change();
1409 
1410     // Remove nmethod from method.
1411     unlink_from_method();
1412 
1413   } // leave critical region under CompiledMethod_lock
1414 
1415 #if INCLUDE_JVMCI
1416   // Invalidate can&#39;t occur while holding the Patching lock
1417   JVMCINMethodData* nmethod_data = jvmci_nmethod_data();
1418   if (nmethod_data != NULL) {
1419     nmethod_data-&gt;invalidate_nmethod_mirror(this);
1420   }
1421 #endif
1422 
1423 #ifdef ASSERT
1424   if (is_osr_method() &amp;&amp; method() != NULL) {
1425     // Make sure osr nmethod is invalidated, i.e. not on the list
1426     bool found = method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1427     assert(!found, &quot;osr nmethod should have been invalidated&quot;);
1428   }
1429 #endif
1430 
1431   // When the nmethod becomes zombie it is no longer alive so the
1432   // dependencies must be flushed.  nmethods in the not_entrant
1433   // state will be flushed later when the transition to zombie
1434   // happens or they get unloaded.
1435   if (state == zombie) {
1436     {
1437       // Flushing dependencies must be done before any possible
1438       // safepoint can sneak in, otherwise the oops used by the
1439       // dependency logic could have become stale.
1440       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1441       if (nmethod_needs_unregister) {
1442         Universe::heap()-&gt;unregister_nmethod(this);
1443       }
1444       flush_dependencies(/*delete_immediately*/true);
1445     }
1446 
1447 #if INCLUDE_JVMCI
1448     // Now that the nmethod has been unregistered, it&#39;s
1449     // safe to clear the HotSpotNmethod mirror oop.
1450     if (nmethod_data != NULL) {
1451       nmethod_data-&gt;clear_nmethod_mirror(this);
1452     }
1453 #endif
1454 
1455     // Clear ICStubs to prevent back patching stubs of zombie or flushed
1456     // nmethods during the next safepoint (see ICStub::finalize), as well
1457     // as to free up CompiledICHolder resources.
1458     {
1459       CompiledICLocker ml(this);
1460       clear_ic_callsites();
1461     }
1462 
1463     // zombie only - if a JVMTI agent has enabled the CompiledMethodUnload
1464     // event and it hasn&#39;t already been reported for this nmethod then
1465     // report it now. The event may have been reported earlier if the GC
1466     // marked it for unloading). JvmtiDeferredEventQueue support means
1467     // we no longer go to a safepoint here.
1468     post_compiled_method_unload();
1469 
1470 #ifdef ASSERT
1471     // It&#39;s no longer safe to access the oops section since zombie
1472     // nmethods aren&#39;t scanned for GC.
1473     _oops_are_stale = true;
1474 #endif
1475      // the Method may be reclaimed by class unloading now that the
1476      // nmethod is in zombie state
1477     set_method(NULL);
1478   } else {
1479     assert(state == not_entrant, &quot;other cases may need to be handled differently&quot;);
1480   }
1481 
1482   if (TraceCreateZombies &amp;&amp; state == zombie) {
1483     ResourceMark m;
1484     tty-&gt;print_cr(&quot;nmethod &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made %s&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;, (state == not_entrant) ? &quot;not entrant&quot; : &quot;zombie&quot;);
1485   }
1486 
1487   NMethodSweeper::report_state_change(this);
1488   return true;
1489 }
1490 
1491 void nmethod::flush() {
1492   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1493   // Note that there are no valid oops in the nmethod anymore.
1494   assert(!is_osr_method() || is_unloaded() || is_zombie(),
1495          &quot;osr nmethod must be unloaded or zombie before flushing&quot;);
1496   assert(is_zombie() || is_osr_method(), &quot;must be a zombie method&quot;);
1497   assert (!is_locked_by_vm(), &quot;locked methods shouldn&#39;t be flushed&quot;);
1498   assert_locked_or_safepoint(CodeCache_lock);
1499 
1500   // completely deallocate this method
1501   Events::log(JavaThread::current(), &quot;flushing nmethod &quot; INTPTR_FORMAT, p2i(this));
1502   if (PrintMethodFlushing) {
1503     tty-&gt;print_cr(&quot;*flushing %s nmethod %3d/&quot; INTPTR_FORMAT &quot;. Live blobs:&quot; UINT32_FORMAT
1504                   &quot;/Free CodeCache:&quot; SIZE_FORMAT &quot;Kb&quot;,
1505                   is_osr_method() ? &quot;osr&quot; : &quot;&quot;,_compile_id, p2i(this), CodeCache::blob_count(),
1506                   CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))/1024);
1507   }
1508 
1509   // We need to deallocate any ExceptionCache data.
1510   // Note that we do not need to grab the nmethod lock for this, it
1511   // better be thread safe if we&#39;re disposing of it!
1512   ExceptionCache* ec = exception_cache();
1513   set_exception_cache(NULL);
1514   while(ec != NULL) {
1515     ExceptionCache* next = ec-&gt;next();
1516     delete ec;
1517     ec = next;
1518   }
1519 
1520   Universe::heap()-&gt;flush_nmethod(this);
1521   CodeCache::unregister_old_nmethod(this);
1522 
1523   CodeBlob::flush();
1524   CodeCache::free(this);
1525 }
1526 
1527 oop nmethod::oop_at(int index) const {
1528   if (index == 0) {
1529     return NULL;
1530   }
1531   return NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(oop_addr_at(index));
1532 }
1533 
1534 oop nmethod::oop_at_phantom(int index) const {
1535   if (index == 0) {
1536     return NULL;
1537   }
1538   return NativeAccess&lt;ON_PHANTOM_OOP_REF&gt;::oop_load(oop_addr_at(index));
1539 }
1540 
1541 //
1542 // Notify all classes this nmethod is dependent on that it is no
1543 // longer dependent. This should only be called in two situations.
1544 // First, when a nmethod transitions to a zombie all dependents need
1545 // to be clear.  Since zombification happens at a safepoint there&#39;s no
1546 // synchronization issues.  The second place is a little more tricky.
1547 // During phase 1 of mark sweep class unloading may happen and as a
1548 // result some nmethods may get unloaded.  In this case the flushing
1549 // of dependencies must happen during phase 1 since after GC any
1550 // dependencies in the unloaded nmethod won&#39;t be updated, so
1551 // traversing the dependency information in unsafe.  In that case this
1552 // function is called with a boolean argument and this function only
1553 // notifies instanceKlasses that are reachable
1554 
1555 void nmethod::flush_dependencies(bool delete_immediately) {
1556   DEBUG_ONLY(bool called_by_gc = Universe::heap()-&gt;is_gc_active() || Thread::current()-&gt;is_ConcurrentGC_thread();)
1557   assert(called_by_gc != delete_immediately,
1558   &quot;delete_immediately is false if and only if we are called during GC&quot;);
1559   if (!has_flushed_dependencies()) {
1560     set_has_flushed_dependencies();
1561     for (Dependencies::DepStream deps(this); deps.next(); ) {
1562       if (deps.type() == Dependencies::call_site_target_value) {
1563         // CallSite dependencies are managed on per-CallSite instance basis.
1564         oop call_site = deps.argument_oop(0);
1565         if (delete_immediately) {
1566           assert_locked_or_safepoint(CodeCache_lock);
1567           MethodHandles::remove_dependent_nmethod(call_site, this);
1568         } else {
1569           MethodHandles::clean_dependency_context(call_site);
1570         }
1571       } else {
1572         Klass* klass = deps.context_type();
1573         if (klass == NULL) {
1574           continue;  // ignore things like evol_method
1575         }
1576         // During GC delete_immediately is false, and liveness
1577         // of dependee determines class that needs to be updated.
1578         if (delete_immediately) {
1579           assert_locked_or_safepoint(CodeCache_lock);
1580           InstanceKlass::cast(klass)-&gt;remove_dependent_nmethod(this);
1581         } else if (klass-&gt;is_loader_alive()) {
1582           // The GC may clean dependency contexts concurrently and in parallel.
1583           InstanceKlass::cast(klass)-&gt;clean_dependency_context();
1584         }
1585       }
1586     }
1587   }
1588 }
1589 
1590 // ------------------------------------------------------------------
1591 // post_compiled_method_load_event
1592 // new method for install_code() path
1593 // Transfer information from compilation to jvmti
1594 void nmethod::post_compiled_method_load_event(JvmtiThreadState* state) {
1595 
1596   // Don&#39;t post this nmethod load event if it is already dying
1597   // because the sweeper might already be deleting this nmethod.
1598   if (is_not_entrant() &amp;&amp; can_convert_to_zombie()) {
1599     return;
1600   }
1601 
1602   // This is a bad time for a safepoint.  We don&#39;t want
1603   // this nmethod to get unloaded while we&#39;re queueing the event.
1604   NoSafepointVerifier nsv;
1605 
1606   Method* m = method();
1607   HOTSPOT_COMPILED_METHOD_LOAD(
1608       (char *) m-&gt;klass_name()-&gt;bytes(),
1609       m-&gt;klass_name()-&gt;utf8_length(),
1610       (char *) m-&gt;name()-&gt;bytes(),
1611       m-&gt;name()-&gt;utf8_length(),
1612       (char *) m-&gt;signature()-&gt;bytes(),
1613       m-&gt;signature()-&gt;utf8_length(),
1614       insts_begin(), insts_size());
1615 
1616 
1617   if (JvmtiExport::should_post_compiled_method_load()) {
1618     // Only post unload events if load events are found.
1619     set_load_reported();
1620     // If a JavaThread hasn&#39;t been passed in, let the Service thread
1621     // (which is a real Java thread) post the event
1622     JvmtiDeferredEvent event = JvmtiDeferredEvent::compiled_method_load_event(this);
1623     if (state == NULL) {
1624       // Execute any barrier code for this nmethod as if it&#39;s called, since
1625       // keeping it alive looks like stack walking.
1626       run_nmethod_entry_barrier();
1627       ServiceThread::enqueue_deferred_event(&amp;event);
1628     } else {
1629       // This enters the nmethod barrier outside in the caller.
1630       state-&gt;enqueue_event(&amp;event);
1631     }
1632   }
1633 }
1634 
1635 void nmethod::post_compiled_method_unload() {
1636   if (unload_reported()) {
1637     // During unloading we transition to unloaded and then to zombie
1638     // and the unloading is reported during the first transition.
1639     return;
1640   }
1641 
1642   assert(_method != NULL &amp;&amp; !is_unloaded(), &quot;just checking&quot;);
1643   DTRACE_METHOD_UNLOAD_PROBE(method());
1644 
1645   // If a JVMTI agent has enabled the CompiledMethodUnload event then
1646   // post the event. Sometime later this nmethod will be made a zombie
1647   // by the sweeper but the Method* will not be valid at that point.
1648   // The jmethodID is a weak reference to the Method* so if
1649   // it&#39;s being unloaded there&#39;s no way to look it up since the weak
1650   // ref will have been cleared.
1651 
1652   // Don&#39;t bother posting the unload if the load event wasn&#39;t posted.
1653   if (load_reported() &amp;&amp; JvmtiExport::should_post_compiled_method_unload()) {
1654     assert(!unload_reported(), &quot;already unloaded&quot;);
1655     JvmtiDeferredEvent event =
1656       JvmtiDeferredEvent::compiled_method_unload_event(
1657           method()-&gt;jmethod_id(), insts_begin());
1658     ServiceThread::enqueue_deferred_event(&amp;event);
1659   }
1660 
1661   // The JVMTI CompiledMethodUnload event can be enabled or disabled at
1662   // any time. As the nmethod is being unloaded now we mark it has
1663   // having the unload event reported - this will ensure that we don&#39;t
1664   // attempt to report the event in the unlikely scenario where the
1665   // event is enabled at the time the nmethod is made a zombie.
1666   set_unload_reported();
1667 }
1668 
1669 // Iterate over metadata calling this function.   Used by RedefineClasses
1670 void nmethod::metadata_do(MetadataClosure* f) {
1671   {
1672     // Visit all immediate references that are embedded in the instruction stream.
1673     RelocIterator iter(this, oops_reloc_begin());
1674     while (iter.next()) {
1675       if (iter.type() == relocInfo::metadata_type) {
1676         metadata_Relocation* r = iter.metadata_reloc();
1677         // In this metadata, we must only follow those metadatas directly embedded in
1678         // the code.  Other metadatas (oop_index&gt;0) are seen as part of
1679         // the metadata section below.
1680         assert(1 == (r-&gt;metadata_is_immediate()) +
1681                (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
1682                &quot;metadata must be found in exactly one place&quot;);
1683         if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
1684           Metadata* md = r-&gt;metadata_value();
1685           if (md != _method) f-&gt;do_metadata(md);
1686         }
1687       } else if (iter.type() == relocInfo::virtual_call_type) {
1688         // Check compiledIC holders associated with this nmethod
1689         ResourceMark rm;
1690         CompiledIC *ic = CompiledIC_at(&amp;iter);
1691         if (ic-&gt;is_icholder_call()) {
1692           CompiledICHolder* cichk = ic-&gt;cached_icholder();
1693           f-&gt;do_metadata(cichk-&gt;holder_metadata());
1694           f-&gt;do_metadata(cichk-&gt;holder_klass());
1695         } else {
1696           Metadata* ic_oop = ic-&gt;cached_metadata();
1697           if (ic_oop != NULL) {
1698             f-&gt;do_metadata(ic_oop);
1699           }
1700         }
1701       }
1702     }
1703   }
1704 
1705   // Visit the metadata section
1706   for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
1707     if (*p == Universe::non_oop_word() || *p == NULL)  continue;  // skip non-oops
1708     Metadata* md = *p;
1709     f-&gt;do_metadata(md);
1710   }
1711 
1712   // Visit metadata not embedded in the other places.
1713   if (_method != NULL) f-&gt;do_metadata(_method);
1714 }
1715 
1716 // The _is_unloading_state encodes a tuple comprising the unloading cycle
1717 // and the result of IsUnloadingBehaviour::is_unloading() fpr that cycle.
1718 // This is the bit layout of the _is_unloading_state byte: 00000CCU
1719 // CC refers to the cycle, which has 2 bits, and U refers to the result of
1720 // IsUnloadingBehaviour::is_unloading() for that unloading cycle.
1721 
1722 class IsUnloadingState: public AllStatic {
1723   static const uint8_t _is_unloading_mask = 1;
1724   static const uint8_t _is_unloading_shift = 0;
1725   static const uint8_t _unloading_cycle_mask = 6;
1726   static const uint8_t _unloading_cycle_shift = 1;
1727 
1728   static uint8_t set_is_unloading(uint8_t state, bool value) {
1729     state &amp;= ~_is_unloading_mask;
1730     if (value) {
1731       state |= 1 &lt;&lt; _is_unloading_shift;
1732     }
1733     assert(is_unloading(state) == value, &quot;unexpected unloading cycle overflow&quot;);
1734     return state;
1735   }
1736 
1737   static uint8_t set_unloading_cycle(uint8_t state, uint8_t value) {
1738     state &amp;= ~_unloading_cycle_mask;
1739     state |= value &lt;&lt; _unloading_cycle_shift;
1740     assert(unloading_cycle(state) == value, &quot;unexpected unloading cycle overflow&quot;);
1741     return state;
1742   }
1743 
1744 public:
1745   static bool is_unloading(uint8_t state) { return (state &amp; _is_unloading_mask) &gt;&gt; _is_unloading_shift == 1; }
1746   static uint8_t unloading_cycle(uint8_t state) { return (state &amp; _unloading_cycle_mask) &gt;&gt; _unloading_cycle_shift; }
1747 
1748   static uint8_t create(bool is_unloading, uint8_t unloading_cycle) {
1749     uint8_t state = 0;
1750     state = set_is_unloading(state, is_unloading);
1751     state = set_unloading_cycle(state, unloading_cycle);
1752     return state;
1753   }
1754 };
1755 
1756 bool nmethod::is_unloading() {
1757   uint8_t state = RawAccess&lt;MO_RELAXED&gt;::load(&amp;_is_unloading_state);
1758   bool state_is_unloading = IsUnloadingState::is_unloading(state);
1759   uint8_t state_unloading_cycle = IsUnloadingState::unloading_cycle(state);
1760   if (state_is_unloading) {
1761     return true;
1762   }
1763   uint8_t current_cycle = CodeCache::unloading_cycle();
1764   if (state_unloading_cycle == current_cycle) {
1765     return false;
1766   }
1767 
1768   // The IsUnloadingBehaviour is responsible for checking if there are any dead
1769   // oops in the CompiledMethod, by calling oops_do on it.
1770   state_unloading_cycle = current_cycle;
1771 
1772   if (is_zombie()) {
1773     // Zombies without calculated unloading epoch are never unloading due to GC.
1774 
1775     // There are no races where a previously observed is_unloading() nmethod
1776     // suddenly becomes not is_unloading() due to here being observed as zombie.
1777 
1778     // With STW unloading, all is_alive() &amp;&amp; is_unloading() nmethods are unlinked
1779     // and unloaded in the safepoint. That makes races where an nmethod is first
1780     // observed as is_alive() &amp;&amp; is_unloading() and subsequently observed as
1781     // is_zombie() impossible.
1782 
1783     // With concurrent unloading, all references to is_unloading() nmethods are
1784     // first unlinked (e.g. IC caches and dependency contexts). Then a global
1785     // handshake operation is performed with all JavaThreads before finally
1786     // unloading the nmethods. The sweeper never converts is_alive() &amp;&amp; is_unloading()
1787     // nmethods to zombies; it waits for them to become is_unloaded(). So before
1788     // the global handshake, it is impossible for is_unloading() nmethods to
1789     // racingly become is_zombie(). And is_unloading() is calculated for all is_alive()
1790     // nmethods before taking that global handshake, meaning that it will never
1791     // be recalculated after the handshake.
1792 
1793     // After that global handshake, is_unloading() nmethods are only observable
1794     // to the iterators, and they will never trigger recomputation of the cached
1795     // is_unloading_state, and hence may not suffer from such races.
1796 
1797     state_is_unloading = false;
1798   } else {
1799     state_is_unloading = IsUnloadingBehaviour::current()-&gt;is_unloading(this);
1800   }
1801 
1802   state = IsUnloadingState::create(state_is_unloading, state_unloading_cycle);
1803 
1804   RawAccess&lt;MO_RELAXED&gt;::store(&amp;_is_unloading_state, state);
1805 
1806   return state_is_unloading;
1807 }
1808 
1809 void nmethod::clear_unloading_state() {
1810   uint8_t state = IsUnloadingState::create(false, CodeCache::unloading_cycle());
1811   RawAccess&lt;MO_RELAXED&gt;::store(&amp;_is_unloading_state, state);
1812 }
1813 
1814 
1815 // This is called at the end of the strong tracing/marking phase of a
1816 // GC to unload an nmethod if it contains otherwise unreachable
1817 // oops.
1818 
1819 void nmethod::do_unloading(bool unloading_occurred) {
1820   // Make sure the oop&#39;s ready to receive visitors
1821   assert(!is_zombie() &amp;&amp; !is_unloaded(),
1822          &quot;should not call follow on zombie or unloaded nmethod&quot;);
1823 
1824   if (is_unloading()) {
1825     make_unloaded();
1826   } else {
1827     guarantee(unload_nmethod_caches(unloading_occurred),
1828               &quot;Should not need transition stubs&quot;);
1829   }
1830 }
1831 
1832 void nmethod::oops_do(OopClosure* f, bool allow_dead) {
1833   // make sure the oops ready to receive visitors
1834   assert(allow_dead || is_alive(), &quot;should not call follow on dead nmethod&quot;);
1835 
1836   // Prevent extra code cache walk for platforms that don&#39;t have immediate oops.
1837   if (relocInfo::mustIterateImmediateOopsInCode()) {
1838     RelocIterator iter(this, oops_reloc_begin());
1839 
1840     while (iter.next()) {
1841       if (iter.type() == relocInfo::oop_type ) {
1842         oop_Relocation* r = iter.oop_reloc();
1843         // In this loop, we must only follow those oops directly embedded in
1844         // the code.  Other oops (oop_index&gt;0) are seen as part of scopes_oops.
1845         assert(1 == (r-&gt;oop_is_immediate()) +
1846                (r-&gt;oop_addr() &gt;= oops_begin() &amp;&amp; r-&gt;oop_addr() &lt; oops_end()),
1847                &quot;oop must be found in exactly one place&quot;);
1848         if (r-&gt;oop_is_immediate() &amp;&amp; r-&gt;oop_value() != NULL) {
1849           f-&gt;do_oop(r-&gt;oop_addr());
1850         }
1851       }
1852     }
1853   }
1854 
1855   // Scopes
1856   // This includes oop constants not inlined in the code stream.
1857   for (oop* p = oops_begin(); p &lt; oops_end(); p++) {
1858     if (*p == Universe::non_oop_word())  continue;  // skip non-oops
1859     f-&gt;do_oop(p);
1860   }
1861 }
1862 
1863 nmethod* volatile nmethod::_oops_do_mark_nmethods;
1864 
1865 void nmethod::oops_do_log_change(const char* state) {
1866   LogTarget(Trace, gc, nmethod) lt;
1867   if (lt.is_enabled()) {
1868     LogStream ls(lt);
1869     CompileTask::print(&amp;ls, this, state, true /* short_form */);
1870   }
1871 }
1872 
1873 bool nmethod::oops_do_try_claim() {
1874   if (oops_do_try_claim_weak_request()) {
1875     nmethod* result = oops_do_try_add_to_list_as_weak_done();
1876     assert(result == NULL, &quot;adding to global list as weak done must always succeed.&quot;);
1877     return true;
1878   }
1879   return false;
1880 }
1881 
1882 bool nmethod::oops_do_try_claim_weak_request() {
1883   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);
1884 
1885   if ((_oops_do_mark_link == NULL) &amp;&amp;
1886       (Atomic::replace_if_null(&amp;_oops_do_mark_link, mark_link(this, claim_weak_request_tag)))) {
1887     oops_do_log_change(&quot;oops_do, mark weak request&quot;);
1888     return true;
1889   }
1890   return false;
1891 }
1892 
1893 void nmethod::oops_do_set_strong_done(nmethod* old_head) {
1894   _oops_do_mark_link = mark_link(old_head, claim_strong_done_tag);
1895 }
1896 
1897 nmethod::oops_do_mark_link* nmethod::oops_do_try_claim_strong_done() {
1898   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);
1899 
1900   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, mark_link(NULL, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));
1901   if (old_next == NULL) {
1902     oops_do_log_change(&quot;oops_do, mark strong done&quot;);
1903   }
1904   return old_next;
1905 }
1906 
1907 nmethod::oops_do_mark_link* nmethod::oops_do_try_add_strong_request(nmethod::oops_do_mark_link* next) {
1908   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);
1909   assert(next == mark_link(this, claim_weak_request_tag), &quot;Should be claimed as weak&quot;);
1910 
1911   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, next, mark_link(this, claim_strong_request_tag));
1912   if (old_next == next) {
1913     oops_do_log_change(&quot;oops_do, mark strong request&quot;);
1914   }
1915   return old_next;
1916 }
1917 
1918 bool nmethod::oops_do_try_claim_weak_done_as_strong_done(nmethod::oops_do_mark_link* next) {
1919   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);
1920   assert(extract_state(next) == claim_weak_done_tag, &quot;Should be claimed as weak done&quot;);
1921 
1922   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, next, mark_link(extract_nmethod(next), claim_strong_done_tag));
1923   if (old_next == next) {
1924     oops_do_log_change(&quot;oops_do, mark weak done -&gt; mark strong done&quot;);
1925     return true;
1926   }
1927   return false;
1928 }
1929 
1930 nmethod* nmethod::oops_do_try_add_to_list_as_weak_done() {
1931   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);
1932 
1933   assert(extract_state(_oops_do_mark_link) == claim_weak_request_tag ||
1934          extract_state(_oops_do_mark_link) == claim_strong_request_tag,
1935          &quot;must be but is nmethod &quot; PTR_FORMAT &quot; %u&quot;, p2i(extract_nmethod(_oops_do_mark_link)), extract_state(_oops_do_mark_link));
1936 
1937   nmethod* old_head = Atomic::xchg(&amp;_oops_do_mark_nmethods, this);
1938   // Self-loop if needed.
1939   if (old_head == NULL) {
1940     old_head = this;
1941   }
1942   // Try to install end of list and weak done tag.
1943   if (Atomic::cmpxchg(&amp;_oops_do_mark_link, mark_link(this, claim_weak_request_tag), mark_link(old_head, claim_weak_done_tag)) == mark_link(this, claim_weak_request_tag)) {
1944     oops_do_log_change(&quot;oops_do, mark weak done&quot;);
1945     return NULL;
1946   } else {
1947     return old_head;
1948   }
1949 }
1950 
1951 void nmethod::oops_do_add_to_list_as_strong_done() {
1952   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);
1953 
1954   nmethod* old_head = Atomic::xchg(&amp;_oops_do_mark_nmethods, this);
1955   // Self-loop if needed.
1956   if (old_head == NULL) {
1957     old_head = this;
1958   }
1959   assert(_oops_do_mark_link == mark_link(this, claim_strong_done_tag), &quot;must be but is nmethod &quot; PTR_FORMAT &quot; state %u&quot;,
1960          p2i(extract_nmethod(_oops_do_mark_link)), extract_state(_oops_do_mark_link));
1961 
1962   oops_do_set_strong_done(old_head);
1963 }
1964 
1965 void nmethod::oops_do_process_weak(OopsDoProcessor* p) {
1966   if (!oops_do_try_claim_weak_request()) {
1967     // Failed to claim for weak processing.
1968     oops_do_log_change(&quot;oops_do, mark weak request fail&quot;);
1969     return;
1970   }
1971 
1972   p-&gt;do_regular_processing(this);
1973 
1974   nmethod* old_head = oops_do_try_add_to_list_as_weak_done();
1975   if (old_head == NULL) {
1976     return;
1977   }
1978   oops_do_log_change(&quot;oops_do, mark weak done fail&quot;);
1979   // Adding to global list failed, another thread added a strong request.
1980   assert(extract_state(_oops_do_mark_link) == claim_strong_request_tag,
1981          &quot;must be but is %u&quot;, extract_state(_oops_do_mark_link));
1982 
1983   oops_do_log_change(&quot;oops_do, mark weak request -&gt; mark strong done&quot;);
1984 
1985   oops_do_set_strong_done(old_head);
1986   // Do missing strong processing.
1987   p-&gt;do_remaining_strong_processing(this);
1988 }
1989 
1990 void nmethod::oops_do_process_strong(OopsDoProcessor* p) {
1991   oops_do_mark_link* next_raw = oops_do_try_claim_strong_done();
1992   if (next_raw == NULL) {
1993     p-&gt;do_regular_processing(this);
1994     oops_do_add_to_list_as_strong_done();
1995     return;
1996   }
1997   // Claim failed. Figure out why and handle it.
1998   if (oops_do_has_weak_request(next_raw)) {
1999     oops_do_mark_link* old = next_raw;
2000     // Claim failed because being weak processed (state == &quot;weak request&quot;).
2001     // Try to request deferred strong processing.
2002     next_raw = oops_do_try_add_strong_request(old);
2003     if (next_raw == old) {
2004       // Successfully requested deferred strong processing.
2005       return;
2006     }
2007     // Failed because of a concurrent transition. No longer in &quot;weak request&quot; state.
2008   }
2009   if (oops_do_has_any_strong_state(next_raw)) {
2010     // Already claimed for strong processing or requested for such.
2011     return;
2012   }
2013   if (oops_do_try_claim_weak_done_as_strong_done(next_raw)) {
2014     // Successfully claimed &quot;weak done&quot; as &quot;strong done&quot;. Do the missing marking.
2015     p-&gt;do_remaining_strong_processing(this);
2016     return;
2017   }
2018   // Claim failed, some other thread got it.
2019 }
2020 
2021 void nmethod::oops_do_marking_prologue() {
2022   assert_at_safepoint();
2023 
2024   log_trace(gc, nmethod)(&quot;oops_do_marking_prologue&quot;);
2025   assert(_oops_do_mark_nmethods == NULL, &quot;must be empty&quot;);
2026 }
2027 
2028 void nmethod::oops_do_marking_epilogue() {
2029   assert_at_safepoint();
2030 
2031   nmethod* next = _oops_do_mark_nmethods;
2032   _oops_do_mark_nmethods = NULL;
2033   if (next != NULL) {
2034     nmethod* cur;
2035     do {
2036       cur = next;
2037       next = extract_nmethod(cur-&gt;_oops_do_mark_link);
2038       cur-&gt;_oops_do_mark_link = NULL;
2039       DEBUG_ONLY(cur-&gt;verify_oop_relocations());
2040 
2041       LogTarget(Trace, gc, nmethod) lt;
2042       if (lt.is_enabled()) {
2043         LogStream ls(lt);
2044         CompileTask::print(&amp;ls, cur, &quot;oops_do, unmark&quot;, /*short_form:*/ true);
2045       }
2046       // End if self-loop has been detected.
2047     } while (cur != next);
2048   }
2049   log_trace(gc, nmethod)(&quot;oops_do_marking_epilogue&quot;);
2050 }
2051 
2052 inline bool includes(void* p, void* from, void* to) {
2053   return from &lt;= p &amp;&amp; p &lt; to;
2054 }
2055 
2056 
2057 void nmethod::copy_scopes_pcs(PcDesc* pcs, int count) {
2058   assert(count &gt;= 2, &quot;must be sentinel values, at least&quot;);
2059 
2060 #ifdef ASSERT
2061   // must be sorted and unique; we do a binary search in find_pc_desc()
2062   int prev_offset = pcs[0].pc_offset();
2063   assert(prev_offset == PcDesc::lower_offset_limit,
2064          &quot;must start with a sentinel&quot;);
2065   for (int i = 1; i &lt; count; i++) {
2066     int this_offset = pcs[i].pc_offset();
2067     assert(this_offset &gt; prev_offset, &quot;offsets must be sorted&quot;);
2068     prev_offset = this_offset;
2069   }
2070   assert(prev_offset == PcDesc::upper_offset_limit,
2071          &quot;must end with a sentinel&quot;);
2072 #endif //ASSERT
2073 
2074   // Search for MethodHandle invokes and tag the nmethod.
2075   for (int i = 0; i &lt; count; i++) {
2076     if (pcs[i].is_method_handle_invoke()) {
2077       set_has_method_handle_invokes(true);
2078       break;
2079     }
2080   }
2081   assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != NULL), &quot;must have deopt mh handler&quot;);
2082 
2083   int size = count * sizeof(PcDesc);
2084   assert(scopes_pcs_size() &gt;= size, &quot;oob&quot;);
2085   memcpy(scopes_pcs_begin(), pcs, size);
2086 
2087   // Adjust the final sentinel downward.
2088   PcDesc* last_pc = &amp;scopes_pcs_begin()[count-1];
2089   assert(last_pc-&gt;pc_offset() == PcDesc::upper_offset_limit, &quot;sanity&quot;);
2090   last_pc-&gt;set_pc_offset(content_size() + 1);
2091   for (; last_pc + 1 &lt; scopes_pcs_end(); last_pc += 1) {
2092     // Fill any rounding gaps with copies of the last record.
2093     last_pc[1] = last_pc[0];
2094   }
2095   // The following assert could fail if sizeof(PcDesc) is not
2096   // an integral multiple of oopSize (the rounding term).
2097   // If it fails, change the logic to always allocate a multiple
2098   // of sizeof(PcDesc), and fill unused words with copies of *last_pc.
2099   assert(last_pc + 1 == scopes_pcs_end(), &quot;must match exactly&quot;);
2100 }
2101 
2102 void nmethod::copy_scopes_data(u_char* buffer, int size) {
2103   assert(scopes_data_size() &gt;= size, &quot;oob&quot;);
2104   memcpy(scopes_data_begin(), buffer, size);
2105 }
2106 
2107 #ifdef ASSERT
2108 static PcDesc* linear_search(const PcDescSearch&amp; search, int pc_offset, bool approximate) {
2109   PcDesc* lower = search.scopes_pcs_begin();
2110   PcDesc* upper = search.scopes_pcs_end();
2111   lower += 1; // exclude initial sentinel
2112   PcDesc* res = NULL;
2113   for (PcDesc* p = lower; p &lt; upper; p++) {
2114     NOT_PRODUCT(--pc_nmethod_stats.pc_desc_tests);  // don&#39;t count this call to match_desc
2115     if (match_desc(p, pc_offset, approximate)) {
2116       if (res == NULL)
2117         res = p;
2118       else
2119         res = (PcDesc*) badAddress;
2120     }
2121   }
2122   return res;
2123 }
2124 #endif
2125 
2126 
2127 // Finds a PcDesc with real-pc equal to &quot;pc&quot;
2128 PcDesc* PcDescContainer::find_pc_desc_internal(address pc, bool approximate, const PcDescSearch&amp; search) {
2129   address base_address = search.code_begin();
2130   if ((pc &lt; base_address) ||
2131       (pc - base_address) &gt;= (ptrdiff_t) PcDesc::upper_offset_limit) {
2132     return NULL;  // PC is wildly out of range
2133   }
2134   int pc_offset = (int) (pc - base_address);
2135 
2136   // Check the PcDesc cache if it contains the desired PcDesc
2137   // (This as an almost 100% hit rate.)
2138   PcDesc* res = _pc_desc_cache.find_pc_desc(pc_offset, approximate);
2139   if (res != NULL) {
2140     assert(res == linear_search(search, pc_offset, approximate), &quot;cache ok&quot;);
2141     return res;
2142   }
2143 
2144   // Fallback algorithm: quasi-linear search for the PcDesc
2145   // Find the last pc_offset less than the given offset.
2146   // The successor must be the required match, if there is a match at all.
2147   // (Use a fixed radix to avoid expensive affine pointer arithmetic.)
2148   PcDesc* lower = search.scopes_pcs_begin();
2149   PcDesc* upper = search.scopes_pcs_end();
2150   upper -= 1; // exclude final sentinel
2151   if (lower &gt;= upper)  return NULL;  // native method; no PcDescs at all
2152 
2153 #define assert_LU_OK \
2154   /* invariant on lower..upper during the following search: */ \
2155   assert(lower-&gt;pc_offset() &lt;  pc_offset, &quot;sanity&quot;); \
2156   assert(upper-&gt;pc_offset() &gt;= pc_offset, &quot;sanity&quot;)
2157   assert_LU_OK;
2158 
2159   // Use the last successful return as a split point.
2160   PcDesc* mid = _pc_desc_cache.last_pc_desc();
2161   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
2162   if (mid-&gt;pc_offset() &lt; pc_offset) {
2163     lower = mid;
2164   } else {
2165     upper = mid;
2166   }
2167 
2168   // Take giant steps at first (4096, then 256, then 16, then 1)
2169   const int LOG2_RADIX = 4 /*smaller steps in debug mode:*/ debug_only(-1);
2170   const int RADIX = (1 &lt;&lt; LOG2_RADIX);
2171   for (int step = (1 &lt;&lt; (LOG2_RADIX*3)); step &gt; 1; step &gt;&gt;= LOG2_RADIX) {
2172     while ((mid = lower + step) &lt; upper) {
2173       assert_LU_OK;
2174       NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
2175       if (mid-&gt;pc_offset() &lt; pc_offset) {
2176         lower = mid;
2177       } else {
2178         upper = mid;
2179         break;
2180       }
2181     }
2182     assert_LU_OK;
2183   }
2184 
2185   // Sneak up on the value with a linear search of length ~16.
2186   while (true) {
2187     assert_LU_OK;
2188     mid = lower + 1;
2189     NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
2190     if (mid-&gt;pc_offset() &lt; pc_offset) {
2191       lower = mid;
2192     } else {
2193       upper = mid;
2194       break;
2195     }
2196   }
2197 #undef assert_LU_OK
2198 
2199   if (match_desc(upper, pc_offset, approximate)) {
2200     assert(upper == linear_search(search, pc_offset, approximate), &quot;search ok&quot;);
2201     _pc_desc_cache.add_pc_desc(upper);
2202     return upper;
2203   } else {
2204     assert(NULL == linear_search(search, pc_offset, approximate), &quot;search ok&quot;);
2205     return NULL;
2206   }
2207 }
2208 
2209 
2210 void nmethod::check_all_dependencies(DepChange&amp; changes) {
2211   // Checked dependencies are allocated into this ResourceMark
2212   ResourceMark rm;
2213 
2214   // Turn off dependency tracing while actually testing dependencies.
2215   NOT_PRODUCT( FlagSetting fs(TraceDependencies, false) );
2216 
2217   typedef ResourceHashtable&lt;DependencySignature, int, &amp;DependencySignature::hash,
2218                             &amp;DependencySignature::equals, 11027&gt; DepTable;
2219 
2220   DepTable* table = new DepTable();
2221 
2222   // Iterate over live nmethods and check dependencies of all nmethods that are not
2223   // marked for deoptimization. A particular dependency is only checked once.
2224   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
2225   while(iter.next()) {
2226     nmethod* nm = iter.method();
2227     // Only notify for live nmethods
2228     if (!nm-&gt;is_marked_for_deoptimization()) {
2229       for (Dependencies::DepStream deps(nm); deps.next(); ) {
2230         // Construct abstraction of a dependency.
2231         DependencySignature* current_sig = new DependencySignature(deps);
2232 
2233         // Determine if dependency is already checked. table-&gt;put(...) returns
2234         // &#39;true&#39; if the dependency is added (i.e., was not in the hashtable).
2235         if (table-&gt;put(*current_sig, 1)) {
2236           if (deps.check_dependency() != NULL) {
2237             // Dependency checking failed. Print out information about the failed
2238             // dependency and finally fail with an assert. We can fail here, since
2239             // dependency checking is never done in a product build.
2240             tty-&gt;print_cr(&quot;Failed dependency:&quot;);
2241             changes.print();
2242             nm-&gt;print();
2243             nm-&gt;print_dependencies();
2244             assert(false, &quot;Should have been marked for deoptimization&quot;);
2245           }
2246         }
2247       }
2248     }
2249   }
2250 }
2251 
2252 bool nmethod::check_dependency_on(DepChange&amp; changes) {
2253   // What has happened:
2254   // 1) a new class dependee has been added
2255   // 2) dependee and all its super classes have been marked
2256   bool found_check = false;  // set true if we are upset
2257   for (Dependencies::DepStream deps(this); deps.next(); ) {
2258     // Evaluate only relevant dependencies.
2259     if (deps.spot_check_dependency_at(changes) != NULL) {
2260       found_check = true;
2261       NOT_DEBUG(break);
2262     }
2263   }
2264   return found_check;
2265 }
2266 
2267 // Called from mark_for_deoptimization, when dependee is invalidated.
2268 bool nmethod::is_dependent_on_method(Method* dependee) {
2269   for (Dependencies::DepStream deps(this); deps.next(); ) {
2270     if (deps.type() != Dependencies::evol_method)
2271       continue;
2272     Method* method = deps.method_argument(0);
2273     if (method == dependee) return true;
2274   }
2275   return false;
2276 }
2277 
2278 
2279 bool nmethod::is_patchable_at(address instr_addr) {
2280   assert(insts_contains(instr_addr), &quot;wrong nmethod used&quot;);
2281   if (is_zombie()) {
2282     // a zombie may never be patched
2283     return false;
2284   }
2285   return true;
2286 }
2287 
2288 
2289 void nmethod_init() {
2290   // make sure you didn&#39;t forget to adjust the filler fields
2291   assert(sizeof(nmethod) % oopSize == 0, &quot;nmethod size must be multiple of a word&quot;);
2292 }
2293 
2294 
2295 //-------------------------------------------------------------------------------------------
2296 
2297 
2298 // QQQ might we make this work from a frame??
2299 nmethodLocker::nmethodLocker(address pc) {
2300   CodeBlob* cb = CodeCache::find_blob(pc);
2301   guarantee(cb != NULL &amp;&amp; cb-&gt;is_compiled(), &quot;bad pc for a nmethod found&quot;);
2302   _nm = cb-&gt;as_compiled_method();
2303   lock_nmethod(_nm);
2304 }
2305 
2306 // Only JvmtiDeferredEvent::compiled_method_unload_event()
2307 // should pass zombie_ok == true.
2308 void nmethodLocker::lock_nmethod(CompiledMethod* cm, bool zombie_ok) {
2309   if (cm == NULL)  return;
2310   if (cm-&gt;is_aot()) return;  // FIXME: Revisit once _lock_count is added to aot_method
2311   nmethod* nm = cm-&gt;as_nmethod();
2312   Atomic::inc(&amp;nm-&gt;_lock_count);
2313   assert(zombie_ok || !nm-&gt;is_zombie(), &quot;cannot lock a zombie method: %p&quot;, nm);
2314 }
2315 
2316 void nmethodLocker::unlock_nmethod(CompiledMethod* cm) {
2317   if (cm == NULL)  return;
2318   if (cm-&gt;is_aot()) return;  // FIXME: Revisit once _lock_count is added to aot_method
2319   nmethod* nm = cm-&gt;as_nmethod();
2320   Atomic::dec(&amp;nm-&gt;_lock_count);
2321   assert(nm-&gt;_lock_count &gt;= 0, &quot;unmatched nmethod lock/unlock&quot;);
2322 }
2323 
2324 
2325 // -----------------------------------------------------------------------------
2326 // Verification
2327 
2328 class VerifyOopsClosure: public OopClosure {
2329   nmethod* _nm;
2330   bool     _ok;
2331 public:
2332   VerifyOopsClosure(nmethod* nm) : _nm(nm), _ok(true) { }
2333   bool ok() { return _ok; }
2334   virtual void do_oop(oop* p) {
2335     if (oopDesc::is_oop_or_null(*p)) return;
2336     // Print diagnostic information before calling print_nmethod().
2337     // Assertions therein might prevent call from returning.
2338     tty-&gt;print_cr(&quot;*** non-oop &quot; PTR_FORMAT &quot; found at &quot; PTR_FORMAT &quot; (offset %d)&quot;,
2339                   p2i(*p), p2i(p), (int)((intptr_t)p - (intptr_t)_nm));
2340     if (_ok) {
2341       _nm-&gt;print_nmethod(true);
2342       _ok = false;
2343     }
2344   }
2345   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
2346 };
2347 
2348 class VerifyMetadataClosure: public MetadataClosure {
2349  public:
2350   void do_metadata(Metadata* md) {
2351     if (md-&gt;is_method()) {
2352       Method* method = (Method*)md;
2353       assert(!method-&gt;is_old(), &quot;Should not be installing old methods&quot;);
2354     }
2355   }
2356 };
2357 
2358 
2359 void nmethod::verify() {
2360 
2361   // Hmm. OSR methods can be deopted but not marked as zombie or not_entrant
2362   // seems odd.
2363 
2364   if (is_zombie() || is_not_entrant() || is_unloaded())
2365     return;
2366 
2367   // Make sure all the entry points are correctly aligned for patching.
2368   NativeJump::check_verified_entry_alignment(entry_point(), verified_entry_point());
2369 
2370   // assert(oopDesc::is_oop(method()), &quot;must be valid&quot;);
2371 
2372   ResourceMark rm;
2373 
2374   if (!CodeCache::contains(this)) {
2375     fatal(&quot;nmethod at &quot; INTPTR_FORMAT &quot; not in zone&quot;, p2i(this));
2376   }
2377 
2378   if(is_native_method() )
2379     return;
2380 
2381   nmethod* nm = CodeCache::find_nmethod(verified_entry_point());
2382   if (nm != this) {
2383     fatal(&quot;findNMethod did not find this nmethod (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
2384   }
2385 
2386   for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {
2387     if (! p-&gt;verify(this)) {
2388       tty-&gt;print_cr(&quot;\t\tin nmethod at &quot; INTPTR_FORMAT &quot; (pcs)&quot;, p2i(this));
2389     }
2390   }
2391 
2392 #ifdef ASSERT
2393 #if INCLUDE_JVMCI
2394   {
2395     // Verify that implicit exceptions that deoptimize have a PcDesc and OopMap
2396     ImmutableOopMapSet* oms = oop_maps();
2397     ImplicitExceptionTable implicit_table(this);
2398     for (uint i = 0; i &lt; implicit_table.len(); i++) {
2399       int exec_offset = (int) implicit_table.get_exec_offset(i);
2400       if (implicit_table.get_exec_offset(i) == implicit_table.get_cont_offset(i)) {
2401         assert(pc_desc_at(code_begin() + exec_offset) != NULL, &quot;missing PcDesc&quot;);
2402         bool found = false;
2403         for (int i = 0, imax = oms-&gt;count(); i &lt; imax; i++) {
2404           if (oms-&gt;pair_at(i)-&gt;pc_offset() == exec_offset) {
2405             found = true;
2406             break;
2407           }
2408         }
2409         assert(found, &quot;missing oopmap&quot;);
2410       }
2411     }
2412   }
2413 #endif
2414 #endif
2415 
2416   VerifyOopsClosure voc(this);
2417   oops_do(&amp;voc);
2418   assert(voc.ok(), &quot;embedded oops must be OK&quot;);
2419   Universe::heap()-&gt;verify_nmethod(this);
2420 
2421   assert(_oops_do_mark_link == NULL, &quot;_oops_do_mark_link for %s should be NULL but is &quot; PTR_FORMAT,
2422          nm-&gt;method()-&gt;external_name(), p2i(_oops_do_mark_link));
2423   verify_scopes();
2424 
2425   CompiledICLocker nm_verify(this);
2426   VerifyMetadataClosure vmc;
2427   metadata_do(&amp;vmc);
2428 }
2429 
2430 
2431 void nmethod::verify_interrupt_point(address call_site) {
2432   // Verify IC only when nmethod installation is finished.
2433   if (!is_not_installed()) {
2434     if (CompiledICLocker::is_safe(this)) {
2435       CompiledIC_at(this, call_site);
2436     } else {
2437       CompiledICLocker ml_verify(this);
2438       CompiledIC_at(this, call_site);
2439     }
2440   }
2441 
2442   PcDesc* pd = pc_desc_at(nativeCall_at(call_site)-&gt;return_address());
2443   assert(pd != NULL, &quot;PcDesc must exist&quot;);
2444   for (ScopeDesc* sd = new ScopeDesc(this, pd-&gt;scope_decode_offset(),
2445                                      pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
2446                                      pd-&gt;return_oop(), pd-&gt;return_vt());
2447        !sd-&gt;is_top(); sd = sd-&gt;sender()) {
2448     sd-&gt;verify();
2449   }
2450 }
2451 
2452 void nmethod::verify_scopes() {
2453   if( !method() ) return;       // Runtime stubs have no scope
2454   if (method()-&gt;is_native()) return; // Ignore stub methods.
2455   // iterate through all interrupt point
2456   // and verify the debug information is valid.
2457   RelocIterator iter((nmethod*)this);
2458   while (iter.next()) {
2459     address stub = NULL;
2460     switch (iter.type()) {
2461       case relocInfo::virtual_call_type:
2462         verify_interrupt_point(iter.addr());
2463         break;
2464       case relocInfo::opt_virtual_call_type:
2465         stub = iter.opt_virtual_call_reloc()-&gt;static_stub(false);
2466         verify_interrupt_point(iter.addr());
2467         break;
2468       case relocInfo::static_call_type:
2469         stub = iter.static_call_reloc()-&gt;static_stub(false);
2470         //verify_interrupt_point(iter.addr());
2471         break;
2472       case relocInfo::runtime_call_type:
2473       case relocInfo::runtime_call_w_cp_type: {
2474         address destination = iter.reloc()-&gt;value();
2475         // Right now there is no way to find out which entries support
2476         // an interrupt point.  It would be nice if we had this
2477         // information in a table.
2478         break;
2479       }
2480       default:
2481         break;
2482     }
2483     assert(stub == NULL || stub_contains(stub), &quot;static call stub outside stub section&quot;);
2484   }
2485 }
2486 
2487 
2488 // -----------------------------------------------------------------------------
2489 // Printing operations
2490 
2491 void nmethod::print() const {
2492   ttyLocker ttyl;   // keep the following output all in one block
2493   print(tty);
2494 }
2495 
2496 void nmethod::print(outputStream* st) const {
2497   ResourceMark rm;
2498 
2499   st-&gt;print(&quot;Compiled method &quot;);
2500 
2501   if (is_compiled_by_c1()) {
2502     st-&gt;print(&quot;(c1) &quot;);
2503   } else if (is_compiled_by_c2()) {
2504     st-&gt;print(&quot;(c2) &quot;);
2505   } else if (is_compiled_by_jvmci()) {
2506     st-&gt;print(&quot;(JVMCI) &quot;);
2507   } else {
2508     st-&gt;print(&quot;(n/a) &quot;);
2509   }
2510 
2511   print_on(tty, NULL);
2512 
2513   if (WizardMode) {
2514     st-&gt;print(&quot;((nmethod*) &quot; INTPTR_FORMAT &quot;) &quot;, p2i(this));
2515     st-&gt;print(&quot; for method &quot; INTPTR_FORMAT , p2i(method()));
2516     st-&gt;print(&quot; { &quot;);
2517     st-&gt;print_cr(&quot;%s &quot;, state());
2518     st-&gt;print_cr(&quot;}:&quot;);
2519   }
2520   if (size              () &gt; 0) st-&gt;print_cr(&quot; total in heap  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2521                                              p2i(this),
2522                                              p2i(this) + size(),
2523                                              size());
2524   if (relocation_size   () &gt; 0) st-&gt;print_cr(&quot; relocation     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2525                                              p2i(relocation_begin()),
2526                                              p2i(relocation_end()),
2527                                              relocation_size());
2528   if (consts_size       () &gt; 0) st-&gt;print_cr(&quot; constants      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2529                                              p2i(consts_begin()),
2530                                              p2i(consts_end()),
2531                                              consts_size());
2532   if (insts_size        () &gt; 0) st-&gt;print_cr(&quot; main code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2533                                              p2i(insts_begin()),
2534                                              p2i(insts_end()),
2535                                              insts_size());
2536   if (stub_size         () &gt; 0) st-&gt;print_cr(&quot; stub code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2537                                              p2i(stub_begin()),
2538                                              p2i(stub_end()),
2539                                              stub_size());
2540   if (oops_size         () &gt; 0) st-&gt;print_cr(&quot; oops           [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2541                                              p2i(oops_begin()),
2542                                              p2i(oops_end()),
2543                                              oops_size());
2544   if (metadata_size     () &gt; 0) st-&gt;print_cr(&quot; metadata       [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2545                                              p2i(metadata_begin()),
2546                                              p2i(metadata_end()),
2547                                              metadata_size());
2548   if (scopes_data_size  () &gt; 0) st-&gt;print_cr(&quot; scopes data    [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2549                                              p2i(scopes_data_begin()),
2550                                              p2i(scopes_data_end()),
2551                                              scopes_data_size());
2552   if (scopes_pcs_size   () &gt; 0) st-&gt;print_cr(&quot; scopes pcs     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2553                                              p2i(scopes_pcs_begin()),
2554                                              p2i(scopes_pcs_end()),
2555                                              scopes_pcs_size());
2556   if (dependencies_size () &gt; 0) st-&gt;print_cr(&quot; dependencies   [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2557                                              p2i(dependencies_begin()),
2558                                              p2i(dependencies_end()),
2559                                              dependencies_size());
2560   if (handler_table_size() &gt; 0) st-&gt;print_cr(&quot; handler table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2561                                              p2i(handler_table_begin()),
2562                                              p2i(handler_table_end()),
2563                                              handler_table_size());
2564   if (nul_chk_table_size() &gt; 0) st-&gt;print_cr(&quot; nul chk table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2565                                              p2i(nul_chk_table_begin()),
2566                                              p2i(nul_chk_table_end()),
2567                                              nul_chk_table_size());
2568 #if INCLUDE_JVMCI
2569   if (speculations_size () &gt; 0) st-&gt;print_cr(&quot; speculations   [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2570                                              p2i(speculations_begin()),
2571                                              p2i(speculations_end()),
2572                                              speculations_size());
2573   if (jvmci_data_size   () &gt; 0) st-&gt;print_cr(&quot; JVMCI data     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,
2574                                              p2i(jvmci_data_begin()),
2575                                              p2i(jvmci_data_end()),
2576                                              jvmci_data_size());
2577 #endif
2578 }
2579 
2580 void nmethod::print_code() {
2581   HandleMark hm;
2582   ResourceMark m;
2583   ttyLocker ttyl;
2584   // Call the specialized decode method of this class.
2585   decode(tty);
2586 }
2587 
2588 #ifndef PRODUCT  // called InstanceKlass methods are available only then. Declared as PRODUCT_RETURN
2589 
2590 void nmethod::print_dependencies() {
2591   ResourceMark rm;
2592   ttyLocker ttyl;   // keep the following output all in one block
2593   tty-&gt;print_cr(&quot;Dependencies:&quot;);
2594   for (Dependencies::DepStream deps(this); deps.next(); ) {
2595     deps.print_dependency();
2596     Klass* ctxk = deps.context_type();
2597     if (ctxk != NULL) {
2598       if (ctxk-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(ctxk)-&gt;is_dependent_nmethod(this)) {
2599         tty-&gt;print_cr(&quot;   [nmethod&lt;=klass]%s&quot;, ctxk-&gt;external_name());
2600       }
2601     }
2602     deps.log_dependency();  // put it into the xml log also
2603   }
2604 }
2605 #endif
2606 
2607 #if defined(SUPPORT_DATA_STRUCTS)
2608 
2609 // Print the oops from the underlying CodeBlob.
2610 void nmethod::print_oops(outputStream* st) {
2611   HandleMark hm;
2612   ResourceMark m;
2613   st-&gt;print(&quot;Oops:&quot;);
2614   if (oops_begin() &lt; oops_end()) {
2615     st-&gt;cr();
2616     for (oop* p = oops_begin(); p &lt; oops_end(); p++) {
2617       Disassembler::print_location((unsigned char*)p, (unsigned char*)oops_begin(), (unsigned char*)oops_end(), st, true, false);
2618       st-&gt;print(PTR_FORMAT &quot; &quot;, *((uintptr_t*)p));
2619       if (*p == Universe::non_oop_word()) {
2620         st-&gt;print_cr(&quot;NON_OOP&quot;);
2621         continue;  // skip non-oops
2622       }
2623       if (*p == NULL) {
2624         st-&gt;print_cr(&quot;NULL-oop&quot;);
2625         continue;  // skip non-oops
2626       }
2627       (*p)-&gt;print_value_on(st);
2628       st-&gt;cr();
2629     }
2630   } else {
2631     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);
2632   }
2633 }
2634 
2635 // Print metadata pool.
2636 void nmethod::print_metadata(outputStream* st) {
2637   HandleMark hm;
2638   ResourceMark m;
2639   st-&gt;print(&quot;Metadata:&quot;);
2640   if (metadata_begin() &lt; metadata_end()) {
2641     st-&gt;cr();
2642     for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
2643       Disassembler::print_location((unsigned char*)p, (unsigned char*)metadata_begin(), (unsigned char*)metadata_end(), st, true, false);
2644       st-&gt;print(PTR_FORMAT &quot; &quot;, *((uintptr_t*)p));
2645       if (*p &amp;&amp; *p != Universe::non_oop_word()) {
2646         (*p)-&gt;print_value_on(st);
2647       }
2648       st-&gt;cr();
2649     }
2650   } else {
2651     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);
2652   }
2653 }
2654 
2655 #ifndef PRODUCT  // ScopeDesc::print_on() is available only then. Declared as PRODUCT_RETURN
2656 void nmethod::print_scopes_on(outputStream* st) {
2657   // Find the first pc desc for all scopes in the code and print it.
2658   ResourceMark rm;
2659   st-&gt;print(&quot;scopes:&quot;);
2660   if (scopes_pcs_begin() &lt; scopes_pcs_end()) {
2661     st-&gt;cr();
2662     for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {
2663       if (p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null)
2664         continue;
2665 
2666       ScopeDesc* sd = scope_desc_at(p-&gt;real_pc(this));
2667       while (sd != NULL) {
2668         sd-&gt;print_on(st, p);  // print output ends with a newline
2669         sd = sd-&gt;sender();
2670       }
2671     }
2672   } else {
2673     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);
2674   }
2675 }
2676 #endif
2677 
2678 #ifndef PRODUCT  // RelocIterator does support printing only then.
2679 void nmethod::print_relocations() {
2680   ResourceMark m;       // in case methods get printed via the debugger
2681   tty-&gt;print_cr(&quot;relocations:&quot;);
2682   RelocIterator iter(this);
2683   iter.print();
2684 }
2685 #endif
2686 
2687 void nmethod::print_pcs_on(outputStream* st) {
2688   ResourceMark m;       // in case methods get printed via debugger
2689   st-&gt;print(&quot;pc-bytecode offsets:&quot;);
2690   if (scopes_pcs_begin() &lt; scopes_pcs_end()) {
2691     st-&gt;cr();
2692     for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {
2693       p-&gt;print_on(st, this);  // print output ends with a newline
2694     }
2695   } else {
2696     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);
2697   }
2698 }
2699 
2700 void nmethod::print_handler_table() {
2701   ExceptionHandlerTable(this).print();
2702 }
2703 
2704 void nmethod::print_nul_chk_table() {
2705   ImplicitExceptionTable(this).print(code_begin());
2706 }
2707 
2708 void nmethod::print_recorded_oops() {
2709   const int n = oops_count();
2710   const int log_n = (n&lt;10) ? 1 : (n&lt;100) ? 2 : (n&lt;1000) ? 3 : (n&lt;10000) ? 4 : 6;
2711   tty-&gt;print(&quot;Recorded oops:&quot;);
2712   if (n &gt; 0) {
2713     tty-&gt;cr();
2714     for (int i = 0; i &lt; n; i++) {
2715       oop o = oop_at(i);
2716       tty-&gt;print(&quot;#%*d: &quot; INTPTR_FORMAT &quot; &quot;, log_n, i, p2i(o));
2717       if (o == (oop)Universe::non_oop_word()) {
2718         tty-&gt;print(&quot;non-oop word&quot;);
2719       } else if (o == NULL) {
2720         tty-&gt;print(&quot;NULL-oop&quot;);
2721       } else {
2722         o-&gt;print_value_on(tty);
2723       }
2724       tty-&gt;cr();
2725     }
2726   } else {
2727     tty-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);
2728   }
2729 }
2730 
2731 void nmethod::print_recorded_metadata() {
2732   const int n = metadata_count();
2733   const int log_n = (n&lt;10) ? 1 : (n&lt;100) ? 2 : (n&lt;1000) ? 3 : (n&lt;10000) ? 4 : 6;
2734   tty-&gt;print(&quot;Recorded metadata:&quot;);
2735   if (n &gt; 0) {
2736     tty-&gt;cr();
2737     for (int i = 0; i &lt; n; i++) {
2738       Metadata* m = metadata_at(i);
2739       tty-&gt;print(&quot;#%*d: &quot; INTPTR_FORMAT &quot; &quot;, log_n, i, p2i(m));
2740       if (m == (Metadata*)Universe::non_oop_word()) {
2741         tty-&gt;print(&quot;non-metadata word&quot;);
2742       } else if (m == NULL) {
2743         tty-&gt;print(&quot;NULL-oop&quot;);
2744       } else {
2745         Metadata::print_value_on_maybe_null(tty, m);
2746       }
2747       tty-&gt;cr();
2748     }
2749   } else {
2750     tty-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);
2751   }
2752 }
2753 #endif
2754 
2755 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)
2756 
2757 void nmethod::print_constant_pool(outputStream* st) {
2758   //-----------------------------------
2759   //---&lt;  Print the constant pool  &gt;---
2760   //-----------------------------------
2761   int consts_size = this-&gt;consts_size();
2762   if ( consts_size &gt; 0 ) {
2763     unsigned char* cstart = this-&gt;consts_begin();
2764     unsigned char* cp     = cstart;
2765     unsigned char* cend   = cp + consts_size;
2766     unsigned int   bytes_per_line = 4;
2767     unsigned int   CP_alignment   = 8;
2768     unsigned int   n;
2769 
2770     st-&gt;cr();
2771 
2772     //---&lt;  print CP header to make clear what&#39;s printed  &gt;---
2773     if( ((uintptr_t)cp&amp;(CP_alignment-1)) == 0 ) {
2774       n = bytes_per_line;
2775       st-&gt;print_cr(&quot;[Constant Pool]&quot;);
2776       Disassembler::print_location(cp, cstart, cend, st, true, true);
2777       Disassembler::print_hexdata(cp, n, st, true);
2778       st-&gt;cr();
2779     } else {
2780       n = (uintptr_t)cp&amp;(bytes_per_line-1);
2781       st-&gt;print_cr(&quot;[Constant Pool (unaligned)]&quot;);
2782     }
2783 
2784     //---&lt;  print CP contents, bytes_per_line at a time  &gt;---
2785     while (cp &lt; cend) {
2786       Disassembler::print_location(cp, cstart, cend, st, true, false);
2787       Disassembler::print_hexdata(cp, n, st, false);
2788       cp += n;
2789       n   = bytes_per_line;
2790       st-&gt;cr();
2791     }
2792 
2793     //---&lt;  Show potential alignment gap between constant pool and code  &gt;---
2794     cend = code_begin();
2795     if( cp &lt; cend ) {
2796       n = 4;
2797       st-&gt;print_cr(&quot;[Code entry alignment]&quot;);
2798       while (cp &lt; cend) {
2799         Disassembler::print_location(cp, cstart, cend, st, false, false);
2800         cp += n;
2801         st-&gt;cr();
2802       }
2803     }
2804   } else {
2805     st-&gt;print_cr(&quot;[Constant Pool (empty)]&quot;);
2806   }
2807   st-&gt;cr();
2808 }
2809 
2810 #endif
2811 
2812 // Disassemble this nmethod.
2813 // Print additional debug information, if requested. This could be code
2814 // comments, block comments, profiling counters, etc.
2815 // The undisassembled format is useful no disassembler library is available.
2816 // The resulting hex dump (with markers) can be disassembled later, or on
2817 // another system, when/where a disassembler library is available.
2818 void nmethod::decode2(outputStream* ost) const {
2819 
2820   // Called from frame::back_trace_with_decode without ResourceMark.
2821   ResourceMark rm;
2822 
2823   // Make sure we have a valid stream to print on.
2824   outputStream* st = ost ? ost : tty;
2825 
2826 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) &amp;&amp; ! defined(SUPPORT_ASSEMBLY)
2827   const bool use_compressed_format    = true;
2828   const bool compressed_with_comments = use_compressed_format &amp;&amp; (AbstractDisassembler::show_comment() ||
2829                                                                   AbstractDisassembler::show_block_comment());
2830 #else
2831   const bool use_compressed_format    = Disassembler::is_abstract();
2832   const bool compressed_with_comments = use_compressed_format &amp;&amp; (AbstractDisassembler::show_comment() ||
2833                                                                   AbstractDisassembler::show_block_comment());
2834 #endif
2835 
2836   st-&gt;cr();
2837   this-&gt;print(st);
2838   st-&gt;cr();
2839 
2840 #if defined(SUPPORT_ASSEMBLY)
2841   //----------------------------------
2842   //---&lt;  Print real disassembly  &gt;---
2843   //----------------------------------
2844   if (! use_compressed_format) {
2845     Disassembler::decode(const_cast&lt;nmethod*&gt;(this), st);
2846     return;
2847   }
2848 #endif
2849 
2850 #if defined(SUPPORT_ABSTRACT_ASSEMBLY)
2851 
2852   // Compressed undisassembled disassembly format.
2853   // The following stati are defined/supported:
2854   //   = 0 - currently at bol() position, nothing printed yet on current line.
2855   //   = 1 - currently at position after print_location().
2856   //   &gt; 1 - in the midst of printing instruction stream bytes.
2857   int        compressed_format_idx    = 0;
2858   int        code_comment_column      = 0;
2859   const int  instr_maxlen             = Assembler::instr_maxlen();
2860   const uint tabspacing               = 8;
2861   unsigned char* start = this-&gt;code_begin();
2862   unsigned char* p     = this-&gt;code_begin();
2863   unsigned char* end   = this-&gt;code_end();
2864   unsigned char* pss   = p; // start of a code section (used for offsets)
2865 
2866   if ((start == NULL) || (end == NULL)) {
2867     st-&gt;print_cr(&quot;PrintAssembly not possible due to uninitialized section pointers&quot;);
2868     return;
2869   }
2870 #endif
2871 
2872 #if defined(SUPPORT_ABSTRACT_ASSEMBLY)
2873   //---&lt;  plain abstract disassembly, no comments or anything, just section headers  &gt;---
2874   if (use_compressed_format &amp;&amp; ! compressed_with_comments) {
2875     const_cast&lt;nmethod*&gt;(this)-&gt;print_constant_pool(st);
2876 
2877     //---&lt;  Open the output (Marker for post-mortem disassembler)  &gt;---
2878     st-&gt;print_cr(&quot;[MachCode]&quot;);
2879     const char* header = NULL;
2880     address p0 = p;
2881     while (p &lt; end) {
2882       address pp = p;
2883       while ((p &lt; end) &amp;&amp; (header == NULL)) {
2884         header = nmethod_section_label(p);
2885         pp  = p;
2886         p  += Assembler::instr_len(p);
2887       }
2888       if (pp &gt; p0) {
2889         AbstractDisassembler::decode_range_abstract(p0, pp, start, end, st, Assembler::instr_maxlen());
2890         p0 = pp;
2891         p  = pp;
2892         header = NULL;
2893       } else if (header != NULL) {
2894         st-&gt;bol();
2895         st-&gt;print_cr(&quot;%s&quot;, header);
2896         header = NULL;
2897       }
2898     }
2899     //---&lt;  Close the output (Marker for post-mortem disassembler)  &gt;---
2900     st-&gt;bol();
2901     st-&gt;print_cr(&quot;[/MachCode]&quot;);
2902     return;
2903   }
2904 #endif
2905 
2906 #if defined(SUPPORT_ABSTRACT_ASSEMBLY)
2907   //---&lt;  abstract disassembly with comments and section headers merged in  &gt;---
2908   if (compressed_with_comments) {
2909     const_cast&lt;nmethod*&gt;(this)-&gt;print_constant_pool(st);
2910 
2911     //---&lt;  Open the output (Marker for post-mortem disassembler)  &gt;---
2912     st-&gt;print_cr(&quot;[MachCode]&quot;);
2913     while ((p &lt; end) &amp;&amp; (p != NULL)) {
2914       const int instruction_size_in_bytes = Assembler::instr_len(p);
2915 
2916       //---&lt;  Block comments for nmethod. Interrupts instruction stream, if any.  &gt;---
2917       // Outputs a bol() before and a cr() after, but only if a comment is printed.
2918       // Prints nmethod_section_label as well.
2919       if (AbstractDisassembler::show_block_comment()) {
2920         print_block_comment(st, p);
2921         if (st-&gt;position() == 0) {
2922           compressed_format_idx = 0;
2923         }
2924       }
2925 
2926       //---&lt;  New location information after line break  &gt;---
2927       if (compressed_format_idx == 0) {
2928         code_comment_column   = Disassembler::print_location(p, pss, end, st, false, false);
2929         compressed_format_idx = 1;
2930       }
2931 
2932       //---&lt;  Code comment for current instruction. Address range [p..(p+len))  &gt;---
2933       unsigned char* p_end = p + (ssize_t)instruction_size_in_bytes;
2934       S390_ONLY(if (p_end &gt; end) p_end = end;) // avoid getting past the end
2935 
2936       if (AbstractDisassembler::show_comment() &amp;&amp; const_cast&lt;nmethod*&gt;(this)-&gt;has_code_comment(p, p_end)) {
2937         //---&lt;  interrupt instruction byte stream for code comment  &gt;---
2938         if (compressed_format_idx &gt; 1) {
2939           st-&gt;cr();  // interrupt byte stream
2940           st-&gt;cr();  // add an empty line
2941           code_comment_column = Disassembler::print_location(p, pss, end, st, false, false);
2942         }
2943         const_cast&lt;nmethod*&gt;(this)-&gt;print_code_comment_on(st, code_comment_column, p, p_end );
2944         st-&gt;bol();
2945         compressed_format_idx = 0;
2946       }
2947 
2948       //---&lt;  New location information after line break  &gt;---
2949       if (compressed_format_idx == 0) {
2950         code_comment_column   = Disassembler::print_location(p, pss, end, st, false, false);
2951         compressed_format_idx = 1;
2952       }
2953 
2954       //---&lt;  Nicely align instructions for readability  &gt;---
2955       if (compressed_format_idx &gt; 1) {
2956         Disassembler::print_delimiter(st);
2957       }
2958 
2959       //---&lt;  Now, finally, print the actual instruction bytes  &gt;---
2960       unsigned char* p0 = p;
2961       p = Disassembler::decode_instruction_abstract(p, st, instruction_size_in_bytes, instr_maxlen);
2962       compressed_format_idx += p - p0;
2963 
2964       if (Disassembler::start_newline(compressed_format_idx-1)) {
2965         st-&gt;cr();
2966         compressed_format_idx = 0;
2967       }
2968     }
2969     //---&lt;  Close the output (Marker for post-mortem disassembler)  &gt;---
2970     st-&gt;bol();
2971     st-&gt;print_cr(&quot;[/MachCode]&quot;);
2972     return;
2973   }
2974 #endif
2975 }
2976 
2977 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)
2978 
2979 const char* nmethod::reloc_string_for(u_char* begin, u_char* end) {
2980   RelocIterator iter(this, begin, end);
2981   bool have_one = false;
2982   while (iter.next()) {
2983     have_one = true;
2984     switch (iter.type()) {
2985         case relocInfo::none:                  return &quot;no_reloc&quot;;
2986         case relocInfo::oop_type: {
2987           // Get a non-resizable resource-allocated stringStream.
2988           // Our callees make use of (nested) ResourceMarks.
2989           stringStream st(NEW_RESOURCE_ARRAY(char, 1024), 1024);
2990           oop_Relocation* r = iter.oop_reloc();
2991           oop obj = r-&gt;oop_value();
2992           st.print(&quot;oop(&quot;);
2993           if (obj == NULL) st.print(&quot;NULL&quot;);
2994           else obj-&gt;print_value_on(&amp;st);
2995           st.print(&quot;)&quot;);
2996           return st.as_string();
2997         }
2998         case relocInfo::metadata_type: {
2999           stringStream st;
3000           metadata_Relocation* r = iter.metadata_reloc();
3001           Metadata* obj = r-&gt;metadata_value();
3002           st.print(&quot;metadata(&quot;);
3003           if (obj == NULL) st.print(&quot;NULL&quot;);
3004           else obj-&gt;print_value_on(&amp;st);
3005           st.print(&quot;)&quot;);
3006           return st.as_string();
3007         }
3008         case relocInfo::runtime_call_type:
3009         case relocInfo::runtime_call_w_cp_type: {
3010           stringStream st;
3011           st.print(&quot;runtime_call&quot;);
3012           CallRelocation* r = (CallRelocation*)iter.reloc();
3013           address dest = r-&gt;destination();
3014           CodeBlob* cb = CodeCache::find_blob(dest);
3015           if (cb != NULL) {
3016             st.print(&quot; %s&quot;, cb-&gt;name());
3017           } else {
3018             ResourceMark rm;
3019             const int buflen = 1024;
3020             char* buf = NEW_RESOURCE_ARRAY(char, buflen);
3021             int offset;
3022             if (os::dll_address_to_function_name(dest, buf, buflen, &amp;offset)) {
3023               st.print(&quot; %s&quot;, buf);
3024               if (offset != 0) {
3025                 st.print(&quot;+%d&quot;, offset);
3026               }
3027             }
3028           }
3029           return st.as_string();
3030         }
3031         case relocInfo::virtual_call_type: {
3032           stringStream st;
3033           st.print_raw(&quot;virtual_call&quot;);
3034           virtual_call_Relocation* r = iter.virtual_call_reloc();
3035           Method* m = r-&gt;method_value();
3036           if (m != NULL) {
3037             assert(m-&gt;is_method(), &quot;&quot;);
3038             m-&gt;print_short_name(&amp;st);
3039           }
3040           return st.as_string();
3041         }
3042         case relocInfo::opt_virtual_call_type: {
3043           stringStream st;
3044           st.print_raw(&quot;optimized virtual_call&quot;);
3045           opt_virtual_call_Relocation* r = iter.opt_virtual_call_reloc();
3046           Method* m = r-&gt;method_value();
3047           if (m != NULL) {
3048             assert(m-&gt;is_method(), &quot;&quot;);
3049             m-&gt;print_short_name(&amp;st);
3050           }
3051           return st.as_string();
3052         }
3053         case relocInfo::static_call_type: {
3054           stringStream st;
3055           st.print_raw(&quot;static_call&quot;);
3056           static_call_Relocation* r = iter.static_call_reloc();
3057           Method* m = r-&gt;method_value();
3058           if (m != NULL) {
3059             assert(m-&gt;is_method(), &quot;&quot;);
3060             m-&gt;print_short_name(&amp;st);
3061           }
3062           return st.as_string();
3063         }
3064         case relocInfo::static_stub_type:      return &quot;static_stub&quot;;
3065         case relocInfo::external_word_type:    return &quot;external_word&quot;;
3066         case relocInfo::internal_word_type:    return &quot;internal_word&quot;;
3067         case relocInfo::section_word_type:     return &quot;section_word&quot;;
3068         case relocInfo::poll_type:             return &quot;poll&quot;;
3069         case relocInfo::poll_return_type:      return &quot;poll_return&quot;;
3070         case relocInfo::trampoline_stub_type:  return &quot;trampoline_stub&quot;;
3071         case relocInfo::type_mask:             return &quot;type_bit_mask&quot;;
3072 
3073         default:
3074           break;
3075     }
3076   }
3077   return have_one ? &quot;other&quot; : NULL;
3078 }
3079 
3080 // Return a the last scope in (begin..end]
3081 ScopeDesc* nmethod::scope_desc_in(address begin, address end) {
3082   PcDesc* p = pc_desc_near(begin+1);
3083   if (p != NULL &amp;&amp; p-&gt;real_pc(this) &lt;= end) {
3084     return new ScopeDesc(this, p-&gt;scope_decode_offset(),
3085                          p-&gt;obj_decode_offset(), p-&gt;should_reexecute(), p-&gt;rethrow_exception(),
3086                          p-&gt;return_oop(), p-&gt;return_vt());
3087   }
3088   return NULL;
3089 }
3090 
3091 const char* nmethod::nmethod_section_label(address pos) const {
3092   const char* label = NULL;
3093   if (pos == code_begin())                                              label = &quot;[Instructions begin]&quot;;
3094   if (pos == entry_point())                                             label = &quot;[Entry Point]&quot;;
<a name="3" id="anc3"></a><span class="line-modified">3095   if (pos == inline_entry_point())                                      label = &quot;[Inline Entry Point]&quot;;</span>
3096   if (pos == verified_entry_point())                                    label = &quot;[Verified Entry Point]&quot;;
<a name="4" id="anc4"></a><span class="line-modified">3097   if (pos == verified_inline_entry_point())                             label = &quot;[Verified Inline Entry Point]&quot;;</span>
<span class="line-modified">3098   if (pos == verified_inline_ro_entry_point())                          label = &quot;[Verified Inline Entry Point (RO)]&quot;;</span>
3099   if (has_method_handle_invokes() &amp;&amp; (pos == deopt_mh_handler_begin())) label = &quot;[Deopt MH Handler Code]&quot;;
3100   if (pos == consts_begin() &amp;&amp; pos != insts_begin())                    label = &quot;[Constants]&quot;;
3101   // Check stub_code before checking exception_handler or deopt_handler.
3102   if (pos == this-&gt;stub_begin())                                        label = &quot;[Stub Code]&quot;;
3103   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) pos == exception_begin())           label = &quot;[Exception Handler]&quot;;
3104   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) pos == deopt_handler_begin()) label = &quot;[Deopt Handler Code]&quot;;
3105   return label;
3106 }
3107 
3108 static int maybe_print_entry_label(outputStream* stream, address pos, address entry, const char* label) {
3109   if (pos == entry) {
3110     stream-&gt;bol();
3111     stream-&gt;print_cr(&quot;%s&quot;, label);
3112     return 1;
3113   } else {
3114     return 0;
3115   }
3116 }
3117 
3118 void nmethod::print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels) const {
3119   if (print_section_labels) {
3120     int n = 0;
3121     // Multiple entry points may be at the same position. Print them all.
<a name="5" id="anc5"></a><span class="line-modified">3122     n += maybe_print_entry_label(stream, block_begin, entry_point(),                    &quot;[Entry Point]&quot;);</span>
<span class="line-modified">3123     n += maybe_print_entry_label(stream, block_begin, inline_entry_point(),             &quot;[Inline Entry Point]&quot;);</span>
<span class="line-modified">3124     n += maybe_print_entry_label(stream, block_begin, verified_entry_point(),           &quot;[Verified Entry Point]&quot;);</span>
<span class="line-modified">3125     n += maybe_print_entry_label(stream, block_begin, verified_inline_entry_point(),    &quot;[Verified Inline Entry Point]&quot;);</span>
<span class="line-modified">3126     n += maybe_print_entry_label(stream, block_begin, verified_inline_ro_entry_point(), &quot;[Verified Inline Entry Point (RO)]&quot;);</span>
3127     if (n == 0) {
3128       const char* label = nmethod_section_label(block_begin);
3129       if (label != NULL) {
3130         stream-&gt;bol();
3131         stream-&gt;print_cr(&quot;%s&quot;, label);
3132       }
3133     }
3134   }
3135 
3136   if (_nmethod_to_print != this) {
3137     return;
3138   }
3139   Method* m = method();
3140   if (m == NULL || is_osr_method()) {
3141     return;
3142   }
3143 
3144   // Print the name of the method (only once)
<a name="6" id="anc6"></a><span class="line-modified">3145   address low = MIN4(entry_point(), verified_entry_point(), verified_inline_entry_point(), verified_inline_ro_entry_point());</span>
<span class="line-modified">3146   low = MIN2(low, inline_entry_point());</span>
3147   assert(low != 0, &quot;sanity&quot;);
3148   if (block_begin == low) {
3149     stream-&gt;print(&quot;  # &quot;);
3150     m-&gt;print_value_on(stream);
3151     stream-&gt;cr();
3152   }
3153 
3154   // Print the arguments for the 3 types of verified entry points
3155   {
3156     const CompiledEntrySignature* ces = _nmethod_to_print_ces;
3157     const GrowableArray&lt;SigEntry&gt;* sig_cc;
3158     const VMRegPair* regs;
3159     if (block_begin == verified_entry_point()) {
3160       sig_cc = &amp;ces-&gt;sig_cc();
3161       regs = ces-&gt;regs_cc();
<a name="7" id="anc7"></a><span class="line-modified">3162     } else if (block_begin == verified_inline_entry_point()) {</span>
3163       sig_cc = &amp;ces-&gt;sig();
3164       regs = ces-&gt;regs();
<a name="8" id="anc8"></a><span class="line-modified">3165     } else if (block_begin == verified_inline_ro_entry_point()) {</span>
3166       sig_cc = &amp;ces-&gt;sig_cc_ro();
3167       regs = ces-&gt;regs_cc_ro();
3168     } else {
3169       return;
3170     }
3171 
3172     ResourceMark rm;
3173     int sizeargs = 0;
3174     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, 256);
3175     bool has_scalarized_args = ces-&gt;has_scalarized_args();
3176     TempNewSymbol sig = SigEntry::create_symbol(sig_cc);
3177     for (SignatureStream ss(sig); !ss.at_return_type(); ss.next()) {
3178       BasicType t = ss.type();
3179       sig_bt[sizeargs++] = t;
3180       if (type2size[t] == 2) {
3181         sig_bt[sizeargs++] = T_VOID;
3182       } else {
3183         assert(type2size[t] == 1, &quot;size is 1 or 2&quot;);
3184       }
3185     }
3186     bool has_this = !m-&gt;is_static();
<a name="9" id="anc9"></a><span class="line-modified">3187     if (ces-&gt;has_inline_recv() &amp;&amp; block_begin == verified_entry_point()) {</span>
3188       // &lt;this&gt; argument is scalarized for verified_entry_point()
3189       has_this = false;
3190     }
3191     const char* spname = &quot;sp&quot;; // make arch-specific?
3192     int stack_slot_offset = this-&gt;frame_size() * wordSize;
3193     int tab1 = 14, tab2 = 24;
3194     int sig_index = 0;
3195     int sig_index_cc = 0;
3196     int arg_index = has_this ? -1 : 0;
3197     bool did_old_sp = false;
3198     for (SignatureStream ss(sig); !ss.at_return_type(); ) {
3199       bool at_this = (arg_index == -1);
3200       bool at_old_sp = false;
3201       BasicType t = ss.type();
3202       assert(t == sig_bt[sig_index], &quot;sigs in sync&quot;);
3203       if (at_this) {
3204         stream-&gt;print(&quot;  # this: &quot;);
3205       } else {
3206         stream-&gt;print(&quot;  # parm%d: &quot;, arg_index);
3207       }
3208       stream-&gt;move_to(tab1);
3209       VMReg fst = regs[sig_index].first();
3210       VMReg snd = regs[sig_index].second();
3211       if (fst-&gt;is_reg()) {
3212         stream-&gt;print(&quot;%s&quot;, fst-&gt;name());
3213         if (snd-&gt;is_valid())  {
3214           stream-&gt;print(&quot;:%s&quot;, snd-&gt;name());
3215         }
3216       } else if (fst-&gt;is_stack()) {
3217         int offset = fst-&gt;reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;
3218         if (offset == stack_slot_offset)  at_old_sp = true;
3219         stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, offset);
3220       } else {
3221         stream-&gt;print(&quot;reg%d:%d??&quot;, (int)(intptr_t)fst, (int)(intptr_t)snd);
3222       }
3223       stream-&gt;print(&quot; &quot;);
3224       stream-&gt;move_to(tab2);
3225       stream-&gt;print(&quot;= &quot;);
3226       if (at_this) {
3227         m-&gt;method_holder()-&gt;print_value_on(stream);
3228       } else {
3229         bool did_name = false;
3230         if (ss.is_reference()) {
3231           Symbol* name = ss.as_symbol();
3232           name-&gt;print_value_on(stream);
3233           did_name = true;
3234         }
3235         if (!did_name)
3236           stream-&gt;print(&quot;%s&quot;, type2name(t));
3237       }
3238       if (has_scalarized_args) {
3239         while (!SigEntry::skip_value_delimiters(sig_cc, sig_index_cc)) {
3240           sig_index_cc++;
3241         }
3242         if (SigEntry::is_reserved_entry(sig_cc, sig_index_cc)) {
3243           stream-&gt;print(&quot; [RESERVED]&quot;);
3244         }
3245         sig_index_cc += type2size[t];
3246       }
3247       if (at_old_sp) {
3248         stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
3249         did_old_sp = true;
3250       }
3251       stream-&gt;cr();
3252       sig_index += type2size[t];
3253       arg_index += 1;
3254       ss.next();
3255     }
3256     if (!did_old_sp) {
3257       stream-&gt;print(&quot;  # &quot;);
3258       stream-&gt;move_to(tab1);
3259       stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, stack_slot_offset);
3260       stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
3261       stream-&gt;cr();
3262     }
3263   }
3264 }
3265 
3266 // Returns whether this nmethod has code comments.
3267 bool nmethod::has_code_comment(address begin, address end) {
3268   // scopes?
3269   ScopeDesc* sd  = scope_desc_in(begin, end);
3270   if (sd != NULL) return true;
3271 
3272   // relocations?
3273   const char* str = reloc_string_for(begin, end);
3274   if (str != NULL) return true;
3275 
3276   // implicit exceptions?
3277   int cont_offset = ImplicitExceptionTable(this).continuation_offset(begin - code_begin());
3278   if (cont_offset != 0) return true;
3279 
3280   return false;
3281 }
3282 
3283 void nmethod::print_code_comment_on(outputStream* st, int column, address begin, address end) {
3284   ImplicitExceptionTable implicit_table(this);
3285   int pc_offset = begin - code_begin();
3286   int cont_offset = implicit_table.continuation_offset(pc_offset);
3287   bool oop_map_required = false;
3288   if (cont_offset != 0) {
3289     st-&gt;move_to(column, 6, 0);
3290     if (pc_offset == cont_offset) {
3291       st-&gt;print(&quot;; implicit exception: deoptimizes&quot;);
3292       oop_map_required = true;
3293     } else {
3294       st-&gt;print(&quot;; implicit exception: dispatches to &quot; INTPTR_FORMAT, p2i(code_begin() + cont_offset));
3295     }
3296   }
3297 
3298   // Find an oopmap in (begin, end].  We use the odd half-closed
3299   // interval so that oop maps and scope descs which are tied to the
3300   // byte after a call are printed with the call itself.  OopMaps
3301   // associated with implicit exceptions are printed with the implicit
3302   // instruction.
3303   address base = code_begin();
3304   ImmutableOopMapSet* oms = oop_maps();
3305   if (oms != NULL) {
3306     for (int i = 0, imax = oms-&gt;count(); i &lt; imax; i++) {
3307       const ImmutableOopMapPair* pair = oms-&gt;pair_at(i);
3308       const ImmutableOopMap* om = pair-&gt;get_from(oms);
3309       address pc = base + pair-&gt;pc_offset();
3310       if (pc &gt;= begin) {
3311 #if INCLUDE_JVMCI
3312         bool is_implicit_deopt = implicit_table.continuation_offset(pair-&gt;pc_offset()) == (uint) pair-&gt;pc_offset();
3313 #else
3314         bool is_implicit_deopt = false;
3315 #endif
3316         if (is_implicit_deopt ? pc == begin : pc &gt; begin &amp;&amp; pc &lt;= end) {
3317           st-&gt;move_to(column, 6, 0);
3318           st-&gt;print(&quot;; &quot;);
3319           om-&gt;print_on(st);
3320           oop_map_required = false;
3321         }
3322       }
3323       if (pc &gt; end) {
3324         break;
3325       }
3326     }
3327   }
3328   assert(!oop_map_required, &quot;missed oopmap&quot;);
3329 
3330   Thread* thread = Thread::current();
3331 
3332   // Print any debug info present at this pc.
3333   ScopeDesc* sd  = scope_desc_in(begin, end);
3334   if (sd != NULL) {
3335     st-&gt;move_to(column, 6, 0);
3336     if (sd-&gt;bci() == SynchronizationEntryBCI) {
3337       st-&gt;print(&quot;;*synchronization entry&quot;);
3338     } else if (sd-&gt;bci() == AfterBci) {
3339       st-&gt;print(&quot;;* method exit (unlocked if synchronized)&quot;);
3340     } else if (sd-&gt;bci() == UnwindBci) {
3341       st-&gt;print(&quot;;* unwind (locked if synchronized)&quot;);
3342     } else if (sd-&gt;bci() == AfterExceptionBci) {
3343       st-&gt;print(&quot;;* unwind (unlocked if synchronized)&quot;);
3344     } else if (sd-&gt;bci() == UnknownBci) {
3345       st-&gt;print(&quot;;* unknown&quot;);
3346     } else if (sd-&gt;bci() == InvalidFrameStateBci) {
3347       st-&gt;print(&quot;;* invalid frame state&quot;);
3348     } else {
3349       if (sd-&gt;method() == NULL) {
3350         st-&gt;print(&quot;method is NULL&quot;);
3351       } else if (sd-&gt;method()-&gt;is_native()) {
3352         st-&gt;print(&quot;method is native&quot;);
3353       } else {
3354         Bytecodes::Code bc = sd-&gt;method()-&gt;java_code_at(sd-&gt;bci());
3355         st-&gt;print(&quot;;*%s&quot;, Bytecodes::name(bc));
3356         switch (bc) {
3357         case Bytecodes::_invokevirtual:
3358         case Bytecodes::_invokespecial:
3359         case Bytecodes::_invokestatic:
3360         case Bytecodes::_invokeinterface:
3361           {
3362             Bytecode_invoke invoke(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());
3363             st-&gt;print(&quot; &quot;);
3364             if (invoke.name() != NULL)
3365               invoke.name()-&gt;print_symbol_on(st);
3366             else
3367               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3368             break;
3369           }
3370         case Bytecodes::_getfield:
3371         case Bytecodes::_putfield:
3372         case Bytecodes::_getstatic:
3373         case Bytecodes::_putstatic:
3374           {
3375             Bytecode_field field(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());
3376             st-&gt;print(&quot; &quot;);
3377             if (field.name() != NULL)
3378               field.name()-&gt;print_symbol_on(st);
3379             else
3380               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3381           }
3382         default:
3383           break;
3384         }
3385       }
3386       st-&gt;print(&quot; {reexecute=%d rethrow=%d return_oop=%d return_vt=%d}&quot;, sd-&gt;should_reexecute(), sd-&gt;rethrow_exception(), sd-&gt;return_oop(), sd-&gt;return_vt());
3387     }
3388 
3389     // Print all scopes
3390     for (;sd != NULL; sd = sd-&gt;sender()) {
3391       st-&gt;move_to(column, 6, 0);
3392       st-&gt;print(&quot;; -&quot;);
3393       if (sd-&gt;should_reexecute()) {
3394         st-&gt;print(&quot; (reexecute)&quot;);
3395       }
3396       if (sd-&gt;method() == NULL) {
3397         st-&gt;print(&quot;method is NULL&quot;);
3398       } else {
3399         sd-&gt;method()-&gt;print_short_name(st);
3400       }
3401       int lineno = sd-&gt;method()-&gt;line_number_from_bci(sd-&gt;bci());
3402       if (lineno != -1) {
3403         st-&gt;print(&quot;@%d (line %d)&quot;, sd-&gt;bci(), lineno);
3404       } else {
3405         st-&gt;print(&quot;@%d&quot;, sd-&gt;bci());
3406       }
3407       st-&gt;cr();
3408     }
3409   }
3410 
3411   // Print relocation information
3412   // Prevent memory leak: allocating without ResourceMark.
3413   ResourceMark rm;
3414   const char* str = reloc_string_for(begin, end);
3415   if (str != NULL) {
3416     if (sd != NULL) st-&gt;cr();
3417     st-&gt;move_to(column, 6, 0);
3418     st-&gt;print(&quot;;   {%s}&quot;, str);
3419   }
3420 }
3421 
3422 #endif
3423 
3424 class DirectNativeCallWrapper: public NativeCallWrapper {
3425 private:
3426   NativeCall* _call;
3427 
3428 public:
3429   DirectNativeCallWrapper(NativeCall* call) : _call(call) {}
3430 
3431   virtual address destination() const { return _call-&gt;destination(); }
3432   virtual address instruction_address() const { return _call-&gt;instruction_address(); }
3433   virtual address next_instruction_address() const { return _call-&gt;next_instruction_address(); }
3434   virtual address return_address() const { return _call-&gt;return_address(); }
3435 
3436   virtual address get_resolve_call_stub(bool is_optimized) const {
3437     if (is_optimized) {
3438       return SharedRuntime::get_resolve_opt_virtual_call_stub();
3439     }
3440     return SharedRuntime::get_resolve_virtual_call_stub();
3441   }
3442 
3443   virtual void set_destination_mt_safe(address dest) {
3444 #if INCLUDE_AOT
3445     if (UseAOT) {
3446       CodeBlob* callee = CodeCache::find_blob(dest);
3447       CompiledMethod* cm = callee-&gt;as_compiled_method_or_null();
3448       if (cm != NULL &amp;&amp; cm-&gt;is_far_code()) {
3449         // Temporary fix, see JDK-8143106
3450         CompiledDirectStaticCall* csc = CompiledDirectStaticCall::at(instruction_address());
3451         csc-&gt;set_to_far(methodHandle(Thread::current(), cm-&gt;method()), dest);
3452         return;
3453       }
3454     }
3455 #endif
3456     _call-&gt;set_destination_mt_safe(dest);
3457   }
3458 
3459   virtual void set_to_interpreted(const methodHandle&amp; method, CompiledICInfo&amp; info) {
3460     CompiledDirectStaticCall* csc = CompiledDirectStaticCall::at(instruction_address());
3461 #if INCLUDE_AOT
3462     if (info.to_aot()) {
3463       csc-&gt;set_to_far(method, info.entry());
3464     } else
3465 #endif
3466     {
3467       csc-&gt;set_to_interpreted(method, info.entry());
3468     }
3469   }
3470 
3471   virtual void verify() const {
3472     // make sure code pattern is actually a call imm32 instruction
3473     _call-&gt;verify();
3474     _call-&gt;verify_alignment();
3475   }
3476 
3477   virtual void verify_resolve_call(address dest) const {
3478     CodeBlob* db = CodeCache::find_blob_unsafe(dest);
3479     assert(db != NULL &amp;&amp; !db-&gt;is_adapter_blob(), &quot;must use stub!&quot;);
3480   }
3481 
3482   virtual bool is_call_to_interpreted(address dest) const {
3483     CodeBlob* cb = CodeCache::find_blob(_call-&gt;instruction_address());
3484     return cb-&gt;contains(dest);
3485   }
3486 
3487   virtual bool is_safe_for_patching() const { return false; }
3488 
3489   virtual NativeInstruction* get_load_instruction(virtual_call_Relocation* r) const {
3490     return nativeMovConstReg_at(r-&gt;cached_value());
3491   }
3492 
3493   virtual void *get_data(NativeInstruction* instruction) const {
3494     return (void*)((NativeMovConstReg*) instruction)-&gt;data();
3495   }
3496 
3497   virtual void set_data(NativeInstruction* instruction, intptr_t data) {
3498     ((NativeMovConstReg*) instruction)-&gt;set_data(data);
3499   }
3500 };
3501 
3502 NativeCallWrapper* nmethod::call_wrapper_at(address call) const {
3503   return new DirectNativeCallWrapper((NativeCall*) call);
3504 }
3505 
3506 NativeCallWrapper* nmethod::call_wrapper_before(address return_pc) const {
3507   return new DirectNativeCallWrapper(nativeCall_before(return_pc));
3508 }
3509 
3510 address nmethod::call_instruction_address(address pc) const {
3511   if (NativeCall::is_call_before(pc)) {
3512     NativeCall *ncall = nativeCall_before(pc);
3513     return ncall-&gt;instruction_address();
3514   }
3515   return NULL;
3516 }
3517 
3518 CompiledStaticCall* nmethod::compiledStaticCall_at(Relocation* call_site) const {
3519   return CompiledDirectStaticCall::at(call_site);
3520 }
3521 
3522 CompiledStaticCall* nmethod::compiledStaticCall_at(address call_site) const {
3523   return CompiledDirectStaticCall::at(call_site);
3524 }
3525 
3526 CompiledStaticCall* nmethod::compiledStaticCall_before(address return_addr) const {
3527   return CompiledDirectStaticCall::before(return_addr);
3528 }
3529 
3530 #if defined(SUPPORT_DATA_STRUCTS)
3531 void nmethod::print_value_on(outputStream* st) const {
3532   st-&gt;print(&quot;nmethod&quot;);
3533   print_on(st, NULL);
3534 }
3535 #endif
3536 
3537 #ifndef PRODUCT
3538 
3539 void nmethod::print_calls(outputStream* st) {
3540   RelocIterator iter(this);
3541   while (iter.next()) {
3542     switch (iter.type()) {
3543     case relocInfo::virtual_call_type:
3544     case relocInfo::opt_virtual_call_type: {
3545       CompiledICLocker ml_verify(this);
3546       CompiledIC_at(&amp;iter)-&gt;print();
3547       break;
3548     }
3549     case relocInfo::static_call_type:
3550       st-&gt;print_cr(&quot;Static call at &quot; INTPTR_FORMAT, p2i(iter.reloc()-&gt;addr()));
3551       CompiledDirectStaticCall::at(iter.reloc())-&gt;print();
3552       break;
3553     default:
3554       break;
3555     }
3556   }
3557 }
3558 
3559 void nmethod::print_statistics() {
3560   ttyLocker ttyl;
3561   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;nmethod&#39;&quot;);
3562   native_nmethod_stats.print_native_nmethod_stats();
3563 #ifdef COMPILER1
3564   c1_java_nmethod_stats.print_nmethod_stats(&quot;C1&quot;);
3565 #endif
3566 #ifdef COMPILER2
3567   c2_java_nmethod_stats.print_nmethod_stats(&quot;C2&quot;);
3568 #endif
3569 #if INCLUDE_JVMCI
3570   jvmci_java_nmethod_stats.print_nmethod_stats(&quot;JVMCI&quot;);
3571 #endif
3572   unknown_java_nmethod_stats.print_nmethod_stats(&quot;Unknown&quot;);
3573   DebugInformationRecorder::print_statistics();
3574 #ifndef PRODUCT
3575   pc_nmethod_stats.print_pc_stats();
3576 #endif
3577   Dependencies::print_statistics();
3578   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
3579 }
3580 
3581 #endif // !PRODUCT
3582 
3583 #if INCLUDE_JVMCI
3584 void nmethod::update_speculation(JavaThread* thread) {
3585   jlong speculation = thread-&gt;pending_failed_speculation();
3586   if (speculation != 0) {
3587     guarantee(jvmci_nmethod_data() != NULL, &quot;failed speculation in nmethod without failed speculation list&quot;);
3588     jvmci_nmethod_data()-&gt;add_failed_speculation(this, speculation);
3589     thread-&gt;set_pending_failed_speculation(0);
3590   }
3591 }
3592 
3593 const char* nmethod::jvmci_name() {
3594   if (jvmci_nmethod_data() != NULL) {
3595     return jvmci_nmethod_data()-&gt;name();
3596   }
3597   return NULL;
3598 }
3599 #endif
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
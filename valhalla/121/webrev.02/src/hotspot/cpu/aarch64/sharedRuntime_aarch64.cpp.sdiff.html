<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 422   // VM needs target method
 423   // This needs to be a long call since we will relocate this adapter to
 424   // the codeBuffer and it may not reach
 425 
 426 #ifndef PRODUCT
 427   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 428 #endif
 429 
 430   __ mov(c_rarg0, rmethod);
 431   __ mov(c_rarg1, lr);
 432   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 433   __ blr(rscratch1);
 434   __ maybe_isb();
 435 
 436   __ pop_CPU_state();
 437   // restore sp
 438   __ leave();
 439   __ bind(L);
 440 }
 441 
<span class="line-modified"> 442 // For each value type argument, sig includes the list of fields of</span>
<span class="line-modified"> 443 // the value type. This utility function computes the number of</span>
<span class="line-modified"> 444 // arguments for the call if value types are passed by reference (the</span>
 445 // calling convention the interpreter expects).
 446 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 447   int total_args_passed = 0;
 448   if (InlineTypePassFieldsAsArgs) {
 449      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 450        BasicType bt = sig_extended-&gt;at(i)._bt;
 451        if (SigEntry::is_reserved_entry(sig_extended, i)) {
 452          // Ignore reserved entry
 453        } else if (bt == T_INLINE_TYPE) {
<span class="line-modified"> 454          // In sig_extended, a value type argument starts with:</span>
 455          // T_INLINE_TYPE, followed by the types of the fields of the
<span class="line-modified"> 456          // value type and T_VOID to mark the end of the value</span>
<span class="line-modified"> 457          // type. Value types are flattened so, for instance, in the</span>
<span class="line-modified"> 458          // case of a value type with an int field and a value type</span>
 459          // field that itself has 2 fields, an int and a long:
 460          // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second
 461          // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID
 462          // (outer T_INLINE_TYPE)
 463          total_args_passed++;
 464          int vt = 1;
 465          do {
 466            i++;
 467            BasicType bt = sig_extended-&gt;at(i)._bt;
 468            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
 469            if (bt == T_INLINE_TYPE) {
 470              vt++;
 471            } else if (bt == T_VOID &amp;&amp;
 472                       prev_bt != T_LONG &amp;&amp;
 473                       prev_bt != T_DOUBLE) {
 474              vt--;
 475            }
 476          } while (vt != 0);
 477        } else {
 478          total_args_passed++;
</pre>
<hr />
<pre>
 531       __ str(r, to);
 532     } else {
 533       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 534       if (!r_2-&gt;is_valid()) {
 535         // only a float use just part of the slot
 536         __ strs(r_1-&gt;as_FloatRegister(), to);
 537       } else {
 538         __ strd(r_1-&gt;as_FloatRegister(), to);
 539       }
 540    }
 541 }
 542 
 543 static void gen_c2i_adapter(MacroAssembler *masm,
 544                             const GrowableArray&lt;SigEntry&gt;* sig_extended,
 545                             const VMRegPair *regs,
 546                             Label&amp; skip_fixup,
 547                             address start,
 548                             OopMapSet* oop_maps,
 549                             int&amp; frame_complete,
 550                             int&amp; frame_size_in_words,
<span class="line-modified"> 551                             bool alloc_value_receiver) {</span>
 552 
 553   // Before we get into the guts of the C2I adapter, see if we should be here
 554   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 555   // interpreter, which means the caller made a static call to get here
 556   // (vcalls always get a compiled target if there is one).  Check for a
 557   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 558   patch_callers_callsite(masm);
 559 
 560   __ bind(skip_fixup);
 561 
<span class="line-modified"> 562   bool has_value_argument = false;</span>
 563 
 564   if (InlineTypePassFieldsAsArgs) {
 565       // Is there an inline type argument?
<span class="line-modified"> 566      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {</span>
<span class="line-modified"> 567        has_value_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
 568      }
<span class="line-modified"> 569      if (has_value_argument) {</span>
<span class="line-modified"> 570       // There is at least a value type argument: we&#39;re coming from</span>
<span class="line-modified"> 571       // compiled code so we have no buffers to back the value</span>
<span class="line-modified"> 572       // types. Allocate the buffers here with a runtime call.</span>
 573       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 574 
 575       frame_complete = __ offset();
 576       address the_pc = __ pc();
 577 
 578       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);
 579 
 580       __ mov(c_rarg0, rthread);
 581       __ mov(c_rarg1, r1);
<span class="line-modified"> 582       __ mov(c_rarg2, (int64_t)alloc_value_receiver);</span>
 583 
<span class="line-modified"> 584       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));</span>
 585       __ blr(rscratch1);
 586 
 587       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
 588       __ reset_last_Java_frame(false);
 589 
 590       RegisterSaver::restore_live_registers(masm);
 591 
 592       Label no_exception;
 593       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 594       __ cbz(r0, no_exception);
 595 
 596       __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
 597       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 598       __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));
 599 
 600       __ bind(no_exception);
 601 
 602       // We get an array of objects from the runtime call
 603       __ get_vm_result(r10, rthread);
 604       __ get_vm_result_2(r1, rthread); // TODO: required to keep the callee Method live?
</pre>
<hr />
<pre>
 640             if (bt == T_VOID) {
 641                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 642                next_arg_int ++;
 643                continue;
 644              }
 645 
 646              int next_off = st_off - Interpreter::stackElementSize;
 647              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 648 
 649              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));
 650              next_arg_int ++;
 651    } else {
 652        ignored++;
 653       // get the buffer from the just allocated pool of buffers
 654       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);
 655       __ load_heap_oop(rscratch1, Address(r10, index));
 656       next_vt_arg++;
 657       next_arg_int++;
 658       int vt = 1;
 659       // write fields we get from compiled code in registers/stack
<span class="line-modified"> 660       // slots to the buffer: we know we are done with that value type</span>
 661       // argument when we hit the T_VOID that acts as an end of value
<span class="line-modified"> 662       // type delimiter for this value type. Value types are flattened</span>
<span class="line-modified"> 663       // so we might encounter embedded value types. Each entry in</span>
 664       // sig_extended contains a field offset in the buffer.
 665       do {
 666         next_arg_comp++;
 667         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 668         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;
 669         if (bt == T_INLINE_TYPE) {
 670           vt++;
 671           ignored++;
 672         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {
 673           vt--;
 674           ignored++;
 675         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 676           // Ignore reserved entry
 677         } else {
 678           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 679           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 680 
 681           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
 682           has_oop_field = has_oop_field || is_oop;
 683 
 684           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));
 685         }
 686       } while (vt != 0);
 687       // pass the buffer to the interpreter
 688       __ str(rscratch1, Address(sp, st_off));
 689    }
 690 
 691   }
 692 
<span class="line-modified"> 693 // If a value type was allocated and initialized, apply post barrier to all oop fields</span>
<span class="line-modified"> 694   if (has_value_argument &amp;&amp; has_oop_field) {</span>
 695     __ push(r13); // save senderSP
 696     __ push(r1); // save callee
 697     // Allocate argument register save area
 698     if (frame::arg_reg_save_area_bytes != 0) {
 699       __ sub(sp, sp, frame::arg_reg_save_area_bytes);
 700     }
 701     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::apply_post_barriers), rthread, r10);
 702     // De-allocate argument register save area
 703     if (frame::arg_reg_save_area_bytes != 0) {
 704       __ add(sp, sp, frame::arg_reg_save_area_bytes);
 705     }
 706     __ pop(r1); // restore callee
 707     __ pop(r13); // restore sender SP
 708   }
 709 
 710   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 711 
 712   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 713   __ br(rscratch1);
 714 }
</pre>
<hr />
<pre>
 786   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 787 
 788 #if INCLUDE_JVMCI
 789   if (EnableJVMCI || UseAOT) {
 790     // check if this call should be routed towards a specific entry point
 791     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 792     Label no_alternative_target;
 793     __ cbz(rscratch2, no_alternative_target);
 794     __ mov(rscratch1, rscratch2);
 795     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 796     __ bind(no_alternative_target);
 797   }
 798 #endif // INCLUDE_JVMCI
 799 
 800   int total_args_passed = sig-&gt;length();
 801 
 802   // Now generate the shuffle code.
 803   for (int i = 0; i &lt; total_args_passed; i++) {
 804     BasicType bt = sig-&gt;at(i)._bt;
 805 
<span class="line-modified"> 806     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
 807     if (bt == T_VOID) {
 808       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 809       continue;
 810     }
 811 
 812     // Pick up 0, 1 or 2 words from SP+offset.
 813     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);
 814 
 815     // Load in argument order going down.
 816     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 817     // Point to interpreter value (vs. tag)
 818     int next_off = ld_off - Interpreter::stackElementSize;
 819     //
 820     //
 821     //
 822     VMReg r_1 = regs[i].first();
 823     VMReg r_2 = regs[i].second();
 824     if (!r_1-&gt;is_valid()) {
 825       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 826       continue;
</pre>
<hr />
<pre>
 937                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc,
 938                                                             const VMRegPair* regs_cc,
 939                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,
 940                                                             const VMRegPair* regs_cc_ro,
 941                                                             AdapterFingerPrint* fingerprint,
 942                                                             AdapterBlob*&amp; new_adapter) {
 943 
 944   address i2c_entry = __ pc();
 945   gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);
 946 
 947   address c2i_unverified_entry = __ pc();
 948   Label skip_fixup;
 949 
 950   gen_inline_cache_check(masm, skip_fixup);
 951 
 952   OopMapSet* oop_maps = new OopMapSet();
 953   int frame_complete = CodeOffsets::frame_never_safe;
 954   int frame_size_in_words = 0;
 955 
 956   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)
<span class="line-modified"> 957   address c2i_value_ro_entry = __ pc();</span>
 958   if (regs_cc != regs_cc_ro) {
 959     Label unused;
 960     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);
 961     skip_fixup = unused;
 962   }
 963 
 964   // Scalarized c2i adapter
 965   address c2i_entry = __ pc();
 966 
 967   // Class initialization barrier for static methods
 968   address c2i_no_clinit_check_entry = NULL;
 969 
 970   if (VM_Version::supports_fast_class_init_checks()) {
 971     Label L_skip_barrier;
 972     { // Bypass the barrier for non-static methods
 973         Register flags  = rscratch1;
 974       __ ldrw(flags, Address(rmethod, Method::access_flags_offset()));
 975       __ tst(flags, JVM_ACC_STATIC);
 976       __ br(Assembler::NE, L_skip_barrier); // non-static
 977     }
 978 
 979     Register klass = rscratch1;
 980     __ load_method_holder(klass, rmethod);
 981     // We pass rthread to this function on x86
 982     __ clinit_barrier(klass, rscratch2, &amp;L_skip_barrier /*L_fast_path*/);
 983 
 984     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
 985 
 986     __ bind(L_skip_barrier);
 987     c2i_no_clinit_check_entry = __ pc();
 988   }
 989 
 990   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 991   bs-&gt;c2i_entry_barrier(masm);
 992 
 993   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 994 
<span class="line-modified"> 995   address c2i_unverified_value_entry = c2i_unverified_entry;</span>
 996 
 997  // Non-scalarized c2i adapter
<span class="line-modified"> 998   address c2i_value_entry = c2i_entry;</span>
 999   if (regs != regs_cc) {
<span class="line-modified">1000     Label value_entry_skip_fixup;</span>
<span class="line-modified">1001     c2i_unverified_value_entry = __ pc();</span>
<span class="line-modified">1002     gen_inline_cache_check(masm, value_entry_skip_fixup);</span>
1003 
<span class="line-modified">1004     c2i_value_entry = __ pc();</span>
1005     Label unused;
<span class="line-modified">1006     gen_c2i_adapter(masm, sig, regs, value_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
1007   }
1008 
1009   __ flush();
1010 
1011   // The c2i adapter might safepoint and trigger a GC. The caller must make sure that
1012   // the GC knows about the location of oop argument locations passed to the c2i adapter.
1013 
1014   bool caller_must_gc_arguments = (regs != regs_cc);
1015   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words + 10, oop_maps, caller_must_gc_arguments);
1016 
<span class="line-modified">1017   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry, c2i_unverified_entry, c2i_unverified_value_entry, c2i_no_clinit_check_entry);</span>
1018 }
1019 
1020 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1021                                          VMRegPair *regs,
1022                                          VMRegPair *regs2,
1023                                          int total_args_passed) {
1024   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
1025 
1026 // We return the amount of VMRegImpl stack slots we need to reserve for all
1027 // the arguments NOT counting out_preserve_stack_slots.
1028 
1029     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1030       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
1031     };
1032     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1033       c_farg0, c_farg1, c_farg2, c_farg3,
1034       c_farg4, c_farg5, c_farg6, c_farg7
1035     };
1036 
1037     uint int_args = 0;
</pre>
<hr />
<pre>
3307   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3308   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3309 #endif
3310   // Clear the exception oop so GC no longer processes it as a root.
3311   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3312 
3313   // r0: exception oop
3314   // r8:  exception handler
3315   // r4: exception pc
3316   // Jump to handler
3317 
3318   __ br(r8);
3319 
3320   // Make sure all code is generated
3321   masm-&gt;flush();
3322 
3323   // Set exception blob
3324   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3325 }
3326 
<span class="line-modified">3327 BufferedValueTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {</span>
<span class="line-modified">3328   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);</span>
3329   CodeBuffer buffer(buf);
3330   short buffer_locs[20];
3331   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3332                                          sizeof(buffer_locs)/sizeof(relocInfo));
3333 
3334   MacroAssembler _masm(&amp;buffer);
3335   MacroAssembler* masm = &amp;_masm;
3336 
3337   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3338   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3339 
3340   int pack_fields_off = __ offset();
3341 
3342   int j = 1;
3343   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3344     BasicType bt = sig_vk-&gt;at(i)._bt;
3345     if (bt == T_INLINE_TYPE) {
3346       continue;
3347     }
3348     if (bt == T_VOID) {
</pre>
<hr />
<pre>
3409     } else if (bt == T_DOUBLE) {
3410       __ ldrd(r_1-&gt;as_FloatRegister(), from);
3411     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3412        assert_different_registers(r0, r_1-&gt;as_Register());
3413        __ load_heap_oop(r_1-&gt;as_Register(), from);
3414     } else {
3415       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3416       assert_different_registers(r0, r_1-&gt;as_Register());
3417 
3418       size_t size_in_bytes = type2aelembytes(bt);
3419       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);
3420     }
3421     j++;
3422   }
3423   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3424 
3425   __ ret(lr);
3426 
3427   __ flush();
3428 
<span class="line-modified">3429   return BufferedValueTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);</span>
3430 }
3431 #endif // COMPILER2
</pre>
</td>
<td>
<hr />
<pre>
 422   // VM needs target method
 423   // This needs to be a long call since we will relocate this adapter to
 424   // the codeBuffer and it may not reach
 425 
 426 #ifndef PRODUCT
 427   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 428 #endif
 429 
 430   __ mov(c_rarg0, rmethod);
 431   __ mov(c_rarg1, lr);
 432   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 433   __ blr(rscratch1);
 434   __ maybe_isb();
 435 
 436   __ pop_CPU_state();
 437   // restore sp
 438   __ leave();
 439   __ bind(L);
 440 }
 441 
<span class="line-modified"> 442 // For each inline type argument, sig includes the list of fields of</span>
<span class="line-modified"> 443 // the inline type. This utility function computes the number of</span>
<span class="line-modified"> 444 // arguments for the call if inline types are passed by reference (the</span>
 445 // calling convention the interpreter expects).
 446 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 447   int total_args_passed = 0;
 448   if (InlineTypePassFieldsAsArgs) {
 449      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 450        BasicType bt = sig_extended-&gt;at(i)._bt;
 451        if (SigEntry::is_reserved_entry(sig_extended, i)) {
 452          // Ignore reserved entry
 453        } else if (bt == T_INLINE_TYPE) {
<span class="line-modified"> 454          // In sig_extended, an inline type argument starts with:</span>
 455          // T_INLINE_TYPE, followed by the types of the fields of the
<span class="line-modified"> 456          // inline type and T_VOID to mark the end of the value</span>
<span class="line-modified"> 457          // type. Inline types are flattened so, for instance, in the</span>
<span class="line-modified"> 458          // case of an inline type with an int field and an inline type</span>
 459          // field that itself has 2 fields, an int and a long:
 460          // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second
 461          // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID
 462          // (outer T_INLINE_TYPE)
 463          total_args_passed++;
 464          int vt = 1;
 465          do {
 466            i++;
 467            BasicType bt = sig_extended-&gt;at(i)._bt;
 468            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
 469            if (bt == T_INLINE_TYPE) {
 470              vt++;
 471            } else if (bt == T_VOID &amp;&amp;
 472                       prev_bt != T_LONG &amp;&amp;
 473                       prev_bt != T_DOUBLE) {
 474              vt--;
 475            }
 476          } while (vt != 0);
 477        } else {
 478          total_args_passed++;
</pre>
<hr />
<pre>
 531       __ str(r, to);
 532     } else {
 533       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 534       if (!r_2-&gt;is_valid()) {
 535         // only a float use just part of the slot
 536         __ strs(r_1-&gt;as_FloatRegister(), to);
 537       } else {
 538         __ strd(r_1-&gt;as_FloatRegister(), to);
 539       }
 540    }
 541 }
 542 
 543 static void gen_c2i_adapter(MacroAssembler *masm,
 544                             const GrowableArray&lt;SigEntry&gt;* sig_extended,
 545                             const VMRegPair *regs,
 546                             Label&amp; skip_fixup,
 547                             address start,
 548                             OopMapSet* oop_maps,
 549                             int&amp; frame_complete,
 550                             int&amp; frame_size_in_words,
<span class="line-modified"> 551                             bool alloc_inline_receiver) {</span>
 552 
 553   // Before we get into the guts of the C2I adapter, see if we should be here
 554   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 555   // interpreter, which means the caller made a static call to get here
 556   // (vcalls always get a compiled target if there is one).  Check for a
 557   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 558   patch_callers_callsite(masm);
 559 
 560   __ bind(skip_fixup);
 561 
<span class="line-modified"> 562   bool has_inline_argument = false;</span>
 563 
 564   if (InlineTypePassFieldsAsArgs) {
 565       // Is there an inline type argument?
<span class="line-modified"> 566      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_inline_argument; i++) {</span>
<span class="line-modified"> 567        has_inline_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
 568      }
<span class="line-modified"> 569      if (has_inline_argument) {</span>
<span class="line-modified"> 570       // There is at least an inline type argument: we&#39;re coming from</span>
<span class="line-modified"> 571       // compiled code so we have no buffers to back the inline types</span>
<span class="line-modified"> 572       // Allocate the buffers here with a runtime call.</span>
 573       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 574 
 575       frame_complete = __ offset();
 576       address the_pc = __ pc();
 577 
 578       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);
 579 
 580       __ mov(c_rarg0, rthread);
 581       __ mov(c_rarg1, r1);
<span class="line-modified"> 582       __ mov(c_rarg2, (int64_t)alloc_inline_receiver);</span>
 583 
<span class="line-modified"> 584       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));</span>
 585       __ blr(rscratch1);
 586 
 587       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
 588       __ reset_last_Java_frame(false);
 589 
 590       RegisterSaver::restore_live_registers(masm);
 591 
 592       Label no_exception;
 593       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 594       __ cbz(r0, no_exception);
 595 
 596       __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
 597       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 598       __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));
 599 
 600       __ bind(no_exception);
 601 
 602       // We get an array of objects from the runtime call
 603       __ get_vm_result(r10, rthread);
 604       __ get_vm_result_2(r1, rthread); // TODO: required to keep the callee Method live?
</pre>
<hr />
<pre>
 640             if (bt == T_VOID) {
 641                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 642                next_arg_int ++;
 643                continue;
 644              }
 645 
 646              int next_off = st_off - Interpreter::stackElementSize;
 647              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 648 
 649              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));
 650              next_arg_int ++;
 651    } else {
 652        ignored++;
 653       // get the buffer from the just allocated pool of buffers
 654       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);
 655       __ load_heap_oop(rscratch1, Address(r10, index));
 656       next_vt_arg++;
 657       next_arg_int++;
 658       int vt = 1;
 659       // write fields we get from compiled code in registers/stack
<span class="line-modified"> 660       // slots to the buffer: we know we are done with that inline type</span>
 661       // argument when we hit the T_VOID that acts as an end of value
<span class="line-modified"> 662       // type delimiter for this inline type. Inline types are flattened</span>
<span class="line-modified"> 663       // so we might encounter embedded inline types. Each entry in</span>
 664       // sig_extended contains a field offset in the buffer.
 665       do {
 666         next_arg_comp++;
 667         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 668         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;
 669         if (bt == T_INLINE_TYPE) {
 670           vt++;
 671           ignored++;
 672         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {
 673           vt--;
 674           ignored++;
 675         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 676           // Ignore reserved entry
 677         } else {
 678           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 679           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 680 
 681           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
 682           has_oop_field = has_oop_field || is_oop;
 683 
 684           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));
 685         }
 686       } while (vt != 0);
 687       // pass the buffer to the interpreter
 688       __ str(rscratch1, Address(sp, st_off));
 689    }
 690 
 691   }
 692 
<span class="line-modified"> 693 // If an inline type was allocated and initialized, apply post barrier to all oop fields</span>
<span class="line-modified"> 694   if (has_inline_argument &amp;&amp; has_oop_field) {</span>
 695     __ push(r13); // save senderSP
 696     __ push(r1); // save callee
 697     // Allocate argument register save area
 698     if (frame::arg_reg_save_area_bytes != 0) {
 699       __ sub(sp, sp, frame::arg_reg_save_area_bytes);
 700     }
 701     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::apply_post_barriers), rthread, r10);
 702     // De-allocate argument register save area
 703     if (frame::arg_reg_save_area_bytes != 0) {
 704       __ add(sp, sp, frame::arg_reg_save_area_bytes);
 705     }
 706     __ pop(r1); // restore callee
 707     __ pop(r13); // restore sender SP
 708   }
 709 
 710   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 711 
 712   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 713   __ br(rscratch1);
 714 }
</pre>
<hr />
<pre>
 786   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 787 
 788 #if INCLUDE_JVMCI
 789   if (EnableJVMCI || UseAOT) {
 790     // check if this call should be routed towards a specific entry point
 791     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 792     Label no_alternative_target;
 793     __ cbz(rscratch2, no_alternative_target);
 794     __ mov(rscratch1, rscratch2);
 795     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 796     __ bind(no_alternative_target);
 797   }
 798 #endif // INCLUDE_JVMCI
 799 
 800   int total_args_passed = sig-&gt;length();
 801 
 802   // Now generate the shuffle code.
 803   for (int i = 0; i &lt; total_args_passed; i++) {
 804     BasicType bt = sig-&gt;at(i)._bt;
 805 
<span class="line-modified"> 806     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack inline typ args&quot;);</span>
 807     if (bt == T_VOID) {
 808       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 809       continue;
 810     }
 811 
 812     // Pick up 0, 1 or 2 words from SP+offset.
 813     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);
 814 
 815     // Load in argument order going down.
 816     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 817     // Point to interpreter value (vs. tag)
 818     int next_off = ld_off - Interpreter::stackElementSize;
 819     //
 820     //
 821     //
 822     VMReg r_1 = regs[i].first();
 823     VMReg r_2 = regs[i].second();
 824     if (!r_1-&gt;is_valid()) {
 825       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 826       continue;
</pre>
<hr />
<pre>
 937                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc,
 938                                                             const VMRegPair* regs_cc,
 939                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,
 940                                                             const VMRegPair* regs_cc_ro,
 941                                                             AdapterFingerPrint* fingerprint,
 942                                                             AdapterBlob*&amp; new_adapter) {
 943 
 944   address i2c_entry = __ pc();
 945   gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);
 946 
 947   address c2i_unverified_entry = __ pc();
 948   Label skip_fixup;
 949 
 950   gen_inline_cache_check(masm, skip_fixup);
 951 
 952   OopMapSet* oop_maps = new OopMapSet();
 953   int frame_complete = CodeOffsets::frame_never_safe;
 954   int frame_size_in_words = 0;
 955 
 956   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)
<span class="line-modified"> 957   address c2i_inline_ro_entry = __ pc();</span>
 958   if (regs_cc != regs_cc_ro) {
 959     Label unused;
 960     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);
 961     skip_fixup = unused;
 962   }
 963 
 964   // Scalarized c2i adapter
 965   address c2i_entry = __ pc();
 966 
 967   // Class initialization barrier for static methods
 968   address c2i_no_clinit_check_entry = NULL;
 969 
 970   if (VM_Version::supports_fast_class_init_checks()) {
 971     Label L_skip_barrier;
 972     { // Bypass the barrier for non-static methods
 973         Register flags  = rscratch1;
 974       __ ldrw(flags, Address(rmethod, Method::access_flags_offset()));
 975       __ tst(flags, JVM_ACC_STATIC);
 976       __ br(Assembler::NE, L_skip_barrier); // non-static
 977     }
 978 
 979     Register klass = rscratch1;
 980     __ load_method_holder(klass, rmethod);
 981     // We pass rthread to this function on x86
 982     __ clinit_barrier(klass, rscratch2, &amp;L_skip_barrier /*L_fast_path*/);
 983 
 984     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
 985 
 986     __ bind(L_skip_barrier);
 987     c2i_no_clinit_check_entry = __ pc();
 988   }
 989 
 990   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 991   bs-&gt;c2i_entry_barrier(masm);
 992 
 993   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 994 
<span class="line-modified"> 995   address c2i_unverified_inline_entry = c2i_unverified_entry;</span>
 996 
 997  // Non-scalarized c2i adapter
<span class="line-modified"> 998   address c2i_inline_entry = c2i_entry;</span>
 999   if (regs != regs_cc) {
<span class="line-modified">1000     Label inline_entry_skip_fixup;</span>
<span class="line-modified">1001     c2i_unverified_inline_entry = __ pc();</span>
<span class="line-modified">1002     gen_inline_cache_check(masm, inline_entry_skip_fixup);</span>
1003 
<span class="line-modified">1004     c2i_inline_entry = __ pc();</span>
1005     Label unused;
<span class="line-modified">1006     gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
1007   }
1008 
1009   __ flush();
1010 
1011   // The c2i adapter might safepoint and trigger a GC. The caller must make sure that
1012   // the GC knows about the location of oop argument locations passed to the c2i adapter.
1013 
1014   bool caller_must_gc_arguments = (regs != regs_cc);
1015   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words + 10, oop_maps, caller_must_gc_arguments);
1016 
<span class="line-modified">1017   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);</span>
1018 }
1019 
1020 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1021                                          VMRegPair *regs,
1022                                          VMRegPair *regs2,
1023                                          int total_args_passed) {
1024   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
1025 
1026 // We return the amount of VMRegImpl stack slots we need to reserve for all
1027 // the arguments NOT counting out_preserve_stack_slots.
1028 
1029     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1030       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
1031     };
1032     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1033       c_farg0, c_farg1, c_farg2, c_farg3,
1034       c_farg4, c_farg5, c_farg6, c_farg7
1035     };
1036 
1037     uint int_args = 0;
</pre>
<hr />
<pre>
3307   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3308   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3309 #endif
3310   // Clear the exception oop so GC no longer processes it as a root.
3311   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3312 
3313   // r0: exception oop
3314   // r8:  exception handler
3315   // r4: exception pc
3316   // Jump to handler
3317 
3318   __ br(r8);
3319 
3320   // Make sure all code is generated
3321   masm-&gt;flush();
3322 
3323   // Set exception blob
3324   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3325 }
3326 
<span class="line-modified">3327 BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {</span>
<span class="line-modified">3328   BufferBlob* buf = BufferBlob::create(&quot;inline types pack/unpack&quot;, 16 * K);</span>
3329   CodeBuffer buffer(buf);
3330   short buffer_locs[20];
3331   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3332                                          sizeof(buffer_locs)/sizeof(relocInfo));
3333 
3334   MacroAssembler _masm(&amp;buffer);
3335   MacroAssembler* masm = &amp;_masm;
3336 
3337   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3338   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3339 
3340   int pack_fields_off = __ offset();
3341 
3342   int j = 1;
3343   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3344     BasicType bt = sig_vk-&gt;at(i)._bt;
3345     if (bt == T_INLINE_TYPE) {
3346       continue;
3347     }
3348     if (bt == T_VOID) {
</pre>
<hr />
<pre>
3409     } else if (bt == T_DOUBLE) {
3410       __ ldrd(r_1-&gt;as_FloatRegister(), from);
3411     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3412        assert_different_registers(r0, r_1-&gt;as_Register());
3413        __ load_heap_oop(r_1-&gt;as_Register(), from);
3414     } else {
3415       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3416       assert_different_registers(r0, r_1-&gt;as_Register());
3417 
3418       size_t size_in_bytes = type2aelembytes(bt);
3419       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);
3420     }
3421     j++;
3422   }
3423   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3424 
3425   __ ret(lr);
3426 
3427   __ flush();
3428 
<span class="line-modified">3429   return BufferedInlineTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);</span>
3430 }
3431 #endif // COMPILER2
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
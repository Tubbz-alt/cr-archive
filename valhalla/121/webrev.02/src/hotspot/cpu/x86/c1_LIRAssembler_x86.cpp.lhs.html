<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
<a name="1" id="anc1"></a>
  34 #include &quot;ci/ciInstance.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed">  35 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  36 #include &quot;gc/shared/collectedHeap.hpp&quot;
  37 #include &quot;nativeInst_x86.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 #include &quot;vmreg_x86.inline.hpp&quot;
  45 
  46 
  47 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  48 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  49 // fast versions of NegF/NegD and AbsF/AbsD.
  50 
  51 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  52 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  53   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  54   // of 128-bits operands for SSE instructions.
  55   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  56   // Store the value to a 128-bits operand.
  57   operand[0] = lo;
  58   operand[1] = hi;
  59   return operand;
  60 }
  61 
  62 // Buffer for 128-bits masks used by SSE instructions.
  63 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  64 
  65 // Static initialization during VM startup.
  66 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  67 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  68 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  69 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  70 
  71 
  72 NEEDS_CLEANUP // remove this definitions ?
  73 const Register IC_Klass    = rax;   // where the IC klass is cached
  74 const Register SYNC_header = rax;   // synchronization header
  75 const Register SHIFT_count = rcx;   // where count for shift operations must be
  76 
  77 #define __ _masm-&gt;
  78 
  79 
  80 static void select_different_registers(Register preserve,
  81                                        Register extra,
  82                                        Register &amp;tmp1,
  83                                        Register &amp;tmp2) {
  84   if (tmp1 == preserve) {
  85     assert_different_registers(tmp1, tmp2, extra);
  86     tmp1 = extra;
  87   } else if (tmp2 == preserve) {
  88     assert_different_registers(tmp1, tmp2, extra);
  89     tmp2 = extra;
  90   }
  91   assert_different_registers(preserve, tmp1, tmp2);
  92 }
  93 
  94 
  95 
  96 static void select_different_registers(Register preserve,
  97                                        Register extra,
  98                                        Register &amp;tmp1,
  99                                        Register &amp;tmp2,
 100                                        Register &amp;tmp3) {
 101   if (tmp1 == preserve) {
 102     assert_different_registers(tmp1, tmp2, tmp3, extra);
 103     tmp1 = extra;
 104   } else if (tmp2 == preserve) {
 105     assert_different_registers(tmp1, tmp2, tmp3, extra);
 106     tmp2 = extra;
 107   } else if (tmp3 == preserve) {
 108     assert_different_registers(tmp1, tmp2, tmp3, extra);
 109     tmp3 = extra;
 110   }
 111   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 112 }
 113 
 114 
 115 
 116 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 117   if (opr-&gt;is_constant()) {
 118     LIR_Const* constant = opr-&gt;as_constant_ptr();
 119     switch (constant-&gt;type()) {
 120       case T_INT: {
 121         return true;
 122       }
 123 
 124       default:
 125         return false;
 126     }
 127   }
 128   return false;
 129 }
 130 
 131 
 132 LIR_Opr LIR_Assembler::receiverOpr() {
 133   return FrameMap::receiver_opr;
 134 }
 135 
 136 LIR_Opr LIR_Assembler::osrBufferPointer() {
 137   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 138 }
 139 
 140 //--------------fpu register translations-----------------------
 141 
 142 
 143 address LIR_Assembler::float_constant(float f) {
 144   address const_addr = __ float_constant(f);
 145   if (const_addr == NULL) {
 146     bailout(&quot;const section overflow&quot;);
 147     return __ code()-&gt;consts()-&gt;start();
 148   } else {
 149     return const_addr;
 150   }
 151 }
 152 
 153 
 154 address LIR_Assembler::double_constant(double d) {
 155   address const_addr = __ double_constant(d);
 156   if (const_addr == NULL) {
 157     bailout(&quot;const section overflow&quot;);
 158     return __ code()-&gt;consts()-&gt;start();
 159   } else {
 160     return const_addr;
 161   }
 162 }
 163 
 164 #ifndef _LP64
 165 void LIR_Assembler::fpop() {
 166   __ fpop();
 167 }
 168 
 169 void LIR_Assembler::fxch(int i) {
 170   __ fxch(i);
 171 }
 172 
 173 void LIR_Assembler::fld(int i) {
 174   __ fld_s(i);
 175 }
 176 
 177 void LIR_Assembler::ffree(int i) {
 178   __ ffree(i);
 179 }
 180 #endif // !_LP64
 181 
 182 void LIR_Assembler::breakpoint() {
 183   __ int3();
 184 }
 185 
 186 void LIR_Assembler::push(LIR_Opr opr) {
 187   if (opr-&gt;is_single_cpu()) {
 188     __ push_reg(opr-&gt;as_register());
 189   } else if (opr-&gt;is_double_cpu()) {
 190     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 191     __ push_reg(opr-&gt;as_register_lo());
 192   } else if (opr-&gt;is_stack()) {
 193     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 194   } else if (opr-&gt;is_constant()) {
 195     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 196     if (const_opr-&gt;type() == T_OBJECT || const_opr-&gt;type() == T_INLINE_TYPE) {
 197       __ push_oop(const_opr-&gt;as_jobject());
 198     } else if (const_opr-&gt;type() == T_INT) {
 199       __ push_jint(const_opr-&gt;as_jint());
 200     } else {
 201       ShouldNotReachHere();
 202     }
 203 
 204   } else {
 205     ShouldNotReachHere();
 206   }
 207 }
 208 
 209 void LIR_Assembler::pop(LIR_Opr opr) {
 210   if (opr-&gt;is_single_cpu()) {
 211     __ pop_reg(opr-&gt;as_register());
 212   } else {
 213     ShouldNotReachHere();
 214   }
 215 }
 216 
 217 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 218   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 219 }
 220 
 221 //-------------------------------------------
 222 
 223 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 224   return as_Address(addr, rscratch1);
 225 }
 226 
 227 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 228   if (addr-&gt;base()-&gt;is_illegal()) {
 229     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 230     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 231     if (! __ reachable(laddr)) {
 232       __ movptr(tmp, laddr.addr());
 233       Address res(tmp, 0);
 234       return res;
 235     } else {
 236       return __ as_Address(laddr);
 237     }
 238   }
 239 
 240   Register base = addr-&gt;base()-&gt;as_pointer_register();
 241 
 242   if (addr-&gt;index()-&gt;is_illegal()) {
 243     return Address( base, addr-&gt;disp());
 244   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 245     Register index = addr-&gt;index()-&gt;as_pointer_register();
 246     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 247   } else if (addr-&gt;index()-&gt;is_constant()) {
 248     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 249     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 250 
 251     return Address(base, addr_offset);
 252   } else {
 253     Unimplemented();
 254     return Address();
 255   }
 256 }
 257 
 258 
 259 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 260   Address base = as_Address(addr);
 261   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 262 }
 263 
 264 
 265 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 266   return as_Address(addr);
 267 }
 268 
 269 
 270 void LIR_Assembler::osr_entry() {
 271   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 272   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 273   ValueStack* entry_state = osr_entry-&gt;state();
 274   int number_of_locks = entry_state-&gt;locks_size();
 275 
 276   // we jump here if osr happens with the interpreter
 277   // state set up to continue at the beginning of the
 278   // loop that triggered osr - in particular, we have
 279   // the following registers setup:
 280   //
 281   // rcx: osr buffer
 282   //
 283 
 284   // build frame
 285   ciMethod* m = compilation()-&gt;method();
 286   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 287 
 288   // OSR buffer is
 289   //
 290   // locals[nlocals-1..0]
 291   // monitors[0..number_of_locks]
 292   //
 293   // locals is a direct copy of the interpreter frame so in the osr buffer
 294   // so first slot in the local array is the last local from the interpreter
 295   // and last slot is local[0] (receiver) from the interpreter
 296   //
 297   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 298   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 299   // in the interpreter frame (the method lock if a sync method)
 300 
 301   // Initialize monitors in the compiled activation.
 302   //   rcx: pointer to osr buffer
 303   //
 304   // All other registers are dead at this point and the locals will be
 305   // copied into place by code emitted in the IR.
 306 
 307   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 308   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 309     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 310       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 311     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 312     // the OSR buffer using 2 word entries: first the lock and then
 313     // the oop.
 314     for (int i = 0; i &lt; number_of_locks; i++) {
 315       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 316 #ifdef ASSERT
 317       // verify the interpreter&#39;s monitor has a non-null object
 318       {
 319         Label L;
 320         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 321         __ jcc(Assembler::notZero, L);
 322         __ stop(&quot;locked object is NULL&quot;);
 323         __ bind(L);
 324       }
 325 #endif
 326       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 327       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 328       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 329       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 330     }
 331   }
 332 }
 333 
 334 
 335 // inline cache check; done before the frame is built.
 336 int LIR_Assembler::check_icache() {
 337   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 338   Register ic_klass = IC_Klass;
 339   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 340   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 341   if (!do_post_padding) {
 342     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 343     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 344   }
 345   int offset = __ offset();
 346   __ inline_cache_check(receiver, IC_Klass);
 347   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 348   if (do_post_padding) {
 349     // force alignment after the cache check.
 350     // It&#39;s been verified to be aligned if !VerifyOops
 351     __ align(CodeEntryAlignment);
 352   }
 353   return offset;
 354 }
 355 
 356 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 357   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 358   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 359 
 360   Label L_skip_barrier;
 361   Register klass = rscratch1;
 362   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 363   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 364 
 365   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 366   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 367 
 368   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 369 
 370   __ bind(L_skip_barrier);
 371 }
 372 
 373 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 374   jobject o = NULL;
 375   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 376   __ movoop(reg, o);
 377   patching_epilog(patch, lir_patch_normal, reg, info);
 378 }
 379 
 380 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 381   Metadata* o = NULL;
 382   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 383   __ mov_metadata(reg, o);
 384   patching_epilog(patch, lir_patch_normal, reg, info);
 385 }
 386 
 387 // This specifies the rsp decrement needed to build the frame
 388 int LIR_Assembler::initial_frame_size_in_bytes() const {
 389   // if rounding, must let FrameMap know!
 390 
 391   // The frame_map records size in slots (32bit word)
 392 
 393   // subtract two words to account for return address and link
 394   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 395 }
 396 
 397 
 398 int LIR_Assembler::emit_exception_handler() {
 399   // if the last instruction is a call (typically to do a throw which
 400   // is coming at the end after block reordering) the return address
 401   // must still point into the code area in order to avoid assertion
 402   // failures when searching for the corresponding bci =&gt; add a nop
 403   // (was bug 5/14/1999 - gri)
 404   __ nop();
 405 
 406   // generate code for exception handler
 407   address handler_base = __ start_a_stub(exception_handler_size());
 408   if (handler_base == NULL) {
 409     // not enough space left for the handler
 410     bailout(&quot;exception handler overflow&quot;);
 411     return -1;
 412   }
 413 
 414   int offset = code_offset();
 415 
 416   // the exception oop and pc are in rax, and rdx
 417   // no other registers need to be preserved, so invalidate them
 418   __ invalidate_registers(false, true, true, false, true, true);
 419 
 420   // check that there is really an exception
 421   __ verify_not_null_oop(rax);
 422 
 423   // search an exception handler (rax: exception oop, rdx: throwing pc)
 424   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 425   __ should_not_reach_here();
 426   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 427   __ end_a_stub();
 428 
 429   return offset;
 430 }
 431 
 432 
 433 // Emit the code to remove the frame from the stack in the exception
 434 // unwind path.
 435 int LIR_Assembler::emit_unwind_handler() {
 436 #ifndef PRODUCT
 437   if (CommentedAssembly) {
 438     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 439   }
 440 #endif
 441 
 442   int offset = code_offset();
 443 
 444   // Fetch the exception from TLS and clear out exception related thread state
 445   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 446   NOT_LP64(__ get_thread(rsi));
 447   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 448   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 449   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 450 
 451   __ bind(_unwind_handler_entry);
 452   __ verify_not_null_oop(rax);
 453   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 454     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 455   }
 456 
 457   // Preform needed unlocking
 458   MonitorExitStub* stub = NULL;
 459   if (method()-&gt;is_synchronized()) {
 460     monitor_address(0, FrameMap::rax_opr);
 461     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 462     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 463     __ bind(*stub-&gt;continuation());
 464   }
 465 
 466   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 467 #ifdef _LP64
 468     __ mov(rdi, r15_thread);
 469     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 470 #else
 471     __ get_thread(rax);
 472     __ movptr(Address(rsp, 0), rax);
 473     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 474 #endif
 475     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 476   }
 477 
 478   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 479     __ mov(rax, rbx);  // Restore the exception
 480   }
 481 
 482   // remove the activation and dispatch to the unwind handler
 483   int initial_framesize = initial_frame_size_in_bytes();
 484   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);
 485   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 486 
 487   // Emit the slow path assembly
 488   if (stub != NULL) {
 489     stub-&gt;emit_code(this);
 490   }
 491 
 492   return offset;
 493 }
 494 
 495 
 496 int LIR_Assembler::emit_deopt_handler() {
 497   // if the last instruction is a call (typically to do a throw which
 498   // is coming at the end after block reordering) the return address
 499   // must still point into the code area in order to avoid assertion
 500   // failures when searching for the corresponding bci =&gt; add a nop
 501   // (was bug 5/14/1999 - gri)
 502   __ nop();
 503 
 504   // generate code for exception handler
 505   address handler_base = __ start_a_stub(deopt_handler_size());
 506   if (handler_base == NULL) {
 507     // not enough space left for the handler
 508     bailout(&quot;deopt handler overflow&quot;);
 509     return -1;
 510   }
 511 
 512   int offset = code_offset();
 513   InternalAddress here(__ pc());
 514 
 515   __ pushptr(here.addr());
 516   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 517   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 518   __ end_a_stub();
 519 
 520   return offset;
 521 }
 522 
 523 
 524 void LIR_Assembler::return_op(LIR_Opr result) {
 525   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 526   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 527     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 528   }
 529 
 530   ciMethod* method = compilation()-&gt;method();
 531   ciType* return_type = method-&gt;return_type();
<a name="3" id="anc3"></a><span class="line-modified"> 532   if (InlineTypeReturnedAsFields &amp;&amp; return_type-&gt;is_valuetype()) {</span>
<span class="line-modified"> 533     ciValueKlass* vk = return_type-&gt;as_value_klass();</span>
 534     if (vk-&gt;can_be_returned_as_fields()) {
 535 #ifndef _LP64
 536       Unimplemented();
 537 #else
 538       address unpack_handler = vk-&gt;unpack_handler();
 539       assert(unpack_handler != NULL, &quot;must be&quot;);
 540       __ call(RuntimeAddress(unpack_handler));
 541       // At this point, rax points to the value object (for interpreter or C1 caller).
 542       // The fields of the object are copied into registers (for C2 caller).
 543 #endif
 544     }
 545   }
 546 
 547   // Pop the stack before the safepoint code
 548   int initial_framesize = initial_frame_size_in_bytes();
 549   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);
 550 
 551   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 552     __ reserved_stack_check();
 553   }
 554 
 555   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 556 
 557   // Note: we do not need to round double result; float result has the right precision
 558   // the poll sets the condition code, but no data registers
 559 
 560 #ifdef _LP64
 561   const Register poll_addr = rscratch1;
 562   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 563 #else
 564   const Register poll_addr = rbx;
 565   assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 566   __ get_thread(poll_addr);
 567   __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 568 #endif
 569   __ relocate(relocInfo::poll_return_type);
 570   __ testl(rax, Address(poll_addr, 0));
 571   __ ret(0);
 572 }
 573 
 574 
<a name="4" id="anc4"></a><span class="line-modified"> 575 int LIR_Assembler::store_inline_type_fields_to_buf(ciValueKlass* vk) {</span>
 576   return (__ store_inline_type_fields_to_buf(vk, false));
 577 }
 578 
 579 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 580   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 581   int offset = __ offset();
 582 #ifdef _LP64
 583   const Register poll_addr = rscratch1;
 584   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 585 #else
 586   assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 587   const Register poll_addr = tmp-&gt;as_register();
 588   __ get_thread(poll_addr);
 589   __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 590 #endif
 591   add_debug_info_for_branch(info);
 592   __ relocate(relocInfo::poll_type);
 593   address pre_pc = __ pc();
 594   __ testl(rax, Address(poll_addr, 0));
 595   address post_pc = __ pc();
 596   guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 597   return offset;
 598 }
 599 
 600 
 601 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 602   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 603 }
 604 
 605 void LIR_Assembler::swap_reg(Register a, Register b) {
 606   __ xchgptr(a, b);
 607 }
 608 
 609 
 610 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 611   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 612   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 613   LIR_Const* c = src-&gt;as_constant_ptr();
 614 
 615   switch (c-&gt;type()) {
 616     case T_INT: {
 617       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 618       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 619       break;
 620     }
 621 
 622     case T_ADDRESS: {
 623       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 624       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 625       break;
 626     }
 627 
 628     case T_LONG: {
 629       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 630 #ifdef _LP64
 631       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 632 #else
 633       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 634       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 635 #endif // _LP64
 636       break;
 637     }
 638 
 639     case T_INLINE_TYPE: // Fall through
 640     case T_OBJECT: {
 641       if (patch_code != lir_patch_none) {
 642         jobject2reg_with_patching(dest-&gt;as_register(), info);
 643       } else {
 644         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 645       }
 646       break;
 647     }
 648 
 649     case T_METADATA: {
 650       if (patch_code != lir_patch_none) {
 651         klass2reg_with_patching(dest-&gt;as_register(), info);
 652       } else {
 653         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 654       }
 655       break;
 656     }
 657 
 658     case T_FLOAT: {
 659       if (dest-&gt;is_single_xmm()) {
 660         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 661           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 662         } else {
 663           __ movflt(dest-&gt;as_xmm_float_reg(),
 664                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 665         }
 666       } else {
 667 #ifndef _LP64
 668         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 669         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 670         if (c-&gt;is_zero_float()) {
 671           __ fldz();
 672         } else if (c-&gt;is_one_float()) {
 673           __ fld1();
 674         } else {
 675           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 676         }
 677 #else
 678         ShouldNotReachHere();
 679 #endif // !_LP64
 680       }
 681       break;
 682     }
 683 
 684     case T_DOUBLE: {
 685       if (dest-&gt;is_double_xmm()) {
 686         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 687           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 688         } else {
 689           __ movdbl(dest-&gt;as_xmm_double_reg(),
 690                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 691         }
 692       } else {
 693 #ifndef _LP64
 694         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 695         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 696         if (c-&gt;is_zero_double()) {
 697           __ fldz();
 698         } else if (c-&gt;is_one_double()) {
 699           __ fld1();
 700         } else {
 701           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 702         }
 703 #else
 704         ShouldNotReachHere();
 705 #endif // !_LP64
 706       }
 707       break;
 708     }
 709 
 710     default:
 711       ShouldNotReachHere();
 712   }
 713 }
 714 
 715 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 716   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 717   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 718   LIR_Const* c = src-&gt;as_constant_ptr();
 719 
 720   switch (c-&gt;type()) {
 721     case T_INT:  // fall through
 722     case T_FLOAT:
 723       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 724       break;
 725 
 726     case T_ADDRESS:
 727       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 728       break;
 729 
 730     case T_INLINE_TYPE: // Fall through
 731     case T_OBJECT:
 732       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 733       break;
 734 
 735     case T_LONG:  // fall through
 736     case T_DOUBLE:
 737 #ifdef _LP64
 738       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 739                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 740 #else
 741       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 742                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 743       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 744                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 745 #endif // _LP64
 746       break;
 747 
 748     default:
 749       ShouldNotReachHere();
 750   }
 751 }
 752 
 753 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 754   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 755   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 756   LIR_Const* c = src-&gt;as_constant_ptr();
 757   LIR_Address* addr = dest-&gt;as_address_ptr();
 758 
 759   int null_check_here = code_offset();
 760   switch (type) {
 761     case T_INT:    // fall through
 762     case T_FLOAT:
 763       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 764       break;
 765 
 766     case T_ADDRESS:
 767       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 768       break;
 769 
 770     case T_INLINE_TYPE: // fall through
 771     case T_OBJECT:  // fall through
 772     case T_ARRAY:
 773       if (c-&gt;as_jobject() == NULL) {
 774         if (UseCompressedOops &amp;&amp; !wide) {
 775           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 776         } else {
 777 #ifdef _LP64
 778           __ xorptr(rscratch1, rscratch1);
 779           null_check_here = code_offset();
 780           __ movptr(as_Address(addr), rscratch1);
 781 #else
 782           __ movptr(as_Address(addr), NULL_WORD);
 783 #endif
 784         }
 785       } else {
 786         if (is_literal_address(addr)) {
 787           ShouldNotReachHere();
 788           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 789         } else {
 790 #ifdef _LP64
 791           __ movoop(rscratch1, c-&gt;as_jobject());
 792           if (UseCompressedOops &amp;&amp; !wide) {
 793             __ encode_heap_oop(rscratch1);
 794             null_check_here = code_offset();
 795             __ movl(as_Address_lo(addr), rscratch1);
 796           } else {
 797             null_check_here = code_offset();
 798             __ movptr(as_Address_lo(addr), rscratch1);
 799           }
 800 #else
 801           __ movoop(as_Address(addr), c-&gt;as_jobject());
 802 #endif
 803         }
 804       }
 805       break;
 806 
 807     case T_LONG:    // fall through
 808     case T_DOUBLE:
 809 #ifdef _LP64
 810       if (is_literal_address(addr)) {
 811         ShouldNotReachHere();
 812         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 813       } else {
 814         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 815         null_check_here = code_offset();
 816         __ movptr(as_Address_lo(addr), r10);
 817       }
 818 #else
 819       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 820       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 821       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 822 #endif // _LP64
 823       break;
 824 
 825     case T_BOOLEAN: // fall through
 826     case T_BYTE:
 827       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 828       break;
 829 
 830     case T_CHAR:    // fall through
 831     case T_SHORT:
 832       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 833       break;
 834 
 835     default:
 836       ShouldNotReachHere();
 837   };
 838 
 839   if (info != NULL) {
 840     add_debug_info_for_null_check(null_check_here, info);
 841   }
 842 }
 843 
 844 
 845 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 846   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 847   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 848 
 849   // move between cpu-registers
 850   if (dest-&gt;is_single_cpu()) {
 851 #ifdef _LP64
 852     if (src-&gt;type() == T_LONG) {
 853       // Can do LONG -&gt; OBJECT
 854       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 855       return;
 856     }
 857 #endif
 858     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 859     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_INLINE_TYPE) {
 860       __ verify_oop(src-&gt;as_register());
 861     }
 862     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 863 
 864   } else if (dest-&gt;is_double_cpu()) {
 865 #ifdef _LP64
 866     if (is_reference_type(src-&gt;type())) {
 867       // Surprising to me but we can see move of a long to t_object
 868       __ verify_oop(src-&gt;as_register());
 869       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 870       return;
 871     }
 872 #endif
 873     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 874     Register f_lo = src-&gt;as_register_lo();
 875     Register f_hi = src-&gt;as_register_hi();
 876     Register t_lo = dest-&gt;as_register_lo();
 877     Register t_hi = dest-&gt;as_register_hi();
 878 #ifdef _LP64
 879     assert(f_hi == f_lo, &quot;must be same&quot;);
 880     assert(t_hi == t_lo, &quot;must be same&quot;);
 881     move_regs(f_lo, t_lo);
 882 #else
 883     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 884 
 885 
 886     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 887       swap_reg(f_lo, f_hi);
 888     } else if (f_hi == t_lo) {
 889       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 890       move_regs(f_hi, t_hi);
 891       move_regs(f_lo, t_lo);
 892     } else {
 893       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 894       move_regs(f_lo, t_lo);
 895       move_regs(f_hi, t_hi);
 896     }
 897 #endif // LP64
 898 
 899 #ifndef _LP64
 900     // special moves from fpu-register to xmm-register
 901     // necessary for method results
 902   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 903     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 904     __ fld_s(Address(rsp, 0));
 905   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 906     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 907     __ fld_d(Address(rsp, 0));
 908   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 909     __ fstp_s(Address(rsp, 0));
 910     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 911   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 912     __ fstp_d(Address(rsp, 0));
 913     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 914 #endif // !_LP64
 915 
 916     // move between xmm-registers
 917   } else if (dest-&gt;is_single_xmm()) {
 918     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 919     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 920   } else if (dest-&gt;is_double_xmm()) {
 921     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 922     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 923 
 924 #ifndef _LP64
 925     // move between fpu-registers (no instruction necessary because of fpu-stack)
 926   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 927     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 928     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 929 #endif // !_LP64
 930 
 931   } else {
 932     ShouldNotReachHere();
 933   }
 934 }
 935 
 936 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 937   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 938   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 939 
 940   if (src-&gt;is_single_cpu()) {
 941     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 942     if (is_reference_type(type)) {
 943       __ verify_oop(src-&gt;as_register());
 944       __ movptr (dst, src-&gt;as_register());
 945     } else if (type == T_METADATA || type == T_ADDRESS) {
 946       __ movptr (dst, src-&gt;as_register());
 947     } else {
 948       __ movl (dst, src-&gt;as_register());
 949     }
 950 
 951   } else if (src-&gt;is_double_cpu()) {
 952     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 953     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 954     __ movptr (dstLO, src-&gt;as_register_lo());
 955     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 956 
 957   } else if (src-&gt;is_single_xmm()) {
 958     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 959     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 960 
 961   } else if (src-&gt;is_double_xmm()) {
 962     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 963     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 964 
 965 #ifndef _LP64
 966   } else if (src-&gt;is_single_fpu()) {
 967     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 968     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 969     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 970     else                   __ fst_s  (dst_addr);
 971 
 972   } else if (src-&gt;is_double_fpu()) {
 973     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
 974     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 975     if (pop_fpu_stack)     __ fstp_d (dst_addr);
 976     else                   __ fst_d  (dst_addr);
 977 #endif // !_LP64
 978 
 979   } else {
 980     ShouldNotReachHere();
 981   }
 982 }
 983 
 984 
 985 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 986   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 987   PatchingStub* patch = NULL;
 988   Register compressed_src = rscratch1;
 989 
 990   if (is_reference_type(type)) {
 991     __ verify_oop(src-&gt;as_register());
 992 #ifdef _LP64
 993     if (UseCompressedOops &amp;&amp; !wide) {
 994       __ movptr(compressed_src, src-&gt;as_register());
 995       __ encode_heap_oop(compressed_src);
 996       if (patch_code != lir_patch_none) {
 997         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
 998       }
 999     }
1000 #endif
1001   }
1002 
1003   if (patch_code != lir_patch_none) {
1004     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1005     Address toa = as_Address(to_addr);
1006     assert(toa.disp() != 0, &quot;must have&quot;);
1007   }
1008 
1009   int null_check_here = code_offset();
1010   switch (type) {
1011     case T_FLOAT: {
1012 #ifdef _LP64
1013       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
1014       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1015 #else
1016       if (src-&gt;is_single_xmm()) {
1017         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1018       } else {
1019         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
1020         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
1021         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
1022         else                    __ fst_s (as_Address(to_addr));
1023       }
1024 #endif // _LP64
1025       break;
1026     }
1027 
1028     case T_DOUBLE: {
1029 #ifdef _LP64
1030       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1031       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1032 #else
1033       if (src-&gt;is_double_xmm()) {
1034         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1035       } else {
1036         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1037         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1038         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1039         else                    __ fst_d (as_Address(to_addr));
1040       }
1041 #endif // _LP64
1042       break;
1043     }
1044 
1045     case T_INLINE_TYPE: // fall through
1046     case T_ARRAY:   // fall through
1047     case T_OBJECT:  // fall through
1048       if (UseCompressedOops &amp;&amp; !wide) {
1049         __ movl(as_Address(to_addr), compressed_src);
1050       } else {
1051         __ movptr(as_Address(to_addr), src-&gt;as_register());
1052       }
1053       break;
1054     case T_METADATA:
1055       // We get here to store a method pointer to the stack to pass to
1056       // a dtrace runtime call. This can&#39;t work on 64 bit with
1057       // compressed klass ptrs: T_METADATA can be a compressed klass
1058       // ptr or a 64 bit method pointer.
1059       LP64_ONLY(ShouldNotReachHere());
1060       __ movptr(as_Address(to_addr), src-&gt;as_register());
1061       break;
1062     case T_ADDRESS:
1063       __ movptr(as_Address(to_addr), src-&gt;as_register());
1064       break;
1065     case T_INT:
1066       __ movl(as_Address(to_addr), src-&gt;as_register());
1067       break;
1068 
1069     case T_LONG: {
1070       Register from_lo = src-&gt;as_register_lo();
1071       Register from_hi = src-&gt;as_register_hi();
1072 #ifdef _LP64
1073       __ movptr(as_Address_lo(to_addr), from_lo);
1074 #else
1075       Register base = to_addr-&gt;base()-&gt;as_register();
1076       Register index = noreg;
1077       if (to_addr-&gt;index()-&gt;is_register()) {
1078         index = to_addr-&gt;index()-&gt;as_register();
1079       }
1080       if (base == from_lo || index == from_lo) {
1081         assert(base != from_hi, &quot;can&#39;t be&quot;);
1082         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1083         __ movl(as_Address_hi(to_addr), from_hi);
1084         if (patch != NULL) {
1085           patching_epilog(patch, lir_patch_high, base, info);
1086           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1087           patch_code = lir_patch_low;
1088         }
1089         __ movl(as_Address_lo(to_addr), from_lo);
1090       } else {
1091         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1092         __ movl(as_Address_lo(to_addr), from_lo);
1093         if (patch != NULL) {
1094           patching_epilog(patch, lir_patch_low, base, info);
1095           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1096           patch_code = lir_patch_high;
1097         }
1098         __ movl(as_Address_hi(to_addr), from_hi);
1099       }
1100 #endif // _LP64
1101       break;
1102     }
1103 
1104     case T_BYTE:    // fall through
1105     case T_BOOLEAN: {
1106       Register src_reg = src-&gt;as_register();
1107       Address dst_addr = as_Address(to_addr);
1108       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1109       __ movb(dst_addr, src_reg);
1110       break;
1111     }
1112 
1113     case T_CHAR:    // fall through
1114     case T_SHORT:
1115       __ movw(as_Address(to_addr), src-&gt;as_register());
1116       break;
1117 
1118     default:
1119       ShouldNotReachHere();
1120   }
1121   if (info != NULL) {
1122     add_debug_info_for_null_check(null_check_here, info);
1123   }
1124 
1125   if (patch_code != lir_patch_none) {
1126     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1127   }
1128 }
1129 
1130 
1131 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1132   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1133   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1134 
1135   if (dest-&gt;is_single_cpu()) {
1136     if (is_reference_type(type)) {
1137       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1138       __ verify_oop(dest-&gt;as_register());
1139     } else if (type == T_METADATA || type == T_ADDRESS) {
1140       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1141     } else {
1142       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1143     }
1144 
1145   } else if (dest-&gt;is_double_cpu()) {
1146     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1147     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1148     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1149     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1150 
1151   } else if (dest-&gt;is_single_xmm()) {
1152     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1153     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1154 
1155   } else if (dest-&gt;is_double_xmm()) {
1156     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1157     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1158 
1159 #ifndef _LP64
1160   } else if (dest-&gt;is_single_fpu()) {
1161     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1162     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1163     __ fld_s(src_addr);
1164 
1165   } else if (dest-&gt;is_double_fpu()) {
1166     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1167     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1168     __ fld_d(src_addr);
1169 #endif // _LP64
1170 
1171   } else {
1172     ShouldNotReachHere();
1173   }
1174 }
1175 
1176 
1177 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1178   if (src-&gt;is_single_stack()) {
1179     if (is_reference_type(type)) {
1180       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1181       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1182     } else {
1183 #ifndef _LP64
1184       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1185       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1186 #else
1187       //no pushl on 64bits
1188       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1189       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1190 #endif
1191     }
1192 
1193   } else if (src-&gt;is_double_stack()) {
1194 #ifdef _LP64
1195     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1196     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1197 #else
1198     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1199     // push and pop the part at src + wordSize, adding wordSize for the previous push
1200     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1201     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1202     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1203 #endif // _LP64
1204 
1205   } else {
1206     ShouldNotReachHere();
1207   }
1208 }
1209 
1210 
1211 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1212   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1213   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1214 
1215   LIR_Address* addr = src-&gt;as_address_ptr();
1216   Address from_addr = as_Address(addr);
1217   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
1218 
1219   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_INLINE_TYPE) {
1220     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1221   }
1222 
1223   switch (type) {
1224     case T_BOOLEAN: // fall through
1225     case T_BYTE:    // fall through
1226     case T_CHAR:    // fall through
1227     case T_SHORT:
1228       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1229         // on pre P6 processors we may get partial register stalls
1230         // so blow away the value of to_rinfo before loading a
1231         // partial word into it.  Do it here so that it precedes
1232         // the potential patch point below.
1233         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1234       }
1235       break;
1236    default:
1237      break;
1238   }
1239 
1240   PatchingStub* patch = NULL;
1241   if (patch_code != lir_patch_none) {
1242     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1243     assert(from_addr.disp() != 0, &quot;must have&quot;);
1244   }
1245   if (info != NULL) {
1246     add_debug_info_for_null_check_here(info);
1247   }
1248 
1249   switch (type) {
1250     case T_FLOAT: {
1251       if (dest-&gt;is_single_xmm()) {
1252         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1253       } else {
1254 #ifndef _LP64
1255         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1256         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1257         __ fld_s(from_addr);
1258 #else
1259         ShouldNotReachHere();
1260 #endif // !LP64
1261       }
1262       break;
1263     }
1264 
1265     case T_DOUBLE: {
1266       if (dest-&gt;is_double_xmm()) {
1267         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1268       } else {
1269 #ifndef _LP64
1270         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1271         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1272         __ fld_d(from_addr);
1273 #else
1274         ShouldNotReachHere();
1275 #endif // !LP64
1276       }
1277       break;
1278     }
1279 
1280     case T_INLINE_TYPE: // fall through
1281     case T_OBJECT:  // fall through
1282     case T_ARRAY:   // fall through
1283       if (UseCompressedOops &amp;&amp; !wide) {
1284         __ movl(dest-&gt;as_register(), from_addr);
1285       } else {
1286         __ movptr(dest-&gt;as_register(), from_addr);
1287       }
1288       break;
1289 
1290     case T_ADDRESS:
1291       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1292         __ movl(dest-&gt;as_register(), from_addr);
1293       } else {
1294         __ movptr(dest-&gt;as_register(), from_addr);
1295       }
1296       break;
1297     case T_INT:
1298       __ movl(dest-&gt;as_register(), from_addr);
1299       break;
1300 
1301     case T_LONG: {
1302       Register to_lo = dest-&gt;as_register_lo();
1303       Register to_hi = dest-&gt;as_register_hi();
1304 #ifdef _LP64
1305       __ movptr(to_lo, as_Address_lo(addr));
1306 #else
1307       Register base = addr-&gt;base()-&gt;as_register();
1308       Register index = noreg;
1309       if (addr-&gt;index()-&gt;is_register()) {
1310         index = addr-&gt;index()-&gt;as_register();
1311       }
1312       if ((base == to_lo &amp;&amp; index == to_hi) ||
1313           (base == to_hi &amp;&amp; index == to_lo)) {
1314         // addresses with 2 registers are only formed as a result of
1315         // array access so this code will never have to deal with
1316         // patches or null checks.
1317         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1318         __ lea(to_hi, as_Address(addr));
1319         __ movl(to_lo, Address(to_hi, 0));
1320         __ movl(to_hi, Address(to_hi, BytesPerWord));
1321       } else if (base == to_lo || index == to_lo) {
1322         assert(base != to_hi, &quot;can&#39;t be&quot;);
1323         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1324         __ movl(to_hi, as_Address_hi(addr));
1325         if (patch != NULL) {
1326           patching_epilog(patch, lir_patch_high, base, info);
1327           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1328           patch_code = lir_patch_low;
1329         }
1330         __ movl(to_lo, as_Address_lo(addr));
1331       } else {
1332         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1333         __ movl(to_lo, as_Address_lo(addr));
1334         if (patch != NULL) {
1335           patching_epilog(patch, lir_patch_low, base, info);
1336           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1337           patch_code = lir_patch_high;
1338         }
1339         __ movl(to_hi, as_Address_hi(addr));
1340       }
1341 #endif // _LP64
1342       break;
1343     }
1344 
1345     case T_BOOLEAN: // fall through
1346     case T_BYTE: {
1347       Register dest_reg = dest-&gt;as_register();
1348       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1349       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1350         __ movsbl(dest_reg, from_addr);
1351       } else {
1352         __ movb(dest_reg, from_addr);
1353         __ shll(dest_reg, 24);
1354         __ sarl(dest_reg, 24);
1355       }
1356       break;
1357     }
1358 
1359     case T_CHAR: {
1360       Register dest_reg = dest-&gt;as_register();
1361       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1362       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1363         __ movzwl(dest_reg, from_addr);
1364       } else {
1365         __ movw(dest_reg, from_addr);
1366       }
1367       break;
1368     }
1369 
1370     case T_SHORT: {
1371       Register dest_reg = dest-&gt;as_register();
1372       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1373         __ movswl(dest_reg, from_addr);
1374       } else {
1375         __ movw(dest_reg, from_addr);
1376         __ shll(dest_reg, 16);
1377         __ sarl(dest_reg, 16);
1378       }
1379       break;
1380     }
1381 
1382     default:
1383       ShouldNotReachHere();
1384   }
1385 
1386   if (patch != NULL) {
1387     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1388   }
1389 
1390   if (is_reference_type(type)) {
1391 #ifdef _LP64
1392     if (UseCompressedOops &amp;&amp; !wide) {
1393       __ decode_heap_oop(dest-&gt;as_register());
1394     }
1395 #endif
1396 
1397     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1398     if (!UseZGC) {
1399       __ verify_oop(dest-&gt;as_register());
1400     }
1401   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1402 #ifdef _LP64
1403     if (UseCompressedClassPointers) {
1404       __ decode_klass_not_null(dest-&gt;as_register(), tmp_load_klass);
1405     }
1406 #endif
1407   }
1408 }
1409 
1410 
1411 NEEDS_CLEANUP; // This could be static?
1412 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1413   int elem_size = type2aelembytes(type);
1414   switch (elem_size) {
1415     case 1: return Address::times_1;
1416     case 2: return Address::times_2;
1417     case 4: return Address::times_4;
1418     case 8: return Address::times_8;
1419   }
1420   ShouldNotReachHere();
1421   return Address::no_scale;
1422 }
1423 
1424 
1425 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1426   switch (op-&gt;code()) {
1427     case lir_idiv:
1428     case lir_irem:
1429       arithmetic_idiv(op-&gt;code(),
1430                       op-&gt;in_opr1(),
1431                       op-&gt;in_opr2(),
1432                       op-&gt;in_opr3(),
1433                       op-&gt;result_opr(),
1434                       op-&gt;info());
1435       break;
1436     case lir_fmad:
1437       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1438               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1439               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1440               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1441       break;
1442     case lir_fmaf:
1443       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1444               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1445               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1446               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1447       break;
1448     default:      ShouldNotReachHere(); break;
1449   }
1450 }
1451 
1452 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1453 #ifdef ASSERT
1454   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1455   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1456   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1457 #endif
1458 
1459   if (op-&gt;cond() == lir_cond_always) {
1460     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1461     __ jmp (*(op-&gt;label()));
1462   } else {
1463     Assembler::Condition acond = Assembler::zero;
1464     if (op-&gt;code() == lir_cond_float_branch) {
1465       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1466       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1467       switch(op-&gt;cond()) {
1468         case lir_cond_equal:        acond = Assembler::equal;      break;
1469         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1470         case lir_cond_less:         acond = Assembler::below;      break;
1471         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1472         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1473         case lir_cond_greater:      acond = Assembler::above;      break;
1474         default:                         ShouldNotReachHere();
1475       }
1476     } else {
1477       switch (op-&gt;cond()) {
1478         case lir_cond_equal:        acond = Assembler::equal;       break;
1479         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1480         case lir_cond_less:         acond = Assembler::less;        break;
1481         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1482         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1483         case lir_cond_greater:      acond = Assembler::greater;     break;
1484         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1485         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1486         default:                         ShouldNotReachHere();
1487       }
1488     }
1489     __ jcc(acond,*(op-&gt;label()));
1490   }
1491 }
1492 
1493 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1494   LIR_Opr src  = op-&gt;in_opr();
1495   LIR_Opr dest = op-&gt;result_opr();
1496 
1497   switch (op-&gt;bytecode()) {
1498     case Bytecodes::_i2l:
1499 #ifdef _LP64
1500       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1501 #else
1502       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1503       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1504       __ sarl(dest-&gt;as_register_hi(), 31);
1505 #endif // LP64
1506       break;
1507 
1508     case Bytecodes::_l2i:
1509 #ifdef _LP64
1510       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1511 #else
1512       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1513 #endif
1514       break;
1515 
1516     case Bytecodes::_i2b:
1517       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1518       __ sign_extend_byte(dest-&gt;as_register());
1519       break;
1520 
1521     case Bytecodes::_i2c:
1522       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1523       __ andl(dest-&gt;as_register(), 0xFFFF);
1524       break;
1525 
1526     case Bytecodes::_i2s:
1527       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1528       __ sign_extend_short(dest-&gt;as_register());
1529       break;
1530 
1531 
1532 #ifdef _LP64
1533     case Bytecodes::_f2d:
1534       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1535       break;
1536 
1537     case Bytecodes::_d2f:
1538       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1539       break;
1540 
1541     case Bytecodes::_i2f:
1542       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1543       break;
1544 
1545     case Bytecodes::_i2d:
1546       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1547       break;
1548 
1549     case Bytecodes::_l2f:
1550       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1551       break;
1552 
1553     case Bytecodes::_l2d:
1554       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1555       break;
1556 
1557     case Bytecodes::_f2i:
1558       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1559       break;
1560 
1561     case Bytecodes::_d2i:
1562       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1563       break;
1564 
1565     case Bytecodes::_f2l:
1566       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1567       break;
1568 
1569     case Bytecodes::_d2l:
1570       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1571       break;
1572 #else
1573     case Bytecodes::_f2d:
1574     case Bytecodes::_d2f:
1575       if (dest-&gt;is_single_xmm()) {
1576         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1577       } else if (dest-&gt;is_double_xmm()) {
1578         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1579       } else {
1580         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1581         // do nothing (float result is rounded later through spilling)
1582       }
1583       break;
1584 
1585     case Bytecodes::_i2f:
1586     case Bytecodes::_i2d:
1587       if (dest-&gt;is_single_xmm()) {
1588         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1589       } else if (dest-&gt;is_double_xmm()) {
1590         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1591       } else {
1592         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1593         __ movl(Address(rsp, 0), src-&gt;as_register());
1594         __ fild_s(Address(rsp, 0));
1595       }
1596       break;
1597 
1598     case Bytecodes::_l2f:
1599     case Bytecodes::_l2d:
1600       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1601       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1602       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1603       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1604       __ fild_d(Address(rsp, 0));
1605       // float result is rounded later through spilling
1606       break;
1607 
1608     case Bytecodes::_f2i:
1609     case Bytecodes::_d2i:
1610       if (src-&gt;is_single_xmm()) {
1611         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1612       } else if (src-&gt;is_double_xmm()) {
1613         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1614       } else {
1615         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1616         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1617         __ fist_s(Address(rsp, 0));
1618         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1619         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1620       }
1621       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1622       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1623       __ cmpl(dest-&gt;as_register(), 0x80000000);
1624       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1625       __ bind(*op-&gt;stub()-&gt;continuation());
1626       break;
1627 
1628     case Bytecodes::_f2l:
1629     case Bytecodes::_d2l:
1630       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1631       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1632       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1633 
1634       // instruction sequence too long to inline it here
1635       {
1636         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1637       }
1638       break;
1639 #endif // _LP64
1640 
1641     default: ShouldNotReachHere();
1642   }
1643 }
1644 
1645 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1646   if (op-&gt;init_check()) {
1647     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1648     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1649                     InstanceKlass::init_state_offset()),
1650                     InstanceKlass::fully_initialized);
1651     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1652   }
1653   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1654                      op-&gt;tmp1()-&gt;as_register(),
1655                      op-&gt;tmp2()-&gt;as_register(),
1656                      op-&gt;header_size(),
1657                      op-&gt;object_size(),
1658                      op-&gt;klass()-&gt;as_register(),
1659                      *op-&gt;stub()-&gt;entry());
1660   __ bind(*op-&gt;stub()-&gt;continuation());
1661 }
1662 
1663 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1664   Register len =  op-&gt;len()-&gt;as_register();
1665   LP64_ONLY( __ movslq(len, len); )
1666 
1667   if (UseSlowPath || op-&gt;type() == T_INLINE_TYPE ||
1668       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1669       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1670     __ jmp(*op-&gt;stub()-&gt;entry());
1671   } else {
1672     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1673     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1674     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1675     if (len == tmp1) {
1676       tmp1 = tmp3;
1677     } else if (len == tmp2) {
1678       tmp2 = tmp3;
1679     } else if (len == tmp3) {
1680       // everything is ok
1681     } else {
1682       __ mov(tmp3, len);
1683     }
1684     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1685                       len,
1686                       tmp1,
1687                       tmp2,
1688                       arrayOopDesc::header_size(op-&gt;type()),
1689                       array_element_size(op-&gt;type()),
1690                       op-&gt;klass()-&gt;as_register(),
1691                       *op-&gt;stub()-&gt;entry());
1692   }
1693   __ bind(*op-&gt;stub()-&gt;continuation());
1694 }
1695 
1696 void LIR_Assembler::type_profile_helper(Register mdo,
1697                                         ciMethodData *md, ciProfileData *data,
1698                                         Register recv, Label* update_done) {
1699   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1700     Label next_test;
1701     // See if the receiver is receiver[n].
1702     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1703     __ jccb(Assembler::notEqual, next_test);
1704     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1705     __ addptr(data_addr, DataLayout::counter_increment);
1706     __ jmp(*update_done);
1707     __ bind(next_test);
1708   }
1709 
1710   // Didn&#39;t find receiver; find next empty slot and fill it in
1711   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1712     Label next_test;
1713     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1714     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1715     __ jccb(Assembler::notEqual, next_test);
1716     __ movptr(recv_addr, recv);
1717     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1718     __ jmp(*update_done);
1719     __ bind(next_test);
1720   }
1721 }
1722 
1723 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1724   // we always need a stub for the failure case.
1725   CodeStub* stub = op-&gt;stub();
1726   Register obj = op-&gt;object()-&gt;as_register();
1727   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1728   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1729   Register dst = op-&gt;result_opr()-&gt;as_register();
1730   ciKlass* k = op-&gt;klass();
1731   Register Rtmp1 = noreg;
1732   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
1733 
1734   // check if it needs to be profiled
1735   ciMethodData* md = NULL;
1736   ciProfileData* data = NULL;
1737 
1738   if (op-&gt;should_profile()) {
1739     ciMethod* method = op-&gt;profiled_method();
1740     assert(method != NULL, &quot;Should have method&quot;);
1741     int bci = op-&gt;profiled_bci();
1742     md = method-&gt;method_data_or_null();
1743     assert(md != NULL, &quot;Sanity&quot;);
1744     data = md-&gt;bci_to_data(bci);
1745     assert(data != NULL,                &quot;need data for type check&quot;);
1746     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1747   }
1748   Label profile_cast_success, profile_cast_failure;
1749   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1750   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1751 
1752   if (obj == k_RInfo) {
1753     k_RInfo = dst;
1754   } else if (obj == klass_RInfo) {
1755     klass_RInfo = dst;
1756   }
1757   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1758     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1759   } else {
1760     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1761     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1762   }
1763 
1764   assert_different_registers(obj, k_RInfo, klass_RInfo);
1765 
1766   if (op-&gt;need_null_check()) {
1767     __ cmpptr(obj, (int32_t)NULL_WORD);
1768     if (op-&gt;should_profile()) {
1769       Label not_null;
1770       __ jccb(Assembler::notEqual, not_null);
1771       // Object is null; update MDO and exit
1772       Register mdo  = klass_RInfo;
1773       __ mov_metadata(mdo, md-&gt;constant_encoding());
1774       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1775       int header_bits = BitData::null_seen_byte_constant();
1776       __ orb(data_addr, header_bits);
1777       __ jmp(*obj_is_null);
1778       __ bind(not_null);
1779     } else {
1780       __ jcc(Assembler::equal, *obj_is_null);
1781     }
1782   }
1783 
1784   if (!k-&gt;is_loaded()) {
1785     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1786   } else {
1787 #ifdef _LP64
1788     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1789 #endif // _LP64
1790   }
1791   __ verify_oop(obj);
1792 
1793   if (op-&gt;fast_check()) {
1794     // get object class
1795     // not a safepoint as obj null check happens earlier
1796 #ifdef _LP64
1797     if (UseCompressedClassPointers) {
1798       __ load_klass(Rtmp1, obj, tmp_load_klass);
1799       __ cmpptr(k_RInfo, Rtmp1);
1800     } else {
1801       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1802     }
1803 #else
1804     if (k-&gt;is_loaded()) {
1805       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1806     } else {
1807       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1808     }
1809 #endif
1810     __ jcc(Assembler::notEqual, *failure_target);
1811     // successful cast, fall through to profile or jump
1812   } else {
1813     // get object class
1814     // not a safepoint as obj null check happens earlier
1815     __ load_klass(klass_RInfo, obj, tmp_load_klass);
1816     if (k-&gt;is_loaded()) {
1817       // See if we get an immediate positive hit
1818 #ifdef _LP64
1819       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1820 #else
1821       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1822 #endif // _LP64
1823       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1824         __ jcc(Assembler::notEqual, *failure_target);
1825         // successful cast, fall through to profile or jump
1826       } else {
1827         // See if we get an immediate positive hit
1828         __ jcc(Assembler::equal, *success_target);
1829         // check for self
1830 #ifdef _LP64
1831         __ cmpptr(klass_RInfo, k_RInfo);
1832 #else
1833         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1834 #endif // _LP64
1835         __ jcc(Assembler::equal, *success_target);
1836 
1837         __ push(klass_RInfo);
1838 #ifdef _LP64
1839         __ push(k_RInfo);
1840 #else
1841         __ pushklass(k-&gt;constant_encoding());
1842 #endif // _LP64
1843         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1844         __ pop(klass_RInfo);
1845         __ pop(klass_RInfo);
1846         // result is a boolean
1847         __ cmpl(klass_RInfo, 0);
1848         __ jcc(Assembler::equal, *failure_target);
1849         // successful cast, fall through to profile or jump
1850       }
1851     } else {
1852       // perform the fast part of the checking logic
1853       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1854       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1855       __ push(klass_RInfo);
1856       __ push(k_RInfo);
1857       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1858       __ pop(klass_RInfo);
1859       __ pop(k_RInfo);
1860       // result is a boolean
1861       __ cmpl(k_RInfo, 0);
1862       __ jcc(Assembler::equal, *failure_target);
1863       // successful cast, fall through to profile or jump
1864     }
1865   }
1866   if (op-&gt;should_profile()) {
1867     Register mdo  = klass_RInfo, recv = k_RInfo;
1868     __ bind(profile_cast_success);
1869     __ mov_metadata(mdo, md-&gt;constant_encoding());
1870     __ load_klass(recv, obj, tmp_load_klass);
1871     type_profile_helper(mdo, md, data, recv, success);
1872     __ jmp(*success);
1873 
1874     __ bind(profile_cast_failure);
1875     __ mov_metadata(mdo, md-&gt;constant_encoding());
1876     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1877     __ subptr(counter_addr, DataLayout::counter_increment);
1878     __ jmp(*failure);
1879   }
1880   __ jmp(*success);
1881 }
1882 
1883 
1884 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1885   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
1886   LIR_Code code = op-&gt;code();
1887   if (code == lir_store_check) {
1888     Register value = op-&gt;object()-&gt;as_register();
1889     Register array = op-&gt;array()-&gt;as_register();
1890     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1891     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1892     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1893 
1894     CodeStub* stub = op-&gt;stub();
1895 
1896     // check if it needs to be profiled
1897     ciMethodData* md = NULL;
1898     ciProfileData* data = NULL;
1899 
1900     if (op-&gt;should_profile()) {
1901       ciMethod* method = op-&gt;profiled_method();
1902       assert(method != NULL, &quot;Should have method&quot;);
1903       int bci = op-&gt;profiled_bci();
1904       md = method-&gt;method_data_or_null();
1905       assert(md != NULL, &quot;Sanity&quot;);
1906       data = md-&gt;bci_to_data(bci);
1907       assert(data != NULL,                &quot;need data for type check&quot;);
1908       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1909     }
1910     Label profile_cast_success, profile_cast_failure, done;
1911     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1912     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1913 
1914     __ cmpptr(value, (int32_t)NULL_WORD);
1915     if (op-&gt;should_profile()) {
1916       Label not_null;
1917       __ jccb(Assembler::notEqual, not_null);
1918       // Object is null; update MDO and exit
1919       Register mdo  = klass_RInfo;
1920       __ mov_metadata(mdo, md-&gt;constant_encoding());
1921       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1922       int header_bits = BitData::null_seen_byte_constant();
1923       __ orb(data_addr, header_bits);
1924       __ jmp(done);
1925       __ bind(not_null);
1926     } else {
1927       __ jcc(Assembler::equal, done);
1928     }
1929 
1930     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1931     __ load_klass(k_RInfo, array, tmp_load_klass);
1932     __ load_klass(klass_RInfo, value, tmp_load_klass);
1933 
1934     // get instance klass (it&#39;s already uncompressed)
1935     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1936     // perform the fast part of the checking logic
1937     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1938     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1939     __ push(klass_RInfo);
1940     __ push(k_RInfo);
1941     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1942     __ pop(klass_RInfo);
1943     __ pop(k_RInfo);
1944     // result is a boolean
1945     __ cmpl(k_RInfo, 0);
1946     __ jcc(Assembler::equal, *failure_target);
1947     // fall through to the success case
1948 
1949     if (op-&gt;should_profile()) {
1950       Register mdo  = klass_RInfo, recv = k_RInfo;
1951       __ bind(profile_cast_success);
1952       __ mov_metadata(mdo, md-&gt;constant_encoding());
1953       __ load_klass(recv, value, tmp_load_klass);
1954       type_profile_helper(mdo, md, data, recv, &amp;done);
1955       __ jmpb(done);
1956 
1957       __ bind(profile_cast_failure);
1958       __ mov_metadata(mdo, md-&gt;constant_encoding());
1959       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1960       __ subptr(counter_addr, DataLayout::counter_increment);
1961       __ jmp(*stub-&gt;entry());
1962     }
1963 
1964     __ bind(done);
1965   } else
1966     if (code == lir_checkcast) {
1967       Register obj = op-&gt;object()-&gt;as_register();
1968       Register dst = op-&gt;result_opr()-&gt;as_register();
1969       Label success;
1970       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1971       __ bind(success);
1972       if (dst != obj) {
1973         __ mov(dst, obj);
1974       }
1975     } else
1976       if (code == lir_instanceof) {
1977         Register obj = op-&gt;object()-&gt;as_register();
1978         Register dst = op-&gt;result_opr()-&gt;as_register();
1979         Label success, failure, done;
1980         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1981         __ bind(failure);
1982         __ xorptr(dst, dst);
1983         __ jmpb(done);
1984         __ bind(success);
1985         __ movptr(dst, 1);
1986         __ bind(done);
1987       } else {
1988         ShouldNotReachHere();
1989       }
1990 
1991 }
1992 
1993 void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {
1994   // We are loading/storing from/to an array that *may* be flattened (the
1995   // declared type is Object[], abstract[], interface[] or VT.ref[]).
1996   // If this array is flattened, take the slow path.
1997   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
1998   Register klass = op-&gt;tmp()-&gt;as_register();
1999   __ load_klass(klass, op-&gt;array()-&gt;as_register(), tmp_load_klass);
2000   __ movl(klass, Address(klass, Klass::layout_helper_offset()));
2001   __ testl(klass, Klass::_lh_array_tag_vt_value_bit_inplace);
2002   __ jcc(Assembler::notZero, *op-&gt;stub()-&gt;entry());
2003   if (!op-&gt;value()-&gt;is_illegal()) {
2004     // The array is not flattened, but it might be null-free. If we are storing
2005     // a null into a null-free array, take the slow path (which will throw NPE).
2006     Label skip;
2007     __ cmpptr(op-&gt;value()-&gt;as_register(), (int32_t)NULL_WORD);
2008     __ jcc(Assembler::notEqual, skip);
2009     __ testl(klass, Klass::_lh_null_free_bit_inplace);
2010     __ jcc(Assembler::notZero, *op-&gt;stub()-&gt;entry());
2011     __ bind(skip);
2012   }
2013 }
2014 
2015 void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {
2016   // We are storing into an array that *may* be null-free (the declared type is
2017   // Object[], abstract[], interface[] or VT.ref[]).
2018   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
2019   Register klass = op-&gt;tmp()-&gt;as_register();
2020   __ load_klass(klass, op-&gt;array()-&gt;as_register(), tmp_load_klass);
2021   __ movl(klass, Address(klass, Klass::layout_helper_offset()));
2022   __ testl(klass, Klass::_lh_null_free_bit_inplace);
2023 }
2024 
2025 void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {
2026   Label L_oops_equal;
2027   Label L_oops_not_equal;
2028   Label L_end;
2029 
2030   Register left  = op-&gt;left()-&gt;as_register();
2031   Register right = op-&gt;right()-&gt;as_register();
2032 
2033   __ cmpptr(left, right);
2034   __ jcc(Assembler::equal, L_oops_equal);
2035 
2036   // (1) Null check -- if one of the operands is null, the other must not be null (because
2037   //     the two references are not equal), so they are not substitutable,
2038   //     FIXME: do null check only if the operand is nullable
2039   {
2040     __ cmpptr(left, (int32_t)NULL_WORD);
2041     __ jcc(Assembler::equal, L_oops_not_equal);
2042 
2043     __ cmpptr(right, (int32_t)NULL_WORD);
2044     __ jcc(Assembler::equal, L_oops_not_equal);
2045   }
2046 
2047   ciKlass* left_klass = op-&gt;left_klass();
2048   ciKlass* right_klass = op-&gt;right_klass();
2049 
2050   // (2) Value object check -- if either of the operands is not a value object,
2051   //     they are not substitutable. We do this only if we are not sure that the
2052   //     operands are value objects
2053   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.
<a name="5" id="anc5"></a><span class="line-modified">2054       !left_klass-&gt;is_valuetype() || !right_klass-&gt;is_valuetype()) {</span>
2055     Register tmp1  = op-&gt;tmp1()-&gt;as_register();
2056     __ movptr(tmp1, (intptr_t)markWord::always_locked_pattern);
2057     __ andl(tmp1, Address(left, oopDesc::mark_offset_in_bytes()));
2058     __ andl(tmp1, Address(right, oopDesc::mark_offset_in_bytes()));
2059     __ cmpptr(tmp1, (intptr_t)markWord::always_locked_pattern);
2060     __ jcc(Assembler::notEqual, L_oops_not_equal);
2061   }
2062 
2063   // (3) Same klass check: if the operands are of different klasses, they are not substitutable.
<a name="6" id="anc6"></a><span class="line-modified">2064   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_valuetype() &amp;&amp; left_klass == right_klass) {</span>
<span class="line-modified">2065     // No need to load klass -- the operands are statically known to be the same value klass.</span>
2066     __ jmp(*op-&gt;stub()-&gt;entry());
2067   } else {
2068     Register left_klass_op = op-&gt;left_klass_op()-&gt;as_register();
2069     Register right_klass_op = op-&gt;right_klass_op()-&gt;as_register();
2070 
2071     if (UseCompressedOops) {
2072       __ movl(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
2073       __ movl(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
2074       __ cmpl(left_klass_op, right_klass_op);
2075     } else {
2076       __ movptr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
2077       __ movptr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
2078       __ cmpptr(left_klass_op, right_klass_op);
2079     }
2080 
2081     __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry()); // same klass -&gt; do slow check
2082     // fall through to L_oops_not_equal
2083   }
2084 
2085   __ bind(L_oops_not_equal);
2086   move(op-&gt;not_equal_result(), op-&gt;result_opr());
2087   __ jmp(L_end);
2088 
2089   __ bind(L_oops_equal);
2090   move(op-&gt;equal_result(), op-&gt;result_opr());
2091   __ jmp(L_end);
2092 
2093   // We&#39;ve returned from the stub. RAX contains 0x0 IFF the two
2094   // operands are not substitutable. (Don&#39;t compare against 0x1 in case the
2095   // C compiler is naughty)
2096   __ bind(*op-&gt;stub()-&gt;continuation());
2097   __ cmpl(rax, 0);
2098   __ jcc(Assembler::equal, L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal
2099   move(op-&gt;equal_result(), op-&gt;result_opr()); // (call_stub() != 0x0) -&gt; equal
2100   // fall-through
2101   __ bind(L_end);
2102 }
2103 
2104 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2105   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
2106     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
2107     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
2108     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
2109     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
2110     Register addr = op-&gt;addr()-&gt;as_register();
2111     __ lock();
2112     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
2113 
2114   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
2115     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
2116     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2117     Register newval = op-&gt;new_value()-&gt;as_register();
2118     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
2119     assert(cmpval == rax, &quot;wrong register&quot;);
2120     assert(newval != NULL, &quot;new val must be register&quot;);
2121     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2122     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2123     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2124 
2125     if ( op-&gt;code() == lir_cas_obj) {
2126 #ifdef _LP64
2127       if (UseCompressedOops) {
2128         __ encode_heap_oop(cmpval);
2129         __ mov(rscratch1, newval);
2130         __ encode_heap_oop(rscratch1);
2131         __ lock();
2132         // cmpval (rax) is implicitly used by this instruction
2133         __ cmpxchgl(rscratch1, Address(addr, 0));
2134       } else
2135 #endif
2136       {
2137         __ lock();
2138         __ cmpxchgptr(newval, Address(addr, 0));
2139       }
2140     } else {
2141       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
2142       __ lock();
2143       __ cmpxchgl(newval, Address(addr, 0));
2144     }
2145 #ifdef _LP64
2146   } else if (op-&gt;code() == lir_cas_long) {
2147     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2148     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2149     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2150     assert(cmpval == rax, &quot;wrong register&quot;);
2151     assert(newval != NULL, &quot;new val must be register&quot;);
2152     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2153     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2154     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2155     __ lock();
2156     __ cmpxchgq(newval, Address(addr, 0));
2157 #endif // _LP64
2158   } else {
2159     Unimplemented();
2160   }
2161 }
2162 
2163 void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {
2164   assert(dst-&gt;is_cpu_register(), &quot;must be&quot;);
2165   assert(dst-&gt;type() == src-&gt;type(), &quot;must be&quot;);
2166 
2167   if (src-&gt;is_cpu_register()) {
2168     reg2reg(src, dst);
2169   } else if (src-&gt;is_stack()) {
2170     stack2reg(src, dst, dst-&gt;type());
2171   } else if (src-&gt;is_constant()) {
2172     const2reg(src, dst, lir_patch_none, NULL);
2173   } else {
2174     ShouldNotReachHere();
2175   }
2176 }
2177 
2178 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2179   Assembler::Condition acond, ncond;
2180   switch (condition) {
2181     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2182     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2183     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2184     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2185     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2186     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2187     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2188     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2189     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2190                                 ShouldNotReachHere();
2191   }
2192 
2193   if (opr1-&gt;is_cpu_register()) {
2194     reg2reg(opr1, result);
2195   } else if (opr1-&gt;is_stack()) {
2196     stack2reg(opr1, result, result-&gt;type());
2197   } else if (opr1-&gt;is_constant()) {
2198     const2reg(opr1, result, lir_patch_none, NULL);
2199   } else {
2200     ShouldNotReachHere();
2201   }
2202 
2203   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2204     // optimized version that does not require a branch
2205     if (opr2-&gt;is_single_cpu()) {
2206       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2207       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2208     } else if (opr2-&gt;is_double_cpu()) {
2209       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2210       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2211       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2212       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2213     } else if (opr2-&gt;is_single_stack()) {
2214       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2215     } else if (opr2-&gt;is_double_stack()) {
2216       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2217       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2218     } else {
2219       ShouldNotReachHere();
2220     }
2221 
2222   } else {
2223     Label skip;
2224     __ jcc (acond, skip);
2225     if (opr2-&gt;is_cpu_register()) {
2226       reg2reg(opr2, result);
2227     } else if (opr2-&gt;is_stack()) {
2228       stack2reg(opr2, result, result-&gt;type());
2229     } else if (opr2-&gt;is_constant()) {
2230       const2reg(opr2, result, lir_patch_none, NULL);
2231     } else {
2232       ShouldNotReachHere();
2233     }
2234     __ bind(skip);
2235   }
2236 }
2237 
2238 
2239 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2240   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2241 
2242   if (left-&gt;is_single_cpu()) {
2243     assert(left == dest, &quot;left and dest must be equal&quot;);
2244     Register lreg = left-&gt;as_register();
2245 
2246     if (right-&gt;is_single_cpu()) {
2247       // cpu register - cpu register
2248       Register rreg = right-&gt;as_register();
2249       switch (code) {
2250         case lir_add: __ addl (lreg, rreg); break;
2251         case lir_sub: __ subl (lreg, rreg); break;
2252         case lir_mul: __ imull(lreg, rreg); break;
2253         default:      ShouldNotReachHere();
2254       }
2255 
2256     } else if (right-&gt;is_stack()) {
2257       // cpu register - stack
2258       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2259       switch (code) {
2260         case lir_add: __ addl(lreg, raddr); break;
2261         case lir_sub: __ subl(lreg, raddr); break;
2262         default:      ShouldNotReachHere();
2263       }
2264 
2265     } else if (right-&gt;is_constant()) {
2266       // cpu register - constant
2267       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2268       switch (code) {
2269         case lir_add: {
2270           __ incrementl(lreg, c);
2271           break;
2272         }
2273         case lir_sub: {
2274           __ decrementl(lreg, c);
2275           break;
2276         }
2277         default: ShouldNotReachHere();
2278       }
2279 
2280     } else {
2281       ShouldNotReachHere();
2282     }
2283 
2284   } else if (left-&gt;is_double_cpu()) {
2285     assert(left == dest, &quot;left and dest must be equal&quot;);
2286     Register lreg_lo = left-&gt;as_register_lo();
2287     Register lreg_hi = left-&gt;as_register_hi();
2288 
2289     if (right-&gt;is_double_cpu()) {
2290       // cpu register - cpu register
2291       Register rreg_lo = right-&gt;as_register_lo();
2292       Register rreg_hi = right-&gt;as_register_hi();
2293       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2294       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2295       switch (code) {
2296         case lir_add:
2297           __ addptr(lreg_lo, rreg_lo);
2298           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2299           break;
2300         case lir_sub:
2301           __ subptr(lreg_lo, rreg_lo);
2302           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2303           break;
2304         case lir_mul:
2305 #ifdef _LP64
2306           __ imulq(lreg_lo, rreg_lo);
2307 #else
2308           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2309           __ imull(lreg_hi, rreg_lo);
2310           __ imull(rreg_hi, lreg_lo);
2311           __ addl (rreg_hi, lreg_hi);
2312           __ mull (rreg_lo);
2313           __ addl (lreg_hi, rreg_hi);
2314 #endif // _LP64
2315           break;
2316         default:
2317           ShouldNotReachHere();
2318       }
2319 
2320     } else if (right-&gt;is_constant()) {
2321       // cpu register - constant
2322 #ifdef _LP64
2323       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2324       __ movptr(r10, (intptr_t) c);
2325       switch (code) {
2326         case lir_add:
2327           __ addptr(lreg_lo, r10);
2328           break;
2329         case lir_sub:
2330           __ subptr(lreg_lo, r10);
2331           break;
2332         default:
2333           ShouldNotReachHere();
2334       }
2335 #else
2336       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2337       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2338       switch (code) {
2339         case lir_add:
2340           __ addptr(lreg_lo, c_lo);
2341           __ adcl(lreg_hi, c_hi);
2342           break;
2343         case lir_sub:
2344           __ subptr(lreg_lo, c_lo);
2345           __ sbbl(lreg_hi, c_hi);
2346           break;
2347         default:
2348           ShouldNotReachHere();
2349       }
2350 #endif // _LP64
2351 
2352     } else {
2353       ShouldNotReachHere();
2354     }
2355 
2356   } else if (left-&gt;is_single_xmm()) {
2357     assert(left == dest, &quot;left and dest must be equal&quot;);
2358     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2359 
2360     if (right-&gt;is_single_xmm()) {
2361       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2362       switch (code) {
2363         case lir_add: __ addss(lreg, rreg);  break;
2364         case lir_sub: __ subss(lreg, rreg);  break;
2365         case lir_mul_strictfp: // fall through
2366         case lir_mul: __ mulss(lreg, rreg);  break;
2367         case lir_div_strictfp: // fall through
2368         case lir_div: __ divss(lreg, rreg);  break;
2369         default: ShouldNotReachHere();
2370       }
2371     } else {
2372       Address raddr;
2373       if (right-&gt;is_single_stack()) {
2374         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2375       } else if (right-&gt;is_constant()) {
2376         // hack for now
2377         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2378       } else {
2379         ShouldNotReachHere();
2380       }
2381       switch (code) {
2382         case lir_add: __ addss(lreg, raddr);  break;
2383         case lir_sub: __ subss(lreg, raddr);  break;
2384         case lir_mul_strictfp: // fall through
2385         case lir_mul: __ mulss(lreg, raddr);  break;
2386         case lir_div_strictfp: // fall through
2387         case lir_div: __ divss(lreg, raddr);  break;
2388         default: ShouldNotReachHere();
2389       }
2390     }
2391 
2392   } else if (left-&gt;is_double_xmm()) {
2393     assert(left == dest, &quot;left and dest must be equal&quot;);
2394 
2395     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2396     if (right-&gt;is_double_xmm()) {
2397       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2398       switch (code) {
2399         case lir_add: __ addsd(lreg, rreg);  break;
2400         case lir_sub: __ subsd(lreg, rreg);  break;
2401         case lir_mul_strictfp: // fall through
2402         case lir_mul: __ mulsd(lreg, rreg);  break;
2403         case lir_div_strictfp: // fall through
2404         case lir_div: __ divsd(lreg, rreg);  break;
2405         default: ShouldNotReachHere();
2406       }
2407     } else {
2408       Address raddr;
2409       if (right-&gt;is_double_stack()) {
2410         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2411       } else if (right-&gt;is_constant()) {
2412         // hack for now
2413         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2414       } else {
2415         ShouldNotReachHere();
2416       }
2417       switch (code) {
2418         case lir_add: __ addsd(lreg, raddr);  break;
2419         case lir_sub: __ subsd(lreg, raddr);  break;
2420         case lir_mul_strictfp: // fall through
2421         case lir_mul: __ mulsd(lreg, raddr);  break;
2422         case lir_div_strictfp: // fall through
2423         case lir_div: __ divsd(lreg, raddr);  break;
2424         default: ShouldNotReachHere();
2425       }
2426     }
2427 
2428 #ifndef _LP64
2429   } else if (left-&gt;is_single_fpu()) {
2430     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2431 
2432     if (right-&gt;is_single_fpu()) {
2433       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2434 
2435     } else {
2436       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2437       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2438 
2439       Address raddr;
2440       if (right-&gt;is_single_stack()) {
2441         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2442       } else if (right-&gt;is_constant()) {
2443         address const_addr = float_constant(right-&gt;as_jfloat());
2444         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2445         // hack for now
2446         raddr = __ as_Address(InternalAddress(const_addr));
2447       } else {
2448         ShouldNotReachHere();
2449       }
2450 
2451       switch (code) {
2452         case lir_add: __ fadd_s(raddr); break;
2453         case lir_sub: __ fsub_s(raddr); break;
2454         case lir_mul_strictfp: // fall through
2455         case lir_mul: __ fmul_s(raddr); break;
2456         case lir_div_strictfp: // fall through
2457         case lir_div: __ fdiv_s(raddr); break;
2458         default:      ShouldNotReachHere();
2459       }
2460     }
2461 
2462   } else if (left-&gt;is_double_fpu()) {
2463     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2464 
2465     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2466       // Double values require special handling for strictfp mul/div on x86
2467       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2468       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2469     }
2470 
2471     if (right-&gt;is_double_fpu()) {
2472       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2473 
2474     } else {
2475       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2476       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2477 
2478       Address raddr;
2479       if (right-&gt;is_double_stack()) {
2480         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2481       } else if (right-&gt;is_constant()) {
2482         // hack for now
2483         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2484       } else {
2485         ShouldNotReachHere();
2486       }
2487 
2488       switch (code) {
2489         case lir_add: __ fadd_d(raddr); break;
2490         case lir_sub: __ fsub_d(raddr); break;
2491         case lir_mul_strictfp: // fall through
2492         case lir_mul: __ fmul_d(raddr); break;
2493         case lir_div_strictfp: // fall through
2494         case lir_div: __ fdiv_d(raddr); break;
2495         default: ShouldNotReachHere();
2496       }
2497     }
2498 
2499     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2500       // Double values require special handling for strictfp mul/div on x86
2501       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2502       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2503     }
2504 #endif // !_LP64
2505 
2506   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2507     assert(left == dest, &quot;left and dest must be equal&quot;);
2508 
2509     Address laddr;
2510     if (left-&gt;is_single_stack()) {
2511       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2512     } else if (left-&gt;is_address()) {
2513       laddr = as_Address(left-&gt;as_address_ptr());
2514     } else {
2515       ShouldNotReachHere();
2516     }
2517 
2518     if (right-&gt;is_single_cpu()) {
2519       Register rreg = right-&gt;as_register();
2520       switch (code) {
2521         case lir_add: __ addl(laddr, rreg); break;
2522         case lir_sub: __ subl(laddr, rreg); break;
2523         default:      ShouldNotReachHere();
2524       }
2525     } else if (right-&gt;is_constant()) {
2526       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2527       switch (code) {
2528         case lir_add: {
2529           __ incrementl(laddr, c);
2530           break;
2531         }
2532         case lir_sub: {
2533           __ decrementl(laddr, c);
2534           break;
2535         }
2536         default: ShouldNotReachHere();
2537       }
2538     } else {
2539       ShouldNotReachHere();
2540     }
2541 
2542   } else {
2543     ShouldNotReachHere();
2544   }
2545 }
2546 
2547 #ifndef _LP64
2548 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2549   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2550   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2551   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2552 
2553   bool left_is_tos = (left_index == 0);
2554   bool dest_is_tos = (dest_index == 0);
2555   int non_tos_index = (left_is_tos ? right_index : left_index);
2556 
2557   switch (code) {
2558     case lir_add:
2559       if (pop_fpu_stack)       __ faddp(non_tos_index);
2560       else if (dest_is_tos)    __ fadd (non_tos_index);
2561       else                     __ fadda(non_tos_index);
2562       break;
2563 
2564     case lir_sub:
2565       if (left_is_tos) {
2566         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2567         else if (dest_is_tos)  __ fsub  (non_tos_index);
2568         else                   __ fsubra(non_tos_index);
2569       } else {
2570         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2571         else if (dest_is_tos)  __ fsubr (non_tos_index);
2572         else                   __ fsuba (non_tos_index);
2573       }
2574       break;
2575 
2576     case lir_mul_strictfp: // fall through
2577     case lir_mul:
2578       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2579       else if (dest_is_tos)    __ fmul (non_tos_index);
2580       else                     __ fmula(non_tos_index);
2581       break;
2582 
2583     case lir_div_strictfp: // fall through
2584     case lir_div:
2585       if (left_is_tos) {
2586         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2587         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2588         else                   __ fdivra(non_tos_index);
2589       } else {
2590         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2591         else if (dest_is_tos)  __ fdivr (non_tos_index);
2592         else                   __ fdiva (non_tos_index);
2593       }
2594       break;
2595 
2596     case lir_rem:
2597       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2598       __ fremr(noreg);
2599       break;
2600 
2601     default:
2602       ShouldNotReachHere();
2603   }
2604 }
2605 #endif // _LP64
2606 
2607 
2608 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2609   if (value-&gt;is_double_xmm()) {
2610     switch(code) {
2611       case lir_abs :
2612         {
2613 #ifdef _LP64
2614           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2615             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2616             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2617           } else
2618 #endif
2619           {
2620             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2621               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2622             }
2623             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2624             __ andpd(dest-&gt;as_xmm_double_reg(),
2625                      ExternalAddress((address)double_signmask_pool));
2626           }
2627         }
2628         break;
2629 
2630       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2631       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2632       default      : ShouldNotReachHere();
2633     }
2634 
2635 #ifndef _LP64
2636   } else if (value-&gt;is_double_fpu()) {
2637     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2638     switch(code) {
2639       case lir_abs   : __ fabs() ; break;
2640       case lir_sqrt  : __ fsqrt(); break;
2641       default      : ShouldNotReachHere();
2642     }
2643 #endif // !_LP64
2644   } else {
2645     Unimplemented();
2646   }
2647 }
2648 
2649 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2650   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2651   if (left-&gt;is_single_cpu()) {
2652     Register reg = left-&gt;as_register();
2653     if (right-&gt;is_constant()) {
2654       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2655       switch (code) {
2656         case lir_logic_and: __ andl (reg, val); break;
2657         case lir_logic_or:  __ orl  (reg, val); break;
2658         case lir_logic_xor: __ xorl (reg, val); break;
2659         default: ShouldNotReachHere();
2660       }
2661     } else if (right-&gt;is_stack()) {
2662       // added support for stack operands
2663       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2664       switch (code) {
2665         case lir_logic_and: __ andl (reg, raddr); break;
2666         case lir_logic_or:  __ orl  (reg, raddr); break;
2667         case lir_logic_xor: __ xorl (reg, raddr); break;
2668         default: ShouldNotReachHere();
2669       }
2670     } else {
2671       Register rright = right-&gt;as_register();
2672       switch (code) {
2673         case lir_logic_and: __ andptr (reg, rright); break;
2674         case lir_logic_or : __ orptr  (reg, rright); break;
2675         case lir_logic_xor: __ xorptr (reg, rright); break;
2676         default: ShouldNotReachHere();
2677       }
2678     }
2679     move_regs(reg, dst-&gt;as_register());
2680   } else {
2681     Register l_lo = left-&gt;as_register_lo();
2682     Register l_hi = left-&gt;as_register_hi();
2683     if (right-&gt;is_constant()) {
2684 #ifdef _LP64
2685       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2686       switch (code) {
2687         case lir_logic_and:
2688           __ andq(l_lo, rscratch1);
2689           break;
2690         case lir_logic_or:
2691           __ orq(l_lo, rscratch1);
2692           break;
2693         case lir_logic_xor:
2694           __ xorq(l_lo, rscratch1);
2695           break;
2696         default: ShouldNotReachHere();
2697       }
2698 #else
2699       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2700       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2701       switch (code) {
2702         case lir_logic_and:
2703           __ andl(l_lo, r_lo);
2704           __ andl(l_hi, r_hi);
2705           break;
2706         case lir_logic_or:
2707           __ orl(l_lo, r_lo);
2708           __ orl(l_hi, r_hi);
2709           break;
2710         case lir_logic_xor:
2711           __ xorl(l_lo, r_lo);
2712           __ xorl(l_hi, r_hi);
2713           break;
2714         default: ShouldNotReachHere();
2715       }
2716 #endif // _LP64
2717     } else {
2718 #ifdef _LP64
2719       Register r_lo;
2720       if (is_reference_type(right-&gt;type())) {
2721         r_lo = right-&gt;as_register();
2722       } else {
2723         r_lo = right-&gt;as_register_lo();
2724       }
2725 #else
2726       Register r_lo = right-&gt;as_register_lo();
2727       Register r_hi = right-&gt;as_register_hi();
2728       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2729 #endif
2730       switch (code) {
2731         case lir_logic_and:
2732           __ andptr(l_lo, r_lo);
2733           NOT_LP64(__ andptr(l_hi, r_hi);)
2734           break;
2735         case lir_logic_or:
2736           __ orptr(l_lo, r_lo);
2737           NOT_LP64(__ orptr(l_hi, r_hi);)
2738           break;
2739         case lir_logic_xor:
2740           __ xorptr(l_lo, r_lo);
2741           NOT_LP64(__ xorptr(l_hi, r_hi);)
2742           break;
2743         default: ShouldNotReachHere();
2744       }
2745     }
2746 
2747     Register dst_lo = dst-&gt;as_register_lo();
2748     Register dst_hi = dst-&gt;as_register_hi();
2749 
2750 #ifdef _LP64
2751     move_regs(l_lo, dst_lo);
2752 #else
2753     if (dst_lo == l_hi) {
2754       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2755       move_regs(l_hi, dst_hi);
2756       move_regs(l_lo, dst_lo);
2757     } else {
2758       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2759       move_regs(l_lo, dst_lo);
2760       move_regs(l_hi, dst_hi);
2761     }
2762 #endif // _LP64
2763   }
2764 }
2765 
2766 
2767 // we assume that rax, and rdx can be overwritten
2768 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2769 
2770   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2771   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2772   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2773 
2774   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2775   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2776 
2777   Register lreg = left-&gt;as_register();
2778   Register dreg = result-&gt;as_register();
2779 
2780   if (right-&gt;is_constant()) {
2781     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2782     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2783     if (code == lir_idiv) {
2784       assert(lreg == rax, &quot;must be rax,&quot;);
2785       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2786       __ cdql(); // sign extend into rdx:rax
2787       if (divisor == 2) {
2788         __ subl(lreg, rdx);
2789       } else {
2790         __ andl(rdx, divisor - 1);
2791         __ addl(lreg, rdx);
2792       }
2793       __ sarl(lreg, log2_jint(divisor));
2794       move_regs(lreg, dreg);
2795     } else if (code == lir_irem) {
2796       Label done;
2797       __ mov(dreg, lreg);
2798       __ andl(dreg, 0x80000000 | (divisor - 1));
2799       __ jcc(Assembler::positive, done);
2800       __ decrement(dreg);
2801       __ orl(dreg, ~(divisor - 1));
2802       __ increment(dreg);
2803       __ bind(done);
2804     } else {
2805       ShouldNotReachHere();
2806     }
2807   } else {
2808     Register rreg = right-&gt;as_register();
2809     assert(lreg == rax, &quot;left register must be rax,&quot;);
2810     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2811     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2812 
2813     move_regs(lreg, rax);
2814 
2815     int idivl_offset = __ corrected_idivl(rreg);
2816     if (ImplicitDiv0Checks) {
2817       add_debug_info_for_div0(idivl_offset, info);
2818     }
2819     if (code == lir_irem) {
2820       move_regs(rdx, dreg); // result is in rdx
2821     } else {
2822       move_regs(rax, dreg);
2823     }
2824   }
2825 }
2826 
2827 
2828 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2829   if (opr1-&gt;is_single_cpu()) {
2830     Register reg1 = opr1-&gt;as_register();
2831     if (opr2-&gt;is_single_cpu()) {
2832       // cpu register - cpu register
2833       if (is_reference_type(opr1-&gt;type())) {
2834         __ cmpoop(reg1, opr2-&gt;as_register());
2835       } else {
2836         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2837         __ cmpl(reg1, opr2-&gt;as_register());
2838       }
2839     } else if (opr2-&gt;is_stack()) {
2840       // cpu register - stack
2841       if (is_reference_type(opr1-&gt;type())) {
2842         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2843       } else {
2844         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2845       }
2846     } else if (opr2-&gt;is_constant()) {
2847       // cpu register - constant
2848       LIR_Const* c = opr2-&gt;as_constant_ptr();
2849       if (c-&gt;type() == T_INT) {
2850         __ cmpl(reg1, c-&gt;as_jint());
2851       } else if (c-&gt;type() == T_METADATA) {
2852         // All we need for now is a comparison with NULL for equality.
2853         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2854         Metadata* m = c-&gt;as_metadata();
2855         if (m == NULL) {
2856           __ cmpptr(reg1, (int32_t)0);
2857         } else {
2858           ShouldNotReachHere();
2859         }
2860       } else if (is_reference_type(c-&gt;type())) {
2861         // In 64bit oops are single register
2862         jobject o = c-&gt;as_jobject();
2863         if (o == NULL) {
2864           __ cmpptr(reg1, (int32_t)NULL_WORD);
2865         } else {
2866           __ cmpoop(reg1, o);
2867         }
2868       } else {
2869         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2870       }
2871       // cpu register - address
2872     } else if (opr2-&gt;is_address()) {
2873       if (op-&gt;info() != NULL) {
2874         add_debug_info_for_null_check_here(op-&gt;info());
2875       }
2876       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2877     } else {
2878       ShouldNotReachHere();
2879     }
2880 
2881   } else if(opr1-&gt;is_double_cpu()) {
2882     Register xlo = opr1-&gt;as_register_lo();
2883     Register xhi = opr1-&gt;as_register_hi();
2884     if (opr2-&gt;is_double_cpu()) {
2885 #ifdef _LP64
2886       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2887 #else
2888       // cpu register - cpu register
2889       Register ylo = opr2-&gt;as_register_lo();
2890       Register yhi = opr2-&gt;as_register_hi();
2891       __ subl(xlo, ylo);
2892       __ sbbl(xhi, yhi);
2893       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2894         __ orl(xhi, xlo);
2895       }
2896 #endif // _LP64
2897     } else if (opr2-&gt;is_constant()) {
2898       // cpu register - constant 0
2899       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2900 #ifdef _LP64
2901       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2902 #else
2903       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2904       __ orl(xhi, xlo);
2905 #endif // _LP64
2906     } else {
2907       ShouldNotReachHere();
2908     }
2909 
2910   } else if (opr1-&gt;is_single_xmm()) {
2911     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2912     if (opr2-&gt;is_single_xmm()) {
2913       // xmm register - xmm register
2914       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2915     } else if (opr2-&gt;is_stack()) {
2916       // xmm register - stack
2917       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2918     } else if (opr2-&gt;is_constant()) {
2919       // xmm register - constant
2920       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2921     } else if (opr2-&gt;is_address()) {
2922       // xmm register - address
2923       if (op-&gt;info() != NULL) {
2924         add_debug_info_for_null_check_here(op-&gt;info());
2925       }
2926       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2927     } else {
2928       ShouldNotReachHere();
2929     }
2930 
2931   } else if (opr1-&gt;is_double_xmm()) {
2932     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2933     if (opr2-&gt;is_double_xmm()) {
2934       // xmm register - xmm register
2935       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2936     } else if (opr2-&gt;is_stack()) {
2937       // xmm register - stack
2938       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2939     } else if (opr2-&gt;is_constant()) {
2940       // xmm register - constant
2941       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2942     } else if (opr2-&gt;is_address()) {
2943       // xmm register - address
2944       if (op-&gt;info() != NULL) {
2945         add_debug_info_for_null_check_here(op-&gt;info());
2946       }
2947       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2948     } else {
2949       ShouldNotReachHere();
2950     }
2951 
2952 #ifndef _LP64
2953   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2954     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2955     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2956     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2957 #endif // LP64
2958 
2959   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2960     LIR_Const* c = opr2-&gt;as_constant_ptr();
2961 #ifdef _LP64
2962     if (is_reference_type(c-&gt;type())) {
2963       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2964       __ movoop(rscratch1, c-&gt;as_jobject());
2965     }
2966 #endif // LP64
2967     if (op-&gt;info() != NULL) {
2968       add_debug_info_for_null_check_here(op-&gt;info());
2969     }
2970     // special case: address - constant
2971     LIR_Address* addr = opr1-&gt;as_address_ptr();
2972     if (c-&gt;type() == T_INT) {
2973       __ cmpl(as_Address(addr), c-&gt;as_jint());
2974     } else if (is_reference_type(c-&gt;type())) {
2975 #ifdef _LP64
2976       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
2977       // better strategy by giving noreg as the temp for as_Address
2978       __ cmpoop(rscratch1, as_Address(addr, noreg));
2979 #else
2980       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
2981 #endif // _LP64
2982     } else {
2983       ShouldNotReachHere();
2984     }
2985 
2986   } else {
2987     ShouldNotReachHere();
2988   }
2989 }
2990 
2991 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
2992   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2993     if (left-&gt;is_single_xmm()) {
2994       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
2995       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2996     } else if (left-&gt;is_double_xmm()) {
2997       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
2998       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2999 
3000     } else {
3001 #ifdef _LP64
3002       ShouldNotReachHere();
3003 #else
3004       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
3005       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
3006 
3007       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
3008       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
3009                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
3010 #endif // LP64
3011     }
3012   } else {
3013     assert(code == lir_cmp_l2i, &quot;check&quot;);
3014 #ifdef _LP64
3015     Label done;
3016     Register dest = dst-&gt;as_register();
3017     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
3018     __ movl(dest, -1);
3019     __ jccb(Assembler::less, done);
3020     __ set_byte_if_not_zero(dest);
3021     __ movzbl(dest, dest);
3022     __ bind(done);
3023 #else
3024     __ lcmp2int(left-&gt;as_register_hi(),
3025                 left-&gt;as_register_lo(),
3026                 right-&gt;as_register_hi(),
3027                 right-&gt;as_register_lo());
3028     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
3029 #endif // _LP64
3030   }
3031 }
3032 
3033 
3034 void LIR_Assembler::align_call(LIR_Code code) {
3035   // make sure that the displacement word of the call ends up word aligned
3036   int offset = __ offset();
3037   switch (code) {
3038   case lir_static_call:
3039   case lir_optvirtual_call:
3040   case lir_dynamic_call:
3041     offset += NativeCall::displacement_offset;
3042     break;
3043   case lir_icvirtual_call:
3044     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
3045     break;
3046   case lir_virtual_call:  // currently, sparc-specific for niagara
3047   default: ShouldNotReachHere();
3048   }
3049   __ align(BytesPerWord, offset);
3050 }
3051 
3052 
3053 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
3054   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
3055          &quot;must be aligned&quot;);
3056   __ call(AddressLiteral(op-&gt;addr(), rtype));
3057   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());
3058 }
3059 
3060 
3061 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
3062   __ ic_call(op-&gt;addr());
3063   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());
3064   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
3065          &quot;must be aligned&quot;);
3066 }
3067 
3068 
3069 /* Currently, vtable-dispatch is only enabled for sparc platforms */
3070 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
3071   ShouldNotReachHere();
3072 }
3073 
3074 
3075 void LIR_Assembler::emit_static_call_stub() {
3076   address call_pc = __ pc();
3077   address stub = __ start_a_stub(call_stub_size());
3078   if (stub == NULL) {
3079     bailout(&quot;static call stub overflow&quot;);
3080     return;
3081   }
3082 
3083   int start = __ offset();
3084 
3085   // make sure that the displacement word of the call ends up word aligned
3086   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
3087   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
3088   __ mov_metadata(rbx, (Metadata*)NULL);
3089   // must be set to -1 at code generation time
3090   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
3091   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
3092   __ jump(RuntimeAddress(__ pc()));
3093 
3094   if (UseAOT) {
3095     // Trampoline to aot code
3096     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
3097 #ifdef _LP64
3098     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
3099 #else
3100     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
3101 #endif
3102     __ jmp(rax);
3103   }
3104   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
3105   __ end_a_stub();
3106 }
3107 
3108 
3109 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
3110   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3111   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
3112 
3113   // exception object is not added to oop map by LinearScan
3114   // (LinearScan assumes that no oops are in fixed registers)
3115   info-&gt;add_register_oop(exceptionOop);
3116   Runtime1::StubID unwind_id;
3117 
3118   // get current pc information
3119   // pc is only needed if the method has an exception handler, the unwind code does not need it.
3120   int pc_for_athrow_offset = __ offset();
3121   InternalAddress pc_for_athrow(__ pc());
3122   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
3123   add_call_info(pc_for_athrow_offset, info); // for exception handler
3124 
3125   __ verify_not_null_oop(rax);
3126   // search an exception handler (rax: exception oop, rdx: throwing pc)
3127   if (compilation()-&gt;has_fpu_code()) {
3128     unwind_id = Runtime1::handle_exception_id;
3129   } else {
3130     unwind_id = Runtime1::handle_exception_nofpu_id;
3131   }
3132   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
3133 
3134   // enough room for two byte trap
3135   __ nop();
3136 }
3137 
3138 
3139 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
3140   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3141 
3142   __ jmp(_unwind_handler_entry);
3143 }
3144 
3145 
3146 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
3147 
3148   // optimized version for linear scan:
3149   // * count must be already in ECX (guaranteed by LinearScan)
3150   // * left and dest must be equal
3151   // * tmp must be unused
3152   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
3153   assert(left == dest, &quot;left and dest must be equal&quot;);
3154   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3155 
3156   if (left-&gt;is_single_cpu()) {
3157     Register value = left-&gt;as_register();
3158     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
3159 
3160     switch (code) {
3161       case lir_shl:  __ shll(value); break;
3162       case lir_shr:  __ sarl(value); break;
3163       case lir_ushr: __ shrl(value); break;
3164       default: ShouldNotReachHere();
3165     }
3166   } else if (left-&gt;is_double_cpu()) {
3167     Register lo = left-&gt;as_register_lo();
3168     Register hi = left-&gt;as_register_hi();
3169     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3170 #ifdef _LP64
3171     switch (code) {
3172       case lir_shl:  __ shlptr(lo);        break;
3173       case lir_shr:  __ sarptr(lo);        break;
3174       case lir_ushr: __ shrptr(lo);        break;
3175       default: ShouldNotReachHere();
3176     }
3177 #else
3178 
3179     switch (code) {
3180       case lir_shl:  __ lshl(hi, lo);        break;
3181       case lir_shr:  __ lshr(hi, lo, true);  break;
3182       case lir_ushr: __ lshr(hi, lo, false); break;
3183       default: ShouldNotReachHere();
3184     }
3185 #endif // LP64
3186   } else {
3187     ShouldNotReachHere();
3188   }
3189 }
3190 
3191 
3192 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3193   if (dest-&gt;is_single_cpu()) {
3194     // first move left into dest so that left is not destroyed by the shift
3195     Register value = dest-&gt;as_register();
3196     count = count &amp; 0x1F; // Java spec
3197 
3198     move_regs(left-&gt;as_register(), value);
3199     switch (code) {
3200       case lir_shl:  __ shll(value, count); break;
3201       case lir_shr:  __ sarl(value, count); break;
3202       case lir_ushr: __ shrl(value, count); break;
3203       default: ShouldNotReachHere();
3204     }
3205   } else if (dest-&gt;is_double_cpu()) {
3206 #ifndef _LP64
3207     Unimplemented();
3208 #else
3209     // first move left into dest so that left is not destroyed by the shift
3210     Register value = dest-&gt;as_register_lo();
3211     count = count &amp; 0x1F; // Java spec
3212 
3213     move_regs(left-&gt;as_register_lo(), value);
3214     switch (code) {
3215       case lir_shl:  __ shlptr(value, count); break;
3216       case lir_shr:  __ sarptr(value, count); break;
3217       case lir_ushr: __ shrptr(value, count); break;
3218       default: ShouldNotReachHere();
3219     }
3220 #endif // _LP64
3221   } else {
3222     ShouldNotReachHere();
3223   }
3224 }
3225 
3226 
3227 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3228   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3229   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3230   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3231   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3232 }
3233 
3234 
3235 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3236   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3237   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3238   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3239   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3240 }
3241 
3242 
3243 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3244   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3245   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3246   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3247   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3248 }
3249 
3250 
3251 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3252   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3253   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3254   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3255   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3256 }
3257 
3258 
<a name="7" id="anc7"></a><span class="line-modified">3259 void LIR_Assembler::arraycopy_valuetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest, bool null_check) {</span>
3260   if (null_check) {
3261     __ testptr(obj, obj);
3262     __ jcc(Assembler::zero, *slow_path-&gt;entry());
3263   }
3264   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3265   __ load_klass(tmp, obj, tmp_load_klass);
3266   __ movl(tmp, Address(tmp, Klass::layout_helper_offset()));
3267   if (is_dest) {
3268     // We also take slow path if it&#39;s a null_free destination array, just in case the source array
3269     // contains NULLs.
3270     __ testl(tmp, Klass::_lh_null_free_bit_inplace);
3271   } else {
3272     __ testl(tmp, Klass::_lh_array_tag_vt_value_bit_inplace);
3273   }
3274   __ jcc(Assembler::notZero, *slow_path-&gt;entry());
3275 }
3276 
3277 
3278 // This code replaces a call to arraycopy; no exception may
3279 // be thrown in this code, they must be thrown in the System.arraycopy
3280 // activation frame; we could save some checks if this would not be the case
3281 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3282   ciArrayKlass* default_type = op-&gt;expected_type();
3283   Register src = op-&gt;src()-&gt;as_register();
3284   Register dst = op-&gt;dst()-&gt;as_register();
3285   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3286   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3287   Register length  = op-&gt;length()-&gt;as_register();
3288   Register tmp = op-&gt;tmp()-&gt;as_register();
3289   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3290 
3291   __ resolve(ACCESS_READ, src);
3292   __ resolve(ACCESS_WRITE, dst);
3293 
3294   CodeStub* stub = op-&gt;stub();
3295   int flags = op-&gt;flags();
3296   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3297   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3298 
3299   if (flags &amp; LIR_OpArrayCopy::always_slow_path) {
3300     __ jmp(*stub-&gt;entry());
3301     __ bind(*stub-&gt;continuation());
3302     return;
3303   }
3304 
<a name="8" id="anc8"></a><span class="line-modified">3305   if (flags &amp; LIR_OpArrayCopy::src_valuetype_check) {</span>
<span class="line-modified">3306     arraycopy_valuetype_check(src, tmp, stub, false, (flags &amp; LIR_OpArrayCopy::src_null_check));</span>
3307   }
3308 
<a name="9" id="anc9"></a><span class="line-modified">3309   if (flags &amp; LIR_OpArrayCopy::dst_valuetype_check) {</span>
<span class="line-modified">3310     arraycopy_valuetype_check(dst, tmp, stub, true, (flags &amp; LIR_OpArrayCopy::dst_null_check));</span>
3311   }
3312 
3313   // if we don&#39;t know anything, just go through the generic arraycopy
3314   if (default_type == NULL) {
3315     // save outgoing arguments on stack in case call to System.arraycopy is needed
3316     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3317     // for interpreter calling conventions. Now we have to do it in new style conventions.
3318     // For the moment until C1 gets the new register allocator I just force all the
3319     // args to the right place (except the register args) and then on the back side
3320     // reload the register args properly if we go slow path. Yuck
3321 
3322     // These are proper for the calling convention
3323     store_parameter(length, 2);
3324     store_parameter(dst_pos, 1);
3325     store_parameter(dst, 0);
3326 
3327     // these are just temporary placements until we need to reload
3328     store_parameter(src_pos, 3);
3329     store_parameter(src, 4);
3330     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3331 
3332     address copyfunc_addr = StubRoutines::generic_arraycopy();
3333     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3334 
3335     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3336 #ifdef _LP64
3337     // The arguments are in java calling convention so we can trivially shift them to C
3338     // convention
3339     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3340     __ mov(c_rarg0, j_rarg0);
3341     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3342     __ mov(c_rarg1, j_rarg1);
3343     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3344     __ mov(c_rarg2, j_rarg2);
3345     assert_different_registers(c_rarg3, j_rarg4);
3346     __ mov(c_rarg3, j_rarg3);
3347 #ifdef _WIN64
3348     // Allocate abi space for args but be sure to keep stack aligned
3349     __ subptr(rsp, 6*wordSize);
3350     store_parameter(j_rarg4, 4);
3351 #ifndef PRODUCT
3352     if (PrintC1Statistics) {
3353       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3354     }
3355 #endif
3356     __ call(RuntimeAddress(copyfunc_addr));
3357     __ addptr(rsp, 6*wordSize);
3358 #else
3359     __ mov(c_rarg4, j_rarg4);
3360 #ifndef PRODUCT
3361     if (PrintC1Statistics) {
3362       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3363     }
3364 #endif
3365     __ call(RuntimeAddress(copyfunc_addr));
3366 #endif // _WIN64
3367 #else
3368     __ push(length);
3369     __ push(dst_pos);
3370     __ push(dst);
3371     __ push(src_pos);
3372     __ push(src);
3373 
3374 #ifndef PRODUCT
3375     if (PrintC1Statistics) {
3376       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3377     }
3378 #endif
3379     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3380 
3381 #endif // _LP64
3382 
3383     __ cmpl(rax, 0);
3384     __ jcc(Assembler::equal, *stub-&gt;continuation());
3385 
3386     __ mov(tmp, rax);
3387     __ xorl(tmp, -1);
3388 
3389     // Reload values from the stack so they are where the stub
3390     // expects them.
3391     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3392     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3393     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3394     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3395     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3396 
3397     __ subl(length, tmp);
3398     __ addl(src_pos, tmp);
3399     __ addl(dst_pos, tmp);
3400     __ jmp(*stub-&gt;entry());
3401 
3402     __ bind(*stub-&gt;continuation());
3403     return;
3404   }
3405 
3406   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3407 
3408   int elem_size = type2aelembytes(basic_type);
3409   Address::ScaleFactor scale;
3410 
3411   switch (elem_size) {
3412     case 1 :
3413       scale = Address::times_1;
3414       break;
3415     case 2 :
3416       scale = Address::times_2;
3417       break;
3418     case 4 :
3419       scale = Address::times_4;
3420       break;
3421     case 8 :
3422       scale = Address::times_8;
3423       break;
3424     default:
3425       scale = Address::no_scale;
3426       ShouldNotReachHere();
3427   }
3428 
3429   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3430   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3431   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3432   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3433 
3434   // length and pos&#39;s are all sign extended at this point on 64bit
3435 
3436   // test for NULL
3437   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3438     __ testptr(src, src);
3439     __ jcc(Assembler::zero, *stub-&gt;entry());
3440   }
3441   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3442     __ testptr(dst, dst);
3443     __ jcc(Assembler::zero, *stub-&gt;entry());
3444   }
3445 
3446   // If the compiler was not able to prove that exact type of the source or the destination
3447   // of the arraycopy is an array type, check at runtime if the source or the destination is
3448   // an instance type.
3449   if (flags &amp; LIR_OpArrayCopy::type_check) {
3450     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3451       __ load_klass(tmp, dst, tmp_load_klass);
3452       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3453       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3454     }
3455 
3456     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3457       __ load_klass(tmp, src, tmp_load_klass);
3458       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3459       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3460     }
3461   }
3462 
3463   // check if negative
3464   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3465     __ testl(src_pos, src_pos);
3466     __ jcc(Assembler::less, *stub-&gt;entry());
3467   }
3468   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3469     __ testl(dst_pos, dst_pos);
3470     __ jcc(Assembler::less, *stub-&gt;entry());
3471   }
3472 
3473   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3474     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3475     __ cmpl(tmp, src_length_addr);
3476     __ jcc(Assembler::above, *stub-&gt;entry());
3477   }
3478   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3479     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3480     __ cmpl(tmp, dst_length_addr);
3481     __ jcc(Assembler::above, *stub-&gt;entry());
3482   }
3483 
3484   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3485     __ testl(length, length);
3486     __ jcc(Assembler::less, *stub-&gt;entry());
3487   }
3488 
3489 #ifdef _LP64
3490   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3491   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3492 #endif
3493 
3494   if (flags &amp; LIR_OpArrayCopy::type_check) {
3495     // We don&#39;t know the array types are compatible
3496     if (basic_type != T_OBJECT) {
3497       // Simple test for basic type arrays
3498       if (UseCompressedClassPointers) {
3499         __ movl(tmp, src_klass_addr);
3500         __ cmpl(tmp, dst_klass_addr);
3501       } else {
3502         __ movptr(tmp, src_klass_addr);
3503         __ cmpptr(tmp, dst_klass_addr);
3504       }
3505       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3506     } else {
3507       // For object arrays, if src is a sub class of dst then we can
3508       // safely do the copy.
3509       Label cont, slow;
3510 
3511       __ push(src);
3512       __ push(dst);
3513 
3514       __ load_klass(src, src, tmp_load_klass);
3515       __ load_klass(dst, dst, tmp_load_klass);
3516 
3517       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3518 
3519       __ push(src);
3520       __ push(dst);
3521       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3522       __ pop(dst);
3523       __ pop(src);
3524 
3525       __ cmpl(src, 0);
3526       __ jcc(Assembler::notEqual, cont);
3527 
3528       __ bind(slow);
3529       __ pop(dst);
3530       __ pop(src);
3531 
3532       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3533       if (copyfunc_addr != NULL) { // use stub if available
3534         // src is not a sub class of dst so we have to do a
3535         // per-element check.
3536 
3537         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3538         if ((flags &amp; mask) != mask) {
3539           // Check that at least both of them object arrays.
3540           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3541 
3542           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3543             __ load_klass(tmp, src, tmp_load_klass);
3544           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3545             __ load_klass(tmp, dst, tmp_load_klass);
3546           }
3547           int lh_offset = in_bytes(Klass::layout_helper_offset());
3548           Address klass_lh_addr(tmp, lh_offset);
3549           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3550           __ cmpl(klass_lh_addr, objArray_lh);
3551           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3552         }
3553 
3554        // Spill because stubs can use any register they like and it&#39;s
3555        // easier to restore just those that we care about.
3556        store_parameter(dst, 0);
3557        store_parameter(dst_pos, 1);
3558        store_parameter(length, 2);
3559        store_parameter(src_pos, 3);
3560        store_parameter(src, 4);
3561 
3562 #ifndef _LP64
3563         __ movptr(tmp, dst_klass_addr);
3564         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3565         __ push(tmp);
3566         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3567         __ push(tmp);
3568         __ push(length);
3569         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3570         __ push(tmp);
3571         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3572         __ push(tmp);
3573 
3574         __ call_VM_leaf(copyfunc_addr, 5);
3575 #else
3576         __ movl2ptr(length, length); //higher 32bits must be null
3577 
3578         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3579         assert_different_registers(c_rarg0, dst, dst_pos, length);
3580         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3581         assert_different_registers(c_rarg1, dst, length);
3582 
3583         __ mov(c_rarg2, length);
3584         assert_different_registers(c_rarg2, dst);
3585 
3586 #ifdef _WIN64
3587         // Allocate abi space for args but be sure to keep stack aligned
3588         __ subptr(rsp, 6*wordSize);
3589         __ load_klass(c_rarg3, dst, tmp_load_klass);
3590         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3591         store_parameter(c_rarg3, 4);
3592         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3593         __ call(RuntimeAddress(copyfunc_addr));
3594         __ addptr(rsp, 6*wordSize);
3595 #else
3596         __ load_klass(c_rarg4, dst, tmp_load_klass);
3597         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3598         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3599         __ call(RuntimeAddress(copyfunc_addr));
3600 #endif
3601 
3602 #endif
3603 
3604 #ifndef PRODUCT
3605         if (PrintC1Statistics) {
3606           Label failed;
3607           __ testl(rax, rax);
3608           __ jcc(Assembler::notZero, failed);
3609           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3610           __ bind(failed);
3611         }
3612 #endif
3613 
3614         __ testl(rax, rax);
3615         __ jcc(Assembler::zero, *stub-&gt;continuation());
3616 
3617 #ifndef PRODUCT
3618         if (PrintC1Statistics) {
3619           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3620         }
3621 #endif
3622 
3623         __ mov(tmp, rax);
3624 
3625         __ xorl(tmp, -1);
3626 
3627         // Restore previously spilled arguments
3628         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3629         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3630         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3631         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3632         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3633 
3634 
3635         __ subl(length, tmp);
3636         __ addl(src_pos, tmp);
3637         __ addl(dst_pos, tmp);
3638       }
3639 
3640       __ jmp(*stub-&gt;entry());
3641 
3642       __ bind(cont);
3643       __ pop(dst);
3644       __ pop(src);
3645     }
3646   }
3647 
3648 #ifdef ASSERT
3649   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3650     // Sanity check the known type with the incoming class.  For the
3651     // primitive case the types must match exactly with src.klass and
3652     // dst.klass each exactly matching the default type.  For the
3653     // object array case, if no type check is needed then either the
3654     // dst type is exactly the expected type and the src type is a
3655     // subtype which we can&#39;t check or src is the same array as dst
3656     // but not necessarily exactly of type default_type.
3657     Label known_ok, halt;
3658     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3659 #ifdef _LP64
3660     if (UseCompressedClassPointers) {
3661       __ encode_klass_not_null(tmp, rscratch1);
3662     }
3663 #endif
3664 
3665     if (basic_type != T_OBJECT) {
3666 
3667       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3668       else                   __ cmpptr(tmp, dst_klass_addr);
3669       __ jcc(Assembler::notEqual, halt);
3670       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3671       else                   __ cmpptr(tmp, src_klass_addr);
3672       __ jcc(Assembler::equal, known_ok);
3673     } else {
3674       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3675       else                   __ cmpptr(tmp, dst_klass_addr);
3676       __ jcc(Assembler::equal, known_ok);
3677       __ cmpptr(src, dst);
3678       __ jcc(Assembler::equal, known_ok);
3679     }
3680     __ bind(halt);
3681     __ stop(&quot;incorrect type information in arraycopy&quot;);
3682     __ bind(known_ok);
3683   }
3684 #endif
3685 
3686 #ifndef PRODUCT
3687   if (PrintC1Statistics) {
3688     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3689   }
3690 #endif
3691 
3692 #ifdef _LP64
3693   assert_different_registers(c_rarg0, dst, dst_pos, length);
3694   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3695   assert_different_registers(c_rarg1, length);
3696   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3697   __ mov(c_rarg2, length);
3698 
3699 #else
3700   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3701   store_parameter(tmp, 0);
3702   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3703   store_parameter(tmp, 1);
3704   store_parameter(length, 2);
3705 #endif // _LP64
3706 
3707   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3708   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3709   const char *name;
3710   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3711   __ call_VM_leaf(entry, 0);
3712 
3713   __ bind(*stub-&gt;continuation());
3714 }
3715 
3716 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3717   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3718   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3719   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3720   Register crc = op-&gt;crc()-&gt;as_register();
3721   Register val = op-&gt;val()-&gt;as_register();
3722   Register res = op-&gt;result_opr()-&gt;as_register();
3723 
3724   assert_different_registers(val, crc, res);
3725 
3726   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3727   __ notl(crc); // ~crc
3728   __ update_byte_crc32(crc, val, res);
3729   __ notl(crc); // ~crc
3730   __ mov(res, crc);
3731 }
3732 
3733 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3734   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3735   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3736   Register lock = op-&gt;lock_opr()-&gt;as_register();
3737   if (!UseFastLocking) {
3738     __ jmp(*op-&gt;stub()-&gt;entry());
3739   } else if (op-&gt;code() == lir_lock) {
3740     Register scratch = noreg;
3741     if (UseBiasedLocking) {
3742       scratch = op-&gt;scratch_opr()-&gt;as_register();
3743     }
3744     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3745     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3746     // add debug info for NullPointerException only if one is possible
3747     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3748     if (op-&gt;info() != NULL) {
3749       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3750     }
3751     // done
3752   } else if (op-&gt;code() == lir_unlock) {
3753     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3754     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3755   } else {
3756     Unimplemented();
3757   }
3758   __ bind(*op-&gt;stub()-&gt;continuation());
3759 }
3760 
3761 
3762 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3763   ciMethod* method = op-&gt;profiled_method();
3764   int bci          = op-&gt;profiled_bci();
3765   ciMethod* callee = op-&gt;profiled_callee();
3766   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3767 
3768   // Update counter for all call types
3769   ciMethodData* md = method-&gt;method_data_or_null();
3770   assert(md != NULL, &quot;Sanity&quot;);
3771   ciProfileData* data = md-&gt;bci_to_data(bci);
3772   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3773   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3774   Register mdo  = op-&gt;mdo()-&gt;as_register();
3775   __ mov_metadata(mdo, md-&gt;constant_encoding());
3776   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3777   // Perform additional virtual call profiling for invokevirtual and
3778   // invokeinterface bytecodes
3779   if (op-&gt;should_profile_receiver_type()) {
3780     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3781     Register recv = op-&gt;recv()-&gt;as_register();
3782     assert_different_registers(mdo, recv);
3783     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3784     ciKlass* known_klass = op-&gt;known_holder();
3785     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3786       // We know the type that will be seen at this call site; we can
3787       // statically update the MethodData* rather than needing to do
3788       // dynamic tests on the receiver type
3789 
3790       // NOTE: we should probably put a lock around this search to
3791       // avoid collisions by concurrent compilations
3792       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3793       uint i;
3794       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3795         ciKlass* receiver = vc_data-&gt;receiver(i);
3796         if (known_klass-&gt;equals(receiver)) {
3797           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3798           __ addptr(data_addr, DataLayout::counter_increment);
3799           return;
3800         }
3801       }
3802 
3803       // Receiver type not found in profile data; select an empty slot
3804 
3805       // Note that this is less efficient than it should be because it
3806       // always does a write to the receiver part of the
3807       // VirtualCallData rather than just the first time
3808       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3809         ciKlass* receiver = vc_data-&gt;receiver(i);
3810         if (receiver == NULL) {
3811           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3812           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3813           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3814           __ addptr(data_addr, DataLayout::counter_increment);
3815           return;
3816         }
3817       }
3818     } else {
3819       __ load_klass(recv, recv, tmp_load_klass);
3820       Label update_done;
3821       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3822       // Receiver did not match any saved receiver and there is no empty row for it.
3823       // Increment total counter to indicate polymorphic case.
3824       __ addptr(counter_addr, DataLayout::counter_increment);
3825 
3826       __ bind(update_done);
3827     }
3828   } else {
3829     // Static call
3830     __ addptr(counter_addr, DataLayout::counter_increment);
3831   }
3832 }
3833 
3834 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3835   Register obj = op-&gt;obj()-&gt;as_register();
3836   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3837   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3838   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3839   ciKlass* exact_klass = op-&gt;exact_klass();
3840   intptr_t current_klass = op-&gt;current_klass();
3841   bool not_null = op-&gt;not_null();
3842   bool no_conflict = op-&gt;no_conflict();
3843 
3844   Label update, next, none;
3845 
3846   bool do_null = !not_null;
3847   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3848   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3849 
3850   assert(do_null || do_update, &quot;why are we here?&quot;);
3851   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3852 
3853   __ verify_oop(obj);
3854 
3855   if (tmp != obj) {
3856     __ mov(tmp, obj);
3857   }
3858   if (do_null) {
3859     __ testptr(tmp, tmp);
3860     __ jccb(Assembler::notZero, update);
3861     if (!TypeEntries::was_null_seen(current_klass)) {
3862       __ orptr(mdo_addr, TypeEntries::null_seen);
3863     }
3864     if (do_update) {
3865 #ifndef ASSERT
3866       __ jmpb(next);
3867     }
3868 #else
3869       __ jmp(next);
3870     }
3871   } else {
3872     __ testptr(tmp, tmp);
3873     __ jcc(Assembler::notZero, update);
3874     __ stop(&quot;unexpect null obj&quot;);
3875 #endif
3876   }
3877 
3878   __ bind(update);
3879 
3880   if (do_update) {
3881 #ifdef ASSERT
3882     if (exact_klass != NULL) {
3883       Label ok;
3884       __ load_klass(tmp, tmp, tmp_load_klass);
3885       __ push(tmp);
3886       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3887       __ cmpptr(tmp, Address(rsp, 0));
3888       __ jcc(Assembler::equal, ok);
3889       __ stop(&quot;exact klass and actual klass differ&quot;);
3890       __ bind(ok);
3891       __ pop(tmp);
3892     }
3893 #endif
3894     if (!no_conflict) {
3895       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3896         if (exact_klass != NULL) {
3897           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3898         } else {
3899           __ load_klass(tmp, tmp, tmp_load_klass);
3900         }
3901 
3902         __ xorptr(tmp, mdo_addr);
3903         __ testptr(tmp, TypeEntries::type_klass_mask);
3904         // klass seen before, nothing to do. The unknown bit may have been
3905         // set already but no need to check.
3906         __ jccb(Assembler::zero, next);
3907 
3908         __ testptr(tmp, TypeEntries::type_unknown);
3909         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3910 
3911         if (TypeEntries::is_type_none(current_klass)) {
3912           __ cmpptr(mdo_addr, 0);
3913           __ jccb(Assembler::equal, none);
3914           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3915           __ jccb(Assembler::equal, none);
3916           // There is a chance that the checks above (re-reading profiling
3917           // data from memory) fail if another thread has just set the
3918           // profiling to this obj&#39;s klass
3919           __ xorptr(tmp, mdo_addr);
3920           __ testptr(tmp, TypeEntries::type_klass_mask);
3921           __ jccb(Assembler::zero, next);
3922         }
3923       } else {
3924         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3925                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3926 
3927         __ movptr(tmp, mdo_addr);
3928         __ testptr(tmp, TypeEntries::type_unknown);
3929         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3930       }
3931 
3932       // different than before. Cannot keep accurate profile.
3933       __ orptr(mdo_addr, TypeEntries::type_unknown);
3934 
3935       if (TypeEntries::is_type_none(current_klass)) {
3936         __ jmpb(next);
3937 
3938         __ bind(none);
3939         // first time here. Set profile type.
3940         __ movptr(mdo_addr, tmp);
3941       }
3942     } else {
3943       // There&#39;s a single possible klass at this profile point
3944       assert(exact_klass != NULL, &quot;should be&quot;);
3945       if (TypeEntries::is_type_none(current_klass)) {
3946         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3947         __ xorptr(tmp, mdo_addr);
3948         __ testptr(tmp, TypeEntries::type_klass_mask);
3949 #ifdef ASSERT
3950         __ jcc(Assembler::zero, next);
3951 
3952         {
3953           Label ok;
3954           __ push(tmp);
3955           __ cmpptr(mdo_addr, 0);
3956           __ jcc(Assembler::equal, ok);
3957           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3958           __ jcc(Assembler::equal, ok);
3959           // may have been set by another thread
3960           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3961           __ xorptr(tmp, mdo_addr);
3962           __ testptr(tmp, TypeEntries::type_mask);
3963           __ jcc(Assembler::zero, ok);
3964 
3965           __ stop(&quot;unexpected profiling mismatch&quot;);
3966           __ bind(ok);
3967           __ pop(tmp);
3968         }
3969 #else
3970         __ jccb(Assembler::zero, next);
3971 #endif
3972         // first time here. Set profile type.
3973         __ movptr(mdo_addr, tmp);
3974       } else {
3975         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3976                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3977 
3978         __ movptr(tmp, mdo_addr);
3979         __ testptr(tmp, TypeEntries::type_unknown);
3980         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3981 
3982         __ orptr(mdo_addr, TypeEntries::type_unknown);
3983       }
3984     }
3985 
3986     __ bind(next);
3987   }
3988 }
3989 
3990 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
3991   Unimplemented();
3992 }
3993 
3994 
3995 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
3996   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
3997 }
3998 
3999 
4000 void LIR_Assembler::align_backward_branch_target() {
4001   __ align(BytesPerWord);
4002 }
4003 
4004 
4005 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
4006   if (left-&gt;is_single_cpu()) {
4007     __ negl(left-&gt;as_register());
4008     move_regs(left-&gt;as_register(), dest-&gt;as_register());
4009 
4010   } else if (left-&gt;is_double_cpu()) {
4011     Register lo = left-&gt;as_register_lo();
4012 #ifdef _LP64
4013     Register dst = dest-&gt;as_register_lo();
4014     __ movptr(dst, lo);
4015     __ negptr(dst);
4016 #else
4017     Register hi = left-&gt;as_register_hi();
4018     __ lneg(hi, lo);
4019     if (dest-&gt;as_register_lo() == hi) {
4020       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
4021       move_regs(hi, dest-&gt;as_register_hi());
4022       move_regs(lo, dest-&gt;as_register_lo());
4023     } else {
4024       move_regs(lo, dest-&gt;as_register_lo());
4025       move_regs(hi, dest-&gt;as_register_hi());
4026     }
4027 #endif // _LP64
4028 
4029   } else if (dest-&gt;is_single_xmm()) {
4030 #ifdef _LP64
4031     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
4032       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
4033       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
4034       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
4035     }
4036     else
4037 #endif
4038     {
4039       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
4040       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
4041         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
4042       }
4043       __ xorps(dest-&gt;as_xmm_float_reg(),
4044                ExternalAddress((address)float_signflip_pool));
4045     }
4046   } else if (dest-&gt;is_double_xmm()) {
4047 #ifdef _LP64
4048     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
4049       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
4050       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
4051       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
4052     }
4053     else
4054 #endif
4055     {
4056       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
4057       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
4058         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
4059       }
4060       __ xorpd(dest-&gt;as_xmm_double_reg(),
4061                ExternalAddress((address)double_signflip_pool));
4062     }
4063 #ifndef _LP64
4064   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
4065     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
4066     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
4067     __ fchs();
4068 #endif // !_LP64
4069 
4070   } else {
4071     ShouldNotReachHere();
4072   }
4073 }
4074 
4075 
4076 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
4077   assert(src-&gt;is_address(), &quot;must be an address&quot;);
4078   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
4079 
4080   PatchingStub* patch = NULL;
4081   if (patch_code != lir_patch_none) {
4082     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
4083   }
4084 
4085   Register reg = dest-&gt;as_pointer_register();
4086   LIR_Address* addr = src-&gt;as_address_ptr();
4087   __ lea(reg, as_Address(addr));
4088 
4089   if (patch != NULL) {
4090     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
4091   }
4092 }
4093 
4094 
4095 
4096 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
4097   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
4098   __ call(RuntimeAddress(dest));
4099   if (info != NULL) {
4100     add_call_info_here(info);
4101   }
4102 }
4103 
4104 
4105 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
4106   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
4107 
4108   if (info != NULL) {
4109     add_debug_info_for_null_check_here(info);
4110   }
4111 
4112   if (src-&gt;is_double_xmm()) {
4113     if (dest-&gt;is_double_cpu()) {
4114 #ifdef _LP64
4115       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
4116 #else
4117       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
4118       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
4119       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
4120 #endif // _LP64
4121     } else if (dest-&gt;is_double_stack()) {
4122       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
4123     } else if (dest-&gt;is_address()) {
4124       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
4125     } else {
4126       ShouldNotReachHere();
4127     }
4128 
4129   } else if (dest-&gt;is_double_xmm()) {
4130     if (src-&gt;is_double_stack()) {
4131       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
4132     } else if (src-&gt;is_address()) {
4133       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
4134     } else {
4135       ShouldNotReachHere();
4136     }
4137 
4138 #ifndef _LP64
4139   } else if (src-&gt;is_double_fpu()) {
4140     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
4141     if (dest-&gt;is_double_stack()) {
4142       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
4143     } else if (dest-&gt;is_address()) {
4144       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
4145     } else {
4146       ShouldNotReachHere();
4147     }
4148 
4149   } else if (dest-&gt;is_double_fpu()) {
4150     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
4151     if (src-&gt;is_double_stack()) {
4152       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
4153     } else if (src-&gt;is_address()) {
4154       __ fild_d(as_Address(src-&gt;as_address_ptr()));
4155     } else {
4156       ShouldNotReachHere();
4157     }
4158 #endif // !_LP64
4159 
4160   } else {
4161     ShouldNotReachHere();
4162   }
4163 }
4164 
4165 #ifdef ASSERT
4166 // emit run-time assertion
4167 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
4168   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
4169 
4170   if (op-&gt;in_opr1()-&gt;is_valid()) {
4171     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
4172     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
4173   } else {
4174     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
4175     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
4176   }
4177 
4178   Label ok;
4179   if (op-&gt;condition() != lir_cond_always) {
4180     Assembler::Condition acond = Assembler::zero;
4181     switch (op-&gt;condition()) {
4182       case lir_cond_equal:        acond = Assembler::equal;       break;
4183       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
4184       case lir_cond_less:         acond = Assembler::less;        break;
4185       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
4186       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
4187       case lir_cond_greater:      acond = Assembler::greater;     break;
4188       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
4189       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
4190       default:                    ShouldNotReachHere();
4191     }
4192     __ jcc(acond, ok);
4193   }
4194   if (op-&gt;halt()) {
4195     const char* str = __ code_string(op-&gt;msg());
4196     __ stop(str);
4197   } else {
4198     breakpoint();
4199   }
4200   __ bind(ok);
4201 }
4202 #endif
4203 
4204 void LIR_Assembler::membar() {
4205   // QQQ sparc TSO uses this,
4206   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4207 }
4208 
4209 void LIR_Assembler::membar_acquire() {
4210   // No x86 machines currently require load fences
4211 }
4212 
4213 void LIR_Assembler::membar_release() {
4214   // No x86 machines currently require store fences
4215 }
4216 
4217 void LIR_Assembler::membar_loadload() {
4218   // no-op
4219   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4220 }
4221 
4222 void LIR_Assembler::membar_storestore() {
4223   // no-op
4224   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4225 }
4226 
4227 void LIR_Assembler::membar_loadstore() {
4228   // no-op
4229   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4230 }
4231 
4232 void LIR_Assembler::membar_storeload() {
4233   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4234 }
4235 
4236 void LIR_Assembler::on_spin_wait() {
4237   __ pause ();
4238 }
4239 
4240 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4241   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4242 #ifdef _LP64
4243   // __ get_thread(result_reg-&gt;as_register_lo());
4244   __ mov(result_reg-&gt;as_register(), r15_thread);
4245 #else
4246   __ get_thread(result_reg-&gt;as_register());
4247 #endif // _LP64
4248 }
4249 
4250 void LIR_Assembler::check_orig_pc() {
4251   __ cmpptr(frame_map()-&gt;address_for_orig_pc_addr(), (int32_t)NULL_WORD);
4252 }
4253 
4254 void LIR_Assembler::peephole(LIR_List*) {
4255   // do nothing for now
4256 }
4257 
4258 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4259   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4260 
4261   if (data-&gt;type() == T_INT) {
4262     if (code == lir_xadd) {
4263       __ lock();
4264       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4265     } else {
4266       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4267     }
4268   } else if (data-&gt;is_oop()) {
4269     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4270     Register obj = data-&gt;as_register();
4271 #ifdef _LP64
4272     if (UseCompressedOops) {
4273       __ encode_heap_oop(obj);
4274       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4275       __ decode_heap_oop(obj);
4276     } else {
4277       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4278     }
4279 #else
4280     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4281 #endif
4282   } else if (data-&gt;type() == T_LONG) {
4283 #ifdef _LP64
4284     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4285     if (code == lir_xadd) {
4286       __ lock();
4287       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4288     } else {
4289       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4290     }
4291 #else
4292     ShouldNotReachHere();
4293 #endif
4294   } else {
4295     ShouldNotReachHere();
4296   }
4297 }
4298 
4299 #undef __
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_x86_32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 635   // Allocate argument register save area
 636   if (frame::arg_reg_save_area_bytes != 0) {
 637     __ subptr(rsp, frame::arg_reg_save_area_bytes);
 638   }
 639   __ mov(c_rarg0, rbx);
 640   __ mov(c_rarg1, rax);
 641   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 642 
 643   // De-allocate argument register save area
 644   if (frame::arg_reg_save_area_bytes != 0) {
 645     __ addptr(rsp, frame::arg_reg_save_area_bytes);
 646   }
 647 
 648   __ vzeroupper();
 649   __ pop_CPU_state();
 650   // restore sp
 651   __ mov(rsp, r13);
 652   __ bind(L);
 653 }
 654 
<span class="line-modified"> 655 // For each value type argument, sig includes the list of fields of</span>
<span class="line-modified"> 656 // the value type. This utility function computes the number of</span>
<span class="line-modified"> 657 // arguments for the call if value types are passed by reference (the</span>
 658 // calling convention the interpreter expects).
 659 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 660   int total_args_passed = 0;
 661   if (InlineTypePassFieldsAsArgs) {
 662     for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 663       BasicType bt = sig_extended-&gt;at(i)._bt;
 664       if (SigEntry::is_reserved_entry(sig_extended, i)) {
 665         // Ignore reserved entry
 666       } else if (bt == T_INLINE_TYPE) {
<span class="line-modified"> 667         // In sig_extended, a value type argument starts with:</span>
 668         // T_INLINE_TYPE, followed by the types of the fields of the
<span class="line-modified"> 669         // value type and T_VOID to mark the end of the value</span>
<span class="line-modified"> 670         // type. Value types are flattened so, for instance, in the</span>
<span class="line-modified"> 671         // case of a value type with an int field and a value type</span>
 672         // field that itself has 2 fields, an int and a long:
 673         // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second
 674         // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID
 675         // (outer T_INLINE_TYPE)
 676         total_args_passed++;
 677         int vt = 1;
 678         do {
 679           i++;
 680           BasicType bt = sig_extended-&gt;at(i)._bt;
 681           BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
 682           if (bt == T_INLINE_TYPE) {
 683             vt++;
 684           } else if (bt == T_VOID &amp;&amp;
 685                      prev_bt != T_LONG &amp;&amp;
 686                      prev_bt != T_DOUBLE) {
 687             vt--;
 688           }
 689         } while (vt != 0);
 690       } else {
 691         total_args_passed++;
</pre>
<hr />
<pre>
 752     } else {
 753       __ store_sized_value(to, val, size_in_bytes);
 754     }
 755   } else {
 756     if (wide) {
 757       __ movdbl(to, r_1-&gt;as_XMMRegister());
 758     } else {
 759       __ movflt(to, r_1-&gt;as_XMMRegister());
 760     }
 761   }
 762 }
 763 
 764 static void gen_c2i_adapter(MacroAssembler *masm,
 765                             const GrowableArray&lt;SigEntry&gt;* sig_extended,
 766                             const VMRegPair *regs,
 767                             Label&amp; skip_fixup,
 768                             address start,
 769                             OopMapSet* oop_maps,
 770                             int&amp; frame_complete,
 771                             int&amp; frame_size_in_words,
<span class="line-modified"> 772                             bool alloc_value_receiver) {</span>
 773   // Before we get into the guts of the C2I adapter, see if we should be here
 774   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 775   // interpreter, which means the caller made a static call to get here
 776   // (vcalls always get a compiled target if there is one).  Check for a
 777   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 778   patch_callers_callsite(masm);
 779 
 780   __ bind(skip_fixup);
 781 
 782   if (InlineTypePassFieldsAsArgs) {
 783     // Is there an inline type argument?
<span class="line-modified"> 784     bool has_value_argument = false;</span>
<span class="line-modified"> 785     for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {</span>
<span class="line-modified"> 786       has_value_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
 787     }
<span class="line-modified"> 788     if (has_value_argument) {</span>
<span class="line-modified"> 789       // There is at least a value type argument: we&#39;re coming from</span>
<span class="line-modified"> 790       // compiled code so we have no buffers to back the value</span>
<span class="line-modified"> 791       // types. Allocate the buffers here with a runtime call.</span>
 792       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 793 
 794       frame_complete = __ offset();
 795 
 796       __ set_last_Java_frame(noreg, noreg, NULL);
 797 
 798       __ mov(c_rarg0, r15_thread);
 799       __ mov(c_rarg1, rbx);
<span class="line-modified"> 800       __ mov64(c_rarg2, (int64_t)alloc_value_receiver);</span>
<span class="line-modified"> 801       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));</span>
 802 
 803       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
 804       __ reset_last_Java_frame(false);
 805 
 806       RegisterSaver::restore_live_registers(masm);
 807 
 808       Label no_exception;
 809       __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
 810       __ jcc(Assembler::equal, no_exception);
 811 
 812       __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), (int)NULL_WORD);
 813       __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));
 814       __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
 815 
 816       __ bind(no_exception);
 817 
 818       // We get an array of objects from the runtime call
 819       __ get_vm_result(rscratch2, r15_thread); // Use rscratch2 (r11) as temporary because rscratch1 (r10) is trashed by movptr()
 820       __ get_vm_result_2(rbx, r15_thread); // TODO: required to keep the callee Method live?
 821     }
</pre>
<hr />
<pre>
 828   int total_args_passed = compute_total_args_passed_int(sig_extended);
 829   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 830 
 831   // stack is aligned, keep it that way
 832   extraspace = align_up(extraspace, 2*wordSize);
 833 
 834   // Get return address
 835   __ pop(rax);
 836 
 837   // set senderSP value
 838   __ mov(r13, rsp);
 839 
 840   __ subptr(rsp, extraspace);
 841 
 842   // Store the return address in the expected location
 843   __ movptr(Address(rsp, 0), rax);
 844 
 845   // Now write the args into the outgoing interpreter space
 846 
 847   // next_arg_comp is the next argument from the compiler point of
<span class="line-modified"> 848   // view (value type fields are passed in registers/on the stack). In</span>
<span class="line-modified"> 849   // sig_extended, a value type argument starts with: T_INLINE_TYPE,</span>
<span class="line-modified"> 850   // followed by the types of the fields of the value type and T_VOID</span>
<span class="line-modified"> 851   // to mark the end of the value type. ignored counts the number of</span>
<span class="line-modified"> 852   // T_INLINE_TYPE/T_VOID. next_vt_arg is the next value type argument:</span>
 853   // used to get the buffer for that argument from the pool of buffers
 854   // we allocated above and want to pass to the
 855   // interpreter. next_arg_int is the next argument from the
<span class="line-modified"> 856   // interpreter point of view (value types are passed by reference).</span>
 857   for (int next_arg_comp = 0, ignored = 0, next_vt_arg = 0, next_arg_int = 0;
 858        next_arg_comp &lt; sig_extended-&gt;length(); next_arg_comp++) {
 859     assert(ignored &lt;= next_arg_comp, &quot;shouldn&#39;t skip over more slots than there are arguments&quot;);
 860     assert(next_arg_int &lt;= total_args_passed, &quot;more arguments for the interpreter than expected?&quot;);
 861     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 862     int st_off = (total_args_passed - next_arg_int) * Interpreter::stackElementSize;
 863     if (!InlineTypePassFieldsAsArgs || bt != T_INLINE_TYPE) {
 864       if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 865         continue; // Ignore reserved entry
 866       }
 867       int next_off = st_off - Interpreter::stackElementSize;
 868       const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 869       const VMRegPair reg_pair = regs[next_arg_comp-ignored];
 870       size_t size_in_bytes = reg_pair.second()-&gt;is_valid() ? 8 : 4;
 871       gen_c2i_adapter_helper(masm, bt, next_arg_comp &gt; 0 ? sig_extended-&gt;at(next_arg_comp-1)._bt : T_ILLEGAL,
 872                              size_in_bytes, reg_pair, Address(rsp, offset), extraspace, false);
 873       next_arg_int++;
 874 #ifdef ASSERT
 875       if (bt == T_LONG || bt == T_DOUBLE) {
 876         // Overwrite the unused slot with known junk
 877         __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 878         __ movptr(Address(rsp, st_off), rax);
 879       }
 880 #endif /* ASSERT */
 881     } else {
 882       ignored++;
 883       // get the buffer from the just allocated pool of buffers
 884       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);
 885       __ load_heap_oop(r14, Address(rscratch2, index));
 886       next_vt_arg++; next_arg_int++;
 887       int vt = 1;
 888       // write fields we get from compiled code in registers/stack
<span class="line-modified"> 889       // slots to the buffer: we know we are done with that value type</span>
<span class="line-modified"> 890       // argument when we hit the T_VOID that acts as an end of value</span>
<span class="line-modified"> 891       // type delimiter for this value type. Value types are flattened</span>
<span class="line-modified"> 892       // so we might encounter embedded value types. Each entry in</span>
 893       // sig_extended contains a field offset in the buffer.
 894       do {
 895         next_arg_comp++;
 896         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 897         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp-1)._bt;
 898         if (bt == T_INLINE_TYPE) {
 899           vt++;
 900           ignored++;
 901         } else if (bt == T_VOID &amp;&amp;
 902                    prev_bt != T_LONG &amp;&amp;
 903                    prev_bt != T_DOUBLE) {
 904           vt--;
 905           ignored++;
 906         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 907           // Ignore reserved entry
 908         } else {
 909           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 910           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 911           size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;
 912           bool is_oop = is_reference_type(bt);
</pre>
<hr />
<pre>
1014     comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
1015     // Round up to miminum stack alignment, in wordSize
1016     comp_words_on_stack = align_up(comp_words_on_stack, 2);
1017     __ subptr(rsp, comp_words_on_stack * wordSize);
1018   }
1019 
1020 
1021   // Ensure compiled code always sees stack at proper alignment
1022   __ andptr(rsp, -16);
1023 
1024   // push the return address and misalign the stack that youngest frame always sees
1025   // as far as the placement of the call instruction
1026   __ push(rax);
1027 
1028   // Put saved SP in another register
1029   const Register saved_sp = rax;
1030   __ movptr(saved_sp, r11);
1031 
1032   // Will jump to the compiled code just as if compiled code was doing it.
1033   // Pre-load the register-jump target early, to schedule it better.
<span class="line-modified">1034   __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_value_offset())));</span>
1035 
1036 #if INCLUDE_JVMCI
1037   if (EnableJVMCI || UseAOT) {
1038     // check if this call should be routed towards a specific entry point
1039     __ cmpptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
1040     Label no_alternative_target;
1041     __ jcc(Assembler::equal, no_alternative_target);
1042     __ movptr(r11, Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
1043     __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
1044     __ bind(no_alternative_target);
1045   }
1046 #endif // INCLUDE_JVMCI
1047 
1048   int total_args_passed = sig-&gt;length();
1049 
1050   // Now generate the shuffle code.  Pick up all register args and move the
1051   // rest through the floating point stack top.
1052   for (int i = 0; i &lt; total_args_passed; i++) {
1053     BasicType bt = sig-&gt;at(i)._bt;
<span class="line-modified">1054     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
1055     if (bt == T_VOID) {
1056       // Longs and doubles are passed in native word order, but misaligned
1057       // in the 32-bit build.
1058       BasicType prev_bt = (i &gt; 0) ? sig-&gt;at(i-1)._bt : T_ILLEGAL;
1059       assert(i &gt; 0 &amp;&amp; (prev_bt == T_LONG || prev_bt == T_DOUBLE), &quot;missing half&quot;);
1060       continue;
1061     }
1062 
1063     // Pick up 0, 1 or 2 words from SP+offset.
1064 
1065     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
1066             &quot;scrambled load targets?&quot;);
1067     // Load in argument order going down.
1068     int ld_off = (total_args_passed - i)*Interpreter::stackElementSize;
1069     // Point to interpreter value (vs. tag)
1070     int next_off = ld_off - Interpreter::stackElementSize;
1071     //
1072     //
1073     //
1074     VMReg r_1 = regs[i].first();
</pre>
<hr />
<pre>
1188 
1189   // -------------------------------------------------------------------------
1190   // Generate a C2I adapter.  On entry we know rbx holds the Method* during calls
1191   // to the interpreter.  The args start out packed in the compiled layout.  They
1192   // need to be unpacked into the interpreter layout.  This will almost always
1193   // require some stack space.  We grow the current (compiled) stack, then repack
1194   // the args.  We  finally end in a jump to the generic interpreter entry point.
1195   // On exit from the interpreter, the interpreter will restore our SP (lest the
1196   // compiled code, which relys solely on SP and not RBP, get sick).
1197 
1198   address c2i_unverified_entry = __ pc();
1199   Label skip_fixup;
1200 
1201   gen_inline_cache_check(masm, skip_fixup);
1202 
1203   OopMapSet* oop_maps = new OopMapSet();
1204   int frame_complete = CodeOffsets::frame_never_safe;
1205   int frame_size_in_words = 0;
1206 
1207   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)
<span class="line-modified">1208   address c2i_value_ro_entry = __ pc();</span>
1209   if (regs_cc != regs_cc_ro) {
1210     Label unused;
1211     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);
1212     skip_fixup = unused;
1213   }
1214 
1215   // Scalarized c2i adapter
1216   address c2i_entry = __ pc();
1217 
1218   // Class initialization barrier for static methods
1219   address c2i_no_clinit_check_entry = NULL;
1220   if (VM_Version::supports_fast_class_init_checks()) {
1221     Label L_skip_barrier;
1222     Register method = rbx;
1223 
1224     { // Bypass the barrier for non-static methods
1225       Register flags  = rscratch1;
1226       __ movl(flags, Address(method, Method::access_flags_offset()));
1227       __ testl(flags, JVM_ACC_STATIC);
1228       __ jcc(Assembler::zero, L_skip_barrier); // non-static
1229     }
1230 
1231     Register klass = rscratch1;
1232     __ load_method_holder(klass, method);
1233     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
1234 
1235     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
1236 
1237     __ bind(L_skip_barrier);
1238     c2i_no_clinit_check_entry = __ pc();
1239   }
1240 
1241   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1242   bs-&gt;c2i_entry_barrier(masm);
1243 
1244   gen_c2i_adapter(masm, sig_cc, regs_cc, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, true);
1245 
<span class="line-modified">1246   address c2i_unverified_value_entry = c2i_unverified_entry;</span>
1247 
1248   // Non-scalarized c2i adapter
<span class="line-modified">1249   address c2i_value_entry = c2i_entry;</span>
1250   if (regs != regs_cc) {
<span class="line-modified">1251     Label value_entry_skip_fixup;</span>
<span class="line-modified">1252     c2i_unverified_value_entry = __ pc();</span>
<span class="line-modified">1253     gen_inline_cache_check(masm, value_entry_skip_fixup);</span>
1254 
<span class="line-modified">1255     c2i_value_entry = __ pc();</span>
1256     Label unused;
<span class="line-modified">1257     gen_c2i_adapter(masm, sig, regs, value_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
1258   }
1259 
1260   __ flush();
1261 
1262   // The c2i adapters might safepoint and trigger a GC. The caller must make sure that
1263   // the GC knows about the location of oop argument locations passed to the c2i adapter.
1264   bool caller_must_gc_arguments = (regs != regs_cc);
1265   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);
1266 
<span class="line-modified">1267   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry, c2i_unverified_entry, c2i_unverified_value_entry, c2i_no_clinit_check_entry);</span>
1268 }
1269 
1270 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1271                                          VMRegPair *regs,
1272                                          VMRegPair *regs2,
1273                                          int total_args_passed) {
1274   assert(regs2 == NULL, &quot;not needed on x86&quot;);
1275 // We return the amount of VMRegImpl stack slots we need to reserve for all
1276 // the arguments NOT counting out_preserve_stack_slots.
1277 
1278 // NOTE: These arrays will have to change when c1 is ported
1279 #ifdef _WIN64
1280     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1281       c_rarg0, c_rarg1, c_rarg2, c_rarg3
1282     };
1283     static const XMMRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1284       c_farg0, c_farg1, c_farg2, c_farg3
1285     };
1286 #else
1287     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
</pre>
<hr />
<pre>
4306   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int)NULL_WORD);
4307 #endif
4308   // Clear the exception oop so GC no longer processes it as a root.
4309   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int)NULL_WORD);
4310 
4311   // rax: exception oop
4312   // r8:  exception handler
4313   // rdx: exception pc
4314   // Jump to handler
4315 
4316   __ jmp(r8);
4317 
4318   // Make sure all code is generated
4319   masm-&gt;flush();
4320 
4321   // Set exception blob
4322   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
4323 }
4324 #endif // COMPILER2
4325 
<span class="line-modified">4326 BufferedValueTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {</span>
<span class="line-modified">4327   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);</span>
4328   CodeBuffer buffer(buf);
4329   short buffer_locs[20];
4330   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
4331                                          sizeof(buffer_locs)/sizeof(relocInfo));
4332 
4333   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
4334 
4335   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
4336   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
4337 
4338   int pack_fields_jobject_off = __ offset();
4339   // Resolve pre-allocated buffer from JNI handle.
4340   // We cannot do this in generate_call_stub() because it requires GC code to be initialized.
4341   __ movptr(rax, Address(r13, 0));
4342   __ resolve_jobject(rax /* value */,
4343                      r15_thread /* thread */,
4344                      r12 /* tmp */);
4345   __ movptr(Address(r13, 0), rax);
4346 
4347   int pack_fields_off = __ offset();
</pre>
<hr />
<pre>
4414       __ load_heap_oop(r_1-&gt;as_Register(), from);
4415     } else {
4416       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
4417       assert_different_registers(rax, r_1-&gt;as_Register());
4418       size_t size_in_bytes = type2aelembytes(bt);
4419       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);
4420     }
4421     j++;
4422   }
4423   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
4424 
4425   if (StressInlineTypeReturnedAsFields) {
4426     __ load_klass(rax, rax, rscratch1);
4427     __ orptr(rax, 1);
4428   }
4429 
4430   __ ret(0);
4431 
4432   __ flush();
4433 
<span class="line-modified">4434   return BufferedValueTypeBlob::create(&amp;buffer, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);</span>
4435 }
</pre>
</td>
<td>
<hr />
<pre>
 635   // Allocate argument register save area
 636   if (frame::arg_reg_save_area_bytes != 0) {
 637     __ subptr(rsp, frame::arg_reg_save_area_bytes);
 638   }
 639   __ mov(c_rarg0, rbx);
 640   __ mov(c_rarg1, rax);
 641   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 642 
 643   // De-allocate argument register save area
 644   if (frame::arg_reg_save_area_bytes != 0) {
 645     __ addptr(rsp, frame::arg_reg_save_area_bytes);
 646   }
 647 
 648   __ vzeroupper();
 649   __ pop_CPU_state();
 650   // restore sp
 651   __ mov(rsp, r13);
 652   __ bind(L);
 653 }
 654 
<span class="line-modified"> 655 // For each inline type argument, sig includes the list of fields of</span>
<span class="line-modified"> 656 // the inline type. This utility function computes the number of</span>
<span class="line-modified"> 657 // arguments for the call if inline types are passed by reference (the</span>
 658 // calling convention the interpreter expects).
 659 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 660   int total_args_passed = 0;
 661   if (InlineTypePassFieldsAsArgs) {
 662     for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 663       BasicType bt = sig_extended-&gt;at(i)._bt;
 664       if (SigEntry::is_reserved_entry(sig_extended, i)) {
 665         // Ignore reserved entry
 666       } else if (bt == T_INLINE_TYPE) {
<span class="line-modified"> 667         // In sig_extended, an inline type argument starts with:</span>
 668         // T_INLINE_TYPE, followed by the types of the fields of the
<span class="line-modified"> 669         // inline type and T_VOID to mark the end of the value</span>
<span class="line-modified"> 670         // type. Inline types are flattened so, for instance, in the</span>
<span class="line-modified"> 671         // case of an inline type with an int field and an inline type</span>
 672         // field that itself has 2 fields, an int and a long:
 673         // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second
 674         // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID
 675         // (outer T_INLINE_TYPE)
 676         total_args_passed++;
 677         int vt = 1;
 678         do {
 679           i++;
 680           BasicType bt = sig_extended-&gt;at(i)._bt;
 681           BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
 682           if (bt == T_INLINE_TYPE) {
 683             vt++;
 684           } else if (bt == T_VOID &amp;&amp;
 685                      prev_bt != T_LONG &amp;&amp;
 686                      prev_bt != T_DOUBLE) {
 687             vt--;
 688           }
 689         } while (vt != 0);
 690       } else {
 691         total_args_passed++;
</pre>
<hr />
<pre>
 752     } else {
 753       __ store_sized_value(to, val, size_in_bytes);
 754     }
 755   } else {
 756     if (wide) {
 757       __ movdbl(to, r_1-&gt;as_XMMRegister());
 758     } else {
 759       __ movflt(to, r_1-&gt;as_XMMRegister());
 760     }
 761   }
 762 }
 763 
 764 static void gen_c2i_adapter(MacroAssembler *masm,
 765                             const GrowableArray&lt;SigEntry&gt;* sig_extended,
 766                             const VMRegPair *regs,
 767                             Label&amp; skip_fixup,
 768                             address start,
 769                             OopMapSet* oop_maps,
 770                             int&amp; frame_complete,
 771                             int&amp; frame_size_in_words,
<span class="line-modified"> 772                             bool alloc_inline_receiver) {</span>
 773   // Before we get into the guts of the C2I adapter, see if we should be here
 774   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 775   // interpreter, which means the caller made a static call to get here
 776   // (vcalls always get a compiled target if there is one).  Check for a
 777   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 778   patch_callers_callsite(masm);
 779 
 780   __ bind(skip_fixup);
 781 
 782   if (InlineTypePassFieldsAsArgs) {
 783     // Is there an inline type argument?
<span class="line-modified"> 784     bool has_inline_argument = false;</span>
<span class="line-modified"> 785     for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_inline_argument; i++) {</span>
<span class="line-modified"> 786       has_inline_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
 787     }
<span class="line-modified"> 788     if (has_inline_argument) {</span>
<span class="line-modified"> 789       // There is at least an inline type argument: we&#39;re coming from</span>
<span class="line-modified"> 790       // compiled code so we have no buffers to back the inline types.</span>
<span class="line-modified"> 791       // Allocate the buffers here with a runtime call.</span>
 792       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 793 
 794       frame_complete = __ offset();
 795 
 796       __ set_last_Java_frame(noreg, noreg, NULL);
 797 
 798       __ mov(c_rarg0, r15_thread);
 799       __ mov(c_rarg1, rbx);
<span class="line-modified"> 800       __ mov64(c_rarg2, (int64_t)alloc_inline_receiver);</span>
<span class="line-modified"> 801       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));</span>
 802 
 803       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
 804       __ reset_last_Java_frame(false);
 805 
 806       RegisterSaver::restore_live_registers(masm);
 807 
 808       Label no_exception;
 809       __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
 810       __ jcc(Assembler::equal, no_exception);
 811 
 812       __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), (int)NULL_WORD);
 813       __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));
 814       __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
 815 
 816       __ bind(no_exception);
 817 
 818       // We get an array of objects from the runtime call
 819       __ get_vm_result(rscratch2, r15_thread); // Use rscratch2 (r11) as temporary because rscratch1 (r10) is trashed by movptr()
 820       __ get_vm_result_2(rbx, r15_thread); // TODO: required to keep the callee Method live?
 821     }
</pre>
<hr />
<pre>
 828   int total_args_passed = compute_total_args_passed_int(sig_extended);
 829   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 830 
 831   // stack is aligned, keep it that way
 832   extraspace = align_up(extraspace, 2*wordSize);
 833 
 834   // Get return address
 835   __ pop(rax);
 836 
 837   // set senderSP value
 838   __ mov(r13, rsp);
 839 
 840   __ subptr(rsp, extraspace);
 841 
 842   // Store the return address in the expected location
 843   __ movptr(Address(rsp, 0), rax);
 844 
 845   // Now write the args into the outgoing interpreter space
 846 
 847   // next_arg_comp is the next argument from the compiler point of
<span class="line-modified"> 848   // view (inline type fields are passed in registers/on the stack). In</span>
<span class="line-modified"> 849   // sig_extended, an inline type argument starts with: T_INLINE_TYPE,</span>
<span class="line-modified"> 850   // followed by the types of the fields of the inline type and T_VOID</span>
<span class="line-modified"> 851   // to mark the end of the inline type. ignored counts the number of</span>
<span class="line-modified"> 852   // T_INLINE_TYPE/T_VOID. next_vt_arg is the next inline type argument:</span>
 853   // used to get the buffer for that argument from the pool of buffers
 854   // we allocated above and want to pass to the
 855   // interpreter. next_arg_int is the next argument from the
<span class="line-modified"> 856   // interpreter point of view (inline types are passed by reference).</span>
 857   for (int next_arg_comp = 0, ignored = 0, next_vt_arg = 0, next_arg_int = 0;
 858        next_arg_comp &lt; sig_extended-&gt;length(); next_arg_comp++) {
 859     assert(ignored &lt;= next_arg_comp, &quot;shouldn&#39;t skip over more slots than there are arguments&quot;);
 860     assert(next_arg_int &lt;= total_args_passed, &quot;more arguments for the interpreter than expected?&quot;);
 861     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 862     int st_off = (total_args_passed - next_arg_int) * Interpreter::stackElementSize;
 863     if (!InlineTypePassFieldsAsArgs || bt != T_INLINE_TYPE) {
 864       if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 865         continue; // Ignore reserved entry
 866       }
 867       int next_off = st_off - Interpreter::stackElementSize;
 868       const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 869       const VMRegPair reg_pair = regs[next_arg_comp-ignored];
 870       size_t size_in_bytes = reg_pair.second()-&gt;is_valid() ? 8 : 4;
 871       gen_c2i_adapter_helper(masm, bt, next_arg_comp &gt; 0 ? sig_extended-&gt;at(next_arg_comp-1)._bt : T_ILLEGAL,
 872                              size_in_bytes, reg_pair, Address(rsp, offset), extraspace, false);
 873       next_arg_int++;
 874 #ifdef ASSERT
 875       if (bt == T_LONG || bt == T_DOUBLE) {
 876         // Overwrite the unused slot with known junk
 877         __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 878         __ movptr(Address(rsp, st_off), rax);
 879       }
 880 #endif /* ASSERT */
 881     } else {
 882       ignored++;
 883       // get the buffer from the just allocated pool of buffers
 884       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);
 885       __ load_heap_oop(r14, Address(rscratch2, index));
 886       next_vt_arg++; next_arg_int++;
 887       int vt = 1;
 888       // write fields we get from compiled code in registers/stack
<span class="line-modified"> 889       // slots to the buffer: we know we are done with that inline type</span>
<span class="line-modified"> 890       // argument when we hit the T_VOID that acts as an end of inline</span>
<span class="line-modified"> 891       // type delimiter for this inline type. Inline types are flattened</span>
<span class="line-modified"> 892       // so we might encounter embedded inline types. Each entry in</span>
 893       // sig_extended contains a field offset in the buffer.
 894       do {
 895         next_arg_comp++;
 896         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 897         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp-1)._bt;
 898         if (bt == T_INLINE_TYPE) {
 899           vt++;
 900           ignored++;
 901         } else if (bt == T_VOID &amp;&amp;
 902                    prev_bt != T_LONG &amp;&amp;
 903                    prev_bt != T_DOUBLE) {
 904           vt--;
 905           ignored++;
 906         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 907           // Ignore reserved entry
 908         } else {
 909           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 910           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 911           size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;
 912           bool is_oop = is_reference_type(bt);
</pre>
<hr />
<pre>
1014     comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
1015     // Round up to miminum stack alignment, in wordSize
1016     comp_words_on_stack = align_up(comp_words_on_stack, 2);
1017     __ subptr(rsp, comp_words_on_stack * wordSize);
1018   }
1019 
1020 
1021   // Ensure compiled code always sees stack at proper alignment
1022   __ andptr(rsp, -16);
1023 
1024   // push the return address and misalign the stack that youngest frame always sees
1025   // as far as the placement of the call instruction
1026   __ push(rax);
1027 
1028   // Put saved SP in another register
1029   const Register saved_sp = rax;
1030   __ movptr(saved_sp, r11);
1031 
1032   // Will jump to the compiled code just as if compiled code was doing it.
1033   // Pre-load the register-jump target early, to schedule it better.
<span class="line-modified">1034   __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_inline_offset())));</span>
1035 
1036 #if INCLUDE_JVMCI
1037   if (EnableJVMCI || UseAOT) {
1038     // check if this call should be routed towards a specific entry point
1039     __ cmpptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
1040     Label no_alternative_target;
1041     __ jcc(Assembler::equal, no_alternative_target);
1042     __ movptr(r11, Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
1043     __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
1044     __ bind(no_alternative_target);
1045   }
1046 #endif // INCLUDE_JVMCI
1047 
1048   int total_args_passed = sig-&gt;length();
1049 
1050   // Now generate the shuffle code.  Pick up all register args and move the
1051   // rest through the floating point stack top.
1052   for (int i = 0; i &lt; total_args_passed; i++) {
1053     BasicType bt = sig-&gt;at(i)._bt;
<span class="line-modified">1054     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack inline type args&quot;);</span>
1055     if (bt == T_VOID) {
1056       // Longs and doubles are passed in native word order, but misaligned
1057       // in the 32-bit build.
1058       BasicType prev_bt = (i &gt; 0) ? sig-&gt;at(i-1)._bt : T_ILLEGAL;
1059       assert(i &gt; 0 &amp;&amp; (prev_bt == T_LONG || prev_bt == T_DOUBLE), &quot;missing half&quot;);
1060       continue;
1061     }
1062 
1063     // Pick up 0, 1 or 2 words from SP+offset.
1064 
1065     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
1066             &quot;scrambled load targets?&quot;);
1067     // Load in argument order going down.
1068     int ld_off = (total_args_passed - i)*Interpreter::stackElementSize;
1069     // Point to interpreter value (vs. tag)
1070     int next_off = ld_off - Interpreter::stackElementSize;
1071     //
1072     //
1073     //
1074     VMReg r_1 = regs[i].first();
</pre>
<hr />
<pre>
1188 
1189   // -------------------------------------------------------------------------
1190   // Generate a C2I adapter.  On entry we know rbx holds the Method* during calls
1191   // to the interpreter.  The args start out packed in the compiled layout.  They
1192   // need to be unpacked into the interpreter layout.  This will almost always
1193   // require some stack space.  We grow the current (compiled) stack, then repack
1194   // the args.  We  finally end in a jump to the generic interpreter entry point.
1195   // On exit from the interpreter, the interpreter will restore our SP (lest the
1196   // compiled code, which relys solely on SP and not RBP, get sick).
1197 
1198   address c2i_unverified_entry = __ pc();
1199   Label skip_fixup;
1200 
1201   gen_inline_cache_check(masm, skip_fixup);
1202 
1203   OopMapSet* oop_maps = new OopMapSet();
1204   int frame_complete = CodeOffsets::frame_never_safe;
1205   int frame_size_in_words = 0;
1206 
1207   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)
<span class="line-modified">1208   address c2i_inline_ro_entry = __ pc();</span>
1209   if (regs_cc != regs_cc_ro) {
1210     Label unused;
1211     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);
1212     skip_fixup = unused;
1213   }
1214 
1215   // Scalarized c2i adapter
1216   address c2i_entry = __ pc();
1217 
1218   // Class initialization barrier for static methods
1219   address c2i_no_clinit_check_entry = NULL;
1220   if (VM_Version::supports_fast_class_init_checks()) {
1221     Label L_skip_barrier;
1222     Register method = rbx;
1223 
1224     { // Bypass the barrier for non-static methods
1225       Register flags  = rscratch1;
1226       __ movl(flags, Address(method, Method::access_flags_offset()));
1227       __ testl(flags, JVM_ACC_STATIC);
1228       __ jcc(Assembler::zero, L_skip_barrier); // non-static
1229     }
1230 
1231     Register klass = rscratch1;
1232     __ load_method_holder(klass, method);
1233     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
1234 
1235     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
1236 
1237     __ bind(L_skip_barrier);
1238     c2i_no_clinit_check_entry = __ pc();
1239   }
1240 
1241   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1242   bs-&gt;c2i_entry_barrier(masm);
1243 
1244   gen_c2i_adapter(masm, sig_cc, regs_cc, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, true);
1245 
<span class="line-modified">1246   address c2i_unverified_inline_entry = c2i_unverified_entry;</span>
1247 
1248   // Non-scalarized c2i adapter
<span class="line-modified">1249   address c2i_inline_entry = c2i_entry;</span>
1250   if (regs != regs_cc) {
<span class="line-modified">1251     Label inline_entry_skip_fixup;</span>
<span class="line-modified">1252     c2i_unverified_inline_entry = __ pc();</span>
<span class="line-modified">1253     gen_inline_cache_check(masm, inline_entry_skip_fixup);</span>
1254 
<span class="line-modified">1255     c2i_inline_entry = __ pc();</span>
1256     Label unused;
<span class="line-modified">1257     gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
1258   }
1259 
1260   __ flush();
1261 
1262   // The c2i adapters might safepoint and trigger a GC. The caller must make sure that
1263   // the GC knows about the location of oop argument locations passed to the c2i adapter.
1264   bool caller_must_gc_arguments = (regs != regs_cc);
1265   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);
1266 
<span class="line-modified">1267   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);</span>
1268 }
1269 
1270 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1271                                          VMRegPair *regs,
1272                                          VMRegPair *regs2,
1273                                          int total_args_passed) {
1274   assert(regs2 == NULL, &quot;not needed on x86&quot;);
1275 // We return the amount of VMRegImpl stack slots we need to reserve for all
1276 // the arguments NOT counting out_preserve_stack_slots.
1277 
1278 // NOTE: These arrays will have to change when c1 is ported
1279 #ifdef _WIN64
1280     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1281       c_rarg0, c_rarg1, c_rarg2, c_rarg3
1282     };
1283     static const XMMRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1284       c_farg0, c_farg1, c_farg2, c_farg3
1285     };
1286 #else
1287     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
</pre>
<hr />
<pre>
4306   __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int)NULL_WORD);
4307 #endif
4308   // Clear the exception oop so GC no longer processes it as a root.
4309   __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int)NULL_WORD);
4310 
4311   // rax: exception oop
4312   // r8:  exception handler
4313   // rdx: exception pc
4314   // Jump to handler
4315 
4316   __ jmp(r8);
4317 
4318   // Make sure all code is generated
4319   masm-&gt;flush();
4320 
4321   // Set exception blob
4322   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
4323 }
4324 #endif // COMPILER2
4325 
<span class="line-modified">4326 BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {</span>
<span class="line-modified">4327   BufferBlob* buf = BufferBlob::create(&quot;inline types pack/unpack&quot;, 16 * K);</span>
4328   CodeBuffer buffer(buf);
4329   short buffer_locs[20];
4330   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
4331                                          sizeof(buffer_locs)/sizeof(relocInfo));
4332 
4333   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
4334 
4335   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
4336   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
4337 
4338   int pack_fields_jobject_off = __ offset();
4339   // Resolve pre-allocated buffer from JNI handle.
4340   // We cannot do this in generate_call_stub() because it requires GC code to be initialized.
4341   __ movptr(rax, Address(r13, 0));
4342   __ resolve_jobject(rax /* value */,
4343                      r15_thread /* thread */,
4344                      r12 /* tmp */);
4345   __ movptr(Address(r13, 0), rax);
4346 
4347   int pack_fields_off = __ offset();
</pre>
<hr />
<pre>
4414       __ load_heap_oop(r_1-&gt;as_Register(), from);
4415     } else {
4416       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
4417       assert_different_registers(rax, r_1-&gt;as_Register());
4418       size_t size_in_bytes = type2aelembytes(bt);
4419       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);
4420     }
4421     j++;
4422   }
4423   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
4424 
4425   if (StressInlineTypeReturnedAsFields) {
4426     __ load_klass(rax, rax, rscratch1);
4427     __ orptr(rax, 1);
4428   }
4429 
4430   __ ret(0);
4431 
4432   __ flush();
4433 
<span class="line-modified">4434   return BufferedInlineTypeBlob::create(&amp;buffer, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);</span>
4435 }
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_x86_32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
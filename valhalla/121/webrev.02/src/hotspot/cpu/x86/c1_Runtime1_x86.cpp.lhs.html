<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_Runtime1_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;c1/c1_Defs.hpp&quot;
  28 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  29 #include &quot;c1/c1_Runtime1.hpp&quot;
  30 #include &quot;ci/ciUtilities.hpp&quot;
  31 #include &quot;gc/shared/cardTable.hpp&quot;
  32 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;nativeInst_x86.hpp&quot;
  36 #include &quot;oops/compiledICHolder.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;prims/jvmtiExport.hpp&quot;
  39 #include &quot;register_x86.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/signature.hpp&quot;
  42 #include &quot;runtime/vframeArray.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
  44 #include &quot;vmreg_x86.inline.hpp&quot;
  45 
  46 // Implementation of StubAssembler
  47 
  48 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, int args_size) {
  49   // setup registers
  50   const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread); // is callee-saved register (Visual C++ calling conventions)
  51   assert(!(oop_result1-&gt;is_valid() || metadata_result-&gt;is_valid()) || oop_result1 != metadata_result, &quot;registers must be different&quot;);
  52   assert(oop_result1 != thread &amp;&amp; metadata_result != thread, &quot;registers must be different&quot;);
  53   assert(args_size &gt;= 0, &quot;illegal args_size&quot;);
  54   bool align_stack = false;
  55 #ifdef _LP64
  56   // At a method handle call, the stack may not be properly aligned
  57   // when returning with an exception.
  58   align_stack = (stub_id() == Runtime1::handle_exception_from_callee_id);
  59 #endif
  60 
  61 #ifdef _LP64
  62   mov(c_rarg0, thread);
  63   set_num_rt_args(0); // Nothing on stack
  64 #else
  65   set_num_rt_args(1 + args_size);
  66 
  67   // push java thread (becomes first argument of C function)
  68   get_thread(thread);
  69   push(thread);
  70 #endif // _LP64
  71 
  72   int call_offset;
  73   if (!align_stack) {
  74     set_last_Java_frame(thread, noreg, rbp, NULL);
  75   } else {
  76     address the_pc = pc();
  77     call_offset = offset();
  78     set_last_Java_frame(thread, noreg, rbp, the_pc);
  79     andptr(rsp, -(StackAlignmentInBytes));    // Align stack
  80   }
  81 
  82   // do the call
  83   call(RuntimeAddress(entry));
  84   if (!align_stack) {
  85     call_offset = offset();
  86   }
  87   // verify callee-saved register
  88 #ifdef ASSERT
  89   guarantee(thread != rax, &quot;change this code&quot;);
  90   push(rax);
  91   { Label L;
  92     get_thread(rax);
  93     cmpptr(thread, rax);
  94     jcc(Assembler::equal, L);
  95     int3();
  96     stop(&quot;StubAssembler::call_RT: rdi not callee saved?&quot;);
  97     bind(L);
  98   }
  99   pop(rax);
 100 #endif
 101   reset_last_Java_frame(thread, true);
 102 
 103   // discard thread and arguments
 104   NOT_LP64(addptr(rsp, num_rt_args()*BytesPerWord));
 105 
 106   // check for pending exceptions
 107   { Label L;
 108     cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
 109     jcc(Assembler::equal, L);
 110     // exception pending =&gt; remove activation and forward to exception handler
 111     movptr(rax, Address(thread, Thread::pending_exception_offset()));
 112     // make sure that the vm_results are cleared
 113     if (oop_result1-&gt;is_valid()) {
 114       movptr(Address(thread, JavaThread::vm_result_offset()), NULL_WORD);
 115     }
 116     if (metadata_result-&gt;is_valid()) {
 117       movptr(Address(thread, JavaThread::vm_result_2_offset()), NULL_WORD);
 118     }
 119     if (frame_size() == no_frame_size) {
 120       leave();
 121       jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
 122     } else if (_stub_id == Runtime1::forward_exception_id) {
 123       should_not_reach_here();
 124     } else {
 125       jump(RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));
 126     }
 127     bind(L);
 128   }
 129   // get oop results if there are any and reset the values in the thread
 130   if (oop_result1-&gt;is_valid()) {
 131     get_vm_result(oop_result1, thread);
 132   }
 133   if (metadata_result-&gt;is_valid()) {
 134     get_vm_result_2(metadata_result, thread);
 135   }
 136   return call_offset;
 137 }
 138 
 139 
 140 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1) {
 141 #ifdef _LP64
 142   mov(c_rarg1, arg1);
 143 #else
 144   push(arg1);
 145 #endif // _LP64
 146   return call_RT(oop_result1, metadata_result, entry, 1);
 147 }
 148 
 149 
 150 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1, Register arg2) {
 151 #ifdef _LP64
 152   if (c_rarg1 == arg2) {
 153     if (c_rarg2 == arg1) {
 154       xchgq(arg1, arg2);
 155     } else {
 156       mov(c_rarg2, arg2);
 157       mov(c_rarg1, arg1);
 158     }
 159   } else {
 160     mov(c_rarg1, arg1);
 161     mov(c_rarg2, arg2);
 162   }
 163 #else
 164   push(arg2);
 165   push(arg1);
 166 #endif // _LP64
 167   return call_RT(oop_result1, metadata_result, entry, 2);
 168 }
 169 
 170 
 171 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1, Register arg2, Register arg3) {
 172 #ifdef _LP64
 173   // if there is any conflict use the stack
 174   if (arg1 == c_rarg2 || arg1 == c_rarg3 ||
 175       arg2 == c_rarg1 || arg1 == c_rarg3 ||
 176       arg3 == c_rarg1 || arg1 == c_rarg2) {
 177     push(arg3);
 178     push(arg2);
 179     push(arg1);
 180     pop(c_rarg1);
 181     pop(c_rarg2);
 182     pop(c_rarg3);
 183   } else {
 184     mov(c_rarg1, arg1);
 185     mov(c_rarg2, arg2);
 186     mov(c_rarg3, arg3);
 187   }
 188 #else
 189   push(arg3);
 190   push(arg2);
 191   push(arg1);
 192 #endif // _LP64
 193   return call_RT(oop_result1, metadata_result, entry, 3);
 194 }
 195 
 196 
 197 // Implementation of StubFrame
 198 
 199 class StubFrame: public StackObj {
 200  private:
 201   StubAssembler* _sasm;
 202 
 203  public:
 204   StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments);
 205   void load_argument(int offset_in_words, Register reg);
 206 
 207   ~StubFrame();
 208 };
 209 
 210 void StubAssembler::prologue(const char* name, bool must_gc_arguments) {
 211   set_info(name, must_gc_arguments);
 212   enter();
 213 }
 214 
 215 void StubAssembler::epilogue() {
 216   leave();
 217   ret(0);
 218 }
 219 
 220 #define __ _sasm-&gt;
 221 
 222 StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments) {
 223   _sasm = sasm;
 224   __ prologue(name, must_gc_arguments);
 225 }
 226 
 227 // load parameters that were stored with LIR_Assembler::store_parameter
 228 // Note: offsets for store_parameter and load_argument must match
 229 void StubFrame::load_argument(int offset_in_words, Register reg) {
 230   __ load_parameter(offset_in_words, reg);
 231 }
 232 
 233 
 234 StubFrame::~StubFrame() {
 235   __ epilogue();
 236 }
 237 
 238 #undef __
 239 
 240 
 241 // Implementation of Runtime1
 242 
 243 const int float_regs_as_doubles_size_in_slots = pd_nof_fpu_regs_frame_map * 2;
 244 const int xmm_regs_as_doubles_size_in_slots = FrameMap::nof_xmm_regs * 2;
 245 
 246 // Stack layout for saving/restoring  all the registers needed during a runtime
 247 // call (this includes deoptimization)
 248 // Note: note that users of this frame may well have arguments to some runtime
 249 // while these values are on the stack. These positions neglect those arguments
 250 // but the code in save_live_registers will take the argument count into
 251 // account.
 252 //
 253 #ifdef _LP64
 254   #define SLOT2(x) x,
 255   #define SLOT_PER_WORD 2
 256 #else
 257   #define SLOT2(x)
 258   #define SLOT_PER_WORD 1
 259 #endif // _LP64
 260 
 261 enum reg_save_layout {
 262   // 64bit needs to keep stack 16 byte aligned. So we add some alignment dummies to make that
 263   // happen and will assert if the stack size we create is misaligned
 264 #ifdef _LP64
 265   align_dummy_0, align_dummy_1,
 266 #endif // _LP64
 267 #ifdef _WIN64
 268   // Windows always allocates space for it&#39;s argument registers (see
 269   // frame::arg_reg_save_area_bytes).
 270   arg_reg_save_1, arg_reg_save_1H,                                                          // 0, 4
 271   arg_reg_save_2, arg_reg_save_2H,                                                          // 8, 12
 272   arg_reg_save_3, arg_reg_save_3H,                                                          // 16, 20
 273   arg_reg_save_4, arg_reg_save_4H,                                                          // 24, 28
 274 #endif // _WIN64
 275   xmm_regs_as_doubles_off,                                                                  // 32
 276   float_regs_as_doubles_off = xmm_regs_as_doubles_off + xmm_regs_as_doubles_size_in_slots,  // 160
 277   fpu_state_off = float_regs_as_doubles_off + float_regs_as_doubles_size_in_slots,          // 224
 278   // fpu_state_end_off is exclusive
 279   fpu_state_end_off = fpu_state_off + (FPUStateSizeInWords / SLOT_PER_WORD),                // 352
 280   marker = fpu_state_end_off, SLOT2(markerH)                                                // 352, 356
 281   extra_space_offset,                                                                       // 360
 282 #ifdef _LP64
 283   r15_off = extra_space_offset, r15H_off,                                                   // 360, 364
 284   r14_off, r14H_off,                                                                        // 368, 372
 285   r13_off, r13H_off,                                                                        // 376, 380
 286   r12_off, r12H_off,                                                                        // 384, 388
 287   r11_off, r11H_off,                                                                        // 392, 396
 288   r10_off, r10H_off,                                                                        // 400, 404
 289   r9_off, r9H_off,                                                                          // 408, 412
 290   r8_off, r8H_off,                                                                          // 416, 420
 291   rdi_off, rdiH_off,                                                                        // 424, 428
 292 #else
 293   rdi_off = extra_space_offset,
 294 #endif // _LP64
 295   rsi_off, SLOT2(rsiH_off)                                                                  // 432, 436
 296   rbp_off, SLOT2(rbpH_off)                                                                  // 440, 444
 297   rsp_off, SLOT2(rspH_off)                                                                  // 448, 452
 298   rbx_off, SLOT2(rbxH_off)                                                                  // 456, 460
 299   rdx_off, SLOT2(rdxH_off)                                                                  // 464, 468
 300   rcx_off, SLOT2(rcxH_off)                                                                  // 472, 476
 301   rax_off, SLOT2(raxH_off)                                                                  // 480, 484
 302   saved_rbp_off, SLOT2(saved_rbpH_off)                                                      // 488, 492
 303   return_off, SLOT2(returnH_off)                                                            // 496, 500
 304   reg_save_frame_size   // As noted: neglects any parameters to runtime                     // 504
 305 };
 306 
 307 // Save off registers which might be killed by calls into the runtime.
 308 // Tries to smart of about FP registers.  In particular we separate
 309 // saving and describing the FPU registers for deoptimization since we
 310 // have to save the FPU registers twice if we describe them and on P4
 311 // saving FPU registers which don&#39;t contain anything appears
 312 // expensive.  The deopt blob is the only thing which needs to
 313 // describe FPU registers.  In all other cases it should be sufficient
 314 // to simply save their current value.
 315 
 316 static OopMap* generate_oop_map(StubAssembler* sasm, int num_rt_args,
 317                                 bool save_fpu_registers = true) {
 318 
 319   // In 64bit all the args are in regs so there are no additional stack slots
 320   LP64_ONLY(num_rt_args = 0);
 321   LP64_ONLY(assert((reg_save_frame_size * VMRegImpl::stack_slot_size) % 16 == 0, &quot;must be 16 byte aligned&quot;);)
 322   int frame_size_in_slots = reg_save_frame_size + num_rt_args; // args + thread
 323   sasm-&gt;set_frame_size(frame_size_in_slots / VMRegImpl::slots_per_word);
 324 
 325   // record saved value locations in an OopMap
 326   // locations are offsets from sp after runtime call; num_rt_args is number of arguments in call, including thread
 327   OopMap* map = new OopMap(frame_size_in_slots, 0);
 328   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rax_off + num_rt_args), rax-&gt;as_VMReg());
 329   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rcx_off + num_rt_args), rcx-&gt;as_VMReg());
 330   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rdx_off + num_rt_args), rdx-&gt;as_VMReg());
 331   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rbx_off + num_rt_args), rbx-&gt;as_VMReg());
 332   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rsi_off + num_rt_args), rsi-&gt;as_VMReg());
 333   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rdi_off + num_rt_args), rdi-&gt;as_VMReg());
 334 #ifdef _LP64
 335   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r8_off + num_rt_args),  r8-&gt;as_VMReg());
 336   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r9_off + num_rt_args),  r9-&gt;as_VMReg());
 337   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r10_off + num_rt_args), r10-&gt;as_VMReg());
 338   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r11_off + num_rt_args), r11-&gt;as_VMReg());
 339   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r12_off + num_rt_args), r12-&gt;as_VMReg());
 340   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r13_off + num_rt_args), r13-&gt;as_VMReg());
 341   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r14_off + num_rt_args), r14-&gt;as_VMReg());
 342   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r15_off + num_rt_args), r15-&gt;as_VMReg());
 343 
 344   // This is stupid but needed.
 345   map-&gt;set_callee_saved(VMRegImpl::stack2reg(raxH_off + num_rt_args), rax-&gt;as_VMReg()-&gt;next());
 346   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rcxH_off + num_rt_args), rcx-&gt;as_VMReg()-&gt;next());
 347   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rdxH_off + num_rt_args), rdx-&gt;as_VMReg()-&gt;next());
 348   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rbxH_off + num_rt_args), rbx-&gt;as_VMReg()-&gt;next());
 349   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rsiH_off + num_rt_args), rsi-&gt;as_VMReg()-&gt;next());
 350   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rdiH_off + num_rt_args), rdi-&gt;as_VMReg()-&gt;next());
 351 
 352   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r8H_off + num_rt_args),  r8-&gt;as_VMReg()-&gt;next());
 353   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r9H_off + num_rt_args),  r9-&gt;as_VMReg()-&gt;next());
 354   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r10H_off + num_rt_args), r10-&gt;as_VMReg()-&gt;next());
 355   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r11H_off + num_rt_args), r11-&gt;as_VMReg()-&gt;next());
 356   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r12H_off + num_rt_args), r12-&gt;as_VMReg()-&gt;next());
 357   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r13H_off + num_rt_args), r13-&gt;as_VMReg()-&gt;next());
 358   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r14H_off + num_rt_args), r14-&gt;as_VMReg()-&gt;next());
 359   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r15H_off + num_rt_args), r15-&gt;as_VMReg()-&gt;next());
 360 #endif // _LP64
 361 
 362   int xmm_bypass_limit = FrameMap::nof_xmm_regs;
 363 #ifdef _LP64
 364   if (UseAVX &lt; 3) {
 365     xmm_bypass_limit = xmm_bypass_limit / 2;
 366   }
 367 #endif
 368 
 369   if (save_fpu_registers) {
 370 #ifndef _LP64
 371     if (UseSSE &lt; 2) {
 372       int fpu_off = float_regs_as_doubles_off;
 373       for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 374         VMReg fpu_name_0 = FrameMap::fpu_regname(n);
 375         map-&gt;set_callee_saved(VMRegImpl::stack2reg(fpu_off +     num_rt_args), fpu_name_0);
 376         // %%% This is really a waste but we&#39;ll keep things as they were for now
 377         if (true) {
 378           map-&gt;set_callee_saved(VMRegImpl::stack2reg(fpu_off + 1 + num_rt_args), fpu_name_0-&gt;next());
 379         }
 380         fpu_off += 2;
 381       }
 382       assert(fpu_off == fpu_state_off, &quot;incorrect number of fpu stack slots&quot;);
 383 
 384       if (UseSSE == 1) {
 385         int xmm_off = xmm_regs_as_doubles_off;
 386         for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 387           VMReg xmm_name_0 = as_XMMRegister(n)-&gt;as_VMReg();
 388           map-&gt;set_callee_saved(VMRegImpl::stack2reg(xmm_off + num_rt_args), xmm_name_0);
 389           xmm_off += 2;
 390         }
 391         assert(xmm_off == float_regs_as_doubles_off, &quot;incorrect number of xmm registers&quot;);
 392       }
 393     }
 394 #endif // !LP64
 395 
 396     if (UseSSE &gt;= 2) {
 397       int xmm_off = xmm_regs_as_doubles_off;
 398       for (int n = 0; n &lt; FrameMap::nof_xmm_regs; n++) {
 399         if (n &lt; xmm_bypass_limit) {
 400           VMReg xmm_name_0 = as_XMMRegister(n)-&gt;as_VMReg();
 401           map-&gt;set_callee_saved(VMRegImpl::stack2reg(xmm_off + num_rt_args), xmm_name_0);
 402           // %%% This is really a waste but we&#39;ll keep things as they were for now
 403           if (true) {
 404             map-&gt;set_callee_saved(VMRegImpl::stack2reg(xmm_off + 1 + num_rt_args), xmm_name_0-&gt;next());
 405           }
 406         }
 407         xmm_off += 2;
 408       }
 409       assert(xmm_off == float_regs_as_doubles_off, &quot;incorrect number of xmm registers&quot;);
 410     }
 411   }
 412 
 413   return map;
 414 }
 415 
 416 #define __ this-&gt;
 417 
 418 void C1_MacroAssembler::save_live_registers_no_oop_map(bool save_fpu_registers) {
 419   __ block_comment(&quot;save_live_registers&quot;);
 420 
 421   __ pusha();         // integer registers
 422 
 423   // assert(float_regs_as_doubles_off % 2 == 0, &quot;misaligned offset&quot;);
 424   // assert(xmm_regs_as_doubles_off % 2 == 0, &quot;misaligned offset&quot;);
 425 
 426   __ subptr(rsp, extra_space_offset * VMRegImpl::stack_slot_size);
 427 
 428 #ifdef ASSERT
 429   __ movptr(Address(rsp, marker * VMRegImpl::stack_slot_size), (int32_t)0xfeedbeef);
 430 #endif
 431 
 432   if (save_fpu_registers) {
 433 #ifndef _LP64
 434     if (UseSSE &lt; 2) {
 435       // save FPU stack
 436       __ fnsave(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
 437       __ fwait();
 438 
 439 #ifdef ASSERT
 440       Label ok;
 441       __ cmpw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::fpu_cntrl_wrd_std());
 442       __ jccb(Assembler::equal, ok);
 443       __ stop(&quot;corrupted control word detected&quot;);
 444       __ bind(ok);
 445 #endif
 446 
 447       // Reset the control word to guard against exceptions being unmasked
 448       // since fstp_d can cause FPU stack underflow exceptions.  Write it
 449       // into the on stack copy and then reload that to make sure that the
 450       // current and future values are correct.
 451       __ movw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::fpu_cntrl_wrd_std());
 452       __ frstor(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
 453 
 454       // Save the FPU registers in de-opt-able form
 455       int offset = 0;
 456       for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 457         __ fstp_d(Address(rsp, float_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
 458         offset += 8;
 459       }
 460 
 461       if (UseSSE == 1) {
 462         // save XMM registers as float because double not supported without SSE2(num MMX == num fpu)
 463         int offset = 0;
 464         for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 465           XMMRegister xmm_name = as_XMMRegister(n);
 466           __ movflt(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);
 467           offset += 8;
 468         }
 469       }
 470     }
 471 #endif // !_LP64
 472 
 473     if (UseSSE &gt;= 2) {
 474       // save XMM registers
 475       // XMM registers can contain float or double values, but this is not known here,
 476       // so always save them as doubles.
 477       // note that float values are _not_ converted automatically, so for float values
 478       // the second word contains only garbage data.
 479       int xmm_bypass_limit = FrameMap::nof_xmm_regs;
 480       int offset = 0;
 481 #ifdef _LP64
 482       if (UseAVX &lt; 3) {
 483         xmm_bypass_limit = xmm_bypass_limit / 2;
 484       }
 485 #endif
 486       for (int n = 0; n &lt; xmm_bypass_limit; n++) {
 487         XMMRegister xmm_name = as_XMMRegister(n);
 488         __ movdbl(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);
 489         offset += 8;
 490       }
 491     }
 492   }
 493 
 494   // FPU stack must be empty now
 495   NOT_LP64( __ verify_FPU(0, &quot;save_live_registers&quot;); )
 496 }
 497 
 498 #undef __
 499 #define __ sasm-&gt;
 500 
 501 static void restore_fpu(C1_MacroAssembler* sasm, bool restore_fpu_registers) {
 502 #ifdef _LP64
 503   if (restore_fpu_registers) {
 504     // restore XMM registers
 505     int xmm_bypass_limit = FrameMap::nof_xmm_regs;
 506     if (UseAVX &lt; 3) {
 507       xmm_bypass_limit = xmm_bypass_limit / 2;
 508     }
 509     int offset = 0;
 510     for (int n = 0; n &lt; xmm_bypass_limit; n++) {
 511       XMMRegister xmm_name = as_XMMRegister(n);
 512       __ movdbl(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
 513       offset += 8;
 514     }
 515   }
 516 #else
 517   if (restore_fpu_registers) {
 518     if (UseSSE &gt;= 2) {
 519       // restore XMM registers
 520       int xmm_bypass_limit = FrameMap::nof_xmm_regs;
 521       int offset = 0;
 522       for (int n = 0; n &lt; xmm_bypass_limit; n++) {
 523         XMMRegister xmm_name = as_XMMRegister(n);
 524         __ movdbl(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
 525         offset += 8;
 526       }
 527     } else if (UseSSE == 1) {
 528       // restore XMM registers(num MMX == num fpu)
 529       int offset = 0;
 530       for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 531         XMMRegister xmm_name = as_XMMRegister(n);
 532         __ movflt(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
 533         offset += 8;
 534       }
 535     }
 536 
 537     if (UseSSE &lt; 2) {
 538       __ frstor(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
 539     } else {
 540       // check that FPU stack is really empty
 541       __ verify_FPU(0, &quot;restore_live_registers&quot;);
 542     }
 543   } else {
 544     // check that FPU stack is really empty
 545     __ verify_FPU(0, &quot;restore_live_registers&quot;);
 546   }
 547 #endif // _LP64
 548 
 549 #ifdef ASSERT
 550   {
 551     Label ok;
 552     __ cmpptr(Address(rsp, marker * VMRegImpl::stack_slot_size), (int32_t)0xfeedbeef);
 553     __ jcc(Assembler::equal, ok);
 554     __ stop(&quot;bad offsets in frame&quot;);
 555     __ bind(ok);
 556   }
 557 #endif // ASSERT
 558 
 559   __ addptr(rsp, extra_space_offset * VMRegImpl::stack_slot_size);
 560 }
 561 
 562 #undef __
 563 #define __ this-&gt;
 564 
 565 void C1_MacroAssembler::restore_live_registers(bool restore_fpu_registers) {
 566   __ block_comment(&quot;restore_live_registers&quot;);
 567 
 568   restore_fpu(this, restore_fpu_registers);
 569   __ popa();
 570 }
 571 
 572 
 573 void C1_MacroAssembler::restore_live_registers_except_rax(bool restore_fpu_registers) {
 574   __ block_comment(&quot;restore_live_registers_except_rax&quot;);
 575 
 576   restore_fpu(this, restore_fpu_registers);
 577 
 578 #ifdef _LP64
 579   __ movptr(r15, Address(rsp, 0));
 580   __ movptr(r14, Address(rsp, wordSize));
 581   __ movptr(r13, Address(rsp, 2 * wordSize));
 582   __ movptr(r12, Address(rsp, 3 * wordSize));
 583   __ movptr(r11, Address(rsp, 4 * wordSize));
 584   __ movptr(r10, Address(rsp, 5 * wordSize));
 585   __ movptr(r9,  Address(rsp, 6 * wordSize));
 586   __ movptr(r8,  Address(rsp, 7 * wordSize));
 587   __ movptr(rdi, Address(rsp, 8 * wordSize));
 588   __ movptr(rsi, Address(rsp, 9 * wordSize));
 589   __ movptr(rbp, Address(rsp, 10 * wordSize));
 590   // skip rsp
 591   __ movptr(rbx, Address(rsp, 12 * wordSize));
 592   __ movptr(rdx, Address(rsp, 13 * wordSize));
 593   __ movptr(rcx, Address(rsp, 14 * wordSize));
 594 
 595   __ addptr(rsp, 16 * wordSize);
 596 #else
 597 
 598   __ pop(rdi);
 599   __ pop(rsi);
 600   __ pop(rbp);
 601   __ pop(rbx); // skip this value
 602   __ pop(rbx);
 603   __ pop(rdx);
 604   __ pop(rcx);
 605   __ addptr(rsp, BytesPerWord);
 606 #endif // _LP64
 607 }
 608 
 609 #undef __
 610 #define __ sasm-&gt;
 611 
 612 static OopMap* save_live_registers(StubAssembler* sasm, int num_rt_args,
 613                                    bool save_fpu_registers = true) {
 614   __ save_live_registers_no_oop_map(save_fpu_registers);
 615   return generate_oop_map(sasm, num_rt_args, save_fpu_registers);
 616 }
 617 
 618 static void restore_live_registers(StubAssembler* sasm, bool restore_fpu_registers = true) {
 619   __ restore_live_registers(restore_fpu_registers);
 620 }
 621 
 622 static void restore_live_registers_except_rax(StubAssembler* sasm, bool restore_fpu_registers = true) {
 623   sasm-&gt;restore_live_registers_except_rax(restore_fpu_registers);
 624 }
 625 
 626 
 627 void Runtime1::initialize_pd() {
 628   // nothing to do
 629 }
 630 
 631 
 632 // Target: the entry point of the method that creates and posts the exception oop.
 633 // has_argument: true if the exception needs arguments (passed on the stack because
 634 //               registers must be preserved).
 635 OopMapSet* Runtime1::generate_exception_throw(StubAssembler* sasm, address target, bool has_argument) {
 636   // Preserve all registers.
 637   int num_rt_args = has_argument ? (2 + 1) : 1;
 638   OopMap* oop_map = save_live_registers(sasm, num_rt_args);
 639 
 640   // Now all registers are saved and can be used freely.
 641   // Verify that no old value is used accidentally.
 642   __ invalidate_registers(true, true, true, true, true, true);
 643 
 644   // Registers used by this stub.
 645   const Register temp_reg = rbx;
 646 
 647   // Load arguments for exception that are passed as arguments into the stub.
 648   if (has_argument) {
 649 #ifdef _LP64
 650     __ movptr(c_rarg1, Address(rbp, 2*BytesPerWord));
 651     __ movptr(c_rarg2, Address(rbp, 3*BytesPerWord));
 652 #else
 653     __ movptr(temp_reg, Address(rbp, 3*BytesPerWord));
 654     __ push(temp_reg);
 655     __ movptr(temp_reg, Address(rbp, 2*BytesPerWord));
 656     __ push(temp_reg);
 657 #endif // _LP64
 658   }
 659   int call_offset = __ call_RT(noreg, noreg, target, num_rt_args - 1);
 660 
 661   OopMapSet* oop_maps = new OopMapSet();
 662   oop_maps-&gt;add_gc_map(call_offset, oop_map);
 663 
 664   __ stop(&quot;should not reach here&quot;);
 665 
 666   return oop_maps;
 667 }
 668 
 669 
 670 OopMapSet* Runtime1::generate_handle_exception(StubID id, StubAssembler *sasm) {
 671   __ block_comment(&quot;generate_handle_exception&quot;);
 672 
 673   // incoming parameters
 674   const Register exception_oop = rax;
 675   const Register exception_pc  = rdx;
 676   // other registers used in this stub
 677   const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);
 678 
 679   // Save registers, if required.
 680   OopMapSet* oop_maps = new OopMapSet();
 681   OopMap* oop_map = NULL;
 682   switch (id) {
 683   case forward_exception_id:
 684     // We&#39;re handling an exception in the context of a compiled frame.
 685     // The registers have been saved in the standard places.  Perform
 686     // an exception lookup in the caller and dispatch to the handler
 687     // if found.  Otherwise unwind and dispatch to the callers
 688     // exception handler.
 689     oop_map = generate_oop_map(sasm, 1 /*thread*/);
 690 
 691     // load and clear pending exception oop into RAX
 692     __ movptr(exception_oop, Address(thread, Thread::pending_exception_offset()));
 693     __ movptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);
 694 
 695     // load issuing PC (the return address for this stub) into rdx
 696     __ movptr(exception_pc, Address(rbp, 1*BytesPerWord));
 697 
 698     // make sure that the vm_results are cleared (may be unnecessary)
 699     __ movptr(Address(thread, JavaThread::vm_result_offset()),   NULL_WORD);
 700     __ movptr(Address(thread, JavaThread::vm_result_2_offset()), NULL_WORD);
 701     break;
 702   case handle_exception_nofpu_id:
 703   case handle_exception_id:
 704     // At this point all registers MAY be live.
 705     oop_map = save_live_registers(sasm, 1 /*thread*/, id != handle_exception_nofpu_id);
 706     break;
 707   case handle_exception_from_callee_id: {
 708     // At this point all registers except exception oop (RAX) and
 709     // exception pc (RDX) are dead.
 710     const int frame_size = 2 /*BP, return address*/ NOT_LP64(+ 1 /*thread*/) WIN64_ONLY(+ frame::arg_reg_save_area_bytes / BytesPerWord);
 711     oop_map = new OopMap(frame_size * VMRegImpl::slots_per_word, 0);
 712     sasm-&gt;set_frame_size(frame_size);
 713     WIN64_ONLY(__ subq(rsp, frame::arg_reg_save_area_bytes));
 714     break;
 715   }
 716   default:  ShouldNotReachHere();
 717   }
 718 
 719 #if !defined(_LP64) &amp;&amp; defined(TIERED)
 720   if (UseSSE &lt; 2) {
 721     // C2 can leave the fpu stack dirty
 722     __ empty_FPU_stack();
 723   }
 724 #endif // !_LP64 &amp;&amp; TIERED
 725 
 726   // verify that only rax, and rdx is valid at this time
 727   __ invalidate_registers(false, true, true, false, true, true);
 728   // verify that rax, contains a valid exception
 729   __ verify_not_null_oop(exception_oop);
 730 
 731   // load address of JavaThread object for thread-local data
 732   NOT_LP64(__ get_thread(thread);)
 733 
 734 #ifdef ASSERT
 735   // check that fields in JavaThread for exception oop and issuing pc are
 736   // empty before writing to them
 737   Label oop_empty;
 738   __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), (int32_t) NULL_WORD);
 739   __ jcc(Assembler::equal, oop_empty);
 740   __ stop(&quot;exception oop already set&quot;);
 741   __ bind(oop_empty);
 742 
 743   Label pc_empty;
 744   __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), 0);
 745   __ jcc(Assembler::equal, pc_empty);
 746   __ stop(&quot;exception pc already set&quot;);
 747   __ bind(pc_empty);
 748 #endif
 749 
 750   // save exception oop and issuing pc into JavaThread
 751   // (exception handler will load it from here)
 752   __ movptr(Address(thread, JavaThread::exception_oop_offset()), exception_oop);
 753   __ movptr(Address(thread, JavaThread::exception_pc_offset()),  exception_pc);
 754 
 755   // patch throwing pc into return address (has bci &amp; oop map)
 756   __ movptr(Address(rbp, 1*BytesPerWord), exception_pc);
 757 
 758   // compute the exception handler.
 759   // the exception oop and the throwing pc are read from the fields in JavaThread
 760   int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, exception_handler_for_pc));
 761   oop_maps-&gt;add_gc_map(call_offset, oop_map);
 762 
 763   // rax: handler address
 764   //      will be the deopt blob if nmethod was deoptimized while we looked up
 765   //      handler regardless of whether handler existed in the nmethod.
 766 
 767   // only rax, is valid at this time, all other registers have been destroyed by the runtime call
 768   __ invalidate_registers(false, true, true, true, true, true);
 769 
 770   // patch the return address, this stub will directly return to the exception handler
 771   __ movptr(Address(rbp, 1*BytesPerWord), rax);
 772 
 773   switch (id) {
 774   case forward_exception_id:
 775   case handle_exception_nofpu_id:
 776   case handle_exception_id:
 777     // Restore the registers that were saved at the beginning.
 778     restore_live_registers(sasm, id != handle_exception_nofpu_id);
 779     break;
 780   case handle_exception_from_callee_id:
 781     // WIN64_ONLY: No need to add frame::arg_reg_save_area_bytes to SP
 782     // since we do a leave anyway.
 783 
 784     // Pop the return address.
 785     __ leave();
 786     __ pop(rcx);
 787     __ jmp(rcx);  // jump to exception handler
 788     break;
 789   default:  ShouldNotReachHere();
 790   }
 791 
 792   return oop_maps;
 793 }
 794 
 795 
 796 void Runtime1::generate_unwind_exception(StubAssembler *sasm) {
 797   // incoming parameters
 798   const Register exception_oop = rax;
 799   // callee-saved copy of exception_oop during runtime call
 800   const Register exception_oop_callee_saved = NOT_LP64(rsi) LP64_ONLY(r14);
 801   // other registers used in this stub
 802   const Register exception_pc = rdx;
 803   const Register handler_addr = rbx;
 804   const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);
 805 
 806   // verify that only rax, is valid at this time
 807   __ invalidate_registers(false, true, true, true, true, true);
 808 
 809 #ifdef ASSERT
 810   // check that fields in JavaThread for exception oop and issuing pc are empty
 811   NOT_LP64(__ get_thread(thread);)
 812   Label oop_empty;
 813   __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), 0);
 814   __ jcc(Assembler::equal, oop_empty);
 815   __ stop(&quot;exception oop must be empty&quot;);
 816   __ bind(oop_empty);
 817 
 818   Label pc_empty;
 819   __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), 0);
 820   __ jcc(Assembler::equal, pc_empty);
 821   __ stop(&quot;exception pc must be empty&quot;);
 822   __ bind(pc_empty);
 823 #endif
 824 
 825   // clear the FPU stack in case any FPU results are left behind
 826   NOT_LP64( __ empty_FPU_stack(); )
 827 
 828   // save exception_oop in callee-saved register to preserve it during runtime calls
 829   __ verify_not_null_oop(exception_oop);
 830   __ movptr(exception_oop_callee_saved, exception_oop);
 831 
 832   NOT_LP64(__ get_thread(thread);)
 833   // Get return address (is on top of stack after leave).
 834   __ movptr(exception_pc, Address(rsp, 0));
 835 
 836   // search the exception handler address of the caller (using the return address)
 837   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), thread, exception_pc);
 838   // rax: exception handler address of the caller
 839 
 840   // Only RAX and RSI are valid at this time, all other registers have been destroyed by the call.
 841   __ invalidate_registers(false, true, true, true, false, true);
 842 
 843   // move result of call into correct register
 844   __ movptr(handler_addr, rax);
 845 
 846   // Restore exception oop to RAX (required convention of exception handler).
 847   __ movptr(exception_oop, exception_oop_callee_saved);
 848 
 849   // verify that there is really a valid exception in rax
 850   __ verify_not_null_oop(exception_oop);
 851 
 852   // get throwing pc (= return address).
 853   // rdx has been destroyed by the call, so it must be set again
 854   // the pop is also necessary to simulate the effect of a ret(0)
 855   __ pop(exception_pc);
 856 
 857   // continue at exception handler (return address removed)
 858   // note: do *not* remove arguments when unwinding the
 859   //       activation since the caller assumes having
 860   //       all arguments on the stack when entering the
 861   //       runtime to determine the exception handler
 862   //       (GC happens at call site with arguments!)
 863   // rax: exception oop
 864   // rdx: throwing pc
 865   // rbx: exception handler
 866   __ jmp(handler_addr);
 867 }
 868 
 869 
 870 OopMapSet* Runtime1::generate_patching(StubAssembler* sasm, address target) {
 871   // use the maximum number of runtime-arguments here because it is difficult to
 872   // distinguish each RT-Call.
 873   // Note: This number affects also the RT-Call in generate_handle_exception because
 874   //       the oop-map is shared for all calls.
 875   const int num_rt_args = 2;  // thread + dummy
 876 
 877   DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
 878   assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
 879 
 880   OopMap* oop_map = save_live_registers(sasm, num_rt_args);
 881 
 882 #ifdef _LP64
 883   const Register thread = r15_thread;
 884   // No need to worry about dummy
 885   __ mov(c_rarg0, thread);
 886 #else
 887   __ push(rax); // push dummy
 888 
 889   const Register thread = rdi; // is callee-saved register (Visual C++ calling conventions)
 890   // push java thread (becomes first argument of C function)
 891   __ get_thread(thread);
 892   __ push(thread);
 893 #endif // _LP64
 894   __ set_last_Java_frame(thread, noreg, rbp, NULL);
 895   // do the call
 896   __ call(RuntimeAddress(target));
 897   OopMapSet* oop_maps = new OopMapSet();
 898   oop_maps-&gt;add_gc_map(__ offset(), oop_map);
 899   // verify callee-saved register
 900 #ifdef ASSERT
 901   guarantee(thread != rax, &quot;change this code&quot;);
 902   __ push(rax);
 903   { Label L;
 904     __ get_thread(rax);
 905     __ cmpptr(thread, rax);
 906     __ jcc(Assembler::equal, L);
 907     __ stop(&quot;StubAssembler::call_RT: rdi/r15 not callee saved?&quot;);
 908     __ bind(L);
 909   }
 910   __ pop(rax);
 911 #endif
 912   __ reset_last_Java_frame(thread, true);
 913 #ifndef _LP64
 914   __ pop(rcx); // discard thread arg
 915   __ pop(rcx); // discard dummy
 916 #endif // _LP64
 917 
 918   // check for pending exceptions
 919   { Label L;
 920     __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
 921     __ jcc(Assembler::equal, L);
 922     // exception pending =&gt; remove activation and forward to exception handler
 923 
 924     __ testptr(rax, rax);                                   // have we deoptimized?
 925     __ jump_cc(Assembler::equal,
 926                RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));
 927 
 928     // the deopt blob expects exceptions in the special fields of
 929     // JavaThread, so copy and clear pending exception.
 930 
 931     // load and clear pending exception
 932     __ movptr(rax, Address(thread, Thread::pending_exception_offset()));
 933     __ movptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);
 934 
 935     // check that there is really a valid exception
 936     __ verify_not_null_oop(rax);
 937 
 938     // load throwing pc: this is the return address of the stub
 939     __ movptr(rdx, Address(rsp, return_off * VMRegImpl::stack_slot_size));
 940 
 941 #ifdef ASSERT
 942     // check that fields in JavaThread for exception oop and issuing pc are empty
 943     Label oop_empty;
 944     __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);
 945     __ jcc(Assembler::equal, oop_empty);
 946     __ stop(&quot;exception oop must be empty&quot;);
 947     __ bind(oop_empty);
 948 
 949     Label pc_empty;
 950     __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);
 951     __ jcc(Assembler::equal, pc_empty);
 952     __ stop(&quot;exception pc must be empty&quot;);
 953     __ bind(pc_empty);
 954 #endif
 955 
 956     // store exception oop and throwing pc to JavaThread
 957     __ movptr(Address(thread, JavaThread::exception_oop_offset()), rax);
 958     __ movptr(Address(thread, JavaThread::exception_pc_offset()), rdx);
 959 
 960     restore_live_registers(sasm);
 961 
 962     __ leave();
 963     __ addptr(rsp, BytesPerWord);  // remove return address from stack
 964 
 965     // Forward the exception directly to deopt blob. We can blow no
 966     // registers and must leave throwing pc on the stack.  A patch may
 967     // have values live in registers so the entry point with the
 968     // exception in tls.
 969     __ jump(RuntimeAddress(deopt_blob-&gt;unpack_with_exception_in_tls()));
 970 
 971     __ bind(L);
 972   }
 973 
 974 
 975   // Runtime will return true if the nmethod has been deoptimized during
 976   // the patching process. In that case we must do a deopt reexecute instead.
 977 
 978   Label cont;
 979 
 980   __ testptr(rax, rax);                                 // have we deoptimized?
 981   __ jcc(Assembler::equal, cont);                       // no
 982 
 983   // Will reexecute. Proper return address is already on the stack we just restore
 984   // registers, pop all of our frame but the return address and jump to the deopt blob
 985   restore_live_registers(sasm);
 986   __ leave();
 987   __ jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
 988 
 989   __ bind(cont);
 990   restore_live_registers(sasm);
 991   __ leave();
 992   __ ret(0);
 993 
 994   return oop_maps;
 995 }
 996 
 997 
 998 OopMapSet* Runtime1::generate_code_for(StubID id, StubAssembler* sasm) {
 999 
1000   // for better readability
1001   const bool must_gc_arguments = true;
1002   const bool dont_gc_arguments = false;
1003 
1004   // default value; overwritten for some optimized stubs that are called from methods that do not use the fpu
1005   bool save_fpu_registers = true;
1006 
1007   // stub code &amp; info for the different stubs
1008   OopMapSet* oop_maps = NULL;
1009   switch (id) {
1010     case forward_exception_id:
1011       {
1012         oop_maps = generate_handle_exception(id, sasm);
1013         __ leave();
1014         __ ret(0);
1015       }
1016       break;
1017 
1018     case new_instance_id:
1019     case fast_new_instance_id:
1020     case fast_new_instance_init_check_id:
1021       {
1022         Register klass = rdx; // Incoming
1023         Register obj   = rax; // Result
1024 
1025         if (id == new_instance_id) {
1026           __ set_info(&quot;new_instance&quot;, dont_gc_arguments);
1027         } else if (id == fast_new_instance_id) {
1028           __ set_info(&quot;fast new_instance&quot;, dont_gc_arguments);
1029         } else {
1030           assert(id == fast_new_instance_init_check_id, &quot;bad StubID&quot;);
1031           __ set_info(&quot;fast new_instance init check&quot;, dont_gc_arguments);
1032         }
1033 
1034         // If TLAB is disabled, see if there is support for inlining contiguous
1035         // allocations.
1036         // Otherwise, just go to the slow path.
1037         if ((id == fast_new_instance_id || id == fast_new_instance_init_check_id) &amp;&amp; !UseTLAB
1038             &amp;&amp; Universe::heap()-&gt;supports_inline_contig_alloc()) {
1039           Label slow_path;
1040           Register obj_size = rcx;
1041           Register t1       = rbx;
1042           Register t2       = rsi;
1043           assert_different_registers(klass, obj, obj_size, t1, t2);
1044 
1045           __ push(rdi);
1046           __ push(rbx);
1047 
1048           if (id == fast_new_instance_init_check_id) {
1049             // make sure the klass is initialized
1050             __ cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
1051             __ jcc(Assembler::notEqual, slow_path);
1052           }
1053 
1054 #ifdef ASSERT
1055           // assert object can be fast path allocated
1056           {
1057             Label ok, not_ok;
1058             __ movl(obj_size, Address(klass, Klass::layout_helper_offset()));
1059             __ cmpl(obj_size, 0);  // make sure it&#39;s an instance (LH &gt; 0)
1060             __ jcc(Assembler::lessEqual, not_ok);
1061             __ testl(obj_size, Klass::_lh_instance_slow_path_bit);
1062             __ jcc(Assembler::zero, ok);
1063             __ bind(not_ok);
1064             __ stop(&quot;assert(can be fast path allocated)&quot;);
1065             __ should_not_reach_here();
1066             __ bind(ok);
1067           }
1068 #endif // ASSERT
1069 
1070           const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);
1071           NOT_LP64(__ get_thread(thread));
1072 
1073           // get the instance size (size is postive so movl is fine for 64bit)
1074           __ movl(obj_size, Address(klass, Klass::layout_helper_offset()));
1075 
1076           __ eden_allocate(thread, obj, obj_size, 0, t1, slow_path);
1077 
1078           __ initialize_object(obj, klass, obj_size, 0, t1, t2, /* is_tlab_allocated */ false);
1079           __ verify_oop(obj);
1080           __ pop(rbx);
1081           __ pop(rdi);
1082           __ ret(0);
1083 
1084           __ bind(slow_path);
1085           __ pop(rbx);
1086           __ pop(rdi);
1087         }
1088 
1089         __ enter();
1090         OopMap* map = save_live_registers(sasm, 2);
1091         int call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);
1092         oop_maps = new OopMapSet();
1093         oop_maps-&gt;add_gc_map(call_offset, map);
1094         restore_live_registers_except_rax(sasm);
1095         __ verify_oop(obj);
1096         __ leave();
1097         __ ret(0);
1098 
1099         // rax,: new instance
1100       }
1101 
1102       break;
1103 
1104     case counter_overflow_id:
1105       {
1106         Register bci = rax, method = rbx;
1107         __ enter();
1108         OopMap* map = save_live_registers(sasm, 3);
1109         // Retrieve bci
1110         __ movl(bci, Address(rbp, 2*BytesPerWord));
1111         // And a pointer to the Method*
1112         __ movptr(method, Address(rbp, 3*BytesPerWord));
1113         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, counter_overflow), bci, method);
1114         oop_maps = new OopMapSet();
1115         oop_maps-&gt;add_gc_map(call_offset, map);
1116         restore_live_registers(sasm);
1117         __ leave();
1118         __ ret(0);
1119       }
1120       break;
1121 
1122     case new_type_array_id:
1123     case new_object_array_id:
<a name="1" id="anc1"></a><span class="line-modified">1124     case new_value_array_id:</span>
1125       {
1126         Register length   = rbx; // Incoming
1127         Register klass    = rdx; // Incoming
1128         Register obj      = rax; // Result
1129 
1130         if (id == new_type_array_id) {
1131           __ set_info(&quot;new_type_array&quot;, dont_gc_arguments);
1132         } else if (id == new_object_array_id) {
1133           __ set_info(&quot;new_object_array&quot;, dont_gc_arguments);
1134         } else {
<a name="2" id="anc2"></a><span class="line-modified">1135           __ set_info(&quot;new_value_array&quot;, dont_gc_arguments);</span>
1136         }
1137 
1138 #ifdef ASSERT
1139         // assert object type is really an array of the proper kind
1140         {
1141           Label ok;
1142           Register t0 = obj;
1143           __ movl(t0, Address(klass, Klass::layout_helper_offset()));
1144           __ sarl(t0, Klass::_lh_array_tag_shift);
1145           switch (id) {
1146           case new_type_array_id:
1147             __ cmpl(t0, Klass::_lh_array_tag_type_value);
1148             __ jcc(Assembler::equal, ok);
1149             __ stop(&quot;assert(is a type array klass)&quot;);
1150             break;
1151           case new_object_array_id:
1152             __ cmpl(t0, Klass::_lh_array_tag_obj_value); // new &quot;[Ljava/lang/Object;&quot;
1153             __ jcc(Assembler::equal, ok);
1154             __ cmpl(t0, Klass::_lh_array_tag_vt_value);  // new &quot;[LVT;&quot;
1155             __ jcc(Assembler::equal, ok);
<a name="3" id="anc3"></a><span class="line-modified">1156             __ stop(&quot;assert(is an object or value array klass)&quot;);</span>
1157             break;
<a name="4" id="anc4"></a><span class="line-modified">1158           case new_value_array_id:</span>
1159             // new &quot;[QVT;&quot;
1160             __ cmpl(t0, Klass::_lh_array_tag_vt_value);  // the array can be flattened.
1161             __ jcc(Assembler::equal, ok);
1162             __ cmpl(t0, Klass::_lh_array_tag_obj_value); // the array cannot be flattened (due to InlineArrayElementMaxFlatSize, etc)
1163             __ jcc(Assembler::equal, ok);
<a name="5" id="anc5"></a><span class="line-modified">1164             __ stop(&quot;assert(is an object or value array klass)&quot;);</span>
1165             break;
1166           default:  ShouldNotReachHere();
1167           }
1168           __ should_not_reach_here();
1169           __ bind(ok);
1170         }
1171 #endif // ASSERT
1172 
1173         // If TLAB is disabled, see if there is support for inlining contiguous
1174         // allocations.
1175         // Otherwise, just go to the slow path.
1176         if (!UseTLAB &amp;&amp; Universe::heap()-&gt;supports_inline_contig_alloc()) {
1177           Register arr_size = rsi;
1178           Register t1       = rcx;  // must be rcx for use as shift count
1179           Register t2       = rdi;
1180           Label slow_path;
1181 
1182           // get the allocation size: round_up(hdr + length &lt;&lt; (layout_helper &amp; 0x1F))
1183           // since size is positive movl does right thing on 64bit
1184           __ movl(t1, Address(klass, Klass::layout_helper_offset()));
1185           // since size is postive movl does right thing on 64bit
1186           __ movl(arr_size, length);
1187           assert(t1 == rcx, &quot;fixed register usage&quot;);
1188           __ shlptr(arr_size /* by t1=rcx, mod 32 */);
1189           __ shrptr(t1, Klass::_lh_header_size_shift);
1190           __ andptr(t1, Klass::_lh_header_size_mask);
1191           __ addptr(arr_size, t1);
1192           __ addptr(arr_size, MinObjAlignmentInBytesMask); // align up
1193           __ andptr(arr_size, ~MinObjAlignmentInBytesMask);
1194 
1195           // Using t2 for non 64-bit.
1196           const Register thread = NOT_LP64(t2) LP64_ONLY(r15_thread);
1197           NOT_LP64(__ get_thread(thread));
1198           __ eden_allocate(thread, obj, arr_size, 0, t1, slow_path);  // preserves arr_size
1199 
1200           __ initialize_header(obj, klass, length, t1, t2);
1201           __ movb(t1, Address(klass, in_bytes(Klass::layout_helper_offset()) + (Klass::_lh_header_size_shift / BitsPerByte)));
1202           assert(Klass::_lh_header_size_shift % BitsPerByte == 0, &quot;bytewise&quot;);
1203           assert(Klass::_lh_header_size_mask &lt;= 0xFF, &quot;bytewise&quot;);
1204           __ andptr(t1, Klass::_lh_header_size_mask);
1205           __ subptr(arr_size, t1);  // body length
1206           __ addptr(t1, obj);       // body start
1207           __ initialize_body(t1, arr_size, 0, t2);
1208           __ verify_oop(obj);
1209           __ ret(0);
1210 
1211           __ bind(slow_path);
1212         }
1213 
1214         __ enter();
1215         OopMap* map = save_live_registers(sasm, 3);
1216         int call_offset;
1217         if (id == new_type_array_id) {
1218           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_type_array), klass, length);
1219         } else if (id == new_object_array_id) {
1220           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_object_array), klass, length);
1221         } else {
<a name="6" id="anc6"></a><span class="line-modified">1222           assert(id == new_value_array_id, &quot;must be&quot;);</span>
<span class="line-modified">1223           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_value_array), klass, length);</span>
1224         }
1225 
1226         oop_maps = new OopMapSet();
1227         oop_maps-&gt;add_gc_map(call_offset, map);
1228         restore_live_registers_except_rax(sasm);
1229 
1230         __ verify_oop(obj);
1231         __ leave();
1232         __ ret(0);
1233 
1234         // rax,: new array
1235       }
1236       break;
1237 
1238     case new_multi_array_id:
1239       { StubFrame f(sasm, &quot;new_multi_array&quot;, dont_gc_arguments);
1240         // rax,: klass
1241         // rbx,: rank
1242         // rcx: address of 1st dimension
1243         OopMap* map = save_live_registers(sasm, 4);
1244         int call_offset = __ call_RT(rax, noreg, CAST_FROM_FN_PTR(address, new_multi_array), rax, rbx, rcx);
1245 
1246         oop_maps = new OopMapSet();
1247         oop_maps-&gt;add_gc_map(call_offset, map);
1248         restore_live_registers_except_rax(sasm);
1249 
1250         // rax,: new multi array
1251         __ verify_oop(rax);
1252       }
1253       break;
1254 
1255     case load_flattened_array_id:
1256       {
1257         StubFrame f(sasm, &quot;load_flattened_array&quot;, dont_gc_arguments);
1258         OopMap* map = save_live_registers(sasm, 3);
1259 
1260         // Called with store_parameter and not C abi
1261 
1262         f.load_argument(1, rax); // rax,: array
1263         f.load_argument(0, rbx); // rbx,: index
1264         int call_offset = __ call_RT(rax, noreg, CAST_FROM_FN_PTR(address, load_flattened_array), rax, rbx);
1265 
1266         oop_maps = new OopMapSet();
1267         oop_maps-&gt;add_gc_map(call_offset, map);
1268         restore_live_registers_except_rax(sasm);
1269 
1270         // rax,: loaded element at array[index]
1271         __ verify_oop(rax);
1272       }
1273       break;
1274 
1275     case store_flattened_array_id:
1276       {
1277         StubFrame f(sasm, &quot;store_flattened_array&quot;, dont_gc_arguments);
1278         OopMap* map = save_live_registers(sasm, 4);
1279 
1280         // Called with store_parameter and not C abi
1281 
1282         f.load_argument(2, rax); // rax,: array
1283         f.load_argument(1, rbx); // rbx,: index
1284         f.load_argument(0, rcx); // rcx,: value
1285         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, store_flattened_array), rax, rbx, rcx);
1286 
1287         oop_maps = new OopMapSet();
1288         oop_maps-&gt;add_gc_map(call_offset, map);
1289         restore_live_registers_except_rax(sasm);
1290       }
1291       break;
1292 
1293     case substitutability_check_id:
1294       {
1295         StubFrame f(sasm, &quot;substitutability_check&quot;, dont_gc_arguments);
1296         OopMap* map = save_live_registers(sasm, 3);
1297 
1298         // Called with store_parameter and not C abi
1299 
1300         f.load_argument(1, rax); // rax,: left
1301         f.load_argument(0, rbx); // rbx,: right
1302         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, substitutability_check), rax, rbx);
1303 
1304         oop_maps = new OopMapSet();
1305         oop_maps-&gt;add_gc_map(call_offset, map);
1306         restore_live_registers_except_rax(sasm);
1307 
1308         // rax,: are the two operands substitutable
1309       }
1310       break;
1311 
1312 
<a name="7" id="anc7"></a><span class="line-modified">1313     case buffer_value_args_id:</span>
<span class="line-modified">1314     case buffer_value_args_no_receiver_id:</span>
1315       {
<a name="8" id="anc8"></a><span class="line-modified">1316         const char* name = (id == buffer_value_args_id) ?</span>
<span class="line-modified">1317           &quot;buffer_value_args&quot; : &quot;buffer_value_args_no_receiver&quot;;</span>
1318         StubFrame f(sasm, name, dont_gc_arguments);
1319         OopMap* map = save_live_registers(sasm, 2);
1320         Register method = rbx;
<a name="9" id="anc9"></a><span class="line-modified">1321         address entry = (id == buffer_value_args_id) ?</span>
<span class="line-modified">1322           CAST_FROM_FN_PTR(address, buffer_value_args) :</span>
<span class="line-modified">1323           CAST_FROM_FN_PTR(address, buffer_value_args_no_receiver);</span>
1324         int call_offset = __ call_RT(rax, noreg, entry, method);
1325         oop_maps = new OopMapSet();
1326         oop_maps-&gt;add_gc_map(call_offset, map);
1327         restore_live_registers_except_rax(sasm);
1328         __ verify_oop(rax);  // rax: an array of buffered value objects
1329       }
1330       break;
1331 
1332     case register_finalizer_id:
1333       {
1334         __ set_info(&quot;register_finalizer&quot;, dont_gc_arguments);
1335 
1336         // This is called via call_runtime so the arguments
1337         // will be place in C abi locations
1338 
1339 #ifdef _LP64
1340         __ verify_oop(c_rarg0);
1341         __ mov(rax, c_rarg0);
1342 #else
1343         // The object is passed on the stack and we haven&#39;t pushed a
1344         // frame yet so it&#39;s one work away from top of stack.
1345         __ movptr(rax, Address(rsp, 1 * BytesPerWord));
1346         __ verify_oop(rax);
1347 #endif // _LP64
1348 
1349         // load the klass and check the has finalizer flag
1350         Label register_finalizer;
1351         Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
1352         Register t = rsi;
1353         __ load_klass(t, rax, tmp_load_klass);
1354         __ movl(t, Address(t, Klass::access_flags_offset()));
1355         __ testl(t, JVM_ACC_HAS_FINALIZER);
1356         __ jcc(Assembler::notZero, register_finalizer);
1357         __ ret(0);
1358 
1359         __ bind(register_finalizer);
1360         __ enter();
1361         OopMap* oop_map = save_live_registers(sasm, 2 /*num_rt_args */);
1362         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, SharedRuntime::register_finalizer), rax);
1363         oop_maps = new OopMapSet();
1364         oop_maps-&gt;add_gc_map(call_offset, oop_map);
1365 
1366         // Now restore all the live registers
1367         restore_live_registers(sasm);
1368 
1369         __ leave();
1370         __ ret(0);
1371       }
1372       break;
1373 
1374     case throw_range_check_failed_id:
1375       { StubFrame f(sasm, &quot;range_check_failed&quot;, dont_gc_arguments);
1376         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_range_check_exception), true);
1377       }
1378       break;
1379 
1380     case throw_index_exception_id:
1381       { StubFrame f(sasm, &quot;index_range_check_failed&quot;, dont_gc_arguments);
1382         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_index_exception), true);
1383       }
1384       break;
1385 
1386     case throw_div0_exception_id:
1387       { StubFrame f(sasm, &quot;throw_div0_exception&quot;, dont_gc_arguments);
1388         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_div0_exception), false);
1389       }
1390       break;
1391 
1392     case throw_null_pointer_exception_id:
1393       { StubFrame f(sasm, &quot;throw_null_pointer_exception&quot;, dont_gc_arguments);
1394         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_null_pointer_exception), false);
1395       }
1396       break;
1397 
1398     case handle_exception_nofpu_id:
1399     case handle_exception_id:
1400       { StubFrame f(sasm, &quot;handle_exception&quot;, dont_gc_arguments);
1401         oop_maps = generate_handle_exception(id, sasm);
1402       }
1403       break;
1404 
1405     case handle_exception_from_callee_id:
1406       { StubFrame f(sasm, &quot;handle_exception_from_callee&quot;, dont_gc_arguments);
1407         oop_maps = generate_handle_exception(id, sasm);
1408       }
1409       break;
1410 
1411     case unwind_exception_id:
1412       { __ set_info(&quot;unwind_exception&quot;, dont_gc_arguments);
1413         // note: no stubframe since we are about to leave the current
1414         //       activation and we are calling a leaf VM function only.
1415         generate_unwind_exception(sasm);
1416       }
1417       break;
1418 
1419     case throw_array_store_exception_id:
1420       { StubFrame f(sasm, &quot;throw_array_store_exception&quot;, dont_gc_arguments);
1421         // tos + 0: link
1422         //     + 1: return address
1423         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_array_store_exception), true);
1424       }
1425       break;
1426 
1427     case throw_class_cast_exception_id:
1428       { StubFrame f(sasm, &quot;throw_class_cast_exception&quot;, dont_gc_arguments);
1429         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_class_cast_exception), true);
1430       }
1431       break;
1432 
1433     case throw_incompatible_class_change_error_id:
1434       { StubFrame f(sasm, &quot;throw_incompatible_class_change_error&quot;, dont_gc_arguments);
1435         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_incompatible_class_change_error), false);
1436       }
1437       break;
1438 
1439     case throw_illegal_monitor_state_exception_id:
1440       { StubFrame f(sasm, &quot;throw_illegal_monitor_state_exception&quot;, dont_gc_arguments);
1441         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_illegal_monitor_state_exception), false);
1442       }
1443       break;
1444 
1445     case slow_subtype_check_id:
1446       {
1447         // Typical calling sequence:
1448         // __ push(klass_RInfo);  // object klass or other subclass
1449         // __ push(sup_k_RInfo);  // array element klass or other superclass
1450         // __ call(slow_subtype_check);
1451         // Note that the subclass is pushed first, and is therefore deepest.
1452         // Previous versions of this code reversed the names &#39;sub&#39; and &#39;super&#39;.
1453         // This was operationally harmless but made the code unreadable.
1454         enum layout {
1455           rax_off, SLOT2(raxH_off)
1456           rcx_off, SLOT2(rcxH_off)
1457           rsi_off, SLOT2(rsiH_off)
1458           rdi_off, SLOT2(rdiH_off)
1459           // saved_rbp_off, SLOT2(saved_rbpH_off)
1460           return_off, SLOT2(returnH_off)
1461           sup_k_off, SLOT2(sup_kH_off)
1462           klass_off, SLOT2(superH_off)
1463           framesize,
1464           result_off = klass_off  // deepest argument is also the return value
1465         };
1466 
1467         __ set_info(&quot;slow_subtype_check&quot;, dont_gc_arguments);
1468         __ push(rdi);
1469         __ push(rsi);
1470         __ push(rcx);
1471         __ push(rax);
1472 
1473         // This is called by pushing args and not with C abi
1474         __ movptr(rsi, Address(rsp, (klass_off) * VMRegImpl::stack_slot_size)); // subclass
1475         __ movptr(rax, Address(rsp, (sup_k_off) * VMRegImpl::stack_slot_size)); // superclass
1476 
1477         Label miss;
1478         __ check_klass_subtype_slow_path(rsi, rax, rcx, rdi, NULL, &amp;miss);
1479 
1480         // fallthrough on success:
1481         __ movptr(Address(rsp, (result_off) * VMRegImpl::stack_slot_size), 1); // result
1482         __ pop(rax);
1483         __ pop(rcx);
1484         __ pop(rsi);
1485         __ pop(rdi);
1486         __ ret(0);
1487 
1488         __ bind(miss);
1489         __ movptr(Address(rsp, (result_off) * VMRegImpl::stack_slot_size), NULL_WORD); // result
1490         __ pop(rax);
1491         __ pop(rcx);
1492         __ pop(rsi);
1493         __ pop(rdi);
1494         __ ret(0);
1495       }
1496       break;
1497 
1498     case monitorenter_nofpu_id:
1499       save_fpu_registers = false;
1500       // fall through
1501     case monitorenter_id:
1502       {
1503         StubFrame f(sasm, &quot;monitorenter&quot;, dont_gc_arguments);
1504         OopMap* map = save_live_registers(sasm, 3, save_fpu_registers);
1505 
1506         // Called with store_parameter and not C abi
1507 
1508         f.load_argument(1, rax); // rax,: object
1509         f.load_argument(0, rbx); // rbx,: lock address
1510 
1511         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorenter), rax, rbx);
1512 
1513         oop_maps = new OopMapSet();
1514         oop_maps-&gt;add_gc_map(call_offset, map);
1515         restore_live_registers(sasm, save_fpu_registers);
1516       }
1517       break;
1518 
1519     case monitorexit_nofpu_id:
1520       save_fpu_registers = false;
1521       // fall through
1522     case monitorexit_id:
1523       {
1524         StubFrame f(sasm, &quot;monitorexit&quot;, dont_gc_arguments);
1525         OopMap* map = save_live_registers(sasm, 2, save_fpu_registers);
1526 
1527         // Called with store_parameter and not C abi
1528 
1529         f.load_argument(0, rax); // rax,: lock address
1530 
1531         // note: really a leaf routine but must setup last java sp
1532         //       =&gt; use call_RT for now (speed can be improved by
1533         //       doing last java sp setup manually)
1534         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorexit), rax);
1535 
1536         oop_maps = new OopMapSet();
1537         oop_maps-&gt;add_gc_map(call_offset, map);
1538         restore_live_registers(sasm, save_fpu_registers);
1539       }
1540       break;
1541 
1542     case deoptimize_id:
1543       {
1544         StubFrame f(sasm, &quot;deoptimize&quot;, dont_gc_arguments);
1545         const int num_rt_args = 2;  // thread, trap_request
1546         OopMap* oop_map = save_live_registers(sasm, num_rt_args);
1547         f.load_argument(0, rax);
1548         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, deoptimize), rax);
1549         oop_maps = new OopMapSet();
1550         oop_maps-&gt;add_gc_map(call_offset, oop_map);
1551         restore_live_registers(sasm);
1552         DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
1553         assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
1554         __ leave();
1555         __ jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
1556       }
1557       break;
1558 
1559     case access_field_patching_id:
1560       { StubFrame f(sasm, &quot;access_field_patching&quot;, dont_gc_arguments);
1561         // we should set up register map
1562         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, access_field_patching));
1563       }
1564       break;
1565 
1566     case load_klass_patching_id:
1567       { StubFrame f(sasm, &quot;load_klass_patching&quot;, dont_gc_arguments);
1568         // we should set up register map
1569         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_klass_patching));
1570       }
1571       break;
1572 
1573     case load_mirror_patching_id:
1574       { StubFrame f(sasm, &quot;load_mirror_patching&quot;, dont_gc_arguments);
1575         // we should set up register map
1576         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_mirror_patching));
1577       }
1578       break;
1579 
1580     case load_appendix_patching_id:
1581       { StubFrame f(sasm, &quot;load_appendix_patching&quot;, dont_gc_arguments);
1582         // we should set up register map
1583         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_appendix_patching));
1584       }
1585       break;
1586 
1587     case dtrace_object_alloc_id:
1588       { // rax,: object
1589         StubFrame f(sasm, &quot;dtrace_object_alloc&quot;, dont_gc_arguments);
1590         // we can&#39;t gc here so skip the oopmap but make sure that all
1591         // the live registers get saved.
1592         save_live_registers(sasm, 1);
1593 
1594         __ NOT_LP64(push(rax)) LP64_ONLY(mov(c_rarg0, rax));
1595         __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc)));
1596         NOT_LP64(__ pop(rax));
1597 
1598         restore_live_registers(sasm);
1599       }
1600       break;
1601 
1602     case fpu2long_stub_id:
1603       {
1604 #ifdef _LP64
1605         Label done;
1606         __ cvttsd2siq(rax, Address(rsp, wordSize));
1607         __ cmp64(rax, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
1608         __ jccb(Assembler::notEqual, done);
1609         __ movq(rax, Address(rsp, wordSize));
1610         __ subptr(rsp, 8);
1611         __ movq(Address(rsp, 0), rax);
1612         __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
1613         __ pop(rax);
1614         __ bind(done);
1615         __ ret(0);
1616 #else
1617         // rax, and rdx are destroyed, but should be free since the result is returned there
1618         // preserve rsi,ecx
1619         __ push(rsi);
1620         __ push(rcx);
1621 
1622         // check for NaN
1623         Label return0, do_return, return_min_jlong, do_convert;
1624 
1625         Address value_high_word(rsp, wordSize + 4);
1626         Address value_low_word(rsp, wordSize);
1627         Address result_high_word(rsp, 3*wordSize + 4);
1628         Address result_low_word(rsp, 3*wordSize);
1629 
1630         __ subptr(rsp, 32);                    // more than enough on 32bit
1631         __ fst_d(value_low_word);
1632         __ movl(rax, value_high_word);
1633         __ andl(rax, 0x7ff00000);
1634         __ cmpl(rax, 0x7ff00000);
1635         __ jcc(Assembler::notEqual, do_convert);
1636         __ movl(rax, value_high_word);
1637         __ andl(rax, 0xfffff);
1638         __ orl(rax, value_low_word);
1639         __ jcc(Assembler::notZero, return0);
1640 
1641         __ bind(do_convert);
1642         __ fnstcw(Address(rsp, 0));
1643         __ movzwl(rax, Address(rsp, 0));
1644         __ orl(rax, 0xc00);
1645         __ movw(Address(rsp, 2), rax);
1646         __ fldcw(Address(rsp, 2));
1647         __ fwait();
1648         __ fistp_d(result_low_word);
1649         __ fldcw(Address(rsp, 0));
1650         __ fwait();
1651         // This gets the entire long in rax on 64bit
1652         __ movptr(rax, result_low_word);
1653         // testing of high bits
1654         __ movl(rdx, result_high_word);
1655         __ mov(rcx, rax);
1656         // What the heck is the point of the next instruction???
1657         __ xorl(rcx, 0x0);
1658         __ movl(rsi, 0x80000000);
1659         __ xorl(rsi, rdx);
1660         __ orl(rcx, rsi);
1661         __ jcc(Assembler::notEqual, do_return);
1662         __ fldz();
1663         __ fcomp_d(value_low_word);
1664         __ fnstsw_ax();
1665         __ sahf();
1666         __ jcc(Assembler::above, return_min_jlong);
1667         // return max_jlong
1668         __ movl(rdx, 0x7fffffff);
1669         __ movl(rax, 0xffffffff);
1670         __ jmp(do_return);
1671 
1672         __ bind(return_min_jlong);
1673         __ movl(rdx, 0x80000000);
1674         __ xorl(rax, rax);
1675         __ jmp(do_return);
1676 
1677         __ bind(return0);
1678         __ fpop();
1679         __ xorptr(rdx,rdx);
1680         __ xorptr(rax,rax);
1681 
1682         __ bind(do_return);
1683         __ addptr(rsp, 32);
1684         __ pop(rcx);
1685         __ pop(rsi);
1686         __ ret(0);
1687 #endif // _LP64
1688       }
1689       break;
1690 
1691     case predicate_failed_trap_id:
1692       {
1693         StubFrame f(sasm, &quot;predicate_failed_trap&quot;, dont_gc_arguments);
1694 
1695         OopMap* map = save_live_registers(sasm, 1);
1696 
1697         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, predicate_failed_trap));
1698         oop_maps = new OopMapSet();
1699         oop_maps-&gt;add_gc_map(call_offset, map);
1700         restore_live_registers(sasm);
1701         __ leave();
1702         DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
1703         assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
1704 
1705         __ jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
1706       }
1707       break;
1708 
1709     default:
1710       { StubFrame f(sasm, &quot;unimplemented entry&quot;, dont_gc_arguments);
1711         __ movptr(rax, (int)id);
1712         __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, unimplemented_entry), rax);
1713         __ should_not_reach_here();
1714       }
1715       break;
1716   }
1717   return oop_maps;
1718 }
1719 
1720 #undef __
1721 
1722 const char *Runtime1::pd_name_for_address(address entry) {
1723   return &quot;&lt;unknown function&gt;&quot;;
1724 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
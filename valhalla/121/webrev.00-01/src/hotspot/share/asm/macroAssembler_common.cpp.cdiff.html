<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/asm/macroAssembler_common.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/macroAssembler_x86.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_common.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/asm/macroAssembler_common.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 172,20 ***</span>
    if (args_on_stack_cc &gt; args_on_stack) {
      sp_inc = (args_on_stack_cc - args_on_stack) * VMRegImpl::stack_slot_size;
      sp_inc = align_up(sp_inc, StackAlignmentInBytes);
    }
    shuffle_inline_args(false, receiver_only, extra_stack_offset, sig_bt, sig_cc,
<span class="line-modified">!                      args_passed, args_on_stack, regs,</span>
<span class="line-modified">!                      args_passed_cc, args_on_stack_cc, regs_cc, sp_inc);</span>
    return sp_inc;
  }
  
  void MacroAssembler::shuffle_inline_args_common(bool is_packing, bool receiver_only, int extra_stack_offset,
<span class="line-modified">!                                                BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-modified">!                                                int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-modified">!                                                int args_passed_to, int args_on_stack_to, VMRegPair* regs_to,</span>
<span class="line-modified">!                                                int sp_inc, int ret_off) {</span>
    int max_stack = MAX2(args_on_stack + sp_inc/VMRegImpl::stack_slot_size, args_on_stack_to);
    RegState* reg_state = init_reg_state(is_packing, sig_cc, regs, args_passed, sp_inc, max_stack);
  
    // Emit code for packing/unpacking inline type arguments
    // We try multiple times and eventually start spilling to resolve (circular) dependencies
<span class="line-new-header">--- 172,20 ---</span>
    if (args_on_stack_cc &gt; args_on_stack) {
      sp_inc = (args_on_stack_cc - args_on_stack) * VMRegImpl::stack_slot_size;
      sp_inc = align_up(sp_inc, StackAlignmentInBytes);
    }
    shuffle_inline_args(false, receiver_only, extra_stack_offset, sig_bt, sig_cc,
<span class="line-modified">!                       args_passed, args_on_stack, regs,</span>
<span class="line-modified">!                       args_passed_cc, args_on_stack_cc, regs_cc, sp_inc);</span>
    return sp_inc;
  }
  
  void MacroAssembler::shuffle_inline_args_common(bool is_packing, bool receiver_only, int extra_stack_offset,
<span class="line-modified">!                                                 BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-modified">!                                                 int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-modified">!                                                 int args_passed_to, int args_on_stack_to, VMRegPair* regs_to,</span>
<span class="line-modified">!                                                 int sp_inc, int ret_off) {</span>
    int max_stack = MAX2(args_on_stack + sp_inc/VMRegImpl::stack_slot_size, args_on_stack_to);
    RegState* reg_state = init_reg_state(is_packing, sig_cc, regs, args_passed, sp_inc, max_stack);
  
    // Emit code for packing/unpacking inline type arguments
    // We try multiple times and eventually start spilling to resolve (circular) dependencies
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,22 ***</span>
          assert(0 &lt;= from_index &amp;&amp; from_index &lt; args_passed, &quot;index out of bounds&quot;);
          assert(0 &lt;= to_index &amp;&amp; to_index &lt; args_passed_to, &quot;index out of bounds&quot;);
          if (spill) {
            // This call returns true IFF we should keep trying to spill in this round.
            spill = shuffle_inline_args_spill(is_packing, sig_cc, sig_index, regs, from_index, args_passed,
<span class="line-modified">!                                            reg_state, ret_off, extra_stack_offset);</span>
          }
          BasicType bt = sig_cc-&gt;at(sig_index)._bt;
          if (SigEntry::skip_value_delimiters(sig_cc, sig_index)) {
            VMReg from_reg = regs[from_index].first();
            done &amp;= move_helper(from_reg, regs_to[to_index].first(), bt, reg_state, ret_off, extra_stack_offset);
            to_index += step;
          } else if (is_packing || !receiver_only || (from_index == 0 &amp;&amp; bt == T_VOID)) {
            if (is_packing) {
              VMReg reg_to = regs_to[to_index].first();
              done &amp;= pack_inline_helper(sig_cc, sig_index, vtarg_index, reg_to, regs, args_passed, from_index,
<span class="line-modified">!                                       reg_state, ret_off, extra_stack_offset);</span>
              vtarg_index ++;
              to_index ++;
              continue; // from_index already adjusted
            } else {
              VMReg from_reg = regs[from_index].first();
<span class="line-new-header">--- 212,22 ---</span>
          assert(0 &lt;= from_index &amp;&amp; from_index &lt; args_passed, &quot;index out of bounds&quot;);
          assert(0 &lt;= to_index &amp;&amp; to_index &lt; args_passed_to, &quot;index out of bounds&quot;);
          if (spill) {
            // This call returns true IFF we should keep trying to spill in this round.
            spill = shuffle_inline_args_spill(is_packing, sig_cc, sig_index, regs, from_index, args_passed,
<span class="line-modified">!                                             reg_state, ret_off, extra_stack_offset);</span>
          }
          BasicType bt = sig_cc-&gt;at(sig_index)._bt;
          if (SigEntry::skip_value_delimiters(sig_cc, sig_index)) {
            VMReg from_reg = regs[from_index].first();
            done &amp;= move_helper(from_reg, regs_to[to_index].first(), bt, reg_state, ret_off, extra_stack_offset);
            to_index += step;
          } else if (is_packing || !receiver_only || (from_index == 0 &amp;&amp; bt == T_VOID)) {
            if (is_packing) {
              VMReg reg_to = regs_to[to_index].first();
              done &amp;= pack_inline_helper(sig_cc, sig_index, vtarg_index, reg_to, regs, args_passed, from_index,
<span class="line-modified">!                                        reg_state, ret_off, extra_stack_offset);</span>
              vtarg_index ++;
              to_index ++;
              continue; // from_index already adjusted
            } else {
              VMReg from_reg = regs[from_index].first();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,12 ***</span>
    }
    guarantee(done, &quot;Could not resolve circular dependency when shuffling inline type arguments&quot;);
  }
  
  bool MacroAssembler::shuffle_inline_args_spill(bool is_packing, const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
<span class="line-modified">!                                               VMRegPair* regs_from, int from_index, int regs_from_count,</span>
<span class="line-modified">!                                               RegState* reg_state, int ret_off, int extra_stack_offset) {</span>
    VMReg reg;
  
    if (!is_packing || SigEntry::skip_value_delimiters(sig_cc, sig_cc_index)) {
      reg = regs_from[from_index].first();
      if (!reg-&gt;is_valid() || reg_state[reg-&gt;value()] != reg_readonly) {
<span class="line-new-header">--- 242,12 ---</span>
    }
    guarantee(done, &quot;Could not resolve circular dependency when shuffling inline type arguments&quot;);
  }
  
  bool MacroAssembler::shuffle_inline_args_spill(bool is_packing, const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
<span class="line-modified">!                                                VMRegPair* regs_from, int from_index, int regs_from_count,</span>
<span class="line-modified">!                                                RegState* reg_state, int ret_off, int extra_stack_offset) {</span>
    VMReg reg;
  
    if (!is_packing || SigEntry::skip_value_delimiters(sig_cc, sig_cc_index)) {
      reg = regs_from[from_index].first();
      if (!reg-&gt;is_valid() || reg_state[reg-&gt;value()] != reg_readonly) {
</pre>
<center><a href="../../cpu/x86/macroAssembler_x86.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_common.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIRAssembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIRAssembler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/assembler.inline.hpp&quot;
 27 #include &quot;c1/c1_Compilation.hpp&quot;
 28 #include &quot;c1/c1_Instruction.hpp&quot;
 29 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
 30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
<span class="line-removed"> 31 </span>
 32 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 33 #include &quot;c1/c1_ValueStack.hpp&quot;
 34 #include &quot;ci/ciInlineKlass.hpp&quot;
 35 #include &quot;ci/ciInstance.hpp&quot;
 36 #include &quot;gc/shared/barrierSet.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 
 40 void LIR_Assembler::patching_epilog(PatchingStub* patch, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info) {
 41   // We must have enough patching space so that call can be inserted.
 42   // We cannot use fat nops here, since the concurrent code rewrite may transiently
 43   // create the illegal instruction sequence.
 44   while ((intx) _masm-&gt;pc() - (intx) patch-&gt;pc_start() &lt; NativeGeneralJump::instruction_size) {
 45     _masm-&gt;nop();
 46   }
 47   patch-&gt;install(_masm, patch_code, obj, info);
 48   append_code_stub(patch);
 49 
 50 #ifdef ASSERT
 51   Bytecodes::Code code = info-&gt;scope()-&gt;method()-&gt;java_code_at_bci(info-&gt;stack()-&gt;bci());
</pre>
<hr />
<pre>
607   DebugToken* expvals = debug_info-&gt;create_scope_values(NULL); // FIXME is this needed (for Java debugging to work properly??)
608   DebugToken* monvals = debug_info-&gt;create_monitor_values(NULL); // FIXME: need testing with synchronized method
609   bool reexecute = false;
610   bool return_oop = false; // This flag will be ignored since it used only for C2 with escape analysis.
611   bool rethrow_exception = false;
612   bool is_method_handle_invoke = false;
613   debug_info-&gt;describe_scope(pc_offset, methodHandle(), method(), 0, reexecute, rethrow_exception, is_method_handle_invoke, return_oop, false, locvals, expvals, monvals);
614   debug_info-&gt;end_safepoint(pc_offset);
615 }
616 
617 // The entries points of C1-compiled methods can have the following types:
618 // (1) Methods with no inline type args
619 // (2) Methods with inline type receiver but no inline type args
620 //     VIEP_RO is the same as VIEP
621 // (3) Methods with non-inline type receiver and some inline type args
622 //     VIEP_RO is the same as VEP
623 // (4) Methods with inline type receiver and other inline type args
624 //     Separate VEP, VIEP and VIEP_RO
625 //
626 // (1)               (2)                 (3)                    (4)
<span class="line-modified">627 // UEP/UVEP:         VEP:                UEP:                   UEP:</span>
628 //   check_icache      pack receiver       check_icache           check_icache
629 // VEP/VIEP/VIEP_RO    jump to VIEP      VEP/VIEP_RO:           VIEP_RO:
<span class="line-modified">630 //   body            UEP/UVEP:             pack inline args       pack inline args (except receiver)</span>
631 //                     check_icache        jump to VIEP           jump to VIEP
<span class="line-modified">632 //                   VIEP/VIEP_RO        UVEP:                  VEP:</span>
633 //                     body                check_icache           pack all inline args
634 //                                       VIEP:                    jump to VIEP
<span class="line-modified">635 //                                         body                 UVEP:</span>
636 //                                                                check_icache
637 //                                                              VIEP:
638 //                                                                body
639 void LIR_Assembler::emit_std_entries() {
640   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, _masm-&gt;offset());
641 
642   _masm-&gt;align(CodeEntryAlignment);
643   const CompiledEntrySignature* ces = compilation()-&gt;compiled_entry_signature();
644   if (ces-&gt;has_scalarized_args()) {
645     assert(InlineTypePassFieldsAsArgs &amp;&amp; method()-&gt;get_Method()-&gt;has_scalarized_args(), &quot;must be&quot;);
646     CodeOffsets::Entries ro_entry_type = ces-&gt;c1_inline_ro_entry_type();
647 
648     // UEP: check icache and fall-through
649     if (ro_entry_type != CodeOffsets::Verified_Inline_Entry) {
650       offsets()-&gt;set_value(CodeOffsets::Entry, _masm-&gt;offset());
651       if (needs_icache(method())) {
652         check_icache();
653       }
654     }
655 
656     // VIEP_RO: pack all value parameters, except the receiver
657     if (ro_entry_type == CodeOffsets::Verified_Inline_Entry_RO) {
658       emit_std_entry(CodeOffsets::Verified_Inline_Entry_RO, ces);
659     }
660 
661     // VEP: pack all value parameters
662     _masm-&gt;align(CodeEntryAlignment);
663     emit_std_entry(CodeOffsets::Verified_Entry, ces);
664 
<span class="line-modified">665     // UVEP: check icache and fall-through</span>
666     _masm-&gt;align(CodeEntryAlignment);
667     offsets()-&gt;set_value(CodeOffsets::Inline_Entry, _masm-&gt;offset());
668     if (ro_entry_type == CodeOffsets::Verified_Inline_Entry) {
669       // Special case if we have VIEP == VIEP(RO):
<span class="line-modified">670       // this means UVEP (called by C1) == UEP (called by C2).</span>
671       offsets()-&gt;set_value(CodeOffsets::Entry, _masm-&gt;offset());
672     }
673     if (needs_icache(method())) {
674       check_icache();
675     }
676 
677     // VIEP: all value parameters are passed as refs - no packing.
678     emit_std_entry(CodeOffsets::Verified_Inline_Entry, NULL);
679 
680     if (ro_entry_type != CodeOffsets::Verified_Inline_Entry_RO) {
681       // The VIEP(RO) is the same as VEP or VIEP
682       assert(ro_entry_type == CodeOffsets::Verified_Entry ||
683              ro_entry_type == CodeOffsets::Verified_Inline_Entry, &quot;must be&quot;);
684       offsets()-&gt;set_value(CodeOffsets::Verified_Inline_Entry_RO,
685                            offsets()-&gt;value(ro_entry_type));
686     }
687   } else {
688     // All 3 entries are the same (no value-type packing)
689     offsets()-&gt;set_value(CodeOffsets::Entry, _masm-&gt;offset());
690     offsets()-&gt;set_value(CodeOffsets::Inline_Entry, _masm-&gt;offset());
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/assembler.inline.hpp&quot;
 27 #include &quot;c1/c1_Compilation.hpp&quot;
 28 #include &quot;c1/c1_Instruction.hpp&quot;
 29 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
 30 #include &quot;c1/c1_LIRAssembler.hpp&quot;

 31 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 32 #include &quot;c1/c1_ValueStack.hpp&quot;
 33 #include &quot;ci/ciInlineKlass.hpp&quot;
 34 #include &quot;ci/ciInstance.hpp&quot;
 35 #include &quot;gc/shared/barrierSet.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/sharedRuntime.hpp&quot;
 38 
 39 void LIR_Assembler::patching_epilog(PatchingStub* patch, LIR_PatchCode patch_code, Register obj, CodeEmitInfo* info) {
 40   // We must have enough patching space so that call can be inserted.
 41   // We cannot use fat nops here, since the concurrent code rewrite may transiently
 42   // create the illegal instruction sequence.
 43   while ((intx) _masm-&gt;pc() - (intx) patch-&gt;pc_start() &lt; NativeGeneralJump::instruction_size) {
 44     _masm-&gt;nop();
 45   }
 46   patch-&gt;install(_masm, patch_code, obj, info);
 47   append_code_stub(patch);
 48 
 49 #ifdef ASSERT
 50   Bytecodes::Code code = info-&gt;scope()-&gt;method()-&gt;java_code_at_bci(info-&gt;stack()-&gt;bci());
</pre>
<hr />
<pre>
606   DebugToken* expvals = debug_info-&gt;create_scope_values(NULL); // FIXME is this needed (for Java debugging to work properly??)
607   DebugToken* monvals = debug_info-&gt;create_monitor_values(NULL); // FIXME: need testing with synchronized method
608   bool reexecute = false;
609   bool return_oop = false; // This flag will be ignored since it used only for C2 with escape analysis.
610   bool rethrow_exception = false;
611   bool is_method_handle_invoke = false;
612   debug_info-&gt;describe_scope(pc_offset, methodHandle(), method(), 0, reexecute, rethrow_exception, is_method_handle_invoke, return_oop, false, locvals, expvals, monvals);
613   debug_info-&gt;end_safepoint(pc_offset);
614 }
615 
616 // The entries points of C1-compiled methods can have the following types:
617 // (1) Methods with no inline type args
618 // (2) Methods with inline type receiver but no inline type args
619 //     VIEP_RO is the same as VIEP
620 // (3) Methods with non-inline type receiver and some inline type args
621 //     VIEP_RO is the same as VEP
622 // (4) Methods with inline type receiver and other inline type args
623 //     Separate VEP, VIEP and VIEP_RO
624 //
625 // (1)               (2)                 (3)                    (4)
<span class="line-modified">626 // UEP/UIEP:         VEP:                UEP:                   UEP:</span>
627 //   check_icache      pack receiver       check_icache           check_icache
628 // VEP/VIEP/VIEP_RO    jump to VIEP      VEP/VIEP_RO:           VIEP_RO:
<span class="line-modified">629 //   body            UEP/UIEP:             pack inline args       pack inline args (except receiver)</span>
630 //                     check_icache        jump to VIEP           jump to VIEP
<span class="line-modified">631 //                   VIEP/VIEP_RO        UIEP:                  VEP:</span>
632 //                     body                check_icache           pack all inline args
633 //                                       VIEP:                    jump to VIEP
<span class="line-modified">634 //                                         body                 UIEP:</span>
635 //                                                                check_icache
636 //                                                              VIEP:
637 //                                                                body
638 void LIR_Assembler::emit_std_entries() {
639   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, _masm-&gt;offset());
640 
641   _masm-&gt;align(CodeEntryAlignment);
642   const CompiledEntrySignature* ces = compilation()-&gt;compiled_entry_signature();
643   if (ces-&gt;has_scalarized_args()) {
644     assert(InlineTypePassFieldsAsArgs &amp;&amp; method()-&gt;get_Method()-&gt;has_scalarized_args(), &quot;must be&quot;);
645     CodeOffsets::Entries ro_entry_type = ces-&gt;c1_inline_ro_entry_type();
646 
647     // UEP: check icache and fall-through
648     if (ro_entry_type != CodeOffsets::Verified_Inline_Entry) {
649       offsets()-&gt;set_value(CodeOffsets::Entry, _masm-&gt;offset());
650       if (needs_icache(method())) {
651         check_icache();
652       }
653     }
654 
655     // VIEP_RO: pack all value parameters, except the receiver
656     if (ro_entry_type == CodeOffsets::Verified_Inline_Entry_RO) {
657       emit_std_entry(CodeOffsets::Verified_Inline_Entry_RO, ces);
658     }
659 
660     // VEP: pack all value parameters
661     _masm-&gt;align(CodeEntryAlignment);
662     emit_std_entry(CodeOffsets::Verified_Entry, ces);
663 
<span class="line-modified">664     // UIEP: check icache and fall-through</span>
665     _masm-&gt;align(CodeEntryAlignment);
666     offsets()-&gt;set_value(CodeOffsets::Inline_Entry, _masm-&gt;offset());
667     if (ro_entry_type == CodeOffsets::Verified_Inline_Entry) {
668       // Special case if we have VIEP == VIEP(RO):
<span class="line-modified">669       // this means UIEP (called by C1) == UEP (called by C2).</span>
670       offsets()-&gt;set_value(CodeOffsets::Entry, _masm-&gt;offset());
671     }
672     if (needs_icache(method())) {
673       check_icache();
674     }
675 
676     // VIEP: all value parameters are passed as refs - no packing.
677     emit_std_entry(CodeOffsets::Verified_Inline_Entry, NULL);
678 
679     if (ro_entry_type != CodeOffsets::Verified_Inline_Entry_RO) {
680       // The VIEP(RO) is the same as VEP or VIEP
681       assert(ro_entry_type == CodeOffsets::Verified_Entry ||
682              ro_entry_type == CodeOffsets::Verified_Inline_Entry, &quot;must be&quot;);
683       offsets()-&gt;set_value(CodeOffsets::Verified_Inline_Entry_RO,
684                            offsets()-&gt;value(ro_entry_type));
685     }
686   } else {
687     // All 3 entries are the same (no value-type packing)
688     offsets()-&gt;set_value(CodeOffsets::Entry, _masm-&gt;offset());
689     offsets()-&gt;set_value(CodeOffsets::Inline_Entry, _masm-&gt;offset());
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/method.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../code/nmethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/compile.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  89     _hidden                = 1 &lt;&lt; 3,
  90     _has_injected_profile  = 1 &lt;&lt; 4,
  91     _running_emcp          = 1 &lt;&lt; 5,
  92     _intrinsic_candidate   = 1 &lt;&lt; 6,
  93     _reserved_stack_access = 1 &lt;&lt; 7,
  94     _scalarized_args       = 1 &lt;&lt; 8,
  95     _c1_needs_stack_repair = 1 &lt;&lt; 9,
  96     _c2_needs_stack_repair = 1 &lt;&lt; 10
  97   };
  98   mutable u2 _flags;
  99 
 100   JFR_ONLY(DEFINE_TRACE_FLAG;)
 101 
 102 #ifndef PRODUCT
 103   int               _compiled_invocation_count;  // Number of nmethod invocations so far (for perf. debugging)
 104 #endif
 105   // Entry point for calling both from and to the interpreter.
 106   address _i2i_entry;           // All-args-on-stack calling convention
 107   // Entry point for calling from compiled code, to compiled code if it exists
 108   // or else the interpreter.
<span class="line-modified"> 109   volatile address _from_compiled_entry;          // Cache of: _code ? _code-&gt;verified_entry_point()          : _adapter-&gt;c2i_entry()</span>
 110   volatile address _from_compiled_inline_ro_entry; // Cache of: _code ? _code-&gt;verified_inline_ro_entry_point() : _adapter-&gt;c2i_inline_ro_entry()
 111   volatile address _from_compiled_inline_entry;    // Cache of: _code ? _code-&gt;verified_inline_entry_point()    : _adapter-&gt;c2i_inline_entry()
 112   // The entry point for calling both from and to compiled code is
 113   // &quot;_code-&gt;entry_point()&quot;.  Because of tiered compilation and de-opt, this
 114   // field can come and go.  It can transition from NULL to not-null at any
 115   // time (whenever a compile completes).  It can transition from not-null to
 116   // NULL only at safepoints (because of a de-opt).
 117   CompiledMethod* volatile _code;                       // Points to the corresponding piece of native code
 118   volatile address           _from_interpreted_entry; // Cache of _code ? _adapter-&gt;i2c_entry() : _i2i_entry
 119   int _max_vt_buffer; // max number of VT buffer chunk to use before recycling
 120 
 121 #if INCLUDE_AOT &amp;&amp; defined(TIERED)
 122   CompiledMethod* _aot_code;
 123 #endif
 124 
 125   // Constructor
 126   Method(ConstMethod* xconst, AccessFlags access_flags);
 127  public:
 128 
 129   static Method* allocate(ClassLoaderData* loader_data,
</pre>
</td>
<td>
<hr />
<pre>
  89     _hidden                = 1 &lt;&lt; 3,
  90     _has_injected_profile  = 1 &lt;&lt; 4,
  91     _running_emcp          = 1 &lt;&lt; 5,
  92     _intrinsic_candidate   = 1 &lt;&lt; 6,
  93     _reserved_stack_access = 1 &lt;&lt; 7,
  94     _scalarized_args       = 1 &lt;&lt; 8,
  95     _c1_needs_stack_repair = 1 &lt;&lt; 9,
  96     _c2_needs_stack_repair = 1 &lt;&lt; 10
  97   };
  98   mutable u2 _flags;
  99 
 100   JFR_ONLY(DEFINE_TRACE_FLAG;)
 101 
 102 #ifndef PRODUCT
 103   int               _compiled_invocation_count;  // Number of nmethod invocations so far (for perf. debugging)
 104 #endif
 105   // Entry point for calling both from and to the interpreter.
 106   address _i2i_entry;           // All-args-on-stack calling convention
 107   // Entry point for calling from compiled code, to compiled code if it exists
 108   // or else the interpreter.
<span class="line-modified"> 109   volatile address _from_compiled_entry;           // Cache of: _code ? _code-&gt;verified_entry_point()           : _adapter-&gt;c2i_entry()</span>
 110   volatile address _from_compiled_inline_ro_entry; // Cache of: _code ? _code-&gt;verified_inline_ro_entry_point() : _adapter-&gt;c2i_inline_ro_entry()
 111   volatile address _from_compiled_inline_entry;    // Cache of: _code ? _code-&gt;verified_inline_entry_point()    : _adapter-&gt;c2i_inline_entry()
 112   // The entry point for calling both from and to compiled code is
 113   // &quot;_code-&gt;entry_point()&quot;.  Because of tiered compilation and de-opt, this
 114   // field can come and go.  It can transition from NULL to not-null at any
 115   // time (whenever a compile completes).  It can transition from not-null to
 116   // NULL only at safepoints (because of a de-opt).
 117   CompiledMethod* volatile _code;                       // Points to the corresponding piece of native code
 118   volatile address           _from_interpreted_entry; // Cache of _code ? _adapter-&gt;i2c_entry() : _i2i_entry
 119   int _max_vt_buffer; // max number of VT buffer chunk to use before recycling
 120 
 121 #if INCLUDE_AOT &amp;&amp; defined(TIERED)
 122   CompiledMethod* _aot_code;
 123 #endif
 124 
 125   // Constructor
 126   Method(ConstMethod* xconst, AccessFlags access_flags);
 127  public:
 128 
 129   static Method* allocate(ClassLoaderData* loader_data,
</pre>
</td>
</tr>
</table>
<center><a href="../code/nmethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/compile.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
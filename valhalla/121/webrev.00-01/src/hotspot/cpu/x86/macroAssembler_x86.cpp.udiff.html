<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_MacroAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -5347,11 +5347,11 @@</span>
    return true;
  }
  
  // Read all fields from an inline type oop and store the values in registers/stack slots
  bool MacroAssembler::unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,
<span class="udiff-line-modified-removed">-                                          int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
<span class="udiff-line-modified-added">+                                           int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
    Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;
    assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);
  
    int vt = 1;
    bool done = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5429,12 +5429,12 @@</span>
    return done;
  }
  
  // Pack fields back into an inline type oop
  bool MacroAssembler::pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
<span class="udiff-line-modified-removed">-                                        VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="udiff-line-modified-removed">-                                        int ret_off, int extra_stack_offset) {</span>
<span class="udiff-line-modified-added">+                                         VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="udiff-line-modified-added">+                                         int ret_off, int extra_stack_offset) {</span>
    assert(sig-&gt;at(sig_index)._bt == T_INLINE_TYPE, &quot;should be at end delimiter&quot;);
    assert(to-&gt;is_valid(), &quot;must be&quot;);
  
    if (reg_state[to-&gt;value()] == reg_written) {
      skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5514,13 +5514,13 @@</span>
    // Emit code for verified entry and save increment for stack repair on return
    verified_entry(C, sp_inc);
  }
  
  void MacroAssembler::shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,
<span class="udiff-line-modified-removed">-                                         BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="udiff-line-modified-removed">-                                         int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="udiff-line-modified-removed">-                                         int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc) {</span>
<span class="udiff-line-modified-added">+                                          BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="udiff-line-modified-added">+                                          int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="udiff-line-modified-added">+                                          int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc) {</span>
    // Check if we need to extend the stack for packing/unpacking
    if (sp_inc &gt; 0 &amp;&amp; !is_packing) {
      // Save the return address, adjust the stack (make sure it is properly
      // 16-byte aligned) and copy the return address to the new top of the stack.
      // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5538,14 +5538,14 @@</span>
      // C2 code ensures that sp_inc is a reserved slot.
      ret_off = sp_inc;
    }
  
    shuffle_inline_args_common(is_packing, receiver_only, extra_stack_offset,
<span class="udiff-line-modified-removed">-                             sig_bt, sig_cc,</span>
<span class="udiff-line-modified-removed">-                             args_passed, args_on_stack, regs,</span>
<span class="udiff-line-modified-removed">-                             args_passed_to, args_on_stack_to, regs_to,</span>
<span class="udiff-line-modified-removed">-                             sp_inc, ret_off);</span>
<span class="udiff-line-modified-added">+                              sig_bt, sig_cc,</span>
<span class="udiff-line-modified-added">+                              args_passed, args_on_stack, regs,</span>
<span class="udiff-line-modified-added">+                              args_passed_to, args_on_stack_to, regs_to,</span>
<span class="udiff-line-modified-added">+                              sp_inc, ret_off);</span>
  }
  
  VMReg MacroAssembler::spill_reg_for(VMReg reg) {
    return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();
  }
</pre>
<center><a href="c1_MacroAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
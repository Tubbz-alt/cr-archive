<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
5332           }
5333         } else {
5334           movq(to-&gt;as_Register(), from_addr);
5335         }
5336       } else {
5337         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5338         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5339         movq(r13, from_addr);
5340         movq(Address(rsp, st_off), r13);
5341       }
5342     }
5343   }
5344   // Update register states
5345   reg_state[from-&gt;value()] = reg_writable;
5346   reg_state[to-&gt;value()] = reg_written;
5347   return true;
5348 }
5349 
5350 // Read all fields from an inline type oop and store the values in registers/stack slots
5351 bool MacroAssembler::unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,
<span class="line-modified">5352                                          int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
5353   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;
5354   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);
5355 
5356   int vt = 1;
5357   bool done = true;
5358   bool mark_done = true;
5359   do {
5360     sig_index--;
5361     BasicType bt = sig-&gt;at(sig_index)._bt;
5362     if (bt == T_INLINE_TYPE) {
5363       vt--;
5364     } else if (bt == T_VOID &amp;&amp;
5365                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;
5366                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {
5367       vt++;
5368     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {
5369       to_index--; // Ignore this
5370     } else {
5371       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);
5372       VMRegPair pair_to = regs_to[to_index--];
</pre>
<hr />
<pre>
5414         }
5415       } else {
5416         if (bt == T_DOUBLE) {
5417           movdbl(to-&gt;as_XMMRegister(), fromAddr);
5418         } else {
5419           assert(bt == T_FLOAT, &quot;must be float&quot;);
5420           movflt(to-&gt;as_XMMRegister(), fromAddr);
5421         }
5422       }
5423     }
5424   } while (vt != 0);
5425   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {
5426     // This is okay because no one else will write to that slot
5427     reg_state[from-&gt;value()] = reg_writable;
5428   }
5429   return done;
5430 }
5431 
5432 // Pack fields back into an inline type oop
5433 bool MacroAssembler::pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
<span class="line-modified">5434                                        VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="line-modified">5435                                        int ret_off, int extra_stack_offset) {</span>
5436   assert(sig-&gt;at(sig_index)._bt == T_INLINE_TYPE, &quot;should be at end delimiter&quot;);
5437   assert(to-&gt;is_valid(), &quot;must be&quot;);
5438 
5439   if (reg_state[to-&gt;value()] == reg_written) {
5440     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5441     return true; // Already written
5442   }
5443 
5444   Register val_array = rax;
5445   Register val_obj_tmp = r11;
5446   Register from_reg_tmp = r14; // Be careful with r14 because it&#39;s used for spilling
5447   Register tmp1 = r10;
5448   Register tmp2 = r13;
5449   Register tmp3 = rbx;
5450   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();
5451 
5452   if (reg_state[to-&gt;value()] == reg_readonly) {
5453     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {
5454       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5455       return false; // Not yet writable
</pre>
<hr />
<pre>
5499     reg_state[from_r1-&gt;value()] = reg_writable;
5500   }
5501   sig_index = stream.sig_cc_index();
5502   from_index = stream.regs_cc_index();
5503 
5504   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);
5505   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);
5506   assert(success, &quot;to register must be writeable&quot;);
5507 
5508   return true;
5509 }
5510 
5511 // Unpack all inline type arguments passed as oops
5512 void MacroAssembler::unpack_inline_args(Compile* C, bool receiver_only) {
5513   int sp_inc = unpack_inline_args_common(C, receiver_only);
5514   // Emit code for verified entry and save increment for stack repair on return
5515   verified_entry(C, sp_inc);
5516 }
5517 
5518 void MacroAssembler::shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,
<span class="line-modified">5519                                         BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-modified">5520                                         int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-modified">5521                                         int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc) {</span>
5522   // Check if we need to extend the stack for packing/unpacking
5523   if (sp_inc &gt; 0 &amp;&amp; !is_packing) {
5524     // Save the return address, adjust the stack (make sure it is properly
5525     // 16-byte aligned) and copy the return address to the new top of the stack.
5526     // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).
5527     pop(r13);
5528     subptr(rsp, sp_inc);
5529     push(r13);
5530   }
5531 
5532   int ret_off; // make sure we don&#39;t overwrite the return address
5533   if (is_packing) {
5534     // For C1 code, the VIEP doesn&#39;t have reserved slots, so we store the returned address at
5535     // rsp[0] during shuffling.
5536     ret_off = 0;
5537   } else {
5538     // C2 code ensures that sp_inc is a reserved slot.
5539     ret_off = sp_inc;
5540   }
5541 
5542   shuffle_inline_args_common(is_packing, receiver_only, extra_stack_offset,
<span class="line-modified">5543                             sig_bt, sig_cc,</span>
<span class="line-modified">5544                             args_passed, args_on_stack, regs,</span>
<span class="line-modified">5545                             args_passed_to, args_on_stack_to, regs_to,</span>
<span class="line-modified">5546                             sp_inc, ret_off);</span>
5547 }
5548 
5549 VMReg MacroAssembler::spill_reg_for(VMReg reg) {
5550   return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();
5551 }
5552 
5553 void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {
5554   assert((initial_framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5555   if (needs_stack_repair) {
5556     movq(rbp, Address(rsp, initial_framesize));
5557     addq(rsp, Address(rsp, sp_inc_offset));
5558   } else {
5559     if (initial_framesize &gt; 0) {
5560       addq(rsp, initial_framesize);
5561     }
5562     pop(rbp);
5563   }
5564 }
5565 
5566 void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {
</pre>
</td>
<td>
<hr />
<pre>
5332           }
5333         } else {
5334           movq(to-&gt;as_Register(), from_addr);
5335         }
5336       } else {
5337         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5338         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5339         movq(r13, from_addr);
5340         movq(Address(rsp, st_off), r13);
5341       }
5342     }
5343   }
5344   // Update register states
5345   reg_state[from-&gt;value()] = reg_writable;
5346   reg_state[to-&gt;value()] = reg_written;
5347   return true;
5348 }
5349 
5350 // Read all fields from an inline type oop and store the values in registers/stack slots
5351 bool MacroAssembler::unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,
<span class="line-modified">5352                                           int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
5353   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;
5354   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);
5355 
5356   int vt = 1;
5357   bool done = true;
5358   bool mark_done = true;
5359   do {
5360     sig_index--;
5361     BasicType bt = sig-&gt;at(sig_index)._bt;
5362     if (bt == T_INLINE_TYPE) {
5363       vt--;
5364     } else if (bt == T_VOID &amp;&amp;
5365                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;
5366                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {
5367       vt++;
5368     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {
5369       to_index--; // Ignore this
5370     } else {
5371       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);
5372       VMRegPair pair_to = regs_to[to_index--];
</pre>
<hr />
<pre>
5414         }
5415       } else {
5416         if (bt == T_DOUBLE) {
5417           movdbl(to-&gt;as_XMMRegister(), fromAddr);
5418         } else {
5419           assert(bt == T_FLOAT, &quot;must be float&quot;);
5420           movflt(to-&gt;as_XMMRegister(), fromAddr);
5421         }
5422       }
5423     }
5424   } while (vt != 0);
5425   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {
5426     // This is okay because no one else will write to that slot
5427     reg_state[from-&gt;value()] = reg_writable;
5428   }
5429   return done;
5430 }
5431 
5432 // Pack fields back into an inline type oop
5433 bool MacroAssembler::pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
<span class="line-modified">5434                                         VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="line-modified">5435                                         int ret_off, int extra_stack_offset) {</span>
5436   assert(sig-&gt;at(sig_index)._bt == T_INLINE_TYPE, &quot;should be at end delimiter&quot;);
5437   assert(to-&gt;is_valid(), &quot;must be&quot;);
5438 
5439   if (reg_state[to-&gt;value()] == reg_written) {
5440     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5441     return true; // Already written
5442   }
5443 
5444   Register val_array = rax;
5445   Register val_obj_tmp = r11;
5446   Register from_reg_tmp = r14; // Be careful with r14 because it&#39;s used for spilling
5447   Register tmp1 = r10;
5448   Register tmp2 = r13;
5449   Register tmp3 = rbx;
5450   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();
5451 
5452   if (reg_state[to-&gt;value()] == reg_readonly) {
5453     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {
5454       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5455       return false; // Not yet writable
</pre>
<hr />
<pre>
5499     reg_state[from_r1-&gt;value()] = reg_writable;
5500   }
5501   sig_index = stream.sig_cc_index();
5502   from_index = stream.regs_cc_index();
5503 
5504   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);
5505   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);
5506   assert(success, &quot;to register must be writeable&quot;);
5507 
5508   return true;
5509 }
5510 
5511 // Unpack all inline type arguments passed as oops
5512 void MacroAssembler::unpack_inline_args(Compile* C, bool receiver_only) {
5513   int sp_inc = unpack_inline_args_common(C, receiver_only);
5514   // Emit code for verified entry and save increment for stack repair on return
5515   verified_entry(C, sp_inc);
5516 }
5517 
5518 void MacroAssembler::shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,
<span class="line-modified">5519                                          BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-modified">5520                                          int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-modified">5521                                          int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc) {</span>
5522   // Check if we need to extend the stack for packing/unpacking
5523   if (sp_inc &gt; 0 &amp;&amp; !is_packing) {
5524     // Save the return address, adjust the stack (make sure it is properly
5525     // 16-byte aligned) and copy the return address to the new top of the stack.
5526     // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).
5527     pop(r13);
5528     subptr(rsp, sp_inc);
5529     push(r13);
5530   }
5531 
5532   int ret_off; // make sure we don&#39;t overwrite the return address
5533   if (is_packing) {
5534     // For C1 code, the VIEP doesn&#39;t have reserved slots, so we store the returned address at
5535     // rsp[0] during shuffling.
5536     ret_off = 0;
5537   } else {
5538     // C2 code ensures that sp_inc is a reserved slot.
5539     ret_off = sp_inc;
5540   }
5541 
5542   shuffle_inline_args_common(is_packing, receiver_only, extra_stack_offset,
<span class="line-modified">5543                              sig_bt, sig_cc,</span>
<span class="line-modified">5544                              args_passed, args_on_stack, regs,</span>
<span class="line-modified">5545                              args_passed_to, args_on_stack_to, regs_to,</span>
<span class="line-modified">5546                              sp_inc, ret_off);</span>
5547 }
5548 
5549 VMReg MacroAssembler::spill_reg_for(VMReg reg) {
5550   return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();
5551 }
5552 
5553 void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {
5554   assert((initial_framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5555   if (needs_stack_repair) {
5556     movq(rbp, Address(rsp, initial_framesize));
5557     addq(rsp, Address(rsp, sp_inc_offset));
5558   } else {
5559     if (initial_framesize &gt; 0) {
5560       addq(rsp, initial_framesize);
5561     }
5562     pop(rbp);
5563   }
5564 }
5565 
5566 void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
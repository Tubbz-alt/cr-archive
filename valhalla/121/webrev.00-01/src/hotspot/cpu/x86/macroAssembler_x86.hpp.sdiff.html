<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/asm/macroAssembler_common.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1643   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1644   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1645 
1646 
1647  public:
1648   // C2 compiled method&#39;s prolog code.
1649   void verified_entry(Compile* C, int sp_inc = 0);
1650 
1651   enum RegState {
1652     reg_readonly,
1653     reg_writable,
1654     reg_written
1655   };
1656 
1657   int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);
1658 
1659   // Unpack all inline type arguments passed as oops
1660   void unpack_inline_args(Compile* C, bool receiver_only);
1661   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1662   bool unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
<span class="line-modified">1663                            RegState reg_state[], int ret_off, int extra_stack_offset);</span>
1664   bool pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
<span class="line-modified">1665                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="line-modified">1666                          int ret_off, int extra_stack_offset);</span>
1667   void remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset);
1668 
1669   void shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,
<span class="line-modified">1670                           BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-modified">1671                           int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-modified">1672                           int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc);</span>
1673   bool shuffle_inline_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
<span class="line-modified">1674                                 VMRegPair* regs_from, int from_index, int regs_from_count,</span>
<span class="line-modified">1675                                 RegState* reg_state, int sp_inc, int extra_stack_offset);</span>
1676   VMReg spill_reg_for(VMReg reg);
1677 
1678   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1679   // if &#39;is_large&#39; is set, do not try to produce short loop
1680   void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only);
1681 
1682   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1683   void xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp);
1684 
1685   // Fill primitive arrays
1686   void generate_fill(BasicType t, bool aligned,
1687                      Register to, Register value, Register count,
1688                      Register rtmp, XMMRegister xtmp);
1689 
1690   void encode_iso_array(Register src, Register dst, Register len,
1691                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1692                         XMMRegister tmp4, Register tmp5, Register result);
1693 
1694 #ifdef _LP64
1695   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
</pre>
</td>
<td>
<hr />
<pre>
1643   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1644   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1645 
1646 
1647  public:
1648   // C2 compiled method&#39;s prolog code.
1649   void verified_entry(Compile* C, int sp_inc = 0);
1650 
1651   enum RegState {
1652     reg_readonly,
1653     reg_writable,
1654     reg_written
1655   };
1656 
1657   int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);
1658 
1659   // Unpack all inline type arguments passed as oops
1660   void unpack_inline_args(Compile* C, bool receiver_only);
1661   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1662   bool unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
<span class="line-modified">1663                             RegState reg_state[], int ret_off, int extra_stack_offset);</span>
1664   bool pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
<span class="line-modified">1665                           VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="line-modified">1666                           int ret_off, int extra_stack_offset);</span>
1667   void remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset);
1668 
1669   void shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,
<span class="line-modified">1670                            BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-modified">1671                            int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-modified">1672                            int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc);</span>
1673   bool shuffle_inline_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
<span class="line-modified">1674                                  VMRegPair* regs_from, int from_index, int regs_from_count,</span>
<span class="line-modified">1675                                  RegState* reg_state, int sp_inc, int extra_stack_offset);</span>
1676   VMReg spill_reg_for(VMReg reg);
1677 
1678   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1679   // if &#39;is_large&#39; is set, do not try to produce short loop
1680   void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only);
1681 
1682   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1683   void xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp);
1684 
1685   // Fill primitive arrays
1686   void generate_fill(BasicType t, bool aligned,
1687                      Register to, Register value, Register count,
1688                      Register rtmp, XMMRegister xtmp);
1689 
1690   void encode_iso_array(Register src, Register dst, Register len,
1691                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1692                         XMMRegister tmp4, Register tmp5, Register result);
1693 
1694 #ifdef _LP64
1695   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/asm/macroAssembler_common.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
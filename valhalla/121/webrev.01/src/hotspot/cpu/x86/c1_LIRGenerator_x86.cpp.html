<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_FrameMap.hpp&quot;
  28 #include &quot;c1/c1_Instruction.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArray.hpp&quot;
  34 #include &quot;ci/ciInlineKlass.hpp&quot;
  35 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  36 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  37 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;
  40 #include &quot;utilities/powerOfTwo.hpp&quot;
  41 #include &quot;vmreg_x86.inline.hpp&quot;
  42 
  43 #ifdef ASSERT
  44 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  45 #else
  46 #define __ gen()-&gt;lir()-&gt;
  47 #endif
  48 
  49 // Item will be loaded into a byte register; Intel only
  50 void LIRItem::load_byte_item() {
  51   load_item();
  52   LIR_Opr res = result();
  53 
  54   if (!res-&gt;is_virtual() || !_gen-&gt;is_vreg_flag_set(res, LIRGenerator::byte_reg)) {
  55     // make sure that it is a byte register
  56     assert(!value()-&gt;type()-&gt;is_float() &amp;&amp; !value()-&gt;type()-&gt;is_double(),
  57            &quot;can&#39;t load floats in byte register&quot;);
  58     LIR_Opr reg = _gen-&gt;rlock_byte(T_BYTE);
  59     __ move(res, reg);
  60 
  61     _result = reg;
  62   }
  63 }
  64 
  65 
  66 void LIRItem::load_nonconstant() {
  67   LIR_Opr r = value()-&gt;operand();
  68   if (r-&gt;is_constant()) {
  69     _result = r;
  70   } else {
  71     load_item();
  72   }
  73 }
  74 
  75 //--------------------------------------------------------------
  76 //               LIRGenerator
  77 //--------------------------------------------------------------
  78 
  79 
  80 LIR_Opr LIRGenerator::exceptionOopOpr() { return FrameMap::rax_oop_opr; }
  81 LIR_Opr LIRGenerator::exceptionPcOpr()  { return FrameMap::rdx_opr; }
  82 LIR_Opr LIRGenerator::divInOpr()        { return FrameMap::rax_opr; }
  83 LIR_Opr LIRGenerator::divOutOpr()       { return FrameMap::rax_opr; }
  84 LIR_Opr LIRGenerator::remOutOpr()       { return FrameMap::rdx_opr; }
  85 LIR_Opr LIRGenerator::shiftCountOpr()   { return FrameMap::rcx_opr; }
  86 LIR_Opr LIRGenerator::syncLockOpr()     { return new_register(T_INT); }
  87 LIR_Opr LIRGenerator::syncTempOpr()     { return FrameMap::rax_opr; }
  88 LIR_Opr LIRGenerator::getThreadTemp()   { return LIR_OprFact::illegalOpr; }
  89 
  90 
  91 LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {
  92   LIR_Opr opr;
  93   switch (type-&gt;tag()) {
  94     case intTag:     opr = FrameMap::rax_opr;          break;
  95     case objectTag:  opr = FrameMap::rax_oop_opr;      break;
  96     case longTag:    opr = FrameMap::long0_opr;        break;
  97 #ifdef _LP64
  98     case floatTag:   opr = FrameMap::xmm0_float_opr;   break;
  99     case doubleTag:  opr = FrameMap::xmm0_double_opr;  break;
 100 #else
 101     case floatTag:   opr = UseSSE &gt;= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;
 102     case doubleTag:  opr = UseSSE &gt;= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;
 103 #endif // _LP64
 104     case addressTag:
 105     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
 106   }
 107 
 108   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
 109   return opr;
 110 }
 111 
 112 
 113 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 114   LIR_Opr reg = new_register(T_INT);
 115   set_vreg_flag(reg, LIRGenerator::byte_reg);
 116   return reg;
 117 }
 118 
 119 
 120 void LIRGenerator::init_temps_for_substitutability_check(LIR_Opr&amp; tmp1, LIR_Opr&amp; tmp2) {
 121   // We just need one 32-bit temp register for x86/x64, to check whether both
 122   // oops have markWord::always_locked_pattern. See LIR_Assembler::emit_opSubstitutabilityCheck().
 123   // @temp = %r10d
 124   // mov $0x405, %r10d
 125   // and (%left), %r10d   /* if need to check left */
 126   // and (%right), %r10d  /* if need to check right */
 127   // cmp $0x405, $r10d
 128   // jne L_oops_not_equal
 129   tmp1 = new_register(T_INT);
 130   tmp2 = LIR_OprFact::illegalOpr;
 131 }
 132 
 133 //--------- loading items into registers --------------------------------
 134 
 135 
 136 // i486 instructions can inline constants
 137 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 138   if (type == T_SHORT || type == T_CHAR) {
 139     // there is no immediate move of word values in asembler_i486.?pp
 140     return false;
 141   }
 142   Constant* c = v-&gt;as_Constant();
 143   if (c &amp;&amp; c-&gt;state_before() == NULL) {
 144     // constants of any type can be stored directly, except for
 145     // unloaded object constants.
 146     return true;
 147   }
 148   return false;
 149 }
 150 
 151 
 152 bool LIRGenerator::can_inline_as_constant(Value v) const {
 153   if (v-&gt;type()-&gt;tag() == longTag) return false;
 154   return v-&gt;type()-&gt;tag() != objectTag ||
 155     (v-&gt;type()-&gt;is_constant() &amp;&amp; v-&gt;type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object());
 156 }
 157 
 158 
 159 bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const {
 160   if (c-&gt;type() == T_LONG) return false;
 161   return c-&gt;type() != T_OBJECT || c-&gt;as_jobject() == NULL;
 162 }
 163 
 164 
 165 LIR_Opr LIRGenerator::safepoint_poll_register() {
 166   NOT_LP64( return new_register(T_ADDRESS); )
 167   return LIR_OprFact::illegalOpr;
 168 }
 169 
 170 
 171 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 172                                             int shift, int disp, BasicType type) {
 173   assert(base-&gt;is_register(), &quot;must be&quot;);
 174   if (index-&gt;is_constant()) {
 175     LIR_Const *constant = index-&gt;as_constant_ptr();
 176 #ifdef _LP64
 177     jlong c;
 178     if (constant-&gt;type() == T_INT) {
 179       c = (jlong(index-&gt;as_jint()) &lt;&lt; shift) + disp;
 180     } else {
 181       assert(constant-&gt;type() == T_LONG, &quot;should be&quot;);
 182       c = (index-&gt;as_jlong() &lt;&lt; shift) + disp;
 183     }
 184     if ((jlong)((jint)c) == c) {
 185       return new LIR_Address(base, (jint)c, type);
 186     } else {
 187       LIR_Opr tmp = new_register(T_LONG);
 188       __ move(index, tmp);
 189       return new LIR_Address(base, tmp, type);
 190     }
 191 #else
 192     return new LIR_Address(base,
 193                            ((intx)(constant-&gt;as_jint()) &lt;&lt; shift) + disp,
 194                            type);
 195 #endif
 196   } else {
 197     return new LIR_Address(base, index, (LIR_Address::Scale)shift, disp, type);
 198   }
 199 }
 200 
 201 
 202 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 203                                               BasicType type) {
 204   int offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);
 205 
 206   LIR_Address* addr;
 207   if (index_opr-&gt;is_constant()) {
 208     int elem_size = type2aelembytes(type);
 209     addr = new LIR_Address(array_opr,
 210                            offset_in_bytes + (intx)(index_opr-&gt;as_jint()) * elem_size, type);
 211   } else {
 212 #ifdef _LP64
 213     if (index_opr-&gt;type() == T_INT) {
 214       LIR_Opr tmp = new_register(T_LONG);
 215       __ convert(Bytecodes::_i2l, index_opr, tmp);
 216       index_opr = tmp;
 217     }
 218 #endif // _LP64
 219     addr =  new LIR_Address(array_opr,
 220                             index_opr,
 221                             LIR_Address::scale(type),
 222                             offset_in_bytes, type);
 223   }
 224   return addr;
 225 }
 226 
 227 
 228 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 229   LIR_Opr r = NULL;
 230   if (type == T_LONG) {
 231     r = LIR_OprFact::longConst(x);
 232   } else if (type == T_INT) {
 233     r = LIR_OprFact::intConst(x);
 234   } else {
 235     ShouldNotReachHere();
 236   }
 237   return r;
 238 }
 239 
 240 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 241   LIR_Opr pointer = new_pointer_register();
 242   __ move(LIR_OprFact::intptrConst(counter), pointer);
 243   LIR_Address* addr = new LIR_Address(pointer, type);
 244   increment_counter(addr, step);
 245 }
 246 
 247 
 248 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 249   __ add((LIR_Opr)addr, LIR_OprFact::intConst(step), (LIR_Opr)addr);
 250 }
 251 
 252 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 253   __ cmp_mem_int(condition, base, disp, c, info);
 254 }
 255 
 256 
 257 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 258   __ cmp_reg_mem(condition, reg, new LIR_Address(base, disp, type), info);
 259 }
 260 
 261 
 262 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, jint c, LIR_Opr result, LIR_Opr tmp) {
 263   if (tmp-&gt;is_valid() &amp;&amp; c &gt; 0 &amp;&amp; c &lt; max_jint) {
 264     if (is_power_of_2(c + 1)) {
 265       __ move(left, tmp);
 266       __ shift_left(left, log2_jint(c + 1), left);
 267       __ sub(left, tmp, result);
 268       return true;
 269     } else if (is_power_of_2(c - 1)) {
 270       __ move(left, tmp);
 271       __ shift_left(left, log2_jint(c - 1), left);
 272       __ add(left, tmp, result);
 273       return true;
 274     }
 275   }
 276   return false;
 277 }
 278 
 279 
 280 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 281   BasicType type = item-&gt;type();
 282   __ store(item, new LIR_Address(FrameMap::rsp_opr, in_bytes(offset_from_sp), type));
 283 }
 284 
 285 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 286   LIR_Opr tmp1 = new_register(objectType);
 287   LIR_Opr tmp2 = new_register(objectType);
 288   LIR_Opr tmp3 = new_register(objectType);
 289   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 290 }
 291 
 292 //----------------------------------------------------------------------
 293 //             visitor functions
 294 //----------------------------------------------------------------------
 295 
 296 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 297   assert(x-&gt;is_pinned(),&quot;&quot;);
 298   LIRItem obj(x-&gt;obj(), this);
 299   obj.load_item();
 300 
 301   set_no_result(x);
 302 
 303   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop
 304   LIR_Opr lock = new_register(T_INT);
 305   // Need a scratch register for biased locking on x86
 306   LIR_Opr scratch = LIR_OprFact::illegalOpr;
 307   if (UseBiasedLocking || x-&gt;maybe_inlinetype()) {
 308     scratch = new_register(T_INT);
 309   }
 310 
 311   CodeEmitInfo* info_for_exception = NULL;
 312   if (x-&gt;needs_null_check()) {
 313     info_for_exception = state_for(x);
 314   }
 315 
 316   CodeStub* throw_imse_stub = x-&gt;maybe_inlinetype() ?
 317       new SimpleExceptionStub(Runtime1::throw_illegal_monitor_state_exception_id,
 318                               LIR_OprFact::illegalOpr, state_for(x))
 319     : NULL;
 320 
 321   // this CodeEmitInfo must not have the xhandlers because here the
 322   // object is already locked (xhandlers expect object to be unlocked)
 323   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 324   monitor_enter(obj.result(), lock, syncTempOpr(), scratch,
 325                 x-&gt;monitor_no(), info_for_exception, info, throw_imse_stub);
 326 }
 327 
 328 
 329 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 330   assert(x-&gt;is_pinned(),&quot;&quot;);
 331 
 332   LIRItem obj(x-&gt;obj(), this);
 333   obj.dont_load_item();
 334 
 335   LIR_Opr lock = new_register(T_INT);
 336   LIR_Opr obj_temp = new_register(T_INT);
 337   set_no_result(x);
 338   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 339 }
 340 
 341 
 342 // _ineg, _lneg, _fneg, _dneg
 343 void LIRGenerator::do_NegateOp(NegateOp* x) {
 344   LIRItem value(x-&gt;x(), this);
 345   value.set_destroys_register();
 346   value.load_item();
 347   LIR_Opr reg = rlock(x);
 348 
 349   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 350 #ifdef _LP64
 351   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
 352     if (x-&gt;type()-&gt;tag() == doubleTag) {
 353       tmp = new_register(T_DOUBLE);
 354       __ move(LIR_OprFact::doubleConst(-0.0), tmp);
 355     }
 356     else if (x-&gt;type()-&gt;tag() == floatTag) {
 357       tmp = new_register(T_FLOAT);
 358       __ move(LIR_OprFact::floatConst(-0.0), tmp);
 359     }
 360   }
 361 #endif
 362   __ negate(value.result(), reg, tmp);
 363 
 364   set_result(x, round_item(reg));
 365 }
 366 
 367 
 368 // for  _fadd, _fmul, _fsub, _fdiv, _frem
 369 //      _dadd, _dmul, _dsub, _ddiv, _drem
 370 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 371   LIRItem left(x-&gt;x(),  this);
 372   LIRItem right(x-&gt;y(), this);
 373   LIRItem* left_arg  = &amp;left;
 374   LIRItem* right_arg = &amp;right;
 375   assert(!left.is_stack() || !right.is_stack(), &quot;can&#39;t both be memory operands&quot;);
 376   bool must_load_both = (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem);
 377   if (left.is_register() || x-&gt;x()-&gt;type()-&gt;is_constant() || must_load_both) {
 378     left.load_item();
 379   } else {
 380     left.dont_load_item();
 381   }
 382 
 383 #ifndef _LP64
 384   // do not load right operand if it is a constant.  only 0 and 1 are
 385   // loaded because there are special instructions for loading them
 386   // without memory access (not needed for SSE2 instructions)
 387   bool must_load_right = false;
 388   if (right.is_constant()) {
 389     LIR_Const* c = right.result()-&gt;as_constant_ptr();
 390     assert(c != NULL, &quot;invalid constant&quot;);
 391     assert(c-&gt;type() == T_FLOAT || c-&gt;type() == T_DOUBLE, &quot;invalid type&quot;);
 392 
 393     if (c-&gt;type() == T_FLOAT) {
 394       must_load_right = UseSSE &lt; 1 &amp;&amp; (c-&gt;is_one_float() || c-&gt;is_zero_float());
 395     } else {
 396       must_load_right = UseSSE &lt; 2 &amp;&amp; (c-&gt;is_one_double() || c-&gt;is_zero_double());
 397     }
 398   }
 399 #endif // !LP64
 400 
 401   if (must_load_both) {
 402     // frem and drem destroy also right operand, so move it to a new register
 403     right.set_destroys_register();
 404     right.load_item();
 405   } else if (right.is_register()) {
 406     right.load_item();
 407 #ifndef _LP64
 408   } else if (must_load_right) {
 409     right.load_item();
 410 #endif // !LP64
 411   } else {
 412     right.dont_load_item();
 413   }
 414   LIR_Opr reg = rlock(x);
 415   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 416   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 417     tmp = new_register(T_DOUBLE);
 418   }
 419 
 420 #ifdef _LP64
 421   if (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem) {
 422     // frem and drem are implemented as a direct call into the runtime.
 423     LIRItem left(x-&gt;x(), this);
 424     LIRItem right(x-&gt;y(), this);
 425 
 426     BasicType bt = as_BasicType(x-&gt;type());
 427     BasicTypeList signature(2);
 428     signature.append(bt);
 429     signature.append(bt);
 430     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 431 
 432     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 433     left.load_item_force(cc-&gt;at(0));
 434     right.load_item_force(cc-&gt;at(1));
 435 
 436     address entry = NULL;
 437     switch (x-&gt;op()) {
 438       case Bytecodes::_frem:
 439         entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 440         break;
 441       case Bytecodes::_drem:
 442         entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 443         break;
 444       default:
 445         ShouldNotReachHere();
 446     }
 447 
 448     LIR_Opr result = rlock_result(x);
 449     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 450     __ move(result_reg, result);
 451   } else {
 452     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 453     set_result(x, round_item(reg));
 454   }
 455 #else
 456   if ((UseSSE &gt;= 1 &amp;&amp; x-&gt;op() == Bytecodes::_frem) || (UseSSE &gt;= 2 &amp;&amp; x-&gt;op() == Bytecodes::_drem)) {
 457     // special handling for frem and drem: no SSE instruction, so must use FPU with temporary fpu stack slots
 458     LIR_Opr fpu0, fpu1;
 459     if (x-&gt;op() == Bytecodes::_frem) {
 460       fpu0 = LIR_OprFact::single_fpu(0);
 461       fpu1 = LIR_OprFact::single_fpu(1);
 462     } else {
 463       fpu0 = LIR_OprFact::double_fpu(0);
 464       fpu1 = LIR_OprFact::double_fpu(1);
 465     }
 466     __ move(right.result(), fpu1); // order of left and right operand is important!
 467     __ move(left.result(), fpu0);
 468     __ rem (fpu0, fpu1, fpu0);
 469     __ move(fpu0, reg);
 470 
 471   } else {
 472     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 473   }
 474   set_result(x, round_item(reg));
 475 #endif // _LP64
 476 }
 477 
 478 
 479 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 480 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 481   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem ) {
 482     // long division is implemented as a direct call into the runtime
 483     LIRItem left(x-&gt;x(), this);
 484     LIRItem right(x-&gt;y(), this);
 485 
 486     // the check for division by zero destroys the right operand
 487     right.set_destroys_register();
 488 
 489     BasicTypeList signature(2);
 490     signature.append(T_LONG);
 491     signature.append(T_LONG);
 492     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 493 
 494     // check for division by zero (destroys registers of right operand!)
 495     CodeEmitInfo* info = state_for(x);
 496 
 497     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 498     left.load_item_force(cc-&gt;at(1));
 499     right.load_item();
 500 
 501     __ move(right.result(), cc-&gt;at(0));
 502 
 503     __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 504     __ branch(lir_cond_equal, new DivByZeroStub(info));
 505 
 506     address entry = NULL;
 507     switch (x-&gt;op()) {
 508     case Bytecodes::_lrem:
 509       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 510       break; // check if dividend is 0 is done elsewhere
 511     case Bytecodes::_ldiv:
 512       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 513       break; // check if dividend is 0 is done elsewhere
 514     default:
 515       ShouldNotReachHere();
 516     }
 517 
 518     LIR_Opr result = rlock_result(x);
 519     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 520     __ move(result_reg, result);
 521   } else if (x-&gt;op() == Bytecodes::_lmul) {
 522     // missing test if instr is commutative and if we should swap
 523     LIRItem left(x-&gt;x(), this);
 524     LIRItem right(x-&gt;y(), this);
 525 
 526     // right register is destroyed by the long mul, so it must be
 527     // copied to a new register.
 528     right.set_destroys_register();
 529 
 530     left.load_item();
 531     right.load_item();
 532 
 533     LIR_Opr reg = FrameMap::long0_opr;
 534     arithmetic_op_long(x-&gt;op(), reg, left.result(), right.result(), NULL);
 535     LIR_Opr result = rlock_result(x);
 536     __ move(reg, result);
 537   } else {
 538     // missing test if instr is commutative and if we should swap
 539     LIRItem left(x-&gt;x(), this);
 540     LIRItem right(x-&gt;y(), this);
 541 
 542     left.load_item();
 543     // don&#39;t load constants to save register
 544     right.load_nonconstant();
 545     rlock_result(x);
 546     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 547   }
 548 }
 549 
 550 
 551 
 552 // for: _iadd, _imul, _isub, _idiv, _irem
 553 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 554   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 555     // The requirements for division and modulo
 556     // input : rax,: dividend                         min_int
 557     //         reg: divisor   (may not be rax,/rdx)   -1
 558     //
 559     // output: rax,: quotient  (= rax, idiv reg)       min_int
 560     //         rdx: remainder (= rax, irem reg)       0
 561 
 562     // rax, and rdx will be destroyed
 563 
 564     // Note: does this invalidate the spec ???
 565     LIRItem right(x-&gt;y(), this);
 566     LIRItem left(x-&gt;x() , this);   // visit left second, so that the is_register test is valid
 567 
 568     // call state_for before load_item_force because state_for may
 569     // force the evaluation of other instructions that are needed for
 570     // correct debug info.  Otherwise the live range of the fix
 571     // register might be too long.
 572     CodeEmitInfo* info = state_for(x);
 573 
 574     left.load_item_force(divInOpr());
 575 
 576     right.load_item();
 577 
 578     LIR_Opr result = rlock_result(x);
 579     LIR_Opr result_reg;
 580     if (x-&gt;op() == Bytecodes::_idiv) {
 581       result_reg = divOutOpr();
 582     } else {
 583       result_reg = remOutOpr();
 584     }
 585 
 586     if (!ImplicitDiv0Checks) {
 587       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
 588       __ branch(lir_cond_equal, new DivByZeroStub(info));
 589       // Idiv/irem cannot trap (passing info would generate an assertion).
 590       info = NULL;
 591     }
 592     LIR_Opr tmp = FrameMap::rdx_opr; // idiv and irem use rdx in their implementation
 593     if (x-&gt;op() == Bytecodes::_irem) {
 594       __ irem(left.result(), right.result(), result_reg, tmp, info);
 595     } else if (x-&gt;op() == Bytecodes::_idiv) {
 596       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 597     } else {
 598       ShouldNotReachHere();
 599     }
 600 
 601     __ move(result_reg, result);
 602   } else {
 603     // missing test if instr is commutative and if we should swap
 604     LIRItem left(x-&gt;x(),  this);
 605     LIRItem right(x-&gt;y(), this);
 606     LIRItem* left_arg = &amp;left;
 607     LIRItem* right_arg = &amp;right;
 608     if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
 609       // swap them if left is real stack (or cached) and right is real register(not cached)
 610       left_arg = &amp;right;
 611       right_arg = &amp;left;
 612     }
 613 
 614     left_arg-&gt;load_item();
 615 
 616     // do not need to load right, as we can handle stack and constants
 617     if (x-&gt;op() == Bytecodes::_imul ) {
 618       // check if we can use shift instead
 619       bool use_constant = false;
 620       bool use_tmp = false;
 621       if (right_arg-&gt;is_constant()) {
 622         jint iconst = right_arg-&gt;get_jint_constant();
 623         if (iconst &gt; 0 &amp;&amp; iconst &lt; max_jint) {
 624           if (is_power_of_2(iconst)) {
 625             use_constant = true;
 626           } else if (is_power_of_2(iconst - 1) || is_power_of_2(iconst + 1)) {
 627             use_constant = true;
 628             use_tmp = true;
 629           }
 630         }
 631       }
 632       if (use_constant) {
 633         right_arg-&gt;dont_load_item();
 634       } else {
 635         right_arg-&gt;load_item();
 636       }
 637       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 638       if (use_tmp) {
 639         tmp = new_register(T_INT);
 640       }
 641       rlock_result(x);
 642 
 643       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 644     } else {
 645       right_arg-&gt;dont_load_item();
 646       rlock_result(x);
 647       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 648       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 649     }
 650   }
 651 }
 652 
 653 
 654 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 655   // when an operand with use count 1 is the left operand, then it is
 656   // likely that no move for 2-operand-LIR-form is necessary
 657   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 658     x-&gt;swap_operands();
 659   }
 660 
 661   ValueTag tag = x-&gt;type()-&gt;tag();
 662   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 663   switch (tag) {
 664     case floatTag:
 665     case doubleTag:  do_ArithmeticOp_FPU(x);  return;
 666     case longTag:    do_ArithmeticOp_Long(x); return;
 667     case intTag:     do_ArithmeticOp_Int(x);  return;
 668     default:         ShouldNotReachHere();    return;
 669   }
 670 }
 671 
 672 
 673 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 674 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 675   // count must always be in rcx
 676   LIRItem value(x-&gt;x(), this);
 677   LIRItem count(x-&gt;y(), this);
 678 
 679   ValueTag elemType = x-&gt;type()-&gt;tag();
 680   bool must_load_count = !count.is_constant() || elemType == longTag;
 681   if (must_load_count) {
 682     // count for long must be in register
 683     count.load_item_force(shiftCountOpr());
 684   } else {
 685     count.dont_load_item();
 686   }
 687   value.load_item();
 688   LIR_Opr reg = rlock_result(x);
 689 
 690   shift_op(x-&gt;op(), reg, value.result(), count.result(), LIR_OprFact::illegalOpr);
 691 }
 692 
 693 
 694 // _iand, _land, _ior, _lor, _ixor, _lxor
 695 void LIRGenerator::do_LogicOp(LogicOp* x) {
 696   // when an operand with use count 1 is the left operand, then it is
 697   // likely that no move for 2-operand-LIR-form is necessary
 698   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 699     x-&gt;swap_operands();
 700   }
 701 
 702   LIRItem left(x-&gt;x(), this);
 703   LIRItem right(x-&gt;y(), this);
 704 
 705   left.load_item();
 706   right.load_nonconstant();
 707   LIR_Opr reg = rlock_result(x);
 708 
 709   logic_op(x-&gt;op(), reg, left.result(), right.result());
 710 }
 711 
 712 
 713 
 714 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 715 void LIRGenerator::do_CompareOp(CompareOp* x) {
 716   LIRItem left(x-&gt;x(), this);
 717   LIRItem right(x-&gt;y(), this);
 718   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 719   if (tag == longTag) {
 720     left.set_destroys_register();
 721   }
 722   left.load_item();
 723   right.load_item();
 724   LIR_Opr reg = rlock_result(x);
 725 
 726   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 727     Bytecodes::Code code = x-&gt;op();
 728     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 729   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 730     __ lcmp2int(left.result(), right.result(), reg);
 731   } else {
 732     Unimplemented();
 733   }
 734 }
 735 
 736 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 737   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
 738   if (is_reference_type(type)) {
 739     cmp_value.load_item_force(FrameMap::rax_oop_opr);
 740     new_value.load_item();
 741     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 742   } else if (type == T_INT) {
 743     cmp_value.load_item_force(FrameMap::rax_opr);
 744     new_value.load_item();
 745     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 746   } else if (type == T_LONG) {
 747     cmp_value.load_item_force(FrameMap::long0_opr);
 748     new_value.load_item_force(FrameMap::long1_opr);
 749     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 750   } else {
 751     Unimplemented();
 752   }
 753   LIR_Opr result = new_register(T_INT);
 754   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 755            result, T_INT);
 756   return result;
 757 }
 758 
 759 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 760   bool is_oop = is_reference_type(type);
 761   LIR_Opr result = new_register(type);
 762   value.load_item();
 763   // Because we want a 2-arg form of xchg and xadd
 764   __ move(value.result(), result);
 765   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 766   __ xchg(addr, result, result, LIR_OprFact::illegalOpr);
 767   return result;
 768 }
 769 
 770 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 771   LIR_Opr result = new_register(type);
 772   value.load_item();
 773   // Because we want a 2-arg form of xchg and xadd
 774   __ move(value.result(), result);
 775   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 776   __ xadd(addr, result, result, LIR_OprFact::illegalOpr);
 777   return result;
 778 }
 779 
 780 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
 781   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
 782   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
 783   LIRItem value(x-&gt;argument_at(0), this);
 784   LIRItem value1(x-&gt;argument_at(1), this);
 785   LIRItem value2(x-&gt;argument_at(2), this);
 786 
 787   value2.set_destroys_register();
 788 
 789   value.load_item();
 790   value1.load_item();
 791   value2.load_item();
 792 
 793   LIR_Opr calc_input = value.result();
 794   LIR_Opr calc_input1 = value1.result();
 795   LIR_Opr calc_input2 = value2.result();
 796   LIR_Opr calc_result = rlock_result(x);
 797 
 798   switch (x-&gt;id()) {
 799   case vmIntrinsics::_fmaD:   __ fmad(calc_input, calc_input1, calc_input2, calc_result); break;
 800   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
 801   default:                    ShouldNotReachHere();
 802   }
 803 
 804 }
 805 
 806 
 807 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 808   assert(x-&gt;number_of_arguments() == 1 || (x-&gt;number_of_arguments() == 2 &amp;&amp; x-&gt;id() == vmIntrinsics::_dpow), &quot;wrong type&quot;);
 809 
 810   if (x-&gt;id() == vmIntrinsics::_dexp || x-&gt;id() == vmIntrinsics::_dlog ||
 811       x-&gt;id() == vmIntrinsics::_dpow || x-&gt;id() == vmIntrinsics::_dcos ||
 812       x-&gt;id() == vmIntrinsics::_dsin || x-&gt;id() == vmIntrinsics::_dtan ||
 813       x-&gt;id() == vmIntrinsics::_dlog10) {
 814     do_LibmIntrinsic(x);
 815     return;
 816   }
 817 
 818   LIRItem value(x-&gt;argument_at(0), this);
 819 
 820   bool use_fpu = false;
 821 #ifndef _LP64
 822   if (UseSSE &lt; 2) {
 823     value.set_destroys_register();
 824   }
 825 #endif // !LP64
 826   value.load_item();
 827 
 828   LIR_Opr calc_input = value.result();
 829   LIR_Opr calc_result = rlock_result(x);
 830 
 831   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 832 #ifdef _LP64
 833   if (UseAVX &gt; 2 &amp;&amp; (!VM_Version::supports_avx512vl()) &amp;&amp;
 834       (x-&gt;id() == vmIntrinsics::_dabs)) {
 835     tmp = new_register(T_DOUBLE);
 836     __ move(LIR_OprFact::doubleConst(-0.0), tmp);
 837   }
 838 #endif
 839 
 840   switch(x-&gt;id()) {
 841     case vmIntrinsics::_dabs:   __ abs  (calc_input, calc_result, tmp); break;
 842     case vmIntrinsics::_dsqrt:  __ sqrt (calc_input, calc_result, LIR_OprFact::illegalOpr); break;
 843     default:                    ShouldNotReachHere();
 844   }
 845 
 846   if (use_fpu) {
 847     __ move(calc_result, x-&gt;operand());
 848   }
 849 }
 850 
 851 void LIRGenerator::do_LibmIntrinsic(Intrinsic* x) {
 852   LIRItem value(x-&gt;argument_at(0), this);
 853   value.set_destroys_register();
 854 
 855   LIR_Opr calc_result = rlock_result(x);
 856   LIR_Opr result_reg = result_register_for(x-&gt;type());
 857 
 858   CallingConvention* cc = NULL;
 859 
 860   if (x-&gt;id() == vmIntrinsics::_dpow) {
 861     LIRItem value1(x-&gt;argument_at(1), this);
 862 
 863     value1.set_destroys_register();
 864 
 865     BasicTypeList signature(2);
 866     signature.append(T_DOUBLE);
 867     signature.append(T_DOUBLE);
 868     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 869     value.load_item_force(cc-&gt;at(0));
 870     value1.load_item_force(cc-&gt;at(1));
 871   } else {
 872     BasicTypeList signature(1);
 873     signature.append(T_DOUBLE);
 874     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 875     value.load_item_force(cc-&gt;at(0));
 876   }
 877 
 878 #ifndef _LP64
 879   LIR_Opr tmp = FrameMap::fpu0_double_opr;
 880   result_reg = tmp;
 881   switch(x-&gt;id()) {
 882     case vmIntrinsics::_dexp:
 883       if (StubRoutines::dexp() != NULL) {
 884         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 885       } else {
 886         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 887       }
 888       break;
 889     case vmIntrinsics::_dlog:
 890       if (StubRoutines::dlog() != NULL) {
 891         __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 892       } else {
 893         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 894       }
 895       break;
 896     case vmIntrinsics::_dlog10:
 897       if (StubRoutines::dlog10() != NULL) {
 898        __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 899       } else {
 900         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 901       }
 902       break;
 903     case vmIntrinsics::_dpow:
 904       if (StubRoutines::dpow() != NULL) {
 905         __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 906       } else {
 907         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 908       }
 909       break;
 910     case vmIntrinsics::_dsin:
 911       if (VM_Version::supports_sse2() &amp;&amp; StubRoutines::dsin() != NULL) {
 912         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 913       } else {
 914         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 915       }
 916       break;
 917     case vmIntrinsics::_dcos:
 918       if (VM_Version::supports_sse2() &amp;&amp; StubRoutines::dcos() != NULL) {
 919         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 920       } else {
 921         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 922       }
 923       break;
 924     case vmIntrinsics::_dtan:
 925       if (StubRoutines::dtan() != NULL) {
 926         __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 927       } else {
 928         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 929       }
 930       break;
 931     default:  ShouldNotReachHere();
 932   }
 933 #else
 934   switch (x-&gt;id()) {
 935     case vmIntrinsics::_dexp:
 936       if (StubRoutines::dexp() != NULL) {
 937         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 938       } else {
 939         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 940       }
 941       break;
 942     case vmIntrinsics::_dlog:
 943       if (StubRoutines::dlog() != NULL) {
 944       __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 945       } else {
 946         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 947       }
 948       break;
 949     case vmIntrinsics::_dlog10:
 950       if (StubRoutines::dlog10() != NULL) {
 951       __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 952       } else {
 953         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 954       }
 955       break;
 956     case vmIntrinsics::_dpow:
 957        if (StubRoutines::dpow() != NULL) {
 958       __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 959       } else {
 960         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 961       }
 962       break;
 963     case vmIntrinsics::_dsin:
 964       if (StubRoutines::dsin() != NULL) {
 965         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 966       } else {
 967         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 968       }
 969       break;
 970     case vmIntrinsics::_dcos:
 971       if (StubRoutines::dcos() != NULL) {
 972         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 973       } else {
 974         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 975       }
 976       break;
 977     case vmIntrinsics::_dtan:
 978        if (StubRoutines::dtan() != NULL) {
 979       __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 980       } else {
 981         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 982       }
 983       break;
 984     default:  ShouldNotReachHere();
 985   }
 986 #endif // _LP64
 987   __ move(result_reg, calc_result);
 988 }
 989 
 990 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 991   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 992 
 993   // Make all state_for calls early since they can emit code
 994   CodeEmitInfo* info = state_for(x, x-&gt;state());
 995 
 996   LIRItem src(x-&gt;argument_at(0), this);
 997   LIRItem src_pos(x-&gt;argument_at(1), this);
 998   LIRItem dst(x-&gt;argument_at(2), this);
 999   LIRItem dst_pos(x-&gt;argument_at(3), this);
1000   LIRItem length(x-&gt;argument_at(4), this);
1001 
1002   // operands for arraycopy must use fixed registers, otherwise
1003   // LinearScan will fail allocation (because arraycopy always needs a
1004   // call)
1005 
1006 #ifndef _LP64
1007   src.load_item_force     (FrameMap::rcx_oop_opr);
1008   src_pos.load_item_force (FrameMap::rdx_opr);
1009   dst.load_item_force     (FrameMap::rax_oop_opr);
1010   dst_pos.load_item_force (FrameMap::rbx_opr);
1011   length.load_item_force  (FrameMap::rdi_opr);
1012   LIR_Opr tmp =           (FrameMap::rsi_opr);
1013 #else
1014 
1015   // The java calling convention will give us enough registers
1016   // so that on the stub side the args will be perfect already.
1017   // On the other slow/special case side we call C and the arg
1018   // positions are not similar enough to pick one as the best.
1019   // Also because the java calling convention is a &quot;shifted&quot; version
1020   // of the C convention we can process the java args trivially into C
1021   // args without worry of overwriting during the xfer
1022 
1023   src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));
1024   src_pos.load_item_force (FrameMap::as_opr(j_rarg1));
1025   dst.load_item_force     (FrameMap::as_oop_opr(j_rarg2));
1026   dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));
1027   length.load_item_force  (FrameMap::as_opr(j_rarg4));
1028 
1029   LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);
1030 #endif // LP64
1031 
1032   set_no_result(x);
1033 
1034   int flags;
1035   ciArrayKlass* expected_type;
1036   arraycopy_helper(x, &amp;flags, &amp;expected_type);
1037 
1038   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(), tmp, expected_type, flags, info); // does add_safepoint
1039 }
1040 
1041 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
1042   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
1043   // Make all state_for calls early since they can emit code
1044   LIR_Opr result = rlock_result(x);
1045   int flags = 0;
1046   switch (x-&gt;id()) {
1047     case vmIntrinsics::_updateCRC32: {
1048       LIRItem crc(x-&gt;argument_at(0), this);
1049       LIRItem val(x-&gt;argument_at(1), this);
1050       // val is destroyed by update_crc32
1051       val.set_destroys_register();
1052       crc.load_item();
1053       val.load_item();
1054       __ update_crc32(crc.result(), val.result(), result);
1055       break;
1056     }
1057     case vmIntrinsics::_updateBytesCRC32:
1058     case vmIntrinsics::_updateByteBufferCRC32: {
1059       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
1060 
1061       LIRItem crc(x-&gt;argument_at(0), this);
1062       LIRItem buf(x-&gt;argument_at(1), this);
1063       LIRItem off(x-&gt;argument_at(2), this);
1064       LIRItem len(x-&gt;argument_at(3), this);
1065       buf.load_item();
1066       off.load_nonconstant();
1067 
1068       LIR_Opr index = off.result();
1069       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1070       if(off.result()-&gt;is_constant()) {
1071         index = LIR_OprFact::illegalOpr;
1072        offset += off.result()-&gt;as_jint();
1073       }
1074       LIR_Opr base_op = buf.result();
1075 
1076 #ifndef _LP64
1077       if (!is_updateBytes) { // long b raw address
1078          base_op = new_register(T_INT);
1079          __ convert(Bytecodes::_l2i, buf.result(), base_op);
1080       }
1081 #else
1082       if (index-&gt;is_valid()) {
1083         LIR_Opr tmp = new_register(T_LONG);
1084         __ convert(Bytecodes::_i2l, index, tmp);
1085         index = tmp;
1086       }
1087 #endif
1088 
1089       if (is_updateBytes) {
1090         base_op = access_resolve(IS_NOT_NULL | ACCESS_READ, base_op);
1091       }
1092 
1093       LIR_Address* a = new LIR_Address(base_op,
1094                                        index,
1095                                        offset,
1096                                        T_BYTE);
1097       BasicTypeList signature(3);
1098       signature.append(T_INT);
1099       signature.append(T_ADDRESS);
1100       signature.append(T_INT);
1101       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1102       const LIR_Opr result_reg = result_register_for(x-&gt;type());
1103 
1104       LIR_Opr addr = new_pointer_register();
1105       __ leal(LIR_OprFact::address(a), addr);
1106 
1107       crc.load_item_force(cc-&gt;at(0));
1108       __ move(addr, cc-&gt;at(1));
1109       len.load_item_force(cc-&gt;at(2));
1110 
1111       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc-&gt;args());
1112       __ move(result_reg, result);
1113 
1114       break;
1115     }
1116     default: {
1117       ShouldNotReachHere();
1118     }
1119   }
1120 }
1121 
1122 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
1123   Unimplemented();
1124 }
1125 
1126 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1127   assert(UseVectorizedMismatchIntrinsic, &quot;need AVX instruction support&quot;);
1128 
1129   // Make all state_for calls early since they can emit code
1130   LIR_Opr result = rlock_result(x);
1131 
1132   LIRItem a(x-&gt;argument_at(0), this); // Object
1133   LIRItem aOffset(x-&gt;argument_at(1), this); // long
1134   LIRItem b(x-&gt;argument_at(2), this); // Object
1135   LIRItem bOffset(x-&gt;argument_at(3), this); // long
1136   LIRItem length(x-&gt;argument_at(4), this); // int
1137   LIRItem log2ArrayIndexScale(x-&gt;argument_at(5), this); // int
1138 
1139   a.load_item();
1140   aOffset.load_nonconstant();
1141   b.load_item();
1142   bOffset.load_nonconstant();
1143 
1144   long constant_aOffset = 0;
1145   LIR_Opr result_aOffset = aOffset.result();
1146   if (result_aOffset-&gt;is_constant()) {
1147     constant_aOffset = result_aOffset-&gt;as_jlong();
1148     result_aOffset = LIR_OprFact::illegalOpr;
1149   }
1150   LIR_Opr result_a = access_resolve(ACCESS_READ, a.result());
1151 
1152   long constant_bOffset = 0;
1153   LIR_Opr result_bOffset = bOffset.result();
1154   if (result_bOffset-&gt;is_constant()) {
1155     constant_bOffset = result_bOffset-&gt;as_jlong();
1156     result_bOffset = LIR_OprFact::illegalOpr;
1157   }
1158   LIR_Opr result_b = access_resolve(ACCESS_READ, b.result());
1159 
1160 #ifndef _LP64
1161   result_a = new_register(T_INT);
1162   __ convert(Bytecodes::_l2i, a.result(), result_a);
1163   result_b = new_register(T_INT);
1164   __ convert(Bytecodes::_l2i, b.result(), result_b);
1165 #endif
1166 
1167 
1168   LIR_Address* addr_a = new LIR_Address(result_a,
1169                                         result_aOffset,
1170                                         constant_aOffset,
1171                                         T_BYTE);
1172 
1173   LIR_Address* addr_b = new LIR_Address(result_b,
1174                                         result_bOffset,
1175                                         constant_bOffset,
1176                                         T_BYTE);
1177 
1178   BasicTypeList signature(4);
1179   signature.append(T_ADDRESS);
1180   signature.append(T_ADDRESS);
1181   signature.append(T_INT);
1182   signature.append(T_INT);
1183   CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1184   const LIR_Opr result_reg = result_register_for(x-&gt;type());
1185 
1186   LIR_Opr ptr_addr_a = new_pointer_register();
1187   __ leal(LIR_OprFact::address(addr_a), ptr_addr_a);
1188 
1189   LIR_Opr ptr_addr_b = new_pointer_register();
1190   __ leal(LIR_OprFact::address(addr_b), ptr_addr_b);
1191 
1192   __ move(ptr_addr_a, cc-&gt;at(0));
1193   __ move(ptr_addr_b, cc-&gt;at(1));
1194   length.load_item_force(cc-&gt;at(2));
1195   log2ArrayIndexScale.load_item_force(cc-&gt;at(3));
1196 
1197   __ call_runtime_leaf(StubRoutines::vectorizedMismatch(), getThreadTemp(), result_reg, cc-&gt;args());
1198   __ move(result_reg, result);
1199 }
1200 
1201 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1202 // _i2b, _i2c, _i2s
1203 LIR_Opr fixed_register_for(BasicType type) {
1204   switch (type) {
1205     case T_FLOAT:  return FrameMap::fpu0_float_opr;
1206     case T_DOUBLE: return FrameMap::fpu0_double_opr;
1207     case T_INT:    return FrameMap::rax_opr;
1208     case T_LONG:   return FrameMap::long0_opr;
1209     default:       ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
1210   }
1211 }
1212 
1213 void LIRGenerator::do_Convert(Convert* x) {
1214 #ifdef _LP64
1215   LIRItem value(x-&gt;value(), this);
1216   value.load_item();
1217   LIR_Opr input = value.result();
1218   LIR_Opr result = rlock(x);
1219   __ convert(x-&gt;op(), input, result);
1220   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1221   set_result(x, result);
1222 #else
1223   // flags that vary for the different operations and different SSE-settings
1224   bool fixed_input = false, fixed_result = false, round_result = false, needs_stub = false;
1225 
1226   switch (x-&gt;op()) {
1227     case Bytecodes::_i2l: // fall through
1228     case Bytecodes::_l2i: // fall through
1229     case Bytecodes::_i2b: // fall through
1230     case Bytecodes::_i2c: // fall through
1231     case Bytecodes::_i2s: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1232 
1233     case Bytecodes::_f2d: fixed_input = UseSSE == 1; fixed_result = false;       round_result = false;      needs_stub = false; break;
1234     case Bytecodes::_d2f: fixed_input = false;       fixed_result = UseSSE == 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1235     case Bytecodes::_i2f: fixed_input = false;       fixed_result = false;       round_result = UseSSE &lt; 1; needs_stub = false; break;
1236     case Bytecodes::_i2d: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1237     case Bytecodes::_f2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1238     case Bytecodes::_d2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1239     case Bytecodes::_l2f: fixed_input = false;       fixed_result = UseSSE &gt;= 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1240     case Bytecodes::_l2d: fixed_input = false;       fixed_result = UseSSE &gt;= 2; round_result = UseSSE &lt; 2; needs_stub = false; break;
1241     case Bytecodes::_f2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1242     case Bytecodes::_d2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1243     default: ShouldNotReachHere();
1244   }
1245 
1246   LIRItem value(x-&gt;value(), this);
1247   value.load_item();
1248   LIR_Opr input = value.result();
1249   LIR_Opr result = rlock(x);
1250 
1251   // arguments of lir_convert
1252   LIR_Opr conv_input = input;
1253   LIR_Opr conv_result = result;
1254   ConversionStub* stub = NULL;
1255 
1256   if (fixed_input) {
1257     conv_input = fixed_register_for(input-&gt;type());
1258     __ move(input, conv_input);
1259   }
1260 
1261   assert(fixed_result == false || round_result == false, &quot;cannot set both&quot;);
1262   if (fixed_result) {
1263     conv_result = fixed_register_for(result-&gt;type());
1264   } else if (round_result) {
1265     result = new_register(result-&gt;type());
1266     set_vreg_flag(result, must_start_in_memory);
1267   }
1268 
1269   if (needs_stub) {
1270     stub = new ConversionStub(x-&gt;op(), conv_input, conv_result);
1271   }
1272 
1273   __ convert(x-&gt;op(), conv_input, conv_result, stub);
1274 
1275   if (result != conv_result) {
1276     __ move(conv_result, result);
1277   }
1278 
1279   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1280   set_result(x, result);
1281 #endif // _LP64
1282 }
1283 
1284 
1285 void LIRGenerator::do_NewInstance(NewInstance* x) {
1286   print_if_not_loaded(x);
1287 
1288   CodeEmitInfo* info = state_for(x, x-&gt;state());
1289   LIR_Opr reg = result_register_for(x-&gt;type());
1290   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1291                        FrameMap::rcx_oop_opr,
1292                        FrameMap::rdi_oop_opr,
1293                        FrameMap::rsi_oop_opr,
1294                        LIR_OprFact::illegalOpr,
1295                        FrameMap::rdx_metadata_opr, info);
1296   LIR_Opr result = rlock_result(x);
1297   __ move(reg, result);
1298 }
1299 
1300 void LIRGenerator::do_NewInlineTypeInstance(NewInlineTypeInstance* x) {
1301   // Mapping to do_NewInstance (same code) but use state_before for reexecution.
1302   CodeEmitInfo* info = state_for(x, x-&gt;state_before());
1303   x-&gt;set_to_object_type();
1304   LIR_Opr reg = result_register_for(x-&gt;type());
1305   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1306              FrameMap::rcx_oop_opr,
1307              FrameMap::rdi_oop_opr,
1308              FrameMap::rsi_oop_opr,
1309              LIR_OprFact::illegalOpr,
1310              FrameMap::rdx_metadata_opr, info);
1311   LIR_Opr result = rlock_result(x);
1312   __ move(reg, result);
1313 
1314 }
1315 
1316 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1317   CodeEmitInfo* info = state_for(x, x-&gt;state());
1318 
1319   LIRItem length(x-&gt;length(), this);
1320   length.load_item_force(FrameMap::rbx_opr);
1321 
1322   LIR_Opr reg = result_register_for(x-&gt;type());
1323   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1324   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1325   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1326   LIR_Opr tmp4 = reg;
1327   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1328   LIR_Opr len = length.result();
1329   BasicType elem_type = x-&gt;elt_type();
1330 
1331   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1332 
1333   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1334   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
1335 
1336   LIR_Opr result = rlock_result(x);
1337   __ move(reg, result);
1338 }
1339 
1340 
1341 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
1342   LIRItem length(x-&gt;length(), this);
1343   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1344   // and therefore provide the state before the parameters have been consumed
1345   CodeEmitInfo* patching_info = NULL;
1346   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1347     patching_info =  state_for(x, x-&gt;state_before());
1348   }
1349 
1350   CodeEmitInfo* info = state_for(x, x-&gt;state());
1351 
1352   const LIR_Opr reg = result_register_for(x-&gt;type());
1353   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1354   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1355   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1356   LIR_Opr tmp4 = reg;
1357   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1358 
1359   length.load_item_force(FrameMap::rbx_opr);
1360   LIR_Opr len = length.result();
1361 
1362   ciKlass* obj = (ciKlass*) x-&gt;exact_type();
1363   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x-&gt;is_never_null());
1364   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1365     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1366   }
1367   klass2reg_with_patching(klass_reg, obj, patching_info);
1368   if (x-&gt;is_never_null()) {
1369     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_INLINE_TYPE, klass_reg, slow_path);
1370   } else {
1371     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1372   }
1373 
1374   LIR_Opr result = rlock_result(x);
1375   __ move(reg, result);
1376 }
1377 
1378 
1379 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1380   Values* dims = x-&gt;dims();
1381   int i = dims-&gt;length();
1382   LIRItemList* items = new LIRItemList(i, i, NULL);
1383   while (i-- &gt; 0) {
1384     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1385     items-&gt;at_put(i, size);
1386   }
1387 
1388   // Evaluate state_for early since it may emit code.
1389   CodeEmitInfo* patching_info = NULL;
1390   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1391     patching_info = state_for(x, x-&gt;state_before());
1392 
1393     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
1394     // clone all handlers (NOTE: Usually this is handled transparently
1395     // by the CodeEmitInfo cloning logic in CodeStub constructors but
1396     // is done explicitly here because a stub isn&#39;t being used).
1397     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
1398   }
1399   CodeEmitInfo* info = state_for(x, x-&gt;state());
1400 
1401   i = dims-&gt;length();
1402   while (i-- &gt; 0) {
1403     LIRItem* size = items-&gt;at(i);
1404     size-&gt;load_nonconstant();
1405 
1406     store_stack_parameter(size-&gt;result(), in_ByteSize(i*4));
1407   }
1408 
1409   LIR_Opr klass_reg = FrameMap::rax_metadata_opr;
1410   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
1411 
1412   LIR_Opr rank = FrameMap::rbx_opr;
1413   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
1414   LIR_Opr varargs = FrameMap::rcx_opr;
1415   __ move(FrameMap::rsp_opr, varargs);
1416   LIR_OprList* args = new LIR_OprList(3);
1417   args-&gt;append(klass_reg);
1418   args-&gt;append(rank);
1419   args-&gt;append(varargs);
1420   LIR_Opr reg = result_register_for(x-&gt;type());
1421   __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),
1422                   LIR_OprFact::illegalOpr,
1423                   reg, args, info);
1424 
1425   LIR_Opr result = rlock_result(x);
1426   __ move(reg, result);
1427 }
1428 
1429 
1430 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1431   // nothing to do for now
1432 }
1433 
1434 
1435 void LIRGenerator::do_CheckCast(CheckCast* x) {
1436   LIRItem obj(x-&gt;obj(), this);
1437 
1438   CodeEmitInfo* patching_info = NULL;
1439   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1440     // must do this before locking the destination register as an oop register,
1441     // and before the obj is loaded (the latter is for deoptimization)
1442     patching_info = state_for(x, x-&gt;state_before());
1443   }
1444   obj.load_item();
1445 
1446   // info for exceptions
1447   CodeEmitInfo* info_for_exception =
1448       (x-&gt;needs_exception_state() ? state_for(x) :
1449                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1450 
1451   if (x-&gt;is_never_null()) {
1452     __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));
1453   }
1454 
1455   CodeStub* stub;
1456   if (x-&gt;is_incompatible_class_change_check()) {
1457     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1458     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1459   } else if (x-&gt;is_invokespecial_receiver_check()) {
1460     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1461     stub = new DeoptimizeStub(info_for_exception, Deoptimization::Reason_class_check, Deoptimization::Action_none);
1462   } else {
1463     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1464   }
1465   LIR_Opr reg = rlock_result(x);
1466   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1467   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1468     tmp3 = new_register(objectType);
1469   }
1470   __ checkcast(reg, obj.result(), x-&gt;klass(),
1471                new_register(objectType), new_register(objectType), tmp3,
1472                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
1473                x-&gt;profiled_method(), x-&gt;profiled_bci(), x-&gt;is_never_null());
1474 }
1475 
1476 
1477 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1478   LIRItem obj(x-&gt;obj(), this);
1479 
1480   // result and test object may not be in same register
1481   LIR_Opr reg = rlock_result(x);
1482   CodeEmitInfo* patching_info = NULL;
1483   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1484     // must do this before locking the destination register as an oop register
1485     patching_info = state_for(x, x-&gt;state_before());
1486   }
1487   obj.load_item();
1488   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1489   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1490     tmp3 = new_register(objectType);
1491   }
1492   __ instanceof(reg, obj.result(), x-&gt;klass(),
1493                 new_register(objectType), new_register(objectType), tmp3,
1494                 x-&gt;direct_compare(), patching_info, x-&gt;profiled_method(), x-&gt;profiled_bci());
1495 }
1496 
1497 
1498 void LIRGenerator::do_If(If* x) {
1499   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1500   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1501   bool is_safepoint = x-&gt;is_safepoint();
1502 
1503   If::Condition cond = x-&gt;cond();
1504 
1505   LIRItem xitem(x-&gt;x(), this);
1506   LIRItem yitem(x-&gt;y(), this);
1507   LIRItem* xin = &amp;xitem;
1508   LIRItem* yin = &amp;yitem;
1509 
1510   if (tag == longTag) {
1511     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1512     // mirror for other conditions
1513     if (cond == If::gtr || cond == If::leq) {
1514       cond = Instruction::mirror(cond);
1515       xin = &amp;yitem;
1516       yin = &amp;xitem;
1517     }
1518     xin-&gt;set_destroys_register();
1519   }
1520   xin-&gt;load_item();
1521   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp; (cond == If::eql || cond == If::neq)) {
1522     // inline long zero
1523     yin-&gt;dont_load_item();
1524   } else if (tag == longTag || tag == floatTag || tag == doubleTag || x-&gt;substitutability_check()) {
1525     // longs cannot handle constants at right side
1526     yin-&gt;load_item();
1527   } else {
1528     yin-&gt;dont_load_item();
1529   }
1530 
1531   LIR_Opr left = xin-&gt;result();
1532   LIR_Opr right = yin-&gt;result();
1533 
1534   set_no_result(x);
1535 
1536   // add safepoint before generating condition code so it can be recomputed
1537   if (x-&gt;is_safepoint()) {
1538     // increment backedge counter if needed
1539     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1540         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1541     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1542   }
1543 
1544   if (x-&gt;substitutability_check()) {
1545     substitutability_check(x, *xin, *yin);
1546   } else {
1547     __ cmp(lir_cond(cond), left, right);
1548   }
1549   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1550   profile_branch(x, cond);
1551   move_to_phi(x-&gt;state());
1552   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1553     __ branch(lir_cond(cond), x-&gt;tsux(), x-&gt;usux());
1554   } else {
1555     __ branch(lir_cond(cond), x-&gt;tsux());
1556   }
1557   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1558   __ jump(x-&gt;default_sux());
1559 }
1560 
1561 
1562 LIR_Opr LIRGenerator::getThreadPointer() {
1563 #ifdef _LP64
1564   return FrameMap::as_pointer_opr(r15_thread);
1565 #else
1566   LIR_Opr result = new_register(T_INT);
1567   __ get_thread(result);
1568   return result;
1569 #endif //
1570 }
1571 
1572 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1573   store_stack_parameter(LIR_OprFact::intConst(block-&gt;block_id()), in_ByteSize(0));
1574   LIR_OprList* args = new LIR_OprList();
1575   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1576   __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, args);
1577 }
1578 
1579 
1580 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1581                                         CodeEmitInfo* info) {
1582   if (address-&gt;type() == T_LONG) {
1583     address = new LIR_Address(address-&gt;base(),
1584                               address-&gt;index(), address-&gt;scale(),
1585                               address-&gt;disp(), T_DOUBLE);
1586     // Transfer the value atomically by using FP moves.  This means
1587     // the value has to be moved between CPU and FPU registers.  It
1588     // always has to be moved through spill slot since there&#39;s no
1589     // quick way to pack the value into an SSE register.
1590     LIR_Opr temp_double = new_register(T_DOUBLE);
1591     LIR_Opr spill = new_register(T_LONG);
1592     set_vreg_flag(spill, must_start_in_memory);
1593     __ move(value, spill);
1594     __ volatile_move(spill, temp_double, T_LONG);
1595     __ volatile_move(temp_double, LIR_OprFact::address(address), T_LONG, info);
1596   } else {
1597     __ store(value, address, info);
1598   }
1599 }
1600 
1601 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1602                                        CodeEmitInfo* info) {
1603   if (address-&gt;type() == T_LONG) {
1604     address = new LIR_Address(address-&gt;base(),
1605                               address-&gt;index(), address-&gt;scale(),
1606                               address-&gt;disp(), T_DOUBLE);
1607     // Transfer the value atomically by using FP moves.  This means
1608     // the value has to be moved between CPU and FPU registers.  In
1609     // SSE0 and SSE1 mode it has to be moved through spill slot but in
1610     // SSE2+ mode it can be moved directly.
1611     LIR_Opr temp_double = new_register(T_DOUBLE);
1612     __ volatile_move(LIR_OprFact::address(address), temp_double, T_LONG, info);
1613     __ volatile_move(temp_double, result, T_LONG);
1614 #ifndef _LP64
1615     if (UseSSE &lt; 2) {
1616       // no spill slot needed in SSE2 mode because xmm-&gt;cpu register move is possible
1617       set_vreg_flag(result, must_start_in_memory);
1618     }
1619 #endif // !LP64
1620   } else {
1621     __ load(address, result, info);
1622   }
1623 }
    </pre>
  </body>
</html>
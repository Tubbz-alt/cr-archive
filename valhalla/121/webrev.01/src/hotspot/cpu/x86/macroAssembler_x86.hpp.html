<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_MACROASSEMBLER_X86_HPP
  26 #define CPU_X86_MACROASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 #include &quot;runtime/rtmLocking.hpp&quot;
  31 #include &quot;runtime/signature.hpp&quot;
  32 
  33 class ciInlineKlass;
  34 
  35 // MacroAssembler extends Assembler by frequently used macros.
  36 //
  37 // Instructions for which a &#39;better&#39; code sequence exists depending
  38 // on arguments should also go in here.
  39 
  40 class MacroAssembler: public Assembler {
  41   friend class LIR_Assembler;
  42   friend class Runtime1;      // as_Address()
  43 
  44  public:
  45   // Support for VM calls
  46   //
  47   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  48   // may customize this version by overriding it for its purposes (e.g., to save/restore
  49   // additional registers when doing a VM call).
  50 
  51   virtual void call_VM_leaf_base(
  52     address entry_point,               // the entry point
  53     int     number_of_arguments        // the number of arguments to pop after the call
  54   );
  55 
  56  protected:
  57   // This is the base routine called by the different versions of call_VM. The interpreter
  58   // may customize this version by overriding it for its purposes (e.g., to save/restore
  59   // additional registers when doing a VM call).
  60   //
  61   // If no java_thread register is specified (noreg) than rdi will be used instead. call_VM_base
  62   // returns the register which contains the thread upon return. If a thread register has been
  63   // specified, the return value will correspond to that register. If no last_java_sp is specified
  64   // (noreg) than rsp will be used instead.
  65   virtual void call_VM_base(           // returns the register containing the thread upon return
  66     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  67     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  68     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  69     address  entry_point,              // the entry point
  70     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  71     bool     check_exceptions          // whether to check for pending exceptions after return
  72   );
  73 
  74   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  75 
  76   // helpers for FPU flag access
  77   // tmp is a temporary register, if none is available use noreg
  78   void save_rax   (Register tmp);
  79   void restore_rax(Register tmp);
  80 
  81  public:
  82   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
  83 
  84  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  85  // The implementation is only non-empty for the InterpreterMacroAssembler,
  86  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
  87  virtual void check_and_handle_popframe(Register java_thread);
  88  virtual void check_and_handle_earlyret(Register java_thread);
  89 
  90   Address as_Address(AddressLiteral adr);
  91   Address as_Address(ArrayAddress adr);
  92 
  93   // Support for NULL-checks
  94   //
  95   // Generates code that causes a NULL OS exception if the content of reg is NULL.
  96   // If the accessed location is M[reg + offset] and the offset is known, provide the
  97   // offset. No explicit code generation is needed if the offset is within a certain
  98   // range (0 &lt;= offset &lt;= page_size).
  99 
 100   void null_check(Register reg, int offset = -1);
 101   static bool needs_explicit_null_check(intptr_t offset);
 102   static bool uses_implicit_null_check(void* address);
 103 
 104   // valueKlass queries, kills temp_reg
 105   void test_klass_is_inline_type(Register klass, Register temp_reg, Label&amp; is_inline_type);
 106   void test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label&amp; is_empty_inline_type);
 107 
 108   // Get the default value oop for the given InlineKlass
 109   void get_default_value_oop(Register inline_klass, Register temp_reg, Register obj);
 110   // The empty value oop, for the given InlineKlass (&quot;empty&quot; as in no instance fields)
 111   // get_default_value_oop with extra assertion for empty inline klass
 112   void get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj);
 113 
 114   void test_field_is_inline_type(Register flags, Register temp_reg, Label&amp; is_inline);
 115   void test_field_is_not_inline_type(Register flags, Register temp_reg, Label&amp; not_inline);
 116   void test_field_is_inlined(Register flags, Register temp_reg, Label&amp; is_inlined);
 117 
 118   // Check oops array storage properties, i.e. flattened and/or null-free
 119   void test_flattened_array_oop(Register oop, Register temp_reg, Label&amp;is_flattened_array);
 120   void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&amp;is_non_flattened_array);
 121   void test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array);
 122   void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array);
 123 
 124   // Check array klass layout helper for flatten or null-free arrays...
 125   void test_flattened_array_layout(Register lh, Label&amp; is_flattened_array);
 126   void test_non_flattened_array_layout(Register lh, Label&amp; is_non_flattened_array);
 127   void test_null_free_array_layout(Register lh, Label&amp; is_null_free_array);
 128   void test_non_null_free_array_layout(Register lh, Label&amp; is_non_null_free_array);
 129 
 130   // Required platform-specific helpers for Label::patch_instructions.
 131   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 132   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 133     unsigned char op = branch[0];
 134     assert(op == 0xE8 /* call */ ||
 135         op == 0xE9 /* jmp */ ||
 136         op == 0xEB /* short jmp */ ||
 137         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 138         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 139         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 140         &quot;Invalid opcode at patch point&quot;);
 141 
 142     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 143       // short offset operators (jmp and jcc)
 144       char* disp = (char*) &amp;branch[1];
 145       int imm8 = target - (address) &amp;disp[1];
 146       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;,
 147                 file == NULL ? &quot;&lt;NULL&gt;&quot; : file, line);
 148       *disp = imm8;
 149     } else {
 150       int* disp = (int*) &amp;branch[(op == 0x0F || op == 0xC7)? 2: 1];
 151       int imm32 = target - (address) &amp;disp[1];
 152       *disp = imm32;
 153     }
 154   }
 155 
 156   // The following 4 methods return the offset of the appropriate move instruction
 157 
 158   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 159   int load_unsigned_byte(Register dst, Address src);
 160   int load_unsigned_short(Register dst, Address src);
 161 
 162   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 163   int load_signed_byte(Register dst, Address src);
 164   int load_signed_short(Register dst, Address src);
 165 
 166   // Support for sign-extension (hi:lo = extend_sign(lo))
 167   void extend_sign(Register hi, Register lo);
 168 
 169   // Load and store values by size and signed-ness
 170   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 171   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 172 
 173   // Support for inc/dec with optimal instruction selection depending on value
 174 
 175   void increment(Register reg, int value = 1) { LP64_ONLY(incrementq(reg, value)) NOT_LP64(incrementl(reg, value)) ; }
 176   void decrement(Register reg, int value = 1) { LP64_ONLY(decrementq(reg, value)) NOT_LP64(decrementl(reg, value)) ; }
 177 
 178   void decrementl(Address dst, int value = 1);
 179   void decrementl(Register reg, int value = 1);
 180 
 181   void decrementq(Register reg, int value = 1);
 182   void decrementq(Address dst, int value = 1);
 183 
 184   void incrementl(Address dst, int value = 1);
 185   void incrementl(Register reg, int value = 1);
 186 
 187   void incrementq(Register reg, int value = 1);
 188   void incrementq(Address dst, int value = 1);
 189 
 190   // Support optimal SSE move instructions.
 191   void movflt(XMMRegister dst, XMMRegister src) {
 192     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 193     if (UseXmmRegToRegMoveAll) { movaps(dst, src); return; }
 194     else                       { movss (dst, src); return; }
 195   }
 196   void movflt(XMMRegister dst, Address src) { movss(dst, src); }
 197   void movflt(XMMRegister dst, AddressLiteral src);
 198   void movflt(Address dst, XMMRegister src) { movss(dst, src); }
 199 
 200   void movdbl(XMMRegister dst, XMMRegister src) {
 201     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 202     if (UseXmmRegToRegMoveAll) { movapd(dst, src); return; }
 203     else                       { movsd (dst, src); return; }
 204   }
 205 
 206   void movdbl(XMMRegister dst, AddressLiteral src);
 207 
 208   void movdbl(XMMRegister dst, Address src) {
 209     if (UseXmmLoadAndClearUpper) { movsd (dst, src); return; }
 210     else                         { movlpd(dst, src); return; }
 211   }
 212   void movdbl(Address dst, XMMRegister src) { movsd(dst, src); }
 213 
 214   void incrementl(AddressLiteral dst);
 215   void incrementl(ArrayAddress dst);
 216 
 217   void incrementq(AddressLiteral dst);
 218 
 219   // Alignment
 220   void align(int modulus);
 221   void align(int modulus, int target);
 222 
 223   // A 5 byte nop that is safe for patching (see patch_verified_entry)
 224   void fat_nop();
 225 
 226   // Stack frame creation/removal
 227   void enter();
 228   void leave();
 229 
 230   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 231   // The pointer will be loaded into the thread register.
 232   void get_thread(Register thread);
 233 
 234 
 235   // Support for VM calls
 236   //
 237   // It is imperative that all calls into the VM are handled via the call_VM macros.
 238   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 239   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 240 
 241 
 242   void call_VM(Register oop_result,
 243                address entry_point,
 244                bool check_exceptions = true);
 245   void call_VM(Register oop_result,
 246                address entry_point,
 247                Register arg_1,
 248                bool check_exceptions = true);
 249   void call_VM(Register oop_result,
 250                address entry_point,
 251                Register arg_1, Register arg_2,
 252                bool check_exceptions = true);
 253   void call_VM(Register oop_result,
 254                address entry_point,
 255                Register arg_1, Register arg_2, Register arg_3,
 256                bool check_exceptions = true);
 257 
 258   // Overloadings with last_Java_sp
 259   void call_VM(Register oop_result,
 260                Register last_java_sp,
 261                address entry_point,
 262                int number_of_arguments = 0,
 263                bool check_exceptions = true);
 264   void call_VM(Register oop_result,
 265                Register last_java_sp,
 266                address entry_point,
 267                Register arg_1, bool
 268                check_exceptions = true);
 269   void call_VM(Register oop_result,
 270                Register last_java_sp,
 271                address entry_point,
 272                Register arg_1, Register arg_2,
 273                bool check_exceptions = true);
 274   void call_VM(Register oop_result,
 275                Register last_java_sp,
 276                address entry_point,
 277                Register arg_1, Register arg_2, Register arg_3,
 278                bool check_exceptions = true);
 279 
 280   void get_vm_result  (Register oop_result, Register thread);
 281   void get_vm_result_2(Register metadata_result, Register thread);
 282 
 283   // These always tightly bind to MacroAssembler::call_VM_base
 284   // bypassing the virtual implementation
 285   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 286   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 287   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 288   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 289   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 290 
 291   void call_VM_leaf0(address entry_point);
 292   void call_VM_leaf(address entry_point,
 293                     int number_of_arguments = 0);
 294   void call_VM_leaf(address entry_point,
 295                     Register arg_1);
 296   void call_VM_leaf(address entry_point,
 297                     Register arg_1, Register arg_2);
 298   void call_VM_leaf(address entry_point,
 299                     Register arg_1, Register arg_2, Register arg_3);
 300 
 301   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 302   // bypassing the virtual implementation
 303   void super_call_VM_leaf(address entry_point);
 304   void super_call_VM_leaf(address entry_point, Register arg_1);
 305   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 306   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 307   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 308 
 309   // last Java Frame (fills frame anchor)
 310   void set_last_Java_frame(Register thread,
 311                            Register last_java_sp,
 312                            Register last_java_fp,
 313                            address last_java_pc);
 314 
 315   // thread in the default location (r15_thread on 64bit)
 316   void set_last_Java_frame(Register last_java_sp,
 317                            Register last_java_fp,
 318                            address last_java_pc);
 319 
 320   void reset_last_Java_frame(Register thread, bool clear_fp);
 321 
 322   // thread in the default location (r15_thread on 64bit)
 323   void reset_last_Java_frame(bool clear_fp);
 324 
 325   // jobjects
 326   void clear_jweak_tag(Register possibly_jweak);
 327   void resolve_jobject(Register value, Register thread, Register tmp);
 328 
 329   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 330   void c2bool(Register x);
 331 
 332   // C++ bool manipulation
 333 
 334   void movbool(Register dst, Address src);
 335   void movbool(Address dst, bool boolconst);
 336   void movbool(Address dst, Register src);
 337   void testbool(Register dst);
 338 
 339   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 340   void resolve_weak_handle(Register result, Register tmp);
 341   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 342   void load_method_holder_cld(Register rresult, Register rmethod);
 343 
 344   void load_method_holder(Register holder, Register method);
 345 
 346   // oop manipulations
 347   void load_metadata(Register dst, Register src);
 348   void load_klass(Register dst, Register src, Register tmp);
 349   void store_klass(Register dst, Register src, Register tmp);
 350 
 351   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 352                       Register tmp1, Register thread_tmp);
 353   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 354                        Register tmp1, Register tmp2, Register tmp3 = noreg);
 355 
 356   void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register inline_klass);
 357 
 358   // inline type data payload offsets...
 359   void first_field_offset(Register inline_klass, Register offset);
 360   void data_for_oop(Register oop, Register data, Register inline_klass);
 361   // get data payload ptr a flat value array at index, kills rcx and index
 362   void data_for_value_array_index(Register array, Register array_klass,
 363                                   Register index, Register data);
 364 
 365 
 366   // Resolves obj access. Result is placed in the same register.
 367   // All other registers are preserved.
 368   void resolve(DecoratorSet decorators, Register obj);
 369 
 370   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 371                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 372   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 373                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 374   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 375                       Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);
 376 
 377   // Used for storing NULL. All other oop constants should be
 378   // stored using routines that take a jobject.
 379   void store_heap_oop_null(Address dst);
 380 
 381   void load_prototype_header(Register dst, Register src, Register tmp);
 382 
 383 #ifdef _LP64
 384   void store_klass_gap(Register dst, Register src);
 385 
 386   // This dummy is to prevent a call to store_heap_oop from
 387   // converting a zero (like NULL) into a Register by giving
 388   // the compiler two choices it can&#39;t resolve
 389 
 390   void store_heap_oop(Address dst, void* dummy);
 391 
 392   void encode_heap_oop(Register r);
 393   void decode_heap_oop(Register r);
 394   void encode_heap_oop_not_null(Register r);
 395   void decode_heap_oop_not_null(Register r);
 396   void encode_heap_oop_not_null(Register dst, Register src);
 397   void decode_heap_oop_not_null(Register dst, Register src);
 398 
 399   void set_narrow_oop(Register dst, jobject obj);
 400   void set_narrow_oop(Address dst, jobject obj);
 401   void cmp_narrow_oop(Register dst, jobject obj);
 402   void cmp_narrow_oop(Address dst, jobject obj);
 403 
 404   void encode_klass_not_null(Register r, Register tmp);
 405   void decode_klass_not_null(Register r, Register tmp);
 406   void encode_and_move_klass_not_null(Register dst, Register src);
 407   void decode_and_move_klass_not_null(Register dst, Register src);
 408   void set_narrow_klass(Register dst, Klass* k);
 409   void set_narrow_klass(Address dst, Klass* k);
 410   void cmp_narrow_klass(Register dst, Klass* k);
 411   void cmp_narrow_klass(Address dst, Klass* k);
 412 
 413   // if heap base register is used - reinit it with the correct value
 414   void reinit_heapbase();
 415 
 416   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 417 
 418 #endif // _LP64
 419 
 420   // Int division/remainder for Java
 421   // (as idivl, but checks for special case as described in JVM spec.)
 422   // returns idivl instruction offset for implicit exception handling
 423   int corrected_idivl(Register reg);
 424 
 425   // Long division/remainder for Java
 426   // (as idivq, but checks for special case as described in JVM spec.)
 427   // returns idivq instruction offset for implicit exception handling
 428   int corrected_idivq(Register reg);
 429 
 430   void int3();
 431 
 432   // Long operation macros for a 32bit cpu
 433   // Long negation for Java
 434   void lneg(Register hi, Register lo);
 435 
 436   // Long multiplication for Java
 437   // (destroys contents of eax, ebx, ecx and edx)
 438   void lmul(int x_rsp_offset, int y_rsp_offset); // rdx:rax = x * y
 439 
 440   // Long shifts for Java
 441   // (semantics as described in JVM spec.)
 442   void lshl(Register hi, Register lo);                               // hi:lo &lt;&lt; (rcx &amp; 0x3f)
 443   void lshr(Register hi, Register lo, bool sign_extension = false);  // hi:lo &gt;&gt; (rcx &amp; 0x3f)
 444 
 445   // Long compare for Java
 446   // (semantics as described in JVM spec.)
 447   void lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo); // x_hi = lcmp(x, y)
 448 
 449 
 450   // misc
 451 
 452   // Sign extension
 453   void sign_extend_short(Register reg);
 454   void sign_extend_byte(Register reg);
 455 
 456   // Division by power of 2, rounding towards 0
 457   void division_with_shift(Register reg, int shift_value);
 458 
 459 #ifndef _LP64
 460   // Compares the top-most stack entries on the FPU stack and sets the eflags as follows:
 461   //
 462   // CF (corresponds to C0) if x &lt; y
 463   // PF (corresponds to C2) if unordered
 464   // ZF (corresponds to C3) if x = y
 465   //
 466   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 467   // tmp is a temporary register, if none is available use noreg (only matters for non-P6 code)
 468   void fcmp(Register tmp);
 469   // Variant of the above which allows y to be further down the stack
 470   // and which only pops x and y if specified. If pop_right is
 471   // specified then pop_left must also be specified.
 472   void fcmp(Register tmp, int index, bool pop_left, bool pop_right);
 473 
 474   // Floating-point comparison for Java
 475   // Compares the top-most stack entries on the FPU stack and stores the result in dst.
 476   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 477   // (semantics as described in JVM spec.)
 478   void fcmp2int(Register dst, bool unordered_is_less);
 479   // Variant of the above which allows y to be further down the stack
 480   // and which only pops x and y if specified. If pop_right is
 481   // specified then pop_left must also be specified.
 482   void fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right);
 483 
 484   // Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)
 485   // tmp is a temporary register, if none is available use noreg
 486   void fremr(Register tmp);
 487 
 488   // only if +VerifyFPU
 489   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 490 #endif // !LP64
 491 
 492   // dst = c = a * b + c
 493   void fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 494   void fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 495 
 496   void vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 497   void vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 498   void vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 499   void vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 500 
 501 
 502   // same as fcmp2int, but using SSE2
 503   void cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 504   void cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 505 
 506   // branch to L if FPU flag C2 is set/not set
 507   // tmp is a temporary register, if none is available use noreg
 508   void jC2 (Register tmp, Label&amp; L);
 509   void jnC2(Register tmp, Label&amp; L);
 510 
 511   // Load float value from &#39;address&#39;. If UseSSE &gt;= 1, the value is loaded into
 512   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 513   void load_float(Address src);
 514 
 515   // Store float value to &#39;address&#39;. If UseSSE &gt;= 1, the value is stored
 516   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 517   void store_float(Address dst);
 518 
 519   // Load double value from &#39;address&#39;. If UseSSE &gt;= 2, the value is loaded into
 520   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 521   void load_double(Address src);
 522 
 523   // Store double value to &#39;address&#39;. If UseSSE &gt;= 2, the value is stored
 524   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 525   void store_double(Address dst);
 526 
 527 #ifndef _LP64
 528   // Pop ST (ffree &amp; fincstp combined)
 529   void fpop();
 530 
 531   void empty_FPU_stack();
 532 #endif // !_LP64
 533 
 534   void push_IU_state();
 535   void pop_IU_state();
 536 
 537   void push_FPU_state();
 538   void pop_FPU_state();
 539 
 540   void push_CPU_state();
 541   void pop_CPU_state();
 542 
 543   // Round up to a power of two
 544   void round_to(Register reg, int modulus);
 545 
 546   // Callee saved registers handling
 547   void push_callee_saved_registers();
 548   void pop_callee_saved_registers();
 549 
 550   // allocation
 551 
 552   // Object / value buffer allocation...
 553   // Allocate instance of klass, assumes klass initialized by caller
 554   // new_obj prefers to be rax
 555   // Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)
 556   void allocate_instance(Register klass, Register new_obj,
 557                          Register t1, Register t2,
 558                          bool clear_fields, Label&amp; alloc_failed);
 559 
 560   void eden_allocate(
 561     Register thread,                   // Current thread
 562     Register obj,                      // result: pointer to object after successful allocation
 563     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 564     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 565     Register t1,                       // temp register
 566     Label&amp;   slow_case                 // continuation point if fast allocation fails
 567   );
 568   void tlab_allocate(
 569     Register thread,                   // Current thread
 570     Register obj,                      // result: pointer to object after successful allocation
 571     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 572     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 573     Register t1,                       // temp register
 574     Register t2,                       // temp register
 575     Label&amp;   slow_case                 // continuation point if fast allocation fails
 576   );
 577   void zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp);
 578 
 579   // For field &quot;index&quot; within &quot;klass&quot;, return inline_klass ...
 580   void get_inline_type_field_klass(Register klass, Register index, Register inline_klass);
 581 
 582   // interface method calling
 583   void lookup_interface_method(Register recv_klass,
 584                                Register intf_klass,
 585                                RegisterOrConstant itable_index,
 586                                Register method_result,
 587                                Register scan_temp,
 588                                Label&amp; no_such_interface,
 589                                bool return_method = true);
 590 
 591   // virtual method calling
 592   void lookup_virtual_method(Register recv_klass,
 593                              RegisterOrConstant vtable_index,
 594                              Register method_result);
 595 
 596   // Test sub_klass against super_klass, with fast and slow paths.
 597 
 598   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 599   // One of the three labels can be NULL, meaning take the fall-through.
 600   // If super_check_offset is -1, the value is loaded up from super_klass.
 601   // No registers are killed, except temp_reg.
 602   void check_klass_subtype_fast_path(Register sub_klass,
 603                                      Register super_klass,
 604                                      Register temp_reg,
 605                                      Label* L_success,
 606                                      Label* L_failure,
 607                                      Label* L_slow_path,
 608                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 609 
 610   // The rest of the type check; must be wired to a corresponding fast path.
 611   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 612   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 613   // Updates the sub&#39;s secondary super cache as necessary.
 614   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 615   void check_klass_subtype_slow_path(Register sub_klass,
 616                                      Register super_klass,
 617                                      Register temp_reg,
 618                                      Register temp2_reg,
 619                                      Label* L_success,
 620                                      Label* L_failure,
 621                                      bool set_cond_codes = false);
 622 
 623   // Simplified, combined version, good for typical uses.
 624   // Falls through on failure.
 625   void check_klass_subtype(Register sub_klass,
 626                            Register super_klass,
 627                            Register temp_reg,
 628                            Label&amp; L_success);
 629 
 630   void clinit_barrier(Register klass,
 631                       Register thread,
 632                       Label* L_fast_path = NULL,
 633                       Label* L_slow_path = NULL);
 634 
 635   // method handles (JSR 292)
 636   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 637 
 638   //----
 639   void set_word_if_not_zero(Register reg); // sets reg to 1 if not zero, otherwise 0
 640 
 641   // Debugging
 642 
 643   // only if +VerifyOops
 644   void _verify_oop(Register reg, const char* s, const char* file, int line);
 645   void _verify_oop_addr(Address addr, const char* s, const char* file, int line);
 646 
 647   // TODO: verify method and klass metadata (compare against vptr?)
 648   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 649   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 650 
 651 #define verify_oop(reg) _verify_oop(reg, &quot;broken oop &quot; #reg, __FILE__, __LINE__)
 652 #define verify_oop_msg(reg, msg) _verify_oop(reg, &quot;broken oop &quot; #reg &quot;, &quot; #msg, __FILE__, __LINE__)
 653 #define verify_oop_addr(addr) _verify_oop_addr(addr, &quot;broken oop addr &quot; #addr, __FILE__, __LINE__)
 654 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 655 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 656 
 657   // Verify or restore cpu control state after JNI call
 658   void restore_cpu_control_state_after_jni();
 659 
 660   // prints msg, dumps registers and stops execution
 661   void stop(const char* msg);
 662 
 663   // prints msg and continues
 664   void warn(const char* msg);
 665 
 666   // dumps registers and other state
 667   void print_state();
 668 
 669   static void debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg);
 670   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 671   static void print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip);
 672   static void print_state64(int64_t pc, int64_t regs[]);
 673 
 674   void os_breakpoint();
 675 
 676   void untested()                                { stop(&quot;untested&quot;); }
 677 
 678   void unimplemented(const char* what = &quot;&quot;);
 679 
 680   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 681 
 682   void print_CPU_state();
 683 
 684   // Stack overflow checking
 685   void bang_stack_with_offset(int offset) {
 686     // stack grows down, caller passes positive offset
 687     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 688     movl(Address(rsp, (-offset)), rax);
 689   }
 690 
 691   // Writes to stack successive pages until offset reached to check for
 692   // stack overflow + shadow pages.  Also, clobbers tmp
 693   void bang_stack_size(Register size, Register tmp);
 694 
 695   // Check for reserved stack access in method being exited (for JIT)
 696   void reserved_stack_check();
 697 
 698   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
 699                                                 Register tmp,
 700                                                 int offset);
 701 
 702   // If thread_reg is != noreg the code assumes the register passed contains
 703   // the thread (required on 64 bit).
 704   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 705 
 706   void verify_tlab();
 707 
 708   // Biased locking support
 709   // lock_reg and obj_reg must be loaded up with the appropriate values.
 710   // swap_reg must be rax, and is killed.
 711   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 712   // be killed; if not supplied, push/pop will be used internally to
 713   // allocate a temporary (inefficient, avoid if possible).
 714   // Optional slow case is for implementations (interpreter and C1) which branch to
 715   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 716   // Returns offset of first potentially-faulting instruction for null
 717   // check info (currently consumed only by C1). If
 718   // swap_reg_contains_mark is true then returns -1 as it is assumed
 719   // the calling code has already passed any potential faults.
 720   int biased_locking_enter(Register lock_reg, Register obj_reg,
 721                            Register swap_reg, Register tmp_reg,
 722                            Register tmp_reg2, bool swap_reg_contains_mark,
 723                            Label&amp; done, Label* slow_case = NULL,
 724                            BiasedLockingCounters* counters = NULL);
 725   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 726 
 727   Condition negate_condition(Condition cond);
 728 
 729   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 730   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 731   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 732   // here in MacroAssembler. The major exception to this rule is call
 733 
 734   // Arithmetics
 735 
 736 
 737   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 738   void addptr(Address dst, Register src);
 739 
 740   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 741   void addptr(Register dst, int32_t src);
 742   void addptr(Register dst, Register src);
 743   void addptr(Register dst, RegisterOrConstant src) {
 744     if (src.is_constant()) addptr(dst, (int) src.as_constant());
 745     else                   addptr(dst,       src.as_register());
 746   }
 747 
 748   void andptr(Register dst, int32_t src);
 749   void andptr(Register src1, Register src2) { LP64_ONLY(andq(src1, src2)) NOT_LP64(andl(src1, src2)) ; }
 750 
 751   void cmp8(AddressLiteral src1, int imm);
 752 
 753   // renamed to drag out the casting of address to int32_t/intptr_t
 754   void cmp32(Register src1, int32_t imm);
 755 
 756   void cmp32(AddressLiteral src1, int32_t imm);
 757   // compare reg - mem, or reg - &amp;mem
 758   void cmp32(Register src1, AddressLiteral src2);
 759 
 760   void cmp32(Register src1, Address src2);
 761 
 762 #ifndef _LP64
 763   void cmpklass(Address dst, Metadata* obj);
 764   void cmpklass(Register dst, Metadata* obj);
 765   void cmpoop(Address dst, jobject obj);
 766   void cmpoop_raw(Address dst, jobject obj);
 767 #endif // _LP64
 768 
 769   void cmpoop(Register src1, Register src2);
 770   void cmpoop(Register src1, Address src2);
 771   void cmpoop(Register dst, jobject obj);
 772   void cmpoop_raw(Register dst, jobject obj);
 773 
 774   // NOTE src2 must be the lval. This is NOT an mem-mem compare
 775   void cmpptr(Address src1, AddressLiteral src2);
 776 
 777   void cmpptr(Register src1, AddressLiteral src2);
 778 
 779   void cmpptr(Register src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 780   void cmpptr(Register src1, Address src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 781   // void cmpptr(Address src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 782 
 783   void cmpptr(Register src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 784   void cmpptr(Address src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 785 
 786   // cmp64 to avoild hiding cmpq
 787   void cmp64(Register src1, AddressLiteral src);
 788 
 789   void cmpxchgptr(Register reg, Address adr);
 790 
 791   void locked_cmpxchgptr(Register reg, AddressLiteral adr);
 792 
 793 
 794   void imulptr(Register dst, Register src) { LP64_ONLY(imulq(dst, src)) NOT_LP64(imull(dst, src)); }
 795   void imulptr(Register dst, Register src, int imm32) { LP64_ONLY(imulq(dst, src, imm32)) NOT_LP64(imull(dst, src, imm32)); }
 796 
 797 
 798   void negptr(Register dst) { LP64_ONLY(negq(dst)) NOT_LP64(negl(dst)); }
 799 
 800   void notptr(Register dst) { LP64_ONLY(notq(dst)) NOT_LP64(notl(dst)); }
 801 
 802   void shlptr(Register dst, int32_t shift);
 803   void shlptr(Register dst) { LP64_ONLY(shlq(dst)) NOT_LP64(shll(dst)); }
 804 
 805   void shrptr(Register dst, int32_t shift);
 806   void shrptr(Register dst) { LP64_ONLY(shrq(dst)) NOT_LP64(shrl(dst)); }
 807 
 808   void sarptr(Register dst) { LP64_ONLY(sarq(dst)) NOT_LP64(sarl(dst)); }
 809   void sarptr(Register dst, int32_t src) { LP64_ONLY(sarq(dst, src)) NOT_LP64(sarl(dst, src)); }
 810 
 811   void subptr(Address dst, int32_t src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 812 
 813   void subptr(Register dst, Address src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 814   void subptr(Register dst, int32_t src);
 815   // Force generation of a 4 byte immediate value even if it fits into 8bit
 816   void subptr_imm32(Register dst, int32_t src);
 817   void subptr(Register dst, Register src);
 818   void subptr(Register dst, RegisterOrConstant src) {
 819     if (src.is_constant()) subptr(dst, (int) src.as_constant());
 820     else                   subptr(dst,       src.as_register());
 821   }
 822 
 823   void sbbptr(Address dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 824   void sbbptr(Register dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 825 
 826   void xchgptr(Register src1, Register src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 827   void xchgptr(Register src1, Address src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 828 
 829   void xaddptr(Address src1, Register src2) { LP64_ONLY(xaddq(src1, src2)) NOT_LP64(xaddl(src1, src2)) ; }
 830 
 831 
 832 
 833   // Helper functions for statistics gathering.
 834   // Conditionally (atomically, on MPs) increments passed counter address, preserving condition codes.
 835   void cond_inc32(Condition cond, AddressLiteral counter_addr);
 836   // Unconditional atomic increment.
 837   void atomic_incl(Address counter_addr);
 838   void atomic_incl(AddressLiteral counter_addr, Register scr = rscratch1);
 839 #ifdef _LP64
 840   void atomic_incq(Address counter_addr);
 841   void atomic_incq(AddressLiteral counter_addr, Register scr = rscratch1);
 842 #endif
 843   void atomic_incptr(AddressLiteral counter_addr, Register scr = rscratch1) { LP64_ONLY(atomic_incq(counter_addr, scr)) NOT_LP64(atomic_incl(counter_addr, scr)) ; }
 844   void atomic_incptr(Address counter_addr) { LP64_ONLY(atomic_incq(counter_addr)) NOT_LP64(atomic_incl(counter_addr)) ; }
 845 
 846   void lea(Register dst, AddressLiteral adr);
 847   void lea(Address dst, AddressLiteral adr);
 848   void lea(Register dst, Address adr) { Assembler::lea(dst, adr); }
 849 
 850   void leal32(Register dst, Address src) { leal(dst, src); }
 851 
 852   // Import other testl() methods from the parent class or else
 853   // they will be hidden by the following overriding declaration.
 854   using Assembler::testl;
 855   void testl(Register dst, AddressLiteral src);
 856 
 857   void orptr(Register dst, Address src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 858   void orptr(Register dst, Register src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 859   void orptr(Register dst, int32_t src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 860   void orptr(Address dst, int32_t imm32) { LP64_ONLY(orq(dst, imm32)) NOT_LP64(orl(dst, imm32)); }
 861 
 862   void testptr(Register src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }
 863   void testptr(Register src1, Address src2) { LP64_ONLY(testq(src1, src2)) NOT_LP64(testl(src1, src2)); }
 864   void testptr(Register src1, Register src2);
 865 
 866   void xorptr(Register dst, Register src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 867   void xorptr(Register dst, Address src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 868 
 869   // Calls
 870 
 871   void call(Label&amp; L, relocInfo::relocType rtype);
 872   void call(Register entry);
 873 
 874   // NOTE: this call transfers to the effective address of entry NOT
 875   // the address contained by entry. This is because this is more natural
 876   // for jumps/calls.
 877   void call(AddressLiteral entry);
 878 
 879   // Emit the CompiledIC call idiom
 880   void ic_call(address entry, jint method_index = 0);
 881 
 882   // Jumps
 883 
 884   // NOTE: these jumps tranfer to the effective address of dst NOT
 885   // the address contained by dst. This is because this is more natural
 886   // for jumps/calls.
 887   void jump(AddressLiteral dst);
 888   void jump_cc(Condition cc, AddressLiteral dst);
 889 
 890   // 32bit can do a case table jump in one instruction but we no longer allow the base
 891   // to be installed in the Address class. This jump will tranfers to the address
 892   // contained in the location described by entry (not the address of entry)
 893   void jump(ArrayAddress entry);
 894 
 895   // Floating
 896 
 897   void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }
 898   void andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
 899   void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }
 900 
 901   void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }
 902   void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }
 903   void andps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
 904 
 905   void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }
 906   void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }
 907   void comiss(XMMRegister dst, AddressLiteral src);
 908 
 909   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 910   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 911   void comisd(XMMRegister dst, AddressLiteral src);
 912 
 913 #ifndef _LP64
 914   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 915   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 916 
 917   void fldcw(Address src) { Assembler::fldcw(src); }
 918   void fldcw(AddressLiteral src);
 919 
 920   void fld_s(int index)   { Assembler::fld_s(index); }
 921   void fld_s(Address src) { Assembler::fld_s(src); }
 922   void fld_s(AddressLiteral src);
 923 
 924   void fld_d(Address src) { Assembler::fld_d(src); }
 925   void fld_d(AddressLiteral src);
 926 
 927   void fld_x(Address src) { Assembler::fld_x(src); }
 928   void fld_x(AddressLiteral src);
 929 
 930   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 931   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
 932 #endif // _LP64
 933 
 934   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 935   void ldmxcsr(AddressLiteral src);
 936 
 937 #ifdef _LP64
 938  private:
 939   void sha256_AVX2_one_round_compute(
 940     Register  reg_old_h,
 941     Register  reg_a,
 942     Register  reg_b,
 943     Register  reg_c,
 944     Register  reg_d,
 945     Register  reg_e,
 946     Register  reg_f,
 947     Register  reg_g,
 948     Register  reg_h,
 949     int iter);
 950   void sha256_AVX2_four_rounds_compute_first(int start);
 951   void sha256_AVX2_four_rounds_compute_last(int start);
 952   void sha256_AVX2_one_round_and_sched(
 953         XMMRegister xmm_0,     /* == ymm4 on 0, 1, 2, 3 iterations, then rotate 4 registers left on 4, 8, 12 iterations */
 954         XMMRegister xmm_1,     /* ymm5 */  /* full cycle is 16 iterations */
 955         XMMRegister xmm_2,     /* ymm6 */
 956         XMMRegister xmm_3,     /* ymm7 */
 957         Register    reg_a,      /* == eax on 0 iteration, then rotate 8 register right on each next iteration */
 958         Register    reg_b,      /* ebx */    /* full cycle is 8 iterations */
 959         Register    reg_c,      /* edi */
 960         Register    reg_d,      /* esi */
 961         Register    reg_e,      /* r8d */
 962         Register    reg_f,      /* r9d */
 963         Register    reg_g,      /* r10d */
 964         Register    reg_h,      /* r11d */
 965         int iter);
 966 
 967   void addm(int disp, Register r1, Register r2);
 968   void gfmul(XMMRegister tmp0, XMMRegister t);
 969   void schoolbookAAD(int i, Register subkeyH, XMMRegister data, XMMRegister tmp0,
 970                      XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3);
 971   void generateHtbl_one_block(Register htbl);
 972   void generateHtbl_eight_blocks(Register htbl);
 973  public:
 974   void sha256_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 975                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 976                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 977                    bool multi_block, XMMRegister shuf_mask);
 978   void avx_ghash(Register state, Register htbl, Register data, Register blocks);
 979 #endif
 980 
 981 #ifdef _LP64
 982  private:
 983   void sha512_AVX2_one_round_compute(Register old_h, Register a, Register b, Register c, Register d,
 984                                      Register e, Register f, Register g, Register h, int iteration);
 985 
 986   void sha512_AVX2_one_round_and_schedule(XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 987                                           Register a, Register b, Register c, Register d, Register e, Register f,
 988                                           Register g, Register h, int iteration);
 989 
 990   void addmq(int disp, Register r1, Register r2);
 991  public:
 992   void sha512_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 993                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 994                    Register buf, Register state, Register ofs, Register limit, Register rsp, bool multi_block,
 995                    XMMRegister shuf_mask);
 996 private:
 997   void roundEnc(XMMRegister key, int rnum);
 998   void lastroundEnc(XMMRegister key, int rnum);
 999   void roundDec(XMMRegister key, int rnum);
1000   void lastroundDec(XMMRegister key, int rnum);
1001   void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask);
1002 
1003 public:
1004   void aesecb_encrypt(Register source_addr, Register dest_addr, Register key, Register len);
1005   void aesecb_decrypt(Register source_addr, Register dest_addr, Register key, Register len);
1006   void aesctr_encrypt(Register src_addr, Register dest_addr, Register key, Register counter,
1007                       Register len_reg, Register used, Register used_addr, Register saved_encCounter_start);
1008 
1009 #endif
1010 
1011   void fast_sha1(XMMRegister abcd, XMMRegister e0, XMMRegister e1, XMMRegister msg0,
1012                  XMMRegister msg1, XMMRegister msg2, XMMRegister msg3, XMMRegister shuf_mask,
1013                  Register buf, Register state, Register ofs, Register limit, Register rsp,
1014                  bool multi_block);
1015 
1016 #ifdef _LP64
1017   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
1018                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
1019                    Register buf, Register state, Register ofs, Register limit, Register rsp,
1020                    bool multi_block, XMMRegister shuf_mask);
1021 #else
1022   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
1023                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
1024                    Register buf, Register state, Register ofs, Register limit, Register rsp,
1025                    bool multi_block);
1026 #endif
1027 
1028   void fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1029                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1030                 Register rax, Register rcx, Register rdx, Register tmp);
1031 
1032 #ifdef _LP64
1033   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1034                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1035                 Register rax, Register rcx, Register rdx, Register tmp1, Register tmp2);
1036 
1037   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1038                   XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1039                   Register rax, Register rcx, Register rdx, Register r11);
1040 
1041   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1042                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1043                 Register rdx, Register tmp1, Register tmp2, Register tmp3, Register tmp4);
1044 
1045   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1046                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1047                 Register rax, Register rbx, Register rcx, Register rdx, Register tmp1, Register tmp2,
1048                 Register tmp3, Register tmp4);
1049 
1050   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1051                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1052                 Register rax, Register rcx, Register rdx, Register tmp1,
1053                 Register tmp2, Register tmp3, Register tmp4);
1054   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1055                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1056                 Register rax, Register rcx, Register rdx, Register tmp1,
1057                 Register tmp2, Register tmp3, Register tmp4);
1058 #else
1059   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1060                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1061                 Register rax, Register rcx, Register rdx, Register tmp1);
1062 
1063   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1064                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1065                 Register rax, Register rcx, Register rdx, Register tmp);
1066 
1067   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1068                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1069                 Register rdx, Register tmp);
1070 
1071   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1072                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1073                 Register rax, Register rbx, Register rdx);
1074 
1075   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1076                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1077                 Register rax, Register rcx, Register rdx, Register tmp);
1078 
1079   void libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1080                         Register edx, Register ebx, Register esi, Register edi,
1081                         Register ebp, Register esp);
1082 
1083   void libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx,
1084                          Register esi, Register edi, Register ebp, Register esp);
1085 
1086   void libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1087                         Register edx, Register ebx, Register esi, Register edi,
1088                         Register ebp, Register esp);
1089 
1090   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1091                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1092                 Register rax, Register rcx, Register rdx, Register tmp);
1093 #endif
1094 
1095 private:
1096 
1097   // these are private because users should be doing movflt/movdbl
1098 
1099   void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }
1100   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }
1101   void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }
1102   void movss(XMMRegister dst, AddressLiteral src);
1103 
1104   void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }
1105   void movlpd(XMMRegister dst, AddressLiteral src);
1106 
1107 public:
1108 
1109   void addsd(XMMRegister dst, XMMRegister src)    { Assembler::addsd(dst, src); }
1110   void addsd(XMMRegister dst, Address src)        { Assembler::addsd(dst, src); }
1111   void addsd(XMMRegister dst, AddressLiteral src);
1112 
1113   void addss(XMMRegister dst, XMMRegister src)    { Assembler::addss(dst, src); }
1114   void addss(XMMRegister dst, Address src)        { Assembler::addss(dst, src); }
1115   void addss(XMMRegister dst, AddressLiteral src);
1116 
1117   void addpd(XMMRegister dst, XMMRegister src)    { Assembler::addpd(dst, src); }
1118   void addpd(XMMRegister dst, Address src)        { Assembler::addpd(dst, src); }
1119   void addpd(XMMRegister dst, AddressLiteral src);
1120 
1121   void divsd(XMMRegister dst, XMMRegister src)    { Assembler::divsd(dst, src); }
1122   void divsd(XMMRegister dst, Address src)        { Assembler::divsd(dst, src); }
1123   void divsd(XMMRegister dst, AddressLiteral src);
1124 
1125   void divss(XMMRegister dst, XMMRegister src)    { Assembler::divss(dst, src); }
1126   void divss(XMMRegister dst, Address src)        { Assembler::divss(dst, src); }
1127   void divss(XMMRegister dst, AddressLiteral src);
1128 
1129   // Move Unaligned Double Quadword
1130   void movdqu(Address     dst, XMMRegister src);
1131   void movdqu(XMMRegister dst, Address src);
1132   void movdqu(XMMRegister dst, XMMRegister src);
1133   void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);
1134   // AVX Unaligned forms
1135   void vmovdqu(Address     dst, XMMRegister src);
1136   void vmovdqu(XMMRegister dst, Address src);
1137   void vmovdqu(XMMRegister dst, XMMRegister src);
1138   void vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1139   void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1140   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1141   void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1142   void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);
1143 
1144   // Move Aligned Double Quadword
1145   void movdqa(XMMRegister dst, Address src)       { Assembler::movdqa(dst, src); }
1146   void movdqa(XMMRegister dst, XMMRegister src)   { Assembler::movdqa(dst, src); }
1147   void movdqa(XMMRegister dst, AddressLiteral src);
1148 
1149   void movsd(XMMRegister dst, XMMRegister src) { Assembler::movsd(dst, src); }
1150   void movsd(Address dst, XMMRegister src)     { Assembler::movsd(dst, src); }
1151   void movsd(XMMRegister dst, Address src)     { Assembler::movsd(dst, src); }
1152   void movsd(XMMRegister dst, AddressLiteral src);
1153 
1154   void mulpd(XMMRegister dst, XMMRegister src)    { Assembler::mulpd(dst, src); }
1155   void mulpd(XMMRegister dst, Address src)        { Assembler::mulpd(dst, src); }
1156   void mulpd(XMMRegister dst, AddressLiteral src);
1157 
1158   void mulsd(XMMRegister dst, XMMRegister src)    { Assembler::mulsd(dst, src); }
1159   void mulsd(XMMRegister dst, Address src)        { Assembler::mulsd(dst, src); }
1160   void mulsd(XMMRegister dst, AddressLiteral src);
1161 
1162   void mulss(XMMRegister dst, XMMRegister src)    { Assembler::mulss(dst, src); }
1163   void mulss(XMMRegister dst, Address src)        { Assembler::mulss(dst, src); }
1164   void mulss(XMMRegister dst, AddressLiteral src);
1165 
1166   // Carry-Less Multiplication Quadword
1167   void pclmulldq(XMMRegister dst, XMMRegister src) {
1168     // 0x00 - multiply lower 64 bits [0:63]
1169     Assembler::pclmulqdq(dst, src, 0x00);
1170   }
1171   void pclmulhdq(XMMRegister dst, XMMRegister src) {
1172     // 0x11 - multiply upper 64 bits [64:127]
1173     Assembler::pclmulqdq(dst, src, 0x11);
1174   }
1175 
1176   void pcmpeqb(XMMRegister dst, XMMRegister src);
1177   void pcmpeqw(XMMRegister dst, XMMRegister src);
1178 
1179   void pcmpestri(XMMRegister dst, Address src, int imm8);
1180   void pcmpestri(XMMRegister dst, XMMRegister src, int imm8);
1181 
1182   void pmovzxbw(XMMRegister dst, XMMRegister src);
1183   void pmovzxbw(XMMRegister dst, Address src);
1184 
1185   void pmovmskb(Register dst, XMMRegister src);
1186 
1187   void ptest(XMMRegister dst, XMMRegister src);
1188 
1189   void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }
1190   void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }
1191   void sqrtsd(XMMRegister dst, AddressLiteral src);
1192 
1193   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode)    { Assembler::roundsd(dst, src, rmode); }
1194   void roundsd(XMMRegister dst, Address src, int32_t rmode)        { Assembler::roundsd(dst, src, rmode); }
1195   void roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg);
1196 
1197   void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }
1198   void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }
1199   void sqrtss(XMMRegister dst, AddressLiteral src);
1200 
1201   void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }
1202   void subsd(XMMRegister dst, Address src)        { Assembler::subsd(dst, src); }
1203   void subsd(XMMRegister dst, AddressLiteral src);
1204 
1205   void subss(XMMRegister dst, XMMRegister src)    { Assembler::subss(dst, src); }
1206   void subss(XMMRegister dst, Address src)        { Assembler::subss(dst, src); }
1207   void subss(XMMRegister dst, AddressLiteral src);
1208 
1209   void ucomiss(XMMRegister dst, XMMRegister src) { Assembler::ucomiss(dst, src); }
1210   void ucomiss(XMMRegister dst, Address src)     { Assembler::ucomiss(dst, src); }
1211   void ucomiss(XMMRegister dst, AddressLiteral src);
1212 
1213   void ucomisd(XMMRegister dst, XMMRegister src) { Assembler::ucomisd(dst, src); }
1214   void ucomisd(XMMRegister dst, Address src)     { Assembler::ucomisd(dst, src); }
1215   void ucomisd(XMMRegister dst, AddressLiteral src);
1216 
1217   // Bitwise Logical XOR of Packed Double-Precision Floating-Point Values
1218   void xorpd(XMMRegister dst, XMMRegister src);
1219   void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }
1220   void xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1221 
1222   // Bitwise Logical XOR of Packed Single-Precision Floating-Point Values
1223   void xorps(XMMRegister dst, XMMRegister src);
1224   void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }
1225   void xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1226 
1227   // Shuffle Bytes
1228   void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }
1229   void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }
1230   void pshufb(XMMRegister dst, AddressLiteral src);
1231   // AVX 3-operands instructions
1232 
1233   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddsd(dst, nds, src); }
1234   void vaddsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddsd(dst, nds, src); }
1235   void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1236 
1237   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddss(dst, nds, src); }
1238   void vaddss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddss(dst, nds, src); }
1239   void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1240 
1241   void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1242   void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1243 
1244   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1245   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1246 
1247   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1248   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1249 
1250   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }
1251   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }
1252   void vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);
1253 
1254   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1255   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1256   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1257 
1258   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
1259   void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }
1260 
1261   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1262 
1263   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1264 
1265   void vpmovzxbw(XMMRegister dst, Address src, int vector_len);
1266   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpmovzxbw(dst, src, vector_len); }
1267 
1268   void vpmovmskb(Register dst, XMMRegister src);
1269 
1270   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1271   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1272 
1273   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1274   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1275 
1276   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1277   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1278 
1279   void vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1280   void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1281 
1282   void evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1283   void evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1284 
1285   void vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1286   void vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1287 
1288   void vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1289   void vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1290 
1291   void vptest(XMMRegister dst, XMMRegister src);
1292 
1293   void punpcklbw(XMMRegister dst, XMMRegister src);
1294   void punpcklbw(XMMRegister dst, Address src) { Assembler::punpcklbw(dst, src); }
1295 
1296   void pshufd(XMMRegister dst, Address src, int mode);
1297   void pshufd(XMMRegister dst, XMMRegister src, int mode) { Assembler::pshufd(dst, src, mode); }
1298 
1299   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1300   void pshuflw(XMMRegister dst, Address src, int mode) { Assembler::pshuflw(dst, src, mode); }
1301 
1302   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }
1303   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }
1304   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1305 
1306   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }
1307   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }
1308   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1309 
1310   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }
1311   void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }
1312   void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1313 
1314   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivss(dst, nds, src); }
1315   void vdivss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivss(dst, nds, src); }
1316   void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1317 
1318   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulsd(dst, nds, src); }
1319   void vmulsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulsd(dst, nds, src); }
1320   void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1321 
1322   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulss(dst, nds, src); }
1323   void vmulss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulss(dst, nds, src); }
1324   void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1325 
1326   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubsd(dst, nds, src); }
1327   void vsubsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubsd(dst, nds, src); }
1328   void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1329 
1330   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubss(dst, nds, src); }
1331   void vsubss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubss(dst, nds, src); }
1332   void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1333 
1334   void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1335   void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1336 
1337   // AVX Vector instructions
1338 
1339   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1340   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1341   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1342 
1343   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1344   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1345   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1346 
1347   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1348     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1349       Assembler::vpxor(dst, nds, src, vector_len);
1350     else
1351       Assembler::vxorpd(dst, nds, src, vector_len);
1352   }
1353   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
1354     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1355       Assembler::vpxor(dst, nds, src, vector_len);
1356     else
1357       Assembler::vxorpd(dst, nds, src, vector_len);
1358   }
1359   void vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1360 
1361   // Simple version for AVX2 256bit vectors
1362   void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }
1363   void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }
1364 
1365   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
1366     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1367       Assembler::vinserti32x4(dst, dst, src, imm8);
1368     } else if (UseAVX &gt; 1) {
1369       // vinserti128 is available only in AVX2
1370       Assembler::vinserti128(dst, nds, src, imm8);
1371     } else {
1372       Assembler::vinsertf128(dst, nds, src, imm8);
1373     }
1374   }
1375 
1376   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
1377     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1378       Assembler::vinserti32x4(dst, dst, src, imm8);
1379     } else if (UseAVX &gt; 1) {
1380       // vinserti128 is available only in AVX2
1381       Assembler::vinserti128(dst, nds, src, imm8);
1382     } else {
1383       Assembler::vinsertf128(dst, nds, src, imm8);
1384     }
1385   }
1386 
1387   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
1388     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1389       Assembler::vextracti32x4(dst, src, imm8);
1390     } else if (UseAVX &gt; 1) {
1391       // vextracti128 is available only in AVX2
1392       Assembler::vextracti128(dst, src, imm8);
1393     } else {
1394       Assembler::vextractf128(dst, src, imm8);
1395     }
1396   }
1397 
1398   void vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
1399     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1400       Assembler::vextracti32x4(dst, src, imm8);
1401     } else if (UseAVX &gt; 1) {
1402       // vextracti128 is available only in AVX2
1403       Assembler::vextracti128(dst, src, imm8);
1404     } else {
1405       Assembler::vextractf128(dst, src, imm8);
1406     }
1407   }
1408 
1409   // 128bit copy to/from high 128 bits of 256bit (YMM) vector registers
1410   void vinserti128_high(XMMRegister dst, XMMRegister src) {
1411     vinserti128(dst, dst, src, 1);
1412   }
1413   void vinserti128_high(XMMRegister dst, Address src) {
1414     vinserti128(dst, dst, src, 1);
1415   }
1416   void vextracti128_high(XMMRegister dst, XMMRegister src) {
1417     vextracti128(dst, src, 1);
1418   }
1419   void vextracti128_high(Address dst, XMMRegister src) {
1420     vextracti128(dst, src, 1);
1421   }
1422 
1423   void vinsertf128_high(XMMRegister dst, XMMRegister src) {
1424     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1425       Assembler::vinsertf32x4(dst, dst, src, 1);
1426     } else {
1427       Assembler::vinsertf128(dst, dst, src, 1);
1428     }
1429   }
1430 
1431   void vinsertf128_high(XMMRegister dst, Address src) {
1432     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1433       Assembler::vinsertf32x4(dst, dst, src, 1);
1434     } else {
1435       Assembler::vinsertf128(dst, dst, src, 1);
1436     }
1437   }
1438 
1439   void vextractf128_high(XMMRegister dst, XMMRegister src) {
1440     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1441       Assembler::vextractf32x4(dst, src, 1);
1442     } else {
1443       Assembler::vextractf128(dst, src, 1);
1444     }
1445   }
1446 
1447   void vextractf128_high(Address dst, XMMRegister src) {
1448     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1449       Assembler::vextractf32x4(dst, src, 1);
1450     } else {
1451       Assembler::vextractf128(dst, src, 1);
1452     }
1453   }
1454 
1455   // 256bit copy to/from high 256 bits of 512bit (ZMM) vector registers
1456   void vinserti64x4_high(XMMRegister dst, XMMRegister src) {
1457     Assembler::vinserti64x4(dst, dst, src, 1);
1458   }
1459   void vinsertf64x4_high(XMMRegister dst, XMMRegister src) {
1460     Assembler::vinsertf64x4(dst, dst, src, 1);
1461   }
1462   void vextracti64x4_high(XMMRegister dst, XMMRegister src) {
1463     Assembler::vextracti64x4(dst, src, 1);
1464   }
1465   void vextractf64x4_high(XMMRegister dst, XMMRegister src) {
1466     Assembler::vextractf64x4(dst, src, 1);
1467   }
1468   void vextractf64x4_high(Address dst, XMMRegister src) {
1469     Assembler::vextractf64x4(dst, src, 1);
1470   }
1471   void vinsertf64x4_high(XMMRegister dst, Address src) {
1472     Assembler::vinsertf64x4(dst, dst, src, 1);
1473   }
1474 
1475   // 128bit copy to/from low 128 bits of 256bit (YMM) vector registers
1476   void vinserti128_low(XMMRegister dst, XMMRegister src) {
1477     vinserti128(dst, dst, src, 0);
1478   }
1479   void vinserti128_low(XMMRegister dst, Address src) {
1480     vinserti128(dst, dst, src, 0);
1481   }
1482   void vextracti128_low(XMMRegister dst, XMMRegister src) {
1483     vextracti128(dst, src, 0);
1484   }
1485   void vextracti128_low(Address dst, XMMRegister src) {
1486     vextracti128(dst, src, 0);
1487   }
1488 
1489   void vinsertf128_low(XMMRegister dst, XMMRegister src) {
1490     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1491       Assembler::vinsertf32x4(dst, dst, src, 0);
1492     } else {
1493       Assembler::vinsertf128(dst, dst, src, 0);
1494     }
1495   }
1496 
1497   void vinsertf128_low(XMMRegister dst, Address src) {
1498     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1499       Assembler::vinsertf32x4(dst, dst, src, 0);
1500     } else {
1501       Assembler::vinsertf128(dst, dst, src, 0);
1502     }
1503   }
1504 
1505   void vextractf128_low(XMMRegister dst, XMMRegister src) {
1506     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1507       Assembler::vextractf32x4(dst, src, 0);
1508     } else {
1509       Assembler::vextractf128(dst, src, 0);
1510     }
1511   }
1512 
1513   void vextractf128_low(Address dst, XMMRegister src) {
1514     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1515       Assembler::vextractf32x4(dst, src, 0);
1516     } else {
1517       Assembler::vextractf128(dst, src, 0);
1518     }
1519   }
1520 
1521   // 256bit copy to/from low 256 bits of 512bit (ZMM) vector registers
1522   void vinserti64x4_low(XMMRegister dst, XMMRegister src) {
1523     Assembler::vinserti64x4(dst, dst, src, 0);
1524   }
1525   void vinsertf64x4_low(XMMRegister dst, XMMRegister src) {
1526     Assembler::vinsertf64x4(dst, dst, src, 0);
1527   }
1528   void vextracti64x4_low(XMMRegister dst, XMMRegister src) {
1529     Assembler::vextracti64x4(dst, src, 0);
1530   }
1531   void vextractf64x4_low(XMMRegister dst, XMMRegister src) {
1532     Assembler::vextractf64x4(dst, src, 0);
1533   }
1534   void vextractf64x4_low(Address dst, XMMRegister src) {
1535     Assembler::vextractf64x4(dst, src, 0);
1536   }
1537   void vinsertf64x4_low(XMMRegister dst, Address src) {
1538     Assembler::vinsertf64x4(dst, dst, src, 0);
1539   }
1540 
1541   // Carry-Less Multiplication Quadword
1542   void vpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1543     // 0x00 - multiply lower 64 bits [0:63]
1544     Assembler::vpclmulqdq(dst, nds, src, 0x00);
1545   }
1546   void vpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1547     // 0x11 - multiply upper 64 bits [64:127]
1548     Assembler::vpclmulqdq(dst, nds, src, 0x11);
1549   }
1550   void vpclmullqhqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1551     // 0x10 - multiply nds[0:63] and src[64:127]
1552     Assembler::vpclmulqdq(dst, nds, src, 0x10);
1553   }
1554   void vpclmulhqlqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1555     //0x01 - multiply nds[64:127] and src[0:63]
1556     Assembler::vpclmulqdq(dst, nds, src, 0x01);
1557   }
1558 
1559   void evpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1560     // 0x00 - multiply lower 64 bits [0:63]
1561     Assembler::evpclmulqdq(dst, nds, src, 0x00, vector_len);
1562   }
1563   void evpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1564     // 0x11 - multiply upper 64 bits [64:127]
1565     Assembler::evpclmulqdq(dst, nds, src, 0x11, vector_len);
1566   }
1567 
1568   // Data
1569 
1570   void cmov32( Condition cc, Register dst, Address  src);
1571   void cmov32( Condition cc, Register dst, Register src);
1572 
1573   void cmov(   Condition cc, Register dst, Register src) { cmovptr(cc, dst, src); }
1574 
1575   void cmovptr(Condition cc, Register dst, Address  src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1576   void cmovptr(Condition cc, Register dst, Register src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1577 
1578   void movoop(Register dst, jobject obj);
1579   void movoop(Address dst, jobject obj);
1580 
1581   void mov_metadata(Register dst, Metadata* obj);
1582   void mov_metadata(Address dst, Metadata* obj);
1583 
1584   void movptr(ArrayAddress dst, Register src);
1585   // can this do an lea?
1586   void movptr(Register dst, ArrayAddress src);
1587 
1588   void movptr(Register dst, Address src);
1589 
1590 #ifdef _LP64
1591   void movptr(Register dst, AddressLiteral src, Register scratch=rscratch1);
1592 #else
1593   void movptr(Register dst, AddressLiteral src, Register scratch=noreg); // Scratch reg is ignored in 32-bit
1594 #endif
1595 
1596   void movptr(Register dst, intptr_t src);
1597   void movptr(Register dst, Register src);
1598   void movptr(Address dst, intptr_t src);
1599 
1600   void movptr(Address dst, Register src);
1601 
1602   void movptr(Register dst, RegisterOrConstant src) {
1603     if (src.is_constant()) movptr(dst, src.as_constant());
1604     else                   movptr(dst, src.as_register());
1605   }
1606 
1607 #ifdef _LP64
1608   // Generally the next two are only used for moving NULL
1609   // Although there are situations in initializing the mark word where
1610   // they could be used. They are dangerous.
1611 
1612   // They only exist on LP64 so that int32_t and intptr_t are not the same
1613   // and we have ambiguous declarations.
1614 
1615   void movptr(Address dst, int32_t imm32);
1616   void movptr(Register dst, int32_t imm32);
1617 #endif // _LP64
1618 
1619   // to avoid hiding movl
1620   void mov32(AddressLiteral dst, Register src);
1621   void mov32(Register dst, AddressLiteral src);
1622 
1623   // to avoid hiding movb
1624   void movbyte(ArrayAddress dst, int src);
1625 
1626   // Import other mov() methods from the parent class or else
1627   // they will be hidden by the following overriding declaration.
1628   using Assembler::movdl;
1629   using Assembler::movq;
1630   void movdl(XMMRegister dst, AddressLiteral src);
1631   void movq(XMMRegister dst, AddressLiteral src);
1632 
1633   // Can push value or effective address
1634   void pushptr(AddressLiteral src);
1635 
1636   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1637   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1638 
1639   void pushoop(jobject obj);
1640   void pushklass(Metadata* obj);
1641 
1642   // sign extend as need a l to ptr sized element
1643   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1644   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1645 
1646 
1647  public:
1648   // C2 compiled method&#39;s prolog code.
1649   void verified_entry(Compile* C, int sp_inc = 0);
1650 
1651   enum RegState {
1652     reg_readonly,
1653     reg_writable,
1654     reg_written
1655   };
1656 
1657   int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);
1658 
1659   // Unpack all inline type arguments passed as oops
1660   void unpack_inline_args(Compile* C, bool receiver_only);
1661   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1662   bool unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
1663                             RegState reg_state[], int ret_off, int extra_stack_offset);
1664   bool pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
1665                           VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
1666                           int ret_off, int extra_stack_offset);
1667   void remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset);
1668 
1669   void shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,
1670                            BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
1671                            int args_passed, int args_on_stack, VMRegPair* regs,
1672                            int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc);
1673   bool shuffle_inline_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
1674                                  VMRegPair* regs_from, int from_index, int regs_from_count,
1675                                  RegState* reg_state, int sp_inc, int extra_stack_offset);
1676   VMReg spill_reg_for(VMReg reg);
1677 
1678   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1679   // if &#39;is_large&#39; is set, do not try to produce short loop
1680   void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only);
1681 
1682   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1683   void xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp);
1684 
1685   // Fill primitive arrays
1686   void generate_fill(BasicType t, bool aligned,
1687                      Register to, Register value, Register count,
1688                      Register rtmp, XMMRegister xtmp);
1689 
1690   void encode_iso_array(Register src, Register dst, Register len,
1691                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1692                         XMMRegister tmp4, Register tmp5, Register result);
1693 
1694 #ifdef _LP64
1695   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
1696   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1697                              Register y, Register y_idx, Register z,
1698                              Register carry, Register product,
1699                              Register idx, Register kdx);
1700   void multiply_add_128_x_128(Register x_xstart, Register y, Register z,
1701                               Register yz_idx, Register idx,
1702                               Register carry, Register product, int offset);
1703   void multiply_128_x_128_bmi2_loop(Register y, Register z,
1704                                     Register carry, Register carry2,
1705                                     Register idx, Register jdx,
1706                                     Register yz_idx1, Register yz_idx2,
1707                                     Register tmp, Register tmp3, Register tmp4);
1708   void multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
1709                                Register yz_idx, Register idx, Register jdx,
1710                                Register carry, Register product,
1711                                Register carry2);
1712   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
1713                        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5);
1714   void square_rshift(Register x, Register len, Register z, Register tmp1, Register tmp3,
1715                      Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1716   void multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry,
1717                             Register tmp2);
1718   void multiply_add_64(Register sum, Register op1, Register op2, Register carry,
1719                        Register rdxReg, Register raxReg);
1720   void add_one_64(Register z, Register zlen, Register carry, Register tmp1);
1721   void lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1722                        Register tmp3, Register tmp4);
1723   void square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1724                      Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1725 
1726   void mul_add_128_x_32_loop(Register out, Register in, Register offset, Register len, Register tmp1,
1727                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1728                Register raxReg);
1729   void mul_add(Register out, Register in, Register offset, Register len, Register k, Register tmp1,
1730                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1731                Register raxReg);
1732   void vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
1733                            Register result, Register tmp1, Register tmp2,
1734                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3);
1735 #endif
1736 
1737   // CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.
1738   void update_byte_crc32(Register crc, Register val, Register table);
1739   void kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp);
1740 
1741 
1742 #ifdef _LP64
1743   void kernel_crc32_avx512(Register crc, Register buf, Register len, Register table, Register tmp1, Register tmp2);
1744   void kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register key, Register pos,
1745                                 Register tmp1, Register tmp2, Label&amp; L_barrett, Label&amp; L_16B_reduction_loop,
1746                                 Label&amp; L_get_last_two_xmms, Label&amp; L_128_done, Label&amp; L_cleanup);
1747 #endif // _LP64
1748 
1749   // CRC32C code for java.util.zip.CRC32C::updateBytes() intrinsic
1750   // Note on a naming convention:
1751   // Prefix w = register only used on a Westmere+ architecture
1752   // Prefix n = register only used on a Nehalem architecture
1753 #ifdef _LP64
1754   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1755                        Register tmp1, Register tmp2, Register tmp3);
1756 #else
1757   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1758                        Register tmp1, Register tmp2, Register tmp3,
1759                        XMMRegister xtmp1, XMMRegister xtmp2);
1760 #endif
1761   void crc32c_pclmulqdq(XMMRegister w_xtmp1,
1762                         Register in_out,
1763                         uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
1764                         XMMRegister w_xtmp2,
1765                         Register tmp1,
1766                         Register n_tmp2, Register n_tmp3);
1767   void crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
1768                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1769                        Register tmp1, Register tmp2,
1770                        Register n_tmp3);
1771   void crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
1772                          Register in_out1, Register in_out2, Register in_out3,
1773                          Register tmp1, Register tmp2, Register tmp3,
1774                          XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1775                          Register tmp4, Register tmp5,
1776                          Register n_tmp6);
1777   void crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
1778                             Register tmp1, Register tmp2, Register tmp3,
1779                             Register tmp4, Register tmp5, Register tmp6,
1780                             XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1781                             bool is_pclmulqdq_supported);
1782   // Fold 128-bit data chunk
1783   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1784   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf);
1785 #ifdef _LP64
1786   // Fold 512-bit data chunk
1787   void fold512bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, Register pos, int offset);
1788 #endif // _LP64
1789   // Fold 8-bit data
1790   void fold_8bit_crc32(Register crc, Register table, Register tmp);
1791   void fold_8bit_crc32(XMMRegister crc, Register table, XMMRegister xtmp, Register tmp);
1792 
1793   // Compress char[] array to byte[].
1794   void char_array_compress(Register src, Register dst, Register len,
1795                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1796                            XMMRegister tmp4, Register tmp5, Register result);
1797 
1798   // Inflate byte[] array to char[].
1799   void byte_array_inflate(Register src, Register dst, Register len,
1800                           XMMRegister tmp1, Register tmp2);
1801 
1802 #ifdef _LP64
1803   void convert_f2i(Register dst, XMMRegister src);
1804   void convert_d2i(Register dst, XMMRegister src);
1805   void convert_f2l(Register dst, XMMRegister src);
1806   void convert_d2l(Register dst, XMMRegister src);
1807 
1808   void cache_wb(Address line);
1809   void cache_wbsync(bool is_pre);
1810 #endif // _LP64
1811 
1812   void vallones(XMMRegister dst, int vector_len);
1813 
1814   #include &quot;asm/macroAssembler_common.hpp&quot;
1815 };
1816 
1817 /**
1818  * class SkipIfEqual:
1819  *
1820  * Instantiating this class will result in assembly code being output that will
1821  * jump around any code emitted between the creation of the instance and it&#39;s
1822  * automatic destruction at the end of a scope block, depending on the value of
1823  * the flag passed to the constructor, which will be checked at run-time.
1824  */
1825 class SkipIfEqual {
1826  private:
1827   MacroAssembler* _masm;
1828   Label _label;
1829 
1830  public:
1831    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1832    ~SkipIfEqual();
1833 };
1834 
1835 #endif // CPU_X86_MACROASSEMBLER_X86_HPP
    </pre>
  </body>
</html>
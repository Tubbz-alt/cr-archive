<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="inlineKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  56 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  57 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
  58 //    [EMBEDDED inline_type_field_klasses] only if has_inline_fields() == true
  59 //    [EMBEDDED InlineKlassFixedBlock] only if is a InlineKlass instance
  60 
  61 
  62 // forward declaration for class -- see below for definition
  63 #if INCLUDE_JVMTI
  64 class BreakpointInfo;
  65 #endif
  66 class ClassFileParser;
  67 class ClassFileStream;
  68 class KlassDepChange;
  69 class DependencyContext;
  70 class fieldDescriptor;
  71 class jniIdMapBase;
  72 class JNIid;
  73 class JvmtiCachedClassFieldMap;
  74 class nmethodBucket;
  75 class OopMapCache;
<span class="line-modified">  76 class BufferedValueTypeBlob;</span>
  77 class InterpreterOopMap;
  78 class PackageEntry;
  79 class ModuleEntry;
  80 
  81 // This is used in iterators below.
  82 class FieldClosure: public StackObj {
  83 public:
  84   virtual void do_field(fieldDescriptor* fd) = 0;
  85 };
  86 
  87 #ifndef PRODUCT
  88 // Print fields.
  89 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  90 class FieldPrinter: public FieldClosure {
  91    oop _obj;
  92    outputStream* _st;
  93  public:
  94    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  95    void do_field(fieldDescriptor* fd);
  96 };
</pre>
<hr />
<pre>
 425     return (_misc_flags &amp; _misc_is_empty_inline_type) != 0;
 426   }
 427   void set_is_empty_inline_type() {
 428     _misc_flags |= _misc_is_empty_inline_type;
 429   }
 430 
 431   // Note:  The naturally_atomic property only applies to
 432   // inline classes; it is never true on identity classes.
 433   // The bit is placed on instanceKlass for convenience.
 434 
 435   // Query if h/w provides atomic load/store for instances.
 436   bool is_naturally_atomic() const {
 437     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 438   }
 439   // Initialized in the class file parser, not changed later.
 440   void set_is_naturally_atomic() {
 441     _misc_flags |= _misc_is_naturally_atomic;
 442   }
 443 
 444   // Query if this class implements jl.NonTearable or was
<span class="line-modified"> 445   // mentioned in the JVM option AlwaysAtomicValueTypes.</span>
 446   // This bit can occur anywhere, but is only significant
 447   // for inline classes *and* their super types.
 448   // It inherits from supers along with NonTearable.
 449   bool is_declared_atomic() const {
 450     return (_misc_flags &amp; _misc_is_declared_atomic) != 0;
 451   }
 452   // Initialized in the class file parser, not changed later.
 453   void set_is_declared_atomic() {
 454     _misc_flags |= _misc_is_declared_atomic;
 455   }
 456 
 457   // Query if class is an invalid super class for an inline type.
 458   bool invalid_inline_super() const {
 459     return (_misc_flags &amp; _misc_invalid_inline_super) != 0;
 460   }
 461   // Initialized in the class file parser, not changed later.
 462   void set_invalid_inline_super() {
 463     _misc_flags |= _misc_invalid_inline_super;
 464   }
 465   // Query if class is an invalid super class for an identity type.
</pre>
</td>
<td>
<hr />
<pre>
  56 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  57 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
  58 //    [EMBEDDED inline_type_field_klasses] only if has_inline_fields() == true
  59 //    [EMBEDDED InlineKlassFixedBlock] only if is a InlineKlass instance
  60 
  61 
  62 // forward declaration for class -- see below for definition
  63 #if INCLUDE_JVMTI
  64 class BreakpointInfo;
  65 #endif
  66 class ClassFileParser;
  67 class ClassFileStream;
  68 class KlassDepChange;
  69 class DependencyContext;
  70 class fieldDescriptor;
  71 class jniIdMapBase;
  72 class JNIid;
  73 class JvmtiCachedClassFieldMap;
  74 class nmethodBucket;
  75 class OopMapCache;
<span class="line-modified">  76 class BufferedInlineTypeBlob;</span>
  77 class InterpreterOopMap;
  78 class PackageEntry;
  79 class ModuleEntry;
  80 
  81 // This is used in iterators below.
  82 class FieldClosure: public StackObj {
  83 public:
  84   virtual void do_field(fieldDescriptor* fd) = 0;
  85 };
  86 
  87 #ifndef PRODUCT
  88 // Print fields.
  89 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  90 class FieldPrinter: public FieldClosure {
  91    oop _obj;
  92    outputStream* _st;
  93  public:
  94    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  95    void do_field(fieldDescriptor* fd);
  96 };
</pre>
<hr />
<pre>
 425     return (_misc_flags &amp; _misc_is_empty_inline_type) != 0;
 426   }
 427   void set_is_empty_inline_type() {
 428     _misc_flags |= _misc_is_empty_inline_type;
 429   }
 430 
 431   // Note:  The naturally_atomic property only applies to
 432   // inline classes; it is never true on identity classes.
 433   // The bit is placed on instanceKlass for convenience.
 434 
 435   // Query if h/w provides atomic load/store for instances.
 436   bool is_naturally_atomic() const {
 437     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 438   }
 439   // Initialized in the class file parser, not changed later.
 440   void set_is_naturally_atomic() {
 441     _misc_flags |= _misc_is_naturally_atomic;
 442   }
 443 
 444   // Query if this class implements jl.NonTearable or was
<span class="line-modified"> 445   // mentioned in the JVM option ForceNonTearable.</span>
 446   // This bit can occur anywhere, but is only significant
 447   // for inline classes *and* their super types.
 448   // It inherits from supers along with NonTearable.
 449   bool is_declared_atomic() const {
 450     return (_misc_flags &amp; _misc_is_declared_atomic) != 0;
 451   }
 452   // Initialized in the class file parser, not changed later.
 453   void set_is_declared_atomic() {
 454     _misc_flags |= _misc_is_declared_atomic;
 455   }
 456 
 457   // Query if class is an invalid super class for an inline type.
 458   bool invalid_inline_super() const {
 459     return (_misc_flags &amp; _misc_invalid_inline_super) != 0;
 460   }
 461   // Initialized in the class file parser, not changed later.
 462   void set_invalid_inline_super() {
 463     _misc_flags |= _misc_invalid_inline_super;
 464   }
 465   // Query if class is an invalid super class for an identity type.
</pre>
</td>
</tr>
</table>
<center><a href="inlineKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
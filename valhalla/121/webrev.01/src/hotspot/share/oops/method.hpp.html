<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/method.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHOD_HPP
  26 #define SHARE_OOPS_METHOD_HPP
  27 
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;code/compressedStream.hpp&quot;
  30 #include &quot;compiler/compilerDefinitions.hpp&quot;
  31 #include &quot;compiler/oopMap.hpp&quot;
  32 #include &quot;interpreter/invocationCounter.hpp&quot;
  33 #include &quot;oops/annotations.hpp&quot;
  34 #include &quot;oops/constantPool.hpp&quot;
  35 #include &quot;oops/methodCounters.hpp&quot;
  36 #include &quot;oops/instanceKlass.hpp&quot;
  37 #include &quot;oops/oop.hpp&quot;
  38 #include &quot;oops/typeArrayOop.hpp&quot;
  39 #include &quot;utilities/accessFlags.hpp&quot;
  40 #include &quot;utilities/align.hpp&quot;
  41 #include &quot;utilities/growableArray.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 #if INCLUDE_JFR
  44 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  45 #endif
  46 
  47 
  48 // A Method represents a Java method.
  49 //
  50 // Note that most applications load thousands of methods, so keeping the size of this
  51 // class small has a big impact on footprint.
  52 //
  53 // Note that native_function and signature_handler have to be at fixed offsets
  54 // (required by the interpreter)
  55 //
  56 //  Method embedded field layout (after declared fields):
  57 //   [EMBEDDED native_function       (present only if native) ]
  58 //   [EMBEDDED signature_handler     (present only if native) ]
  59 
  60 class CheckedExceptionElement;
  61 class LocalVariableTableElement;
  62 class AdapterHandlerEntry;
  63 class MethodData;
  64 class MethodCounters;
  65 class ConstMethod;
  66 class InlineTableSizes;
  67 class CompiledMethod;
  68 class InterpreterOopMap;
  69 
  70 class Method : public Metadata {
  71  friend class VMStructs;
  72  friend class JVMCIVMStructs;
  73  private:
  74   // If you add a new field that points to any metaspace object, you
  75   // must add this field to Method::metaspace_pointers_do().
  76   ConstMethod*      _constMethod;                // Method read-only data.
  77   MethodData*       _method_data;
  78   MethodCounters*   _method_counters;
  79   AccessFlags       _access_flags;               // Access flags
  80   int               _vtable_index;               // vtable index of this method (see VtableIndexFlag)
  81                                                  // note: can have vtables with &gt;2**16 elements (because of inheritance)
  82   u2                _intrinsic_id;               // vmSymbols::intrinsic_id (0 == _none)
  83 
  84   // Flags
  85   enum Flags {
  86     _caller_sensitive      = 1 &lt;&lt; 0,
  87     _force_inline          = 1 &lt;&lt; 1,
  88     _dont_inline           = 1 &lt;&lt; 2,
  89     _hidden                = 1 &lt;&lt; 3,
  90     _has_injected_profile  = 1 &lt;&lt; 4,
  91     _running_emcp          = 1 &lt;&lt; 5,
  92     _intrinsic_candidate   = 1 &lt;&lt; 6,
  93     _reserved_stack_access = 1 &lt;&lt; 7,
  94     _scalarized_args       = 1 &lt;&lt; 8,
  95     _c1_needs_stack_repair = 1 &lt;&lt; 9,
  96     _c2_needs_stack_repair = 1 &lt;&lt; 10
  97   };
  98   mutable u2 _flags;
  99 
 100   JFR_ONLY(DEFINE_TRACE_FLAG;)
 101 
 102 #ifndef PRODUCT
 103   int               _compiled_invocation_count;  // Number of nmethod invocations so far (for perf. debugging)
 104 #endif
 105   // Entry point for calling both from and to the interpreter.
 106   address _i2i_entry;           // All-args-on-stack calling convention
 107   // Entry point for calling from compiled code, to compiled code if it exists
 108   // or else the interpreter.
 109   volatile address _from_compiled_entry;           // Cache of: _code ? _code-&gt;verified_entry_point()           : _adapter-&gt;c2i_entry()
 110   volatile address _from_compiled_inline_ro_entry; // Cache of: _code ? _code-&gt;verified_inline_ro_entry_point() : _adapter-&gt;c2i_inline_ro_entry()
 111   volatile address _from_compiled_inline_entry;    // Cache of: _code ? _code-&gt;verified_inline_entry_point()    : _adapter-&gt;c2i_inline_entry()
 112   // The entry point for calling both from and to compiled code is
 113   // &quot;_code-&gt;entry_point()&quot;.  Because of tiered compilation and de-opt, this
 114   // field can come and go.  It can transition from NULL to not-null at any
 115   // time (whenever a compile completes).  It can transition from not-null to
 116   // NULL only at safepoints (because of a de-opt).
 117   CompiledMethod* volatile _code;                       // Points to the corresponding piece of native code
 118   volatile address           _from_interpreted_entry; // Cache of _code ? _adapter-&gt;i2c_entry() : _i2i_entry
 119   int _max_vt_buffer; // max number of VT buffer chunk to use before recycling
 120 
 121 #if INCLUDE_AOT &amp;&amp; defined(TIERED)
 122   CompiledMethod* _aot_code;
 123 #endif
 124 
 125   // Constructor
 126   Method(ConstMethod* xconst, AccessFlags access_flags);
 127  public:
 128 
 129   static Method* allocate(ClassLoaderData* loader_data,
 130                           int byte_code_size,
 131                           AccessFlags access_flags,
 132                           InlineTableSizes* sizes,
 133                           ConstMethod::MethodType method_type,
 134                           TRAPS);
 135 
 136   // CDS and vtbl checking can create an empty Method to get vtbl pointer.
 137   Method(){}
 138 
 139   virtual bool is_method() const { return true; }
 140 
 141   void restore_unshareable_info(TRAPS);
 142 
 143   // accessors for instance variables
 144 
 145   ConstMethod* constMethod() const             { return _constMethod; }
 146   void set_constMethod(ConstMethod* xconst)    { _constMethod = xconst; }
 147 
 148 
 149   static address make_adapters(const methodHandle&amp; mh, TRAPS);
 150   address from_compiled_entry() const;
 151   address from_compiled_inline_ro_entry() const;
 152   address from_compiled_inline_entry() const;
 153   address from_compiled_entry_no_trampoline(bool caller_is_c1) const;
 154   address from_interpreted_entry() const;
 155 
 156   // access flag
 157   AccessFlags access_flags() const               { return _access_flags;  }
 158   void set_access_flags(AccessFlags flags)       { _access_flags = flags; }
 159 
 160   // name
 161   Symbol* name() const                           { return constants()-&gt;symbol_at(name_index()); }
 162   int name_index() const                         { return constMethod()-&gt;name_index();         }
 163   void set_name_index(int index)                 { constMethod()-&gt;set_name_index(index);       }
 164 
 165   // signature
 166   Symbol* signature() const                      { return constants()-&gt;symbol_at(signature_index()); }
 167   int signature_index() const                    { return constMethod()-&gt;signature_index();         }
 168   void set_signature_index(int index)            { constMethod()-&gt;set_signature_index(index);       }
 169 
 170   // generics support
 171   Symbol* generic_signature() const              { int idx = generic_signature_index(); return ((idx != 0) ? constants()-&gt;symbol_at(idx) : (Symbol*)NULL); }
 172   int generic_signature_index() const            { return constMethod()-&gt;generic_signature_index(); }
 173   void set_generic_signature_index(int index)    { constMethod()-&gt;set_generic_signature_index(index); }
 174 
 175   // annotations support
 176   AnnotationArray* annotations() const           {
 177     return constMethod()-&gt;method_annotations();
 178   }
 179   AnnotationArray* parameter_annotations() const {
 180     return constMethod()-&gt;parameter_annotations();
 181   }
 182   AnnotationArray* annotation_default() const    {
 183     return constMethod()-&gt;default_annotations();
 184   }
 185   AnnotationArray* type_annotations() const      {
 186     return constMethod()-&gt;type_annotations();
 187   }
 188 
 189   // Helper routine: get klass name + &quot;.&quot; + method name + signature as
 190   // C string, for the purpose of providing more useful
 191   // fatal error handling. The string is allocated in resource
 192   // area if a buffer is not provided by the caller.
 193   char* name_and_sig_as_C_string() const;
 194   char* name_and_sig_as_C_string(char* buf, int size) const;
 195 
 196   // Static routine in the situations we don&#39;t have a Method*
 197   static char* name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature);
 198   static char* name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature, char* buf, int size);
 199 
 200   // Get return type + klass name + &quot;.&quot; + method name + ( parameters types )
 201   // as a C string or print it to an outputStream.
 202   // This is to be used to assemble strings passed to Java, so that
 203   // the text more resembles Java code. Used in exception messages.
 204   // Memory is allocated in the resource area; the caller needs
 205   // a ResourceMark.
 206   const char* external_name() const;
 207   void  print_external_name(outputStream *os) const;
 208 
 209   static const char* external_name(                  Klass* klass, Symbol* method_name, Symbol* signature);
 210   static void  print_external_name(outputStream *os, Klass* klass, Symbol* method_name, Symbol* signature);
 211 
 212   Bytecodes::Code java_code_at(int bci) const {
 213     return Bytecodes::java_code_at(this, bcp_from(bci));
 214   }
 215   Bytecodes::Code code_at(int bci) const {
 216     return Bytecodes::code_at(this, bcp_from(bci));
 217   }
 218 
 219   // JVMTI breakpoints
 220 #if !INCLUDE_JVMTI
 221   Bytecodes::Code orig_bytecode_at(int bci) const {
 222     ShouldNotReachHere();
 223     return Bytecodes::_shouldnotreachhere;
 224   }
 225   void set_orig_bytecode_at(int bci, Bytecodes::Code code) {
 226     ShouldNotReachHere();
 227   };
 228   u2   number_of_breakpoints() const {return 0;}
 229 #else // !INCLUDE_JVMTI
 230   Bytecodes::Code orig_bytecode_at(int bci) const;
 231   void set_orig_bytecode_at(int bci, Bytecodes::Code code);
 232   void set_breakpoint(int bci);
 233   void clear_breakpoint(int bci);
 234   void clear_all_breakpoints();
 235   // Tracking number of breakpoints, for fullspeed debugging.
 236   // Only mutated by VM thread.
 237   u2   number_of_breakpoints()             const {
 238     MethodCounters* mcs = method_counters();
 239     if (mcs == NULL) {
 240       return 0;
 241     } else {
 242       return mcs-&gt;number_of_breakpoints();
 243     }
 244   }
 245   void incr_number_of_breakpoints(TRAPS)         {
 246     MethodCounters* mcs = get_method_counters(CHECK);
 247     if (mcs != NULL) {
 248       mcs-&gt;incr_number_of_breakpoints();
 249     }
 250   }
 251   void decr_number_of_breakpoints(TRAPS)         {
 252     MethodCounters* mcs = get_method_counters(CHECK);
 253     if (mcs != NULL) {
 254       mcs-&gt;decr_number_of_breakpoints();
 255     }
 256   }
 257   // Initialization only
 258   void clear_number_of_breakpoints()             {
 259     MethodCounters* mcs = method_counters();
 260     if (mcs != NULL) {
 261       mcs-&gt;clear_number_of_breakpoints();
 262     }
 263   }
 264 #endif // !INCLUDE_JVMTI
 265 
 266   // index into InstanceKlass methods() array
 267   // note: also used by jfr
 268   u2 method_idnum() const           { return constMethod()-&gt;method_idnum(); }
 269   void set_method_idnum(u2 idnum)   { constMethod()-&gt;set_method_idnum(idnum); }
 270 
 271   u2 orig_method_idnum() const           { return constMethod()-&gt;orig_method_idnum(); }
 272   void set_orig_method_idnum(u2 idnum)   { constMethod()-&gt;set_orig_method_idnum(idnum); }
 273 
 274   // code size
 275   int code_size() const                  { return constMethod()-&gt;code_size(); }
 276 
 277   // method size in words
 278   int method_size() const                { return sizeof(Method)/wordSize + ( is_native() ? 2 : 0 ); }
 279 
 280   // constant pool for Klass* holding this method
 281   ConstantPool* constants() const              { return constMethod()-&gt;constants(); }
 282   void set_constants(ConstantPool* c)          { constMethod()-&gt;set_constants(c); }
 283 
 284   // max stack
 285   // return original max stack size for method verification
 286   int  verifier_max_stack() const                { return constMethod()-&gt;max_stack(); }
 287   int           max_stack() const                { return constMethod()-&gt;max_stack() + extra_stack_entries(); }
 288   void      set_max_stack(int size)              {        constMethod()-&gt;set_max_stack(size); }
 289 
 290   // max locals
 291   int  max_locals() const                        { return constMethod()-&gt;max_locals(); }
 292   void set_max_locals(int size)                  { constMethod()-&gt;set_max_locals(size); }
 293 
 294   int highest_comp_level() const;
 295   void set_highest_comp_level(int level);
 296   int highest_osr_comp_level() const;
 297   void set_highest_osr_comp_level(int level);
 298 
 299 #if COMPILER2_OR_JVMCI
 300   // Count of times method was exited via exception while interpreting
 301   void interpreter_throwout_increment(TRAPS) {
 302     MethodCounters* mcs = get_method_counters(CHECK);
 303     if (mcs != NULL) {
 304       mcs-&gt;interpreter_throwout_increment();
 305     }
 306   }
 307 #endif
 308 
 309   int  interpreter_throwout_count() const        {
 310     MethodCounters* mcs = method_counters();
 311     if (mcs == NULL) {
 312       return 0;
 313     } else {
 314       return mcs-&gt;interpreter_throwout_count();
 315     }
 316   }
 317 
 318   // Derive stuff from the signature at load time.
 319   void compute_from_signature(Symbol* sig);
 320 
 321   // size of parameters (receiver if any + arguments)
 322   int  size_of_parameters() const                { return constMethod()-&gt;size_of_parameters(); }
 323   void set_size_of_parameters(int size)          { constMethod()-&gt;set_size_of_parameters(size); }
 324 
 325   bool has_stackmap_table() const {
 326     return constMethod()-&gt;has_stackmap_table();
 327   }
 328 
 329   Array&lt;u1&gt;* stackmap_data() const {
 330     return constMethod()-&gt;stackmap_data();
 331   }
 332 
 333   void set_stackmap_data(Array&lt;u1&gt;* sd) {
 334     constMethod()-&gt;set_stackmap_data(sd);
 335   }
 336 
 337   // exception handler table
 338   bool has_exception_handler() const
 339                              { return constMethod()-&gt;has_exception_handler(); }
 340   int exception_table_length() const
 341                              { return constMethod()-&gt;exception_table_length(); }
 342   ExceptionTableElement* exception_table_start() const
 343                              { return constMethod()-&gt;exception_table_start(); }
 344 
 345   // Finds the first entry point bci of an exception handler for an
 346   // exception of klass ex_klass thrown at throw_bci. A value of NULL
 347   // for ex_klass indicates that the exception klass is not known; in
 348   // this case it matches any constraint class. Returns -1 if the
 349   // exception cannot be handled in this method. The handler
 350   // constraint classes are loaded if necessary. Note that this may
 351   // throw an exception if loading of the constraint classes causes
 352   // an IllegalAccessError (bugid 4307310) or an OutOfMemoryError.
 353   // If an exception is thrown, returns the bci of the
 354   // exception handler which caused the exception to be thrown, which
 355   // is needed for proper retries. See, for example,
 356   // InterpreterRuntime::exception_handler_for_exception.
 357   static int fast_exception_handler_bci_for(const methodHandle&amp; mh, Klass* ex_klass, int throw_bci, TRAPS);
 358 
 359   static bool register_native(Klass* k,
 360                               Symbol* name,
 361                               Symbol* signature,
 362                               address entry,
 363                               TRAPS);
 364 
 365   // method data access
 366   MethodData* method_data() const              {
 367     return _method_data;
 368   }
 369 
 370   void set_method_data(MethodData* data);
 371 
 372   MethodCounters* method_counters() const {
 373     return _method_counters;
 374   }
 375 
 376   void clear_method_counters() {
 377     _method_counters = NULL;
 378   }
 379 
 380   bool init_method_counters(MethodCounters* counters);
 381 
 382 #ifdef TIERED
 383   // We are reusing interpreter_invocation_count as a holder for the previous event count!
 384   // We can do that since interpreter_invocation_count is not used in tiered.
 385   int prev_event_count() const                   {
 386     if (method_counters() == NULL) {
 387       return 0;
 388     } else {
 389       return method_counters()-&gt;interpreter_invocation_count();
 390     }
 391   }
 392   void set_prev_event_count(int count) {
 393     MethodCounters* mcs = method_counters();
 394     if (mcs != NULL) {
 395       mcs-&gt;set_interpreter_invocation_count(count);
 396     }
 397   }
 398   jlong prev_time() const                        {
 399     MethodCounters* mcs = method_counters();
 400     return mcs == NULL ? 0 : mcs-&gt;prev_time();
 401   }
 402   void set_prev_time(jlong time) {
 403     MethodCounters* mcs = method_counters();
 404     if (mcs != NULL) {
 405       mcs-&gt;set_prev_time(time);
 406     }
 407   }
 408   float rate() const                             {
 409     MethodCounters* mcs = method_counters();
 410     return mcs == NULL ? 0 : mcs-&gt;rate();
 411   }
 412   void set_rate(float rate) {
 413     MethodCounters* mcs = method_counters();
 414     if (mcs != NULL) {
 415       mcs-&gt;set_rate(rate);
 416     }
 417   }
 418 
 419 #if INCLUDE_AOT
 420   void set_aot_code(CompiledMethod* aot_code) {
 421     _aot_code = aot_code;
 422   }
 423 
 424   CompiledMethod* aot_code() const {
 425     return _aot_code;
 426   }
 427 #else
 428   CompiledMethod* aot_code() const { return NULL; }
 429 #endif // INCLUDE_AOT
 430 #endif // TIERED
 431 
 432   int nmethod_age() const {
 433     if (method_counters() == NULL) {
 434       return INT_MAX;
 435     } else {
 436       return method_counters()-&gt;nmethod_age();
 437     }
 438   }
 439 
 440   int invocation_count();
 441   int backedge_count();
 442 
 443   bool was_executed_more_than(int n);
 444   bool was_never_executed()                      { return !was_executed_more_than(0); }
 445 
 446   static void build_interpreter_method_data(const methodHandle&amp; method, TRAPS);
 447 
 448   static MethodCounters* build_method_counters(Method* m, TRAPS);
 449 
 450   int interpreter_invocation_count() {
 451     if (TieredCompilation) {
 452       return invocation_count();
 453     } else {
 454       MethodCounters* mcs = method_counters();
 455       return (mcs == NULL) ? 0 : mcs-&gt;interpreter_invocation_count();
 456     }
 457   }
 458 #if COMPILER2_OR_JVMCI
 459   int increment_interpreter_invocation_count(TRAPS) {
 460     if (TieredCompilation) ShouldNotReachHere();
 461     MethodCounters* mcs = get_method_counters(CHECK_0);
 462     return (mcs == NULL) ? 0 : mcs-&gt;increment_interpreter_invocation_count();
 463   }
 464 #endif
 465 
 466 #ifndef PRODUCT
 467   int  compiled_invocation_count() const         { return _compiled_invocation_count;  }
 468   void set_compiled_invocation_count(int count)  { _compiled_invocation_count = count; }
 469 #else
 470   // for PrintMethodData in a product build
 471   int  compiled_invocation_count() const         { return 0;  }
 472 #endif // not PRODUCT
 473 
 474   // Clear (non-shared space) pointers which could not be relevant
 475   // if this (shared) method were mapped into another JVM.
 476   void remove_unshareable_info();
 477 
 478   // nmethod/verified compiler entry
 479   address verified_code_entry();
 480   address verified_inline_code_entry();
 481   address verified_inline_ro_code_entry();
 482   bool check_code() const;      // Not inline to avoid circular ref
 483   CompiledMethod* volatile code() const;
 484 
 485   // Locks CompiledMethod_lock if not held.
 486   void unlink_code(CompiledMethod *compare);
 487   // Locks CompiledMethod_lock if not held.
 488   void unlink_code();
 489 
 490 private:
 491   // Either called with CompiledMethod_lock held or from constructor.
 492   void clear_code();
 493 
 494 public:
 495   static void set_code(const methodHandle&amp; mh, CompiledMethod* code);
 496   void set_adapter_entry(AdapterHandlerEntry* adapter) {
 497     constMethod()-&gt;set_adapter_entry(adapter);
 498   }
 499   void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {
 500     constMethod()-&gt;set_adapter_trampoline(trampoline);
 501   }
 502   void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
 503     constMethod()-&gt;update_adapter_trampoline(adapter);
 504   }
 505   void set_from_compiled_entry(address entry) {
 506     _from_compiled_entry = entry;
 507   }
 508   void set_from_compiled_inline_ro_entry(address entry) {
 509     _from_compiled_inline_ro_entry = entry;
 510   }
 511   void set_from_compiled_inline_entry(address entry) {
 512     _from_compiled_inline_entry = entry;
 513   }
 514 
 515   address get_i2c_entry();
 516   address get_c2i_entry();
 517   address get_c2i_inline_entry();
 518   address get_c2i_unverified_entry();
 519   address get_c2i_unverified_inline_entry();
 520   address get_c2i_no_clinit_check_entry();
 521   AdapterHandlerEntry* adapter() const {
 522     return constMethod()-&gt;adapter();
 523   }
 524   // setup entry points
 525   void link_method(const methodHandle&amp; method, TRAPS);
 526   // clear entry points. Used by sharing code during dump time
 527   void unlink_method() NOT_CDS_RETURN;
 528 
 529   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 530   virtual MetaspaceObj::Type type() const { return MethodType; }
 531 
 532   // vtable index
 533   enum VtableIndexFlag {
 534     // Valid vtable indexes are non-negative (&gt;= 0).
 535     // These few negative values are used as sentinels.
 536     itable_index_max        = -10, // first itable index, growing downward
 537     pending_itable_index    = -9,  // itable index will be assigned
 538     invalid_vtable_index    = -4,  // distinct from any valid vtable index
 539     garbage_vtable_index    = -3,  // not yet linked; no vtable layout yet
 540     nonvirtual_vtable_index = -2   // there is no need for vtable dispatch
 541     // 6330203 Note:  Do not use -1, which was overloaded with many meanings.
 542   };
 543   DEBUG_ONLY(bool valid_vtable_index() const     { return _vtable_index &gt;= nonvirtual_vtable_index; })
 544   bool has_vtable_index() const                  { return _vtable_index &gt;= 0; }
 545   int  vtable_index() const                      { return _vtable_index; }
 546   void set_vtable_index(int index);
 547   DEBUG_ONLY(bool valid_itable_index() const     { return _vtable_index &lt;= pending_itable_index; })
 548   bool has_itable_index() const                  { return _vtable_index &lt;= itable_index_max; }
 549   int  itable_index() const                      { assert(valid_itable_index(), &quot;&quot;);
 550                                                    return itable_index_max - _vtable_index; }
 551   void set_itable_index(int index);
 552 
 553   // interpreter entry
 554   address interpreter_entry() const              { return _i2i_entry; }
 555   // Only used when first initialize so we can set _i2i_entry and _from_interpreted_entry
 556   void set_interpreter_entry(address entry) {
 557     assert(!is_shared(),
 558            &quot;shared method&#39;s interpreter entry should not be changed at run time&quot;);
 559     if (_i2i_entry != entry) {
 560       _i2i_entry = entry;
 561     }
 562     if (_from_interpreted_entry != entry) {
 563       _from_interpreted_entry = entry;
 564     }
 565   }
 566 
 567   // native function (used for native methods only)
 568   enum {
 569     native_bind_event_is_interesting = true
 570   };
 571   address native_function() const                { return *(native_function_addr()); }
 572 
 573   // Must specify a real function (not NULL).
 574   // Use clear_native_function() to unregister.
 575   void set_native_function(address function, bool post_event_flag);
 576   bool has_native_function() const;
 577   void clear_native_function();
 578 
 579   // signature handler (used for native methods only)
 580   address signature_handler() const              { return *(signature_handler_addr()); }
 581   void set_signature_handler(address handler);
 582 
 583   // Interpreter oopmap support
 584   void mask_for(int bci, InterpreterOopMap* mask);
 585 
 586   // operations on invocation counter
 587   void print_invocation_count();
 588 
 589   // byte codes
 590   void    set_code(address code)      { return constMethod()-&gt;set_code(code); }
 591   address code_base() const           { return constMethod()-&gt;code_base(); }
 592   bool    contains(address bcp) const { return constMethod()-&gt;contains(bcp); }
 593 
 594   // prints byte codes
 595   void print_codes() const            { print_codes_on(tty); }
 596   void print_codes_on(outputStream* st) const;
 597   void print_codes_on(int from, int to, outputStream* st) const;
 598 
 599   // method parameters
 600   bool has_method_parameters() const
 601                          { return constMethod()-&gt;has_method_parameters(); }
 602   int method_parameters_length() const
 603                          { return constMethod()-&gt;method_parameters_length(); }
 604   MethodParametersElement* method_parameters_start() const
 605                           { return constMethod()-&gt;method_parameters_start(); }
 606 
 607   // checked exceptions
 608   int checked_exceptions_length() const
 609                          { return constMethod()-&gt;checked_exceptions_length(); }
 610   CheckedExceptionElement* checked_exceptions_start() const
 611                           { return constMethod()-&gt;checked_exceptions_start(); }
 612 
 613   // localvariable table
 614   bool has_localvariable_table() const
 615                           { return constMethod()-&gt;has_localvariable_table(); }
 616   int localvariable_table_length() const
 617                         { return constMethod()-&gt;localvariable_table_length(); }
 618   LocalVariableTableElement* localvariable_table_start() const
 619                          { return constMethod()-&gt;localvariable_table_start(); }
 620 
 621   bool has_linenumber_table() const
 622                               { return constMethod()-&gt;has_linenumber_table(); }
 623   u_char* compressed_linenumber_table() const
 624                        { return constMethod()-&gt;compressed_linenumber_table(); }
 625 
 626   // method holder (the Klass* holding this method)
 627   InstanceKlass* method_holder() const         { return constants()-&gt;pool_holder(); }
 628 
 629   Symbol* klass_name() const;                    // returns the name of the method holder
 630   BasicType result_type() const                  { return constMethod()-&gt;result_type(); }
 631   bool is_returning_oop() const                  { BasicType r = result_type(); return is_reference_type(r); }
 632   InlineKlass* returned_inline_type(Thread* thread) const;
 633 
 634   // Checked exceptions thrown by this method (resolved to mirrors)
 635   objArrayHandle resolved_checked_exceptions(TRAPS) { return resolved_checked_exceptions_impl(this, THREAD); }
 636 
 637   // Access flags
 638   bool is_public() const                         { return access_flags().is_public();      }
 639   bool is_private() const                        { return access_flags().is_private();     }
 640   bool is_protected() const                      { return access_flags().is_protected();   }
 641   bool is_package_private() const                { return !is_public() &amp;&amp; !is_private() &amp;&amp; !is_protected(); }
 642   bool is_static() const                         { return access_flags().is_static();      }
 643   bool is_final() const                          { return access_flags().is_final();       }
 644   bool is_synchronized() const                   { return access_flags().is_synchronized();}
 645   bool is_native() const                         { return access_flags().is_native();      }
 646   bool is_abstract() const                       { return access_flags().is_abstract();    }
 647   bool is_strict() const                         { return access_flags().is_strict();      }
 648   bool is_synthetic() const                      { return access_flags().is_synthetic();   }
 649 
 650   // returns true if contains only return operation
 651   bool is_empty_method() const;
 652 
 653   // returns true if this is a vanilla constructor
 654   bool is_vanilla_constructor() const;
 655 
 656   // checks method and its method holder
 657   bool is_final_method() const;
 658   bool is_final_method(AccessFlags class_access_flags) const;
 659   // interface method declared with &#39;default&#39; - excludes private interface methods
 660   bool is_default_method() const;
 661 
 662   // true if method needs no dynamic dispatch (final and/or no vtable entry)
 663   bool can_be_statically_bound() const;
 664   bool can_be_statically_bound(InstanceKlass* context) const;
 665   bool can_be_statically_bound(AccessFlags class_access_flags) const;
 666 
 667   // returns true if the method has any backward branches.
 668   bool has_loops() {
 669     return access_flags().loops_flag_init() ? access_flags().has_loops() : compute_has_loops_flag();
 670   };
 671 
 672   bool compute_has_loops_flag();
 673 
 674   bool has_jsrs() {
 675     return access_flags().has_jsrs();
 676   };
 677   void set_has_jsrs() {
 678     _access_flags.set_has_jsrs();
 679   }
 680 
 681   // returns true if the method has any monitors.
 682   bool has_monitors() const                      { return is_synchronized() || access_flags().has_monitor_bytecodes(); }
 683   bool has_monitor_bytecodes() const             { return access_flags().has_monitor_bytecodes(); }
 684 
 685   void set_has_monitor_bytecodes()               { _access_flags.set_has_monitor_bytecodes(); }
 686 
 687   // monitor matching. This returns a conservative estimate of whether the monitorenter/monitorexit bytecodes
 688   // propererly nest in the method. It might return false, even though they actually nest properly, since the info.
 689   // has not been computed yet.
 690   bool guaranteed_monitor_matching() const       { return access_flags().is_monitor_matching(); }
 691   void set_guaranteed_monitor_matching()         { _access_flags.set_monitor_matching(); }
 692 
 693   // returns true if the method is an accessor function (setter/getter).
 694   bool is_accessor() const;
 695 
 696   // returns true if the method is a getter
 697   bool is_getter() const;
 698 
 699   // returns true if the method is a setter
 700   bool is_setter() const;
 701 
 702   // returns true if the method does nothing but return a constant of primitive type
 703   bool is_constant_getter() const;
 704 
 705   // returns true if the method name is &lt;clinit&gt; and the method has
 706   // valid static initializer flags.
 707   bool is_class_initializer() const;
 708 
 709   // returns true if the method name is &lt;init&gt; and the method is not a static factory
 710   bool is_object_constructor() const;
 711 
 712   // returns true if the method is an object constructor or class initializer
 713   // (non-static &lt;init&gt; or &lt;clinit&gt;), but false for factories (static &lt;init&gt;).
 714   bool is_object_constructor_or_class_initializer() const;
 715 
 716   // returns true if the method name is &lt;init&gt; and the method is static
 717   bool is_static_init_factory() const;
 718 
 719   // compiled code support
 720   // NOTE: code() is inherently racy as deopt can be clearing code
 721   // simultaneously. Use with caution.
 722   bool has_compiled_code() const;
 723 
 724 #ifdef TIERED
 725   bool has_aot_code() const                      { return aot_code() != NULL; }
 726 #endif
 727 
 728   bool needs_clinit_barrier() const;
 729 
 730   // sizing
 731   static int header_size()                       {
 732     return align_up((int)sizeof(Method), wordSize) / wordSize;
 733   }
 734   static int size(bool is_native);
 735   int size() const                               { return method_size(); }
 736   void log_touched(TRAPS);
 737   static void print_touched_methods(outputStream* out);
 738 
 739   // interpreter support
 740   static ByteSize const_offset()                 { return byte_offset_of(Method, _constMethod       ); }
 741   static ByteSize access_flags_offset()          { return byte_offset_of(Method, _access_flags      ); }
 742   static ByteSize from_compiled_offset()         { return byte_offset_of(Method, _from_compiled_entry); }
 743   static ByteSize from_compiled_inline_offset()  { return byte_offset_of(Method, _from_compiled_inline_entry); }
 744   static ByteSize from_compiled_inline_ro_offset(){ return byte_offset_of(Method, _from_compiled_inline_ro_entry); }
 745   static ByteSize code_offset()                  { return byte_offset_of(Method, _code); }
 746   static ByteSize flags_offset()                 { return byte_offset_of(Method, _flags); }
 747   static ByteSize method_data_offset()           {
 748     return byte_offset_of(Method, _method_data);
 749   }
 750   static ByteSize method_counters_offset()       {
 751     return byte_offset_of(Method, _method_counters);
 752   }
 753 #ifndef PRODUCT
 754   static ByteSize compiled_invocation_counter_offset() { return byte_offset_of(Method, _compiled_invocation_count); }
 755 #endif // not PRODUCT
 756   static ByteSize native_function_offset()       { return in_ByteSize(sizeof(Method));                 }
 757   static ByteSize from_interpreted_offset()      { return byte_offset_of(Method, _from_interpreted_entry ); }
 758   static ByteSize interpreter_entry_offset()     { return byte_offset_of(Method, _i2i_entry ); }
 759   static ByteSize signature_handler_offset()     { return in_ByteSize(sizeof(Method) + wordSize);      }
 760   static ByteSize itable_index_offset()          { return byte_offset_of(Method, _vtable_index ); }
 761 
 762   // for code generation
 763   static int method_data_offset_in_bytes()       { return offset_of(Method, _method_data); }
 764   static int intrinsic_id_offset_in_bytes()      { return offset_of(Method, _intrinsic_id); }
 765   static int intrinsic_id_size_in_bytes()        { return sizeof(u2); }
 766 
 767   static ByteSize max_vt_buffer_offset()         { return byte_offset_of(Method, _max_vt_buffer); }
 768 
 769   // Static methods that are used to implement member methods where an exposed this pointer
 770   // is needed due to possible GCs
 771   static objArrayHandle resolved_checked_exceptions_impl(Method* method, TRAPS);
 772 
 773   // Returns the byte code index from the byte code pointer
 774   int     bci_from(address bcp) const;
 775   address bcp_from(int bci) const;
 776   address bcp_from(address bcp) const;
 777   int validate_bci_from_bcp(address bcp) const;
 778   int validate_bci(int bci) const;
 779 
 780   // Returns the line number for a bci if debugging information for the method is prowided,
 781   // -1 is returned otherwise.
 782   int line_number_from_bci(int bci) const;
 783 
 784   // Reflection support
 785   bool is_overridden_in(Klass* k) const;
 786 
 787   // Stack walking support
 788   bool is_ignored_by_security_stack_walk() const;
 789 
 790   // JSR 292 support
 791   bool is_method_handle_intrinsic() const;          // MethodHandles::is_signature_polymorphic_intrinsic(intrinsic_id)
 792   bool is_compiled_lambda_form() const;             // intrinsic_id() == vmIntrinsics::_compiledLambdaForm
 793   bool has_member_arg() const;                      // intrinsic_id() == vmIntrinsics::_linkToSpecial, etc.
 794   static methodHandle make_method_handle_intrinsic(vmIntrinsics::ID iid, // _invokeBasic, _linkToVirtual
 795                                                    Symbol* signature, //anything at all
 796                                                    TRAPS);
 797   static Klass* check_non_bcp_klass(Klass* klass);
 798 
 799   enum {
 800     // How many extra stack entries for invokedynamic
 801     extra_stack_entries_for_jsr292 = 1
 802   };
 803 
 804   // this operates only on invoke methods:
 805   // presize interpreter frames for extra interpreter stack entries, if needed
 806   // Account for the extra appendix argument for invokehandle/invokedynamic
 807   static int extra_stack_entries() { return extra_stack_entries_for_jsr292; }
 808   static int extra_stack_words();  // = extra_stack_entries() * Interpreter::stackElementSize
 809 
 810   // RedefineClasses() support:
 811   bool is_old() const                               { return access_flags().is_old(); }
 812   void set_is_old()                                 { _access_flags.set_is_old(); }
 813   bool is_obsolete() const                          { return access_flags().is_obsolete(); }
 814   void set_is_obsolete()                            { _access_flags.set_is_obsolete(); }
 815   bool is_deleted() const                           { return access_flags().is_deleted(); }
 816   void set_is_deleted()                             { _access_flags.set_is_deleted(); }
 817 
 818   bool is_running_emcp() const {
 819     // EMCP methods are old but not obsolete or deleted. Equivalent
 820     // Modulo Constant Pool means the method is equivalent except
 821     // the constant pool and instructions that access the constant
 822     // pool might be different.
 823     // If a breakpoint is set in a redefined method, its EMCP methods that are
 824     // still running must have a breakpoint also.
 825     return (_flags &amp; _running_emcp) != 0;
 826   }
 827 
 828   void set_running_emcp(bool x) {
 829     _flags = x ? (_flags | _running_emcp) : (_flags &amp; ~_running_emcp);
 830   }
 831 
 832   bool on_stack() const                             { return access_flags().on_stack(); }
 833   void set_on_stack(const bool value);
 834 
 835   // see the definition in Method*.cpp for the gory details
 836   bool should_not_be_cached() const;
 837 
 838   // JVMTI Native method prefixing support:
 839   bool is_prefixed_native() const                   { return access_flags().is_prefixed_native(); }
 840   void set_is_prefixed_native()                     { _access_flags.set_is_prefixed_native(); }
 841 
 842   // Rewriting support
 843   static methodHandle clone_with_new_data(const methodHandle&amp; m, u_char* new_code, int new_code_length,
 844                                           u_char* new_compressed_linenumber_table, int new_compressed_linenumber_size, TRAPS);
 845 
 846   // jmethodID handling
 847   // Because the useful life-span of a jmethodID cannot be determined,
 848   // once created they are never reclaimed.  The methods to which they refer,
 849   // however, can be GC&#39;ed away if the class is unloaded or if the method is
 850   // made obsolete or deleted -- in these cases, the jmethodID
 851   // refers to NULL (as is the case for any weak reference).
 852   static jmethodID make_jmethod_id(ClassLoaderData* loader_data, Method* mh);
 853   static void destroy_jmethod_id(ClassLoaderData* loader_data, jmethodID mid);
 854 
 855   // Ensure there is enough capacity in the internal tracking data
 856   // structures to hold the number of jmethodIDs you plan to generate.
 857   // This saves substantial time doing allocations.
 858   static void ensure_jmethod_ids(ClassLoaderData* loader_data, int capacity);
 859 
 860   // Use resolve_jmethod_id() in situations where the caller is expected
 861   // to provide a valid jmethodID; the only sanity checks are in asserts;
 862   // result guaranteed not to be NULL.
 863   inline static Method* resolve_jmethod_id(jmethodID mid) {
 864     assert(mid != NULL, &quot;JNI method id should not be null&quot;);
 865     return *((Method**)mid);
 866   }
 867 
 868   // Use checked_resolve_jmethod_id() in situations where the caller
 869   // should provide a valid jmethodID, but might not. NULL is returned
 870   // when the jmethodID does not refer to a valid method.
 871   static Method* checked_resolve_jmethod_id(jmethodID mid);
 872 
 873   static void change_method_associated_with_jmethod_id(jmethodID old_jmid_ptr, Method* new_method);
 874   static bool is_method_id(jmethodID mid);
 875 
 876   // Clear methods
 877   static void clear_jmethod_ids(ClassLoaderData* loader_data);
 878   static void print_jmethod_ids(const ClassLoaderData* loader_data, outputStream* out) PRODUCT_RETURN;
 879 
 880   // Get this method&#39;s jmethodID -- allocate if it doesn&#39;t exist
 881   jmethodID jmethod_id();
 882 
 883   // Lookup the jmethodID for this method.  Return NULL if not found.
 884   // NOTE that this function can be called from a signal handler
 885   // (see AsyncGetCallTrace support for Forte Analyzer) and this
 886   // needs to be async-safe. No allocation should be done and
 887   // so handles are not used to avoid deadlock.
 888   jmethodID find_jmethod_id_or_null()               { return method_holder()-&gt;jmethod_id_or_null(this); }
 889 
 890   // Support for inlining of intrinsic methods
 891   vmIntrinsics::ID intrinsic_id() const          { return (vmIntrinsics::ID) _intrinsic_id;           }
 892   void     set_intrinsic_id(vmIntrinsics::ID id) {                           _intrinsic_id = (u2) id; }
 893 
 894   // Helper routines for intrinsic_id() and vmIntrinsics::method().
 895   void init_intrinsic_id();     // updates from _none if a match
 896   static vmSymbols::SID klass_id_for_intrinsics(const Klass* holder);
 897 
 898   bool caller_sensitive() {
 899     return (_flags &amp; _caller_sensitive) != 0;
 900   }
 901   void set_caller_sensitive(bool x) {
 902     _flags = x ? (_flags | _caller_sensitive) : (_flags &amp; ~_caller_sensitive);
 903   }
 904 
 905   bool force_inline() {
 906     return (_flags &amp; _force_inline) != 0;
 907   }
 908   void set_force_inline(bool x) {
 909     _flags = x ? (_flags | _force_inline) : (_flags &amp; ~_force_inline);
 910   }
 911 
 912   bool dont_inline() {
 913     return (_flags &amp; _dont_inline) != 0;
 914   }
 915   void set_dont_inline(bool x) {
 916     _flags = x ? (_flags | _dont_inline) : (_flags &amp; ~_dont_inline);
 917   }
 918 
 919   bool is_hidden() const {
 920     return (_flags &amp; _hidden) != 0;
 921   }
 922 
 923   void set_hidden(bool x) {
 924     _flags = x ? (_flags | _hidden) : (_flags &amp; ~_hidden);
 925   }
 926 
 927   bool intrinsic_candidate() {
 928     return (_flags &amp; _intrinsic_candidate) != 0;
 929   }
 930   void set_intrinsic_candidate(bool x) {
 931     _flags = x ? (_flags | _intrinsic_candidate) : (_flags &amp; ~_intrinsic_candidate);
 932   }
 933 
 934   bool has_injected_profile() {
 935     return (_flags &amp; _has_injected_profile) != 0;
 936   }
 937   void set_has_injected_profile(bool x) {
 938     _flags = x ? (_flags | _has_injected_profile) : (_flags &amp; ~_has_injected_profile);
 939   }
 940 
 941   bool has_reserved_stack_access() {
 942     return (_flags &amp; _reserved_stack_access) != 0;
 943   }
 944 
 945   void set_has_reserved_stack_access(bool x) {
 946     _flags = x ? (_flags | _reserved_stack_access) : (_flags &amp; ~_reserved_stack_access);
 947   }
 948 
 949   bool has_scalarized_args() {
 950     return (_flags &amp; _scalarized_args) != 0;
 951   }
 952 
 953   void set_has_scalarized_args(bool x) {
 954     _flags = x ? (_flags | _scalarized_args) : (_flags &amp; ~_scalarized_args);
 955   }
 956 
 957   bool c1_needs_stack_repair() {
 958     return (_flags &amp; _c1_needs_stack_repair) != 0;
 959   }
 960 
 961   bool c2_needs_stack_repair() {
 962     return (_flags &amp; _c2_needs_stack_repair) != 0;
 963   }
 964 
 965   void set_c1_needs_stack_repair(bool x) {
 966     _flags = x ? (_flags | _c1_needs_stack_repair) : (_flags &amp; ~_c1_needs_stack_repair);
 967   }
 968 
 969   void set_c2_needs_stack_repair(bool x) {
 970     _flags = x ? (_flags | _c2_needs_stack_repair) : (_flags &amp; ~_c2_needs_stack_repair);
 971   }
 972 
 973   JFR_ONLY(DEFINE_TRACE_FLAG_ACCESSOR;)
 974 
 975   ConstMethod::MethodType method_type() const {
 976       return _constMethod-&gt;method_type();
 977   }
 978   bool is_overpass() const { return method_type() == ConstMethod::OVERPASS; }
 979 
 980   // On-stack replacement support
 981   bool has_osr_nmethod(int level, bool match_level) {
 982    return method_holder()-&gt;lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != NULL;
 983   }
 984 
 985   int mark_osr_nmethods() {
 986     return method_holder()-&gt;mark_osr_nmethods(this);
 987   }
 988 
 989   nmethod* lookup_osr_nmethod_for(int bci, int level, bool match_level) {
 990     return method_holder()-&gt;lookup_osr_nmethod(this, bci, level, match_level);
 991   }
 992 
 993   // Find if klass for method is loaded
 994   bool is_klass_loaded_by_klass_index(int klass_index) const;
 995   bool is_klass_loaded(int refinfo_index, bool must_be_resolved = false) const;
 996 
 997   // Indicates whether compilation failed earlier for this method, or
 998   // whether it is not compilable for another reason like having a
 999   // breakpoint set in it.
1000   bool  is_not_compilable(int comp_level = CompLevel_any) const;
1001   void set_not_compilable(const char* reason, int comp_level = CompLevel_all, bool report = true);
1002   void set_not_compilable_quietly(const char* reason, int comp_level = CompLevel_all) {
1003     set_not_compilable(reason, comp_level, false);
1004   }
1005   bool  is_not_osr_compilable(int comp_level = CompLevel_any) const;
1006   void set_not_osr_compilable(const char* reason, int comp_level = CompLevel_all, bool report = true);
1007   void set_not_osr_compilable_quietly(const char* reason, int comp_level = CompLevel_all) {
1008     set_not_osr_compilable(reason, comp_level, false);
1009   }
1010   bool is_always_compilable() const;
1011 
1012  private:
1013   void print_made_not_compilable(int comp_level, bool is_osr, bool report, const char* reason);
1014 
1015  public:
1016   MethodCounters* get_method_counters(TRAPS) {
1017     if (_method_counters == NULL) {
1018       build_method_counters(this, CHECK_AND_CLEAR_NULL);
1019     }
1020     return _method_counters;
1021   }
1022 
1023   bool   is_not_c1_compilable() const         { return access_flags().is_not_c1_compilable();  }
1024   void  set_not_c1_compilable()               {       _access_flags.set_not_c1_compilable();   }
1025   void clear_not_c1_compilable()              {       _access_flags.clear_not_c1_compilable(); }
1026   bool   is_not_c2_compilable() const         { return access_flags().is_not_c2_compilable();  }
1027   void  set_not_c2_compilable()               {       _access_flags.set_not_c2_compilable();   }
1028   void clear_not_c2_compilable()              {       _access_flags.clear_not_c2_compilable(); }
1029 
1030   bool    is_not_c1_osr_compilable() const    { return is_not_c1_compilable(); }  // don&#39;t waste an accessFlags bit
1031   void   set_not_c1_osr_compilable()          {       set_not_c1_compilable(); }  // don&#39;t waste an accessFlags bit
1032   void clear_not_c1_osr_compilable()          {     clear_not_c1_compilable(); }  // don&#39;t waste an accessFlags bit
1033   bool   is_not_c2_osr_compilable() const     { return access_flags().is_not_c2_osr_compilable();  }
1034   void  set_not_c2_osr_compilable()           {       _access_flags.set_not_c2_osr_compilable();   }
1035   void clear_not_c2_osr_compilable()          {       _access_flags.clear_not_c2_osr_compilable(); }
1036 
1037   // Background compilation support
1038   bool queued_for_compilation() const  { return access_flags().queued_for_compilation(); }
1039   void set_queued_for_compilation()    { _access_flags.set_queued_for_compilation();     }
1040   void clear_queued_for_compilation()  { _access_flags.clear_queued_for_compilation();   }
1041 
1042   // Resolve all classes in signature, return &#39;true&#39; if successful
1043   static bool load_signature_classes(const methodHandle&amp; m, TRAPS);
1044 
1045   // Return if true if not all classes references in signature, including return type, has been loaded
1046   static bool has_unloaded_classes_in_signature(const methodHandle&amp; m, TRAPS);
1047 
1048   // Printing
1049   void print_short_name(outputStream* st = tty); // prints as klassname::methodname; Exposed so field engineers can debug VM
1050 #if INCLUDE_JVMTI
1051   void print_name(outputStream* st = tty); // prints as &quot;virtual void foo(int)&quot;; exposed for TraceRedefineClasses
1052 #else
1053   void print_name(outputStream* st = tty)        PRODUCT_RETURN; // prints as &quot;virtual void foo(int)&quot;
1054 #endif
1055 
1056   typedef int (*method_comparator_func)(Method* a, Method* b);
1057 
1058   // Helper routine used for method sorting
1059   static void sort_methods(Array&lt;Method*&gt;* methods, bool set_idnums = true, method_comparator_func func = NULL);
1060 
1061   // Deallocation function for redefine classes or if an error occurs
1062   void deallocate_contents(ClassLoaderData* loader_data);
1063 
1064   void release_C_heap_structures();
1065 
1066   Method* get_new_method() const {
1067     InstanceKlass* holder = method_holder();
1068     Method* new_method = holder-&gt;method_with_idnum(orig_method_idnum());
1069 
1070     assert(new_method != NULL, &quot;method_with_idnum() should not be NULL&quot;);
1071     assert(this != new_method, &quot;sanity check&quot;);
1072     return new_method;
1073   }
1074 
1075   // Printing
1076 #ifndef PRODUCT
1077   void print_on(outputStream* st) const;
1078 #endif
1079   void print_value_on(outputStream* st) const;
1080   void print_linkage_flags(outputStream* st) PRODUCT_RETURN;
1081 
1082   const char* internal_name() const { return &quot;{method}&quot;; }
1083 
1084   // Check for valid method pointer
1085   static bool has_method_vptr(const void* ptr);
1086   static bool is_valid_method(const Method* m);
1087 
1088   // Verify
1089   void verify() { verify_on(tty); }
1090   void verify_on(outputStream* st);
1091 
1092  private:
1093 
1094   // Inlined elements
1095   address* native_function_addr() const          { assert(is_native(), &quot;must be native&quot;); return (address*) (this+1); }
1096   address* signature_handler_addr() const        { return native_function_addr() + 1; }
1097 };
1098 
1099 
1100 // Utility class for compressing line number tables
1101 
1102 class CompressedLineNumberWriteStream: public CompressedWriteStream {
1103  private:
1104   int _bci;
1105   int _line;
1106  public:
1107   // Constructor
1108   CompressedLineNumberWriteStream(int initial_size) : CompressedWriteStream(initial_size), _bci(0), _line(0) {}
1109   CompressedLineNumberWriteStream(u_char* buffer, int initial_size) : CompressedWriteStream(buffer, initial_size), _bci(0), _line(0) {}
1110 
1111   // Write (bci, line number) pair to stream
1112   void write_pair_regular(int bci_delta, int line_delta);
1113 
1114   // If (bci delta, line delta) fits in (5-bit unsigned, 3-bit unsigned)
1115   // we save it as one byte, otherwise we write a 0xFF escape character
1116   // and use regular compression. 0x0 is used as end-of-stream terminator.
1117   void write_pair_inline(int bci, int line);
1118 
1119   void write_pair(int bci, int line);
1120 
1121   // Write end-of-stream marker
1122   void write_terminator()                        { write_byte(0); }
1123 };
1124 
1125 
1126 // Utility class for decompressing line number tables
1127 
1128 class CompressedLineNumberReadStream: public CompressedReadStream {
1129  private:
1130   int _bci;
1131   int _line;
1132  public:
1133   // Constructor
1134   CompressedLineNumberReadStream(u_char* buffer);
1135   // Read (bci, line number) pair from stream. Returns false at end-of-stream.
1136   bool read_pair();
1137   // Accessing bci and line number (after calling read_pair)
1138   int bci() const                               { return _bci; }
1139   int line() const                              { return _line; }
1140 };
1141 
1142 
1143 #if INCLUDE_JVMTI
1144 
1145 /// Fast Breakpoints.
1146 
1147 // If this structure gets more complicated (because bpts get numerous),
1148 // move it into its own header.
1149 
1150 // There is presently no provision for concurrent access
1151 // to breakpoint lists, which is only OK for JVMTI because
1152 // breakpoints are written only at safepoints, and are read
1153 // concurrently only outside of safepoints.
1154 
1155 class BreakpointInfo : public CHeapObj&lt;mtClass&gt; {
1156   friend class VMStructs;
1157  private:
1158   Bytecodes::Code  _orig_bytecode;
1159   int              _bci;
1160   u2               _name_index;       // of method
1161   u2               _signature_index;  // of method
1162   BreakpointInfo*  _next;             // simple storage allocation
1163 
1164  public:
1165   BreakpointInfo(Method* m, int bci);
1166 
1167   // accessors
1168   Bytecodes::Code orig_bytecode()                     { return _orig_bytecode; }
1169   void        set_orig_bytecode(Bytecodes::Code code) { _orig_bytecode = code; }
1170   int         bci()                                   { return _bci; }
1171 
1172   BreakpointInfo*          next() const               { return _next; }
1173   void                 set_next(BreakpointInfo* n)    { _next = n; }
1174 
1175   // helps for searchers
1176   bool match(const Method* m, int bci) {
1177     return bci == _bci &amp;&amp; match(m);
1178   }
1179 
1180   bool match(const Method* m) {
1181     return _name_index == m-&gt;name_index() &amp;&amp;
1182       _signature_index == m-&gt;signature_index();
1183   }
1184 
1185   void set(Method* method);
1186   void clear(Method* method);
1187 };
1188 
1189 #endif // INCLUDE_JVMTI
1190 
1191 // Utility class for access exception handlers
1192 class ExceptionTable : public StackObj {
1193  private:
1194   ExceptionTableElement* _table;
1195   u2  _length;
1196 
1197  public:
1198   ExceptionTable(const Method* m) {
1199     if (m-&gt;has_exception_handler()) {
1200       _table = m-&gt;exception_table_start();
1201       _length = m-&gt;exception_table_length();
1202     } else {
1203       _table = NULL;
1204       _length = 0;
1205     }
1206   }
1207 
1208   int length() const {
1209     return _length;
1210   }
1211 
1212   u2 start_pc(int idx) const {
1213     assert(idx &lt; _length, &quot;out of bounds&quot;);
1214     return _table[idx].start_pc;
1215   }
1216 
1217   void set_start_pc(int idx, u2 value) {
1218     assert(idx &lt; _length, &quot;out of bounds&quot;);
1219     _table[idx].start_pc = value;
1220   }
1221 
1222   u2 end_pc(int idx) const {
1223     assert(idx &lt; _length, &quot;out of bounds&quot;);
1224     return _table[idx].end_pc;
1225   }
1226 
1227   void set_end_pc(int idx, u2 value) {
1228     assert(idx &lt; _length, &quot;out of bounds&quot;);
1229     _table[idx].end_pc = value;
1230   }
1231 
1232   u2 handler_pc(int idx) const {
1233     assert(idx &lt; _length, &quot;out of bounds&quot;);
1234     return _table[idx].handler_pc;
1235   }
1236 
1237   void set_handler_pc(int idx, u2 value) {
1238     assert(idx &lt; _length, &quot;out of bounds&quot;);
1239     _table[idx].handler_pc = value;
1240   }
1241 
1242   u2 catch_type_index(int idx) const {
1243     assert(idx &lt; _length, &quot;out of bounds&quot;);
1244     return _table[idx].catch_type_index;
1245   }
1246 
1247   void set_catch_type_index(int idx, u2 value) {
1248     assert(idx &lt; _length, &quot;out of bounds&quot;);
1249     _table[idx].catch_type_index = value;
1250   }
1251 };
1252 
1253 #endif // SHARE_OOPS_METHOD_HPP
    </pre>
  </body>
</html>
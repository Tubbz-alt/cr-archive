<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/machnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_MACHNODE_HPP
  26 #define SHARE_OPTO_MACHNODE_HPP
  27 
  28 #include &quot;opto/callnode.hpp&quot;
  29 #include &quot;opto/constantTable.hpp&quot;
  30 #include &quot;opto/matcher.hpp&quot;
  31 #include &quot;opto/multnode.hpp&quot;
  32 #include &quot;opto/node.hpp&quot;
  33 #include &quot;opto/regmask.hpp&quot;
  34 
  35 class BiasedLockingCounters;
  36 class BufferBlob;
  37 class CodeBuffer;
  38 class JVMState;
  39 class MachCallDynamicJavaNode;
  40 class MachCallJavaNode;
  41 class MachCallLeafNode;
  42 class MachCallNode;
  43 class MachCallRuntimeNode;
  44 class MachCallStaticJavaNode;
  45 class MachEpilogNode;
  46 class MachIfNode;
  47 class MachNullCheckNode;
  48 class MachOper;
  49 class MachProjNode;
  50 class MachPrologNode;
  51 class MachReturnNode;
  52 class MachSafePointNode;
  53 class MachSpillCopyNode;
  54 class MachVEPNode;
  55 class Matcher;
  56 class PhaseRegAlloc;
  57 class RegMask;
  58 class RTMLockingCounters;
  59 class State;
  60 
  61 //---------------------------MachOper------------------------------------------
  62 class MachOper : public ResourceObj {
  63 public:
  64   // Allocate right next to the MachNodes in the same arena
  65   void *operator new(size_t x) throw() {
  66     Compile* C = Compile::current();
  67     return C-&gt;node_arena()-&gt;Amalloc_D(x);
  68   }
  69 
  70   // Opcode
  71   virtual uint opcode() const = 0;
  72 
  73   // Number of input edges.
  74   // Generally at least 1
  75   virtual uint num_edges() const { return 1; }
  76   // Array of Register masks
  77   virtual const RegMask *in_RegMask(int index) const;
  78 
  79   // Methods to output the encoding of the operand
  80 
  81   // Negate conditional branches.  Error for non-branch Nodes
  82   virtual void negate();
  83 
  84   // Return the value requested
  85   // result register lookup, corresponding to int_format
  86   virtual int  reg(PhaseRegAlloc *ra_, const Node *node)   const;
  87   // input register lookup, corresponding to ext_format
  88   virtual int  reg(PhaseRegAlloc *ra_, const Node *node, int idx)   const;
  89 
  90   // helpers for MacroAssembler generation from ADLC
  91   Register  as_Register(PhaseRegAlloc *ra_, const Node *node)   const {
  92     return ::as_Register(reg(ra_, node));
  93   }
  94   Register  as_Register(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
  95     return ::as_Register(reg(ra_, node, idx));
  96   }
  97   FloatRegister  as_FloatRegister(PhaseRegAlloc *ra_, const Node *node)   const {
  98     return ::as_FloatRegister(reg(ra_, node));
  99   }
 100   FloatRegister  as_FloatRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
 101     return ::as_FloatRegister(reg(ra_, node, idx));
 102   }
 103 
 104 #if defined(IA32) || defined(AMD64)
 105   XMMRegister  as_XMMRegister(PhaseRegAlloc *ra_, const Node *node)   const {
 106     return ::as_XMMRegister(reg(ra_, node));
 107   }
 108   XMMRegister  as_XMMRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
 109     return ::as_XMMRegister(reg(ra_, node, idx));
 110   }
 111 #endif
 112   // CondRegister reg converter
 113 #if defined(PPC64)
 114   ConditionRegister as_ConditionRegister(PhaseRegAlloc *ra_, const Node *node) const {
 115     return ::as_ConditionRegister(reg(ra_, node));
 116   }
 117   ConditionRegister as_ConditionRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 118     return ::as_ConditionRegister(reg(ra_, node, idx));
 119   }
 120   VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node) const {
 121     return ::as_VectorRegister(reg(ra_, node));
 122   }
 123   VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 124     return ::as_VectorRegister(reg(ra_, node, idx));
 125   }
 126   VectorSRegister as_VectorSRegister(PhaseRegAlloc *ra_, const Node *node) const {
 127     return ::as_VectorSRegister(reg(ra_, node));
 128   }
 129   VectorSRegister as_VectorSRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 130     return ::as_VectorSRegister(reg(ra_, node, idx));
 131   }
 132 #endif
 133 
 134   virtual intptr_t  constant() const;
 135   virtual relocInfo::relocType constant_reloc() const;
 136   virtual jdouble constantD() const;
 137   virtual jfloat  constantF() const;
 138   virtual jlong   constantL() const;
 139   virtual TypeOopPtr *oop() const;
 140   virtual int  ccode() const;
 141   // A zero, default, indicates this value is not needed.
 142   // May need to lookup the base register, as done in int_ and ext_format
 143   virtual int  base (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 144   virtual int  index(PhaseRegAlloc *ra_, const Node *node, int idx) const;
 145   virtual int  scale() const;
 146   // Parameters needed to support MEMORY_INTERFACE access to stackSlot
 147   virtual int  disp (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 148   // Check for PC-Relative displacement
 149   virtual relocInfo::relocType disp_reloc() const;
 150   virtual int  constant_disp() const;   // usu. 0, may return Type::OffsetBot
 151   virtual int  base_position()  const;  // base edge position, or -1
 152   virtual int  index_position() const;  // index edge position, or -1
 153 
 154   // Access the TypeKlassPtr of operands with a base==RegI and disp==RegP
 155   // Only returns non-null value for i486.ad&#39;s indOffset32X
 156   virtual const TypePtr *disp_as_type() const { return NULL; }
 157 
 158   // Return the label
 159   virtual Label *label() const;
 160 
 161   // Return the method&#39;s address
 162   virtual intptr_t  method() const;
 163 
 164   // Hash and compare over operands are currently identical
 165   virtual uint  hash() const;
 166   virtual bool  cmp( const MachOper &amp;oper ) const;
 167 
 168   // Virtual clone, since I do not know how big the MachOper is.
 169   virtual MachOper *clone() const = 0;
 170 
 171   // Return ideal Type from simple operands.  Fail for complex operands.
 172   virtual const Type *type() const;
 173 
 174   // Set an integer offset if we have one, or error otherwise
 175   virtual void set_con( jint c0 ) { ShouldNotReachHere();  }
 176 
 177 #ifndef PRODUCT
 178   // Return name of operand
 179   virtual const char    *Name() const { return &quot;???&quot;;}
 180 
 181   // Methods to output the text version of the operand
 182   virtual void int_format(PhaseRegAlloc *,const MachNode *node, outputStream *st) const = 0;
 183   virtual void ext_format(PhaseRegAlloc *,const MachNode *node,int idx, outputStream *st) const=0;
 184 
 185   virtual void dump_spec(outputStream *st) const; // Print per-operand info
 186 
 187   // Check whether o is a valid oper.
 188   static bool notAnOper(const MachOper *o) {
 189     if (o == NULL)                   return true;
 190     if (((intptr_t)o &amp; 1) != 0)      return true;
 191     if (*(address*)o == badAddress)  return true;  // kill by Node::destruct
 192     return false;
 193   }
 194 #endif // !PRODUCT
 195 };
 196 
 197 //------------------------------MachNode---------------------------------------
 198 // Base type for all machine specific nodes.  All node classes generated by the
 199 // ADLC inherit from this class.
 200 class MachNode : public Node {
 201 public:
 202   MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(NULL) {
 203     init_class_id(Class_Mach);
 204   }
 205   // Required boilerplate
 206   virtual uint size_of() const { return sizeof(MachNode); }
 207   virtual int  Opcode() const;          // Always equal to MachNode
 208   virtual uint rule() const = 0;        // Machine-specific opcode
 209   // Number of inputs which come before the first operand.
 210   // Generally at least 1, to skip the Control input
 211   virtual uint oper_input_base() const { return 1; }
 212   // Position of constant base node in node&#39;s inputs. -1 if
 213   // no constant base node input.
 214   virtual uint mach_constant_base_node_input() const { return (uint)-1; }
 215 
 216   uint8_t barrier_data() const { return _barrier; }
 217   void set_barrier_data(uint data) { _barrier = data; }
 218 
 219   // Copy inputs and operands to new node of instruction.
 220   // Called from cisc_version() and short_branch_version().
 221   // !!!! The method&#39;s body is defined in ad_&lt;arch&gt;.cpp file.
 222   void fill_new_machnode(MachNode *n) const;
 223 
 224   // Return an equivalent instruction using memory for cisc_operand position
 225   virtual MachNode *cisc_version(int offset);
 226   // Modify this instruction&#39;s register mask to use stack version for cisc_operand
 227   virtual void use_cisc_RegMask();
 228 
 229   // Support for short branches
 230   bool may_be_short_branch() const { return (flags() &amp; Flag_may_be_short_branch) != 0; }
 231 
 232   // Avoid back to back some instructions on some CPUs.
 233   enum AvoidBackToBackFlag { AVOID_NONE = 0,
 234                              AVOID_BEFORE = Flag_avoid_back_to_back_before,
 235                              AVOID_AFTER = Flag_avoid_back_to_back_after,
 236                              AVOID_BEFORE_AND_AFTER = AVOID_BEFORE | AVOID_AFTER };
 237 
 238   bool avoid_back_to_back(AvoidBackToBackFlag flag_value) const {
 239     return (flags() &amp; flag_value) == flag_value;
 240   }
 241 
 242   // instruction implemented with a call
 243   bool has_call() const { return (flags() &amp; Flag_has_call) != 0; }
 244 
 245   // First index in _in[] corresponding to operand, or -1 if there is none
 246   int  operand_index(uint operand) const;
 247   int  operand_index(const MachOper *oper) const;
 248   int  operand_index(Node* m) const;
 249 
 250   // Register class input is expected in
 251   virtual const RegMask &amp;in_RegMask(uint) const;
 252 
 253   // cisc-spillable instructions redefine for use by in_RegMask
 254   virtual const RegMask *cisc_RegMask() const { return NULL; }
 255 
 256   // If this instruction is a 2-address instruction, then return the
 257   // index of the input which must match the output.  Not nessecary
 258   // for instructions which bind the input and output register to the
 259   // same singleton regiser (e.g., Intel IDIV which binds AX to be
 260   // both an input and an output).  It is nessecary when the input and
 261   // output have choices - but they must use the same choice.
 262   virtual uint two_adr( ) const { return 0; }
 263 
 264   // The GC might require some barrier metadata for machine code emission.
 265   uint8_t _barrier;
 266 
 267   // Array of complex operand pointers.  Each corresponds to zero or
 268   // more leafs.  Must be set by MachNode constructor to point to an
 269   // internal array of MachOpers.  The MachOper array is sized by
 270   // specific MachNodes described in the ADL.
 271   uint _num_opnds;
 272   MachOper **_opnds;
 273   uint  num_opnds() const { return _num_opnds; }
 274 
 275   // Emit bytes into cbuf
 276   virtual void  emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 277   // Expand node after register allocation.
 278   // Node is replaced by several nodes in the postalloc expand phase.
 279   // Corresponding methods are generated for nodes if they specify
 280   // postalloc_expand. See block.cpp for more documentation.
 281   virtual bool requires_postalloc_expand() const { return false; }
 282   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 283   // Size of instruction in bytes
 284   virtual uint  size(PhaseRegAlloc *ra_) const;
 285   // Helper function that computes size by emitting code
 286   virtual uint  emit_size(PhaseRegAlloc *ra_) const;
 287 
 288   // Return the alignment required (in units of relocInfo::addr_unit())
 289   // for this instruction (must be a power of 2)
 290   int           pd_alignment_required() const;
 291   virtual int   alignment_required() const { return pd_alignment_required(); }
 292 
 293   // Return the padding (in bytes) to be emitted before this
 294   // instruction to properly align it.
 295   virtual int   compute_padding(int current_offset) const;
 296 
 297   // Return number of relocatable values contained in this instruction
 298   virtual int   reloc() const { return 0; }
 299 
 300   // Return number of words used for double constants in this instruction
 301   virtual int   ins_num_consts() const { return 0; }
 302 
 303   // Hash and compare over operands.  Used to do GVN on machine Nodes.
 304   virtual uint  hash() const;
 305   virtual bool  cmp( const Node &amp;n ) const;
 306 
 307   // Expand method for MachNode, replaces nodes representing pseudo
 308   // instructions with a set of nodes which represent real machine
 309   // instructions and compute the same value.
 310   virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
 311 
 312   // Bottom_type call; value comes from operand0
 313   virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
 314   virtual uint ideal_reg() const {
 315     const Type *t = _opnds[0]-&gt;type();
 316     if (t == TypeInt::CC) {
 317       return Op_RegFlags;
 318     } else {
 319       return t-&gt;ideal_reg();
 320     }
 321   }
 322 
 323   // If this is a memory op, return the base pointer and fixed offset.
 324   // If there are no such, return NULL.  If there are multiple addresses
 325   // or the address is indeterminate (rare cases) then return (Node*)-1,
 326   // which serves as node bottom.
 327   // If the offset is not statically determined, set it to Type::OffsetBot.
 328   // This method is free to ignore stack slots if that helps.
 329   #define TYPE_PTR_SENTINAL  ((const TypePtr*)-1)
 330   // Passing TYPE_PTR_SENTINAL as adr_type asks for computation of the adr_type if possible
 331   const Node* get_base_and_disp(intptr_t &amp;offset, const TypePtr* &amp;adr_type) const;
 332 
 333   // Helper for get_base_and_disp: find the base and index input nodes.
 334   // Returns the MachOper as determined by memory_operand(), for use, if
 335   // needed by the caller. If (MachOper *)-1 is returned, base and index
 336   // are set to NodeSentinel. If (MachOper *) NULL is returned, base and
 337   // index are set to NULL.
 338   const MachOper* memory_inputs(Node* &amp;base, Node* &amp;index) const;
 339 
 340   // Helper for memory_inputs:  Which operand carries the necessary info?
 341   // By default, returns NULL, which means there is no such operand.
 342   // If it returns (MachOper*)-1, this means there are multiple memories.
 343   virtual const MachOper* memory_operand() const { return NULL; }
 344 
 345   // Call &quot;get_base_and_disp&quot; to decide which category of memory is used here.
 346   virtual const class TypePtr *adr_type() const;
 347 
 348   // Apply peephole rule(s) to this instruction
 349   virtual MachNode *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted);
 350 
 351   // Top-level ideal Opcode matched
 352   virtual int ideal_Opcode()     const { return Op_Node; }
 353 
 354   // Adds the label for the case
 355   virtual void add_case_label( int switch_val, Label* blockLabel);
 356 
 357   // Set the absolute address for methods
 358   virtual void method_set( intptr_t addr );
 359 
 360   // Should we clone rather than spill this instruction?
 361   bool rematerialize() const;
 362 
 363   // Get the pipeline info
 364   static const Pipeline *pipeline_class();
 365   virtual const Pipeline *pipeline() const;
 366 
 367   // Returns true if this node is a check that can be implemented with a trap.
 368   virtual bool is_TrapBasedCheckNode() const { return false; }
 369 
 370 #ifndef PRODUCT
 371   virtual const char *Name() const = 0; // Machine-specific name
 372   virtual void dump_spec(outputStream *st) const; // Print per-node info
 373   void         dump_format(PhaseRegAlloc *ra, outputStream *st) const; // access to virtual
 374 #endif
 375 };
 376 
 377 //------------------------------MachIdealNode----------------------------
 378 // Machine specific versions of nodes that must be defined by user.
 379 // These are not converted by matcher from ideal nodes to machine nodes
 380 // but are inserted into the code by the compiler.
 381 class MachIdealNode : public MachNode {
 382 public:
 383   MachIdealNode( ) {}
 384 
 385   // Define the following defaults for non-matched machine nodes
 386   virtual uint oper_input_base() const { return 0; }
 387   virtual uint rule()            const { return 9999999; }
 388   virtual const class Type *bottom_type() const { return _opnds == NULL ? Type::CONTROL : MachNode::bottom_type(); }
 389 };
 390 
 391 //------------------------------MachTypeNode----------------------------
 392 // Machine Nodes that need to retain a known Type.
 393 class MachTypeNode : public MachNode {
 394   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 395 public:
 396   MachTypeNode( ) {}
 397   const Type *_bottom_type;
 398 
 399   virtual const class Type *bottom_type() const { return _bottom_type; }
 400 #ifndef PRODUCT
 401   virtual void dump_spec(outputStream *st) const;
 402 #endif
 403 };
 404 
 405 //------------------------------MachBreakpointNode----------------------------
 406 // Machine breakpoint or interrupt Node
 407 class MachBreakpointNode : public MachIdealNode {
 408 public:
 409   MachBreakpointNode( ) {}
 410   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 411   virtual uint size(PhaseRegAlloc *ra_) const;
 412 
 413 #ifndef PRODUCT
 414   virtual const char *Name() const { return &quot;Breakpoint&quot;; }
 415   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 416 #endif
 417 };
 418 
 419 //------------------------------MachConstantBaseNode--------------------------
 420 // Machine node that represents the base address of the constant table.
 421 class MachConstantBaseNode : public MachIdealNode {
 422 public:
 423   static const RegMask&amp; _out_RegMask;  // We need the out_RegMask statically in MachConstantNode::in_RegMask().
 424 
 425 public:
 426   MachConstantBaseNode() : MachIdealNode() {
 427     init_class_id(Class_MachConstantBase);
 428   }
 429   virtual const class Type* bottom_type() const { return TypeRawPtr::NOTNULL; }
 430   virtual uint ideal_reg() const { return Op_RegP; }
 431   virtual uint oper_input_base() const { return 1; }
 432 
 433   virtual bool requires_postalloc_expand() const;
 434   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 435 
 436   virtual void emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const;
 437   virtual uint size(PhaseRegAlloc* ra_) const;
 438   virtual bool pinned() const { return UseRDPCForConstantTableBase; }
 439 
 440   static const RegMask&amp; static_out_RegMask() { return _out_RegMask; }
 441   virtual const RegMask&amp; out_RegMask() const { return static_out_RegMask(); }
 442 
 443 #ifndef PRODUCT
 444   virtual const char* Name() const { return &quot;MachConstantBaseNode&quot;; }
 445   virtual void format(PhaseRegAlloc*, outputStream* st) const;
 446 #endif
 447 };
 448 
 449 //------------------------------MachConstantNode-------------------------------
 450 // Machine node that holds a constant which is stored in the constant table.
 451 class MachConstantNode : public MachTypeNode {
 452 protected:
 453   ConstantTable::Constant _constant;  // This node&#39;s constant.
 454 
 455 public:
 456   MachConstantNode() : MachTypeNode() {
 457     init_class_id(Class_MachConstant);
 458   }
 459 
 460   virtual void eval_constant(Compile* C) {
 461 #ifdef ASSERT
 462     tty-&gt;print(&quot;missing MachConstantNode eval_constant function: &quot;);
 463     dump();
 464 #endif
 465     ShouldNotCallThis();
 466   }
 467 
 468   virtual const RegMask &amp;in_RegMask(uint idx) const {
 469     if (idx == mach_constant_base_node_input())
 470       return MachConstantBaseNode::static_out_RegMask();
 471     return MachNode::in_RegMask(idx);
 472   }
 473 
 474   // Input edge of MachConstantBaseNode.
 475   virtual uint mach_constant_base_node_input() const { return req() - 1; }
 476 
 477   int  constant_offset();
 478   int  constant_offset() const { return ((MachConstantNode*) this)-&gt;constant_offset(); }
 479   // Unchecked version to avoid assertions in debug output.
 480   int  constant_offset_unchecked() const;
 481 };
 482 
 483 //------------------------------MachVEPNode-----------------------------------
 484 // Machine Inline Type Entry Point Node
 485 class MachVEPNode : public MachIdealNode {
 486 public:
 487   Label* _verified_entry;
 488 
 489   MachVEPNode(Label* verified_entry, bool verified, bool receiver_only) :
 490     _verified_entry(verified_entry),
 491     _verified(verified),
 492     _receiver_only(receiver_only) {
 493     init_class_id(Class_MachVEP);
 494   }
 495   virtual bool cmp(const Node &amp;n) const {
 496     return (_verified_entry == ((MachVEPNode&amp;)n)._verified_entry) &amp;&amp;
 497            (_verified == ((MachVEPNode&amp;)n)._verified) &amp;&amp;
 498            (_receiver_only == ((MachVEPNode&amp;)n)._receiver_only) &amp;&amp;
 499            MachIdealNode::cmp(n);
 500   }
 501   virtual uint size_of() const { return sizeof(*this); }
 502   virtual void emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const;
 503 
 504 #ifndef PRODUCT
 505   virtual const char* Name() const { return &quot;InlineType Entry-Point&quot;; }
 506   virtual void format(PhaseRegAlloc*, outputStream* st) const;
 507 #endif
 508 private:
 509   bool   _verified;
 510   bool   _receiver_only;
 511 };
 512 
 513 //------------------------------MachUEPNode-----------------------------------
 514 // Machine Unvalidated Entry Point Node
 515 class MachUEPNode : public MachIdealNode {
 516 public:
 517   MachUEPNode( ) {}
 518   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 519 
 520 #ifndef PRODUCT
 521   virtual const char *Name() const { return &quot;Unvalidated-Entry-Point&quot;; }
 522   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 523 #endif
 524 };
 525 
 526 //------------------------------MachPrologNode--------------------------------
 527 // Machine function Prolog Node
 528 class MachPrologNode : public MachIdealNode {
 529 public:
 530   Label* _verified_entry;
 531 
 532   MachPrologNode(Label* verified_entry) : _verified_entry(verified_entry) {
 533     init_class_id(Class_MachProlog);
 534   }
 535   virtual bool cmp(const Node &amp;n) const {
 536     return (_verified_entry == ((MachPrologNode&amp;)n)._verified_entry) &amp;&amp; MachIdealNode::cmp(n);
 537   }
 538   virtual uint size_of() const { return sizeof(*this); }
 539   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 540   virtual int reloc() const;
 541 
 542 #ifndef PRODUCT
 543   virtual const char *Name() const { return &quot;Prolog&quot;; }
 544   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 545 #endif
 546 };
 547 
 548 //------------------------------MachEpilogNode--------------------------------
 549 // Machine function Epilog Node
 550 class MachEpilogNode : public MachIdealNode {
 551 public:
 552   MachEpilogNode(bool do_poll = false) : _do_polling(do_poll) {}
 553   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 554   virtual int reloc() const;
 555   virtual const Pipeline *pipeline() const;
 556 
 557 private:
 558   bool _do_polling;
 559 
 560 public:
 561   bool do_polling() const { return _do_polling; }
 562 
 563 #ifndef PRODUCT
 564   virtual const char *Name() const { return &quot;Epilog&quot;; }
 565   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 566 #endif
 567 };
 568 
 569 //------------------------------MachNopNode-----------------------------------
 570 // Machine function Nop Node
 571 class MachNopNode : public MachIdealNode {
 572 private:
 573   int _count;
 574 public:
 575   MachNopNode( ) : _count(1) {}
 576   MachNopNode( int count ) : _count(count) {}
 577   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 578   virtual uint size(PhaseRegAlloc *ra_) const;
 579 
 580   virtual const class Type *bottom_type() const { return Type::CONTROL; }
 581 
 582   virtual int ideal_Opcode() const { return Op_Con; } // bogus; see output.cpp
 583   virtual const Pipeline *pipeline() const;
 584 #ifndef PRODUCT
 585   virtual const char *Name() const { return &quot;Nop&quot;; }
 586   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 587   virtual void dump_spec(outputStream *st) const { } // No per-operand info
 588 #endif
 589 };
 590 
 591 //------------------------------MachSpillCopyNode------------------------------
 592 // Machine SpillCopy Node.  Copies 1 or 2 words from any location to any
 593 // location (stack or register).
 594 class MachSpillCopyNode : public MachIdealNode {
 595 public:
 596   enum SpillType {
 597     TwoAddress,                        // Inserted when coalescing of a two-address-instruction node and its input fails
 598     PhiInput,                          // Inserted when coalescing of a phi node and its input fails
 599     DebugUse,                          // Inserted as debug info spills to safepoints in non-frequent blocks
 600     LoopPhiInput,                      // Pre-split compares of loop-phis
 601     Definition,                        // An lrg marked as spilled will be spilled to memory right after its definition,
 602                                        // if in high pressure region or the lrg is bound
 603     RegToReg,                          // A register to register move
 604     RegToMem,                          // A register to memory move
 605     MemToReg,                          // A memory to register move
 606     PhiLocationDifferToInputLocation,  // When coalescing phi nodes in PhaseChaitin::Split(), a move spill is inserted if
 607                                        // the phi and its input resides at different locations (i.e. reg or mem)
 608     BasePointerToMem,                  // Spill base pointer to memory at safepoint
 609     InputToRematerialization,          // When rematerializing a node we stretch the inputs live ranges, and they might be
 610                                        // stretched beyond a new definition point, therefore we split out new copies instead
 611     CallUse,                           // Spill use at a call
 612     Bound                              // An lrg marked as spill that is bound and needs to be spilled at a use
 613   };
 614 private:
 615   const RegMask *_in;           // RegMask for input
 616   const RegMask *_out;          // RegMask for output
 617   const Type *_type;
 618   const SpillType _spill_type;
 619 public:
 620   MachSpillCopyNode(SpillType spill_type, Node *n, const RegMask &amp;in, const RegMask &amp;out ) :
 621     MachIdealNode(), _in(&amp;in), _out(&amp;out), _type(n-&gt;bottom_type()), _spill_type(spill_type) {
 622     init_class_id(Class_MachSpillCopy);
 623     init_flags(Flag_is_Copy);
 624     add_req(NULL);
 625     add_req(n);
 626   }
 627   virtual uint size_of() const { return sizeof(*this); }
 628   void set_out_RegMask(const RegMask &amp;out) { _out = &amp;out; }
 629   void set_in_RegMask(const RegMask &amp;in) { _in = &amp;in; }
 630   virtual const RegMask &amp;out_RegMask() const { return *_out; }
 631   virtual const RegMask &amp;in_RegMask(uint) const { return *_in; }
 632   virtual const class Type *bottom_type() const { return _type; }
 633   virtual uint ideal_reg() const { return _type-&gt;ideal_reg(); }
 634   virtual uint oper_input_base() const { return 1; }
 635   uint implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const;
 636 
 637   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 638   virtual uint size(PhaseRegAlloc *ra_) const;
 639 
 640 
 641 #ifndef PRODUCT
 642   static const char *spill_type(SpillType st) {
 643     switch (st) {
 644       case TwoAddress:
 645         return &quot;TwoAddressSpillCopy&quot;;
 646       case PhiInput:
 647         return &quot;PhiInputSpillCopy&quot;;
 648       case DebugUse:
 649         return &quot;DebugUseSpillCopy&quot;;
 650       case LoopPhiInput:
 651         return &quot;LoopPhiInputSpillCopy&quot;;
 652       case Definition:
 653         return &quot;DefinitionSpillCopy&quot;;
 654       case RegToReg:
 655         return &quot;RegToRegSpillCopy&quot;;
 656       case RegToMem:
 657         return &quot;RegToMemSpillCopy&quot;;
 658       case MemToReg:
 659         return &quot;MemToRegSpillCopy&quot;;
 660       case PhiLocationDifferToInputLocation:
 661         return &quot;PhiLocationDifferToInputLocationSpillCopy&quot;;
 662       case BasePointerToMem:
 663         return &quot;BasePointerToMemSpillCopy&quot;;
 664       case InputToRematerialization:
 665         return &quot;InputToRematerializationSpillCopy&quot;;
 666       case CallUse:
 667         return &quot;CallUseSpillCopy&quot;;
 668       case Bound:
 669         return &quot;BoundSpillCopy&quot;;
 670       default:
 671         assert(false, &quot;Must have valid spill type&quot;);
 672         return &quot;MachSpillCopy&quot;;
 673     }
 674   }
 675 
 676   virtual const char *Name() const {
 677     return spill_type(_spill_type);
 678   }
 679 
 680   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 681 #endif
 682 };
 683 
 684 // MachMergeNode is similar to a PhiNode in a sense it merges multiple values,
 685 // however it doesn&#39;t have a control input and is more like a MergeMem.
 686 // It is inserted after the register allocation is done to ensure that nodes use single
 687 // definition of a multidef lrg in a block.
 688 class MachMergeNode : public MachIdealNode {
 689 public:
 690   MachMergeNode(Node *n1) {
 691     init_class_id(Class_MachMerge);
 692     add_req(NULL);
 693     add_req(n1);
 694   }
 695   virtual const RegMask &amp;out_RegMask() const { return in(1)-&gt;out_RegMask(); }
 696   virtual const RegMask &amp;in_RegMask(uint idx) const { return in(1)-&gt;in_RegMask(idx); }
 697   virtual const class Type *bottom_type() const { return in(1)-&gt;bottom_type(); }
 698   virtual uint ideal_reg() const { return bottom_type()-&gt;ideal_reg(); }
 699   virtual uint oper_input_base() const { return 1; }
 700   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const { }
 701   virtual uint size(PhaseRegAlloc *ra_) const { return 0; }
 702 #ifndef PRODUCT
 703   virtual const char *Name() const { return &quot;MachMerge&quot;; }
 704 #endif
 705 };
 706 
 707 //------------------------------MachBranchNode--------------------------------
 708 // Abstract machine branch Node
 709 class MachBranchNode : public MachIdealNode {
 710 public:
 711   MachBranchNode() : MachIdealNode() {
 712     init_class_id(Class_MachBranch);
 713   }
 714   virtual void label_set(Label* label, uint block_num) = 0;
 715   virtual void save_label(Label** label, uint* block_num) = 0;
 716 
 717   // Support for short branches
 718   virtual MachNode *short_branch_version() { return NULL; }
 719 
 720   virtual bool pinned() const { return true; };
 721 };
 722 
 723 //------------------------------MachNullChkNode--------------------------------
 724 // Machine-dependent null-pointer-check Node.  Points a real MachNode that is
 725 // also some kind of memory op.  Turns the indicated MachNode into a
 726 // conditional branch with good latency on the ptr-not-null path and awful
 727 // latency on the pointer-is-null path.
 728 
 729 class MachNullCheckNode : public MachBranchNode {
 730 public:
 731   const uint _vidx;             // Index of memop being tested
 732   MachNullCheckNode( Node *ctrl, Node *memop, uint vidx ) : MachBranchNode(), _vidx(vidx) {
 733     init_class_id(Class_MachNullCheck);
 734     add_req(ctrl);
 735     add_req(memop);
 736   }
 737   virtual uint size_of() const { return sizeof(*this); }
 738 
 739   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 740   virtual void label_set(Label* label, uint block_num);
 741   virtual void save_label(Label** label, uint* block_num);
 742   virtual void negate() { }
 743   virtual const class Type *bottom_type() const { return TypeTuple::IFBOTH; }
 744   virtual uint ideal_reg() const { return NotAMachineReg; }
 745   virtual const RegMask &amp;in_RegMask(uint) const;
 746   virtual const RegMask &amp;out_RegMask() const { return RegMask::Empty; }
 747 #ifndef PRODUCT
 748   virtual const char *Name() const { return &quot;NullCheck&quot;; }
 749   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 750 #endif
 751 };
 752 
 753 //------------------------------MachProjNode----------------------------------
 754 // Machine-dependent Ideal projections (how is that for an oxymoron).  Really
 755 // just MachNodes made by the Ideal world that replicate simple projections
 756 // but with machine-dependent input &amp; output register masks.  Generally
 757 // produced as part of calling conventions.  Normally I make MachNodes as part
 758 // of the Matcher process, but the Matcher is ill suited to issues involving
 759 // frame handling, so frame handling is all done in the Ideal world with
 760 // occasional callbacks to the machine model for important info.
 761 class MachProjNode : public ProjNode {
 762 public:
 763   MachProjNode( Node *multi, uint con, const RegMask &amp;out, uint ideal_reg ) : ProjNode(multi,con), _rout(out), _ideal_reg(ideal_reg) {
 764     init_class_id(Class_MachProj);
 765   }
 766   RegMask _rout;
 767   const uint  _ideal_reg;
 768   enum projType {
 769     unmatched_proj = 0,         // Projs for Control, I/O, memory not matched
 770     fat_proj       = 999        // Projs killing many regs, defined by _rout
 771   };
 772   virtual int   Opcode() const;
 773   virtual const Type *bottom_type() const;
 774   virtual const TypePtr *adr_type() const;
 775   virtual const RegMask &amp;in_RegMask(uint) const { return RegMask::Empty; }
 776   virtual const RegMask &amp;out_RegMask() const { return _rout; }
 777   virtual uint  ideal_reg() const { return _ideal_reg; }
 778   // Need size_of() for virtual ProjNode::clone()
 779   virtual uint  size_of() const { return sizeof(MachProjNode); }
 780 #ifndef PRODUCT
 781   virtual void dump_spec(outputStream *st) const;
 782 #endif
 783 };
 784 
 785 //------------------------------MachIfNode-------------------------------------
 786 // Machine-specific versions of IfNodes
 787 class MachIfNode : public MachBranchNode {
 788   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 789 public:
 790   float _prob;                  // Probability branch goes either way
 791   float _fcnt;                  // Frequency counter
 792   MachIfNode() : MachBranchNode() {
 793     init_class_id(Class_MachIf);
 794   }
 795   // Negate conditional branches.
 796   virtual void negate() = 0;
 797 #ifndef PRODUCT
 798   virtual void dump_spec(outputStream *st) const;
 799 #endif
 800 };
 801 
 802 //------------------------------MachJumpNode-----------------------------------
 803 // Machine-specific versions of JumpNodes
 804 class MachJumpNode : public MachConstantNode {
 805 public:
 806   float* _probs;
 807   MachJumpNode() : MachConstantNode() {
 808     init_class_id(Class_MachJump);
 809   }
 810 };
 811 
 812 //------------------------------MachGotoNode-----------------------------------
 813 // Machine-specific versions of GotoNodes
 814 class MachGotoNode : public MachBranchNode {
 815 public:
 816   MachGotoNode() : MachBranchNode() {
 817     init_class_id(Class_MachGoto);
 818   }
 819 };
 820 
 821 //------------------------------MachFastLockNode-------------------------------------
 822 // Machine-specific versions of FastLockNodes
 823 class MachFastLockNode : public MachNode {
 824   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 825 public:
 826   BiasedLockingCounters*        _counters;
 827   RTMLockingCounters*       _rtm_counters; // RTM lock counters for inflated locks
 828   RTMLockingCounters* _stack_rtm_counters; // RTM lock counters for stack locks
 829   MachFastLockNode() : MachNode() {}
 830 };
 831 
 832 //------------------------------MachReturnNode--------------------------------
 833 // Machine-specific versions of subroutine returns
 834 class MachReturnNode : public MachNode {
 835   virtual uint size_of() const; // Size is bigger
 836 public:
 837   RegMask *_in_rms;             // Input register masks, set during allocation
 838   ReallocMark _nesting;         // assertion check for reallocations
 839   const TypePtr* _adr_type;     // memory effects of call or return
 840   MachReturnNode() : MachNode() {
 841     init_class_id(Class_MachReturn);
 842     _adr_type = TypePtr::BOTTOM; // the default: all of memory
 843   }
 844 
 845   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
 846 
 847   virtual const RegMask &amp;in_RegMask(uint) const;
 848   virtual bool pinned() const { return true; };
 849   virtual const TypePtr *adr_type() const;
 850 };
 851 
 852 //------------------------------MachSafePointNode-----------------------------
 853 // Machine-specific versions of safepoints
 854 class MachSafePointNode : public MachReturnNode {
 855 public:
 856   OopMap*         _oop_map;     // Array of OopMap info (8-bit char) for GC
 857   JVMState*       _jvms;        // Pointer to list of JVM State Objects
 858   uint            _jvmadj;      // Extra delta to jvms indexes (mach. args)
 859   OopMap*         oop_map() const { return _oop_map; }
 860   void            set_oop_map(OopMap* om) { _oop_map = om; }
 861 
 862   MachSafePointNode() : MachReturnNode(), _oop_map(NULL), _jvms(NULL), _jvmadj(0) {
 863     init_class_id(Class_MachSafePoint);
 864   }
 865 
 866   virtual JVMState* jvms() const { return _jvms; }
 867   void set_jvms(JVMState* s) {
 868     _jvms = s;
 869   }
 870   virtual const Type    *bottom_type() const;
 871 
 872   virtual const RegMask &amp;in_RegMask(uint) const;
 873 
 874   // Functionality from old debug nodes
 875   Node *returnadr() const { return in(TypeFunc::ReturnAdr); }
 876   Node *frameptr () const { return in(TypeFunc::FramePtr); }
 877 
 878   Node *local(const JVMState* jvms, uint idx) const {
 879     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 880     return in(_jvmadj + jvms-&gt;locoff() + idx);
 881   }
 882   Node *stack(const JVMState* jvms, uint idx) const {
 883     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 884     return in(_jvmadj + jvms-&gt;stkoff() + idx);
 885  }
 886   Node *monitor_obj(const JVMState* jvms, uint idx) const {
 887     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 888     return in(_jvmadj + jvms-&gt;monitor_obj_offset(idx));
 889   }
 890   Node *monitor_box(const JVMState* jvms, uint idx) const {
 891     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 892     return in(_jvmadj + jvms-&gt;monitor_box_offset(idx));
 893   }
 894   void  set_local(const JVMState* jvms, uint idx, Node *c) {
 895     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 896     set_req(_jvmadj + jvms-&gt;locoff() + idx, c);
 897   }
 898   void  set_stack(const JVMState* jvms, uint idx, Node *c) {
 899     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 900     set_req(_jvmadj + jvms-&gt;stkoff() + idx, c);
 901   }
 902   void  set_monitor(const JVMState* jvms, uint idx, Node *c) {
 903     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 904     set_req(_jvmadj + jvms-&gt;monoff() + idx, c);
 905   }
 906 };
 907 
 908 //------------------------------MachCallNode----------------------------------
 909 // Machine-specific versions of subroutine calls
 910 class MachCallNode : public MachSafePointNode {
 911 protected:
 912   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 913   virtual bool cmp( const Node &amp;n ) const;
 914   virtual uint size_of() const = 0; // Size is bigger
 915 public:
 916   const TypeFunc *_tf;        // Function type
 917   address      _entry_point;  // Address of the method being called
 918   float        _cnt;          // Estimate of number of times called
 919   uint         _argsize;      // Size of argument block on stack
 920 
 921   const TypeFunc* tf()        const { return _tf; }
 922   const address entry_point() const { return _entry_point; }
 923   const float   cnt()         const { return _cnt; }
 924   uint argsize()              const { return _argsize; }
 925 
 926   void set_tf(const TypeFunc* tf) { _tf = tf; }
 927   void set_entry_point(address p) { _entry_point = p; }
 928   void set_cnt(float c)           { _cnt = c; }
 929   void set_argsize(int s)         { _argsize = s; }
 930 
 931   MachCallNode() : MachSafePointNode() {
 932     init_class_id(Class_MachCall);
 933   }
 934 
 935   virtual const Type *bottom_type() const;
 936   virtual bool  pinned() const { return false; }
 937   virtual const Type* Value(PhaseGVN* phase) const;
 938   virtual const RegMask &amp;in_RegMask(uint) const;
 939   virtual int ret_addr_offset() { return 0; }
 940 
 941   bool returns_long() const { return tf()-&gt;return_type() == T_LONG; }
 942   bool return_value_is_used() const;
 943 
 944   // Similar to cousin class CallNode::returns_pointer
 945   bool returns_pointer() const;
 946   bool returns_vt() const;
 947 
 948 #ifndef PRODUCT
 949   virtual void dump_spec(outputStream *st) const;
 950 #endif
 951 };
 952 
 953 //------------------------------MachCallJavaNode------------------------------
 954 // &quot;Base&quot; class for machine-specific versions of subroutine calls
 955 class MachCallJavaNode : public MachCallNode {
 956 protected:
 957   virtual bool cmp( const Node &amp;n ) const;
 958   virtual uint size_of() const; // Size is bigger
 959 public:
 960   ciMethod* _method;                 // Method being direct called
 961   bool      _override_symbolic_info; // Override symbolic call site info from bytecode
 962   int       _bci;                    // Byte Code index of call byte code
 963   bool      _optimized_virtual;      // Tells if node is a static call or an optimized virtual
 964   bool      _method_handle_invoke;   // Tells if the call has to preserve SP
 965   MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {
 966     init_class_id(Class_MachCallJava);
 967   }
 968 
 969   virtual const RegMask &amp;in_RegMask(uint) const;
 970 
 971   int resolved_method_index(CodeBuffer &amp;cbuf) const {
 972     if (_override_symbolic_info) {
 973       // Attach corresponding Method* to the call site, so VM can use it during resolution
 974       // instead of querying symbolic info from bytecode.
 975       assert(_method != NULL, &quot;method should be set&quot;);
 976       assert(_method-&gt;constant_encoding()-&gt;is_method(), &quot;should point to a Method&quot;);
 977       return cbuf.oop_recorder()-&gt;find_index(_method-&gt;constant_encoding());
 978     }
 979     return 0; // Use symbolic info from bytecode (resolved_method == NULL).
 980   }
 981 
 982 #ifndef PRODUCT
 983   virtual void dump_spec(outputStream *st) const;
 984 #endif
 985 };
 986 
 987 //------------------------------MachCallStaticJavaNode------------------------
 988 // Machine-specific versions of monomorphic subroutine calls
 989 class MachCallStaticJavaNode : public MachCallJavaNode {
 990   virtual bool cmp( const Node &amp;n ) const;
 991   virtual uint size_of() const; // Size is bigger
 992 public:
 993   const char *_name;            // Runtime wrapper name
 994   MachCallStaticJavaNode() : MachCallJavaNode() {
 995     init_class_id(Class_MachCallStaticJava);
 996   }
 997 
 998   // If this is an uncommon trap, return the request code, else zero.
 999   int uncommon_trap_request() const;
1000 
1001   virtual int ret_addr_offset();
1002 #ifndef PRODUCT
1003   virtual void dump_spec(outputStream *st) const;
1004   void dump_trap_args(outputStream *st) const;
1005 #endif
1006 };
1007 
1008 //------------------------------MachCallDynamicJavaNode------------------------
1009 // Machine-specific versions of possibly megamorphic subroutine calls
1010 class MachCallDynamicJavaNode : public MachCallJavaNode {
1011 public:
1012   int _vtable_index;
1013   MachCallDynamicJavaNode() : MachCallJavaNode() {
1014     init_class_id(Class_MachCallDynamicJava);
1015     DEBUG_ONLY(_vtable_index = -99);  // throw an assert if uninitialized
1016   }
1017   virtual int ret_addr_offset();
1018 #ifndef PRODUCT
1019   virtual void dump_spec(outputStream *st) const;
1020 #endif
1021 };
1022 
1023 //------------------------------MachCallRuntimeNode----------------------------
1024 // Machine-specific versions of subroutine calls
1025 class MachCallRuntimeNode : public MachCallNode {
1026   virtual bool cmp( const Node &amp;n ) const;
1027   virtual uint size_of() const; // Size is bigger
1028 public:
1029   const char *_name;            // Printable name, if _method is NULL
1030   MachCallRuntimeNode() : MachCallNode() {
1031     init_class_id(Class_MachCallRuntime);
1032   }
1033   virtual int ret_addr_offset();
1034 #ifndef PRODUCT
1035   virtual void dump_spec(outputStream *st) const;
1036 #endif
1037 };
1038 
1039 class MachCallLeafNode: public MachCallRuntimeNode {
1040 public:
1041   MachCallLeafNode() : MachCallRuntimeNode() {
1042     init_class_id(Class_MachCallLeaf);
1043   }
1044 };
1045 
1046 //------------------------------MachHaltNode-----------------------------------
1047 // Machine-specific versions of halt nodes
1048 class MachHaltNode : public MachReturnNode {
1049 public:
1050   bool _reachable;
1051   const char* _halt_reason;
1052   virtual JVMState* jvms() const;
1053   bool is_reachable() const {
1054     return _reachable;
1055   }
1056 };
1057 
1058 class MachMemBarNode : public MachNode {
1059   virtual uint size_of() const; // Size is bigger
1060 public:
1061   const TypePtr* _adr_type;     // memory effects
1062   MachMemBarNode() : MachNode() {
1063     init_class_id(Class_MachMemBar);
1064     _adr_type = TypePtr::BOTTOM; // the default: all of memory
1065   }
1066 
1067   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
1068   virtual const TypePtr *adr_type() const;
1069 };
1070 
1071 
1072 //------------------------------MachTempNode-----------------------------------
1073 // Node used by the adlc to construct inputs to represent temporary registers
1074 class MachTempNode : public MachNode {
1075 private:
1076   MachOper *_opnd_array[1];
1077 
1078 public:
1079   virtual const RegMask &amp;out_RegMask() const { return *_opnds[0]-&gt;in_RegMask(0); }
1080   virtual uint rule() const { return 9999999; }
1081   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1082 
1083   MachTempNode(MachOper* oper) {
1084     init_class_id(Class_MachTemp);
1085     _num_opnds = 1;
1086     _opnds = _opnd_array;
1087     add_req(NULL);
1088     _opnds[0] = oper;
1089   }
1090   virtual uint size_of() const { return sizeof(MachTempNode); }
1091 
1092 #ifndef PRODUCT
1093   virtual void format(PhaseRegAlloc *, outputStream *st ) const {}
1094   virtual const char *Name() const { return &quot;MachTemp&quot;;}
1095 #endif
1096 };
1097 
1098 
1099 
1100 //------------------------------labelOper--------------------------------------
1101 // Machine-independent version of label operand
1102 class labelOper : public MachOper {
1103 private:
1104   virtual uint           num_edges() const { return 0; }
1105 public:
1106   // Supported for fixed size branches
1107   Label* _label;                // Label for branch(es)
1108 
1109   uint _block_num;
1110 
1111   labelOper() : _label(0), _block_num(0) {}
1112 
1113   labelOper(Label* label, uint block_num) : _label(label), _block_num(block_num) {}
1114 
1115   labelOper(labelOper* l) : _label(l-&gt;_label) , _block_num(l-&gt;_block_num) {}
1116 
1117   virtual MachOper *clone() const;
1118 
1119   virtual Label *label() const { assert(_label != NULL, &quot;need Label&quot;); return _label; }
1120 
1121   virtual uint           opcode() const;
1122 
1123   virtual uint           hash()   const;
1124   virtual bool           cmp( const MachOper &amp;oper ) const;
1125 #ifndef PRODUCT
1126   virtual const char    *Name()   const { return &quot;Label&quot;;}
1127 
1128   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1129   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1130 #endif
1131 };
1132 
1133 
1134 //------------------------------methodOper--------------------------------------
1135 // Machine-independent version of method operand
1136 class methodOper : public MachOper {
1137 private:
1138   virtual uint           num_edges() const { return 0; }
1139 public:
1140   intptr_t _method;             // Address of method
1141   methodOper() :   _method(0) {}
1142   methodOper(intptr_t method) : _method(method)  {}
1143 
1144   virtual MachOper *clone() const;
1145 
1146   virtual intptr_t method() const { return _method; }
1147 
1148   virtual uint           opcode() const;
1149 
1150   virtual uint           hash()   const;
1151   virtual bool           cmp( const MachOper &amp;oper ) const;
1152 #ifndef PRODUCT
1153   virtual const char    *Name()   const { return &quot;Method&quot;;}
1154 
1155   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1156   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1157 #endif
1158 };
1159 
1160 #endif // SHARE_OPTO_MACHNODE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;

  26 #include &quot;ci/ciField.hpp&quot;

  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciTypeFlow.hpp&quot;
<span class="line-removed">  29 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;compiler/compileLog.hpp&quot;
  33 #include &quot;libadt/dict.hpp&quot;
  34 #include &quot;memory/oopFactory.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/instanceKlass.hpp&quot;
  37 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;oops/typeArrayKlass.hpp&quot;
  40 #include &quot;opto/matcher.hpp&quot;
  41 #include &quot;opto/node.hpp&quot;
  42 #include &quot;opto/opcodes.hpp&quot;
  43 #include &quot;opto/type.hpp&quot;
  44 #include &quot;utilities/powerOfTwo.hpp&quot;
  45 
  46 // Portions of code courtesy of Clifford Click
  47 
  48 // Optimization - Graph Style
  49 
</pre>
<hr />
<pre>
 111 
 112 #if defined(PPC64)
 113   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 114   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 115   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 116   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 117   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 118 #elif defined(S390)
 119   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 120   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 121   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 122   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 123   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 124 #else // all other
 125   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 126   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 127   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 128   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 129   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 130 #endif
<span class="line-modified"> 131   { Bad,             T_INLINE_TYPE, &quot;value:&quot;,       false, Node::NotAMachineReg, relocInfo::none          },  // ValueType</span>
 132   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 133   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 134   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 135   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 136   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 137   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 138   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 139   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 140   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 141   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 142   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 143   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 144   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 145   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 146   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 147   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 148   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 149   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 150 };
 151 
</pre>
<hr />
<pre>
 243     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 244     return TypePtr::NULL_PTR;
 245 
 246   case ciTypeFlow::StateVector::T_LONG2:
 247     // The ciTypeFlow pass pushes a long, then the half.
 248     // We do the same.
 249     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 250     return TypeInt::TOP;
 251 
 252   case ciTypeFlow::StateVector::T_DOUBLE2:
 253     // The ciTypeFlow pass pushes double, then the half.
 254     // Our convention is the same.
 255     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 256     return Type::TOP;
 257 
 258   case T_ADDRESS:
 259     assert(type-&gt;is_return_address(), &quot;&quot;);
 260     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 261 
 262   case T_INLINE_TYPE: {
<span class="line-modified"> 263     ciValueKlass* vk = type-&gt;as_value_klass();</span>
 264     if (vk-&gt;is_scalarizable()) {
<span class="line-modified"> 265       return TypeValueType::make(vk);</span>
 266     } else {
 267       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(TypePtr::NOTNULL);
 268     }
 269   }
 270 
 271   default:
 272     // make sure we did not mix up the cases:
 273     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 274     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 275     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 276     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 277     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 278     assert(!type-&gt;is_return_address(), &quot;&quot;);
 279 
 280     return Type::get_const_type(type);
 281   }
 282 }
 283 
 284 
 285 //-----------------------make_from_constant------------------------------------
</pre>
<hr />
<pre>
 578 
 579   const Type **fmembar = TypeTuple::fields(0);
 580   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 581 
 582   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 583   fsc[0] = TypeInt::CC;
 584   fsc[1] = Type::MEMORY;
 585   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 586 
 587   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 588   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 589   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 590   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 591                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);
 592   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 593                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
 594   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 595 
 596   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 597 
<span class="line-modified"> 598   TypeValueType::BOTTOM = TypeValueType::make(NULL);</span>
 599 
 600   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 601   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 602 
 603   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 604 
 605   mreg2type[Op_Node] = Type::BOTTOM;
 606   mreg2type[Op_Set ] = 0;
 607   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 608   mreg2type[Op_RegI] = TypeInt::INT;
 609   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 610   mreg2type[Op_RegF] = Type::FLOAT;
 611   mreg2type[Op_RegD] = Type::DOUBLE;
 612   mreg2type[Op_RegL] = TypeLong::LONG;
 613   mreg2type[Op_RegFlags] = TypeInt::CC;
 614 
 615   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));
 616 
 617   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 618 
 619 #ifdef _LP64
 620   if (UseCompressedOops) {
 621     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 622     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 623   } else
 624 #endif
 625   {
 626     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 627     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 628   }
 629   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);
 630   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);
 631   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
 632   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 633   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 634   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 635   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
<span class="line-modified"> 636   TypeAryPtr::VALUES  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeValueType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);</span>
 637 
 638   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 639   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 640   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 641   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;
 642   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 643   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 644   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 645   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 646   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 647   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 648   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 649   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 650   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 651 
 652   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 653   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 654 
 655   const Type **fi2c = TypeTuple::fields(2);
 656   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
</pre>
<hr />
<pre>
 969 
 970   case OopPtr:
 971     return t-&gt;xmeet(this);
 972 
 973   case InstPtr:
 974     return t-&gt;xmeet(this);
 975 
 976   case MetadataPtr:
 977   case KlassPtr:
 978     return t-&gt;xmeet(this);
 979 
 980   case AryPtr:
 981     return t-&gt;xmeet(this);
 982 
 983   case NarrowOop:
 984     return t-&gt;xmeet(this);
 985 
 986   case NarrowKlass:
 987     return t-&gt;xmeet(this);
 988 
<span class="line-modified"> 989   case ValueType:</span>
 990     return t-&gt;xmeet(this);
 991 
 992   case Bad:                     // Type check
 993   default:                      // Bogus type not in lattice
 994     typerr(t);
 995     return Type::BOTTOM;
 996 
 997   case Bottom:                  // Ye Olde Default
 998     return t;
 999 
1000   case FloatTop:
1001     if( _base == FloatTop ) return this;
1002   case FloatBot:                // Float
1003     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
1004     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
1005     typerr(t);
1006     return Type::BOTTOM;
1007 
1008   case DoubleTop:
1009     if( _base == DoubleTop ) return this;
</pre>
<hr />
<pre>
1039 
1040 //------------------------------xdual------------------------------------------
1041 // Compute dual right now.
1042 const Type::TYPES Type::dual_type[Type::lastype] = {
1043   Bad,          // Bad
1044   Control,      // Control
1045   Bottom,       // Top
1046   Bad,          // Int - handled in v-call
1047   Bad,          // Long - handled in v-call
1048   Half,         // Half
1049   Bad,          // NarrowOop - handled in v-call
1050   Bad,          // NarrowKlass - handled in v-call
1051 
1052   Bad,          // Tuple - handled in v-call
1053   Bad,          // Array - handled in v-call
1054   Bad,          // VectorS - handled in v-call
1055   Bad,          // VectorD - handled in v-call
1056   Bad,          // VectorX - handled in v-call
1057   Bad,          // VectorY - handled in v-call
1058   Bad,          // VectorZ - handled in v-call
<span class="line-modified">1059   Bad,          // ValueType - handled in v-call</span>
1060 
1061   Bad,          // AnyPtr - handled in v-call
1062   Bad,          // RawPtr - handled in v-call
1063   Bad,          // OopPtr - handled in v-call
1064   Bad,          // InstPtr - handled in v-call
1065   Bad,          // AryPtr - handled in v-call
1066 
1067   Bad,          //  MetadataPtr - handled in v-call
1068   Bad,          // KlassPtr - handled in v-call
1069 
1070   Bad,          // Function - handled in v-call
1071   Abio,         // Abio
1072   Return_Address,// Return_Address
1073   Memory,       // Memory
1074   FloatBot,     // FloatTop
1075   FloatCon,     // FloatCon
1076   FloatTop,     // FloatBot
1077   DoubleBot,    // DoubleTop
1078   DoubleCon,    // DoubleCon
1079   DoubleTop,    // DoubleBot
</pre>
<hr />
<pre>
1935 
1936 bool TypeLong::empty(void) const {
1937   return _lo &gt; _hi;
1938 }
1939 
1940 //=============================================================================
1941 // Convenience common pre-built types.
1942 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1943 const TypeTuple *TypeTuple::IFFALSE;
1944 const TypeTuple *TypeTuple::IFTRUE;
1945 const TypeTuple *TypeTuple::IFNEITHER;
1946 const TypeTuple *TypeTuple::LOOPBODY;
1947 const TypeTuple *TypeTuple::MEMBAR;
1948 const TypeTuple *TypeTuple::STORECONDITIONAL;
1949 const TypeTuple *TypeTuple::START_I2C;
1950 const TypeTuple *TypeTuple::INT_PAIR;
1951 const TypeTuple *TypeTuple::LONG_PAIR;
1952 const TypeTuple *TypeTuple::INT_CC_PAIR;
1953 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1954 
<span class="line-modified">1955 static void collect_value_fields(ciValueKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {</span>
1956   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
1957     ciField* field = vk-&gt;nonstatic_field_at(j);
1958     BasicType bt = field-&gt;type()-&gt;basic_type();
1959     const Type* ft = Type::get_const_type(field-&gt;type());
1960     field_array[pos++] = ft;
1961     if (type2size[bt] == 2) {
1962       field_array[pos++] = Type::HALF;
1963     }
1964     // Skip reserved arguments
1965     while (SigEntry::next_is_reserved(sig_cc, bt)) {
1966       field_array[pos++] = Type::get_const_basic_type(bt);
1967       if (type2size[bt] == 2) {
1968         field_array[pos++] = Type::HALF;
1969       }
1970     }
1971   }
1972 }
1973 
1974 //------------------------------make-------------------------------------------
1975 // Make a TypeTuple from the range of a method signature
1976 const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {
1977   ciType* return_type = sig-&gt;return_type();
1978   uint arg_cnt = return_type-&gt;size();
1979   if (ret_vt_fields) {
<span class="line-modified">1980     arg_cnt = return_type-&gt;as_value_klass()-&gt;value_arg_slots() + 1;</span>
1981   }
1982 
1983   const Type **field_array = fields(arg_cnt);
1984   switch (return_type-&gt;basic_type()) {
1985   case T_LONG:
1986     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1987     field_array[TypeFunc::Parms+1] = Type::HALF;
1988     break;
1989   case T_DOUBLE:
1990     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1991     field_array[TypeFunc::Parms+1] = Type::HALF;
1992     break;
1993   case T_OBJECT:
1994   case T_ARRAY:
1995   case T_BOOLEAN:
1996   case T_CHAR:
1997   case T_FLOAT:
1998   case T_BYTE:
1999   case T_SHORT:
2000   case T_INT:
2001     field_array[TypeFunc::Parms] = get_const_type(return_type);
2002     break;
2003   case T_INLINE_TYPE:
2004     if (ret_vt_fields) {
2005       uint pos = TypeFunc::Parms;
2006       field_array[pos] = TypePtr::BOTTOM;
2007       pos++;
2008       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
<span class="line-modified">2009       collect_value_fields(return_type-&gt;as_value_klass(), field_array, pos, sig);</span>
2010     } else {
2011       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(TypePtr::NOTNULL);
2012     }
2013     break;
2014   case T_VOID:
2015     break;
2016   default:
2017     ShouldNotReachHere();
2018   }
2019   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2020 }
2021 
2022 // Make a TypeTuple from the domain of a method signature
2023 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
2024   ciSignature* sig = method-&gt;signature();
2025   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());
2026 
2027   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);
2028   if (vt_fields_as_args) {
2029     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {
2030       arg_cnt += type2size[(*sig_cc)._bt];
2031     }
2032     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());
2033   }
2034 
2035   uint pos = TypeFunc::Parms;
2036   const Type** field_array = fields(arg_cnt);
2037   if (!method-&gt;is_static()) {
2038     ciInstanceKlass* recv = method-&gt;holder();
<span class="line-modified">2039     if (vt_fields_as_args &amp;&amp; recv-&gt;is_valuetype() &amp;&amp; recv-&gt;as_value_klass()-&gt;can_be_passed_as_fields()) {</span>
<span class="line-modified">2040       collect_value_fields(recv-&gt;as_value_klass(), field_array, pos, sig_cc);</span>
2041     } else {
2042       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
2043       if (vt_fields_as_args) {
2044         ++sig_cc;
2045       }
2046     }
2047   }
2048 
2049   int i = 0;
2050   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2051     ciType* type = sig-&gt;type_at(i);
2052     BasicType bt = type-&gt;basic_type();
2053     bool is_flattened = false;
2054 
2055     switch (bt) {
2056     case T_LONG:
2057       field_array[pos++] = TypeLong::LONG;
2058       field_array[pos++] = Type::HALF;
2059       break;
2060     case T_DOUBLE:
2061       field_array[pos++] = Type::DOUBLE;
2062       field_array[pos++] = Type::HALF;
2063       break;
2064     case T_OBJECT:
2065     case T_ARRAY:
2066     case T_FLOAT:
2067     case T_INT:
2068       field_array[pos++] = get_const_type(type);
2069       break;
2070     case T_BOOLEAN:
2071     case T_CHAR:
2072     case T_BYTE:
2073     case T_SHORT:
2074       field_array[pos++] = TypeInt::INT;
2075       break;
2076     case T_INLINE_TYPE: {
<span class="line-modified">2077       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;can_be_passed_as_fields()) {</span>
2078         is_flattened = true;
<span class="line-modified">2079         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);</span>
2080       } else {
2081         field_array[pos++] = get_const_type(type)-&gt;join_speculative(TypePtr::NOTNULL);
2082       }
2083       break;
2084     }
2085     default:
2086       ShouldNotReachHere();
2087     }
2088     // Skip reserved arguments
2089     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2090       field_array[pos++] = Type::get_const_basic_type(bt);
2091       if (type2size[bt] == 2) {
2092         field_array[pos++] = Type::HALF;
2093       }
2094     }
2095     i++;
2096   }
2097   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);
2098 
2099   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
</pre>
<hr />
<pre>
2379   ciKlass* tklass = toop-&gt;klass();
2380   if (tklass == NULL)       return false;  // unloaded class
2381   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2382   const TypeInstPtr* tinst;
2383   if (_elem-&gt;isa_narrowoop())
2384     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2385   else
2386     tinst = _elem-&gt;isa_instptr();
2387   if (tinst)
2388     return tklass-&gt;as_instance_klass()-&gt;is_final();
2389   const TypeAryPtr*  tap;
2390   if (_elem-&gt;isa_narrowoop())
2391     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2392   else
2393     tap = _elem-&gt;isa_aryptr();
2394   if (tap)
2395     return tap-&gt;ary()-&gt;ary_must_be_exact();
2396   return false;
2397 }
2398 
<span class="line-modified">2399 //==============================TypeValueType=======================================</span>
2400 
<span class="line-modified">2401 const TypeValueType *TypeValueType::BOTTOM;</span>
2402 
2403 //------------------------------make-------------------------------------------
<span class="line-modified">2404 const TypeValueType* TypeValueType::make(ciValueKlass* vk, bool larval) {</span>
<span class="line-modified">2405   return (TypeValueType*)(new TypeValueType(vk, larval))-&gt;hashcons();</span>
2406 }
2407 
2408 //------------------------------meet-------------------------------------------
2409 // Compute the MEET of two types.  It returns a new Type object.
<span class="line-modified">2410 const Type* TypeValueType::xmeet(const Type* t) const {</span>
2411   // Perform a fast test for common case; meeting the same types together.
2412   if(this == t) return this;  // Meeting same type-rep?
2413 
<span class="line-modified">2414   // Current &quot;this-&gt;_base&quot; is ValueType</span>
2415   switch (t-&gt;base()) {          // switch on original type
2416 
2417   case Int:
2418   case Long:
2419   case FloatTop:
2420   case FloatCon:
2421   case FloatBot:
2422   case DoubleTop:
2423   case DoubleCon:
2424   case DoubleBot:
2425   case NarrowKlass:
2426   case Bottom:
2427     return Type::BOTTOM;
2428 
2429   case OopPtr:
2430   case MetadataPtr:
2431   case KlassPtr:
2432   case RawPtr:
2433     return TypePtr::BOTTOM;
2434 
2435   case Top:
2436     return this;
2437 
2438   case NarrowOop: {
2439     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);
2440     if (res-&gt;isa_ptr()) {
2441       return res-&gt;make_narrowoop();
2442     }
2443     return res;
2444   }
2445 
2446   case AryPtr:
2447   case InstPtr: {
2448     return t-&gt;xmeet(this);
2449   }
2450 
<span class="line-modified">2451   case ValueType: {</span>
<span class="line-modified">2452     // All value types inherit from Object</span>
<span class="line-modified">2453     const TypeValueType* other = t-&gt;is_valuetype();</span>
2454     if (_vk == NULL) {
2455       return this;
2456     } else if (other-&gt;_vk == NULL) {
2457       return other;
2458     } else if (_vk == other-&gt;_vk) {
2459       if (_larval == other-&gt;_larval ||
2460           !_larval) {
2461         return this;
2462       } else {
2463         return t;
2464       }
2465     }
2466     return TypeInstPtr::NOTNULL;
2467   }
2468 
2469   default:                      // All else is a mistake
2470     typerr(t);
2471 
2472   }
2473   return this;
2474 }
2475 
2476 //------------------------------xdual------------------------------------------
<span class="line-modified">2477 const Type* TypeValueType::xdual() const {</span>
2478   return this;
2479 }
2480 
2481 //------------------------------eq---------------------------------------------
2482 // Structural equality check for Type representations
<span class="line-modified">2483 bool TypeValueType::eq(const Type* t) const {</span>
<span class="line-modified">2484   const TypeValueType* vt = t-&gt;is_valuetype();</span>
<span class="line-modified">2485   return (_vk == vt-&gt;value_klass() &amp;&amp; _larval == vt-&gt;larval());</span>
2486 }
2487 
2488 //------------------------------hash-------------------------------------------
2489 // Type-specific hashing function.
<span class="line-modified">2490 int TypeValueType::hash(void) const {</span>
2491   return (intptr_t)_vk;
2492 }
2493 
2494 //------------------------------singleton--------------------------------------
2495 // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.
<span class="line-modified">2496 bool TypeValueType::singleton(void) const {</span>
2497   return false;
2498 }
2499 
2500 //------------------------------empty------------------------------------------
2501 // TRUE if Type is a type with no values, FALSE otherwise.
<span class="line-modified">2502 bool TypeValueType::empty(void) const {</span>
2503   return false;
2504 }
2505 
2506 //------------------------------dump2------------------------------------------
2507 #ifndef PRODUCT
<span class="line-modified">2508 void TypeValueType::dump2(Dict &amp;d, uint depth, outputStream* st) const {</span>
2509   if (_vk == NULL) {
<span class="line-modified">2510     st-&gt;print(&quot;BOTTOM valuetype&quot;);</span>
2511     return;
2512   }
2513   int count = _vk-&gt;nof_declared_nonstatic_fields();
<span class="line-modified">2514   st-&gt;print(&quot;valuetype[%d]:{&quot;, count);</span>
2515   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);
2516   for (int i = 1; i &lt; count; ++i) {
2517     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());
2518   }
2519   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);
2520 }
2521 #endif
2522 
2523 //==============================TypeVect=======================================
2524 // Convenience common pre-built types.
2525 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2526 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2527 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2528 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2529 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2530 
2531 //------------------------------make-------------------------------------------
2532 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2533   BasicType elem_bt = elem-&gt;array_element_basic_type();
2534   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
</pre>
<hr />
<pre>
3230     _klass_is_exact(xk),
3231     _is_ptr_to_narrowoop(false),
3232     _is_ptr_to_narrowklass(false),
3233     _is_ptr_to_boxed_value(false),
3234     _instance_id(instance_id) {
3235   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
3236       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
3237     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());
3238   }
3239 #ifdef _LP64
3240   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {
3241     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
3242       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3243     } else if (klass() == NULL) {
3244       // Array with unknown body type
3245       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3246       _is_ptr_to_narrowoop = UseCompressedOops;
3247     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
3248       if (klass()-&gt;is_obj_array_klass()) {
3249         _is_ptr_to_narrowoop = true;
<span class="line-modified">3250       } else if (klass()-&gt;is_value_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {</span>
<span class="line-modified">3251         // Check if the field of the value type array element contains oops</span>
<span class="line-modified">3252         ciValueKlass* vk = klass()-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
3253         int foffset = field_offset.get() + vk-&gt;first_field_offset();
3254         ciField* field = vk-&gt;get_field_by_offset(foffset, false);
3255         assert(field != NULL, &quot;missing field&quot;);
3256         BasicType bt = field-&gt;layout_type();
3257         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);
3258       }
3259     } else if (klass()-&gt;is_instance_klass()) {
3260       if (this-&gt;isa_klassptr()) {
3261         // Perm objects don&#39;t use compressed references
3262       } else if (_offset == Offset::bottom || _offset == Offset::top) {
3263         // unsafe access
3264         _is_ptr_to_narrowoop = UseCompressedOops;
3265       } else { // exclude unsafe ops
3266         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3267         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3268             (this-&gt;offset() == java_lang_Class::klass_offset() ||
3269              this-&gt;offset() == java_lang_Class::array_klass_offset())) {
3270           // Special hidden fields from the Class.
3271           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3272           _is_ptr_to_narrowoop = false;
3273         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3274                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3275           // Static fields
3276           assert(o != NULL, &quot;must be constant&quot;);
3277           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3278           BasicType basic_elem_type;
<span class="line-modified">3279           if (ik-&gt;is_valuetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_value_klass()-&gt;default_value_offset()) {</span>
<span class="line-modified">3280             // Special hidden field that contains the oop of the default value type</span>
3281             basic_elem_type = T_INLINE_TYPE;
3282           } else {
3283             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
3284             assert(field != NULL, &quot;missing field&quot;);
3285             basic_elem_type = field-&gt;layout_type();
3286           }
3287           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3288         } else {
3289           // Instance fields which contains a compressed oop references.
3290           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3291           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);
3292           if (field != NULL) {
3293             BasicType basic_elem_type = field-&gt;layout_type();
3294             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3295           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3296             // Compile::find_alias_type() cast exactness on all types to verify
3297             // that it does not affect alias type.
3298             _is_ptr_to_narrowoop = UseCompressedOops;
3299           } else {
3300             // Type for the copy start in LibraryCallKit::inline_native_clone().
</pre>
<hr />
<pre>
3418   case InstPtr:                  // For these, flip the call around to cut down
3419   case AryPtr:
3420     return t-&gt;xmeet(this);      // Call in reverse direction
3421 
3422   } // End of switch
3423   return this;                  // Return the double constant
3424 }
3425 
3426 
3427 //------------------------------xdual------------------------------------------
3428 // Dual of a pure heap pointer.  No relevant klass or oop information.
3429 const Type *TypeOopPtr::xdual() const {
3430   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3431   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3432   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());
3433 }
3434 
3435 //--------------------------make_from_klass_common-----------------------------
3436 // Computes the element-type given a klass.
3437 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="line-modified">3438   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {</span>
3439     Compile* C = Compile::current();
3440     Dependencies* deps = C-&gt;dependencies();
3441     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3442     // Element is an instance
3443     bool klass_is_exact = false;
3444     if (klass-&gt;is_loaded()) {
3445       // Try to set klass_is_exact.
3446       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3447       klass_is_exact = ik-&gt;is_final();
3448       if (!klass_is_exact &amp;&amp; klass_change
3449           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3450         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3451         if (sub != NULL) {
3452           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3453           klass = ik = sub;
3454           klass_is_exact = sub-&gt;is_final();
3455         }
3456       }
3457       if (!klass_is_exact &amp;&amp; try_for_exact
3458           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3459         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3460           // Add a dependence; if concrete subclass added we need to recompile
3461           deps-&gt;assert_leaf_type(ik);
3462           klass_is_exact = true;
3463         }
3464       }
3465     }
3466     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
3467   } else if (klass-&gt;is_obj_array_klass()) {
<span class="line-modified">3468     // Element is an object or value array. Recursively call ourself.</span>
3469     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
<span class="line-modified">3470     if (etype-&gt;is_valuetypeptr()) {</span>
3471       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3472     }
3473     // Determine null-free/flattened properties
3474     const TypeOopPtr* exact_etype = etype;
<span class="line-modified">3475     if (etype-&gt;can_be_value_type()) {</span>
<span class="line-modified">3476       // Use exact type if element can be a value type</span>
3477       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
3478     }
<span class="line-modified">3479     bool not_null_free = !exact_etype-&gt;can_be_value_type();</span>
<span class="line-modified">3480     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_valuetypeptr() &amp;&amp; !exact_etype-&gt;value_klass()-&gt;flatten_array());</span>
3481 
3482     bool xk = etype-&gt;klass_is_exact();
3483     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3484     // We used to pass NotNull in here, asserting that the sub-arrays
3485     // are all not-null.  This is not true in generally, as code can
3486     // slam NULLs down in the subarrays.
3487     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
3488     return arr;
3489   } else if (klass-&gt;is_type_array_klass()) {
3490     // Element is an typeArray
3491     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3492     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,
3493                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3494     // We used to pass NotNull in here, asserting that the array pointer
3495     // is not-null. That was not true in general.
3496     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3497     return arr;
<span class="line-modified">3498   } else if (klass-&gt;is_value_array_klass()) {</span>
<span class="line-modified">3499     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-modified">3500     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::POS);</span>
3501     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3502     return arr;
3503   } else {
3504     ShouldNotReachHere();
3505     return NULL;
3506   }
3507 }
3508 
3509 //------------------------------make_from_constant-----------------------------
3510 // Make a java pointer from an oop constant
3511 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3512   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3513 
3514   const bool make_constant = require_constant || o-&gt;should_be_constant();
3515 
3516   ciKlass* klass = o-&gt;klass();
<span class="line-modified">3517   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {</span>
<span class="line-modified">3518     // Element is an instance or value type</span>
3519     if (make_constant) {
3520       return TypeInstPtr::make(o);
3521     } else {
3522       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
3523     }
3524   } else if (klass-&gt;is_obj_array_klass()) {
3525     // Element is an object array. Recursively call ourself.
3526     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
3527     bool null_free = false;
<span class="line-modified">3528     if (etype-&gt;is_valuetypeptr()) {</span>
3529       null_free = true;
3530       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3531     }
3532     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3533                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3534     // We used to pass NotNull in here, asserting that the sub-arrays
3535     // are all not-null.  This is not true in generally, as code can
3536     // slam NULLs down in the subarrays.
3537     if (make_constant) {
3538       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3539     } else {
3540       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3541     }
3542   } else if (klass-&gt;is_type_array_klass()) {
3543     // Element is an typeArray
3544     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3545     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3546                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3547     // We used to pass NotNull in here, asserting that the array pointer
3548     // is not-null. That was not true in general.
3549     if (make_constant) {
3550       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3551     } else {
3552       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3553     }
<span class="line-modified">3554   } else if (klass-&gt;is_value_array_klass()) {</span>
<span class="line-modified">3555     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-modified">3556     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
3557     // We used to pass NotNull in here, asserting that the sub-arrays
3558     // are all not-null.  This is not true in generally, as code can
3559     // slam NULLs down in the subarrays.
3560     if (make_constant) {
3561       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3562     } else {
3563       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3564     }
3565   }
3566 
3567   fatal(&quot;unhandled object type&quot;);
3568   return NULL;
3569 }
3570 
3571 //------------------------------get_con----------------------------------------
3572 intptr_t TypeOopPtr::get_con() const {
3573   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3574   assert(offset() &gt;= 0, &quot;&quot;);
3575 
3576   if (offset() != 0) {
</pre>
<hr />
<pre>
3766   return TypePtr::would_improve_type(exact_kls, inline_depth);
3767 }
3768 
3769 //=============================================================================
3770 // Convenience common pre-built types.
3771 const TypeInstPtr *TypeInstPtr::NOTNULL;
3772 const TypeInstPtr *TypeInstPtr::BOTTOM;
3773 const TypeInstPtr *TypeInstPtr::MIRROR;
3774 const TypeInstPtr *TypeInstPtr::MARK;
3775 const TypeInstPtr *TypeInstPtr::KLASS;
3776 
3777 //------------------------------TypeInstPtr-------------------------------------
3778 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
3779                          bool flat_array, int instance_id, const TypePtr* speculative,
3780                          int inline_depth)
3781   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
3782     _name(k-&gt;name()), _flat_array(flat_array) {
3783    assert(k != NULL &amp;&amp;
3784           (k-&gt;is_loaded() || o == NULL),
3785           &quot;cannot have constants with non-loaded klass&quot;);
<span class="line-modified">3786    assert(!klass()-&gt;is_valuetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">3787    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);</span>
3788 };
3789 
3790 //------------------------------make-------------------------------------------
3791 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3792                                      ciKlass* k,
3793                                      bool xk,
3794                                      ciObject* o,
3795                                      Offset offset,
3796                                      bool flat_array,
3797                                      int instance_id,
3798                                      const TypePtr* speculative,
3799                                      int inline_depth) {
3800   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3801   // Either const_oop() is NULL or else ptr is Constant
3802   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3803           &quot;constant pointers must have a value supplied&quot; );
3804   // Ptr is never Null
3805   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3806 
3807   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
</pre>
<hr />
<pre>
4233         else if (above_centerline(tinst -&gt;_ptr))
4234           o = this_oop;
4235         else
4236           ptr = NotNull;
4237       }
4238       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);
4239     } // Else classes are not equal
4240 
4241     // Since klasses are different, we require a LCA in the Java
4242     // class hierarchy - which means we have to fall to at least NotNull.
4243     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4244       ptr = NotNull;
4245 
4246     instance_id = InstanceBot;
4247 
4248     // Now we find the LCA of Java classes
4249     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4250     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4251   } // End of case InstPtr
4252 
<span class="line-modified">4253   case ValueType: {</span>
<span class="line-modified">4254     const TypeValueType* tv = t-&gt;is_valuetype();</span>
4255     if (above_centerline(ptr())) {
<span class="line-modified">4256       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {</span>
4257         return t;
4258       } else {
4259         return TypeInstPtr::NOTNULL;
4260       }
4261     } else {
4262       PTR ptr = this-&gt;_ptr;
4263       if (ptr == Constant) {
4264         ptr = NotNull;
4265       }
<span class="line-modified">4266       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {</span>
4267         return TypeInstPtr::make(ptr, _klass);
4268       } else {
4269         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4270       }
4271     }
4272   }
4273 
4274   } // End of switch
4275   return this;                  // Return the double constant
4276 }
4277 
4278 
4279 //------------------------java_mirror_type--------------------------------------
4280 ciType* TypeInstPtr::java_mirror_type() const {
4281   // must be a singleton type
4282   if( const_oop() == NULL )  return NULL;
4283 
4284   // must be of type java.lang.Class
4285   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
4286   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
</pre>
<hr />
<pre>
4326     }
4327   case BotPTR:
4328     if (!WizardMode &amp;&amp; !Verbose) {
4329       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4330       break;
4331     }
4332   case TopPTR:
4333   case AnyNull:
4334   case NotNull:
4335     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4336     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4337     break;
4338   default:
4339     break;
4340   }
4341 
4342   _offset.dump2(st);
4343 
4344   st-&gt;print(&quot; *&quot;);
4345 
<span class="line-modified">4346   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {</span>
4347     st-&gt;print(&quot; (flatten array)&quot;);
4348   }
4349 
4350   if (_instance_id == InstanceTop)
4351     st-&gt;print(&quot;,iid=top&quot;);
4352   else if (_instance_id != InstanceBot)
4353     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4354 
4355   dump_inline_depth(st);
4356   dump_speculative(st);
4357 }
4358 #endif
4359 
4360 //------------------------------add_offset-------------------------------------
4361 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4362   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),
4363               _instance_id, add_offset_speculative(offset), _inline_depth);
4364 }
4365 
4366 const Type *TypeInstPtr::remove_speculative() const {
</pre>
<hr />
<pre>
4384   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);
4385 }
4386 
4387 const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {
4388   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
4389 }
4390 
4391 
4392 //=============================================================================
4393 // Convenience common pre-built types.
4394 const TypeAryPtr *TypeAryPtr::RANGE;
4395 const TypeAryPtr *TypeAryPtr::OOPS;
4396 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4397 const TypeAryPtr *TypeAryPtr::BYTES;
4398 const TypeAryPtr *TypeAryPtr::SHORTS;
4399 const TypeAryPtr *TypeAryPtr::CHARS;
4400 const TypeAryPtr *TypeAryPtr::INTS;
4401 const TypeAryPtr *TypeAryPtr::LONGS;
4402 const TypeAryPtr *TypeAryPtr::FLOATS;
4403 const TypeAryPtr *TypeAryPtr::DOUBLES;
<span class="line-modified">4404 const TypeAryPtr *TypeAryPtr::VALUES;</span>
4405 
4406 //------------------------------make-------------------------------------------
4407 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4408                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4409   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4410          &quot;integral arrays must be pre-equipped with a class&quot;);
4411   if (!xk) xk = ary-&gt;ary_must_be_exact();
4412   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4413   if (!UseExactTypes)  xk = (ptr == Constant);
4414   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4415 }
4416 
4417 //------------------------------make-------------------------------------------
4418 const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4419                                    int instance_id, const TypePtr* speculative, int inline_depth,
4420                                    bool is_autobox_cache) {
4421   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4422          &quot;integral arrays must be pre-equipped with a class&quot;);
4423   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4424   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
</pre>
<hr />
<pre>
4687         // This must fall to bottom, not (int[-128..65535])[int+].
4688         instance_id = InstanceBot;
4689         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4690       }
4691     } else // Non integral arrays.
4692       // Must fall to bottom if exact klasses in upper lattice
4693       // are not equal or super klass is exact.
4694       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4695           // meet with top[] and bottom[] are processed further down:
4696           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4697           // both are exact and not equal:
4698           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4699            // &#39;tap&#39; is exact and super or unrelated:
4700            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4701            // &#39;this&#39; is exact and super or unrelated:
4702            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4703       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4704         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4705       }
4706       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
<span class="line-modified">4707     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_value_array_klass() != tap-&gt;klass()-&gt;is_value_array_klass()) {</span>
<span class="line-modified">4708       // Meeting flattened value type array with non-flattened array. Adjust (field) offset accordingly.</span>
<span class="line-modified">4709       if (tary-&gt;_elem-&gt;isa_valuetype()) {</span>
4710         // Result is flattened
<span class="line-modified">4711         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());</span>
<span class="line-modified">4712         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();</span>
4713       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4714         // Result is non-flattened
4715         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4716         field_off = Offset::bottom;
4717       }
4718     }
4719 
4720     bool xk = false;
4721     switch (tap-&gt;ptr()) {
4722     case AnyNull:
4723     case TopPTR:
4724       // Compute new klass on demand, do not use tap-&gt;_klass
4725       if (below_centerline(this-&gt;_ptr)) {
4726         xk = this-&gt;_klass_is_exact;
4727       } else {
4728         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4729       }
4730       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4731     case Constant: {
4732       ciObject* o = const_oop();
</pre>
<hr />
<pre>
4791         // then we can subclass in the Java class hierarchy.
4792         // For instances when a subclass meets a superclass we fall
4793         // below the centerline when the superclass is exact. We need
4794         // to do the same here.
4795         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {
4796           // that is, my array type is a subtype of &#39;tp&#39; klass
4797           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4798                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4799         }
4800       }
4801       // The other case cannot happen, since t cannot be a subtype of an array.
4802       // The meet falls down to Object class below centerline.
4803       if( ptr == Constant )
4804          ptr = NotNull;
4805       instance_id = InstanceBot;
4806       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4807     default: typerr(t);
4808     }
4809   }
4810 
<span class="line-modified">4811   case ValueType: {</span>
<span class="line-modified">4812     const TypeValueType* tv = t-&gt;is_valuetype();</span>
4813     if (above_centerline(ptr())) {
4814       return TypeInstPtr::NOTNULL;
4815     } else {
4816       PTR ptr = this-&gt;_ptr;
4817       if (ptr == Constant) {
4818         ptr = NotNull;
4819       }
4820       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4821     }
4822   }
4823   }
4824   return this;                  // Lint noise
4825 }
4826 
4827 //------------------------------xdual------------------------------------------
4828 // Dual: compute field-by-field dual
4829 const Type *TypeAryPtr::xdual() const {
4830   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4831 }
4832 
</pre>
<hr />
<pre>
4856   _ary-&gt;dump2(d,depth,st);
4857   switch( _ptr ) {
4858   case Constant:
4859     const_oop()-&gt;print(st);
4860     break;
4861   case BotPTR:
4862     if (!WizardMode &amp;&amp; !Verbose) {
4863       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4864       break;
4865     }
4866   case TopPTR:
4867   case AnyNull:
4868   case NotNull:
4869     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4870     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4871     break;
4872   default:
4873     break;
4874   }
4875 
<span class="line-modified">4876   if (elem()-&gt;isa_valuetype()) {</span>
4877     st-&gt;print(&quot;(&quot;);
4878     _field_offset.dump2(st);
4879     st-&gt;print(&quot;)&quot;);
4880   }
4881   if (offset() != 0) {
4882     int header_size = objArrayOopDesc::header_size() * wordSize;
4883     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);
4884     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);
4885     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());
4886     else {
4887       BasicType basic_elem_type = elem()-&gt;basic_type();
4888       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4889       int elem_size = type2aelembytes(basic_elem_type);
4890       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);
4891     }
4892   }
4893   st-&gt;print(&quot; *&quot;);
4894   if (_instance_id == InstanceTop)
4895     st-&gt;print(&quot;,iid=top&quot;);
4896   else if (_instance_id != InstanceBot)
</pre>
<hr />
<pre>
4929     return this;
4930   }
4931   return TypeOopPtr::cleanup_speculative();
4932 }
4933 
4934 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4935   if (!UseInlineDepthForSpeculativeTypes) {
4936     return this;
4937   }
4938   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);
4939 }
4940 
4941 const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {
4942   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4943 }
4944 
4945 const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {
4946   int adj = 0;
4947   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {
4948     const Type* elemtype = elem();
<span class="line-modified">4949     if (elemtype-&gt;isa_valuetype()) {</span>
4950       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {
4951         adj = _offset.get();
4952         offset += _offset.get();
4953       }
4954       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
4955       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {
4956         offset += _field_offset.get();
4957         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {
4958           offset += header;
4959         }
4960       }
4961       if (offset &gt;= (intptr_t)header || offset &lt; 0) {
<span class="line-modified">4962         // Try to get the field of the value type array element we are pointing to</span>
4963         ciKlass* arytype_klass = klass();
<span class="line-modified">4964         ciValueArrayKlass* vak = arytype_klass-&gt;as_value_array_klass();</span>
<span class="line-modified">4965         ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();</span>
4966         int shift = vak-&gt;log2_element_size();
4967         int mask = (1 &lt;&lt; shift) - 1;
4968         intptr_t field_offset = ((offset - header) &amp; mask);
4969         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);
4970         if (field == NULL) {
4971           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))
4972           return add_offset(offset);
4973         } else {
4974           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);
4975         }
4976       }
4977     }
4978   }
4979   return add_offset(offset - adj);
4980 }
4981 
<span class="line-modified">4982 // Return offset incremented by field_offset for flattened value type arrays</span>
4983 const int TypeAryPtr::flattened_offset() const {
4984   int offset = _offset.get();
4985   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;
4986       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {
4987     offset += _field_offset.get();
4988   }
4989   return offset;
4990 }
4991 
4992 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4993   assert(is_known_instance(), &quot;should be known&quot;);
4994   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);
4995 }
4996 
4997 //=============================================================================
4998 
4999 
5000 //------------------------------hash-------------------------------------------
5001 // Type-specific hashing function.
5002 int TypeNarrowPtr::hash(void) const {
</pre>
<hr />
<pre>
5073   case FloatTop:
5074   case FloatCon:
5075   case FloatBot:
5076   case DoubleTop:
5077   case DoubleCon:
5078   case DoubleBot:
5079   case AnyPtr:
5080   case RawPtr:
5081   case OopPtr:
5082   case InstPtr:
5083   case AryPtr:
5084   case MetadataPtr:
5085   case KlassPtr:
5086   case NarrowOop:
5087   case NarrowKlass:
5088   case Bottom:                  // Ye Olde Default
5089     return Type::BOTTOM;
5090   case Top:
5091     return this;
5092 
<span class="line-modified">5093   case ValueType:</span>
5094     return t-&gt;xmeet(this);
5095 
5096   default:                      // All else is a mistake
5097     typerr(t);
5098 
5099   } // End of switch
5100 
5101   return this;
5102 }
5103 
5104 #ifndef PRODUCT
5105 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5106   _ptrtype-&gt;dump2(d, depth, st);
5107 }
5108 #endif
5109 
5110 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
5111 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
5112 
5113 
</pre>
<hr />
<pre>
5329 }
5330 
5331 //------------------------------make-------------------------------------------
5332 // Create a meta data constant
5333 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {
5334   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5335   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5336 }
5337 
5338 
5339 //=============================================================================
5340 // Convenience common pre-built types.
5341 
5342 // Not-null object klass or below
5343 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5344 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5345 
5346 //------------------------------TypeKlassPtr-----------------------------------
5347 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
5348   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
<span class="line-modified">5349    assert(!klass-&gt;is_valuetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">5350    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);</span>
5351 }
5352 
5353 //------------------------------make-------------------------------------------
5354 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
5355 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
5356   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
5357   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();
5358 }
5359 
5360 //------------------------------eq---------------------------------------------
5361 // Structural equality check for Type representations
5362 bool TypeKlassPtr::eq( const Type *t ) const {
5363   const TypeKlassPtr *p = t-&gt;is_klassptr();
5364   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();
5365 }
5366 
5367 //------------------------------hash-------------------------------------------
5368 // Type-specific hashing function.
5369 int TypeKlassPtr::hash(void) const {
5370   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());
</pre>
<hr />
<pre>
5404   }
5405 
5406   return ft;
5407 }
5408 
5409 //----------------------compute_klass------------------------------------------
5410 // Compute the defining klass for this class
5411 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5412   // Compute _klass based on element type.
5413   ciKlass* k_ary = NULL;
5414   const TypeAryPtr *tary;
5415   const Type* el = elem();
5416   if (el-&gt;isa_narrowoop()) {
5417     el = el-&gt;make_ptr();
5418   }
5419 
5420   // Get element klass
5421   if (el-&gt;isa_instptr()) {
5422     // Compute object array klass from element klass
5423     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());
<span class="line-modified">5424   } else if (el-&gt;isa_valuetype()) {</span>
<span class="line-modified">5425     // If element type is TypeValueType::BOTTOM, value_klass() will be null.</span>
<span class="line-modified">5426     if (el-&gt;value_klass() != NULL) {</span>
<span class="line-modified">5427       k_ary = ciArrayKlass::make(el-&gt;value_klass());</span>
5428     }
5429   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5430     // Compute array klass from element klass
5431     ciKlass* k_elem = tary-&gt;klass();
5432     // If element type is something like bottom[], k_elem will be null.
5433     if (k_elem != NULL)
5434       k_ary = ciObjArrayKlass::make(k_elem);
5435   } else if ((el-&gt;base() == Type::Top) ||
5436              (el-&gt;base() == Type::Bottom)) {
5437     // element type of Bottom occurs from meet of basic type
5438     // and object; Top occurs when doing join on Bottom.
5439     // Leave k_ary at NULL.
5440   } else {
5441     // Cannot compute array klass directly from basic type,
5442     // since subtypes of TypeInt all have basic type T_INT.
5443 #ifdef ASSERT
5444     if (verify &amp;&amp; el-&gt;isa_int()) {
5445       // Check simple cases when verifying klass.
5446       BasicType bt = T_ILLEGAL;
5447       if (el == TypeInt::BYTE) {
</pre>
<hr />
<pre>
5514 
5515 //-----------------------------cast_to_exactness-------------------------------
5516 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5517   if( klass_is_exact == _klass_is_exact ) return this;
5518   if (!UseExactTypes)  return this;
5519   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);
5520 }
5521 
5522 
5523 //-----------------------------as_instance_type--------------------------------
5524 // Corresponding type for an instance of the given class.
5525 // It will be NotNull, and exact if and only if the klass type is exact.
5526 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5527   ciKlass* k = klass();
5528   assert(k != NULL, &quot;klass should not be NULL&quot;);
5529   bool    xk = klass_is_exact();
5530   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5531   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5532   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5533   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">5534   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {</span>
5535     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();
5536   }
5537   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5538 }
5539 
5540 
5541 //------------------------------xmeet------------------------------------------
5542 // Compute the MEET of two types, return a new Type object.
5543 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5544   // Perform a fast test for common case; meeting the same types together.
5545   if( this == t ) return this;  // Meeting same type-rep?
5546 
5547   // Current &quot;this-&gt;_base&quot; is Pointer
5548   switch (t-&gt;base()) {          // switch on original type
5549 
5550   case Int:                     // Mixing ints &amp; oops happens when javac
5551   case Long:                    // reuses local variables
5552   case FloatTop:
5553   case FloatCon:
5554   case FloatBot:
</pre>
<hr />
<pre>
5655       // If the klasses are equal, the constants may still differ.  Fall to
5656       // NotNull if they do (neither constant is NULL; that is a special case
5657       // handled elsewhere).
5658       if( ptr == Constant ) {
5659         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5660             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5661         else if (above_centerline(this-&gt;ptr()));
5662         else if (above_centerline(tkls-&gt;ptr()));
5663         else
5664           ptr = NotNull;
5665       }
5666       return make(ptr, this_klass, off, flat_array);
5667     } // Else classes are not equal
5668 
5669     // Since klasses are different, we require the LCA in the Java
5670     // class hierarchy - which means we have to fall to at least NotNull.
5671     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5672       ptr = NotNull;
5673     // Now we find the LCA of Java classes
5674     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">5675     return   make(ptr, k, off, k-&gt;is_valuetype() &amp;&amp; k-&gt;flatten_array());</span>
5676   } // End of case KlassPtr
5677 
5678   } // End of switch
5679   return this;                  // Return the double constant
5680 }
5681 
5682 //------------------------------xdual------------------------------------------
5683 // Dual: compute field-by-field dual
5684 const Type    *TypeKlassPtr::xdual() const {
5685   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());
5686 }
5687 
5688 //------------------------------get_con----------------------------------------
5689 intptr_t TypeKlassPtr::get_con() const {
5690   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5691   assert(offset() &gt;= 0, &quot;&quot;);
5692 
5693   if (offset() != 0) {
5694     // After being ported to the compiler interface, the compiler no longer
5695     // directly manipulates the addresses of oops.  Rather, it only has a pointer
</pre>
<hr />
<pre>
5750 
5751 const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {
5752   return make(domain, domain, range, range);
5753 }
5754 
5755 //------------------------------osr_domain-----------------------------
5756 const TypeTuple* osr_domain() {
5757   const Type **fields = TypeTuple::fields(2);
5758   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
5759   return TypeTuple::make(TypeFunc::Parms+1, fields);
5760 }
5761 
5762 //------------------------------make-------------------------------------------
5763 const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {
5764   Compile* C = Compile::current();
5765   const TypeFunc* tf = NULL;
5766   if (!is_osr_compilation) {
5767     tf = C-&gt;last_tf(method); // check cache
5768     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5769   }
<span class="line-modified">5770   // Value types are not passed/returned by reference, instead each field of</span>
<span class="line-modified">5771   // the value type is passed/returned as an argument. We maintain two views of</span>
<span class="line-modified">5772   // the argument/return list here: one based on the signature (with a value</span>
5773   // type argument/return as a single slot), one based on the actual calling
<span class="line-modified">5774   // convention (with a value type argument/return as a list of its fields).</span>
5775   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;
5776   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);
5777   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;
5778   ciSignature* sig = method-&gt;signature();
<span class="line-modified">5779   bool has_scalar_ret = sig-&gt;return_type()-&gt;is_valuetype() &amp;&amp; sig-&gt;return_type()-&gt;as_value_klass()-&gt;can_be_returned_as_fields();</span>
5780   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);
5781   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;
5782   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);
5783   if (!is_osr_compilation) {
5784     C-&gt;set_last_tf(method, tf);  // fill cache
5785   }
5786   return tf;
5787 }
5788 
5789 //------------------------------meet-------------------------------------------
5790 // Compute the MEET of two types.  It returns a new Type object.
5791 const Type *TypeFunc::xmeet( const Type *t ) const {
5792   // Perform a fast test for common case; meeting the same types together.
5793   if( this == t ) return this;  // Meeting same type-rep?
5794 
5795   // Current &quot;this-&gt;_base&quot; is Func
5796   switch (t-&gt;base()) {          // switch on original type
5797 
5798   case Bottom:                  // Ye Olde Default
5799     return t;
</pre>
</td>
<td>
<hr />
<pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<span class="line-added">  26 #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
  27 #include &quot;ci/ciField.hpp&quot;
<span class="line-added">  28 #include &quot;ci/ciInlineKlass.hpp&quot;</span>
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciTypeFlow.hpp&quot;

  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/instanceKlass.hpp&quot;
  38 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/typeArrayKlass.hpp&quot;
  41 #include &quot;opto/matcher.hpp&quot;
  42 #include &quot;opto/node.hpp&quot;
  43 #include &quot;opto/opcodes.hpp&quot;
  44 #include &quot;opto/type.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 
  47 // Portions of code courtesy of Clifford Click
  48 
  49 // Optimization - Graph Style
  50 
</pre>
<hr />
<pre>
 112 
 113 #if defined(PPC64)
 114   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 115   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 116   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 117   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 118   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 119 #elif defined(S390)
 120   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 121   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 122   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 123   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 124   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 125 #else // all other
 126   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 127   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 128   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 129   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 130   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 131 #endif
<span class="line-modified"> 132   { Bad,             T_INLINE_TYPE, &quot;inline:&quot;,      false, Node::NotAMachineReg, relocInfo::none          },  // InlineType</span>
 133   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 134   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 135   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 136   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 137   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 138   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 139   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 140   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 141   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 142   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 143   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 144   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 145   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 146   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 147   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 148   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 149   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 150   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 151 };
 152 
</pre>
<hr />
<pre>
 244     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 245     return TypePtr::NULL_PTR;
 246 
 247   case ciTypeFlow::StateVector::T_LONG2:
 248     // The ciTypeFlow pass pushes a long, then the half.
 249     // We do the same.
 250     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 251     return TypeInt::TOP;
 252 
 253   case ciTypeFlow::StateVector::T_DOUBLE2:
 254     // The ciTypeFlow pass pushes double, then the half.
 255     // Our convention is the same.
 256     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 257     return Type::TOP;
 258 
 259   case T_ADDRESS:
 260     assert(type-&gt;is_return_address(), &quot;&quot;);
 261     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 262 
 263   case T_INLINE_TYPE: {
<span class="line-modified"> 264     ciInlineKlass* vk = type-&gt;as_inline_klass();</span>
 265     if (vk-&gt;is_scalarizable()) {
<span class="line-modified"> 266       return TypeInlineType::make(vk);</span>
 267     } else {
 268       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(TypePtr::NOTNULL);
 269     }
 270   }
 271 
 272   default:
 273     // make sure we did not mix up the cases:
 274     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 275     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 276     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 277     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 278     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 279     assert(!type-&gt;is_return_address(), &quot;&quot;);
 280 
 281     return Type::get_const_type(type);
 282   }
 283 }
 284 
 285 
 286 //-----------------------make_from_constant------------------------------------
</pre>
<hr />
<pre>
 579 
 580   const Type **fmembar = TypeTuple::fields(0);
 581   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 582 
 583   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 584   fsc[0] = TypeInt::CC;
 585   fsc[1] = Type::MEMORY;
 586   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 587 
 588   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 589   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 590   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 591   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 592                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);
 593   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 594                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
 595   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 596 
 597   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 598 
<span class="line-modified"> 599   TypeInlineType::BOTTOM = TypeInlineType::make(NULL);</span>
 600 
 601   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 602   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 603 
 604   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 605 
 606   mreg2type[Op_Node] = Type::BOTTOM;
 607   mreg2type[Op_Set ] = 0;
 608   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 609   mreg2type[Op_RegI] = TypeInt::INT;
 610   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 611   mreg2type[Op_RegF] = Type::FLOAT;
 612   mreg2type[Op_RegD] = Type::DOUBLE;
 613   mreg2type[Op_RegL] = TypeLong::LONG;
 614   mreg2type[Op_RegFlags] = TypeInt::CC;
 615 
 616   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));
 617 
 618   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 619 
 620 #ifdef _LP64
 621   if (UseCompressedOops) {
 622     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 623     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 624   } else
 625 #endif
 626   {
 627     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 628     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 629   }
 630   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);
 631   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);
 632   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
 633   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 634   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 635   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 636   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
<span class="line-modified"> 637   TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);</span>
 638 
 639   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 640   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 641   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 642   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;
 643   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 644   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 645   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 646   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 647   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 648   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 649   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 650   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 651   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 652 
 653   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 654   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 655 
 656   const Type **fi2c = TypeTuple::fields(2);
 657   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
</pre>
<hr />
<pre>
 970 
 971   case OopPtr:
 972     return t-&gt;xmeet(this);
 973 
 974   case InstPtr:
 975     return t-&gt;xmeet(this);
 976 
 977   case MetadataPtr:
 978   case KlassPtr:
 979     return t-&gt;xmeet(this);
 980 
 981   case AryPtr:
 982     return t-&gt;xmeet(this);
 983 
 984   case NarrowOop:
 985     return t-&gt;xmeet(this);
 986 
 987   case NarrowKlass:
 988     return t-&gt;xmeet(this);
 989 
<span class="line-modified"> 990   case InlineType:</span>
 991     return t-&gt;xmeet(this);
 992 
 993   case Bad:                     // Type check
 994   default:                      // Bogus type not in lattice
 995     typerr(t);
 996     return Type::BOTTOM;
 997 
 998   case Bottom:                  // Ye Olde Default
 999     return t;
1000 
1001   case FloatTop:
1002     if( _base == FloatTop ) return this;
1003   case FloatBot:                // Float
1004     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
1005     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
1006     typerr(t);
1007     return Type::BOTTOM;
1008 
1009   case DoubleTop:
1010     if( _base == DoubleTop ) return this;
</pre>
<hr />
<pre>
1040 
1041 //------------------------------xdual------------------------------------------
1042 // Compute dual right now.
1043 const Type::TYPES Type::dual_type[Type::lastype] = {
1044   Bad,          // Bad
1045   Control,      // Control
1046   Bottom,       // Top
1047   Bad,          // Int - handled in v-call
1048   Bad,          // Long - handled in v-call
1049   Half,         // Half
1050   Bad,          // NarrowOop - handled in v-call
1051   Bad,          // NarrowKlass - handled in v-call
1052 
1053   Bad,          // Tuple - handled in v-call
1054   Bad,          // Array - handled in v-call
1055   Bad,          // VectorS - handled in v-call
1056   Bad,          // VectorD - handled in v-call
1057   Bad,          // VectorX - handled in v-call
1058   Bad,          // VectorY - handled in v-call
1059   Bad,          // VectorZ - handled in v-call
<span class="line-modified">1060   Bad,          // InlineType - handled in v-call</span>
1061 
1062   Bad,          // AnyPtr - handled in v-call
1063   Bad,          // RawPtr - handled in v-call
1064   Bad,          // OopPtr - handled in v-call
1065   Bad,          // InstPtr - handled in v-call
1066   Bad,          // AryPtr - handled in v-call
1067 
1068   Bad,          //  MetadataPtr - handled in v-call
1069   Bad,          // KlassPtr - handled in v-call
1070 
1071   Bad,          // Function - handled in v-call
1072   Abio,         // Abio
1073   Return_Address,// Return_Address
1074   Memory,       // Memory
1075   FloatBot,     // FloatTop
1076   FloatCon,     // FloatCon
1077   FloatTop,     // FloatBot
1078   DoubleBot,    // DoubleTop
1079   DoubleCon,    // DoubleCon
1080   DoubleTop,    // DoubleBot
</pre>
<hr />
<pre>
1936 
1937 bool TypeLong::empty(void) const {
1938   return _lo &gt; _hi;
1939 }
1940 
1941 //=============================================================================
1942 // Convenience common pre-built types.
1943 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1944 const TypeTuple *TypeTuple::IFFALSE;
1945 const TypeTuple *TypeTuple::IFTRUE;
1946 const TypeTuple *TypeTuple::IFNEITHER;
1947 const TypeTuple *TypeTuple::LOOPBODY;
1948 const TypeTuple *TypeTuple::MEMBAR;
1949 const TypeTuple *TypeTuple::STORECONDITIONAL;
1950 const TypeTuple *TypeTuple::START_I2C;
1951 const TypeTuple *TypeTuple::INT_PAIR;
1952 const TypeTuple *TypeTuple::LONG_PAIR;
1953 const TypeTuple *TypeTuple::INT_CC_PAIR;
1954 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1955 
<span class="line-modified">1956 static void collect_inline_fields(ciInlineKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {</span>
1957   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
1958     ciField* field = vk-&gt;nonstatic_field_at(j);
1959     BasicType bt = field-&gt;type()-&gt;basic_type();
1960     const Type* ft = Type::get_const_type(field-&gt;type());
1961     field_array[pos++] = ft;
1962     if (type2size[bt] == 2) {
1963       field_array[pos++] = Type::HALF;
1964     }
1965     // Skip reserved arguments
1966     while (SigEntry::next_is_reserved(sig_cc, bt)) {
1967       field_array[pos++] = Type::get_const_basic_type(bt);
1968       if (type2size[bt] == 2) {
1969         field_array[pos++] = Type::HALF;
1970       }
1971     }
1972   }
1973 }
1974 
1975 //------------------------------make-------------------------------------------
1976 // Make a TypeTuple from the range of a method signature
1977 const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {
1978   ciType* return_type = sig-&gt;return_type();
1979   uint arg_cnt = return_type-&gt;size();
1980   if (ret_vt_fields) {
<span class="line-modified">1981     arg_cnt = return_type-&gt;as_inline_klass()-&gt;inline_arg_slots() + 1;</span>
1982   }
1983 
1984   const Type **field_array = fields(arg_cnt);
1985   switch (return_type-&gt;basic_type()) {
1986   case T_LONG:
1987     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1988     field_array[TypeFunc::Parms+1] = Type::HALF;
1989     break;
1990   case T_DOUBLE:
1991     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1992     field_array[TypeFunc::Parms+1] = Type::HALF;
1993     break;
1994   case T_OBJECT:
1995   case T_ARRAY:
1996   case T_BOOLEAN:
1997   case T_CHAR:
1998   case T_FLOAT:
1999   case T_BYTE:
2000   case T_SHORT:
2001   case T_INT:
2002     field_array[TypeFunc::Parms] = get_const_type(return_type);
2003     break;
2004   case T_INLINE_TYPE:
2005     if (ret_vt_fields) {
2006       uint pos = TypeFunc::Parms;
2007       field_array[pos] = TypePtr::BOTTOM;
2008       pos++;
2009       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
<span class="line-modified">2010       collect_inline_fields(return_type-&gt;as_inline_klass(), field_array, pos, sig);</span>
2011     } else {
2012       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(TypePtr::NOTNULL);
2013     }
2014     break;
2015   case T_VOID:
2016     break;
2017   default:
2018     ShouldNotReachHere();
2019   }
2020   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2021 }
2022 
2023 // Make a TypeTuple from the domain of a method signature
2024 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
2025   ciSignature* sig = method-&gt;signature();
2026   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());
2027 
2028   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);
2029   if (vt_fields_as_args) {
2030     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {
2031       arg_cnt += type2size[(*sig_cc)._bt];
2032     }
2033     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());
2034   }
2035 
2036   uint pos = TypeFunc::Parms;
2037   const Type** field_array = fields(arg_cnt);
2038   if (!method-&gt;is_static()) {
2039     ciInstanceKlass* recv = method-&gt;holder();
<span class="line-modified">2040     if (vt_fields_as_args &amp;&amp; recv-&gt;is_inlinetype() &amp;&amp; recv-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {</span>
<span class="line-modified">2041       collect_inline_fields(recv-&gt;as_inline_klass(), field_array, pos, sig_cc);</span>
2042     } else {
2043       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
2044       if (vt_fields_as_args) {
2045         ++sig_cc;
2046       }
2047     }
2048   }
2049 
2050   int i = 0;
2051   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2052     ciType* type = sig-&gt;type_at(i);
2053     BasicType bt = type-&gt;basic_type();
2054     bool is_flattened = false;
2055 
2056     switch (bt) {
2057     case T_LONG:
2058       field_array[pos++] = TypeLong::LONG;
2059       field_array[pos++] = Type::HALF;
2060       break;
2061     case T_DOUBLE:
2062       field_array[pos++] = Type::DOUBLE;
2063       field_array[pos++] = Type::HALF;
2064       break;
2065     case T_OBJECT:
2066     case T_ARRAY:
2067     case T_FLOAT:
2068     case T_INT:
2069       field_array[pos++] = get_const_type(type);
2070       break;
2071     case T_BOOLEAN:
2072     case T_CHAR:
2073     case T_BYTE:
2074     case T_SHORT:
2075       field_array[pos++] = TypeInt::INT;
2076       break;
2077     case T_INLINE_TYPE: {
<span class="line-modified">2078       if (vt_fields_as_args &amp;&amp; type-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {</span>
2079         is_flattened = true;
<span class="line-modified">2080         collect_inline_fields(type-&gt;as_inline_klass(), field_array, pos, sig_cc);</span>
2081       } else {
2082         field_array[pos++] = get_const_type(type)-&gt;join_speculative(TypePtr::NOTNULL);
2083       }
2084       break;
2085     }
2086     default:
2087       ShouldNotReachHere();
2088     }
2089     // Skip reserved arguments
2090     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2091       field_array[pos++] = Type::get_const_basic_type(bt);
2092       if (type2size[bt] == 2) {
2093         field_array[pos++] = Type::HALF;
2094       }
2095     }
2096     i++;
2097   }
2098   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);
2099 
2100   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
</pre>
<hr />
<pre>
2380   ciKlass* tklass = toop-&gt;klass();
2381   if (tklass == NULL)       return false;  // unloaded class
2382   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2383   const TypeInstPtr* tinst;
2384   if (_elem-&gt;isa_narrowoop())
2385     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2386   else
2387     tinst = _elem-&gt;isa_instptr();
2388   if (tinst)
2389     return tklass-&gt;as_instance_klass()-&gt;is_final();
2390   const TypeAryPtr*  tap;
2391   if (_elem-&gt;isa_narrowoop())
2392     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2393   else
2394     tap = _elem-&gt;isa_aryptr();
2395   if (tap)
2396     return tap-&gt;ary()-&gt;ary_must_be_exact();
2397   return false;
2398 }
2399 
<span class="line-modified">2400 //==============================TypeInlineType=======================================</span>
2401 
<span class="line-modified">2402 const TypeInlineType *TypeInlineType::BOTTOM;</span>
2403 
2404 //------------------------------make-------------------------------------------
<span class="line-modified">2405 const TypeInlineType* TypeInlineType::make(ciInlineKlass* vk, bool larval) {</span>
<span class="line-modified">2406   return (TypeInlineType*)(new TypeInlineType(vk, larval))-&gt;hashcons();</span>
2407 }
2408 
2409 //------------------------------meet-------------------------------------------
2410 // Compute the MEET of two types.  It returns a new Type object.
<span class="line-modified">2411 const Type* TypeInlineType::xmeet(const Type* t) const {</span>
2412   // Perform a fast test for common case; meeting the same types together.
2413   if(this == t) return this;  // Meeting same type-rep?
2414 
<span class="line-modified">2415   // Current &quot;this-&gt;_base&quot; is InlineType</span>
2416   switch (t-&gt;base()) {          // switch on original type
2417 
2418   case Int:
2419   case Long:
2420   case FloatTop:
2421   case FloatCon:
2422   case FloatBot:
2423   case DoubleTop:
2424   case DoubleCon:
2425   case DoubleBot:
2426   case NarrowKlass:
2427   case Bottom:
2428     return Type::BOTTOM;
2429 
2430   case OopPtr:
2431   case MetadataPtr:
2432   case KlassPtr:
2433   case RawPtr:
2434     return TypePtr::BOTTOM;
2435 
2436   case Top:
2437     return this;
2438 
2439   case NarrowOop: {
2440     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);
2441     if (res-&gt;isa_ptr()) {
2442       return res-&gt;make_narrowoop();
2443     }
2444     return res;
2445   }
2446 
2447   case AryPtr:
2448   case InstPtr: {
2449     return t-&gt;xmeet(this);
2450   }
2451 
<span class="line-modified">2452   case InlineType: {</span>
<span class="line-modified">2453     // All inline types inherit from Object</span>
<span class="line-modified">2454     const TypeInlineType* other = t-&gt;is_inlinetype();</span>
2455     if (_vk == NULL) {
2456       return this;
2457     } else if (other-&gt;_vk == NULL) {
2458       return other;
2459     } else if (_vk == other-&gt;_vk) {
2460       if (_larval == other-&gt;_larval ||
2461           !_larval) {
2462         return this;
2463       } else {
2464         return t;
2465       }
2466     }
2467     return TypeInstPtr::NOTNULL;
2468   }
2469 
2470   default:                      // All else is a mistake
2471     typerr(t);
2472 
2473   }
2474   return this;
2475 }
2476 
2477 //------------------------------xdual------------------------------------------
<span class="line-modified">2478 const Type* TypeInlineType::xdual() const {</span>
2479   return this;
2480 }
2481 
2482 //------------------------------eq---------------------------------------------
2483 // Structural equality check for Type representations
<span class="line-modified">2484 bool TypeInlineType::eq(const Type* t) const {</span>
<span class="line-modified">2485   const TypeInlineType* vt = t-&gt;is_inlinetype();</span>
<span class="line-modified">2486   return (_vk == vt-&gt;inline_klass() &amp;&amp; _larval == vt-&gt;larval());</span>
2487 }
2488 
2489 //------------------------------hash-------------------------------------------
2490 // Type-specific hashing function.
<span class="line-modified">2491 int TypeInlineType::hash(void) const {</span>
2492   return (intptr_t)_vk;
2493 }
2494 
2495 //------------------------------singleton--------------------------------------
2496 // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.
<span class="line-modified">2497 bool TypeInlineType::singleton(void) const {</span>
2498   return false;
2499 }
2500 
2501 //------------------------------empty------------------------------------------
2502 // TRUE if Type is a type with no values, FALSE otherwise.
<span class="line-modified">2503 bool TypeInlineType::empty(void) const {</span>
2504   return false;
2505 }
2506 
2507 //------------------------------dump2------------------------------------------
2508 #ifndef PRODUCT
<span class="line-modified">2509 void TypeInlineType::dump2(Dict &amp;d, uint depth, outputStream* st) const {</span>
2510   if (_vk == NULL) {
<span class="line-modified">2511     st-&gt;print(&quot;BOTTOM inlinetype&quot;);</span>
2512     return;
2513   }
2514   int count = _vk-&gt;nof_declared_nonstatic_fields();
<span class="line-modified">2515   st-&gt;print(&quot;inlinetype[%d]:{&quot;, count);</span>
2516   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);
2517   for (int i = 1; i &lt; count; ++i) {
2518     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());
2519   }
2520   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);
2521 }
2522 #endif
2523 
2524 //==============================TypeVect=======================================
2525 // Convenience common pre-built types.
2526 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2527 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2528 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2529 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2530 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2531 
2532 //------------------------------make-------------------------------------------
2533 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2534   BasicType elem_bt = elem-&gt;array_element_basic_type();
2535   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
</pre>
<hr />
<pre>
3231     _klass_is_exact(xk),
3232     _is_ptr_to_narrowoop(false),
3233     _is_ptr_to_narrowklass(false),
3234     _is_ptr_to_boxed_value(false),
3235     _instance_id(instance_id) {
3236   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
3237       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
3238     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());
3239   }
3240 #ifdef _LP64
3241   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {
3242     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
3243       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3244     } else if (klass() == NULL) {
3245       // Array with unknown body type
3246       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3247       _is_ptr_to_narrowoop = UseCompressedOops;
3248     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
3249       if (klass()-&gt;is_obj_array_klass()) {
3250         _is_ptr_to_narrowoop = true;
<span class="line-modified">3251       } else if (klass()-&gt;is_flat_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {</span>
<span class="line-modified">3252         // Check if the field of the inline type array element contains oops</span>
<span class="line-modified">3253         ciInlineKlass* vk = klass()-&gt;as_flat_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
3254         int foffset = field_offset.get() + vk-&gt;first_field_offset();
3255         ciField* field = vk-&gt;get_field_by_offset(foffset, false);
3256         assert(field != NULL, &quot;missing field&quot;);
3257         BasicType bt = field-&gt;layout_type();
3258         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);
3259       }
3260     } else if (klass()-&gt;is_instance_klass()) {
3261       if (this-&gt;isa_klassptr()) {
3262         // Perm objects don&#39;t use compressed references
3263       } else if (_offset == Offset::bottom || _offset == Offset::top) {
3264         // unsafe access
3265         _is_ptr_to_narrowoop = UseCompressedOops;
3266       } else { // exclude unsafe ops
3267         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3268         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3269             (this-&gt;offset() == java_lang_Class::klass_offset() ||
3270              this-&gt;offset() == java_lang_Class::array_klass_offset())) {
3271           // Special hidden fields from the Class.
3272           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3273           _is_ptr_to_narrowoop = false;
3274         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3275                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3276           // Static fields
3277           assert(o != NULL, &quot;must be constant&quot;);
3278           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3279           BasicType basic_elem_type;
<span class="line-modified">3280           if (ik-&gt;is_inlinetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_inline_klass()-&gt;default_value_offset()) {</span>
<span class="line-modified">3281             // Special hidden field that contains the oop of the default inline type</span>
3282             basic_elem_type = T_INLINE_TYPE;
3283           } else {
3284             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
3285             assert(field != NULL, &quot;missing field&quot;);
3286             basic_elem_type = field-&gt;layout_type();
3287           }
3288           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3289         } else {
3290           // Instance fields which contains a compressed oop references.
3291           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3292           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);
3293           if (field != NULL) {
3294             BasicType basic_elem_type = field-&gt;layout_type();
3295             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3296           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3297             // Compile::find_alias_type() cast exactness on all types to verify
3298             // that it does not affect alias type.
3299             _is_ptr_to_narrowoop = UseCompressedOops;
3300           } else {
3301             // Type for the copy start in LibraryCallKit::inline_native_clone().
</pre>
<hr />
<pre>
3419   case InstPtr:                  // For these, flip the call around to cut down
3420   case AryPtr:
3421     return t-&gt;xmeet(this);      // Call in reverse direction
3422 
3423   } // End of switch
3424   return this;                  // Return the double constant
3425 }
3426 
3427 
3428 //------------------------------xdual------------------------------------------
3429 // Dual of a pure heap pointer.  No relevant klass or oop information.
3430 const Type *TypeOopPtr::xdual() const {
3431   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3432   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3433   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());
3434 }
3435 
3436 //--------------------------make_from_klass_common-----------------------------
3437 // Computes the element-type given a klass.
3438 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="line-modified">3439   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {</span>
3440     Compile* C = Compile::current();
3441     Dependencies* deps = C-&gt;dependencies();
3442     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3443     // Element is an instance
3444     bool klass_is_exact = false;
3445     if (klass-&gt;is_loaded()) {
3446       // Try to set klass_is_exact.
3447       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3448       klass_is_exact = ik-&gt;is_final();
3449       if (!klass_is_exact &amp;&amp; klass_change
3450           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3451         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3452         if (sub != NULL) {
3453           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3454           klass = ik = sub;
3455           klass_is_exact = sub-&gt;is_final();
3456         }
3457       }
3458       if (!klass_is_exact &amp;&amp; try_for_exact
3459           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3460         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3461           // Add a dependence; if concrete subclass added we need to recompile
3462           deps-&gt;assert_leaf_type(ik);
3463           klass_is_exact = true;
3464         }
3465       }
3466     }
3467     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
3468   } else if (klass-&gt;is_obj_array_klass()) {
<span class="line-modified">3469     // Element is an object or inline type array. Recursively call ourself.</span>
3470     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
<span class="line-modified">3471     if (etype-&gt;is_inlinetypeptr()) {</span>
3472       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3473     }
3474     // Determine null-free/flattened properties
3475     const TypeOopPtr* exact_etype = etype;
<span class="line-modified">3476     if (etype-&gt;can_be_inline_type()) {</span>
<span class="line-modified">3477       // Use exact type if element can be an inline type</span>
3478       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
3479     }
<span class="line-modified">3480     bool not_null_free = !exact_etype-&gt;can_be_inline_type();</span>
<span class="line-modified">3481     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_inlinetypeptr() &amp;&amp; !exact_etype-&gt;inline_klass()-&gt;flatten_array());</span>
3482 
3483     bool xk = etype-&gt;klass_is_exact();
3484     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3485     // We used to pass NotNull in here, asserting that the sub-arrays
3486     // are all not-null.  This is not true in generally, as code can
3487     // slam NULLs down in the subarrays.
3488     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
3489     return arr;
3490   } else if (klass-&gt;is_type_array_klass()) {
3491     // Element is an typeArray
3492     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3493     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,
3494                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3495     // We used to pass NotNull in here, asserting that the array pointer
3496     // is not-null. That was not true in general.
3497     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3498     return arr;
<span class="line-modified">3499   } else if (klass-&gt;is_flat_array_klass()) {</span>
<span class="line-modified">3500     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-modified">3501     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::POS);</span>
3502     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3503     return arr;
3504   } else {
3505     ShouldNotReachHere();
3506     return NULL;
3507   }
3508 }
3509 
3510 //------------------------------make_from_constant-----------------------------
3511 // Make a java pointer from an oop constant
3512 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3513   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3514 
3515   const bool make_constant = require_constant || o-&gt;should_be_constant();
3516 
3517   ciKlass* klass = o-&gt;klass();
<span class="line-modified">3518   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {</span>
<span class="line-modified">3519     // Element is an instance or inline type</span>
3520     if (make_constant) {
3521       return TypeInstPtr::make(o);
3522     } else {
3523       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
3524     }
3525   } else if (klass-&gt;is_obj_array_klass()) {
3526     // Element is an object array. Recursively call ourself.
3527     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
3528     bool null_free = false;
<span class="line-modified">3529     if (etype-&gt;is_inlinetypeptr()) {</span>
3530       null_free = true;
3531       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3532     }
3533     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3534                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3535     // We used to pass NotNull in here, asserting that the sub-arrays
3536     // are all not-null.  This is not true in generally, as code can
3537     // slam NULLs down in the subarrays.
3538     if (make_constant) {
3539       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3540     } else {
3541       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3542     }
3543   } else if (klass-&gt;is_type_array_klass()) {
3544     // Element is an typeArray
3545     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3546     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3547                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3548     // We used to pass NotNull in here, asserting that the array pointer
3549     // is not-null. That was not true in general.
3550     if (make_constant) {
3551       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3552     } else {
3553       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3554     }
<span class="line-modified">3555   } else if (klass-&gt;is_flat_array_klass()) {</span>
<span class="line-modified">3556     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-modified">3557     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
3558     // We used to pass NotNull in here, asserting that the sub-arrays
3559     // are all not-null.  This is not true in generally, as code can
3560     // slam NULLs down in the subarrays.
3561     if (make_constant) {
3562       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3563     } else {
3564       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3565     }
3566   }
3567 
3568   fatal(&quot;unhandled object type&quot;);
3569   return NULL;
3570 }
3571 
3572 //------------------------------get_con----------------------------------------
3573 intptr_t TypeOopPtr::get_con() const {
3574   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3575   assert(offset() &gt;= 0, &quot;&quot;);
3576 
3577   if (offset() != 0) {
</pre>
<hr />
<pre>
3767   return TypePtr::would_improve_type(exact_kls, inline_depth);
3768 }
3769 
3770 //=============================================================================
3771 // Convenience common pre-built types.
3772 const TypeInstPtr *TypeInstPtr::NOTNULL;
3773 const TypeInstPtr *TypeInstPtr::BOTTOM;
3774 const TypeInstPtr *TypeInstPtr::MIRROR;
3775 const TypeInstPtr *TypeInstPtr::MARK;
3776 const TypeInstPtr *TypeInstPtr::KLASS;
3777 
3778 //------------------------------TypeInstPtr-------------------------------------
3779 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
3780                          bool flat_array, int instance_id, const TypePtr* speculative,
3781                          int inline_depth)
3782   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
3783     _name(k-&gt;name()), _flat_array(flat_array) {
3784    assert(k != NULL &amp;&amp;
3785           (k-&gt;is_loaded() || o == NULL),
3786           &quot;cannot have constants with non-loaded klass&quot;);
<span class="line-modified">3787    assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">3788    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
3789 };
3790 
3791 //------------------------------make-------------------------------------------
3792 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3793                                      ciKlass* k,
3794                                      bool xk,
3795                                      ciObject* o,
3796                                      Offset offset,
3797                                      bool flat_array,
3798                                      int instance_id,
3799                                      const TypePtr* speculative,
3800                                      int inline_depth) {
3801   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3802   // Either const_oop() is NULL or else ptr is Constant
3803   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3804           &quot;constant pointers must have a value supplied&quot; );
3805   // Ptr is never Null
3806   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3807 
3808   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
</pre>
<hr />
<pre>
4234         else if (above_centerline(tinst -&gt;_ptr))
4235           o = this_oop;
4236         else
4237           ptr = NotNull;
4238       }
4239       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);
4240     } // Else classes are not equal
4241 
4242     // Since klasses are different, we require a LCA in the Java
4243     // class hierarchy - which means we have to fall to at least NotNull.
4244     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4245       ptr = NotNull;
4246 
4247     instance_id = InstanceBot;
4248 
4249     // Now we find the LCA of Java classes
4250     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4251     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4252   } // End of case InstPtr
4253 
<span class="line-modified">4254   case InlineType: {</span>
<span class="line-modified">4255     const TypeInlineType* tv = t-&gt;is_inlinetype();</span>
4256     if (above_centerline(ptr())) {
<span class="line-modified">4257       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {</span>
4258         return t;
4259       } else {
4260         return TypeInstPtr::NOTNULL;
4261       }
4262     } else {
4263       PTR ptr = this-&gt;_ptr;
4264       if (ptr == Constant) {
4265         ptr = NotNull;
4266       }
<span class="line-modified">4267       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {</span>
4268         return TypeInstPtr::make(ptr, _klass);
4269       } else {
4270         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4271       }
4272     }
4273   }
4274 
4275   } // End of switch
4276   return this;                  // Return the double constant
4277 }
4278 
4279 
4280 //------------------------java_mirror_type--------------------------------------
4281 ciType* TypeInstPtr::java_mirror_type() const {
4282   // must be a singleton type
4283   if( const_oop() == NULL )  return NULL;
4284 
4285   // must be of type java.lang.Class
4286   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
4287   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
</pre>
<hr />
<pre>
4327     }
4328   case BotPTR:
4329     if (!WizardMode &amp;&amp; !Verbose) {
4330       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4331       break;
4332     }
4333   case TopPTR:
4334   case AnyNull:
4335   case NotNull:
4336     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4337     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4338     break;
4339   default:
4340     break;
4341   }
4342 
4343   _offset.dump2(st);
4344 
4345   st-&gt;print(&quot; *&quot;);
4346 
<span class="line-modified">4347   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
4348     st-&gt;print(&quot; (flatten array)&quot;);
4349   }
4350 
4351   if (_instance_id == InstanceTop)
4352     st-&gt;print(&quot;,iid=top&quot;);
4353   else if (_instance_id != InstanceBot)
4354     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4355 
4356   dump_inline_depth(st);
4357   dump_speculative(st);
4358 }
4359 #endif
4360 
4361 //------------------------------add_offset-------------------------------------
4362 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4363   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),
4364               _instance_id, add_offset_speculative(offset), _inline_depth);
4365 }
4366 
4367 const Type *TypeInstPtr::remove_speculative() const {
</pre>
<hr />
<pre>
4385   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);
4386 }
4387 
4388 const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {
4389   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
4390 }
4391 
4392 
4393 //=============================================================================
4394 // Convenience common pre-built types.
4395 const TypeAryPtr *TypeAryPtr::RANGE;
4396 const TypeAryPtr *TypeAryPtr::OOPS;
4397 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4398 const TypeAryPtr *TypeAryPtr::BYTES;
4399 const TypeAryPtr *TypeAryPtr::SHORTS;
4400 const TypeAryPtr *TypeAryPtr::CHARS;
4401 const TypeAryPtr *TypeAryPtr::INTS;
4402 const TypeAryPtr *TypeAryPtr::LONGS;
4403 const TypeAryPtr *TypeAryPtr::FLOATS;
4404 const TypeAryPtr *TypeAryPtr::DOUBLES;
<span class="line-modified">4405 const TypeAryPtr *TypeAryPtr::INLINES;</span>
4406 
4407 //------------------------------make-------------------------------------------
4408 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4409                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4410   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4411          &quot;integral arrays must be pre-equipped with a class&quot;);
4412   if (!xk) xk = ary-&gt;ary_must_be_exact();
4413   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4414   if (!UseExactTypes)  xk = (ptr == Constant);
4415   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4416 }
4417 
4418 //------------------------------make-------------------------------------------
4419 const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4420                                    int instance_id, const TypePtr* speculative, int inline_depth,
4421                                    bool is_autobox_cache) {
4422   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4423          &quot;integral arrays must be pre-equipped with a class&quot;);
4424   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4425   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
</pre>
<hr />
<pre>
4688         // This must fall to bottom, not (int[-128..65535])[int+].
4689         instance_id = InstanceBot;
4690         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4691       }
4692     } else // Non integral arrays.
4693       // Must fall to bottom if exact klasses in upper lattice
4694       // are not equal or super klass is exact.
4695       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4696           // meet with top[] and bottom[] are processed further down:
4697           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4698           // both are exact and not equal:
4699           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4700            // &#39;tap&#39; is exact and super or unrelated:
4701            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4702            // &#39;this&#39; is exact and super or unrelated:
4703            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4704       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4705         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4706       }
4707       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
<span class="line-modified">4708     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {</span>
<span class="line-modified">4709       // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.</span>
<span class="line-modified">4710       if (tary-&gt;_elem-&gt;isa_inlinetype()) {</span>
4711         // Result is flattened
<span class="line-modified">4712         off = Offset(elem()-&gt;isa_inlinetype() ? offset() : tap-&gt;offset());</span>
<span class="line-modified">4713         field_off = elem()-&gt;isa_inlinetype() ? field_offset() : tap-&gt;field_offset();</span>
4714       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4715         // Result is non-flattened
4716         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4717         field_off = Offset::bottom;
4718       }
4719     }
4720 
4721     bool xk = false;
4722     switch (tap-&gt;ptr()) {
4723     case AnyNull:
4724     case TopPTR:
4725       // Compute new klass on demand, do not use tap-&gt;_klass
4726       if (below_centerline(this-&gt;_ptr)) {
4727         xk = this-&gt;_klass_is_exact;
4728       } else {
4729         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4730       }
4731       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4732     case Constant: {
4733       ciObject* o = const_oop();
</pre>
<hr />
<pre>
4792         // then we can subclass in the Java class hierarchy.
4793         // For instances when a subclass meets a superclass we fall
4794         // below the centerline when the superclass is exact. We need
4795         // to do the same here.
4796         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {
4797           // that is, my array type is a subtype of &#39;tp&#39; klass
4798           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4799                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4800         }
4801       }
4802       // The other case cannot happen, since t cannot be a subtype of an array.
4803       // The meet falls down to Object class below centerline.
4804       if( ptr == Constant )
4805          ptr = NotNull;
4806       instance_id = InstanceBot;
4807       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4808     default: typerr(t);
4809     }
4810   }
4811 
<span class="line-modified">4812   case InlineType: {</span>
<span class="line-modified">4813     const TypeInlineType* tv = t-&gt;is_inlinetype();</span>
4814     if (above_centerline(ptr())) {
4815       return TypeInstPtr::NOTNULL;
4816     } else {
4817       PTR ptr = this-&gt;_ptr;
4818       if (ptr == Constant) {
4819         ptr = NotNull;
4820       }
4821       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4822     }
4823   }
4824   }
4825   return this;                  // Lint noise
4826 }
4827 
4828 //------------------------------xdual------------------------------------------
4829 // Dual: compute field-by-field dual
4830 const Type *TypeAryPtr::xdual() const {
4831   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4832 }
4833 
</pre>
<hr />
<pre>
4857   _ary-&gt;dump2(d,depth,st);
4858   switch( _ptr ) {
4859   case Constant:
4860     const_oop()-&gt;print(st);
4861     break;
4862   case BotPTR:
4863     if (!WizardMode &amp;&amp; !Verbose) {
4864       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4865       break;
4866     }
4867   case TopPTR:
4868   case AnyNull:
4869   case NotNull:
4870     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4871     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4872     break;
4873   default:
4874     break;
4875   }
4876 
<span class="line-modified">4877   if (elem()-&gt;isa_inlinetype()) {</span>
4878     st-&gt;print(&quot;(&quot;);
4879     _field_offset.dump2(st);
4880     st-&gt;print(&quot;)&quot;);
4881   }
4882   if (offset() != 0) {
4883     int header_size = objArrayOopDesc::header_size() * wordSize;
4884     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);
4885     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);
4886     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());
4887     else {
4888       BasicType basic_elem_type = elem()-&gt;basic_type();
4889       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4890       int elem_size = type2aelembytes(basic_elem_type);
4891       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);
4892     }
4893   }
4894   st-&gt;print(&quot; *&quot;);
4895   if (_instance_id == InstanceTop)
4896     st-&gt;print(&quot;,iid=top&quot;);
4897   else if (_instance_id != InstanceBot)
</pre>
<hr />
<pre>
4930     return this;
4931   }
4932   return TypeOopPtr::cleanup_speculative();
4933 }
4934 
4935 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4936   if (!UseInlineDepthForSpeculativeTypes) {
4937     return this;
4938   }
4939   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);
4940 }
4941 
4942 const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {
4943   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4944 }
4945 
4946 const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {
4947   int adj = 0;
4948   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {
4949     const Type* elemtype = elem();
<span class="line-modified">4950     if (elemtype-&gt;isa_inlinetype()) {</span>
4951       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {
4952         adj = _offset.get();
4953         offset += _offset.get();
4954       }
4955       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
4956       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {
4957         offset += _field_offset.get();
4958         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {
4959           offset += header;
4960         }
4961       }
4962       if (offset &gt;= (intptr_t)header || offset &lt; 0) {
<span class="line-modified">4963         // Try to get the field of the inline type array element we are pointing to</span>
4964         ciKlass* arytype_klass = klass();
<span class="line-modified">4965         ciFlatArrayKlass* vak = arytype_klass-&gt;as_flat_array_klass();</span>
<span class="line-modified">4966         ciInlineKlass* vk = vak-&gt;element_klass()-&gt;as_inline_klass();</span>
4967         int shift = vak-&gt;log2_element_size();
4968         int mask = (1 &lt;&lt; shift) - 1;
4969         intptr_t field_offset = ((offset - header) &amp; mask);
4970         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);
4971         if (field == NULL) {
4972           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))
4973           return add_offset(offset);
4974         } else {
4975           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);
4976         }
4977       }
4978     }
4979   }
4980   return add_offset(offset - adj);
4981 }
4982 
<span class="line-modified">4983 // Return offset incremented by field_offset for flattened inline type arrays</span>
4984 const int TypeAryPtr::flattened_offset() const {
4985   int offset = _offset.get();
4986   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;
4987       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {
4988     offset += _field_offset.get();
4989   }
4990   return offset;
4991 }
4992 
4993 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4994   assert(is_known_instance(), &quot;should be known&quot;);
4995   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);
4996 }
4997 
4998 //=============================================================================
4999 
5000 
5001 //------------------------------hash-------------------------------------------
5002 // Type-specific hashing function.
5003 int TypeNarrowPtr::hash(void) const {
</pre>
<hr />
<pre>
5074   case FloatTop:
5075   case FloatCon:
5076   case FloatBot:
5077   case DoubleTop:
5078   case DoubleCon:
5079   case DoubleBot:
5080   case AnyPtr:
5081   case RawPtr:
5082   case OopPtr:
5083   case InstPtr:
5084   case AryPtr:
5085   case MetadataPtr:
5086   case KlassPtr:
5087   case NarrowOop:
5088   case NarrowKlass:
5089   case Bottom:                  // Ye Olde Default
5090     return Type::BOTTOM;
5091   case Top:
5092     return this;
5093 
<span class="line-modified">5094   case InlineType:</span>
5095     return t-&gt;xmeet(this);
5096 
5097   default:                      // All else is a mistake
5098     typerr(t);
5099 
5100   } // End of switch
5101 
5102   return this;
5103 }
5104 
5105 #ifndef PRODUCT
5106 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5107   _ptrtype-&gt;dump2(d, depth, st);
5108 }
5109 #endif
5110 
5111 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
5112 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
5113 
5114 
</pre>
<hr />
<pre>
5330 }
5331 
5332 //------------------------------make-------------------------------------------
5333 // Create a meta data constant
5334 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {
5335   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5336   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5337 }
5338 
5339 
5340 //=============================================================================
5341 // Convenience common pre-built types.
5342 
5343 // Not-null object klass or below
5344 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5345 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5346 
5347 //------------------------------TypeKlassPtr-----------------------------------
5348 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
5349   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
<span class="line-modified">5350    assert(!klass-&gt;is_inlinetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">5351    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
5352 }
5353 
5354 //------------------------------make-------------------------------------------
5355 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
5356 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
5357   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
5358   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();
5359 }
5360 
5361 //------------------------------eq---------------------------------------------
5362 // Structural equality check for Type representations
5363 bool TypeKlassPtr::eq( const Type *t ) const {
5364   const TypeKlassPtr *p = t-&gt;is_klassptr();
5365   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();
5366 }
5367 
5368 //------------------------------hash-------------------------------------------
5369 // Type-specific hashing function.
5370 int TypeKlassPtr::hash(void) const {
5371   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());
</pre>
<hr />
<pre>
5405   }
5406 
5407   return ft;
5408 }
5409 
5410 //----------------------compute_klass------------------------------------------
5411 // Compute the defining klass for this class
5412 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5413   // Compute _klass based on element type.
5414   ciKlass* k_ary = NULL;
5415   const TypeAryPtr *tary;
5416   const Type* el = elem();
5417   if (el-&gt;isa_narrowoop()) {
5418     el = el-&gt;make_ptr();
5419   }
5420 
5421   // Get element klass
5422   if (el-&gt;isa_instptr()) {
5423     // Compute object array klass from element klass
5424     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());
<span class="line-modified">5425   } else if (el-&gt;isa_inlinetype()) {</span>
<span class="line-modified">5426     // If element type is TypeInlineType::BOTTOM, inline_klass() will be null.</span>
<span class="line-modified">5427     if (el-&gt;inline_klass() != NULL) {</span>
<span class="line-modified">5428       k_ary = ciArrayKlass::make(el-&gt;inline_klass());</span>
5429     }
5430   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5431     // Compute array klass from element klass
5432     ciKlass* k_elem = tary-&gt;klass();
5433     // If element type is something like bottom[], k_elem will be null.
5434     if (k_elem != NULL)
5435       k_ary = ciObjArrayKlass::make(k_elem);
5436   } else if ((el-&gt;base() == Type::Top) ||
5437              (el-&gt;base() == Type::Bottom)) {
5438     // element type of Bottom occurs from meet of basic type
5439     // and object; Top occurs when doing join on Bottom.
5440     // Leave k_ary at NULL.
5441   } else {
5442     // Cannot compute array klass directly from basic type,
5443     // since subtypes of TypeInt all have basic type T_INT.
5444 #ifdef ASSERT
5445     if (verify &amp;&amp; el-&gt;isa_int()) {
5446       // Check simple cases when verifying klass.
5447       BasicType bt = T_ILLEGAL;
5448       if (el == TypeInt::BYTE) {
</pre>
<hr />
<pre>
5515 
5516 //-----------------------------cast_to_exactness-------------------------------
5517 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5518   if( klass_is_exact == _klass_is_exact ) return this;
5519   if (!UseExactTypes)  return this;
5520   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);
5521 }
5522 
5523 
5524 //-----------------------------as_instance_type--------------------------------
5525 // Corresponding type for an instance of the given class.
5526 // It will be NotNull, and exact if and only if the klass type is exact.
5527 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5528   ciKlass* k = klass();
5529   assert(k != NULL, &quot;klass should not be NULL&quot;);
5530   bool    xk = klass_is_exact();
5531   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5532   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5533   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5534   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">5535   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
5536     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();
5537   }
5538   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5539 }
5540 
5541 
5542 //------------------------------xmeet------------------------------------------
5543 // Compute the MEET of two types, return a new Type object.
5544 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5545   // Perform a fast test for common case; meeting the same types together.
5546   if( this == t ) return this;  // Meeting same type-rep?
5547 
5548   // Current &quot;this-&gt;_base&quot; is Pointer
5549   switch (t-&gt;base()) {          // switch on original type
5550 
5551   case Int:                     // Mixing ints &amp; oops happens when javac
5552   case Long:                    // reuses local variables
5553   case FloatTop:
5554   case FloatCon:
5555   case FloatBot:
</pre>
<hr />
<pre>
5656       // If the klasses are equal, the constants may still differ.  Fall to
5657       // NotNull if they do (neither constant is NULL; that is a special case
5658       // handled elsewhere).
5659       if( ptr == Constant ) {
5660         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5661             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5662         else if (above_centerline(this-&gt;ptr()));
5663         else if (above_centerline(tkls-&gt;ptr()));
5664         else
5665           ptr = NotNull;
5666       }
5667       return make(ptr, this_klass, off, flat_array);
5668     } // Else classes are not equal
5669 
5670     // Since klasses are different, we require the LCA in the Java
5671     // class hierarchy - which means we have to fall to at least NotNull.
5672     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5673       ptr = NotNull;
5674     // Now we find the LCA of Java classes
5675     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">5676     return   make(ptr, k, off, k-&gt;is_inlinetype() &amp;&amp; k-&gt;flatten_array());</span>
5677   } // End of case KlassPtr
5678 
5679   } // End of switch
5680   return this;                  // Return the double constant
5681 }
5682 
5683 //------------------------------xdual------------------------------------------
5684 // Dual: compute field-by-field dual
5685 const Type    *TypeKlassPtr::xdual() const {
5686   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());
5687 }
5688 
5689 //------------------------------get_con----------------------------------------
5690 intptr_t TypeKlassPtr::get_con() const {
5691   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5692   assert(offset() &gt;= 0, &quot;&quot;);
5693 
5694   if (offset() != 0) {
5695     // After being ported to the compiler interface, the compiler no longer
5696     // directly manipulates the addresses of oops.  Rather, it only has a pointer
</pre>
<hr />
<pre>
5751 
5752 const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {
5753   return make(domain, domain, range, range);
5754 }
5755 
5756 //------------------------------osr_domain-----------------------------
5757 const TypeTuple* osr_domain() {
5758   const Type **fields = TypeTuple::fields(2);
5759   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
5760   return TypeTuple::make(TypeFunc::Parms+1, fields);
5761 }
5762 
5763 //------------------------------make-------------------------------------------
5764 const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {
5765   Compile* C = Compile::current();
5766   const TypeFunc* tf = NULL;
5767   if (!is_osr_compilation) {
5768     tf = C-&gt;last_tf(method); // check cache
5769     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5770   }
<span class="line-modified">5771   // Inline types are not passed/returned by reference, instead each field of</span>
<span class="line-modified">5772   // the inline type is passed/returned as an argument. We maintain two views of</span>
<span class="line-modified">5773   // the argument/return list here: one based on the signature (with an inline</span>
5774   // type argument/return as a single slot), one based on the actual calling
<span class="line-modified">5775   // convention (with an inline type argument/return as a list of its fields).</span>
5776   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;
5777   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);
5778   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;
5779   ciSignature* sig = method-&gt;signature();
<span class="line-modified">5780   bool has_scalar_ret = sig-&gt;return_type()-&gt;is_inlinetype() &amp;&amp; sig-&gt;return_type()-&gt;as_inline_klass()-&gt;can_be_returned_as_fields();</span>
5781   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);
5782   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;
5783   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);
5784   if (!is_osr_compilation) {
5785     C-&gt;set_last_tf(method, tf);  // fill cache
5786   }
5787   return tf;
5788 }
5789 
5790 //------------------------------meet-------------------------------------------
5791 // Compute the MEET of two types.  It returns a new Type object.
5792 const Type *TypeFunc::xmeet( const Type *t ) const {
5793   // Perform a fast test for common case; meeting the same types together.
5794   if( this == t ) return this;  // Meeting same type-rep?
5795 
5796   // Current &quot;this-&gt;_base&quot; is Func
5797   switch (t-&gt;base()) {          // switch on original type
5798 
5799   case Bottom:                  // Ye Olde Default
5800     return t;
</pre>
</td>
</tr>
</table>
<center><a href="subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
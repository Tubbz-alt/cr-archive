<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/addnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.inline.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/castnode.hpp&quot;
  29 #include &quot;opto/cfgnode.hpp&quot;
  30 #include &quot;opto/connode.hpp&quot;
  31 #include &quot;opto/machnode.hpp&quot;
  32 #include &quot;opto/movenode.hpp&quot;
  33 #include &quot;opto/mulnode.hpp&quot;
  34 #include &quot;opto/phaseX.hpp&quot;
  35 #include &quot;opto/subnode.hpp&quot;
  36 
  37 // Portions of code courtesy of Clifford Click
  38 
  39 // Classic Add functionality.  This covers all the usual &#39;add&#39; behaviors for
  40 // an algebraic ring.  Add-integer, add-float, add-double, and binary-or are
  41 // all inherited from this class.  The various identity values are supplied
  42 // by virtual functions.
  43 
  44 
  45 //=============================================================================
  46 //------------------------------hash-------------------------------------------
  47 // Hash function over AddNodes.  Needs to be commutative; i.e., I swap
  48 // (commute) inputs to AddNodes willy-nilly so the hash function must return
  49 // the same value in the presence of edge swapping.
  50 uint AddNode::hash() const {
  51   return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();
  52 }
  53 
  54 //------------------------------Identity---------------------------------------
  55 // If either input is a constant 0, return the other input.
  56 Node* AddNode::Identity(PhaseGVN* phase) {
  57   const Type *zero = add_id();  // The additive identity
  58   if( phase-&gt;type( in(1) )-&gt;higher_equal( zero ) ) return in(2);
  59   if( phase-&gt;type( in(2) )-&gt;higher_equal( zero ) ) return in(1);
  60   return this;
  61 }
  62 
  63 //------------------------------commute----------------------------------------
  64 // Commute operands to move loads and constants to the right.
  65 static bool commute(Node *add, bool con_left, bool con_right) {
  66   Node *in1 = add-&gt;in(1);
  67   Node *in2 = add-&gt;in(2);
  68 
  69   // Convert &quot;1+x&quot; into &quot;x+1&quot;.
  70   // Right is a constant; leave it
  71   if( con_right ) return false;
  72   // Left is a constant; move it right.
  73   if( con_left ) {
  74     add-&gt;swap_edges(1, 2);
  75     return true;
  76   }
  77 
  78   // Convert &quot;Load+x&quot; into &quot;x+Load&quot;.
  79   // Now check for loads
  80   if (in2-&gt;is_Load()) {
  81     if (!in1-&gt;is_Load()) {
  82       // already x+Load to return
  83       return false;
  84     }
  85     // both are loads, so fall through to sort inputs by idx
  86   } else if( in1-&gt;is_Load() ) {
  87     // Left is a Load and Right is not; move it right.
  88     add-&gt;swap_edges(1, 2);
  89     return true;
  90   }
  91 
  92   PhiNode *phi;
  93   // Check for tight loop increments: Loop-phi of Add of loop-phi
  94   if( in1-&gt;is_Phi() &amp;&amp; (phi = in1-&gt;as_Phi()) &amp;&amp; !phi-&gt;is_copy() &amp;&amp; phi-&gt;region()-&gt;is_Loop() &amp;&amp; phi-&gt;in(2)==add)
  95     return false;
  96   if( in2-&gt;is_Phi() &amp;&amp; (phi = in2-&gt;as_Phi()) &amp;&amp; !phi-&gt;is_copy() &amp;&amp; phi-&gt;region()-&gt;is_Loop() &amp;&amp; phi-&gt;in(2)==add){
  97     add-&gt;swap_edges(1, 2);
  98     return true;
  99   }
 100 
 101   // Otherwise, sort inputs (commutativity) to help value numbering.
 102   if( in1-&gt;_idx &gt; in2-&gt;_idx ) {
 103     add-&gt;swap_edges(1, 2);
 104     return true;
 105   }
 106   return false;
 107 }
 108 
 109 //------------------------------Idealize---------------------------------------
 110 // If we get here, we assume we are associative!
 111 Node *AddNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 112   const Type *t1 = phase-&gt;type( in(1) );
 113   const Type *t2 = phase-&gt;type( in(2) );
 114   bool con_left  = t1-&gt;singleton();
 115   bool con_right = t2-&gt;singleton();
 116 
 117   // Check for commutative operation desired
 118   if( commute(this,con_left,con_right) ) return this;
 119 
 120   AddNode *progress = NULL;             // Progress flag
 121 
 122   // Convert &quot;(x+1)+2&quot; into &quot;x+(1+2)&quot;.  If the right input is a
 123   // constant, and the left input is an add of a constant, flatten the
 124   // expression tree.
 125   Node *add1 = in(1);
 126   Node *add2 = in(2);
 127   int add1_op = add1-&gt;Opcode();
 128   int this_op = Opcode();
 129   if( con_right &amp;&amp; t2 != Type::TOP &amp;&amp; // Right input is a constant?
 130       add1_op == this_op ) { // Left input is an Add?
 131 
 132     // Type of left _in right input
 133     const Type *t12 = phase-&gt;type( add1-&gt;in(2) );
 134     if( t12-&gt;singleton() &amp;&amp; t12 != Type::TOP ) { // Left input is an add of a constant?
 135       // Check for rare case of closed data cycle which can happen inside
 136       // unreachable loops. In these cases the computation is undefined.
 137 #ifdef ASSERT
 138       Node *add11    = add1-&gt;in(1);
 139       int   add11_op = add11-&gt;Opcode();
 140       if( (add1 == add1-&gt;in(1))
 141          || (add11_op == this_op &amp;&amp; add11-&gt;in(1) == add1) ) {
 142         assert(false, &quot;dead loop in AddNode::Ideal&quot;);
 143       }
 144 #endif
 145       // The Add of the flattened expression
 146       Node *x1 = add1-&gt;in(1);
 147       Node *x2 = phase-&gt;makecon( add1-&gt;as_Add()-&gt;add_ring( t2, t12 ));
 148       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 149       if( igvn ) {
 150         set_req_X(2,x2,igvn);
 151         set_req_X(1,x1,igvn);
 152       } else {
 153         set_req(2,x2);
 154         set_req(1,x1);
 155       }
 156       progress = this;            // Made progress
 157       add1 = in(1);
 158       add1_op = add1-&gt;Opcode();
 159     }
 160   }
 161 
 162   // Convert &quot;(x+1)+y&quot; into &quot;(x+y)+1&quot;.  Push constants down the expression tree.
 163   if( add1_op == this_op &amp;&amp; !con_right ) {
 164     Node *a12 = add1-&gt;in(2);
 165     const Type *t12 = phase-&gt;type( a12 );
 166     if( t12-&gt;singleton() &amp;&amp; t12 != Type::TOP &amp;&amp; (add1 != add1-&gt;in(1)) &amp;&amp;
 167        !(add1-&gt;in(1)-&gt;is_Phi() &amp;&amp; add1-&gt;in(1)-&gt;as_Phi()-&gt;is_tripcount()) ) {
 168       assert(add1-&gt;in(1) != this, &quot;dead loop in AddNode::Ideal&quot;);
 169       add2 = add1-&gt;clone();
 170       add2-&gt;set_req(2, in(2));
 171       add2 = phase-&gt;transform(add2);
 172       set_req(1, add2);
 173       set_req(2, a12);
 174       progress = this;
 175       add2 = a12;
 176     }
 177   }
 178 
 179   // Convert &quot;x+(y+1)&quot; into &quot;(x+y)+1&quot;.  Push constants down the expression tree.
 180   int add2_op = add2-&gt;Opcode();
 181   if( add2_op == this_op &amp;&amp; !con_left ) {
 182     Node *a22 = add2-&gt;in(2);
 183     const Type *t22 = phase-&gt;type( a22 );
 184     if( t22-&gt;singleton() &amp;&amp; t22 != Type::TOP &amp;&amp; (add2 != add2-&gt;in(1)) &amp;&amp;
 185        !(add2-&gt;in(1)-&gt;is_Phi() &amp;&amp; add2-&gt;in(1)-&gt;as_Phi()-&gt;is_tripcount()) ) {
 186       assert(add2-&gt;in(1) != this, &quot;dead loop in AddNode::Ideal&quot;);
 187       Node *addx = add2-&gt;clone();
 188       addx-&gt;set_req(1, in(1));
 189       addx-&gt;set_req(2, add2-&gt;in(1));
 190       addx = phase-&gt;transform(addx);
 191       set_req(1, addx);
 192       set_req(2, a22);
 193       progress = this;
 194       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 195       if (add2-&gt;outcnt() == 0 &amp;&amp; igvn) {
 196         // add disconnected.
 197         igvn-&gt;_worklist.push(add2);
 198       }
 199     }
 200   }
 201 
 202   return progress;
 203 }
 204 
 205 //------------------------------Value-----------------------------------------
 206 // An add node sums it&#39;s two _in.  If one input is an RSD, we must mixin
 207 // the other input&#39;s symbols.
 208 const Type* AddNode::Value(PhaseGVN* phase) const {
 209   // Either input is TOP ==&gt; the result is TOP
 210   const Type *t1 = phase-&gt;type( in(1) );
 211   const Type *t2 = phase-&gt;type( in(2) );
 212   if( t1 == Type::TOP ) return Type::TOP;
 213   if( t2 == Type::TOP ) return Type::TOP;
 214 
 215   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 216   const Type *bot = bottom_type();
 217   if( (t1 == bot) || (t2 == bot) ||
 218       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 219     return bot;
 220 
 221   // Check for an addition involving the additive identity
 222   const Type *tadd = add_of_identity( t1, t2 );
 223   if( tadd ) return tadd;
 224 
 225   return add_ring(t1,t2);               // Local flavor of type addition
 226 }
 227 
 228 //------------------------------add_identity-----------------------------------
 229 // Check for addition of the identity
 230 const Type *AddNode::add_of_identity( const Type *t1, const Type *t2 ) const {
 231   const Type *zero = add_id();  // The additive identity
 232   if( t1-&gt;higher_equal( zero ) ) return t2;
 233   if( t2-&gt;higher_equal( zero ) ) return t1;
 234 
 235   return NULL;
 236 }
 237 
 238 
 239 //=============================================================================
 240 //------------------------------Idealize---------------------------------------
 241 Node *AddINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 242   Node* in1 = in(1);
 243   Node* in2 = in(2);
 244   int op1 = in1-&gt;Opcode();
 245   int op2 = in2-&gt;Opcode();
 246   // Fold (con1-x)+con2 into (con1+con2)-x
 247   if ( op1 == Op_AddI &amp;&amp; op2 == Op_SubI ) {
 248     // Swap edges to try optimizations below
 249     in1 = in2;
 250     in2 = in(1);
 251     op1 = op2;
 252     op2 = in2-&gt;Opcode();
 253   }
 254   if( op1 == Op_SubI ) {
 255     const Type *t_sub1 = phase-&gt;type( in1-&gt;in(1) );
 256     const Type *t_2    = phase-&gt;type( in2        );
 257     if( t_sub1-&gt;singleton() &amp;&amp; t_2-&gt;singleton() &amp;&amp; t_sub1 != Type::TOP &amp;&amp; t_2 != Type::TOP )
 258       return new SubINode(phase-&gt;makecon( add_ring( t_sub1, t_2 ) ), in1-&gt;in(2) );
 259     // Convert &quot;(a-b)+(c-d)&quot; into &quot;(a+c)-(b+d)&quot;
 260     if( op2 == Op_SubI ) {
 261       // Check for dead cycle: d = (a-b)+(c-d)
 262       assert( in1-&gt;in(2) != this &amp;&amp; in2-&gt;in(2) != this,
 263               &quot;dead loop in AddINode::Ideal&quot; );
 264       Node *sub  = new SubINode(NULL, NULL);
 265       sub-&gt;init_req(1, phase-&gt;transform(new AddINode(in1-&gt;in(1), in2-&gt;in(1) ) ));
 266       sub-&gt;init_req(2, phase-&gt;transform(new AddINode(in1-&gt;in(2), in2-&gt;in(2) ) ));
 267       return sub;
 268     }
 269     // Convert &quot;(a-b)+(b+c)&quot; into &quot;(a+c)&quot;
 270     if( op2 == Op_AddI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) ) {
 271       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(2) != this,&quot;dead loop in AddINode::Ideal&quot;);
 272       return new AddINode(in1-&gt;in(1), in2-&gt;in(2));
 273     }
 274     // Convert &quot;(a-b)+(c+b)&quot; into &quot;(a+c)&quot;
 275     if( op2 == Op_AddI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(2) ) {
 276       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(1) != this,&quot;dead loop in AddINode::Ideal&quot;);
 277       return new AddINode(in1-&gt;in(1), in2-&gt;in(1));
 278     }
 279     // Convert &quot;(a-b)+(b-c)&quot; into &quot;(a-c)&quot;
 280     if( op2 == Op_SubI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) ) {
 281       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(2) != this,&quot;dead loop in AddINode::Ideal&quot;);
 282       return new SubINode(in1-&gt;in(1), in2-&gt;in(2));
 283     }
 284     // Convert &quot;(a-b)+(c-a)&quot; into &quot;(c-b)&quot;
 285     if( op2 == Op_SubI &amp;&amp; in1-&gt;in(1) == in2-&gt;in(2) ) {
 286       assert(in1-&gt;in(2) != this &amp;&amp; in2-&gt;in(1) != this,&quot;dead loop in AddINode::Ideal&quot;);
 287       return new SubINode(in2-&gt;in(1), in1-&gt;in(2));
 288     }
 289   }
 290 
 291   // Convert &quot;x+(0-y)&quot; into &quot;(x-y)&quot;
 292   if( op2 == Op_SubI &amp;&amp; phase-&gt;type(in2-&gt;in(1)) == TypeInt::ZERO )
 293     return new SubINode(in1, in2-&gt;in(2) );
 294 
 295   // Convert &quot;(0-y)+x&quot; into &quot;(x-y)&quot;
 296   if( op1 == Op_SubI &amp;&amp; phase-&gt;type(in1-&gt;in(1)) == TypeInt::ZERO )
 297     return new SubINode( in2, in1-&gt;in(2) );
 298 
 299   // Convert (x&gt;&gt;&gt;z)+y into (x+(y&lt;&lt;z))&gt;&gt;&gt;z for small constant z and y.
 300   // Helps with array allocation math constant folding
 301   // See 4790063:
 302   // Unrestricted transformation is unsafe for some runtime values of &#39;x&#39;
 303   // ( x ==  0, z == 1, y == -1 ) fails
 304   // ( x == -5, z == 1, y ==  1 ) fails
 305   // Transform works for small z and small negative y when the addition
 306   // (x + (y &lt;&lt; z)) does not cross zero.
 307   // Implement support for negative y and (x &gt;= -(y &lt;&lt; z))
 308   // Have not observed cases where type information exists to support
 309   // positive y and (x &lt;= -(y &lt;&lt; z))
 310   if( op1 == Op_URShiftI &amp;&amp; op2 == Op_ConI &amp;&amp;
 311       in1-&gt;in(2)-&gt;Opcode() == Op_ConI ) {
 312     jint z = phase-&gt;type( in1-&gt;in(2) )-&gt;is_int()-&gt;get_con() &amp; 0x1f; // only least significant 5 bits matter
 313     jint y = phase-&gt;type( in2 )-&gt;is_int()-&gt;get_con();
 314 
 315     if( z &lt; 5 &amp;&amp; -5 &lt; y &amp;&amp; y &lt; 0 ) {
 316       const Type *t_in11 = phase-&gt;type(in1-&gt;in(1));
 317       if( t_in11 != Type::TOP &amp;&amp; (t_in11-&gt;is_int()-&gt;_lo &gt;= -(y &lt;&lt; z)) ) {
 318         Node *a = phase-&gt;transform( new AddINode( in1-&gt;in(1), phase-&gt;intcon(y&lt;&lt;z) ) );
 319         return new URShiftINode( a, in1-&gt;in(2) );
 320       }
 321     }
 322   }
 323 
 324   return AddNode::Ideal(phase, can_reshape);
 325 }
 326 
 327 
 328 //------------------------------Identity---------------------------------------
 329 // Fold (x-y)+y  OR  y+(x-y)  into  x
 330 Node* AddINode::Identity(PhaseGVN* phase) {
 331   if( in(1)-&gt;Opcode() == Op_SubI &amp;&amp; phase-&gt;eqv(in(1)-&gt;in(2),in(2)) ) {
 332     return in(1)-&gt;in(1);
 333   }
 334   else if( in(2)-&gt;Opcode() == Op_SubI &amp;&amp; phase-&gt;eqv(in(2)-&gt;in(2),in(1)) ) {
 335     return in(2)-&gt;in(1);
 336   }
 337   return AddNode::Identity(phase);
 338 }
 339 
 340 
 341 //------------------------------add_ring---------------------------------------
 342 // Supplied function returns the sum of the inputs.  Guaranteed never
 343 // to be passed a TOP or BOTTOM type, these are filtered out by
 344 // pre-check.
 345 const Type *AddINode::add_ring( const Type *t0, const Type *t1 ) const {
 346   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 347   const TypeInt *r1 = t1-&gt;is_int();
 348   int lo = java_add(r0-&gt;_lo, r1-&gt;_lo);
 349   int hi = java_add(r0-&gt;_hi, r1-&gt;_hi);
 350   if( !(r0-&gt;is_con() &amp;&amp; r1-&gt;is_con()) ) {
 351     // Not both constants, compute approximate result
 352     if( (r0-&gt;_lo &amp; r1-&gt;_lo) &lt; 0 &amp;&amp; lo &gt;= 0 ) {
 353       lo = min_jint; hi = max_jint; // Underflow on the low side
 354     }
 355     if( (~(r0-&gt;_hi | r1-&gt;_hi)) &lt; 0 &amp;&amp; hi &lt; 0 ) {
 356       lo = min_jint; hi = max_jint; // Overflow on the high side
 357     }
 358     if( lo &gt; hi ) {               // Handle overflow
 359       lo = min_jint; hi = max_jint;
 360     }
 361   } else {
 362     // both constants, compute precise result using &#39;lo&#39; and &#39;hi&#39;
 363     // Semantics define overflow and underflow for integer addition
 364     // as expected.  In particular: 0x80000000 + 0x80000000 --&gt; 0x0
 365   }
 366   return TypeInt::make( lo, hi, MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 367 }
 368 
 369 
 370 //=============================================================================
 371 //------------------------------Idealize---------------------------------------
 372 Node *AddLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 373   Node* in1 = in(1);
 374   Node* in2 = in(2);
 375   int op1 = in1-&gt;Opcode();
 376   int op2 = in2-&gt;Opcode();
 377   // Fold (con1-x)+con2 into (con1+con2)-x
 378   if ( op1 == Op_AddL &amp;&amp; op2 == Op_SubL ) {
 379     // Swap edges to try optimizations below
 380     in1 = in2;
 381     in2 = in(1);
 382     op1 = op2;
 383     op2 = in2-&gt;Opcode();
 384   }
 385   // Fold (con1-x)+con2 into (con1+con2)-x
 386   if( op1 == Op_SubL ) {
 387     const Type *t_sub1 = phase-&gt;type( in1-&gt;in(1) );
 388     const Type *t_2    = phase-&gt;type( in2        );
 389     if( t_sub1-&gt;singleton() &amp;&amp; t_2-&gt;singleton() &amp;&amp; t_sub1 != Type::TOP &amp;&amp; t_2 != Type::TOP )
 390       return new SubLNode(phase-&gt;makecon( add_ring( t_sub1, t_2 ) ), in1-&gt;in(2) );
 391     // Convert &quot;(a-b)+(c-d)&quot; into &quot;(a+c)-(b+d)&quot;
 392     if( op2 == Op_SubL ) {
 393       // Check for dead cycle: d = (a-b)+(c-d)
 394       assert( in1-&gt;in(2) != this &amp;&amp; in2-&gt;in(2) != this,
 395               &quot;dead loop in AddLNode::Ideal&quot; );
 396       Node *sub  = new SubLNode(NULL, NULL);
 397       sub-&gt;init_req(1, phase-&gt;transform(new AddLNode(in1-&gt;in(1), in2-&gt;in(1) ) ));
 398       sub-&gt;init_req(2, phase-&gt;transform(new AddLNode(in1-&gt;in(2), in2-&gt;in(2) ) ));
 399       return sub;
 400     }
 401     // Convert &quot;(a-b)+(b+c)&quot; into &quot;(a+c)&quot;
 402     if( op2 == Op_AddL &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) ) {
 403       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(2) != this,&quot;dead loop in AddLNode::Ideal&quot;);
 404       return new AddLNode(in1-&gt;in(1), in2-&gt;in(2));
 405     }
 406     // Convert &quot;(a-b)+(c+b)&quot; into &quot;(a+c)&quot;
 407     if( op2 == Op_AddL &amp;&amp; in1-&gt;in(2) == in2-&gt;in(2) ) {
 408       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(1) != this,&quot;dead loop in AddLNode::Ideal&quot;);
 409       return new AddLNode(in1-&gt;in(1), in2-&gt;in(1));
 410     }
 411     // Convert &quot;(a-b)+(b-c)&quot; into &quot;(a-c)&quot;
 412     if( op2 == Op_SubL &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) ) {
 413       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(2) != this,&quot;dead loop in AddLNode::Ideal&quot;);
 414       return new SubLNode(in1-&gt;in(1), in2-&gt;in(2));
 415     }
 416     // Convert &quot;(a-b)+(c-a)&quot; into &quot;(c-b)&quot;
 417     if( op2 == Op_SubL &amp;&amp; in1-&gt;in(1) == in1-&gt;in(2) ) {
 418       assert(in1-&gt;in(2) != this &amp;&amp; in2-&gt;in(1) != this,&quot;dead loop in AddLNode::Ideal&quot;);
 419       return new SubLNode(in2-&gt;in(1), in1-&gt;in(2));
 420     }
 421   }
 422 
 423   // Convert &quot;x+(0-y)&quot; into &quot;(x-y)&quot;
 424   if( op2 == Op_SubL &amp;&amp; phase-&gt;type(in2-&gt;in(1)) == TypeLong::ZERO )
 425     return new SubLNode( in1, in2-&gt;in(2) );
 426 
 427   // Convert &quot;(0-y)+x&quot; into &quot;(x-y)&quot;
 428   if( op1 == Op_SubL &amp;&amp; phase-&gt;type(in1-&gt;in(1)) == TypeInt::ZERO )
 429     return new SubLNode( in2, in1-&gt;in(2) );
 430 
 431   // Convert &quot;X+X+X+X+X...+X+Y&quot; into &quot;k*X+Y&quot; or really convert &quot;X+(X+Y)&quot;
 432   // into &quot;(X&lt;&lt;1)+Y&quot; and let shift-folding happen.
 433   if( op2 == Op_AddL &amp;&amp;
 434       in2-&gt;in(1) == in1 &amp;&amp;
 435       op1 != Op_ConL &amp;&amp;
 436       0 ) {
 437     Node *shift = phase-&gt;transform(new LShiftLNode(in1,phase-&gt;intcon(1)));
 438     return new AddLNode(shift,in2-&gt;in(2));
 439   }
 440 
 441   return AddNode::Ideal(phase, can_reshape);
 442 }
 443 
 444 
 445 //------------------------------Identity---------------------------------------
 446 // Fold (x-y)+y  OR  y+(x-y)  into  x
 447 Node* AddLNode::Identity(PhaseGVN* phase) {
 448   if( in(1)-&gt;Opcode() == Op_SubL &amp;&amp; phase-&gt;eqv(in(1)-&gt;in(2),in(2)) ) {
 449     return in(1)-&gt;in(1);
 450   }
 451   else if( in(2)-&gt;Opcode() == Op_SubL &amp;&amp; phase-&gt;eqv(in(2)-&gt;in(2),in(1)) ) {
 452     return in(2)-&gt;in(1);
 453   }
 454   return AddNode::Identity(phase);
 455 }
 456 
 457 
 458 //------------------------------add_ring---------------------------------------
 459 // Supplied function returns the sum of the inputs.  Guaranteed never
 460 // to be passed a TOP or BOTTOM type, these are filtered out by
 461 // pre-check.
 462 const Type *AddLNode::add_ring( const Type *t0, const Type *t1 ) const {
 463   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 464   const TypeLong *r1 = t1-&gt;is_long();
 465   jlong lo = java_add(r0-&gt;_lo, r1-&gt;_lo);
 466   jlong hi = java_add(r0-&gt;_hi, r1-&gt;_hi);
 467   if( !(r0-&gt;is_con() &amp;&amp; r1-&gt;is_con()) ) {
 468     // Not both constants, compute approximate result
 469     if( (r0-&gt;_lo &amp; r1-&gt;_lo) &lt; 0 &amp;&amp; lo &gt;= 0 ) {
 470       lo =min_jlong; hi = max_jlong; // Underflow on the low side
 471     }
 472     if( (~(r0-&gt;_hi | r1-&gt;_hi)) &lt; 0 &amp;&amp; hi &lt; 0 ) {
 473       lo = min_jlong; hi = max_jlong; // Overflow on the high side
 474     }
 475     if( lo &gt; hi ) {               // Handle overflow
 476       lo = min_jlong; hi = max_jlong;
 477     }
 478   } else {
 479     // both constants, compute precise result using &#39;lo&#39; and &#39;hi&#39;
 480     // Semantics define overflow and underflow for integer addition
 481     // as expected.  In particular: 0x80000000 + 0x80000000 --&gt; 0x0
 482   }
 483   return TypeLong::make( lo, hi, MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 484 }
 485 
 486 
 487 //=============================================================================
 488 //------------------------------add_of_identity--------------------------------
 489 // Check for addition of the identity
 490 const Type *AddFNode::add_of_identity( const Type *t1, const Type *t2 ) const {
 491   // x ADD 0  should return x unless &#39;x&#39; is a -zero
 492   //
 493   // const Type *zero = add_id();     // The additive identity
 494   // jfloat f1 = t1-&gt;getf();
 495   // jfloat f2 = t2-&gt;getf();
 496   //
 497   // if( t1-&gt;higher_equal( zero ) ) return t2;
 498   // if( t2-&gt;higher_equal( zero ) ) return t1;
 499 
 500   return NULL;
 501 }
 502 
 503 //------------------------------add_ring---------------------------------------
 504 // Supplied function returns the sum of the inputs.
 505 // This also type-checks the inputs for sanity.  Guaranteed never to
 506 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 507 const Type *AddFNode::add_ring( const Type *t0, const Type *t1 ) const {
 508   // We must be adding 2 float constants.
 509   return TypeF::make( t0-&gt;getf() + t1-&gt;getf() );
 510 }
 511 
 512 //------------------------------Ideal------------------------------------------
 513 Node *AddFNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 514   if( IdealizedNumerics &amp;&amp; !phase-&gt;C-&gt;method()-&gt;is_strict() ) {
 515     return AddNode::Ideal(phase, can_reshape); // commutative and associative transforms
 516   }
 517 
 518   // Floating point additions are not associative because of boundary conditions (infinity)
 519   return commute(this,
 520                  phase-&gt;type( in(1) )-&gt;singleton(),
 521                  phase-&gt;type( in(2) )-&gt;singleton() ) ? this : NULL;
 522 }
 523 
 524 
 525 //=============================================================================
 526 //------------------------------add_of_identity--------------------------------
 527 // Check for addition of the identity
 528 const Type *AddDNode::add_of_identity( const Type *t1, const Type *t2 ) const {
 529   // x ADD 0  should return x unless &#39;x&#39; is a -zero
 530   //
 531   // const Type *zero = add_id();     // The additive identity
 532   // jfloat f1 = t1-&gt;getf();
 533   // jfloat f2 = t2-&gt;getf();
 534   //
 535   // if( t1-&gt;higher_equal( zero ) ) return t2;
 536   // if( t2-&gt;higher_equal( zero ) ) return t1;
 537 
 538   return NULL;
 539 }
 540 //------------------------------add_ring---------------------------------------
 541 // Supplied function returns the sum of the inputs.
 542 // This also type-checks the inputs for sanity.  Guaranteed never to
 543 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 544 const Type *AddDNode::add_ring( const Type *t0, const Type *t1 ) const {
 545   // We must be adding 2 double constants.
 546   return TypeD::make( t0-&gt;getd() + t1-&gt;getd() );
 547 }
 548 
 549 //------------------------------Ideal------------------------------------------
 550 Node *AddDNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 551   if( IdealizedNumerics &amp;&amp; !phase-&gt;C-&gt;method()-&gt;is_strict() ) {
 552     return AddNode::Ideal(phase, can_reshape); // commutative and associative transforms
 553   }
 554 
 555   // Floating point additions are not associative because of boundary conditions (infinity)
 556   return commute(this,
 557                  phase-&gt;type( in(1) )-&gt;singleton(),
 558                  phase-&gt;type( in(2) )-&gt;singleton() ) ? this : NULL;
 559 }
 560 
 561 
 562 //=============================================================================
 563 //------------------------------Identity---------------------------------------
 564 // If one input is a constant 0, return the other input.
 565 Node* AddPNode::Identity(PhaseGVN* phase) {
 566   return ( phase-&gt;type( in(Offset) )-&gt;higher_equal( TypeX_ZERO ) ) ? in(Address) : this;
 567 }
 568 
 569 //------------------------------Idealize---------------------------------------
 570 Node *AddPNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 571   // Bail out if dead inputs
 572   if( phase-&gt;type( in(Address) ) == Type::TOP ) return NULL;
 573 
 574   // If the left input is an add of a constant, flatten the expression tree.
 575   const Node *n = in(Address);
 576   if (n-&gt;is_AddP() &amp;&amp; n-&gt;in(Base) == in(Base)) {
 577     const AddPNode *addp = n-&gt;as_AddP(); // Left input is an AddP
 578     assert( !addp-&gt;in(Address)-&gt;is_AddP() ||
 579              addp-&gt;in(Address)-&gt;as_AddP() != addp,
 580             &quot;dead loop in AddPNode::Ideal&quot; );
 581     // Type of left input&#39;s right input
 582     const Type *t = phase-&gt;type( addp-&gt;in(Offset) );
 583     if( t == Type::TOP ) return NULL;
 584     const TypeX *t12 = t-&gt;is_intptr_t();
 585     if( t12-&gt;is_con() ) {       // Left input is an add of a constant?
 586       // If the right input is a constant, combine constants
 587       const Type *temp_t2 = phase-&gt;type( in(Offset) );
 588       if( temp_t2 == Type::TOP ) return NULL;
 589       const TypeX *t2 = temp_t2-&gt;is_intptr_t();
 590       Node* address;
 591       Node* offset;
 592       if( t2-&gt;is_con() ) {
 593         // The Add of the flattened expression
 594         address = addp-&gt;in(Address);
 595         offset  = phase-&gt;MakeConX(t2-&gt;get_con() + t12-&gt;get_con());
 596       } else {
 597         // Else move the constant to the right.  ((A+con)+B) into ((A+B)+con)
 598         address = phase-&gt;transform(new AddPNode(in(Base),addp-&gt;in(Address),in(Offset)));
 599         offset  = addp-&gt;in(Offset);
 600       }
 601       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 602       if( igvn ) {
 603         set_req_X(Address,address,igvn);
 604         set_req_X(Offset,offset,igvn);
 605       } else {
 606         set_req(Address,address);
 607         set_req(Offset,offset);
 608       }
 609       return this;
 610     }
 611   }
 612 
 613   // Raw pointers?
 614   if( in(Base)-&gt;bottom_type() == Type::TOP ) {
 615     // If this is a NULL+long form (from unsafe accesses), switch to a rawptr.
 616     if (phase-&gt;type(in(Address)) == TypePtr::NULL_PTR) {
 617       Node* offset = in(Offset);
 618       return new CastX2PNode(offset);
 619     }
 620   }
 621 
 622   // If the right is an add of a constant, push the offset down.
 623   // Convert: (ptr + (offset+con)) into (ptr+offset)+con.
 624   // The idea is to merge array_base+scaled_index groups together,
 625   // and only have different constant offsets from the same base.
 626   const Node *add = in(Offset);
 627   if( add-&gt;Opcode() == Op_AddX &amp;&amp; add-&gt;in(1) != add ) {
 628     const Type *t22 = phase-&gt;type( add-&gt;in(2) );
 629     if( t22-&gt;singleton() &amp;&amp; (t22 != Type::TOP) ) {  // Right input is an add of a constant?
 630       set_req(Address, phase-&gt;transform(new AddPNode(in(Base),in(Address),add-&gt;in(1))));
 631       set_req(Offset, add-&gt;in(2));
 632       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 633       if (add-&gt;outcnt() == 0 &amp;&amp; igvn) {
 634         // add disconnected.
 635         igvn-&gt;_worklist.push((Node*)add);
 636       }
 637       return this;              // Made progress
 638     }
 639   }
 640 
 641   return NULL;                  // No progress
 642 }
 643 
 644 //------------------------------bottom_type------------------------------------
 645 // Bottom-type is the pointer-type with unknown offset.
 646 const Type *AddPNode::bottom_type() const {
 647   if (in(Address) == NULL)  return TypePtr::BOTTOM;
 648   const TypePtr *tp = in(Address)-&gt;bottom_type()-&gt;isa_ptr();
 649   if( !tp ) return Type::TOP;   // TOP input means TOP output
 650   assert( in(Offset)-&gt;Opcode() != Op_ConP, &quot;&quot; );
 651   const Type *t = in(Offset)-&gt;bottom_type();
 652   if( t == Type::TOP )
 653     return tp-&gt;add_offset(Type::OffsetTop);
 654   const TypeX *tx = t-&gt;is_intptr_t();
 655   intptr_t txoffset = Type::OffsetBot;
 656   if (tx-&gt;is_con()) {   // Left input is an add of a constant?
 657     txoffset = tx-&gt;get_con();
 658   }
 659   if (tp-&gt;isa_aryptr()) {
 660     // In the case of a flattened inline type array, each field has its
 661     // own slice so we need to extract the field being accessed from
 662     // the address computation
 663     return tp-&gt;is_aryptr()-&gt;add_field_offset_and_offset(txoffset);
 664   }
 665   return tp-&gt;add_offset(txoffset);
 666 }
 667 
 668 //------------------------------Value------------------------------------------
 669 const Type* AddPNode::Value(PhaseGVN* phase) const {
 670   // Either input is TOP ==&gt; the result is TOP
 671   const Type *t1 = phase-&gt;type( in(Address) );
 672   const Type *t2 = phase-&gt;type( in(Offset) );
 673   if( t1 == Type::TOP ) return Type::TOP;
 674   if( t2 == Type::TOP ) return Type::TOP;
 675 
 676   // Left input is a pointer
 677   const TypePtr *p1 = t1-&gt;isa_ptr();
 678   // Right input is an int
 679   const TypeX *p2 = t2-&gt;is_intptr_t();
 680   // Add &#39;em
 681   intptr_t p2offset = Type::OffsetBot;
 682   if (p2-&gt;is_con()) {   // Left input is an add of a constant?
 683     p2offset = p2-&gt;get_con();
 684   }
 685   if (p1-&gt;isa_aryptr()) {
 686     // In the case of a flattened inline type array, each field has its
 687     // own slice so we need to extract the field being accessed from
 688     // the address computation
 689     return p1-&gt;is_aryptr()-&gt;add_field_offset_and_offset(p2offset);
 690   }
 691   return p1-&gt;add_offset(p2offset);
 692 }
 693 
 694 //------------------------Ideal_base_and_offset--------------------------------
 695 // Split an oop pointer into a base and offset.
 696 // (The offset might be Type::OffsetBot in the case of an array.)
 697 // Return the base, or NULL if failure.
 698 Node* AddPNode::Ideal_base_and_offset(Node* ptr, PhaseTransform* phase,
 699                                       // second return value:
 700                                       intptr_t&amp; offset) {
 701   if (ptr-&gt;is_AddP()) {
 702     Node* base = ptr-&gt;in(AddPNode::Base);
 703     Node* addr = ptr-&gt;in(AddPNode::Address);
 704     Node* offs = ptr-&gt;in(AddPNode::Offset);
 705     if (base == addr || base-&gt;is_top()) {
 706       offset = phase-&gt;find_intptr_t_con(offs, Type::OffsetBot);
 707       if (offset != Type::OffsetBot) {
 708         return addr;
 709       }
 710     }
 711   }
 712   offset = Type::OffsetBot;
 713   return NULL;
 714 }
 715 
 716 //------------------------------unpack_offsets----------------------------------
 717 // Collect the AddP offset values into the elements array, giving up
 718 // if there are more than length.
 719 int AddPNode::unpack_offsets(Node* elements[], int length) {
 720   int count = 0;
 721   Node* addr = this;
 722   Node* base = addr-&gt;in(AddPNode::Base);
 723   while (addr-&gt;is_AddP()) {
 724     if (addr-&gt;in(AddPNode::Base) != base) {
 725       // give up
 726       return -1;
 727     }
 728     elements[count++] = addr-&gt;in(AddPNode::Offset);
 729     if (count == length) {
 730       // give up
 731       return -1;
 732     }
 733     addr = addr-&gt;in(AddPNode::Address);
 734   }
 735   if (addr != base) {
 736     return -1;
 737   }
 738   return count;
 739 }
 740 
 741 //------------------------------match_edge-------------------------------------
 742 // Do we Match on this edge index or not?  Do not match base pointer edge
 743 uint AddPNode::match_edge(uint idx) const {
 744   return idx &gt; Base;
 745 }
 746 
 747 //=============================================================================
 748 //------------------------------Identity---------------------------------------
 749 Node* OrINode::Identity(PhaseGVN* phase) {
 750   // x | x =&gt; x
 751   if (phase-&gt;eqv(in(1), in(2))) {
 752     return in(1);
 753   }
 754 
 755   return AddNode::Identity(phase);
 756 }
 757 
 758 //------------------------------add_ring---------------------------------------
 759 // Supplied function returns the sum of the inputs IN THE CURRENT RING.  For
 760 // the logical operations the ring&#39;s ADD is really a logical OR function.
 761 // This also type-checks the inputs for sanity.  Guaranteed never to
 762 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 763 const Type *OrINode::add_ring( const Type *t0, const Type *t1 ) const {
 764   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 765   const TypeInt *r1 = t1-&gt;is_int();
 766 
 767   // If both args are bool, can figure out better types
 768   if ( r0 == TypeInt::BOOL ) {
 769     if ( r1 == TypeInt::ONE) {
 770       return TypeInt::ONE;
 771     } else if ( r1 == TypeInt::BOOL ) {
 772       return TypeInt::BOOL;
 773     }
 774   } else if ( r0 == TypeInt::ONE ) {
 775     if ( r1 == TypeInt::BOOL ) {
 776       return TypeInt::ONE;
 777     }
 778   }
 779 
 780   // If either input is not a constant, just return all integers.
 781   if( !r0-&gt;is_con() || !r1-&gt;is_con() )
 782     return TypeInt::INT;        // Any integer, but still no symbols.
 783 
 784   // Otherwise just OR them bits.
 785   return TypeInt::make( r0-&gt;get_con() | r1-&gt;get_con() );
 786 }
 787 
 788 //=============================================================================
 789 //------------------------------Identity---------------------------------------
 790 Node* OrLNode::Identity(PhaseGVN* phase) {
 791   // x | x =&gt; x
 792   if (phase-&gt;eqv(in(1), in(2))) {
 793     return in(1);
 794   }
 795 
 796   return AddNode::Identity(phase);
 797 }
 798 
 799 //------------------------------add_ring---------------------------------------
 800 const Type *OrLNode::add_ring( const Type *t0, const Type *t1 ) const {
 801   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 802   const TypeLong *r1 = t1-&gt;is_long();
 803 
 804   // If either input is not a constant, just return all integers.
 805   if( !r0-&gt;is_con() || !r1-&gt;is_con() )
 806     return TypeLong::LONG;      // Any integer, but still no symbols.
 807 
 808   // Otherwise just OR them bits.
 809   return TypeLong::make( r0-&gt;get_con() | r1-&gt;get_con() );
 810 }
 811 
 812 //=============================================================================
 813 //------------------------------add_ring---------------------------------------
 814 // Supplied function returns the sum of the inputs IN THE CURRENT RING.  For
 815 // the logical operations the ring&#39;s ADD is really a logical OR function.
 816 // This also type-checks the inputs for sanity.  Guaranteed never to
 817 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 818 const Type *XorINode::add_ring( const Type *t0, const Type *t1 ) const {
 819   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 820   const TypeInt *r1 = t1-&gt;is_int();
 821 
 822   // Complementing a boolean?
 823   if( r0 == TypeInt::BOOL &amp;&amp; ( r1 == TypeInt::ONE
 824                                || r1 == TypeInt::BOOL))
 825     return TypeInt::BOOL;
 826 
 827   if( !r0-&gt;is_con() || !r1-&gt;is_con() ) // Not constants
 828     return TypeInt::INT;        // Any integer, but still no symbols.
 829 
 830   // Otherwise just XOR them bits.
 831   return TypeInt::make( r0-&gt;get_con() ^ r1-&gt;get_con() );
 832 }
 833 
 834 //=============================================================================
 835 //------------------------------add_ring---------------------------------------
 836 const Type *XorLNode::add_ring( const Type *t0, const Type *t1 ) const {
 837   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 838   const TypeLong *r1 = t1-&gt;is_long();
 839 
 840   // If either input is not a constant, just return all integers.
 841   if( !r0-&gt;is_con() || !r1-&gt;is_con() )
 842     return TypeLong::LONG;      // Any integer, but still no symbols.
 843 
 844   // Otherwise just OR them bits.
 845   return TypeLong::make( r0-&gt;get_con() ^ r1-&gt;get_con() );
 846 }
 847 
 848 
 849 Node* MaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN&amp; gvn) {
 850   bool is_int = gvn.type(a)-&gt;isa_int();
 851   assert(is_int || gvn.type(a)-&gt;isa_long(), &quot;int or long inputs&quot;);
 852   assert(is_int == (gvn.type(b)-&gt;isa_int() != NULL), &quot;inconsistent inputs&quot;);
 853   if (!is_unsigned) {
 854     if (is_max) {
 855       if (is_int) {
 856         Node* res =  gvn.transform(new MaxINode(a, b));
 857         assert(gvn.type(res)-&gt;is_int()-&gt;_lo &gt;= t-&gt;is_int()-&gt;_lo &amp;&amp; gvn.type(res)-&gt;is_int()-&gt;_hi &lt;= t-&gt;is_int()-&gt;_hi, &quot;type doesn&#39;t match&quot;);
 858         return res;
 859       } else {
 860         Node* cmp = gvn.transform(new CmpLNode(a, b));
 861         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 862         return gvn.transform(new CMoveLNode(bol, a, b, t-&gt;is_long()));
 863       }
 864     } else {
 865       if (is_int) {
 866         Node* res =  gvn.transform(new MinINode(a, b));
 867         assert(gvn.type(res)-&gt;is_int()-&gt;_lo &gt;= t-&gt;is_int()-&gt;_lo &amp;&amp; gvn.type(res)-&gt;is_int()-&gt;_hi &lt;= t-&gt;is_int()-&gt;_hi, &quot;type doesn&#39;t match&quot;);
 868         return res;
 869       } else {
 870         Node* cmp = gvn.transform(new CmpLNode(b, a));
 871         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 872         return gvn.transform(new CMoveLNode(bol, a, b, t-&gt;is_long()));
 873       }
 874     }
 875   } else {
 876     if (is_max) {
 877       if (is_int) {
 878         Node* cmp = gvn.transform(new CmpUNode(a, b));
 879         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 880         return gvn.transform(new CMoveINode(bol, a, b, t-&gt;is_int()));
 881       } else {
 882         Node* cmp = gvn.transform(new CmpULNode(a, b));
 883         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 884         return gvn.transform(new CMoveLNode(bol, a, b, t-&gt;is_long()));
 885       }
 886     } else {
 887       if (is_int) {
 888         Node* cmp = gvn.transform(new CmpUNode(b, a));
 889         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 890         return gvn.transform(new CMoveINode(bol, a, b, t-&gt;is_int()));
 891       } else {
 892         Node* cmp = gvn.transform(new CmpULNode(b, a));
 893         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 894         return gvn.transform(new CMoveLNode(bol, a, b, t-&gt;is_long()));
 895       }
 896     }
 897   }
 898 }
 899 
 900 Node* MaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN&amp; gvn) {
 901   bool is_int = gvn.type(a)-&gt;isa_int();
 902   assert(is_int || gvn.type(a)-&gt;isa_long(), &quot;int or long inputs&quot;);
 903   assert(is_int == (gvn.type(b)-&gt;isa_int() != NULL), &quot;inconsistent inputs&quot;);
 904   Node* zero = NULL;
 905   if (is_int) {
 906     zero = gvn.intcon(0);
 907   } else {
 908     zero = gvn.longcon(0);
 909   }
 910   if (is_max) {
 911     if (is_int) {
 912       Node* cmp = gvn.transform(new CmpINode(a, b));
 913       Node* sub = gvn.transform(new SubINode(a, b));
 914       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 915       return gvn.transform(new CMoveINode(bol, sub, zero, t-&gt;is_int()));
 916     } else {
 917       Node* cmp = gvn.transform(new CmpLNode(a, b));
 918       Node* sub = gvn.transform(new SubLNode(a, b));
 919       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 920       return gvn.transform(new CMoveLNode(bol, sub, zero, t-&gt;is_long()));
 921     }
 922   } else {
 923     if (is_int) {
 924       Node* cmp = gvn.transform(new CmpINode(b, a));
 925       Node* sub = gvn.transform(new SubINode(a, b));
 926       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 927       return gvn.transform(new CMoveINode(bol, sub, zero, t-&gt;is_int()));
 928     } else {
 929       Node* cmp = gvn.transform(new CmpLNode(b, a));
 930       Node* sub = gvn.transform(new SubLNode(a, b));
 931       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
 932       return gvn.transform(new CMoveLNode(bol, sub, zero, t-&gt;is_long()));
 933     }
 934   }
 935 }
 936 
 937 //=============================================================================
 938 //------------------------------add_ring---------------------------------------
 939 // Supplied function returns the sum of the inputs.
 940 const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {
 941   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 942   const TypeInt *r1 = t1-&gt;is_int();
 943 
 944   // Otherwise just MAX them bits.
 945   return TypeInt::make( MAX2(r0-&gt;_lo,r1-&gt;_lo), MAX2(r0-&gt;_hi,r1-&gt;_hi), MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 946 }
 947 
 948 //=============================================================================
 949 //------------------------------Idealize---------------------------------------
 950 // MINs show up in range-check loop limit calculations.  Look for
 951 // &quot;MIN2(x+c0,MIN2(y,x+c1))&quot;.  Pick the smaller constant: &quot;MIN2(x+c0,y)&quot;
 952 Node *MinINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 953   Node *progress = NULL;
 954   // Force a right-spline graph
 955   Node *l = in(1);
 956   Node *r = in(2);
 957   // Transform  MinI1( MinI2(a,b), c)  into  MinI1( a, MinI2(b,c) )
 958   // to force a right-spline graph for the rest of MinINode::Ideal().
 959   if( l-&gt;Opcode() == Op_MinI ) {
 960     assert( l != l-&gt;in(1), &quot;dead loop in MinINode::Ideal&quot; );
 961     r = phase-&gt;transform(new MinINode(l-&gt;in(2),r));
 962     l = l-&gt;in(1);
 963     set_req(1, l);
 964     set_req(2, r);
 965     return this;
 966   }
 967 
 968   // Get left input &amp; constant
 969   Node *x = l;
 970   int x_off = 0;
 971   if( x-&gt;Opcode() == Op_AddI &amp;&amp; // Check for &quot;x+c0&quot; and collect constant
 972       x-&gt;in(2)-&gt;is_Con() ) {
 973     const Type *t = x-&gt;in(2)-&gt;bottom_type();
 974     if( t == Type::TOP ) return NULL;  // No progress
 975     x_off = t-&gt;is_int()-&gt;get_con();
 976     x = x-&gt;in(1);
 977   }
 978 
 979   // Scan a right-spline-tree for MINs
 980   Node *y = r;
 981   int y_off = 0;
 982   // Check final part of MIN tree
 983   if( y-&gt;Opcode() == Op_AddI &amp;&amp; // Check for &quot;y+c1&quot; and collect constant
 984       y-&gt;in(2)-&gt;is_Con() ) {
 985     const Type *t = y-&gt;in(2)-&gt;bottom_type();
 986     if( t == Type::TOP ) return NULL;  // No progress
 987     y_off = t-&gt;is_int()-&gt;get_con();
 988     y = y-&gt;in(1);
 989   }
 990   if( x-&gt;_idx &gt; y-&gt;_idx &amp;&amp; r-&gt;Opcode() != Op_MinI ) {
 991     swap_edges(1, 2);
 992     return this;
 993   }
 994 
 995 
 996   if( r-&gt;Opcode() == Op_MinI ) {
 997     assert( r != r-&gt;in(2), &quot;dead loop in MinINode::Ideal&quot; );
 998     y = r-&gt;in(1);
 999     // Check final part of MIN tree
1000     if( y-&gt;Opcode() == Op_AddI &amp;&amp;// Check for &quot;y+c1&quot; and collect constant
1001         y-&gt;in(2)-&gt;is_Con() ) {
1002       const Type *t = y-&gt;in(2)-&gt;bottom_type();
1003       if( t == Type::TOP ) return NULL;  // No progress
1004       y_off = t-&gt;is_int()-&gt;get_con();
1005       y = y-&gt;in(1);
1006     }
1007 
1008     if( x-&gt;_idx &gt; y-&gt;_idx )
1009       return new MinINode(r-&gt;in(1),phase-&gt;transform(new MinINode(l,r-&gt;in(2))));
1010 
1011     // See if covers: MIN2(x+c0,MIN2(y+c1,z))
1012     if( !phase-&gt;eqv(x,y) ) return NULL;
1013     // If (y == x) transform MIN2(x+c0, MIN2(x+c1,z)) into
1014     // MIN2(x+c0 or x+c1 which less, z).
1015     return new MinINode(phase-&gt;transform(new AddINode(x,phase-&gt;intcon(MIN2(x_off,y_off)))),r-&gt;in(2));
1016   } else {
1017     // See if covers: MIN2(x+c0,y+c1)
1018     if( !phase-&gt;eqv(x,y) ) return NULL;
1019     // If (y == x) transform MIN2(x+c0,x+c1) into x+c0 or x+c1 which less.
1020     return new AddINode(x,phase-&gt;intcon(MIN2(x_off,y_off)));
1021   }
1022 
1023 }
1024 
1025 //------------------------------add_ring---------------------------------------
1026 // Supplied function returns the sum of the inputs.
1027 const Type *MinINode::add_ring( const Type *t0, const Type *t1 ) const {
1028   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
1029   const TypeInt *r1 = t1-&gt;is_int();
1030 
1031   // Otherwise just MIN them bits.
1032   return TypeInt::make( MIN2(r0-&gt;_lo,r1-&gt;_lo), MIN2(r0-&gt;_hi,r1-&gt;_hi), MAX2(r0-&gt;_widen,r1-&gt;_widen) );
1033 }
1034 
1035 //------------------------------add_ring---------------------------------------
1036 const Type *MinFNode::add_ring( const Type *t0, const Type *t1 ) const {
1037   const TypeF *r0 = t0-&gt;is_float_constant();
1038   const TypeF *r1 = t1-&gt;is_float_constant();
1039 
1040   if (r0-&gt;is_nan()) {
1041     return r0;
1042   }
1043   if (r1-&gt;is_nan()) {
1044     return r1;
1045   }
1046 
1047   float f0 = r0-&gt;getf();
1048   float f1 = r1-&gt;getf();
1049   if (f0 != 0.0f || f1 != 0.0f) {
1050     return f0 &lt; f1 ? r0 : r1;
1051   }
1052 
1053   // handle min of 0.0, -0.0 case.
1054   return (jint_cast(f0) &lt; jint_cast(f1)) ? r0 : r1;
1055 }
1056 
1057 //------------------------------add_ring---------------------------------------
1058 const Type *MinDNode::add_ring( const Type *t0, const Type *t1 ) const {
1059   const TypeD *r0 = t0-&gt;is_double_constant();
1060   const TypeD *r1 = t1-&gt;is_double_constant();
1061 
1062   if (r0-&gt;is_nan()) {
1063     return r0;
1064   }
1065   if (r1-&gt;is_nan()) {
1066     return r1;
1067   }
1068 
1069   double d0 = r0-&gt;getd();
1070   double d1 = r1-&gt;getd();
1071   if (d0 != 0.0 || d1 != 0.0) {
1072     return d0 &lt; d1 ? r0 : r1;
1073   }
1074 
1075   // handle min of 0.0, -0.0 case.
1076   return (jlong_cast(d0) &lt; jlong_cast(d1)) ? r0 : r1;
1077 }
1078 
1079 //------------------------------add_ring---------------------------------------
1080 const Type *MaxFNode::add_ring( const Type *t0, const Type *t1 ) const {
1081   const TypeF *r0 = t0-&gt;is_float_constant();
1082   const TypeF *r1 = t1-&gt;is_float_constant();
1083 
1084   if (r0-&gt;is_nan()) {
1085     return r0;
1086   }
1087   if (r1-&gt;is_nan()) {
1088     return r1;
1089   }
1090 
1091   float f0 = r0-&gt;getf();
1092   float f1 = r1-&gt;getf();
1093   if (f0 != 0.0f || f1 != 0.0f) {
1094     return f0 &gt; f1 ? r0 : r1;
1095   }
1096 
1097   // handle max of 0.0,-0.0 case.
1098   return (jint_cast(f0) &gt; jint_cast(f1)) ? r0 : r1;
1099 }
1100 
1101 //------------------------------add_ring---------------------------------------
1102 const Type *MaxDNode::add_ring( const Type *t0, const Type *t1 ) const {
1103   const TypeD *r0 = t0-&gt;is_double_constant();
1104   const TypeD *r1 = t1-&gt;is_double_constant();
1105 
1106   if (r0-&gt;is_nan()) {
1107     return r0;
1108   }
1109   if (r1-&gt;is_nan()) {
1110     return r1;
1111   }
1112 
1113   double d0 = r0-&gt;getd();
1114   double d1 = r1-&gt;getd();
1115   if (d0 != 0.0 || d1 != 0.0) {
1116     return d0 &gt; d1 ? r0 : r1;
1117   }
1118 
1119   // handle max of 0.0, -0.0 case.
1120   return (jlong_cast(d0) &gt; jlong_cast(d1)) ? r0 : r1;
1121 }
    </pre>
  </body>
</html>
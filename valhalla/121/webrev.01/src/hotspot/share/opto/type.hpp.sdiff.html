<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../precompiled/precompiled.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
<span class="line-modified">  28 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  29 #include &quot;opto/adlcVMDeps.hpp&quot;
  30 #include &quot;runtime/handles.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 // Optimization - Graph Style
  36 
  37 
  38 // This class defines a Type lattice.  The lattice is used in the constant
  39 // propagation algorithms, and for some type-checking of the iloc code.
  40 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  41 // float &amp; double precision constants, sets of data-labels and code-labels.
  42 // The complete lattice is described below.  Subtypes have no relationship to
  43 // up or down in the lattice; that is entirely determined by the behavior of
  44 // the MEET/JOIN functions.
  45 
  46 class Dict;
  47 class Type;
  48 class   TypeD;
  49 class   TypeF;
  50 class   TypeInt;
  51 class   TypeLong;
  52 class   TypeNarrowPtr;
  53 class     TypeNarrowOop;
  54 class     TypeNarrowKlass;
  55 class   TypeAry;
  56 class   TypeTuple;
<span class="line-modified">  57 class   TypeValueType;</span>
  58 class   TypeVect;
  59 class     TypeVectS;
  60 class     TypeVectD;
  61 class     TypeVectX;
  62 class     TypeVectY;
  63 class     TypeVectZ;
  64 class   TypePtr;
  65 class     TypeRawPtr;
  66 class     TypeOopPtr;
  67 class       TypeInstPtr;
  68 class       TypeAryPtr;
  69 class     TypeKlassPtr;
  70 class     TypeMetadataPtr;
  71 
  72 //------------------------------Type-------------------------------------------
  73 // Basic Type object, represents a set of primitive Values.
  74 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  75 // different kind of Type exists.  Types are never modified after creation, so
  76 // all their interesting fields are constant.
  77 class Type {
  78   friend class VMStructs;
  79 
  80 public:
  81   enum TYPES {
  82     Bad=0,                      // Type check
  83     Control,                    // Control of code (not in lattice)
  84     Top,                        // Top of the lattice
  85     Int,                        // Integer range (lo-hi)
  86     Long,                       // Long integer range (lo-hi)
  87     Half,                       // Placeholder half of doubleword
  88     NarrowOop,                  // Compressed oop pointer
  89     NarrowKlass,                // Compressed klass pointer
  90 
  91     Tuple,                      // Method signature or object layout
  92     Array,                      // Array types
  93     VectorS,                    //  32bit Vector types
  94     VectorD,                    //  64bit Vector types
  95     VectorX,                    // 128bit Vector types
  96     VectorY,                    // 256bit Vector types
  97     VectorZ,                    // 512bit Vector types
<span class="line-modified">  98     ValueType,                  // Value type</span>
  99 
 100     AnyPtr,                     // Any old raw, klass, inst, or array pointer
 101     RawPtr,                     // Raw (non-oop) pointers
 102     OopPtr,                     // Any and all Java heap entities
 103     InstPtr,                    // Instance pointers (non-array objects)
 104     AryPtr,                     // Array pointers
 105     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 106 
 107     MetadataPtr,                // Generic metadata
 108     KlassPtr,                   // Klass pointers
 109 
 110     Function,                   // Function signature
 111     Abio,                       // Abstract I/O
 112     Return_Address,             // Subroutine return address
 113     Memory,                     // Abstract store
 114     FloatTop,                   // No float value
 115     FloatCon,                   // Floating point constant
 116     FloatBot,                   // Any float value
 117     DoubleTop,                  // No double value
 118     DoubleCon,                  // Double precision constant
</pre>
<hr />
<pre>
 316   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 317   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 318   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 319   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 320   const TypeVect   *is_vect() const;             // Vector
 321   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 322   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 323   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 324   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 325   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 326   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 327   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 328   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 329   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 330   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 331   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 332   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 333   const TypeInstPtr  *is_instptr() const;        // Instance
 334   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 335   const TypeAryPtr   *is_aryptr() const;         // Array oop
<span class="line-modified"> 336   const TypeValueType* isa_valuetype() const;    // Returns NULL if not Value Type</span>
<span class="line-modified"> 337   const TypeValueType* is_valuetype() const;     // Value Type</span>
 338 
 339   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 340   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 341   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 342   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 343 
 344   virtual bool      is_finite() const;           // Has a finite value
 345   virtual bool      is_nan()    const;           // Is not a number (NaN)
 346 
<span class="line-modified"> 347   bool is_valuetypeptr() const;</span>
<span class="line-modified"> 348   virtual ciValueKlass* value_klass() const;</span>
 349 
 350   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 351   const TypePtr* make_ptr() const;
 352 
 353   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 354   // Asserts if the underlying type is not an oopptr or narrowoop.
 355   const TypeOopPtr* make_oopptr() const;
 356 
 357   // Returns this compressed pointer or the equivalent compressed version
 358   // of this pointer type.
 359   const TypeNarrowOop* make_narrowoop() const;
 360 
 361   // Returns this compressed klass pointer or the equivalent
 362   // compressed version of this pointer type.
 363   const TypeNarrowKlass* make_narrowklass() const;
 364 
 365   // Special test for register pressure heuristic
 366   bool is_floatingpoint() const;        // True if Float or Double base type
 367 
 368   // Do you have memory, directly or through a tuple?
</pre>
<hr />
<pre>
 719   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 720 #endif
 721 };
 722 
 723 //------------------------------TypeAry----------------------------------------
 724 // Class of Array Types
 725 class TypeAry : public Type {
 726   TypeAry(const Type* elem, const TypeInt* size, bool stable, bool not_flat, bool not_null_free) : Type(Array),
 727       _elem(elem), _size(size), _stable(stable), _not_flat(not_flat), _not_null_free(not_null_free) {}
 728 public:
 729   virtual bool eq( const Type *t ) const;
 730   virtual int  hash() const;             // Type specific hashing
 731   virtual bool singleton(void) const;    // TRUE if type is a singleton
 732   virtual bool empty(void) const;        // TRUE if type is vacuous
 733 
 734 private:
 735   const Type *_elem;            // Element type of array
 736   const TypeInt *_size;         // Elements in array
 737   const bool _stable;           // Are elements @Stable?
 738 
<span class="line-modified"> 739   // Value type array properties</span>
 740   const bool _not_flat;         // Array is never flattened
 741   const bool _not_null_free;    // Array is never null-free
 742 
 743   friend class TypeAryPtr;
 744 
 745 public:
 746   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,
 747                              bool not_flat = false, bool not_null_free = false);
 748 
 749   virtual const Type *xmeet( const Type *t ) const;
 750   virtual const Type *xdual() const;    // Compute dual right now.
 751   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 752   virtual const Type* remove_speculative() const;
 753   virtual const Type* cleanup_speculative() const;
 754 
 755 #ifdef ASSERT
 756   // One type is interface, the other is oop
 757   virtual bool interface_vs_oop(const Type *t) const;
 758 #endif
 759 #ifndef PRODUCT
 760   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 761 #endif
 762 };
 763 
 764 
 765 //------------------------------TypeValue---------------------------------------
<span class="line-modified"> 766 // Class of Value Type Types</span>
<span class="line-modified"> 767 class TypeValueType : public Type {</span>
 768 private:
<span class="line-modified"> 769   ciValueKlass* _vk;</span>
 770   bool _larval;
 771 
 772 protected:
<span class="line-modified"> 773   TypeValueType(ciValueKlass* vk, bool larval)</span>
<span class="line-modified"> 774     : Type(ValueType),</span>
 775       _vk(vk), _larval(larval) {
 776   }
 777 
 778 public:
<span class="line-modified"> 779   static const TypeValueType* make(ciValueKlass* vk, bool larval = false);</span>
<span class="line-modified"> 780   virtual ciValueKlass* value_klass() const { return _vk; }</span>
 781   bool larval() const { return _larval; }
 782 
 783   virtual bool eq(const Type* t) const;
 784   virtual int  hash() const;             // Type specific hashing
 785   virtual bool singleton(void) const;    // TRUE if type is a singleton
 786   virtual bool empty(void) const;        // TRUE if type is vacuous
 787 
 788   virtual const Type* xmeet(const Type* t) const;
 789   virtual const Type* xdual() const;     // Compute dual right now.
 790 
 791   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }
 792   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }
 793 
<span class="line-modified"> 794   static const TypeValueType *BOTTOM;</span>
 795 
 796 #ifndef PRODUCT
 797   virtual void dump2(Dict &amp;d, uint, outputStream* st) const; // Specialized per-Type dumping
 798 #endif
 799 };
 800 
 801 //------------------------------TypeVect---------------------------------------
 802 // Class of Vector Types
 803 class TypeVect : public Type {
 804   const Type*   _elem;  // Vector&#39;s element type
 805   const uint  _length;  // Elements in vector (power of 2)
 806 
 807 protected:
 808   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 809     _elem(elem), _length(length) {}
 810 
 811 public:
 812   const Type* element_type() const { return _elem; }
 813   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 814   uint length() const { return _length; }
</pre>
<hr />
<pre>
 958   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 959   PTR join_ptr( const PTR in_ptr ) const {
 960     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 961   }
 962 
 963   // Speculative type helper methods.
 964   virtual const TypePtr* speculative() const { return _speculative; }
 965   int inline_depth() const                   { return _inline_depth; }
 966   virtual ciKlass* speculative_type() const;
 967   virtual ciKlass* speculative_type_not_null() const;
 968   virtual bool speculative_maybe_null() const;
 969   virtual bool speculative_always_null() const;
 970   virtual const Type* remove_speculative() const;
 971   virtual const Type* cleanup_speculative() const;
 972   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 973   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 974   virtual const TypePtr* with_inline_depth(int depth) const;
 975 
 976   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 977 
<span class="line-modified"> 978   virtual bool can_be_value_type() const { return false; }</span>
 979   virtual bool flat_array() const { return false; }
 980 
 981   // Tests for relation to centerline of type lattice:
 982   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 983   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 984   // Convenience common pre-built types.
 985   static const TypePtr *NULL_PTR;
 986   static const TypePtr *NOTNULL;
 987   static const TypePtr *BOTTOM;
 988 #ifndef PRODUCT
 989   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 990 #endif
 991 };
 992 
 993 //------------------------------TypeRawPtr-------------------------------------
 994 // Class of raw pointers, pointers to things other than Oops.  Examples
 995 // include the stack pointer, top of heap, card-marking area, handles, etc.
 996 class TypeRawPtr : public TypePtr {
 997 protected:
 998   TypeRawPtr(PTR ptr, address bits) : TypePtr(RawPtr,ptr,Offset(0)), _bits(bits){}
</pre>
<hr />
<pre>
1086                                               bool require_constant = false);
1087 
1088   // Make a generic (unclassed) pointer to an oop.
1089   static const TypeOopPtr* make(PTR ptr, Offset offset, int instance_id,
1090                                 const TypePtr* speculative = NULL,
1091                                 int inline_depth = InlineDepthBottom);
1092 
1093   ciObject* const_oop()    const { return _const_oop; }
1094   virtual ciKlass* klass() const { return _klass;     }
1095   bool klass_is_exact()    const { return _klass_is_exact; }
1096 
1097   // Returns true if this pointer points at memory which contains a
1098   // compressed oop references.
1099   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1100   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1101   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1102   bool is_known_instance()       const { return _instance_id &gt; 0; }
1103   int  instance_id()             const { return _instance_id; }
1104   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset.get() &gt;= 0; }
1105 
<span class="line-modified">1106   virtual bool can_be_value_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_value_klass(_klass_is_exact)); }</span>
1107 
1108   virtual intptr_t get_con() const;
1109 
1110   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1111 
1112   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1113 
1114   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1115 
1116   // corresponding pointer to klass, for a given instance
1117   const TypeKlassPtr* as_klass_type() const;
1118 
1119   virtual const TypePtr *add_offset( intptr_t offset ) const;
1120 
1121   // Speculative type helper methods.
1122   virtual const Type* remove_speculative() const;
1123   virtual const Type* cleanup_speculative() const;
1124   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1125   virtual const TypePtr* with_inline_depth(int depth) const;
1126 
</pre>
<hr />
<pre>
1140 //------------------------------TypeInstPtr------------------------------------
1141 // Class of Java object pointers, pointing either to non-array Java instances
1142 // or to a Klass* (including array klasses).
1143 class TypeInstPtr : public TypeOopPtr {
1144   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1145               bool is_value, int instance_id, const TypePtr* speculative,
1146               int inline_depth);
1147   virtual bool eq( const Type *t ) const;
1148   virtual int  hash() const;             // Type specific hashing
1149 
1150   ciSymbol*  _name;        // class name
1151   bool _flat_array;
1152 
1153  public:
1154   ciSymbol* name()         const { return _name; }
1155 
1156   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1157 
1158   // Make a pointer to a constant oop.
1159   static const TypeInstPtr *make(ciObject* o) {
<span class="line-modified">1160     return make(TypePtr::Constant, o-&gt;klass(), true, o, Offset(0), o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);</span>
1161   }
1162   // Make a pointer to a constant oop with offset.
1163   static const TypeInstPtr* make(ciObject* o, Offset offset) {
<span class="line-modified">1164     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);</span>
1165   }
1166 
1167   // Make a pointer to some value of type klass.
1168   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
<span class="line-modified">1169     return make(ptr, klass, false, NULL, Offset(0), klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);</span>
1170   }
1171 
1172   // Make a pointer to some non-polymorphic value of exactly type klass.
1173   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
<span class="line-modified">1174     return make(ptr, klass, true, NULL, Offset(0), klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);</span>
1175   }
1176 
1177   // Make a pointer to some value of type klass with offset.
1178   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
<span class="line-modified">1179     return make(ptr, klass, false, NULL, offset, klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);</span>
1180   }
1181 
1182   // Make a pointer to an oop.
1183   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1184                                  bool flat_array,
1185                                  int instance_id = InstanceBot,
1186                                  const TypePtr* speculative = NULL,
1187                                  int inline_depth = InlineDepthBottom);
1188 
1189   /** Create constant type for a constant boxed value */
1190   const Type* get_const_boxed_value() const;
1191 
1192   // If this is a java.lang.Class constant, return the type for it or NULL.
1193   // Pass to Type::get_const_type to turn it to a type, which will usually
1194   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1195   ciType* java_mirror_type() const;
1196 
1197   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1198 
1199   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1200 
1201   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1202 
1203   virtual const TypePtr *add_offset( intptr_t offset ) const;
1204 
1205   // Speculative type helper methods.
1206   virtual const Type* remove_speculative() const;
1207   virtual const TypePtr* with_inline_depth(int depth) const;
1208   virtual const TypePtr* with_instance_id(int instance_id) const;
1209 
1210   virtual const TypeInstPtr* cast_to_flat_array() const;
1211   virtual bool flat_array() const {
<span class="line-modified">1212     assert(!klass()-&gt;is_valuetype() || !klass()-&gt;as_value_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);</span>
<span class="line-modified">1213     assert(!_flat_array || can_be_value_type(), &quot;incorrect value bit&quot;);</span>
1214     return _flat_array;
1215   }
1216 
1217   // the core of the computation of the meet of 2 types
1218   virtual const Type *xmeet_helper(const Type *t) const;
1219   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1220   virtual const Type *xdual() const;    // Compute dual right now.
1221 
1222   // Convenience common pre-built types.
1223   static const TypeInstPtr *NOTNULL;
1224   static const TypeInstPtr *BOTTOM;
1225   static const TypeInstPtr *MIRROR;
1226   static const TypeInstPtr *MARK;
1227   static const TypeInstPtr *KLASS;
1228 #ifndef PRODUCT
1229   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1230 #endif
1231 };
1232 
1233 //------------------------------TypeAryPtr-------------------------------------
</pre>
<hr />
<pre>
1245     if (k != NULL) {
1246       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1247       ciKlass* ck = compute_klass(true);
1248       if (k != ck) {
1249         this-&gt;dump(); tty-&gt;cr();
1250         tty-&gt;print(&quot; k: &quot;);
1251         k-&gt;print(); tty-&gt;cr();
1252         tty-&gt;print(&quot;ck: &quot;);
1253         if (ck != NULL) ck-&gt;print();
1254         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1255         tty-&gt;cr();
1256         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1257       }
1258     }
1259 #endif
1260   }
1261   virtual bool eq( const Type *t ) const;
1262   virtual int hash() const;     // Type specific hashing
1263   const TypeAry *_ary;          // Array we point into
1264   const bool     _is_autobox_cache;
<span class="line-modified">1265   // For flattened value type arrays, each field of the value type in</span>
1266   // the array has its own memory slice so we need to keep track of
1267   // which field is accessed
1268   const Offset _field_offset;
1269   Offset meet_field_offset(const Type::Offset offset) const;
1270   Offset dual_field_offset() const;
1271 
1272   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1273 
1274 public:
1275   // Accessors
1276   ciKlass* klass() const;
1277   const TypeAry* ary() const  { return _ary; }
1278   const Type*    elem() const { return _ary-&gt;_elem; }
1279   const TypeInt* size() const { return _ary-&gt;_size; }
1280   bool      is_stable() const { return _ary-&gt;_stable; }
1281 
<span class="line-modified">1282   // Value type array properties</span>
1283   bool is_not_flat()      const { return _ary-&gt;_not_flat; }
1284   bool is_not_null_free() const { return _ary-&gt;_not_null_free; }
1285 
1286   bool is_autobox_cache() const { return _is_autobox_cache; }
1287 
1288   static const TypeAryPtr* make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1289                                 Offset field_offset = Offset::bottom,
1290                                 int instance_id = InstanceBot,
1291                                 const TypePtr* speculative = NULL,
1292                                 int inline_depth = InlineDepthBottom);
1293   // Constant pointer to array
1294   static const TypeAryPtr* make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1295                                 Offset field_offset = Offset::bottom,
1296                                 int instance_id = InstanceBot,
1297                                 const TypePtr* speculative = NULL,
1298                                 int inline_depth = InlineDepthBottom,
1299                                 bool is_autobox_cache = false);
1300 
1301   // Return a &#39;ptr&#39; version of this type
1302   virtual const Type *cast_to_ptr_type(PTR ptr) const;
</pre>
<hr />
<pre>
1319 
1320   // the core of the computation of the meet of 2 types
1321   virtual const Type *xmeet_helper(const Type *t) const;
1322   virtual const Type *xdual() const;    // Compute dual right now.
1323 
1324   const TypeAryPtr* cast_to_not_flat(bool not_flat = true) const;
1325   const TypeAryPtr* cast_to_not_null_free(bool not_null_free = true) const;
1326 
1327   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1328   int stable_dimension() const;
1329 
1330   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1331 
1332   static jint max_array_length(BasicType etype);
1333 
1334   const int flattened_offset() const;
1335   const Offset field_offset() const { return _field_offset; }
1336   const TypeAryPtr* with_field_offset(int offset) const;
1337   const TypePtr* add_field_offset_and_offset(intptr_t offset) const;
1338 
<span class="line-modified">1339   virtual bool can_be_value_type() const { return false; }</span>
1340 
1341   // Convenience common pre-built types.
1342   static const TypeAryPtr *RANGE;
1343   static const TypeAryPtr *OOPS;
1344   static const TypeAryPtr *NARROWOOPS;
1345   static const TypeAryPtr *BYTES;
1346   static const TypeAryPtr *SHORTS;
1347   static const TypeAryPtr *CHARS;
1348   static const TypeAryPtr *INTS;
1349   static const TypeAryPtr *LONGS;
1350   static const TypeAryPtr *FLOATS;
1351   static const TypeAryPtr *DOUBLES;
<span class="line-modified">1352   static const TypeAryPtr *VALUES;</span>
1353   // selects one of the above:
1354   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1355     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1356     return _array_body_type[elem];
1357   }
1358   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1359   // sharpen the type of an int which is used as an array size
1360 #ifdef ASSERT
1361   // One type is interface, the other is oop
1362   virtual bool interface_vs_oop(const Type *t) const;
1363 #endif
1364 #ifndef PRODUCT
1365   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1366 #endif
1367 };
1368 
1369 //------------------------------TypeMetadataPtr-------------------------------------
1370 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1371 class TypeMetadataPtr : public TypePtr {
1372 protected:
</pre>
<hr />
<pre>
1412   TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array);
1413 
1414 protected:
1415   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1416  public:
1417   virtual bool eq( const Type *t ) const;
1418   virtual int hash() const;             // Type specific hashing
1419   virtual bool singleton(void) const;    // TRUE if type is a singleton
1420  private:
1421 
1422   ciKlass* _klass;
1423 
1424   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1425   bool          _klass_is_exact;
1426   bool _flat_array;
1427 
1428 public:
1429   ciKlass* klass() const { return  _klass; }
1430   bool klass_is_exact()    const { return _klass_is_exact; }
1431 
<span class="line-modified">1432   virtual bool can_be_value_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_value_klass(_klass_is_exact)); }</span>
1433   virtual bool flat_array() const {
<span class="line-modified">1434     assert(!klass()-&gt;is_valuetype() || !klass()-&gt;as_value_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);</span>
<span class="line-modified">1435     assert(!_flat_array || can_be_value_type(), &quot;incorrect value bit&quot;);</span>
1436     return _flat_array;
1437   }
1438 
1439   bool  is_loaded() const { return klass() != NULL &amp;&amp; klass()-&gt;is_loaded(); }
1440 
1441   // ptr to klass &#39;k&#39;
<span class="line-modified">1442   static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0), k-&gt;is_valuetype() &amp;&amp; k-&gt;as_value_klass()-&gt;flatten_array()); }</span>
1443   // ptr to klass &#39;k&#39; with offset
<span class="line-modified">1444   static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset, k-&gt;is_valuetype() &amp;&amp; k-&gt;as_value_klass()-&gt;flatten_array()); }</span>
1445   // ptr to klass &#39;k&#39; or sub-klass
1446   static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flat_array);
1447 
1448   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1449 
1450   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1451 
1452   // corresponding pointer to instance, for a given class
1453   const TypeOopPtr* as_instance_type() const;
1454 
1455   virtual const TypePtr *add_offset( intptr_t offset ) const;
1456   virtual const Type    *xmeet( const Type *t ) const;
1457   virtual const Type    *xdual() const;      // Compute dual right now.
1458 
1459   virtual intptr_t get_con() const;
1460 
1461   // Convenience common pre-built types.
1462   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1463   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1464 #ifndef PRODUCT
</pre>
<hr />
<pre>
1584   static const TypeNarrowKlass *make( const TypePtr* type);
1585 
1586   // static const TypeNarrowKlass *BOTTOM;
1587   static const TypeNarrowKlass *NULL_PTR;
1588 
1589 #ifndef PRODUCT
1590   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1591 #endif
1592 };
1593 
1594 //------------------------------TypeFunc---------------------------------------
1595 // Class of Array Types
1596 class TypeFunc : public Type {
1597   TypeFunc(const TypeTuple *domain_sig, const TypeTuple *domain_cc, const TypeTuple *range_sig, const TypeTuple *range_cc)
1598     : Type(Function), _domain_sig(domain_sig), _domain_cc(domain_cc), _range_sig(range_sig), _range_cc(range_cc) {}
1599   virtual bool eq( const Type *t ) const;
1600   virtual int  hash() const;             // Type specific hashing
1601   virtual bool singleton(void) const;    // TRUE if type is a singleton
1602   virtual bool empty(void) const;        // TRUE if type is vacuous
1603 
<span class="line-modified">1604   // Domains of inputs: value type arguments are not passed by</span>
<span class="line-modified">1605   // reference, instead each field of the value type is passed as an</span>
1606   // argument. We maintain 2 views of the argument list here: one
<span class="line-modified">1607   // based on the signature (with a value type argument as a single</span>
1608   // slot), one based on the actual calling convention (with a value
1609   // type argument as a list of its fields).
1610   const TypeTuple* const _domain_sig;
1611   const TypeTuple* const _domain_cc;
<span class="line-modified">1612   // Range of results. Similar to domains: a value type result can be</span>
1613   // returned in registers in which case range_cc lists all fields and
1614   // is the actual calling convention.
1615   const TypeTuple* const _range_sig;
1616   const TypeTuple* const _range_cc;
1617 
1618 public:
1619   // Constants are shared among ADLC and VM
1620   enum { Control    = AdlcVMDeps::Control,
1621          I_O        = AdlcVMDeps::I_O,
1622          Memory     = AdlcVMDeps::Memory,
1623          FramePtr   = AdlcVMDeps::FramePtr,
1624          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1625          Parms      = AdlcVMDeps::Parms
1626   };
1627 
1628 
1629   // Accessors:
1630   const TypeTuple* domain_sig() const { return _domain_sig; }
1631   const TypeTuple* domain_cc()  const { return _domain_cc; }
1632   const TypeTuple* range_sig()  const { return _range_sig; }
1633   const TypeTuple* range_cc()   const { return _range_cc; }
1634 
1635   static const TypeFunc* make(ciMethod* method, bool is_osr_compilation = false);
1636   static const TypeFunc *make(const TypeTuple* domain_sig, const TypeTuple* domain_cc,
1637                               const TypeTuple* range_sig, const TypeTuple* range_cc);
1638   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1639 
1640   virtual const Type *xmeet( const Type *t ) const;
1641   virtual const Type *xdual() const;    // Compute dual right now.
1642 
1643   BasicType return_type() const;
1644 
<span class="line-modified">1645   bool returns_value_type_as_fields() const { return range_sig() != range_cc(); }</span>
1646 
1647 #ifndef PRODUCT
1648   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1649 #endif
1650   // Convenience common pre-built types.
1651 };
1652 
1653 //------------------------------accessors--------------------------------------
1654 inline bool Type::is_ptr_to_narrowoop() const {
1655 #ifdef _LP64
1656   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1657 #else
1658   return false;
1659 #endif
1660 }
1661 
1662 inline bool Type::is_ptr_to_narrowklass() const {
1663 #ifdef _LP64
1664   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1665 #else
</pre>
<hr />
<pre>
1780 }
1781 
1782 inline const TypeInstPtr *Type::isa_instptr() const {
1783   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1784 }
1785 
1786 inline const TypeInstPtr *Type::is_instptr() const {
1787   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1788   return (TypeInstPtr*)this;
1789 }
1790 
1791 inline const TypeAryPtr *Type::isa_aryptr() const {
1792   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1793 }
1794 
1795 inline const TypeAryPtr *Type::is_aryptr() const {
1796   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1797   return (TypeAryPtr*)this;
1798 }
1799 
<span class="line-modified">1800 inline const TypeValueType* Type::isa_valuetype() const {</span>
<span class="line-modified">1801   return (_base == ValueType) ? (TypeValueType*)this : NULL;</span>
1802 }
1803 
<span class="line-modified">1804 inline const TypeValueType* Type::is_valuetype() const {</span>
<span class="line-modified">1805   assert(_base == ValueType, &quot;Not a value type&quot;);</span>
<span class="line-modified">1806   return (TypeValueType*)this;</span>
1807 }
1808 
1809 inline const TypeNarrowOop *Type::is_narrowoop() const {
1810   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1811   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1812   return (TypeNarrowOop*)this;
1813 }
1814 
1815 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1816   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1817   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1818 }
1819 
1820 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1821   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1822   return (TypeNarrowKlass*)this;
1823 }
1824 
1825 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1826   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
</pre>
<hr />
<pre>
1855   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1856 }
1857 
1858 inline const TypeNarrowOop* Type::make_narrowoop() const {
1859   return (_base == NarrowOop) ? is_narrowoop() :
1860                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1861 }
1862 
1863 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1864   return (_base == NarrowKlass) ? is_narrowklass() :
1865                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1866 }
1867 
1868 inline bool Type::is_floatingpoint() const {
1869   if( (_base == FloatCon)  || (_base == FloatBot) ||
1870       (_base == DoubleCon) || (_base == DoubleBot) )
1871     return true;
1872   return false;
1873 }
1874 
<span class="line-modified">1875 inline bool Type::is_valuetypeptr() const {</span>
<span class="line-modified">1876   return isa_instptr() != NULL &amp;&amp; is_instptr()-&gt;klass()-&gt;is_valuetype();</span>
1877 }
1878 
1879 
<span class="line-modified">1880 inline ciValueKlass* Type::value_klass() const {</span>
<span class="line-modified">1881   assert(is_valuetypeptr(), &quot;must be a value type ptr&quot;);</span>
<span class="line-modified">1882   return is_instptr()-&gt;klass()-&gt;as_value_klass();</span>
1883 }
1884 
1885 
1886 // ===============================================================
1887 // Things that need to be 64-bits in the 64-bit build but
1888 // 32-bits in the 32-bit build.  Done this way to get full
1889 // optimization AND strong typing.
1890 #ifdef _LP64
1891 
1892 // For type queries and asserts
1893 #define is_intptr_t  is_long
1894 #define isa_intptr_t isa_long
1895 #define find_intptr_t_type find_long_type
1896 #define find_intptr_t_con  find_long_con
1897 #define TypeX        TypeLong
1898 #define Type_X       Type::Long
1899 #define TypeX_X      TypeLong::LONG
1900 #define TypeX_ZERO   TypeLong::ZERO
1901 // For &#39;ideal_reg&#39; machine registers
1902 #define Op_RegX      Op_RegL
</pre>
</td>
<td>
<hr />
<pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
<span class="line-modified">  28 #include &quot;ci/ciInlineKlass.hpp&quot;</span>
  29 #include &quot;opto/adlcVMDeps.hpp&quot;
  30 #include &quot;runtime/handles.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 // Optimization - Graph Style
  36 
  37 
  38 // This class defines a Type lattice.  The lattice is used in the constant
  39 // propagation algorithms, and for some type-checking of the iloc code.
  40 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  41 // float &amp; double precision constants, sets of data-labels and code-labels.
  42 // The complete lattice is described below.  Subtypes have no relationship to
  43 // up or down in the lattice; that is entirely determined by the behavior of
  44 // the MEET/JOIN functions.
  45 
  46 class Dict;
  47 class Type;
  48 class   TypeD;
  49 class   TypeF;
  50 class   TypeInt;
  51 class   TypeLong;
  52 class   TypeNarrowPtr;
  53 class     TypeNarrowOop;
  54 class     TypeNarrowKlass;
  55 class   TypeAry;
  56 class   TypeTuple;
<span class="line-modified">  57 class   TypeInlineType;</span>
  58 class   TypeVect;
  59 class     TypeVectS;
  60 class     TypeVectD;
  61 class     TypeVectX;
  62 class     TypeVectY;
  63 class     TypeVectZ;
  64 class   TypePtr;
  65 class     TypeRawPtr;
  66 class     TypeOopPtr;
  67 class       TypeInstPtr;
  68 class       TypeAryPtr;
  69 class     TypeKlassPtr;
  70 class     TypeMetadataPtr;
  71 
  72 //------------------------------Type-------------------------------------------
  73 // Basic Type object, represents a set of primitive Values.
  74 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  75 // different kind of Type exists.  Types are never modified after creation, so
  76 // all their interesting fields are constant.
  77 class Type {
  78   friend class VMStructs;
  79 
  80 public:
  81   enum TYPES {
  82     Bad=0,                      // Type check
  83     Control,                    // Control of code (not in lattice)
  84     Top,                        // Top of the lattice
  85     Int,                        // Integer range (lo-hi)
  86     Long,                       // Long integer range (lo-hi)
  87     Half,                       // Placeholder half of doubleword
  88     NarrowOop,                  // Compressed oop pointer
  89     NarrowKlass,                // Compressed klass pointer
  90 
  91     Tuple,                      // Method signature or object layout
  92     Array,                      // Array types
  93     VectorS,                    //  32bit Vector types
  94     VectorD,                    //  64bit Vector types
  95     VectorX,                    // 128bit Vector types
  96     VectorY,                    // 256bit Vector types
  97     VectorZ,                    // 512bit Vector types
<span class="line-modified">  98     InlineType,                 // Inline type</span>
  99 
 100     AnyPtr,                     // Any old raw, klass, inst, or array pointer
 101     RawPtr,                     // Raw (non-oop) pointers
 102     OopPtr,                     // Any and all Java heap entities
 103     InstPtr,                    // Instance pointers (non-array objects)
 104     AryPtr,                     // Array pointers
 105     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 106 
 107     MetadataPtr,                // Generic metadata
 108     KlassPtr,                   // Klass pointers
 109 
 110     Function,                   // Function signature
 111     Abio,                       // Abstract I/O
 112     Return_Address,             // Subroutine return address
 113     Memory,                     // Abstract store
 114     FloatTop,                   // No float value
 115     FloatCon,                   // Floating point constant
 116     FloatBot,                   // Any float value
 117     DoubleTop,                  // No double value
 118     DoubleCon,                  // Double precision constant
</pre>
<hr />
<pre>
 316   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 317   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 318   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 319   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 320   const TypeVect   *is_vect() const;             // Vector
 321   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 322   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 323   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 324   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 325   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 326   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 327   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 328   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 329   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 330   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 331   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 332   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 333   const TypeInstPtr  *is_instptr() const;        // Instance
 334   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 335   const TypeAryPtr   *is_aryptr() const;         // Array oop
<span class="line-modified"> 336   const TypeInlineType* isa_inlinetype() const;  // Returns NULL if not Inline Type</span>
<span class="line-modified"> 337   const TypeInlineType* is_inlinetype() const;   // Inline Type</span>
 338 
 339   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 340   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 341   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 342   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 343 
 344   virtual bool      is_finite() const;           // Has a finite value
 345   virtual bool      is_nan()    const;           // Is not a number (NaN)
 346 
<span class="line-modified"> 347   bool is_inlinetypeptr() const;</span>
<span class="line-modified"> 348   virtual ciInlineKlass* inline_klass() const;</span>
 349 
 350   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 351   const TypePtr* make_ptr() const;
 352 
 353   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 354   // Asserts if the underlying type is not an oopptr or narrowoop.
 355   const TypeOopPtr* make_oopptr() const;
 356 
 357   // Returns this compressed pointer or the equivalent compressed version
 358   // of this pointer type.
 359   const TypeNarrowOop* make_narrowoop() const;
 360 
 361   // Returns this compressed klass pointer or the equivalent
 362   // compressed version of this pointer type.
 363   const TypeNarrowKlass* make_narrowklass() const;
 364 
 365   // Special test for register pressure heuristic
 366   bool is_floatingpoint() const;        // True if Float or Double base type
 367 
 368   // Do you have memory, directly or through a tuple?
</pre>
<hr />
<pre>
 719   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 720 #endif
 721 };
 722 
 723 //------------------------------TypeAry----------------------------------------
 724 // Class of Array Types
 725 class TypeAry : public Type {
 726   TypeAry(const Type* elem, const TypeInt* size, bool stable, bool not_flat, bool not_null_free) : Type(Array),
 727       _elem(elem), _size(size), _stable(stable), _not_flat(not_flat), _not_null_free(not_null_free) {}
 728 public:
 729   virtual bool eq( const Type *t ) const;
 730   virtual int  hash() const;             // Type specific hashing
 731   virtual bool singleton(void) const;    // TRUE if type is a singleton
 732   virtual bool empty(void) const;        // TRUE if type is vacuous
 733 
 734 private:
 735   const Type *_elem;            // Element type of array
 736   const TypeInt *_size;         // Elements in array
 737   const bool _stable;           // Are elements @Stable?
 738 
<span class="line-modified"> 739   // Inline type array properties</span>
 740   const bool _not_flat;         // Array is never flattened
 741   const bool _not_null_free;    // Array is never null-free
 742 
 743   friend class TypeAryPtr;
 744 
 745 public:
 746   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,
 747                              bool not_flat = false, bool not_null_free = false);
 748 
 749   virtual const Type *xmeet( const Type *t ) const;
 750   virtual const Type *xdual() const;    // Compute dual right now.
 751   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 752   virtual const Type* remove_speculative() const;
 753   virtual const Type* cleanup_speculative() const;
 754 
 755 #ifdef ASSERT
 756   // One type is interface, the other is oop
 757   virtual bool interface_vs_oop(const Type *t) const;
 758 #endif
 759 #ifndef PRODUCT
 760   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 761 #endif
 762 };
 763 
 764 
 765 //------------------------------TypeValue---------------------------------------
<span class="line-modified"> 766 // Class of Inline Type Types</span>
<span class="line-modified"> 767 class TypeInlineType : public Type {</span>
 768 private:
<span class="line-modified"> 769   ciInlineKlass* _vk;</span>
 770   bool _larval;
 771 
 772 protected:
<span class="line-modified"> 773   TypeInlineType(ciInlineKlass* vk, bool larval)</span>
<span class="line-modified"> 774     : Type(InlineType),</span>
 775       _vk(vk), _larval(larval) {
 776   }
 777 
 778 public:
<span class="line-modified"> 779   static const TypeInlineType* make(ciInlineKlass* vk, bool larval = false);</span>
<span class="line-modified"> 780   virtual ciInlineKlass* inline_klass() const { return _vk; }</span>
 781   bool larval() const { return _larval; }
 782 
 783   virtual bool eq(const Type* t) const;
 784   virtual int  hash() const;             // Type specific hashing
 785   virtual bool singleton(void) const;    // TRUE if type is a singleton
 786   virtual bool empty(void) const;        // TRUE if type is vacuous
 787 
 788   virtual const Type* xmeet(const Type* t) const;
 789   virtual const Type* xdual() const;     // Compute dual right now.
 790 
 791   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }
 792   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }
 793 
<span class="line-modified"> 794   static const TypeInlineType *BOTTOM;</span>
 795 
 796 #ifndef PRODUCT
 797   virtual void dump2(Dict &amp;d, uint, outputStream* st) const; // Specialized per-Type dumping
 798 #endif
 799 };
 800 
 801 //------------------------------TypeVect---------------------------------------
 802 // Class of Vector Types
 803 class TypeVect : public Type {
 804   const Type*   _elem;  // Vector&#39;s element type
 805   const uint  _length;  // Elements in vector (power of 2)
 806 
 807 protected:
 808   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 809     _elem(elem), _length(length) {}
 810 
 811 public:
 812   const Type* element_type() const { return _elem; }
 813   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 814   uint length() const { return _length; }
</pre>
<hr />
<pre>
 958   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 959   PTR join_ptr( const PTR in_ptr ) const {
 960     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 961   }
 962 
 963   // Speculative type helper methods.
 964   virtual const TypePtr* speculative() const { return _speculative; }
 965   int inline_depth() const                   { return _inline_depth; }
 966   virtual ciKlass* speculative_type() const;
 967   virtual ciKlass* speculative_type_not_null() const;
 968   virtual bool speculative_maybe_null() const;
 969   virtual bool speculative_always_null() const;
 970   virtual const Type* remove_speculative() const;
 971   virtual const Type* cleanup_speculative() const;
 972   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 973   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 974   virtual const TypePtr* with_inline_depth(int depth) const;
 975 
 976   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 977 
<span class="line-modified"> 978   virtual bool can_be_inline_type() const { return false; }</span>
 979   virtual bool flat_array() const { return false; }
 980 
 981   // Tests for relation to centerline of type lattice:
 982   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 983   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 984   // Convenience common pre-built types.
 985   static const TypePtr *NULL_PTR;
 986   static const TypePtr *NOTNULL;
 987   static const TypePtr *BOTTOM;
 988 #ifndef PRODUCT
 989   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 990 #endif
 991 };
 992 
 993 //------------------------------TypeRawPtr-------------------------------------
 994 // Class of raw pointers, pointers to things other than Oops.  Examples
 995 // include the stack pointer, top of heap, card-marking area, handles, etc.
 996 class TypeRawPtr : public TypePtr {
 997 protected:
 998   TypeRawPtr(PTR ptr, address bits) : TypePtr(RawPtr,ptr,Offset(0)), _bits(bits){}
</pre>
<hr />
<pre>
1086                                               bool require_constant = false);
1087 
1088   // Make a generic (unclassed) pointer to an oop.
1089   static const TypeOopPtr* make(PTR ptr, Offset offset, int instance_id,
1090                                 const TypePtr* speculative = NULL,
1091                                 int inline_depth = InlineDepthBottom);
1092 
1093   ciObject* const_oop()    const { return _const_oop; }
1094   virtual ciKlass* klass() const { return _klass;     }
1095   bool klass_is_exact()    const { return _klass_is_exact; }
1096 
1097   // Returns true if this pointer points at memory which contains a
1098   // compressed oop references.
1099   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1100   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1101   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1102   bool is_known_instance()       const { return _instance_id &gt; 0; }
1103   int  instance_id()             const { return _instance_id; }
1104   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset.get() &gt;= 0; }
1105 
<span class="line-modified">1106   virtual bool can_be_inline_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_inline_klass(_klass_is_exact)); }</span>
1107 
1108   virtual intptr_t get_con() const;
1109 
1110   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1111 
1112   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1113 
1114   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1115 
1116   // corresponding pointer to klass, for a given instance
1117   const TypeKlassPtr* as_klass_type() const;
1118 
1119   virtual const TypePtr *add_offset( intptr_t offset ) const;
1120 
1121   // Speculative type helper methods.
1122   virtual const Type* remove_speculative() const;
1123   virtual const Type* cleanup_speculative() const;
1124   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1125   virtual const TypePtr* with_inline_depth(int depth) const;
1126 
</pre>
<hr />
<pre>
1140 //------------------------------TypeInstPtr------------------------------------
1141 // Class of Java object pointers, pointing either to non-array Java instances
1142 // or to a Klass* (including array klasses).
1143 class TypeInstPtr : public TypeOopPtr {
1144   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1145               bool is_value, int instance_id, const TypePtr* speculative,
1146               int inline_depth);
1147   virtual bool eq( const Type *t ) const;
1148   virtual int  hash() const;             // Type specific hashing
1149 
1150   ciSymbol*  _name;        // class name
1151   bool _flat_array;
1152 
1153  public:
1154   ciSymbol* name()         const { return _name; }
1155 
1156   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1157 
1158   // Make a pointer to a constant oop.
1159   static const TypeInstPtr *make(ciObject* o) {
<span class="line-modified">1160     return make(TypePtr::Constant, o-&gt;klass(), true, o, Offset(0), o-&gt;klass()-&gt;is_inlinetype() &amp;&amp; o-&gt;klass()-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);</span>
1161   }
1162   // Make a pointer to a constant oop with offset.
1163   static const TypeInstPtr* make(ciObject* o, Offset offset) {
<span class="line-modified">1164     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, o-&gt;klass()-&gt;is_inlinetype() &amp;&amp; o-&gt;klass()-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);</span>
1165   }
1166 
1167   // Make a pointer to some value of type klass.
1168   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
<span class="line-modified">1169     return make(ptr, klass, false, NULL, Offset(0), klass-&gt;is_inlinetype() &amp;&amp; klass-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);</span>
1170   }
1171 
1172   // Make a pointer to some non-polymorphic value of exactly type klass.
1173   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
<span class="line-modified">1174     return make(ptr, klass, true, NULL, Offset(0), klass-&gt;is_inlinetype() &amp;&amp; klass-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);</span>
1175   }
1176 
1177   // Make a pointer to some value of type klass with offset.
1178   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
<span class="line-modified">1179     return make(ptr, klass, false, NULL, offset, klass-&gt;is_inlinetype() &amp;&amp; klass-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);</span>
1180   }
1181 
1182   // Make a pointer to an oop.
1183   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1184                                  bool flat_array,
1185                                  int instance_id = InstanceBot,
1186                                  const TypePtr* speculative = NULL,
1187                                  int inline_depth = InlineDepthBottom);
1188 
1189   /** Create constant type for a constant boxed value */
1190   const Type* get_const_boxed_value() const;
1191 
1192   // If this is a java.lang.Class constant, return the type for it or NULL.
1193   // Pass to Type::get_const_type to turn it to a type, which will usually
1194   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1195   ciType* java_mirror_type() const;
1196 
1197   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1198 
1199   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1200 
1201   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1202 
1203   virtual const TypePtr *add_offset( intptr_t offset ) const;
1204 
1205   // Speculative type helper methods.
1206   virtual const Type* remove_speculative() const;
1207   virtual const TypePtr* with_inline_depth(int depth) const;
1208   virtual const TypePtr* with_instance_id(int instance_id) const;
1209 
1210   virtual const TypeInstPtr* cast_to_flat_array() const;
1211   virtual bool flat_array() const {
<span class="line-modified">1212     assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;as_inline_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);</span>
<span class="line-modified">1213     assert(!_flat_array || can_be_inline_type(), &quot;incorrect value bit&quot;);</span>
1214     return _flat_array;
1215   }
1216 
1217   // the core of the computation of the meet of 2 types
1218   virtual const Type *xmeet_helper(const Type *t) const;
1219   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1220   virtual const Type *xdual() const;    // Compute dual right now.
1221 
1222   // Convenience common pre-built types.
1223   static const TypeInstPtr *NOTNULL;
1224   static const TypeInstPtr *BOTTOM;
1225   static const TypeInstPtr *MIRROR;
1226   static const TypeInstPtr *MARK;
1227   static const TypeInstPtr *KLASS;
1228 #ifndef PRODUCT
1229   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1230 #endif
1231 };
1232 
1233 //------------------------------TypeAryPtr-------------------------------------
</pre>
<hr />
<pre>
1245     if (k != NULL) {
1246       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1247       ciKlass* ck = compute_klass(true);
1248       if (k != ck) {
1249         this-&gt;dump(); tty-&gt;cr();
1250         tty-&gt;print(&quot; k: &quot;);
1251         k-&gt;print(); tty-&gt;cr();
1252         tty-&gt;print(&quot;ck: &quot;);
1253         if (ck != NULL) ck-&gt;print();
1254         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1255         tty-&gt;cr();
1256         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1257       }
1258     }
1259 #endif
1260   }
1261   virtual bool eq( const Type *t ) const;
1262   virtual int hash() const;     // Type specific hashing
1263   const TypeAry *_ary;          // Array we point into
1264   const bool     _is_autobox_cache;
<span class="line-modified">1265   // For flattened inline type arrays, each field of the inline type in</span>
1266   // the array has its own memory slice so we need to keep track of
1267   // which field is accessed
1268   const Offset _field_offset;
1269   Offset meet_field_offset(const Type::Offset offset) const;
1270   Offset dual_field_offset() const;
1271 
1272   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1273 
1274 public:
1275   // Accessors
1276   ciKlass* klass() const;
1277   const TypeAry* ary() const  { return _ary; }
1278   const Type*    elem() const { return _ary-&gt;_elem; }
1279   const TypeInt* size() const { return _ary-&gt;_size; }
1280   bool      is_stable() const { return _ary-&gt;_stable; }
1281 
<span class="line-modified">1282   // Inline type array properties</span>
1283   bool is_not_flat()      const { return _ary-&gt;_not_flat; }
1284   bool is_not_null_free() const { return _ary-&gt;_not_null_free; }
1285 
1286   bool is_autobox_cache() const { return _is_autobox_cache; }
1287 
1288   static const TypeAryPtr* make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1289                                 Offset field_offset = Offset::bottom,
1290                                 int instance_id = InstanceBot,
1291                                 const TypePtr* speculative = NULL,
1292                                 int inline_depth = InlineDepthBottom);
1293   // Constant pointer to array
1294   static const TypeAryPtr* make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1295                                 Offset field_offset = Offset::bottom,
1296                                 int instance_id = InstanceBot,
1297                                 const TypePtr* speculative = NULL,
1298                                 int inline_depth = InlineDepthBottom,
1299                                 bool is_autobox_cache = false);
1300 
1301   // Return a &#39;ptr&#39; version of this type
1302   virtual const Type *cast_to_ptr_type(PTR ptr) const;
</pre>
<hr />
<pre>
1319 
1320   // the core of the computation of the meet of 2 types
1321   virtual const Type *xmeet_helper(const Type *t) const;
1322   virtual const Type *xdual() const;    // Compute dual right now.
1323 
1324   const TypeAryPtr* cast_to_not_flat(bool not_flat = true) const;
1325   const TypeAryPtr* cast_to_not_null_free(bool not_null_free = true) const;
1326 
1327   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1328   int stable_dimension() const;
1329 
1330   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1331 
1332   static jint max_array_length(BasicType etype);
1333 
1334   const int flattened_offset() const;
1335   const Offset field_offset() const { return _field_offset; }
1336   const TypeAryPtr* with_field_offset(int offset) const;
1337   const TypePtr* add_field_offset_and_offset(intptr_t offset) const;
1338 
<span class="line-modified">1339   virtual bool can_be_inline_type() const { return false; }</span>
1340 
1341   // Convenience common pre-built types.
1342   static const TypeAryPtr *RANGE;
1343   static const TypeAryPtr *OOPS;
1344   static const TypeAryPtr *NARROWOOPS;
1345   static const TypeAryPtr *BYTES;
1346   static const TypeAryPtr *SHORTS;
1347   static const TypeAryPtr *CHARS;
1348   static const TypeAryPtr *INTS;
1349   static const TypeAryPtr *LONGS;
1350   static const TypeAryPtr *FLOATS;
1351   static const TypeAryPtr *DOUBLES;
<span class="line-modified">1352   static const TypeAryPtr *INLINES;</span>
1353   // selects one of the above:
1354   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1355     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1356     return _array_body_type[elem];
1357   }
1358   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1359   // sharpen the type of an int which is used as an array size
1360 #ifdef ASSERT
1361   // One type is interface, the other is oop
1362   virtual bool interface_vs_oop(const Type *t) const;
1363 #endif
1364 #ifndef PRODUCT
1365   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1366 #endif
1367 };
1368 
1369 //------------------------------TypeMetadataPtr-------------------------------------
1370 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1371 class TypeMetadataPtr : public TypePtr {
1372 protected:
</pre>
<hr />
<pre>
1412   TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array);
1413 
1414 protected:
1415   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1416  public:
1417   virtual bool eq( const Type *t ) const;
1418   virtual int hash() const;             // Type specific hashing
1419   virtual bool singleton(void) const;    // TRUE if type is a singleton
1420  private:
1421 
1422   ciKlass* _klass;
1423 
1424   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1425   bool          _klass_is_exact;
1426   bool _flat_array;
1427 
1428 public:
1429   ciKlass* klass() const { return  _klass; }
1430   bool klass_is_exact()    const { return _klass_is_exact; }
1431 
<span class="line-modified">1432   virtual bool can_be_inline_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_inline_klass(_klass_is_exact)); }</span>
1433   virtual bool flat_array() const {
<span class="line-modified">1434     assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;as_inline_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);</span>
<span class="line-modified">1435     assert(!_flat_array || can_be_inline_type(), &quot;incorrect value bit&quot;);</span>
1436     return _flat_array;
1437   }
1438 
1439   bool  is_loaded() const { return klass() != NULL &amp;&amp; klass()-&gt;is_loaded(); }
1440 
1441   // ptr to klass &#39;k&#39;
<span class="line-modified">1442   static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0), k-&gt;is_inlinetype() &amp;&amp; k-&gt;as_inline_klass()-&gt;flatten_array()); }</span>
1443   // ptr to klass &#39;k&#39; with offset
<span class="line-modified">1444   static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset, k-&gt;is_inlinetype() &amp;&amp; k-&gt;as_inline_klass()-&gt;flatten_array()); }</span>
1445   // ptr to klass &#39;k&#39; or sub-klass
1446   static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flat_array);
1447 
1448   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1449 
1450   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1451 
1452   // corresponding pointer to instance, for a given class
1453   const TypeOopPtr* as_instance_type() const;
1454 
1455   virtual const TypePtr *add_offset( intptr_t offset ) const;
1456   virtual const Type    *xmeet( const Type *t ) const;
1457   virtual const Type    *xdual() const;      // Compute dual right now.
1458 
1459   virtual intptr_t get_con() const;
1460 
1461   // Convenience common pre-built types.
1462   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1463   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1464 #ifndef PRODUCT
</pre>
<hr />
<pre>
1584   static const TypeNarrowKlass *make( const TypePtr* type);
1585 
1586   // static const TypeNarrowKlass *BOTTOM;
1587   static const TypeNarrowKlass *NULL_PTR;
1588 
1589 #ifndef PRODUCT
1590   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1591 #endif
1592 };
1593 
1594 //------------------------------TypeFunc---------------------------------------
1595 // Class of Array Types
1596 class TypeFunc : public Type {
1597   TypeFunc(const TypeTuple *domain_sig, const TypeTuple *domain_cc, const TypeTuple *range_sig, const TypeTuple *range_cc)
1598     : Type(Function), _domain_sig(domain_sig), _domain_cc(domain_cc), _range_sig(range_sig), _range_cc(range_cc) {}
1599   virtual bool eq( const Type *t ) const;
1600   virtual int  hash() const;             // Type specific hashing
1601   virtual bool singleton(void) const;    // TRUE if type is a singleton
1602   virtual bool empty(void) const;        // TRUE if type is vacuous
1603 
<span class="line-modified">1604   // Domains of inputs: inline type arguments are not passed by</span>
<span class="line-modified">1605   // reference, instead each field of the inline type is passed as an</span>
1606   // argument. We maintain 2 views of the argument list here: one
<span class="line-modified">1607   // based on the signature (with an inline type argument as a single</span>
1608   // slot), one based on the actual calling convention (with a value
1609   // type argument as a list of its fields).
1610   const TypeTuple* const _domain_sig;
1611   const TypeTuple* const _domain_cc;
<span class="line-modified">1612   // Range of results. Similar to domains: an inline type result can be</span>
1613   // returned in registers in which case range_cc lists all fields and
1614   // is the actual calling convention.
1615   const TypeTuple* const _range_sig;
1616   const TypeTuple* const _range_cc;
1617 
1618 public:
1619   // Constants are shared among ADLC and VM
1620   enum { Control    = AdlcVMDeps::Control,
1621          I_O        = AdlcVMDeps::I_O,
1622          Memory     = AdlcVMDeps::Memory,
1623          FramePtr   = AdlcVMDeps::FramePtr,
1624          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1625          Parms      = AdlcVMDeps::Parms
1626   };
1627 
1628 
1629   // Accessors:
1630   const TypeTuple* domain_sig() const { return _domain_sig; }
1631   const TypeTuple* domain_cc()  const { return _domain_cc; }
1632   const TypeTuple* range_sig()  const { return _range_sig; }
1633   const TypeTuple* range_cc()   const { return _range_cc; }
1634 
1635   static const TypeFunc* make(ciMethod* method, bool is_osr_compilation = false);
1636   static const TypeFunc *make(const TypeTuple* domain_sig, const TypeTuple* domain_cc,
1637                               const TypeTuple* range_sig, const TypeTuple* range_cc);
1638   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1639 
1640   virtual const Type *xmeet( const Type *t ) const;
1641   virtual const Type *xdual() const;    // Compute dual right now.
1642 
1643   BasicType return_type() const;
1644 
<span class="line-modified">1645   bool returns_inline_type_as_fields() const { return range_sig() != range_cc(); }</span>
1646 
1647 #ifndef PRODUCT
1648   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1649 #endif
1650   // Convenience common pre-built types.
1651 };
1652 
1653 //------------------------------accessors--------------------------------------
1654 inline bool Type::is_ptr_to_narrowoop() const {
1655 #ifdef _LP64
1656   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1657 #else
1658   return false;
1659 #endif
1660 }
1661 
1662 inline bool Type::is_ptr_to_narrowklass() const {
1663 #ifdef _LP64
1664   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1665 #else
</pre>
<hr />
<pre>
1780 }
1781 
1782 inline const TypeInstPtr *Type::isa_instptr() const {
1783   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1784 }
1785 
1786 inline const TypeInstPtr *Type::is_instptr() const {
1787   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1788   return (TypeInstPtr*)this;
1789 }
1790 
1791 inline const TypeAryPtr *Type::isa_aryptr() const {
1792   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1793 }
1794 
1795 inline const TypeAryPtr *Type::is_aryptr() const {
1796   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1797   return (TypeAryPtr*)this;
1798 }
1799 
<span class="line-modified">1800 inline const TypeInlineType* Type::isa_inlinetype() const {</span>
<span class="line-modified">1801   return (_base == InlineType) ? (TypeInlineType*)this : NULL;</span>
1802 }
1803 
<span class="line-modified">1804 inline const TypeInlineType* Type::is_inlinetype() const {</span>
<span class="line-modified">1805   assert(_base == InlineType, &quot;Not an inline type&quot;);</span>
<span class="line-modified">1806   return (TypeInlineType*)this;</span>
1807 }
1808 
1809 inline const TypeNarrowOop *Type::is_narrowoop() const {
1810   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1811   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1812   return (TypeNarrowOop*)this;
1813 }
1814 
1815 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1816   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1817   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1818 }
1819 
1820 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1821   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1822   return (TypeNarrowKlass*)this;
1823 }
1824 
1825 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1826   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
</pre>
<hr />
<pre>
1855   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1856 }
1857 
1858 inline const TypeNarrowOop* Type::make_narrowoop() const {
1859   return (_base == NarrowOop) ? is_narrowoop() :
1860                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1861 }
1862 
1863 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1864   return (_base == NarrowKlass) ? is_narrowklass() :
1865                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1866 }
1867 
1868 inline bool Type::is_floatingpoint() const {
1869   if( (_base == FloatCon)  || (_base == FloatBot) ||
1870       (_base == DoubleCon) || (_base == DoubleBot) )
1871     return true;
1872   return false;
1873 }
1874 
<span class="line-modified">1875 inline bool Type::is_inlinetypeptr() const {</span>
<span class="line-modified">1876   return isa_instptr() != NULL &amp;&amp; is_instptr()-&gt;klass()-&gt;is_inlinetype();</span>
1877 }
1878 
1879 
<span class="line-modified">1880 inline ciInlineKlass* Type::inline_klass() const {</span>
<span class="line-modified">1881   assert(is_inlinetypeptr(), &quot;must be an inline type ptr&quot;);</span>
<span class="line-modified">1882   return is_instptr()-&gt;klass()-&gt;as_inline_klass();</span>
1883 }
1884 
1885 
1886 // ===============================================================
1887 // Things that need to be 64-bits in the 64-bit build but
1888 // 32-bits in the 32-bit build.  Done this way to get full
1889 // optimization AND strong typing.
1890 #ifdef _LP64
1891 
1892 // For type queries and asserts
1893 #define is_intptr_t  is_long
1894 #define isa_intptr_t isa_long
1895 #define find_intptr_t_type find_long_type
1896 #define find_intptr_t_con  find_long_con
1897 #define TypeX        TypeLong
1898 #define Type_X       Type::Long
1899 #define TypeX_X      TypeLong::LONG
1900 #define TypeX_ZERO   TypeLong::ZERO
1901 // For &#39;ideal_reg&#39; machine registers
1902 #define Op_RegX      Op_RegL
</pre>
</td>
</tr>
</table>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../precompiled/precompiled.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
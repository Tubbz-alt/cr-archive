<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/parse2.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parse1.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse3.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,17 ***</span>
  #include &quot;opto/castnode.hpp&quot;
  #include &quot;opto/convertnode.hpp&quot;
  #include &quot;opto/divnode.hpp&quot;
  #include &quot;opto/idealGraphPrinter.hpp&quot;
  #include &quot;opto/idealKit.hpp&quot;
  #include &quot;opto/matcher.hpp&quot;
  #include &quot;opto/memnode.hpp&quot;
  #include &quot;opto/mulnode.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
<span class="line-removed">- #include &quot;opto/valuetypenode.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  
  #ifndef PRODUCT
  extern int explicit_null_checks_inserted,
<span class="line-new-header">--- 35,17 ---</span>
  #include &quot;opto/castnode.hpp&quot;
  #include &quot;opto/convertnode.hpp&quot;
  #include &quot;opto/divnode.hpp&quot;
  #include &quot;opto/idealGraphPrinter.hpp&quot;
  #include &quot;opto/idealKit.hpp&quot;
<span class="line-added">+ #include &quot;opto/inlinetypenode.hpp&quot;</span>
  #include &quot;opto/matcher.hpp&quot;
  #include &quot;opto/memnode.hpp&quot;
  #include &quot;opto/mulnode.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  
  #ifndef PRODUCT
  extern int explicit_null_checks_inserted,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,26 ***</span>
    if (stopped())  return;     // guaranteed null or range check
  
    Node* idx = pop();
    Node* ary = pop();
  
<span class="line-modified">!   // Handle value type arrays</span>
    const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
    const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
<span class="line-modified">!   if (elemtype-&gt;isa_valuetype() != NULL) {</span>
      C-&gt;set_flattened_accesses();
<span class="line-modified">!     // Load from flattened value type array</span>
<span class="line-modified">!     Node* vt = ValueTypeNode::make_from_flattened(this, elemtype-&gt;value_klass(), ary, adr);</span>
      push(vt);
      return;
<span class="line-modified">!   } else if (elemptr != NULL &amp;&amp; elemptr-&gt;is_valuetypeptr() &amp;&amp; !elemptr-&gt;maybe_null()) {</span>
      // Load from non-flattened inline type array (elements can never be null)
      bt = T_INLINE_TYPE;
    } else if (!ary_t-&gt;is_not_flat()) {
      // Cannot statically determine if array is flattened, emit runtime check
<span class="line-modified">!     assert(UseFlatArray &amp;&amp; is_reference_type(bt) &amp;&amp; elemptr-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free() &amp;&amp;</span>
<span class="line-modified">!            (!elemptr-&gt;is_valuetypeptr() || elemptr-&gt;value_klass()-&gt;flatten_array()), &quot;array can&#39;t be flattened&quot;);</span>
      IdealKit ideal(this);
      IdealVariable res(ideal);
      ideal.declarations_done();
      ideal.if_then(is_non_flattened_array(ary)); {
        // non-flattened
<span class="line-new-header">--- 76,26 ---</span>
    if (stopped())  return;     // guaranteed null or range check
  
    Node* idx = pop();
    Node* ary = pop();
  
<span class="line-modified">!   // Handle inline type arrays</span>
    const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
    const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
<span class="line-modified">!   if (elemtype-&gt;isa_inlinetype() != NULL) {</span>
      C-&gt;set_flattened_accesses();
<span class="line-modified">!     // Load from flattened inline type array</span>
<span class="line-modified">!     Node* vt = InlineTypeNode::make_from_flattened(this, elemtype-&gt;inline_klass(), ary, adr);</span>
      push(vt);
      return;
<span class="line-modified">!   } else if (elemptr != NULL &amp;&amp; elemptr-&gt;is_inlinetypeptr() &amp;&amp; !elemptr-&gt;maybe_null()) {</span>
      // Load from non-flattened inline type array (elements can never be null)
      bt = T_INLINE_TYPE;
    } else if (!ary_t-&gt;is_not_flat()) {
      // Cannot statically determine if array is flattened, emit runtime check
<span class="line-modified">!     assert(UseFlatArray &amp;&amp; is_reference_type(bt) &amp;&amp; elemptr-&gt;can_be_inline_type() &amp;&amp; !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free() &amp;&amp;</span>
<span class="line-modified">!            (!elemptr-&gt;is_inlinetypeptr() || elemptr-&gt;inline_klass()-&gt;flatten_array()), &quot;array can&#39;t be flattened&quot;);</span>
      IdealKit ideal(this);
      IdealVariable res(ideal);
      ideal.declarations_done();
      ideal.if_then(is_non_flattened_array(ary)); {
        // non-flattened
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,23 ***</span>
        ideal.sync_kit(this);
        ideal.set(res, ld);
      } ideal.else_(); {
        // flattened
        sync_kit(ideal);
<span class="line-modified">!       if (elemptr-&gt;is_valuetypeptr()) {</span>
          // Element type is known, cast and load from flattened representation
<span class="line-modified">!         ciValueKlass* vk = elemptr-&gt;value_klass();</span>
          assert(vk-&gt;flatten_array() &amp;&amp; elemptr-&gt;maybe_null(), &quot;never/always flat - should be optimized&quot;);
          ciArrayKlass* array_klass = ciArrayKlass::make(vk);
          const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
          Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));
          Node* casted_adr = array_element_address(cast, idx, T_INLINE_TYPE, ary_t-&gt;size(), control());
          // Re-execute flattened array load if buffering triggers deoptimization
          PreserveReexecuteState preexecs(this);
          jvms()-&gt;set_should_reexecute(true);
          inc_sp(2);
<span class="line-modified">!         Node* vt = ValueTypeNode::make_from_flattened(this, vk, cast, casted_adr)-&gt;buffer(this, false);</span>
          ideal.set(res, vt);
          ideal.sync_kit(this);
        } else {
          // Element type is unknown, emit runtime call
          Node* kls = load_object_klass(ary);
<span class="line-new-header">--- 107,23 ---</span>
        ideal.sync_kit(this);
        ideal.set(res, ld);
      } ideal.else_(); {
        // flattened
        sync_kit(ideal);
<span class="line-modified">!       if (elemptr-&gt;is_inlinetypeptr()) {</span>
          // Element type is known, cast and load from flattened representation
<span class="line-modified">!         ciInlineKlass* vk = elemptr-&gt;inline_klass();</span>
          assert(vk-&gt;flatten_array() &amp;&amp; elemptr-&gt;maybe_null(), &quot;never/always flat - should be optimized&quot;);
          ciArrayKlass* array_klass = ciArrayKlass::make(vk);
          const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
          Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));
          Node* casted_adr = array_element_address(cast, idx, T_INLINE_TYPE, ary_t-&gt;size(), control());
          // Re-execute flattened array load if buffering triggers deoptimization
          PreserveReexecuteState preexecs(this);
          jvms()-&gt;set_should_reexecute(true);
          inc_sp(2);
<span class="line-modified">!         Node* vt = InlineTypeNode::make_from_flattened(this, vk, cast, casted_adr)-&gt;buffer(this, false);</span>
          ideal.set(res, vt);
          ideal.sync_kit(this);
        } else {
          // Element type is unknown, emit runtime call
          Node* kls = load_object_klass(ary);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,14 ***</span>
          alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
  
          // This membar keeps this access to an unknown flattened array
          // correctly ordered with other unknown and known flattened
          // array accesses.
<span class="line-modified">!         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));</span>
  
          BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">!         // Unknown value type might contain reference fields</span>
          if (false &amp;&amp; !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing)) {
            // FIXME 8230656 also merge changes from 8238759 in
            int base_off = sizeof(instanceOopDesc);
            Node* dst_base = basic_plus_adr(alloc_obj, base_off);
            Node* countx = obj_size;
<span class="line-new-header">--- 143,14 ---</span>
          alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
  
          // This membar keeps this access to an unknown flattened array
          // correctly ordered with other unknown and known flattened
          // array accesses.
<span class="line-modified">!         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::INLINES));</span>
  
          BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">!         // Unknown inline type might contain reference fields</span>
          if (false &amp;&amp; !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing)) {
            // FIXME 8230656 also merge changes from 8238759 in
            int base_off = sizeof(instanceOopDesc);
            Node* dst_base = basic_plus_adr(alloc_obj, base_off);
            Node* countx = obj_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,27 ***</span>
            Node* adr = basic_plus_adr(ary, base, scale);
  
            access_clone(adr, dst_base, countx, false);
          } else {
            ideal.sync_kit(this);
<span class="line-modified">!           ideal.make_leaf_call(OptoRuntime::load_unknown_value_Type(),</span>
<span class="line-modified">!                                CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_value),</span>
<span class="line-modified">!                                &quot;load_unknown_value&quot;,</span>
                                 ary, idx, alloc_obj);
            sync_kit(ideal);
          }
  
<span class="line-modified">!         // This makes sure no other thread sees a partially initialized buffered value</span>
          insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
  
          // Same as MemBarCPUOrder above: keep this unknown flattened
          // array access correctly ordered with other flattened array
          // access
<span class="line-modified">!         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));</span>
  
<span class="line-modified">!         // Prevent any use of the newly allocated value before it is</span>
<span class="line-removed">-         // fully initialized</span>
          alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
          alloc_obj-&gt;set_req(0, control());
          alloc_obj = _gvn.transform(alloc_obj);
  
          const Type* unknown_value = elemptr-&gt;is_instptr()-&gt;cast_to_flat_array();
<span class="line-new-header">--- 167,26 ---</span>
            Node* adr = basic_plus_adr(ary, base, scale);
  
            access_clone(adr, dst_base, countx, false);
          } else {
            ideal.sync_kit(this);
<span class="line-modified">!           ideal.make_leaf_call(OptoRuntime::load_unknown_inline_type(),</span>
<span class="line-modified">!                                CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_inline),</span>
<span class="line-modified">!                                &quot;load_unknown_inline&quot;,</span>
                                 ary, idx, alloc_obj);
            sync_kit(ideal);
          }
  
<span class="line-modified">!         // This makes sure no other thread sees a partially initialized buffered inline type</span>
          insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
  
          // Same as MemBarCPUOrder above: keep this unknown flattened
          // array access correctly ordered with other flattened array
          // access
<span class="line-modified">!         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::INLINES));</span>
  
<span class="line-modified">!         // Prevent any use of the newly allocated inline type before it is fully initialized</span>
          alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
          alloc_obj-&gt;set_req(0, control());
          alloc_obj = _gvn.transform(alloc_obj);
  
          const Type* unknown_value = elemptr-&gt;is_instptr()-&gt;cast_to_flat_array();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,17 ***</span>
    }
    const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
    Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,
                              IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
    if (bt == T_INLINE_TYPE) {
<span class="line-modified">!     // Loading a non-flattened value type from an array</span>
<span class="line-modified">!     assert(!gvn().type(ld)-&gt;maybe_null(), &quot;value type array elements should never be null&quot;);</span>
<span class="line-modified">!     if (elemptr-&gt;value_klass()-&gt;is_scalarizable()) {</span>
<span class="line-modified">!       ld = ValueTypeNode::make_from_oop(this, ld, elemptr-&gt;value_klass());</span>
      }
    }
<span class="line-modified">!   if (!ld-&gt;is_ValueType()) {</span>
      ld = record_profile_for_speculation_at_array_load(ld);
    }
  
    push_node(bt, ld);
  }
<span class="line-new-header">--- 208,17 ---</span>
    }
    const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
    Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,
                              IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
    if (bt == T_INLINE_TYPE) {
<span class="line-modified">!     // Loading a non-flattened inline type from an array</span>
<span class="line-modified">!     assert(!gvn().type(ld)-&gt;maybe_null(), &quot;inline type array elements should never be null&quot;);</span>
<span class="line-modified">!     if (elemptr-&gt;inline_klass()-&gt;is_scalarizable()) {</span>
<span class="line-modified">!       ld = InlineTypeNode::make_from_oop(this, ld, elemptr-&gt;inline_klass());</span>
      }
    }
<span class="line-modified">!   if (!ld-&gt;is_InlineType()) {</span>
      ld = record_profile_for_speculation_at_array_load(ld);
    }
  
    push_node(bt, ld);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,17 ***</span>
      const Type* tval = _gvn.type(cast_val);
      // We may have lost type information for &#39;val&#39; here due to the casts
      // emitted by the array_store_check code (see JDK-6312651)
      // TODO Remove this code once JDK-6312651 is in.
      const Type* tval_init = _gvn.type(val);
<span class="line-modified">!     bool not_inline = !tval-&gt;isa_valuetype() &amp;&amp; (tval == TypePtr::NULL_PTR || !tval_init-&gt;is_oopptr()-&gt;can_be_value_type() || !tval-&gt;is_oopptr()-&gt;can_be_value_type());</span>
<span class="line-modified">!     bool not_flattened = !UseFlatArray || not_inline || ((tval_init-&gt;is_valuetypeptr() || tval_init-&gt;isa_valuetype()) &amp;&amp; !tval_init-&gt;value_klass()-&gt;flatten_array());</span>
  
      if (!ary_t-&gt;is_not_null_free() &amp;&amp; not_inline &amp;&amp; (!tval-&gt;maybe_null() || !tval_init-&gt;maybe_null())) {
        // Storing a non-inline type, mark array as not null-free (-&gt; not flat).
        // This is only legal for non-null stores because the array_store_check always passes for null.
<span class="line-modified">!       // Null stores are handled in GraphKit::gen_value_array_null_guard().</span>
        ary_t = ary_t-&gt;cast_to_not_null_free();
        Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
        replace_in_map(ary, cast);
        ary = cast;
      } else if (!ary_t-&gt;is_not_flat() &amp;&amp; not_flattened) {
<span class="line-new-header">--- 248,17 ---</span>
      const Type* tval = _gvn.type(cast_val);
      // We may have lost type information for &#39;val&#39; here due to the casts
      // emitted by the array_store_check code (see JDK-6312651)
      // TODO Remove this code once JDK-6312651 is in.
      const Type* tval_init = _gvn.type(val);
<span class="line-modified">!     bool not_inline = !tval-&gt;isa_inlinetype() &amp;&amp; (tval == TypePtr::NULL_PTR || !tval_init-&gt;is_oopptr()-&gt;can_be_inline_type() || !tval-&gt;is_oopptr()-&gt;can_be_inline_type());</span>
<span class="line-modified">!     bool not_flattened = !UseFlatArray || not_inline || ((tval_init-&gt;is_inlinetypeptr() || tval_init-&gt;isa_inlinetype()) &amp;&amp; !tval_init-&gt;inline_klass()-&gt;flatten_array());</span>
  
      if (!ary_t-&gt;is_not_null_free() &amp;&amp; not_inline &amp;&amp; (!tval-&gt;maybe_null() || !tval_init-&gt;maybe_null())) {
        // Storing a non-inline type, mark array as not null-free (-&gt; not flat).
        // This is only legal for non-null stores because the array_store_check always passes for null.
<span class="line-modified">!       // Null stores are handled in GraphKit::gen_inline_array_null_guard().</span>
        ary_t = ary_t-&gt;cast_to_not_null_free();
        Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
        replace_in_map(ary, cast);
        ary = cast;
      } else if (!ary_t-&gt;is_not_flat() &amp;&amp; not_flattened) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,52 ***</span>
        Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
        replace_in_map(ary, cast);
        ary = cast;
      }
  
<span class="line-modified">!     if (ary_t-&gt;elem()-&gt;isa_valuetype() != NULL) {</span>
<span class="line-modified">!       // Store to flattened value type array</span>
        C-&gt;set_flattened_accesses();
<span class="line-modified">!       if (!cast_val-&gt;is_ValueType()) {</span>
          inc_sp(3);
          cast_val = null_check(cast_val);
          if (stopped()) return;
          dec_sp(3);
<span class="line-modified">!         cast_val = ValueTypeNode::make_from_oop(this, cast_val, ary_t-&gt;elem()-&gt;value_klass());</span>
        }
        // Re-execute flattened array store if buffering triggers deoptimization
        PreserveReexecuteState preexecs(this);
        inc_sp(3);
        jvms()-&gt;set_should_reexecute(true);
<span class="line-modified">!       cast_val-&gt;as_ValueType()-&gt;store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);</span>
        return;
<span class="line-modified">!     } else if (elemtype-&gt;is_valuetypeptr() &amp;&amp; !elemtype-&gt;maybe_null()) {</span>
        // Store to non-flattened inline type array (elements can never be null)
<span class="line-modified">!       if (!cast_val-&gt;is_ValueType() &amp;&amp; tval-&gt;maybe_null()) {</span>
          inc_sp(3);
          cast_val = null_check(cast_val);
          if (stopped()) return;
          dec_sp(3);
        }
      } else if (!ary_t-&gt;is_not_flat()) {
        // Array might be flattened, emit runtime checks
<span class="line-modified">!       assert(UseFlatArray &amp;&amp; !not_flattened &amp;&amp; elemtype-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp;</span>
               !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free(), &quot;array can&#39;t be flattened&quot;);
        IdealKit ideal(this);
        ideal.if_then(is_non_flattened_array(ary)); {
          // non-flattened
          assert(ideal.ctrl()-&gt;in(0)-&gt;as_If()-&gt;is_non_flattened_array_check(&amp;_gvn), &quot;Should be found&quot;);
          sync_kit(ideal);
<span class="line-modified">!         gen_value_array_null_guard(ary, cast_val, 3);</span>
          inc_sp(3);
          access_store_at(ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);
          dec_sp(3);
          ideal.sync_kit(this);
        } ideal.else_(); {
          Node* val = cast_val;
          // flattened
<span class="line-modified">!         if (!val-&gt;is_ValueType() &amp;&amp; tval-&gt;maybe_null()) {</span>
            // Add null check
            sync_kit(ideal);
            Node* null_ctl = top();
            val = null_check_oop(val, &amp;null_ctl);
            if (null_ctl != top()) {
<span class="line-new-header">--- 267,52 ---</span>
        Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
        replace_in_map(ary, cast);
        ary = cast;
      }
  
<span class="line-modified">!     if (ary_t-&gt;elem()-&gt;isa_inlinetype() != NULL) {</span>
<span class="line-modified">!       // Store to flattened inline type array</span>
        C-&gt;set_flattened_accesses();
<span class="line-modified">!       if (!cast_val-&gt;is_InlineType()) {</span>
          inc_sp(3);
          cast_val = null_check(cast_val);
          if (stopped()) return;
          dec_sp(3);
<span class="line-modified">!         cast_val = InlineTypeNode::make_from_oop(this, cast_val, ary_t-&gt;elem()-&gt;inline_klass());</span>
        }
        // Re-execute flattened array store if buffering triggers deoptimization
        PreserveReexecuteState preexecs(this);
        inc_sp(3);
        jvms()-&gt;set_should_reexecute(true);
<span class="line-modified">!       cast_val-&gt;as_InlineType()-&gt;store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);</span>
        return;
<span class="line-modified">!     } else if (elemtype-&gt;is_inlinetypeptr() &amp;&amp; !elemtype-&gt;maybe_null()) {</span>
        // Store to non-flattened inline type array (elements can never be null)
<span class="line-modified">!       if (!cast_val-&gt;is_InlineType() &amp;&amp; tval-&gt;maybe_null()) {</span>
          inc_sp(3);
          cast_val = null_check(cast_val);
          if (stopped()) return;
          dec_sp(3);
        }
      } else if (!ary_t-&gt;is_not_flat()) {
        // Array might be flattened, emit runtime checks
<span class="line-modified">!       assert(UseFlatArray &amp;&amp; !not_flattened &amp;&amp; elemtype-&gt;is_oopptr()-&gt;can_be_inline_type() &amp;&amp;</span>
               !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free(), &quot;array can&#39;t be flattened&quot;);
        IdealKit ideal(this);
        ideal.if_then(is_non_flattened_array(ary)); {
          // non-flattened
          assert(ideal.ctrl()-&gt;in(0)-&gt;as_If()-&gt;is_non_flattened_array_check(&amp;_gvn), &quot;Should be found&quot;);
          sync_kit(ideal);
<span class="line-modified">!         gen_inline_array_null_guard(ary, cast_val, 3);</span>
          inc_sp(3);
          access_store_at(ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);
          dec_sp(3);
          ideal.sync_kit(this);
        } ideal.else_(); {
          Node* val = cast_val;
          // flattened
<span class="line-modified">!         if (!val-&gt;is_InlineType() &amp;&amp; tval-&gt;maybe_null()) {</span>
            // Add null check
            sync_kit(ideal);
            Node* null_ctl = top();
            val = null_check_oop(val, &amp;null_ctl);
            if (null_ctl != top()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,68 ***</span>
              uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);
              dec_sp(3);
            }
            ideal.sync_kit(this);
          }
<span class="line-modified">!         // Try to determine the value klass</span>
<span class="line-modified">!         ciValueKlass* vk = NULL;</span>
<span class="line-modified">!         if (tval-&gt;isa_valuetype() || tval-&gt;is_valuetypeptr()) {</span>
<span class="line-modified">!           vk = tval-&gt;value_klass();</span>
<span class="line-modified">!         } else if (tval_init-&gt;isa_valuetype() || tval_init-&gt;is_valuetypeptr()) {</span>
<span class="line-modified">!           vk = tval_init-&gt;value_klass();</span>
<span class="line-modified">!         } else if (elemtype-&gt;is_valuetypeptr()) {</span>
<span class="line-modified">!           vk = elemtype-&gt;value_klass();</span>
          }
          Node* casted_ary = ary;
          if (vk != NULL &amp;&amp; !stopped()) {
            // Element type is known, cast and store to flattened representation
            sync_kit(ideal);
            assert(vk-&gt;flatten_array() &amp;&amp; elemtype-&gt;maybe_null(), &quot;never/always flat - should be optimized&quot;);
            ciArrayKlass* array_klass = ciArrayKlass::make(vk);
            const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
            casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));
            Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype-&gt;size(), control());
<span class="line-modified">!           if (!val-&gt;is_ValueType()) {</span>
<span class="line-modified">!             assert(!gvn().type(val)-&gt;maybe_null(), &quot;value type array elements should never be null&quot;);</span>
<span class="line-modified">!             val = ValueTypeNode::make_from_oop(this, val, vk);</span>
            }
            // Re-execute flattened array store if buffering triggers deoptimization
            PreserveReexecuteState preexecs(this);
            inc_sp(3);
            jvms()-&gt;set_should_reexecute(true);
<span class="line-modified">!           val-&gt;as_ValueType()-&gt;store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);</span>
            ideal.sync_kit(this);
          } else if (!ideal.ctrl()-&gt;is_top()) {
            // Element type is unknown, emit runtime call
            sync_kit(ideal);
  
            // This membar keeps this access to an unknown flattened
            // array correctly ordered with other unknown and known
            // flattened array accesses.
<span class="line-modified">!           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));</span>
            ideal.sync_kit(this);
  
<span class="line-modified">!           ideal.make_leaf_call(OptoRuntime::store_unknown_value_Type(),</span>
<span class="line-modified">!                                CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_value),</span>
<span class="line-modified">!                                &quot;store_unknown_value&quot;,</span>
                                 val, casted_ary, idx);
  
            sync_kit(ideal);
            // Same as MemBarCPUOrder above: keep this unknown
            // flattened array access correctly ordered with other
            // flattened array accesses.
<span class="line-modified">!           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));</span>
            ideal.sync_kit(this);
          }
        }
        ideal.end_if();
        sync_kit(ideal);
        return;
      } else if (!ary_t-&gt;is_not_null_free()) {
        // Array is not flattened but may be null free
<span class="line-modified">!       assert(elemtype-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact(), &quot;array can&#39;t be null free&quot;);</span>
<span class="line-modified">!       ary = gen_value_array_null_guard(ary, cast_val, 3, true);</span>
      }
    }
    inc_sp(3);
    access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);
    dec_sp(3);
<span class="line-new-header">--- 322,68 ---</span>
              uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);
              dec_sp(3);
            }
            ideal.sync_kit(this);
          }
<span class="line-modified">!         // Try to determine the inline klass</span>
<span class="line-modified">!         ciInlineKlass* vk = NULL;</span>
<span class="line-modified">!         if (tval-&gt;isa_inlinetype() || tval-&gt;is_inlinetypeptr()) {</span>
<span class="line-modified">!           vk = tval-&gt;inline_klass();</span>
<span class="line-modified">!         } else if (tval_init-&gt;isa_inlinetype() || tval_init-&gt;is_inlinetypeptr()) {</span>
<span class="line-modified">!           vk = tval_init-&gt;inline_klass();</span>
<span class="line-modified">!         } else if (elemtype-&gt;is_inlinetypeptr()) {</span>
<span class="line-modified">!           vk = elemtype-&gt;inline_klass();</span>
          }
          Node* casted_ary = ary;
          if (vk != NULL &amp;&amp; !stopped()) {
            // Element type is known, cast and store to flattened representation
            sync_kit(ideal);
            assert(vk-&gt;flatten_array() &amp;&amp; elemtype-&gt;maybe_null(), &quot;never/always flat - should be optimized&quot;);
            ciArrayKlass* array_klass = ciArrayKlass::make(vk);
            const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
            casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));
            Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype-&gt;size(), control());
<span class="line-modified">!           if (!val-&gt;is_InlineType()) {</span>
<span class="line-modified">!             assert(!gvn().type(val)-&gt;maybe_null(), &quot;inline type array elements should never be null&quot;);</span>
<span class="line-modified">!             val = InlineTypeNode::make_from_oop(this, val, vk);</span>
            }
            // Re-execute flattened array store if buffering triggers deoptimization
            PreserveReexecuteState preexecs(this);
            inc_sp(3);
            jvms()-&gt;set_should_reexecute(true);
<span class="line-modified">!           val-&gt;as_InlineType()-&gt;store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);</span>
            ideal.sync_kit(this);
          } else if (!ideal.ctrl()-&gt;is_top()) {
            // Element type is unknown, emit runtime call
            sync_kit(ideal);
  
            // This membar keeps this access to an unknown flattened
            // array correctly ordered with other unknown and known
            // flattened array accesses.
<span class="line-modified">!           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::INLINES));</span>
            ideal.sync_kit(this);
  
<span class="line-modified">!           ideal.make_leaf_call(OptoRuntime::store_unknown_inline_type(),</span>
<span class="line-modified">!                                CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline),</span>
<span class="line-modified">!                                &quot;store_unknown_inline&quot;,</span>
                                 val, casted_ary, idx);
  
            sync_kit(ideal);
            // Same as MemBarCPUOrder above: keep this unknown
            // flattened array access correctly ordered with other
            // flattened array accesses.
<span class="line-modified">!           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::INLINES));</span>
            ideal.sync_kit(this);
          }
        }
        ideal.end_if();
        sync_kit(ideal);
        return;
      } else if (!ary_t-&gt;is_not_null_free()) {
        // Array is not flattened but may be null free
<span class="line-modified">!       assert(elemtype-&gt;is_oopptr()-&gt;can_be_inline_type() &amp;&amp; !ary_t-&gt;klass_is_exact(), &quot;array can&#39;t be null free&quot;);</span>
<span class="line-modified">!       ary = gen_inline_array_null_guard(ary, cast_val, 3, true);</span>
      }
    }
    inc_sp(3);
    access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);
    dec_sp(3);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,19 ***</span>
      }
    }
    // Check for always knowing you are throwing a range-check exception
    if (stopped())  return top();
  
<span class="line-modified">!   // This could be an access to a value array. We can&#39;t tell if it&#39;s</span>
    // flat or not. Speculating it&#39;s not leads to a much simpler graph
    // shape. Check profiling.
    // For aastore, by the time we&#39;re here, the array store check should
    // have already taken advantage of profiling to cast the array to an
    // exact type reported by profiling
    const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
<span class="line-modified">!   if (elemtype-&gt;isa_valuetype() == NULL &amp;&amp;</span>
<span class="line-modified">!       (elemptr == NULL || !elemptr-&gt;is_valuetypeptr() || elemptr-&gt;maybe_null()) &amp;&amp;</span>
        !arytype-&gt;is_not_flat()) {
      assert(is_reference_type(type), &quot;Only references&quot;);
      // First check the speculative type
      Deoptimization::DeoptReason reason = Deoptimization::Reason_speculate_class_check;
      ciKlass* array_type = arytype-&gt;speculative_type();
<span class="line-new-header">--- 484,19 ---</span>
      }
    }
    // Check for always knowing you are throwing a range-check exception
    if (stopped())  return top();
  
<span class="line-modified">!   // This could be an access to an inline type array. We can&#39;t tell if it&#39;s</span>
    // flat or not. Speculating it&#39;s not leads to a much simpler graph
    // shape. Check profiling.
    // For aastore, by the time we&#39;re here, the array store check should
    // have already taken advantage of profiling to cast the array to an
    // exact type reported by profiling
    const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
<span class="line-modified">!   if (elemtype-&gt;isa_inlinetype() == NULL &amp;&amp;</span>
<span class="line-modified">!       (elemptr == NULL || !elemptr-&gt;is_inlinetypeptr() || elemptr-&gt;maybe_null()) &amp;&amp;</span>
        !arytype-&gt;is_not_flat()) {
      assert(is_reference_type(type), &quot;Only references&quot;);
      // First check the speculative type
      Deoptimization::DeoptReason reason = Deoptimization::Reason_speculate_class_check;
      ciKlass* array_type = arytype-&gt;speculative_type();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,12 ***</span>
    // flat so check this one first. Speculating on a non null free
    // array doesn&#39;t help aaload but could be profitable for a
    // subsequent aastore.
    elemptr = elemtype-&gt;make_oopptr();
    if (!arytype-&gt;is_not_null_free() &amp;&amp;
<span class="line-modified">!       elemtype-&gt;isa_valuetype() == NULL &amp;&amp;</span>
<span class="line-modified">!       (elemptr == NULL || !elemptr-&gt;is_valuetypeptr()) &amp;&amp;</span>
        UseArrayLoadStoreProfile) {
      assert(is_reference_type(type), &quot;&quot;);
      bool null_free_array = true;
      Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
      if (arytype-&gt;speculative() != NULL &amp;&amp;
<span class="line-new-header">--- 544,12 ---</span>
    // flat so check this one first. Speculating on a non null free
    // array doesn&#39;t help aaload but could be profitable for a
    // subsequent aastore.
    elemptr = elemtype-&gt;make_oopptr();
    if (!arytype-&gt;is_not_null_free() &amp;&amp;
<span class="line-modified">!       elemtype-&gt;isa_inlinetype() == NULL &amp;&amp;</span>
<span class="line-modified">!       (elemptr == NULL || !elemptr-&gt;is_inlinetypeptr()) &amp;&amp;</span>
        UseArrayLoadStoreProfile) {
      assert(is_reference_type(type), &quot;&quot;);
      bool null_free_array = true;
      Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
      if (arytype-&gt;speculative() != NULL &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,11 ***</span>
        ary = better_ary;
        arytype = _gvn.type(ary)-&gt;is_aryptr();
      }
    }
  
<span class="line-modified">!   if (!arytype-&gt;is_not_flat() &amp;&amp; elemtype-&gt;isa_valuetype() == NULL) {</span>
      assert(is_reference_type(type), &quot;&quot;);
      bool flat_array = true;
      Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
      if (arytype-&gt;speculative() != NULL &amp;&amp;
          arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_flat() &amp;&amp;
<span class="line-new-header">--- 575,11 ---</span>
        ary = better_ary;
        arytype = _gvn.type(ary)-&gt;is_aryptr();
      }
    }
  
<span class="line-modified">!   if (!arytype-&gt;is_not_flat() &amp;&amp; elemtype-&gt;isa_inlinetype() == NULL) {</span>
      assert(is_reference_type(type), &quot;&quot;);
      bool flat_array = true;
      Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
      if (arytype-&gt;speculative() != NULL &amp;&amp;
          arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_flat() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2057,32 ***</span>
      cmp = optimize_cmp_with_klass(cmp);
      do_if(btest, cmp);
      return;
    }
  
<span class="line-modified">!   // Allocate value type operands and re-execute on deoptimization</span>
<span class="line-modified">!   if (a-&gt;is_ValueType()) {</span>
      PreserveReexecuteState preexecs(this);
      inc_sp(2);
      jvms()-&gt;set_should_reexecute(true);
<span class="line-modified">!     a = a-&gt;as_ValueType()-&gt;buffer(this)-&gt;get_oop();</span>
    }
<span class="line-modified">!   if (b-&gt;is_ValueType()) {</span>
      PreserveReexecuteState preexecs(this);
      inc_sp(2);
      jvms()-&gt;set_should_reexecute(true);
<span class="line-modified">!     b = b-&gt;as_ValueType()-&gt;buffer(this)-&gt;get_oop();</span>
    }
  
    // First, do a normal pointer comparison
    const TypeOopPtr* ta = _gvn.type(a)-&gt;isa_oopptr();
    const TypeOopPtr* tb = _gvn.type(b)-&gt;isa_oopptr();
    Node* cmp = CmpP(a, b);
    cmp = optimize_cmp_with_klass(cmp);
<span class="line-modified">!   if (ta == NULL || !ta-&gt;can_be_value_type() ||</span>
<span class="line-modified">!       tb == NULL || !tb-&gt;can_be_value_type()) {</span>
<span class="line-modified">!     // This is sufficient, if one of the operands can&#39;t be a value type</span>
      do_if(btest, cmp);
      return;
    }
    Node* eq_region = NULL;
    if (btest == BoolTest::eq) {
<span class="line-new-header">--- 2056,32 ---</span>
      cmp = optimize_cmp_with_klass(cmp);
      do_if(btest, cmp);
      return;
    }
  
<span class="line-modified">!   // Allocate inline type operands and re-execute on deoptimization</span>
<span class="line-modified">!   if (a-&gt;is_InlineType()) {</span>
      PreserveReexecuteState preexecs(this);
      inc_sp(2);
      jvms()-&gt;set_should_reexecute(true);
<span class="line-modified">!     a = a-&gt;as_InlineType()-&gt;buffer(this)-&gt;get_oop();</span>
    }
<span class="line-modified">!   if (b-&gt;is_InlineType()) {</span>
      PreserveReexecuteState preexecs(this);
      inc_sp(2);
      jvms()-&gt;set_should_reexecute(true);
<span class="line-modified">!     b = b-&gt;as_InlineType()-&gt;buffer(this)-&gt;get_oop();</span>
    }
  
    // First, do a normal pointer comparison
    const TypeOopPtr* ta = _gvn.type(a)-&gt;isa_oopptr();
    const TypeOopPtr* tb = _gvn.type(b)-&gt;isa_oopptr();
    Node* cmp = CmpP(a, b);
    cmp = optimize_cmp_with_klass(cmp);
<span class="line-modified">!   if (ta == NULL || !ta-&gt;can_be_inline_type() ||</span>
<span class="line-modified">!       tb == NULL || !tb-&gt;can_be_inline_type()) {</span>
<span class="line-modified">!     // This is sufficient, if one of the operands can&#39;t be an inline type</span>
      do_if(btest, cmp);
      return;
    }
    Node* eq_region = NULL;
    if (btest == BoolTest::eq) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2129,18 ***</span>
        set_control(_gvn.transform(eq_region));
      }
      return;
    }
  
<span class="line-modified">!   // First operand is non-null, check if it is a value type</span>
<span class="line-modified">!   Node* is_value = is_value_type(not_null_a);</span>
    IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);
    Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));
    ne_region-&gt;init_req(2, not_value);
    set_control(_gvn.transform(new IfTrueNode(is_value_iff)));
  
<span class="line-modified">!   // The first operand is a value type, check if the second operand is non-null</span>
    inc_sp(2);
    null_ctl = top();
    Node* not_null_b = null_check_oop(b, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);
    dec_sp(2);
    ne_region-&gt;init_req(3, null_ctl);
<span class="line-new-header">--- 2128,18 ---</span>
        set_control(_gvn.transform(eq_region));
      }
      return;
    }
  
<span class="line-modified">!   // First operand is non-null, check if it is an inline type</span>
<span class="line-modified">!   Node* is_value = is_inline_type(not_null_a);</span>
    IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);
    Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));
    ne_region-&gt;init_req(2, not_value);
    set_control(_gvn.transform(new IfTrueNode(is_value_iff)));
  
<span class="line-modified">!   // The first operand is an inline type, check if the second operand is non-null</span>
    inc_sp(2);
    null_ctl = top();
    Node* not_null_b = null_check_oop(b, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);
    dec_sp(2);
    ne_region-&gt;init_req(3, null_ctl);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2485,13 ***</span>
        if (obj_type-&gt;speculative_type_not_null() != NULL) {
          ciKlass* k = obj_type-&gt;speculative_type();
          inc_sp(2);
          obj = maybe_cast_profiled_obj(obj, k);
          dec_sp(2);
<span class="line-modified">!         if (obj-&gt;is_ValueType()) {</span>
<span class="line-modified">!           assert(obj-&gt;as_ValueType()-&gt;is_allocated(&amp;_gvn), &quot;must be allocated&quot;);</span>
<span class="line-modified">!           obj = obj-&gt;as_ValueType()-&gt;get_oop();</span>
          }
          // Make the CmpP use the casted obj
          addp = basic_plus_adr(obj, addp-&gt;in(AddPNode::Offset));
          load_klass = load_klass-&gt;clone();
          load_klass-&gt;set_req(2, addp);
<span class="line-new-header">--- 2484,13 ---</span>
        if (obj_type-&gt;speculative_type_not_null() != NULL) {
          ciKlass* k = obj_type-&gt;speculative_type();
          inc_sp(2);
          obj = maybe_cast_profiled_obj(obj, k);
          dec_sp(2);
<span class="line-modified">!         if (obj-&gt;is_InlineType()) {</span>
<span class="line-modified">!           assert(obj-&gt;as_InlineType()-&gt;is_allocated(&amp;_gvn), &quot;must be allocated&quot;);</span>
<span class="line-modified">!           obj = obj-&gt;as_InlineType()-&gt;get_oop();</span>
          }
          // Make the CmpP use the casted obj
          addp = basic_plus_adr(obj, addp-&gt;in(AddPNode::Offset));
          load_klass = load_klass-&gt;clone();
          load_klass-&gt;set_req(2, addp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3336,11 ***</span>
    handle_if_null:
      // If this is a backwards branch in the bytecodes, add Safepoint
      maybe_add_safepoint(iter().get_dest());
      a = null();
      b = pop();
<span class="line-modified">!     if (b-&gt;is_ValueType()) {</span>
        // Return constant false because &#39;b&#39; is always non-null
        c = _gvn.makecon(TypeInt::CC_GT);
      } else {
        if (!_gvn.type(b)-&gt;speculative_maybe_null() &amp;&amp;
            !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
<span class="line-new-header">--- 3335,11 ---</span>
    handle_if_null:
      // If this is a backwards branch in the bytecodes, add Safepoint
      maybe_add_safepoint(iter().get_dest());
      a = null();
      b = pop();
<span class="line-modified">!     if (b-&gt;is_InlineType()) {</span>
        // Return constant false because &#39;b&#39; is always non-null
        c = _gvn.makecon(TypeInt::CC_GT);
      } else {
        if (!_gvn.type(b)-&gt;speculative_maybe_null() &amp;&amp;
            !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
</pre>
<center><a href="parse1.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse3.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
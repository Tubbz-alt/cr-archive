diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CheckcastTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CheckcastTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CheckcastTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test CheckcastTest
+ * @summary checkcast bytecode test
+ * @library /test/lib
+ * @compile VDefaultTest.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.CheckcastTest
+ * @run main/othervm -Xcomp runtime.valhalla.inlinetypes.CheckcastTest
+ */
+
+public class CheckcastTest {
+
+    static inline class Point {
+        int x;
+        int y;
+
+        public Point() {
+            x = 0;
+            y = 0;
+        }
+
+        public Point(int x, int y) {
+            this.x = x;
+            this.y = y;
+        }
+    }
+
+
+    static void testCastingFromObjectToVal(Object o) {
+        boolean npe = false;
+        try {
+            Point pv = (Point)o;
+        } catch(NullPointerException e) {
+            npe = true;
+        }
+        Asserts.assertTrue(npe == false || o == null, "Casting null to val should throw a NPE");
+    }
+
+    static void testCastingFromValToBox(Point p) {
+        boolean npe = false;
+        try {
+            Point.ref pb = p;
+        } catch(NullPointerException e) {
+            npe = true;
+        }
+        Asserts.assertFalse(npe, "Casting from val to box should not throw an NPE");
+    }
+
+    static void testCastingFromBoxToVal(Point.ref p) {
+        boolean npe = false;
+        try {
+            Point pv = (Point) p;
+        } catch(NullPointerException e) {
+            npe = true;
+        }
+        if (npe) {
+            Asserts.assertEquals(p, null, "NPE must be thrown only if p is null");
+        } else {
+            Asserts.assertNotEquals(p, null, "Casting null to val must thrown a NPE");
+        }
+
+    }
+
+    public static void main(String[] args) {
+        // Testing casting from box to val
+        // First invocation: casting null to Point with an unresolved class entry
+        testCastingFromBoxToVal(null);
+        // Second invocation: casting non-null to val, will trigger resolution of the class entry
+        testCastingFromBoxToVal(new Point(3,4));
+        // Third invocation: casting null to Point with a resolved class entry
+        testCastingFromBoxToVal(null);
+
+        // Testing casting from val to box
+        testCastingFromBoxToVal(new Point(3,4));
+
+        // Testing casting from object to val
+        // First invocation: casting null to Point with an unresolved class entry
+        testCastingFromObjectToVal(null);
+        // Second invocation: casting non-null to al, will trigger resolution of the class entry
+        testCastingFromObjectToVal(new Point(3,4));
+        // Third invocation: casting null to Point with a resolved class entry");
+        testCastingFromObjectToVal(null);
+        // Fourth invocation: with something not the right type
+        boolean cce = false;
+        try {
+            testCastingFromObjectToVal(new String("NotPoint"));
+        } catch(ClassCastException e) {
+            cce = true;
+        }
+        Asserts.assertTrue(cce,"casting invalid type to val should throw CCE");
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CircularityTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CircularityTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CircularityTest.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test
+ * @summary Test initialization of static inline fields with circularity
+ * @library /test/lib
+ * @compile CircularityTest.java
+ * @run main/othervm -Xint -XX:+EnableValhalla runtime.valhalla.inlinetypes.CircularityTest
+ */
+
+
+public class CircularityTest {
+    static boolean b = true;
+    static int counter = 0;
+
+    static inline class A {
+        static B b;
+        static C c;
+        int i = 0;
+    }
+
+    static inline class B {
+        static {
+            Asserts.assertNotNull(A.c, "Should have returned C's default value");
+        }
+        int i = 0;
+    }
+
+    static inline class C {
+        int i;
+        public C(int i) {
+            this.i = i;
+        }
+    }
+
+    static inline class D {
+        static C c;
+        int i = 0;
+        static {
+            if (CircularityTest.b) {
+                // throw an exception to cause D's initialization to fail
+                throw new RuntimeException();
+            }
+        }
+    }
+
+    static inline class E {
+        static F f;
+        static C c;
+        int i = 0;
+    }
+
+    static inline class F {
+        int i = 0;
+        static {
+            E.c = new C(5);
+        }
+    }
+
+    static inline class G {
+        static H h;
+        int i = 0;
+    }
+
+    static inline class H {
+        int i = 0;
+        static {
+            if (CircularityTest.b) {
+                // throw an exception to cause H's initialization to fail
+                throw new RuntimeException();
+            }
+        }
+    }
+
+    static inline class I {
+        static J j;
+        static H h;
+        int i = 0;
+    }
+
+    static inline class J {
+        int i = 0;
+        static {
+            CircularityTest.counter = 1;
+            H h = I.h;
+            CircularityTest.counter = 2;
+        }
+    }
+
+    static public void main(String[] args) {
+        Throwable exception = null;
+        // Test 1:
+        // Initialization of A will trigger initialization of B which, in its static
+        // initializer will access a static inline field c of A that has not been initialized
+        // yet. The access must succeed (no exception) because the field is being
+        // accessed during the initialization of D, by the thread initializing D,
+        // and the value must be the default value of C (not null).
+        try {
+            A a = new A();
+        } catch (Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNull(exception, "Circularity should not have caused exceptions");
+
+        // Test 2:
+        // Class D will fail to initialized (exception thrown in its static initializer).
+        // Attempt to access a static inline field of D *after* its failed initialization
+        // should trigger an exception.
+        exception = null;
+        try {
+            D d = new D();
+        } catch (Throwable t) {
+            // ignoring the exception thrown to cause initialization failure
+        }
+        try {
+            C c = D.c;
+        } catch (Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "Accessing static fields of a class which failed to initialized should throw an exception");
+        Asserts.assertEquals(exception.getClass(), java.lang.NoClassDefFoundError.class, "Wrong exception class");
+        // Test 3:
+        // Initialization of E will trigger the initialization of F which, in its static initalizer,
+        // will initialized a static inline field of F before the JVM does. The JVM must not
+        // overwrite the value set by user code.
+        E e = new E();
+        Asserts.assertEquals(E.c.i, 5, "JVM must not overwrite fields initialized by user code");
+
+        // Test 4:
+        // Initialization of G should fail because its static inline field h
+        exception = null;
+        try {
+            G g = new G();
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "G's initialization should have failed");
+        Asserts.assertEquals(exception.getClass(), java.lang.ExceptionInInitializerError.class, "Wrong exception");
+
+        // Test 5:
+        // Initialization of of I should fail when J tries to access I.h
+        exception = null;
+        try {
+            I i = new I();
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "I's initialization should have failed");
+        Asserts.assertEquals(exception.getClass(), java.lang.NoClassDefFoundError.class, "Wrong exception");
+        Asserts.assertEquals(CircularityTest.counter, 1, "Didn't failed at the right place");
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CreationErrorTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CreationErrorTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/CreationErrorTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.lang.invoke.*;
+import java.lang.ref.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.*;
+
+import static jdk.test.lib.Asserts.*;
+
+import jdk.experimental.bytecode.MacroCodeBuilder;
+import jdk.experimental.bytecode.MacroCodeBuilder.CondKind;
+import jdk.experimental.bytecode.TypeTag;
+import jdk.test.lib.Platform;
+import jdk.test.lib.Utils;
+
+import jdk.experimental.value.MethodHandleBuilder;
+
+import javax.tools.*;
+
+/**
+ * @test CreationErrorTest
+ * @summary Test data movement with inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @run main/othervm -Xint -Xmx128m -XX:-ShowMessageBoxOnError
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
+ *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false
+ *                   runtime.valhalla.inlinetypes.CreationErrorTest
+ */
+
+public class CreationErrorTest {
+
+    static inline class InlineClass {
+        int i = 0;
+    }
+
+    static class IdentityClass {
+        long l = 0L;
+    }
+
+    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+
+    public static void main(String[] args) {
+        testErroneousObjectCreation();
+        testErroneousValueCreation();
+    }
+
+    static void testErroneousObjectCreation() {
+        MethodHandle testNewOnInlineClass = MethodHandleBuilder.loadCode(
+                LOOKUP,
+                "testNewOnInlineClass",
+                MethodType.methodType(boolean.class),
+                CODE -> {
+                    CODE.new_(InlineClass.class)
+                        .iconst_1()
+                        .return_(TypeTag.Z);
+                });
+        Throwable error = null;
+        try {
+            boolean result = (boolean) testNewOnInlineClass.invokeExact();
+        } catch (Throwable t) {
+            error = t;
+        }
+        System.out.println("error="+error);
+        assertTrue(error != null && error instanceof InstantiationError, "Invariant");
+
+    }
+
+    // Note: this test might become obsolete if defaultvalue is extended to accept identity classes
+    static void testErroneousValueCreation() {
+        MethodHandle testDefaultvalueOnIdentityClass = MethodHandleBuilder.loadCode(
+                LOOKUP,
+                "testDefaultValueOnIdentityClass",
+                MethodType.methodType(boolean.class),
+                CODE -> {
+                    CODE.defaultvalue(IdentityClass.class)
+                        .iconst_1()
+                        .return_(TypeTag.Z);
+                });
+        Throwable error = null;
+        try {
+            boolean result = (boolean) testDefaultvalueOnIdentityClass.invokeExact();
+        } catch (Throwable t) {
+            error = t;
+        }
+        System.out.println("error="+error);
+        assertTrue(error != null && error instanceof IncompatibleClassChangeError, "Invariant");
+
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/EmptyInlineTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/EmptyInlineTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/EmptyInlineTest.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+import java.lang.reflect.Field;
+
+/*
+ * @test
+ * @summary Test support for empty inline types (no instance fields)
+ * @library /test/lib
+ * @compile -XDallowEmptyValues EmptyInlineTest.java
+ * @run main/othervm -XX:+EnableValhalla runtime.valhalla.inlinetypes.EmptyInlineTest
+
+ */
+
+public class EmptyInlineTest {
+
+    static inline class EmptyInline {
+        public boolean isEmpty() {
+            return true;
+        }
+    }
+
+    static inline class EmptyField {
+        EmptyInline empty;
+
+        EmptyField() {
+            this.empty = new EmptyInline();
+        }
+    }
+
+    static class WithInt {
+        int i;
+    }
+
+    static class WithEmptyField extends WithInt  {
+        // With current layout strategy for reference classs, the empty
+        // inline field would be placed between the int and the Object
+        // fields, along with some padding.
+        Object o;
+        EmptyInline empty;
+    }
+
+    public static void main(String[] args) {
+        // Create an empty inline
+        EmptyInline empty = new EmptyInline();
+        Asserts.assertTrue(empty.isEmpty());
+
+        // Create an inline with an empty inline field
+        EmptyField emptyField = new EmptyField();
+        Asserts.assertEquals(emptyField.empty.getClass(), EmptyInline.class);
+        Asserts.assertTrue(emptyField.empty.isEmpty());
+        System.out.println(emptyField.empty.isEmpty());
+
+        // Regular instance with an empty field inside
+        WithEmptyField w = new WithEmptyField();
+        Asserts.assertEquals(w.empty.getClass(), EmptyInline.class);
+        Asserts.assertTrue(w.empty.isEmpty());
+        w.empty = new EmptyInline();
+        Asserts.assertEquals(w.empty.getClass(), EmptyInline.class);
+        Asserts.assertTrue(w.empty.isEmpty());
+
+        // Create an array of empty inlines
+        EmptyInline[] emptyArray = new EmptyInline[100];
+        for(EmptyInline element : emptyArray) {
+            Asserts.assertEquals(element.getClass(), EmptyInline.class);
+            Asserts.assertTrue(element.isEmpty());
+        }
+
+        // Testing arrayCopy
+        EmptyInline[] array2 = new EmptyInline[100];
+        // with two arrays
+        System.arraycopy(emptyArray, 10, array2, 20, 50);
+        for(EmptyInline element : array2) {
+            Asserts.assertEquals(element.getClass(), EmptyInline.class);
+            Asserts.assertTrue(element.isEmpty());
+        }
+        // single array, no overlap
+        System.arraycopy(emptyArray, 10, emptyArray, 50, 20);
+        for(EmptyInline element : emptyArray) {
+            Asserts.assertEquals(element.getClass(), EmptyInline.class);
+            Asserts.assertTrue(element.isEmpty());
+        }
+        // single array with overlap
+        System.arraycopy(emptyArray, 10, emptyArray, 20, 50);
+        for(EmptyInline element : emptyArray) {
+            Asserts.assertEquals(element.getClass(), EmptyInline.class);
+            Asserts.assertTrue(element.isEmpty());
+        }
+
+        // Passing an empty inline in argument
+        assert isEmpty(empty);
+
+        // Returning an empty inline
+        assert getEmpty().isEmpty();
+
+        // Checking fields with reflection
+        Class<?> c = empty.getClass();
+        try {
+            Field[] fields = c.getDeclaredFields();
+            Asserts.assertTrue(fields.length == 0);
+        } catch (Throwable t) {
+            t.printStackTrace();
+            throw t;
+        }
+        WithEmptyField w0 = new WithEmptyField();
+        Class<?> c2 = w0.getClass();
+        try {
+            Field emptyfield = c2.getDeclaredField("empty");
+            EmptyInline e = (EmptyInline)emptyfield.get(w0);
+            Asserts.assertEquals(e.getClass(), EmptyInline.class);
+            Asserts.assertTrue(e.isEmpty());
+            emptyfield.set(w0, new EmptyInline());
+            e = (EmptyInline)emptyfield.get(w0);
+            Asserts.assertEquals(e.getClass(), EmptyInline.class);
+            Asserts.assertTrue(e.isEmpty());
+        } catch(Throwable t) {
+            t.printStackTrace();
+            throw new RuntimeException("Reflection tests failed: " + t);
+        }
+
+        // Testing JIT compiler
+        // for(int i=0; i < 100000; i++) {
+        //     test();
+        // }
+    }
+
+    static boolean isEmpty(EmptyInline empty) {
+        return empty.isEmpty();
+    }
+
+    static EmptyInline getEmpty() {
+        return new EmptyInline();
+    }
+
+    static void test() {
+        for(int i=0; i < 10000; i++) {
+            Asserts.assertTrue(getEmpty().isEmpty());
+        }
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/FlattenableSemanticTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/FlattenableSemanticTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/FlattenableSemanticTest.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import java.lang.invoke.*;
+
+import jdk.experimental.value.MethodHandleBuilder;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test
+ * @summary Flattenable field semantic test
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java JumboInline.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator FlattenableSemanticTest.java
+ * @run main/othervm -Xint -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.inlinetypes.FlattenableSemanticTest
+ * @run main/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.FlattenableSemanticTest
+ * @run main/othervm -Xcomp -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.inlinetypes.FlattenableSemanticTest
+ * @run main/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.FlattenableSemanticTest
+ * // debug: -XX:+PrintInlineLayout -XX:-ShowMessageBoxOnError
+ */
+public class FlattenableSemanticTest {
+
+    static Point.ref nfsp;
+    static Point fsp;
+
+    Point.ref nfip;
+    Point fip;
+
+    static JumboInline.ref nfsj;
+    static JumboInline fsj;
+
+    JumboInline.ref nfij;
+    JumboInline fij;
+
+    static Object getNull() {
+        return null;
+    }
+
+    FlattenableSemanticTest() { }
+
+    public static void main(String[] args) {
+        FlattenableSemanticTest test = new FlattenableSemanticTest();
+
+        // Uninitialized inline fields must be null for non flattenable fields
+        Asserts.assertNull(nfsp, "Invalid non null value for unitialized non flattenable field");
+        Asserts.assertNull(nfsj, "Invalid non null value for unitialized non flattenable field");
+        Asserts.assertNull(test.nfip, "Invalid non null value for unitialized non flattenable field");
+        Asserts.assertNull(test.nfij, "Invalid non null value for unitialized non flattenable field");
+
+        // fsp.equals(null);
+
+        // Uninitialized inline fields must be non null for flattenable fields
+        Asserts.assertNotNull(fsp, "Invalid null value for unitialized flattenable field");
+        Asserts.assertNotNull(fsj, "Invalid null value for unitialized flattenable field");
+        Asserts.assertNotNull(test.fip, "Invalid null value for unitialized flattenable field");
+        Asserts.assertNotNull(test.fij, "Invalid null value for unitialized flattenable field");
+
+        // Assigning null must be allowed for non flattenable inline fields
+        boolean exception = true;
+        try {
+            nfsp = (Point.ref)getNull();
+            nfsp = null;
+            exception = false;
+        } catch (NullPointerException e) {
+            exception = true;
+        }
+        Asserts.assertFalse(exception, "Invalid NPE when assigning null to a non flattenable field");
+
+        try {
+            nfsj = (JumboInline.ref)getNull();
+            nfsj = null;
+            exception = false;
+        } catch (NullPointerException e) {
+            exception = true;
+        }
+        Asserts.assertFalse(exception, "Invalid NPE when assigning null to a non flattenable field");
+
+        try {
+            test.nfip = (Point.ref)getNull();
+            test.nfip = null;
+            exception = false;
+        } catch (NullPointerException e) {
+            exception = true;
+        }
+        Asserts.assertFalse(exception, "Invalid NPE when assigning null to a non flattenable field");
+
+        try {
+            test.nfij = (JumboInline.ref)getNull();
+            test.nfij = null;
+            exception = false;
+        } catch (NullPointerException e) {
+            exception = true;
+        }
+        Asserts.assertFalse(exception, "Invalid NPE when assigning null to a non flattenable field");
+
+        // Assigning null to a flattenable inline field must trigger a NPE
+        exception = false;
+        try {
+            fsp = (Point)getNull();
+        } catch(NullPointerException e) {
+            exception = true;
+        }
+        Asserts.assertTrue(exception, "NPE not thrown when assigning null to a flattenable field");
+        exception = false;
+        try {
+            fsj = (JumboInline)getNull();
+        } catch(NullPointerException e) {
+            exception = true;
+        }
+        Asserts.assertTrue(exception, "NPE not thrown when assigning null to a flattenable field");
+        exception = false;
+        try {
+            test.fip = (Point)getNull();
+        } catch(NullPointerException e) {
+            exception = true;
+        }
+        Asserts.assertTrue(exception, "NPE not thrown when assigning null to a flattenable field");
+        exception = false;
+        try {
+            test.fij = (JumboInline)getNull();
+        } catch(NullPointerException e) {
+            exception = true;
+        }
+        Asserts.assertTrue(exception, "NPE not thrown when assigning null to a flattenable field");
+        exception = false;
+    }
+
+}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/HiddenInlineClassTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/HiddenInlineClassTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/HiddenInlineClassTest.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/HiddenInlineClassTest.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/HiddenPoint.jcod b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/HiddenPoint.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/HiddenPoint.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/HiddenPoint.jcod
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Ifacmp.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Ifacmp.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Ifacmp.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import java.lang.ref.*;
+
+
+/*
+ * @test Ifacmp
+ * @requires vm.gc == null
+ * @summary if_acmpeq/ne bytecode test
+ * @compile Ifacmp.java
+ * @run main/othervm -Xint -Xms16m -Xmx16m -XX:+UseSerialGC
+ *                   runtime.valhalla.inlinetypes.Ifacmp
+ * @run main/othervm -Xcomp -Xms16m -Xmx16m -XX:+UseSerialGC
+ *                   runtime.valhalla.inlinetypes.Ifacmp
+ */
+public class Ifacmp {
+
+    static inline class MyValue {
+        int value;
+        public MyValue(int v) { this.value = v; }
+    };
+    static inline class MyValue2 {
+        int value;
+        public MyValue2(int v) { this.value = v; }
+    };
+
+    boolean acmpModeInlineAlwaysFalse = false;
+
+    Object aNull = null;
+    Object bNull = null;
+
+    Object aObject = new String("Hi");
+    Object bObject = new String("Hi");
+
+    Object aValue = new MyValue(1);
+    Object bValue = new MyValue(1);
+    Object cValue = new MyValue(0);
+    Object aValue2 = new MyValue2(4711);
+
+    Object[][] equalUseCases = {
+        { aNull, bNull },
+        { aObject, aObject },
+        { aValue, bValue },
+        { cValue, cValue },
+        { aValue2, aValue2 }
+    };
+
+    int objectEqualsUseCases = 2; // Nof object equals use cases
+
+    // Would just generate these fail case from the "equal set" above,
+    // but to do so needs ==, so write out by hand it is...
+    Object[][] notEqualUseCases = {
+        { aNull, aObject },
+        { aNull, bObject },
+        { aNull, aValue },
+        { aNull, bValue },
+        { aNull, cValue },
+        { aNull, aValue2 },
+        { aObject, bObject },
+        { aObject, aValue },
+        { aObject, bValue },
+        { aObject, cValue },
+        { aObject, aValue2 },
+        { bObject, cValue },
+        { bObject, aValue2 },
+        { aValue, cValue },
+        { aValue, aValue2 },
+    };
+
+    public Ifacmp() { this(false); }
+    public Ifacmp(boolean acmpModeInlineAlwaysFalse) {
+        this.acmpModeInlineAlwaysFalse = acmpModeInlineAlwaysFalse;
+        if (acmpModeInlineAlwaysFalse) {
+            System.out.println("ifacmp always false for inline types");
+        } else {
+            System.out.println("ifacmp substitutability inline types");
+        }
+    }
+
+    public void test() {
+        testAllUseCases();
+    }
+
+    public void testUntilGc(int nofGc) {
+        for (int i = 0; i < nofGc; i++) {
+            System.out.println("GC num " + (i + 1));
+            testUntilGc();
+        }
+    }
+
+    public void testUntilGc() {
+        Reference ref = new WeakReference<Object>(new Object(), new ReferenceQueue<>());
+        do {
+            test();
+        } while (ref.get() != null);
+    }
+
+    public void testAllUseCases() {
+        int useCase = 0;
+        for (Object[] pair : equalUseCases) {
+            useCase++;
+            boolean equal = acmpModeInlineAlwaysFalse ? (useCase <= objectEqualsUseCases) : true;
+            checkEqual(pair[0], pair[1], equal);
+        }
+        for (Object[] pair : notEqualUseCases) {
+            checkEqual(pair[0], pair[1], false);
+        }
+        testLocalValues();
+    }
+
+    public void testValues() {
+        checkEqual(aValue, bValue, true);
+
+        checkEqual(aValue, cValue, false);
+        checkEqual(aValue, aValue2, false);
+        checkEqual(aValue2, bValue, false);
+        checkEqual(aValue2, cValue, false);
+        testLocalValues();
+    }
+
+    public void testLocalValues() {
+        // "aload + ifacmp" should be same as "aaload + ifamcp"
+        // but let's be paranoid...
+        MyValue a = new MyValue(11);
+        MyValue b = new MyValue(11);
+        MyValue c = a;
+        MyValue a1 = new MyValue(7);
+        MyValue2 a2 = new MyValue2(13);
+
+        if (acmpModeInlineAlwaysFalse) {
+            if (a == b) throw new RuntimeException("Always false fail " + a + " == " + b);
+            if (a == c) throw new RuntimeException("Always false fail " + a + " == " + c);
+        } else {
+            if (a != b) throw new RuntimeException("Substitutability test failed" + a + " != " + b);
+            if (a != c) throw new RuntimeException("Substitutability test failed");
+        }
+        if (a == a1) throw new RuntimeException();
+        checkEqual(a, a2, false);
+    }
+
+    boolean shouldEqualSelf(Object a) {
+        return acmpModeInlineAlwaysFalse ? (!(a != null && a.getClass().isInlineClass())) : true;
+    }
+
+    void checkEqual(Object a, Object b, boolean isEqual) {
+        testEquals(a, a, shouldEqualSelf(a));
+        testEquals(b, b, shouldEqualSelf(b));
+        testEquals(a, b, isEqual);
+        testNotEquals(a, b, !isEqual);
+    }
+
+    public static void testEquals(Object a, Object b, boolean expected) {
+        boolean isEqual = (a == b);
+        if (isEqual != expected) {
+            throw new RuntimeException("Expected " + expected + " : "
+                                       + a + " == " + b);
+        }
+    }
+
+    public static void testNotEquals(Object a, Object b, boolean expected) {
+        boolean isNotEqual = (a != b);
+        if (isNotEqual != expected) {
+            throw new RuntimeException("Expected " + expected + " : "
+                                       + a + " != " + b);
+        }
+    }
+
+    public static void main(String[] args) {
+        boolean inlineTypesAlwaysFalse = (args.length > 0) && args[0].equals("alwaysFalse");
+        new Ifacmp(inlineTypesAlwaysFalse).test();
+        new Ifacmp(inlineTypesAlwaysFalse).testUntilGc(3);
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineOops.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineOops.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineOops.java
@@ -0,0 +1,762 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import java.lang.invoke.*;
+import java.lang.ref.*;
+import java.util.concurrent.*;
+
+import static jdk.test.lib.Asserts.*;
+import jdk.test.lib.Utils;
+import sun.hotspot.WhiteBox;
+
+import jdk.experimental.value.MethodHandleBuilder;
+
+/**
+ * @test InlineOops_int_Serial
+ * @requires vm.gc.Serial
+ * @summary Test embedding oops into Inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineOops.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ *                   sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run main/othervm -Xint -XX:+UseSerialGC -Xmx128m
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                   runtime.valhalla.inlinetypes.InlineOops
+ */
+
+/**
+ * @test InlineOops_int_G1
+ * @requires vm.gc.G1
+ * @summary Test embedding oops into Inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineOops.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ *                   sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run main/othervm -Xint  -XX:+UseG1GC -Xmx128m
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                   runtime.valhalla.inlinetypes.InlineOops 20
+ */
+
+/**
+ * @test InlineOops_int_Parallel
+ * @requires vm.gc.Parallel
+ * @summary Test embedding oops into Inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineOops.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ *                   sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run main/othervm -Xint -XX:+UseParallelGC -Xmx128m
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                   runtime.valhalla.inlinetypes.InlineOops
+ */
+
+/**
+ * @test InlineOops_int_Z
+ * @requires vm.gc.Z
+ * @summary Test embedding oops into Inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineOops.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ *                   sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run main/othervm -Xint -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx128m
+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                   runtime.valhalla.inlinetypes.InlineOops
+ */
+
+/**
+ * @test InlineOops_comp_serial
+ * @requires vm.gc.Serial
+ * @summary Test embedding oops into Inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineOops.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ *                   sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run main/othervm -Xcomp -XX:+UseSerialGC -Xmx128m
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                   runtime.valhalla.inlinetypes.InlineOops
+ */
+
+/**
+ * @test InlineOops_comp_G1
+ * @requires vm.gc.G1
+ * @summary Test embedding oops into Inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineOops.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ *                   sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run main/othervm -Xcomp -XX:+UseG1GC -Xmx128m
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                   runtime.valhalla.inlinetypes.InlineOops 20
+ */
+
+/**
+ * @test InlineOops_comp_Parallel
+ * @requires vm.gc.Parallel
+ * @summary Test embedding oops into Inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineOops.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ *                   sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run main/othervm -Xcomp -XX:+UseParallelGC -Xmx128m
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                   runtime.valhalla.inlinetypes.InlineOops
+ */
+
+/**
+ * @test InlineOops_comp_Z
+ * @requires vm.gc.Z
+ * @summary Test embedding oops into Inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineOops.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ *                   sun.hotspot.WhiteBox$WhiteBoxPermission
+ * @run main/othervm -Xcomp -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx128m
+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                   runtime.valhalla.inlinetypes.InlineOops
+ */
+public class InlineOops {
+
+    // Extra debug: -XX:+VerifyOops -XX:+VerifyStack -XX:+VerifyLastFrame -XX:+VerifyBeforeGC -XX:+VerifyAfterGC -XX:+VerifyDuringGC -XX:VerifySubSet=threads,heap
+    // Even more debugging: -XX:+TraceNewOopMapGeneration -Xlog:gc*=info
+
+    static final int NOF_PEOPLE = 10000; // Exercise arrays of this size
+
+    static int MIN_ACTIVE_GC_COUNT = 10; // Run active workload for this number of GC passes
+
+    static int MED_ACTIVE_GC_COUNT = 4;  // Medium life span in terms of GC passes
+
+    static final String TEST_STRING1 = "Test String 1";
+    static final String TEST_STRING2 = "Test String 2";
+
+    static boolean USE_COMPILER = WhiteBox.getWhiteBox().getBooleanVMFlag("UseCompiler");
+
+    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+
+    public static void main(String[] args) {
+        if (args.length > 0) {
+            MIN_ACTIVE_GC_COUNT = Integer.parseInt(args[0]);
+        }
+        testClassLoad();
+        testValues();
+
+        if (!USE_COMPILER) {
+            testOopMaps();
+        }
+
+        // Check we survive GC...
+        testOverGc();   // Exercise root scan / oopMap
+        testActiveGc(); // Brute force
+    }
+
+    /**
+     * Test ClassFileParser can load inline types with reference fields
+     */
+    public static void testClassLoad() {
+        String s = Person.class.toString();
+        new Bar();
+        new BarWithValue();
+        s = BarValue.class.toString();
+        s = ObjectWithObjectValue.class.toString();
+        s = ObjectWithObjectValues.class.toString();
+    }
+
+
+    static class Couple {
+        public Person onePerson;
+        public Person otherPerson;
+    }
+
+    static final inline class Composition {
+        public final Person onePerson;
+        public final Person otherPerson;
+
+        private Composition() {
+            onePerson   = Person.create(0, null, null);
+            otherPerson = Person.create(0, null, null);
+        }
+
+        public static Composition create(Person onePerson, Person otherPerson) {
+            Composition comp = Composition.default;
+            comp = __WithField(comp.onePerson, onePerson);
+            comp = __WithField(comp.otherPerson, otherPerson);
+            return comp;
+        }
+    }
+
+    /**
+     * Check inline type operations with "Valhalla Inline Types" (VVT)
+     */
+    public static void testValues() {
+        // Exercise creation, getfield, vreturn with null refs
+        validateDefaultPerson(createDefaultPerson());
+
+        // anewarray, aaload, aastore
+        int index = 7;
+        Person[] array =  new Person[NOF_PEOPLE];
+        validateDefaultPerson(array[index]);
+
+        // Now with refs...
+        validateIndexedPerson(createIndexedPerson(index), index);
+        array[index] = createIndexedPerson(index);
+        validateIndexedPerson(array[index], index);
+
+        // Check the neighbours
+        validateDefaultPerson(array[index - 1]);
+        validateDefaultPerson(array[index + 1]);
+
+        // getfield/putfield
+        Couple couple = new Couple();
+        validateDefaultPerson(couple.onePerson);
+        validateDefaultPerson(couple.otherPerson);
+
+        couple.onePerson = createIndexedPerson(index);
+        validateIndexedPerson(couple.onePerson, index);
+
+        Composition composition = Composition.create(couple.onePerson, couple.onePerson);
+        validateIndexedPerson(composition.onePerson, index);
+        validateIndexedPerson(composition.otherPerson, index);
+    }
+
+    /**
+     * Check oop map generation for klass layout and frame...
+     */
+    public static void testOopMaps() {
+        Object[] objects = WhiteBox.getWhiteBox().getObjectsViaKlassOopMaps(new Couple());
+        assertTrue(objects.length == 4, "Expected 4 oops");
+        for (int i = 0; i < objects.length; i++) {
+            assertTrue(objects[i] == null, "not-null");
+        }
+
+        String fn1 = "Sam";
+        String ln1 = "Smith";
+        String fn2 = "Jane";
+        String ln2 = "Jones";
+        Couple couple = new Couple();
+        couple.onePerson = Person.create(0, fn1, ln1);
+        couple.otherPerson = Person.create(1, fn2, ln2);
+        objects = WhiteBox.getWhiteBox().getObjectsViaKlassOopMaps(couple);
+        assertTrue(objects.length == 4, "Expected 4 oops");
+        assertTrue(objects[0] == fn1, "Bad oop fn1");
+        assertTrue(objects[1] == ln1, "Bad oop ln1");
+        assertTrue(objects[2] == fn2, "Bad oop fn2");
+        assertTrue(objects[3] == ln2, "Bad oop ln2");
+
+        objects = WhiteBox.getWhiteBox().getObjectsViaOopIterator(couple);
+        assertTrue(objects.length == 4, "Expected 4 oops");
+        assertTrue(objects[0] == fn1, "Bad oop fn1");
+        assertTrue(objects[1] == ln1, "Bad oop ln1");
+        assertTrue(objects[2] == fn2, "Bad oop fn2");
+        assertTrue(objects[3] == ln2, "Bad oop ln2");
+
+        // Array..
+        objects = WhiteBox.getWhiteBox().getObjectsViaOopIterator(createPeople());
+        assertTrue(objects.length == NOF_PEOPLE * 2, "Unexpected length: " + objects.length);
+        int o = 0;
+        for (int i = 0; i < NOF_PEOPLE; i++) {
+            assertTrue(objects[o++].equals(firstName(i)), "Bad firstName");
+            assertTrue(objects[o++].equals(lastName(i)), "Bad lastName");
+        }
+
+        // Sanity check, FixMe need more test cases
+        objects = testFrameOops(couple);
+        //assertTrue(objects.length == 5, "Number of frame oops incorrect = " + objects.length);
+        //assertTrue(objects[0] == couple, "Bad oop 0");
+        //assertTrue(objects[1] == fn1, "Bad oop 1");
+        //assertTrue(objects[2] == ln1, "Bad oop 2");
+        //assertTrue(objects[3] == TEST_STRING1, "Bad oop 3");
+        //assertTrue(objects[4] == TEST_STRING2, "Bad oop 4");
+
+        //testFrameOopsVBytecodes();
+    }
+
+    static final String GET_OOP_MAP_NAME = "getOopMap";
+    static final String GET_OOP_MAP_DESC = "()[Ljava/lang/Object;";
+
+    public static Object[] getOopMap() {
+        Object[] oopMap = WhiteBox.getWhiteBox().getObjectsViaFrameOopIterator(2);
+        /* Remove this frame (class mirror for this method), and above class mirror */
+        Object[] trimmedOopMap = new Object[oopMap.length - 2];
+        System.arraycopy(oopMap, 2, trimmedOopMap, 0, trimmedOopMap.length);
+        return trimmedOopMap;
+    }
+
+    // Expecting Couple couple, Person couple.onePerson, and Person (created here)
+    public static Object[] testFrameOops(Couple couple) {
+        int someId = 89898;
+        Person person = couple.onePerson;
+        assertTrue(person.getId() == 0, "Bad Person");
+        Person anotherPerson = Person.create(someId, TEST_STRING1, TEST_STRING2);
+        assertTrue(anotherPerson.getId() == someId, "Bad Person");
+        return getOopMap();
+    }
+
+    // Debug...
+    static void dumpOopMap(Object[] oopMap) {
+        System.out.println("Oop Map len: " + oopMap.length);
+        for (int i = 0; i < oopMap.length; i++) {
+            System.out.println("[" + i + "] = " + oopMap[i]);
+        }
+    }
+
+    /**
+     * Just some check sanity checks with defaultvalue, withfield, astore and aload
+     *
+     * Changes to javac slot usage may well break this test
+     */
+    public static void testFrameOopsVBytecodes() {
+        int nofOopMaps = 4;
+        Object[][] oopMaps = new Object[nofOopMaps][];
+        String[] inputArgs = new String[] { "aName", "aDescription", "someNotes" };
+
+        FooValue.testFrameOopsDefault(oopMaps);
+
+        // Test-D0 Slots=R Stack=Q(RRR)RV
+        assertTrue(oopMaps[0].length == 5 &&
+                oopMaps[0][1] == null &&
+                oopMaps[0][2] == null &&
+                oopMaps[0][3] == null, "Test-D0 incorrect");
+
+        // Test-D1 Slots=R Stack=RV
+        assertTrue(oopMaps[1].length == 2, "Test-D1 incorrect");
+
+        // Test-D2 Slots=RQ(RRR) Stack=RV
+        assertTrue(oopMaps[2].length == 5 &&
+                oopMaps[2][1] == null &&
+                oopMaps[2][2] == null &&
+                oopMaps[2][3] == null, "Test-D2 incorrect");
+
+        // Test-D3 Slots=R Stack=Q(RRR)RV
+        assertTrue(oopMaps[3].length == 6 &&
+                oopMaps[3][1] == null &&
+                oopMaps[3][2] == null &&
+                oopMaps[3][3] == null &&
+                oopMaps[3][4] == null, "Test-D3 incorrect");
+
+        // With ref fields...
+        String name = "TestName";
+        String desc = "TestDesc";
+        String note = "TestNotes";
+        FooValue.testFrameOopsRefs(name, desc, note, oopMaps);
+
+        // Test-R0 Slots=RR Stack=Q(RRR)RV
+        assertTrue(oopMaps[0].length == 6 &&
+                oopMaps[0][2] == name &&
+                oopMaps[0][3] == desc &&
+                oopMaps[0][4] == note, "Test-R0 incorrect");
+
+        /**
+         * TODO: vwithfield from method handle cooked from anonymous class within the inline class
+         *       even with "MethodHandles.privateLookupIn()" will fail final putfield rules
+         */
+    }
+
+    /**
+     * Check forcing GC for combination of VT on stack/LVT etc works
+     */
+    public static void testOverGc() {
+        try {
+            Class<?> vtClass = Person.class;
+
+            System.out.println("vtClass="+vtClass);
+
+            doGc();
+
+            // VT on stack and lvt, null refs, see if GC flies
+            MethodHandle moveValueThroughStackAndLvt = MethodHandleBuilder.loadCode(
+                    LOOKUP,
+                    "gcOverPerson",
+                    MethodType.methodType(vtClass, vtClass),
+                    CODE->{
+                        CODE
+                        .aload(0)
+                        .invokestatic(InlineOops.class, "doGc", "()V", false) // Stack
+                        .astore(0)
+                        .invokestatic(InlineOops.class, "doGc", "()V", false) // LVT
+                        .aload(0)
+                        .astore(1024) // LVT wide index
+                        .aload(1024)
+                        .iconst_1()  // push a litte further down
+                        .invokestatic(InlineOops.class, "doGc", "()V", false) // Stack,LVT
+                        .pop()
+                        .areturn();
+                    });
+            Person person = (Person) moveValueThroughStackAndLvt.invokeExact(createDefaultPerson());
+            validateDefaultPerson(person);
+            doGc();
+
+            int index = 4711;
+            person = (Person) moveValueThroughStackAndLvt.invokeExact(createIndexedPerson(index));
+            validateIndexedPerson(person, index);
+            doGc();
+            person = createDefaultPerson();
+            doGc();
+        }
+        catch (Throwable t) { fail("testOverGc", t); }
+    }
+
+    static void submitNewWork(ForkJoinPool fjPool, int size) {
+        for (int i = 0; i < size; i++) {
+            for (int j = 0; j < 100; j++) {
+                fjPool.execute(InlineOops::testValues);
+            }
+        }
+    }
+
+    static void sleepNoThrow(long ms) {
+        try {
+            Thread.sleep(ms);
+        }
+        catch (Throwable t) {}
+    }
+
+    /**
+     * Run some workloads with different object/value life times...
+     */
+    public static void testActiveGc() {
+        try {
+            int nofThreads = 7;
+            int workSize = nofThreads * 10;
+
+            Object longLivedObjects = createLongLived();
+            Object longLivedPeople = createPeople();
+
+            Object medLivedObjects = createLongLived();
+            Object medLivedPeople = createPeople();
+
+            doGc();
+
+            ForkJoinPool fjPool = new ForkJoinPool(nofThreads, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);
+
+            // submit work until we see some GC
+            Reference ref = createRef();
+            submitNewWork(fjPool, workSize);
+            while (ref.get() != null) {
+                if (fjPool.hasQueuedSubmissions()) {
+                    sleepNoThrow(1L);
+                }
+                else {
+                    workSize *= 2; // Grow the submission size
+                    submitNewWork(fjPool, workSize);
+                }
+            }
+
+            // Keep working and actively GC, until MIN_ACTIVE_GC_COUNT
+            int nofActiveGc = 1;
+            ref = createRef();
+            while (nofActiveGc < MIN_ACTIVE_GC_COUNT) {
+                if (ref.get() == null) {
+                    nofActiveGc++;
+                    ref = createRef();
+                    if (nofActiveGc % MED_ACTIVE_GC_COUNT == 0) {
+                        validateLongLived(medLivedObjects);
+                        validatePeople(medLivedPeople);
+
+                        medLivedObjects = createLongLived();
+                        medLivedPeople = createPeople();
+                    }
+                }
+                else if (fjPool.hasQueuedSubmissions()) {
+                    sleepNoThrow((long) Utils.getRandomInstance().nextInt(1000));
+                    doGc();
+                }
+                else {
+                    submitNewWork(fjPool, workSize);
+                }
+            }
+            fjPool.shutdown();
+
+            validateLongLived(medLivedObjects);
+            validatePeople(medLivedPeople);
+            medLivedObjects = null;
+            medLivedPeople = null;
+
+            validateLongLived(longLivedObjects);
+            validatePeople(longLivedPeople);
+
+            longLivedObjects = null;
+            longLivedPeople = null;
+
+            doGc();
+        }
+        catch (Throwable t) { fail("testActiveGc", t); }
+    }
+
+    static final ReferenceQueue<Object> REFQ = new ReferenceQueue<>();
+
+    public static void doGc() {
+        // Create Reference, wait until it clears...
+        Reference ref = createRef();
+        while (ref.get() != null) {
+            System.gc();
+        }
+    }
+
+    static Reference createRef() {
+        return new WeakReference<Object>(new Object(), REFQ);
+    }
+
+    static void validatePerson(Person person, int id, String fn, String ln, boolean equals) {
+        assertTrue(person.id == id);
+        if (equals) {
+            assertTrue(fn.equals(person.getFirstName()), "Invalid field firstName");
+            assertTrue(ln.equals(person.getLastName()), "Invalid  field lastName");
+        }
+        else {
+            assertTrue(person.getFirstName() == fn, "Invalid field firstName");
+            assertTrue(person.getLastName() == ln, "Invalid  field lastName");
+        }
+    }
+
+    static Person createIndexedPerson(int i) {
+        return Person.create(i, firstName(i), lastName(i));
+    }
+
+    static void validateIndexedPerson(Person person, int i) {
+        validatePerson(person, i, firstName(i), lastName(i), true);
+    }
+
+    static Person createDefaultPerson() {
+        return Person.create(0, null, null);
+    }
+
+    static void validateDefaultPerson(Person person) {
+        validatePerson(person, 0, null, null, false);
+    }
+
+    static String firstName(int i) {
+        return "FirstName-" + i;
+    }
+
+    static String lastName(int i) {
+        return "LastName-" + i;
+    }
+
+    static Object createLongLived()  throws Throwable {
+        Object[] population = new Object[1];
+        population[0] = createPeople();
+        return population;
+    }
+
+    static void validateLongLived(Object pop) throws Throwable {
+        Object[] population = (Object[]) pop;
+        validatePeople(population[0]);
+    }
+
+    static Object createPeople() {
+        int arrayLength = NOF_PEOPLE;
+        Person[] people = new Person[arrayLength];
+        for (int i = 0; i < arrayLength; i++) {
+            people[i] = createIndexedPerson(i);
+        }
+        return people;
+    }
+
+    static void validatePeople(Object array) {
+        Person[] people = (Person[]) array;
+        int arrayLength = people.length;
+        assertTrue(arrayLength == NOF_PEOPLE);
+        for (int i = 0; i < arrayLength; i++) {
+            validateIndexedPerson(people[i], i);
+        }
+    }
+
+    // Various field layouts...sanity testing, see MVTCombo testing for full-set
+
+    static final inline class ObjectValue {
+        final Object object;
+
+        private ObjectValue(Object obj) {
+            object = obj;
+        }
+    }
+
+    static class ObjectWithObjectValue {
+        ObjectValue value1;
+        Object      ref1;
+    }
+
+    static class ObjectWithObjectValues {
+        ObjectValue value1;
+        ObjectValue value2;
+        Object      ref1;
+    }
+
+    static class Foo {
+        int id;
+        String name;
+        String description;
+        long timestamp;
+        String notes;
+    }
+
+    static class Bar extends Foo {
+        long extendedId;
+        String moreNotes;
+        int count;
+        String otherStuff;
+    }
+
+    public static final inline class FooValue {
+        public final int id;
+        public final String name;
+        public final String description;
+        public final long timestamp;
+        public final String notes;
+
+        private FooValue() {
+            id          = 0;
+            name        = null;
+            description = null;
+            timestamp   = 0L;
+            notes       = null;
+        }
+
+        public static FooValue create(int id, String name, String description, long timestamp, String notes) {
+            FooValue f = FooValue.default;
+            f = __WithField(f.id, id);
+            f = __WithField(f.name, name);
+            f = __WithField(f.description, description);
+            f = __WithField(f.timestamp, timestamp);
+            f = __WithField(f.notes, notes);
+            return f;
+        }
+
+        public static void testFrameOopsDefault(Object[][] oopMaps) {
+            MethodType mt = MethodType.methodType(Void.TYPE, oopMaps.getClass());
+            int oopMapsSlot   = 0;
+            int vtSlot        = 1;
+
+            // Slots 1=oopMaps
+            // OopMap Q=RRR (.name .description .someNotes)
+            try {
+                MethodHandleBuilder.loadCode(
+                        LOOKUP, "exerciseVBytecodeExprStackWithDefault", mt,
+                        CODE->{
+                            CODE
+                            .defaultvalue(FooValue.class)
+                            .aload(oopMapsSlot)
+                            .iconst_0()  // Test-D0 Slots=R Stack=Q(RRR)RV
+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
+                            .aastore()
+                            .pop()
+                            .aload(oopMapsSlot)
+                            .iconst_1()  // Test-D1 Slots=R Stack=RV
+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
+                            .aastore()
+                            .defaultvalue(FooValue.class)
+                            .astore(vtSlot)
+                            .aload(oopMapsSlot)
+                            .iconst_2()  // Test-D2 Slots=RQ(RRR) Stack=RV
+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
+                            .aastore()
+                            .aload(vtSlot)
+                            .aconst_null()
+                            .astore(vtSlot) // Storing null over the Q slot won't remove the ref, but should be single null ref
+                            .aload(oopMapsSlot)
+                            .iconst_3()  // Test-D3 Slots=R Stack=Q(RRR)RV
+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
+                            .aastore()
+                            .pop()
+                            .return_();
+                        }).invoke(oopMaps);
+            } catch (Throwable t) { fail("exerciseVBytecodeExprStackWithDefault", t); }
+        }
+
+        public static void testFrameOopsRefs(String name, String description, String notes, Object[][] oopMaps) {
+            FooValue f = create(4711, name, description, 9876543231L, notes);
+            FooValue[] fa = new FooValue[] { f };
+            MethodType mt = MethodType.methodType(Void.TYPE, fa.getClass(), oopMaps.getClass());
+            int fooArraySlot  = 0;
+            int oopMapsSlot   = 1;
+            try {
+                MethodHandleBuilder.loadCode(LOOKUP, "exerciseVBytecodeExprStackWithRefs", mt,
+                        CODE->{
+                            CODE
+                            .aload(fooArraySlot)
+                            .iconst_0()
+                            .aaload()
+                            .aload(oopMapsSlot)
+                            .iconst_0()  // Test-R0 Slots=RR Stack=Q(RRR)RV
+                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
+                            .aastore()
+                            .pop()
+                            .return_();
+                        }).invoke(fa, oopMaps);
+            } catch (Throwable t) { fail("exerciseVBytecodeExprStackWithRefs", t); }
+        }
+    }
+
+    static class BarWithValue {
+        FooValue foo;
+        long extendedId;
+        String moreNotes;
+        int count;
+        String otherStuff;
+    }
+
+    static final inline class BarValue {
+        final FooValue foo;
+        final long extendedId;
+        final String moreNotes;
+        final int count;
+        final String otherStuff;
+
+        private BarValue(FooValue f, long extId, String mNotes, int c, String other) {
+            foo = f;
+            extendedId = extId;
+            moreNotes = mNotes;
+            count = c;
+            otherStuff = other;
+        }
+    }
+
+}
+
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeArray.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeArray.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeArray.java
@@ -0,0 +1,550 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import java.lang.reflect.Array;
+import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
+
+import static jdk.test.lib.Asserts.*;
+
+/*
+ * @test InlineTypeArray
+ * @summary Plain array test for Inline Types
+ * @library /test/lib
+ * @compile InlineTypeArray.java Point.java Long8Inline.java Person.java
+ * @run main/othervm -Xint  -XX:FlatArrayElementMaxSize=-1 runtime.valhalla.inlinetypes.InlineTypeArray
+ * @run main/othervm -Xint  -XX:FlatArrayElementMaxSize=0  runtime.valhalla.inlinetypes.InlineTypeArray
+ * @run main/othervm -Xcomp -XX:FlatArrayElementMaxSize=-1 runtime.valhalla.inlinetypes.InlineTypeArray
+ * @run main/othervm -Xcomp -XX:FlatArrayElementMaxSize=0  runtime.valhalla.inlinetypes.InlineTypeArray
+ * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.InlineTypeArray
+ */
+public class InlineTypeArray {
+    public static void main(String[] args) {
+        InlineTypeArray inlineTypeArray = new InlineTypeArray();
+        inlineTypeArray.run();
+    }
+
+    public void run() {
+        testClassForName();
+        testSimplePointArray();
+        testLong8Array();
+        testMixedPersonArray();
+        testMultiDimPointArray();
+        testComposition();
+
+        testSanityCheckcasts();
+        testObjectArrayOfInlines();
+
+        testReflectArray();
+        testUtilArrays();
+
+        testInlineArrayOom();
+    }
+
+    void testClassForName() {
+        String arrayClsName = "[Lruntime.valhalla.inlinetypes.Point$ref;";
+        String qarrayClsName = "[Qruntime.valhalla.inlinetypes.Point;";
+        try {
+            // L-type..
+            Class<?> arrayCls = Class.forName(arrayClsName);
+            assertTrue(arrayCls.isArray(), "Expected an array class");
+
+            arrayClsName = "[" + arrayClsName;
+            Class<?> mulArrayCls = Class.forName(arrayClsName);
+            assertTrue(mulArrayCls.isArray());
+            assertTrue(mulArrayCls.getComponentType() == arrayCls);
+
+            // Q-type...
+            arrayCls = Class.forName(qarrayClsName);
+            assertTrue(arrayCls.isArray(), "Expected an array class");
+
+            assertTrue(arrayCls.getComponentType() == Point.class,
+                       arrayCls +
+                       " Expected component type of Point.class got: " + arrayCls.getComponentType());
+
+            qarrayClsName = "[" + qarrayClsName;
+            mulArrayCls = Class.forName(qarrayClsName);
+            assertTrue(mulArrayCls.isArray());
+            assertTrue(mulArrayCls.getComponentType() == arrayCls);
+        }
+        catch (ClassNotFoundException cnfe) {
+            fail("Class.forName(" + arrayClsName + ") failed", cnfe);
+        }
+    }
+
+    void testSimplePointArray() {
+        Point[] defaultPoint = new Point[1];
+        Point p = defaultPoint[0];
+        assertEquals(p.x, 0, "invalid default loaded from array");
+        assertEquals(p.y, 0, "invalid default loaded from array");
+        boolean gotNpe = false;
+        try {
+            defaultPoint[0] = (Point) getNull();
+        } catch (NullPointerException npe) {
+            gotNpe = true;
+        }
+        assertTrue(gotNpe, "Expected NullPointerException");
+
+        Point[] points = createSimplePointArray();
+        System.gc(); // check that VTs survive GC
+        checkSimplePointArray(points);
+
+        assertTrue(points instanceof Point[], "Instance of");
+
+        testSimplePointArrayCopy();
+    }
+
+    void testSimplePointArrayCopy() {
+        Point[] points = createSimplePointArray();
+        Point[] pointsCopy = new Point[points.length];
+        System.arraycopy(points, 0, pointsCopy, 0, points.length);
+        checkSimplePointArray(pointsCopy);
+
+        // Conjoint, overlap...left
+        System.arraycopy(points, 0, points, 1, 2);
+        checkArrayElementsEqual(points, new Point[] { pointsCopy[0], pointsCopy[0], pointsCopy[1], pointsCopy[3] });
+
+        // Conjoint, overlap...right
+        points = createSimplePointArray();
+        System.arraycopy(points, 2, points, 1, 2);
+        checkArrayElementsEqual(points, new Point[] { pointsCopy[0], pointsCopy[2], pointsCopy[3], pointsCopy[3] });
+    }
+
+    static Point[] createSimplePointArray() {
+        Point[] ps = new Point[4];
+        assertEquals(ps.length, 4, "Length");
+        ps.toString();
+        ps[0] = Point.createPoint(1, 2);
+        ps[1] = Point.createPoint(3, 4);
+        ps[2] = Point.createPoint(5, 6);
+        ps[3] = Point.createPoint(7, 8);
+        boolean sawOob = false;
+        try {
+            ps[ps.length] = Point.createPoint(0, 0);
+        } catch (ArrayIndexOutOfBoundsException aioobe) { sawOob = true; }
+        assertTrue(sawOob, "Didn't see AIOOBE");
+        return ps;
+    }
+
+    static void checkSimplePointArray(Point[] points) {
+        assertEquals(points[0].x, 1, "invalid 0 point x value");
+        assertEquals(points[0].y, 2, "invalid 0 point y value");
+        assertEquals(points[1].x, 3, "invalid 1 point x value");
+        assertEquals(points[1].y, 4, "invalid 1 point y value");
+        assertEquals(points[2].x, 5, "invalid 2 point x value");
+        assertEquals(points[2].y, 6, "invalid 2 point y value");
+        assertEquals(points[3].x, 7, "invalid 3 point x value");
+        assertEquals(points[3].y, 8, "invalid 3 point y value");
+    }
+
+    void testLong8Array() {
+        Long8Inline[] values = new Long8Inline[3];
+        assertEquals(values.length, 3, "length");
+        values.toString();
+        Long8Inline value = values[1];
+        long zl = 0;
+        Long8Inline.check(value, zl, zl, zl, zl, zl, zl, zl, zl);
+        values[1] = Long8Inline.create(1, 2, 3, 4, 5, 6, 7, 8);
+        value = values[1];
+        Long8Inline.check(value, 1, 2, 3, 4, 5, 6, 7, 8);
+
+        Long8Inline[] copy = new Long8Inline[values.length];
+        System.arraycopy(values, 0, copy, 0, values.length);
+        value = copy[1];
+        Long8Inline.check(value, 1, 2, 3, 4, 5, 6, 7, 8);
+    }
+
+    void testMixedPersonArray() {
+        Person[] people = new Person[3];
+
+        people[0] = Person.create(1, "First", "Last");
+        assertEquals(people[0].getId(), 1, "Invalid Id person");
+        assertEquals(people[0].getFirstName(), "First", "Invalid First Name");
+        assertEquals(people[0].getLastName(), "Last", "Invalid Last Name");
+
+        people[1] = Person.create(2, "Jane", "Wayne");
+        people[2] = Person.create(3, "Bob", "Dobalina");
+
+        Person[] peopleCopy = new Person[people.length];
+        System.arraycopy(people, 0, peopleCopy, 0, people.length);
+        assertEquals(peopleCopy[2].getId(), 3, "Invalid Id");
+        assertEquals(peopleCopy[2].getFirstName(), "Bob", "Invalid First Name");
+        assertEquals(peopleCopy[2].getLastName(), "Dobalina", "Invalid Last Name");
+    }
+
+    void testMultiDimPointArray() {
+        Point[][][] multiPoints = new Point[2][3][4];
+        assertEquals(multiPoints.length, 2, "1st dim length");
+        assertEquals(multiPoints[0].length, 3, "2st dim length");
+        assertEquals(multiPoints[0][0].length, 4, "3rd dim length");
+
+        Point defaultPoint = multiPoints[1][2][3];
+        assertEquals(defaultPoint.x, 0, "invalid point x value");
+        assertEquals(defaultPoint.y, 0, "invalid point x value");
+    }
+
+    void testReflectArray() {
+        // Check the java.lang.reflect.Array.newInstance methods...
+        Class<?> cls = (Class<?>) Point[].class;
+        Point[][] array = (Point[][]) Array.newInstance(cls, 1);
+        assertEquals(array.length, 1, "Incorrect length");
+        assertTrue(array[0] == null, "Expected NULL");
+
+        Point[][][] array3 = (Point[][][]) Array.newInstance(cls, 1, 2);
+        assertEquals(array3.length, 1, "Incorrect length");
+        assertEquals(array3[0].length, 2, "Incorrect length");
+        assertTrue(array3[0][0] == null, "Expected NULL");
+
+        // Now create ObjArrays of InlineArray...
+        Point.ref[][] barray = (Point.ref[][]) Array.newInstance(Point.ref.class, 1, 2);
+        assertEquals(barray.length, 1, "Incorrect length");
+        assertEquals(barray[0].length, 2, "Incorrect length");
+        barray[0][1] = Point.createPoint(1, 2);
+        Point.ref pb = barray[0][1];
+        int x = pb.getX();
+        assertEquals(x, 1, "Bad Point Value");
+    }
+
+    static final inline class MyInt implements Comparable<MyInt.ref> {
+        final int value;
+
+        private MyInt() { this(0); }
+        private MyInt(int v) { value = v; }
+        public int getValue() { return value; }
+        public String toString() { return "MyInt: " + getValue(); }
+        public int compareTo(MyInt.ref that) { return Integer.compare(this.getValue(), that.getValue()); }
+        public boolean equals(Object o) {
+            if (o instanceof MyInt) {
+                return this.getValue() == ((MyInt) o).getValue();
+            }
+            return false;
+        }
+
+        public static MyInt create(int v) {
+            return new MyInt(v);
+        }
+
+        // Null-able fields here are a temp hack to avoid ClassCircularityError
+        public static final MyInt.ref MIN = MyInt.create(Integer.MIN_VALUE);
+        public static final MyInt.ref ZERO = MyInt.create(0);
+        public static final MyInt.ref MAX = MyInt.create(Integer.MAX_VALUE);
+    }
+
+    static MyInt staticMyInt = MyInt.create(-1);
+    static MyInt[] staticMyIntArray = new MyInt[] { staticMyInt };
+    static MyInt[][] staticMyIntArrayArray = new MyInt[][] { staticMyIntArray, staticMyIntArray };
+
+    static interface SomeSecondaryType {
+        default String hi() { return "Hi"; }
+    }
+
+    static final inline class MyOtherInt implements SomeSecondaryType {
+        final int value;
+        private MyOtherInt() { value = 0; }
+    }
+
+    void testSanityCheckcasts() {
+        MyInt[] myInts = new MyInt[1];
+        assertTrue(myInts instanceof Object[]);
+        assertTrue(myInts instanceof Comparable[]);
+        assertTrue(myInts instanceof MyInt.ref[]);
+
+        Class<?> cls = MyInt.class;
+        assertTrue(cls.isInlineClass());
+        Object arrObj = Array.newInstance(cls, 1);
+        assertTrue(arrObj instanceof Object[], "Not Object array");
+        assertTrue(arrObj instanceof Comparable[], "Not Comparable array");
+        assertTrue(arrObj instanceof MyInt[], "Not MyInt array");
+
+        Object[] arr = (Object[]) arrObj;
+        assertTrue(arr instanceof Comparable[], "Not Comparable array");
+        assertTrue(arr instanceof MyInt[], "Not MyInt array");
+        Comparable[] comparables = (Comparable[])arr;
+        MyInt[] myIntArr = (MyInt[]) arr;
+
+        // multi-dim, check secondary array types are setup...
+        MyOtherInt[][] matrix = new MyOtherInt[1][1];
+        assertTrue(matrix[0] instanceof MyOtherInt[]);
+        assertTrue(matrix[0] instanceof SomeSecondaryType[]);
+        assertTrue(matrix[0] instanceof MyOtherInt.ref[]);
+
+        // Box types vs Inline...
+        MyInt.ref[] myValueRefs = new MyInt.ref[1];
+        assertTrue(myValueRefs instanceof MyInt.ref[]);
+        assertTrue(myValueRefs instanceof Object[]);
+        assertTrue(myValueRefs instanceof Comparable[]);
+        assertFalse(myValueRefs instanceof MyInt[]);
+
+        MyInt.ref[][] myMdValueRefs = new MyInt.ref[1][1];
+        assertTrue(myMdValueRefs[0] instanceof MyInt.ref[]);
+        assertTrue(myMdValueRefs[0] instanceof Object[]);
+        assertTrue(myMdValueRefs[0] instanceof Comparable[]);
+        assertFalse(myMdValueRefs[0] instanceof MyInt[]);
+
+        // Did we break checkcast...
+        MyInt.ref[]     va1 = (MyInt.ref[])null;
+        MyInt.ref[]     va2 = null;
+        MyInt.ref[][]   va3 = (MyInt.ref[][])null;
+        MyInt.ref[][][] va4 = (MyInt.ref[][][])null;
+        MyInt[]      va5 = null;
+        MyInt[]      va6 = (MyInt[])null;
+        MyInt[][]    va7 = (MyInt[][])null;
+        MyInt[][][]  va8 = (MyInt[][][])null;
+    }
+
+
+    void testUtilArrays() {
+        // Sanity check j.u.Arrays
+
+        // cast to q-type temp effect of avoiding circularity error (decl static MyInt.ref)
+        MyInt[] myInts = new MyInt[] { (MyInt) MyInt.MAX, (MyInt) MyInt.MIN };
+        // Sanity sort another copy
+        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);
+        checkArrayElementsEqual(copyMyInts, new MyInt[] { myInts[0], myInts[1], (MyInt) MyInt.ZERO});
+
+        Arrays.sort(copyMyInts);
+        checkArrayElementsEqual(copyMyInts, new MyInt[] { (MyInt) MyInt.MIN, (MyInt) MyInt.ZERO, (MyInt) MyInt.MAX });
+
+        List myIntList = Arrays.asList(copyMyInts);
+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(new MyInt[copyMyInts.length]));
+        // This next line needs testMixedLayoutArrays to work
+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());
+
+        // Sanity check j.u.ArrayList
+        ArrayList<MyInt.ref> aList = new ArrayList<MyInt.ref>(Arrays.asList(copyMyInts));
+        assertTrue(aList.indexOf(MyInt.MIN) == 0, "Bad Index");
+        assertTrue(aList.indexOf(MyInt.ZERO) == 1, "Bad Index");
+        assertTrue(aList.indexOf(MyInt.MAX) == 2, "Bad Index");
+
+        aList.remove(2);
+        aList.add(MyInt.create(5));
+    }
+
+
+    void testObjectArrayOfInlines() {
+        testSanityObjectArrays();
+        testMixedLayoutArrays();
+    }
+
+    void testSanityObjectArrays() {
+        Object[] objects = new Object[2];
+        assertTrue(objects[0] == null && objects[1] == null, "Not null ?");
+
+        objects[0] = MyInt.create(1);
+        objects[1] = Integer.valueOf(2);
+        assertTrue(objects[0].equals(MyInt.create(1)), "Bad Value");
+        assertTrue(objects[1].equals(Integer.valueOf(2)), "Bad Object");
+
+        Comparable[] copyComparables = new Comparable[objects.length];
+        System.arraycopy(objects, 0, copyComparables, 0, objects.length);
+        checkArrayElementsEqual(objects, copyComparables);
+
+        objects[0] = null;
+        objects[1] = null;
+        assertTrue(objects[0] == null && objects[1] == null, "Not null ?");
+
+        Comparable[] comparables = new Comparable[2];
+        assertTrue(comparables[0] == null && comparables[1] == null, "Not null ?");
+        comparables[0] = MyInt.create(3);
+        comparables[1] = Integer.valueOf(4);
+        assertTrue(comparables[0].equals(MyInt.create(3)), "Bad Value");
+        assertTrue(comparables[1].equals(Integer.valueOf(4)), "Bad Object");
+
+        Object[] copyObjects = new Object[2];
+        System.arraycopy(comparables, 0, copyObjects, 0, comparables.length);
+        checkArrayElementsEqual(comparables, copyObjects);
+
+        comparables[0] = null;
+        comparables[1] = null;
+        assertTrue(comparables[0] == null && comparables[1] == null, "Not null ?");
+
+        MyInt.ref[] myIntRefArray = new MyInt.ref[1];
+        assertTrue(myIntRefArray[0] == null, "Got: " + myIntRefArray[0]);
+        myIntRefArray[0] = null;
+
+        MyInt.ref[] srcNulls = new MyInt.ref[2];
+        MyInt.ref[] dstNulls = new MyInt.ref[2];
+        System.arraycopy(srcNulls, 0, dstNulls, 0, 2);
+        checkArrayElementsEqual(srcNulls, dstNulls);
+        srcNulls[1] = MyInt.create(1);
+        System.arraycopy(srcNulls, 0, dstNulls, 0, 2);
+        checkArrayElementsEqual(srcNulls, dstNulls);
+    }
+
+    void testMixedLayoutArrays() {
+        Object[] objArray = new Object[3];
+        Comparable[] compArray = new Comparable[3];
+        MyInt[] valArray = new MyInt[] { (MyInt) MyInt.MIN, (MyInt) MyInt.ZERO, (MyInt) MyInt.MAX };
+
+        arrayCopy(valArray, 0, objArray, 0, 3);
+        checkArrayElementsEqual(valArray, objArray);
+        arrayCopy(valArray, 0, objArray, 0, 3);
+
+        objArray = new Object[3];
+        System.arraycopy(valArray, 0, objArray, 0, 3);
+        checkArrayElementsEqual(valArray, objArray);
+
+        System.arraycopy(valArray, 0, compArray, 0, 3);
+        checkArrayElementsEqual(valArray, compArray);
+
+        valArray = new MyInt[] { (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO };
+        System.arraycopy(compArray, 0, valArray, 0, 3);
+        checkArrayElementsEqual(valArray, compArray);
+
+        valArray = new MyInt[] { (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO };
+        System.arraycopy(objArray, 0, valArray, 0, 3);
+        checkArrayElementsEqual(valArray, objArray);
+
+        // Sanity check dst == src
+        System.arraycopy(valArray, 0, valArray, 0, 3);
+        checkArrayElementsEqual(valArray, objArray);
+
+        objArray[0] = "Not an inline object";
+        try {
+            System.arraycopy(objArray, 0, valArray, 0, 3);
+            throw new RuntimeException("Expected ArrayStoreException");
+        } catch (ArrayStoreException ase) {}
+
+        MyInt.ref[] myIntRefArray = new MyInt.ref[3];
+        System.arraycopy(valArray, 0, myIntRefArray, 0, 3);
+        checkArrayElementsEqual(valArray, myIntRefArray);
+
+        myIntRefArray[0] = null;
+        try {
+            System.arraycopy(myIntRefArray, 0, valArray, 0, 3);
+            throw new RuntimeException("Expected NullPointerException");
+        } catch (NullPointerException npe) {}
+    }
+
+    static final inline class MyPoint {
+        final               MyInt x;
+        final               MyInt y;
+
+        private MyPoint() { this(0, 0); }
+        private MyPoint(int x, int y) {
+            this.x = new MyInt(x);
+            this.y = new MyInt(y);
+        }
+        public boolean equals(Object that) {
+            if (that instanceof MyPoint) {
+                MyPoint thatPoint = (MyPoint) that;
+                return x.equals(thatPoint.x) && java.util.Objects.equals(y, thatPoint.y);
+            }
+            return false;
+        }
+        static MyPoint create(int x) {
+            return new MyPoint(x, x);
+        }
+        static MyPoint create(int x, int y) {
+            return new MyPoint(x, y);
+        }
+        static final MyPoint.ref ORIGIN = create(0);
+    }
+
+    void testComposition() {
+        // Test array operations with compostion of inline types, check element payload is correct...
+        MyPoint a = MyPoint.create(1, 2);
+        MyPoint b = MyPoint.create(7, 21);
+        MyPoint c = MyPoint.create(Integer.MAX_VALUE, Integer.MIN_VALUE);
+
+        MyPoint[] pts = new MyPoint[3];
+        if (!pts[0].equals(MyPoint.ORIGIN)) {
+            throw new RuntimeException("Equals failed: " + pts[0] + " vs " + MyPoint.ORIGIN);
+        }
+        pts = new MyPoint[] { a, b, c };
+        checkArrayElementsEqual(pts, new Object[] { a, b, c});
+        Object[] oarr = new Object[3];
+
+        arrayCopy(pts, 0, oarr, 0, 3);
+        checkArrayElementsEqual(pts, oarr);
+
+        oarr = new Object[3];
+        System.arraycopy(pts, 0, oarr, 0, 3);
+        checkArrayElementsEqual(pts, oarr);
+
+        System.arraycopy(oarr, 0, pts, 0, 3);
+        checkArrayElementsEqual(pts, oarr);
+
+        oarr = new Object[3];
+        try {
+            System.arraycopy(oarr, 0, pts, 0, 3);
+            throw new RuntimeException("Expected NPE");
+        }
+        catch (NullPointerException npe) {}
+
+        oarr = new Object[3];
+        oarr[0] = new Object();
+        try {
+            System.arraycopy(oarr, 0, pts, 0, 3);
+            throw new RuntimeException("Expected ASE");
+        }
+        catch (ArrayStoreException ase) {}
+    }
+
+    void checkArrayElementsEqual(MyInt[] arr1, Object[] arr2) {
+        assertTrue(arr1.length == arr2.length, "Bad length");
+        for (int i = 0; i < arr1.length; i++) {
+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), "Element " + i + " not equal");
+        }
+    }
+
+    void checkArrayElementsEqual(MyPoint[] arr1, Object[] arr2) {
+        assertTrue(arr1.length == arr2.length, "Bad length");
+        for (int i = 0; i < arr1.length; i++) {
+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), "Element " + i + " not equal");
+        }
+    }
+
+    void checkArrayElementsEqual(Object[] arr1, Object[] arr2) {
+        assertTrue(arr1.length == arr2.length, "Bad length");
+        for (int i = 0; i < arr1.length; i++) {
+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), "Element " + i + " not equal");
+        }
+    }
+
+    void arrayCopy(MyInt[] src, int srcPos, Object[] dst, int dstPos, int length) {
+        for (int i = 0; i < length ; i++) {
+            dst[dstPos++] = src[srcPos++];
+        }
+    }
+    void arrayCopy(MyPoint[] src, int srcPos, Object[] dst, int dstPos, int length) {
+        for (int i = 0; i < length ; i++) {
+            dst[dstPos++] = src[srcPos++];
+        }
+    }
+
+    Object getNull() { return null; }
+
+
+    void testInlineArrayOom() {
+        int size = Integer.MAX_VALUE;
+        try {
+            MyPoint[] pts = new MyPoint[size];
+            throw new RuntimeException("Excepted OOM");
+        } catch (OutOfMemoryError oom) {}
+    }
+
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeCreation.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeCreation.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeCreation.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test InlineTypeCreation
+ * @summary Inline Type creation test
+ * @library /test/lib
+ * @compile  -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers InlineTypeCreation.java Point.java Long8Inline.java Person.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.InlineTypeCreation
+ * @run main/othervm -Xcomp runtime.valhalla.inlinetypes.InlineTypeCreation
+ */
+public class InlineTypeCreation {
+    public static void main(String[] args) {
+        InlineTypeCreation inlineTypeCreation = new InlineTypeCreation();
+        inlineTypeCreation.run();
+    }
+
+    public void run() {
+        testPoint();
+        testLong8();
+        testPerson();
+        StaticSelf.test();
+    }
+
+    void testPoint() {
+        Point p = Point.createPoint(1, 2);
+        Asserts.assertEquals(p.x, 1, "invalid point x value");
+        Asserts.assertEquals(p.y, 2, "invalid point y value");
+        Point p2 = clonePoint(p);
+        Asserts.assertEquals(p2.x, 1, "invalid point clone x value");
+        Asserts.assertEquals(p2.y, 2, "invalid point clone y value");
+    }
+
+    static Point clonePoint(Point p) {
+        Point q = p;
+        return q;
+    }
+
+    void testLong8() {
+        Long8Inline long8Inline = Long8Inline.create(1, 2, 3, 4, 5, 6, 7, 8);
+        Asserts.assertEquals(long8Inline.getLongField1(), 1L, "Field 1 incorrect");
+        Asserts.assertEquals(long8Inline.getLongField8(), 8L, "Field 8 incorrect");
+        Long8Inline.check(long8Inline, 1, 2, 3, 4, 5, 6, 7, 8);
+    }
+
+    void testPerson() {
+        Person person = Person.create(1, "John", "Smith");
+        Asserts.assertEquals(person.getId(), 1, "Id field incorrect");
+        Asserts.assertEquals(person.getFirstName(), "John", "First name incorrect");
+        Asserts.assertEquals(person.getLastName(), "Smith", "Last name incorrect");
+    }
+
+    static final inline class StaticSelf {
+
+        static final StaticSelf.ref DEFAULT = create(0);
+        final int f1;
+
+        private StaticSelf() { f1 = 0; }
+        public String toString() { return "StaticSelf f1=" + f1; }
+
+        static StaticSelf create(int f1) {
+            StaticSelf s = StaticSelf.default;
+            s = __WithField(s.f1, f1);
+            return s;
+        }
+
+        public static void test() {
+            String s = DEFAULT.toString();
+        }
+
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeDensity.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeDensity.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeDensity.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+import java.lang.management.MemoryPoolMXBean;
+
+import sun.hotspot.WhiteBox;
+import jdk.test.lib.Asserts;
+
+/**
+ * @test InlineTypeDensity
+ * @summary Heap density test for InlineTypes
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator InlineTypeDensity.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run main/othervm -Xint -XX:FlatArrayElementMaxSize=-1
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
+ *                    -XX:+WhiteBoxAPI InlineTypeDensity
+ * @run main/othervm -Xcomp -XX:FlatArrayElementMaxSize=-1
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
+ *                   -XX:+WhiteBoxAPI InlineTypeDensity
+ * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions
+ *                   -Xbootclasspath/a:. -XX:ForceNonTearable=*
+ *                   -XX:+WhiteBoxAPI InlineTypeDensity
+ */
+
+public class InlineTypeDensity {
+
+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
+
+    public InlineTypeDensity() {
+        if (WHITE_BOX.getIntxVMFlag("FlatArrayElementMaxSize") != -1) {
+            throw new IllegalStateException("FlatArrayElementMaxSize should be -1");
+        }
+    }
+
+    interface LocalDate {
+        public int getYear();
+        public short getMonth();
+        public short getDay();
+    }
+
+    interface LocalTime {
+        public byte getHour();
+        public byte getMinute();
+        public byte getSecond();
+        public int getNano();
+    }
+
+    interface LocalDateTime extends LocalDate, LocalTime {}
+
+    static final inline class LocalDateValue implements LocalDate {
+        final int   year;
+        final short month;
+        final short day;
+
+        LocalDateValue() {
+            year  = 0;
+            month = 0;
+            day   = 0;
+        }
+
+        public int   getYear()  { return year; }
+        public short getMonth() { return month; }
+        public short getDay()   { return day; }
+
+        public static LocalDateValue create(int year, short month, short day) {
+            LocalDateValue localDate = LocalDateValue.default;
+            localDate = __WithField(localDate.year, year);
+            localDate = __WithField(localDate.month, month);
+            localDate = __WithField(localDate.day, day);
+            return localDate;
+        }
+    }
+
+    static final inline class LocalTimeValue implements LocalTime {
+        final byte hour;
+        final byte minute;
+        final byte second;
+        final int nano;
+
+        LocalTimeValue() {
+            hour   = 0;
+            minute = 0;
+            second = 0;
+            nano   = 0;
+        }
+
+        public byte getHour()   { return hour; }
+        public byte getMinute() { return minute; }
+        public byte getSecond() { return second; }
+        public int getNano()    { return nano; }
+
+        public static LocalTimeValue create(byte hour, byte minute, byte second, int nano) {
+            LocalTimeValue localTime = LocalTimeValue.default;
+            localTime = __WithField(localTime.hour, hour);
+            localTime = __WithField(localTime.minute, minute);
+            localTime = __WithField(localTime.second, second);
+            localTime = __WithField(localTime.nano, nano);
+            return localTime;
+        }
+    }
+
+    static final inline class LocalDateTimeValue implements LocalDateTime {
+        final LocalDateValue date;
+        final LocalTimeValue time;
+
+        LocalDateTimeValue() {
+            // Well this is a little weird...
+            date = LocalDateValue.create(0, (short)0, (short)0);
+            time = LocalTimeValue.create((byte)0, (byte)0, (byte)0, 0);
+        }
+
+        public int   getYear()  { return date.year; }
+        public short getMonth() { return date.month; }
+        public short getDay()   { return date.day; }
+
+        public byte getHour()   { return time.hour; }
+        public byte getMinute() { return time.minute; }
+        public byte getSecond() { return time.second; }
+        public int getNano()    { return time.nano; }
+
+        public static LocalDateTimeValue create(LocalDateValue date, LocalTimeValue time) {
+            LocalDateTimeValue localDateTime = LocalDateTimeValue.default;
+            localDateTime = __WithField(localDateTime.date, date);
+            localDateTime = __WithField(localDateTime.time, time);
+            return localDateTime;
+        }
+    }
+
+    static final class LocalDateClass implements LocalDate {
+        final int   year;
+        final short month;
+        final short day;
+
+        LocalDateClass(int year, short month, short day) {
+            this.year  = year;
+            this.month = month;
+            this.day   = day;
+        }
+
+        public int   getYear()  { return year; }
+        public short getMonth() { return month; }
+        public short getDay()   { return day; }
+    }
+
+    static final class LocalTimeClass implements LocalTime {
+        final byte hour;
+        final byte minute;
+        final byte second;
+        final int nano;
+
+        LocalTimeClass(byte hour, byte minute, byte second, int nano) {
+            this.hour   = hour;
+            this.minute = minute;
+            this.second = second;
+            this.nano   = nano;
+        }
+
+        public byte getHour()   { return hour; }
+        public byte getMinute() { return minute; }
+        public byte getSecond() { return second; }
+        public int getNano()    { return nano; }
+    }
+
+    static final class LocalDateTimeClass implements LocalDateTime {
+        final LocalDateClass date;
+        final LocalTimeClass time;
+
+        LocalDateTimeClass(LocalDateClass date, LocalTimeClass time) {
+            this.date = date;
+            this.time = time;
+        }
+
+        public LocalDateClass getDate() { return date; }
+        public LocalTimeClass getTime() { return time; }
+
+        public int   getYear()  { return date.year; }
+        public short getMonth() { return date.month; }
+        public short getDay()   { return date.day; }
+
+        public byte getHour()   { return time.hour; }
+        public byte getMinute() { return time.minute; }
+        public byte getSecond() { return time.second; }
+        public int getNano()    { return time.nano; }
+    }
+
+    public void ensureArraySizeWin() {
+        int arrayLength = 1000;
+        System.out.println("ensureArraySizeWin for length " + arrayLength);
+        LocalDateTimeClass[] objectArray = new LocalDateTimeClass[arrayLength];
+        for (int i = 0; i < arrayLength; i++) {
+            objectArray[i] = new LocalDateTimeClass(new LocalDateClass(0, (short)0, (short)0),
+                    new LocalTimeClass((byte)0, (byte)0, (byte)0, 0));
+        }
+
+        long objectArraySize = WHITE_BOX.getObjectSize(objectArray);
+        System.out.println("Empty object array size: " + objectArraySize);
+        objectArraySize += (arrayLength *
+                (WHITE_BOX.getObjectSize(objectArray[0]) +
+                        WHITE_BOX.getObjectSize(objectArray[0].getDate()) +
+                        WHITE_BOX.getObjectSize(objectArray[0].getTime())));
+
+        LocalDateTimeValue[] inlineArray = new LocalDateTimeValue[arrayLength];
+        // CMH: add "isFlatValueArray" to WhiteBox API, to ensure we are correctly account size
+
+        long inlineArraySize = WHITE_BOX.getObjectSize(inlineArray);
+        System.out.println("Object array and elements: " + objectArraySize + " versus Value Array: " + inlineArraySize);
+        Asserts.assertLessThan(inlineArraySize, objectArraySize, "Inline array accounts for more heap than object array + elements !");
+    }
+
+    public void test() {
+        ensureArraySizeWin();
+    }
+
+    public static void main(String[] args) {
+        new InlineTypeDensity().test();
+    }
+
+}
+
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeGetField.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeGetField.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypeGetField.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test InlineTypeGetField
+ * @summary Inline Type get field test
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java InlineTypeGetField.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.InlineTypeGetField
+ * @run main/othervm -Xcomp runtime.valhalla.inlinetypes.InlineTypeGetField
+ */
+public class InlineTypeGetField {
+
+    static Point staticPoint0;
+    static Point staticPoint1;
+    Point instancePoint0;
+    Point instancePoint1;
+
+    static {
+        staticPoint0 = Point.createPoint(358, 406);
+        staticPoint1 = Point.createPoint(101, 2653);
+    }
+
+    InlineTypeGetField() {
+        instancePoint0 = Point.createPoint(1890, 1918);
+        instancePoint1 = Point.createPoint(91, 102);
+    }
+
+    public static void main(String[] args) {
+        InlineTypeGetField inlineTypeGetField = new InlineTypeGetField();
+        System.gc(); // check that VTs survive GC
+        inlineTypeGetField.run();
+    }
+
+    public void run() {
+        // testing initial configuration
+        checkPoint(staticPoint0, 358, 406);
+        checkPoint(staticPoint1, 101, 2653);
+        checkPoint(instancePoint0, 1890, 1918);
+        checkPoint(instancePoint1, 91, 102);
+        // swapping static fields
+        Point p = staticPoint1;
+        staticPoint1 = staticPoint0;
+        staticPoint0 = p;
+        System.gc();
+        checkPoint(staticPoint0, 101, 2653);
+        checkPoint(staticPoint1, 358, 406);
+        //swapping instance fields
+        p = instancePoint1;
+        instancePoint1 = instancePoint0;
+        instancePoint0 = p;
+        System.gc();
+        checkPoint(instancePoint0, 91, 102);
+        checkPoint(instancePoint1, 1890, 1918);
+        // instance to static
+        staticPoint0 = instancePoint0;
+        System.gc();
+        checkPoint(staticPoint0, 91, 102);
+        // static to instance
+        instancePoint1 = staticPoint1;
+        System.gc();
+        checkPoint(instancePoint1, 358, 406);
+    }
+
+    static void checkPoint(Point p , int x, int y) {
+        Asserts.assertEquals(p.x, x, "invalid x value");
+        Asserts.assertEquals(p.y, y, "invalid y value");
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypesTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypesTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineTypesTest.java
@@ -0,0 +1,289 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.lang.invoke.*;
+import java.lang.ref.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.*;
+
+import static jdk.test.lib.Asserts.*;
+
+import jdk.experimental.bytecode.MacroCodeBuilder;
+import jdk.experimental.bytecode.MacroCodeBuilder.CondKind;
+import jdk.experimental.bytecode.TypeTag;
+import jdk.test.lib.Platform;
+import jdk.test.lib.Utils;
+
+import jdk.experimental.value.MethodHandleBuilder;
+
+import javax.tools.*;
+
+/**
+ * @test InlineTypesTest
+ * @summary Test data movement with inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator TestValue1.java TestValue2.java TestValue3.java TestValue4.java InlineTypesTest.java
+ * @run main/othervm -Xint -Xmx128m -XX:-ShowMessageBoxOnError
+ *                   -XX:+ExplicitGCInvokesConcurrent
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
+ *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false
+ *                   runtime.valhalla.inlinetypes.InlineTypesTest
+ * @run main/othervm -Xcomp -Xmx128m -XX:-ShowMessageBoxOnError
+ *                   -XX:+ExplicitGCInvokesConcurrent
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
+ *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false
+ *                   runtime.valhalla.inlinetypes.InlineTypesTest
+ * @run main/othervm -Xbatch -Xmx128m -XX:-ShowMessageBoxOnError
+ *                   -XX:+ExplicitGCInvokesConcurrent
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
+ *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false
+ *                   -XX:ForceNonTearable=*
+ *                   runtime.valhalla.inlinetypes.InlineTypesTest
+ */
+public class InlineTypesTest {
+
+    public static void main(String[] args) {
+        Class<?> inlineClass = runtime.valhalla.inlinetypes.TestValue1.class;
+        Class<?> testClasses[] = {
+                runtime.valhalla.inlinetypes.TestValue1.class,
+                runtime.valhalla.inlinetypes.TestValue2.class,
+                runtime.valhalla.inlinetypes.TestValue3.class,
+                runtime.valhalla.inlinetypes.TestValue4.class
+        };
+        Class<?> containerClasses[] = {
+                runtime.valhalla.inlinetypes.ContainerValue1.class,
+                runtime.valhalla.inlinetypes.ContainerValue2.class,
+                runtime.valhalla.inlinetypes.ContainerValue3.class,
+                runtime.valhalla.inlinetypes.ContainerValue4.class
+        };
+
+        for (int i = 0; i < testClasses.length; i++) {
+            try {
+                testExecutionStackToLocalVariable(testClasses[i]);
+                testExecutionStackToFields(testClasses[i], containerClasses[i]);
+                // testExecutionStackToInlineArray(testClasses[i], containerClasses[i]);
+            } catch (Throwable t) {
+                t.printStackTrace();
+                throw new RuntimeException(t);
+            }
+        }
+    }
+
+    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+
+    static void testExecutionStackToLocalVariable(Class<?> inlineClass) throws Throwable {
+        String sig = "()Q" + inlineClass.getName() + ";";
+        final String signature = sig.replace('.', '/');
+        MethodHandle fromExecStackToLocalVar = MethodHandleBuilder.loadCode(
+                LOOKUP,
+                "execStackToLocalVar",
+                MethodType.methodType(boolean.class),
+                CODE -> {
+                    CODE.invokestatic(System.class, "gc", "()V", false);
+                    int n = -1;
+                    while (n < 1024) {
+                        n++;
+                        CODE
+                        .invokestatic(inlineClass, "getInstance", signature, false)
+                        .astore(n);
+                        n++;
+                        CODE
+                        .invokestatic(inlineClass, "getNonBufferedInstance", signature, false)
+                        .astore(n);
+                    }
+                    CODE.invokestatic(System.class, "gc", "()V", false);
+                    while (n > 0) {
+                        CODE
+                        .aload(n)
+                        .invokevirtual(inlineClass, "verify", "()Z", false)
+                        .iconst_1()
+                        .ifcmp(TypeTag.I, CondKind.NE, "end");
+                        n--;
+                    }
+                    CODE
+                    .iconst_1()
+                    .return_(TypeTag.Z)
+                    .label("end")
+                    .iconst_0()
+                    .return_(TypeTag.Z);
+                });
+        boolean result = (boolean) fromExecStackToLocalVar.invokeExact();
+        System.out.println(result);
+        assertTrue(result, "Invariant");
+    }
+
+    static void testExecutionStackToFields(Class<?> inlineClass, Class<?> containerClass) throws Throwable {
+        final int ITERATIONS = Platform.isDebugBuild() ? 3 : 512;
+        String sig = "()Q" + inlineClass.getName() + ";";
+        final String methodSignature = sig.replace('.', '/');
+        final String fieldQSignature = "Q" + inlineClass.getName().replace('.', '/') + ";";
+        final String fieldLSignature = "L" + inlineClass.getName().replace('.', '/') + "$ref;";
+        System.out.println(methodSignature);
+        MethodHandle fromExecStackToFields = MethodHandleBuilder.loadCode(
+                LOOKUP,
+                "execStackToFields",
+                MethodType.methodType(boolean.class),
+                CODE -> {
+                    CODE
+                    .invokestatic(System.class, "gc", "()V", false)
+                    .new_(containerClass)
+                    .dup()
+                    .invoke(MacroCodeBuilder.InvocationKind.INVOKESPECIAL, containerClass, "<init>", "()V", false)
+                    .astore_1()
+                    .iconst_m1()
+                    .istore_2()
+                    .label("loop")
+                    .iload_2()
+                    .ldc(ITERATIONS)
+                    .ifcmp(TypeTag.I, CondKind.EQ, "end")
+                    .aload_1()
+                    .invokestatic(inlineClass, "getInstance", methodSignature, false)
+                    .putfield(containerClass, "nonStaticInlineField", fieldQSignature)
+                    .invokestatic(System.class, "gc", "()V", false)
+                    .aload_1()
+                    .getfield(containerClass, "nonStaticInlineField", fieldQSignature)
+                    .invokevirtual(inlineClass, "verify", "()Z", false)
+                    .iconst_1()
+                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
+                    .aload_1()
+                    .invokestatic(inlineClass, "getNonBufferedInstance", methodSignature, false)
+                    .putfield(containerClass, "nonStaticInlineField", fieldQSignature)
+                    .invokestatic(System.class, "gc", "()V", false)
+                    .aload_1()
+                    .getfield(containerClass, "nonStaticInlineField", fieldQSignature)
+                    .invokevirtual(inlineClass, "verify", "()Z", false)
+                    .iconst_1()
+                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
+                    .invokestatic(inlineClass, "getInstance", methodSignature, false)
+                    .putstatic(containerClass, "staticInlineField", fieldLSignature)
+                    .invokestatic(System.class, "gc", "()V", false)
+                    .getstatic(containerClass, "staticInlineField", fieldLSignature)
+                    .checkcast(inlineClass)
+                    .invokevirtual(inlineClass, "verify", "()Z", false)
+                    .iconst_1()
+                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
+                    .invokestatic(inlineClass, "getNonBufferedInstance", methodSignature, false)
+                    .putstatic(containerClass, "staticInlineField", fieldLSignature)
+                    .invokestatic(System.class, "gc", "()V", false)
+                    .getstatic(containerClass, "staticInlineField", fieldLSignature)
+                    .checkcast(inlineClass)
+                    .invokevirtual(inlineClass, "verify", "()Z", false)
+                    .iconst_1()
+                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
+                    .iinc(2, 1)
+                    .goto_("loop")
+                    .label("end")
+                    .iconst_1()
+                    .return_(TypeTag.Z)
+                    .label("failed")
+                    .iconst_0()
+                    .return_(TypeTag.Z);
+                });
+        boolean result = (boolean) fromExecStackToFields.invokeExact();
+        System.out.println(result);
+        assertTrue(result, "Invariant");
+    }
+
+    static void testExecutionStackToInlineArray(Class<?> inlineClass, Class<?> containerClass) throws Throwable {
+        final int ITERATIONS = Platform.isDebugBuild() ? 3 : 100;
+        String sig = "()Q" + inlineClass.getName() + ";";
+        final String signature = sig.replace('.', '/');
+        final String arraySignature = "[L" + inlineClass.getName().replace('.', '/') + ";";
+        System.out.println(arraySignature);
+        MethodHandle fromExecStackToInlineArray = MethodHandleBuilder.loadCode(
+                LOOKUP,
+                "execStackToInlineArray",
+                MethodType.methodType(boolean.class),
+                CODE -> {
+                    CODE
+                    .invokestatic(System.class, "gc", "()V", false)
+                    .new_(containerClass)
+                    .dup()
+                    .invoke(MacroCodeBuilder.InvocationKind.INVOKESPECIAL, containerClass, "<init>", "()V", false)
+                    .astore_1()
+                    .ldc(ITERATIONS * 3)
+                    .anewarray(inlineClass)
+                    .astore_2()
+                    .aload_2()
+                    .aload_1()
+                    .swap()
+                    .putfield(containerClass, "valueArray", arraySignature)
+                    .iconst_0()
+                    .istore_3()
+                    .label("loop1")
+                    .iload_3()
+                    .ldc(ITERATIONS)
+                    .ifcmp(TypeTag.I, CondKind.GE, "end1")
+                    .aload_2()
+                    .iload_3()
+                    .invokestatic(inlineClass, "getInstance", signature, false)
+                    .aastore()
+                    .iinc(3, 1)
+                    .aload_2()
+                    .iload_3()
+                    .invokestatic(inlineClass, "getNonBufferedInstance", signature, false)
+                    .aastore()
+                    .iinc(3, 1)
+                    .aload_2()
+                    .iload_3()
+                    .defaultvalue(inlineClass)
+                    .aastore()
+                    .iinc(3, 1)
+                    .goto_("loop1")
+                    .label("end1")
+                    .invokestatic(System.class, "gc", "()V", false)
+                    .iconst_0()
+                    .istore_3()
+                    .label("loop2")
+                    .iload_3()
+                    .ldc(ITERATIONS * 3)
+                    .ifcmp(TypeTag.I, CondKind.GE, "end2")
+                    .aload_2()
+                    .iload_3()
+                    .aaload()
+                    .invokevirtual(inlineClass, "verify", "()Z", false)
+                    .iconst_1()
+                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
+                    .iinc(3, 1)
+                    .goto_("loop2")
+                    .label("end2")
+                    .iconst_1()
+                    .return_(TypeTag.Z)
+                    .label("failed")
+                    .iconst_0()
+                    .return_(TypeTag.Z);
+                });
+        boolean result = (boolean) fromExecStackToInlineArray.invokeExact();
+        System.out.println(result);
+        assertTrue(result, "Invariant");
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineWithJni.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineWithJni.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/InlineWithJni.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+/* @test
+ * @summary test JNI functions with inline types
+ * @compile -XDemitQtypes -XDallowWithFieldOperator InlineWithJni.java
+ * @run main/othervm/native -Xint runtime.valhalla.inlinetypes.InlineWithJni
+ * @run main/othervm/native -Xcomp runtime.valhalla.inlinetypes.InlineWithJni
+ */
+public inline final class InlineWithJni {
+
+    static {
+        System.loadLibrary("InlineWithJni");
+    }
+
+    public static void main(String[] args) {
+        testJniMonitorOps();
+    }
+
+    final int x;
+    private InlineWithJni() { x = 0; }
+
+    public native void doJniMonitorEnter();
+    public native void doJniMonitorExit();
+
+    public static InlineWithJni createInlineWithJni(int x) {
+        InlineWithJni v = InlineWithJni.default;
+        v = __WithField(v.x, x);
+        return v;
+    }
+
+    public static void testJniMonitorOps() {
+        boolean sawImse = false;
+        try {
+            createInlineWithJni(0).doJniMonitorEnter();
+        } catch (Throwable t) {
+            sawImse = checkImse(t);
+        }
+        if (!sawImse) {
+            throw new RuntimeException("JNI MonitorEnter did not fail");
+        }
+        sawImse = false;
+        try {
+            createInlineWithJni(0).doJniMonitorExit();
+        } catch (Throwable t) {
+            sawImse = checkImse(t);
+        }
+        if (!sawImse) {
+            throw new RuntimeException("JNI MonitorExit did not fail");
+        }
+    }
+
+    static boolean checkImse(Throwable t) {
+        if (t instanceof IllegalMonitorStateException) {
+            return true;
+        }
+        throw new RuntimeException(t);
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/IntValue.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/IntValue.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/IntValue.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+public inline class IntValue {
+    int val;
+    public IntValue()       { this(0); }
+    public IntValue(int v)  { val = v; }
+    public int getInt()     { return val; }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/JumboInline.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/JumboInline.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/JumboInline.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+public inline final class JumboInline {
+    final long l0;
+    final long l1;
+    final long l2;
+    final long l3;
+    final long l4;
+    final long l5;
+    final long l6;
+    final long l7;
+    final long l8;
+    final long l9;
+    final long l10;
+    final long l11;
+    final long l12;
+    final long l13;
+    final long l14;
+    final long l15;
+    final long l16;
+    final long l17;
+    final long l18;
+    final long l19;
+
+    private JumboInline() {
+        l0 = 0;
+        l1 = 0;
+        l2 = 0;
+        l3 = 0;
+        l4 = 0;
+        l5 = 0;
+        l6 = 0;
+        l7 = 0;
+        l8 = 0;
+        l9 = 0;
+        l10 = 0;
+        l11 = 0;
+        l12 = 0;
+        l13 = 0;
+        l14 = 0;
+        l15 = 0;
+        l16 = 0;
+        l17 = 0;
+        l18 = 0;
+        l19 = 0;
+    }
+
+    public static JumboInline createJumboInline() {
+        JumboInline j = JumboInline.default;
+        return j;
+    }
+
+    public JumboInline update(long l0, long l1) {
+        JumboInline j = __WithField(this.l0, l0);
+        j = __WithField(j.l1, l1);
+        j = __WithField(j.l2, l0 + l1);
+        j = __WithField(j.l3, l1 + l2);
+        j = __WithField(j.l4, l2 + l3);
+        j = __WithField(j.l5, l3 + l4);
+        j = __WithField(j.l6, l4 + l5);
+        j = __WithField(j.l7, l5 + l6);
+        j = __WithField(j.l8, l6 + l7);
+        j = __WithField(j.l9, l7 + l8);
+        j = __WithField(j.l10, l8 + l9);
+        j = __WithField(j.l11, l9 + l10);
+        j = __WithField(j.l12, l10 + l11);
+        j = __WithField(j.l13, l11 + l12);
+        j = __WithField(j.l14, l12 + l13);
+        j = __WithField(j.l15, l13 + l14);
+        j = __WithField(j.l16, l14 + l15);
+        j = __WithField(j.l17, l15 + l16);
+        j = __WithField(j.l18, l16 + l17);
+        j = __WithField(j.l19, l17 + l18);
+        return j;
+    }
+
+    public boolean verify() {
+        return (l2 == (l0 + l1)  &&  l3 == (l1 + l2) && l5 == (l3 + l4)
+            && l6 == (l4 + l5) && l7 == (l5 + l6) && l8 == (l6 + l7)
+            && l9 == (l7 + l8) && l10 == (l8 + l9) && l11 == (l9 + l10)
+            && l12 == (l10 + l11) && l13 == (l11 + l12) && l14 == (l12 + l13)
+            && l15 == (l13 + l14) && l16 == (l14 + l15) && l17 == (l15 + l16)
+            && l18 == (l16 + l17) && l19 == (l17 + l18));
+    }
+
+    public boolean equals(Object o) {
+        if(o instanceof JumboInline) {
+            JumboInline j = (JumboInline)o;
+            return (l0 == j.l0 && l1 == j.l1 && l2 == j.l2 && l3 == j.l3
+                    && l4 == j.l4 && l5 == j.l5 && l6 == j.l6 && l7 == j.l7
+                    && l8 == j.l8 && l9 == j.l9 && l10 == j.l10 && l7 == j.l10
+                    && l11 == j.l11 && l12 == j.l12 && l13 == j.l13 && l4 == j.l14
+                    && l15 == j.l15 && l16 == j.l16 && l17 == j.l17 && l18 == j.l18
+                    && l19 == j.l19);
+        } else {
+            return false;
+        }
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Long8Inline.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Long8Inline.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Long8Inline.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+public final inline class Long8Inline {
+
+    final long longField1;
+    final long longField2;
+    final long longField3;
+    final long longField4;
+    final long longField5;
+    final long longField6;
+    final long longField7;
+    final long longField8;
+
+    private Long8Inline(long l1, long l2, long l3, long l4, long l5, long l6, long l7, long l8) {
+        longField1 = l1;
+        longField2 = l2;
+        longField3 = l3;
+        longField4 = l4;
+        longField5 = l5;
+        longField6 = l6;
+        longField7 = l7;
+        longField8 = l8;
+    }
+
+    public long getLongField1() { return longField1; }
+    public long getLongField2() { return longField2; }
+    public long getLongField3() { return longField3; }
+    public long getLongField4() { return longField4; }
+    public long getLongField5() { return longField5; }
+    public long getLongField6() { return longField6; }
+    public long getLongField7() { return longField7; }
+    public long getLongField8() { return longField8; }
+
+    public static Long8Inline create(long long1,
+            long long2,
+            long long3,
+            long long4,
+            long long5,
+            long long6,
+            long long7,
+            long long8) {
+        return new Long8Inline(long1, long2, long3, long4, long5, long6, long7, long8);
+    }
+
+    static void check(Long8Inline value,
+            long long1,
+            long long2,
+            long long3,
+            long long4,
+            long long5,
+            long long6,
+            long long7,
+            long long8) {
+        Asserts.assertEquals(value.getLongField1(), long1, "Field 1 incorrect");
+        Asserts.assertEquals(value.getLongField2(), long2, "Field 2 incorrect");
+        Asserts.assertEquals(value.getLongField3(), long3, "Field 3 incorrect");
+        Asserts.assertEquals(value.getLongField4(), long4, "Field 4 incorrect");
+        Asserts.assertEquals(value.getLongField5(), long5, "Field 5 incorrect");
+        Asserts.assertEquals(value.getLongField6(), long6, "Field 6 incorrect");
+        Asserts.assertEquals(value.getLongField7(), long7, "Field 7 incorrect");
+        Asserts.assertEquals(value.getLongField8(), long8, "Field 8 incorrect");
+    }
+
+}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/MultiANewArrayTest/Element0.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/MultiANewArrayTest/Element0.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/MultiANewArrayTest/Element0.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/MultiANewArrayTest/Element0.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/MultiANewArrayTest/Element1.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/MultiANewArrayTest/Element1.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/MultiANewArrayTest/Element1.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/MultiANewArrayTest/Element1.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/MultiANewArrayTest/MultiANewArrayTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/MultiANewArrayTest/MultiANewArrayTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/MultiANewArrayTest/MultiANewArrayTest.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/MultiANewArrayTest/MultiANewArrayTest.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/MultiANewArrayTest/MultiANewArrayTypeCheck.jcod b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/MultiANewArrayTest/MultiANewArrayTypeCheck.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/MultiANewArrayTest/MultiANewArrayTypeCheck.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/MultiANewArrayTest/MultiANewArrayTypeCheck.jcod
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/NewInstanceFromConstructor.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/NewInstanceFromConstructor.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/NewInstanceFromConstructor.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package runtime.valhalla.inlinetypes;
+
+public class NewInstanceFromConstructor {
+
+    int value;
+    static int consCalls = 0;
+
+    public NewInstanceFromConstructor() {
+        this(0);
+    }
+
+    public NewInstanceFromConstructor(int v) {
+        value = v;
+        consCalls++;
+    }
+
+    public NewInstanceFromConstructor(IntValue v) {
+        this(v.getInt());
+    }
+
+    public NewInstanceFromConstructor(IntValue v1,
+                                      IntValue v2) {
+        this(v1.getInt() + v2.getInt());
+    }
+
+    public NewInstanceFromConstructor(IntValue v1,
+                                      String s) {
+        this(v1);
+        throw new RuntimeException(s);
+    }
+
+    public int getValue() { return value; }
+
+    public static int getConsCalls() { return consCalls; }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ObjectMethods.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ObjectMethods.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ObjectMethods.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import java.lang.invoke.*;
+
+import jdk.experimental.value.MethodHandleBuilder;
+
+/*
+ * @test ObjectMethods
+ * @summary Check object method implemented by the VM behave with inline types
+ * @modules java.base/jdk.experimental.bytecode
+ *          java.base/jdk.experimental.value
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ObjectMethods.java
+ * @run main/othervm -Xint -XX:+UseBiasedLocking -XX:+UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods
+ * @run main/othervm -Xint -XX:-UseBiasedLocking -XX:-UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods
+ * @run main/othervm -Xint -noverify runtime.valhalla.inlinetypes.ObjectMethods noverify
+ * @run main/othervm -Xcomp -XX:+UseBiasedLocking -XX:+UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods
+ * @run main/othervm -Xcomp -XX:-UseBiasedLocking -XX:-UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods
+ * @run main/othervm -Xcomp -noverify runtime.valhalla.inlinetypes.ObjectMethods noverify
+ */
+
+public class ObjectMethods {
+
+    public static void main(String[] args) {
+        testObjectMethods((args.length > 0 && args[0].equals("noverify")));
+    }
+
+    public static void testObjectMethods(boolean verifierDisabled) {
+        MyInt val = MyInt.create(7);
+        MyInt sameVal = MyInt.create(7);
+
+        // Exercise all the Object native/VM methods...
+
+        if (verifierDisabled) { // Just noverifier...
+            checkMonitorExit(val);
+            return;
+        }
+
+        // getClass()
+        checkGetClass(val, MyInt.class);
+
+        //hashCode()/identityHashCode()
+        checkHashCodes(val, sameVal.hashCode());
+
+        // clone()
+        checkNotCloneable(val);
+
+        // synchronized
+        checkSynchronized(val);
+
+        // wait/notify()
+        checkWait(val);
+        checkNotify(val);
+
+        System.gc();
+    }
+
+
+    static void checkGetClass(Object val, Class<?> expectedClass) {
+        Class<?> clazz = val.getClass();
+        if (clazz == null) {
+            throw new RuntimeException("getClass return null");
+        } else if (clazz != expectedClass) {
+            throw new RuntimeException("getClass (" + clazz + ") doesn't match " + expectedClass);
+        }
+    }
+
+    // Just check we don't crash the VM
+    static void checkHashCodes(Object val, int expectedHashCode) {
+        if (val.hashCode() != expectedHashCode) {
+            throw new RuntimeException("Hash code mismatch value: " + val.hashCode() +
+                                       " expected: " + expectedHashCode);
+        }
+    }
+
+    static void checkNotCloneable(MyInt val) {
+        boolean sawCnse = false;
+        try {
+            val.attemptClone();
+        } catch (CloneNotSupportedException cnse) {
+            sawCnse = true;
+        }
+        if (!sawCnse) {
+            throw new RuntimeException("clone() did not fail");
+        }
+        // Cloneable inline type checked by "BadInlineTypes" CFP tests
+    }
+
+    static void checkSynchronized(Object val) {
+        boolean sawImse = false;
+        try {
+            synchronized (val) {
+                throw new IllegalStateException("Unreachable code, reached");
+            }
+        } catch (IllegalMonitorStateException imse) {
+            sawImse = true;
+        }
+        if (!sawImse) {
+            throw new RuntimeException("monitorenter did not fail");
+        }
+        // synchronized method modifiers tested by "BadInlineTypes" CFP tests
+        // jni monitor ops tested by "InlineWithJni"
+    }
+
+    // Check we haven't broken the mismatched monitor block check...
+    static void checkMonitorExit(Object val) {
+        boolean sawImse = false;
+        try {
+            MethodHandleBuilder.loadCode(MethodHandles.lookup(),
+                                         "mismatchedMonitorExit",
+                                         MethodType.methodType(Void.TYPE, Object.class),
+                                         CODE->{
+                                             CODE
+                                                 .aload(0)
+                                                 .monitorexit()
+                                                 .return_();
+                                         }).invokeExact(val);
+            throw new IllegalStateException("Unreachable code, reached");
+        } catch (Throwable t) {
+            if (t instanceof IllegalMonitorStateException) {
+                sawImse = true;
+            } else {
+                throw new RuntimeException(t);
+            }
+        }
+        if (!sawImse) {
+            throw new RuntimeException("monitorexit did not fail");
+        }
+    }
+
+    static void checkWait(Object val) {
+        boolean sawImse = false;
+        try {
+            val.wait();
+        } catch (IllegalMonitorStateException imse) {
+            sawImse = true;
+        } catch (InterruptedException intExc) {
+            throw new RuntimeException(intExc);
+        }
+        if (!sawImse) {
+            throw new RuntimeException("wait() did not fail");
+        }
+
+        sawImse = false;
+        try {
+            val.wait(1l);
+        } catch (IllegalMonitorStateException imse) {
+            sawImse = true;
+        } catch (InterruptedException intExc) {
+            throw new RuntimeException(intExc);
+        }
+        if (!sawImse) {
+            throw new RuntimeException("wait() did not fail");
+        }
+
+        sawImse = false;
+        try {
+            val.wait(0l, 100);
+        } catch (IllegalMonitorStateException imse) {
+            sawImse = true;
+        } catch (InterruptedException intExc) {
+            throw new RuntimeException(intExc);
+        }
+        if (!sawImse) {
+            throw new RuntimeException("wait() did not fail");
+        }
+    }
+
+    static void checkNotify(Object val) {
+        boolean sawImse = false;
+        try {
+            val.notify();
+        } catch (IllegalMonitorStateException imse) {
+            sawImse = true;
+        }
+        if (!sawImse) {
+            throw new RuntimeException("notify() did not fail");
+        }
+
+        sawImse = false;
+        try {
+            val.notifyAll();
+        } catch (IllegalMonitorStateException imse) {
+            sawImse = true;
+        }
+        if (!sawImse) {
+            throw new RuntimeException("notifyAll() did not fail");
+        }
+    }
+
+    static final inline class MyInt {
+        final int value;
+        private MyInt() { value = 0; }
+        public static MyInt create(int v) {
+            MyInt mi = MyInt.default;
+            mi = __WithField(mi.value, v);
+            return mi;
+        }
+        public Object attemptClone() throws CloneNotSupportedException {
+            try { // Check it is not possible to clone...
+                MethodHandles.Lookup lookup = MethodHandles.lookup();
+                MethodHandle mh = lookup.findVirtual(getClass(),
+                                                     "clone",
+                                                     MethodType.methodType(Object.class));
+                return mh.invokeExact(this);
+            } catch (Throwable t) {
+                if (t instanceof CloneNotSupportedException) {
+                    throw (CloneNotSupportedException) t;
+                }
+                throw new RuntimeException(t);
+            }
+        }
+    }
+
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Person.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Person.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Person.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+public final inline class Person {
+
+    final int    id;
+    final String firstName;
+    final String lastName;
+
+    private Person(int id, String firstName, String lastName) {
+        this.id = id;
+        this.firstName = firstName;
+        this.lastName = lastName;
+    }
+
+    public int getId() { return id; }
+    public String getFirstName() { return firstName; }
+    public String getLastName() { return lastName; }
+
+    public String toString() {
+        return getFirstName() + " " + getLastName() + " (id=" + getId() + ")";
+    }
+
+    static Person create(int id, String firstName, String lastName) {
+        return new Person(id, firstName, lastName);
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/PersonVcc.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/PersonVcc.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/PersonVcc.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+@jdk.incubator.mvt.ValueCapableClass
+public final class PersonVcc {
+    final int id;
+    final String firstName;
+    final String lastName;
+
+    private PersonVcc(int id, String firstName, String lastName) {
+        this.id = id;
+        this.firstName = firstName;
+        this.lastName = lastName;
+    }
+
+    public int getId() { return id; }
+    public String getFirstName() { return firstName; }
+    public String getLastName() { return lastName; }
+
+    public String toString() {
+        return getFirstName() + " " + getLastName() + " (id=" + getId() + ")";
+    }
+
+    public static PersonVcc create(int id, String firstName, String lastName) {
+        return new PersonVcc(id, firstName, lastName);
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Point.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Point.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Point.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+public inline final class Point {
+    final int x;
+    final int y;
+
+    private Point(int x, int y) {
+        this.x = x;
+        this.y = y;
+    }
+
+    public int getX() { return x; }
+    public int getY() { return y; }
+
+    public boolean isSamePoint(Point that) {
+        return this.getX() == that.getX() && this.getY() == that.getY();
+    }
+
+    public String toString() {
+        return "Point: x=" + getX() + " y=" + getY();
+    }
+
+    public boolean equals(Object o) {
+        if(o instanceof Point) {
+            return ((Point)o).x == x &&  ((Point)o).y == y;
+        } else {
+            return false;
+        }
+    }
+
+    public static Point createPoint(int x, int y) {
+        return new Point(x, y);
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/QuickeningTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/QuickeningTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/QuickeningTest.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test QuickeningTest
+ * @summary Test quickening of getfield and putfield applied to inline fields
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java JumboInline.java QuickeningTest.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.QuickeningTest
+ * @run main/othervm -Xcomp runtime.valhalla.inlinetypes.QuickeningTest
+ */
+
+public class QuickeningTest {
+
+    static class Parent {
+    Point.ref nfp;       /* Not flattenable inline field */
+    Point fp;         /* Flattenable and flattened inline field */
+    JumboInline fj;    /* Flattenable not flattened inline field */
+
+        public void setNfp(Point p) { nfp = p; }
+        public void setFp(Point p) { fp = p; }
+        public void setFj(JumboInline j) { fj = j; }
+    }
+
+    static class Child extends Parent {
+        // This class inherited fields from the Parent class
+        Point.ref nfp2;      /* Not flattenable inline field */
+        Point fp2;        /* Flattenable and flattened inline field */
+        JumboInline fj2;   /* Flattenable not flattened inline field */
+
+        public void setNfp2(Point p) { nfp2 = p; }
+        public void setFp2(Point p)  { fp2 = p; }
+        public void setFj2(JumboInline j) { fj2 = j; }
+    }
+
+    static final inline class Value {
+        final Point.ref nfp;       /* Not flattenable inline field */
+        final Point fp;         /* Flattenable and flattened inline field */
+        final JumboInline fj;    /* Flattenable not flattened inline field */
+
+        private Value() {
+            nfp = Point.createPoint(0, 0);
+            fp = Point.createPoint(0, 0);
+            fj = JumboInline.createJumboInline();
+        }
+
+        public static Value create() {
+            return Value.default;
+        }
+    }
+
+    static void testUninitializedFields() {
+        Parent p = new Parent();
+        Asserts.assertEquals(p.nfp, null, "invalid uninitialized not flattenable");
+        Asserts.assertEquals(p.fp.x, 0, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(p.fp.y, 0, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(p.fj.l0, 0L, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(p.fj.l1, 0L, "invalid value for uninitialized flattened field");
+
+        Child c = new Child();
+        Asserts.assertEquals(c.nfp, null, "invalid uninitialized not flattenable field");
+        Asserts.assertEquals(c.fp.x, 0, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(c.fp.y, 0, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(c.fj.l0, 0L, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(c.fj.l1, 0L, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(c.nfp2, null, "invalid uninitialized not flattenable");
+        Asserts.assertEquals(c.fp2.x, 0, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(c.fp2.y, 0, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(c.fj2.l0, 0L, "invalid value for uninitialized not flattened field");
+        Asserts.assertEquals(c.fj2.l1, 0L, "invalid value for uninitialized not flattened field");
+
+        Value v = Value.create();
+        Asserts.assertEquals(v.nfp, null, "invalid uninitialized not flattenable");
+        Asserts.assertEquals(v.fp.x, 0, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(v.fp.y, 0, "invalid value for uninitialized flattened field");
+        Asserts.assertEquals(v.fj.l0, 0L, "invalid value for uninitialized not flattened field");
+        Asserts.assertEquals(v.fj.l1, 0L, "invalid value for uninitialized not flattened field");
+    }
+
+    static void testPutfieldAndGetField() {
+        Point p1 = Point.createPoint(16, 47);
+        Point p2 = Point.createPoint(32, 64);
+
+        JumboInline j1 = JumboInline.createJumboInline().update(4, 5);
+        JumboInline j2 = JumboInline.createJumboInline().update(7, 9);
+
+        Parent p = new Parent();
+        // executing each setter twice to test quickened bytecodes
+        p.setNfp(p1);
+        p.setNfp(p2);
+        p.setFp(p2);
+        p.setFp(p1);
+        p.setFj(j1);
+        p.setFj(j2);
+
+        Asserts.assertTrue(p.nfp.equals(p2), "invalid updated not flattenable field");
+        Asserts.assertEquals(p.fp.x, 16, "invalid value for updated flattened field");
+        Asserts.assertEquals(p.fp.y, 47, "invalid value for updated flattened field");
+        Asserts.assertTrue(p.fj.equals(j2), "invalid value for updated not flattened field");
+
+        Child c = new Child();
+        c.setNfp(p1);
+        c.setNfp(p2);
+        c.setFp(p2);
+        c.setFp(p1);
+        c.setFj(j1);
+        c.setFj(j2);
+        c.setNfp2(p2);
+        c.setNfp2(p1);
+        c.setFp2(p1);
+        c.setFp2(p2);
+        c.setFj2(j2);
+        c.setFj2(j1);
+
+        Asserts.assertTrue(c.nfp.equals(p2), "invalid updated not flattenable field");
+        Asserts.assertEquals(c.fp.x, 16, "invalid value for updated flattened field");
+        Asserts.assertEquals(c.fp.y, 47, "invalid value for updated flattened field");
+        Asserts.assertTrue(c.fj.equals(j2), "invalid value for updated not flattened field");
+
+        Asserts.assertTrue(c.nfp2.equals(p1), "invalid updated not flattenable field");
+        Asserts.assertEquals(c.fp2.x, 32, "invalid value for updated flattened field");
+        Asserts.assertEquals(c.fp2.y, 64, "invalid value for updated flattened field");
+        Asserts.assertTrue(c.fj2.equals(j1), "invalid value for updated not flattened field");
+    }
+
+    public static void main(String[] args) {
+        testUninitializedFields();
+        testUninitializedFields(); // run twice to test quickened bytecodes
+        testPutfieldAndGetField();
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/StaticFieldsTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/StaticFieldsTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/StaticFieldsTest.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test
+ * @summary Test circularity in static fields
+ * @library /test/lib
+ * @compile StaticFieldsTest.java
+ * @run main/othervm -Xint -XX:+EnableValhalla runtime.valhalla.inlinetypes.StaticFieldsTest
+ */
+
+public class StaticFieldsTest {
+
+
+    // ClassA and ClassB have a simple cycle in their static fields, but they should
+    // be able to load and initialize themselves successfully. Access to these
+    // static fields after their initialization should return the default value.
+    static inline class ClassA {
+        static ClassB b;
+        public int i;
+
+        public ClassA() {
+            i = 3;
+        }
+    }
+
+    static inline class ClassB {
+        static ClassA a;
+        public int i;
+
+        public ClassB() {
+            i = 700;
+        }
+    }
+
+    // ClassC has a reference to itself in its static field, but it should be able
+    // to initialize itelf successfully. Access to this static field after initialization
+    // should return the default value.
+    static inline class ClassC {
+        static ClassC c;
+        int i;
+
+        public ClassC() {
+            i = 42;
+        }
+    }
+
+
+    // ClassD and ClassE have circular references in their static fields, and they
+    // read these static fields during their initialization, the value read from
+    // these fields should be the default value. Both classes should initialize
+    // successfully.
+    static inline class ClassD {
+        static ClassE e;
+        int i;
+
+        static {
+            Asserts.assertEquals(e.i, 0, "Static field e.i incorrect");
+        }
+
+        public ClassD() {
+            i = 42;
+        }
+    }
+
+    static inline class ClassE {
+        static ClassD d;
+        int i;
+
+        static {
+            Asserts.assertEquals(d.i, 0, "Static field d.i incorrect");
+        }
+
+        public ClassE() {
+            i = 42;
+        }
+    }
+
+    // ClassF and ClassG have circular references in their static fields, and they
+    // create new instances of each other type to initialize these static fields
+    // during their initialization. Both classes should initialize successfully.
+    static inline class ClassF {
+        static ClassG g;
+        int i;
+
+        static {
+            g = new ClassG();
+            Asserts.assertEquals(g.i, 64, "Static field ClassF.g.i incorrect");
+        }
+
+        ClassF() {
+            i = 314;
+        }
+    }
+
+    static inline class ClassG {
+        static ClassF f;
+        int i;
+
+        static {
+            f = new ClassF();
+            Asserts.assertEquals(f.i, 314, "Static field ClassG.f.i incorrect");
+        }
+
+        ClassG() {
+            i = 64;
+        }
+    }
+
+    public static void main(String[] args) {
+        Asserts.assertEquals(ClassA.b.i, 0, "Static field ClassA.b.i incorrect");
+        Asserts.assertEquals(ClassB.a.i, 0, "Static field Classb.a.i incorrect");
+        Asserts.assertEquals(ClassC.c.i, 0, "Static field ClassC.c.i incorrect");
+        new ClassD();
+        new ClassF();
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Test8186715.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Test8186715.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/Test8186715.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+/*
+ * @test Test8186715
+ * @summary test return of buffered inline type passed in argument by caller
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDallowWithFieldOperator -XDenableValueTypes Test8186715.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.Test8186715
+ * @run main/othervm runtime.valhalla.inlinetypes.Test8186715
+ */
+
+public class Test8186715 {
+
+    public static void main(String[] args) {
+        MyValueType v = MyValueType.testDefault();
+
+        for (int i = 0; i < 1000000; i++) {
+            MyValueType.testBranchArg1(false, v);
+        }
+    }
+}
+
+inline final class MyValueType {
+    final int i;
+    final int j;
+
+    private MyValueType() {
+        i = 0;
+        j = 0;
+    }
+
+    static MyValueType testDefault() {
+        return MyValueType.default;
+    }
+
+    static MyValueType testBranchArg1(boolean flag, MyValueType v1) {
+        if (flag) {
+            v1 = __WithField(v1.i, 3);
+            v1 = __WithField(v1.j, 4);
+        }
+        return v1;
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestFieldNullability.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestFieldNullability.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestFieldNullability.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test TestFieldNullability
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator TestFieldNullability.java
+ * @run main/othervm -Xint -Xmx128m -XX:-ShowMessageBoxOnError -XX:InlineFieldMaxFlatSize=32
+ *                   runtime.valhalla.inlinetypes.TestFieldNullability
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+public class TestFieldNullability {
+    static inline class MyValue {
+        int x;
+
+        public MyValue() {
+            x = 314;
+        }
+    }
+
+    static inline class MyBigValue {
+        long l0, l1, l2, l3, l4, l5, l6, l7, l8, l9;
+        long l10, l11, l12, l13, l14, l15, l16, l17, l18, l19;
+
+        public MyBigValue() {
+            l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = 271;
+            l10 = l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = 271;
+        }
+    }
+
+    static inline class TestInlineType {
+        final MyValue.ref nullableField;
+        final MyValue nullfreeField;        // flattened
+        final MyValue.ref nullField;           // src of null
+        final MyBigValue nullfreeBigField;  // not flattened
+        final MyBigValue.ref nullBigField;     // src of null
+
+        public void test() {
+            Asserts.assertNull(nullField, "Invalid non null value for uninitialized non flattenable field");
+            Asserts.assertNull(nullBigField, "Invalid non null value for uninitialized non flattenable field");
+            boolean NPE = false;
+            try {
+                TestInlineType tv = __WithField(this.nullableField, nullField);
+            } catch(NullPointerException e) {
+                NPE = true;
+            }
+            Asserts.assertFalse(NPE, "Invalid NPE when assigning null to a non flattenable field");
+            try {
+                TestInlineType tv = __WithField(this.nullfreeField, (MyValue) nullField);
+            } catch(NullPointerException e) {
+                NPE = true;
+            }
+            Asserts.assertTrue(NPE, "Missing NPE when assigning null to a flattened field");
+            try {
+                TestInlineType tv = __WithField(this.nullfreeBigField, (MyBigValue) nullBigField);
+            } catch(NullPointerException e) {
+                NPE = true;
+            }
+            Asserts.assertTrue(NPE, "Missing NPE when assigning null to a flattenable field");
+        }
+
+        public TestInlineType() {
+            nullableField = MyValue.default;
+            nullfreeField = MyValue.default;
+            nullField = MyValue.default;           // fake assignment
+            nullfreeBigField = MyBigValue.default;
+            nullBigField = MyBigValue.default;     // fake assignment
+
+        }
+    }
+
+    static class TestClass {
+        MyValue.ref nullableField;
+        MyValue nullfreeField;       // flattened
+        MyValue.ref nullField;
+        MyBigValue nullfreeBigField; // not flattened
+        MyBigValue.ref nullBigField;
+
+        public void test() {
+            Asserts.assertNull(nullField, "Invalid non null value for uninitialized non flattenable field");
+            Asserts.assertNull(nullBigField, "Invalid non null value for uninitialized non flattenable field");
+            boolean NPE = false;
+            try {
+                nullableField = nullField;
+            } catch(NullPointerException e) {
+                NPE = true;
+            }
+            Asserts.assertFalse(NPE, "Invalid NPE when assigning null to a non flattenable field");
+            try {
+                this.nullfreeField = (MyValue) nullField;
+            } catch(NullPointerException e) {
+                NPE = true;
+            }
+            Asserts.assertTrue(NPE, "Missing NPE when assigning null to a flattened field");
+            try {
+                this.nullfreeBigField = (MyBigValue) nullBigField;
+            } catch(NullPointerException e) {
+                NPE = true;
+            }
+            Asserts.assertTrue(NPE, "Missing NPE when assigning null to a flattenable field");
+        }
+    }
+
+    public static void main(String[] args) {
+        TestClass tc = new TestClass();
+        tc.test();
+        TestInlineType tv =
+            TestInlineType.default;
+        tv.test();
+    }
+
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestInheritedInlineTypeFields.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestInheritedInlineTypeFields.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestInheritedInlineTypeFields.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test TestInheritedInlineTypeFields
+ * @summary Test if inline field klasses are correctly retrieved for inherited fields
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers Point.java TestInheritedInlineTypeFields.java
+ * @run main/othervm runtime.valhalla.inlinetypes.TestInheritedInlineTypeFields
+ */
+
+class A {
+    Point p;
+}
+
+class B extends A {
+
+}
+
+class C extends B {
+    int i;
+}
+
+class D {
+    long l;
+}
+
+class E extends D {
+    Point p1;
+}
+
+class F extends E {
+
+}
+
+class G extends F {
+    Point p2;
+}
+
+public class TestInheritedInlineTypeFields {
+
+    public static void main(String[] args) {
+        for (int i = 0; i < 100000; i++) {
+            run();
+        }
+    }
+
+    public static void run() {
+        B b = new B();
+        Asserts.assertEquals(b.p.x, 0);
+        Asserts.assertEquals(b.p.y, 0);
+        b.p = Point.createPoint(1,2);
+        Asserts.assertEquals(b.p.x, 1);
+        Asserts.assertEquals(b.p.y, 2);
+
+        G g = new G();
+        Asserts.assertEquals(g.p1.x, 0);
+        Asserts.assertEquals(g.p1.y, 0);
+        Asserts.assertEquals(g.p2.x, 0);
+        Asserts.assertEquals(g.p2.y, 0);
+        g.p1 = Point.createPoint(1,2);
+        g.p2 = Point.createPoint(3,4);
+        Asserts.assertEquals(g.p1.x, 1);
+        Asserts.assertEquals(g.p1.y, 2);
+        Asserts.assertEquals(g.p2.x, 3);
+        Asserts.assertEquals(g.p2.y, 4);
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestJNIArrays.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestJNIArrays.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestJNIArrays.java
@@ -0,0 +1,886 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+import jdk.test.lib.Asserts;
+
+import java.lang.reflect.*;
+import java.util.Random;
+import java.util.Arrays;
+import java.util.Comparator;
+
+import jdk.internal.misc.Unsafe;
+import jdk.internal.vm.jni.SubElementSelector;
+
+/*
+ * @test
+ * @summary Test flattened arrays accesses through JNI
+ * @modules java.base/jdk.internal.misc java.base/jdk.internal.vm.jni
+ * @library /testlibrary /test/lib
+ * @requires (os.simpleArch == "x64")
+ * @requires (os.family == "linux" | os.family == "mac")
+ * @compile -XDallowWithFieldOperator TestJNIArrays.java
+ * @run main/othervm/native/timeout=3000 -XX:FlatArrayElementMaxSize=128 -XX:+UseCompressedOops TestJNIArrays
+ * @run main/othervm/native/timeout=3000 -XX:FlatArrayElementMaxSize=128 -XX:-UseCompressedOops TestJNIArrays
+ */
+public class TestJNIArrays {
+
+    static final Unsafe U = Unsafe.getUnsafe();
+
+    public static final int ARRAY_SIZE = 1024;
+    static long seed;
+    static Random random;
+
+    static {
+        seed = System.nanoTime();
+        System.out.println("Seed = " + seed);
+        random = new Random(seed);
+    }
+
+    static {
+        System.loadLibrary("TestJNIArrays");
+    }
+
+    static inline class IntInt {
+        int i0;
+        int i1;
+
+        public IntInt(int i0, int i1) {
+            this.i0 = i0;
+            this.i1 = i1;
+        }
+    }
+
+    static class IntIntComparator implements Comparator<IntInt.ref> {
+        public int compare(IntInt.ref a, IntInt.ref b) {
+            if (a.i0 < b.i0) return -1;
+            if (a.i0 > b.i0) return 1;
+            if (a.i1 < b.i1) return -1;
+            if (a.i1 > b.i1) return 1;
+            return 0;
+        }
+    }
+
+    static inline class Containee {
+        float f;
+        short s;
+
+        Containee(float f, short s) {
+            this.f = f;
+            this.s = s;
+        }
+    }
+
+    static inline class Container {
+        double d;
+        Containee c;
+        byte b;
+
+        Container(double d, Containee c, byte b) {
+            this.d = d ;
+            this.c = c;
+            this.b = b;
+        }
+
+        Container setc(Containee c) {
+            Container res = __WithField(this.c, c);
+            return res;
+        }
+
+    }
+
+    static inline class LongLongLongLong {
+        long l0, l1, l2, l3;
+
+        public LongLongLongLong(long l0, long l1, long l2, long l3) {
+            this.l0 = l0;
+            this.l1 = l1;
+            this.l2 = l2;
+            this.l3 = l3;
+        }
+    }
+
+    static inline class BigValue {
+        long l0 = 0, l1 = 0,   l2 = 0, l3 = 0, l4 = 0, l5 = 0, l6 = 0, l7 = 0, l8 = 0, l9 = 0;
+        long l10 = 0, l11 = 0, l12 = 0, l13 = 0, l14 = 0, l15 = 0, l16 = 0, l17 = 0, l18 = 0, l19 = 0;
+        long l20 = 0, l21 = 0, l22 = 0, l23 = 0, l24 = 0, l25 = 0, l26 = 0, l27 = 0, l28 = 0, l29 = 0;
+        long l30 = 0, l31 = 0, l32 = 0, l33 = 0, l34 = 0, l35 = 0, l36 = 0, l37 = 0, l38 = 0, l39 = 0;
+    }
+
+    static inline class InlineWithOops {
+        String s = "bonjour";
+        int i = 0;
+        Containee c = new Containee(2.3f, (short)4);
+        BigValue b = new BigValue();
+    }
+
+    public static void main(String[] args) {
+        TestJNIArrays test = new TestJNIArrays();
+        test.checkGetFlattenedArrayElementSize();
+        test.checkGetFlattenedArrayElementClass();
+        test.checkGetFieldOffsetInFlattenedLayout();
+        test.checkGetFlattenedArrayElements();
+        test.checkSubElementAPI();
+        test.checkBehaviors();
+
+        // TODO: move these to micro-benchmark or out of tier1 testing...
+        // test.measureInitializationTime(1024 * 1024 * 10 , 1000);
+        // test.measureInitializationTime2(1024 * 1024 * 10 , 1000);
+        // test.measureUpdateTime2(1024 * 1024 * 10, 1000);
+        // test.measureSortingTime(1024 * 1024, 100); // reduced number of iterations because Java sorting is slow (because of generics?)
+        //test.measureInitializationTime3(1024 * 1024 * 2 , 10);
+    }
+
+    void checkSubElementAPI() {
+        Throwable e = null;
+        InlineWithOops[] arrayWithOops = new InlineWithOops[100];
+        InlineWithOops v = new InlineWithOops();
+        for (int i = 0; i < 100; i++) {
+            arrayWithOops[i] = v;
+        }
+        SubElementSelector selector1 = createSubElementSelector(arrayWithOops);
+        SubElementSelector selector2 = getSubElementSelector(selector1, InlineWithOops.class, "s", "Ljava/lang/String;");
+        String s = (String) getObjectSubElement(arrayWithOops, selector2, 1);
+        System.out.println("s = " + s);
+        Asserts.assertEquals(s.equals("bonjour"), true, "Wrong string, expecting \"bonjour\", got " + s);
+        SubElementSelector selector3 = getSubElementSelector(selector1, InlineWithOops.class, "c", "QTestJNIArrays$Containee;");
+        Containee c = (Containee) getObjectSubElement(arrayWithOops, selector3, 2);
+        Asserts.assertEquals(c.f, 2.3f, "Wrong float value: " + c.f);
+        Asserts.assertEquals(c.s, (short)4, "Wrong short value " + c.s);
+        setObjectSubElement(arrayWithOops, selector2, 1, "Hello");
+        Asserts.assertEquals(arrayWithOops[1].s.equals("Hello"), true, "Wrong string, expecting \"Hello\", got " + s);
+        Integer myInteger = new Integer(345);
+        e = null;
+        try {
+            setObjectSubElement(arrayWithOops, selector2, 1, myInteger);
+        } catch(Throwable t) {
+            e = t;
+        }
+        Asserts.assertNotNull(e, "An exception should have been thrown");
+        Asserts.assertEquals(e.getClass(), java.lang.ArrayStoreException.class, "Wrong exception type");
+        c = new Containee(9.8f, (short)-3);
+        setObjectSubElement(arrayWithOops, selector3, 2, c);
+        Asserts.assertEquals(c.f, 9.8f, "Wrong float value: " + c.f);
+        Asserts.assertEquals(c.s, (short)-3, "Wrong short value " + c.s);
+        e = null;
+        try {
+            setObjectSubElement(arrayWithOops, selector3, 2, null);
+        } catch(Throwable t) {
+            e = t;
+        }
+        Asserts.assertNotNull(e, "An exception should have been thrown");
+        Asserts.assertEquals(e.getClass(), java.lang.ArrayStoreException.class, "Wrong exception type");
+        SubElementSelector selector4 = getSubElementSelector(selector3, TestJNIArrays.Containee.class, "s", "S");
+        short s2 = getShortSubElement(arrayWithOops, selector4, 3);
+        Asserts.assertEquals(s2, (short)4, "Wrong short value " + s2);
+        setShortSubElement(arrayWithOops, selector4, 3, (short)7);
+        Asserts.assertEquals(arrayWithOops[3].c.s, (short)7, "Wrong short value " + arrayWithOops[3].c.s);
+        e = null;
+        try {
+            // should fail because selector4 designates a field with type short, not int
+            getIntSubElement(arrayWithOops, selector4, 3);
+        } catch(Throwable t) {
+            e = t;
+        }
+        Asserts.assertNotNull(e, "An exception should have been thrown");
+        Asserts.assertEquals(e.getClass(), java.lang.IllegalArgumentException.class, "Wrong exception type");
+        SubElementSelector selector5 = getSubElementSelector(selector1, InlineWithOops.class, "b", "QTestJNIArrays$BigValue;");
+        e = null;
+        try {
+            // Should fail because selector5 designates a non-flattened field
+            SubElementSelector selector6 = getSubElementSelector(selector5, TestJNIArrays.BigValue.class, "l0", "J");
+        } catch(Throwable t) {
+            e = t;
+        }
+        Asserts.assertNotNull(e, "An exception should have been thrown");
+        Asserts.assertEquals(e.getClass(), java.lang.IllegalArgumentException.class, "Wrong exception type");
+        System.gc();
+    }
+
+    void checkGetFlattenedArrayElementSize() {
+        Throwable exception = null;
+        try {
+            Object o = new Object();
+            GetFlattenedArrayElementSizeWrapper(o);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            int[] array = new int[16];
+            Object o = array;
+            GetFlattenedArrayElementSizeWrapper(o);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            GetFlattenedArrayElementSizeWrapper(new String[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            // Array of BigValue should not be flattened because BigValue is *big*
+            GetFlattenedArrayElementSizeWrapper(new BigValue[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertTrue(exception instanceof IllegalArgumentException , "Exception should be a IAE");
+        exception = null;
+        int size = -1;
+        try {
+            size = GetFlattenedArrayElementSizeWrapper(new IntInt[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNull(exception, "No exception should have been thrown");
+        Asserts.assertEquals(size, 8, "Wrong size");
+    }
+
+    void checkGetFlattenedArrayElementClass() {
+        Throwable exception = null;
+        try {
+            Object o = new Object();
+            GetFlattenedArrayElementClassWrapper(o);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            int[] array = new int[16];
+            Object o = array;
+            GetFlattenedArrayElementClassWrapper(o);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            GetFlattenedArrayElementClassWrapper(new String[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            // Array of BigValue should not be flattened because BigValue is *big*
+            GetFlattenedArrayElementClassWrapper(new BigValue[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertTrue(exception instanceof IllegalArgumentException , "Exception should be a IAE");
+        exception = null;
+        Class c = null;
+        try {
+            c = GetFlattenedArrayElementClassWrapper(new IntInt[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNull(exception, "No exception should have been thrown");
+        Asserts.assertEquals(c, IntInt.class, "Wrong class");
+    }
+
+    void checkGetFieldOffsetInFlattenedLayout() {
+        Throwable exception = null;
+        try {
+            Object o = new Object();
+            GetFieldOffsetInFlattenedLayoutWrapper(o.getClass(), "foo", "I", true);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            int[] array = new int[16];
+            GetFieldOffsetInFlattenedLayoutWrapper(array.getClass(), "foo", "I", true);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            String[] array = new String[16];
+            GetFieldOffsetInFlattenedLayoutWrapper(array.getClass(), "foo", "I", true);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        Containee ce  = new Containee(3.4f, (short)5);
+        Container c = new Container(123.876, ce, (byte)7);
+        Class<?> cclass = c.getClass();
+        Container[] containerArray = new Container[32];
+        int elementSize = GetFlattenedArrayElementSizeWrapper(containerArray);
+        int offset = -1;
+        try {
+            offset = GetFieldOffsetInFlattenedLayoutWrapper(cclass, "d", "D", false);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNull(exception, "No exception should have been thrown");
+        Field f = null;
+        try {
+            f = cclass.getDeclaredField("d");
+        } catch(NoSuchFieldException e) {
+            e.printStackTrace();
+            return;
+        }
+        Asserts.assertEquals(U.valueHeaderSize(cclass) + offset, U.objectFieldOffset(cclass, f.getName()),
+                             "Incorrect offset");
+        Asserts.assertLessThan(offset, elementSize, "Invalid offset");
+        exception = null;
+        try {
+            // Field c should be flattened, so last argument is true, no exception expected
+            GetFieldOffsetInFlattenedLayoutWrapper(cclass, "c", "QTestJNIArrays$Containee;", true);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNull(exception, "No exception should have been thrown");
+        Asserts.assertLessThan(offset, elementSize, "Invalid offset");
+        exception = null;
+        try {
+            // Field c should be flattened, with last argument being false, exception expected from the wrapper
+            GetFieldOffsetInFlattenedLayoutWrapper(cclass, "c", "QTestJNIArrays$Containee;", false);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "Wrapper should have thrown a RuntimeException");
+        Asserts.assertEquals(exception.getClass(), RuntimeException.class , "Wrong exception type");
+    }
+
+    void checkGetFlattenedArrayElements() {
+        Throwable exception = null;
+        Object o = new Object();
+        try {
+            GetFlattenedArrayElementsWrapper(o);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        int[] a1 = new int[16];
+        o = a1;
+        try {
+            GetFlattenedArrayElementsWrapper(o);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            GetFlattenedArrayElementsWrapper(new String[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
+        exception = null;
+        try {
+            // Array of BigValue should not be flattened because BigValue is *big*
+            GetFlattenedArrayElementsWrapper(new BigValue[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertTrue(exception instanceof IllegalArgumentException , "Exception should be a IAE");
+        exception = null;
+        try {
+            // Direct native access to flattened arrays is not allowed if elements contain oops
+            GetFlattenedArrayElementsWrapper(new InlineWithOops[16]);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNotNull(exception, "An IAE should have been thrown");
+        Asserts.assertTrue(exception instanceof IllegalArgumentException , "Exception should be a IAE");
+        exception = null;
+        long addr = 0;
+        IntInt[] a2 = new IntInt[16];
+        try {
+            addr = GetFlattenedArrayElementsWrapper(a2);
+        } catch(Throwable t) {
+            exception = t;
+        }
+        Asserts.assertNull(exception, "No exception should have been thrown");
+        if (exception == null) {
+            ReleaseFlattenedArrayElementsWrapper(a2, addr, 0);
+        }
+    }
+
+    void checkBehaviors() {
+        System.out.println("Check 1");
+        IntInt[] array = new IntInt[ARRAY_SIZE];
+        int value = getIntFieldAtIndex(array, 1, "i0", "I");
+        Asserts.assertEquals(value, 0, "Initial value must be zero");
+        printArrayInformation(array);
+        int i0_value = 42;
+        int i1_value = -314;
+        initializeIntIntArrayBuffer(array, i0_value, i1_value);
+        System.gc();
+        for (int i = 0; i < array.length; i++) {
+            Asserts.assertEquals(array[i].i0, i0_value, "Bad value of i0 at index " + i);
+            Asserts.assertEquals(array[i].i1, i1_value, "Bad value of i1 at index " + i);
+        }
+        System.out.println("Check 2");
+        array = new IntInt[ARRAY_SIZE];
+        i0_value = -194;
+        i1_value = 91;
+        initializeIntIntArrayFields(array, i0_value, i1_value);
+        System.gc();
+        for (int i = 0; i < array.length; i++) {
+            Asserts.assertEquals(array[i].i0, i0_value, "Bad value of i0 at index " + i);
+            Asserts.assertEquals(array[i].i1, i1_value, "Bad value of i1 at index " + i);
+        }
+        System.out.println("Check 3");
+        array = new IntInt[ARRAY_SIZE];
+        initializeIntIntArrayJava(array, i0_value, i1_value);
+        System.gc();
+        for (int i = 0; i < array.length; i++) {
+            Asserts.assertEquals(array[i].i0, i0_value, "Bad value of i0 at index " + i);
+            Asserts.assertEquals(array[i].i1, i1_value, "Bad value of i1 at index " + i);
+        }
+        System.out.println("Check 4");
+        random = new Random(seed);
+        array = new IntInt[ARRAY_SIZE];
+        for (int i = 0; i < ARRAY_SIZE; i++) {
+            array[i] = new IntInt(random.nextInt(), random.nextInt());
+        }
+        sortIntIntArray(array);
+        System.gc();
+        for (int i = 0; i < array.length - 1; i++) {
+            Asserts.assertLessThanOrEqual(array[i].i0, array[i+1].i0, "Incorrect i0 fields ordering at index " + i);
+            if (array[i].i0 == array[i+1].i0) {
+                Asserts.assertLessThanOrEqual(array[i].i1, array[i+1].i1, "Incorrect i1 fields ordering at index " + i);
+            }
+        }
+        System.out.println("Check 5");
+        random = new Random(seed);
+        array = new IntInt[ARRAY_SIZE];
+        for (int i = 0; i < ARRAY_SIZE; i++) {
+            array[i] = new IntInt(random.nextInt(), random.nextInt());
+        }
+        Arrays.sort(array, new IntIntComparator());
+        System.gc();
+        for (int i = 0; i < array.length - 1; i++) {
+            Asserts.assertLessThanOrEqual(array[i].i0, array[i+1].i0, "Incorrect i0 fields ordering at index " + i);
+            if (array[i].i0 == array[i+1].i0) {
+                Asserts.assertLessThanOrEqual(array[i].i1, array[i+1].i1, "Incorrect i1 fields ordering at index " + i);
+            }
+        }
+        System.out.println("Check 6");
+        Container[] array2 = new Container[ARRAY_SIZE];
+        double d  = 1.23456789;
+        float f = -987.654321f;
+        short s = -512;
+        byte b = 127;
+        Containee c = new Containee(f,s);
+        Container c2 = new Container(d, c, b);
+        initializeContainerArray(array2, d, f, s, b);
+        System.gc();
+        for (int i = 0; i < array2.length; i++) {
+            Asserts.assertEquals(array2[i], c2, "Incorrect value at index " + i);
+            Asserts.assertEquals(array2[i].d, d, "Incorrect d value at index " + i);
+            Asserts.assertEquals(array2[i].c.f, f, "Incorrect f value at index " + i);
+            Asserts.assertEquals(array2[i].c.s, s, "Incorrect s value at index " + i);
+            Asserts.assertEquals(array2[i].b, b, "Incorrect b value at inde " +i);
+        }
+        System.out.println("Check 7");
+        f = 19.2837465f;
+        s = 231;
+        updateContainerArray(array2, f, s);
+        System.gc();
+        for (int i = 0; i < array2.length; i++) {
+            Asserts.assertEquals(array2[i].d, d, "Incorrect d value at index " + i);
+            Asserts.assertEquals(array2[i].c.f, f, "Incorrect f value at index " + i);
+            Asserts.assertEquals(array2[i].c.s, s, "Incorrect s value at index " + i);
+            Asserts.assertEquals(array2[i].b, b, "Incorrect b value at inde " +i);
+        }
+        System.out.println("Check 8");
+        long l0 = 52467923;
+        long l1= -7854022;
+        long l2 = 230947485;
+        long l3 = -752497024;
+        LongLongLongLong[] array3 = new LongLongLongLong[ARRAY_SIZE/8];
+        initializeLongLongLongLongArray(array3, l0, l1, l2, l3);
+        System.gc();
+        for (int i = 0; i < array3.length; i++) {
+            Asserts.assertEquals(array3[i].l0, l0, "Bad value of l0 at index " + i);
+            Asserts.assertEquals(array3[i].l1, l1, "Bad value of l1 at index " + i);
+            Asserts.assertEquals(array3[i].l2, l2, "Bad value of l2 at index " + i);
+            Asserts.assertEquals(array3[i].l3, l3, "Bad value of l3 at index " + i);
+        }
+    }
+
+    void initializeIntIntArrayJava(IntInt[] array, int i0, int i1) {
+        IntInt ii = new IntInt(i0, i1);
+        for (int i = 0; i < array.length; i++) {
+            array[i] = ii;
+        }
+    }
+
+    void initializeContainerArrayJava(Container[] array, double d, float f, short s, byte b) {
+        Containee c = new Containee(f,s);
+        Container c2 = new Container(d, c, b);
+        for (int i = 0; i < array.length; i++) {
+            array[i] = c2;
+        }
+    }
+
+    void updateContainerArrayJava(Container[] array, float f, short s) {
+        Containee c = new Containee(f, s);
+        for (int i = 0; i < array.length; i++) {
+            array[i] = array[i].setc(c);;
+        }
+    }
+
+    void initializeLongLongLongLongArrayJava(LongLongLongLong[] array, long l0, long l1, long l2, long l3) {
+        LongLongLongLong llll = new LongLongLongLong(l0, l1, l2, l3);
+        for (int i = 0; i < array.length; i++) {
+            array[i] = llll;
+        }
+    }
+
+    void measureInitializationTime(int array_size, int iterations) {
+        System.out.println("\nInitialization time for IntInt[]:");
+        long[] start = new long[iterations];
+        long[] end = new long[iterations];
+
+
+        System.out.println("\nJava:");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            IntInt[] array = new IntInt[array_size];
+            initializeIntIntArrayJava(array, 42, -314);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            IntInt[] array = new IntInt[array_size];
+            start[i] = System.nanoTime();
+            initializeIntIntArrayJava(array, 42, -314);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+
+        System.out.println("\nNative(memcpy):");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            IntInt[] array = new IntInt[array_size];
+            initializeIntIntArrayBuffer(array, 42, -314);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            IntInt[] array = new IntInt[array_size];
+            start[i] = System.nanoTime();
+            initializeIntIntArrayBuffer(array, 42, -314);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+
+
+        System.out.println("\nNative(fields):");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            IntInt[] array = new IntInt[array_size];
+            initializeIntIntArrayFields(array, 42, -314);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            IntInt[] array = new IntInt[array_size];
+            start[i] = System.nanoTime();
+            initializeIntIntArrayFields(array, 42, -314);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+    }
+
+    void measureInitializationTime2(int array_size, int iterations) {
+        System.out.println("\nInitialization time for Container[]:");
+        long[] start = new long[iterations];
+        long[] end = new long[iterations];
+
+        double d = 0.369852147;
+        float f = -321.654987f;
+        short s = -3579;
+        byte b = 42;
+
+        System.out.println("\nJava:");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            Container[] array = new Container[array_size];
+            initializeContainerArrayJava(array, d, f, s, b);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            Container[] array = new Container[array_size];
+            start[i] = System.nanoTime();
+            initializeContainerArrayJava(array, d, f, s, b);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+
+        System.out.println("\nNative:");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            Container[] array = new Container[array_size];
+            initializeContainerArray(array, d, f, s, b);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            Container[] array = new Container[array_size];
+            start[i] = System.nanoTime();
+            initializeContainerArray(array, d, f, s, b);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+    }
+
+    void measureUpdateTime2(int array_size, int iterations) {
+        System.out.println("\nUpdating Container[]:");
+        long[] start = new long[iterations];
+        long[] end = new long[iterations];
+
+        double d = 0.369852147;
+        float f = -321.654987f;
+        short s = -3579;
+        byte b = 42;
+
+        Containee c = new Containee(f,s);
+        Container c2 = new Container(d, c, b);
+
+        System.out.println("\nJava:");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            Container[] array = new Container[array_size];
+            for (int j = 0; j < array.length; j++) {
+                array[j] = c2;
+            }
+            updateContainerArrayJava(array, f, s);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            Container[] array = new Container[array_size];
+            for (int j = 0; j < array.length; j++) {
+                array[i] = c2;
+            }
+            start[i] = System.nanoTime();
+            updateContainerArrayJava(array, f, s);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+
+        System.out.println("\nNative:");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            Container[] array = new Container[array_size];
+            for (int j = 0; j < array.length; j++) {
+                array[i] = c2;
+            }
+            updateContainerArray(array, f, s);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            Container[] array = new Container[array_size];
+            for (int j = 0; j < array.length; j++) {
+                array[i] = c2;
+            }
+            start[i] = System.nanoTime();
+            updateContainerArray(array, f, s);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+    }
+
+    void measureSortingTime(int array_size, int iterations) {
+        System.out.println("\nSorting time:");
+        long[] start = new long[iterations];
+        long[] end = new long[iterations];
+
+        random = new Random(seed);
+        System.out.println("\nJava:");
+        IntIntComparator comparator = new IntIntComparator();
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            IntInt[] array = new IntInt[array_size];
+            array = new IntInt[array_size];
+            for (int j = 0; j < array_size; j++) {
+                array[j] = new IntInt(random.nextInt(), random.nextInt());
+            }
+            Arrays.sort(array, comparator);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            IntInt[] array = new IntInt[array_size];
+            for (int j = 0; j < array_size; j++) {
+                array[j] = new IntInt(random.nextInt(), random.nextInt());
+            }
+            start[i] = System.nanoTime();
+            Arrays.sort(array, comparator);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+
+        random = new Random(seed);
+        System.out.println("\nNative:");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            IntInt[] array = new IntInt[array_size];
+            array = new IntInt[array_size];
+            for (int j = 0; j < array_size; j++) {
+                array[j] = new IntInt(random.nextInt(), random.nextInt());
+            }
+            sortIntIntArray(array);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            IntInt[] array = new IntInt[array_size];
+            for (int j = 0; j < array_size; j++) {
+                array[j] = new IntInt(random.nextInt(), random.nextInt());
+            }
+            start[i] = System.nanoTime();
+            sortIntIntArray(array);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+    }
+
+
+    void measureInitializationTime3(int array_size, int iterations) {
+        System.out.println("\nInitialization time for LongLongLongLong[]:");
+        long[] start = new long[iterations];
+        long[] end = new long[iterations];
+
+        long l0 = 123456;
+        long l1 = -987654;
+        long l2 = 192837;
+        long l3 = -56473829;
+
+        System.out.println("\nJava:");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            LongLongLongLong[] array = new LongLongLongLong[array_size];
+            initializeLongLongLongLongArrayJava(array, l0, l1, l2, l3);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            LongLongLongLong[] array = new LongLongLongLong[array_size];
+            start[i] = System.nanoTime();
+            initializeLongLongLongLongArrayJava(array, l0, l1, l2, l3);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+
+        System.out.println("\nNative:");
+        // Warmup
+        for (int i = 0; i < 10; i++) {
+            LongLongLongLong[] array = new LongLongLongLong[array_size];
+            initializeLongLongLongLongArray(array, l0, l1, l2, l3);
+        }
+        // Measure
+        for (int i = 0; i < iterations; i++) {
+            LongLongLongLong[] array = new LongLongLongLong[array_size];
+            start[i] = System.nanoTime();
+            initializeLongLongLongLongArray(array, l0, l1, l2, l3);
+            end[i] = System.nanoTime();
+        }
+        // Results
+        computeStatistics(start, end);
+    }
+
+    void computeStatistics(long[] start, long[] end) {
+        int iterations = start.length;
+        long[] duration = new long[iterations];
+        long sum = 0;
+        long min = end[0] - start[0];
+        long max = min;
+        double var = 0.0;
+        for (int i = 0 ; i < iterations; i++) {
+            duration[i] = end[i] - start[i];
+            if (duration[i] < min) min = duration[i];
+            if (duration[i] > max) max = duration[i];
+            sum += duration[i];
+            double d = (double) duration[i];
+            var += Math.pow(d, 2);
+        }
+        double avg = (sum/iterations) / 1000;
+        double std = (Math.sqrt(var/iterations - Math.pow(sum/iterations, 2))) / 1000;
+        System.out.println(String.format("Avg: %8.2f us", avg));
+        System.out.println(String.format("Std: %8.2f us", std));
+        System.out.println(String.format("Min: %8d us", (min/1000)));
+        System.out.println(String.format("Max: %8d us", (max/1000)));
+    }
+
+    native int GetFlattenedArrayElementSizeWrapper(Object array);
+    native Class GetFlattenedArrayElementClassWrapper(Object array);
+    native long GetFlattenedArrayElementsWrapper(Object array);
+    native void ReleaseFlattenedArrayElementsWrapper(Object array, long addr,int mode);
+    native int GetFieldOffsetInFlattenedLayoutWrapper(Class klass, String name, String signature, boolean flattened);
+
+    native int getIntFieldAtIndex(Object[] array, int index, String fieldName, String FieldSignature);
+    native void printArrayInformation(Object[] array);
+
+    native void initializeIntIntArrayBuffer(Object[] array, int i0, int i1);
+    native void initializeIntIntArrayFields(Object[] array, int i0, int i1);
+    native void sortIntIntArray(Object[] array);
+
+    native void initializeContainerArray(Object[] array, double d, float f, short s, byte b);
+    native void updateContainerArray(Object[] array, float f, short s);
+
+    native void initializeLongLongLongLongArray(Object[] array, long l0, long l1, long l2, long l3);
+
+    native SubElementSelector createSubElementSelector(Object[] array);
+    native SubElementSelector getSubElementSelector(SubElementSelector selector, Class<?> klass, String name, String signature);
+    native Object getObjectSubElement(Object[] array, SubElementSelector selector, int index);
+    native void setObjectSubElement(Object[] array, SubElementSelector selector, int index, Object value);
+
+    native short getShortSubElement(Object[] array, SubElementSelector selector, int index);
+    native void setShortSubElement(Object[] array, SubElementSelector selector, int index, short value);
+    native int getIntSubElement(Object[] array, SubElementSelector selector, int index);
+    native void setIntSubElement(Object[] array, SubElementSelector selector, int index, int value);
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestJNIIsSameObject.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestJNIIsSameObject.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestJNIIsSameObject.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+import jdk.test.lib.Asserts;
+
+
+/*
+ * @test
+ * @summary Test JNI IsSameObject semantic with inline types
+ * @library /testlibrary /test/lib
+ * @requires (os.simpleArch == "x64")
+ * @requires (os.family == "linux" | os.family == "mac")
+ * @run main/othervm/native TestJNIIsSameObject
+ */
+public class TestJNIIsSameObject {
+  static inline class Value {
+    int i;
+
+    public Value(int i) {
+      this.i = i;
+    }
+  }
+  native static boolean isSameObject(Object o0, Object o1);
+
+  static {
+    System.loadLibrary("JNIIsSameObject");
+  }
+
+  public static void main(String[] args) {
+    // Same value in different instances
+    Value v0 = new Value(3);
+    Value v1 = new Value(3);
+    Asserts.assertTrue(isSameObject(v0, v1));
+
+    // Different values
+    Value v2 = new Value(4);
+    Asserts.assertFalse(isSameObject(v0, v2));
+
+    // Same object
+    TestJNIIsSameObject t0 = new TestJNIIsSameObject();
+    Object o = t0;
+    Asserts.assertTrue(isSameObject(t0, o));
+
+    // Different objects
+    TestJNIIsSameObject t1 = new TestJNIIsSameObject();
+    Asserts.assertFalse(isSameObject(t0, t1));
+
+    // Comparing against null
+    Asserts.assertFalse(isSameObject(v0, null));
+    Asserts.assertFalse(isSameObject(null, v0));
+    Asserts.assertFalse(isSameObject(t0, null));
+    Asserts.assertFalse(isSameObject(null, t0));
+
+    // Object vs inline
+    Asserts.assertFalse(isSameObject(v0, t0));
+    Asserts.assertFalse(isSameObject(t0, v0));
+
+  }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue1.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue1.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue1.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+final class ContainerValue1 {
+    static TestValue1.ref staticInlineField;
+    TestValue1 nonStaticInlineField;
+    TestValue1[] inlineArray;
+}
+
+public inline final class TestValue1 {
+
+    static TestValue1.ref staticValue = getInstance();
+
+    final int i;
+    final String name;
+
+    private TestValue1() {
+        i = (int)System.nanoTime();
+        name = Integer.valueOf(i).toString();
+    }
+
+    public static TestValue1 create(int i) {
+        TestValue1 v = TestValue1.default;
+        v = __WithField(v.i, i);
+        v = __WithField(v.name, Integer.valueOf(i).toString());
+        return v;
+    }
+
+    public static TestValue1 create() {
+        TestValue1 v = TestValue1.default;
+        v = __WithField(v.i, (int)System.nanoTime());
+        v = __WithField(v.name, Integer.valueOf(v.i).toString());
+        return v;
+    }
+
+    public static TestValue1 getInstance() {
+        return create();
+    }
+
+    public static TestValue1 getNonBufferedInstance() {
+        return (TestValue1) staticValue;
+    }
+
+    public boolean verify() {
+        if (name == null) return i == 0;
+        return Integer.valueOf(i).toString().compareTo(name) == 0;
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue2.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue2.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue2.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+final class ContainerValue2 {
+    static TestValue2.ref staticInlineField;
+    TestValue2 nonStaticInlineField;
+    TestValue2[] valueArray;
+}
+
+public inline final class TestValue2 {
+    static TestValue2.ref staticValue = getInstance();
+
+    final long l;
+    final double d;
+    final String s;
+
+    private TestValue2() {
+        l = System.nanoTime();
+        s = Long.valueOf(l).toString();
+        d = Double.parseDouble(s);
+    }
+
+    public static TestValue2 create(long l) {
+        TestValue2 v = TestValue2.default;
+        v = __WithField(v.l, l);
+        v = __WithField(v.s, Long.valueOf(l).toString());
+        v = __WithField(v.d, Double.parseDouble(v.s));
+        return v;
+    }
+
+    public static TestValue2 create() {
+        TestValue2 v = TestValue2.default;
+        v = __WithField(v.l, System.nanoTime());
+        v = __WithField(v.s, Long.valueOf(v.l).toString());
+        v = __WithField(v.d, Double.parseDouble(v.s));
+        return v;
+    }
+
+    public static TestValue2 getInstance() {
+        return create();
+    }
+
+    public static TestValue2 getNonBufferedInstance() {
+        return (TestValue2) staticValue;
+    }
+
+    public boolean verify() {
+        if (s == null) {
+            return d == 0 && l == 0;
+        }
+        return Long.valueOf(l).toString().compareTo(s) == 0
+                && Double.parseDouble(s) == d;
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue3.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue3.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue3.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+final class ContainerValue3 {
+    static TestValue3.ref staticInlineField;
+    TestValue3 nonStaticInlineField;
+    TestValue3[] valueArray;
+}
+
+public inline final class TestValue3 {
+
+    static TestValue3.ref staticValue = getInstance();
+
+    final byte b;
+
+    private TestValue3() {
+        b = 123;
+    }
+
+    public static TestValue3 create(byte b) {
+        TestValue3 v = TestValue3.default;
+        v = __WithField(v.b, b);
+        return v;
+    }
+
+    public static TestValue3 create() {
+        TestValue3 v = TestValue3.default;
+        v = __WithField(v.b, 123);
+        return v;
+    }
+
+    public static TestValue3 getInstance() {
+        return create();
+    }
+
+    public static TestValue3 getNonBufferedInstance() {
+        return (TestValue3) staticValue;
+    }
+
+    public boolean verify() {
+        return b == 0 || b == 123;
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue4.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue4.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/TestValue4.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import java.nio.ByteBuffer;
+
+final class ContainerValue4 {
+    static TestValue4.ref staticInlineField;
+    TestValue4 nonStaticInlineField;
+    TestValue4[] valueArray;
+}
+
+public inline final class TestValue4 {
+
+    static TestValue4.ref staticValue = getInstance();
+
+    final byte b1;
+    final byte b2;
+    final byte b3;
+    final byte b4;
+    final short s1;
+    final short s2;
+    final int i;
+    final long l;
+    final String val;
+
+    private TestValue4() {
+        i = (int)System.nanoTime();
+        val = Integer.valueOf(i).toString();
+        l = ((long)i) << Integer.SIZE | i;
+        s1 = (short)(i & ~Short.MIN_VALUE);
+        s2 = (short)(i >> Short.SIZE);
+        b1 = (byte)(i & ~Byte.MIN_VALUE);
+        b2 = (byte)((i >> Byte.SIZE) & ~Byte.MIN_VALUE);
+        b3 = (byte)((i >> (2 * Byte.SIZE)) & ~Byte.MIN_VALUE);
+        b4 = (byte)((i >> (3 * Byte.SIZE)) & ~Byte.MIN_VALUE);
+    }
+
+    public static TestValue4 create(int i) {
+        TestValue4 v = TestValue4.default;
+        v = __WithField(v.i, i);
+        v = __WithField(v.val, Integer.valueOf(i).toString());
+        ByteBuffer bf = ByteBuffer.allocate(8);
+        bf.putInt(0, i);
+        bf.putInt(4, i);
+        v = __WithField(v.l, bf.getLong(0));
+        v = __WithField(v.s1, bf.getShort(2));
+        v = __WithField(v.s2, bf.getShort(0));
+        v = __WithField(v.b1, bf.get(3));
+        v = __WithField(v.b2, bf.get(2));
+        v = __WithField(v.b3, bf.get(1));
+        v = __WithField(v.b4, bf.get(0));
+        return v;
+    }
+
+    public static TestValue4 create() {
+        return create((int)System.nanoTime());
+    }
+
+    public static TestValue4 getInstance() {
+        return create();
+    }
+
+    public static TestValue4 getNonBufferedInstance() {
+        return (TestValue4) staticValue;
+    }
+
+    public boolean verify() {
+        if (val == null) {
+            return i == 0 && l == 0 && b1 == 0 && b2 == 0 && b3 == 0 && b4 == 0
+                    && s1 == 0 && s2 == 0;
+        }
+        ByteBuffer bf = ByteBuffer.allocate(8);
+        bf.putInt(0, i);
+        bf.putInt(4, i);
+        long nl =  bf.getLong(0);
+        bf.clear();
+        bf.putShort(0, s2);
+        bf.putShort(2, s1);
+        int from_s = bf.getInt(0);
+        bf.clear();
+        bf.put(0, b4);
+        bf.put(1, b3);
+        bf.put(2, b2);
+        bf.put(3, b1);
+        int from_b = bf.getInt(0);
+        return l == nl && Integer.valueOf(i).toString().compareTo(val) == 0
+                && from_s == i && from_b == i;
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/UninitializedInlineFieldsTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/UninitializedInlineFieldsTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/UninitializedInlineFieldsTest.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test
+ * @summary Uninitialized inline fields test
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers Point.java JumboInline.java UninitializedInlineFieldsTest.java
+ * @run main/othervm -Xint -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.inlinetypes.UninitializedInlineFieldsTest
+ * @run main/othervm -Xcomp -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.inlinetypes.UninitializedInlineFieldsTest
+ */
+public class UninitializedInlineFieldsTest {
+    static Point.ref nonFlattenableStaticPoint;
+    static Point staticPoint;
+
+    Point instancePoint;
+
+    static JumboInline.ref sj1;
+    static JumboInline sj2;
+
+    JumboInline.ref j1;
+    JumboInline j2;
+
+    static Object getNull() {
+        return null;
+    }
+
+    UninitializedInlineFieldsTest() { }
+
+    public static void main(String[] args) {
+        checkUninitializedPoint(UninitializedInlineFieldsTest.staticPoint, 0, 0);
+        Asserts.assertEquals(nonFlattenableStaticPoint, null, "invalid non flattenable static inline field");
+        UninitializedInlineFieldsTest.staticPoint = Point.createPoint(456, 678);
+        checkUninitializedPoint(UninitializedInlineFieldsTest.staticPoint, 456, 678);
+        UninitializedInlineFieldsTest test = new UninitializedInlineFieldsTest();
+        checkUninitializedPoint(test.instancePoint, 0, 0);
+        test.instancePoint = Point.createPoint(123, 345);
+        checkUninitializedPoint(test.instancePoint, 123, 345);
+
+        Asserts.assertEquals(test.j1, null, "invalid non flattenable instance inline field");
+        Asserts.assertEquals(test.j2.l0, 0L, "invalid flattenable instance inline field");
+    }
+
+    static void checkUninitializedPoint(Point p, int x, int y) {
+        Asserts.assertEquals(p.x, x, "invalid x value");
+        Asserts.assertEquals(p.y, y, "invalid y value");
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/UnsafeTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/UnsafeTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/UnsafeTest.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+/*
+ * @test UnsafeTest
+ * @summary unsafe get/put/with inline type
+ * @modules java.base/jdk.internal.misc
+ * @library /test/lib
+ * @compile -XDallowWithFieldOperator Point.java UnsafeTest.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.UnsafeTest
+ * @run main/othervm -Xcomp runtime.valhalla.inlinetypes.UnsafeTest
+ */
+
+import jdk.internal.misc.Unsafe;
+
+import java.lang.reflect.*;
+import java.util.List;
+import static jdk.test.lib.Asserts.*;
+
+public class UnsafeTest {
+    static final Unsafe U = Unsafe.getUnsafe();
+
+    static inline class Value1 {
+        Point point;
+        Point[] array;
+        Value1() {
+            this.point = Point.createPoint(1, 1);
+            this.array = new Point[0];
+        }
+
+        static Value1 create(Point p, Point... points) {
+            Value1 o = Value1.default;
+            o = __WithField(o.point, p);
+            o = __WithField(o.array, points);
+            return o;
+        }
+    }
+
+    static inline class Value2 {
+        int i;
+        Value1 v;
+
+        Value2() {
+            this.i = 0;
+            this.v = Value1.create(Point.createPoint(0,0), new Point[0]);
+        }
+
+        static Value2 create(Value1 v, int i) {
+            Value2 o = Value2.default;
+            o = __WithField(o.v, v);
+            o = __WithField(o.i, i);
+            return o;
+        }
+    }
+
+    static inline class Value3 {
+        Object o;
+        Value2 v;
+
+        Value3() {
+            this.v = Value2.create(Value1.create(Point.createPoint(0,0), new Point[0]), 0);
+            this.o = new Object();
+        }
+
+        static Value3 create(Value2 v, Object ref) {
+            Value3 o = Value3.default;
+            o = __WithField(o.v, v);
+            o = __WithField(o.o, ref);
+            return o;
+        }
+    }
+
+
+    public static void main(String[] args) throws Throwable {
+        printValueClass(Value3.class, 0);
+
+        Value1 v1 = Value1.create(Point.createPoint(10,10), Point.createPoint(20,20), Point.createPoint(30,30));
+        Value2 v2 = Value2.create(v1, 20);
+        Value3 v3 = Value3.create(v2, List.of("Value3"));
+        long off_o = U.objectFieldOffset(Value3.class, "o");
+        long off_v = U.objectFieldOffset(Value3.class, "v");
+        long off_i = U.objectFieldOffset(Value2.class, "i");
+        long off_v2 = U.objectFieldOffset(Value2.class, "v");
+
+        long off_point = U.objectFieldOffset(Value1.class, "point");
+
+        /*
+         * Layout of Value3
+         *
+         * | valueheader | o | i | x | y | array |
+         *                       ^-------^
+         *                        Point
+         *                       ^---------------^
+         *                        Value1
+         *
+         *                   ^-------------------^
+         *                    Value2
+         */
+        Value3 v = v3;
+        try {
+            v = U.makePrivateBuffer(v);
+            // patch v3.o
+            U.putObject(v, off_o, List.of("Value1", "Value2", "Value3"));
+            // patch v3.v.i;
+            U.putInt(v, off_v + off_i - U.valueHeaderSize(Value2.class), 999);
+            // patch v3.v.v.point
+            U.putValue(v, off_v + off_v2 - U.valueHeaderSize(Value2.class) + off_point - U.valueHeaderSize(Value1.class),
+                       Point.class, Point.createPoint(100, 100));
+        } finally {
+            v = U.finishPrivateBuffer(v);
+        }
+
+        assertEquals(v.v.v.point, Point.createPoint(100, 100));
+        assertEquals(v.v.i, 999);
+        assertEquals(v.o, List.of("Value1", "Value2", "Value3"));
+        assertEquals(v.v.v.array, v1.array);
+
+        Value1 nv1 = Value1.create(Point.createPoint(70,70), Point.createPoint(80,80), Point.createPoint(90,90));
+        Value2 nv2 = Value2.create(nv1, 100);
+        Value3 nv3 = Value3.create(nv2, List.of("Value1", "Value2", "Value3"));
+
+        try {
+            v = U.makePrivateBuffer(v);
+            // patch v3.v
+            U.putValue(v, off_v2, Value2.class, nv2);
+        } finally {
+            v = U.finishPrivateBuffer(v);
+        }
+        assertEquals(v, nv3);
+    }
+
+    static void printValueClass(Class<?> vc, int level) {
+        String indent = "";
+        for (int i=0; i < level; i++) {
+            indent += "  ";
+        }
+        System.out.format("%s%s header size %d%n", indent, vc, U.valueHeaderSize(vc));
+        for (Field f : vc.getDeclaredFields()) {
+            System.out.format("%s%s: %s%s offset %d%n", indent, f.getName(),
+                              U.isFlattened(f) ? "flattened " : "", f.getType(),
+                              U.objectFieldOffset(vc, f.getName()));
+            if (U.isFlattened(f)) {
+                printValueClass(f.getType(), level+1);
+            }
+        }
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VDefaultTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VDefaultTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VDefaultTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test VDefaultTest
+ * @summary vdefault bytecode test
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers VDefaultTest.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.VDefaultTest
+ * @run main/othervm -Xcomp runtime.valhalla.inlinetypes.VDefaultTest
+ */
+
+public class VDefaultTest {
+
+    static inline final class Point {
+        final int x;
+        final int y;
+
+        static Point make() {
+            Point p = Point.default;
+            return p;
+        }
+
+        Point() {
+            x = 0;
+            y = 0;
+        }
+    }
+
+    static inline final class Value {
+        final char c;
+        final byte b;
+        final short s;
+        final int i;
+        final long l;
+        final float f;
+        final double d;
+        final Point p;
+
+        static Value make() {
+            Value p = Value.default;
+            return p;
+        }
+
+        Value () {
+            c = 0;
+            b = 0;
+            s = 0;
+            i = 0;
+            l = 0;
+            f = 0;
+            d = 0;
+            p = Point.make();
+        }
+    }
+
+    public static void main(String[] args) {
+        creationTest();
+        creationTest();
+    }
+
+    static void creationTest() {
+        Value v = Value.make();
+        Asserts.assertEquals(v.c, (char)0, "invalid char default value");
+        Asserts.assertEquals(v.b, (byte)0, "invalid char default value");
+        Asserts.assertEquals(v.s, (short)0, "invalid short default value");
+        Asserts.assertEquals(v.i, 0, "invalid int default value");
+        Asserts.assertEquals(v.l, 0L, "invalid long default value");
+        Asserts.assertEquals(v.f, 0.0F, "invalid float default value");
+        Asserts.assertEquals(v.d, 0.0D, "invalid double default value");
+        Asserts.assertEquals(v.p.x, 0, "invalid embedded inline type value");
+        Asserts.assertEquals(v.p.y, 0, "invalid embedded inline type value");
+    }
+}
+
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VWithFieldTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VWithFieldTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VWithFieldTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import jdk.test.lib.Asserts;
+
+/*
+ * @test VWithFieldTest
+ * @summary vwithfield bytecode test
+ * @library /test/lib
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java
+ * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator VWithFieldTest.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.VWithFieldTest
+ * @run main/othervm -Xcomp runtime.valhalla.inlinetypes.VWithFieldTest
+ */
+
+public class VWithFieldTest {
+
+    static inline final class Point {
+        final private int x;
+        final private int y;
+
+        static Point make(int x, int y) {
+            Point p = Point.default;
+            Asserts.assertEquals(p.x, 0, "invalid x default value");
+            Asserts.assertEquals(p.y, 0, "invalid y default value");
+            p = __WithField(p.x, x);
+            Asserts.assertEquals(p.x, x, "invalid x value");
+            Asserts.assertEquals(p.y, 0, "invalid y value");
+            p = __WithField(p.y, y);
+            Asserts.assertEquals(p.x, x, "invalid x value");
+            Asserts.assertEquals(p.y, y, "invalid y value");
+            return p;
+        }
+
+        Point () {
+            x = 0;
+            y = 0;
+        }
+
+        public int getX() {
+            return x;
+        }
+
+        static Point setX(Point p, int x) {
+            p = __WithField(p.x, x);
+            return p;
+        }
+
+        public int getY() {
+            return y;
+        }
+
+        static Point setY(Point p, int y) {
+            p = __WithField(p.y, y);
+            return p;
+        }
+    }
+
+    public static void main(String[] args) {
+        creationTest();
+        creationTest();
+        witherTest();
+        witherTest();
+    }
+
+    static void creationTest() {
+        Point p = Point.make(10,20);
+        Asserts.assertEquals(p.x, 10, "invalid x value");
+        Asserts.assertEquals(p.y, 20, "invalid y value");
+    }
+
+    static void witherTest() {
+        Point p1 = Point.make(2,12);
+        Asserts.assertEquals(p1.x, 2, "invalid x value");
+        Asserts.assertEquals(p1.y, 12, "invalid y value");
+        Point p2 = Point.setX(p1,3);
+        Asserts.assertEquals(p2.x, 3, "invalid x value");
+        Asserts.assertEquals(p2.y, 12, "invalid y value");
+        Point p3 = Point.setY(p2, 14);
+        Asserts.assertEquals(p3.x, 3, "invalid x value");
+        Asserts.assertEquals(p3.y, 14, "invalid y value");
+    }
+
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ValueCapableClass.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ValueCapableClass.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ValueCapableClass.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes;
+
+@jdk.incubator.mvt.ValueCapableClass
+public final class ValueCapableClass {
+
+    public static final int DEFAULT_X = 11;
+    public static final short DEFAULT_Y = 13;
+    public static final short DEFAULT_Z = 15;
+    public static final String STATIC_FIELD = "Should be left alone";
+
+    public final int   x;
+    public final short y;
+    public final short z;
+
+    private ValueCapableClass() {
+        this(DEFAULT_X, DEFAULT_Y, DEFAULT_Z);
+    }
+
+    private ValueCapableClass(int x, short y, short z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public int getX() {
+        return x;
+    }
+
+    public short getY() {
+        return y;
+    }
+
+    public short getZ() {
+        return z;
+    }
+
+    public String toString() {
+        int ax = getX();
+        short ay = getY();
+        short az = getZ();
+        return "ValueCapableClass x=" + ax + " y=" + ay + " z=" + az;
+    }
+
+    public static ValueCapableClass create(int x, short y, short z) {
+        return new ValueCapableClass(x, y, z);
+    }
+
+    public static ValueCapableClass create() {
+        return new ValueCapableClass();
+    }
+
+    public static void test() {
+        ValueCapableClass value = create(4711, (short)7, (short)11);
+        String s = value.toString();
+        if ((value.getX() != 4711) || (value.getY() != 7) || value.getZ() != 11) {
+            throw new IllegalStateException("Bad value: " + s);
+        }
+        System.out.println(s);
+        ValueCapableClass defaultValue = create();
+        s = defaultValue.toString();
+        if ((defaultValue.getX() != DEFAULT_X) ||
+            (defaultValue.getY() != DEFAULT_Y) ||
+            (defaultValue.getZ() != DEFAULT_Z)) {
+            throw new IllegalStateException("Bad value: " + s);
+        }
+
+        if (!STATIC_FIELD.equals("Should be left alone")) {
+            throw new IllegalStateException("Bad static field: " + STATIC_FIELD);
+        }
+    }
+
+    public static void main(String[] args) {
+        test();
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ValueTearing.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ValueTearing.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/ValueTearing.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+import java.lang.reflect.Array;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Supplier;
+import java.util.Optional;
+
+import jdk.internal.misc.Unsafe;
+import sun.hotspot.WhiteBox;
+import static jdk.test.lib.Asserts.*;
+
+/*
+ * @test ValueTearing
+ * @summary Test tearing of inline fields and array elements
+ * @modules java.base/jdk.internal.misc
+ * @library /test/lib
+ * @compile ValueTearing.java
+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox
+ * @run main/othervm -Xint  -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=
+ *                   -DSTEP_COUNT=10000
+ *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
+ *                                   runtime.valhalla.inlinetypes.ValueTearing
+ * @run main/othervm -Xint  -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=*
+ *                   -DSTEP_COUNT=10000
+ *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
+ *                                   runtime.valhalla.inlinetypes.ValueTearing
+ * @run main/othervm -Xbatch -DSTEP_COUNT=10000000
+ *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
+ *                                   runtime.valhalla.inlinetypes.ValueTearing
+ * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=
+ *                   -DTEAR_MODE=fieldonly
+ *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
+ *                                   runtime.valhalla.inlinetypes.ValueTearing
+ * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=
+ *                   -DTEAR_MODE=arrayonly
+ *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
+ *                                   runtime.valhalla.inlinetypes.ValueTearing
+ * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=*
+ *                   -DTEAR_MODE=both
+ *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
+ *                                   runtime.valhalla.inlinetypes.ValueTearing
+ */
+public class ValueTearing {
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
+    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag("UseCompiler");
+    private static final boolean ALWAYS_ATOMIC = WHITE_BOX.getStringVMFlag("ForceNonTearable").contains("*");
+    private static final String TEAR_MODE = System.getProperty("TEAR_MODE", "both");
+    private static final boolean TEAR_FIELD = !TEAR_MODE.equals("arrayonly");
+    private static final boolean TEAR_ARRAY = !TEAR_MODE.equals("fieldonly");
+    private static final int STEP_COUNT = Integer.getInteger("STEP_COUNT", 100_000);
+    private static final boolean TFIELD_FLAT, TARRAY_FLAT;
+    private static final boolean NTFIELD_FLAT, NTARRAY_FLAT;
+    static {
+        try {
+            Field TPB_field = TPointBox.class.getDeclaredField("field");
+            Field TPB_array = TPointBox.class.getDeclaredField("array");
+            Field NTPB_field = NTPointBox.class.getDeclaredField("field");
+            Field NTPB_array = NTPointBox.class.getDeclaredField("array");
+            TFIELD_FLAT = UNSAFE.isFlattened(TPB_field);
+            TARRAY_FLAT = UNSAFE.isFlattenedArray(TPB_array.getType());
+            NTFIELD_FLAT = UNSAFE.isFlattened(NTPB_field);
+            NTARRAY_FLAT = UNSAFE.isFlattenedArray(NTPB_array.getType());
+        } catch (ReflectiveOperationException ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    private static final String SETTINGS =
+        String.format("USE_COMPILER=%s ALWAYS_ATOMIC=%s TEAR_MODE=%s STEP_COUNT=%s FLAT TF/TA=%s/%s NTF/NTA=%s/%s",
+                      USE_COMPILER, ALWAYS_ATOMIC, TEAR_MODE, STEP_COUNT,
+                      TFIELD_FLAT, TARRAY_FLAT, NTFIELD_FLAT, NTARRAY_FLAT);
+    private static final String NOTE_TORN_POINT = "Note: torn point";
+
+    public static void main(String[] args) throws Exception {
+        System.out.println(SETTINGS);
+        ValueTearing valueTearing = new ValueTearing();
+        valueTearing.run();
+        // Extra representation check:
+        assert(!NTFIELD_FLAT) : "NT field must be indirect not flat";
+        assert(!NTARRAY_FLAT) : "NT array must be indirect not flat";
+        if (ALWAYS_ATOMIC) {
+            assert(!TFIELD_FLAT) : "field must be indirect not flat";
+            assert(!TARRAY_FLAT) : "array must be indirect not flat";
+        }
+    }
+
+    // A normally tearable inline value.
+    static inline class TPoint {
+        TPoint(long x, long y) { this.x = x; this.y = y; }
+        final long x, y;
+        public String toString() { return String.format("(%d,%d)", x, y); }
+    }
+
+    static class TooTearable extends AssertionError {
+        final Object badPoint;
+        TooTearable(String msg, Object badPoint) {
+            super(msg);
+            this.badPoint = badPoint;
+        }
+    }
+
+    interface PointBox {
+        void step();    // mutate inline value state
+        void check();   // check sanity of inline value state
+    }
+
+    class TPointBox implements PointBox {
+        TPoint field;
+        TPoint[] array = new TPoint[1];
+        // Step the points forward by incrementing their components
+        // "simultaneously".  A racing thread will catch flaws in the
+        // simultaneity.
+        TPoint step(TPoint p) {
+            return new TPoint(p.x + 1, p.y + 1);
+        }
+        public @Override
+        void step() {
+            if (TEAR_FIELD) {
+                field = step(field);
+            }
+            if (TEAR_ARRAY) {
+                array[0] = step(array[0]);
+            }
+            check();
+        }
+        // Invariant:  The components of each point are "always" equal.
+        // As long as simultaneity is preserved, this is true.
+        public @Override
+        void check() {
+            if (TEAR_FIELD) {
+                check(field, "field");
+            }
+            if (TEAR_ARRAY) {
+                check(array[0], "array element");
+            }
+        }
+        void check(TPoint p, String where) {
+            if (p.x == p.y)  return;
+            String msg = String.format("%s %s in %s; settings = %s",
+                                       NOTE_TORN_POINT,
+                                       p, where, SETTINGS);
+            throw new TooTearable(msg, p);
+        }
+        public String toString() {
+            return String.format("TPB[%s, {%s}]", field, array[0]);
+        }
+    }
+
+    // Add an indirection, as an extra test.
+    interface NT extends NonTearable { }
+
+    // A hardened, non-tearable version of TPoint.
+    static inline class NTPoint implements NT {
+        NTPoint(long x, long y) { this.x = x; this.y = y; }
+        final long x, y;
+        public String toString() { return String.format("(%d,%d)", x, y); }
+    }
+
+    class NTPointBox implements PointBox {
+        NTPoint field;
+        NTPoint[] array = new NTPoint[1];
+        // Step the points forward by incrementing their components
+        // "simultaneously".  A racing thread will catch flaws in the
+        // simultaneity.
+        NTPoint step(NTPoint p) {
+            return new NTPoint(p.x + 1, p.y + 1);
+        }
+        public @Override
+        void step() {
+            field = step(field);
+            array[0] = step(array[0]);
+            check();
+        }
+        // Invariant:  The components of each point are "always" equal.
+        public @Override
+        void check() {
+            check(field, "field");
+            check(array[0], "array element");
+        }
+        void check(NTPoint p, String where) {
+            if (p.x == p.y)  return;
+            String msg = String.format("%s *NonTearable* %s in %s; settings = %s",
+                                       NOTE_TORN_POINT,
+                                       p, where, SETTINGS);
+            throw new TooTearable(msg, p);
+        }
+        public String toString() {
+            return String.format("NTPB[%s, {%s}]", field, array[0]);
+        }
+    }
+
+    class AsyncObserver extends Thread {
+        volatile boolean done;
+        long observationCount;
+        final PointBox pointBox;
+        volatile Object badPointObserved;
+        AsyncObserver(PointBox pointBox) {
+            this.pointBox = pointBox;
+        }
+        public void run() {
+            try {
+                while (!done) {
+                    observationCount++;
+                    pointBox.check();
+                }
+            } catch (TooTearable ex) {
+                done = true;
+                badPointObserved = ex.badPoint;
+                System.out.println(ex);
+                if (ALWAYS_ATOMIC || ex.badPoint instanceof NonTearable) {
+                    throw ex;
+                }
+            }
+        }
+    }
+
+    public void run() throws Exception {
+        System.out.println("Test for tearing of NTPoint, which must not happen...");
+        run(new NTPointBox(), false);
+        System.out.println("Test for tearing of TPoint, which "+
+                           (ALWAYS_ATOMIC ? "must not" : "is allowed to")+
+                           " happen...");
+        run(new TPointBox(), ALWAYS_ATOMIC ? false : true);
+    }
+    public void run(PointBox pointBox, boolean canTear) throws Exception {
+        var observer = new AsyncObserver(pointBox);
+        observer.start();
+        for (int i = 0; i < STEP_COUNT; i++) {
+            pointBox.step();
+            if (observer.done)  break;
+        }
+        observer.done = true;
+        observer.join();
+        var obCount = observer.observationCount;
+        var badPoint = observer.badPointObserved;
+        System.out.println(String.format("finished after %d observations at %s; %s",
+                                         obCount, pointBox,
+                                         (badPoint == null
+                                          ? "no tearing observed"
+                                          : "bad point = " + badPoint)));
+        if (canTear && badPoint == null) {
+            var complain = String.format("%s NOT observed after %d observations",
+                                         NOTE_TORN_POINT, obCount);
+            System.out.println("?????? "+complain);
+            if (STEP_COUNT >= 3_000_000) {
+                // If it's a small count, OK, but if it's big the test is broken.
+                throw new AssertionError(complain + ", but it should have been");
+            }
+        }
+        if (!canTear && badPoint != null) {
+            throw new AssertionError("should not reach here; other thread must throw");
+        }
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VarArgsArray.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VarArgsArray.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VarArgsArray.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package runtime.valhalla.inlinetypes;
+
+import java.lang.reflect.*;
+import static jdk.test.lib.Asserts.*;
+
+/*
+ * @test VarArgsArray
+ * @summary Test if JVM API using varargs work with inline type arrays
+ * @library /test/lib
+ * @compile VarArgsArray.java NewInstanceFromConstructor.java IntValue.java
+ * @run main/othervm -Xint runtime.valhalla.inlinetypes.VarArgsArray
+ * @run main/othervm -Xcomp runtime.valhalla.inlinetypes.VarArgsArray
+ */
+public class VarArgsArray {
+
+    static final int TOKEN_VALUE = 4711;
+
+    int methodACnt = 0;
+    int methodBCnt = 0;
+    int methodCCnt = 0;
+
+    public VarArgsArray() {
+    }
+
+    public void test() throws Throwable {
+        // test publicly accessable API in the VM...given an inline type array
+        testJvmInvokeMethod();
+        testJvmNewInstanceFromConstructor();
+    }
+
+    public void testJvmInvokeMethod() throws Throwable {
+        MyInt[] array0 = new MyInt[0];
+        MyInt[] array1 = new MyInt[] { new MyInt(TOKEN_VALUE) };
+        MyInt[] array2 = new MyInt[] { new MyInt(TOKEN_VALUE), new MyInt(TOKEN_VALUE) };
+
+        Method methodARef = getClass().getDeclaredMethod("methodA", MyInt.class);
+        Method methodBRef = getClass().getDeclaredMethod("methodB", MyInt.class, MyInt.class);
+        Method methodCRef = getClass().getDeclaredMethod("methodC", MyInt.class, String.class);
+
+        // Positive tests...
+        methodARef.invoke(this, (Object[])array1);
+        assertWithMsg(methodACnt == 1, "methodA did not invoke");
+
+        methodARef.invoke(this, array1[0]);
+        assertWithMsg(methodACnt == 2, "methodA did not invoke");
+
+        methodBRef.invoke(this, (Object[]) array2);
+        assertWithMsg(methodBCnt == 1, "methodB did not invoke");
+
+        methodBRef.invoke(this, array2[0], array2[1]);
+        assertWithMsg(methodBCnt == 2, "methodB did not invoke");
+
+        // Negative tests...
+        int argExCnt = 0;
+        try {
+            methodARef.invoke(this, (Object[]) array0);
+            throw new RuntimeException("Expected fail");
+        } catch (IllegalArgumentException argEx) { argExCnt++; }
+        try {
+            methodARef.invoke(this, (Object[]) array2);
+            throw new RuntimeException("Expected fail");
+        } catch (IllegalArgumentException argEx) { argExCnt++; }
+        try {
+            methodCRef.invoke(this, (Object[]) array2);
+            throw new RuntimeException("Expected fail");
+        } catch (IllegalArgumentException argEx) { argExCnt++; }
+        assertWithMsg(argExCnt == 3, "Did not see the correct number of exceptions");
+        assertWithMsg(methodACnt == 2, "methodA bad invoke count");
+        assertWithMsg(methodBCnt == 2, "methodB bad invoke count");
+        assertWithMsg(methodCCnt == 0, "methodC bad invoke count");
+    }
+
+    public void testJvmNewInstanceFromConstructor() throws Throwable {
+        // Inner classes use outer in param list, so these won't exercise inline type array
+        Class tc = NewInstanceFromConstructor.class;
+        Class pt = IntValue.class;
+        Constructor consARef = tc.getConstructor(pt);
+        Constructor consBRef = tc.getConstructor(pt, pt);
+        Constructor consCRef = tc.getConstructor(pt, String.class);
+        IntValue[] array0 = new IntValue[0];
+        IntValue[] array1 = new IntValue[] { new IntValue(TOKEN_VALUE) };
+        IntValue[] array2 = new IntValue[] { new IntValue(TOKEN_VALUE),
+                                             new IntValue(TOKEN_VALUE) };
+
+        // Positive tests...
+        consARef.newInstance((Object[])array1);
+        consARef.newInstance(array1[0]);
+        NewInstanceFromConstructor test = (NewInstanceFromConstructor)
+            consBRef.newInstance((Object[])array2);
+        assertWithMsg(test.getValue() == (2 * TOKEN_VALUE), "Param corrrupt");
+        consBRef.newInstance(array2[0], array2[1]);
+        assertWithMsg(NewInstanceFromConstructor.getConsCalls() == 4, "Constructor did not invoke");
+
+        // Negative tests...
+        int argExCnt = 0;
+        try {
+            consARef.newInstance((Object[])array0);
+            throw new RuntimeException("Expected fail");
+        } catch (IllegalArgumentException argEx) { argExCnt++; }
+        try {
+            consARef.newInstance((Object[])array2);
+            throw new RuntimeException("Expected fail");
+        } catch (IllegalArgumentException argEx) { argExCnt++; }
+        try {
+            consCRef.newInstance((Object[])array2);
+            throw new RuntimeException("Expected fail");
+        } catch (IllegalArgumentException argEx) { argExCnt++; }
+        assertWithMsg(argExCnt == 3, "Did not see the correct number of exceptions");
+        assertWithMsg(NewInstanceFromConstructor.getConsCalls() == 4, "Constructor should have been invoked");
+    }
+
+    public void methodA(MyInt a) {
+        assertWithMsg(a.value == TOKEN_VALUE, "Bad arg");
+        methodACnt++;
+    }
+
+    public void methodB(MyInt a, MyInt b) {
+        assertWithMsg(a.value == TOKEN_VALUE, "Bad arg");
+        assertWithMsg(b.value == TOKEN_VALUE, "Bad arg");
+        methodBCnt++;
+    }
+
+    public void methodC(MyInt a, String b) {
+        assertWithMsg(a.value == TOKEN_VALUE, "Bad arg");
+        methodCCnt++;
+    }
+
+    static void assertWithMsg(boolean expr, String msg) throws RuntimeException {
+        assertTrue(expr, msg);
+    }
+
+    public static void main(String[] args) throws Throwable {
+        new VarArgsArray().test();
+    }
+
+    inline class MyInt {
+        int value;
+        public MyInt() { this(0); }
+        public MyInt(int v) { this.value = v; }
+    }
+
+
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VolatileTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VolatileTest.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/VolatileTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package runtime.valhalla.inlinetypes;
+
+/*
+ * @test VolatileTest
+ * @summary check effect of volatile keyword on flattenable fields
+ * @modules java.base/jdk.internal.misc
+ * @library /test/lib
+ * @run main/othervm runtime.valhalla.inlinetypes.VolatileTest
+ */
+
+import jdk.internal.misc.Unsafe;
+
+import java.lang.reflect.*;
+import jdk.test.lib.Asserts;
+
+public class VolatileTest {
+    static final Unsafe U = Unsafe.getUnsafe();
+
+    static inline class MyValue {
+        int i = 0;
+        int j = 0;
+    }
+
+    static class MyContainer {
+        MyValue mv0;
+        volatile MyValue mv1;
+    }
+
+    static public void main (String[] args) {
+        Class<?> c = MyContainer.class;
+        Field f0 = null;
+        Field f1 = null;
+        try {
+            f0 = c.getDeclaredField("mv0");
+            f1 = c.getDeclaredField("mv1");
+        } catch(NoSuchFieldException e) {
+            e.printStackTrace();
+            return;
+        }
+        Asserts.assertTrue(U.isFlattened(f0), "mv0 should be flattened");
+        Asserts.assertFalse(U.isFlattened(f1), "mv1 should not be flattened");
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldAccessorTest.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/WithFieldAccessorTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldAccessorTest.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/WithFieldAccessorTest.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/WithFieldNoAccessTest.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/WithFieldNoAccessTest.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/WithFieldNoAccessTest.jcod
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/BadACCValue.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/classfileparser/BadACCValue.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/BadACCValue.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/classfileparser/BadACCValue.java
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/classfileparser/BadInlineTypes.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/classfileparser/BadInlineTypes.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/classfileparser/BadInlineTypes.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+/*
+ * @test
+ * @summary test that the right exceptions get thrown for bad inline type
+ *          class files.
+ * @compile cfpTests.jcod
+ * @run main/othervm BadInlineTypes
+ */
+
+public class BadInlineTypes {
+
+    public static void runTest(String test_name, String message) throws Exception {
+        System.out.println("Testing: " + test_name);
+        try {
+            Class newClass = Class.forName(test_name);
+        } catch (java.lang.ClassFormatError e) {
+            if (!e.getMessage().contains(message)) {
+                throw new RuntimeException( "Wrong ClassFormatError: " + e.getMessage());
+            }
+        }
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        // Test that ACC_VALUE with ACC_ABSTRACT is illegal.
+        runTest("ValueAbstract", "Illegal class modifiers in class ValueAbstract");
+
+        // Test that ACC_VALUE with ACC_ENUM is illegal.
+        runTest("ValueEnum", "Illegal class modifiers in class ValueEnum");
+
+        // Test that inline type fields must be final.
+        runTest("ValueFieldNotFinal", "Illegal field modifiers in class ValueFieldNotFinal");
+
+        // Test that ACC_VALUE with ACC_INTERFACE is illegal.
+        runTest("ValueInterface", "Illegal class modifiers in class ValueInterface");
+
+        // Test that inline type instance methods cannot be synchronized.
+        runTest("ValueMethodSynch",
+                "Method getInt in class ValueMethodSynch (an inline class) has illegal modifiers");
+
+        // Test that ClassCircularityError gets detected for instance fields.
+        System.out.println("Testing ClassCircularityError for instance fields");
+        try {
+            Class newClass = Class.forName("Circ");
+            throw new RuntimeException( "java.lang.ClassCircularityError exception not thrown!");
+        } catch (java.lang.ClassCircularityError e) {
+             if (!e.getMessage().contains("Circ")) {
+                 throw new RuntimeException( "Wrong ClassCircularityError: " + e.getMessage());
+             }
+         }
+
+        // Test that ClassCircularityError isn't detected for static fields.
+        System.out.println("Testing ClassCircularityError for static fields");
+        try {
+            Class newClass = Class.forName("CircStaticB");
+        } catch (java.lang.ClassCircularityError e) {
+             throw new RuntimeException( "java.lang.ClassCircularityError exception thrown!");
+         }
+
+        runTest("ValueCloneable", "Inline Types do not support Cloneable");
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/classfileparser/cfpTests.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/cfpTests.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/classfileparser/cfpTests.jcod
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -838,11 +838,11 @@
   } // Attributes
 } // end class ValueMethodSynch
 
 //////////////////////////////////////////////////////////////////////
 
-// Value types Circ and Circ2 have fields of each other's type.  This should
+// Inline types Circ and Circ2 have fields of each other's type.  This should
 // cause a ClassCircularityError exception when one of them is being loaded.
 //
 // The inline types are based on these two Java classes:
 //
 // final inline class Circ {
@@ -1432,11 +1432,11 @@
   } // Attributes
 } // end class Circ2
 
 //////////////////////////////////////////////////////////////////////
 
-// Value types CircStaticA and CircStaticB have static fields of each other's
+// Inline types CircStaticA and CircStaticB have static fields of each other's
 // type.  This should cause a ClassCircularityError exception when one of them
 // is being loaded.
 //
 // The inline types are based on these two Java classes:
 //
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeImplementingIdentityObject.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeImplementingIdentityObject.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeImplementingIdentityObject.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeImplementingIdentityObject.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeWithNonstaticFields.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeWithNonstaticFields.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeWithNonstaticFields.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeWithNonstaticFields.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeWithStaticFields.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeWithStaticFields.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeWithStaticFields.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeWithStaticFields.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeWithSynchronizedNonstaticMethod.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeWithSynchronizedNonstaticMethod.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeWithSynchronizedNonstaticMethod.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeWithSynchronizedNonstaticMethod.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeWithSynchronizedStaticMethod.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeWithSynchronizedStaticMethod.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/AbstractTypeWithSynchronizedStaticMethod.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/AbstractTypeWithSynchronizedStaticMethod.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/IdentityType.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityType.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/IdentityType.jcod
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityTypeImplementingIdentityObject.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/IdentityTypeImplementingIdentityObject.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/IdentityTypeImplementingIdentityObject.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/IdentityTypeImplementingIdentityObject.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/InlineType.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/InlineType.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/InlineType.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/InlineType.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/Interface.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/Interface.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/Interface.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/Interface.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/InterfaceExtendingIdentityObject.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/InterfaceExtendingIdentityObject.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/InterfaceExtendingIdentityObject.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/InterfaceExtendingIdentityObject.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/TestIdentityObject.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/TestIdentityObject.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/identityObject/TestIdentityObject.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/identityObject/TestIdentityObject.java
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/libInlineWithJni.c b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/libInlineWithJni.c
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/libInlineWithJni.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <jni.h>
+
+JNIEXPORT void JNICALL
+Java_runtime_valhalla_inlinetypes_InlineWithJni_doJniMonitorEnter(JNIEnv *env, jobject obj) {
+    (*env)->MonitorEnter(env, obj);
+}
+
+JNIEXPORT void JNICALL
+Java_runtime_valhalla_inlinetypes_InlineWithJni_doJniMonitorExit(JNIEnv *env, jobject obj) {
+    (*env)->MonitorExit(env, obj);
+}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/libJNIIsSameObject.c b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/libJNIIsSameObject.c
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/libJNIIsSameObject.c
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/libJNIIsSameObject.c
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/libTestJNIArrays.c b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/libTestJNIArrays.c
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/libTestJNIArrays.c
@@ -0,0 +1,313 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <jni.h>
+
+#if !defined(_WIN32) && !defined(_WIN64)
+
+JNIEXPORT jint JNICALL
+Java_TestJNIArrays_GetFlattenedArrayElementSizeWrapper(JNIEnv* env, jobject receiver, jarray array) {
+  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
+  return (jint)elm_sz;
+}
+
+JNIEXPORT jclass JNICALL
+Java_TestJNIArrays_GetFlattenedArrayElementClassWrapper(JNIEnv* env, jobject receiver, jarray array) {
+  jclass elm_class = (*env)->GetFlattenedArrayElementClass(env, array);
+  return elm_class;
+}
+
+JNIEXPORT jint JNICALL
+Java_TestJNIArrays_GetFieldOffsetInFlattenedLayoutWrapper(JNIEnv* env, jobject receiver, jclass clazz, jstring name, jstring signature, jboolean expectFlattened) {
+  jboolean flattened;
+  const char *name_ptr = (*env)->GetStringUTFChars(env, name, NULL);
+  const char *signature_ptr = (*env)->GetStringUTFChars(env, signature, NULL);
+  int offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, name_ptr,signature_ptr, &flattened);
+  (*env)->ReleaseStringUTFChars(env, name, name_ptr);
+  (*env)->ReleaseStringUTFChars(env, signature, signature_ptr);
+  if ((*env)->ExceptionCheck(env)) {
+    return -1;
+  }
+  if (flattened != expectFlattened) {
+    jclass RE = (*env)->FindClass(env, "java/lang/RuntimeException");
+    (*env)->ThrowNew(env, RE, "Flattening mismatch");
+    return -1;
+  }
+  return offset;
+}
+
+JNIEXPORT jlong JNICALL
+Java_TestJNIArrays_GetFlattenedArrayElementsWrapper(JNIEnv* env, jobject receiver, jarray array) {
+  jboolean isCopy;
+  void* addr = (*env)->GetFlattenedArrayElements(env, array, &isCopy);
+  return (jlong)addr;
+}
+
+JNIEXPORT void JNICALL
+Java_TestJNIArrays_ReleaseFlattenedArrayElementsWrapper(JNIEnv* env, jobject receiver, jarray array, jlong addr, jint mode) {
+  (*env)->ReleaseFlattenedArrayElements(env, array, (void*)addr, mode);
+}
+
+JNIEXPORT jint JNICALL
+Java_TestJNIArrays_getIntFieldAtIndex(JNIEnv* env, jobject receiver, jarray array, jint index, jstring name, jstring signature) {
+  jint array_length = (*env)->GetArrayLength(env, array);
+  if (index < 0 || index >= array_length) {
+    jclass AIOOBE = (*env)->FindClass(env, "java.lang.ArrayIndexOutOfBoundsException");
+    (*env)->ThrowNew(env, AIOOBE, "Bad index");
+    return -1;
+  }
+  jobject element = (*env)->GetObjectArrayElement(env, array, index);
+  // should add protection against null element here (could happen if array is not a flattened array
+  jclass element_class = (*env)->GetObjectClass(env, element);
+  const char *name_ptr = (*env)->GetStringUTFChars(env, name, NULL);
+  const char *signature_ptr = (*env)->GetStringUTFChars(env, signature, NULL);
+  jfieldID field_id = (*env)->GetFieldID(env, element_class, (const char*)name_ptr, (const char *)signature_ptr);
+  (*env)->ReleaseStringUTFChars(env, name, name_ptr);
+  (*env)->ReleaseStringUTFChars(env, signature, signature_ptr);
+  jint value = (*env)->GetIntField(env, element, field_id);
+  return value;
+}
+
+JNIEXPORT void JNICALL
+Java_TestJNIArrays_printArrayInformation(JNIEnv* env, jobject receiver, jarray array) {
+  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
+  void* base = (*env)->GetFlattenedArrayElements(env, array, NULL);
+  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
+}
+
+JNIEXPORT void JNICALL
+Java_TestJNIArrays_initializeIntIntArrayBuffer(JNIEnv* env, jobject receiver, jarray array, int i0, int i1) {
+  int len = (*env)->GetArrayLength(env, array);
+  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
+  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
+  int i0_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i0", "I", NULL);
+  int i1_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i1", "I", NULL);
+  char* buffer = (char*)malloc(elm_sz);
+  if (buffer == NULL) {
+    jclass OOM = (*env)->FindClass(env, "java/lang/OutOfMemoryException");
+    (*env)->ThrowNew(env, OOM, "Malloc failed");
+    return;
+  }
+  *(int*)(buffer + i0_offset) = i0;
+  *(int*)(buffer + i1_offset) = i1;
+  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
+  for (int i = 0; i < len; i++) {
+    memcpy((char*)base + i * elm_sz, buffer, elm_sz);
+  }
+  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
+  free(buffer);
+}
+
+JNIEXPORT void JNICALL
+Java_TestJNIArrays_initializeIntIntArrayFields(JNIEnv* env, jobject receiver, jarray array, int i0, int i1) {
+  int len = (*env)->GetArrayLength(env, array);
+  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
+  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
+  int i0_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i0", "I", NULL);
+  int i1_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i1", "I", NULL);
+  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
+  char* elm_ptr = base;
+  for (int i = 0; i < len; i++) {
+    *(int*)(elm_ptr + i0_offset) = i0;
+    *(int*)(elm_ptr + i1_offset) = i1;
+    elm_ptr += elm_sz;
+  }
+  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
+}
+
+struct IntInt_offsets {
+  int i0_offset;
+  int i1_offset;
+};
+
+#ifdef __APPLE__
+static int compare_IntInt(void* offsets, const void* x, const void* y)  {
+#endif // __APPLE__
+#ifdef __linux__
+static int compare_IntInt(const void* x, const void* y, void* offsets)  {
+#endif // __linux__
+  int i0_offset = ((struct IntInt_offsets*)offsets)->i0_offset;
+  int x_i0 = *(int*)((char*)x + i0_offset);
+  int y_i0 = *(int*)((char*)y + i0_offset);
+  if (x_i0 < y_i0) return -1;
+  if (x_i0 > y_i0) return 1;
+  int i1_offset = ((struct IntInt_offsets*)offsets)->i1_offset;
+  int x_i1 = *(int*)((char*)x + i1_offset);
+  int y_i1 = *(int*)((char*)y + i1_offset );
+  if (x_i1 < y_i1) return -1;
+  if (x_i1 > y_i1) return 1;
+  return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_TestJNIArrays_sortIntIntArray(JNIEnv* env, jobject receiver, jarray array) {
+  int len = (*env)->GetArrayLength(env, array);
+  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
+  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
+  struct IntInt_offsets offsets;
+  offsets.i0_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i0", "I", NULL);
+  offsets.i1_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i1", "I", NULL);
+  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
+#ifdef __APPLE__
+  qsort_r(base, len, elm_sz, (void*) &offsets, compare_IntInt);
+#endif // __APPLE__
+#ifdef __linux__
+  qsort_r(base, len, elm_sz,  compare_IntInt, (void*) &offsets);
+#endif // __linux__
+  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
+}
+
+
+JNIEXPORT void JNICALL
+Java_TestJNIArrays_initializeContainerArray(JNIEnv* env, jobject receiver, jarray array,
+                                            jdouble d, jfloat f, jshort s, jbyte b) {
+  int len = (*env)->GetArrayLength(env, array);
+  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
+  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
+  int d_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "d", "D", NULL);
+  int b_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "b", "B", NULL);
+  jboolean flattened;
+  int c_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "c", "QTestJNIArrays$Containee;", &flattened);
+  if (!flattened) {
+    jclass RE = (*env)->FindClass(env, "java/lang/RuntimeException");
+    (*env)->ThrowNew(env, RE, "Incompatible layout");
+    return;
+  }
+  jclass clazz2 = (*env)->FindClass(env, "TestJNIArrays$Containee");
+  int f_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz2, "f", "F", NULL);
+  int s_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz2, "s", "S", NULL);
+  f_offset += c_offset;
+  s_offset += c_offset;
+  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
+  char* elm_ptr = base;
+  for (int i = 0; i < len; i++) {
+    *(jdouble*)(elm_ptr + d_offset) = d;
+    *(jfloat*)(elm_ptr + f_offset) = f;
+    *(jshort*)(elm_ptr + s_offset) = s;
+    *(jbyte*)(elm_ptr + b_offset) = b;
+    elm_ptr += elm_sz;
+  }
+  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
+}
+
+
+JNIEXPORT void JNICALL
+Java_TestJNIArrays_updateContainerArray(JNIEnv* env, jobject receiver, jarray array,
+                                        jfloat f, jshort s) {
+  int len = (*env)->GetArrayLength(env, array);
+  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
+  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
+  jboolean flattened;
+  int c_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "c", "QTestJNIArrays$Containee;", &flattened);
+  if (!flattened) {
+    jclass RE = (*env)->FindClass(env, "java/lang/RuntimeException");
+    (*env)->ThrowNew(env, RE, "Incompatible layout");
+    return;
+  }
+  jclass clazz2 = (*env)->FindClass(env, "TestJNIArrays$Containee");
+  int f_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz2, "f", "F", NULL);
+  int s_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz2, "s", "S", NULL);
+  f_offset += c_offset;
+  s_offset += c_offset;
+  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
+  char* elm_ptr = base;
+  for (int i = 0; i < len; i++) {
+    *(jfloat*)(elm_ptr + f_offset) = f;
+    *(jshort*)(elm_ptr + s_offset) = s;
+    elm_ptr += elm_sz;
+  }
+  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
+}
+
+
+ JNIEXPORT void JNICALL
+ Java_TestJNIArrays_initializeLongLongLongLongArray(JNIEnv* env, jobject receiver, jarray array, jlong l0, jlong l1, jlong l2, jlong l3) {
+  int len = (*env)->GetArrayLength(env, array);
+  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
+  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
+  int l0_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "l0", "J", NULL);
+  int l1_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "l1", "J", NULL);
+  int l2_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "l2", "J", NULL);
+  int l3_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "l3", "J", NULL);
+  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
+  char* elm_ptr = base;
+  for (int i = 0; i < len; i++) {
+    *(jlong*)(elm_ptr + l0_offset) = l0;
+    *(jlong*)(elm_ptr + l1_offset) = l1;
+    *(jlong*)(elm_ptr + l2_offset) = l2;
+    *(jlong*)(elm_ptr + l3_offset) = l3;
+    elm_ptr += elm_sz;
+  }
+  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
+}
+
+JNIEXPORT jobject JNICALL
+Java_TestJNIArrays_createSubElementSelector(JNIEnv* env, jobject receiver, jarray array) {
+  return (*env)->CreateSubElementSelector(env, array);
+}
+
+JNIEXPORT jobject JNICALL
+  Java_TestJNIArrays_getSubElementSelector(JNIEnv* env, jobject receiver, jobject selector, jclass klass, jstring name, jstring signature) {
+  const char *name_ptr = (*env)->GetStringUTFChars(env, name, NULL);
+  const char *signature_ptr = (*env)->GetStringUTFChars(env, signature, NULL);
+  jfieldID fieldID = (*env)->GetFieldID(env, klass, name_ptr, signature_ptr);
+  jobject res = (*env)->GetSubElementSelector(env, selector, fieldID);
+  (*env)->ReleaseStringUTFChars(env, name, name_ptr);
+  (*env)->ReleaseStringUTFChars(env, signature, signature_ptr);
+  return res;
+}
+
+JNIEXPORT jobject JNICALL
+Java_TestJNIArrays_getObjectSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index) {
+  return (*env)->GetObjectSubElement(env, array, selector, index);
+}
+
+JNIEXPORT void JNICALL
+  Java_TestJNIArrays_setObjectSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index, jobject value) {
+  (*env)->SetObjectSubElement(env, array, selector, index, value);
+}
+
+JNIEXPORT jshort JNICALL
+Java_TestJNIArrays_getShortSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index) {
+  return (*env)->GetShortSubElement(env, array, selector, index);
+}
+
+JNIEXPORT void JNICALL
+  Java_TestJNIArrays_setShortSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index, short value) {
+  (*env)->SetShortSubElement(env, array, selector, index, value);
+}
+
+JNIEXPORT jint JNICALL
+Java_TestJNIArrays_getIntSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index) {
+  return (*env)->GetIntSubElement(env, array, selector, index);
+}
+
+JNIEXPORT void JNICALL
+  Java_TestJNIArrays_setIntSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index, jint value) {
+  (*env)->SetIntSubElement(env, array, selector, index, value);
+}
+
+#endif // !defined(_WIN32) && !defined(_WIN64)
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/CtorHasArgs.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/CtorHasArgs.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/CtorHasArgs.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/CtorHasArgs.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/CtorIsNotEmpty.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/CtorIsNotEmpty.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/CtorIsNotEmpty.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/CtorIsNotEmpty.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/HasNonStaticFields.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/HasNonStaticFields.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/HasNonStaticFields.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/HasNonStaticFields.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/HasSynchMethod.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/HasSynchMethod.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/HasSynchMethod.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/HasSynchMethod.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/ImplementsIdentityObject.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/ImplementsIdentityObject.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/ImplementsIdentityObject.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/ImplementsIdentityObject.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/InlineClassWithBadSupers.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/InlineClassWithBadSupers.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/InlineClassWithBadSupers.jcod
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/IntfImplementsIdentityObject.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/IntfImplementsIdentityObject.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/IntfImplementsIdentityObject.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/IntfImplementsIdentityObject.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/NotAbstract.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/NotAbstract.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/NotAbstract.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/NotAbstract.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/TestSuperClasses.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/TestSuperClasses.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/TestSuperClasses.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/TestSuperClasses.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/ValidSuper.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/ValidSuper.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/testSupers/ValidSuper.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/testSupers/ValidSuper.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/NoNullVT.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/NoNullVT.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/NoNullVT.jcod
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/VTAssignability.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/VTAssignability.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/VTAssignability.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/VTAssignability.java
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/VTMonitor.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/VTMonitor.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/VTMonitor.java
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/VTMonitor.java
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/ValueCapableClass.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/ValueCapableClass.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/ValueCapableClass.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package runtime.valhalla.inlinetypes.verifier;
+
+@jdk.incubator.mvt.ValueCapableClass
+public final class ValueCapableClass {
+
+    public static final int DEFAULT_X = 11;
+    public static final short DEFAULT_Y = 13;
+    public static final short DEFAULT_Z = 15;
+    public static final String STATIC_FIELD = "Should be left alone";
+
+    public final int   x;
+    public final short y;
+    public final short z;
+
+    private ValueCapableClass() {
+        this(DEFAULT_X, DEFAULT_Y, DEFAULT_Z);
+    }
+
+    private ValueCapableClass(int x, short y, short z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public int getX() {
+        return x;
+    }
+
+    public short getY() {
+        return y;
+    }
+
+    public short getZ() {
+        return z;
+    }
+
+    public String toString() {
+        int ax = getX();
+        short ay = getY();
+        short az = getZ();
+        return "ValueCapableClass x=" + ax + " y=" + ay + " z=" + az;
+    }
+
+    public static ValueCapableClass create(int x, short y, short z) {
+        return new ValueCapableClass(x, y, z);
+    }
+
+    public static ValueCapableClass create() {
+        return new ValueCapableClass();
+    }
+
+    public static void test() {
+        ValueCapableClass value = create(4711, (short)7, (short)11);
+        String s = value.toString();
+        if ((value.getX() != 4711) || (value.getY() != 7) || value.getZ() != 11) {
+            throw new IllegalStateException("Bad value: " + s);
+        }
+        System.out.println(s);
+        ValueCapableClass defaultValue = create();
+        s = defaultValue.toString();
+        if ((defaultValue.getX() != DEFAULT_X) ||
+            (defaultValue.getY() != DEFAULT_Y) ||
+            (defaultValue.getZ() != DEFAULT_Z)) {
+            throw new IllegalStateException("Bad value: " + s);
+        }
+
+        if (!STATIC_FIELD.equals("Should be left alone")) {
+            throw new IllegalStateException("Bad static field: " + STATIC_FIELD);
+        }
+    }
+
+    public static void main(String[] args) {
+        test();
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/VerifierInlineTypes.java b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/VerifierInlineTypes.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/VerifierInlineTypes.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+/*
+ * @test
+ * @bug 8223028
+ * @summary test that the right exceptions get thrown for bad inline type
+ *          class files.
+ * @compile verifierTests.jcod NoNullVT.jcod
+ * @run main/othervm -verify VerifierInlineTypes
+ */
+
+public class VerifierInlineTypes {
+
+    public static void runTestVerifyError(String test_name, String message) throws Exception {
+        System.out.println("Testing: " + test_name);
+        try {
+            Class newClass = Class.forName(test_name);
+            throw new RuntimeException("Expected VerifyError exception not thrown");
+        } catch (java.lang.VerifyError e) {
+            if (!e.getMessage().contains(message)) {
+                throw new RuntimeException("Wrong VerifyError: " + e.getMessage());
+            }
+        }
+    }
+
+    public static void runTestFormatError(String test_name, String message) throws Exception {
+        System.out.println("Testing: " + test_name);
+        try {
+            Class newClass = Class.forName(test_name);
+            throw new RuntimeException("Expected ClassFormatError exception not thrown");
+        } catch (java.lang.ClassFormatError e) {
+            if (!e.getMessage().contains(message)) {
+                throw new RuntimeException("Wrong ClassFormatError: " + e.getMessage());
+            }
+        }
+    }
+
+    public static void runTestNoError(String test_name) throws Exception {
+        System.out.println("Testing: " + test_name);
+        Class newClass = Class.forName(test_name);
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        // Test that a defaultvalue opcode with an out of bounds cp index causes a VerifyError.
+        runTestVerifyError("defValBadCP", "Illegal constant pool index");
+
+        // Test that ClassFormatError is thrown for a class file, with major version 54, that
+        // contains a defaultvalue opcode.
+        runTestFormatError("defValBadMajorVersion", "defaultvalue not supported by this class file version");
+
+        // Test VerifyError is thrown if a defaultvalue's cp entry is not a class.
+        runTestVerifyError("defValWrongCPType", "Illegal type at constant pool entry");
+
+/*
+        // Test that a withfield opcode with an out of bounds cp index causes a VerifyError.
+        runTestVerifyError("wthFldBadCP", "Illegal constant pool index");
+
+        // Test that VerifyError is thrown if the first operand on the stack is not assignable
+        // to withfield's field.
+        runTestVerifyError("wthFldBadFldVal", "Bad type on operand stack");
+
+        // Test that VerifyError is thrown if the second operand on the stack is a primitive.
+        runTestVerifyError("wthFldBadFldRef", "Bad type on operand stack");
+
+        // Test that ClassFormatError is thrown for a class file, with major version 54, that
+        // contains a withfield opcode.
+        runTestFormatError("wthFldBadMajorVersion", "withfield not supported by this class file version");
+
+        // Test VerifyError is thrown if a withfields's cp entry is not a field.
+        runTestVerifyError("wthFldWrongCPType", "Illegal type at constant pool entry");
+
+        // Test that VerifyError is thrown if the class for a withfields's cp fieldref
+        // entry is java.lang.Object and the reference on the stack is an inline type.
+        runTestVerifyError("wthFldObject", "must be identical inline types");
+
+        // Test VerifyError is thrown if a monitorenter's cp entry is an inline type.
+        runTestVerifyError("monEnterVT", "Bad type on operand stack");
+*/
+
+        // Test VerifyError is thrown if a defaultvalue's cp entry is an inline type.
+        runTestVerifyError("defValueObj", "Illegal type at constant pool entry 4");
+
+        // Test VerifyError is thrown if a withfield's class operand is not an inline type.
+//        runTestVerifyError("withfieldObj", "Bad type on operand stack");
+
+        // Test that null is not assignable to an inline type.
+        runTestVerifyError("NoNullVT",
+            "Type null (current frame, stack[1]) is not assignable to 'QNoNullVT;'");
+    }
+}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/verifierTests.jcod
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/verifierTests.jcod
+++ b/test/hotspot/jtreg/runtime/valhalla/inlinetypes/verifier/verifierTests.jcod
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/CheckcastTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/CheckcastTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/CheckcastTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test CheckcastTest
- * @summary checkcast bytecode test
- * @library /test/lib
- * @compile VDefaultTest.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.CheckcastTest
- * @run main/othervm -Xcomp runtime.valhalla.valuetypes.CheckcastTest
- */
-
-public class CheckcastTest {
-
-    static inline class Point {
-        int x;
-        int y;
-
-        public Point() {
-            x = 0;
-            y = 0;
-        }
-
-        public Point(int x, int y) {
-            this.x = x;
-            this.y = y;
-        }
-    }
-
-
-    static void testCastingFromObjectToVal(Object o) {
-        boolean npe = false;
-        try {
-            Point pv = (Point)o;
-        } catch(NullPointerException e) {
-            npe = true;
-        }
-        Asserts.assertTrue(npe == false || o == null, "Casting null to val should throw a NPE");
-    }
-
-    static void testCastingFromValToBox(Point p) {
-        boolean npe = false;
-        try {
-            Point.ref pb = p;
-        } catch(NullPointerException e) {
-            npe = true;
-        }
-        Asserts.assertFalse(npe, "Casting from val to box should not throw an NPE");
-    }
-
-    static void testCastingFromBoxToVal(Point.ref p) {
-        boolean npe = false;
-        try {
-            Point pv = (Point) p;
-        } catch(NullPointerException e) {
-            npe = true;
-        }
-        if (npe) {
-            Asserts.assertEquals(p, null, "NPE must be thrown only if p is null");
-        } else {
-            Asserts.assertNotEquals(p, null, "Casting null to val must thrown a NPE");
-        }
-
-    }
-
-    public static void main(String[] args) {
-        // Testing casting from box to val
-        // First invocation: casting null to Point with an unresolved class entry
-        testCastingFromBoxToVal(null);
-        // Second invocation: casting non-null to val, will trigger resolution of the class entry
-        testCastingFromBoxToVal(new Point(3,4));
-        // Third invocation: casting null to Point with a resolved class entry
-        testCastingFromBoxToVal(null);
-
-        // Testing casting from val to box
-        testCastingFromBoxToVal(new Point(3,4));
-
-        // Testing casting from object to val
-        // First invocation: casting null to Point with an unresolved class entry
-        testCastingFromObjectToVal(null);
-        // Second invocation: casting non-null to al, will trigger resolution of the class entry
-        testCastingFromObjectToVal(new Point(3,4));
-        // Third invocation: casting null to Point with a resolved class entry");
-        testCastingFromObjectToVal(null);
-        // Fourth invocation: with something not the right type
-        boolean cce = false;
-        try {
-            testCastingFromObjectToVal(new String("NotPoint"));
-        } catch(ClassCastException e) {
-            cce = true;
-        }
-        Asserts.assertTrue(cce,"casting invalid type to val should throw CCE");
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/CircularityTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/CircularityTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/CircularityTest.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test
- * @summary Test initialization of static inline fields with circularity
- * @library /test/lib
- * @compile CircularityTest.java
- * @run main/othervm -Xint -XX:+EnableValhalla runtime.valhalla.valuetypes.CircularityTest
- */
-
-
-public class CircularityTest {
-    static boolean b = true;
-    static int counter = 0;
-    
-    static inline class A {
-	static B b;
-	static C c;
-	int i = 0;
-    }
-
-    static inline class B {
-	static {
-	    Asserts.assertNotNull(A.c, "Should have returned C's default value");
-	}
-	int i = 0;
-    }
-
-    static inline class C {
-	int i;
-	public C(int i) {
-	    this.i = i;
-	}
-    }
-
-    static inline class D {
-	static C c;
-	int i = 0;
-	static {
-	    if (CircularityTest.b) {
-		// throw an exception to cause D's initialization to fail
-		throw new RuntimeException();
-	    }
-	}
-    }
-
-    static inline class E {
-	static F f;
-	static C c;
-	int i = 0;
-    }
-
-    static inline class F {
-	int i = 0;
-	static {
-	    E.c = new C(5);
-	}
-    }
-
-    static inline class G {
-	static H h;
-	int i = 0;
-    }
-
-    static inline class H {
-	int i = 0;
-	static {
-	    if (CircularityTest.b) {
-		// throw an exception to cause H's initialization to fail
-		throw new RuntimeException();
-	    }
-	}
-    }
-
-    static inline class I {
-	static J j;
-	static H h;
-	int i = 0;
-    }
-
-    static inline class J {
-	int i = 0;
-	static {
-	    CircularityTest.counter = 1;
-	    H h = I.h;
-	    CircularityTest.counter = 2;
-	}
-    }
-    
-    static public void main(String[] args) {
-	Throwable exception = null;
-	// Test 1:
-	// Initialization of A will trigger initialization of B which, in its static
-	// initializer will access a static inline field c of A that has not been initialized
-	// yet. The access must succeed (no exception) because the field is being
-	// accessed during the initialization of D, by the thread initializing D,
-	// and the value must be the default value of C (not null).
-	try {
-	    A a = new A();
-	} catch (Throwable t) {
-	    exception = t;
-	}
-	Asserts.assertNull(exception, "Circularity should not have caused exceptions");
-	
-	// Test 2:
-	// Class D will fail to initialized (exception thrown in its static initializer).
-	// Attempt to access a static inline field of D *after* its failed initialization
-	// should trigger an exception.
-	exception = null;
-	try {
-	    D d = new D();
-	} catch (Throwable t) {
-	    // ignoring the exception thrown to cause initialization failure
-	}
-	try {
-	    C c = D.c;
-	} catch (Throwable t) {
-	    exception = t;
-	}
-	Asserts.assertNotNull(exception, "Accessing static fields of a class which failed to initialized should throw an exception");
-	Asserts.assertEquals(exception.getClass(), java.lang.NoClassDefFoundError.class, "Wrong exception class");
-	// Test 3:
-	// Initialization of E will trigger the initialization of F which, in its static initalizer,
-	// will initialized a static inline field of F before the JVM does. The JVM must not
-	// overwrite the value set by user code.
-	E e = new E();
-	Asserts.assertEquals(E.c.i, 5, "JVM must not overwrite fields initialized by user code");
-	
-	// Test 4:
-	// Initialization of G should fail because its static inline field h
-	exception = null;
-	try {
-	    G g = new G();
-	} catch(Throwable t) {
-	    exception = t;
-	}
-	Asserts.assertNotNull(exception, "G's initialization should have failed");
-	Asserts.assertEquals(exception.getClass(), java.lang.ExceptionInInitializerError.class, "Wrong exception");
-	
-	// Test 5:
-	// Initialization of of I should fail when J tries to access I.h
-	exception = null;
-	try {
-	    I i = new I();
-	} catch(Throwable t) {
-	    exception = t;
-	}
-	Asserts.assertNotNull(exception, "I's initialization should have failed");
-	Asserts.assertEquals(exception.getClass(), java.lang.NoClassDefFoundError.class, "Wrong exception");
-	Asserts.assertEquals(CircularityTest.counter, 1, "Didn't failed at the right place");
-    }    
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/CreationErrorTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/CreationErrorTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/CreationErrorTest.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.lang.invoke.*;
-import java.lang.ref.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.*;
-
-import static jdk.test.lib.Asserts.*;
-
-import jdk.experimental.bytecode.MacroCodeBuilder;
-import jdk.experimental.bytecode.MacroCodeBuilder.CondKind;
-import jdk.experimental.bytecode.TypeTag;
-import jdk.test.lib.Platform;
-import jdk.test.lib.Utils;
-
-import jdk.experimental.value.MethodHandleBuilder;
-
-import javax.tools.*;
-
-/**
- * @test CreationErrorTest
- * @summary Test data movement with inline types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @run main/othervm -Xint -Xmx128m -XX:-ShowMessageBoxOnError
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
- *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false
- *                   runtime.valhalla.valuetypes.CreationErrorTest
- */
-
-public class CreationErrorTest {
-
-    static inline class InlineClass {
-        int i = 0;
-    }
-
-    static class IdentityClass {
-        long l = 0L;
-    }
-
-    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
-
-    public static void main(String[] args) {
-        testErroneousObjectCreation();
-        testErroneousValueCreation();
-    }
-
-    static void testErroneousObjectCreation() {
-        MethodHandle testNewOnInlineClass = MethodHandleBuilder.loadCode(
-                LOOKUP,
-                "testNewOnInlineClass",
-                MethodType.methodType(boolean.class),
-                CODE -> {
-                    CODE.new_(InlineClass.class)
-                        .iconst_1()
-                        .return_(TypeTag.Z);
-                });
-        Throwable error = null;
-        try {
-            boolean result = (boolean) testNewOnInlineClass.invokeExact();
-        } catch (Throwable t) {
-            error = t;
-        }
-        System.out.println("error="+error);
-        assertTrue(error != null && error instanceof InstantiationError, "Invariant");
-
-    }
-
-    // Note: this test might become obsolete if defaultvalue is extended to accept identity classes
-    static void testErroneousValueCreation() {
-        MethodHandle testDefaultvalueOnIdentityClass = MethodHandleBuilder.loadCode(
-                LOOKUP,
-                "testDefaultValueOnIdentityClass",
-                MethodType.methodType(boolean.class),
-                CODE -> {
-                    CODE.defaultvalue(IdentityClass.class)
-                        .iconst_1()
-                        .return_(TypeTag.Z);
-                });
-        Throwable error = null;
-        try {
-            boolean result = (boolean) testDefaultvalueOnIdentityClass.invokeExact();
-        } catch (Throwable t) {
-            error = t;
-        }
-        System.out.println("error="+error);
-        assertTrue(error != null && error instanceof IncompatibleClassChangeError, "Invariant");
-
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/EmptyValueTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/EmptyValueTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/EmptyValueTest.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-import java.lang.reflect.Field;
-
-/*
- * @test
- * @summary Test support for empty value types (no instance fields)
- * @library /test/lib
- * @compile -XDallowEmptyValues EmptyValueTest.java
- * @run main/othervm -XX:+EnableValhalla runtime.valhalla.valuetypes.EmptyValueTest
-
- */
-
-public class EmptyValueTest {
-
-    static inline class EmptyValue {
-	public boolean isEmpty() {
-	    return true;
-	}
-    }
-
-    static inline class EmptyField {
-	EmptyValue empty;
-
-	EmptyField() {
-	    this.empty = new EmptyValue();
-	}
-    }
-
-    static class WithInt {
-	int i;
-    }
-
-    static class WithEmptyField extends WithInt  {
-	// With current layout strategy for reference classs, the empty
-	// value field would be placed between the int and the Object
-	// fields, along with some padding.
-	Object o;
-	EmptyValue empty;
-    }
-
-    public static void main(String[] args) {
-	// Create an empty value
-	EmptyValue empty = new EmptyValue();
-	Asserts.assertTrue(empty.isEmpty());
-
-	// Create a value with a empty value field
-	EmptyField emptyField = new EmptyField();
-	Asserts.assertEquals(emptyField.empty.getClass(), EmptyValue.class);
-	Asserts.assertTrue(emptyField.empty.isEmpty());
-	System.out.println(emptyField.empty.isEmpty());
-
-	// Regular instance with an empty field inside
-	WithEmptyField w = new WithEmptyField();
-	Asserts.assertEquals(w.empty.getClass(), EmptyValue.class);
-	Asserts.assertTrue(w.empty.isEmpty());
-	w.empty = new EmptyValue();
-	Asserts.assertEquals(w.empty.getClass(), EmptyValue.class);
-	Asserts.assertTrue(w.empty.isEmpty());
-
-	// Create an array of empty values
-	EmptyValue[] emptyArray = new EmptyValue[100];
-	for(EmptyValue element : emptyArray) {
-	    Asserts.assertEquals(element.getClass(), EmptyValue.class);
-	    Asserts.assertTrue(element.isEmpty());
-	}
-
-	// Testing arrayCopy
-	EmptyValue[] array2 = new EmptyValue[100];
-	// with two arrays
-	System.arraycopy(emptyArray, 10, array2, 20, 50);
-	for(EmptyValue element : array2) {
-	    Asserts.assertEquals(element.getClass(), EmptyValue.class);
-	    Asserts.assertTrue(element.isEmpty());
-	}
-	// single array, no overlap
-	System.arraycopy(emptyArray, 10, emptyArray, 50, 20);
-        for(EmptyValue element : emptyArray) {
-	    Asserts.assertEquals(element.getClass(), EmptyValue.class);
-	    Asserts.assertTrue(element.isEmpty());
-	}
-	// single array with overlap
-	System.arraycopy(emptyArray, 10, emptyArray, 20, 50);
-	for(EmptyValue element : emptyArray) {
-	    Asserts.assertEquals(element.getClass(), EmptyValue.class);
-	    Asserts.assertTrue(element.isEmpty());
-	}
-
-	// Passing an empty value in argument
-	assert isEmpty(empty);
-
-	// Returning an empty value
-	assert getEmpty().isEmpty();
-
-	// Checking fields with reflection
-	Class<?> c = empty.getClass();
-	try {
-	    Field[] fields = c.getDeclaredFields();
-	    Asserts.assertTrue(fields.length == 0);
-	} catch (Throwable t) {
-	    t.printStackTrace();
-	    throw t;
-	}
-	WithEmptyField w0 = new WithEmptyField();
-	Class<?> c2 = w0.getClass();
-	try {
-	    Field emptyfield = c2.getDeclaredField("empty");
-	    EmptyValue e = (EmptyValue)emptyfield.get(w0);
-	    Asserts.assertEquals(e.getClass(), EmptyValue.class);
-	    Asserts.assertTrue(e.isEmpty());
-	    emptyfield.set(w0, new EmptyValue());
-	    e = (EmptyValue)emptyfield.get(w0);
-	    Asserts.assertEquals(e.getClass(), EmptyValue.class);
-	    Asserts.assertTrue(e.isEmpty());
-	} catch(Throwable t) {
-	    t.printStackTrace();
-	    throw new RuntimeException("Reflection tests failed: " + t);
-	}
-
-	// Testing JIT compiler
-	// for(int i=0; i < 100000; i++) {
-	//     test();
-	// }
-    }
-
-    static boolean isEmpty(EmptyValue empty) {
-	return empty.isEmpty();
-    }
-
-    static EmptyValue getEmpty() {
-	return new EmptyValue();
-    }
-
-    static void test() {
-	for(int i=0; i < 10000; i++) {
-	    Asserts.assertTrue(getEmpty().isEmpty());
-	}
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/FlattenableSemanticTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/FlattenableSemanticTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/FlattenableSemanticTest.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import java.lang.invoke.*;
-
-import jdk.experimental.value.MethodHandleBuilder;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test
- * @summary Flattenable field semantic test
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java JumboValue.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator FlattenableSemanticTest.java
- * @run main/othervm -Xint -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.valuetypes.FlattenableSemanticTest
- * @run main/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.valuetypes.FlattenableSemanticTest
- * @run main/othervm -Xcomp -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.valuetypes.FlattenableSemanticTest
- * @run main/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.valuetypes.FlattenableSemanticTest
- * // debug: -XX:+PrintInlineLayout -XX:-ShowMessageBoxOnError
- */
-public class FlattenableSemanticTest {
-
-    static Point.ref nfsp;
-    static Point fsp;
-
-    Point.ref nfip;
-    Point fip;
-
-    static JumboValue.ref nfsj;
-    static JumboValue fsj;
-
-    JumboValue.ref nfij;
-    JumboValue fij;
-
-    static Object getNull() {
-        return null;
-    }
-
-    FlattenableSemanticTest() { }
-
-    public static void main(String[] args) {
-        FlattenableSemanticTest test = new FlattenableSemanticTest();
-
-        // Uninitialized inline fields must be null for non flattenable fields
-        Asserts.assertNull(nfsp, "Invalid non null value for unitialized non flattenable field");
-        Asserts.assertNull(nfsj, "Invalid non null value for unitialized non flattenable field");
-        Asserts.assertNull(test.nfip, "Invalid non null value for unitialized non flattenable field");
-        Asserts.assertNull(test.nfij, "Invalid non null value for unitialized non flattenable field");
-
-        // fsp.equals(null);
-
-        // Uninitialized inline fields must be non null for flattenable fields
-        Asserts.assertNotNull(fsp, "Invalid null value for unitialized flattenable field");
-        Asserts.assertNotNull(fsj, "Invalid null value for unitialized flattenable field");
-        Asserts.assertNotNull(test.fip, "Invalid null value for unitialized flattenable field");
-        Asserts.assertNotNull(test.fij, "Invalid null value for unitialized flattenable field");
-
-        // Assigning null must be allowed for non flattenable inline fields
-        boolean exception = true;
-        try {
-            nfsp = (Point.ref)getNull();
-            nfsp = null;
-            exception = false;
-        } catch (NullPointerException e) {
-            exception = true;
-        }
-        Asserts.assertFalse(exception, "Invalid NPE when assigning null to a non flattenable field");
-
-        try {
-            nfsj = (JumboValue.ref)getNull();
-            nfsj = null;
-            exception = false;
-        } catch (NullPointerException e) {
-            exception = true;
-        }
-        Asserts.assertFalse(exception, "Invalid NPE when assigning null to a non flattenable field");
-
-        try {
-            test.nfip = (Point.ref)getNull();
-            test.nfip = null;
-            exception = false;
-        } catch (NullPointerException e) {
-            exception = true;
-        }
-        Asserts.assertFalse(exception, "Invalid NPE when assigning null to a non flattenable field");
-
-        try {
-            test.nfij = (JumboValue.ref)getNull();
-            test.nfij = null;
-            exception = false;
-        } catch (NullPointerException e) {
-            exception = true;
-        }
-        Asserts.assertFalse(exception, "Invalid NPE when assigning null to a non flattenable field");
-
-        // Assigning null to a flattenable inline field must trigger a NPE
-        exception = false;
-        try {
-            fsp = (Point)getNull();
-        } catch(NullPointerException e) {
-            exception = true;
-        }
-        Asserts.assertTrue(exception, "NPE not thrown when assigning null to a flattenable field");
-        exception = false;
-        try {
-            fsj = (JumboValue)getNull();
-        } catch(NullPointerException e) {
-            exception = true;
-        }
-        Asserts.assertTrue(exception, "NPE not thrown when assigning null to a flattenable field");
-        exception = false;
-        try {
-            test.fip = (Point)getNull();
-        } catch(NullPointerException e) {
-            exception = true;
-        }
-        Asserts.assertTrue(exception, "NPE not thrown when assigning null to a flattenable field");
-        exception = false;
-        try {
-            test.fij = (JumboValue)getNull();
-        } catch(NullPointerException e) {
-            exception = true;
-        }
-        Asserts.assertTrue(exception, "NPE not thrown when assigning null to a flattenable field");
-        exception = false;
-    }
-
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Ifacmp.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/Ifacmp.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Ifacmp.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import java.lang.ref.*;
-
-
-/*
- * @test Ifacmp
- * @requires vm.gc == null
- * @summary if_acmpeq/ne bytecode test
- * @compile Ifacmp.java
- * @run main/othervm -Xint -Xms16m -Xmx16m -XX:+UseSerialGC
- *                   runtime.valhalla.valuetypes.Ifacmp
- * @run main/othervm -Xcomp -Xms16m -Xmx16m -XX:+UseSerialGC
- *                   runtime.valhalla.valuetypes.Ifacmp
- */
-public class Ifacmp {
-
-    static inline class MyValue {
-        int value;
-        public MyValue(int v) { this.value = v; }
-    };
-    static inline class MyValue2 {
-        int value;
-        public MyValue2(int v) { this.value = v; }
-    };
-
-    boolean acmpModeInlineAlwaysFalse = false;
-
-    Object aNull = null;
-    Object bNull = null;
-
-    Object aObject = new String("Hi");
-    Object bObject = new String("Hi");
-
-    Object aValue = new MyValue(1);
-    Object bValue = new MyValue(1);
-    Object cValue = new MyValue(0);
-    Object aValue2 = new MyValue2(4711);
-
-    Object[][] equalUseCases = {
-        { aNull, bNull },
-        { aObject, aObject },
-        { aValue, bValue },
-        { cValue, cValue },
-        { aValue2, aValue2 }
-    };
-
-    int objectEqualsUseCases = 2; // Nof object equals use cases
-
-    // Would just generate these fail case from the "equal set" above,
-    // but to do so needs ==, so write out by hand it is...
-    Object[][] notEqualUseCases = {
-        { aNull, aObject },
-        { aNull, bObject },
-        { aNull, aValue },
-        { aNull, bValue },
-        { aNull, cValue },
-        { aNull, aValue2 },
-        { aObject, bObject },
-        { aObject, aValue },
-        { aObject, bValue },
-        { aObject, cValue },
-        { aObject, aValue2 },
-        { bObject, cValue },
-        { bObject, aValue2 },
-        { aValue, cValue },
-        { aValue, aValue2 },
-    };
-
-    public Ifacmp() { this(false); }
-    public Ifacmp(boolean acmpModeInlineAlwaysFalse) {
-        this.acmpModeInlineAlwaysFalse = acmpModeInlineAlwaysFalse;
-        if (acmpModeInlineAlwaysFalse) {
-            System.out.println("ifacmp always false for inline types");
-        } else {
-            System.out.println("ifacmp substitutability inline types");
-        }
-    }
-
-    public void test() {
-        testAllUseCases();
-    }
-
-    public void testUntilGc(int nofGc) {
-        for (int i = 0; i < nofGc; i++) {
-            System.out.println("GC num " + (i + 1));
-            testUntilGc();
-        }
-    }
-
-    public void testUntilGc() {
-        Reference ref = new WeakReference<Object>(new Object(), new ReferenceQueue<>());
-        do {
-            test();
-        } while (ref.get() != null);
-    }
-
-    public void testAllUseCases() {
-        int useCase = 0;
-        for (Object[] pair : equalUseCases) {
-            useCase++;
-            boolean equal = acmpModeInlineAlwaysFalse ? (useCase <= objectEqualsUseCases) : true;
-            checkEqual(pair[0], pair[1], equal);
-        }
-        for (Object[] pair : notEqualUseCases) {
-            checkEqual(pair[0], pair[1], false);
-        }
-        testLocalValues();
-    }
-
-    public void testValues() {
-        checkEqual(aValue, bValue, true);
-
-        checkEqual(aValue, cValue, false);
-        checkEqual(aValue, aValue2, false);
-        checkEqual(aValue2, bValue, false);
-        checkEqual(aValue2, cValue, false);
-        testLocalValues();
-    }
-
-    public void testLocalValues() {
-        // "aload + ifacmp" should be same as "aaload + ifamcp"
-        // but let's be paranoid...
-        MyValue a = new MyValue(11);
-        MyValue b = new MyValue(11);
-        MyValue c = a;
-        MyValue a1 = new MyValue(7);
-        MyValue2 a2 = new MyValue2(13);
-
-        if (acmpModeInlineAlwaysFalse) {
-            if (a == b) throw new RuntimeException("Always false fail " + a + " == " + b);
-            if (a == c) throw new RuntimeException("Always false fail " + a + " == " + c);
-        } else {
-            if (a != b) throw new RuntimeException("Substitutability test failed" + a + " != " + b);
-            if (a != c) throw new RuntimeException("Substitutability test failed");
-        }
-        if (a == a1) throw new RuntimeException();
-        checkEqual(a, a2, false);
-    }
-
-    boolean shouldEqualSelf(Object a) {
-        return acmpModeInlineAlwaysFalse ? (!(a != null && a.getClass().isInlineClass())) : true;
-    }
-
-    void checkEqual(Object a, Object b, boolean isEqual) {
-        testEquals(a, a, shouldEqualSelf(a));
-        testEquals(b, b, shouldEqualSelf(b));
-        testEquals(a, b, isEqual);
-        testNotEquals(a, b, !isEqual);
-    }
-
-    public static void testEquals(Object a, Object b, boolean expected) {
-        boolean isEqual = (a == b);
-        if (isEqual != expected) {
-            throw new RuntimeException("Expected " + expected + " : "
-                                       + a + " == " + b);
-        }
-    }
-
-    public static void testNotEquals(Object a, Object b, boolean expected) {
-        boolean isNotEqual = (a != b);
-        if (isNotEqual != expected) {
-            throw new RuntimeException("Expected " + expected + " : "
-                                       + a + " != " + b);
-        }
-    }
-
-    public static void main(String[] args) {
-        boolean inlineTypesAlwaysFalse = (args.length > 0) && args[0].equals("alwaysFalse");
-        new Ifacmp(inlineTypesAlwaysFalse).test();
-        new Ifacmp(inlineTypesAlwaysFalse).testUntilGc(3);
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/IntValue.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/IntValue.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/IntValue.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-public inline class IntValue {
-    int val;
-    public IntValue()       { this(0); }
-    public IntValue(int v)  { val = v; }
-    public int getInt()     { return val; }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/JumboValue.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/JumboValue.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/JumboValue.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-public inline final class JumboValue {
-    final long l0;
-    final long l1;
-    final long l2;
-    final long l3;
-    final long l4;
-    final long l5;
-    final long l6;
-    final long l7;
-    final long l8;
-    final long l9;
-    final long l10;
-    final long l11;
-    final long l12;
-    final long l13;
-    final long l14;
-    final long l15;
-    final long l16;
-    final long l17;
-    final long l18;
-    final long l19;
-
-    private JumboValue() {
-        l0 = 0;
-        l1 = 0;
-        l2 = 0;
-        l3 = 0;
-        l4 = 0;
-        l5 = 0;
-        l6 = 0;
-        l7 = 0;
-        l8 = 0;
-        l9 = 0;
-        l10 = 0;
-        l11 = 0;
-        l12 = 0;
-        l13 = 0;
-        l14 = 0;
-        l15 = 0;
-        l16 = 0;
-        l17 = 0;
-        l18 = 0;
-        l19 = 0;
-    }
-
-    public static JumboValue createJumboValue() {
-        JumboValue j = JumboValue.default;
-        return j;
-    }
-
-    public JumboValue update(long l0, long l1) {
-        JumboValue j = __WithField(this.l0, l0);
-        j = __WithField(j.l1, l1);
-        j = __WithField(j.l2, l0 + l1);
-        j = __WithField(j.l3, l1 + l2);
-        j = __WithField(j.l4, l2 + l3);
-        j = __WithField(j.l5, l3 + l4);
-        j = __WithField(j.l6, l4 + l5);
-        j = __WithField(j.l7, l5 + l6);
-        j = __WithField(j.l8, l6 + l7);
-        j = __WithField(j.l9, l7 + l8);
-        j = __WithField(j.l10, l8 + l9);
-        j = __WithField(j.l11, l9 + l10);
-        j = __WithField(j.l12, l10 + l11);
-        j = __WithField(j.l13, l11 + l12);
-        j = __WithField(j.l14, l12 + l13);
-        j = __WithField(j.l15, l13 + l14);
-        j = __WithField(j.l16, l14 + l15);
-        j = __WithField(j.l17, l15 + l16);
-        j = __WithField(j.l18, l16 + l17);
-        j = __WithField(j.l19, l17 + l18);
-        return j;
-    }
-
-    public boolean verify() {
-        return (l2 == (l0 + l1)  &&  l3 == (l1 + l2) && l5 == (l3 + l4)
-            && l6 == (l4 + l5) && l7 == (l5 + l6) && l8 == (l6 + l7)
-            && l9 == (l7 + l8) && l10 == (l8 + l9) && l11 == (l9 + l10)
-            && l12 == (l10 + l11) && l13 == (l11 + l12) && l14 == (l12 + l13)
-            && l15 == (l13 + l14) && l16 == (l14 + l15) && l17 == (l15 + l16)
-            && l18 == (l16 + l17) && l19 == (l17 + l18));
-    }
-
-    public boolean equals(Object o) {
-        if(o instanceof JumboValue) {
-            JumboValue j = (JumboValue)o;
-            return (l0 == j.l0 && l1 == j.l1 && l2 == j.l2 && l3 == j.l3
-                    && l4 == j.l4 && l5 == j.l5 && l6 == j.l6 && l7 == j.l7
-                    && l8 == j.l8 && l9 == j.l9 && l10 == j.l10 && l7 == j.l10
-                    && l11 == j.l11 && l12 == j.l12 && l13 == j.l13 && l4 == j.l14
-                    && l15 == j.l15 && l16 == j.l16 && l17 == j.l17 && l18 == j.l18
-                    && l19 == j.l19);
-        } else {
-            return false;
-        }
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Long8Value.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/Long8Value.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Long8Value.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-public final inline class Long8Value {
-
-    final long longField1;
-    final long longField2;
-    final long longField3;
-    final long longField4;
-    final long longField5;
-    final long longField6;
-    final long longField7;
-    final long longField8;
-
-    private Long8Value(long l1, long l2, long l3, long l4, long l5, long l6, long l7, long l8) {
-        longField1 = l1;
-        longField2 = l2;
-        longField3 = l3;
-        longField4 = l4;
-        longField5 = l5;
-        longField6 = l6;
-        longField7 = l7;
-        longField8 = l8;
-    }
-
-    public long getLongField1() { return longField1; }
-    public long getLongField2() { return longField2; }
-    public long getLongField3() { return longField3; }
-    public long getLongField4() { return longField4; }
-    public long getLongField5() { return longField5; }
-    public long getLongField6() { return longField6; }
-    public long getLongField7() { return longField7; }
-    public long getLongField8() { return longField8; }
-
-    public static Long8Value create(long long1,
-            long long2,
-            long long3,
-            long long4,
-            long long5,
-            long long6,
-            long long7,
-            long long8) {
-        return new Long8Value(long1, long2, long3, long4, long5, long6, long7, long8);
-    }
-
-    static void check(Long8Value value,
-            long long1,
-            long long2,
-            long long3,
-            long long4,
-            long long5,
-            long long6,
-            long long7,
-            long long8) {
-        Asserts.assertEquals(value.getLongField1(), long1, "Field 1 incorrect");
-        Asserts.assertEquals(value.getLongField2(), long2, "Field 2 incorrect");
-        Asserts.assertEquals(value.getLongField3(), long3, "Field 3 incorrect");
-        Asserts.assertEquals(value.getLongField4(), long4, "Field 4 incorrect");
-        Asserts.assertEquals(value.getLongField5(), long5, "Field 5 incorrect");
-        Asserts.assertEquals(value.getLongField6(), long6, "Field 6 incorrect");
-        Asserts.assertEquals(value.getLongField7(), long7, "Field 7 incorrect");
-        Asserts.assertEquals(value.getLongField8(), long8, "Field 8 incorrect");
-    }
-
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/NewInstanceFromConstructor.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/NewInstanceFromConstructor.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/NewInstanceFromConstructor.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-
-package runtime.valhalla.valuetypes;
-
-public class NewInstanceFromConstructor {
-
-    int value;
-    static int consCalls = 0;
-
-    public NewInstanceFromConstructor() {
-        this(0);
-    }
-
-    public NewInstanceFromConstructor(int v) {
-        value = v;
-        consCalls++;
-    }
-
-    public NewInstanceFromConstructor(IntValue v) {
-        this(v.getInt());
-    }
-
-    public NewInstanceFromConstructor(IntValue v1,
-                                      IntValue v2) {
-        this(v1.getInt() + v2.getInt());
-    }
-
-    public NewInstanceFromConstructor(IntValue v1,
-                                      String s) {
-        this(v1);
-        throw new RuntimeException(s);
-    }
-
-    public int getValue() { return value; }
-
-    public static int getConsCalls() { return consCalls; }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ObjectMethods.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ObjectMethods.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ObjectMethods.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import java.lang.invoke.*;
-
-import jdk.experimental.value.MethodHandleBuilder;
-
-/*
- * @test ObjectMethods
- * @summary Check object method implemented by the VM behave with value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ObjectMethods.java
- * @run main/othervm -Xint -XX:+UseBiasedLocking -XX:+UseCompressedClassPointers runtime.valhalla.valuetypes.ObjectMethods
- * @run main/othervm -Xint -XX:-UseBiasedLocking -XX:-UseCompressedClassPointers runtime.valhalla.valuetypes.ObjectMethods
- * @run main/othervm -Xint -noverify runtime.valhalla.valuetypes.ObjectMethods noverify
- * @run main/othervm -Xcomp -XX:+UseBiasedLocking -XX:+UseCompressedClassPointers runtime.valhalla.valuetypes.ObjectMethods
- * @run main/othervm -Xcomp -XX:-UseBiasedLocking -XX:-UseCompressedClassPointers runtime.valhalla.valuetypes.ObjectMethods
- * @run main/othervm -Xcomp -noverify runtime.valhalla.valuetypes.ObjectMethods noverify
- */
-
-public class ObjectMethods {
-
-    public static void main(String[] args) {
-        testObjectMethods((args.length > 0 && args[0].equals("noverify")));
-    }
-
-    public static void testObjectMethods(boolean verifierDisabled) {
-        MyInt val = MyInt.create(7);
-        MyInt sameVal = MyInt.create(7);
-
-        // Exercise all the Object native/VM methods...
-
-        if (verifierDisabled) { // Just noverifier...
-            checkMonitorExit(val);
-            return;
-        }
-
-        // getClass()
-        checkGetClass(val, MyInt.class);
-
-        //hashCode()/identityHashCode()
-        checkHashCodes(val, sameVal.hashCode());
-
-        // clone()
-        checkNotCloneable(val);
-
-        // synchronized
-        checkSynchronized(val);
-
-        // wait/notify()
-        checkWait(val);
-        checkNotify(val);
-
-        System.gc();
-    }
-
-
-    static void checkGetClass(Object val, Class<?> expectedClass) {
-        Class<?> clazz = val.getClass();
-        if (clazz == null) {
-            throw new RuntimeException("getClass return null");
-        } else if (clazz != expectedClass) {
-            throw new RuntimeException("getClass (" + clazz + ") doesn't match " + expectedClass);
-        }
-    }
-
-    // Just check we don't crash the VM
-    static void checkHashCodes(Object val, int expectedHashCode) {
-        if (val.hashCode() != expectedHashCode) {
-            throw new RuntimeException("Hash code mismatch value: " + val.hashCode() +
-                                       " expected: " + expectedHashCode);
-        }
-    }
-
-    static void checkNotCloneable(MyInt val) {
-        boolean sawCnse = false;
-        try {
-            val.attemptClone();
-        } catch (CloneNotSupportedException cnse) {
-            sawCnse = true;
-        }
-        if (!sawCnse) {
-            throw new RuntimeException("clone() did not fail");
-        }
-        // Cloneable inline type checked by "BadValueTypes" CFP tests
-    }
-
-    static void checkSynchronized(Object val) {
-        boolean sawImse = false;
-        try {
-            synchronized (val) {
-                throw new IllegalStateException("Unreachable code, reached");
-            }
-        } catch (IllegalMonitorStateException imse) {
-            sawImse = true;
-        }
-        if (!sawImse) {
-            throw new RuntimeException("monitorenter did not fail");
-        }
-        // synchronized method modifiers tested by "BadValueTypes" CFP tests
-        // jni monitor ops tested by "ValueWithJni"
-    }
-
-    // Check we haven't broken the mismatched monitor block check...
-    static void checkMonitorExit(Object val) {
-        boolean sawImse = false;
-        try {
-            MethodHandleBuilder.loadCode(MethodHandles.lookup(),
-                                         "mismatchedMonitorExit",
-                                         MethodType.methodType(Void.TYPE, Object.class),
-                                         CODE->{
-                                             CODE
-                                                 .aload(0)
-                                                 .monitorexit()
-                                                 .return_();
-                                         }).invokeExact(val);
-            throw new IllegalStateException("Unreachable code, reached");
-        } catch (Throwable t) {
-            if (t instanceof IllegalMonitorStateException) {
-                sawImse = true;
-            } else {
-                throw new RuntimeException(t);
-            }
-        }
-        if (!sawImse) {
-            throw new RuntimeException("monitorexit did not fail");
-        }
-    }
-
-    static void checkWait(Object val) {
-        boolean sawImse = false;
-        try {
-            val.wait();
-        } catch (IllegalMonitorStateException imse) {
-            sawImse = true;
-        } catch (InterruptedException intExc) {
-            throw new RuntimeException(intExc);
-        }
-        if (!sawImse) {
-            throw new RuntimeException("wait() did not fail");
-        }
-
-        sawImse = false;
-        try {
-            val.wait(1l);
-        } catch (IllegalMonitorStateException imse) {
-            sawImse = true;
-        } catch (InterruptedException intExc) {
-            throw new RuntimeException(intExc);
-        }
-        if (!sawImse) {
-            throw new RuntimeException("wait() did not fail");
-        }
-
-        sawImse = false;
-        try {
-            val.wait(0l, 100);
-        } catch (IllegalMonitorStateException imse) {
-            sawImse = true;
-        } catch (InterruptedException intExc) {
-            throw new RuntimeException(intExc);
-        }
-        if (!sawImse) {
-            throw new RuntimeException("wait() did not fail");
-        }
-    }
-
-    static void checkNotify(Object val) {
-        boolean sawImse = false;
-        try {
-            val.notify();
-        } catch (IllegalMonitorStateException imse) {
-            sawImse = true;
-        }
-        if (!sawImse) {
-            throw new RuntimeException("notify() did not fail");
-        }
-
-        sawImse = false;
-        try {
-            val.notifyAll();
-        } catch (IllegalMonitorStateException imse) {
-            sawImse = true;
-        }
-        if (!sawImse) {
-            throw new RuntimeException("notifyAll() did not fail");
-        }
-    }
-
-    static final inline class MyInt {
-        final int value;
-        private MyInt() { value = 0; }
-        public static MyInt create(int v) {
-            MyInt mi = MyInt.default;
-            mi = __WithField(mi.value, v);
-            return mi;
-        }
-        public Object attemptClone() throws CloneNotSupportedException {
-            try { // Check it is not possible to clone...
-                MethodHandles.Lookup lookup = MethodHandles.lookup();
-                MethodHandle mh = lookup.findVirtual(getClass(),
-                                                     "clone",
-                                                     MethodType.methodType(Object.class));
-                return mh.invokeExact(this);
-            } catch (Throwable t) {
-                if (t instanceof CloneNotSupportedException) {
-                    throw (CloneNotSupportedException) t;
-                }
-                throw new RuntimeException(t);
-            }
-        }
-    }
-
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Person.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/Person.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Person.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-public final inline class Person {
-
-    final int    id;
-    final String firstName;
-    final String lastName;
-
-    private Person(int id, String firstName, String lastName) {
-        this.id = id;
-        this.firstName = firstName;
-        this.lastName = lastName;
-    }
-
-    public int getId() { return id; }
-    public String getFirstName() { return firstName; }
-    public String getLastName() { return lastName; }
-
-    public String toString() {
-        return getFirstName() + " " + getLastName() + " (id=" + getId() + ")";
-    }
-
-    static Person create(int id, String firstName, String lastName) {
-        return new Person(id, firstName, lastName);
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/PersonVcc.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/PersonVcc.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/PersonVcc.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-@jdk.incubator.mvt.ValueCapableClass
-public final class PersonVcc {
-    final int id;
-    final String firstName;
-    final String lastName;
-
-    private PersonVcc(int id, String firstName, String lastName) {
-        this.id = id;
-        this.firstName = firstName;
-        this.lastName = lastName;
-    }
-
-    public int getId() { return id; }
-    public String getFirstName() { return firstName; }
-    public String getLastName() { return lastName; }
-
-    public String toString() {
-        return getFirstName() + " " + getLastName() + " (id=" + getId() + ")";
-    }
-
-    public static PersonVcc create(int id, String firstName, String lastName) {
-        return new PersonVcc(id, firstName, lastName);
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Point.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/Point.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Point.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-public inline final class Point {
-    final int x;
-    final int y;
-
-    private Point(int x, int y) {
-        this.x = x;
-        this.y = y;
-    }
-
-    public int getX() { return x; }
-    public int getY() { return y; }
-
-    public boolean isSamePoint(Point that) {
-        return this.getX() == that.getX() && this.getY() == that.getY();
-    }
-
-    public String toString() {
-        return "Point: x=" + getX() + " y=" + getY();
-    }
-
-    public boolean equals(Object o) {
-        if(o instanceof Point) {
-            return ((Point)o).x == x &&  ((Point)o).y == y;
-        } else {
-            return false;
-        }
-    }
-
-    public static Point createPoint(int x, int y) {
-        return new Point(x, y);
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/QuickeningTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/QuickeningTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/QuickeningTest.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test QuickeningTest
- * @summary Test quickening of getfield and putfield applied to inline fields
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java JumboValue.java QuickeningTest.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.QuickeningTest
- * @run main/othervm -Xcomp runtime.valhalla.valuetypes.QuickeningTest
- */
-
-public class QuickeningTest {
-
-    static class Parent {
-    Point.ref nfp;       /* Not flattenable inline field */
-    Point fp;         /* Flattenable and flattened inline field */
-    JumboValue fj;    /* Flattenable not flattened inline field */
-
-        public void setNfp(Point p) { nfp = p; }
-        public void setFp(Point p) { fp = p; }
-        public void setFj(JumboValue j) { fj = j; }
-    }
-
-    static class Child extends Parent {
-        // This class inherited fields from the Parent class
-        Point.ref nfp2;      /* Not flattenable inline field */
-        Point fp2;        /* Flattenable and flattened inline field */
-        JumboValue fj2;   /* Flattenable not flattened inline field */
-
-        public void setNfp2(Point p) { nfp2 = p; }
-        public void setFp2(Point p)  { fp2 = p; }
-        public void setFj2(JumboValue j) { fj2 = j; }
-    }
-
-    static final inline class Value {
-        final Point.ref nfp;       /* Not flattenable inline field */
-        final Point fp;         /* Flattenable and flattened inline field */
-        final JumboValue fj;    /* Flattenable not flattened inline field */
-
-        private Value() {
-            nfp = Point.createPoint(0, 0);
-            fp = Point.createPoint(0, 0);
-            fj = JumboValue.createJumboValue();
-        }
-
-        public static Value create() {
-            return Value.default;
-        }
-    }
-
-    static void testUninitializedFields() {
-        Parent p = new Parent();
-        Asserts.assertEquals(p.nfp, null, "invalid uninitialized not flattenable");
-        Asserts.assertEquals(p.fp.x, 0, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(p.fp.y, 0, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(p.fj.l0, 0L, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(p.fj.l1, 0L, "invalid value for uninitialized flattened field");
-
-        Child c = new Child();
-        Asserts.assertEquals(c.nfp, null, "invalid uninitialized not flattenable field");
-        Asserts.assertEquals(c.fp.x, 0, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(c.fp.y, 0, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(c.fj.l0, 0L, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(c.fj.l1, 0L, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(c.nfp2, null, "invalid uninitialized not flattenable");
-        Asserts.assertEquals(c.fp2.x, 0, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(c.fp2.y, 0, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(c.fj2.l0, 0L, "invalid value for uninitialized not flattened field");
-        Asserts.assertEquals(c.fj2.l1, 0L, "invalid value for uninitialized not flattened field");
-
-        Value v = Value.create();
-        Asserts.assertEquals(v.nfp, null, "invalid uninitialized not flattenable");
-        Asserts.assertEquals(v.fp.x, 0, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(v.fp.y, 0, "invalid value for uninitialized flattened field");
-        Asserts.assertEquals(v.fj.l0, 0L, "invalid value for uninitialized not flattened field");
-        Asserts.assertEquals(v.fj.l1, 0L, "invalid value for uninitialized not flattened field");
-    }
-
-    static void testPutfieldAndGetField() {
-        Point p1 = Point.createPoint(16, 47);
-        Point p2 = Point.createPoint(32, 64);
-
-        JumboValue j1 = JumboValue.createJumboValue().update(4, 5);
-        JumboValue j2 = JumboValue.createJumboValue().update(7, 9);
-
-        Parent p = new Parent();
-        // executing each setter twice to test quickened bytecodes
-        p.setNfp(p1);
-        p.setNfp(p2);
-        p.setFp(p2);
-        p.setFp(p1);
-        p.setFj(j1);
-        p.setFj(j2);
-
-        Asserts.assertTrue(p.nfp.equals(p2), "invalid updated not flattenable field");
-        Asserts.assertEquals(p.fp.x, 16, "invalid value for updated flattened field");
-        Asserts.assertEquals(p.fp.y, 47, "invalid value for updated flattened field");
-        Asserts.assertTrue(p.fj.equals(j2), "invalid value for updated not flattened field");
-
-        Child c = new Child();
-        c.setNfp(p1);
-        c.setNfp(p2);
-        c.setFp(p2);
-        c.setFp(p1);
-        c.setFj(j1);
-        c.setFj(j2);
-        c.setNfp2(p2);
-        c.setNfp2(p1);
-        c.setFp2(p1);
-        c.setFp2(p2);
-        c.setFj2(j2);
-        c.setFj2(j1);
-
-        Asserts.assertTrue(c.nfp.equals(p2), "invalid updated not flattenable field");
-        Asserts.assertEquals(c.fp.x, 16, "invalid value for updated flattened field");
-        Asserts.assertEquals(c.fp.y, 47, "invalid value for updated flattened field");
-        Asserts.assertTrue(c.fj.equals(j2), "invalid value for updated not flattened field");
-
-        Asserts.assertTrue(c.nfp2.equals(p1), "invalid updated not flattenable field");
-        Asserts.assertEquals(c.fp2.x, 32, "invalid value for updated flattened field");
-        Asserts.assertEquals(c.fp2.y, 64, "invalid value for updated flattened field");
-        Asserts.assertTrue(c.fj2.equals(j1), "invalid value for updated not flattened field");
-    }
-
-    public static void main(String[] args) {
-        testUninitializedFields();
-        testUninitializedFields(); // run twice to test quickened bytecodes
-        testPutfieldAndGetField();
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/StaticFieldsTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/StaticFieldsTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/StaticFieldsTest.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test
- * @summary Test circularity in static fields
- * @library /test/lib
- * @compile StaticFieldsTest.java
- * @run main/othervm -Xint -XX:+EnableValhalla runtime.valhalla.valuetypes.StaticFieldsTest
- */
-
-public class StaticFieldsTest {
-
-
-    // ClassA and ClassB have a simple cycle in their static fields, but they should
-    // be able to load and initialize themselves successfully. Access to these
-    // static fields after their initialization should return the default value.
-    static inline class ClassA {
-	static ClassB b;
-	public int i;
-	
-	public ClassA() {
-	    i = 3;
-	}
-    }
-
-    static inline class ClassB {
-	static ClassA a;
-	public int i;
-	
-	public ClassB() {
-	    i = 700;
-	}
-    }
-
-    // ClassC has a reference to itself in its static field, but it should be able
-    // to initialize itelf successfully. Access to this static field after initialization
-    // should return the default value.
-    static inline class ClassC {
-	static ClassC c;
-	int i;
-
-	public ClassC() {
-	    i = 42;
-	}
-    }
-
-
-    // ClassD and ClassE have circular references in their static fields, and they
-    // read these static fields during their initialization, the value read from
-    // these fields should be the default value. Both classes should initialize
-    // successfully.
-    static inline class ClassD {
-	static ClassE e;
-	int i;
-
-	static {
-	    Asserts.assertEquals(e.i, 0, "Static field e.i incorrect");
-	}
-	
-	public ClassD() {
-	    i = 42;
-	}
-    }
-
-    static inline class ClassE {
-	static ClassD d;
-	int i;
-
-	static {
-	    Asserts.assertEquals(d.i, 0, "Static field d.i incorrect");
-	}
-	
-	public ClassE() {
-	    i = 42;
-	}
-    }
-
-    // ClassF and ClassG have circular references in their static fields, and they
-    // create new instances of each other type to initialize these static fields
-    // during their initialization. Both classes should initialize successfully.
-    static inline class ClassF {
-	static ClassG g;
-	int i;
-
-	static {
-	    g = new ClassG();
-	    Asserts.assertEquals(g.i, 64, "Static field ClassF.g.i incorrect");
-	}
-
-	ClassF() {
-	    i = 314;
-	}
-    }
-
-    static inline class ClassG {
-	static ClassF f;
-	int i;
-
-	static {
-	    f = new ClassF();
-	    Asserts.assertEquals(f.i, 314, "Static field ClassG.f.i incorrect");
-	}
-
-	ClassG() {
-	    i = 64;
-	}
-    }
-    
-    public static void main(String[] args) {
-	Asserts.assertEquals(ClassA.b.i, 0, "Static field ClassA.b.i incorrect");
-	Asserts.assertEquals(ClassB.a.i, 0, "Static field Classb.a.i incorrect");
-	Asserts.assertEquals(ClassC.c.i, 0, "Static field ClassC.c.i incorrect");
-	new ClassD();
-	new ClassF();
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Test8186715.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/Test8186715.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/Test8186715.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-/*
- * @test Test8186715
- * @summary test return of buffered inline type passed in argument by caller
- * @library /test/lib
- * @compile -XDemitQtypes -XDallowWithFieldOperator -XDenableValueTypes Test8186715.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.Test8186715
- * @run main/othervm runtime.valhalla.valuetypes.Test8186715
- */
-
-public class Test8186715 {
-
-    public static void main(String[] args) {
-        MyValueType v = MyValueType.testDefault();
-
-        for (int i = 0; i < 1000000; i++) {
-            MyValueType.testBranchArg1(false, v);
-        }
-    }
-}
-
-inline final class MyValueType {
-    final int i;
-    final int j;
-
-    private MyValueType() {
-        i = 0;
-        j = 0;
-    }
-
-    static MyValueType testDefault() {
-        return MyValueType.default;
-    }
-
-    static MyValueType testBranchArg1(boolean flag, MyValueType v1) {
-        if (flag) {
-            v1 = __WithField(v1.i, 3);
-            v1 = __WithField(v1.j, 4);
-        }
-        return v1;
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestFieldNullability.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestFieldNullability.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestFieldNullability.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/**
- * @test TestFieldNullability
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator TestFieldNullability.java
- * @run main/othervm -Xint -Xmx128m -XX:-ShowMessageBoxOnError -XX:InlineFieldMaxFlatSize=32
- *                   runtime.valhalla.valuetypes.TestFieldNullability
- */
-
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-public class TestFieldNullability {
-    static inline class MyValue {
-        int x;
-
-        public MyValue() {
-            x = 314;
-        }
-    }
-
-    static inline class MyBigValue {
-        long l0, l1, l2, l3, l4, l5, l6, l7, l8, l9;
-        long l10, l11, l12, l13, l14, l15, l16, l17, l18, l19;
-
-        public MyBigValue() {
-            l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = 271;
-            l10 = l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = 271;
-        }
-    }
-
-    static inline class TestValue {
-        final MyValue.ref nullableField;
-        final MyValue nullfreeField;        // flattened
-        final MyValue.ref nullField;           // src of null
-        final MyBigValue nullfreeBigField;  // not flattened
-        final MyBigValue.ref nullBigField;     // src of null
-
-        public void test() {
-            Asserts.assertNull(nullField, "Invalid non null value for uninitialized non flattenable field");
-            Asserts.assertNull(nullBigField, "Invalid non null value for uninitialized non flattenable field");
-            boolean NPE = false;
-            try {
-                TestValue tv = __WithField(this.nullableField, nullField);
-            } catch(NullPointerException e) {
-                NPE = true;
-            }
-            Asserts.assertFalse(NPE, "Invalid NPE when assigning null to a non flattenable field");
-            try {
-                TestValue tv = __WithField(this.nullfreeField, (MyValue) nullField);
-            } catch(NullPointerException e) {
-                NPE = true;
-            }
-            Asserts.assertTrue(NPE, "Missing NPE when assigning null to a flattened field");
-            try {
-                TestValue tv = __WithField(this.nullfreeBigField, (MyBigValue) nullBigField);
-            } catch(NullPointerException e) {
-                NPE = true;
-            }
-            Asserts.assertTrue(NPE, "Missing NPE when assigning null to a flattenable field");
-        }
-
-        public TestValue() {
-            nullableField = MyValue.default;
-            nullfreeField = MyValue.default;
-            nullField = MyValue.default;           // fake assignment
-            nullfreeBigField = MyBigValue.default;
-            nullBigField = MyBigValue.default;     // fake assignment
-
-        }
-    }
-
-    static class TestClass {
-        MyValue.ref nullableField;
-        MyValue nullfreeField;       // flattened
-        MyValue.ref nullField;
-        MyBigValue nullfreeBigField; // not flattened
-        MyBigValue.ref nullBigField;
-
-        public void test() {
-            Asserts.assertNull(nullField, "Invalid non null value for uninitialized non flattenable field");
-            Asserts.assertNull(nullBigField, "Invalid non null value for uninitialized non flattenable field");
-            boolean NPE = false;
-            try {
-                nullableField = nullField;
-            } catch(NullPointerException e) {
-                NPE = true;
-            }
-            Asserts.assertFalse(NPE, "Invalid NPE when assigning null to a non flattenable field");
-            try {
-                this.nullfreeField = (MyValue) nullField;
-            } catch(NullPointerException e) {
-                NPE = true;
-            }
-            Asserts.assertTrue(NPE, "Missing NPE when assigning null to a flattened field");
-            try {
-                this.nullfreeBigField = (MyBigValue) nullBigField;
-            } catch(NullPointerException e) {
-                NPE = true;
-            }
-            Asserts.assertTrue(NPE, "Missing NPE when assigning null to a flattenable field");
-        }
-    }
-
-    public static void main(String[] args) {
-        TestClass tc = new TestClass();
-        tc.test();
-        TestValue tv =
-            TestValue.default;
-        tv.test();
-    }
-
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestInheritedValueTypeFields.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestInheritedValueTypeFields.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestInheritedValueTypeFields.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test TestInheritedValueTypeFields
- * @summary Test if inline field klasses are correctly retrieved for inherited fields
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers Point.java TestInheritedValueTypeFields.java
- * @run main/othervm runtime.valhalla.valuetypes.TestInheritedValueTypeFields
- */
-
-class A {
-    Point p;
-}
-
-class B extends A {
-
-}
-
-class C extends B {
-    int i;
-}
-
-class D {
-    long l;
-}
-
-class E extends D {
-    Point p1;
-}
-
-class F extends E {
-
-}
-
-class G extends F {
-    Point p2;
-}
-
-public class TestInheritedValueTypeFields {
-
-    public static void main(String[] args) {
-        for (int i = 0; i < 100000; i++) {
-            run();
-        }
-    }
-
-    public static void run() {
-        B b = new B();
-        Asserts.assertEquals(b.p.x, 0);
-        Asserts.assertEquals(b.p.y, 0);
-        b.p = Point.createPoint(1,2);
-        Asserts.assertEquals(b.p.x, 1);
-        Asserts.assertEquals(b.p.y, 2);
-
-        G g = new G();
-        Asserts.assertEquals(g.p1.x, 0);
-        Asserts.assertEquals(g.p1.y, 0);
-        Asserts.assertEquals(g.p2.x, 0);
-        Asserts.assertEquals(g.p2.y, 0);
-        g.p1 = Point.createPoint(1,2);
-        g.p2 = Point.createPoint(3,4);
-        Asserts.assertEquals(g.p1.x, 1);
-        Asserts.assertEquals(g.p1.y, 2);
-        Asserts.assertEquals(g.p2.x, 3);
-        Asserts.assertEquals(g.p2.y, 4);
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIArrays.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIArrays.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIArrays.java
+++ /dev/null
@@ -1,886 +0,0 @@
-/*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-
-import jdk.test.lib.Asserts;
-
-import java.lang.reflect.*;
-import java.util.Random;
-import java.util.Arrays;
-import java.util.Comparator;
-
-import jdk.internal.misc.Unsafe;
-import jdk.internal.vm.jni.SubElementSelector;
-
-/*
- * @test
- * @summary Test flattened arrays accesses through JNI
- * @modules java.base/jdk.internal.misc java.base/jdk.internal.vm.jni
- * @library /testlibrary /test/lib
- * @requires (os.simpleArch == "x64")
- * @requires (os.family == "linux" | os.family == "mac")
- * @compile -XDallowWithFieldOperator TestJNIArrays.java
- * @run main/othervm/native/timeout=3000 -XX:FlatArrayElementMaxSize=128 -XX:+UseCompressedOops TestJNIArrays
- * @run main/othervm/native/timeout=3000 -XX:FlatArrayElementMaxSize=128 -XX:-UseCompressedOops TestJNIArrays
- */
-public class TestJNIArrays {
-
-    static final Unsafe U = Unsafe.getUnsafe();
-
-    public static final int ARRAY_SIZE = 1024;
-    static long seed;
-    static Random random;
-
-    static {
-        seed = System.nanoTime();
-        System.out.println("Seed = " + seed);
-        random = new Random(seed);
-    }
-
-    static {
-        System.loadLibrary("TestJNIArrays");
-    }
-
-    static inline class IntInt {
-        int i0;
-        int i1;
-
-        public IntInt(int i0, int i1) {
-            this.i0 = i0;
-            this.i1 = i1;
-        }
-    }
-
-    static class IntIntComparator implements Comparator<IntInt.ref> {
-        public int compare(IntInt.ref a, IntInt.ref b) {
-            if (a.i0 < b.i0) return -1;
-            if (a.i0 > b.i0) return 1;
-            if (a.i1 < b.i1) return -1;
-            if (a.i1 > b.i1) return 1;
-            return 0;
-        }
-    }
-
-    static inline class Containee {
-        float f;
-        short s;
-
-        Containee(float f, short s) {
-            this.f = f;
-            this.s = s;
-        }
-    }
-
-    static inline class Container {
-        double d;
-        Containee c;
-        byte b;
-
-        Container(double d, Containee c, byte b) {
-            this.d = d ;
-            this.c = c;
-            this.b = b;
-        }
-
-        Container setc(Containee c) {
-            Container res = __WithField(this.c, c);
-            return res;
-        }
-
-    }
-
-    static inline class LongLongLongLong {
-        long l0, l1, l2, l3;
-
-        public LongLongLongLong(long l0, long l1, long l2, long l3) {
-            this.l0 = l0;
-            this.l1 = l1;
-            this.l2 = l2;
-            this.l3 = l3;
-        }
-    }
-
-    static inline class BigValue {
-        long l0 = 0, l1 = 0,   l2 = 0, l3 = 0, l4 = 0, l5 = 0, l6 = 0, l7 = 0, l8 = 0, l9 = 0;
-        long l10 = 0, l11 = 0, l12 = 0, l13 = 0, l14 = 0, l15 = 0, l16 = 0, l17 = 0, l18 = 0, l19 = 0;
-        long l20 = 0, l21 = 0, l22 = 0, l23 = 0, l24 = 0, l25 = 0, l26 = 0, l27 = 0, l28 = 0, l29 = 0;
-        long l30 = 0, l31 = 0, l32 = 0, l33 = 0, l34 = 0, l35 = 0, l36 = 0, l37 = 0, l38 = 0, l39 = 0;
-    }
-
-    static inline class ValueWithOops {
-        String s = "bonjour";
-        int i = 0;
-        Containee c = new Containee(2.3f, (short)4);
-        BigValue b = new BigValue();
-    }
-
-    public static void main(String[] args) {
-        TestJNIArrays test = new TestJNIArrays();
-        test.checkGetFlattenedArrayElementSize();
-        test.checkGetFlattenedArrayElementClass();
-        test.checkGetFieldOffsetInFlattenedLayout();
-        test.checkGetFlattenedArrayElements();
-        test.checkSubElementAPI();
-        test.checkBehaviors();
-
-        // TODO: move these to micro-benchmark or out of tier1 testing...
-        // test.measureInitializationTime(1024 * 1024 * 10 , 1000);
-        // test.measureInitializationTime2(1024 * 1024 * 10 , 1000);
-        // test.measureUpdateTime2(1024 * 1024 * 10, 1000);
-        // test.measureSortingTime(1024 * 1024, 100); // reduced number of iterations because Java sorting is slow (because of generics?)
-        //test.measureInitializationTime3(1024 * 1024 * 2 , 10);
-    }
-
-    void checkSubElementAPI() {
-        Throwable e = null;
-        ValueWithOops[] arrayWithOops = new ValueWithOops[100];
-        ValueWithOops v = new ValueWithOops();
-        for (int i = 0; i < 100; i++) {
-            arrayWithOops[i] = v;
-        }
-        SubElementSelector selector1 = createSubElementSelector(arrayWithOops);
-        SubElementSelector selector2 = getSubElementSelector(selector1, ValueWithOops.class, "s", "Ljava/lang/String;");
-        String s = (String) getObjectSubElement(arrayWithOops, selector2, 1);
-        System.out.println("s = " + s);
-        Asserts.assertEquals(s.equals("bonjour"), true, "Wrong string, expecting \"bonjour\", got " + s);
-        SubElementSelector selector3 = getSubElementSelector(selector1, ValueWithOops.class, "c", "QTestJNIArrays$Containee;");
-        Containee c = (Containee) getObjectSubElement(arrayWithOops, selector3, 2);
-        Asserts.assertEquals(c.f, 2.3f, "Wrong float value: " + c.f);
-        Asserts.assertEquals(c.s, (short)4, "Wrong short value " + c.s);
-        setObjectSubElement(arrayWithOops, selector2, 1, "Hello");
-        Asserts.assertEquals(arrayWithOops[1].s.equals("Hello"), true, "Wrong string, expecting \"Hello\", got " + s);
-        Integer myInteger = new Integer(345);
-        e = null;
-        try {
-            setObjectSubElement(arrayWithOops, selector2, 1, myInteger);
-        } catch(Throwable t) {
-            e = t;
-        }
-        Asserts.assertNotNull(e, "An exception should have been thrown");
-        Asserts.assertEquals(e.getClass(), java.lang.ArrayStoreException.class, "Wrong exception type");
-        c = new Containee(9.8f, (short)-3);
-        setObjectSubElement(arrayWithOops, selector3, 2, c);
-        Asserts.assertEquals(c.f, 9.8f, "Wrong float value: " + c.f);
-        Asserts.assertEquals(c.s, (short)-3, "Wrong short value " + c.s);
-        e = null;
-        try {
-            setObjectSubElement(arrayWithOops, selector3, 2, null);
-        } catch(Throwable t) {
-            e = t;
-        }
-        Asserts.assertNotNull(e, "An exception should have been thrown");
-        Asserts.assertEquals(e.getClass(), java.lang.ArrayStoreException.class, "Wrong exception type");
-        SubElementSelector selector4 = getSubElementSelector(selector3, TestJNIArrays.Containee.class, "s", "S");
-        short s2 = getShortSubElement(arrayWithOops, selector4, 3);
-        Asserts.assertEquals(s2, (short)4, "Wrong short value " + s2);
-        setShortSubElement(arrayWithOops, selector4, 3, (short)7);
-        Asserts.assertEquals(arrayWithOops[3].c.s, (short)7, "Wrong short value " + arrayWithOops[3].c.s);
-        e = null;
-        try {
-            // should fail because selector4 designates a field with type short, not int
-            getIntSubElement(arrayWithOops, selector4, 3);
-        } catch(Throwable t) {
-            e = t;
-        }
-        Asserts.assertNotNull(e, "An exception should have been thrown");
-        Asserts.assertEquals(e.getClass(), java.lang.IllegalArgumentException.class, "Wrong exception type");
-        SubElementSelector selector5 = getSubElementSelector(selector1, ValueWithOops.class, "b", "QTestJNIArrays$BigValue;");
-        e = null;
-        try {
-            // Should fail because selector5 designates a non-flattened field
-            SubElementSelector selector6 = getSubElementSelector(selector5, TestJNIArrays.BigValue.class, "l0", "J");
-        } catch(Throwable t) {
-            e = t;
-        }
-        Asserts.assertNotNull(e, "An exception should have been thrown");
-        Asserts.assertEquals(e.getClass(), java.lang.IllegalArgumentException.class, "Wrong exception type");
-        System.gc();
-    }
-
-    void checkGetFlattenedArrayElementSize() {
-        Throwable exception = null;
-        try {
-            Object o = new Object();
-            GetFlattenedArrayElementSizeWrapper(o);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            int[] array = new int[16];
-            Object o = array;
-            GetFlattenedArrayElementSizeWrapper(o);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            GetFlattenedArrayElementSizeWrapper(new String[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            // Array of BigValue should not be flattened because BigValue is *big*
-            GetFlattenedArrayElementSizeWrapper(new BigValue[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertTrue(exception instanceof IllegalArgumentException , "Exception should be a IAE");
-        exception = null;
-        int size = -1;
-        try {
-            size = GetFlattenedArrayElementSizeWrapper(new IntInt[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNull(exception, "No exception should have been thrown");
-        Asserts.assertEquals(size, 8, "Wrong size");
-    }
-
-    void checkGetFlattenedArrayElementClass() {
-        Throwable exception = null;
-        try {
-            Object o = new Object();
-            GetFlattenedArrayElementClassWrapper(o);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            int[] array = new int[16];
-            Object o = array;
-            GetFlattenedArrayElementClassWrapper(o);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            GetFlattenedArrayElementClassWrapper(new String[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            // Array of BigValue should not be flattened because BigValue is *big*
-            GetFlattenedArrayElementClassWrapper(new BigValue[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertTrue(exception instanceof IllegalArgumentException , "Exception should be a IAE");
-        exception = null;
-        Class c = null;
-        try {
-            c = GetFlattenedArrayElementClassWrapper(new IntInt[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNull(exception, "No exception should have been thrown");
-        Asserts.assertEquals(c, IntInt.class, "Wrong class");
-    }
-
-    void checkGetFieldOffsetInFlattenedLayout() {
-        Throwable exception = null;
-        try {
-            Object o = new Object();
-            GetFieldOffsetInFlattenedLayoutWrapper(o.getClass(), "foo", "I", true);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            int[] array = new int[16];
-            GetFieldOffsetInFlattenedLayoutWrapper(array.getClass(), "foo", "I", true);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            String[] array = new String[16];
-            GetFieldOffsetInFlattenedLayoutWrapper(array.getClass(), "foo", "I", true);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        Containee ce  = new Containee(3.4f, (short)5);
-        Container c = new Container(123.876, ce, (byte)7);
-        Class<?> cclass = c.getClass();
-        Container[] containerArray = new Container[32];
-        int elementSize = GetFlattenedArrayElementSizeWrapper(containerArray);
-        int offset = -1;
-        try {
-            offset = GetFieldOffsetInFlattenedLayoutWrapper(cclass, "d", "D", false);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNull(exception, "No exception should have been thrown");
-        Field f = null;
-        try {
-            f = cclass.getDeclaredField("d");
-        } catch(NoSuchFieldException e) {
-            e.printStackTrace();
-            return;
-        }
-        Asserts.assertEquals(U.valueHeaderSize(cclass) + offset, U.objectFieldOffset(cclass, f.getName()),
-                             "Incorrect offset");
-        Asserts.assertLessThan(offset, elementSize, "Invalid offset");
-        exception = null;
-        try {
-            // Field c should be flattened, so last argument is true, no exception expected
-            GetFieldOffsetInFlattenedLayoutWrapper(cclass, "c", "QTestJNIArrays$Containee;", true);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNull(exception, "No exception should have been thrown");
-        Asserts.assertLessThan(offset, elementSize, "Invalid offset");
-        exception = null;
-        try {
-            // Field c should be flattened, with last argument being false, exception expected from the wrapper
-            GetFieldOffsetInFlattenedLayoutWrapper(cclass, "c", "QTestJNIArrays$Containee;", false);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "Wrapper should have thrown a RuntimeException");
-        Asserts.assertEquals(exception.getClass(), RuntimeException.class , "Wrong exception type");
-    }
-
-    void checkGetFlattenedArrayElements() {
-        Throwable exception = null;
-        Object o = new Object();
-        try {
-            GetFlattenedArrayElementsWrapper(o);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        int[] a1 = new int[16];
-        o = a1;
-        try {
-            GetFlattenedArrayElementsWrapper(o);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            GetFlattenedArrayElementsWrapper(new String[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertEquals(exception.getClass(), IllegalArgumentException.class , "Wrong exception type");
-        exception = null;
-        try {
-            // Array of BigValue should not be flattened because BigValue is *big*
-            GetFlattenedArrayElementsWrapper(new BigValue[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertTrue(exception instanceof IllegalArgumentException , "Exception should be a IAE");
-        exception = null;
-        try {
-            // Direct native access to flattened arrays is not allowed if elements contain oops
-            GetFlattenedArrayElementsWrapper(new ValueWithOops[16]);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNotNull(exception, "An IAE should have been thrown");
-        Asserts.assertTrue(exception instanceof IllegalArgumentException , "Exception should be a IAE");
-        exception = null;
-        long addr = 0;
-        IntInt[] a2 = new IntInt[16];
-        try {
-            addr = GetFlattenedArrayElementsWrapper(a2);
-        } catch(Throwable t) {
-            exception = t;
-        }
-        Asserts.assertNull(exception, "No exception should have been thrown");
-        if (exception == null) {
-            ReleaseFlattenedArrayElementsWrapper(a2, addr, 0);
-        }
-    }
-
-    void checkBehaviors() {
-        System.out.println("Check 1");
-        IntInt[] array = new IntInt[ARRAY_SIZE];
-        int value = getIntFieldAtIndex(array, 1, "i0", "I");
-        Asserts.assertEquals(value, 0, "Initial value must be zero");
-        printArrayInformation(array);
-        int i0_value = 42;
-        int i1_value = -314;
-        initializeIntIntArrayBuffer(array, i0_value, i1_value);
-        System.gc();
-        for (int i = 0; i < array.length; i++) {
-            Asserts.assertEquals(array[i].i0, i0_value, "Bad value of i0 at index " + i);
-            Asserts.assertEquals(array[i].i1, i1_value, "Bad value of i1 at index " + i);
-        }
-        System.out.println("Check 2");
-        array = new IntInt[ARRAY_SIZE];
-        i0_value = -194;
-        i1_value = 91;
-        initializeIntIntArrayFields(array, i0_value, i1_value);
-        System.gc();
-        for (int i = 0; i < array.length; i++) {
-            Asserts.assertEquals(array[i].i0, i0_value, "Bad value of i0 at index " + i);
-            Asserts.assertEquals(array[i].i1, i1_value, "Bad value of i1 at index " + i);
-        }
-        System.out.println("Check 3");
-        array = new IntInt[ARRAY_SIZE];
-        initializeIntIntArrayJava(array, i0_value, i1_value);
-        System.gc();
-        for (int i = 0; i < array.length; i++) {
-            Asserts.assertEquals(array[i].i0, i0_value, "Bad value of i0 at index " + i);
-            Asserts.assertEquals(array[i].i1, i1_value, "Bad value of i1 at index " + i);
-        }
-        System.out.println("Check 4");
-        random = new Random(seed);
-        array = new IntInt[ARRAY_SIZE];
-        for (int i = 0; i < ARRAY_SIZE; i++) {
-            array[i] = new IntInt(random.nextInt(), random.nextInt());
-        }
-        sortIntIntArray(array);
-        System.gc();
-        for (int i = 0; i < array.length - 1; i++) {
-            Asserts.assertLessThanOrEqual(array[i].i0, array[i+1].i0, "Incorrect i0 fields ordering at index " + i);
-            if (array[i].i0 == array[i+1].i0) {
-                Asserts.assertLessThanOrEqual(array[i].i1, array[i+1].i1, "Incorrect i1 fields ordering at index " + i);
-            }
-        }
-        System.out.println("Check 5");
-        random = new Random(seed);
-        array = new IntInt[ARRAY_SIZE];
-        for (int i = 0; i < ARRAY_SIZE; i++) {
-            array[i] = new IntInt(random.nextInt(), random.nextInt());
-        }
-        Arrays.sort(array, new IntIntComparator());
-        System.gc();
-        for (int i = 0; i < array.length - 1; i++) {
-            Asserts.assertLessThanOrEqual(array[i].i0, array[i+1].i0, "Incorrect i0 fields ordering at index " + i);
-            if (array[i].i0 == array[i+1].i0) {
-                Asserts.assertLessThanOrEqual(array[i].i1, array[i+1].i1, "Incorrect i1 fields ordering at index " + i);
-            }
-        }
-        System.out.println("Check 6");
-        Container[] array2 = new Container[ARRAY_SIZE];
-        double d  = 1.23456789;
-        float f = -987.654321f;
-        short s = -512;
-        byte b = 127;
-        Containee c = new Containee(f,s);
-        Container c2 = new Container(d, c, b);
-        initializeContainerArray(array2, d, f, s, b);
-        System.gc();
-        for (int i = 0; i < array2.length; i++) {
-            Asserts.assertEquals(array2[i], c2, "Incorrect value at index " + i);
-            Asserts.assertEquals(array2[i].d, d, "Incorrect d value at index " + i);
-            Asserts.assertEquals(array2[i].c.f, f, "Incorrect f value at index " + i);
-            Asserts.assertEquals(array2[i].c.s, s, "Incorrect s value at index " + i);
-            Asserts.assertEquals(array2[i].b, b, "Incorrect b value at inde " +i);
-        }
-        System.out.println("Check 7");
-        f = 19.2837465f;
-        s = 231;
-        updateContainerArray(array2, f, s);
-        System.gc();
-        for (int i = 0; i < array2.length; i++) {
-            Asserts.assertEquals(array2[i].d, d, "Incorrect d value at index " + i);
-            Asserts.assertEquals(array2[i].c.f, f, "Incorrect f value at index " + i);
-            Asserts.assertEquals(array2[i].c.s, s, "Incorrect s value at index " + i);
-            Asserts.assertEquals(array2[i].b, b, "Incorrect b value at inde " +i);
-        }
-        System.out.println("Check 8");
-        long l0 = 52467923;
-        long l1= -7854022;
-        long l2 = 230947485;
-        long l3 = -752497024;
-        LongLongLongLong[] array3 = new LongLongLongLong[ARRAY_SIZE/8];
-        initializeLongLongLongLongArray(array3, l0, l1, l2, l3);
-        System.gc();
-        for (int i = 0; i < array3.length; i++) {
-            Asserts.assertEquals(array3[i].l0, l0, "Bad value of l0 at index " + i);
-            Asserts.assertEquals(array3[i].l1, l1, "Bad value of l1 at index " + i);
-            Asserts.assertEquals(array3[i].l2, l2, "Bad value of l2 at index " + i);
-            Asserts.assertEquals(array3[i].l3, l3, "Bad value of l3 at index " + i);
-        }
-    }
-
-    void initializeIntIntArrayJava(IntInt[] array, int i0, int i1) {
-        IntInt ii = new IntInt(i0, i1);
-        for (int i = 0; i < array.length; i++) {
-            array[i] = ii;
-        }
-    }
-
-    void initializeContainerArrayJava(Container[] array, double d, float f, short s, byte b) {
-        Containee c = new Containee(f,s);
-        Container c2 = new Container(d, c, b);
-        for (int i = 0; i < array.length; i++) {
-            array[i] = c2;
-        }
-    }
-
-    void updateContainerArrayJava(Container[] array, float f, short s) {
-        Containee c = new Containee(f, s);
-        for (int i = 0; i < array.length; i++) {
-            array[i] = array[i].setc(c);;
-        }
-    }
-
-    void initializeLongLongLongLongArrayJava(LongLongLongLong[] array, long l0, long l1, long l2, long l3) {
-        LongLongLongLong llll = new LongLongLongLong(l0, l1, l2, l3);
-        for (int i = 0; i < array.length; i++) {
-            array[i] = llll;
-        }
-    }
-
-    void measureInitializationTime(int array_size, int iterations) {
-        System.out.println("\nInitialization time for IntInt[]:");
-        long[] start = new long[iterations];
-        long[] end = new long[iterations];
-
-
-        System.out.println("\nJava:");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            IntInt[] array = new IntInt[array_size];
-            initializeIntIntArrayJava(array, 42, -314);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            IntInt[] array = new IntInt[array_size];
-            start[i] = System.nanoTime();
-            initializeIntIntArrayJava(array, 42, -314);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-
-        System.out.println("\nNative(memcpy):");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            IntInt[] array = new IntInt[array_size];
-            initializeIntIntArrayBuffer(array, 42, -314);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            IntInt[] array = new IntInt[array_size];
-            start[i] = System.nanoTime();
-            initializeIntIntArrayBuffer(array, 42, -314);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-
-
-        System.out.println("\nNative(fields):");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            IntInt[] array = new IntInt[array_size];
-            initializeIntIntArrayFields(array, 42, -314);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            IntInt[] array = new IntInt[array_size];
-            start[i] = System.nanoTime();
-            initializeIntIntArrayFields(array, 42, -314);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-    }
-
-    void measureInitializationTime2(int array_size, int iterations) {
-        System.out.println("\nInitialization time for Container[]:");
-        long[] start = new long[iterations];
-        long[] end = new long[iterations];
-
-        double d = 0.369852147;
-        float f = -321.654987f;
-        short s = -3579;
-        byte b = 42;
-
-        System.out.println("\nJava:");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            Container[] array = new Container[array_size];
-            initializeContainerArrayJava(array, d, f, s, b);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            Container[] array = new Container[array_size];
-            start[i] = System.nanoTime();
-            initializeContainerArrayJava(array, d, f, s, b);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-
-        System.out.println("\nNative:");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            Container[] array = new Container[array_size];
-            initializeContainerArray(array, d, f, s, b);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            Container[] array = new Container[array_size];
-            start[i] = System.nanoTime();
-            initializeContainerArray(array, d, f, s, b);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-    }
-
-    void measureUpdateTime2(int array_size, int iterations) {
-        System.out.println("\nUpdating Container[]:");
-        long[] start = new long[iterations];
-        long[] end = new long[iterations];
-
-        double d = 0.369852147;
-        float f = -321.654987f;
-        short s = -3579;
-        byte b = 42;
-
-        Containee c = new Containee(f,s);
-        Container c2 = new Container(d, c, b);
-
-        System.out.println("\nJava:");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            Container[] array = new Container[array_size];
-            for (int j = 0; j < array.length; j++) {
-                array[j] = c2;
-            }
-            updateContainerArrayJava(array, f, s);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            Container[] array = new Container[array_size];
-            for (int j = 0; j < array.length; j++) {
-                array[i] = c2;
-            }
-            start[i] = System.nanoTime();
-            updateContainerArrayJava(array, f, s);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-
-        System.out.println("\nNative:");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            Container[] array = new Container[array_size];
-            for (int j = 0; j < array.length; j++) {
-                array[i] = c2;
-            }
-            updateContainerArray(array, f, s);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            Container[] array = new Container[array_size];
-            for (int j = 0; j < array.length; j++) {
-                array[i] = c2;
-            }
-            start[i] = System.nanoTime();
-            updateContainerArray(array, f, s);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-    }
-
-    void measureSortingTime(int array_size, int iterations) {
-        System.out.println("\nSorting time:");
-        long[] start = new long[iterations];
-        long[] end = new long[iterations];
-
-        random = new Random(seed);
-        System.out.println("\nJava:");
-        IntIntComparator comparator = new IntIntComparator();
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            IntInt[] array = new IntInt[array_size];
-            array = new IntInt[array_size];
-            for (int j = 0; j < array_size; j++) {
-                array[j] = new IntInt(random.nextInt(), random.nextInt());
-            }
-            Arrays.sort(array, comparator);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            IntInt[] array = new IntInt[array_size];
-            for (int j = 0; j < array_size; j++) {
-                array[j] = new IntInt(random.nextInt(), random.nextInt());
-            }
-            start[i] = System.nanoTime();
-            Arrays.sort(array, comparator);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-
-        random = new Random(seed);
-        System.out.println("\nNative:");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            IntInt[] array = new IntInt[array_size];
-            array = new IntInt[array_size];
-            for (int j = 0; j < array_size; j++) {
-                array[j] = new IntInt(random.nextInt(), random.nextInt());
-            }
-            sortIntIntArray(array);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            IntInt[] array = new IntInt[array_size];
-            for (int j = 0; j < array_size; j++) {
-                array[j] = new IntInt(random.nextInt(), random.nextInt());
-            }
-            start[i] = System.nanoTime();
-            sortIntIntArray(array);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-    }
-
-
-    void measureInitializationTime3(int array_size, int iterations) {
-        System.out.println("\nInitialization time for LongLongLongLong[]:");
-        long[] start = new long[iterations];
-        long[] end = new long[iterations];
-
-        long l0 = 123456;
-        long l1 = -987654;
-        long l2 = 192837;
-        long l3 = -56473829;
-
-        System.out.println("\nJava:");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            LongLongLongLong[] array = new LongLongLongLong[array_size];
-            initializeLongLongLongLongArrayJava(array, l0, l1, l2, l3);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            LongLongLongLong[] array = new LongLongLongLong[array_size];
-            start[i] = System.nanoTime();
-            initializeLongLongLongLongArrayJava(array, l0, l1, l2, l3);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-
-        System.out.println("\nNative:");
-        // Warmup
-        for (int i = 0; i < 10; i++) {
-            LongLongLongLong[] array = new LongLongLongLong[array_size];
-            initializeLongLongLongLongArray(array, l0, l1, l2, l3);
-        }
-        // Measure
-        for (int i = 0; i < iterations; i++) {
-            LongLongLongLong[] array = new LongLongLongLong[array_size];
-            start[i] = System.nanoTime();
-            initializeLongLongLongLongArray(array, l0, l1, l2, l3);
-            end[i] = System.nanoTime();
-        }
-        // Results
-        computeStatistics(start, end);
-    }
-
-    void computeStatistics(long[] start, long[] end) {
-        int iterations = start.length;
-        long[] duration = new long[iterations];
-        long sum = 0;
-        long min = end[0] - start[0];
-        long max = min;
-        double var = 0.0;
-        for (int i = 0 ; i < iterations; i++) {
-            duration[i] = end[i] - start[i];
-            if (duration[i] < min) min = duration[i];
-            if (duration[i] > max) max = duration[i];
-            sum += duration[i];
-            double d = (double) duration[i];
-            var += Math.pow(d, 2);
-        }
-        double avg = (sum/iterations) / 1000;
-        double std = (Math.sqrt(var/iterations - Math.pow(sum/iterations, 2))) / 1000;
-        System.out.println(String.format("Avg: %8.2f us", avg));
-        System.out.println(String.format("Std: %8.2f us", std));
-        System.out.println(String.format("Min: %8d us", (min/1000)));
-        System.out.println(String.format("Max: %8d us", (max/1000)));
-    }
-
-    native int GetFlattenedArrayElementSizeWrapper(Object array);
-    native Class GetFlattenedArrayElementClassWrapper(Object array);
-    native long GetFlattenedArrayElementsWrapper(Object array);
-    native void ReleaseFlattenedArrayElementsWrapper(Object array, long addr,int mode);
-    native int GetFieldOffsetInFlattenedLayoutWrapper(Class klass, String name, String signature, boolean flattened);
-
-    native int getIntFieldAtIndex(Object[] array, int index, String fieldName, String FieldSignature);
-    native void printArrayInformation(Object[] array);
-
-    native void initializeIntIntArrayBuffer(Object[] array, int i0, int i1);
-    native void initializeIntIntArrayFields(Object[] array, int i0, int i1);
-    native void sortIntIntArray(Object[] array);
-
-    native void initializeContainerArray(Object[] array, double d, float f, short s, byte b);
-    native void updateContainerArray(Object[] array, float f, short s);
-
-    native void initializeLongLongLongLongArray(Object[] array, long l0, long l1, long l2, long l3);
-
-    native SubElementSelector createSubElementSelector(Object[] array);
-    native SubElementSelector getSubElementSelector(SubElementSelector selector, Class<?> klass, String name, String signature);
-    native Object getObjectSubElement(Object[] array, SubElementSelector selector, int index);
-    native void setObjectSubElement(Object[] array, SubElementSelector selector, int index, Object value);
-
-    native short getShortSubElement(Object[] array, SubElementSelector selector, int index);
-    native void setShortSubElement(Object[] array, SubElementSelector selector, int index, short value);
-    native int getIntSubElement(Object[] array, SubElementSelector selector, int index);
-    native void setIntSubElement(Object[] array, SubElementSelector selector, int index, int value);
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIIsSameObject.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIIsSameObject.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIIsSameObject.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-
-import jdk.test.lib.Asserts;
-
-
-/*
- * @test
- * @summary Test JNI IsSameObject semantic with inline types
- * @library /testlibrary /test/lib
- * @requires (os.simpleArch == "x64")
- * @requires (os.family == "linux" | os.family == "mac")
- * @run main/othervm/native TestJNIIsSameObject
- */
-public class TestJNIIsSameObject {
-  static inline class Value {
-    int i;
-
-    public Value(int i) {
-      this.i = i;
-    }
-  }
-  native static boolean isSameObject(Object o0, Object o1);
-
-  static {
-    System.loadLibrary("JNIIsSameObject");
-  }
-
-  public static void main(String[] args) {
-    // Same value in different instances
-    Value v0 = new Value(3);
-    Value v1 = new Value(3);
-    Asserts.assertTrue(isSameObject(v0, v1));
-
-    // Different values
-    Value v2 = new Value(4);
-    Asserts.assertFalse(isSameObject(v0, v2));
-
-    // Same object
-    TestJNIIsSameObject t0 = new TestJNIIsSameObject();
-    Object o = t0;
-    Asserts.assertTrue(isSameObject(t0, o));
-
-    // Different objects
-    TestJNIIsSameObject t1 = new TestJNIIsSameObject();
-    Asserts.assertFalse(isSameObject(t0, t1));
-
-    // Comparing against null
-    Asserts.assertFalse(isSameObject(v0, null));
-    Asserts.assertFalse(isSameObject(null, v0));
-    Asserts.assertFalse(isSameObject(t0, null));
-    Asserts.assertFalse(isSameObject(null, t0));
-
-    // Object vs value
-    Asserts.assertFalse(isSameObject(v0, t0));
-    Asserts.assertFalse(isSameObject(t0, v0));
-
-  }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue1.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue1.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue1.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-final class ContainerValue1 {
-    static TestValue1.ref staticValueField;
-    TestValue1 nonStaticValueField;
-    TestValue1[] inlineArray;
-}
-
-public inline final class TestValue1 {
-
-    static TestValue1.ref staticValue = getInstance();
-
-    final int i;
-    final String name;
-
-    private TestValue1() {
-        i = (int)System.nanoTime();
-        name = Integer.valueOf(i).toString();
-    }
-
-    public static TestValue1 create(int i) {
-        TestValue1 v = TestValue1.default;
-        v = __WithField(v.i, i);
-        v = __WithField(v.name, Integer.valueOf(i).toString());
-        return v;
-    }
-
-    public static TestValue1 create() {
-        TestValue1 v = TestValue1.default;
-        v = __WithField(v.i, (int)System.nanoTime());
-        v = __WithField(v.name, Integer.valueOf(v.i).toString());
-        return v;
-    }
-
-    public static TestValue1 getInstance() {
-        return create();
-    }
-
-    public static TestValue1 getNonBufferedInstance() {
-        return (TestValue1) staticValue;
-    }
-
-    public boolean verify() {
-        if (name == null) return i == 0;
-        return Integer.valueOf(i).toString().compareTo(name) == 0;
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue2.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue2.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue2.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-final class ContainerValue2 {
-    static TestValue2.ref staticValueField;
-    TestValue2 nonStaticValueField;
-    TestValue2[] valueArray;
-}
-
-public inline final class TestValue2 {
-    static TestValue2.ref staticValue = getInstance();
-
-    final long l;
-    final double d;
-    final String s;
-
-    private TestValue2() {
-        l = System.nanoTime();
-        s = Long.valueOf(l).toString();
-        d = Double.parseDouble(s);
-    }
-
-    public static TestValue2 create(long l) {
-        TestValue2 v = TestValue2.default;
-        v = __WithField(v.l, l);
-        v = __WithField(v.s, Long.valueOf(l).toString());
-        v = __WithField(v.d, Double.parseDouble(v.s));
-        return v;
-    }
-
-    public static TestValue2 create() {
-        TestValue2 v = TestValue2.default;
-        v = __WithField(v.l, System.nanoTime());
-        v = __WithField(v.s, Long.valueOf(v.l).toString());
-        v = __WithField(v.d, Double.parseDouble(v.s));
-        return v;
-    }
-
-    public static TestValue2 getInstance() {
-        return create();
-    }
-
-    public static TestValue2 getNonBufferedInstance() {
-        return (TestValue2) staticValue;
-    }
-
-    public boolean verify() {
-        if (s == null) {
-            return d == 0 && l == 0;
-        }
-        return Long.valueOf(l).toString().compareTo(s) == 0
-                && Double.parseDouble(s) == d;
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue3.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue3.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue3.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-final class ContainerValue3 {
-    static TestValue3.ref staticValueField;
-    TestValue3 nonStaticValueField;
-    TestValue3[] valueArray;
-}
-
-public inline final class TestValue3 {
-
-    static TestValue3.ref staticValue = getInstance();
-
-    final byte b;
-
-    private TestValue3() {
-        b = 123;
-    }
-
-    public static TestValue3 create(byte b) {
-        TestValue3 v = TestValue3.default;
-        v = __WithField(v.b, b);
-        return v;
-    }
-
-    public static TestValue3 create() {
-        TestValue3 v = TestValue3.default;
-        v = __WithField(v.b, 123);
-        return v;
-    }
-
-    public static TestValue3 getInstance() {
-        return create();
-    }
-
-    public static TestValue3 getNonBufferedInstance() {
-        return (TestValue3) staticValue;
-    }
-
-    public boolean verify() {
-        return b == 0 || b == 123;
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue4.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue4.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestValue4.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import java.nio.ByteBuffer;
-
-final class ContainerValue4 {
-    static TestValue4.ref staticValueField;
-    TestValue4 nonStaticValueField;
-    TestValue4[] valueArray;
-}
-
-public inline final class TestValue4 {
-
-    static TestValue4.ref staticValue = getInstance();
-
-    final byte b1;
-    final byte b2;
-    final byte b3;
-    final byte b4;
-    final short s1;
-    final short s2;
-    final int i;
-    final long l;
-    final String val;
-
-    private TestValue4() {
-        i = (int)System.nanoTime();
-        val = Integer.valueOf(i).toString();
-        l = ((long)i) << Integer.SIZE | i;
-        s1 = (short)(i & ~Short.MIN_VALUE);
-        s2 = (short)(i >> Short.SIZE);
-        b1 = (byte)(i & ~Byte.MIN_VALUE);
-        b2 = (byte)((i >> Byte.SIZE) & ~Byte.MIN_VALUE);
-        b3 = (byte)((i >> (2 * Byte.SIZE)) & ~Byte.MIN_VALUE);
-        b4 = (byte)((i >> (3 * Byte.SIZE)) & ~Byte.MIN_VALUE);
-    }
-
-    public static TestValue4 create(int i) {
-        TestValue4 v = TestValue4.default;
-        v = __WithField(v.i, i);
-        v = __WithField(v.val, Integer.valueOf(i).toString());
-        ByteBuffer bf = ByteBuffer.allocate(8);
-        bf.putInt(0, i);
-        bf.putInt(4, i);
-        v = __WithField(v.l, bf.getLong(0));
-        v = __WithField(v.s1, bf.getShort(2));
-        v = __WithField(v.s2, bf.getShort(0));
-        v = __WithField(v.b1, bf.get(3));
-        v = __WithField(v.b2, bf.get(2));
-        v = __WithField(v.b3, bf.get(1));
-        v = __WithField(v.b4, bf.get(0));
-        return v;
-    }
-
-    public static TestValue4 create() {
-        return create((int)System.nanoTime());
-    }
-
-    public static TestValue4 getInstance() {
-        return create();
-    }
-
-    public static TestValue4 getNonBufferedInstance() {
-        return (TestValue4) staticValue;
-    }
-
-    public boolean verify() {
-        if (val == null) {
-            return i == 0 && l == 0 && b1 == 0 && b2 == 0 && b3 == 0 && b4 == 0
-                    && s1 == 0 && s2 == 0;
-        }
-        ByteBuffer bf = ByteBuffer.allocate(8);
-        bf.putInt(0, i);
-        bf.putInt(4, i);
-        long nl =  bf.getLong(0);
-        bf.clear();
-        bf.putShort(0, s2);
-        bf.putShort(2, s1);
-        int from_s = bf.getInt(0);
-        bf.clear();
-        bf.put(0, b4);
-        bf.put(1, b3);
-        bf.put(2, b2);
-        bf.put(3, b1);
-        int from_b = bf.getInt(0);
-        return l == nl && Integer.valueOf(i).toString().compareTo(val) == 0
-                && from_s == i && from_b == i;
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/UninitializedValueFieldsTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/UninitializedValueFieldsTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/UninitializedValueFieldsTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test
- * @summary Uninitialized inline fields test
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers Point.java JumboValue.java UninitializedValueFieldsTest.java
- * @run main/othervm -Xint -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.valuetypes.UninitializedValueFieldsTest
- * @run main/othervm -Xcomp -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.valuetypes.UninitializedValueFieldsTest
- */
-public class UninitializedValueFieldsTest {
-    static Point.ref nonFlattenableStaticPoint;
-    static Point staticPoint;
-
-    Point instancePoint;
-
-    static JumboValue.ref sj1;
-    static JumboValue sj2;
-
-    JumboValue.ref j1;
-    JumboValue j2;
-
-    static Object getNull() {
-        return null;
-    }
-
-    UninitializedValueFieldsTest() { }
-
-    public static void main(String[] args) {
-        checkUninitializedPoint(UninitializedValueFieldsTest.staticPoint, 0, 0);
-        Asserts.assertEquals(nonFlattenableStaticPoint, null, "invalid non flattenable static inline field");
-        UninitializedValueFieldsTest.staticPoint = Point.createPoint(456, 678);
-        checkUninitializedPoint(UninitializedValueFieldsTest.staticPoint, 456, 678);
-        UninitializedValueFieldsTest test = new UninitializedValueFieldsTest();
-        checkUninitializedPoint(test.instancePoint, 0, 0);
-        test.instancePoint = Point.createPoint(123, 345);
-        checkUninitializedPoint(test.instancePoint, 123, 345);
-
-        Asserts.assertEquals(test.j1, null, "invalid non flattenable instance inline field");
-        Asserts.assertEquals(test.j2.l0, 0L, "invalid flattenable instance inline field");
-    }
-
-    static void checkUninitializedPoint(Point p, int x, int y) {
-        Asserts.assertEquals(p.x, x, "invalid x value");
-        Asserts.assertEquals(p.y, y, "invalid y value");
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/UnsafeTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/UnsafeTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/UnsafeTest.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-/*
- * @test UnsafeTest
- * @summary unsafe get/put/with inline type
- * @modules java.base/jdk.internal.misc
- * @library /test/lib
- * @compile -XDallowWithFieldOperator Point.java UnsafeTest.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.UnsafeTest
- * @run main/othervm -Xcomp runtime.valhalla.valuetypes.UnsafeTest
- */
-
-import jdk.internal.misc.Unsafe;
-
-import java.lang.reflect.*;
-import java.util.List;
-import static jdk.test.lib.Asserts.*;
-
-public class UnsafeTest {
-    static final Unsafe U = Unsafe.getUnsafe();
-
-    static inline class Value1 {
-        Point point;
-        Point[] array;
-        Value1() {
-            this.point = Point.createPoint(1, 1);
-            this.array = new Point[0];
-        }
-
-        static Value1 create(Point p, Point... points) {
-            Value1 o = Value1.default;
-            o = __WithField(o.point, p);
-            o = __WithField(o.array, points);
-            return o;
-        }
-    }
-
-    static inline class Value2 {
-        int i;
-        Value1 v;
-
-        Value2() {
-            this.i = 0;
-            this.v = Value1.create(Point.createPoint(0,0), new Point[0]);
-        }
-
-        static Value2 create(Value1 v, int i) {
-            Value2 o = Value2.default;
-            o = __WithField(o.v, v);
-            o = __WithField(o.i, i);
-            return o;
-        }
-    }
-
-    static inline class Value3 {
-        Object o;
-        Value2 v;
-
-        Value3() {
-            this.v = Value2.create(Value1.create(Point.createPoint(0,0), new Point[0]), 0);
-            this.o = new Object();
-        }
-
-        static Value3 create(Value2 v, Object ref) {
-            Value3 o = Value3.default;
-            o = __WithField(o.v, v);
-            o = __WithField(o.o, ref);
-            return o;
-        }
-    }
-
-
-    public static void main(String[] args) throws Throwable {
-        printValueClass(Value3.class, 0);
-
-        Value1 v1 = Value1.create(Point.createPoint(10,10), Point.createPoint(20,20), Point.createPoint(30,30));
-        Value2 v2 = Value2.create(v1, 20);
-        Value3 v3 = Value3.create(v2, List.of("Value3"));
-        long off_o = U.objectFieldOffset(Value3.class, "o");
-        long off_v = U.objectFieldOffset(Value3.class, "v");
-        long off_i = U.objectFieldOffset(Value2.class, "i");
-        long off_v2 = U.objectFieldOffset(Value2.class, "v");
-
-        long off_point = U.objectFieldOffset(Value1.class, "point");
-
-        /*
-         * Layout of Value3
-         *
-         * | valueheader | o | i | x | y | array |
-         *                       ^-------^
-         *                        Point
-         *                       ^---------------^
-         *                        Value1
-         *
-         *                   ^-------------------^
-         *                    Value2
-         */
-        Value3 v = v3;
-        try {
-            v = U.makePrivateBuffer(v);
-            // patch v3.o
-            U.putObject(v, off_o, List.of("Value1", "Value2", "Value3"));
-            // patch v3.v.i;
-            U.putInt(v, off_v + off_i - U.valueHeaderSize(Value2.class), 999);
-            // patch v3.v.v.point
-            U.putValue(v, off_v + off_v2 - U.valueHeaderSize(Value2.class) + off_point - U.valueHeaderSize(Value1.class),
-                       Point.class, Point.createPoint(100, 100));
-        } finally {
-            v = U.finishPrivateBuffer(v);
-        }
-
-        assertEquals(v.v.v.point, Point.createPoint(100, 100));
-        assertEquals(v.v.i, 999);
-        assertEquals(v.o, List.of("Value1", "Value2", "Value3"));
-        assertEquals(v.v.v.array, v1.array);
-
-        Value1 nv1 = Value1.create(Point.createPoint(70,70), Point.createPoint(80,80), Point.createPoint(90,90));
-        Value2 nv2 = Value2.create(nv1, 100);
-        Value3 nv3 = Value3.create(nv2, List.of("Value1", "Value2", "Value3"));
-
-        try {
-            v = U.makePrivateBuffer(v);
-            // patch v3.v
-            U.putValue(v, off_v2, Value2.class, nv2);
-        } finally {
-            v = U.finishPrivateBuffer(v);
-        }
-        assertEquals(v, nv3);
-    }
-
-    static void printValueClass(Class<?> vc, int level) {
-        String indent = "";
-        for (int i=0; i < level; i++) {
-            indent += "  ";
-        }
-        System.out.format("%s%s header size %d%n", indent, vc, U.valueHeaderSize(vc));
-        for (Field f : vc.getDeclaredFields()) {
-            System.out.format("%s%s: %s%s offset %d%n", indent, f.getName(),
-                              U.isFlattened(f) ? "flattened " : "", f.getType(),
-                              U.objectFieldOffset(vc, f.getName()));
-            if (U.isFlattened(f)) {
-                printValueClass(f.getType(), level+1);
-            }
-        }
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/VDefaultTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/VDefaultTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/VDefaultTest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test VDefaultTest
- * @summary vdefault bytecode test
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers VDefaultTest.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.VDefaultTest
- * @run main/othervm -Xcomp runtime.valhalla.valuetypes.VDefaultTest
- */
-
-public class VDefaultTest {
-
-    static inline final class Point {
-        final int x;
-        final int y;
-
-        static Point make() {
-            Point p = Point.default;
-            return p;
-        }
-
-        Point() {
-            x = 0;
-            y = 0;
-        }
-    }
-
-    static inline final class Value {
-        final char c;
-        final byte b;
-        final short s;
-        final int i;
-        final long l;
-        final float f;
-        final double d;
-        final Point p;
-
-        static Value make() {
-            Value p = Value.default;
-            return p;
-        }
-
-        Value () {
-            c = 0;
-            b = 0;
-            s = 0;
-            i = 0;
-            l = 0;
-            f = 0;
-            d = 0;
-            p = Point.make();
-        }
-    }
-
-    public static void main(String[] args) {
-        creationTest();
-        creationTest();
-    }
-
-    static void creationTest() {
-        Value v = Value.make();
-        Asserts.assertEquals(v.c, (char)0, "invalid char default value");
-        Asserts.assertEquals(v.b, (byte)0, "invalid char default value");
-        Asserts.assertEquals(v.s, (short)0, "invalid short default value");
-        Asserts.assertEquals(v.i, 0, "invalid int default value");
-        Asserts.assertEquals(v.l, 0L, "invalid long default value");
-        Asserts.assertEquals(v.f, 0.0F, "invalid float default value");
-        Asserts.assertEquals(v.d, 0.0D, "invalid double default value");
-        Asserts.assertEquals(v.p.x, 0, "invalid embedded inline type value");
-        Asserts.assertEquals(v.p.y, 0, "invalid embedded inline type value");
-    }
-}
-
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/VWithFieldTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/VWithFieldTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/VWithFieldTest.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test VWithFieldTest
- * @summary vwithfield bytecode test
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator VWithFieldTest.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.VWithFieldTest
- * @run main/othervm -Xcomp runtime.valhalla.valuetypes.VWithFieldTest
- */
-
-public class VWithFieldTest {
-
-    static inline final class Point {
-        final private int x;
-        final private int y;
-
-        static Point make(int x, int y) {
-            Point p = Point.default;
-            Asserts.assertEquals(p.x, 0, "invalid x default value");
-            Asserts.assertEquals(p.y, 0, "invalid y default value");
-            p = __WithField(p.x, x);
-            Asserts.assertEquals(p.x, x, "invalid x value");
-            Asserts.assertEquals(p.y, 0, "invalid y value");
-            p = __WithField(p.y, y);
-            Asserts.assertEquals(p.x, x, "invalid x value");
-            Asserts.assertEquals(p.y, y, "invalid y value");
-            return p;
-        }
-
-        Point () {
-            x = 0;
-            y = 0;
-        }
-
-        public int getX() {
-            return x;
-        }
-
-        static Point setX(Point p, int x) {
-            p = __WithField(p.x, x);
-            return p;
-        }
-
-        public int getY() {
-            return y;
-        }
-
-        static Point setY(Point p, int y) {
-            p = __WithField(p.y, y);
-            return p;
-        }
-    }
-
-    public static void main(String[] args) {
-        creationTest();
-        creationTest();
-        witherTest();
-        witherTest();
-    }
-
-    static void creationTest() {
-        Point p = Point.make(10,20);
-        Asserts.assertEquals(p.x, 10, "invalid x value");
-        Asserts.assertEquals(p.y, 20, "invalid y value");
-    }
-
-    static void witherTest() {
-        Point p1 = Point.make(2,12);
-        Asserts.assertEquals(p1.x, 2, "invalid x value");
-        Asserts.assertEquals(p1.y, 12, "invalid y value");
-        Point p2 = Point.setX(p1,3);
-        Asserts.assertEquals(p2.x, 3, "invalid x value");
-        Asserts.assertEquals(p2.y, 12, "invalid y value");
-        Point p3 = Point.setY(p2, 14);
-        Asserts.assertEquals(p3.x, 3, "invalid x value");
-        Asserts.assertEquals(p3.y, 14, "invalid y value");
-    }
-
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueCapableClass.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueCapableClass.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueCapableClass.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-@jdk.incubator.mvt.ValueCapableClass
-public final class ValueCapableClass {
-
-    public static final int DEFAULT_X = 11;
-    public static final short DEFAULT_Y = 13;
-    public static final short DEFAULT_Z = 15;
-    public static final String STATIC_FIELD = "Should be left alone";
-
-    public final int   x;
-    public final short y;
-    public final short z;
-
-    private ValueCapableClass() {
-        this(DEFAULT_X, DEFAULT_Y, DEFAULT_Z);
-    }
-
-    private ValueCapableClass(int x, short y, short z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    public int getX() {
-        return x;
-    }
-
-    public short getY() {
-        return y;
-    }
-
-    public short getZ() {
-        return z;
-    }
-
-    public String toString() {
-        int ax = getX();
-        short ay = getY();
-        short az = getZ();
-        return "ValueCapableClass x=" + ax + " y=" + ay + " z=" + az;
-    }
-
-    public static ValueCapableClass create(int x, short y, short z) {
-        return new ValueCapableClass(x, y, z);
-    }
-
-    public static ValueCapableClass create() {
-        return new ValueCapableClass();
-    }
-
-    public static void test() {
-        ValueCapableClass value = create(4711, (short)7, (short)11);
-        String s = value.toString();
-        if ((value.getX() != 4711) || (value.getY() != 7) || value.getZ() != 11) {
-            throw new IllegalStateException("Bad value: " + s);
-        }
-        System.out.println(s);
-        ValueCapableClass defaultValue = create();
-        s = defaultValue.toString();
-        if ((defaultValue.getX() != DEFAULT_X) ||
-            (defaultValue.getY() != DEFAULT_Y) ||
-            (defaultValue.getZ() != DEFAULT_Z)) {
-            throw new IllegalStateException("Bad value: " + s);
-        }
-
-        if (!STATIC_FIELD.equals("Should be left alone")) {
-            throw new IllegalStateException("Bad static field: " + STATIC_FIELD);
-        }
-    }
-
-    public static void main(String[] args) {
-        test();
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueOops.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueOops.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueOops.java
+++ /dev/null
@@ -1,762 +0,0 @@
-/*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import java.lang.invoke.*;
-import java.lang.ref.*;
-import java.util.concurrent.*;
-
-import static jdk.test.lib.Asserts.*;
-import jdk.test.lib.Utils;
-import sun.hotspot.WhiteBox;
-
-import jdk.experimental.value.MethodHandleBuilder;
-
-/**
- * @test ValueOops_int_Serial
- * @requires vm.gc.Serial
- * @summary Test embedding oops into Value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueOops.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- *                   sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run main/othervm -Xint -XX:+UseSerialGC -Xmx128m
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                   runtime.valhalla.valuetypes.ValueOops
- */
-
-/**
- * @test ValueOops_int_G1
- * @requires vm.gc.G1
- * @summary Test embedding oops into Value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueOops.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- *                   sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run main/othervm -Xint  -XX:+UseG1GC -Xmx128m
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                   runtime.valhalla.valuetypes.ValueOops 20
- */
-
-/**
- * @test ValueOops_int_Parallel
- * @requires vm.gc.Parallel
- * @summary Test embedding oops into Value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueOops.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- *                   sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run main/othervm -Xint -XX:+UseParallelGC -Xmx128m
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                   runtime.valhalla.valuetypes.ValueOops
- */
-
-/**
- * @test ValueOops_int_Z
- * @requires vm.gc.Z
- * @summary Test embedding oops into Value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueOops.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- *                   sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run main/othervm -Xint -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx128m
- *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                   runtime.valhalla.valuetypes.ValueOops
- */
-
-/**
- * @test ValueOops_comp_serial
- * @requires vm.gc.Serial
- * @summary Test embedding oops into Value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueOops.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- *                   sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run main/othervm -Xcomp -XX:+UseSerialGC -Xmx128m
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                   runtime.valhalla.valuetypes.ValueOops
- */
-
-/**
- * @test ValueOops_comp_G1
- * @requires vm.gc.G1
- * @summary Test embedding oops into Value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueOops.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- *                   sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run main/othervm -Xcomp -XX:+UseG1GC -Xmx128m
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                   runtime.valhalla.valuetypes.ValueOops 20
- */
-
-/**
- * @test ValueOops_comp_Parallel
- * @requires vm.gc.Parallel
- * @summary Test embedding oops into Value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueOops.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- *                   sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run main/othervm -Xcomp -XX:+UseParallelGC -Xmx128m
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                   runtime.valhalla.valuetypes.ValueOops
- */
-
-/**
- * @test ValueOops_comp_Z
- * @requires vm.gc.Z
- * @summary Test embedding oops into Value types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Person.java
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueOops.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- *                   sun.hotspot.WhiteBox$WhiteBoxPermission
- * @run main/othervm -Xcomp -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx128m
- *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                   runtime.valhalla.valuetypes.ValueOops
- */
-public class ValueOops {
-
-    // Extra debug: -XX:+VerifyOops -XX:+VerifyStack -XX:+VerifyLastFrame -XX:+VerifyBeforeGC -XX:+VerifyAfterGC -XX:+VerifyDuringGC -XX:VerifySubSet=threads,heap
-    // Even more debugging: -XX:+TraceNewOopMapGeneration -Xlog:gc*=info
-
-    static final int NOF_PEOPLE = 10000; // Exercise arrays of this size
-
-    static int MIN_ACTIVE_GC_COUNT = 10; // Run active workload for this number of GC passes
-
-    static int MED_ACTIVE_GC_COUNT = 4;  // Medium life span in terms of GC passes
-
-    static final String TEST_STRING1 = "Test String 1";
-    static final String TEST_STRING2 = "Test String 2";
-
-    static boolean USE_COMPILER = WhiteBox.getWhiteBox().getBooleanVMFlag("UseCompiler");
-
-    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
-
-    public static void main(String[] args) {
-        if (args.length > 0) {
-            MIN_ACTIVE_GC_COUNT = Integer.parseInt(args[0]);
-        }
-        testClassLoad();
-        testValues();
-
-        if (!USE_COMPILER) {
-            testOopMaps();
-        }
-
-        // Check we survive GC...
-        testOverGc();   // Exercise root scan / oopMap
-        testActiveGc(); // Brute force
-    }
-
-    /**
-     * Test ClassFileParser can load inline types with reference fields
-     */
-    public static void testClassLoad() {
-        String s = Person.class.toString();
-        new Bar();
-        new BarWithValue();
-        s = BarValue.class.toString();
-        s = ObjectWithObjectValue.class.toString();
-        s = ObjectWithObjectValues.class.toString();
-    }
-
-
-    static class Couple {
-        public Person onePerson;
-        public Person otherPerson;
-    }
-
-    static final inline class Composition {
-        public final Person onePerson;
-        public final Person otherPerson;
-
-        private Composition() {
-            onePerson   = Person.create(0, null, null);
-            otherPerson = Person.create(0, null, null);
-        }
-
-        public static Composition create(Person onePerson, Person otherPerson) {
-            Composition comp = Composition.default;
-            comp = __WithField(comp.onePerson, onePerson);
-            comp = __WithField(comp.otherPerson, otherPerson);
-            return comp;
-        }
-    }
-
-    /**
-     * Check inline type operations with "Valhalla Inline Types" (VVT)
-     */
-    public static void testValues() {
-        // Exercise creation, getfield, vreturn with null refs
-        validateDefaultPerson(createDefaultPerson());
-
-        // anewarray, aaload, aastore
-        int index = 7;
-        Person[] array =  new Person[NOF_PEOPLE];
-        validateDefaultPerson(array[index]);
-
-        // Now with refs...
-        validateIndexedPerson(createIndexedPerson(index), index);
-        array[index] = createIndexedPerson(index);
-        validateIndexedPerson(array[index], index);
-
-        // Check the neighbours
-        validateDefaultPerson(array[index - 1]);
-        validateDefaultPerson(array[index + 1]);
-
-        // getfield/putfield
-        Couple couple = new Couple();
-        validateDefaultPerson(couple.onePerson);
-        validateDefaultPerson(couple.otherPerson);
-
-        couple.onePerson = createIndexedPerson(index);
-        validateIndexedPerson(couple.onePerson, index);
-
-        Composition composition = Composition.create(couple.onePerson, couple.onePerson);
-        validateIndexedPerson(composition.onePerson, index);
-        validateIndexedPerson(composition.otherPerson, index);
-    }
-
-    /**
-     * Check oop map generation for klass layout and frame...
-     */
-    public static void testOopMaps() {
-        Object[] objects = WhiteBox.getWhiteBox().getObjectsViaKlassOopMaps(new Couple());
-        assertTrue(objects.length == 4, "Expected 4 oops");
-        for (int i = 0; i < objects.length; i++) {
-            assertTrue(objects[i] == null, "not-null");
-        }
-
-        String fn1 = "Sam";
-        String ln1 = "Smith";
-        String fn2 = "Jane";
-        String ln2 = "Jones";
-        Couple couple = new Couple();
-        couple.onePerson = Person.create(0, fn1, ln1);
-        couple.otherPerson = Person.create(1, fn2, ln2);
-        objects = WhiteBox.getWhiteBox().getObjectsViaKlassOopMaps(couple);
-        assertTrue(objects.length == 4, "Expected 4 oops");
-        assertTrue(objects[0] == fn1, "Bad oop fn1");
-        assertTrue(objects[1] == ln1, "Bad oop ln1");
-        assertTrue(objects[2] == fn2, "Bad oop fn2");
-        assertTrue(objects[3] == ln2, "Bad oop ln2");
-
-        objects = WhiteBox.getWhiteBox().getObjectsViaOopIterator(couple);
-        assertTrue(objects.length == 4, "Expected 4 oops");
-        assertTrue(objects[0] == fn1, "Bad oop fn1");
-        assertTrue(objects[1] == ln1, "Bad oop ln1");
-        assertTrue(objects[2] == fn2, "Bad oop fn2");
-        assertTrue(objects[3] == ln2, "Bad oop ln2");
-
-        // Array..
-        objects = WhiteBox.getWhiteBox().getObjectsViaOopIterator(createPeople());
-        assertTrue(objects.length == NOF_PEOPLE * 2, "Unexpected length: " + objects.length);
-        int o = 0;
-        for (int i = 0; i < NOF_PEOPLE; i++) {
-            assertTrue(objects[o++].equals(firstName(i)), "Bad firstName");
-            assertTrue(objects[o++].equals(lastName(i)), "Bad lastName");
-        }
-
-        // Sanity check, FixMe need more test cases
-        objects = testFrameOops(couple);
-        //assertTrue(objects.length == 5, "Number of frame oops incorrect = " + objects.length);
-        //assertTrue(objects[0] == couple, "Bad oop 0");
-        //assertTrue(objects[1] == fn1, "Bad oop 1");
-        //assertTrue(objects[2] == ln1, "Bad oop 2");
-        //assertTrue(objects[3] == TEST_STRING1, "Bad oop 3");
-        //assertTrue(objects[4] == TEST_STRING2, "Bad oop 4");
-
-        //testFrameOopsVBytecodes();
-    }
-
-    static final String GET_OOP_MAP_NAME = "getOopMap";
-    static final String GET_OOP_MAP_DESC = "()[Ljava/lang/Object;";
-
-    public static Object[] getOopMap() {
-        Object[] oopMap = WhiteBox.getWhiteBox().getObjectsViaFrameOopIterator(2);
-        /* Remove this frame (class mirror for this method), and above class mirror */
-        Object[] trimmedOopMap = new Object[oopMap.length - 2];
-        System.arraycopy(oopMap, 2, trimmedOopMap, 0, trimmedOopMap.length);
-        return trimmedOopMap;
-    }
-
-    // Expecting Couple couple, Person couple.onePerson, and Person (created here)
-    public static Object[] testFrameOops(Couple couple) {
-        int someId = 89898;
-        Person person = couple.onePerson;
-        assertTrue(person.getId() == 0, "Bad Person");
-        Person anotherPerson = Person.create(someId, TEST_STRING1, TEST_STRING2);
-        assertTrue(anotherPerson.getId() == someId, "Bad Person");
-        return getOopMap();
-    }
-
-    // Debug...
-    static void dumpOopMap(Object[] oopMap) {
-        System.out.println("Oop Map len: " + oopMap.length);
-        for (int i = 0; i < oopMap.length; i++) {
-            System.out.println("[" + i + "] = " + oopMap[i]);
-        }
-    }
-
-    /**
-     * Just some check sanity checks with defaultvalue, withfield, astore and aload
-     *
-     * Changes to javac slot usage may well break this test
-     */
-    public static void testFrameOopsVBytecodes() {
-        int nofOopMaps = 4;
-        Object[][] oopMaps = new Object[nofOopMaps][];
-        String[] inputArgs = new String[] { "aName", "aDescription", "someNotes" };
-
-        FooValue.testFrameOopsDefault(oopMaps);
-
-        // Test-D0 Slots=R Stack=Q(RRR)RV
-        assertTrue(oopMaps[0].length == 5 &&
-                oopMaps[0][1] == null &&
-                oopMaps[0][2] == null &&
-                oopMaps[0][3] == null, "Test-D0 incorrect");
-
-        // Test-D1 Slots=R Stack=RV
-        assertTrue(oopMaps[1].length == 2, "Test-D1 incorrect");
-
-        // Test-D2 Slots=RQ(RRR) Stack=RV
-        assertTrue(oopMaps[2].length == 5 &&
-                oopMaps[2][1] == null &&
-                oopMaps[2][2] == null &&
-                oopMaps[2][3] == null, "Test-D2 incorrect");
-
-        // Test-D3 Slots=R Stack=Q(RRR)RV
-        assertTrue(oopMaps[3].length == 6 &&
-                oopMaps[3][1] == null &&
-                oopMaps[3][2] == null &&
-                oopMaps[3][3] == null &&
-                oopMaps[3][4] == null, "Test-D3 incorrect");
-
-        // With ref fields...
-        String name = "TestName";
-        String desc = "TestDesc";
-        String note = "TestNotes";
-        FooValue.testFrameOopsRefs(name, desc, note, oopMaps);
-
-        // Test-R0 Slots=RR Stack=Q(RRR)RV
-        assertTrue(oopMaps[0].length == 6 &&
-                oopMaps[0][2] == name &&
-                oopMaps[0][3] == desc &&
-                oopMaps[0][4] == note, "Test-R0 incorrect");
-
-        /**
-         * TODO: vwithfield from method handle cooked from anonymous class within the inline class
-         *       even with "MethodHandles.privateLookupIn()" will fail final putfield rules
-         */
-    }
-
-    /**
-     * Check forcing GC for combination of VT on stack/LVT etc works
-     */
-    public static void testOverGc() {
-        try {
-            Class<?> vtClass = Person.class;
-
-            System.out.println("vtClass="+vtClass);
-
-            doGc();
-
-            // VT on stack and lvt, null refs, see if GC flies
-            MethodHandle moveValueThroughStackAndLvt = MethodHandleBuilder.loadCode(
-                    LOOKUP,
-                    "gcOverPerson",
-                    MethodType.methodType(vtClass, vtClass),
-                    CODE->{
-                        CODE
-                        .aload(0)
-                        .invokestatic(ValueOops.class, "doGc", "()V", false) // Stack
-                        .astore(0)
-                        .invokestatic(ValueOops.class, "doGc", "()V", false) // LVT
-                        .aload(0)
-                        .astore(1024) // LVT wide index
-                        .aload(1024)
-                        .iconst_1()  // push a litte further down
-                        .invokestatic(ValueOops.class, "doGc", "()V", false) // Stack,LVT
-                        .pop()
-                        .areturn();
-                    });
-            Person person = (Person) moveValueThroughStackAndLvt.invokeExact(createDefaultPerson());
-            validateDefaultPerson(person);
-            doGc();
-
-            int index = 4711;
-            person = (Person) moveValueThroughStackAndLvt.invokeExact(createIndexedPerson(index));
-            validateIndexedPerson(person, index);
-            doGc();
-            person = createDefaultPerson();
-            doGc();
-        }
-        catch (Throwable t) { fail("testOverGc", t); }
-    }
-
-    static void submitNewWork(ForkJoinPool fjPool, int size) {
-        for (int i = 0; i < size; i++) {
-            for (int j = 0; j < 100; j++) {
-                fjPool.execute(ValueOops::testValues);
-            }
-        }
-    }
-
-    static void sleepNoThrow(long ms) {
-        try {
-            Thread.sleep(ms);
-        }
-        catch (Throwable t) {}
-    }
-
-    /**
-     * Run some workloads with different object/value life times...
-     */
-    public static void testActiveGc() {
-        try {
-            int nofThreads = 7;
-            int workSize = nofThreads * 10;
-
-            Object longLivedObjects = createLongLived();
-            Object longLivedPeople = createPeople();
-
-            Object medLivedObjects = createLongLived();
-            Object medLivedPeople = createPeople();
-
-            doGc();
-
-            ForkJoinPool fjPool = new ForkJoinPool(nofThreads, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);
-
-            // submit work until we see some GC
-            Reference ref = createRef();
-            submitNewWork(fjPool, workSize);
-            while (ref.get() != null) {
-                if (fjPool.hasQueuedSubmissions()) {
-                    sleepNoThrow(1L);
-                }
-                else {
-                    workSize *= 2; // Grow the submission size
-                    submitNewWork(fjPool, workSize);
-                }
-            }
-
-            // Keep working and actively GC, until MIN_ACTIVE_GC_COUNT
-            int nofActiveGc = 1;
-            ref = createRef();
-            while (nofActiveGc < MIN_ACTIVE_GC_COUNT) {
-                if (ref.get() == null) {
-                    nofActiveGc++;
-                    ref = createRef();
-                    if (nofActiveGc % MED_ACTIVE_GC_COUNT == 0) {
-                        validateLongLived(medLivedObjects);
-                        validatePeople(medLivedPeople);
-
-                        medLivedObjects = createLongLived();
-                        medLivedPeople = createPeople();
-                    }
-                }
-                else if (fjPool.hasQueuedSubmissions()) {
-                    sleepNoThrow((long) Utils.getRandomInstance().nextInt(1000));
-                    doGc();
-                }
-                else {
-                    submitNewWork(fjPool, workSize);
-                }
-            }
-            fjPool.shutdown();
-
-            validateLongLived(medLivedObjects);
-            validatePeople(medLivedPeople);
-            medLivedObjects = null;
-            medLivedPeople = null;
-
-            validateLongLived(longLivedObjects);
-            validatePeople(longLivedPeople);
-
-            longLivedObjects = null;
-            longLivedPeople = null;
-
-            doGc();
-        }
-        catch (Throwable t) { fail("testActiveGc", t); }
-    }
-
-    static final ReferenceQueue<Object> REFQ = new ReferenceQueue<>();
-
-    public static void doGc() {
-        // Create Reference, wait until it clears...
-        Reference ref = createRef();
-        while (ref.get() != null) {
-            System.gc();
-        }
-    }
-
-    static Reference createRef() {
-        return new WeakReference<Object>(new Object(), REFQ);
-    }
-
-    static void validatePerson(Person person, int id, String fn, String ln, boolean equals) {
-        assertTrue(person.id == id);
-        if (equals) {
-            assertTrue(fn.equals(person.getFirstName()), "Invalid field firstName");
-            assertTrue(ln.equals(person.getLastName()), "Invalid  field lastName");
-        }
-        else {
-            assertTrue(person.getFirstName() == fn, "Invalid field firstName");
-            assertTrue(person.getLastName() == ln, "Invalid  field lastName");
-        }
-    }
-
-    static Person createIndexedPerson(int i) {
-        return Person.create(i, firstName(i), lastName(i));
-    }
-
-    static void validateIndexedPerson(Person person, int i) {
-        validatePerson(person, i, firstName(i), lastName(i), true);
-    }
-
-    static Person createDefaultPerson() {
-        return Person.create(0, null, null);
-    }
-
-    static void validateDefaultPerson(Person person) {
-        validatePerson(person, 0, null, null, false);
-    }
-
-    static String firstName(int i) {
-        return "FirstName-" + i;
-    }
-
-    static String lastName(int i) {
-        return "LastName-" + i;
-    }
-
-    static Object createLongLived()  throws Throwable {
-        Object[] population = new Object[1];
-        population[0] = createPeople();
-        return population;
-    }
-
-    static void validateLongLived(Object pop) throws Throwable {
-        Object[] population = (Object[]) pop;
-        validatePeople(population[0]);
-    }
-
-    static Object createPeople() {
-        int arrayLength = NOF_PEOPLE;
-        Person[] people = new Person[arrayLength];
-        for (int i = 0; i < arrayLength; i++) {
-            people[i] = createIndexedPerson(i);
-        }
-        return people;
-    }
-
-    static void validatePeople(Object array) {
-        Person[] people = (Person[]) array;
-        int arrayLength = people.length;
-        assertTrue(arrayLength == NOF_PEOPLE);
-        for (int i = 0; i < arrayLength; i++) {
-            validateIndexedPerson(people[i], i);
-        }
-    }
-
-    // Various field layouts...sanity testing, see MVTCombo testing for full-set
-
-    static final inline class ObjectValue {
-        final Object object;
-
-        private ObjectValue(Object obj) {
-            object = obj;
-        }
-    }
-
-    static class ObjectWithObjectValue {
-        ObjectValue value1;
-        Object      ref1;
-    }
-
-    static class ObjectWithObjectValues {
-        ObjectValue value1;
-        ObjectValue value2;
-        Object      ref1;
-    }
-
-    static class Foo {
-        int id;
-        String name;
-        String description;
-        long timestamp;
-        String notes;
-    }
-
-    static class Bar extends Foo {
-        long extendedId;
-        String moreNotes;
-        int count;
-        String otherStuff;
-    }
-
-    public static final inline class FooValue {
-        public final int id;
-        public final String name;
-        public final String description;
-        public final long timestamp;
-        public final String notes;
-
-        private FooValue() {
-            id          = 0;
-            name        = null;
-            description = null;
-            timestamp   = 0L;
-            notes       = null;
-        }
-
-        public static FooValue create(int id, String name, String description, long timestamp, String notes) {
-            FooValue f = FooValue.default;
-            f = __WithField(f.id, id);
-            f = __WithField(f.name, name);
-            f = __WithField(f.description, description);
-            f = __WithField(f.timestamp, timestamp);
-            f = __WithField(f.notes, notes);
-            return f;
-        }
-
-        public static void testFrameOopsDefault(Object[][] oopMaps) {
-            MethodType mt = MethodType.methodType(Void.TYPE, oopMaps.getClass());
-            int oopMapsSlot   = 0;
-            int vtSlot        = 1;
-
-            // Slots 1=oopMaps
-            // OopMap Q=RRR (.name .description .someNotes)
-            try {
-                MethodHandleBuilder.loadCode(
-                        LOOKUP, "exerciseVBytecodeExprStackWithDefault", mt,
-                        CODE->{
-                            CODE
-                            .defaultvalue(FooValue.class)
-                            .aload(oopMapsSlot)
-                            .iconst_0()  // Test-D0 Slots=R Stack=Q(RRR)RV
-                            .invokestatic(ValueOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
-                            .aastore()
-                            .pop()
-                            .aload(oopMapsSlot)
-                            .iconst_1()  // Test-D1 Slots=R Stack=RV
-                            .invokestatic(ValueOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
-                            .aastore()
-                            .defaultvalue(FooValue.class)
-                            .astore(vtSlot)
-                            .aload(oopMapsSlot)
-                            .iconst_2()  // Test-D2 Slots=RQ(RRR) Stack=RV
-                            .invokestatic(ValueOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
-                            .aastore()
-                            .aload(vtSlot)
-                            .aconst_null()
-                            .astore(vtSlot) // Storing null over the Q slot won't remove the ref, but should be single null ref
-                            .aload(oopMapsSlot)
-                            .iconst_3()  // Test-D3 Slots=R Stack=Q(RRR)RV
-                            .invokestatic(ValueOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
-                            .aastore()
-                            .pop()
-                            .return_();
-                        }).invoke(oopMaps);
-            } catch (Throwable t) { fail("exerciseVBytecodeExprStackWithDefault", t); }
-        }
-
-        public static void testFrameOopsRefs(String name, String description, String notes, Object[][] oopMaps) {
-            FooValue f = create(4711, name, description, 9876543231L, notes);
-            FooValue[] fa = new FooValue[] { f };
-            MethodType mt = MethodType.methodType(Void.TYPE, fa.getClass(), oopMaps.getClass());
-            int fooArraySlot  = 0;
-            int oopMapsSlot   = 1;
-            try {
-                MethodHandleBuilder.loadCode(LOOKUP, "exerciseVBytecodeExprStackWithRefs", mt,
-                        CODE->{
-                            CODE
-                            .aload(fooArraySlot)
-                            .iconst_0()
-                            .aaload()
-                            .aload(oopMapsSlot)
-                            .iconst_0()  // Test-R0 Slots=RR Stack=Q(RRR)RV
-                            .invokestatic(ValueOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)
-                            .aastore()
-                            .pop()
-                            .return_();
-                        }).invoke(fa, oopMaps);
-            } catch (Throwable t) { fail("exerciseVBytecodeExprStackWithRefs", t); }
-        }
-    }
-
-    static class BarWithValue {
-        FooValue foo;
-        long extendedId;
-        String moreNotes;
-        int count;
-        String otherStuff;
-    }
-
-    static final inline class BarValue {
-        final FooValue foo;
-        final long extendedId;
-        final String moreNotes;
-        final int count;
-        final String otherStuff;
-
-        private BarValue(FooValue f, long extId, String mNotes, int c, String other) {
-            foo = f;
-            extendedId = extId;
-            moreNotes = mNotes;
-            count = c;
-            otherStuff = other;
-        }
-    }
-
-}
-
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTearing.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTearing.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTearing.java
+++ /dev/null
@@ -1,280 +0,0 @@
-/*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import java.lang.reflect.Array;
-import java.lang.reflect.Field;
-import java.util.Arrays;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Supplier;
-import java.util.Optional;
-
-import jdk.internal.misc.Unsafe;
-import sun.hotspot.WhiteBox;
-import static jdk.test.lib.Asserts.*;
-
-/*
- * @test ValueTearing
- * @summary Test tearing of inline fields and array elements
- * @modules java.base/jdk.internal.misc
- * @library /test/lib
- * @compile ValueTearing.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- * @run main/othervm -Xint  -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=
- *                   -DSTEP_COUNT=10000
- *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
- *                                   runtime.valhalla.valuetypes.ValueTearing
- * @run main/othervm -Xint  -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=*
- *                   -DSTEP_COUNT=10000
- *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
- *                                   runtime.valhalla.valuetypes.ValueTearing
- * @run main/othervm -Xbatch -DSTEP_COUNT=10000000
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
- *                                   runtime.valhalla.valuetypes.ValueTearing
- * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=
- *                   -DTEAR_MODE=fieldonly
- *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
- *                                   runtime.valhalla.valuetypes.ValueTearing
- * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=
- *                   -DTEAR_MODE=arrayonly
- *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
- *                                   runtime.valhalla.valuetypes.ValueTearing
- * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=*
- *                   -DTEAR_MODE=both
- *                   -Xbootclasspath/a:. -XX:+WhiteBoxAPI
- *                                   runtime.valhalla.valuetypes.ValueTearing
- */
-public class ValueTearing {
-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
-    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag("UseCompiler");
-    private static final boolean ALWAYS_ATOMIC = WHITE_BOX.getStringVMFlag("ForceNonTearable").contains("*");
-    private static final String TEAR_MODE = System.getProperty("TEAR_MODE", "both");
-    private static final boolean TEAR_FIELD = !TEAR_MODE.equals("arrayonly");
-    private static final boolean TEAR_ARRAY = !TEAR_MODE.equals("fieldonly");
-    private static final int STEP_COUNT = Integer.getInteger("STEP_COUNT", 100_000);
-    private static final boolean TFIELD_FLAT, TARRAY_FLAT;
-    private static final boolean NTFIELD_FLAT, NTARRAY_FLAT;
-    static {
-        try {
-            Field TPB_field = TPointBox.class.getDeclaredField("field");
-            Field TPB_array = TPointBox.class.getDeclaredField("array");
-            Field NTPB_field = NTPointBox.class.getDeclaredField("field");
-            Field NTPB_array = NTPointBox.class.getDeclaredField("array");
-            TFIELD_FLAT = UNSAFE.isFlattened(TPB_field);
-            TARRAY_FLAT = UNSAFE.isFlattenedArray(TPB_array.getType());
-            NTFIELD_FLAT = UNSAFE.isFlattened(NTPB_field);
-            NTARRAY_FLAT = UNSAFE.isFlattenedArray(NTPB_array.getType());
-        } catch (ReflectiveOperationException ex) {
-            throw new AssertionError(ex);
-        }
-    }
-    private static final String SETTINGS =
-        String.format("USE_COMPILER=%s ALWAYS_ATOMIC=%s TEAR_MODE=%s STEP_COUNT=%s FLAT TF/TA=%s/%s NTF/NTA=%s/%s",
-                      USE_COMPILER, ALWAYS_ATOMIC, TEAR_MODE, STEP_COUNT,
-                      TFIELD_FLAT, TARRAY_FLAT, NTFIELD_FLAT, NTARRAY_FLAT);
-    private static final String NOTE_TORN_POINT = "Note: torn point";
-
-    public static void main(String[] args) throws Exception {
-        System.out.println(SETTINGS);
-        ValueTearing valueTearing = new ValueTearing();
-        valueTearing.run();
-        // Extra representation check:
-        assert(!NTFIELD_FLAT) : "NT field must be indirect not flat";
-        assert(!NTARRAY_FLAT) : "NT array must be indirect not flat";
-        if (ALWAYS_ATOMIC) {
-            assert(!TFIELD_FLAT) : "field must be indirect not flat";
-            assert(!TARRAY_FLAT) : "array must be indirect not flat";
-        }
-    }
-
-    // A normally tearable inline value.
-    static inline class TPoint {
-        TPoint(long x, long y) { this.x = x; this.y = y; }
-        final long x, y;
-        public String toString() { return String.format("(%d,%d)", x, y); }
-    }
-
-    static class TooTearable extends AssertionError {
-        final Object badPoint;
-        TooTearable(String msg, Object badPoint) {
-            super(msg);
-            this.badPoint = badPoint;
-        }
-    }
-
-    interface PointBox {
-        void step();    // mutate inline value state
-        void check();   // check sanity of inline value state
-    }
-
-    class TPointBox implements PointBox {
-        TPoint field;
-        TPoint[] array = new TPoint[1];
-        // Step the points forward by incrementing their components
-        // "simultaneously".  A racing thread will catch flaws in the
-        // simultaneity.
-        TPoint step(TPoint p) {
-            return new TPoint(p.x + 1, p.y + 1);
-        }
-        public @Override
-        void step() {
-            if (TEAR_FIELD) {
-                field = step(field);
-            }
-            if (TEAR_ARRAY) {
-                array[0] = step(array[0]);
-            }
-            check();
-        }
-        // Invariant:  The components of each point are "always" equal.
-        // As long as simultaneity is preserved, this is true.
-        public @Override
-        void check() {
-            if (TEAR_FIELD) {
-                check(field, "field");
-            }
-            if (TEAR_ARRAY) {
-                check(array[0], "array element");
-            }
-        }
-        void check(TPoint p, String where) {
-            if (p.x == p.y)  return;
-            String msg = String.format("%s %s in %s; settings = %s",
-                                       NOTE_TORN_POINT,
-                                       p, where, SETTINGS);
-            throw new TooTearable(msg, p);
-        }
-        public String toString() {
-            return String.format("TPB[%s, {%s}]", field, array[0]);
-        }
-    }
-
-    // Add an indirection, as an extra test.
-    interface NT extends NonTearable { }
-
-    // A hardened, non-tearable version of TPoint.
-    static inline class NTPoint implements NT {
-        NTPoint(long x, long y) { this.x = x; this.y = y; }
-        final long x, y;
-        public String toString() { return String.format("(%d,%d)", x, y); }
-    }
-
-    class NTPointBox implements PointBox {
-        NTPoint field;
-        NTPoint[] array = new NTPoint[1];
-        // Step the points forward by incrementing their components
-        // "simultaneously".  A racing thread will catch flaws in the
-        // simultaneity.
-        NTPoint step(NTPoint p) {
-            return new NTPoint(p.x + 1, p.y + 1);
-        }
-        public @Override
-        void step() {
-            field = step(field);
-            array[0] = step(array[0]);
-            check();
-        }
-        // Invariant:  The components of each point are "always" equal.
-        public @Override
-        void check() {
-            check(field, "field");
-            check(array[0], "array element");
-        }
-        void check(NTPoint p, String where) {
-            if (p.x == p.y)  return;
-            String msg = String.format("%s *NonTearable* %s in %s; settings = %s",
-                                       NOTE_TORN_POINT,
-                                       p, where, SETTINGS);
-            throw new TooTearable(msg, p);
-        }
-        public String toString() {
-            return String.format("NTPB[%s, {%s}]", field, array[0]);
-        }
-    }
-
-    class AsyncObserver extends Thread {
-        volatile boolean done;
-        long observationCount;
-        final PointBox pointBox;
-        volatile Object badPointObserved;
-        AsyncObserver(PointBox pointBox) {
-            this.pointBox = pointBox;
-        }
-        public void run() {
-            try {
-                while (!done) {
-                    observationCount++;
-                    pointBox.check();
-                }
-            } catch (TooTearable ex) {
-                done = true;
-                badPointObserved = ex.badPoint;
-                System.out.println(ex);
-                if (ALWAYS_ATOMIC || ex.badPoint instanceof NonTearable) {
-                    throw ex;
-                }
-            }
-        }
-    }
-
-    public void run() throws Exception {
-        System.out.println("Test for tearing of NTPoint, which must not happen...");
-        run(new NTPointBox(), false);
-        System.out.println("Test for tearing of TPoint, which "+
-                           (ALWAYS_ATOMIC ? "must not" : "is allowed to")+
-                           " happen...");
-        run(new TPointBox(), ALWAYS_ATOMIC ? false : true);
-    }
-    public void run(PointBox pointBox, boolean canTear) throws Exception {
-        var observer = new AsyncObserver(pointBox);
-        observer.start();
-        for (int i = 0; i < STEP_COUNT; i++) {
-            pointBox.step();
-            if (observer.done)  break;
-        }
-        observer.done = true;
-        observer.join();
-        var obCount = observer.observationCount;
-        var badPoint = observer.badPointObserved;
-        System.out.println(String.format("finished after %d observations at %s; %s",
-                                         obCount, pointBox,
-                                         (badPoint == null
-                                          ? "no tearing observed"
-                                          : "bad point = " + badPoint)));
-        if (canTear && badPoint == null) {
-            var complain = String.format("%s NOT observed after %d observations",
-                                         NOTE_TORN_POINT, obCount);
-            System.out.println("?????? "+complain);
-            if (STEP_COUNT >= 3_000_000) {
-                // If it's a small count, OK, but if it's big the test is broken.
-                throw new AssertionError(complain + ", but it should have been");
-            }
-        }
-        if (!canTear && badPoint != null) {
-            throw new AssertionError("should not reach here; other thread must throw");
-        }
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
+++ /dev/null
@@ -1,550 +0,0 @@
-/*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import java.lang.reflect.Array;
-import java.util.Arrays;
-import java.util.ArrayList;
-import java.util.List;
-
-import static jdk.test.lib.Asserts.*;
-
-/*
- * @test ValueTypeArray
- * @summary Plain array test for Inline Types
- * @library /test/lib
- * @compile ValueTypeArray.java Point.java Long8Value.java Person.java
- * @run main/othervm -Xint  -XX:FlatArrayElementMaxSize=-1 runtime.valhalla.valuetypes.ValueTypeArray
- * @run main/othervm -Xint  -XX:FlatArrayElementMaxSize=0  runtime.valhalla.valuetypes.ValueTypeArray
- * @run main/othervm -Xcomp -XX:FlatArrayElementMaxSize=-1 runtime.valhalla.valuetypes.ValueTypeArray
- * @run main/othervm -Xcomp -XX:FlatArrayElementMaxSize=0  runtime.valhalla.valuetypes.ValueTypeArray
- * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.valuetypes.ValueTypeArray
- */
-public class ValueTypeArray {
-    public static void main(String[] args) {
-        ValueTypeArray valueTypeArray = new ValueTypeArray();
-        valueTypeArray.run();
-    }
-
-    public void run() {
-        testClassForName();
-        testSimplePointArray();
-        testLong8Array();
-        testMixedPersonArray();
-        testMultiDimPointArray();
-        testComposition();
-
-        testSanityCheckcasts();
-        testObjectArrayOfValues();
-
-        testReflectArray();
-        testUtilArrays();
-
-        testValueArrayOom();
-    }
-
-    void testClassForName() {
-        String arrayClsName = "[Lruntime.valhalla.valuetypes.Point$ref;";
-        String qarrayClsName = "[Qruntime.valhalla.valuetypes.Point;";
-        try {
-            // L-type..
-            Class<?> arrayCls = Class.forName(arrayClsName);
-            assertTrue(arrayCls.isArray(), "Expected an array class");
-
-            arrayClsName = "[" + arrayClsName;
-            Class<?> mulArrayCls = Class.forName(arrayClsName);
-            assertTrue(mulArrayCls.isArray());
-            assertTrue(mulArrayCls.getComponentType() == arrayCls);
-
-            // Q-type...
-            arrayCls = Class.forName(qarrayClsName);
-            assertTrue(arrayCls.isArray(), "Expected an array class");
-
-            assertTrue(arrayCls.getComponentType() == Point.class,
-                       arrayCls +
-                       " Expected component type of Point.class got: " + arrayCls.getComponentType());
-
-            qarrayClsName = "[" + qarrayClsName;
-            mulArrayCls = Class.forName(qarrayClsName);
-            assertTrue(mulArrayCls.isArray());
-            assertTrue(mulArrayCls.getComponentType() == arrayCls);
-        }
-        catch (ClassNotFoundException cnfe) {
-            fail("Class.forName(" + arrayClsName + ") failed", cnfe);
-        }
-    }
-
-    void testSimplePointArray() {
-        Point[] defaultPoint = new Point[1];
-        Point p = defaultPoint[0];
-        assertEquals(p.x, 0, "invalid default loaded from array");
-        assertEquals(p.y, 0, "invalid default loaded from array");
-        boolean gotNpe = false;
-        try {
-            defaultPoint[0] = (Point) getNull();
-        } catch (NullPointerException npe) {
-            gotNpe = true;
-        }
-        assertTrue(gotNpe, "Expected NullPointerException");
-
-        Point[] points = createSimplePointArray();
-        System.gc(); // check that VTs survive GC
-        checkSimplePointArray(points);
-
-        assertTrue(points instanceof Point[], "Instance of");
-
-        testSimplePointArrayCopy();
-    }
-
-    void testSimplePointArrayCopy() {
-        Point[] points = createSimplePointArray();
-        Point[] pointsCopy = new Point[points.length];
-        System.arraycopy(points, 0, pointsCopy, 0, points.length);
-        checkSimplePointArray(pointsCopy);
-
-        // Conjoint, overlap...left
-        System.arraycopy(points, 0, points, 1, 2);
-        checkArrayElementsEqual(points, new Point[] { pointsCopy[0], pointsCopy[0], pointsCopy[1], pointsCopy[3] });
-
-        // Conjoint, overlap...right
-        points = createSimplePointArray();
-        System.arraycopy(points, 2, points, 1, 2);
-        checkArrayElementsEqual(points, new Point[] { pointsCopy[0], pointsCopy[2], pointsCopy[3], pointsCopy[3] });
-    }
-
-    static Point[] createSimplePointArray() {
-        Point[] ps = new Point[4];
-        assertEquals(ps.length, 4, "Length");
-        ps.toString();
-        ps[0] = Point.createPoint(1, 2);
-        ps[1] = Point.createPoint(3, 4);
-        ps[2] = Point.createPoint(5, 6);
-        ps[3] = Point.createPoint(7, 8);
-        boolean sawOob = false;
-        try {
-            ps[ps.length] = Point.createPoint(0, 0);
-        } catch (ArrayIndexOutOfBoundsException aioobe) { sawOob = true; }
-        assertTrue(sawOob, "Didn't see AIOOBE");
-        return ps;
-    }
-
-    static void checkSimplePointArray(Point[] points) {
-        assertEquals(points[0].x, 1, "invalid 0 point x value");
-        assertEquals(points[0].y, 2, "invalid 0 point y value");
-        assertEquals(points[1].x, 3, "invalid 1 point x value");
-        assertEquals(points[1].y, 4, "invalid 1 point y value");
-        assertEquals(points[2].x, 5, "invalid 2 point x value");
-        assertEquals(points[2].y, 6, "invalid 2 point y value");
-        assertEquals(points[3].x, 7, "invalid 3 point x value");
-        assertEquals(points[3].y, 8, "invalid 3 point y value");
-    }
-
-    void testLong8Array() {
-        Long8Value[] values = new Long8Value[3];
-        assertEquals(values.length, 3, "length");
-        values.toString();
-        Long8Value value = values[1];
-        long zl = 0;
-        Long8Value.check(value, zl, zl, zl, zl, zl, zl, zl, zl);
-        values[1] = Long8Value.create(1, 2, 3, 4, 5, 6, 7, 8);
-        value = values[1];
-        Long8Value.check(value, 1, 2, 3, 4, 5, 6, 7, 8);
-
-        Long8Value[] copy = new Long8Value[values.length];
-        System.arraycopy(values, 0, copy, 0, values.length);
-        value = copy[1];
-        Long8Value.check(value, 1, 2, 3, 4, 5, 6, 7, 8);
-    }
-
-    void testMixedPersonArray() {
-        Person[] people = new Person[3];
-
-        people[0] = Person.create(1, "First", "Last");
-        assertEquals(people[0].getId(), 1, "Invalid Id person");
-        assertEquals(people[0].getFirstName(), "First", "Invalid First Name");
-        assertEquals(people[0].getLastName(), "Last", "Invalid Last Name");
-
-        people[1] = Person.create(2, "Jane", "Wayne");
-        people[2] = Person.create(3, "Bob", "Dobalina");
-
-        Person[] peopleCopy = new Person[people.length];
-        System.arraycopy(people, 0, peopleCopy, 0, people.length);
-        assertEquals(peopleCopy[2].getId(), 3, "Invalid Id");
-        assertEquals(peopleCopy[2].getFirstName(), "Bob", "Invalid First Name");
-        assertEquals(peopleCopy[2].getLastName(), "Dobalina", "Invalid Last Name");
-    }
-
-    void testMultiDimPointArray() {
-        Point[][][] multiPoints = new Point[2][3][4];
-        assertEquals(multiPoints.length, 2, "1st dim length");
-        assertEquals(multiPoints[0].length, 3, "2st dim length");
-        assertEquals(multiPoints[0][0].length, 4, "3rd dim length");
-
-        Point defaultPoint = multiPoints[1][2][3];
-        assertEquals(defaultPoint.x, 0, "invalid point x value");
-        assertEquals(defaultPoint.y, 0, "invalid point x value");
-    }
-
-    void testReflectArray() {
-        // Check the java.lang.reflect.Array.newInstance methods...
-        Class<?> cls = (Class<?>) Point[].class;
-        Point[][] array = (Point[][]) Array.newInstance(cls, 1);
-        assertEquals(array.length, 1, "Incorrect length");
-        assertTrue(array[0] == null, "Expected NULL");
-
-        Point[][][] array3 = (Point[][][]) Array.newInstance(cls, 1, 2);
-        assertEquals(array3.length, 1, "Incorrect length");
-        assertEquals(array3[0].length, 2, "Incorrect length");
-        assertTrue(array3[0][0] == null, "Expected NULL");
-
-        // Now create ObjArrays of ValueArray...
-        Point.ref[][] barray = (Point.ref[][]) Array.newInstance(Point.ref.class, 1, 2);
-        assertEquals(barray.length, 1, "Incorrect length");
-        assertEquals(barray[0].length, 2, "Incorrect length");
-        barray[0][1] = Point.createPoint(1, 2);
-        Point.ref pb = barray[0][1];
-        int x = pb.getX();
-        assertEquals(x, 1, "Bad Point Value");
-    }
-
-    static final inline class MyInt implements Comparable<MyInt.ref> {
-        final int value;
-
-        private MyInt() { this(0); }
-        private MyInt(int v) { value = v; }
-        public int getValue() { return value; }
-        public String toString() { return "MyInt: " + getValue(); }
-        public int compareTo(MyInt.ref that) { return Integer.compare(this.getValue(), that.getValue()); }
-        public boolean equals(Object o) {
-            if (o instanceof MyInt) {
-                return this.getValue() == ((MyInt) o).getValue();
-            }
-            return false;
-        }
-
-        public static MyInt create(int v) {
-            return new MyInt(v);
-        }
-
-        // Null-able fields here are a temp hack to avoid ClassCircularityError
-        public static final MyInt.ref MIN = MyInt.create(Integer.MIN_VALUE);
-        public static final MyInt.ref ZERO = MyInt.create(0);
-        public static final MyInt.ref MAX = MyInt.create(Integer.MAX_VALUE);
-    }
-
-    static MyInt staticMyInt = MyInt.create(-1);
-    static MyInt[] staticMyIntArray = new MyInt[] { staticMyInt };
-    static MyInt[][] staticMyIntArrayArray = new MyInt[][] { staticMyIntArray, staticMyIntArray };
-
-    static interface SomeSecondaryType {
-        default String hi() { return "Hi"; }
-    }
-
-    static final inline class MyOtherInt implements SomeSecondaryType {
-        final int value;
-        private MyOtherInt() { value = 0; }
-    }
-
-    void testSanityCheckcasts() {
-        MyInt[] myInts = new MyInt[1];
-        assertTrue(myInts instanceof Object[]);
-        assertTrue(myInts instanceof Comparable[]);
-        assertTrue(myInts instanceof MyInt.ref[]);
-
-        Class<?> cls = MyInt.class;
-        assertTrue(cls.isInlineClass());
-        Object arrObj = Array.newInstance(cls, 1);
-        assertTrue(arrObj instanceof Object[], "Not Object array");
-        assertTrue(arrObj instanceof Comparable[], "Not Comparable array");
-        assertTrue(arrObj instanceof MyInt[], "Not MyInt array");
-
-        Object[] arr = (Object[]) arrObj;
-        assertTrue(arr instanceof Comparable[], "Not Comparable array");
-        assertTrue(arr instanceof MyInt[], "Not MyInt array");
-        Comparable[] comparables = (Comparable[])arr;
-        MyInt[] myIntArr = (MyInt[]) arr;
-
-        // multi-dim, check secondary array types are setup...
-        MyOtherInt[][] matrix = new MyOtherInt[1][1];
-        assertTrue(matrix[0] instanceof MyOtherInt[]);
-        assertTrue(matrix[0] instanceof SomeSecondaryType[]);
-        assertTrue(matrix[0] instanceof MyOtherInt.ref[]);
-
-        // Box types vs Inline...
-        MyInt.ref[] myValueRefs = new MyInt.ref[1];
-        assertTrue(myValueRefs instanceof MyInt.ref[]);
-        assertTrue(myValueRefs instanceof Object[]);
-        assertTrue(myValueRefs instanceof Comparable[]);
-        assertFalse(myValueRefs instanceof MyInt[]);
-
-        MyInt.ref[][] myMdValueRefs = new MyInt.ref[1][1];
-        assertTrue(myMdValueRefs[0] instanceof MyInt.ref[]);
-        assertTrue(myMdValueRefs[0] instanceof Object[]);
-        assertTrue(myMdValueRefs[0] instanceof Comparable[]);
-        assertFalse(myMdValueRefs[0] instanceof MyInt[]);
-
-        // Did we break checkcast...
-        MyInt.ref[]     va1 = (MyInt.ref[])null;
-        MyInt.ref[]     va2 = null;
-        MyInt.ref[][]   va3 = (MyInt.ref[][])null;
-        MyInt.ref[][][] va4 = (MyInt.ref[][][])null;
-        MyInt[]      va5 = null;
-        MyInt[]      va6 = (MyInt[])null;
-        MyInt[][]    va7 = (MyInt[][])null;
-        MyInt[][][]  va8 = (MyInt[][][])null;
-    }
-
-
-    void testUtilArrays() {
-        // Sanity check j.u.Arrays
-
-        // cast to q-type temp effect of avoiding circularity error (decl static MyInt.ref)
-        MyInt[] myInts = new MyInt[] { (MyInt) MyInt.MAX, (MyInt) MyInt.MIN };
-        // Sanity sort another copy
-        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);
-        checkArrayElementsEqual(copyMyInts, new MyInt[] { myInts[0], myInts[1], (MyInt) MyInt.ZERO});
-
-        Arrays.sort(copyMyInts);
-        checkArrayElementsEqual(copyMyInts, new MyInt[] { (MyInt) MyInt.MIN, (MyInt) MyInt.ZERO, (MyInt) MyInt.MAX });
-
-        List myIntList = Arrays.asList(copyMyInts);
-        checkArrayElementsEqual(copyMyInts, myIntList.toArray(new MyInt[copyMyInts.length]));
-        // This next line needs testMixedLayoutArrays to work
-        checkArrayElementsEqual(copyMyInts, myIntList.toArray());
-
-        // Sanity check j.u.ArrayList
-        ArrayList<MyInt.ref> aList = new ArrayList<MyInt.ref>(Arrays.asList(copyMyInts));
-        assertTrue(aList.indexOf(MyInt.MIN) == 0, "Bad Index");
-        assertTrue(aList.indexOf(MyInt.ZERO) == 1, "Bad Index");
-        assertTrue(aList.indexOf(MyInt.MAX) == 2, "Bad Index");
-
-        aList.remove(2);
-        aList.add(MyInt.create(5));
-    }
-
-
-    void testObjectArrayOfValues() {
-        testSanityObjectArrays();
-        testMixedLayoutArrays();
-    }
-
-    void testSanityObjectArrays() {
-        Object[] objects = new Object[2];
-        assertTrue(objects[0] == null && objects[1] == null, "Not null ?");
-
-        objects[0] = MyInt.create(1);
-        objects[1] = Integer.valueOf(2);
-        assertTrue(objects[0].equals(MyInt.create(1)), "Bad Value");
-        assertTrue(objects[1].equals(Integer.valueOf(2)), "Bad Object");
-
-        Comparable[] copyComparables = new Comparable[objects.length];
-        System.arraycopy(objects, 0, copyComparables, 0, objects.length);
-        checkArrayElementsEqual(objects, copyComparables);
-
-        objects[0] = null;
-        objects[1] = null;
-        assertTrue(objects[0] == null && objects[1] == null, "Not null ?");
-
-        Comparable[] comparables = new Comparable[2];
-        assertTrue(comparables[0] == null && comparables[1] == null, "Not null ?");
-        comparables[0] = MyInt.create(3);
-        comparables[1] = Integer.valueOf(4);
-        assertTrue(comparables[0].equals(MyInt.create(3)), "Bad Value");
-        assertTrue(comparables[1].equals(Integer.valueOf(4)), "Bad Object");
-
-        Object[] copyObjects = new Object[2];
-        System.arraycopy(comparables, 0, copyObjects, 0, comparables.length);
-        checkArrayElementsEqual(comparables, copyObjects);
-
-        comparables[0] = null;
-        comparables[1] = null;
-        assertTrue(comparables[0] == null && comparables[1] == null, "Not null ?");
-
-        MyInt.ref[] myIntRefArray = new MyInt.ref[1];
-        assertTrue(myIntRefArray[0] == null, "Got: " + myIntRefArray[0]);
-        myIntRefArray[0] = null;
-
-        MyInt.ref[] srcNulls = new MyInt.ref[2];
-        MyInt.ref[] dstNulls = new MyInt.ref[2];
-        System.arraycopy(srcNulls, 0, dstNulls, 0, 2);
-        checkArrayElementsEqual(srcNulls, dstNulls);
-        srcNulls[1] = MyInt.create(1);
-        System.arraycopy(srcNulls, 0, dstNulls, 0, 2);
-        checkArrayElementsEqual(srcNulls, dstNulls);
-    }
-
-    void testMixedLayoutArrays() {
-        Object[] objArray = new Object[3];
-        Comparable[] compArray = new Comparable[3];
-        MyInt[] valArray = new MyInt[] { (MyInt) MyInt.MIN, (MyInt) MyInt.ZERO, (MyInt) MyInt.MAX };
-
-        arrayCopy(valArray, 0, objArray, 0, 3);
-        checkArrayElementsEqual(valArray, objArray);
-        arrayCopy(valArray, 0, objArray, 0, 3);
-
-        objArray = new Object[3];
-        System.arraycopy(valArray, 0, objArray, 0, 3);
-        checkArrayElementsEqual(valArray, objArray);
-
-        System.arraycopy(valArray, 0, compArray, 0, 3);
-        checkArrayElementsEqual(valArray, compArray);
-
-        valArray = new MyInt[] { (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO };
-        System.arraycopy(compArray, 0, valArray, 0, 3);
-        checkArrayElementsEqual(valArray, compArray);
-
-        valArray = new MyInt[] { (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO };
-        System.arraycopy(objArray, 0, valArray, 0, 3);
-        checkArrayElementsEqual(valArray, objArray);
-
-        // Sanity check dst == src
-        System.arraycopy(valArray, 0, valArray, 0, 3);
-        checkArrayElementsEqual(valArray, objArray);
-
-        objArray[0] = "Not an inline object";
-        try {
-            System.arraycopy(objArray, 0, valArray, 0, 3);
-            throw new RuntimeException("Expected ArrayStoreException");
-        } catch (ArrayStoreException ase) {}
-
-        MyInt.ref[] myIntRefArray = new MyInt.ref[3];
-        System.arraycopy(valArray, 0, myIntRefArray, 0, 3);
-        checkArrayElementsEqual(valArray, myIntRefArray);
-
-        myIntRefArray[0] = null;
-        try {
-            System.arraycopy(myIntRefArray, 0, valArray, 0, 3);
-            throw new RuntimeException("Expected NullPointerException");
-        } catch (NullPointerException npe) {}
-    }
-
-    static final inline class MyPoint {
-        final               MyInt x;
-        final               MyInt y;
-
-        private MyPoint() { this(0, 0); }
-        private MyPoint(int x, int y) {
-            this.x = new MyInt(x);
-            this.y = new MyInt(y);
-        }
-        public boolean equals(Object that) {
-            if (that instanceof MyPoint) {
-                MyPoint thatPoint = (MyPoint) that;
-                return x.equals(thatPoint.x) && java.util.Objects.equals(y, thatPoint.y);
-            }
-            return false;
-        }
-        static MyPoint create(int x) {
-            return new MyPoint(x, x);
-        }
-        static MyPoint create(int x, int y) {
-            return new MyPoint(x, y);
-        }
-        static final MyPoint.ref ORIGIN = create(0);
-    }
-
-    void testComposition() {
-        // Test array operations with compostion of inline types, check element payload is correct...
-        MyPoint a = MyPoint.create(1, 2);
-        MyPoint b = MyPoint.create(7, 21);
-        MyPoint c = MyPoint.create(Integer.MAX_VALUE, Integer.MIN_VALUE);
-
-        MyPoint[] pts = new MyPoint[3];
-        if (!pts[0].equals(MyPoint.ORIGIN)) {
-            throw new RuntimeException("Equals failed: " + pts[0] + " vs " + MyPoint.ORIGIN);
-        }
-        pts = new MyPoint[] { a, b, c };
-        checkArrayElementsEqual(pts, new Object[] { a, b, c});
-        Object[] oarr = new Object[3];
-
-        arrayCopy(pts, 0, oarr, 0, 3);
-        checkArrayElementsEqual(pts, oarr);
-
-        oarr = new Object[3];
-        System.arraycopy(pts, 0, oarr, 0, 3);
-        checkArrayElementsEqual(pts, oarr);
-
-        System.arraycopy(oarr, 0, pts, 0, 3);
-        checkArrayElementsEqual(pts, oarr);
-
-        oarr = new Object[3];
-        try {
-            System.arraycopy(oarr, 0, pts, 0, 3);
-            throw new RuntimeException("Expected NPE");
-        }
-        catch (NullPointerException npe) {}
-
-        oarr = new Object[3];
-        oarr[0] = new Object();
-        try {
-            System.arraycopy(oarr, 0, pts, 0, 3);
-            throw new RuntimeException("Expected ASE");
-        }
-        catch (ArrayStoreException ase) {}
-    }
-
-    void checkArrayElementsEqual(MyInt[] arr1, Object[] arr2) {
-        assertTrue(arr1.length == arr2.length, "Bad length");
-        for (int i = 0; i < arr1.length; i++) {
-            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), "Element " + i + " not equal");
-        }
-    }
-
-    void checkArrayElementsEqual(MyPoint[] arr1, Object[] arr2) {
-        assertTrue(arr1.length == arr2.length, "Bad length");
-        for (int i = 0; i < arr1.length; i++) {
-            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), "Element " + i + " not equal");
-        }
-    }
-
-    void checkArrayElementsEqual(Object[] arr1, Object[] arr2) {
-        assertTrue(arr1.length == arr2.length, "Bad length");
-        for (int i = 0; i < arr1.length; i++) {
-            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), "Element " + i + " not equal");
-        }
-    }
-
-    void arrayCopy(MyInt[] src, int srcPos, Object[] dst, int dstPos, int length) {
-        for (int i = 0; i < length ; i++) {
-            dst[dstPos++] = src[srcPos++];
-        }
-    }
-    void arrayCopy(MyPoint[] src, int srcPos, Object[] dst, int dstPos, int length) {
-        for (int i = 0; i < length ; i++) {
-            dst[dstPos++] = src[srcPos++];
-        }
-    }
-
-    Object getNull() { return null; }
-
-
-    void testValueArrayOom() {
-        int size = Integer.MAX_VALUE;
-        try {
-            MyPoint[] pts = new MyPoint[size];
-            throw new RuntimeException("Excepted OOM");
-        } catch (OutOfMemoryError oom) {}
-    }
-
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeCreation.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeCreation.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeCreation.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test ValueTypeCreation
- * @summary Value Type creation test
- * @library /test/lib
- * @compile  -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers ValueTypeCreation.java Point.java Long8Value.java Person.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.ValueTypeCreation
- * @run main/othervm -Xcomp runtime.valhalla.valuetypes.ValueTypeCreation
- */
-public class ValueTypeCreation {
-    public static void main(String[] args) {
-        ValueTypeCreation valueTypeCreation = new ValueTypeCreation();
-        valueTypeCreation.run();
-    }
-
-    public void run() {
-        testPoint();
-        testLong8();
-        testPerson();
-        StaticSelf.test();
-    }
-
-    void testPoint() {
-        Point p = Point.createPoint(1, 2);
-        Asserts.assertEquals(p.x, 1, "invalid point x value");
-        Asserts.assertEquals(p.y, 2, "invalid point y value");
-        Point p2 = clonePoint(p);
-        Asserts.assertEquals(p2.x, 1, "invalid point clone x value");
-        Asserts.assertEquals(p2.y, 2, "invalid point clone y value");
-    }
-
-    static Point clonePoint(Point p) {
-        Point q = p;
-        return q;
-    }
-
-    void testLong8() {
-        Long8Value long8Value = Long8Value.create(1, 2, 3, 4, 5, 6, 7, 8);
-        Asserts.assertEquals(long8Value.getLongField1(), 1L, "Field 1 incorrect");
-        Asserts.assertEquals(long8Value.getLongField8(), 8L, "Field 8 incorrect");
-        Long8Value.check(long8Value, 1, 2, 3, 4, 5, 6, 7, 8);
-    }
-
-    void testPerson() {
-        Person person = Person.create(1, "John", "Smith");
-        Asserts.assertEquals(person.getId(), 1, "Id field incorrect");
-        Asserts.assertEquals(person.getFirstName(), "John", "First name incorrect");
-        Asserts.assertEquals(person.getLastName(), "Smith", "Last name incorrect");
-    }
-
-    static final inline class StaticSelf {
-
-        static final StaticSelf.ref DEFAULT = create(0);
-        final int f1;
-
-        private StaticSelf() { f1 = 0; }
-        public String toString() { return "StaticSelf f1=" + f1; }
-
-        static StaticSelf create(int f1) {
-            StaticSelf s = StaticSelf.default;
-            s = __WithField(s.f1, f1);
-            return s;
-        }
-
-        public static void test() {
-            String s = DEFAULT.toString();
-        }
-
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeDensity.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeDensity.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeDensity.java
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-import java.lang.management.MemoryPoolMXBean;
-
-import sun.hotspot.WhiteBox;
-import jdk.test.lib.Asserts;
-
-/**
- * @test ValueTypeDensity
- * @summary Heap density test for ValueTypes
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueTypeDensity.java
- * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- * @run main/othervm -Xint -XX:FlatArrayElementMaxSize=-1
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
- *                    -XX:+WhiteBoxAPI ValueTypeDensity
- * @run main/othervm -Xcomp -XX:FlatArrayElementMaxSize=-1
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
- *                   -XX:+WhiteBoxAPI ValueTypeDensity
- * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions
- *                   -Xbootclasspath/a:. -XX:ForceNonTearable=*
- *                   -XX:+WhiteBoxAPI ValueTypeDensity
- */
-
-public class ValueTypeDensity {
-
-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
-
-    public ValueTypeDensity() {
-        if (WHITE_BOX.getIntxVMFlag("FlatArrayElementMaxSize") != -1) {
-            throw new IllegalStateException("FlatArrayElementMaxSize should be -1");
-        }
-    }
-
-    interface LocalDate {
-        public int getYear();
-        public short getMonth();
-        public short getDay();
-    }
-
-    interface LocalTime {
-        public byte getHour();
-        public byte getMinute();
-        public byte getSecond();
-        public int getNano();
-    }
-
-    interface LocalDateTime extends LocalDate, LocalTime {}
-
-    static final inline class LocalDateValue implements LocalDate {
-        final int   year;
-        final short month;
-        final short day;
-
-        LocalDateValue() {
-            year  = 0;
-            month = 0;
-            day   = 0;
-        }
-
-        public int   getYear()  { return year; }
-        public short getMonth() { return month; }
-        public short getDay()   { return day; }
-
-        public static LocalDateValue create(int year, short month, short day) {
-            LocalDateValue localDate = LocalDateValue.default;
-            localDate = __WithField(localDate.year, year);
-            localDate = __WithField(localDate.month, month);
-            localDate = __WithField(localDate.day, day);
-            return localDate;
-        }
-    }
-
-    static final inline class LocalTimeValue implements LocalTime {
-        final byte hour;
-        final byte minute;
-        final byte second;
-        final int nano;
-
-        LocalTimeValue() {
-            hour   = 0;
-            minute = 0;
-            second = 0;
-            nano   = 0;
-        }
-
-        public byte getHour()   { return hour; }
-        public byte getMinute() { return minute; }
-        public byte getSecond() { return second; }
-        public int getNano()    { return nano; }
-
-        public static LocalTimeValue create(byte hour, byte minute, byte second, int nano) {
-            LocalTimeValue localTime = LocalTimeValue.default;
-            localTime = __WithField(localTime.hour, hour);
-            localTime = __WithField(localTime.minute, minute);
-            localTime = __WithField(localTime.second, second);
-            localTime = __WithField(localTime.nano, nano);
-            return localTime;
-        }
-    }
-
-    static final inline class LocalDateTimeValue implements LocalDateTime {
-        final LocalDateValue date;
-        final LocalTimeValue time;
-
-        LocalDateTimeValue() {
-            // Well this is a little weird...
-            date = LocalDateValue.create(0, (short)0, (short)0);
-            time = LocalTimeValue.create((byte)0, (byte)0, (byte)0, 0);
-        }
-
-        public int   getYear()  { return date.year; }
-        public short getMonth() { return date.month; }
-        public short getDay()   { return date.day; }
-
-        public byte getHour()   { return time.hour; }
-        public byte getMinute() { return time.minute; }
-        public byte getSecond() { return time.second; }
-        public int getNano()    { return time.nano; }
-
-        public static LocalDateTimeValue create(LocalDateValue date, LocalTimeValue time) {
-            LocalDateTimeValue localDateTime = LocalDateTimeValue.default;
-            localDateTime = __WithField(localDateTime.date, date);
-            localDateTime = __WithField(localDateTime.time, time);
-            return localDateTime;
-        }
-    }
-
-    static final class LocalDateClass implements LocalDate {
-        final int   year;
-        final short month;
-        final short day;
-
-        LocalDateClass(int year, short month, short day) {
-            this.year  = year;
-            this.month = month;
-            this.day   = day;
-        }
-
-        public int   getYear()  { return year; }
-        public short getMonth() { return month; }
-        public short getDay()   { return day; }
-    }
-
-    static final class LocalTimeClass implements LocalTime {
-        final byte hour;
-        final byte minute;
-        final byte second;
-        final int nano;
-
-        LocalTimeClass(byte hour, byte minute, byte second, int nano) {
-            this.hour   = hour;
-            this.minute = minute;
-            this.second = second;
-            this.nano   = nano;
-        }
-
-        public byte getHour()   { return hour; }
-        public byte getMinute() { return minute; }
-        public byte getSecond() { return second; }
-        public int getNano()    { return nano; }
-    }
-
-    static final class LocalDateTimeClass implements LocalDateTime {
-        final LocalDateClass date;
-        final LocalTimeClass time;
-
-        LocalDateTimeClass(LocalDateClass date, LocalTimeClass time) {
-            this.date = date;
-            this.time = time;
-        }
-
-        public LocalDateClass getDate() { return date; }
-        public LocalTimeClass getTime() { return time; }
-
-        public int   getYear()  { return date.year; }
-        public short getMonth() { return date.month; }
-        public short getDay()   { return date.day; }
-
-        public byte getHour()   { return time.hour; }
-        public byte getMinute() { return time.minute; }
-        public byte getSecond() { return time.second; }
-        public int getNano()    { return time.nano; }
-    }
-
-    public void ensureArraySizeWin() {
-        int arrayLength = 1000;
-        System.out.println("ensureArraySizeWin for length " + arrayLength);
-        LocalDateTimeClass[] objectArray = new LocalDateTimeClass[arrayLength];
-        for (int i = 0; i < arrayLength; i++) {
-            objectArray[i] = new LocalDateTimeClass(new LocalDateClass(0, (short)0, (short)0),
-                    new LocalTimeClass((byte)0, (byte)0, (byte)0, 0));
-        }
-
-        long objectArraySize = WHITE_BOX.getObjectSize(objectArray);
-        System.out.println("Empty object array size: " + objectArraySize);
-        objectArraySize += (arrayLength *
-                (WHITE_BOX.getObjectSize(objectArray[0]) +
-                        WHITE_BOX.getObjectSize(objectArray[0].getDate()) +
-                        WHITE_BOX.getObjectSize(objectArray[0].getTime())));
-
-        LocalDateTimeValue[] valueArray = new LocalDateTimeValue[arrayLength];
-        // CMH: add "isFlatValueArray" to WhiteBox API, to ensure we are correctly account size
-
-        long valueArraySize = WHITE_BOX.getObjectSize(valueArray);
-        System.out.println("Object array and elements: " + objectArraySize + " versus Value Array: " + valueArraySize);
-        Asserts.assertLessThan(valueArraySize, objectArraySize, "Value array accounts for more heap than object array + elements !");
-    }
-
-    public void test() {
-        ensureArraySizeWin();
-    }
-
-    public static void main(String[] args) {
-        new ValueTypeDensity().test();
-    }
-
-}
-
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeGetField.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeGetField.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeGetField.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes;
-
-import jdk.test.lib.Asserts;
-
-/*
- * @test ValueTypeGetField
- * @summary Value Type get field test
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java ValueTypeGetField.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.ValueTypeGetField
- * @run main/othervm -Xcomp runtime.valhalla.valuetypes.ValueTypeGetField
- */
-public class ValueTypeGetField {
-
-    static Point staticPoint0;
-    static Point staticPoint1;
-    Point instancePoint0;
-    Point instancePoint1;
-
-    static {
-        staticPoint0 = Point.createPoint(358, 406);
-        staticPoint1 = Point.createPoint(101, 2653);
-    }
-
-    ValueTypeGetField() {
-        instancePoint0 = Point.createPoint(1890, 1918);
-        instancePoint1 = Point.createPoint(91, 102);
-    }
-
-    public static void main(String[] args) {
-        ValueTypeGetField valueTypeGetField = new ValueTypeGetField();
-        System.gc(); // check that VTs survive GC
-        valueTypeGetField.run();
-    }
-
-    public void run() {
-        // testing initial configuration
-        checkPoint(staticPoint0, 358, 406);
-        checkPoint(staticPoint1, 101, 2653);
-        checkPoint(instancePoint0, 1890, 1918);
-        checkPoint(instancePoint1, 91, 102);
-        // swapping static fields
-        Point p = staticPoint1;
-        staticPoint1 = staticPoint0;
-        staticPoint0 = p;
-        System.gc();
-        checkPoint(staticPoint0, 101, 2653);
-        checkPoint(staticPoint1, 358, 406);
-        //swapping instance fields
-        p = instancePoint1;
-        instancePoint1 = instancePoint0;
-        instancePoint0 = p;
-        System.gc();
-        checkPoint(instancePoint0, 91, 102);
-        checkPoint(instancePoint1, 1890, 1918);
-        // instance to static
-        staticPoint0 = instancePoint0;
-        System.gc();
-        checkPoint(staticPoint0, 91, 102);
-        // static to instance
-        instancePoint1 = staticPoint1;
-        System.gc();
-        checkPoint(instancePoint1, 358, 406);
-    }
-
-    static void checkPoint(Point p , int x, int y) {
-        Asserts.assertEquals(p.x, x, "invalid x value");
-        Asserts.assertEquals(p.y, y, "invalid y value");
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypesTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypesTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypesTest.java
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.lang.invoke.*;
-import java.lang.ref.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.*;
-
-import static jdk.test.lib.Asserts.*;
-
-import jdk.experimental.bytecode.MacroCodeBuilder;
-import jdk.experimental.bytecode.MacroCodeBuilder.CondKind;
-import jdk.experimental.bytecode.TypeTag;
-import jdk.test.lib.Platform;
-import jdk.test.lib.Utils;
-
-import jdk.experimental.value.MethodHandleBuilder;
-
-import javax.tools.*;
-
-/**
- * @test ValueTypesTest
- * @summary Test data movement with inline types
- * @modules java.base/jdk.experimental.bytecode
- *          java.base/jdk.experimental.value
- * @library /test/lib
- * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator TestValue1.java TestValue2.java TestValue3.java TestValue4.java ValueTypesTest.java
- * @run main/othervm -Xint -Xmx128m -XX:-ShowMessageBoxOnError
- *                   -XX:+ExplicitGCInvokesConcurrent
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
- *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false
- *                   runtime.valhalla.valuetypes.ValueTypesTest
- * @run main/othervm -Xcomp -Xmx128m -XX:-ShowMessageBoxOnError
- *                   -XX:+ExplicitGCInvokesConcurrent
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
- *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false
- *                   runtime.valhalla.valuetypes.ValueTypesTest
- * @run main/othervm -Xbatch -Xmx128m -XX:-ShowMessageBoxOnError
- *                   -XX:+ExplicitGCInvokesConcurrent
- *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
- *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false
- *                   -XX:ForceNonTearable=*
- *                   runtime.valhalla.valuetypes.ValueTypesTest
- */
-public class ValueTypesTest {
-
-    public static void main(String[] args) {
-        Class<?> inlineClass = runtime.valhalla.valuetypes.TestValue1.class;
-        Class<?> testClasses[] = {
-                runtime.valhalla.valuetypes.TestValue1.class,
-                runtime.valhalla.valuetypes.TestValue2.class,
-                runtime.valhalla.valuetypes.TestValue3.class,
-                runtime.valhalla.valuetypes.TestValue4.class
-        };
-        Class<?> containerClasses[] = {
-                runtime.valhalla.valuetypes.ContainerValue1.class,
-                runtime.valhalla.valuetypes.ContainerValue2.class,
-                runtime.valhalla.valuetypes.ContainerValue3.class,
-                runtime.valhalla.valuetypes.ContainerValue4.class
-        };
-
-        for (int i = 0; i < testClasses.length; i++) {
-            try {
-                testExecutionStackToLocalVariable(testClasses[i]);
-                testExecutionStackToFields(testClasses[i], containerClasses[i]);
-                // testExecutionStackToValueArray(testClasses[i], containerClasses[i]);
-            } catch (Throwable t) {
-                t.printStackTrace();
-                throw new RuntimeException(t);
-            }
-        }
-    }
-
-    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
-
-    static void testExecutionStackToLocalVariable(Class<?> inlineClass) throws Throwable {
-        String sig = "()Q" + inlineClass.getName() + ";";
-        final String signature = sig.replace('.', '/');
-        MethodHandle fromExecStackToLocalVar = MethodHandleBuilder.loadCode(
-                LOOKUP,
-                "execStackToLocalVar",
-                MethodType.methodType(boolean.class),
-                CODE -> {
-                    CODE.invokestatic(System.class, "gc", "()V", false);
-                    int n = -1;
-                    while (n < 1024) {
-                        n++;
-                        CODE
-                        .invokestatic(inlineClass, "getInstance", signature, false)
-                        .astore(n);
-                        n++;
-                        CODE
-                        .invokestatic(inlineClass, "getNonBufferedInstance", signature, false)
-                        .astore(n);
-                    }
-                    CODE.invokestatic(System.class, "gc", "()V", false);
-                    while (n > 0) {
-                        CODE
-                        .aload(n)
-                        .invokevirtual(inlineClass, "verify", "()Z", false)
-                        .iconst_1()
-                        .ifcmp(TypeTag.I, CondKind.NE, "end");
-                        n--;
-                    }
-                    CODE
-                    .iconst_1()
-                    .return_(TypeTag.Z)
-                    .label("end")
-                    .iconst_0()
-                    .return_(TypeTag.Z);
-                });
-        boolean result = (boolean) fromExecStackToLocalVar.invokeExact();
-        System.out.println(result);
-        assertTrue(result, "Invariant");
-    }
-
-    static void testExecutionStackToFields(Class<?> inlineClass, Class<?> containerClass) throws Throwable {
-        final int ITERATIONS = Platform.isDebugBuild() ? 3 : 512;
-        String sig = "()Q" + inlineClass.getName() + ";";
-        final String methodSignature = sig.replace('.', '/');
-        final String fieldQSignature = "Q" + inlineClass.getName().replace('.', '/') + ";";
-        final String fieldLSignature = "L" + inlineClass.getName().replace('.', '/') + "$ref;";
-        System.out.println(methodSignature);
-        MethodHandle fromExecStackToFields = MethodHandleBuilder.loadCode(
-                LOOKUP,
-                "execStackToFields",
-                MethodType.methodType(boolean.class),
-                CODE -> {
-                    CODE
-                    .invokestatic(System.class, "gc", "()V", false)
-                    .new_(containerClass)
-                    .dup()
-                    .invoke(MacroCodeBuilder.InvocationKind.INVOKESPECIAL, containerClass, "<init>", "()V", false)
-                    .astore_1()
-                    .iconst_m1()
-                    .istore_2()
-                    .label("loop")
-                    .iload_2()
-                    .ldc(ITERATIONS)
-                    .ifcmp(TypeTag.I, CondKind.EQ, "end")
-                    .aload_1()
-                    .invokestatic(inlineClass, "getInstance", methodSignature, false)
-                    .putfield(containerClass, "nonStaticValueField", fieldQSignature)
-                    .invokestatic(System.class, "gc", "()V", false)
-                    .aload_1()
-                    .getfield(containerClass, "nonStaticValueField", fieldQSignature)
-                    .invokevirtual(inlineClass, "verify", "()Z", false)
-                    .iconst_1()
-                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
-                    .aload_1()
-                    .invokestatic(inlineClass, "getNonBufferedInstance", methodSignature, false)
-                    .putfield(containerClass, "nonStaticValueField", fieldQSignature)
-                    .invokestatic(System.class, "gc", "()V", false)
-                    .aload_1()
-                    .getfield(containerClass, "nonStaticValueField", fieldQSignature)
-                    .invokevirtual(inlineClass, "verify", "()Z", false)
-                    .iconst_1()
-                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
-                    .invokestatic(inlineClass, "getInstance", methodSignature, false)
-                    .putstatic(containerClass, "staticValueField", fieldLSignature)
-                    .invokestatic(System.class, "gc", "()V", false)
-                    .getstatic(containerClass, "staticValueField", fieldLSignature)
-                    .checkcast(inlineClass)
-                    .invokevirtual(inlineClass, "verify", "()Z", false)
-                    .iconst_1()
-                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
-                    .invokestatic(inlineClass, "getNonBufferedInstance", methodSignature, false)
-                    .putstatic(containerClass, "staticValueField", fieldLSignature)
-                    .invokestatic(System.class, "gc", "()V", false)
-                    .getstatic(containerClass, "staticValueField", fieldLSignature)
-                    .checkcast(inlineClass)
-                    .invokevirtual(inlineClass, "verify", "()Z", false)
-                    .iconst_1()
-                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
-                    .iinc(2, 1)
-                    .goto_("loop")
-                    .label("end")
-                    .iconst_1()
-                    .return_(TypeTag.Z)
-                    .label("failed")
-                    .iconst_0()
-                    .return_(TypeTag.Z);
-                });
-        boolean result = (boolean) fromExecStackToFields.invokeExact();
-        System.out.println(result);
-        assertTrue(result, "Invariant");
-    }
-
-    static void testExecutionStackToValueArray(Class<?> inlineClass, Class<?> containerClass) throws Throwable {
-        final int ITERATIONS = Platform.isDebugBuild() ? 3 : 100;
-        String sig = "()Q" + inlineClass.getName() + ";";
-        final String signature = sig.replace('.', '/');
-        final String arraySignature = "[L" + inlineClass.getName().replace('.', '/') + ";";
-        System.out.println(arraySignature);
-        MethodHandle fromExecStackToValueArray = MethodHandleBuilder.loadCode(
-                LOOKUP,
-                "execStackToValueArray",
-                MethodType.methodType(boolean.class),
-                CODE -> {
-                    CODE
-                    .invokestatic(System.class, "gc", "()V", false)
-                    .new_(containerClass)
-                    .dup()
-                    .invoke(MacroCodeBuilder.InvocationKind.INVOKESPECIAL, containerClass, "<init>", "()V", false)
-                    .astore_1()
-                    .ldc(ITERATIONS * 3)
-                    .anewarray(inlineClass)
-                    .astore_2()
-                    .aload_2()
-                    .aload_1()
-                    .swap()
-                    .putfield(containerClass, "valueArray", arraySignature)
-                    .iconst_0()
-                    .istore_3()
-                    .label("loop1")
-                    .iload_3()
-                    .ldc(ITERATIONS)
-                    .ifcmp(TypeTag.I, CondKind.GE, "end1")
-                    .aload_2()
-                    .iload_3()
-                    .invokestatic(inlineClass, "getInstance", signature, false)
-                    .aastore()
-                    .iinc(3, 1)
-                    .aload_2()
-                    .iload_3()
-                    .invokestatic(inlineClass, "getNonBufferedInstance", signature, false)
-                    .aastore()
-                    .iinc(3, 1)
-                    .aload_2()
-                    .iload_3()
-                    .defaultvalue(inlineClass)
-                    .aastore()
-                    .iinc(3, 1)
-                    .goto_("loop1")
-                    .label("end1")
-                    .invokestatic(System.class, "gc", "()V", false)
-                    .iconst_0()
-                    .istore_3()
-                    .label("loop2")
-                    .iload_3()
-                    .ldc(ITERATIONS * 3)
-                    .ifcmp(TypeTag.I, CondKind.GE, "end2")
-                    .aload_2()
-                    .iload_3()
-                    .aaload()
-                    .invokevirtual(inlineClass, "verify", "()Z", false)
-                    .iconst_1()
-                    .ifcmp(TypeTag.I, CondKind.NE, "failed")
-                    .iinc(3, 1)
-                    .goto_("loop2")
-                    .label("end2")
-                    .iconst_1()
-                    .return_(TypeTag.Z)
-                    .label("failed")
-                    .iconst_0()
-                    .return_(TypeTag.Z);
-                });
-        boolean result = (boolean) fromExecStackToValueArray.invokeExact();
-        System.out.println(result);
-        assertTrue(result, "Invariant");
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueWithJni.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueWithJni.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueWithJni.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-/* @test
- * @summary test JNI functions with inline types
- * @compile -XDemitQtypes -XDallowWithFieldOperator ValueWithJni.java
- * @run main/othervm/native -Xint runtime.valhalla.valuetypes.ValueWithJni
- * @run main/othervm/native -Xcomp runtime.valhalla.valuetypes.ValueWithJni
- */
-public inline final class ValueWithJni {
-
-    static {
-        System.loadLibrary("ValueWithJni");
-    }
-
-    public static void main(String[] args) {
-        testJniMonitorOps();
-    }
-
-    final int x;
-    private ValueWithJni() { x = 0; }
-
-    public native void doJniMonitorEnter();
-    public native void doJniMonitorExit();
-
-    public static ValueWithJni createValueWithJni(int x) {
-        ValueWithJni v = ValueWithJni.default;
-        v = __WithField(v.x, x);
-        return v;
-    }
-
-    public static void testJniMonitorOps() {
-        boolean sawImse = false;
-        try {
-            createValueWithJni(0).doJniMonitorEnter();
-        } catch (Throwable t) {
-            sawImse = checkImse(t);
-        }
-        if (!sawImse) {
-            throw new RuntimeException("JNI MonitorEnter did not fail");
-        }
-        sawImse = false;
-        try {
-            createValueWithJni(0).doJniMonitorExit();
-        } catch (Throwable t) {
-            sawImse = checkImse(t);
-        }
-        if (!sawImse) {
-            throw new RuntimeException("JNI MonitorExit did not fail");
-        }
-    }
-
-    static boolean checkImse(Throwable t) {
-        if (t instanceof IllegalMonitorStateException) {
-            return true;
-        }
-        throw new RuntimeException(t);
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/VarArgsArray.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/VarArgsArray.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/VarArgsArray.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-
-package runtime.valhalla.valuetypes;
-
-import java.lang.reflect.*;
-import static jdk.test.lib.Asserts.*;
-
-/*
- * @test VarArgsArray
- * @summary Test if JVM API using varargs work with inline type arrays
- * @library /test/lib
- * @compile VarArgsArray.java NewInstanceFromConstructor.java IntValue.java
- * @run main/othervm -Xint runtime.valhalla.valuetypes.VarArgsArray
- * @run main/othervm -Xcomp runtime.valhalla.valuetypes.VarArgsArray
- */
-public class VarArgsArray {
-
-    static final int TOKEN_VALUE = 4711;
-
-    int methodACnt = 0;
-    int methodBCnt = 0;
-    int methodCCnt = 0;
-
-    public VarArgsArray() {
-    }
-
-    public void test() throws Throwable {
-        // test publicly accessable API in the VM...given an inline type array
-        testJvmInvokeMethod();
-        testJvmNewInstanceFromConstructor();
-    }
-
-    public void testJvmInvokeMethod() throws Throwable {
-        MyInt[] array0 = new MyInt[0];
-        MyInt[] array1 = new MyInt[] { new MyInt(TOKEN_VALUE) };
-        MyInt[] array2 = new MyInt[] { new MyInt(TOKEN_VALUE), new MyInt(TOKEN_VALUE) };
-
-        Method methodARef = getClass().getDeclaredMethod("methodA", MyInt.class);
-        Method methodBRef = getClass().getDeclaredMethod("methodB", MyInt.class, MyInt.class);
-        Method methodCRef = getClass().getDeclaredMethod("methodC", MyInt.class, String.class);
-
-        // Positive tests...
-        methodARef.invoke(this, (Object[])array1);
-        assertWithMsg(methodACnt == 1, "methodA did not invoke");
-
-        methodARef.invoke(this, array1[0]);
-        assertWithMsg(methodACnt == 2, "methodA did not invoke");
-
-        methodBRef.invoke(this, (Object[]) array2);
-        assertWithMsg(methodBCnt == 1, "methodB did not invoke");
-
-        methodBRef.invoke(this, array2[0], array2[1]);
-        assertWithMsg(methodBCnt == 2, "methodB did not invoke");
-
-        // Negative tests...
-        int argExCnt = 0;
-        try {
-            methodARef.invoke(this, (Object[]) array0);
-            throw new RuntimeException("Expected fail");
-        } catch (IllegalArgumentException argEx) { argExCnt++; }
-        try {
-            methodARef.invoke(this, (Object[]) array2);
-            throw new RuntimeException("Expected fail");
-        } catch (IllegalArgumentException argEx) { argExCnt++; }
-        try {
-            methodCRef.invoke(this, (Object[]) array2);
-            throw new RuntimeException("Expected fail");
-        } catch (IllegalArgumentException argEx) { argExCnt++; }
-        assertWithMsg(argExCnt == 3, "Did not see the correct number of exceptions");
-        assertWithMsg(methodACnt == 2, "methodA bad invoke count");
-        assertWithMsg(methodBCnt == 2, "methodB bad invoke count");
-        assertWithMsg(methodCCnt == 0, "methodC bad invoke count");
-    }
-
-    public void testJvmNewInstanceFromConstructor() throws Throwable {
-        // Inner classes use outer in param list, so these won't exercise inline type array
-        Class tc = NewInstanceFromConstructor.class;
-        Class pt = IntValue.class;
-        Constructor consARef = tc.getConstructor(pt);
-        Constructor consBRef = tc.getConstructor(pt, pt);
-        Constructor consCRef = tc.getConstructor(pt, String.class);
-        IntValue[] array0 = new IntValue[0];
-        IntValue[] array1 = new IntValue[] { new IntValue(TOKEN_VALUE) };
-        IntValue[] array2 = new IntValue[] { new IntValue(TOKEN_VALUE),
-                                             new IntValue(TOKEN_VALUE) };
-
-        // Positive tests...
-        consARef.newInstance((Object[])array1);
-        consARef.newInstance(array1[0]);
-        NewInstanceFromConstructor test = (NewInstanceFromConstructor)
-            consBRef.newInstance((Object[])array2);
-        assertWithMsg(test.getValue() == (2 * TOKEN_VALUE), "Param corrrupt");
-        consBRef.newInstance(array2[0], array2[1]);
-        assertWithMsg(NewInstanceFromConstructor.getConsCalls() == 4, "Constructor did not invoke");
-
-        // Negative tests...
-        int argExCnt = 0;
-        try {
-            consARef.newInstance((Object[])array0);
-            throw new RuntimeException("Expected fail");
-        } catch (IllegalArgumentException argEx) { argExCnt++; }
-        try {
-            consARef.newInstance((Object[])array2);
-            throw new RuntimeException("Expected fail");
-        } catch (IllegalArgumentException argEx) { argExCnt++; }
-        try {
-            consCRef.newInstance((Object[])array2);
-            throw new RuntimeException("Expected fail");
-        } catch (IllegalArgumentException argEx) { argExCnt++; }
-        assertWithMsg(argExCnt == 3, "Did not see the correct number of exceptions");
-        assertWithMsg(NewInstanceFromConstructor.getConsCalls() == 4, "Constructor should have been invoked");
-    }
-
-    public void methodA(MyInt a) {
-        assertWithMsg(a.value == TOKEN_VALUE, "Bad arg");
-        methodACnt++;
-    }
-
-    public void methodB(MyInt a, MyInt b) {
-        assertWithMsg(a.value == TOKEN_VALUE, "Bad arg");
-        assertWithMsg(b.value == TOKEN_VALUE, "Bad arg");
-        methodBCnt++;
-    }
-
-    public void methodC(MyInt a, String b) {
-        assertWithMsg(a.value == TOKEN_VALUE, "Bad arg");
-        methodCCnt++;
-    }
-
-    static void assertWithMsg(boolean expr, String msg) throws RuntimeException {
-        assertTrue(expr, msg);
-    }
-
-    public static void main(String[] args) throws Throwable {
-        new VarArgsArray().test();
-    }
-
-    inline class MyInt {
-        int value;
-        public MyInt() { this(0); }
-        public MyInt(int v) { this.value = v; }
-    }
-
-
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/VolatileTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/VolatileTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/VolatileTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package runtime.valhalla.valuetypes;
-
-/*
- * @test VolatileTest
- * @summary check effect of volatile keyword on flattenable fields
- * @modules java.base/jdk.internal.misc
- * @library /test/lib
- * @run main/othervm runtime.valhalla.valuetypes.VolatileTest
- */
-
-import jdk.internal.misc.Unsafe;
-
-import java.lang.reflect.*;
-import jdk.test.lib.Asserts;
-
-public class VolatileTest {
-    static final Unsafe U = Unsafe.getUnsafe();
-
-    static inline class MyValue {
-	int i = 0;
-	int j = 0;
-    }
-
-    static class MyContainer {
-	MyValue mv0;
-	volatile MyValue mv1;
-    }
-
-    static public void main (String[] args) {
-	Class<?> c = MyContainer.class;
-	Field f0 = null;
-	Field f1 = null;
-	try {
-	    f0 = c.getDeclaredField("mv0");
-	    f1 = c.getDeclaredField("mv1");
-	} catch(NoSuchFieldException e) {
-	    e.printStackTrace();
-	    return;
-	}
-	Asserts.assertTrue(U.isFlattened(f0), "mv0 should be flattened");
-	Asserts.assertFalse(U.isFlattened(f1), "mv1 should not be flattened");
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/BadValueTypes.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/BadValueTypes.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/BadValueTypes.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-/*
- * @test
- * @summary test that the right exceptions get thrown for bad inline type
- *          class files.
- * @compile cfpTests.jcod
- * @run main/othervm BadValueTypes
- */
-
-public class BadValueTypes {
-
-    public static void runTest(String test_name, String message) throws Exception {
-        System.out.println("Testing: " + test_name);
-        try {
-            Class newClass = Class.forName(test_name);
-        } catch (java.lang.ClassFormatError e) {
-            if (!e.getMessage().contains(message)) {
-                throw new RuntimeException( "Wrong ClassFormatError: " + e.getMessage());
-            }
-        }
-    }
-
-    public static void main(String[] args) throws Exception {
-
-        // Test that ACC_VALUE with ACC_ABSTRACT is illegal.
-        runTest("ValueAbstract", "Illegal class modifiers in class ValueAbstract");
-
-        // Test that ACC_VALUE with ACC_ENUM is illegal.
-        runTest("ValueEnum", "Illegal class modifiers in class ValueEnum");
-
-        // Test that inline type fields must be final.
-        runTest("ValueFieldNotFinal", "Illegal field modifiers in class ValueFieldNotFinal");
-
-        // Test that ACC_VALUE with ACC_INTERFACE is illegal.
-        runTest("ValueInterface", "Illegal class modifiers in class ValueInterface");
-
-        // Test that inline type instance methods cannot be synchronized.
-        runTest("ValueMethodSynch",
-                "Method getInt in class ValueMethodSynch (an inline class) has illegal modifiers");
-
-        // Test that ClassCircularityError gets detected for instance fields.
-        System.out.println("Testing ClassCircularityError for instance fields");
-        try {
-            Class newClass = Class.forName("Circ");
-            throw new RuntimeException( "java.lang.ClassCircularityError exception not thrown!");
-        } catch (java.lang.ClassCircularityError e) {
-             if (!e.getMessage().contains("Circ")) {
-                 throw new RuntimeException( "Wrong ClassCircularityError: " + e.getMessage());
-             }
-         }
-
-        // Test that ClassCircularityError isn't detected for static fields.
-        System.out.println("Testing ClassCircularityError for static fields");
-        try {
-            Class newClass = Class.forName("CircStaticB");
-        } catch (java.lang.ClassCircularityError e) {
-             throw new RuntimeException( "java.lang.ClassCircularityError exception thrown!");
-         }
-
-        runTest("ValueCloneable", "Inline Types do not support Cloneable");
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/libTestJNIArrays.c b/test/hotspot/jtreg/runtime/valhalla/valuetypes/libTestJNIArrays.c
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/libTestJNIArrays.c
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <jni.h>
-
-#if !defined(_WIN32) && !defined(_WIN64)
-
-JNIEXPORT jint JNICALL
-Java_TestJNIArrays_GetFlattenedArrayElementSizeWrapper(JNIEnv* env, jobject receiver, jarray array) {
-  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
-  return (jint)elm_sz;
-}
-
-JNIEXPORT jclass JNICALL
-Java_TestJNIArrays_GetFlattenedArrayElementClassWrapper(JNIEnv* env, jobject receiver, jarray array) {
-  jclass elm_class = (*env)->GetFlattenedArrayElementClass(env, array);
-  return elm_class;
-}
-
-JNIEXPORT jint JNICALL
-Java_TestJNIArrays_GetFieldOffsetInFlattenedLayoutWrapper(JNIEnv* env, jobject receiver, jclass clazz, jstring name, jstring signature, jboolean expectFlattened) {
-  jboolean flattened;
-  const char *name_ptr = (*env)->GetStringUTFChars(env, name, NULL);
-  const char *signature_ptr = (*env)->GetStringUTFChars(env, signature, NULL);
-  int offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, name_ptr,signature_ptr, &flattened);
-  (*env)->ReleaseStringUTFChars(env, name, name_ptr);
-  (*env)->ReleaseStringUTFChars(env, signature, signature_ptr);
-  if ((*env)->ExceptionCheck(env)) {
-    return -1;
-  }
-  if (flattened != expectFlattened) {
-    jclass RE = (*env)->FindClass(env, "java/lang/RuntimeException");
-    (*env)->ThrowNew(env, RE, "Flattening mismatch");
-    return -1;
-  }
-  return offset;
-}
-
-JNIEXPORT jlong JNICALL
-Java_TestJNIArrays_GetFlattenedArrayElementsWrapper(JNIEnv* env, jobject receiver, jarray array) {
-  jboolean isCopy;
-  void* addr = (*env)->GetFlattenedArrayElements(env, array, &isCopy);
-  return (jlong)addr;
-}
-
-JNIEXPORT void JNICALL
-Java_TestJNIArrays_ReleaseFlattenedArrayElementsWrapper(JNIEnv* env, jobject receiver, jarray array, jlong addr, jint mode) {
-  (*env)->ReleaseFlattenedArrayElements(env, array, (void*)addr, mode);
-}
-
-JNIEXPORT jint JNICALL
-Java_TestJNIArrays_getIntFieldAtIndex(JNIEnv* env, jobject receiver, jarray array, jint index, jstring name, jstring signature) {
-  jint array_length = (*env)->GetArrayLength(env, array);
-  if (index < 0 || index >= array_length) {
-    jclass AIOOBE = (*env)->FindClass(env, "java.lang.ArrayIndexOutOfBoundsException");
-    (*env)->ThrowNew(env, AIOOBE, "Bad index");
-    return -1;
-  }
-  jobject element = (*env)->GetObjectArrayElement(env, array, index);
-  // should add protection against null element here (could happen if array is not a flattened array
-  jclass element_class = (*env)->GetObjectClass(env, element);
-  const char *name_ptr = (*env)->GetStringUTFChars(env, name, NULL);
-  const char *signature_ptr = (*env)->GetStringUTFChars(env, signature, NULL);
-  jfieldID field_id = (*env)->GetFieldID(env, element_class, (const char*)name_ptr, (const char *)signature_ptr);
-  (*env)->ReleaseStringUTFChars(env, name, name_ptr);
-  (*env)->ReleaseStringUTFChars(env, signature, signature_ptr);
-  jint value = (*env)->GetIntField(env, element, field_id);
-  return value;
-}
-
-JNIEXPORT void JNICALL
-Java_TestJNIArrays_printArrayInformation(JNIEnv* env, jobject receiver, jarray array) {
-  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
-  void* base = (*env)->GetFlattenedArrayElements(env, array, NULL);
-  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
-}
-
-JNIEXPORT void JNICALL
-Java_TestJNIArrays_initializeIntIntArrayBuffer(JNIEnv* env, jobject receiver, jarray array, int i0, int i1) {
-  int len = (*env)->GetArrayLength(env, array);
-  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
-  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
-  int i0_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i0", "I", NULL);
-  int i1_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i1", "I", NULL);
-  char* buffer = (char*)malloc(elm_sz);
-  if (buffer == NULL) {
-    jclass OOM = (*env)->FindClass(env, "java/lang/OutOfMemoryException");
-    (*env)->ThrowNew(env, OOM, "Malloc failed");
-    return;
-  }
-  *(int*)(buffer + i0_offset) = i0;
-  *(int*)(buffer + i1_offset) = i1;
-  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
-  for (int i = 0; i < len; i++) {
-    memcpy((char*)base + i * elm_sz, buffer, elm_sz);
-  }
-  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
-  free(buffer);
-}
-
-JNIEXPORT void JNICALL
-Java_TestJNIArrays_initializeIntIntArrayFields(JNIEnv* env, jobject receiver, jarray array, int i0, int i1) {
-  int len = (*env)->GetArrayLength(env, array);
-  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
-  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
-  int i0_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i0", "I", NULL);
-  int i1_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i1", "I", NULL);
-  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
-  char* elm_ptr = base;
-  for (int i = 0; i < len; i++) {
-    *(int*)(elm_ptr + i0_offset) = i0;
-    *(int*)(elm_ptr + i1_offset) = i1;
-    elm_ptr += elm_sz;
-  }
-  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
-}
-
-struct IntInt_offsets {
-  int i0_offset;
-  int i1_offset;
-};
-
-#ifdef __APPLE__
-static int compare_IntInt(void* offsets, const void* x, const void* y)  {
-#endif // __APPLE__
-#ifdef __linux__
-static int compare_IntInt(const void* x, const void* y, void* offsets)  {
-#endif // __linux__
-  int i0_offset = ((struct IntInt_offsets*)offsets)->i0_offset;
-  int x_i0 = *(int*)((char*)x + i0_offset);
-  int y_i0 = *(int*)((char*)y + i0_offset);
-  if (x_i0 < y_i0) return -1;
-  if (x_i0 > y_i0) return 1;
-  int i1_offset = ((struct IntInt_offsets*)offsets)->i1_offset;
-  int x_i1 = *(int*)((char*)x + i1_offset);
-  int y_i1 = *(int*)((char*)y + i1_offset );
-  if (x_i1 < y_i1) return -1;
-  if (x_i1 > y_i1) return 1;
-  return 0;
-}
-
-JNIEXPORT void JNICALL
-Java_TestJNIArrays_sortIntIntArray(JNIEnv* env, jobject receiver, jarray array) {
-  int len = (*env)->GetArrayLength(env, array);
-  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
-  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
-  struct IntInt_offsets offsets;
-  offsets.i0_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i0", "I", NULL);
-  offsets.i1_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "i1", "I", NULL);
-  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
-#ifdef __APPLE__
-  qsort_r(base, len, elm_sz, (void*) &offsets, compare_IntInt);
-#endif // __APPLE__
-#ifdef __linux__
-  qsort_r(base, len, elm_sz,  compare_IntInt, (void*) &offsets);
-#endif // __linux__
-  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
-}
-
-
-JNIEXPORT void JNICALL
-Java_TestJNIArrays_initializeContainerArray(JNIEnv* env, jobject receiver, jarray array,
-					       jdouble d, jfloat f, jshort s, jbyte b) {
-  int len = (*env)->GetArrayLength(env, array);
-  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
-  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
-  int d_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "d", "D", NULL);
-  int b_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "b", "B", NULL);
-  jboolean flattened;
-  int c_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "c", "QTestJNIArrays$Containee;", &flattened);
-  if (!flattened) {
-    jclass RE = (*env)->FindClass(env, "java/lang/RuntimeException");
-    (*env)->ThrowNew(env, RE, "Incompatible layout");
-    return;
-  }
-  jclass clazz2 = (*env)->FindClass(env, "TestJNIArrays$Containee");
-  int f_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz2, "f", "F", NULL);
-  int s_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz2, "s", "S", NULL);
-  f_offset += c_offset;
-  s_offset += c_offset;
-  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
-  char* elm_ptr = base;
-  for (int i = 0; i < len; i++) {
-    *(jdouble*)(elm_ptr + d_offset) = d;
-    *(jfloat*)(elm_ptr + f_offset) = f;
-    *(jshort*)(elm_ptr + s_offset) = s;
-    *(jbyte*)(elm_ptr + b_offset) = b;
-    elm_ptr += elm_sz;
-  }
-  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
-}
-
-
-JNIEXPORT void JNICALL
-Java_TestJNIArrays_updateContainerArray(JNIEnv* env, jobject receiver, jarray array,
-					       jfloat f, jshort s) {
-  int len = (*env)->GetArrayLength(env, array);
-  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
-  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
-  jboolean flattened;
-  int c_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "c", "QTestJNIArrays$Containee;", &flattened);
-  if (!flattened) {
-    jclass RE = (*env)->FindClass(env, "java/lang/RuntimeException");
-    (*env)->ThrowNew(env, RE, "Incompatible layout");
-    return;
-  }
-  jclass clazz2 = (*env)->FindClass(env, "TestJNIArrays$Containee");
-  int f_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz2, "f", "F", NULL);
-  int s_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz2, "s", "S", NULL);
-  f_offset += c_offset;
-  s_offset += c_offset;
-  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
-  char* elm_ptr = base;
-  for (int i = 0; i < len; i++) {
-    *(jfloat*)(elm_ptr + f_offset) = f;
-    *(jshort*)(elm_ptr + s_offset) = s;
-    elm_ptr += elm_sz;
-  }
-  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
-}
-
-
- JNIEXPORT void JNICALL
- Java_TestJNIArrays_initializeLongLongLongLongArray(JNIEnv* env, jobject receiver, jarray array, jlong l0, jlong l1, jlong l2, jlong l3) {
-  int len = (*env)->GetArrayLength(env, array);
-  jsize elm_sz = (*env)->GetFlattenedArrayElementSize(env, array);
-  jclass clazz = (*env)->GetFlattenedArrayElementClass(env, array);
-  int l0_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "l0", "J", NULL);
-  int l1_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "l1", "J", NULL);
-  int l2_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "l2", "J", NULL);
-  int l3_offset = (*env)->GetFieldOffsetInFlattenedLayout(env, clazz, "l3", "J", NULL);
-  void* base = (void*)(*env)->GetFlattenedArrayElements(env, array, NULL);
-  char* elm_ptr = base;
-  for (int i = 0; i < len; i++) {
-    *(jlong*)(elm_ptr + l0_offset) = l0;
-    *(jlong*)(elm_ptr + l1_offset) = l1;
-    *(jlong*)(elm_ptr + l2_offset) = l2;
-    *(jlong*)(elm_ptr + l3_offset) = l3;
-    elm_ptr += elm_sz;
-  }
-  (*env)->ReleaseFlattenedArrayElements(env, array, base, 0);
-}
-
-JNIEXPORT jobject JNICALL
-Java_TestJNIArrays_createSubElementSelector(JNIEnv* env, jobject receiver, jarray array) {
-  return (*env)->CreateSubElementSelector(env, array);
-}
-
-JNIEXPORT jobject JNICALL
-  Java_TestJNIArrays_getSubElementSelector(JNIEnv* env, jobject receiver, jobject selector, jclass klass, jstring name, jstring signature) {
-  const char *name_ptr = (*env)->GetStringUTFChars(env, name, NULL);
-  const char *signature_ptr = (*env)->GetStringUTFChars(env, signature, NULL);
-  jfieldID fieldID = (*env)->GetFieldID(env, klass, name_ptr, signature_ptr);
-  jobject res = (*env)->GetSubElementSelector(env, selector, fieldID);
-  (*env)->ReleaseStringUTFChars(env, name, name_ptr);
-  (*env)->ReleaseStringUTFChars(env, signature, signature_ptr);
-  return res;
-}
-
-JNIEXPORT jobject JNICALL
-Java_TestJNIArrays_getObjectSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index) {
-  return (*env)->GetObjectSubElement(env, array, selector, index);
-}
-
-JNIEXPORT void JNICALL
-  Java_TestJNIArrays_setObjectSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index, jobject value) {
-  (*env)->SetObjectSubElement(env, array, selector, index, value);
-}
-
-JNIEXPORT jshort JNICALL
-Java_TestJNIArrays_getShortSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index) {
-  return (*env)->GetShortSubElement(env, array, selector, index);
-}
-
-JNIEXPORT void JNICALL
-  Java_TestJNIArrays_setShortSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index, short value) {
-  (*env)->SetShortSubElement(env, array, selector, index, value);
-}
-
-JNIEXPORT jint JNICALL
-Java_TestJNIArrays_getIntSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index) {
-  return (*env)->GetIntSubElement(env, array, selector, index);
-}
-
-JNIEXPORT void JNICALL
-  Java_TestJNIArrays_setIntSubElement(JNIEnv* env, jobject receiver, jarray array, jobject selector, jint index, jint value) {
-  (*env)->SetIntSubElement(env, array, selector, index, value);
-}
-
-#endif // !defined(_WIN32) && !defined(_WIN64)
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/libValueWithJni.c b/test/hotspot/jtreg/runtime/valhalla/valuetypes/libValueWithJni.c
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/libValueWithJni.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <jni.h>
-
-JNIEXPORT void JNICALL
-Java_runtime_valhalla_valuetypes_ValueWithJni_doJniMonitorEnter(JNIEnv *env, jobject obj) {
-    (*env)->MonitorEnter(env, obj);
-}
-
-JNIEXPORT void JNICALL
-Java_runtime_valhalla_valuetypes_ValueWithJni_doJniMonitorExit(JNIEnv *env, jobject obj) {
-    (*env)->MonitorExit(env, obj);
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/ValueCapableClass.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/ValueCapableClass.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/ValueCapableClass.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package runtime.valhalla.valuetypes.verifier;
-
-@jdk.incubator.mvt.ValueCapableClass
-public final class ValueCapableClass {
-
-    public static final int DEFAULT_X = 11;
-    public static final short DEFAULT_Y = 13;
-    public static final short DEFAULT_Z = 15;
-    public static final String STATIC_FIELD = "Should be left alone";
-
-    public final int   x;
-    public final short y;
-    public final short z;
-
-    private ValueCapableClass() {
-        this(DEFAULT_X, DEFAULT_Y, DEFAULT_Z);
-    }
-
-    private ValueCapableClass(int x, short y, short z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    public int getX() {
-        return x;
-    }
-
-    public short getY() {
-        return y;
-    }
-
-    public short getZ() {
-        return z;
-    }
-
-    public String toString() {
-        int ax = getX();
-        short ay = getY();
-        short az = getZ();
-        return "ValueCapableClass x=" + ax + " y=" + ay + " z=" + az;
-    }
-
-    public static ValueCapableClass create(int x, short y, short z) {
-        return new ValueCapableClass(x, y, z);
-    }
-
-    public static ValueCapableClass create() {
-        return new ValueCapableClass();
-    }
-
-    public static void test() {
-        ValueCapableClass value = create(4711, (short)7, (short)11);
-        String s = value.toString();
-        if ((value.getX() != 4711) || (value.getY() != 7) || value.getZ() != 11) {
-            throw new IllegalStateException("Bad value: " + s);
-        }
-        System.out.println(s);
-        ValueCapableClass defaultValue = create();
-        s = defaultValue.toString();
-        if ((defaultValue.getX() != DEFAULT_X) ||
-            (defaultValue.getY() != DEFAULT_Y) ||
-            (defaultValue.getZ() != DEFAULT_Z)) {
-            throw new IllegalStateException("Bad value: " + s);
-        }
-
-        if (!STATIC_FIELD.equals("Should be left alone")) {
-            throw new IllegalStateException("Bad static field: " + STATIC_FIELD);
-        }
-    }
-
-    public static void main(String[] args) {
-        test();
-    }
-}
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/VerifierValueTypes.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/VerifierValueTypes.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/verifier/VerifierValueTypes.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-/*
- * @test
- * @bug 8223028
- * @summary test that the right exceptions get thrown for bad inline type
- *          class files.
- * @compile verifierTests.jcod NoNullVT.jcod
- * @run main/othervm -verify VerifierValueTypes
- */
-
-public class VerifierValueTypes {
-
-    public static void runTestVerifyError(String test_name, String message) throws Exception {
-        System.out.println("Testing: " + test_name);
-        try {
-            Class newClass = Class.forName(test_name);
-            throw new RuntimeException("Expected VerifyError exception not thrown");
-        } catch (java.lang.VerifyError e) {
-            if (!e.getMessage().contains(message)) {
-                throw new RuntimeException("Wrong VerifyError: " + e.getMessage());
-            }
-        }
-    }
-
-    public static void runTestFormatError(String test_name, String message) throws Exception {
-        System.out.println("Testing: " + test_name);
-        try {
-            Class newClass = Class.forName(test_name);
-            throw new RuntimeException("Expected ClassFormatError exception not thrown");
-        } catch (java.lang.ClassFormatError e) {
-            if (!e.getMessage().contains(message)) {
-                throw new RuntimeException("Wrong ClassFormatError: " + e.getMessage());
-            }
-        }
-    }
-
-    public static void runTestNoError(String test_name) throws Exception {
-        System.out.println("Testing: " + test_name);
-        Class newClass = Class.forName(test_name);
-    }
-
-    public static void main(String[] args) throws Exception {
-
-        // Test that a defaultvalue opcode with an out of bounds cp index causes a VerifyError.
-        runTestVerifyError("defValBadCP", "Illegal constant pool index");
-
-        // Test that ClassFormatError is thrown for a class file, with major version 54, that
-        // contains a defaultvalue opcode.
-        runTestFormatError("defValBadMajorVersion", "defaultvalue not supported by this class file version");
-
-        // Test VerifyError is thrown if a defaultvalue's cp entry is not a class.
-        runTestVerifyError("defValWrongCPType", "Illegal type at constant pool entry");
-
-/*
-        // Test that a withfield opcode with an out of bounds cp index causes a VerifyError.
-        runTestVerifyError("wthFldBadCP", "Illegal constant pool index");
-
-        // Test that VerifyError is thrown if the first operand on the stack is not assignable
-        // to withfield's field.
-        runTestVerifyError("wthFldBadFldVal", "Bad type on operand stack");
-
-        // Test that VerifyError is thrown if the second operand on the stack is a primitive.
-        runTestVerifyError("wthFldBadFldRef", "Bad type on operand stack");
-
-        // Test that ClassFormatError is thrown for a class file, with major version 54, that
-        // contains a withfield opcode.
-        runTestFormatError("wthFldBadMajorVersion", "withfield not supported by this class file version");
-
-        // Test VerifyError is thrown if a withfields's cp entry is not a field.
-        runTestVerifyError("wthFldWrongCPType", "Illegal type at constant pool entry");
-
-        // Test that VerifyError is thrown if the class for a withfields's cp fieldref
-        // entry is java.lang.Object and the reference on the stack is an inline type.
-        runTestVerifyError("wthFldObject", "must be identical inline types");
-
-        // Test VerifyError is thrown if a monitorenter's cp entry is an inline type.
-        runTestVerifyError("monEnterVT", "Bad type on operand stack");
-*/
-
-        // Test VerifyError is thrown if a defaultvalue's cp entry is an inline type.
-        runTestVerifyError("defValueObj", "Illegal type at constant pool entry 4");
-
-        // Test VerifyError is thrown if a withfield's class operand is not an inline type.
-//        runTestVerifyError("withfieldObj", "Bad type on operand stack");
-
-        // Test that null is not assignable to an inline type.
-        runTestVerifyError("NoNullVT",
-            "Type null (current frame, stack[1]) is not assignable to 'QNoNullVT;'");
-    }
-}

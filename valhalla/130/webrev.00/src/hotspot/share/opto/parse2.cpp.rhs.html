<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/parse2.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;compiler/compileLog.hpp&quot;
  30 #include &quot;interpreter/linkResolver.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/oop.inline.hpp&quot;
  34 #include &quot;opto/addnode.hpp&quot;
  35 #include &quot;opto/castnode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/idealKit.hpp&quot;
  40 #include &quot;opto/inlinetypenode.hpp&quot;
  41 #include &quot;opto/matcher.hpp&quot;
  42 #include &quot;opto/memnode.hpp&quot;
  43 #include &quot;opto/mulnode.hpp&quot;
  44 #include &quot;opto/opaquenode.hpp&quot;
  45 #include &quot;opto/parse.hpp&quot;
  46 #include &quot;opto/runtime.hpp&quot;
  47 #include &quot;runtime/deoptimization.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 
  50 #ifndef PRODUCT
  51 extern int explicit_null_checks_inserted,
  52            explicit_null_checks_elided;
  53 #endif
  54 
  55 Node* Parse::record_profile_for_speculation_at_array_load(Node* ld) {
  56   // Feed unused profile data to type speculation
  57   if (UseTypeSpeculation &amp;&amp; UseArrayLoadStoreProfile) {
  58     ciKlass* array_type = NULL;
  59     ciKlass* element_type = NULL;
  60     ProfilePtrKind element_ptr = ProfileMaybeNull;
  61     bool flat_array = true;
  62     bool null_free_array = true;
  63     method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
  64     if (element_type != NULL || element_ptr != ProfileMaybeNull) {
  65       ld = record_profile_for_speculation(ld, element_type, element_ptr);
  66     }
  67   }
  68   return ld;
  69 }
  70 
  71 
  72 //---------------------------------array_load----------------------------------
  73 void Parse::array_load(BasicType bt) {
  74   const Type* elemtype = Type::TOP;
  75   Node* adr = array_addressing(bt, 0, elemtype);
  76   if (stopped())  return;     // guaranteed null or range check
  77 
  78   Node* idx = pop();
  79   Node* ary = pop();
  80 
  81   // Handle inline type arrays
  82   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
  83   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
  84   if (elemtype-&gt;isa_inlinetype() != NULL) {
  85     C-&gt;set_flattened_accesses();
  86     // Load from flattened inline type array
  87     Node* vt = InlineTypeNode::make_from_flattened(this, elemtype-&gt;inline_klass(), ary, adr);
  88     push(vt);
  89     return;
  90   } else if (elemptr != NULL &amp;&amp; elemptr-&gt;is_inlinetypeptr() &amp;&amp; !elemptr-&gt;maybe_null()) {
  91     // Load from non-flattened inline type array (elements can never be null)
  92     bt = T_INLINE_TYPE;
  93   } else if (!ary_t-&gt;is_not_flat()) {
  94     // Cannot statically determine if array is flattened, emit runtime check
  95     assert(UseFlatArray &amp;&amp; is_reference_type(bt) &amp;&amp; elemptr-&gt;can_be_inline_type() &amp;&amp; !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free() &amp;&amp;
  96            (!elemptr-&gt;is_inlinetypeptr() || elemptr-&gt;inline_klass()-&gt;flatten_array()), &quot;array can&#39;t be flattened&quot;);
  97     IdealKit ideal(this);
  98     IdealVariable res(ideal);
  99     ideal.declarations_done();
 100     ideal.if_then(is_non_flattened_array(ary)); {
 101       // non-flattened
 102       assert(ideal.ctrl()-&gt;in(0)-&gt;as_If()-&gt;is_non_flattened_array_check(&amp;_gvn), &quot;Should be found&quot;);
 103       sync_kit(ideal);
 104       const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 105       Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,
 106                                 IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
 107       ideal.sync_kit(this);
 108       ideal.set(res, ld);
 109     } ideal.else_(); {
 110       // flattened
 111       sync_kit(ideal);
 112       if (elemptr-&gt;is_inlinetypeptr()) {
 113         // Element type is known, cast and load from flattened representation
 114         ciInlineKlass* vk = elemptr-&gt;inline_klass();
 115         assert(vk-&gt;flatten_array() &amp;&amp; elemptr-&gt;maybe_null(), &quot;never/always flat - should be optimized&quot;);
 116         ciArrayKlass* array_klass = ciArrayKlass::make(vk);
 117         const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
 118         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));
 119         Node* casted_adr = array_element_address(cast, idx, T_INLINE_TYPE, ary_t-&gt;size(), control());
 120         // Re-execute flattened array load if buffering triggers deoptimization
 121         PreserveReexecuteState preexecs(this);
 122         jvms()-&gt;set_should_reexecute(true);
 123         inc_sp(2);
 124         Node* vt = InlineTypeNode::make_from_flattened(this, vk, cast, casted_adr)-&gt;buffer(this, false);
 125         ideal.set(res, vt);
 126         ideal.sync_kit(this);
 127       } else {
 128         // Element type is unknown, emit runtime call
 129         Node* kls = load_object_klass(ary);
 130         Node* k_adr = basic_plus_adr(kls, in_bytes(ArrayKlass::element_klass_offset()));
 131         Node* elem_klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS));
 132         Node* obj_size  = NULL;
 133         kill_dead_locals();
 134         // Re-execute flattened array load if buffering triggers deoptimization
 135         PreserveReexecuteState preexecs(this);
 136         jvms()-&gt;set_bci(_bci);
 137         jvms()-&gt;set_should_reexecute(true);
 138         inc_sp(2);
 139         Node* alloc_obj = new_instance(elem_klass, NULL, &amp;obj_size, /*deoptimize_on_exception=*/true);
 140 
 141         AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
 142         assert(alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
 143         alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
 144 
 145         // This membar keeps this access to an unknown flattened array
 146         // correctly ordered with other unknown and known flattened
 147         // array accesses.
 148         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::INLINES));
 149 
 150         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 151         // Unknown inline type might contain reference fields
 152         if (false &amp;&amp; !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing)) {
 153           // FIXME 8230656 also merge changes from 8238759 in
 154           int base_off = sizeof(instanceOopDesc);
 155           Node* dst_base = basic_plus_adr(alloc_obj, base_off);
 156           Node* countx = obj_size;
 157           countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));
 158           countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));
 159 
 160           assert(Klass::_lh_log2_element_size_shift == 0, &quot;use shift in place&quot;);
 161           Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));
 162           Node* elem_shift = make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);
 163           uint header = arrayOopDesc::base_offset_in_bytes(T_INLINE_TYPE);
 164           Node* base  = basic_plus_adr(ary, header);
 165           idx = Compile::conv_I2X_index(&amp;_gvn, idx, TypeInt::POS, control());
 166           Node* scale = _gvn.transform(new LShiftXNode(idx, elem_shift));
 167           Node* adr = basic_plus_adr(ary, base, scale);
 168 
 169           access_clone(adr, dst_base, countx, false);
 170         } else {
 171           ideal.sync_kit(this);
 172           ideal.make_leaf_call(OptoRuntime::load_unknown_inline_type(),
 173                                CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_inline),
 174                                &quot;load_unknown_inline&quot;,
 175                                ary, idx, alloc_obj);
 176           sync_kit(ideal);
 177         }
 178 
 179         // This makes sure no other thread sees a partially initialized buffered inline type
 180         insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
 181 
 182         // Same as MemBarCPUOrder above: keep this unknown flattened
 183         // array access correctly ordered with other flattened array
 184         // access
 185         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::INLINES));
 186 
 187         // Prevent any use of the newly allocated inline type before it is fully initialized
 188         alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
 189         alloc_obj-&gt;set_req(0, control());
 190         alloc_obj = _gvn.transform(alloc_obj);
 191 
 192         const Type* unknown_value = elemptr-&gt;is_instptr()-&gt;cast_to_flat_array();
 193         alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));
 194 
 195         ideal.sync_kit(this);
 196         ideal.set(res, alloc_obj);
 197       }
 198     } ideal.end_if();
 199     sync_kit(ideal);
 200     Node* ld = _gvn.transform(ideal.value(res));
 201     ld = record_profile_for_speculation_at_array_load(ld);
 202     push_node(bt, ld);
 203     return;
 204   }
 205 
 206   if (elemtype == TypeInt::BOOL) {
 207     bt = T_BOOLEAN;
 208   }
 209   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 210   Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,
 211                             IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
 212   if (bt == T_INLINE_TYPE) {
 213     // Loading a non-flattened inline type from an array
 214     assert(!gvn().type(ld)-&gt;maybe_null(), &quot;inline type array elements should never be null&quot;);
 215     if (elemptr-&gt;inline_klass()-&gt;is_scalarizable()) {
 216       ld = InlineTypeNode::make_from_oop(this, ld, elemptr-&gt;inline_klass());
 217     }
 218   }
 219   if (!ld-&gt;is_InlineType()) {
 220     ld = record_profile_for_speculation_at_array_load(ld);
 221   }
 222 
 223   push_node(bt, ld);
 224 }
 225 
 226 
 227 //--------------------------------array_store----------------------------------
 228 void Parse::array_store(BasicType bt) {
 229   const Type* elemtype = Type::TOP;
 230   Node* adr = array_addressing(bt, type2size[bt], elemtype);
 231   if (stopped())  return;     // guaranteed null or range check
 232   Node* cast_val = NULL;
 233   if (bt == T_OBJECT) {
 234     cast_val = array_store_check();
 235     if (stopped()) return;
 236   }
 237   Node* val = pop_node(bt); // Value to store
 238   Node* idx = pop();        // Index in the array
 239   Node* ary = pop();        // The array itself
 240 
 241   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
 242   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 243 
 244   if (elemtype == TypeInt::BOOL) {
 245     bt = T_BOOLEAN;
 246   } else if (bt == T_OBJECT) {
 247     elemtype = elemtype-&gt;make_oopptr();
 248     const Type* tval = _gvn.type(cast_val);
 249     // We may have lost type information for &#39;val&#39; here due to the casts
 250     // emitted by the array_store_check code (see JDK-6312651)
 251     // TODO Remove this code once JDK-6312651 is in.
 252     const Type* tval_init = _gvn.type(val);
<a name="1" id="anc1"></a><span class="line-modified"> 253     // Based on the value to be stored, try to determine if the array is not null-free and/or not flat.</span>
<span class="line-modified"> 254     // This is only legal for non-null stores because the array_store_check always passes for null, even</span>
<span class="line-modified"> 255     // if the array is null-free. Null stores are handled in GraphKit::gen_inline_array_null_guard().</span>
<span class="line-modified"> 256     bool not_inline = !tval-&gt;isa_inlinetype() &amp;&amp;</span>
<span class="line-added"> 257                       ((!tval_init-&gt;maybe_null() &amp;&amp; !tval_init-&gt;is_oopptr()-&gt;can_be_inline_type()) ||</span>
<span class="line-added"> 258                        (!tval-&gt;maybe_null() &amp;&amp; !tval-&gt;is_oopptr()-&gt;can_be_inline_type()));</span>
<span class="line-added"> 259     bool not_flattened = not_inline || ((tval_init-&gt;is_inlinetypeptr() || tval_init-&gt;isa_inlinetype()) &amp;&amp; !tval_init-&gt;inline_klass()-&gt;flatten_array());</span>
<span class="line-added"> 260     if (!ary_t-&gt;is_not_null_free() &amp;&amp; not_inline) {</span>
 261       // Storing a non-inline type, mark array as not null-free (-&gt; not flat).
<a name="2" id="anc2"></a>

 262       ary_t = ary_t-&gt;cast_to_not_null_free();
 263       Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
 264       replace_in_map(ary, cast);
 265       ary = cast;
 266     } else if (!ary_t-&gt;is_not_flat() &amp;&amp; not_flattened) {
 267       // Storing a non-flattened value, mark array as not flat.
 268       ary_t = ary_t-&gt;cast_to_not_flat();
 269       Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
 270       replace_in_map(ary, cast);
 271       ary = cast;
 272     }
 273 
 274     if (ary_t-&gt;elem()-&gt;isa_inlinetype() != NULL) {
 275       // Store to flattened inline type array
 276       C-&gt;set_flattened_accesses();
 277       if (!cast_val-&gt;is_InlineType()) {
 278         inc_sp(3);
 279         cast_val = null_check(cast_val);
 280         if (stopped()) return;
 281         dec_sp(3);
 282         cast_val = InlineTypeNode::make_from_oop(this, cast_val, ary_t-&gt;elem()-&gt;inline_klass());
 283       }
 284       // Re-execute flattened array store if buffering triggers deoptimization
 285       PreserveReexecuteState preexecs(this);
 286       inc_sp(3);
 287       jvms()-&gt;set_should_reexecute(true);
 288       cast_val-&gt;as_InlineType()-&gt;store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 289       return;
 290     } else if (elemtype-&gt;is_inlinetypeptr() &amp;&amp; !elemtype-&gt;maybe_null()) {
 291       // Store to non-flattened inline type array (elements can never be null)
 292       if (!cast_val-&gt;is_InlineType() &amp;&amp; tval-&gt;maybe_null()) {
 293         inc_sp(3);
 294         cast_val = null_check(cast_val);
 295         if (stopped()) return;
 296         dec_sp(3);
 297       }
<a name="3" id="anc3"></a><span class="line-modified"> 298     } else if (!ary_t-&gt;is_not_flat() &amp;&amp; tval != TypePtr::NULL_PTR) {</span>
<span class="line-modified"> 299       // Array might be flattened, emit runtime checks (for NULL, a simple inline_array_null_guard is sufficient).</span>
 300       assert(UseFlatArray &amp;&amp; !not_flattened &amp;&amp; elemtype-&gt;is_oopptr()-&gt;can_be_inline_type() &amp;&amp;
 301              !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free(), &quot;array can&#39;t be flattened&quot;);
 302       IdealKit ideal(this);
 303       ideal.if_then(is_non_flattened_array(ary)); {
 304         // non-flattened
 305         assert(ideal.ctrl()-&gt;in(0)-&gt;as_If()-&gt;is_non_flattened_array_check(&amp;_gvn), &quot;Should be found&quot;);
 306         sync_kit(ideal);
 307         gen_inline_array_null_guard(ary, cast_val, 3);
 308         inc_sp(3);
 309         access_store_at(ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);
 310         dec_sp(3);
 311         ideal.sync_kit(this);
 312       } ideal.else_(); {
 313         Node* val = cast_val;
 314         // flattened
 315         if (!val-&gt;is_InlineType() &amp;&amp; tval-&gt;maybe_null()) {
 316           // Add null check
 317           sync_kit(ideal);
 318           Node* null_ctl = top();
 319           val = null_check_oop(val, &amp;null_ctl);
 320           if (null_ctl != top()) {
 321             PreserveJVMState pjvms(this);
 322             inc_sp(3);
 323             set_control(null_ctl);
 324             uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);
 325             dec_sp(3);
 326           }
 327           ideal.sync_kit(this);
 328         }
 329         // Try to determine the inline klass
 330         ciInlineKlass* vk = NULL;
 331         if (tval-&gt;isa_inlinetype() || tval-&gt;is_inlinetypeptr()) {
 332           vk = tval-&gt;inline_klass();
 333         } else if (tval_init-&gt;isa_inlinetype() || tval_init-&gt;is_inlinetypeptr()) {
 334           vk = tval_init-&gt;inline_klass();
 335         } else if (elemtype-&gt;is_inlinetypeptr()) {
 336           vk = elemtype-&gt;inline_klass();
 337         }
 338         Node* casted_ary = ary;
 339         if (vk != NULL &amp;&amp; !stopped()) {
 340           // Element type is known, cast and store to flattened representation
 341           sync_kit(ideal);
 342           assert(vk-&gt;flatten_array() &amp;&amp; elemtype-&gt;maybe_null(), &quot;never/always flat - should be optimized&quot;);
 343           ciArrayKlass* array_klass = ciArrayKlass::make(vk);
 344           const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
 345           casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));
 346           Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype-&gt;size(), control());
 347           if (!val-&gt;is_InlineType()) {
 348             assert(!gvn().type(val)-&gt;maybe_null(), &quot;inline type array elements should never be null&quot;);
 349             val = InlineTypeNode::make_from_oop(this, val, vk);
 350           }
 351           // Re-execute flattened array store if buffering triggers deoptimization
 352           PreserveReexecuteState preexecs(this);
 353           inc_sp(3);
 354           jvms()-&gt;set_should_reexecute(true);
 355           val-&gt;as_InlineType()-&gt;store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 356           ideal.sync_kit(this);
 357         } else if (!ideal.ctrl()-&gt;is_top()) {
 358           // Element type is unknown, emit runtime call
 359           sync_kit(ideal);
 360 
 361           // This membar keeps this access to an unknown flattened
 362           // array correctly ordered with other unknown and known
 363           // flattened array accesses.
 364           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::INLINES));
 365           ideal.sync_kit(this);
 366 
 367           ideal.make_leaf_call(OptoRuntime::store_unknown_inline_type(),
 368                                CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline),
 369                                &quot;store_unknown_inline&quot;,
 370                                val, casted_ary, idx);
 371 
 372           sync_kit(ideal);
 373           // Same as MemBarCPUOrder above: keep this unknown
 374           // flattened array access correctly ordered with other
 375           // flattened array accesses.
 376           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::INLINES));
 377           ideal.sync_kit(this);
 378         }
 379       }
 380       ideal.end_if();
 381       sync_kit(ideal);
 382       return;
 383     } else if (!ary_t-&gt;is_not_null_free()) {
 384       // Array is not flattened but may be null free
<a name="4" id="anc4"></a><span class="line-modified"> 385       assert(elemtype-&gt;is_oopptr()-&gt;can_be_inline_type() &amp;&amp; !ary_t-&gt;klass_is_exact(), &quot;array can&#39;t be null-free&quot;);</span>
 386       ary = gen_inline_array_null_guard(ary, cast_val, 3, true);
 387     }
 388   }
 389   inc_sp(3);
 390   access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 391   dec_sp(3);
 392 }
 393 
 394 
 395 //------------------------------array_addressing-------------------------------
 396 // Pull array and index from the stack.  Compute pointer-to-element.
 397 Node* Parse::array_addressing(BasicType type, int vals, const Type*&amp; elemtype) {
 398   Node *idx   = peek(0+vals);   // Get from stack without popping
 399   Node *ary   = peek(1+vals);   // in case of exception
 400 
 401   // Null check the array base, with correct stack contents
 402   ary = null_check(ary, T_ARRAY);
 403   // Compile-time detect of null-exception?
 404   if (stopped())  return top();
 405 
 406   const TypeAryPtr* arytype  = _gvn.type(ary)-&gt;is_aryptr();
 407   const TypeInt*    sizetype = arytype-&gt;size();
 408   elemtype = arytype-&gt;elem();
 409 
 410   if (UseUniqueSubclasses) {
 411     const Type* el = elemtype-&gt;make_ptr();
 412     if (el &amp;&amp; el-&gt;isa_instptr()) {
 413       const TypeInstPtr* toop = el-&gt;is_instptr();
 414       if (toop-&gt;klass()-&gt;as_instance_klass()-&gt;unique_concrete_subklass()) {
 415         // If we load from &quot;AbstractClass[]&quot; we must see &quot;ConcreteSubClass&quot;.
 416         const Type* subklass = Type::get_const_type(toop-&gt;klass());
 417         elemtype = subklass-&gt;join_speculative(el);
 418       }
 419     }
 420   }
 421 
 422   // Check for big class initializers with all constant offsets
 423   // feeding into a known-size array.
 424   const TypeInt* idxtype = _gvn.type(idx)-&gt;is_int();
 425   // See if the highest idx value is less than the lowest array bound,
 426   // and if the idx value cannot be negative:
 427   bool need_range_check = true;
 428   if (idxtype-&gt;_hi &lt; sizetype-&gt;_lo &amp;&amp; idxtype-&gt;_lo &gt;= 0) {
 429     need_range_check = false;
 430     if (C-&gt;log() != NULL)   C-&gt;log()-&gt;elem(&quot;observe that=&#39;!need_range_check&#39;&quot;);
 431   }
 432 
 433   ciKlass * arytype_klass = arytype-&gt;klass();
 434   if ((arytype_klass != NULL) &amp;&amp; (!arytype_klass-&gt;is_loaded())) {
 435     // Only fails for some -Xcomp runs
 436     // The class is unloaded.  We have to run this bytecode in the interpreter.
 437     uncommon_trap(Deoptimization::Reason_unloaded,
 438                   Deoptimization::Action_reinterpret,
 439                   arytype-&gt;klass(), &quot;!loaded array&quot;);
 440     return top();
 441   }
 442 
 443   // Do the range check
 444   if (GenerateRangeChecks &amp;&amp; need_range_check) {
 445     Node* tst;
 446     if (sizetype-&gt;_hi &lt;= 0) {
 447       // The greatest array bound is negative, so we can conclude that we&#39;re
 448       // compiling unreachable code, but the unsigned compare trick used below
 449       // only works with non-negative lengths.  Instead, hack &quot;tst&quot; to be zero so
 450       // the uncommon_trap path will always be taken.
 451       tst = _gvn.intcon(0);
 452     } else {
 453       // Range is constant in array-oop, so we can use the original state of mem
 454       Node* len = load_array_length(ary);
 455 
 456       // Test length vs index (standard trick using unsigned compare)
 457       Node* chk = _gvn.transform( new CmpUNode(idx, len) );
 458       BoolTest::mask btest = BoolTest::lt;
 459       tst = _gvn.transform( new BoolNode(chk, btest) );
 460     }
 461     RangeCheckNode* rc = new RangeCheckNode(control(), tst, PROB_MAX, COUNT_UNKNOWN);
 462     _gvn.set_type(rc, rc-&gt;Value(&amp;_gvn));
 463     if (!tst-&gt;is_Con()) {
 464       record_for_igvn(rc);
 465     }
 466     set_control(_gvn.transform(new IfTrueNode(rc)));
 467     // Branch to failure if out of bounds
 468     {
 469       PreserveJVMState pjvms(this);
 470       set_control(_gvn.transform(new IfFalseNode(rc)));
 471       if (C-&gt;allow_range_check_smearing()) {
 472         // Do not use builtin_throw, since range checks are sometimes
 473         // made more stringent by an optimistic transformation.
 474         // This creates &quot;tentative&quot; range checks at this point,
 475         // which are not guaranteed to throw exceptions.
 476         // See IfNode::Ideal, is_range_check, adjust_check.
 477         uncommon_trap(Deoptimization::Reason_range_check,
 478                       Deoptimization::Action_make_not_entrant,
 479                       NULL, &quot;range_check&quot;);
 480       } else {
 481         // If we have already recompiled with the range-check-widening
 482         // heroic optimization turned off, then we must really be throwing
 483         // range check exceptions.
 484         builtin_throw(Deoptimization::Reason_range_check, idx);
 485       }
 486     }
 487   }
 488   // Check for always knowing you are throwing a range-check exception
 489   if (stopped())  return top();
 490 
 491   // This could be an access to an inline type array. We can&#39;t tell if it&#39;s
 492   // flat or not. Speculating it&#39;s not leads to a much simpler graph
 493   // shape. Check profiling.
 494   // For aastore, by the time we&#39;re here, the array store check should
 495   // have already taken advantage of profiling to cast the array to an
 496   // exact type reported by profiling
 497   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
 498   if (elemtype-&gt;isa_inlinetype() == NULL &amp;&amp;
 499       (elemptr == NULL || !elemptr-&gt;is_inlinetypeptr() || elemptr-&gt;maybe_null()) &amp;&amp;
 500       !arytype-&gt;is_not_flat()) {
 501     assert(is_reference_type(type), &quot;Only references&quot;);
 502     // First check the speculative type
 503     Deoptimization::DeoptReason reason = Deoptimization::Reason_speculate_class_check;
 504     ciKlass* array_type = arytype-&gt;speculative_type();
 505     if (too_many_traps_or_recompiles(reason) || array_type == NULL) {
 506       // No speculative type, check profile data at this bci
 507       array_type = NULL;
 508       reason = Deoptimization::Reason_class_check;
 509       if (UseArrayLoadStoreProfile &amp;&amp; !too_many_traps_or_recompiles(reason)) {
 510         ciKlass* element_type = NULL;
 511         ProfilePtrKind element_ptr = ProfileMaybeNull;
 512         bool flat_array = true;
 513         bool null_free_array = true;
 514         method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 515       }
 516     }
 517     if (array_type != NULL) {
 518       // Speculate that this array has the exact type reported by profile data
 519       Node* better_ary = NULL;
 520       Node* slow_ctl = type_check_receiver(ary, array_type, 1.0, &amp;better_ary);
 521       { PreserveJVMState pjvms(this);
 522         set_control(slow_ctl);
 523         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 524       }
 525       replace_in_map(ary, better_ary);
 526       ary = better_ary;
 527       arytype  = _gvn.type(ary)-&gt;is_aryptr();
 528       elemtype = arytype-&gt;elem();
 529     }
 530   } else if (UseTypeSpeculation &amp;&amp; UseArrayLoadStoreProfile) {
 531     // No need to speculate: feed profile data at this bci for the
 532     // array to type speculation
 533     ciKlass* array_type = NULL;
 534     ciKlass* element_type = NULL;
 535     ProfilePtrKind element_ptr = ProfileMaybeNull;
 536     bool flat_array = true;
 537     bool null_free_array = true;
 538     method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 539     if (array_type != NULL) {
 540       record_profile_for_speculation(ary, array_type, ProfileMaybeNull);
 541     }
 542   }
 543 
 544   // We have no exact array type from profile data. Check profile data
 545   // for a non null free or non flat array. Non null free implies non
 546   // flat so check this one first. Speculating on a non null free
 547   // array doesn&#39;t help aaload but could be profitable for a
 548   // subsequent aastore.
 549   elemptr = elemtype-&gt;make_oopptr();
 550   if (!arytype-&gt;is_not_null_free() &amp;&amp;
 551       elemtype-&gt;isa_inlinetype() == NULL &amp;&amp;
 552       (elemptr == NULL || !elemptr-&gt;is_inlinetypeptr()) &amp;&amp;
 553       UseArrayLoadStoreProfile) {
 554     assert(is_reference_type(type), &quot;&quot;);
 555     bool null_free_array = true;
 556     Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
 557     if (arytype-&gt;speculative() != NULL &amp;&amp;
 558         arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_null_free() &amp;&amp;
 559         !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {
 560       null_free_array = false;
 561       reason = Deoptimization::Reason_speculate_class_check;
 562     } else if (!too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {
 563       ciKlass* array_type = NULL;
 564       ciKlass* element_type = NULL;
 565       ProfilePtrKind element_ptr = ProfileMaybeNull;
 566       bool flat_array = true;
 567       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 568       reason = Deoptimization::Reason_class_check;
 569     }
 570     if (!null_free_array) {
 571       { // Deoptimize if null-free array
 572         BuildCutout unless(this, is_nullable_array(ary), PROB_MAX);
 573         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 574       }
 575       Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype-&gt;cast_to_not_null_free()));
 576       replace_in_map(ary, better_ary);
 577       ary = better_ary;
 578       arytype = _gvn.type(ary)-&gt;is_aryptr();
 579     }
 580   }
 581 
 582   if (!arytype-&gt;is_not_flat() &amp;&amp; elemtype-&gt;isa_inlinetype() == NULL) {
 583     assert(is_reference_type(type), &quot;&quot;);
 584     bool flat_array = true;
 585     Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
 586     if (arytype-&gt;speculative() != NULL &amp;&amp;
 587         arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_flat() &amp;&amp;
 588         !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {
 589       flat_array = false;
 590       reason = Deoptimization::Reason_speculate_class_check;
 591     } else if (UseArrayLoadStoreProfile &amp;&amp; !too_many_traps_or_recompiles(reason)) {
 592       ciKlass* array_type = NULL;
 593       ciKlass* element_type = NULL;
 594       ProfilePtrKind element_ptr = ProfileMaybeNull;
 595       bool null_free_array = true;
 596       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 597       reason = Deoptimization::Reason_class_check;
 598     }
 599     if (!flat_array) {
 600       { // Deoptimize if flat array
 601         BuildCutout unless(this, is_non_flattened_array(ary), PROB_MAX);
 602         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 603       }
 604       Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype-&gt;cast_to_not_flat()));
 605       replace_in_map(ary, better_ary);
 606       ary = better_ary;
 607       arytype = _gvn.type(ary)-&gt;is_aryptr();
 608     }
 609   }
 610 
 611   // Make array address computation control dependent to prevent it
 612   // from floating above the range check during loop optimizations.
 613   Node* ptr = array_element_address(ary, idx, type, sizetype, control());
 614   assert(ptr != top(), &quot;top should go hand-in-hand with stopped&quot;);
 615 
 616   return ptr;
 617 }
 618 
 619 
 620 // returns IfNode
 621 IfNode* Parse::jump_if_fork_int(Node* a, Node* b, BoolTest::mask mask, float prob, float cnt) {
 622   Node   *cmp = _gvn.transform(new CmpINode(a, b)); // two cases: shiftcount &gt; 32 and shiftcount &lt;= 32
 623   Node   *tst = _gvn.transform(new BoolNode(cmp, mask));
 624   IfNode *iff = create_and_map_if(control(), tst, prob, cnt);
 625   return iff;
 626 }
 627 
 628 // return Region node
 629 Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {
 630   Node *region  = new RegionNode(3); // 2 results
 631   record_for_igvn(region);
 632   region-&gt;init_req(1, iffalse);
 633   region-&gt;init_req(2, iftrue );
 634   _gvn.set_type(region, Type::CONTROL);
 635   region = _gvn.transform(region);
 636   set_control (region);
 637   return region;
 638 }
 639 
 640 // sentinel value for the target bci to mark never taken branches
 641 // (according to profiling)
 642 static const int never_reached = INT_MAX;
 643 
 644 //------------------------------helper for tableswitch-------------------------
 645 void Parse::jump_if_true_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {
 646   // True branch, use existing map info
 647   { PreserveJVMState pjvms(this);
 648     Node *iftrue  = _gvn.transform( new IfTrueNode (iff) );
 649     set_control( iftrue );
 650     if (unc) {
 651       repush_if_args();
 652       uncommon_trap(Deoptimization::Reason_unstable_if,
 653                     Deoptimization::Action_reinterpret,
 654                     NULL,
 655                     &quot;taken always&quot;);
 656     } else {
 657       assert(dest_bci_if_true != never_reached, &quot;inconsistent dest&quot;);
 658       profile_switch_case(prof_table_index);
 659       merge_new_path(dest_bci_if_true);
 660     }
 661   }
 662 
 663   // False branch
 664   Node *iffalse = _gvn.transform( new IfFalseNode(iff) );
 665   set_control( iffalse );
 666 }
 667 
 668 void Parse::jump_if_false_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {
 669   // True branch, use existing map info
 670   { PreserveJVMState pjvms(this);
 671     Node *iffalse  = _gvn.transform( new IfFalseNode (iff) );
 672     set_control( iffalse );
 673     if (unc) {
 674       repush_if_args();
 675       uncommon_trap(Deoptimization::Reason_unstable_if,
 676                     Deoptimization::Action_reinterpret,
 677                     NULL,
 678                     &quot;taken never&quot;);
 679     } else {
 680       assert(dest_bci_if_true != never_reached, &quot;inconsistent dest&quot;);
 681       profile_switch_case(prof_table_index);
 682       merge_new_path(dest_bci_if_true);
 683     }
 684   }
 685 
 686   // False branch
 687   Node *iftrue = _gvn.transform( new IfTrueNode(iff) );
 688   set_control( iftrue );
 689 }
 690 
 691 void Parse::jump_if_always_fork(int dest_bci, int prof_table_index, bool unc) {
 692   // False branch, use existing map and control()
 693   if (unc) {
 694     repush_if_args();
 695     uncommon_trap(Deoptimization::Reason_unstable_if,
 696                   Deoptimization::Action_reinterpret,
 697                   NULL,
 698                   &quot;taken never&quot;);
 699   } else {
 700     assert(dest_bci != never_reached, &quot;inconsistent dest&quot;);
 701     profile_switch_case(prof_table_index);
 702     merge_new_path(dest_bci);
 703   }
 704 }
 705 
 706 
 707 extern &quot;C&quot; {
 708   static int jint_cmp(const void *i, const void *j) {
 709     int a = *(jint *)i;
 710     int b = *(jint *)j;
 711     return a &gt; b ? 1 : a &lt; b ? -1 : 0;
 712   }
 713 }
 714 
 715 
 716 // Default value for methodData switch indexing. Must be a negative value to avoid
 717 // conflict with any legal switch index.
 718 #define NullTableIndex -1
 719 
 720 class SwitchRange : public StackObj {
 721   // a range of integers coupled with a bci destination
 722   jint _lo;                     // inclusive lower limit
 723   jint _hi;                     // inclusive upper limit
 724   int _dest;
 725   int _table_index;             // index into method data table
 726   float _cnt;                   // how many times this range was hit according to profiling
 727 
 728 public:
 729   jint lo() const              { return _lo;   }
 730   jint hi() const              { return _hi;   }
 731   int  dest() const            { return _dest; }
 732   int  table_index() const     { return _table_index; }
 733   bool is_singleton() const    { return _lo == _hi; }
 734   float cnt() const            { return _cnt; }
 735 
 736   void setRange(jint lo, jint hi, int dest, int table_index, float cnt) {
 737     assert(lo &lt;= hi, &quot;must be a non-empty range&quot;);
 738     _lo = lo, _hi = hi; _dest = dest; _table_index = table_index; _cnt = cnt;
 739     assert(_cnt &gt;= 0, &quot;&quot;);
 740   }
 741   bool adjoinRange(jint lo, jint hi, int dest, int table_index, float cnt, bool trim_ranges) {
 742     assert(lo &lt;= hi, &quot;must be a non-empty range&quot;);
 743     if (lo == _hi+1 &amp;&amp; table_index == _table_index) {
 744       // see merge_ranges() comment below
 745       if (trim_ranges) {
 746         if (cnt == 0) {
 747           if (_cnt != 0) {
 748             return false;
 749           }
 750           if (dest != _dest) {
 751             _dest = never_reached;
 752           }
 753         } else {
 754           if (_cnt == 0) {
 755             return false;
 756           }
 757           if (dest != _dest) {
 758             return false;
 759           }
 760         }
 761       } else {
 762         if (dest != _dest) {
 763           return false;
 764         }
 765       }
 766       _hi = hi;
 767       _cnt += cnt;
 768       return true;
 769     }
 770     return false;
 771   }
 772 
 773   void set (jint value, int dest, int table_index, float cnt) {
 774     setRange(value, value, dest, table_index, cnt);
 775   }
 776   bool adjoin(jint value, int dest, int table_index, float cnt, bool trim_ranges) {
 777     return adjoinRange(value, value, dest, table_index, cnt, trim_ranges);
 778   }
 779   bool adjoin(SwitchRange&amp; other) {
 780     return adjoinRange(other._lo, other._hi, other._dest, other._table_index, other._cnt, false);
 781   }
 782 
 783   void print() {
 784     if (is_singleton())
 785       tty-&gt;print(&quot; {%d}=&gt;%d (cnt=%f)&quot;, lo(), dest(), cnt());
 786     else if (lo() == min_jint)
 787       tty-&gt;print(&quot; {..%d}=&gt;%d (cnt=%f)&quot;, hi(), dest(), cnt());
 788     else if (hi() == max_jint)
 789       tty-&gt;print(&quot; {%d..}=&gt;%d (cnt=%f)&quot;, lo(), dest(), cnt());
 790     else
 791       tty-&gt;print(&quot; {%d..%d}=&gt;%d (cnt=%f)&quot;, lo(), hi(), dest(), cnt());
 792   }
 793 };
 794 
 795 // We try to minimize the number of ranges and the size of the taken
 796 // ones using profiling data. When ranges are created,
 797 // SwitchRange::adjoinRange() only allows 2 adjoining ranges to merge
 798 // if both were never hit or both were hit to build longer unreached
 799 // ranges. Here, we now merge adjoining ranges with the same
 800 // destination and finally set destination of unreached ranges to the
 801 // special value never_reached because it can help minimize the number
 802 // of tests that are necessary.
 803 //
 804 // For instance:
 805 // [0, 1] to target1 sometimes taken
 806 // [1, 2] to target1 never taken
 807 // [2, 3] to target2 never taken
 808 // would lead to:
 809 // [0, 1] to target1 sometimes taken
 810 // [1, 3] never taken
 811 //
 812 // (first 2 ranges to target1 are not merged)
 813 static void merge_ranges(SwitchRange* ranges, int&amp; rp) {
 814   if (rp == 0) {
 815     return;
 816   }
 817   int shift = 0;
 818   for (int j = 0; j &lt; rp; j++) {
 819     SwitchRange&amp; r1 = ranges[j-shift];
 820     SwitchRange&amp; r2 = ranges[j+1];
 821     if (r1.adjoin(r2)) {
 822       shift++;
 823     } else if (shift &gt; 0) {
 824       ranges[j+1-shift] = r2;
 825     }
 826   }
 827   rp -= shift;
 828   for (int j = 0; j &lt;= rp; j++) {
 829     SwitchRange&amp; r = ranges[j];
 830     if (r.cnt() == 0 &amp;&amp; r.dest() != never_reached) {
 831       r.setRange(r.lo(), r.hi(), never_reached, r.table_index(), r.cnt());
 832     }
 833   }
 834 }
 835 
 836 //-------------------------------do_tableswitch--------------------------------
 837 void Parse::do_tableswitch() {
 838   Node* lookup = pop();
 839   // Get information about tableswitch
 840   int default_dest = iter().get_dest_table(0);
 841   int lo_index     = iter().get_int_table(1);
 842   int hi_index     = iter().get_int_table(2);
 843   int len          = hi_index - lo_index + 1;
 844 
 845   if (len &lt; 1) {
 846     // If this is a backward branch, add safepoint
 847     maybe_add_safepoint(default_dest);
 848     merge(default_dest);
 849     return;
 850   }
 851 
 852   ciMethodData* methodData = method()-&gt;method_data();
 853   ciMultiBranchData* profile = NULL;
 854   if (methodData-&gt;is_mature() &amp;&amp; UseSwitchProfiling) {
 855     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 856     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 857       profile = (ciMultiBranchData*)data;
 858     }
 859   }
 860   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 861 
 862   // generate decision tree, using trichotomy when possible
 863   int rnum = len+2;
 864   bool makes_backward_branch = false;
 865   SwitchRange* ranges = NEW_RESOURCE_ARRAY(SwitchRange, rnum);
 866   int rp = -1;
 867   if (lo_index != min_jint) {
 868     uint cnt = 1;
 869     if (profile != NULL) {
 870       cnt = profile-&gt;default_count() / (hi_index != max_jint ? 2 : 1);
 871     }
 872     ranges[++rp].setRange(min_jint, lo_index-1, default_dest, NullTableIndex, cnt);
 873   }
 874   for (int j = 0; j &lt; len; j++) {
 875     jint match_int = lo_index+j;
 876     int  dest      = iter().get_dest_table(j+3);
 877     makes_backward_branch |= (dest &lt;= bci());
 878     int  table_index = method_data_update() ? j : NullTableIndex;
 879     uint cnt = 1;
 880     if (profile != NULL) {
 881       cnt = profile-&gt;count_at(j);
 882     }
 883     if (rp &lt; 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {
 884       ranges[++rp].set(match_int, dest, table_index, cnt);
 885     }
 886   }
 887   jint highest = lo_index+(len-1);
 888   assert(ranges[rp].hi() == highest, &quot;&quot;);
 889   if (highest != max_jint) {
 890     uint cnt = 1;
 891     if (profile != NULL) {
 892       cnt = profile-&gt;default_count() / (lo_index != min_jint ? 2 : 1);
 893     }
 894     if (!ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, cnt, trim_ranges)) {
 895       ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, cnt);
 896     }
 897   }
 898   assert(rp &lt; len+2, &quot;not too many ranges&quot;);
 899 
 900   if (trim_ranges) {
 901     merge_ranges(ranges, rp);
 902   }
 903 
 904   // Safepoint in case if backward branch observed
 905   if( makes_backward_branch &amp;&amp; UseLoopSafepoints )
 906     add_safepoint();
 907 
 908   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
 909 }
 910 
 911 
 912 //------------------------------do_lookupswitch--------------------------------
 913 void Parse::do_lookupswitch() {
 914   Node *lookup = pop();         // lookup value
 915   // Get information about lookupswitch
 916   int default_dest = iter().get_dest_table(0);
 917   int len          = iter().get_int_table(1);
 918 
 919   if (len &lt; 1) {    // If this is a backward branch, add safepoint
 920     maybe_add_safepoint(default_dest);
 921     merge(default_dest);
 922     return;
 923   }
 924 
 925   ciMethodData* methodData = method()-&gt;method_data();
 926   ciMultiBranchData* profile = NULL;
 927   if (methodData-&gt;is_mature() &amp;&amp; UseSwitchProfiling) {
 928     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 929     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 930       profile = (ciMultiBranchData*)data;
 931     }
 932   }
 933   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 934 
 935   // generate decision tree, using trichotomy when possible
 936   jint* table = NEW_RESOURCE_ARRAY(jint, len*3);
 937   {
 938     for (int j = 0; j &lt; len; j++) {
 939       table[3*j+0] = iter().get_int_table(2+2*j);
 940       table[3*j+1] = iter().get_dest_table(2+2*j+1);
 941       table[3*j+2] = profile == NULL ? 1 : profile-&gt;count_at(j);
 942     }
 943     qsort(table, len, 3*sizeof(table[0]), jint_cmp);
 944   }
 945 
 946   float defaults = 0;
 947   jint prev = min_jint;
 948   for (int j = 0; j &lt; len; j++) {
 949     jint match_int = table[3*j+0];
 950     if (match_int != prev) {
 951       defaults += (float)match_int - prev;
 952     }
 953     prev = match_int+1;
 954   }
 955   if (prev-1 != max_jint) {
 956     defaults += (float)max_jint - prev + 1;
 957   }
 958   float default_cnt = 1;
 959   if (profile != NULL) {
 960     default_cnt = profile-&gt;default_count()/defaults;
 961   }
 962 
 963   int rnum = len*2+1;
 964   bool makes_backward_branch = false;
 965   SwitchRange* ranges = NEW_RESOURCE_ARRAY(SwitchRange, rnum);
 966   int rp = -1;
 967   for (int j = 0; j &lt; len; j++) {
 968     jint match_int   = table[3*j+0];
 969     int  dest        = table[3*j+1];
 970     int  cnt         = table[3*j+2];
 971     int  next_lo     = rp &lt; 0 ? min_jint : ranges[rp].hi()+1;
 972     int  table_index = method_data_update() ? j : NullTableIndex;
 973     makes_backward_branch |= (dest &lt;= bci());
 974     float c = default_cnt * ((float)match_int - next_lo);
 975     if (match_int != next_lo &amp;&amp; (rp &lt; 0 || !ranges[rp].adjoinRange(next_lo, match_int-1, default_dest, NullTableIndex, c, trim_ranges))) {
 976       assert(default_dest != never_reached, &quot;sentinel value for dead destinations&quot;);
 977       ranges[++rp].setRange(next_lo, match_int-1, default_dest, NullTableIndex, c);
 978     }
 979     if (rp &lt; 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {
 980       assert(dest != never_reached, &quot;sentinel value for dead destinations&quot;);
 981       ranges[++rp].set(match_int, dest, table_index, cnt);
 982     }
 983   }
 984   jint highest = table[3*(len-1)];
 985   assert(ranges[rp].hi() == highest, &quot;&quot;);
 986   if (highest != max_jint &amp;&amp;
 987       !ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest), trim_ranges)) {
 988     ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest));
 989   }
 990   assert(rp &lt; rnum, &quot;not too many ranges&quot;);
 991 
 992   if (trim_ranges) {
 993     merge_ranges(ranges, rp);
 994   }
 995 
 996   // Safepoint in case backward branch observed
 997   if (makes_backward_branch &amp;&amp; UseLoopSafepoints)
 998     add_safepoint();
 999 
1000   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
1001 }
1002 
1003 static float if_prob(float taken_cnt, float total_cnt) {
1004   assert(taken_cnt &lt;= total_cnt, &quot;&quot;);
1005   if (total_cnt == 0) {
1006     return PROB_FAIR;
1007   }
1008   float p = taken_cnt / total_cnt;
1009   return clamp(p, PROB_MIN, PROB_MAX);
1010 }
1011 
1012 static float if_cnt(float cnt) {
1013   if (cnt == 0) {
1014     return COUNT_UNKNOWN;
1015   }
1016   return cnt;
1017 }
1018 
1019 static float sum_of_cnts(SwitchRange *lo, SwitchRange *hi) {
1020   float total_cnt = 0;
1021   for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
1022     total_cnt += sr-&gt;cnt();
1023   }
1024   return total_cnt;
1025 }
1026 
1027 class SwitchRanges : public ResourceObj {
1028 public:
1029   SwitchRange* _lo;
1030   SwitchRange* _hi;
1031   SwitchRange* _mid;
1032   float _cost;
1033 
1034   enum {
1035     Start,
1036     LeftDone,
1037     RightDone,
1038     Done
1039   } _state;
1040 
1041   SwitchRanges(SwitchRange *lo, SwitchRange *hi)
1042     : _lo(lo), _hi(hi), _mid(NULL),
1043       _cost(0), _state(Start) {
1044   }
1045 
1046   SwitchRanges()
1047     : _lo(NULL), _hi(NULL), _mid(NULL),
1048       _cost(0), _state(Start) {}
1049 };
1050 
1051 // Estimate cost of performing a binary search on lo..hi
1052 static float compute_tree_cost(SwitchRange *lo, SwitchRange *hi, float total_cnt) {
1053   GrowableArray&lt;SwitchRanges&gt; tree;
1054   SwitchRanges root(lo, hi);
1055   tree.push(root);
1056 
1057   float cost = 0;
1058   do {
1059     SwitchRanges&amp; r = *tree.adr_at(tree.length()-1);
1060     if (r._hi != r._lo) {
1061       if (r._mid == NULL) {
1062         float r_cnt = sum_of_cnts(r._lo, r._hi);
1063 
1064         if (r_cnt == 0) {
1065           tree.pop();
1066           cost = 0;
1067           continue;
1068         }
1069 
1070         SwitchRange* mid = NULL;
1071         mid = r._lo;
1072         for (float cnt = 0; ; ) {
1073           assert(mid &lt;= r._hi, &quot;out of bounds&quot;);
1074           cnt += mid-&gt;cnt();
1075           if (cnt &gt; r_cnt / 2) {
1076             break;
1077           }
1078           mid++;
1079         }
1080         assert(mid &lt;= r._hi, &quot;out of bounds&quot;);
1081         r._mid = mid;
1082         r._cost = r_cnt / total_cnt;
1083       }
1084       r._cost += cost;
1085       if (r._state &lt; SwitchRanges::LeftDone &amp;&amp; r._mid &gt; r._lo) {
1086         cost = 0;
1087         r._state = SwitchRanges::LeftDone;
1088         tree.push(SwitchRanges(r._lo, r._mid-1));
1089       } else if (r._state &lt; SwitchRanges::RightDone) {
1090         cost = 0;
1091         r._state = SwitchRanges::RightDone;
1092         tree.push(SwitchRanges(r._mid == r._lo ? r._mid+1 : r._mid, r._hi));
1093       } else {
1094         tree.pop();
1095         cost = r._cost;
1096       }
1097     } else {
1098       tree.pop();
1099       cost = r._cost;
1100     }
1101   } while (tree.length() &gt; 0);
1102 
1103 
1104   return cost;
1105 }
1106 
1107 // It sometimes pays off to test most common ranges before the binary search
1108 void Parse::linear_search_switch_ranges(Node* key_val, SwitchRange*&amp; lo, SwitchRange*&amp; hi) {
1109   uint nr = hi - lo + 1;
1110   float total_cnt = sum_of_cnts(lo, hi);
1111 
1112   float min = compute_tree_cost(lo, hi, total_cnt);
1113   float extra = 1;
1114   float sub = 0;
1115 
1116   SwitchRange* array1 = lo;
1117   SwitchRange* array2 = NEW_RESOURCE_ARRAY(SwitchRange, nr);
1118 
1119   SwitchRange* ranges = NULL;
1120 
1121   while (nr &gt;= 2) {
1122     assert(lo == array1 || lo == array2, &quot;one the 2 already allocated arrays&quot;);
1123     ranges = (lo == array1) ? array2 : array1;
1124 
1125     // Find highest frequency range
1126     SwitchRange* candidate = lo;
1127     for (SwitchRange* sr = lo+1; sr &lt;= hi; sr++) {
1128       if (sr-&gt;cnt() &gt; candidate-&gt;cnt()) {
1129         candidate = sr;
1130       }
1131     }
1132     SwitchRange most_freq = *candidate;
1133     if (most_freq.cnt() == 0) {
1134       break;
1135     }
1136 
1137     // Copy remaining ranges into another array
1138     int shift = 0;
1139     for (uint i = 0; i &lt; nr; i++) {
1140       SwitchRange* sr = &amp;lo[i];
1141       if (sr != candidate) {
1142         ranges[i-shift] = *sr;
1143       } else {
1144         shift++;
1145         if (i &gt; 0 &amp;&amp; i &lt; nr-1) {
1146           SwitchRange prev = lo[i-1];
1147           prev.setRange(prev.lo(), sr-&gt;hi(), prev.dest(), prev.table_index(), prev.cnt());
1148           if (prev.adjoin(lo[i+1])) {
1149             shift++;
1150             i++;
1151           }
1152           ranges[i-shift] = prev;
1153         }
1154       }
1155     }
1156     nr -= shift;
1157 
1158     // Evaluate cost of testing the most common range and performing a
1159     // binary search on the other ranges
1160     float cost = extra + compute_tree_cost(&amp;ranges[0], &amp;ranges[nr-1], total_cnt);
1161     if (cost &gt;= min) {
1162       break;
1163     }
1164     // swap arrays
1165     lo = &amp;ranges[0];
1166     hi = &amp;ranges[nr-1];
1167 
1168     // It pays off: emit the test for the most common range
1169     assert(most_freq.cnt() &gt; 0, &quot;must be taken&quot;);
1170     Node* val = _gvn.transform(new SubINode(key_val, _gvn.intcon(most_freq.lo())));
1171     Node* cmp = _gvn.transform(new CmpUNode(val, _gvn.intcon(most_freq.hi() - most_freq.lo())));
1172     Node* tst = _gvn.transform(new BoolNode(cmp, BoolTest::le));
1173     IfNode* iff = create_and_map_if(control(), tst, if_prob(most_freq.cnt(), total_cnt), if_cnt(most_freq.cnt()));
1174     jump_if_true_fork(iff, most_freq.dest(), most_freq.table_index(), false);
1175 
1176     sub += most_freq.cnt() / total_cnt;
1177     extra += 1 - sub;
1178     min = cost;
1179   }
1180 }
1181 
1182 //----------------------------create_jump_tables-------------------------------
1183 bool Parse::create_jump_tables(Node* key_val, SwitchRange* lo, SwitchRange* hi) {
1184   // Are jumptables enabled
1185   if (!UseJumpTables)  return false;
1186 
1187   // Are jumptables supported
1188   if (!Matcher::has_match_rule(Op_Jump))  return false;
1189 
1190   // Don&#39;t make jump table if profiling
1191   if (method_data_update())  return false;
1192 
1193   bool trim_ranges = !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
1194 
1195   // Decide if a guard is needed to lop off big ranges at either (or
1196   // both) end(s) of the input set. We&#39;ll call this the default target
1197   // even though we can&#39;t be sure that it is the true &quot;default&quot;.
1198 
1199   bool needs_guard = false;
1200   int default_dest;
1201   int64_t total_outlier_size = 0;
1202   int64_t hi_size = ((int64_t)hi-&gt;hi()) - ((int64_t)hi-&gt;lo()) + 1;
1203   int64_t lo_size = ((int64_t)lo-&gt;hi()) - ((int64_t)lo-&gt;lo()) + 1;
1204 
1205   if (lo-&gt;dest() == hi-&gt;dest()) {
1206     total_outlier_size = hi_size + lo_size;
1207     default_dest = lo-&gt;dest();
1208   } else if (lo_size &gt; hi_size) {
1209     total_outlier_size = lo_size;
1210     default_dest = lo-&gt;dest();
1211   } else {
1212     total_outlier_size = hi_size;
1213     default_dest = hi-&gt;dest();
1214   }
1215 
1216   float total = sum_of_cnts(lo, hi);
1217   float cost = compute_tree_cost(lo, hi, total);
1218 
1219   // If a guard test will eliminate very sparse end ranges, then
1220   // it is worth the cost of an extra jump.
1221   float trimmed_cnt = 0;
1222   if (total_outlier_size &gt; (MaxJumpTableSparseness * 4)) {
1223     needs_guard = true;
1224     if (default_dest == lo-&gt;dest()) {
1225       trimmed_cnt += lo-&gt;cnt();
1226       lo++;
1227     }
1228     if (default_dest == hi-&gt;dest()) {
1229       trimmed_cnt += hi-&gt;cnt();
1230       hi--;
1231     }
1232   }
1233 
1234   // Find the total number of cases and ranges
1235   int64_t num_cases = ((int64_t)hi-&gt;hi()) - ((int64_t)lo-&gt;lo()) + 1;
1236   int num_range = hi - lo + 1;
1237 
1238   // Don&#39;t create table if: too large, too small, or too sparse.
1239   if (num_cases &gt; MaxJumpTableSize)
1240     return false;
1241   if (UseSwitchProfiling) {
1242     // MinJumpTableSize is set so with a well balanced binary tree,
1243     // when the number of ranges is MinJumpTableSize, it&#39;s cheaper to
1244     // go through a JumpNode that a tree of IfNodes. Average cost of a
1245     // tree of IfNodes with MinJumpTableSize is
1246     // log2f(MinJumpTableSize) comparisons. So if the cost computed
1247     // from profile data is less than log2f(MinJumpTableSize) then
1248     // going with the binary search is cheaper.
1249     if (cost &lt; log2f(MinJumpTableSize)) {
1250       return false;
1251     }
1252   } else {
1253     if (num_cases &lt; MinJumpTableSize)
1254       return false;
1255   }
1256   if (num_cases &gt; (MaxJumpTableSparseness * num_range))
1257     return false;
1258 
1259   // Normalize table lookups to zero
1260   int lowval = lo-&gt;lo();
1261   key_val = _gvn.transform( new SubINode(key_val, _gvn.intcon(lowval)) );
1262 
1263   // Generate a guard to protect against input keyvals that aren&#39;t
1264   // in the switch domain.
1265   if (needs_guard) {
1266     Node*   size = _gvn.intcon(num_cases);
1267     Node*   cmp = _gvn.transform(new CmpUNode(key_val, size));
1268     Node*   tst = _gvn.transform(new BoolNode(cmp, BoolTest::ge));
1269     IfNode* iff = create_and_map_if(control(), tst, if_prob(trimmed_cnt, total), if_cnt(trimmed_cnt));
1270     jump_if_true_fork(iff, default_dest, NullTableIndex, trim_ranges &amp;&amp; trimmed_cnt == 0);
1271 
1272     total -= trimmed_cnt;
1273   }
1274 
1275   // Create an ideal node JumpTable that has projections
1276   // of all possible ranges for a switch statement
1277   // The key_val input must be converted to a pointer offset and scaled.
1278   // Compare Parse::array_addressing above.
1279 
1280   // Clean the 32-bit int into a real 64-bit offset.
1281   // Otherwise, the jint value 0 might turn into an offset of 0x0800000000.
1282   const TypeInt* ikeytype = TypeInt::make(0, num_cases, Type::WidenMin);
1283   // Make I2L conversion control dependent to prevent it from
1284   // floating above the range check during loop optimizations.
1285   key_val = C-&gt;conv_I2X_index(&amp;_gvn, key_val, ikeytype, control());
1286 
1287   // Shift the value by wordsize so we have an index into the table, rather
1288   // than a switch value
1289   Node *shiftWord = _gvn.MakeConX(wordSize);
1290   key_val = _gvn.transform( new MulXNode( key_val, shiftWord));
1291 
1292   // Create the JumpNode
1293   Arena* arena = C-&gt;comp_arena();
1294   float* probs = (float*)arena-&gt;Amalloc(sizeof(float)*num_cases);
1295   int i = 0;
1296   if (total == 0) {
1297     for (SwitchRange* r = lo; r &lt;= hi; r++) {
1298       for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1299         probs[i] = 1.0F / num_cases;
1300       }
1301     }
1302   } else {
1303     for (SwitchRange* r = lo; r &lt;= hi; r++) {
1304       float prob = r-&gt;cnt()/total;
1305       for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1306         probs[i] = prob / (r-&gt;hi() - r-&gt;lo() + 1);
1307       }
1308     }
1309   }
1310 
1311   ciMethodData* methodData = method()-&gt;method_data();
1312   ciMultiBranchData* profile = NULL;
1313   if (methodData-&gt;is_mature()) {
1314     ciProfileData* data = methodData-&gt;bci_to_data(bci());
1315     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
1316       profile = (ciMultiBranchData*)data;
1317     }
1318   }
1319 
1320   Node* jtn = _gvn.transform(new JumpNode(control(), key_val, num_cases, probs, profile == NULL ? COUNT_UNKNOWN : total));
1321 
1322   // These are the switch destinations hanging off the jumpnode
1323   i = 0;
1324   for (SwitchRange* r = lo; r &lt;= hi; r++) {
1325     for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1326       Node* input = _gvn.transform(new JumpProjNode(jtn, i, r-&gt;dest(), (int)(j - lowval)));
1327       {
1328         PreserveJVMState pjvms(this);
1329         set_control(input);
1330         jump_if_always_fork(r-&gt;dest(), r-&gt;table_index(), trim_ranges &amp;&amp; r-&gt;cnt() == 0);
1331       }
1332     }
1333   }
1334   assert(i == num_cases, &quot;miscount of cases&quot;);
1335   stop_and_kill_map();  // no more uses for this JVMS
1336   return true;
1337 }
1338 
1339 //----------------------------jump_switch_ranges-------------------------------
1340 void Parse::jump_switch_ranges(Node* key_val, SwitchRange *lo, SwitchRange *hi, int switch_depth) {
1341   Block* switch_block = block();
1342   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
1343 
1344   if (switch_depth == 0) {
1345     // Do special processing for the top-level call.
1346     assert(lo-&gt;lo() == min_jint, &quot;initial range must exhaust Type::INT&quot;);
1347     assert(hi-&gt;hi() == max_jint, &quot;initial range must exhaust Type::INT&quot;);
1348 
1349     // Decrement pred-numbers for the unique set of nodes.
1350 #ifdef ASSERT
1351     if (!trim_ranges) {
1352       // Ensure that the block&#39;s successors are a (duplicate-free) set.
1353       int successors_counted = 0;  // block occurrences in [hi..lo]
1354       int unique_successors = switch_block-&gt;num_successors();
1355       for (int i = 0; i &lt; unique_successors; i++) {
1356         Block* target = switch_block-&gt;successor_at(i);
1357 
1358         // Check that the set of successors is the same in both places.
1359         int successors_found = 0;
1360         for (SwitchRange* p = lo; p &lt;= hi; p++) {
1361           if (p-&gt;dest() == target-&gt;start())  successors_found++;
1362         }
1363         assert(successors_found &gt; 0, &quot;successor must be known&quot;);
1364         successors_counted += successors_found;
1365       }
1366       assert(successors_counted == (hi-lo)+1, &quot;no unexpected successors&quot;);
1367     }
1368 #endif
1369 
1370     // Maybe prune the inputs, based on the type of key_val.
1371     jint min_val = min_jint;
1372     jint max_val = max_jint;
1373     const TypeInt* ti = key_val-&gt;bottom_type()-&gt;isa_int();
1374     if (ti != NULL) {
1375       min_val = ti-&gt;_lo;
1376       max_val = ti-&gt;_hi;
1377       assert(min_val &lt;= max_val, &quot;invalid int type&quot;);
1378     }
1379     while (lo-&gt;hi() &lt; min_val) {
1380       lo++;
1381     }
1382     if (lo-&gt;lo() &lt; min_val)  {
1383       lo-&gt;setRange(min_val, lo-&gt;hi(), lo-&gt;dest(), lo-&gt;table_index(), lo-&gt;cnt());
1384     }
1385     while (hi-&gt;lo() &gt; max_val) {
1386       hi--;
1387     }
1388     if (hi-&gt;hi() &gt; max_val) {
1389       hi-&gt;setRange(hi-&gt;lo(), max_val, hi-&gt;dest(), hi-&gt;table_index(), hi-&gt;cnt());
1390     }
1391 
1392     linear_search_switch_ranges(key_val, lo, hi);
1393   }
1394 
1395 #ifndef PRODUCT
1396   if (switch_depth == 0) {
1397     _max_switch_depth = 0;
1398     _est_switch_depth = log2_intptr((hi-lo+1)-1)+1;
1399   }
1400 #endif
1401 
1402   assert(lo &lt;= hi, &quot;must be a non-empty set of ranges&quot;);
1403   if (lo == hi) {
1404     jump_if_always_fork(lo-&gt;dest(), lo-&gt;table_index(), trim_ranges &amp;&amp; lo-&gt;cnt() == 0);
1405   } else {
1406     assert(lo-&gt;hi() == (lo+1)-&gt;lo()-1, &quot;contiguous ranges&quot;);
1407     assert(hi-&gt;lo() == (hi-1)-&gt;hi()+1, &quot;contiguous ranges&quot;);
1408 
1409     if (create_jump_tables(key_val, lo, hi)) return;
1410 
1411     SwitchRange* mid = NULL;
1412     float total_cnt = sum_of_cnts(lo, hi);
1413 
1414     int nr = hi - lo + 1;
1415     if (UseSwitchProfiling) {
1416       // Don&#39;t keep the binary search tree balanced: pick up mid point
1417       // that split frequencies in half.
1418       float cnt = 0;
1419       for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
1420         cnt += sr-&gt;cnt();
1421         if (cnt &gt;= total_cnt / 2) {
1422           mid = sr;
1423           break;
1424         }
1425       }
1426     } else {
1427       mid = lo + nr/2;
1428 
1429       // if there is an easy choice, pivot at a singleton:
1430       if (nr &gt; 3 &amp;&amp; !mid-&gt;is_singleton() &amp;&amp; (mid-1)-&gt;is_singleton())  mid--;
1431 
1432       assert(lo &lt; mid &amp;&amp; mid &lt;= hi, &quot;good pivot choice&quot;);
1433       assert(nr != 2 || mid == hi,   &quot;should pick higher of 2&quot;);
1434       assert(nr != 3 || mid == hi-1, &quot;should pick middle of 3&quot;);
1435     }
1436 
1437 
1438     Node *test_val = _gvn.intcon(mid == lo ? mid-&gt;hi() : mid-&gt;lo());
1439 
1440     if (mid-&gt;is_singleton()) {
1441       IfNode *iff_ne = jump_if_fork_int(key_val, test_val, BoolTest::ne, 1-if_prob(mid-&gt;cnt(), total_cnt), if_cnt(mid-&gt;cnt()));
1442       jump_if_false_fork(iff_ne, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; mid-&gt;cnt() == 0);
1443 
1444       // Special Case:  If there are exactly three ranges, and the high
1445       // and low range each go to the same place, omit the &quot;gt&quot; test,
1446       // since it will not discriminate anything.
1447       bool eq_test_only = (hi == lo+2 &amp;&amp; hi-&gt;dest() == lo-&gt;dest() &amp;&amp; mid == hi-1) || mid == lo;
1448 
1449       // if there is a higher range, test for it and process it:
1450       if (mid &lt; hi &amp;&amp; !eq_test_only) {
1451         // two comparisons of same values--should enable 1 test for 2 branches
1452         // Use BoolTest::lt instead of BoolTest::gt
1453         float cnt = sum_of_cnts(lo, mid-1);
1454         IfNode *iff_lt  = jump_if_fork_int(key_val, test_val, BoolTest::lt, if_prob(cnt, total_cnt), if_cnt(cnt));
1455         Node   *iftrue  = _gvn.transform( new IfTrueNode(iff_lt) );
1456         Node   *iffalse = _gvn.transform( new IfFalseNode(iff_lt) );
1457         { PreserveJVMState pjvms(this);
1458           set_control(iffalse);
1459           jump_switch_ranges(key_val, mid+1, hi, switch_depth+1);
1460         }
1461         set_control(iftrue);
1462       }
1463 
1464     } else {
1465       // mid is a range, not a singleton, so treat mid..hi as a unit
1466       float cnt = sum_of_cnts(mid == lo ? mid+1 : mid, hi);
1467       IfNode *iff_ge = jump_if_fork_int(key_val, test_val, mid == lo ? BoolTest::gt : BoolTest::ge, if_prob(cnt, total_cnt), if_cnt(cnt));
1468 
1469       // if there is a higher range, test for it and process it:
1470       if (mid == hi) {
1471         jump_if_true_fork(iff_ge, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; cnt == 0);
1472       } else {
1473         Node *iftrue  = _gvn.transform( new IfTrueNode(iff_ge) );
1474         Node *iffalse = _gvn.transform( new IfFalseNode(iff_ge) );
1475         { PreserveJVMState pjvms(this);
1476           set_control(iftrue);
1477           jump_switch_ranges(key_val, mid == lo ? mid+1 : mid, hi, switch_depth+1);
1478         }
1479         set_control(iffalse);
1480       }
1481     }
1482 
1483     // in any case, process the lower range
1484     if (mid == lo) {
1485       if (mid-&gt;is_singleton()) {
1486         jump_switch_ranges(key_val, lo+1, hi, switch_depth+1);
1487       } else {
1488         jump_if_always_fork(lo-&gt;dest(), lo-&gt;table_index(), trim_ranges &amp;&amp; lo-&gt;cnt() == 0);
1489       }
1490     } else {
1491       jump_switch_ranges(key_val, lo, mid-1, switch_depth+1);
1492     }
1493   }
1494 
1495   // Decrease pred_count for each successor after all is done.
1496   if (switch_depth == 0) {
1497     int unique_successors = switch_block-&gt;num_successors();
1498     for (int i = 0; i &lt; unique_successors; i++) {
1499       Block* target = switch_block-&gt;successor_at(i);
1500       // Throw away the pre-allocated path for each unique successor.
1501       target-&gt;next_path_num();
1502     }
1503   }
1504 
1505 #ifndef PRODUCT
1506   _max_switch_depth = MAX2(switch_depth, _max_switch_depth);
1507   if (TraceOptoParse &amp;&amp; Verbose &amp;&amp; WizardMode &amp;&amp; switch_depth == 0) {
1508     SwitchRange* r;
1509     int nsing = 0;
1510     for( r = lo; r &lt;= hi; r++ ) {
1511       if( r-&gt;is_singleton() )  nsing++;
1512     }
1513     tty-&gt;print(&quot;&gt;&gt;&gt; &quot;);
1514     _method-&gt;print_short_name();
1515     tty-&gt;print_cr(&quot; switch decision tree&quot;);
1516     tty-&gt;print_cr(&quot;    %d ranges (%d singletons), max_depth=%d, est_depth=%d&quot;,
1517                   (int) (hi-lo+1), nsing, _max_switch_depth, _est_switch_depth);
1518     if (_max_switch_depth &gt; _est_switch_depth) {
1519       tty-&gt;print_cr(&quot;******** BAD SWITCH DEPTH ********&quot;);
1520     }
1521     tty-&gt;print(&quot;   &quot;);
1522     for( r = lo; r &lt;= hi; r++ ) {
1523       r-&gt;print();
1524     }
1525     tty-&gt;cr();
1526   }
1527 #endif
1528 }
1529 
1530 void Parse::modf() {
1531   Node *f2 = pop();
1532   Node *f1 = pop();
1533   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::modf_Type(),
1534                               CAST_FROM_FN_PTR(address, SharedRuntime::frem),
1535                               &quot;frem&quot;, NULL, //no memory effects
1536                               f1, f2);
1537   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1538 
1539   push(res);
1540 }
1541 
1542 void Parse::modd() {
1543   Node *d2 = pop_pair();
1544   Node *d1 = pop_pair();
1545   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::Math_DD_D_Type(),
1546                               CAST_FROM_FN_PTR(address, SharedRuntime::drem),
1547                               &quot;drem&quot;, NULL, //no memory effects
1548                               d1, top(), d2, top());
1549   Node* res_d   = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1550 
1551 #ifdef ASSERT
1552   Node* res_top = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 1));
1553   assert(res_top == top(), &quot;second value must be top&quot;);
1554 #endif
1555 
1556   push_pair(res_d);
1557 }
1558 
1559 void Parse::l2f() {
1560   Node* f2 = pop();
1561   Node* f1 = pop();
1562   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::l2f_Type(),
1563                               CAST_FROM_FN_PTR(address, SharedRuntime::l2f),
1564                               &quot;l2f&quot;, NULL, //no memory effects
1565                               f1, f2);
1566   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1567 
1568   push(res);
1569 }
1570 
1571 void Parse::do_irem() {
1572   // Must keep both values on the expression-stack during null-check
1573   zero_check_int(peek());
1574   // Compile-time detect of null-exception?
1575   if (stopped())  return;
1576 
1577   Node* b = pop();
1578   Node* a = pop();
1579 
1580   const Type *t = _gvn.type(b);
1581   if (t != Type::TOP) {
1582     const TypeInt *ti = t-&gt;is_int();
1583     if (ti-&gt;is_con()) {
1584       int divisor = ti-&gt;get_con();
1585       // check for positive power of 2
1586       if (divisor &gt; 0 &amp;&amp;
1587           (divisor &amp; ~(divisor-1)) == divisor) {
1588         // yes !
1589         Node *mask = _gvn.intcon((divisor - 1));
1590         // Sigh, must handle negative dividends
1591         Node *zero = _gvn.intcon(0);
1592         IfNode *ifff = jump_if_fork_int(a, zero, BoolTest::lt, PROB_FAIR, COUNT_UNKNOWN);
1593         Node *iff = _gvn.transform( new IfFalseNode(ifff) );
1594         Node *ift = _gvn.transform( new IfTrueNode (ifff) );
1595         Node *reg = jump_if_join(ift, iff);
1596         Node *phi = PhiNode::make(reg, NULL, TypeInt::INT);
1597         // Negative path; negate/and/negate
1598         Node *neg = _gvn.transform( new SubINode(zero, a) );
1599         Node *andn= _gvn.transform( new AndINode(neg, mask) );
1600         Node *negn= _gvn.transform( new SubINode(zero, andn) );
1601         phi-&gt;init_req(1, negn);
1602         // Fast positive case
1603         Node *andx = _gvn.transform( new AndINode(a, mask) );
1604         phi-&gt;init_req(2, andx);
1605         // Push the merge
1606         push( _gvn.transform(phi) );
1607         return;
1608       }
1609     }
1610   }
1611   // Default case
1612   push( _gvn.transform( new ModINode(control(),a,b) ) );
1613 }
1614 
1615 // Handle jsr and jsr_w bytecode
1616 void Parse::do_jsr() {
1617   assert(bc() == Bytecodes::_jsr || bc() == Bytecodes::_jsr_w, &quot;wrong bytecode&quot;);
1618 
1619   // Store information about current state, tagged with new _jsr_bci
1620   int return_bci = iter().next_bci();
1621   int jsr_bci    = (bc() == Bytecodes::_jsr) ? iter().get_dest() : iter().get_far_dest();
1622 
1623   // Update method data
1624   profile_taken_branch(jsr_bci);
1625 
1626   // The way we do things now, there is only one successor block
1627   // for the jsr, because the target code is cloned by ciTypeFlow.
1628   Block* target = successor_for_bci(jsr_bci);
1629 
1630   // What got pushed?
1631   const Type* ret_addr = target-&gt;peek();
1632   assert(ret_addr-&gt;singleton(), &quot;must be a constant (cloned jsr body)&quot;);
1633 
1634   // Effect on jsr on stack
1635   push(_gvn.makecon(ret_addr));
1636 
1637   // Flow to the jsr.
1638   merge(jsr_bci);
1639 }
1640 
1641 // Handle ret bytecode
1642 void Parse::do_ret() {
1643   // Find to whom we return.
1644   assert(block()-&gt;num_successors() == 1, &quot;a ret can only go one place now&quot;);
1645   Block* target = block()-&gt;successor_at(0);
1646   assert(!target-&gt;is_ready(), &quot;our arrival must be expected&quot;);
1647   profile_ret(target-&gt;flow()-&gt;start());
1648   int pnum = target-&gt;next_path_num();
1649   merge_common(target, pnum);
1650 }
1651 
1652 static bool has_injected_profile(BoolTest::mask btest, Node* test, int&amp; taken, int&amp; not_taken) {
1653   if (btest != BoolTest::eq &amp;&amp; btest != BoolTest::ne) {
1654     // Only ::eq and ::ne are supported for profile injection.
1655     return false;
1656   }
1657   if (test-&gt;is_Cmp() &amp;&amp;
1658       test-&gt;in(1)-&gt;Opcode() == Op_ProfileBoolean) {
1659     ProfileBooleanNode* profile = (ProfileBooleanNode*)test-&gt;in(1);
1660     int false_cnt = profile-&gt;false_count();
1661     int  true_cnt = profile-&gt;true_count();
1662 
1663     // Counts matching depends on the actual test operation (::eq or ::ne).
1664     // No need to scale the counts because profile injection was designed
1665     // to feed exact counts into VM.
1666     taken     = (btest == BoolTest::eq) ? false_cnt :  true_cnt;
1667     not_taken = (btest == BoolTest::eq) ?  true_cnt : false_cnt;
1668 
1669     profile-&gt;consume();
1670     return true;
1671   }
1672   return false;
1673 }
1674 //--------------------------dynamic_branch_prediction--------------------------
1675 // Try to gather dynamic branch prediction behavior.  Return a probability
1676 // of the branch being taken and set the &quot;cnt&quot; field.  Returns a -1.0
1677 // if we need to use static prediction for some reason.
1678 float Parse::dynamic_branch_prediction(float &amp;cnt, BoolTest::mask btest, Node* test) {
1679   ResourceMark rm;
1680 
1681   cnt  = COUNT_UNKNOWN;
1682 
1683   int     taken = 0;
1684   int not_taken = 0;
1685 
1686   bool use_mdo = !has_injected_profile(btest, test, taken, not_taken);
1687 
1688   if (use_mdo) {
1689     // Use MethodData information if it is available
1690     // FIXME: free the ProfileData structure
1691     ciMethodData* methodData = method()-&gt;method_data();
1692     if (!methodData-&gt;is_mature())  return PROB_UNKNOWN;
1693     ciProfileData* data = methodData-&gt;bci_to_data(bci());
1694     if (data == NULL) {
1695       return PROB_UNKNOWN;
1696     }
1697     if (!data-&gt;is_JumpData())  return PROB_UNKNOWN;
1698 
1699     // get taken and not taken values
1700     taken = data-&gt;as_JumpData()-&gt;taken();
1701     not_taken = 0;
1702     if (data-&gt;is_BranchData()) {
1703       not_taken = data-&gt;as_BranchData()-&gt;not_taken();
1704     }
1705 
1706     // scale the counts to be commensurate with invocation counts:
1707     taken = method()-&gt;scale_count(taken);
1708     not_taken = method()-&gt;scale_count(not_taken);
1709   }
1710 
1711   // Give up if too few (or too many, in which case the sum will overflow) counts to be meaningful.
1712   // We also check that individual counters are positive first, otherwise the sum can become positive.
1713   if (taken &lt; 0 || not_taken &lt; 0 || taken + not_taken &lt; 40) {
1714     if (C-&gt;log() != NULL) {
1715       C-&gt;log()-&gt;elem(&quot;branch target_bci=&#39;%d&#39; taken=&#39;%d&#39; not_taken=&#39;%d&#39;&quot;, iter().get_dest(), taken, not_taken);
1716     }
1717     return PROB_UNKNOWN;
1718   }
1719 
1720   // Compute frequency that we arrive here
1721   float sum = taken + not_taken;
1722   // Adjust, if this block is a cloned private block but the
1723   // Jump counts are shared.  Taken the private counts for
1724   // just this path instead of the shared counts.
1725   if( block()-&gt;count() &gt; 0 )
1726     sum = block()-&gt;count();
1727   cnt = sum / FreqCountInvocations;
1728 
1729   // Pin probability to sane limits
1730   float prob;
1731   if( !taken )
1732     prob = (0+PROB_MIN) / 2;
1733   else if( !not_taken )
1734     prob = (1+PROB_MAX) / 2;
1735   else {                         // Compute probability of true path
1736     prob = (float)taken / (float)(taken + not_taken);
1737     if (prob &gt; PROB_MAX)  prob = PROB_MAX;
1738     if (prob &lt; PROB_MIN)   prob = PROB_MIN;
1739   }
1740 
1741   assert((cnt &gt; 0.0f) &amp;&amp; (prob &gt; 0.0f),
1742          &quot;Bad frequency assignment in if&quot;);
1743 
1744   if (C-&gt;log() != NULL) {
1745     const char* prob_str = NULL;
1746     if (prob &gt;= PROB_MAX)  prob_str = (prob == PROB_MAX) ? &quot;max&quot; : &quot;always&quot;;
1747     if (prob &lt;= PROB_MIN)  prob_str = (prob == PROB_MIN) ? &quot;min&quot; : &quot;never&quot;;
1748     char prob_str_buf[30];
1749     if (prob_str == NULL) {
1750       jio_snprintf(prob_str_buf, sizeof(prob_str_buf), &quot;%20.2f&quot;, prob);
1751       prob_str = prob_str_buf;
1752     }
1753     C-&gt;log()-&gt;elem(&quot;branch target_bci=&#39;%d&#39; taken=&#39;%d&#39; not_taken=&#39;%d&#39; cnt=&#39;%f&#39; prob=&#39;%s&#39;&quot;,
1754                    iter().get_dest(), taken, not_taken, cnt, prob_str);
1755   }
1756   return prob;
1757 }
1758 
1759 //-----------------------------branch_prediction-------------------------------
1760 float Parse::branch_prediction(float&amp; cnt,
1761                                BoolTest::mask btest,
1762                                int target_bci,
1763                                Node* test) {
1764   float prob = dynamic_branch_prediction(cnt, btest, test);
1765   // If prob is unknown, switch to static prediction
1766   if (prob != PROB_UNKNOWN)  return prob;
1767 
1768   prob = PROB_FAIR;                   // Set default value
1769   if (btest == BoolTest::eq)          // Exactly equal test?
1770     prob = PROB_STATIC_INFREQUENT;    // Assume its relatively infrequent
1771   else if (btest == BoolTest::ne)
1772     prob = PROB_STATIC_FREQUENT;      // Assume its relatively frequent
1773 
1774   // If this is a conditional test guarding a backwards branch,
1775   // assume its a loop-back edge.  Make it a likely taken branch.
1776   if (target_bci &lt; bci()) {
1777     if (is_osr_parse()) {    // Could be a hot OSR&#39;d loop; force deopt
1778       // Since it&#39;s an OSR, we probably have profile data, but since
1779       // branch_prediction returned PROB_UNKNOWN, the counts are too small.
1780       // Let&#39;s make a special check here for completely zero counts.
1781       ciMethodData* methodData = method()-&gt;method_data();
1782       if (!methodData-&gt;is_empty()) {
1783         ciProfileData* data = methodData-&gt;bci_to_data(bci());
1784         // Only stop for truly zero counts, which mean an unknown part
1785         // of the OSR-ed method, and we want to deopt to gather more stats.
1786         // If you have ANY counts, then this loop is simply &#39;cold&#39; relative
1787         // to the OSR loop.
1788         if (data == NULL ||
1789             (data-&gt;as_BranchData()-&gt;taken() +  data-&gt;as_BranchData()-&gt;not_taken() == 0)) {
1790           // This is the only way to return PROB_UNKNOWN:
1791           return PROB_UNKNOWN;
1792         }
1793       }
1794     }
1795     prob = PROB_STATIC_FREQUENT;     // Likely to take backwards branch
1796   }
1797 
1798   assert(prob != PROB_UNKNOWN, &quot;must have some guess at this point&quot;);
1799   return prob;
1800 }
1801 
1802 // The magic constants are chosen so as to match the output of
1803 // branch_prediction() when the profile reports a zero taken count.
1804 // It is important to distinguish zero counts unambiguously, because
1805 // some branches (e.g., _213_javac.Assembler.eliminate) validly produce
1806 // very small but nonzero probabilities, which if confused with zero
1807 // counts would keep the program recompiling indefinitely.
1808 bool Parse::seems_never_taken(float prob) const {
1809   return prob &lt; PROB_MIN;
1810 }
1811 
1812 // True if the comparison seems to be the kind that will not change its
1813 // statistics from true to false.  See comments in adjust_map_after_if.
1814 // This question is only asked along paths which are already
1815 // classifed as untaken (by seems_never_taken), so really,
1816 // if a path is never taken, its controlling comparison is
1817 // already acting in a stable fashion.  If the comparison
1818 // seems stable, we will put an expensive uncommon trap
1819 // on the untaken path.
1820 bool Parse::seems_stable_comparison() const {
1821   if (C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if)) {
1822     return false;
1823   }
1824   return true;
1825 }
1826 
1827 //-------------------------------repush_if_args--------------------------------
1828 // Push arguments of an &quot;if&quot; bytecode back onto the stack by adjusting _sp.
1829 inline int Parse::repush_if_args() {
1830   if (PrintOpto &amp;&amp; WizardMode) {
1831     tty-&gt;print(&quot;defending against excessive implicit null exceptions on %s @%d in &quot;,
1832                Bytecodes::name(iter().cur_bc()), iter().cur_bci());
1833     method()-&gt;print_name(); tty-&gt;cr();
1834   }
1835   int bc_depth = - Bytecodes::depth(iter().cur_bc());
1836   assert(bc_depth == 1 || bc_depth == 2, &quot;only two kinds of branches&quot;);
1837   DEBUG_ONLY(sync_jvms());   // argument(n) requires a synced jvms
1838   assert(argument(0) != NULL, &quot;must exist&quot;);
1839   assert(bc_depth == 1 || argument(1) != NULL, &quot;two must exist&quot;);
1840   inc_sp(bc_depth);
1841   return bc_depth;
1842 }
1843 
1844 //----------------------------------do_ifnull----------------------------------
1845 void Parse::do_ifnull(BoolTest::mask btest, Node *c) {
1846   int target_bci = iter().get_dest();
1847 
1848   Block* branch_block = successor_for_bci(target_bci);
1849   Block* next_block   = successor_for_bci(iter().next_bci());
1850 
1851   float cnt;
1852   float prob = branch_prediction(cnt, btest, target_bci, c);
1853   if (prob == PROB_UNKNOWN) {
1854     // (An earlier version of do_ifnull omitted this trap for OSR methods.)
1855     if (PrintOpto &amp;&amp; Verbose) {
1856       tty-&gt;print_cr(&quot;Never-taken edge stops compilation at bci %d&quot;, bci());
1857     }
1858     repush_if_args(); // to gather stats on loop
1859     // We need to mark this branch as taken so that if we recompile we will
1860     // see that it is possible. In the tiered system the interpreter doesn&#39;t
1861     // do profiling and by the time we get to the lower tier from the interpreter
1862     // the path may be cold again. Make sure it doesn&#39;t look untaken
1863     profile_taken_branch(target_bci, !ProfileInterpreter);
1864     uncommon_trap(Deoptimization::Reason_unreached,
1865                   Deoptimization::Action_reinterpret,
1866                   NULL, &quot;cold&quot;);
1867     if (C-&gt;eliminate_boxing()) {
1868       // Mark the successor blocks as parsed
1869       branch_block-&gt;next_path_num();
1870       next_block-&gt;next_path_num();
1871     }
1872     return;
1873   }
1874 
1875   NOT_PRODUCT(explicit_null_checks_inserted++);
1876 
1877   // Generate real control flow
1878   Node   *tst = _gvn.transform( new BoolNode( c, btest ) );
1879 
1880   // Sanity check the probability value
1881   assert(prob &gt; 0.0f,&quot;Bad probability in Parser&quot;);
1882  // Need xform to put node in hash table
1883   IfNode *iff = create_and_xform_if( control(), tst, prob, cnt );
1884   assert(iff-&gt;_prob &gt; 0.0f,&quot;Optimizer made bad probability in parser&quot;);
1885   // True branch
1886   { PreserveJVMState pjvms(this);
1887     Node* iftrue  = _gvn.transform( new IfTrueNode (iff) );
1888     set_control(iftrue);
1889 
1890     if (stopped()) {            // Path is dead?
1891       NOT_PRODUCT(explicit_null_checks_elided++);
1892       if (C-&gt;eliminate_boxing()) {
1893         // Mark the successor block as parsed
1894         branch_block-&gt;next_path_num();
1895       }
1896     } else {                    // Path is live.
1897       // Update method data
1898       profile_taken_branch(target_bci);
1899       adjust_map_after_if(btest, c, prob, branch_block);
1900       if (!stopped()) {
1901         merge(target_bci);
1902       }
1903     }
1904   }
1905 
1906   // False branch
1907   Node* iffalse = _gvn.transform( new IfFalseNode(iff) );
1908   set_control(iffalse);
1909 
1910   if (stopped()) {              // Path is dead?
1911     NOT_PRODUCT(explicit_null_checks_elided++);
1912     if (C-&gt;eliminate_boxing()) {
1913       // Mark the successor block as parsed
1914       next_block-&gt;next_path_num();
1915     }
1916   } else  {                     // Path is live.
1917     // Update method data
1918     profile_not_taken_branch();
1919     adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob, next_block);
1920   }
1921 }
1922 
1923 //------------------------------------do_if------------------------------------
1924 void Parse::do_if(BoolTest::mask btest, Node* c, bool new_path, Node** ctrl_taken) {
1925   int target_bci = iter().get_dest();
1926 
1927   Block* branch_block = successor_for_bci(target_bci);
1928   Block* next_block   = successor_for_bci(iter().next_bci());
1929 
1930   float cnt;
1931   float prob = branch_prediction(cnt, btest, target_bci, c);
1932   float untaken_prob = 1.0 - prob;
1933 
1934   if (prob == PROB_UNKNOWN) {
1935     if (PrintOpto &amp;&amp; Verbose) {
1936       tty-&gt;print_cr(&quot;Never-taken edge stops compilation at bci %d&quot;, bci());
1937     }
1938     repush_if_args(); // to gather stats on loop
1939     // We need to mark this branch as taken so that if we recompile we will
1940     // see that it is possible. In the tiered system the interpreter doesn&#39;t
1941     // do profiling and by the time we get to the lower tier from the interpreter
1942     // the path may be cold again. Make sure it doesn&#39;t look untaken
1943     profile_taken_branch(target_bci, !ProfileInterpreter);
1944     uncommon_trap(Deoptimization::Reason_unreached,
1945                   Deoptimization::Action_reinterpret,
1946                   NULL, &quot;cold&quot;);
1947     if (C-&gt;eliminate_boxing()) {
1948       // Mark the successor blocks as parsed
1949       branch_block-&gt;next_path_num();
1950       next_block-&gt;next_path_num();
1951     }
1952     return;
1953   }
1954 
1955   // Sanity check the probability value
1956   assert(0.0f &lt; prob &amp;&amp; prob &lt; 1.0f,&quot;Bad probability in Parser&quot;);
1957 
1958   bool taken_if_true = true;
1959   // Convert BoolTest to canonical form:
1960   if (!BoolTest(btest).is_canonical()) {
1961     btest         = BoolTest(btest).negate();
1962     taken_if_true = false;
1963     // prob is NOT updated here; it remains the probability of the taken
1964     // path (as opposed to the prob of the path guarded by an &#39;IfTrueNode&#39;).
1965   }
1966   assert(btest != BoolTest::eq, &quot;!= is the only canonical exact test&quot;);
1967 
1968   Node* tst0 = new BoolNode(c, btest);
1969   Node* tst = _gvn.transform(tst0);
1970   BoolTest::mask taken_btest   = BoolTest::illegal;
1971   BoolTest::mask untaken_btest = BoolTest::illegal;
1972 
1973   if (tst-&gt;is_Bool()) {
1974     // Refresh c from the transformed bool node, since it may be
1975     // simpler than the original c.  Also re-canonicalize btest.
1976     // This wins when (Bool ne (Conv2B p) 0) =&gt; (Bool ne (CmpP p NULL)).
1977     // That can arise from statements like: if (x instanceof C) ...
1978     if (tst != tst0) {
1979       // Canonicalize one more time since transform can change it.
1980       btest = tst-&gt;as_Bool()-&gt;_test._test;
1981       if (!BoolTest(btest).is_canonical()) {
1982         // Reverse edges one more time...
1983         tst   = _gvn.transform( tst-&gt;as_Bool()-&gt;negate(&amp;_gvn) );
1984         btest = tst-&gt;as_Bool()-&gt;_test._test;
1985         assert(BoolTest(btest).is_canonical(), &quot;sanity&quot;);
1986         taken_if_true = !taken_if_true;
1987       }
1988       c = tst-&gt;in(1);
1989     }
1990     BoolTest::mask neg_btest = BoolTest(btest).negate();
1991     taken_btest   = taken_if_true ?     btest : neg_btest;
1992     untaken_btest = taken_if_true ? neg_btest :     btest;
1993   }
1994 
1995   // Generate real control flow
1996   float true_prob = (taken_if_true ? prob : untaken_prob);
1997   IfNode* iff = create_and_map_if(control(), tst, true_prob, cnt);
1998   assert(iff-&gt;_prob &gt; 0.0f,&quot;Optimizer made bad probability in parser&quot;);
1999   Node* taken_branch   = new IfTrueNode(iff);
2000   Node* untaken_branch = new IfFalseNode(iff);
2001   if (!taken_if_true) {  // Finish conversion to canonical form
2002     Node* tmp      = taken_branch;
2003     taken_branch   = untaken_branch;
2004     untaken_branch = tmp;
2005   }
2006 
2007   // Branch is taken:
2008   { PreserveJVMState pjvms(this);
2009     taken_branch = _gvn.transform(taken_branch);
2010     set_control(taken_branch);
2011 
2012     if (stopped()) {
2013       if (C-&gt;eliminate_boxing() &amp;&amp; !new_path) {
2014         // Mark the successor block as parsed (if we haven&#39;t created a new path)
2015         branch_block-&gt;next_path_num();
2016       }
2017     } else {
2018       // Update method data
2019       profile_taken_branch(target_bci);
2020       adjust_map_after_if(taken_btest, c, prob, branch_block);
2021       if (!stopped()) {
2022         if (new_path) {
2023           // Merge by using a new path
2024           merge_new_path(target_bci);
2025         } else if (ctrl_taken != NULL) {
2026           // Don&#39;t merge but save taken branch to be wired by caller
2027           *ctrl_taken = control();
2028         } else {
2029           merge(target_bci);
2030         }
2031       }
2032     }
2033   }
2034 
2035   untaken_branch = _gvn.transform(untaken_branch);
2036   set_control(untaken_branch);
2037 
2038   // Branch not taken.
2039   if (stopped() &amp;&amp; ctrl_taken == NULL) {
2040     if (C-&gt;eliminate_boxing()) {
2041       // Mark the successor block as parsed (if caller does not re-wire control flow)
2042       next_block-&gt;next_path_num();
2043     }
2044   } else {
2045     // Update method data
2046     profile_not_taken_branch();
2047     adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);
2048   }
2049 }
2050 
2051 void Parse::do_acmp(BoolTest::mask btest, Node* a, Node* b) {
2052   ciMethod* subst_method = ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature());
2053   // If current method is ValueBootstrapMethods::isSubstitutable(),
2054   // compile the acmp as a regular pointer comparison otherwise we
2055   // could call ValueBootstrapMethods::isSubstitutable() back
2056   if (!EnableValhalla || (method() == subst_method)) {
2057     Node* cmp = CmpP(a, b);
2058     cmp = optimize_cmp_with_klass(cmp);
2059     do_if(btest, cmp);
2060     return;
2061   }
2062 
2063   // Allocate inline type operands and re-execute on deoptimization
2064   if (a-&gt;is_InlineType()) {
2065     PreserveReexecuteState preexecs(this);
2066     inc_sp(2);
2067     jvms()-&gt;set_should_reexecute(true);
2068     a = a-&gt;as_InlineType()-&gt;buffer(this)-&gt;get_oop();
2069   }
2070   if (b-&gt;is_InlineType()) {
2071     PreserveReexecuteState preexecs(this);
2072     inc_sp(2);
2073     jvms()-&gt;set_should_reexecute(true);
2074     b = b-&gt;as_InlineType()-&gt;buffer(this)-&gt;get_oop();
2075   }
2076 
2077   // First, do a normal pointer comparison
2078   const TypeOopPtr* ta = _gvn.type(a)-&gt;isa_oopptr();
2079   const TypeOopPtr* tb = _gvn.type(b)-&gt;isa_oopptr();
2080   Node* cmp = CmpP(a, b);
2081   cmp = optimize_cmp_with_klass(cmp);
2082   if (ta == NULL || !ta-&gt;can_be_inline_type() ||
2083       tb == NULL || !tb-&gt;can_be_inline_type()) {
2084     // This is sufficient, if one of the operands can&#39;t be an inline type
2085     do_if(btest, cmp);
2086     return;
2087   }
2088   Node* eq_region = NULL;
2089   if (btest == BoolTest::eq) {
2090     do_if(btest, cmp, true);
2091     if (stopped()) {
2092       return;
2093     }
2094   } else {
2095     assert(btest == BoolTest::ne, &quot;only eq or ne&quot;);
2096     Node* is_not_equal = NULL;
2097     eq_region = new RegionNode(3);
2098     {
2099       PreserveJVMState pjvms(this);
2100       do_if(btest, cmp, false, &amp;is_not_equal);
2101       if (!stopped()) {
2102         eq_region-&gt;init_req(1, control());
2103       }
2104     }
2105     if (is_not_equal == NULL || is_not_equal-&gt;is_top()) {
2106       record_for_igvn(eq_region);
2107       set_control(_gvn.transform(eq_region));
2108       return;
2109     }
2110     set_control(is_not_equal);
2111   }
2112 
2113   // Pointers are not equal, check if first operand is non-null
2114   Node* ne_region = new RegionNode(6);
2115   inc_sp(2);
2116   Node* null_ctl = top();
2117   Node* not_null_a = null_check_oop(a, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);
2118   dec_sp(2);
2119   ne_region-&gt;init_req(1, null_ctl);
2120   if (stopped()) {
2121     record_for_igvn(ne_region);
2122     set_control(_gvn.transform(ne_region));
2123     if (btest == BoolTest::ne) {
2124       {
2125         PreserveJVMState pjvms(this);
2126         int target_bci = iter().get_dest();
2127         merge(target_bci);
2128       }
2129       record_for_igvn(eq_region);
2130       set_control(_gvn.transform(eq_region));
2131     }
2132     return;
2133   }
2134 
2135   // First operand is non-null, check if it is an inline type
2136   Node* is_value = is_inline_type(not_null_a);
2137   IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);
2138   Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));
2139   ne_region-&gt;init_req(2, not_value);
2140   set_control(_gvn.transform(new IfTrueNode(is_value_iff)));
2141 
2142   // The first operand is an inline type, check if the second operand is non-null
2143   inc_sp(2);
2144   null_ctl = top();
2145   Node* not_null_b = null_check_oop(b, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);
2146   dec_sp(2);
2147   ne_region-&gt;init_req(3, null_ctl);
2148   if (stopped()) {
2149     record_for_igvn(ne_region);
2150     set_control(_gvn.transform(ne_region));
2151     if (btest == BoolTest::ne) {
2152       {
2153         PreserveJVMState pjvms(this);
2154         int target_bci = iter().get_dest();
2155         merge(target_bci);
2156       }
2157       record_for_igvn(eq_region);
2158       set_control(_gvn.transform(eq_region));
2159     }
2160     return;
2161   }
2162 
2163   // Check if both operands are of the same class.
2164   Node* kls_a = load_object_klass(not_null_a);
2165   Node* kls_b = load_object_klass(not_null_b);
2166   Node* kls_cmp = CmpP(kls_a, kls_b);
2167   Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));
2168   IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);
2169   Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));
2170   set_control(_gvn.transform(new IfFalseNode(kls_iff)));
2171   ne_region-&gt;init_req(4, kls_ne);
2172 
2173   if (stopped()) {
2174     record_for_igvn(ne_region);
2175     set_control(_gvn.transform(ne_region));
2176     if (btest == BoolTest::ne) {
2177       {
2178         PreserveJVMState pjvms(this);
2179         int target_bci = iter().get_dest();
2180         merge(target_bci);
2181       }
2182       record_for_igvn(eq_region);
2183       set_control(_gvn.transform(eq_region));
2184     }
2185     return;
2186   }
2187 
2188   // Both operands are values types of the same class, we need to perform a
2189   // substitutability test. Delegate to ValueBootstrapMethods::isSubstitutable().
2190   Node* ne_io_phi = PhiNode::make(ne_region, i_o());
2191   Node* mem = reset_memory();
2192   Node* ne_mem_phi = PhiNode::make(ne_region, mem);
2193 
2194   Node* eq_io_phi = NULL;
2195   Node* eq_mem_phi = NULL;
2196   if (eq_region != NULL) {
2197     eq_io_phi = PhiNode::make(eq_region, i_o());
2198     eq_mem_phi = PhiNode::make(eq_region, mem);
2199   }
2200 
2201   set_all_memory(mem);
2202 
2203   kill_dead_locals();
2204   CallStaticJavaNode *call = new CallStaticJavaNode(C, TypeFunc::make(subst_method), SharedRuntime::get_resolve_static_call_stub(), subst_method, bci());
2205   call-&gt;set_override_symbolic_info(true);
2206   call-&gt;init_req(TypeFunc::Parms, not_null_a);
2207   call-&gt;init_req(TypeFunc::Parms+1, not_null_b);
2208   inc_sp(2);
2209   set_edges_for_java_call(call, false, false);
2210   Node* ret = set_results_for_java_call(call, false, true);
2211   dec_sp(2);
2212 
2213   // Test the return value of ValueBootstrapMethods::isSubstitutable()
2214   Node* subst_cmp = _gvn.transform(new CmpINode(ret, intcon(1)));
2215   Node* ctl = C-&gt;top();
2216   if (btest == BoolTest::eq) {
2217     PreserveJVMState pjvms(this);
2218     do_if(btest, subst_cmp);
2219     if (!stopped()) {
2220       ctl = control();
2221     }
2222   } else {
2223     assert(btest == BoolTest::ne, &quot;only eq or ne&quot;);
2224     PreserveJVMState pjvms(this);
2225     do_if(btest, subst_cmp, false, &amp;ctl);
2226     if (!stopped()) {
2227       eq_region-&gt;init_req(2, control());
2228       eq_io_phi-&gt;init_req(2, i_o());
2229       eq_mem_phi-&gt;init_req(2, reset_memory());
2230     }
2231   }
2232   ne_region-&gt;init_req(5, ctl);
2233   ne_io_phi-&gt;init_req(5, i_o());
2234   ne_mem_phi-&gt;init_req(5, reset_memory());
2235 
2236   record_for_igvn(ne_region);
2237   set_control(_gvn.transform(ne_region));
2238   set_i_o(_gvn.transform(ne_io_phi));
2239   set_all_memory(_gvn.transform(ne_mem_phi));
2240 
2241   if (btest == BoolTest::ne) {
2242     {
2243       PreserveJVMState pjvms(this);
2244       int target_bci = iter().get_dest();
2245       merge(target_bci);
2246     }
2247 
2248     record_for_igvn(eq_region);
2249     set_control(_gvn.transform(eq_region));
2250     set_i_o(_gvn.transform(eq_io_phi));
2251     set_all_memory(_gvn.transform(eq_mem_phi));
2252   }
2253 }
2254 
2255 bool Parse::path_is_suitable_for_uncommon_trap(float prob) const {
2256   // Don&#39;t want to speculate on uncommon traps when running with -Xcomp
2257   if (!UseInterpreter) {
2258     return false;
2259   }
2260   return (seems_never_taken(prob) &amp;&amp; seems_stable_comparison());
2261 }
2262 
2263 void Parse::maybe_add_predicate_after_if(Block* path) {
2264   if (path-&gt;is_SEL_head() &amp;&amp; path-&gt;preds_parsed() == 0) {
2265     // Add predicates at bci of if dominating the loop so traps can be
2266     // recorded on the if&#39;s profile data
2267     int bc_depth = repush_if_args();
2268     add_empty_predicates();
2269     dec_sp(bc_depth);
2270     path-&gt;set_has_predicates();
2271   }
2272 }
2273 
2274 
2275 //----------------------------adjust_map_after_if------------------------------
2276 // Adjust the JVM state to reflect the result of taking this path.
2277 // Basically, it means inspecting the CmpNode controlling this
2278 // branch, seeing how it constrains a tested value, and then
2279 // deciding if it&#39;s worth our while to encode this constraint
2280 // as graph nodes in the current abstract interpretation map.
2281 void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {
2282   if (!c-&gt;is_Cmp()) {
2283     maybe_add_predicate_after_if(path);
2284     return;
2285   }
2286 
2287   if (stopped() || btest == BoolTest::illegal) {
2288     return;                             // nothing to do
2289   }
2290 
2291   bool is_fallthrough = (path == successor_for_bci(iter().next_bci()));
2292 
2293   if (path_is_suitable_for_uncommon_trap(prob)) {
2294     repush_if_args();
2295     uncommon_trap(Deoptimization::Reason_unstable_if,
2296                   Deoptimization::Action_reinterpret,
2297                   NULL,
2298                   (is_fallthrough ? &quot;taken always&quot; : &quot;taken never&quot;));
2299     return;
2300   }
2301 
2302   Node* val = c-&gt;in(1);
2303   Node* con = c-&gt;in(2);
2304   const Type* tcon = _gvn.type(con);
2305   const Type* tval = _gvn.type(val);
2306   bool have_con = tcon-&gt;singleton();
2307   if (tval-&gt;singleton()) {
2308     if (!have_con) {
2309       // Swap, so constant is in con.
2310       con  = val;
2311       tcon = tval;
2312       val  = c-&gt;in(2);
2313       tval = _gvn.type(val);
2314       btest = BoolTest(btest).commute();
2315       have_con = true;
2316     } else {
2317       // Do we have two constants?  Then leave well enough alone.
2318       have_con = false;
2319     }
2320   }
2321   if (!have_con) {                        // remaining adjustments need a con
2322     maybe_add_predicate_after_if(path);
2323     return;
2324   }
2325 
2326   sharpen_type_after_if(btest, con, tcon, val, tval);
2327   maybe_add_predicate_after_if(path);
2328 }
2329 
2330 
2331 static Node* extract_obj_from_klass_load(PhaseGVN* gvn, Node* n) {
2332   Node* ldk;
2333   if (n-&gt;is_DecodeNKlass()) {
2334     if (n-&gt;in(1)-&gt;Opcode() != Op_LoadNKlass) {
2335       return NULL;
2336     } else {
2337       ldk = n-&gt;in(1);
2338     }
2339   } else if (n-&gt;Opcode() != Op_LoadKlass) {
2340     return NULL;
2341   } else {
2342     ldk = n;
2343   }
2344   assert(ldk != NULL &amp;&amp; ldk-&gt;is_Load(), &quot;should have found a LoadKlass or LoadNKlass node&quot;);
2345 
2346   Node* adr = ldk-&gt;in(MemNode::Address);
2347   intptr_t off = 0;
2348   Node* obj = AddPNode::Ideal_base_and_offset(adr, gvn, off);
2349   if (obj == NULL || off != oopDesc::klass_offset_in_bytes()) // loading oopDesc::_klass?
2350     return NULL;
2351   const TypePtr* tp = gvn-&gt;type(obj)-&gt;is_ptr();
2352   if (tp == NULL || !(tp-&gt;isa_instptr() || tp-&gt;isa_aryptr())) // is obj a Java object ptr?
2353     return NULL;
2354 
2355   return obj;
2356 }
2357 
2358 void Parse::sharpen_type_after_if(BoolTest::mask btest,
2359                                   Node* con, const Type* tcon,
2360                                   Node* val, const Type* tval) {
2361   // Look for opportunities to sharpen the type of a node
2362   // whose klass is compared with a constant klass.
2363   if (btest == BoolTest::eq &amp;&amp; tcon-&gt;isa_klassptr()) {
2364     Node* obj = extract_obj_from_klass_load(&amp;_gvn, val);
2365     const TypeOopPtr* con_type = tcon-&gt;isa_klassptr()-&gt;as_instance_type();
2366     if (obj != NULL &amp;&amp; (con_type-&gt;isa_instptr() || con_type-&gt;isa_aryptr())) {
2367        // Found:
2368        //   Bool(CmpP(LoadKlass(obj._klass), ConP(Foo.klass)), [eq])
2369        // or the narrowOop equivalent.
2370        const Type* obj_type = _gvn.type(obj);
2371        const TypeOopPtr* tboth = obj_type-&gt;join_speculative(con_type)-&gt;isa_oopptr();
2372        if (tboth != NULL &amp;&amp; tboth-&gt;klass_is_exact() &amp;&amp; tboth != obj_type &amp;&amp;
2373            tboth-&gt;higher_equal(obj_type)) {
2374           // obj has to be of the exact type Foo if the CmpP succeeds.
2375           int obj_in_map = map()-&gt;find_edge(obj);
2376           JVMState* jvms = this-&gt;jvms();
2377           if (obj_in_map &gt;= 0 &amp;&amp;
2378               (jvms-&gt;is_loc(obj_in_map) || jvms-&gt;is_stk(obj_in_map))) {
2379             TypeNode* ccast = new CheckCastPPNode(control(), obj, tboth);
2380             const Type* tcc = ccast-&gt;as_Type()-&gt;type();
2381             assert(tcc != obj_type &amp;&amp; tcc-&gt;higher_equal(obj_type), &quot;must improve&quot;);
2382             // Delay transform() call to allow recovery of pre-cast value
2383             // at the control merge.
2384             _gvn.set_type_bottom(ccast);
2385             record_for_igvn(ccast);
2386             // Here&#39;s the payoff.
2387             replace_in_map(obj, ccast);
2388           }
2389        }
2390     }
2391   }
2392 
2393   int val_in_map = map()-&gt;find_edge(val);
2394   if (val_in_map &lt; 0)  return;          // replace_in_map would be useless
2395   {
2396     JVMState* jvms = this-&gt;jvms();
2397     if (!(jvms-&gt;is_loc(val_in_map) ||
2398           jvms-&gt;is_stk(val_in_map)))
2399       return;                           // again, it would be useless
2400   }
2401 
2402   // Check for a comparison to a constant, and &quot;know&quot; that the compared
2403   // value is constrained on this path.
2404   assert(tcon-&gt;singleton(), &quot;&quot;);
2405   ConstraintCastNode* ccast = NULL;
2406   Node* cast = NULL;
2407 
2408   switch (btest) {
2409   case BoolTest::eq:                    // Constant test?
2410     {
2411       const Type* tboth = tcon-&gt;join_speculative(tval);
2412       if (tboth == tval)  break;        // Nothing to gain.
2413       if (tcon-&gt;isa_int()) {
2414         ccast = new CastIINode(val, tboth);
2415       } else if (tcon == TypePtr::NULL_PTR) {
2416         // Cast to null, but keep the pointer identity temporarily live.
2417         ccast = new CastPPNode(val, tboth);
2418       } else {
2419         const TypeF* tf = tcon-&gt;isa_float_constant();
2420         const TypeD* td = tcon-&gt;isa_double_constant();
2421         // Exclude tests vs float/double 0 as these could be
2422         // either +0 or -0.  Just because you are equal to +0
2423         // doesn&#39;t mean you ARE +0!
2424         // Note, following code also replaces Long and Oop values.
2425         if ((!tf || tf-&gt;_f != 0.0) &amp;&amp;
2426             (!td || td-&gt;_d != 0.0))
2427           cast = con;                   // Replace non-constant val by con.
2428       }
2429     }
2430     break;
2431 
2432   case BoolTest::ne:
2433     if (tcon == TypePtr::NULL_PTR) {
2434       cast = cast_not_null(val, false);
2435     }
2436     break;
2437 
2438   default:
2439     // (At this point we could record int range types with CastII.)
2440     break;
2441   }
2442 
2443   if (ccast != NULL) {
2444     const Type* tcc = ccast-&gt;as_Type()-&gt;type();
2445     assert(tcc != tval &amp;&amp; tcc-&gt;higher_equal(tval), &quot;must improve&quot;);
2446     // Delay transform() call to allow recovery of pre-cast value
2447     // at the control merge.
2448     ccast-&gt;set_req(0, control());
2449     _gvn.set_type_bottom(ccast);
2450     record_for_igvn(ccast);
2451     cast = ccast;
2452   }
2453 
2454   if (cast != NULL) {                   // Here&#39;s the payoff.
2455     replace_in_map(val, cast);
2456   }
2457 }
2458 
2459 /**
2460  * Use speculative type to optimize CmpP node: if comparison is
2461  * against the low level class, cast the object to the speculative
2462  * type if any. CmpP should then go away.
2463  *
2464  * @param c  expected CmpP node
2465  * @return   result of CmpP on object casted to speculative type
2466  *
2467  */
2468 Node* Parse::optimize_cmp_with_klass(Node* c) {
2469   // If this is transformed by the _gvn to a comparison with the low
2470   // level klass then we may be able to use speculation
2471   if (c-&gt;Opcode() == Op_CmpP &amp;&amp;
2472       (c-&gt;in(1)-&gt;Opcode() == Op_LoadKlass || c-&gt;in(1)-&gt;Opcode() == Op_DecodeNKlass) &amp;&amp;
2473       c-&gt;in(2)-&gt;is_Con()) {
2474     Node* load_klass = NULL;
2475     Node* decode = NULL;
2476     if (c-&gt;in(1)-&gt;Opcode() == Op_DecodeNKlass) {
2477       decode = c-&gt;in(1);
2478       load_klass = c-&gt;in(1)-&gt;in(1);
2479     } else {
2480       load_klass = c-&gt;in(1);
2481     }
2482     if (load_klass-&gt;in(2)-&gt;is_AddP()) {
2483       Node* addp = load_klass-&gt;in(2);
2484       Node* obj = addp-&gt;in(AddPNode::Address);
2485       const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
2486       if (obj_type-&gt;speculative_type_not_null() != NULL) {
2487         ciKlass* k = obj_type-&gt;speculative_type();
2488         inc_sp(2);
2489         obj = maybe_cast_profiled_obj(obj, k);
2490         dec_sp(2);
2491         if (obj-&gt;is_InlineType()) {
2492           assert(obj-&gt;as_InlineType()-&gt;is_allocated(&amp;_gvn), &quot;must be allocated&quot;);
2493           obj = obj-&gt;as_InlineType()-&gt;get_oop();
2494         }
2495         // Make the CmpP use the casted obj
2496         addp = basic_plus_adr(obj, addp-&gt;in(AddPNode::Offset));
2497         load_klass = load_klass-&gt;clone();
2498         load_klass-&gt;set_req(2, addp);
2499         load_klass = _gvn.transform(load_klass);
2500         if (decode != NULL) {
2501           decode = decode-&gt;clone();
2502           decode-&gt;set_req(1, load_klass);
2503           load_klass = _gvn.transform(decode);
2504         }
2505         c = c-&gt;clone();
2506         c-&gt;set_req(1, load_klass);
2507         c = _gvn.transform(c);
2508       }
2509     }
2510   }
2511   return c;
2512 }
2513 
2514 //------------------------------do_one_bytecode--------------------------------
2515 // Parse this bytecode, and alter the Parsers JVM-&gt;Node mapping
2516 void Parse::do_one_bytecode() {
2517   Node *a, *b, *c, *d;          // Handy temps
2518   BoolTest::mask btest;
2519   int i;
2520 
2521   assert(!has_exceptions(), &quot;bytecode entry state must be clear of throws&quot;);
2522 
2523   if (C-&gt;check_node_count(NodeLimitFudgeFactor * 5,
2524                           &quot;out of nodes parsing method&quot;)) {
2525     return;
2526   }
2527 
2528 #ifdef ASSERT
2529   // for setting breakpoints
2530   if (TraceOptoParse) {
2531     tty-&gt;print(&quot; @&quot;);
2532     dump_bci(bci());
2533     tty-&gt;cr();
2534   }
2535 #endif
2536 
2537   switch (bc()) {
2538   case Bytecodes::_nop:
2539     // do nothing
2540     break;
2541   case Bytecodes::_lconst_0:
2542     push_pair(longcon(0));
2543     break;
2544 
2545   case Bytecodes::_lconst_1:
2546     push_pair(longcon(1));
2547     break;
2548 
2549   case Bytecodes::_fconst_0:
2550     push(zerocon(T_FLOAT));
2551     break;
2552 
2553   case Bytecodes::_fconst_1:
2554     push(makecon(TypeF::ONE));
2555     break;
2556 
2557   case Bytecodes::_fconst_2:
2558     push(makecon(TypeF::make(2.0f)));
2559     break;
2560 
2561   case Bytecodes::_dconst_0:
2562     push_pair(zerocon(T_DOUBLE));
2563     break;
2564 
2565   case Bytecodes::_dconst_1:
2566     push_pair(makecon(TypeD::ONE));
2567     break;
2568 
2569   case Bytecodes::_iconst_m1:push(intcon(-1)); break;
2570   case Bytecodes::_iconst_0: push(intcon( 0)); break;
2571   case Bytecodes::_iconst_1: push(intcon( 1)); break;
2572   case Bytecodes::_iconst_2: push(intcon( 2)); break;
2573   case Bytecodes::_iconst_3: push(intcon( 3)); break;
2574   case Bytecodes::_iconst_4: push(intcon( 4)); break;
2575   case Bytecodes::_iconst_5: push(intcon( 5)); break;
2576   case Bytecodes::_bipush:   push(intcon(iter().get_constant_u1())); break;
2577   case Bytecodes::_sipush:   push(intcon(iter().get_constant_u2())); break;
2578   case Bytecodes::_aconst_null: push(null());  break;
2579   case Bytecodes::_ldc:
2580   case Bytecodes::_ldc_w:
2581   case Bytecodes::_ldc2_w:
2582     // If the constant is unresolved, run this BC once in the interpreter.
2583     {
2584       ciConstant constant = iter().get_constant();
2585       if (!constant.is_valid() ||
2586           (constant.basic_type() == T_OBJECT &amp;&amp;
2587            !constant.as_object()-&gt;is_loaded())) {
2588         int index = iter().get_constant_pool_index();
2589         constantTag tag = iter().get_constant_pool_tag(index);
2590         uncommon_trap(Deoptimization::make_trap_request
2591                       (Deoptimization::Reason_unloaded,
2592                        Deoptimization::Action_reinterpret,
2593                        index),
2594                       NULL, tag.internal_name());
2595         break;
2596       }
2597       assert(constant.basic_type() != T_OBJECT || constant.as_object()-&gt;is_instance(),
2598              &quot;must be java_mirror of klass&quot;);
2599       const Type* con_type = Type::make_from_constant(constant);
2600       if (con_type != NULL) {
2601         push_node(con_type-&gt;basic_type(), makecon(con_type));
2602       }
2603     }
2604 
2605     break;
2606 
2607   case Bytecodes::_aload_0:
2608     push( local(0) );
2609     break;
2610   case Bytecodes::_aload_1:
2611     push( local(1) );
2612     break;
2613   case Bytecodes::_aload_2:
2614     push( local(2) );
2615     break;
2616   case Bytecodes::_aload_3:
2617     push( local(3) );
2618     break;
2619   case Bytecodes::_aload:
2620     push( local(iter().get_index()) );
2621     break;
2622 
2623   case Bytecodes::_fload_0:
2624   case Bytecodes::_iload_0:
2625     push( local(0) );
2626     break;
2627   case Bytecodes::_fload_1:
2628   case Bytecodes::_iload_1:
2629     push( local(1) );
2630     break;
2631   case Bytecodes::_fload_2:
2632   case Bytecodes::_iload_2:
2633     push( local(2) );
2634     break;
2635   case Bytecodes::_fload_3:
2636   case Bytecodes::_iload_3:
2637     push( local(3) );
2638     break;
2639   case Bytecodes::_fload:
2640   case Bytecodes::_iload:
2641     push( local(iter().get_index()) );
2642     break;
2643   case Bytecodes::_lload_0:
2644     push_pair_local( 0 );
2645     break;
2646   case Bytecodes::_lload_1:
2647     push_pair_local( 1 );
2648     break;
2649   case Bytecodes::_lload_2:
2650     push_pair_local( 2 );
2651     break;
2652   case Bytecodes::_lload_3:
2653     push_pair_local( 3 );
2654     break;
2655   case Bytecodes::_lload:
2656     push_pair_local( iter().get_index() );
2657     break;
2658 
2659   case Bytecodes::_dload_0:
2660     push_pair_local(0);
2661     break;
2662   case Bytecodes::_dload_1:
2663     push_pair_local(1);
2664     break;
2665   case Bytecodes::_dload_2:
2666     push_pair_local(2);
2667     break;
2668   case Bytecodes::_dload_3:
2669     push_pair_local(3);
2670     break;
2671   case Bytecodes::_dload:
2672     push_pair_local(iter().get_index());
2673     break;
2674   case Bytecodes::_fstore_0:
2675   case Bytecodes::_istore_0:
2676   case Bytecodes::_astore_0:
2677     set_local( 0, pop() );
2678     break;
2679   case Bytecodes::_fstore_1:
2680   case Bytecodes::_istore_1:
2681   case Bytecodes::_astore_1:
2682     set_local( 1, pop() );
2683     break;
2684   case Bytecodes::_fstore_2:
2685   case Bytecodes::_istore_2:
2686   case Bytecodes::_astore_2:
2687     set_local( 2, pop() );
2688     break;
2689   case Bytecodes::_fstore_3:
2690   case Bytecodes::_istore_3:
2691   case Bytecodes::_astore_3:
2692     set_local( 3, pop() );
2693     break;
2694   case Bytecodes::_fstore:
2695   case Bytecodes::_istore:
2696   case Bytecodes::_astore:
2697     set_local( iter().get_index(), pop() );
2698     break;
2699   // long stores
2700   case Bytecodes::_lstore_0:
2701     set_pair_local( 0, pop_pair() );
2702     break;
2703   case Bytecodes::_lstore_1:
2704     set_pair_local( 1, pop_pair() );
2705     break;
2706   case Bytecodes::_lstore_2:
2707     set_pair_local( 2, pop_pair() );
2708     break;
2709   case Bytecodes::_lstore_3:
2710     set_pair_local( 3, pop_pair() );
2711     break;
2712   case Bytecodes::_lstore:
2713     set_pair_local( iter().get_index(), pop_pair() );
2714     break;
2715 
2716   // double stores
2717   case Bytecodes::_dstore_0:
2718     set_pair_local( 0, dstore_rounding(pop_pair()) );
2719     break;
2720   case Bytecodes::_dstore_1:
2721     set_pair_local( 1, dstore_rounding(pop_pair()) );
2722     break;
2723   case Bytecodes::_dstore_2:
2724     set_pair_local( 2, dstore_rounding(pop_pair()) );
2725     break;
2726   case Bytecodes::_dstore_3:
2727     set_pair_local( 3, dstore_rounding(pop_pair()) );
2728     break;
2729   case Bytecodes::_dstore:
2730     set_pair_local( iter().get_index(), dstore_rounding(pop_pair()) );
2731     break;
2732 
2733   case Bytecodes::_pop:  dec_sp(1);   break;
2734   case Bytecodes::_pop2: dec_sp(2);   break;
2735   case Bytecodes::_swap:
2736     a = pop();
2737     b = pop();
2738     push(a);
2739     push(b);
2740     break;
2741   case Bytecodes::_dup:
2742     a = pop();
2743     push(a);
2744     push(a);
2745     break;
2746   case Bytecodes::_dup_x1:
2747     a = pop();
2748     b = pop();
2749     push( a );
2750     push( b );
2751     push( a );
2752     break;
2753   case Bytecodes::_dup_x2:
2754     a = pop();
2755     b = pop();
2756     c = pop();
2757     push( a );
2758     push( c );
2759     push( b );
2760     push( a );
2761     break;
2762   case Bytecodes::_dup2:
2763     a = pop();
2764     b = pop();
2765     push( b );
2766     push( a );
2767     push( b );
2768     push( a );
2769     break;
2770 
2771   case Bytecodes::_dup2_x1:
2772     // before: .. c, b, a
2773     // after:  .. b, a, c, b, a
2774     // not tested
2775     a = pop();
2776     b = pop();
2777     c = pop();
2778     push( b );
2779     push( a );
2780     push( c );
2781     push( b );
2782     push( a );
2783     break;
2784   case Bytecodes::_dup2_x2:
2785     // before: .. d, c, b, a
2786     // after:  .. b, a, d, c, b, a
2787     // not tested
2788     a = pop();
2789     b = pop();
2790     c = pop();
2791     d = pop();
2792     push( b );
2793     push( a );
2794     push( d );
2795     push( c );
2796     push( b );
2797     push( a );
2798     break;
2799 
2800   case Bytecodes::_arraylength: {
2801     // Must do null-check with value on expression stack
2802     Node *ary = null_check(peek(), T_ARRAY);
2803     // Compile-time detect of null-exception?
2804     if (stopped())  return;
2805     a = pop();
2806     push(load_array_length(a));
2807     break;
2808   }
2809 
2810   case Bytecodes::_baload:  array_load(T_BYTE);    break;
2811   case Bytecodes::_caload:  array_load(T_CHAR);    break;
2812   case Bytecodes::_iaload:  array_load(T_INT);     break;
2813   case Bytecodes::_saload:  array_load(T_SHORT);   break;
2814   case Bytecodes::_faload:  array_load(T_FLOAT);   break;
2815   case Bytecodes::_aaload:  array_load(T_OBJECT);  break;
2816   case Bytecodes::_laload:  array_load(T_LONG);    break;
2817   case Bytecodes::_daload:  array_load(T_DOUBLE);  break;
2818   case Bytecodes::_bastore: array_store(T_BYTE);   break;
2819   case Bytecodes::_castore: array_store(T_CHAR);   break;
2820   case Bytecodes::_iastore: array_store(T_INT);    break;
2821   case Bytecodes::_sastore: array_store(T_SHORT);  break;
2822   case Bytecodes::_fastore: array_store(T_FLOAT);  break;
2823   case Bytecodes::_aastore: array_store(T_OBJECT); break;
2824   case Bytecodes::_lastore: array_store(T_LONG);   break;
2825   case Bytecodes::_dastore: array_store(T_DOUBLE); break;
2826 
2827   case Bytecodes::_getfield:
2828     do_getfield();
2829     break;
2830 
2831   case Bytecodes::_getstatic:
2832     do_getstatic();
2833     break;
2834 
2835   case Bytecodes::_putfield:
2836     do_putfield();
2837     break;
2838 
2839   case Bytecodes::_putstatic:
2840     do_putstatic();
2841     break;
2842 
2843   case Bytecodes::_irem:
2844     do_irem();
2845     break;
2846   case Bytecodes::_idiv:
2847     // Must keep both values on the expression-stack during null-check
2848     zero_check_int(peek());
2849     // Compile-time detect of null-exception?
2850     if (stopped())  return;
2851     b = pop();
2852     a = pop();
2853     push( _gvn.transform( new DivINode(control(),a,b) ) );
2854     break;
2855   case Bytecodes::_imul:
2856     b = pop(); a = pop();
2857     push( _gvn.transform( new MulINode(a,b) ) );
2858     break;
2859   case Bytecodes::_iadd:
2860     b = pop(); a = pop();
2861     push( _gvn.transform( new AddINode(a,b) ) );
2862     break;
2863   case Bytecodes::_ineg:
2864     a = pop();
2865     push( _gvn.transform( new SubINode(_gvn.intcon(0),a)) );
2866     break;
2867   case Bytecodes::_isub:
2868     b = pop(); a = pop();
2869     push( _gvn.transform( new SubINode(a,b) ) );
2870     break;
2871   case Bytecodes::_iand:
2872     b = pop(); a = pop();
2873     push( _gvn.transform( new AndINode(a,b) ) );
2874     break;
2875   case Bytecodes::_ior:
2876     b = pop(); a = pop();
2877     push( _gvn.transform( new OrINode(a,b) ) );
2878     break;
2879   case Bytecodes::_ixor:
2880     b = pop(); a = pop();
2881     push( _gvn.transform( new XorINode(a,b) ) );
2882     break;
2883   case Bytecodes::_ishl:
2884     b = pop(); a = pop();
2885     push( _gvn.transform( new LShiftINode(a,b) ) );
2886     break;
2887   case Bytecodes::_ishr:
2888     b = pop(); a = pop();
2889     push( _gvn.transform( new RShiftINode(a,b) ) );
2890     break;
2891   case Bytecodes::_iushr:
2892     b = pop(); a = pop();
2893     push( _gvn.transform( new URShiftINode(a,b) ) );
2894     break;
2895 
2896   case Bytecodes::_fneg:
2897     a = pop();
2898     b = _gvn.transform(new NegFNode (a));
2899     push(b);
2900     break;
2901 
2902   case Bytecodes::_fsub:
2903     b = pop();
2904     a = pop();
2905     c = _gvn.transform( new SubFNode(a,b) );
2906     d = precision_rounding(c);
2907     push( d );
2908     break;
2909 
2910   case Bytecodes::_fadd:
2911     b = pop();
2912     a = pop();
2913     c = _gvn.transform( new AddFNode(a,b) );
2914     d = precision_rounding(c);
2915     push( d );
2916     break;
2917 
2918   case Bytecodes::_fmul:
2919     b = pop();
2920     a = pop();
2921     c = _gvn.transform( new MulFNode(a,b) );
2922     d = precision_rounding(c);
2923     push( d );
2924     break;
2925 
2926   case Bytecodes::_fdiv:
2927     b = pop();
2928     a = pop();
2929     c = _gvn.transform( new DivFNode(0,a,b) );
2930     d = precision_rounding(c);
2931     push( d );
2932     break;
2933 
2934   case Bytecodes::_frem:
2935     if (Matcher::has_match_rule(Op_ModF)) {
2936       // Generate a ModF node.
2937       b = pop();
2938       a = pop();
2939       c = _gvn.transform( new ModFNode(0,a,b) );
2940       d = precision_rounding(c);
2941       push( d );
2942     }
2943     else {
2944       // Generate a call.
2945       modf();
2946     }
2947     break;
2948 
2949   case Bytecodes::_fcmpl:
2950     b = pop();
2951     a = pop();
2952     c = _gvn.transform( new CmpF3Node( a, b));
2953     push(c);
2954     break;
2955   case Bytecodes::_fcmpg:
2956     b = pop();
2957     a = pop();
2958 
2959     // Same as fcmpl but need to flip the unordered case.  Swap the inputs,
2960     // which negates the result sign except for unordered.  Flip the unordered
2961     // as well by using CmpF3 which implements unordered-lesser instead of
2962     // unordered-greater semantics.  Finally, commute the result bits.  Result
2963     // is same as using a CmpF3Greater except we did it with CmpF3 alone.
2964     c = _gvn.transform( new CmpF3Node( b, a));
2965     c = _gvn.transform( new SubINode(_gvn.intcon(0),c) );
2966     push(c);
2967     break;
2968 
2969   case Bytecodes::_f2i:
2970     a = pop();
2971     push(_gvn.transform(new ConvF2INode(a)));
2972     break;
2973 
2974   case Bytecodes::_d2i:
2975     a = pop_pair();
2976     b = _gvn.transform(new ConvD2INode(a));
2977     push( b );
2978     break;
2979 
2980   case Bytecodes::_f2d:
2981     a = pop();
2982     b = _gvn.transform( new ConvF2DNode(a));
2983     push_pair( b );
2984     break;
2985 
2986   case Bytecodes::_d2f:
2987     a = pop_pair();
2988     b = _gvn.transform( new ConvD2FNode(a));
2989     // This breaks _227_mtrt (speed &amp; correctness) and _222_mpegaudio (speed)
2990     //b = _gvn.transform(new RoundFloatNode(0, b) );
2991     push( b );
2992     break;
2993 
2994   case Bytecodes::_l2f:
2995     if (Matcher::convL2FSupported()) {
2996       a = pop_pair();
2997       b = _gvn.transform( new ConvL2FNode(a));
2998       // For i486.ad, FILD doesn&#39;t restrict precision to 24 or 53 bits.
2999       // Rather than storing the result into an FP register then pushing
3000       // out to memory to round, the machine instruction that implements
3001       // ConvL2D is responsible for rounding.
3002       // c = precision_rounding(b);
3003       c = _gvn.transform(b);
3004       push(c);
3005     } else {
3006       l2f();
3007     }
3008     break;
3009 
3010   case Bytecodes::_l2d:
3011     a = pop_pair();
3012     b = _gvn.transform( new ConvL2DNode(a));
3013     // For i486.ad, rounding is always necessary (see _l2f above).
3014     // c = dprecision_rounding(b);
3015     c = _gvn.transform(b);
3016     push_pair(c);
3017     break;
3018 
3019   case Bytecodes::_f2l:
3020     a = pop();
3021     b = _gvn.transform( new ConvF2LNode(a));
3022     push_pair(b);
3023     break;
3024 
3025   case Bytecodes::_d2l:
3026     a = pop_pair();
3027     b = _gvn.transform( new ConvD2LNode(a));
3028     push_pair(b);
3029     break;
3030 
3031   case Bytecodes::_dsub:
3032     b = pop_pair();
3033     a = pop_pair();
3034     c = _gvn.transform( new SubDNode(a,b) );
3035     d = dprecision_rounding(c);
3036     push_pair( d );
3037     break;
3038 
3039   case Bytecodes::_dadd:
3040     b = pop_pair();
3041     a = pop_pair();
3042     c = _gvn.transform( new AddDNode(a,b) );
3043     d = dprecision_rounding(c);
3044     push_pair( d );
3045     break;
3046 
3047   case Bytecodes::_dmul:
3048     b = pop_pair();
3049     a = pop_pair();
3050     c = _gvn.transform( new MulDNode(a,b) );
3051     d = dprecision_rounding(c);
3052     push_pair( d );
3053     break;
3054 
3055   case Bytecodes::_ddiv:
3056     b = pop_pair();
3057     a = pop_pair();
3058     c = _gvn.transform( new DivDNode(0,a,b) );
3059     d = dprecision_rounding(c);
3060     push_pair( d );
3061     break;
3062 
3063   case Bytecodes::_dneg:
3064     a = pop_pair();
3065     b = _gvn.transform(new NegDNode (a));
3066     push_pair(b);
3067     break;
3068 
3069   case Bytecodes::_drem:
3070     if (Matcher::has_match_rule(Op_ModD)) {
3071       // Generate a ModD node.
3072       b = pop_pair();
3073       a = pop_pair();
3074       // a % b
3075 
3076       c = _gvn.transform( new ModDNode(0,a,b) );
3077       d = dprecision_rounding(c);
3078       push_pair( d );
3079     }
3080     else {
3081       // Generate a call.
3082       modd();
3083     }
3084     break;
3085 
3086   case Bytecodes::_dcmpl:
3087     b = pop_pair();
3088     a = pop_pair();
3089     c = _gvn.transform( new CmpD3Node( a, b));
3090     push(c);
3091     break;
3092 
3093   case Bytecodes::_dcmpg:
3094     b = pop_pair();
3095     a = pop_pair();
3096     // Same as dcmpl but need to flip the unordered case.
3097     // Commute the inputs, which negates the result sign except for unordered.
3098     // Flip the unordered as well by using CmpD3 which implements
3099     // unordered-lesser instead of unordered-greater semantics.
3100     // Finally, negate the result bits.  Result is same as using a
3101     // CmpD3Greater except we did it with CmpD3 alone.
3102     c = _gvn.transform( new CmpD3Node( b, a));
3103     c = _gvn.transform( new SubINode(_gvn.intcon(0),c) );
3104     push(c);
3105     break;
3106 
3107 
3108     // Note for longs -&gt; lo word is on TOS, hi word is on TOS - 1
3109   case Bytecodes::_land:
3110     b = pop_pair();
3111     a = pop_pair();
3112     c = _gvn.transform( new AndLNode(a,b) );
3113     push_pair(c);
3114     break;
3115   case Bytecodes::_lor:
3116     b = pop_pair();
3117     a = pop_pair();
3118     c = _gvn.transform( new OrLNode(a,b) );
3119     push_pair(c);
3120     break;
3121   case Bytecodes::_lxor:
3122     b = pop_pair();
3123     a = pop_pair();
3124     c = _gvn.transform( new XorLNode(a,b) );
3125     push_pair(c);
3126     break;
3127 
3128   case Bytecodes::_lshl:
3129     b = pop();                  // the shift count
3130     a = pop_pair();             // value to be shifted
3131     c = _gvn.transform( new LShiftLNode(a,b) );
3132     push_pair(c);
3133     break;
3134   case Bytecodes::_lshr:
3135     b = pop();                  // the shift count
3136     a = pop_pair();             // value to be shifted
3137     c = _gvn.transform( new RShiftLNode(a,b) );
3138     push_pair(c);
3139     break;
3140   case Bytecodes::_lushr:
3141     b = pop();                  // the shift count
3142     a = pop_pair();             // value to be shifted
3143     c = _gvn.transform( new URShiftLNode(a,b) );
3144     push_pair(c);
3145     break;
3146   case Bytecodes::_lmul:
3147     b = pop_pair();
3148     a = pop_pair();
3149     c = _gvn.transform( new MulLNode(a,b) );
3150     push_pair(c);
3151     break;
3152 
3153   case Bytecodes::_lrem:
3154     // Must keep both values on the expression-stack during null-check
3155     assert(peek(0) == top(), &quot;long word order&quot;);
3156     zero_check_long(peek(1));
3157     // Compile-time detect of null-exception?
3158     if (stopped())  return;
3159     b = pop_pair();
3160     a = pop_pair();
3161     c = _gvn.transform( new ModLNode(control(),a,b) );
3162     push_pair(c);
3163     break;
3164 
3165   case Bytecodes::_ldiv:
3166     // Must keep both values on the expression-stack during null-check
3167     assert(peek(0) == top(), &quot;long word order&quot;);
3168     zero_check_long(peek(1));
3169     // Compile-time detect of null-exception?
3170     if (stopped())  return;
3171     b = pop_pair();
3172     a = pop_pair();
3173     c = _gvn.transform( new DivLNode(control(),a,b) );
3174     push_pair(c);
3175     break;
3176 
3177   case Bytecodes::_ladd:
3178     b = pop_pair();
3179     a = pop_pair();
3180     c = _gvn.transform( new AddLNode(a,b) );
3181     push_pair(c);
3182     break;
3183   case Bytecodes::_lsub:
3184     b = pop_pair();
3185     a = pop_pair();
3186     c = _gvn.transform( new SubLNode(a,b) );
3187     push_pair(c);
3188     break;
3189   case Bytecodes::_lcmp:
3190     // Safepoints are now inserted _before_ branches.  The long-compare
3191     // bytecode painfully produces a 3-way value (-1,0,+1) which requires a
3192     // slew of control flow.  These are usually followed by a CmpI vs zero and
3193     // a branch; this pattern then optimizes to the obvious long-compare and
3194     // branch.  However, if the branch is backwards there&#39;s a Safepoint
3195     // inserted.  The inserted Safepoint captures the JVM state at the
3196     // pre-branch point, i.e. it captures the 3-way value.  Thus if a
3197     // long-compare is used to control a loop the debug info will force
3198     // computation of the 3-way value, even though the generated code uses a
3199     // long-compare and branch.  We try to rectify the situation by inserting
3200     // a SafePoint here and have it dominate and kill the safepoint added at a
3201     // following backwards branch.  At this point the JVM state merely holds 2
3202     // longs but not the 3-way value.
3203     if( UseLoopSafepoints ) {
3204       switch( iter().next_bc() ) {
3205       case Bytecodes::_ifgt:
3206       case Bytecodes::_iflt:
3207       case Bytecodes::_ifge:
3208       case Bytecodes::_ifle:
3209       case Bytecodes::_ifne:
3210       case Bytecodes::_ifeq:
3211         // If this is a backwards branch in the bytecodes, add Safepoint
3212         maybe_add_safepoint(iter().next_get_dest());
3213       default:
3214         break;
3215       }
3216     }
3217     b = pop_pair();
3218     a = pop_pair();
3219     c = _gvn.transform( new CmpL3Node( a, b ));
3220     push(c);
3221     break;
3222 
3223   case Bytecodes::_lneg:
3224     a = pop_pair();
3225     b = _gvn.transform( new SubLNode(longcon(0),a));
3226     push_pair(b);
3227     break;
3228   case Bytecodes::_l2i:
3229     a = pop_pair();
3230     push( _gvn.transform( new ConvL2INode(a)));
3231     break;
3232   case Bytecodes::_i2l:
3233     a = pop();
3234     b = _gvn.transform( new ConvI2LNode(a));
3235     push_pair(b);
3236     break;
3237   case Bytecodes::_i2b:
3238     // Sign extend
3239     a = pop();
3240     a = _gvn.transform( new LShiftINode(a,_gvn.intcon(24)) );
3241     a = _gvn.transform( new RShiftINode(a,_gvn.intcon(24)) );
3242     push( a );
3243     break;
3244   case Bytecodes::_i2s:
3245     a = pop();
3246     a = _gvn.transform( new LShiftINode(a,_gvn.intcon(16)) );
3247     a = _gvn.transform( new RShiftINode(a,_gvn.intcon(16)) );
3248     push( a );
3249     break;
3250   case Bytecodes::_i2c:
3251     a = pop();
3252     push( _gvn.transform( new AndINode(a,_gvn.intcon(0xFFFF)) ) );
3253     break;
3254 
3255   case Bytecodes::_i2f:
3256     a = pop();
3257     b = _gvn.transform( new ConvI2FNode(a) ) ;
3258     c = precision_rounding(b);
3259     push (b);
3260     break;
3261 
3262   case Bytecodes::_i2d:
3263     a = pop();
3264     b = _gvn.transform( new ConvI2DNode(a));
3265     push_pair(b);
3266     break;
3267 
3268   case Bytecodes::_iinc:        // Increment local
3269     i = iter().get_index();     // Get local index
3270     set_local( i, _gvn.transform( new AddINode( _gvn.intcon(iter().get_iinc_con()), local(i) ) ) );
3271     break;
3272 
3273   // Exit points of synchronized methods must have an unlock node
3274   case Bytecodes::_return:
3275     return_current(NULL);
3276     break;
3277 
3278   case Bytecodes::_ireturn:
3279   case Bytecodes::_areturn:
3280   case Bytecodes::_freturn:
3281     return_current(pop());
3282     break;
3283   case Bytecodes::_lreturn:
3284     return_current(pop_pair());
3285     break;
3286   case Bytecodes::_dreturn:
3287     return_current(pop_pair());
3288     break;
3289 
3290   case Bytecodes::_athrow:
3291     // null exception oop throws NULL pointer exception
3292     null_check(peek());
3293     if (stopped())  return;
3294     // Hook the thrown exception directly to subsequent handlers.
3295     if (BailoutToInterpreterForThrows) {
3296       // Keep method interpreted from now on.
3297       uncommon_trap(Deoptimization::Reason_unhandled,
3298                     Deoptimization::Action_make_not_compilable);
3299       return;
3300     }
3301     if (env()-&gt;jvmti_can_post_on_exceptions()) {
3302       // check if we must post exception events, take uncommon trap if so (with must_throw = false)
3303       uncommon_trap_if_should_post_on_exceptions(Deoptimization::Reason_unhandled, false);
3304     }
3305     // Here if either can_post_on_exceptions or should_post_on_exceptions is false
3306     add_exception_state(make_exception_state(peek()));
3307     break;
3308 
3309   case Bytecodes::_goto:   // fall through
3310   case Bytecodes::_goto_w: {
3311     int target_bci = (bc() == Bytecodes::_goto) ? iter().get_dest() : iter().get_far_dest();
3312 
3313     // If this is a backwards branch in the bytecodes, add Safepoint
3314     maybe_add_safepoint(target_bci);
3315 
3316     // Update method data
3317     profile_taken_branch(target_bci);
3318 
3319     // Merge the current control into the target basic block
3320     merge(target_bci);
3321 
3322     // See if we can get some profile data and hand it off to the next block
3323     Block *target_block = block()-&gt;successor_for_bci(target_bci);
3324     if (target_block-&gt;pred_count() != 1)  break;
3325     ciMethodData* methodData = method()-&gt;method_data();
3326     if (!methodData-&gt;is_mature())  break;
3327     ciProfileData* data = methodData-&gt;bci_to_data(bci());
3328     assert(data != NULL &amp;&amp; data-&gt;is_JumpData(), &quot;need JumpData for taken branch&quot;);
3329     int taken = ((ciJumpData*)data)-&gt;taken();
3330     taken = method()-&gt;scale_count(taken);
3331     target_block-&gt;set_count(taken);
3332     break;
3333   }
3334 
3335   case Bytecodes::_ifnull:    btest = BoolTest::eq; goto handle_if_null;
3336   case Bytecodes::_ifnonnull: btest = BoolTest::ne; goto handle_if_null;
3337   handle_if_null:
3338     // If this is a backwards branch in the bytecodes, add Safepoint
3339     maybe_add_safepoint(iter().get_dest());
3340     a = null();
3341     b = pop();
3342     if (b-&gt;is_InlineType()) {
3343       // Return constant false because &#39;b&#39; is always non-null
3344       c = _gvn.makecon(TypeInt::CC_GT);
3345     } else {
3346       if (!_gvn.type(b)-&gt;speculative_maybe_null() &amp;&amp;
3347           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
3348         inc_sp(1);
3349         Node* null_ctl = top();
3350         b = null_check_oop(b, &amp;null_ctl, true, true, true);
3351         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
3352         dec_sp(1);
3353       } else if (_gvn.type(b)-&gt;speculative_always_null() &amp;&amp;
3354                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
3355         inc_sp(1);
3356         b = null_assert(b);
3357         dec_sp(1);
3358       }
3359       c = _gvn.transform( new CmpPNode(b, a) );
3360     }
3361     do_ifnull(btest, c);
3362     break;
3363 
3364   case Bytecodes::_if_acmpeq: btest = BoolTest::eq; goto handle_if_acmp;
3365   case Bytecodes::_if_acmpne: btest = BoolTest::ne; goto handle_if_acmp;
3366   handle_if_acmp:
3367     // If this is a backwards branch in the bytecodes, add Safepoint
3368     maybe_add_safepoint(iter().get_dest());
3369     a = pop();
3370     b = pop();
3371     do_acmp(btest, a, b);
3372     break;
3373 
3374   case Bytecodes::_ifeq: btest = BoolTest::eq; goto handle_ifxx;
3375   case Bytecodes::_ifne: btest = BoolTest::ne; goto handle_ifxx;
3376   case Bytecodes::_iflt: btest = BoolTest::lt; goto handle_ifxx;
3377   case Bytecodes::_ifle: btest = BoolTest::le; goto handle_ifxx;
3378   case Bytecodes::_ifgt: btest = BoolTest::gt; goto handle_ifxx;
3379   case Bytecodes::_ifge: btest = BoolTest::ge; goto handle_ifxx;
3380   handle_ifxx:
3381     // If this is a backwards branch in the bytecodes, add Safepoint
3382     maybe_add_safepoint(iter().get_dest());
3383     a = _gvn.intcon(0);
3384     b = pop();
3385     c = _gvn.transform( new CmpINode(b, a) );
3386     do_if(btest, c);
3387     break;
3388 
3389   case Bytecodes::_if_icmpeq: btest = BoolTest::eq; goto handle_if_icmp;
3390   case Bytecodes::_if_icmpne: btest = BoolTest::ne; goto handle_if_icmp;
3391   case Bytecodes::_if_icmplt: btest = BoolTest::lt; goto handle_if_icmp;
3392   case Bytecodes::_if_icmple: btest = BoolTest::le; goto handle_if_icmp;
3393   case Bytecodes::_if_icmpgt: btest = BoolTest::gt; goto handle_if_icmp;
3394   case Bytecodes::_if_icmpge: btest = BoolTest::ge; goto handle_if_icmp;
3395   handle_if_icmp:
3396     // If this is a backwards branch in the bytecodes, add Safepoint
3397     maybe_add_safepoint(iter().get_dest());
3398     a = pop();
3399     b = pop();
3400     c = _gvn.transform( new CmpINode( b, a ) );
3401     do_if(btest, c);
3402     break;
3403 
3404   case Bytecodes::_tableswitch:
3405     do_tableswitch();
3406     break;
3407 
3408   case Bytecodes::_lookupswitch:
3409     do_lookupswitch();
3410     break;
3411 
3412   case Bytecodes::_invokestatic:
3413   case Bytecodes::_invokedynamic:
3414   case Bytecodes::_invokespecial:
3415   case Bytecodes::_invokevirtual:
3416   case Bytecodes::_invokeinterface:
3417     do_call();
3418     break;
3419   case Bytecodes::_checkcast:
3420     do_checkcast();
3421     break;
3422   case Bytecodes::_instanceof:
3423     do_instanceof();
3424     break;
3425   case Bytecodes::_anewarray:
3426     do_newarray();
3427     break;
3428   case Bytecodes::_newarray:
3429     do_newarray((BasicType)iter().get_index());
3430     break;
3431   case Bytecodes::_multianewarray:
3432     do_multianewarray();
3433     break;
3434   case Bytecodes::_new:
3435     do_new();
3436     break;
3437   case Bytecodes::_defaultvalue:
3438     do_defaultvalue();
3439     break;
3440   case Bytecodes::_withfield:
3441     do_withfield();
3442     break;
3443 
3444   case Bytecodes::_jsr:
3445   case Bytecodes::_jsr_w:
3446     do_jsr();
3447     break;
3448 
3449   case Bytecodes::_ret:
3450     do_ret();
3451     break;
3452 
3453 
3454   case Bytecodes::_monitorenter:
3455     do_monitor_enter();
3456     break;
3457 
3458   case Bytecodes::_monitorexit:
3459     do_monitor_exit();
3460     break;
3461 
3462   case Bytecodes::_breakpoint:
3463     // Breakpoint set concurrently to compile
3464     // %%% use an uncommon trap?
3465     C-&gt;record_failure(&quot;breakpoint in method&quot;);
3466     return;
3467 
3468   default:
3469 #ifndef PRODUCT
3470     map()-&gt;dump(99);
3471 #endif
3472     tty-&gt;print(&quot;\nUnhandled bytecode %s\n&quot;, Bytecodes::name(bc()) );
3473     ShouldNotReachHere();
3474   }
3475 
3476 #ifndef PRODUCT
3477   if (C-&gt;should_print(1)) {
3478     IdealGraphPrinter* printer = C-&gt;printer();
3479     char buffer[256];
3480     jio_snprintf(buffer, sizeof(buffer), &quot;Bytecode %d: %s&quot;, bci(), Bytecodes::name(bc()));
3481     bool old = printer-&gt;traverse_outs();
3482     printer-&gt;set_traverse_outs(true);
3483     printer-&gt;print_method(buffer, 4);
3484     printer-&gt;set_traverse_outs(old);
3485   }
3486 #endif
3487 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
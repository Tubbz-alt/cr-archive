<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/valuetypenode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../../test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1140,12 ***</span>
        callee = bytecode.static_target(CHECK_NH);
        if (callee == NULL) {
          THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
        }
      }
<span class="line-modified">!     if (!caller_is_c1 &amp;&amp; callee-&gt;has_scalarized_args() &amp;&amp; callee-&gt;method_holder()-&gt;is_inline_klass()) {</span>
<span class="line-modified">!       // If the receiver is a value type that is passed as fields, no oop is available.</span>
        // Resolve the call without receiver null checking.
        assert(attached_method.not_null() &amp;&amp; !attached_method-&gt;is_abstract(), &quot;must have non-abstract attached method&quot;);
        if (bc == Bytecodes::_invokeinterface) {
          bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls
        }
<span class="line-new-header">--- 1140,13 ---</span>
        callee = bytecode.static_target(CHECK_NH);
        if (callee == NULL) {
          THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
        }
      }
<span class="line-modified">!     if (!caller_is_c1 &amp;&amp; callee-&gt;has_scalarized_args() &amp;&amp; callee-&gt;method_holder()-&gt;is_inline_klass() &amp;&amp;</span>
<span class="line-modified">!         ValueKlass::cast(callee-&gt;method_holder())-&gt;can_be_passed_as_fields()) {</span>
<span class="line-added">+       // If the receiver is an inline type that is passed as fields, no oop is available</span>
        // Resolve the call without receiver null checking.
        assert(attached_method.not_null() &amp;&amp; !attached_method-&gt;is_abstract(), &quot;must have non-abstract attached method&quot;);
        if (bc == Bytecodes::_invokeinterface) {
          bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1283,11 ***</span>
    bool is_nmethod = caller_nm-&gt;is_nmethod();
    bool caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
  
    if (is_virtual) {
      Klass* receiver_klass = NULL;
<span class="line-modified">!     if (InlineTypePassFieldsAsArgs &amp;&amp; !caller_is_c1 &amp;&amp; callee_method-&gt;method_holder()-&gt;is_inline_klass()) {</span>
        // If the receiver is an inline type that is passed as fields, no oop is available
        receiver_klass = callee_method-&gt;method_holder();
      } else {
        assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);
        receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();
<span class="line-new-header">--- 1284,12 ---</span>
    bool is_nmethod = caller_nm-&gt;is_nmethod();
    bool caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
  
    if (is_virtual) {
      Klass* receiver_klass = NULL;
<span class="line-modified">!     if (!caller_is_c1 &amp;&amp; callee_method-&gt;has_scalarized_args() &amp;&amp; callee_method-&gt;method_holder()-&gt;is_inline_klass() &amp;&amp;</span>
<span class="line-added">+         ValueKlass::cast(callee_method-&gt;method_holder())-&gt;can_be_passed_as_fields()) {</span>
        // If the receiver is an inline type that is passed as fields, no oop is available
        receiver_klass = callee_method-&gt;method_holder();
      } else {
        assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);
        receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2744,21 ***</span>
  
  int CompiledEntrySignature::compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver) {
    InstanceKlass* holder = _method-&gt;method_holder();
    sig_cc = new GrowableArray&lt;SigEntry&gt;(_method-&gt;size_of_parameters());
    if (!_method-&gt;is_static()) {
<span class="line-modified">!     if (holder-&gt;is_inline_klass() &amp;&amp; scalar_receiver &amp;&amp; ValueKlass::cast(holder)-&gt;is_scalarizable()) {</span>
        sig_cc-&gt;appendAll(ValueKlass::cast(holder)-&gt;extended_sig());
      } else {
        SigEntry::add_entry(sig_cc, T_OBJECT);
      }
    }
    Thread* THREAD = Thread::current();
    for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
      if (ss.type() == T_VALUETYPE) {
        ValueKlass* vk = ss.as_value_klass(holder);
<span class="line-modified">!       if (vk-&gt;is_scalarizable()) {</span>
          sig_cc-&gt;appendAll(vk-&gt;extended_sig());
        } else {
          SigEntry::add_entry(sig_cc, T_OBJECT);
        }
      } else {
<span class="line-new-header">--- 2746,21 ---</span>
  
  int CompiledEntrySignature::compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver) {
    InstanceKlass* holder = _method-&gt;method_holder();
    sig_cc = new GrowableArray&lt;SigEntry&gt;(_method-&gt;size_of_parameters());
    if (!_method-&gt;is_static()) {
<span class="line-modified">!     if (holder-&gt;is_inline_klass() &amp;&amp; scalar_receiver &amp;&amp; ValueKlass::cast(holder)-&gt;can_be_passed_as_fields()) {</span>
        sig_cc-&gt;appendAll(ValueKlass::cast(holder)-&gt;extended_sig());
      } else {
        SigEntry::add_entry(sig_cc, T_OBJECT);
      }
    }
    Thread* THREAD = Thread::current();
    for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
      if (ss.type() == T_VALUETYPE) {
        ValueKlass* vk = ss.as_value_klass(holder);
<span class="line-modified">!       if (vk-&gt;can_be_passed_as_fields()) {</span>
          sig_cc-&gt;appendAll(vk-&gt;extended_sig());
        } else {
          SigEntry::add_entry(sig_cc, T_OBJECT);
        }
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2831,27 ***</span>
  
  
  void CompiledEntrySignature::compute_calling_conventions() {
    // Get the (non-scalarized) signature and check for value type arguments
    if (!_method-&gt;is_static()) {
<span class="line-modified">!     if (_method-&gt;method_holder()-&gt;is_inline_klass() &amp;&amp; ValueKlass::cast(_method-&gt;method_holder())-&gt;is_scalarizable()) {</span>
        _has_value_recv = true;
        _num_value_args++;
      }
      SigEntry::add_entry(_sig, T_OBJECT);
    }
    for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
      BasicType bt = ss.type();
      if (bt == T_VALUETYPE) {
<span class="line-modified">!       if (ss.as_value_klass(_method-&gt;method_holder())-&gt;is_scalarizable()) {</span>
          _num_value_args++;
        }
        bt = T_OBJECT;
      }
      SigEntry::add_entry(_sig, bt);
    }
<span class="line-modified">!   if (_method-&gt;is_abstract() &amp;&amp; !(InlineTypePassFieldsAsArgs &amp;&amp; has_value_arg())) {</span>
      return;
    }
  
    // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage
    _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig-&gt;length());
<span class="line-new-header">--- 2833,27 ---</span>
  
  
  void CompiledEntrySignature::compute_calling_conventions() {
    // Get the (non-scalarized) signature and check for value type arguments
    if (!_method-&gt;is_static()) {
<span class="line-modified">!     if (_method-&gt;method_holder()-&gt;is_inline_klass() &amp;&amp; ValueKlass::cast(_method-&gt;method_holder())-&gt;can_be_passed_as_fields()) {</span>
        _has_value_recv = true;
        _num_value_args++;
      }
      SigEntry::add_entry(_sig, T_OBJECT);
    }
    for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
      BasicType bt = ss.type();
      if (bt == T_VALUETYPE) {
<span class="line-modified">!       if (ss.as_value_klass(_method-&gt;method_holder())-&gt;can_be_passed_as_fields()) {</span>
          _num_value_args++;
        }
        bt = T_OBJECT;
      }
      SigEntry::add_entry(_sig, bt);
    }
<span class="line-modified">!   if (_method-&gt;is_abstract() &amp;&amp; !has_value_arg()) {</span>
      return;
    }
  
    // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage
    _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig-&gt;length());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2863,11 ***</span>
    _regs_cc = _regs;
    _regs_cc_ro = _regs;
    _args_on_stack_cc = _args_on_stack;
    _args_on_stack_cc_ro = _args_on_stack;
  
<span class="line-modified">!   if (InlineTypePassFieldsAsArgs &amp;&amp; has_value_arg() &amp;&amp; !_method-&gt;is_native()) {</span>
      _args_on_stack_cc = compute_scalarized_cc(_sig_cc, _regs_cc, /* scalar_receiver = */ true);
  
      _sig_cc_ro = _sig_cc;
      _regs_cc_ro = _regs_cc;
      _args_on_stack_cc_ro = _args_on_stack_cc;
<span class="line-new-header">--- 2865,11 ---</span>
    _regs_cc = _regs;
    _regs_cc_ro = _regs;
    _args_on_stack_cc = _args_on_stack;
    _args_on_stack_cc_ro = _args_on_stack;
  
<span class="line-modified">!   if (has_value_arg() &amp;&amp; !_method-&gt;is_native()) {</span>
      _args_on_stack_cc = compute_scalarized_cc(_sig_cc, _regs_cc, /* scalar_receiver = */ true);
  
      _sig_cc_ro = _sig_cc;
      _regs_cc_ro = _regs_cc;
      _args_on_stack_cc_ro = _args_on_stack_cc;
</pre>
<center><a href="../opto/valuetypenode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../../test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
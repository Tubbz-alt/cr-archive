<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciValueKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="ciValueKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciValueKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 59       // Exact match
 60       return i;
 61     } else if (field_offset &lt; offset &amp;&amp; field_offset &gt; best_offset) {
 62       // No exact match. Save the index of the field with the closest offset that
 63       // is smaller than the given field offset. This index corresponds to the
 64       // flattened value type field that holds the field we are looking for.
 65       best_offset = field_offset;
 66       best_index = i;
 67     }
 68   }
 69   assert(best_index &gt;= 0, &quot;field not found&quot;);
 70   assert(best_offset == offset || _declared_nonstatic_fields-&gt;at(best_index)-&gt;type()-&gt;is_valuetype(), &quot;offset should match for non-VTs&quot;);
 71   return best_index;
 72 }
 73 
 74 // Are arrays containing this value type flattened?
 75 bool ciValueKlass::flatten_array() const {
 76   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;flatten_array();)
 77 }
 78 










 79 // Can this value type be returned as multiple values?
 80 bool ciValueKlass::can_be_returned_as_fields() const {
 81   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;can_be_returned_as_fields();)
 82 }
 83 
<span class="line-modified"> 84 // Can this value type be scalarized?</span>
<span class="line-modified"> 85 bool ciValueKlass::is_scalarizable() const {</span>
<span class="line-removed"> 86   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;is_scalarizable();)</span>
 87 }
 88 
 89 // When passing a value type&#39;s fields as arguments, count the number
 90 // of argument slots that are needed
 91 int ciValueKlass::value_arg_slots() {
 92   int slots = 0;
 93   for (int j = 0; j &lt; nof_nonstatic_fields(); j++) {
 94     ciField* field = nonstatic_field_at(j);
 95     slots += type2size[field-&gt;type()-&gt;basic_type()];
 96   }
 97   return slots;
 98 }
 99 
100 // Offset of the default oop in the mirror
101 int ciValueKlass::default_value_offset() const {
102   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;default_value_offset();)
103 }
104 
105 ciInstance* ciValueKlass::default_value_instance() const {
106   GUARDED_VM_ENTRY(
</pre>
</td>
<td>
<hr />
<pre>
 59       // Exact match
 60       return i;
 61     } else if (field_offset &lt; offset &amp;&amp; field_offset &gt; best_offset) {
 62       // No exact match. Save the index of the field with the closest offset that
 63       // is smaller than the given field offset. This index corresponds to the
 64       // flattened value type field that holds the field we are looking for.
 65       best_offset = field_offset;
 66       best_index = i;
 67     }
 68   }
 69   assert(best_index &gt;= 0, &quot;field not found&quot;);
 70   assert(best_offset == offset || _declared_nonstatic_fields-&gt;at(best_index)-&gt;type()-&gt;is_valuetype(), &quot;offset should match for non-VTs&quot;);
 71   return best_index;
 72 }
 73 
 74 // Are arrays containing this value type flattened?
 75 bool ciValueKlass::flatten_array() const {
 76   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;flatten_array();)
 77 }
 78 
<span class="line-added"> 79 // Can this value type be scalarized?</span>
<span class="line-added"> 80 bool ciValueKlass::is_scalarizable() const {</span>
<span class="line-added"> 81   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;is_scalarizable();)</span>
<span class="line-added"> 82 }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 // Can this value type be passed as multiple values?</span>
<span class="line-added"> 85 bool ciValueKlass::can_be_passed_as_fields() const {</span>
<span class="line-added"> 86   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;can_be_passed_as_fields();)</span>
<span class="line-added"> 87 }</span>
<span class="line-added"> 88 </span>
 89 // Can this value type be returned as multiple values?
 90 bool ciValueKlass::can_be_returned_as_fields() const {
 91   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;can_be_returned_as_fields();)
 92 }
 93 
<span class="line-modified"> 94 bool ciValueKlass::is_empty() const {</span>
<span class="line-modified"> 95   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;is_empty_inline_type();)</span>

 96 }
 97 
 98 // When passing a value type&#39;s fields as arguments, count the number
 99 // of argument slots that are needed
100 int ciValueKlass::value_arg_slots() {
101   int slots = 0;
102   for (int j = 0; j &lt; nof_nonstatic_fields(); j++) {
103     ciField* field = nonstatic_field_at(j);
104     slots += type2size[field-&gt;type()-&gt;basic_type()];
105   }
106   return slots;
107 }
108 
109 // Offset of the default oop in the mirror
110 int ciValueKlass::default_value_offset() const {
111   GUARDED_VM_ENTRY(return to_ValueKlass()-&gt;default_value_offset();)
112 }
113 
114 ciInstance* ciValueKlass::default_value_instance() const {
115   GUARDED_VM_ENTRY(
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="ciValueKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/valueKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2020   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2021 }
2022 
2023 // Make a TypeTuple from the domain of a method signature
2024 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
2025   ciSignature* sig = method-&gt;signature();
2026   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());
2027 
2028   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);
2029   if (vt_fields_as_args) {
2030     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {
2031       arg_cnt += type2size[(*sig_cc)._bt];
2032     }
2033     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());
2034   }
2035 
2036   uint pos = TypeFunc::Parms;
2037   const Type** field_array = fields(arg_cnt);
2038   if (!method-&gt;is_static()) {
2039     ciInstanceKlass* recv = method-&gt;holder();
<span class="line-modified">2040     if (vt_fields_as_args &amp;&amp; recv-&gt;is_valuetype() &amp;&amp; recv-&gt;as_value_klass()-&gt;is_scalarizable()) {</span>
2041       collect_value_fields(recv-&gt;as_value_klass(), field_array, pos, sig_cc);
2042     } else {
2043       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
2044       if (vt_fields_as_args) {
2045         ++sig_cc;
2046       }
2047     }
2048   }
2049 
2050   int i = 0;
2051   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2052     ciType* type = sig-&gt;type_at(i);
2053     BasicType bt = type-&gt;basic_type();
2054     bool is_flattened = false;
2055 
2056     switch (bt) {
2057     case T_LONG:
2058       field_array[pos++] = TypeLong::LONG;
2059       field_array[pos++] = Type::HALF;
2060       break;
2061     case T_DOUBLE:
2062       field_array[pos++] = Type::DOUBLE;
2063       field_array[pos++] = Type::HALF;
2064       break;
2065     case T_OBJECT:
2066     case T_ARRAY:
2067     case T_FLOAT:
2068     case T_INT:
2069       field_array[pos++] = get_const_type(type);
2070       break;
2071     case T_BOOLEAN:
2072     case T_CHAR:
2073     case T_BYTE:
2074     case T_SHORT:
2075       field_array[pos++] = TypeInt::INT;
2076       break;
2077     case T_VALUETYPE: {
2078       bool never_null = sig-&gt;is_never_null_at(i);
<span class="line-modified">2079       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;is_scalarizable() &amp;&amp; never_null) {</span>
2080         is_flattened = true;
2081         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);
2082       } else {
2083         field_array[pos++] = get_const_type(type)-&gt;join_speculative(never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2084       }
2085       break;
2086     }
2087     default:
2088       ShouldNotReachHere();
2089     }
2090     // Skip reserved arguments
2091     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2092       field_array[pos++] = Type::get_const_basic_type(bt);
2093       if (type2size[bt] == 2) {
2094         field_array[pos++] = Type::HALF;
2095       }
2096     }
2097     i++;
2098   }
2099   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);
</pre>
</td>
<td>
<hr />
<pre>
2020   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2021 }
2022 
2023 // Make a TypeTuple from the domain of a method signature
2024 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
2025   ciSignature* sig = method-&gt;signature();
2026   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());
2027 
2028   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);
2029   if (vt_fields_as_args) {
2030     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {
2031       arg_cnt += type2size[(*sig_cc)._bt];
2032     }
2033     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());
2034   }
2035 
2036   uint pos = TypeFunc::Parms;
2037   const Type** field_array = fields(arg_cnt);
2038   if (!method-&gt;is_static()) {
2039     ciInstanceKlass* recv = method-&gt;holder();
<span class="line-modified">2040     if (vt_fields_as_args &amp;&amp; recv-&gt;is_valuetype() &amp;&amp; recv-&gt;as_value_klass()-&gt;can_be_passed_as_fields()) {</span>
2041       collect_value_fields(recv-&gt;as_value_klass(), field_array, pos, sig_cc);
2042     } else {
2043       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
2044       if (vt_fields_as_args) {
2045         ++sig_cc;
2046       }
2047     }
2048   }
2049 
2050   int i = 0;
2051   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2052     ciType* type = sig-&gt;type_at(i);
2053     BasicType bt = type-&gt;basic_type();
2054     bool is_flattened = false;
2055 
2056     switch (bt) {
2057     case T_LONG:
2058       field_array[pos++] = TypeLong::LONG;
2059       field_array[pos++] = Type::HALF;
2060       break;
2061     case T_DOUBLE:
2062       field_array[pos++] = Type::DOUBLE;
2063       field_array[pos++] = Type::HALF;
2064       break;
2065     case T_OBJECT:
2066     case T_ARRAY:
2067     case T_FLOAT:
2068     case T_INT:
2069       field_array[pos++] = get_const_type(type);
2070       break;
2071     case T_BOOLEAN:
2072     case T_CHAR:
2073     case T_BYTE:
2074     case T_SHORT:
2075       field_array[pos++] = TypeInt::INT;
2076       break;
2077     case T_VALUETYPE: {
2078       bool never_null = sig-&gt;is_never_null_at(i);
<span class="line-modified">2079       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;can_be_passed_as_fields() &amp;&amp; never_null) {</span>
2080         is_flattened = true;
2081         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);
2082       } else {
2083         field_array[pos++] = get_const_type(type)-&gt;join_speculative(never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2084       }
2085       break;
2086     }
2087     default:
2088       ShouldNotReachHere();
2089     }
2090     // Skip reserved arguments
2091     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2092       field_array[pos++] = Type::get_const_basic_type(bt);
2093       if (type2size[bt] == 2) {
2094         field_array[pos++] = Type::HALF;
2095       }
2096     }
2097     i++;
2098   }
2099   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../oops/valueKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
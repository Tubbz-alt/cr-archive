diff a/src/hotspot/share/opto/type.cpp b/src/hotspot/share/opto/type.cpp
--- a/src/hotspot/share/opto/type.cpp
+++ b/src/hotspot/share/opto/type.cpp
@@ -2035,11 +2035,11 @@
 
   uint pos = TypeFunc::Parms;
   const Type** field_array = fields(arg_cnt);
   if (!method->is_static()) {
     ciInstanceKlass* recv = method->holder();
-    if (vt_fields_as_args && recv->is_valuetype() && recv->as_value_klass()->is_scalarizable()) {
+    if (vt_fields_as_args && recv->is_valuetype() && recv->as_value_klass()->can_be_passed_as_fields()) {
       collect_value_fields(recv->as_value_klass(), field_array, pos, sig_cc);
     } else {
       field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);
       if (vt_fields_as_args) {
         ++sig_cc;
@@ -2074,11 +2074,11 @@
     case T_SHORT:
       field_array[pos++] = TypeInt::INT;
       break;
     case T_VALUETYPE: {
       bool never_null = sig->is_never_null_at(i);
-      if (vt_fields_as_args && type->as_value_klass()->is_scalarizable() && never_null) {
+      if (vt_fields_as_args && type->as_value_klass()->can_be_passed_as_fields() && never_null) {
         is_flattened = true;
         collect_value_fields(type->as_value_klass(), field_array, pos, sig_cc);
       } else {
         field_array[pos++] = get_const_type(type)->join_speculative(never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
       }

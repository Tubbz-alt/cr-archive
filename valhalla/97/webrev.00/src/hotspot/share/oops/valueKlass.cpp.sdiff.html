<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/valueKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciValueKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/valueKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
306       if (bt == T_VALUETYPE) {
307         bt = T_OBJECT;
308       }
309       SigEntry::add_entry(sig, bt, offset);
310       count += type2size[bt];
311     }
312   }
313   int offset = base_off + size_helper()*HeapWordSize - (base_off &gt; 0 ? first_field_offset() : 0);
314   SigEntry::add_entry(sig, T_VOID, offset);
315   if (base_off == 0) {
316     sig-&gt;sort(SigEntry::compare);
317   }
318   assert(sig-&gt;at(0)._bt == T_VALUETYPE &amp;&amp; sig-&gt;at(sig-&gt;length()-1)._bt == T_VOID, &quot;broken structure&quot;);
319   return count;
320 }
321 
322 void ValueKlass::initialize_calling_convention(TRAPS) {
323   // Because the pack and unpack handler addresses need to be loadable from generated code,
324   // they are stored at a fixed offset in the klass metadata. Since value type klasses do
325   // not have a vtable, the vtable offset is used to store these addresses.
<span class="line-modified">326   if (is_scalarizable() &amp;&amp; (InlineTypeReturnedAsFields || InlineTypePassFieldsAsArgs)) {</span>
327     ResourceMark rm;
328     GrowableArray&lt;SigEntry&gt; sig_vk;
329     int nb_fields = collect_fields(&amp;sig_vk);
330     Array&lt;SigEntry&gt;* extended_sig = MetadataFactory::new_array&lt;SigEntry&gt;(class_loader_data(), sig_vk.length(), CHECK);
331     *((Array&lt;SigEntry&gt;**)adr_extended_sig()) = extended_sig;
332     for (int i = 0; i &lt; sig_vk.length(); i++) {
333       extended_sig-&gt;at_put(i, sig_vk.at(i));
334     }
<span class="line-modified">335 </span>
<span class="line-removed">336     if (InlineTypeReturnedAsFields) {</span>
337       nb_fields++;
338       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nb_fields);
339       sig_bt[0] = T_METADATA;
340       SigEntry::fill_sig_bt(&amp;sig_vk, sig_bt+1);
341       VMRegPair* regs = NEW_RESOURCE_ARRAY(VMRegPair, nb_fields);
342       int total = SharedRuntime::java_return_convention(sig_bt, regs, nb_fields);
343 
344       if (total &gt; 0) {
345         Array&lt;VMRegPair&gt;* return_regs = MetadataFactory::new_array&lt;VMRegPair&gt;(class_loader_data(), nb_fields, CHECK);
346         *((Array&lt;VMRegPair&gt;**)adr_return_regs()) = return_regs;
347         for (int i = 0; i &lt; nb_fields; i++) {
348           return_regs-&gt;at_put(i, regs[i]);
349         }
350 
351         BufferedValueTypeBlob* buffered_blob = SharedRuntime::generate_buffered_value_type_adapter(this);
352         *((address*)adr_pack_handler()) = buffered_blob-&gt;pack_fields();
353         *((address*)adr_pack_handler_jobject()) = buffered_blob-&gt;pack_fields_jobject();
354         *((address*)adr_unpack_handler()) = buffered_blob-&gt;unpack_fields();
355         assert(CodeCache::find_blob(pack_handler()) == buffered_blob, &quot;lost track of blob&quot;);

356       }
357     }




358   }
359 }
360 
361 void ValueKlass::deallocate_contents(ClassLoaderData* loader_data) {
362   if (extended_sig() != NULL) {
363     MetadataFactory::free_array&lt;SigEntry&gt;(loader_data, extended_sig());
364   }
365   if (return_regs() != NULL) {
366     MetadataFactory::free_array&lt;VMRegPair&gt;(loader_data, return_regs());
367   }
368   cleanup_blobs();
369   InstanceKlass::deallocate_contents(loader_data);
370 }
371 
372 void ValueKlass::cleanup(ValueKlass* ik) {
373   ik-&gt;cleanup_blobs();
374 }
375 
376 void ValueKlass::cleanup_blobs() {
377   if (pack_handler() != NULL) {
378     CodeBlob* buffered_blob = CodeCache::find_blob(pack_handler());
379     assert(buffered_blob-&gt;is_buffered_value_type_blob(), &quot;bad blob type&quot;);
380     BufferBlob::free((BufferBlob*)buffered_blob);
381     *((address*)adr_pack_handler()) = NULL;
382     *((address*)adr_pack_handler_jobject()) = NULL;
383     *((address*)adr_unpack_handler()) = NULL;
384   }
385 }
386 
387 // Can this inline type be scalarized?
388 bool ValueKlass::is_scalarizable() const {
389   return ScalarizeInlineTypes;
390 }
391 





392 // Can this value type be returned as multiple values?
<span class="line-modified">393 bool ValueKlass::can_be_returned_as_fields() const {</span>
<span class="line-modified">394   return return_regs() != NULL;</span>
395 }
396 
397 // Create handles for all oop fields returned in registers that are going to be live across a safepoint
398 void ValueKlass::save_oop_fields(const RegisterMap&amp; reg_map, GrowableArray&lt;Handle&gt;&amp; handles) const {
399   Thread* thread = Thread::current();
400   const Array&lt;SigEntry&gt;* sig_vk = extended_sig();
401   const Array&lt;VMRegPair&gt;* regs = return_regs();
402   int j = 1;
403 
404   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
405     BasicType bt = sig_vk-&gt;at(i)._bt;
406     if (bt == T_OBJECT || bt == T_ARRAY) {
407       VMRegPair pair = regs-&gt;at(j);
408       address loc = reg_map.location(pair.first());
409       oop v = *(oop*)loc;
410       assert(v == NULL || oopDesc::is_oop(v), &quot;not an oop?&quot;);
411       assert(Universe::heap()-&gt;is_in_or_null(v), &quot;must be heap pointer&quot;);
412       handles.push(Handle(thread, v));
413     }
414     if (bt == T_VALUETYPE) {
</pre>
</td>
<td>
<hr />
<pre>
306       if (bt == T_VALUETYPE) {
307         bt = T_OBJECT;
308       }
309       SigEntry::add_entry(sig, bt, offset);
310       count += type2size[bt];
311     }
312   }
313   int offset = base_off + size_helper()*HeapWordSize - (base_off &gt; 0 ? first_field_offset() : 0);
314   SigEntry::add_entry(sig, T_VOID, offset);
315   if (base_off == 0) {
316     sig-&gt;sort(SigEntry::compare);
317   }
318   assert(sig-&gt;at(0)._bt == T_VALUETYPE &amp;&amp; sig-&gt;at(sig-&gt;length()-1)._bt == T_VOID, &quot;broken structure&quot;);
319   return count;
320 }
321 
322 void ValueKlass::initialize_calling_convention(TRAPS) {
323   // Because the pack and unpack handler addresses need to be loadable from generated code,
324   // they are stored at a fixed offset in the klass metadata. Since value type klasses do
325   // not have a vtable, the vtable offset is used to store these addresses.
<span class="line-modified">326   if (InlineTypeReturnedAsFields || InlineTypePassFieldsAsArgs) {</span>
327     ResourceMark rm;
328     GrowableArray&lt;SigEntry&gt; sig_vk;
329     int nb_fields = collect_fields(&amp;sig_vk);
330     Array&lt;SigEntry&gt;* extended_sig = MetadataFactory::new_array&lt;SigEntry&gt;(class_loader_data(), sig_vk.length(), CHECK);
331     *((Array&lt;SigEntry&gt;**)adr_extended_sig()) = extended_sig;
332     for (int i = 0; i &lt; sig_vk.length(); i++) {
333       extended_sig-&gt;at_put(i, sig_vk.at(i));
334     }
<span class="line-modified">335     if (can_be_returned_as_fields(/* init= */ true)) {</span>

336       nb_fields++;
337       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nb_fields);
338       sig_bt[0] = T_METADATA;
339       SigEntry::fill_sig_bt(&amp;sig_vk, sig_bt+1);
340       VMRegPair* regs = NEW_RESOURCE_ARRAY(VMRegPair, nb_fields);
341       int total = SharedRuntime::java_return_convention(sig_bt, regs, nb_fields);
342 
343       if (total &gt; 0) {
344         Array&lt;VMRegPair&gt;* return_regs = MetadataFactory::new_array&lt;VMRegPair&gt;(class_loader_data(), nb_fields, CHECK);
345         *((Array&lt;VMRegPair&gt;**)adr_return_regs()) = return_regs;
346         for (int i = 0; i &lt; nb_fields; i++) {
347           return_regs-&gt;at_put(i, regs[i]);
348         }
349 
350         BufferedValueTypeBlob* buffered_blob = SharedRuntime::generate_buffered_value_type_adapter(this);
351         *((address*)adr_pack_handler()) = buffered_blob-&gt;pack_fields();
352         *((address*)adr_pack_handler_jobject()) = buffered_blob-&gt;pack_fields_jobject();
353         *((address*)adr_unpack_handler()) = buffered_blob-&gt;unpack_fields();
354         assert(CodeCache::find_blob(pack_handler()) == buffered_blob, &quot;lost track of blob&quot;);
<span class="line-added">355         assert(can_be_returned_as_fields(), &quot;sanity&quot;);</span>
356       }
357     }
<span class="line-added">358     if (!can_be_returned_as_fields() &amp;&amp; !can_be_passed_as_fields()) {</span>
<span class="line-added">359       MetadataFactory::free_array&lt;SigEntry&gt;(class_loader_data(), extended_sig);</span>
<span class="line-added">360       assert(return_regs() == NULL, &quot;sanity&quot;);</span>
<span class="line-added">361     }</span>
362   }
363 }
364 
365 void ValueKlass::deallocate_contents(ClassLoaderData* loader_data) {
366   if (extended_sig() != NULL) {
367     MetadataFactory::free_array&lt;SigEntry&gt;(loader_data, extended_sig());
368   }
369   if (return_regs() != NULL) {
370     MetadataFactory::free_array&lt;VMRegPair&gt;(loader_data, return_regs());
371   }
372   cleanup_blobs();
373   InstanceKlass::deallocate_contents(loader_data);
374 }
375 
376 void ValueKlass::cleanup(ValueKlass* ik) {
377   ik-&gt;cleanup_blobs();
378 }
379 
380 void ValueKlass::cleanup_blobs() {
381   if (pack_handler() != NULL) {
382     CodeBlob* buffered_blob = CodeCache::find_blob(pack_handler());
383     assert(buffered_blob-&gt;is_buffered_value_type_blob(), &quot;bad blob type&quot;);
384     BufferBlob::free((BufferBlob*)buffered_blob);
385     *((address*)adr_pack_handler()) = NULL;
386     *((address*)adr_pack_handler_jobject()) = NULL;
387     *((address*)adr_unpack_handler()) = NULL;
388   }
389 }
390 
391 // Can this inline type be scalarized?
392 bool ValueKlass::is_scalarizable() const {
393   return ScalarizeInlineTypes;
394 }
395 
<span class="line-added">396 // Can this value type be passed as multiple values?</span>
<span class="line-added">397 bool ValueKlass::can_be_passed_as_fields() const {</span>
<span class="line-added">398   return InlineTypePassFieldsAsArgs &amp;&amp; is_scalarizable() &amp;&amp; !is_empty_inline_type();</span>
<span class="line-added">399 }</span>
<span class="line-added">400 </span>
401 // Can this value type be returned as multiple values?
<span class="line-modified">402 bool ValueKlass::can_be_returned_as_fields(bool init) const {</span>
<span class="line-modified">403   return InlineTypeReturnedAsFields &amp;&amp; is_scalarizable() &amp;&amp; !is_empty_inline_type() &amp;&amp; (init || return_regs() != NULL);</span>
404 }
405 
406 // Create handles for all oop fields returned in registers that are going to be live across a safepoint
407 void ValueKlass::save_oop_fields(const RegisterMap&amp; reg_map, GrowableArray&lt;Handle&gt;&amp; handles) const {
408   Thread* thread = Thread::current();
409   const Array&lt;SigEntry&gt;* sig_vk = extended_sig();
410   const Array&lt;VMRegPair&gt;* regs = return_regs();
411   int j = 1;
412 
413   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
414     BasicType bt = sig_vk-&gt;at(i)._bt;
415     if (bt == T_OBJECT || bt == T_ARRAY) {
416       VMRegPair pair = regs-&gt;at(j);
417       address loc = reg_map.location(pair.first());
418       oop v = *(oop*)loc;
419       assert(v == NULL || oopDesc::is_oop(v), &quot;not an oop?&quot;);
420       assert(Universe::heap()-&gt;is_in_or_null(v), &quot;must be heap pointer&quot;);
421       handles.push(Handle(thread, v));
422     }
423     if (bt == T_VALUETYPE) {
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciValueKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
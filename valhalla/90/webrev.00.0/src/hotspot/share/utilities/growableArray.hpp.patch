diff a/src/hotspot/share/utilities/growableArray.hpp b/src/hotspot/share/utilities/growableArray.hpp
--- a/src/hotspot/share/utilities/growableArray.hpp
+++ b/src/hotspot/share/utilities/growableArray.hpp
@@ -105,18 +105,17 @@
   bool on_stack () { return _arena == NULL;      }
   bool on_arena () { return _arena >  (Arena*)1;  }
 
   // This GA will use the resource stack for storage if c_heap==false,
   // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.
-  GenericGrowableArray(int initial_size, int initial_len, bool c_heap, MEMFLAGS flags = mtNone) {
+  GenericGrowableArray(int initial_size, int initial_len, MEMFLAGS flags) {
     _len = initial_len;
     _max = initial_size;
     _memflags = flags;
 
-    // memory type has to be specified for C heap allocation
-    assert(!(c_heap && flags == mtNone), "memory type not specified for C heap object");
-
+    assert(_len >= 0 && _len <= _max, "initial_len too big");
+
     assert(_len >= 0 && _len <= _max, "initial_len too big");
     _arena = (c_heap ? (Arena*)1 : NULL);
     set_nesting();
     assert(!on_C_heap() || allocated_on_C_heap(), "growable array must be on C heap if elements are");
     assert(!on_stack() ||
@@ -140,16 +139,10 @@
            "growable array must be on arena or on stack if elements are on arena");
   }
 
   void* raw_allocate(int elementSize);
 
-  // some uses pass the Thread explicitly for speed (4990299 tuning)
-  void* raw_allocate(Thread* thread, int elementSize) {
-    assert(on_stack(), "fast ResourceObj path only");
-    return (void*)resource_allocate_bytes(thread, elementSize * _max);
-  }
-
   void free_C_heap(void* elements);
 };
 
 template<class E> class GrowableArrayIterator;
 template<class E, class UnaryPredicate> class GrowableArrayFilterIterator;
@@ -167,28 +160,24 @@
   E*     _data;         // data array
 
   void grow(int j);
   void raw_at_put_grow(int i, const E& p, const E& fill);
   void  clear_and_deallocate();
- public:
-  GrowableArray(Thread* thread, int initial_size) : GenericGrowableArray(initial_size, 0, false) {
-    _data = (E*)raw_allocate(thread, sizeof(E));
-    for (int i = 0; i < _max; i++) ::new ((void*)&_data[i]) E();
-  }
-
-  GrowableArray(int initial_size, bool C_heap = false, MEMFLAGS F = mtInternal)
+
+public:
+  GrowableArray(int initial_size, MEMFLAGS F = mtNone)
     : GenericGrowableArray(initial_size, 0, C_heap, F) {
     _data = (E*)raw_allocate(sizeof(E));
 // Needed for Visual Studio 2012 and older
 #ifdef _MSC_VER
 #pragma warning(suppress: 4345)
 #endif
     for (int i = 0; i < _max; i++) ::new ((void*)&_data[i]) E();
   }
 
-  GrowableArray(int initial_size, int initial_len, const E& filler, bool C_heap = false, MEMFLAGS memflags = mtInternal)
-    : GenericGrowableArray(initial_size, initial_len, C_heap, memflags) {
+  GrowableArray(int initial_size, int initial_len, const E& filler, MEMFLAGS memflags = mtNone)
+    : GenericGrowableArray(initial_size, initial_len, memflags) {
     _data = (E*)raw_allocate(sizeof(E));
     int i = 0;
     for (; i < _len; i++) ::new ((void*)&_data[i]) E(filler);
     for (; i < _max; i++) ::new ((void*)&_data[i]) E();
   }
@@ -202,11 +191,11 @@
     int i = 0;
     for (; i < _len; i++) ::new ((void*)&_data[i]) E(filler);
     for (; i < _max; i++) ::new ((void*)&_data[i]) E();
   }
 
-  GrowableArray() : GenericGrowableArray(2, 0, false) {
+  GrowableArray() : GenericGrowableArray(2, 0, mtNone) {
     _data = (E*)raw_allocate(sizeof(E));
     ::new ((void*)&_data[0]) E();
     ::new ((void*)&_data[1]) E();
   }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../services/heapDumper.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/Class.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/growableArray.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 105,18 ***</span>
    bool on_stack () { return _arena == NULL;      }
    bool on_arena () { return _arena &gt;  (Arena*)1;  }
  
    // This GA will use the resource stack for storage if c_heap==false,
    // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.
<span class="line-modified">!   GenericGrowableArray(int initial_size, int initial_len, bool c_heap, MEMFLAGS flags = mtNone) {</span>
      _len = initial_len;
      _max = initial_size;
      _memflags = flags;
  
<span class="line-modified">!     // memory type has to be specified for C heap allocation</span>
<span class="line-modified">!     assert(!(c_heap &amp;&amp; flags == mtNone), &quot;memory type not specified for C heap object&quot;);</span>
<span class="line-removed">- </span>
      const bool c_heap = flags != mtNone;
      _arena = (c_heap ? (Arena*)1 : NULL);
      set_nesting();
      assert(!on_C_heap() || allocated_on_C_heap(), &quot;growable array must be on C heap if elements are&quot;);
      assert(!on_stack() ||
<span class="line-new-header">--- 105,17 ---</span>
    bool on_stack () { return _arena == NULL;      }
    bool on_arena () { return _arena &gt;  (Arena*)1;  }
  
    // This GA will use the resource stack for storage if c_heap==false,
    // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.
<span class="line-modified">!   GenericGrowableArray(int initial_size, int initial_len, MEMFLAGS flags) {</span>
      _len = initial_len;
      _max = initial_size;
      _memflags = flags;
  
<span class="line-modified">!     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);</span>
<span class="line-modified">! </span>
      const bool c_heap = flags != mtNone;
      _arena = (c_heap ? (Arena*)1 : NULL);
      set_nesting();
      assert(!on_C_heap() || allocated_on_C_heap(), &quot;growable array must be on C heap if elements are&quot;);
      assert(!on_stack() ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,16 ***</span>
             &quot;growable array must be on arena or on stack if elements are on arena&quot;);
    }
  
    void* raw_allocate(int elementSize);
  
<span class="line-removed">-   // some uses pass the Thread explicitly for speed (4990299 tuning)</span>
<span class="line-removed">-   void* raw_allocate(Thread* thread, int elementSize) {</span>
<span class="line-removed">-     assert(on_stack(), &quot;fast ResourceObj path only&quot;);</span>
<span class="line-removed">-     return (void*)resource_allocate_bytes(thread, elementSize * _max);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    void free_C_heap(void* elements);
  };
  
  template&lt;class E&gt; class GrowableArrayIterator;
  template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;
<span class="line-new-header">--- 139,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,28 ***</span>
    E*     _data;         // data array
  
    void grow(int j);
    void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);
    void  clear_and_deallocate();
<span class="line-modified">!  public:</span>
<span class="line-modified">!   GrowableArray(Thread* thread, int initial_size) : GenericGrowableArray(initial_size, 0, false) {</span>
<span class="line-modified">!     _data = (E*)raw_allocate(thread, sizeof(E));</span>
<span class="line-removed">-     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   GrowableArray(int initial_size, bool C_heap = false, MEMFLAGS F = mtInternal)</span>
      : GenericGrowableArray(initial_size, 0, F) {
      _data = (E*)raw_allocate(sizeof(E));
  // Needed for Visual Studio 2012 and older
  #ifdef _MSC_VER
  #pragma warning(suppress: 4345)
  #endif
      for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
    }
  
<span class="line-modified">!   GrowableArray(int initial_size, int initial_len, const E&amp; filler, bool C_heap = false, MEMFLAGS memflags = mtInternal)</span>
<span class="line-modified">!     : GenericGrowableArray(initial_size, initial_len, C_heap, memflags) {</span>
      _data = (E*)raw_allocate(sizeof(E));
      int i = 0;
      for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
      for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
    }
<span class="line-new-header">--- 160,24 ---</span>
    E*     _data;         // data array
  
    void grow(int j);
    void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);
    void  clear_and_deallocate();
<span class="line-modified">! </span>
<span class="line-modified">! public:</span>
<span class="line-modified">!   GrowableArray(int initial_size, MEMFLAGS F = mtNone)</span>
      : GenericGrowableArray(initial_size, 0, F) {
      _data = (E*)raw_allocate(sizeof(E));
  // Needed for Visual Studio 2012 and older
  #ifdef _MSC_VER
  #pragma warning(suppress: 4345)
  #endif
      for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
    }
  
<span class="line-modified">!   GrowableArray(int initial_size, int initial_len, const E&amp; filler, MEMFLAGS memflags = mtNone)</span>
<span class="line-modified">!     : GenericGrowableArray(initial_size, initial_len, memflags) {</span>
      _data = (E*)raw_allocate(sizeof(E));
      int i = 0;
      for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
      for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,11 ***</span>
      int i = 0;
      for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
      for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
    }
  
<span class="line-modified">!   GrowableArray() : GenericGrowableArray(2, 0, false) {</span>
      _data = (E*)raw_allocate(sizeof(E));
      ::new ((void*)&amp;_data[0]) E();
      ::new ((void*)&amp;_data[1]) E();
    }
  
<span class="line-new-header">--- 191,11 ---</span>
      int i = 0;
      for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
      for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
    }
  
<span class="line-modified">!   GrowableArray() : GenericGrowableArray(2, 0, mtNone) {</span>
      _data = (E*)raw_allocate(sizeof(E));
      ::new ((void*)&amp;_data[0]) E();
      ::new ((void*)&amp;_data[1]) E();
    }
  
</pre>
<center><a href="../services/heapDumper.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/Class.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_GROWABLEARRAY_HPP
 26 #define SHARE_UTILITIES_GROWABLEARRAY_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/array.hpp&quot;
 30 #include &quot;oops/oop.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 #include &quot;utilities/ostream.hpp&quot;
 34 #include &quot;utilities/powerOfTwo.hpp&quot;
 35 
 36 // A growable array.
 37 
 38 /*************************************************************************/
 39 /*                                                                       */
 40 /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
 41 /*                                                                       */
 42 /* Should you use GrowableArrays to contain handles you must be certain  */
 43 /* the the GrowableArray does not outlive the HandleMark that contains   */
 44 /* the handles. Since GrowableArrays are typically resource allocated    */
 45 /* the following is an example of INCORRECT CODE,                        */
 46 /*                                                                       */
 47 /* ResourceMark rm;                                                      */
 48 /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
 49 /* if (blah) {                                                           */
 50 /*    while (...) {                                                      */
 51 /*      HandleMark hm;                                                   */
 52 /*      ...                                                              */
 53 /*      Handle h(THREAD, some_oop);                                      */
 54 /*      arr-&gt;append(h);                                                  */
 55 /*    }                                                                  */
 56 /* }                                                                     */
 57 /* if (arr-&gt;length() != 0 ) {                                            */
 58 /*    oop bad_oop = arr-&gt;at(0)(); // Handle is BAD HERE.                 */
 59 /*    ...                                                                */
 60 /* }                                                                     */
 61 /*                                                                       */
 62 /* If the GrowableArrays you are creating is C_Heap allocated then it    */
 63 /* hould not old handles since the handles could trivially try and       */
 64 /* outlive their HandleMark. In some situations you might need to do     */
 65 /* this and it would be legal but be very careful and see if you can do  */
 66 /* the code in some other manner.                                        */
 67 /*                                                                       */
 68 /*************************************************************************/
 69 
 70 // To call default constructor the placement operator new() is used.
 71 // It should be empty (it only returns the passed void* pointer).
 72 // The definition of placement operator new(size_t, void*) in the &lt;new&gt;.
 73 
 74 #include &lt;new&gt;
 75 
 76 // Need the correct linkage to call qsort without warnings
 77 extern &quot;C&quot; {
 78   typedef int (*_sort_Fn)(const void *, const void *);
 79 }
 80 
 81 class GenericGrowableArray : public ResourceObj {
 82   friend class VMStructs;
 83 
 84  protected:
 85   int    _len;          // current length
 86   int    _max;          // maximum length
 87   Arena* _arena;        // Indicates where allocation occurs:
 88                         //   0 means default ResourceArea
 89                         //   1 means on C heap
 90                         //   otherwise, allocate in _arena
 91 
 92   MEMFLAGS   _memflags;   // memory type if allocation in C heap
 93 
 94 #ifdef ASSERT
 95   int    _nesting;      // resource area nesting at creation
 96   void   set_nesting();
 97   void   check_nesting();
 98 #else
 99 #define  set_nesting();
100 #define  check_nesting();
101 #endif
102 
103   // Where are we going to allocate memory?
104   bool on_C_heap() { return _arena == (Arena*)1; }
105   bool on_stack () { return _arena == NULL;      }
106   bool on_arena () { return _arena &gt;  (Arena*)1;  }
107 
108   // This GA will use the resource stack for storage if c_heap==false,
109   // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.
<a name="1" id="anc1"></a><span class="line-modified">110   GenericGrowableArray(int initial_size, int initial_len, bool c_heap, MEMFLAGS flags = mtNone) {</span>
111     _len = initial_len;
112     _max = initial_size;
113     _memflags = flags;
114 
<a name="2" id="anc2"></a><span class="line-modified">115     // memory type has to be specified for C heap allocation</span>
<span class="line-modified">116     assert(!(c_heap &amp;&amp; flags == mtNone), &quot;memory type not specified for C heap object&quot;);</span>
<span class="line-removed">117 </span>
118     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
119     _arena = (c_heap ? (Arena*)1 : NULL);
120     set_nesting();
121     assert(!on_C_heap() || allocated_on_C_heap(), &quot;growable array must be on C heap if elements are&quot;);
122     assert(!on_stack() ||
123            (allocated_on_res_area() || allocated_on_stack()),
124            &quot;growable array must be on stack if elements are not on arena and not on C heap&quot;);
125   }
126 
127   // This GA will use the given arena for storage.
128   // Consider using new(arena) GrowableArray&lt;T&gt; to allocate the header.
129   GenericGrowableArray(Arena* arena, int initial_size, int initial_len) {
130     _len = initial_len;
131     _max = initial_size;
132     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
133     _arena = arena;
134     _memflags = mtNone;
135 
136     assert(on_arena(), &quot;arena has taken on reserved value 0 or 1&quot;);
137     // Relax next assert to allow object allocation on resource area,
138     // on stack or embedded into an other object.
139     assert(allocated_on_arena() || allocated_on_stack(),
140            &quot;growable array must be on arena or on stack if elements are on arena&quot;);
141   }
142 
143   void* raw_allocate(int elementSize);
144 
<a name="3" id="anc3"></a><span class="line-removed">145   // some uses pass the Thread explicitly for speed (4990299 tuning)</span>
<span class="line-removed">146   void* raw_allocate(Thread* thread, int elementSize) {</span>
<span class="line-removed">147     assert(on_stack(), &quot;fast ResourceObj path only&quot;);</span>
<span class="line-removed">148     return (void*)resource_allocate_bytes(thread, elementSize * _max);</span>
<span class="line-removed">149   }</span>
<span class="line-removed">150 </span>
151   void free_C_heap(void* elements);
152 };
153 
154 template&lt;class E&gt; class GrowableArrayIterator;
155 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;
156 
157 template&lt;class E&gt;
158 class CompareClosure : public Closure {
159 public:
160     virtual int do_compare(const E&amp;, const E&amp;) = 0;
161 };
162 
163 template&lt;class E&gt; class GrowableArray : public GenericGrowableArray {
164   friend class VMStructs;
165 
166  private:
167   E*     _data;         // data array
168 
169   void grow(int j);
170   void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);
171   void  clear_and_deallocate();
<a name="4" id="anc4"></a><span class="line-modified">172  public:</span>
<span class="line-modified">173   GrowableArray(Thread* thread, int initial_size) : GenericGrowableArray(initial_size, 0, false) {</span>
<span class="line-modified">174     _data = (E*)raw_allocate(thread, sizeof(E));</span>
<span class="line-removed">175     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();</span>
<span class="line-removed">176   }</span>
<span class="line-removed">177 </span>
<span class="line-removed">178   GrowableArray(int initial_size, bool C_heap = false, MEMFLAGS F = mtInternal)</span>
179     : GenericGrowableArray(initial_size, 0, C_heap, F) {
180     _data = (E*)raw_allocate(sizeof(E));
181 // Needed for Visual Studio 2012 and older
182 #ifdef _MSC_VER
183 #pragma warning(suppress: 4345)
184 #endif
185     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
186   }
187 
<a name="5" id="anc5"></a><span class="line-modified">188   GrowableArray(int initial_size, int initial_len, const E&amp; filler, bool C_heap = false, MEMFLAGS memflags = mtInternal)</span>
<span class="line-modified">189     : GenericGrowableArray(initial_size, initial_len, C_heap, memflags) {</span>
190     _data = (E*)raw_allocate(sizeof(E));
191     int i = 0;
192     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
193     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
194   }
195 
196   // Watch out, if filler was generated by a constructor, the destuctor might
197   // be called on the original object invalidating all the copies made here.
198   // Carefully design the copy constructor.
199   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) :
200       GenericGrowableArray(arena, initial_size, initial_len) {
201     _data = (E*)raw_allocate(sizeof(E));
202     int i = 0;
203     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
204     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
205   }
206 
<a name="6" id="anc6"></a><span class="line-modified">207   GrowableArray() : GenericGrowableArray(2, 0, false) {</span>
208     _data = (E*)raw_allocate(sizeof(E));
209     ::new ((void*)&amp;_data[0]) E();
210     ::new ((void*)&amp;_data[1]) E();
211   }
212 
213                                 // Does nothing for resource and arena objects
214   ~GrowableArray()              { if (on_C_heap()) clear_and_deallocate(); }
215 
216   void  clear()                 { _len = 0; }
217   int   length() const          { return _len; }
218   int   max_length() const      { return _max; }
219   void  trunc_to(int l)         { assert(l &lt;= _len,&quot;cannot increase length&quot;); _len = l; }
220   bool  is_empty() const        { return _len == 0; }
221   bool  is_nonempty() const     { return _len != 0; }
222   bool  is_full() const         { return _len == _max; }
223   DEBUG_ONLY(E* data_addr() const      { return _data; })
224 
225   void print();
226 
227   int append(const E&amp; elem) {
228     check_nesting();
229     if (_len == _max) grow(_len);
230     int idx = _len++;
231     _data[idx] = elem;
232     return idx;
233   }
234 
235   bool append_if_missing(const E&amp; elem) {
236     // Returns TRUE if elem is added.
237     bool missed = !contains(elem);
238     if (missed) append(elem);
239     return missed;
240   }
241 
242   E&amp; at(int i) {
243     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
244     return _data[i];
245   }
246 
247   E const&amp; at(int i) const {
248     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
249     return _data[i];
250   }
251 
252   E* adr_at(int i) const {
253     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
254     return &amp;_data[i];
255   }
256 
257   E first() const {
258     assert(_len &gt; 0, &quot;empty list&quot;);
259     return _data[0];
260   }
261 
262   E top() const {
263     assert(_len &gt; 0, &quot;empty list&quot;);
264     return _data[_len-1];
265   }
266 
267   E last() const {
268     return top();
269   }
270 
271   GrowableArrayIterator&lt;E&gt; begin() const {
272     return GrowableArrayIterator&lt;E&gt;(this, 0);
273   }
274 
275   GrowableArrayIterator&lt;E&gt; end() const {
276     return GrowableArrayIterator&lt;E&gt;(this, length());
277   }
278 
279   void push(const E&amp; elem) { append(elem); }
280 
281   E pop() {
282     assert(_len &gt; 0, &quot;empty list&quot;);
283     return _data[--_len];
284   }
285 
286   void at_put(int i, const E&amp; elem) {
287     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
288     _data[i] = elem;
289   }
290 
291   E at_grow(int i, const E&amp; fill = E()) {
292     assert(0 &lt;= i, &quot;negative index&quot;);
293     check_nesting();
294     if (i &gt;= _len) {
295       if (i &gt;= _max) grow(i);
296       for (int j = _len; j &lt;= i; j++)
297         _data[j] = fill;
298       _len = i+1;
299     }
300     return _data[i];
301   }
302 
303   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {
304     assert(0 &lt;= i, &quot;negative index&quot;);
305     check_nesting();
306     raw_at_put_grow(i, elem, fill);
307   }
308 
309   bool contains(const E&amp; elem) const {
310     for (int i = 0; i &lt; _len; i++) {
311       if (_data[i] == elem) return true;
312     }
313     return false;
314   }
315 
316   int  find(const E&amp; elem) const {
317     for (int i = 0; i &lt; _len; i++) {
318       if (_data[i] == elem) return i;
319     }
320     return -1;
321   }
322 
323   int  find_from_end(const E&amp; elem) const {
324     for (int i = _len-1; i &gt;= 0; i--) {
325       if (_data[i] == elem) return i;
326     }
327     return -1;
328   }
329 
330   int  find(void* token, bool f(void*, E)) const {
331     for (int i = 0; i &lt; _len; i++) {
332       if (f(token, _data[i])) return i;
333     }
334     return -1;
335   }
336 
337   int  find_from_end(void* token, bool f(void*, E)) const {
338     // start at the end of the array
339     for (int i = _len-1; i &gt;= 0; i--) {
340       if (f(token, _data[i])) return i;
341     }
342     return -1;
343   }
344 
345   void remove(const E&amp; elem) {
346     for (int i = 0; i &lt; _len; i++) {
347       if (_data[i] == elem) {
348         for (int j = i + 1; j &lt; _len; j++) _data[j-1] = _data[j];
349         _len--;
350         return;
351       }
352     }
353     ShouldNotReachHere();
354   }
355 
356   // The order is preserved.
357   void remove_at(int index) {
358     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
359     for (int j = index + 1; j &lt; _len; j++) _data[j-1] = _data[j];
360     _len--;
361   }
362 
363   // The order is changed.
364   void delete_at(int index) {
365     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
366     if (index &lt; --_len) {
367       // Replace removed element with last one.
368       _data[index] = _data[_len];
369     }
370   }
371 
372   // inserts the given element before the element at index i
373   void insert_before(const int idx, const E&amp; elem) {
374     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);
375     check_nesting();
376     if (_len == _max) grow(_len);
377     for (int j = _len - 1; j &gt;= idx; j--) {
378       _data[j + 1] = _data[j];
379     }
380     _len++;
381     _data[idx] = elem;
382   }
383 
384   void insert_before(const int idx, const GrowableArray&lt;E&gt;* array) {
385     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);
386     check_nesting();
387     int array_len = array-&gt;length();
388     int new_len = _len + array_len;
389     if (new_len &gt;= _max) grow(new_len);
390 
391     for (int j = _len - 1; j &gt;= idx; j--) {
392       _data[j + array_len] = _data[j];
393     }
394 
395     for (int j = 0; j &lt; array_len; j++) {
396       _data[idx + j] = array-&gt;_data[j];
397     }
398 
399     _len += array_len;
400   }
401 
402   void appendAll(const GrowableArray&lt;E&gt;* l) {
403     for (int i = 0; i &lt; l-&gt;_len; i++) {
404       raw_at_put_grow(_len, l-&gt;_data[i], E());
405     }
406   }
407 
408   void appendAll(const Array&lt;E&gt;* l) {
409     for (int i = 0; i &lt; l-&gt;length(); i++) {
410       raw_at_put_grow(_len, l-&gt;at(i), E());
411     }
412   }
413 
414   void sort(int f(E*,E*)) {
415     qsort(_data, length(), sizeof(E), (_sort_Fn)f);
416   }
417   // sort by fixed-stride sub arrays:
418   void sort(int f(E*,E*), int stride) {
419     qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
420   }
421 
422   // Binary search and insertion utility.  Search array for element
423   // matching key according to the static compare function.  Insert
424   // that element is not already in the list.  Assumes the list is
425   // already sorted according to compare function.
426   template &lt;int compare(const E&amp;, const E&amp;)&gt; E insert_sorted(const E&amp; key) {
427     bool found;
428     int location = find_sorted&lt;E, compare&gt;(key, found);
429     if (!found) {
430       insert_before(location, key);
431     }
432     return at(location);
433   }
434 
435   template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
436     found = false;
437     int min = 0;
438     int max = length() - 1;
439 
440     while (max &gt;= min) {
441       int mid = (int)(((uint)max + min) / 2);
442       E value = at(mid);
443       int diff = compare(key, value);
444       if (diff &gt; 0) {
445         min = mid + 1;
446       } else if (diff &lt; 0) {
447         max = mid - 1;
448       } else {
449         found = true;
450         return mid;
451       }
452     }
453     return min;
454   }
455 
456   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {
457     bool found;
458     int location = find_sorted(cc, key, found);
459     if (!found) {
460       insert_before(location, key);
461     }
462     return at(location);
463   }
464 
465   template&lt;typename K&gt;
466   int find_sorted(CompareClosure&lt;E&gt;* cc, const K&amp; key, bool&amp; found) {
467     found = false;
468     int min = 0;
469     int max = length() - 1;
470 
471     while (max &gt;= min) {
472       int mid = (int)(((uint)max + min) / 2);
473       E value = at(mid);
474       int diff = cc-&gt;do_compare(key, value);
475       if (diff &gt; 0) {
476         min = mid + 1;
477       } else if (diff &lt; 0) {
478         max = mid - 1;
479       } else {
480         found = true;
481         return mid;
482       }
483     }
484     return min;
485   }
486 };
487 
488 // Global GrowableArray methods (one instance in the library per each &#39;E&#39; type).
489 
490 template&lt;class E&gt; void GrowableArray&lt;E&gt;::grow(int j) {
491     int old_max = _max;
492     // grow the array by increasing _max to the first power of two larger than the size we need
493     _max = next_power_of_2((uint32_t)j);
494     // j &lt; _max
495     E* newData = (E*)raw_allocate(sizeof(E));
496     int i = 0;
497     for (     ; i &lt; _len; i++) ::new ((void*)&amp;newData[i]) E(_data[i]);
498 // Needed for Visual Studio 2012 and older
499 #ifdef _MSC_VER
500 #pragma warning(suppress: 4345)
501 #endif
502     for (     ; i &lt; _max; i++) ::new ((void*)&amp;newData[i]) E();
503     for (i = 0; i &lt; old_max; i++) _data[i].~E();
504     if (on_C_heap() &amp;&amp; _data != NULL) {
505       free_C_heap(_data);
506     }
507     _data = newData;
508 }
509 
510 template&lt;class E&gt; void GrowableArray&lt;E&gt;::raw_at_put_grow(int i, const E&amp; p, const E&amp; fill) {
511     if (i &gt;= _len) {
512       if (i &gt;= _max) grow(i);
513       for (int j = _len; j &lt; i; j++)
514         _data[j] = fill;
515       _len = i+1;
516     }
517     _data[i] = p;
518 }
519 
520 // This function clears and deallocate the data in the growable array that
521 // has been allocated on the C heap.  It&#39;s not public - called by the
522 // destructor.
523 template&lt;class E&gt; void GrowableArray&lt;E&gt;::clear_and_deallocate() {
524     assert(on_C_heap(),
525            &quot;clear_and_deallocate should only be called when on C heap&quot;);
526     clear();
527     if (_data != NULL) {
528       for (int i = 0; i &lt; _max; i++) _data[i].~E();
529       free_C_heap(_data);
530       _data = NULL;
531     }
532 }
533 
534 template&lt;class E&gt; void GrowableArray&lt;E&gt;::print() {
535     tty-&gt;print(&quot;Growable Array &quot; INTPTR_FORMAT, this);
536     tty-&gt;print(&quot;: length %ld (_max %ld) { &quot;, _len, _max);
537     for (int i = 0; i &lt; _len; i++) tty-&gt;print(INTPTR_FORMAT &quot; &quot;, *(intptr_t*)&amp;(_data[i]));
538     tty-&gt;print(&quot;}\n&quot;);
539 }
540 
541 // Custom STL-style iterator to iterate over GrowableArrays
542 // It is constructed by invoking GrowableArray::begin() and GrowableArray::end()
543 template&lt;class E&gt; class GrowableArrayIterator : public StackObj {
544   friend class GrowableArray&lt;E&gt;;
545   template&lt;class F, class UnaryPredicate&gt; friend class GrowableArrayFilterIterator;
546 
547  private:
548   const GrowableArray&lt;E&gt;* _array; // GrowableArray we iterate over
549   int _position;                  // The current position in the GrowableArray
550 
551   // Private constructor used in GrowableArray::begin() and GrowableArray::end()
552   GrowableArrayIterator(const GrowableArray&lt;E&gt;* array, int position) : _array(array), _position(position) {
553     assert(0 &lt;= position &amp;&amp; position &lt;= _array-&gt;length(), &quot;illegal position&quot;);
554   }
555 
556  public:
557   GrowableArrayIterator() : _array(NULL), _position(0) { }
558   GrowableArrayIterator&lt;E&gt;&amp; operator++()  { ++_position; return *this; }
559   E operator*()                           { return _array-&gt;at(_position); }
560 
561   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
562     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
563     return _position == rhs._position;
564   }
565 
566   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
567     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
568     return _position != rhs._position;
569   }
570 };
571 
572 // Custom STL-style iterator to iterate over elements of a GrowableArray that satisfy a given predicate
573 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator : public StackObj {
574   friend class GrowableArray&lt;E&gt;;
575 
576  private:
577   const GrowableArray&lt;E&gt;* _array;   // GrowableArray we iterate over
578   int _position;                    // Current position in the GrowableArray
579   UnaryPredicate _predicate;        // Unary predicate the elements of the GrowableArray should satisfy
580 
581  public:
582   GrowableArrayFilterIterator(const GrowableArray&lt;E&gt;* array, UnaryPredicate filter_predicate)
583    : _array(array), _position(0), _predicate(filter_predicate) {
584     // Advance to first element satisfying the predicate
585     while(!at_end() &amp;&amp; !_predicate(_array-&gt;at(_position))) {
586       ++_position;
587     }
588   }
589 
590   GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; operator++() {
591     do {
592       // Advance to next element satisfying the predicate
593       ++_position;
594     } while(!at_end() &amp;&amp; !_predicate(_array-&gt;at(_position)));
595     return *this;
596   }
597 
598   E operator*()   { return _array-&gt;at(_position); }
599 
600   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
601     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
602     return _position == rhs._position;
603   }
604 
605   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
606     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
607     return _position != rhs._position;
608   }
609 
610   bool operator==(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
611     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
612     return _position == rhs._position;
613   }
614 
615   bool operator!=(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
616     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
617     return _position != rhs._position;
618   }
619 
620   bool at_end() const {
621     return _array == NULL || _position == _array-&gt;end()._position;
622   }
623 };
624 
625 // Arrays for basic types
626 typedef GrowableArray&lt;int&gt; intArray;
627 typedef GrowableArray&lt;int&gt; intStack;
628 typedef GrowableArray&lt;bool&gt; boolArray;
629 
630 #endif // SHARE_UTILITIES_GROWABLEARRAY_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
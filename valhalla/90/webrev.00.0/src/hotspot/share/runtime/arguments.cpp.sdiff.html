<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="biasedLocking.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 531   { &quot;BiasedLockingBulkRebiasThreshold&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 532   { &quot;BiasedLockingBulkRevokeThreshold&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 533   { &quot;BiasedLockingDecayTime&quot;,              JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 534   { &quot;UseOptoBiasInlining&quot;,                 JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 535   { &quot;PrintPreciseBiasedLockingStatistics&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 536   { &quot;InitialBootClassLoaderMetaspaceSize&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 537   { &quot;UseLargePagesInMetaspace&quot;,            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 538 
 539   // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
 540   { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
 541   { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
 542   { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
 543 
 544   // -------------- Obsolete Flags - sorted by expired_in --------------
 545   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 546   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 547   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 548   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 549   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 550   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
<span class="line-modified"> 551   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-modified"> 552   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-modified"> 553   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 554   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 555   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 556   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 557   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 558 #ifndef X86</span>
<span class="line-removed"> 559   { &quot;UseSSE&quot;,                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 560 #endif // !X86</span>
<span class="line-removed"> 561   { &quot;UseAdaptiveGCBoundary&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 562   { &quot;MonitorBound&quot;,                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 563 #ifdef AARCH64</span>
<span class="line-removed"> 564   { &quot;UseBarriersForVolatile&quot;,        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
 565 #endif
<span class="line-removed"> 566   { &quot;UseLWPSynchronization&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 567   { &quot;BranchOnRegister&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-removed"> 568   { &quot;LIRFillDelaySlots&quot;,             JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
 569 
 570 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 571   // These entries will generate build errors.  Their purpose is to test the macros.
 572   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 573   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 574   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
 575   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },
 576   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 577   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 578   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 579 #endif
 580 
 581 #ifndef COMPILER2
 582   // These flags were generally available, but are C2 only, now.
 583   { &quot;MaxInlineLevel&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 584   { &quot;MaxRecursiveInlineLevel&quot;,      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 585   { &quot;InlineSmallCode&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 586   { &quot;MaxInlineSize&quot;,                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 587   { &quot;FreqInlineSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 588   { &quot;MaxTrivialSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
</pre>
<hr />
<pre>
1450 bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {
1451   const char* eq = strchr(prop, &#39;=&#39;);
1452   const char* key;
1453   const char* value = &quot;&quot;;
1454 
1455   if (eq == NULL) {
1456     // property doesn&#39;t have a value, thus use passed string
1457     key = prop;
1458   } else {
1459     // property have a value, thus extract it and save to the
1460     // allocated string
1461     size_t key_len = eq - prop;
1462     char* tmp_key = AllocateHeap(key_len + 1, mtArguments);
1463 
1464     jio_snprintf(tmp_key, key_len + 1, &quot;%s&quot;, prop);
1465     key = tmp_key;
1466 
1467     value = &amp;prop[key_len + 1];
1468   }
1469 

1470   if (is_internal_module_property(key) ||
1471       strcmp(key, &quot;jdk.module.main&quot;) == 0) {
1472     MetaspaceShared::disable_optimized_module_handling();
1473     log_info(cds)(&quot;Using optimized module handling disabled due to incompatible property: %s=%s&quot;, key, value);
1474   }

1475 
1476   if (strcmp(key, &quot;java.compiler&quot;) == 0) {
1477     process_java_compiler_argument(value);
1478     // Record value in Arguments, but let it get passed to Java.
1479   } else if (strcmp(key, &quot;sun.java.launcher.is_altjvm&quot;) == 0) {
1480     // sun.java.launcher.is_altjvm property is
1481     // private and is processed in process_sun_java_launcher_properties();
1482     // the sun.java.launcher property is passed on to the java application
1483   } else if (strcmp(key, &quot;sun.boot.library.path&quot;) == 0) {
1484     // append is true, writable is true, internal is false
1485     PropertyList_unique_add(&amp;_system_properties, key, value, AppendProperty,
1486                             WriteableProperty, ExternalProperty);
1487   } else {
1488     if (strcmp(key, &quot;sun.java.command&quot;) == 0) {
1489       char *old_java_command = _java_command;
1490       _java_command = os::strdup_check_oom(value, mtArguments);
1491       if (old_java_command != NULL) {
1492         os::free(old_java_command);
1493       }
1494     } else if (strcmp(key, &quot;java.vendor.url.bug&quot;) == 0) {
</pre>
<hr />
<pre>
2509     } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
2510       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2511       if (*tail == &#39;\0&#39;) {
2512         JavaAssertions::setUserClassDefault(enable);
2513       } else {
2514         assert(*tail == &#39;:&#39;, &quot;bogus match by match_option()&quot;);
2515         JavaAssertions::addOption(tail + 1, enable);
2516       }
2517     // -dsa / -esa / -disablesystemassertions / -enablesystemassertions
2518     } else if (match_option(option, system_assertion_options, &amp;tail, false)) {
2519       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2520       JavaAssertions::setSystemClassDefault(enable);
2521     // -bootclasspath:
2522     } else if (match_option(option, &quot;-Xbootclasspath:&quot;, &amp;tail)) {
2523         jio_fprintf(defaultStream::output_stream(),
2524           &quot;-Xbootclasspath is no longer a supported option.\n&quot;);
2525         return JNI_EINVAL;
2526     // -bootclasspath/a:
2527     } else if (match_option(option, &quot;-Xbootclasspath/a:&quot;, &amp;tail)) {
2528       Arguments::append_sysclasspath(tail);

2529       MetaspaceShared::disable_optimized_module_handling();
2530       log_info(cds)(&quot;Using optimized module handling disabled due to bootclasspath was appended&quot;);

2531     // -bootclasspath/p:
2532     } else if (match_option(option, &quot;-Xbootclasspath/p:&quot;, &amp;tail)) {
2533         jio_fprintf(defaultStream::output_stream(),
2534           &quot;-Xbootclasspath/p is no longer a supported option.\n&quot;);
2535         return JNI_EINVAL;
2536     // -Xrun
2537     } else if (match_option(option, &quot;-Xrun&quot;, &amp;tail)) {
2538       if (tail != NULL) {
2539         const char* pos = strchr(tail, &#39;:&#39;);
2540         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2541         char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2542         jio_snprintf(name, len + 1, &quot;%s&quot;, tail);
2543 
2544         char *options = NULL;
2545         if(pos != NULL) {
2546           size_t len2 = strlen(pos+1) + 1; // options start after &#39;:&#39;.  Final zero must be copied.
2547           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
2548         }
2549 #if !INCLUDE_JVMTI
2550         if (strcmp(name, &quot;jdwp&quot;) == 0) {
</pre>
<hr />
<pre>
3131   fix_appclasspath();
3132 
3133   return JNI_OK;
3134 }
3135 
3136 void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {
3137   // For java.base check for duplicate --patch-module options being specified on the command line.
3138   // This check is only required for java.base, all other duplicate module specifications
3139   // will be checked during module system initialization.  The module system initialization
3140   // will throw an ExceptionInInitializerError if this situation occurs.
3141   if (strcmp(module_name, JAVA_BASE_NAME) == 0) {
3142     if (*patch_mod_javabase) {
3143       vm_exit_during_initialization(&quot;Cannot specify &quot; JAVA_BASE_NAME &quot; more than once to --patch-module&quot;);
3144     } else {
3145       *patch_mod_javabase = true;
3146     }
3147   }
3148 
3149   // Create GrowableArray lazily, only if --patch-module has been specified
3150   if (_patch_mod_prefix == NULL) {
<span class="line-modified">3151     _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;ModulePatchPath*&gt;(10, true);</span>
3152   }
3153 
3154   _patch_mod_prefix-&gt;push(new ModulePatchPath(module_name, path));
3155 }
3156 
3157 // Remove all empty paths from the app classpath (if IgnoreEmptyClassPaths is enabled)
3158 //
3159 // This is necessary because some apps like to specify classpath like -cp foo.jar:${XYZ}:bar.jar
3160 // in their start-up scripts. If XYZ is empty, the classpath will look like &quot;-cp foo.jar::bar.jar&quot;.
3161 // Java treats such empty paths as if the user specified &quot;-cp foo.jar:.:bar.jar&quot;. I.e., an empty
3162 // path is treated as the current directory.
3163 //
3164 // This causes problems with CDS, which requires that all directories specified in the classpath
3165 // must be empty. In most cases, applications do NOT want to load classes from the current
3166 // directory anyway. Adding -XX:+IgnoreEmptyClassPaths will make these applications&#39; start-up
3167 // scripts compatible with CDS.
3168 void Arguments::fix_appclasspath() {
3169   if (IgnoreEmptyClassPaths) {
3170     const char separator = *os::path_separator();
3171     const char* src = _java_class_path-&gt;value();
</pre>
<hr />
<pre>
3387       os::free(_vm_options_file_arg);
3388     }
3389     if (_args.options == NULL) return;
3390     for (int i = 0; i &lt; _args.nOptions; i++) {
3391       os::free(_args.options[i].optionString);
3392     }
3393     FREE_C_HEAP_ARRAY(JavaVMOption, _args.options);
3394   }
3395 
3396   // Insert options into this option list, to replace option at
3397   // vm_options_file_pos (-XX:VMOptionsFile)
3398   jint insert(const JavaVMInitArgs* args,
3399               const JavaVMInitArgs* args_to_insert,
3400               const int vm_options_file_pos) {
3401     assert(_args.options == NULL, &quot;shouldn&#39;t be set yet&quot;);
3402     assert(args_to_insert-&gt;nOptions != 0, &quot;there should be args to insert&quot;);
3403     assert(vm_options_file_pos != -1, &quot;vm_options_file_pos should be set&quot;);
3404 
3405     int length = args-&gt;nOptions + args_to_insert-&gt;nOptions - 1;
3406     GrowableArray&lt;JavaVMOption&gt; *options = new (ResourceObj::C_HEAP, mtArguments)
<span class="line-modified">3407               GrowableArray&lt;JavaVMOption&gt;(length, true);    // Construct new option array</span>
3408     for (int i = 0; i &lt; args-&gt;nOptions; i++) {
3409       if (i == vm_options_file_pos) {
3410         // insert the new options starting at the same place as the
3411         // -XX:VMOptionsFile option
3412         for (int j = 0; j &lt; args_to_insert-&gt;nOptions; j++) {
3413           options-&gt;push(args_to_insert-&gt;options[j]);
3414         }
3415       } else {
3416         options-&gt;push(args-&gt;options[i]);
3417       }
3418     }
3419     // make into options array
3420     jint result = set_args(options);
3421     delete options;
3422     return result;
3423   }
3424 };
3425 
3426 jint Arguments::parse_java_options_environment_variable(ScopedVMInitArgs* args) {
3427   return parse_options_environment_variable(&quot;_JAVA_OPTIONS&quot;, args);
</pre>
<hr />
<pre>
3499   if (bytes_read &lt; 0) {
3500     FREE_C_HEAP_ARRAY(char, buf);
3501     jio_fprintf(defaultStream::error_stream(),
3502                 &quot;Could not read options file &#39;%s&#39;\n&quot;, file_name);
3503     return JNI_ERR;
3504   }
3505 
3506   if (bytes_read == 0) {
3507     // tell caller there is no option data and that is ok
3508     FREE_C_HEAP_ARRAY(char, buf);
3509     return JNI_OK;
3510   }
3511 
3512   retcode = parse_options_buffer(file_name, buf, bytes_read, vm_args);
3513 
3514   FREE_C_HEAP_ARRAY(char, buf);
3515   return retcode;
3516 }
3517 
3518 jint Arguments::parse_options_buffer(const char* name, char* buffer, const size_t buf_len, ScopedVMInitArgs* vm_args) {
<span class="line-modified">3519   GrowableArray&lt;JavaVMOption&gt; *options = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;JavaVMOption&gt;(2, true);    // Construct option array</span>
3520 
3521   // some pointers to help with parsing
3522   char *buffer_end = buffer + buf_len;
3523   char *opt_hd = buffer;
3524   char *wrt = buffer;
3525   char *rd = buffer;
3526 
3527   // parse all options
3528   while (rd &lt; buffer_end) {
3529     // skip leading white space from the input string
3530     while (rd &lt; buffer_end &amp;&amp; isspace(*rd)) {
3531       rd++;
3532     }
3533 
3534     if (rd &gt;= buffer_end) {
3535       break;
3536     }
3537 
3538     // Remember this is where we found the head of the token.
3539     opt_hd = wrt;
</pre>
</td>
<td>
<hr />
<pre>
 531   { &quot;BiasedLockingBulkRebiasThreshold&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 532   { &quot;BiasedLockingBulkRevokeThreshold&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 533   { &quot;BiasedLockingDecayTime&quot;,              JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 534   { &quot;UseOptoBiasInlining&quot;,                 JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 535   { &quot;PrintPreciseBiasedLockingStatistics&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 536   { &quot;InitialBootClassLoaderMetaspaceSize&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 537   { &quot;UseLargePagesInMetaspace&quot;,            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 538 
 539   // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
 540   { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
 541   { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
 542   { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
 543 
 544   // -------------- Obsolete Flags - sorted by expired_in --------------
 545   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 546   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 547   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 548   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 549   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 550   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
<span class="line-modified"> 551 #ifdef BSD</span>
<span class="line-modified"> 552   { &quot;UseBsdPosixThreadCPUClocks&quot;,    JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-modified"> 553   { &quot;UseOprofile&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>











 554 #endif



 555 
 556 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 557   // These entries will generate build errors.  Their purpose is to test the macros.
 558   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 559   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 560   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
 561   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },
 562   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 563   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 564   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 565 #endif
 566 
 567 #ifndef COMPILER2
 568   // These flags were generally available, but are C2 only, now.
 569   { &quot;MaxInlineLevel&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 570   { &quot;MaxRecursiveInlineLevel&quot;,      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 571   { &quot;InlineSmallCode&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 572   { &quot;MaxInlineSize&quot;,                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 573   { &quot;FreqInlineSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 574   { &quot;MaxTrivialSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
</pre>
<hr />
<pre>
1436 bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {
1437   const char* eq = strchr(prop, &#39;=&#39;);
1438   const char* key;
1439   const char* value = &quot;&quot;;
1440 
1441   if (eq == NULL) {
1442     // property doesn&#39;t have a value, thus use passed string
1443     key = prop;
1444   } else {
1445     // property have a value, thus extract it and save to the
1446     // allocated string
1447     size_t key_len = eq - prop;
1448     char* tmp_key = AllocateHeap(key_len + 1, mtArguments);
1449 
1450     jio_snprintf(tmp_key, key_len + 1, &quot;%s&quot;, prop);
1451     key = tmp_key;
1452 
1453     value = &amp;prop[key_len + 1];
1454   }
1455 
<span class="line-added">1456 #if INCLUDE_CDS</span>
1457   if (is_internal_module_property(key) ||
1458       strcmp(key, &quot;jdk.module.main&quot;) == 0) {
1459     MetaspaceShared::disable_optimized_module_handling();
1460     log_info(cds)(&quot;Using optimized module handling disabled due to incompatible property: %s=%s&quot;, key, value);
1461   }
<span class="line-added">1462 #endif</span>
1463 
1464   if (strcmp(key, &quot;java.compiler&quot;) == 0) {
1465     process_java_compiler_argument(value);
1466     // Record value in Arguments, but let it get passed to Java.
1467   } else if (strcmp(key, &quot;sun.java.launcher.is_altjvm&quot;) == 0) {
1468     // sun.java.launcher.is_altjvm property is
1469     // private and is processed in process_sun_java_launcher_properties();
1470     // the sun.java.launcher property is passed on to the java application
1471   } else if (strcmp(key, &quot;sun.boot.library.path&quot;) == 0) {
1472     // append is true, writable is true, internal is false
1473     PropertyList_unique_add(&amp;_system_properties, key, value, AppendProperty,
1474                             WriteableProperty, ExternalProperty);
1475   } else {
1476     if (strcmp(key, &quot;sun.java.command&quot;) == 0) {
1477       char *old_java_command = _java_command;
1478       _java_command = os::strdup_check_oom(value, mtArguments);
1479       if (old_java_command != NULL) {
1480         os::free(old_java_command);
1481       }
1482     } else if (strcmp(key, &quot;java.vendor.url.bug&quot;) == 0) {
</pre>
<hr />
<pre>
2497     } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
2498       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2499       if (*tail == &#39;\0&#39;) {
2500         JavaAssertions::setUserClassDefault(enable);
2501       } else {
2502         assert(*tail == &#39;:&#39;, &quot;bogus match by match_option()&quot;);
2503         JavaAssertions::addOption(tail + 1, enable);
2504       }
2505     // -dsa / -esa / -disablesystemassertions / -enablesystemassertions
2506     } else if (match_option(option, system_assertion_options, &amp;tail, false)) {
2507       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2508       JavaAssertions::setSystemClassDefault(enable);
2509     // -bootclasspath:
2510     } else if (match_option(option, &quot;-Xbootclasspath:&quot;, &amp;tail)) {
2511         jio_fprintf(defaultStream::output_stream(),
2512           &quot;-Xbootclasspath is no longer a supported option.\n&quot;);
2513         return JNI_EINVAL;
2514     // -bootclasspath/a:
2515     } else if (match_option(option, &quot;-Xbootclasspath/a:&quot;, &amp;tail)) {
2516       Arguments::append_sysclasspath(tail);
<span class="line-added">2517 #if INCLUDE_CDS</span>
2518       MetaspaceShared::disable_optimized_module_handling();
2519       log_info(cds)(&quot;Using optimized module handling disabled due to bootclasspath was appended&quot;);
<span class="line-added">2520 #endif</span>
2521     // -bootclasspath/p:
2522     } else if (match_option(option, &quot;-Xbootclasspath/p:&quot;, &amp;tail)) {
2523         jio_fprintf(defaultStream::output_stream(),
2524           &quot;-Xbootclasspath/p is no longer a supported option.\n&quot;);
2525         return JNI_EINVAL;
2526     // -Xrun
2527     } else if (match_option(option, &quot;-Xrun&quot;, &amp;tail)) {
2528       if (tail != NULL) {
2529         const char* pos = strchr(tail, &#39;:&#39;);
2530         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2531         char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2532         jio_snprintf(name, len + 1, &quot;%s&quot;, tail);
2533 
2534         char *options = NULL;
2535         if(pos != NULL) {
2536           size_t len2 = strlen(pos+1) + 1; // options start after &#39;:&#39;.  Final zero must be copied.
2537           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
2538         }
2539 #if !INCLUDE_JVMTI
2540         if (strcmp(name, &quot;jdwp&quot;) == 0) {
</pre>
<hr />
<pre>
3121   fix_appclasspath();
3122 
3123   return JNI_OK;
3124 }
3125 
3126 void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {
3127   // For java.base check for duplicate --patch-module options being specified on the command line.
3128   // This check is only required for java.base, all other duplicate module specifications
3129   // will be checked during module system initialization.  The module system initialization
3130   // will throw an ExceptionInInitializerError if this situation occurs.
3131   if (strcmp(module_name, JAVA_BASE_NAME) == 0) {
3132     if (*patch_mod_javabase) {
3133       vm_exit_during_initialization(&quot;Cannot specify &quot; JAVA_BASE_NAME &quot; more than once to --patch-module&quot;);
3134     } else {
3135       *patch_mod_javabase = true;
3136     }
3137   }
3138 
3139   // Create GrowableArray lazily, only if --patch-module has been specified
3140   if (_patch_mod_prefix == NULL) {
<span class="line-modified">3141     _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;ModulePatchPath*&gt;(10, mtArguments);</span>
3142   }
3143 
3144   _patch_mod_prefix-&gt;push(new ModulePatchPath(module_name, path));
3145 }
3146 
3147 // Remove all empty paths from the app classpath (if IgnoreEmptyClassPaths is enabled)
3148 //
3149 // This is necessary because some apps like to specify classpath like -cp foo.jar:${XYZ}:bar.jar
3150 // in their start-up scripts. If XYZ is empty, the classpath will look like &quot;-cp foo.jar::bar.jar&quot;.
3151 // Java treats such empty paths as if the user specified &quot;-cp foo.jar:.:bar.jar&quot;. I.e., an empty
3152 // path is treated as the current directory.
3153 //
3154 // This causes problems with CDS, which requires that all directories specified in the classpath
3155 // must be empty. In most cases, applications do NOT want to load classes from the current
3156 // directory anyway. Adding -XX:+IgnoreEmptyClassPaths will make these applications&#39; start-up
3157 // scripts compatible with CDS.
3158 void Arguments::fix_appclasspath() {
3159   if (IgnoreEmptyClassPaths) {
3160     const char separator = *os::path_separator();
3161     const char* src = _java_class_path-&gt;value();
</pre>
<hr />
<pre>
3377       os::free(_vm_options_file_arg);
3378     }
3379     if (_args.options == NULL) return;
3380     for (int i = 0; i &lt; _args.nOptions; i++) {
3381       os::free(_args.options[i].optionString);
3382     }
3383     FREE_C_HEAP_ARRAY(JavaVMOption, _args.options);
3384   }
3385 
3386   // Insert options into this option list, to replace option at
3387   // vm_options_file_pos (-XX:VMOptionsFile)
3388   jint insert(const JavaVMInitArgs* args,
3389               const JavaVMInitArgs* args_to_insert,
3390               const int vm_options_file_pos) {
3391     assert(_args.options == NULL, &quot;shouldn&#39;t be set yet&quot;);
3392     assert(args_to_insert-&gt;nOptions != 0, &quot;there should be args to insert&quot;);
3393     assert(vm_options_file_pos != -1, &quot;vm_options_file_pos should be set&quot;);
3394 
3395     int length = args-&gt;nOptions + args_to_insert-&gt;nOptions - 1;
3396     GrowableArray&lt;JavaVMOption&gt; *options = new (ResourceObj::C_HEAP, mtArguments)
<span class="line-modified">3397               GrowableArray&lt;JavaVMOption&gt;(length, mtArguments);    // Construct new option array</span>
3398     for (int i = 0; i &lt; args-&gt;nOptions; i++) {
3399       if (i == vm_options_file_pos) {
3400         // insert the new options starting at the same place as the
3401         // -XX:VMOptionsFile option
3402         for (int j = 0; j &lt; args_to_insert-&gt;nOptions; j++) {
3403           options-&gt;push(args_to_insert-&gt;options[j]);
3404         }
3405       } else {
3406         options-&gt;push(args-&gt;options[i]);
3407       }
3408     }
3409     // make into options array
3410     jint result = set_args(options);
3411     delete options;
3412     return result;
3413   }
3414 };
3415 
3416 jint Arguments::parse_java_options_environment_variable(ScopedVMInitArgs* args) {
3417   return parse_options_environment_variable(&quot;_JAVA_OPTIONS&quot;, args);
</pre>
<hr />
<pre>
3489   if (bytes_read &lt; 0) {
3490     FREE_C_HEAP_ARRAY(char, buf);
3491     jio_fprintf(defaultStream::error_stream(),
3492                 &quot;Could not read options file &#39;%s&#39;\n&quot;, file_name);
3493     return JNI_ERR;
3494   }
3495 
3496   if (bytes_read == 0) {
3497     // tell caller there is no option data and that is ok
3498     FREE_C_HEAP_ARRAY(char, buf);
3499     return JNI_OK;
3500   }
3501 
3502   retcode = parse_options_buffer(file_name, buf, bytes_read, vm_args);
3503 
3504   FREE_C_HEAP_ARRAY(char, buf);
3505   return retcode;
3506 }
3507 
3508 jint Arguments::parse_options_buffer(const char* name, char* buffer, const size_t buf_len, ScopedVMInitArgs* vm_args) {
<span class="line-modified">3509   GrowableArray&lt;JavaVMOption&gt; *options = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;JavaVMOption&gt;(2, mtArguments);    // Construct option array</span>
3510 
3511   // some pointers to help with parsing
3512   char *buffer_end = buffer + buf_len;
3513   char *opt_hd = buffer;
3514   char *wrt = buffer;
3515   char *rd = buffer;
3516 
3517   // parse all options
3518   while (rd &lt; buffer_end) {
3519     // skip leading white space from the input string
3520     while (rd &lt; buffer_end &amp;&amp; isspace(*rd)) {
3521       rd++;
3522     }
3523 
3524     if (rd &gt;= buffer_end) {
3525       break;
3526     }
3527 
3528     // Remember this is where we found the head of the token.
3529     opt_hd = wrt;
</pre>
</td>
</tr>
</table>
<center><a href="../prims/jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="biasedLocking.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
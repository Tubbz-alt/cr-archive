<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/method.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 119   int _max_vt_buffer; // max number of VT buffer chunk to use before recycling
 120 
 121 #if INCLUDE_AOT &amp;&amp; defined(TIERED)
 122   CompiledMethod* _aot_code;
 123 #endif
 124 
 125   // Constructor
 126   Method(ConstMethod* xconst, AccessFlags access_flags);
 127  public:
 128 
 129   static Method* allocate(ClassLoaderData* loader_data,
 130                           int byte_code_size,
 131                           AccessFlags access_flags,
 132                           InlineTableSizes* sizes,
 133                           ConstMethod::MethodType method_type,
 134                           TRAPS);
 135 
 136   // CDS and vtbl checking can create an empty Method to get vtbl pointer.
 137   Method(){}
 138 
<span class="line-modified"> 139   bool is_method() const volatile { return true; }</span>
 140 
 141   void restore_unshareable_info(TRAPS);
 142 
 143   // accessors for instance variables
 144 
 145   ConstMethod* constMethod() const             { return _constMethod; }
 146   void set_constMethod(ConstMethod* xconst)    { _constMethod = xconst; }
 147 
 148 
 149   static address make_adapters(const methodHandle&amp; mh, TRAPS);
 150   address from_compiled_entry() const;
 151   address from_compiled_value_ro_entry() const;
 152   address from_compiled_value_entry() const;
 153   address from_compiled_entry_no_trampoline(bool caller_is_c1) const;
 154   address from_interpreted_entry() const;
 155 
 156   // access flag
 157   AccessFlags access_flags() const               { return _access_flags;  }
 158   void set_access_flags(AccessFlags flags)       { _access_flags = flags; }
 159 
</pre>
</td>
<td>
<hr />
<pre>
 119   int _max_vt_buffer; // max number of VT buffer chunk to use before recycling
 120 
 121 #if INCLUDE_AOT &amp;&amp; defined(TIERED)
 122   CompiledMethod* _aot_code;
 123 #endif
 124 
 125   // Constructor
 126   Method(ConstMethod* xconst, AccessFlags access_flags);
 127  public:
 128 
 129   static Method* allocate(ClassLoaderData* loader_data,
 130                           int byte_code_size,
 131                           AccessFlags access_flags,
 132                           InlineTableSizes* sizes,
 133                           ConstMethod::MethodType method_type,
 134                           TRAPS);
 135 
 136   // CDS and vtbl checking can create an empty Method to get vtbl pointer.
 137   Method(){}
 138 
<span class="line-modified"> 139   virtual bool is_method() const { return true; }</span>
 140 
 141   void restore_unshareable_info(TRAPS);
 142 
 143   // accessors for instance variables
 144 
 145   ConstMethod* constMethod() const             { return _constMethod; }
 146   void set_constMethod(ConstMethod* xconst)    { _constMethod = xconst; }
 147 
 148 
 149   static address make_adapters(const methodHandle&amp; mh, TRAPS);
 150   address from_compiled_entry() const;
 151   address from_compiled_value_ro_entry() const;
 152   address from_compiled_value_entry() const;
 153   address from_compiled_entry_no_trampoline(bool caller_is_c1) const;
 154   address from_interpreted_entry() const;
 155 
 156   // access flag
 157   AccessFlags access_flags() const               { return _access_flags;  }
 158   void set_access_flags(AccessFlags flags)       { _access_flags = flags; }
 159 
</pre>
</td>
</tr>
</table>
<center><a href="klass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
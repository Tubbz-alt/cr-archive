<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/constantPool.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_CONSTANTPOOL_HPP
  26 #define SHARE_OOPS_CONSTANTPOOL_HPP
  27 
  28 #include &quot;memory/allocation.hpp&quot;
  29 #include &quot;oops/arrayOop.hpp&quot;
  30 #include &quot;oops/cpCache.hpp&quot;
  31 #include &quot;oops/objArrayOop.hpp&quot;
  32 #include &quot;oops/oopHandle.hpp&quot;
  33 #include &quot;oops/symbol.hpp&quot;
  34 #include &quot;oops/typeArrayOop.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;utilities/align.hpp&quot;
  37 #include &quot;utilities/bytes.hpp&quot;
  38 #include &quot;utilities/constantTag.hpp&quot;
  39 
  40 // A ConstantPool is an array containing class constants as described in the
  41 // class file.
  42 //
  43 // Most of the constant pool entries are written during class parsing, which
  44 // is safe.  For klass types, the constant pool entry is
  45 // modified when the entry is resolved.  If a klass constant pool
  46 // entry is read without a lock, only the resolved state guarantees that
  47 // the entry in the constant pool is a klass object and not a Symbol*.
  48 
  49 class SymbolHashMap;
  50 
  51 class CPSlot {
  52  friend class ConstantPool;
  53   intptr_t _ptr;
  54   enum TagBits  {_pseudo_bit = 1};
  55  public:
  56 
  57   CPSlot(intptr_t ptr): _ptr(ptr) {}
  58   CPSlot(Symbol* ptr, int tag_bits = 0): _ptr((intptr_t)ptr | tag_bits) {}
  59 
  60   intptr_t value()   { return _ptr; }
  61   bool is_pseudo_string() { return (_ptr &amp; _pseudo_bit) != 0; }
  62 
  63   Symbol* get_symbol() {
  64     return (Symbol*)(_ptr &amp; ~_pseudo_bit);
  65   }
  66 };
  67 
  68 // This represents a JVM_CONSTANT_Class, JVM_CONSTANT_UnresolvedClass, or
  69 // JVM_CONSTANT_UnresolvedClassInError slot in the constant pool.
  70 class CPKlassSlot {
  71   // cp-&gt;symbol_at(_name_index) gives the name of the class.
  72   int _name_index;
  73 
  74   // cp-&gt;_resolved_klasses-&gt;at(_resolved_klass_index) gives the Klass* for the class.
  75   int _resolved_klass_index;
  76 public:
  77   enum {
  78     // This is used during constant pool merging where the resolved klass index is
  79     // not yet known, and will be computed at a later stage (during a call to
  80     // initialize_unresolved_klasses()).
  81     _temp_resolved_klass_index = 0xffff
  82   };
  83   CPKlassSlot(int n, int rk) {
  84     _name_index = n;
  85     _resolved_klass_index = rk;
  86   }
  87   int name_index() const {
  88     return _name_index;
  89   }
  90   int resolved_klass_index() const {
  91     assert(_resolved_klass_index != _temp_resolved_klass_index, &quot;constant pool merging was incomplete&quot;);
  92     return _resolved_klass_index;
  93   }
  94 };
  95 
  96 class ConstantPool : public Metadata {
  97   friend class VMStructs;
  98   friend class JVMCIVMStructs;
  99   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 100   friend class Universe;             // For null constructor
 101  private:
 102   // If you add a new field that points to any metaspace object, you
 103   // must add this field to ConstantPool::metaspace_pointers_do().
 104   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 105   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 106   InstanceKlass*       _pool_holder; // the corresponding class
 107   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 108 
 109   // Consider using an array of compressed klass pointers to
 110   // save space on 64-bit platforms.
 111   Array&lt;Klass*&gt;*       _resolved_klasses;
 112 
 113   u2              _major_version;        // major version number of class file
 114   u2              _minor_version;        // minor version number of class file
 115 
 116   // Constant pool index to the utf8 entry of the Generic signature,
 117   // or 0 if none.
 118   u2              _generic_signature_index;
 119   // Constant pool index to the utf8 entry for the name of source file
 120   // containing this klass, 0 if not specified.
 121   u2              _source_file_name_index;
 122 
 123   enum {
 124     _has_preresolution    = 1,       // Flags
 125     _on_stack             = 2,
 126     _is_shared            = 4,
 127     _has_dynamic_constant = 8
 128   };
 129 
 130   u2              _flags;  // old fashioned bit twiddling
 131 
 132   int             _length; // number of elements in the array
 133 
 134   union {
 135     // set for CDS to restore resolved references
 136     int                _resolved_reference_length;
 137     // keeps version number for redefined classes (used in backtrace)
 138     int                _version;
 139   } _saved;
 140 
 141   void set_tags(Array&lt;u1&gt;* tags)               { _tags = tags; }
 142   void tag_at_put(int which, jbyte t)          { tags()-&gt;at_put(which, t); }
 143   void release_tag_at_put(int which, jbyte t)  { tags()-&gt;release_at_put(which, t); }
 144 
 145   u1* tag_addr_at(int which) const             { return tags()-&gt;adr_at(which); }
 146 
 147   void set_operands(Array&lt;u2&gt;* operands)       { _operands = operands; }
 148 
 149   u2 flags() const                             { return _flags; }
 150   void set_flags(u2 f)                         { _flags = f; }
 151 
 152  private:
 153   intptr_t* base() const { return (intptr_t*) (((char*) this) + sizeof(ConstantPool)); }
 154 
 155   CPSlot slot_at(int which) const;
 156 
 157   void slot_at_put(int which, CPSlot s) const {
 158     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 159     assert(s.value() != 0, &quot;Caught something&quot;);
 160     *(intptr_t*)&amp;base()[which] = s.value();
 161   }
 162   intptr_t* obj_at_addr(int which) const {
 163     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 164     return (intptr_t*) &amp;base()[which];
 165   }
 166 
 167   jint* int_at_addr(int which) const {
 168     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 169     return (jint*) &amp;base()[which];
 170   }
 171 
 172   jlong* long_at_addr(int which) const {
 173     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 174     return (jlong*) &amp;base()[which];
 175   }
 176 
 177   jfloat* float_at_addr(int which) const {
 178     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 179     return (jfloat*) &amp;base()[which];
 180   }
 181 
 182   jdouble* double_at_addr(int which) const {
 183     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 184     return (jdouble*) &amp;base()[which];
 185   }
 186 
 187   ConstantPool(Array&lt;u1&gt;* tags);
 188   ConstantPool() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 189  public:
 190   static ConstantPool* allocate(ClassLoaderData* loader_data, int length, TRAPS);
 191 
 192   virtual bool is_constantPool() const      { return true; }
 193 
 194   Array&lt;u1&gt;* tags() const                   { return _tags; }
 195   Array&lt;u2&gt;* operands() const               { return _operands; }
 196 
 197   bool has_preresolution() const            { return (_flags &amp; _has_preresolution) != 0; }
 198   void set_has_preresolution() {
 199     assert(!is_shared(), &quot;should never be called on shared ConstantPools&quot;);
 200     _flags |= _has_preresolution;
 201   }
 202 
 203   // minor and major version numbers of class file
 204   u2 major_version() const                 { return _major_version; }
 205   void set_major_version(u2 major_version) { _major_version = major_version; }
 206   u2 minor_version() const                 { return _minor_version; }
 207   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
 208 
 209   // generics support
 210   Symbol* generic_signature() const {
 211     return (_generic_signature_index == 0) ?
 212       (Symbol*)NULL : symbol_at(_generic_signature_index);
 213   }
 214   u2 generic_signature_index() const                   { return _generic_signature_index; }
 215   void set_generic_signature_index(u2 sig_index)       { _generic_signature_index = sig_index; }
 216 
 217   // source file name
 218   Symbol* source_file_name() const {
 219     return (_source_file_name_index == 0) ?
 220       (Symbol*)NULL : symbol_at(_source_file_name_index);
 221   }
 222   u2 source_file_name_index() const                    { return _source_file_name_index; }
 223   void set_source_file_name_index(u2 sourcefile_index) { _source_file_name_index = sourcefile_index; }
 224 
 225   void copy_fields(const ConstantPool* orig);
 226 
 227   // Redefine classes support.  If a method refering to this constant pool
 228   // is on the executing stack, or as a handle in vm code, this constant pool
 229   // can&#39;t be removed from the set of previous versions saved in the instance
 230   // class.
 231   bool on_stack() const                      { return (_flags &amp;_on_stack) != 0; }
 232   void set_on_stack(const bool value);
 233 
 234   // Faster than MetaspaceObj::is_shared() - used by set_on_stack()
 235   bool is_shared() const                     { return (_flags &amp; _is_shared) != 0; }
 236 
 237   bool has_dynamic_constant() const       { return (_flags &amp; _has_dynamic_constant) != 0; }
 238   void set_has_dynamic_constant()         { _flags |= _has_dynamic_constant; }
 239 
 240   // Klass holding pool
 241   InstanceKlass* pool_holder() const      { return _pool_holder; }
 242   void set_pool_holder(InstanceKlass* k)  { _pool_holder = k; }
 243   InstanceKlass** pool_holder_addr()      { return &amp;_pool_holder; }
 244 
 245   // Interpreter runtime support
 246   ConstantPoolCache* cache() const        { return _cache; }
 247   void set_cache(ConstantPoolCache* cache){ _cache = cache; }
 248 
 249   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 250   virtual MetaspaceObj::Type type() const { return ConstantPoolType; }
 251 
 252   // Create object cache in the constant pool
 253   void initialize_resolved_references(ClassLoaderData* loader_data,
 254                                       const intStack&amp; reference_map,
 255                                       int constant_pool_map_length,
 256                                       TRAPS);
 257 
 258   // resolved strings, methodHandles and callsite objects from the constant pool
 259   objArrayOop resolved_references()  const;
 260   objArrayOop resolved_references_or_null()  const;
 261   // mapping resolved object array indexes to cp indexes and back.
 262   int object_to_cp_index(int index)         { return reference_map()-&gt;at(index); }
 263   int cp_to_object_index(int index);
 264 
 265   void set_resolved_klasses(Array&lt;Klass*&gt;* rk)  { _resolved_klasses = rk; }
 266   Array&lt;Klass*&gt;* resolved_klasses() const       { return _resolved_klasses; }
 267   void allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS);
 268   void initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS);
 269 
 270   // Invokedynamic indexes.
 271   // They must look completely different from normal indexes.
 272   // The main reason is that byte swapping is sometimes done on normal indexes.
 273   // Finally, it is helpful for debugging to tell the two apart.
 274   static bool is_invokedynamic_index(int i) { return (i &lt; 0); }
 275   static int  decode_invokedynamic_index(int i) { assert(is_invokedynamic_index(i),  &quot;&quot;); return ~i; }
 276   static int  encode_invokedynamic_index(int i) { assert(!is_invokedynamic_index(i), &quot;&quot;); return ~i; }
 277 
 278 
 279   // The invokedynamic points at a CP cache entry.  This entry points back
 280   // at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry
 281   // in the resolved_references array (which provides the appendix argument).
 282   int invokedynamic_cp_cache_index(int indy_index) const {
 283     assert(is_invokedynamic_index(indy_index), &quot;should be a invokedynamic index&quot;);
 284     int cache_index = decode_invokedynamic_index(indy_index);
 285     return cache_index;
 286   }
 287   ConstantPoolCacheEntry* invokedynamic_cp_cache_entry_at(int indy_index) const {
 288     // decode index that invokedynamic points to.
 289     int cp_cache_index = invokedynamic_cp_cache_index(indy_index);
 290     return cache()-&gt;entry_at(cp_cache_index);
 291   }
 292   // Given the per-instruction index of an indy instruction, report the
 293   // main constant pool entry for its bootstrap specifier.
 294   // From there, uncached_name/signature_ref_at will get the name/type.
 295   int invokedynamic_bootstrap_ref_index_at(int indy_index) const {
 296     return invokedynamic_cp_cache_entry_at(indy_index)-&gt;constant_pool_index();
 297   }
 298 
 299   // Assembly code support
 300   static int tags_offset_in_bytes()         { return offset_of(ConstantPool, _tags); }
 301   static int cache_offset_in_bytes()        { return offset_of(ConstantPool, _cache); }
 302   static int pool_holder_offset_in_bytes()  { return offset_of(ConstantPool, _pool_holder); }
 303   static int resolved_klasses_offset_in_bytes()    { return offset_of(ConstantPool, _resolved_klasses); }
 304 
 305   // Storing constants
 306 
 307   // For temporary use while constructing constant pool. Used during a retransform/class redefinition as well.
 308   void klass_index_at_put(int which, int name_index) {
 309     tag_at_put(which, JVM_CONSTANT_ClassIndex);
 310     *int_at_addr(which) = name_index;
 311   }
 312 
 313   // Unsafe anonymous class support:
 314   void klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name);
 315   void klass_at_put(int class_index, Klass* k);
 316 
 317   void unresolved_qdescriptor_at_put(int which, int name_index, int resolved_klass_index) {
 318       release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);
 319 
 320       assert((name_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 321       assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 322       *int_at_addr(which) =
 323         build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 324     }
 325 
 326   void unresolved_klass_at_put(int which, int name_index, int resolved_klass_index) {
 327     release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass);
 328 
 329     assert((name_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 330     assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 331     *int_at_addr(which) =
 332       build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 333   }
 334 
 335   void method_handle_index_at_put(int which, int ref_kind, int ref_index) {
 336     tag_at_put(which, JVM_CONSTANT_MethodHandle);
 337     *int_at_addr(which) = ((jint) ref_index&lt;&lt;16) | ref_kind;
 338   }
 339 
 340   void method_type_index_at_put(int which, int ref_index) {
 341     tag_at_put(which, JVM_CONSTANT_MethodType);
 342     *int_at_addr(which) = ref_index;
 343   }
 344 
 345   void dynamic_constant_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 346     tag_at_put(which, JVM_CONSTANT_Dynamic);
 347     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 348   }
 349 
 350   void invoke_dynamic_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 351     tag_at_put(which, JVM_CONSTANT_InvokeDynamic);
 352     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 353   }
 354 
 355   void unresolved_string_at_put(int which, Symbol* s) {
 356     release_tag_at_put(which, JVM_CONSTANT_String);
 357     slot_at_put(which, CPSlot(s));
 358   }
 359 
 360   void int_at_put(int which, jint i) {
 361     tag_at_put(which, JVM_CONSTANT_Integer);
 362     *int_at_addr(which) = i;
 363   }
 364 
 365   void long_at_put(int which, jlong l) {
 366     tag_at_put(which, JVM_CONSTANT_Long);
 367     // *long_at_addr(which) = l;
 368     Bytes::put_native_u8((address)long_at_addr(which), *((u8*) &amp;l));
 369   }
 370 
 371   void float_at_put(int which, jfloat f) {
 372     tag_at_put(which, JVM_CONSTANT_Float);
 373     *float_at_addr(which) = f;
 374   }
 375 
 376   void double_at_put(int which, jdouble d) {
 377     tag_at_put(which, JVM_CONSTANT_Double);
 378     // *double_at_addr(which) = d;
 379     // u8 temp = *(u8*) &amp;d;
 380     Bytes::put_native_u8((address) double_at_addr(which), *((u8*) &amp;d));
 381   }
 382 
 383   Symbol** symbol_at_addr(int which) const {
 384     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 385     return (Symbol**) &amp;base()[which];
 386   }
 387 
 388   void symbol_at_put(int which, Symbol* s) {
 389     assert(s-&gt;refcount() != 0, &quot;should have nonzero refcount&quot;);
 390     tag_at_put(which, JVM_CONSTANT_Utf8);
 391     *symbol_at_addr(which) = s;
 392   }
 393 
 394   void string_at_put(int which, int obj_index, oop str);
 395 
 396   // For temporary use while constructing constant pool
 397   void string_index_at_put(int which, int string_index) {
 398     tag_at_put(which, JVM_CONSTANT_StringIndex);
 399     *int_at_addr(which) = string_index;
 400   }
 401 
 402   void field_at_put(int which, int class_index, int name_and_type_index) {
 403     tag_at_put(which, JVM_CONSTANT_Fieldref);
 404     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 405   }
 406 
 407   void method_at_put(int which, int class_index, int name_and_type_index) {
 408     tag_at_put(which, JVM_CONSTANT_Methodref);
 409     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 410   }
 411 
 412   void interface_method_at_put(int which, int class_index, int name_and_type_index) {
 413     tag_at_put(which, JVM_CONSTANT_InterfaceMethodref);
 414     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;  // Not so nice
 415   }
 416 
 417   void name_and_type_at_put(int which, int name_index, int signature_index) {
 418     tag_at_put(which, JVM_CONSTANT_NameAndType);
 419     *int_at_addr(which) = ((jint) signature_index&lt;&lt;16) | name_index;  // Not so nice
 420   }
 421 
 422   // Tag query
 423 
 424   constantTag tag_at(int which) const { return (constantTag)tags()-&gt;at_acquire(which); }
 425 
 426   // Fetching constants
 427 
 428   Klass* klass_at(int which, TRAPS) {
 429     constantPoolHandle h_this(THREAD, this);
 430     return klass_at_impl(h_this, which, true, THREAD);
 431   }
 432 
 433   // Version of klass_at that doesn&#39;t save the resolution error, called during deopt
 434   Klass* klass_at_ignore_error(int which, TRAPS) {
 435     constantPoolHandle h_this(THREAD, this);
 436     return klass_at_impl(h_this, which, false, THREAD);
 437   }
 438 
 439   CPKlassSlot klass_slot_at(int which) const {
 440     assert(tag_at(which).is_unresolved_klass() || tag_at(which).is_klass(),
 441            &quot;Corrupted constant pool&quot;);
 442     int value = *int_at_addr(which);
 443     int name_index = extract_high_short_from_int(value);
 444     int resolved_klass_index = extract_low_short_from_int(value);
 445     return CPKlassSlot(name_index, resolved_klass_index);
 446   }
 447 
 448   Symbol* klass_name_at(int which) const;  // Returns the name, w/o resolving.
 449   int klass_name_index_at(int which) const {
 450     return klass_slot_at(which).name_index();
 451   }
 452 
 453   Klass* resolved_klass_at(int which) const;  // Used by Compiler
 454 
 455   // RedefineClasses() API support:
 456   Symbol* klass_at_noresolve(int which) { return klass_name_at(which); }
 457   void temp_unresolved_klass_at_put(int which, int name_index) {
 458     // Used only during constant pool merging for class redefinition. The resolved klass index
 459     // will be initialized later by a call to initialize_unresolved_klasses().
 460     unresolved_klass_at_put(which, name_index, CPKlassSlot::_temp_resolved_klass_index);
 461   }
 462 
 463   jint int_at(int which) {
 464     assert(tag_at(which).is_int(), &quot;Corrupted constant pool&quot;);
 465     return *int_at_addr(which);
 466   }
 467 
 468   jlong long_at(int which) {
 469     assert(tag_at(which).is_long(), &quot;Corrupted constant pool&quot;);
 470     // return *long_at_addr(which);
 471     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 472     return *((jlong*)&amp;tmp);
 473   }
 474 
 475   jfloat float_at(int which) {
 476     assert(tag_at(which).is_float(), &quot;Corrupted constant pool&quot;);
 477     return *float_at_addr(which);
 478   }
 479 
 480   jdouble double_at(int which) {
 481     assert(tag_at(which).is_double(), &quot;Corrupted constant pool&quot;);
 482     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 483     return *((jdouble*)&amp;tmp);
 484   }
 485 
 486   Symbol* symbol_at(int which) const {
 487     assert(tag_at(which).is_utf8(), &quot;Corrupted constant pool&quot;);
 488     return *symbol_at_addr(which);
 489   }
 490 
 491   oop string_at(int which, int obj_index, TRAPS) {
 492     constantPoolHandle h_this(THREAD, this);
 493     return string_at_impl(h_this, which, obj_index, THREAD);
 494   }
 495   oop string_at(int which, TRAPS) {
 496     int obj_index = cp_to_object_index(which);
 497     return string_at(which, obj_index, THREAD);
 498   }
 499 
 500   // Version that can be used before string oop array is created.
 501   oop uncached_string_at(int which, TRAPS);
 502 
 503   // A &quot;pseudo-string&quot; is an non-string oop that has found its way into
 504   // a String entry.
 505   // This can happen if the user patches a live
 506   // object into a CONSTANT_String entry of an unsafe anonymous class.
 507   // Method oops internally created for method handles may also
 508   // use pseudo-strings to link themselves to related metaobjects.
 509 
 510   bool is_pseudo_string_at(int which);
 511 
 512   oop pseudo_string_at(int which, int obj_index);
 513 
 514   oop pseudo_string_at(int which);
 515 
 516   void pseudo_string_at_put(int which, int obj_index, oop x) {
 517     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 518     Symbol* sym = unresolved_string_at(which);
 519     slot_at_put(which, CPSlot(sym, CPSlot::_pseudo_bit));
 520     string_at_put(which, obj_index, x);    // this works just fine
 521   }
 522 
 523   // only called when we are sure a string entry is already resolved (via an
 524   // earlier string_at call.
 525   oop resolved_string_at(int which) {
 526     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 527     // Must do an acquire here in case another thread resolved the klass
 528     // behind our back, lest we later load stale values thru the oop.
 529     // we might want a volatile_obj_at in ObjArrayKlass.
 530     int obj_index = cp_to_object_index(which);
 531     return resolved_references()-&gt;obj_at(obj_index);
 532   }
 533 
 534   Symbol* unresolved_string_at(int which) {
 535     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 536     Symbol* sym = slot_at(which).get_symbol();
 537     return sym;
 538   }
 539 
 540   // Returns an UTF8 for a CONSTANT_String entry at a given index.
 541   // UTF8 char* representation was chosen to avoid conversion of
 542   // java_lang_Strings at resolved entries into Symbol*s
 543   // or vice versa.
 544   char* string_at_noresolve(int which);
 545 
 546   jint name_and_type_at(int which) {
 547     assert(tag_at(which).is_name_and_type(), &quot;Corrupted constant pool&quot;);
 548     return *int_at_addr(which);
 549   }
 550 
 551   int method_handle_ref_kind_at(int which) {
 552     assert(tag_at(which).is_method_handle() ||
 553            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 554     return extract_low_short_from_int(*int_at_addr(which));  // mask out unwanted ref_index bits
 555   }
 556   int method_handle_index_at(int which) {
 557     assert(tag_at(which).is_method_handle() ||
 558            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 559     return extract_high_short_from_int(*int_at_addr(which));  // shift out unwanted ref_kind bits
 560   }
 561   int method_type_index_at(int which) {
 562     assert(tag_at(which).is_method_type() ||
 563            tag_at(which).is_method_type_in_error(), &quot;Corrupted constant pool&quot;);
 564     return *int_at_addr(which);
 565   }
 566 
 567   // Derived queries:
 568   Symbol* method_handle_name_ref_at(int which) {
 569     int member = method_handle_index_at(which);
 570     return impl_name_ref_at(member, true);
 571   }
 572   Symbol* method_handle_signature_ref_at(int which) {
 573     int member = method_handle_index_at(which);
 574     return impl_signature_ref_at(member, true);
 575   }
 576   int method_handle_klass_index_at(int which) {
 577     int member = method_handle_index_at(which);
 578     return impl_klass_ref_index_at(member, true);
 579   }
 580   Symbol* method_type_signature_at(int which) {
 581     int sym = method_type_index_at(which);
 582     return symbol_at(sym);
 583   }
 584 
 585   int bootstrap_name_and_type_ref_index_at(int which) {
 586     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 587     return extract_high_short_from_int(*int_at_addr(which));
 588   }
 589   int bootstrap_methods_attribute_index(int which) {
 590     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 591     return extract_low_short_from_int(*int_at_addr(which));
 592   }
 593   int bootstrap_operand_base(int which) {
 594     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 595     return operand_offset_at(operands(), bsms_attribute_index);
 596   }
 597   // The first part of the operands array consists of an index into the second part.
 598   // Extract a 32-bit index value from the first part.
 599   static int operand_offset_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 600     int n = (bsms_attribute_index * 2);
 601     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 602     // The first 32-bit index points to the beginning of the second part
 603     // of the operands array.  Make sure this index is in the first part.
 604     DEBUG_ONLY(int second_part = build_int_from_shorts(operands-&gt;at(0),
 605                                                        operands-&gt;at(1)));
 606     assert(second_part == 0 || n+2 &lt;= second_part, &quot;oob (2)&quot;);
 607     int offset = build_int_from_shorts(operands-&gt;at(n+0),
 608                                        operands-&gt;at(n+1));
 609     // The offset itself must point into the second part of the array.
 610     assert(offset == 0 || offset &gt;= second_part &amp;&amp; offset &lt;= operands-&gt;length(), &quot;oob (3)&quot;);
 611     return offset;
 612   }
 613   static void operand_offset_at_put(Array&lt;u2&gt;* operands, int bsms_attribute_index, int offset) {
 614     int n = bsms_attribute_index * 2;
 615     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 616     operands-&gt;at_put(n+0, extract_low_short_from_int(offset));
 617     operands-&gt;at_put(n+1, extract_high_short_from_int(offset));
 618   }
 619   static int operand_array_length(Array&lt;u2&gt;* operands) {
 620     if (operands == NULL || operands-&gt;length() == 0)  return 0;
 621     int second_part = operand_offset_at(operands, 0);
 622     return (second_part / 2);
 623   }
 624 
 625 #ifdef ASSERT
 626   // operand tuples fit together exactly, end to end
 627   static int operand_limit_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 628     int nextidx = bsms_attribute_index + 1;
 629     if (nextidx == operand_array_length(operands))
 630       return operands-&gt;length();
 631     else
 632       return operand_offset_at(operands, nextidx);
 633   }
 634   int bootstrap_operand_limit(int which) {
 635     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 636     return operand_limit_at(operands(), bsms_attribute_index);
 637   }
 638 #endif //ASSERT
 639 
 640   // Layout of InvokeDynamic and Dynamic bootstrap method specifier
 641   // data in second part of operands array.  This encodes one record in
 642   // the BootstrapMethods attribute.  The whole specifier also includes
 643   // the name and type information from the main constant pool entry.
 644   enum {
 645          _indy_bsm_offset  = 0,  // CONSTANT_MethodHandle bsm
 646          _indy_argc_offset = 1,  // u2 argc
 647          _indy_argv_offset = 2   // u2 argv[argc]
 648   };
 649 
 650   // These functions are used in RedefineClasses for CP merge
 651 
 652   int operand_offset_at(int bsms_attribute_index) {
 653     assert(0 &lt;= bsms_attribute_index &amp;&amp;
 654            bsms_attribute_index &lt; operand_array_length(operands()),
 655            &quot;Corrupted CP operands&quot;);
 656     return operand_offset_at(operands(), bsms_attribute_index);
 657   }
 658   int operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {
 659     int offset = operand_offset_at(bsms_attribute_index);
 660     return operands()-&gt;at(offset + _indy_bsm_offset);
 661   }
 662   int operand_argument_count_at(int bsms_attribute_index) {
 663     int offset = operand_offset_at(bsms_attribute_index);
 664     int argc = operands()-&gt;at(offset + _indy_argc_offset);
 665     return argc;
 666   }
 667   int operand_argument_index_at(int bsms_attribute_index, int j) {
 668     int offset = operand_offset_at(bsms_attribute_index);
 669     return operands()-&gt;at(offset + _indy_argv_offset + j);
 670   }
 671   int operand_next_offset_at(int bsms_attribute_index) {
 672     int offset = operand_offset_at(bsms_attribute_index) + _indy_argv_offset
 673                    + operand_argument_count_at(bsms_attribute_index);
 674     return offset;
 675   }
 676   // Compare a bootstrap specifier data in the operands arrays
 677   bool compare_operand_to(int bsms_attribute_index1, const constantPoolHandle&amp; cp2,
 678                           int bsms_attribute_index2, TRAPS);
 679   // Find a bootstrap specifier data in the operands array
 680   int find_matching_operand(int bsms_attribute_index, const constantPoolHandle&amp; search_cp,
 681                             int operands_cur_len, TRAPS);
 682   // Resize the operands array with delta_len and delta_size
 683   void resize_operands(int delta_len, int delta_size, TRAPS);
 684   // Extend the operands array with the length and size of the ext_cp operands
 685   void extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS);
 686   // Shrink the operands array to a smaller array with new_len length
 687   void shrink_operands(int new_len, TRAPS);
 688 
 689   int bootstrap_method_ref_index_at(int which) {
 690     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 691     int op_base = bootstrap_operand_base(which);
 692     return operands()-&gt;at(op_base + _indy_bsm_offset);
 693   }
 694   int bootstrap_argument_count_at(int which) {
 695     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 696     int op_base = bootstrap_operand_base(which);
 697     int argc = operands()-&gt;at(op_base + _indy_argc_offset);
 698     DEBUG_ONLY(int end_offset = op_base + _indy_argv_offset + argc;
 699                int next_offset = bootstrap_operand_limit(which));
 700     assert(end_offset == next_offset, &quot;matched ending&quot;);
 701     return argc;
 702   }
 703   int bootstrap_argument_index_at(int which, int j) {
 704     int op_base = bootstrap_operand_base(which);
 705     DEBUG_ONLY(int argc = operands()-&gt;at(op_base + _indy_argc_offset));
 706     assert((uint)j &lt; (uint)argc, &quot;oob&quot;);
 707     return operands()-&gt;at(op_base + _indy_argv_offset + j);
 708   }
 709 
 710   // The following methods (name/signature/klass_ref_at, klass_ref_at_noresolve,
 711   // name_and_type_ref_index_at) all expect to be passed indices obtained
 712   // directly from the bytecode.
 713   // If the indices are meant to refer to fields or methods, they are
 714   // actually rewritten constant pool cache indices.
 715   // The routine remap_instruction_operand_from_cache manages the adjustment
 716   // of these values back to constant pool indices.
 717 
 718   // There are also &quot;uncached&quot; versions which do not adjust the operand index; see below.
 719 
 720   // FIXME: Consider renaming these with a prefix &quot;cached_&quot; to make the distinction clear.
 721   // In a few cases (the verifier) there are uses before a cpcache has been built,
 722   // which are handled by a dynamic check in remap_instruction_operand_from_cache.
 723   // FIXME: Remove the dynamic check, and adjust all callers to specify the correct mode.
 724 
 725   // Lookup for entries consisting of (klass_index, name_and_type index)
 726   Klass* klass_ref_at(int which, TRAPS);
 727   Symbol* klass_ref_at_noresolve(int which);
 728   Symbol* name_ref_at(int which)                { return impl_name_ref_at(which, false); }
 729   Symbol* signature_ref_at(int which)           { return impl_signature_ref_at(which, false); }
 730 
 731   int klass_ref_index_at(int which)               { return impl_klass_ref_index_at(which, false); }
 732   int name_and_type_ref_index_at(int which)       { return impl_name_and_type_ref_index_at(which, false); }
 733 
 734   int remap_instruction_operand_from_cache(int operand);  // operand must be biased by CPCACHE_INDEX_TAG
 735 
 736   constantTag tag_ref_at(int cp_cache_index)      { return impl_tag_ref_at(cp_cache_index, false); }
 737 
 738   // Lookup for entries consisting of (name_index, signature_index)
 739   int name_ref_index_at(int which_nt);            // ==  low-order jshort of name_and_type_at(which_nt)
 740   int signature_ref_index_at(int which_nt);       // == high-order jshort of name_and_type_at(which_nt)
 741 
 742   BasicType basic_type_for_signature_at(int which) const;
 743 
 744   // Resolve string constants (to prevent allocation during compilation)
 745   void resolve_string_constants(TRAPS) {
 746     constantPoolHandle h_this(THREAD, this);
 747     resolve_string_constants_impl(h_this, CHECK);
 748   }
 749 
 750   // CDS support
 751   void archive_resolved_references(Thread *THREAD) NOT_CDS_JAVA_HEAP_RETURN;
 752   void resolve_class_constants(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 753   void remove_unshareable_info();
 754   void restore_unshareable_info(TRAPS);
 755   // The ConstantPool vtable is restored by this call when the ConstantPool is
 756   // in the shared archive.  See patch_klass_vtables() in metaspaceShared.cpp for
 757   // all the gory details.  SA, dtrace and pstack helpers distinguish metadata
 758   // by their vtable.
 759   void restore_vtable() { guarantee(is_constantPool(), &quot;vtable restored by this call&quot;); }
 760 
 761  private:
 762   enum { _no_index_sentinel = -1, _possible_index_sentinel = -2 };
 763  public:
 764 
 765   // Get the tag for a constant, which may involve a constant dynamic
 766   constantTag constant_tag_at(int which);
 767   // Get the basic type for a constant, which may involve a constant dynamic
 768   BasicType basic_type_for_constant_at(int which);
 769 
 770   // Resolve late bound constants.
 771   oop resolve_constant_at(int index, TRAPS) {
 772     constantPoolHandle h_this(THREAD, this);
 773     return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);
 774   }
 775 
 776   oop resolve_cached_constant_at(int cache_index, TRAPS) {
 777     constantPoolHandle h_this(THREAD, this);
 778     return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);
 779   }
 780 
 781   oop resolve_possibly_cached_constant_at(int pool_index, TRAPS) {
 782     constantPoolHandle h_this(THREAD, this);
 783     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);
 784   }
 785 
 786   oop find_cached_constant_at(int pool_index, bool&amp; found_it, TRAPS) {
 787     constantPoolHandle h_this(THREAD, this);
 788     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, &amp;found_it, THREAD);
 789   }
 790 
 791   void copy_bootstrap_arguments_at(int index,
 792                                    int start_arg, int end_arg,
 793                                    objArrayHandle info, int pos,
 794                                    bool must_resolve, Handle if_not_available, TRAPS) {
 795     constantPoolHandle h_this(THREAD, this);
 796     copy_bootstrap_arguments_at_impl(h_this, index, start_arg, end_arg,
 797                                      info, pos, must_resolve, if_not_available, THREAD);
 798   }
 799 
 800   // Klass name matches name at offset
 801   bool klass_name_at_matches(const InstanceKlass* k, int which);
 802 
 803   // Sizing
 804   int length() const                   { return _length; }
 805   void set_length(int length)          { _length = length; }
 806 
 807   // Tells whether index is within bounds.
 808   bool is_within_bounds(int index) const {
 809     return 0 &lt;= index &amp;&amp; index &lt; length();
 810   }
 811 
 812   // Sizing (in words)
 813   static int header_size()             {
 814     return align_up((int)sizeof(ConstantPool), wordSize) / wordSize;
 815   }
 816   static int size(int length)          { return align_metadata_size(header_size() + length); }
 817   int size() const                     { return size(length()); }
 818 
 819   // ConstantPools should be stored in the read-only region of CDS archive.
 820   static bool is_read_only_by_default() { return true; }
 821 
 822   friend class ClassFileParser;
 823   friend class SystemDictionary;
 824 
 825   // Used by CDS. These classes need to access the private ConstantPool() constructor.
 826   template &lt;class T&gt; friend class CppVtableTesterA;
 827   template &lt;class T&gt; friend class CppVtableTesterB;
 828   template &lt;class T&gt; friend class CppVtableCloner;
 829 
 830   // Used by compiler to prevent classloading.
 831   static Method*          method_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 832   static bool       has_appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 833   static oop            appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 834   static bool has_local_signature_at_if_loaded     (const constantPoolHandle&amp; this_cp, int which);
 835   static Klass*            klass_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 836 
 837   // Routines currently used for annotations (only called by jvm.cpp) but which might be used in the
 838   // future by other Java code. These take constant pool indices rather than
 839   // constant pool cache indices as do the peer methods above.
 840   Symbol* uncached_klass_ref_at_noresolve(int which);
 841   Symbol* uncached_name_ref_at(int which)                 { return impl_name_ref_at(which, true); }
 842   Symbol* uncached_signature_ref_at(int which)            { return impl_signature_ref_at(which, true); }
 843   int       uncached_klass_ref_index_at(int which)          { return impl_klass_ref_index_at(which, true); }
 844   int       uncached_name_and_type_ref_index_at(int which)  { return impl_name_and_type_ref_index_at(which, true); }
 845 
 846   // Sharing
 847   int pre_resolve_shared_klasses(TRAPS);
 848 
 849   // Debugging
 850   const char* printable_name_at(int which) PRODUCT_RETURN0;
 851 
 852 #ifdef ASSERT
 853   enum { CPCACHE_INDEX_TAG = 0x10000 };  // helps keep CP cache indices distinct from CP indices
 854 #else
 855   enum { CPCACHE_INDEX_TAG = 0 };        // in product mode, this zero value is a no-op
 856 #endif //ASSERT
 857 
 858   static int decode_cpcache_index(int raw_index, bool invokedynamic_ok = false) {
 859     if (invokedynamic_ok &amp;&amp; is_invokedynamic_index(raw_index))
 860       return decode_invokedynamic_index(raw_index);
 861     else
 862       return raw_index - CPCACHE_INDEX_TAG;
 863   }
 864 
 865  private:
 866 
 867   void set_resolved_references(OopHandle s) { _cache-&gt;set_resolved_references(s); }
 868   Array&lt;u2&gt;* reference_map() const        {  return (_cache == NULL) ? NULL :  _cache-&gt;reference_map(); }
 869   void set_reference_map(Array&lt;u2&gt;* o)    { _cache-&gt;set_reference_map(o); }
 870 
 871   // patch JSR 292 resolved references after the class is linked.
 872   void patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches);
 873 
 874   Symbol* impl_name_ref_at(int which, bool uncached);
 875   Symbol* impl_signature_ref_at(int which, bool uncached);
 876 
 877   int       impl_klass_ref_index_at(int which, bool uncached);
 878   int       impl_name_and_type_ref_index_at(int which, bool uncached);
 879   constantTag impl_tag_ref_at(int which, bool uncached);
 880 
 881   // Used while constructing constant pool (only by ClassFileParser)
 882   jint klass_index_at(int which) {
 883     assert(tag_at(which).is_klass_index(), &quot;Corrupted constant pool&quot;);
 884     return *int_at_addr(which);
 885   }
 886 
 887   jint string_index_at(int which) {
 888     assert(tag_at(which).is_string_index(), &quot;Corrupted constant pool&quot;);
 889     return *int_at_addr(which);
 890   }
 891 
 892   // Performs the LinkResolver checks
 893   static void verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* klass, TRAPS);
 894 
 895   // Implementation of methods that needs an exposed &#39;this&#39; pointer, in order to
 896   // handle GC while executing the method
 897   static Klass* klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 898                               bool save_resolution_error, TRAPS);
 899   static oop string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS);
 900 
 901   static void trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k);
 902 
 903   // Resolve string constants (to prevent allocation during compilation)
 904   static void resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS);
 905 
 906   static oop resolve_constant_at_impl(const constantPoolHandle&amp; this_cp, int index, int cache_index,
 907                                       bool* status_return, TRAPS);
 908   static void copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
 909                                                int start_arg, int end_arg,
 910                                                objArrayHandle info, int pos,
 911                                                bool must_resolve, Handle if_not_available, TRAPS);
 912 
 913   // Exception handling
 914   static Symbol* exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception);
 915   static void save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which, constantTag tag, TRAPS);
 916 
 917  public:
 918   // Exception handling
 919   static void throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS);
 920 
 921   // Merging ConstantPool* support:
 922   bool compare_entry_to(int index1, const constantPoolHandle&amp; cp2, int index2, TRAPS);
 923   void copy_cp_to(int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
 924     constantPoolHandle h_this(THREAD, this);
 925     copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);
 926   }
 927   static void copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 928   static void copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 929   static void copy_operands(const constantPoolHandle&amp; from_cp, const constantPoolHandle&amp; to_cp, TRAPS);
 930   int  find_matching_entry(int pattern_i, const constantPoolHandle&amp; search_cp, TRAPS);
 931   int  version() const                    { return _saved._version; }
 932   void set_version(int version)           { _saved._version = version; }
 933   void increment_and_save_version(int version) {
 934     _saved._version = version &gt;= 0 ? (version + 1) : version;  // keep overflow
 935   }
 936 
 937   void set_resolved_reference_length(int length) { _saved._resolved_reference_length = length; }
 938   int  resolved_reference_length() const  { return _saved._resolved_reference_length; }
 939 
 940   // Decrease ref counts of symbols that are in the constant pool
 941   // when the holder class is unloaded
 942   void unreference_symbols();
 943 
 944   // Deallocate constant pool for RedefineClasses
 945   void deallocate_contents(ClassLoaderData* loader_data);
 946   void release_C_heap_structures();
 947 
 948   // JVMTI accesss - GetConstantPool, RetransformClasses, ...
 949   friend class JvmtiConstantPoolReconstituter;
 950 
 951  private:
 952   jint cpool_entry_size(jint idx);
 953   jint hash_entries_to(SymbolHashMap *symmap, SymbolHashMap *classmap);
 954 
 955   // Copy cpool bytes into byte array.
 956   // Returns:
 957   //  int &gt; 0, count of the raw cpool bytes that have been copied
 958   //        0, OutOfMemory error
 959   //       -1, Internal error
 960   int  copy_cpool_bytes(int cpool_size,
 961                         SymbolHashMap* tbl,
 962                         unsigned char *bytes);
 963 
 964  public:
 965   // Verify
 966   void verify_on(outputStream* st);
 967 
 968   // Printing
 969   void print_on(outputStream* st) const;
 970   void print_value_on(outputStream* st) const;
 971   void print_entry_on(int index, outputStream* st);
 972 
 973   const char* internal_name() const { return &quot;{constant pool}&quot;; }
 974 };
 975 
 976 class SymbolHashMapEntry : public CHeapObj&lt;mtSymbol&gt; {
 977  private:
 978   unsigned int        _hash;   // 32-bit hash for item
 979   SymbolHashMapEntry* _next;   // Next element in the linked list for this bucket
 980   Symbol*             _symbol; // 1-st part of the mapping: symbol =&gt; value
 981   u2                  _value;  // 2-nd part of the mapping: symbol =&gt; value
 982 
 983  public:
 984   unsigned   int hash() const             { return _hash;   }
 985   void       set_hash(unsigned int hash)  { _hash = hash;   }
 986 
 987   SymbolHashMapEntry* next() const        { return _next;   }
 988   void set_next(SymbolHashMapEntry* next) { _next = next;   }
 989 
 990   Symbol*    symbol() const               { return _symbol; }
 991   void       set_symbol(Symbol* sym)      { _symbol = sym;  }
 992 
 993   u2         value() const                {  return _value; }
 994   void       set_value(u2 value)          { _value = value; }
 995 
 996   SymbolHashMapEntry(unsigned int hash, Symbol* symbol, u2 value)
 997     : _hash(hash), _next(NULL), _symbol(symbol), _value(value) {}
 998 
 999 }; // End SymbolHashMapEntry class
1000 
1001 
1002 class SymbolHashMapBucket : public CHeapObj&lt;mtSymbol&gt; {
1003 
1004 private:
1005   SymbolHashMapEntry*    _entry;
1006 
1007 public:
1008   SymbolHashMapEntry* entry() const         {  return _entry; }
1009   void set_entry(SymbolHashMapEntry* entry) { _entry = entry; }
1010   void clear()                              { _entry = NULL;  }
1011 
1012 }; // End SymbolHashMapBucket class
1013 
1014 
1015 class SymbolHashMap: public CHeapObj&lt;mtSymbol&gt; {
1016 
1017  private:
1018   // Default number of entries in the table
1019   enum SymbolHashMap_Constants {
1020     _Def_HashMap_Size = 256
1021   };
1022 
1023   int                   _table_size;
1024   SymbolHashMapBucket*  _buckets;
1025 
1026   void initialize_table(int table_size);
1027 
1028  public:
1029 
1030   int table_size() const        { return _table_size; }
1031 
1032   SymbolHashMap()               { initialize_table(_Def_HashMap_Size); }
1033   SymbolHashMap(int table_size) { initialize_table(table_size); }
1034 
1035   // hash P(31) from Kernighan &amp; Ritchie
1036   static unsigned int compute_hash(const char* str, int len) {
1037     unsigned int hash = 0;
1038     while (len-- &gt; 0) {
1039       hash = 31*hash + (unsigned) *str;
1040       str++;
1041     }
1042     return hash;
1043   }
1044 
1045   SymbolHashMapEntry* bucket(int i) {
1046     return _buckets[i].entry();
1047   }
1048 
1049   void add_entry(Symbol* sym, u2 value);
1050   SymbolHashMapEntry* find_entry(Symbol* sym);
1051 
1052   u2 symbol_to_value(Symbol* sym) {
1053     SymbolHashMapEntry *entry = find_entry(sym);
1054     return (entry == NULL) ? 0 : entry-&gt;value();
1055   }
1056 
1057   ~SymbolHashMap();
1058 }; // End SymbolHashMap class
1059 
1060 #endif // SHARE_OOPS_CONSTANTPOOL_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 609   bool          method_has_option(const char * option) {
 610     return method() != NULL &amp;&amp; method()-&gt;has_option(option);
 611   }
 612 
 613 #ifndef PRODUCT
 614   bool          trace_opto_output() const       { return _trace_opto_output; }
 615   bool          print_ideal() const             { return _print_ideal; }
 616   bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
 617   void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
 618   int _in_dump_cnt;  // Required for dumping ir nodes.
 619 #endif
 620   bool              has_irreducible_loop() const { return _has_irreducible_loop; }
 621   void          set_has_irreducible_loop(bool z) { _has_irreducible_loop = z; }
 622 
 623   // JSR 292
 624   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
 625   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 626 
 627   Ticks _latest_stage_start_counter;
 628 
<span class="line-modified"> 629   void begin_method() {</span>
 630 #ifndef PRODUCT
<span class="line-modified"> 631     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {</span>
 632       _printer-&gt;begin_method();
 633     }
 634 #endif
 635     C-&gt;_latest_stage_start_counter.stamp();
 636   }
 637 
 638   bool should_print(int level = 1) {
 639 #ifndef PRODUCT
<span class="line-modified"> 640     return (_printer &amp;&amp; _printer-&gt;should_print(level));</span>










 641 #else
 642     return false;
 643 #endif
 644   }
 645 
 646   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0);
 647 
 648 #ifndef PRODUCT
 649   void igv_print_method_to_file(const char* phase_name = &quot;Debug&quot;, bool append = false);
 650   void igv_print_method_to_network(const char* phase_name = &quot;Debug&quot;);
 651   static IdealGraphPrinter* debug_file_printer() { return _debug_file_printer; }
 652   static IdealGraphPrinter* debug_network_printer() { return _debug_network_printer; }
 653 #endif
 654 
 655   void end_method(int level = 1);
 656 
 657   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 658   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 659   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 660   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
</pre>
</td>
<td>
<hr />
<pre>
 609   bool          method_has_option(const char * option) {
 610     return method() != NULL &amp;&amp; method()-&gt;has_option(option);
 611   }
 612 
 613 #ifndef PRODUCT
 614   bool          trace_opto_output() const       { return _trace_opto_output; }
 615   bool          print_ideal() const             { return _print_ideal; }
 616   bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
 617   void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
 618   int _in_dump_cnt;  // Required for dumping ir nodes.
 619 #endif
 620   bool              has_irreducible_loop() const { return _has_irreducible_loop; }
 621   void          set_has_irreducible_loop(bool z) { _has_irreducible_loop = z; }
 622 
 623   // JSR 292
 624   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
 625   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 626 
 627   Ticks _latest_stage_start_counter;
 628 
<span class="line-modified"> 629   void begin_method(int level = 1) {</span>
 630 #ifndef PRODUCT
<span class="line-modified"> 631     if (_method != NULL &amp;&amp; should_print(level)) {</span>
 632       _printer-&gt;begin_method();
 633     }
 634 #endif
 635     C-&gt;_latest_stage_start_counter.stamp();
 636   }
 637 
 638   bool should_print(int level = 1) {
 639 #ifndef PRODUCT
<span class="line-modified"> 640     if (PrintIdealGraphLevel &lt; 0) { // disabled by the user</span>
<span class="line-added"> 641       return false;</span>
<span class="line-added"> 642     }</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644     bool need = directive()-&gt;IGVPrintLevelOption &gt;= level;</span>
<span class="line-added"> 645     if (need &amp;&amp; !_printer) {</span>
<span class="line-added"> 646       _printer = IdealGraphPrinter::printer();</span>
<span class="line-added"> 647       assert(_printer != NULL, &quot;_printer is NULL when we need it!&quot;);</span>
<span class="line-added"> 648       _printer-&gt;set_compile(this);</span>
<span class="line-added"> 649     }</span>
<span class="line-added"> 650     return need;</span>
 651 #else
 652     return false;
 653 #endif
 654   }
 655 
 656   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0);
 657 
 658 #ifndef PRODUCT
 659   void igv_print_method_to_file(const char* phase_name = &quot;Debug&quot;, bool append = false);
 660   void igv_print_method_to_network(const char* phase_name = &quot;Debug&quot;);
 661   static IdealGraphPrinter* debug_file_printer() { return _debug_file_printer; }
 662   static IdealGraphPrinter* debug_network_printer() { return _debug_network_printer; }
 663 #endif
 664 
 665   void end_method(int level = 1);
 666 
 667   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 668   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 669   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 670   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
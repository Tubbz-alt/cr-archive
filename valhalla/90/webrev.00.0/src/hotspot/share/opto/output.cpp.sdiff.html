<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="node.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/output.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;

  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
  38 #include &quot;opto/block.hpp&quot;
  39 #include &quot;opto/c2compiler.hpp&quot;
  40 #include &quot;opto/callnode.hpp&quot;
  41 #include &quot;opto/cfgnode.hpp&quot;
  42 #include &quot;opto/locknode.hpp&quot;
  43 #include &quot;opto/machnode.hpp&quot;
  44 #include &quot;opto/node.hpp&quot;
  45 #include &quot;opto/optoreg.hpp&quot;
  46 #include &quot;opto/output.hpp&quot;
  47 #include &quot;opto/regalloc.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
  50 #include &quot;opto/type.hpp&quot;
  51 #include &quot;runtime/handles.inline.hpp&quot;
  52 #include &quot;runtime/sharedRuntime.hpp&quot;
</pre>
<hr />
<pre>
1651       // Save the offset for the listing
1652 #if defined(SUPPORT_OPTO_ASSEMBLY)
1653       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1654         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1655       }
1656 #endif
1657 
1658       // &quot;Normal&quot; instruction case
1659       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
1660       n-&gt;emit(*cb, C-&gt;regalloc());
1661       current_offset  = cb-&gt;insts_size();
1662 
1663       // Above we only verified that there is enough space in the instruction section.
1664       // However, the instruction may emit stubs that cause code buffer expansion.
1665       // Bail out here if expansion failed due to a lack of code cache space.
1666       if (C-&gt;failing()) {
1667         return;
1668       }
1669 
1670 #ifdef ASSERT
<span class="line-modified">1671       if (n-&gt;size(C-&gt;regalloc()) &lt; (current_offset-instr_offset)) {</span>


1672         n-&gt;dump();







1673         assert(false, &quot;wrong size of mach node&quot;);
1674       }
1675 #endif
1676       non_safepoints.observe_instruction(n, current_offset);
1677 
1678       // mcall is last &quot;call&quot; that can be a safepoint
1679       // record it so we can see if a poll will directly follow it
1680       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1681       // see  5010568. This can be slightly inaccurate but conservative
1682       // in the case that return address is not actually at current_offset.
1683       // This is a small price to pay.
1684 
1685       if (is_mcall) {
1686         last_call_offset = current_offset;
1687       }
1688 
1689       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1690         // Avoid back to back some instructions.
1691         last_avoid_back_to_back_offset = current_offset;
1692       }
</pre>
</td>
<td>
<hr />
<pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
<span class="line-added">  33 #include &quot;compiler/disassembler.hpp&quot;</span>
  34 #include &quot;compiler/oopMap.hpp&quot;
  35 #include &quot;gc/shared/barrierSet.hpp&quot;
  36 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;opto/ad.hpp&quot;
  39 #include &quot;opto/block.hpp&quot;
  40 #include &quot;opto/c2compiler.hpp&quot;
  41 #include &quot;opto/callnode.hpp&quot;
  42 #include &quot;opto/cfgnode.hpp&quot;
  43 #include &quot;opto/locknode.hpp&quot;
  44 #include &quot;opto/machnode.hpp&quot;
  45 #include &quot;opto/node.hpp&quot;
  46 #include &quot;opto/optoreg.hpp&quot;
  47 #include &quot;opto/output.hpp&quot;
  48 #include &quot;opto/regalloc.hpp&quot;
  49 #include &quot;opto/runtime.hpp&quot;
  50 #include &quot;opto/subnode.hpp&quot;
  51 #include &quot;opto/type.hpp&quot;
  52 #include &quot;runtime/handles.inline.hpp&quot;
  53 #include &quot;runtime/sharedRuntime.hpp&quot;
</pre>
<hr />
<pre>
1652       // Save the offset for the listing
1653 #if defined(SUPPORT_OPTO_ASSEMBLY)
1654       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1655         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1656       }
1657 #endif
1658 
1659       // &quot;Normal&quot; instruction case
1660       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
1661       n-&gt;emit(*cb, C-&gt;regalloc());
1662       current_offset  = cb-&gt;insts_size();
1663 
1664       // Above we only verified that there is enough space in the instruction section.
1665       // However, the instruction may emit stubs that cause code buffer expansion.
1666       // Bail out here if expansion failed due to a lack of code cache space.
1667       if (C-&gt;failing()) {
1668         return;
1669       }
1670 
1671 #ifdef ASSERT
<span class="line-modified">1672       uint n_size = n-&gt;size(C-&gt;regalloc());</span>
<span class="line-added">1673       if (n_size &lt; (current_offset-instr_offset)) {</span>
<span class="line-added">1674         MachNode* mach = n-&gt;as_Mach();</span>
1675         n-&gt;dump();
<span class="line-added">1676         mach-&gt;dump_format(C-&gt;regalloc(), tty);</span>
<span class="line-added">1677         tty-&gt;print_cr(&quot; n_size (%d), current_offset (%d), instr_offset (%d)&quot;, n_size, current_offset, instr_offset);</span>
<span class="line-added">1678         Disassembler::decode(cb-&gt;insts_begin() + instr_offset, cb-&gt;insts_begin() + current_offset + 1, tty);</span>
<span class="line-added">1679         tty-&gt;print_cr(&quot; ------------------- &quot;);</span>
<span class="line-added">1680         BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-added">1681         address blob_begin = blob-&gt;content_begin();</span>
<span class="line-added">1682         Disassembler::decode(blob_begin, blob_begin + n_size + 1, tty);</span>
1683         assert(false, &quot;wrong size of mach node&quot;);
1684       }
1685 #endif
1686       non_safepoints.observe_instruction(n, current_offset);
1687 
1688       // mcall is last &quot;call&quot; that can be a safepoint
1689       // record it so we can see if a poll will directly follow it
1690       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1691       // see  5010568. This can be slightly inaccurate but conservative
1692       // in the case that return address is not actually at current_offset.
1693       // This is a small price to pay.
1694 
1695       if (is_mcall) {
1696         last_call_offset = current_offset;
1697       }
1698 
1699       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1700         // Avoid back to back some instructions.
1701         last_avoid_back_to_back_offset = current_offset;
1702       }
</pre>
</td>
</tr>
</table>
<center><a href="node.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 545       if (scratch_i != *merge_cp_length_p) {
 546         // The new entry in *merge_cp_p is at a different index than
 547         // the new entry in scratch_cp so we need to map the index values.
 548         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 549       }
 550       (*merge_cp_length_p)++;
 551     } break;
 552 
 553     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 554     // ClassIndex
 555     case JVM_CONSTANT_ClassIndex: // fall through
 556 
 557     // Invalid is used as the tag for the second constant pool entry
 558     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 559     // not be seen by itself.
 560     case JVM_CONSTANT_Invalid: // fall through
 561 
 562     // At this stage, String could be here, but not StringIndex
 563     case JVM_CONSTANT_StringIndex: // fall through
 564 
<span class="line-modified"> 565     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be</span>
<span class="line-removed"> 566     // here</span>
 567     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 568 
 569     default:
 570     {
 571       // leave a breadcrumb
 572       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 573       ShouldNotReachHere();
 574     } break;
 575   } // end switch tag value
 576 } // end append_entry()
 577 
 578 
 579 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 580       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 581 
 582   int new_ref_i = ref_i;
 583   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 584                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 585 
 586   if (!match) {
</pre>
</td>
<td>
<hr />
<pre>
 545       if (scratch_i != *merge_cp_length_p) {
 546         // The new entry in *merge_cp_p is at a different index than
 547         // the new entry in scratch_cp so we need to map the index values.
 548         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 549       }
 550       (*merge_cp_length_p)++;
 551     } break;
 552 
 553     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 554     // ClassIndex
 555     case JVM_CONSTANT_ClassIndex: // fall through
 556 
 557     // Invalid is used as the tag for the second constant pool entry
 558     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 559     // not be seen by itself.
 560     case JVM_CONSTANT_Invalid: // fall through
 561 
 562     // At this stage, String could be here, but not StringIndex
 563     case JVM_CONSTANT_StringIndex: // fall through
 564 
<span class="line-modified"> 565     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be here</span>

 566     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 567 
 568     default:
 569     {
 570       // leave a breadcrumb
 571       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 572       ShouldNotReachHere();
 573     } break;
 574   } // end switch tag value
 575 } // end append_entry()
 576 
 577 
 578 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 579       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 580 
 581   int new_ref_i = ref_i;
 582   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 583                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 584 
 585   if (!match) {
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
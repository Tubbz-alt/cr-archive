<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verifier.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52

  63 #define MAX_ARRAY_DIMENSIONS 255
  64 
  65 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  66 
  67 extern &quot;C&quot; {
  68   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
  69 }
  70 
  71 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
  72 
  73 static verify_byte_codes_fn_t verify_byte_codes_fn() {
  74 
  75   if (_verify_byte_codes_fn != NULL)
  76     return _verify_byte_codes_fn;
  77 
  78   MutexLocker locker(Verify_lock);
  79 
  80   if (_verify_byte_codes_fn != NULL)
  81     return _verify_byte_codes_fn;
  82 
</pre>
<hr />
<pre>
 254       }
 255       kls = kls-&gt;super();
 256     }
 257     if (message_buffer != NULL) {
 258       message_buffer[message_buffer_len - 1] = &#39;\0&#39;; // just to be sure
 259     }
 260     assert(exception_message != NULL, &quot;&quot;);
 261     THROW_MSG_(exception_name, exception_message, false);
 262   }
 263 }
 264 
 265 bool Verifier::is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class) {
 266   Symbol* name = klass-&gt;name();
 267   Klass* refl_magic_klass = SystemDictionary::reflect_MagicAccessorImpl_klass();
 268 
 269   bool is_reflect = refl_magic_klass != NULL &amp;&amp; klass-&gt;is_subtype_of(refl_magic_klass);
 270 
 271   return (should_verify_for(klass-&gt;class_loader(), should_verify_class) &amp;&amp;
 272     // return if the class is a bootstrapping class
 273     // or defineClass specified not to verify by default (flags override passed arg)
<span class="line-modified"> 274     // We need to skip the following four for bootstraping</span>
 275     name != vmSymbols::java_lang_Object() &amp;&amp;
 276     name != vmSymbols::java_lang_Class() &amp;&amp;
 277     name != vmSymbols::java_lang_String() &amp;&amp;
 278     name != vmSymbols::java_lang_Throwable() &amp;&amp;
 279 
 280     // Can not verify the bytecodes for shared classes because they have
 281     // already been rewritten to contain constant pool cache indices,
 282     // which the verifier can&#39;t understand.
 283     // Shared classes shouldn&#39;t have stackmaps either.
 284     !klass-&gt;is_shared() &amp;&amp;
 285 
 286     // As of the fix for 4486457 we disable verification for all of the
 287     // dynamically-generated bytecodes associated with the 1.4
 288     // reflection implementation, not just those associated with
 289     // jdk/internal/reflect/SerializationConstructorAccessor.
 290     // NOTE: this is called too early in the bootstrapping process to be
 291     // guarded by Universe::is_gte_jdk14x_version().
 292     // Also for lambda generated code, gte jdk8
 293     (!is_reflect));
 294 }
</pre>
<hr />
<pre>
 476       ss-&gt;print(&quot;Local index %d is invalid&quot;, _type.index());
 477       break;
 478     case LOCALS_SIZE_MISMATCH:
 479       ss-&gt;print(&quot;Current frame&#39;s local size doesn&#39;t match stackmap.&quot;);
 480       break;
 481     case STACK_SIZE_MISMATCH:
 482       ss-&gt;print(&quot;Current frame&#39;s stack size doesn&#39;t match stackmap.&quot;);
 483       break;
 484     case STACK_OVERFLOW:
 485       ss-&gt;print(&quot;Exceeded max stack size.&quot;);
 486       break;
 487     case STACK_UNDERFLOW:
 488       ss-&gt;print(&quot;Attempt to pop empty stack.&quot;);
 489       break;
 490     case MISSING_STACKMAP:
 491       ss-&gt;print(&quot;Expected stackmap frame at this location.&quot;);
 492       break;
 493     case BAD_STACKMAP:
 494       ss-&gt;print(&quot;Invalid stackmap specification.&quot;);
 495       break;







 496     case UNKNOWN:
 497     default:
 498       ShouldNotReachHere();
 499       ss-&gt;print_cr(&quot;Unknown&quot;);
 500   }
 501   ss-&gt;cr();
 502 }
 503 
 504 void ErrorContext::location_details(outputStream* ss, const Method* method) const {
 505   if (_bci != -1 &amp;&amp; method != NULL) {
 506     streamIndentor si(ss);
 507     const char* bytecode_name = &quot;&lt;invalid&gt;&quot;;
 508     if (method-&gt;validate_bci(_bci) != -1) {
 509       Bytecodes::Code code = Bytecodes::code_or_bp_at(method-&gt;bcp_from(_bci));
 510       if (Bytecodes::is_defined(code)) {
 511           bytecode_name = Bytecodes::name(code);
 512       } else {
 513           bytecode_name = &quot;&lt;illegal&gt;&quot;;
 514       }
 515     }
</pre>
<hr />
<pre>
 570     stack_map_frame* sm_frame = sm_table-&gt;entries();
 571     streamIndentor si2(ss);
 572     int current_offset = -1;
 573     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 574     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 575       ss-&gt;indent();
 576       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 577         sm_frame-&gt;print_truncated(ss, current_offset);
 578         return;
 579       }
 580       sm_frame-&gt;print_on(ss, current_offset);
 581       ss-&gt;cr();
 582       current_offset += sm_frame-&gt;offset_delta();
 583       sm_frame = sm_frame-&gt;next();
 584     }
 585   }
 586 }
 587 
 588 // Methods in ClassVerifier
 589 








 590 ClassVerifier::ClassVerifier(
 591     InstanceKlass* klass, TRAPS)
 592     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
 593       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="line-modified"> 594   _this_type = VerificationType::reference_type(klass-&gt;name());</span>
 595 }
 596 
 597 ClassVerifier::~ClassVerifier() {
 598   // Decrement the reference count for any symbols created.
 599   if (_symbols != NULL) {
 600     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 601       Symbol* s = _symbols-&gt;at(i);
 602       s-&gt;decrement_refcount();
 603     }
 604   }
 605 }
 606 
 607 VerificationType ClassVerifier::object_type() const {
 608   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 609 }
 610 
 611 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
 612   VerificationType vt = VerificationType::reference_type(
 613                          create_temporary_symbol(sig, (int)strlen(sig)));
 614   return TypeOrigin::implicit(vt);
</pre>
<hr />
<pre>
1019         case Bytecodes::_daload :
1020           type = current_frame.pop_stack(
1021             VerificationType::integer_type(), CHECK_VERIFY(this));
1022           atype = current_frame.pop_stack(
1023             VerificationType::reference_check(), CHECK_VERIFY(this));
1024           if (!atype.is_double_array()) {
1025             verify_error(ErrorContext::bad_type(bci,
1026                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),
1027                 bad_type_msg, &quot;daload&quot;);
1028             return;
1029           }
1030           current_frame.push_stack_2(
1031             VerificationType::double_type(),
1032             VerificationType::double2_type(), CHECK_VERIFY(this));
1033           no_control_flow = false; break;
1034         case Bytecodes::_aaload : {
1035           type = current_frame.pop_stack(
1036             VerificationType::integer_type(), CHECK_VERIFY(this));
1037           atype = current_frame.pop_stack(
1038             VerificationType::reference_check(), CHECK_VERIFY(this));
<span class="line-modified">1039           if (!atype.is_reference_array()) {</span>
1040             verify_error(ErrorContext::bad_type(bci,
1041                 current_frame.stack_top_ctx(),
1042                 TypeOrigin::implicit(VerificationType::reference_check())),
1043                 bad_type_msg, &quot;aaload&quot;);
1044             return;
1045           }
1046           if (atype.is_null()) {
1047             current_frame.push_stack(
1048               VerificationType::null_type(), CHECK_VERIFY(this));
1049           } else {
1050             VerificationType component =
1051               atype.get_component(this, CHECK_VERIFY(this));
1052             current_frame.push_stack(component, CHECK_VERIFY(this));
1053           }
1054           no_control_flow = false; break;
1055         }
1056         case Bytecodes::_istore :
1057           verify_istore(bcs.get_index(), &amp;current_frame, CHECK_VERIFY(this));
1058           no_control_flow = false; break;
1059         case Bytecodes::_istore_0 :
</pre>
<hr />
<pre>
1193             VerificationType::double2_type(),
1194             VerificationType::double_type(), CHECK_VERIFY(this));
1195           current_frame.pop_stack(
1196             VerificationType::integer_type(), CHECK_VERIFY(this));
1197           atype = current_frame.pop_stack(
1198             VerificationType::reference_check(), CHECK_VERIFY(this));
1199           if (!atype.is_double_array()) {
1200             verify_error(ErrorContext::bad_type(bci,
1201                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),
1202                 bad_type_msg, &quot;dastore&quot;);
1203             return;
1204           }
1205           no_control_flow = false; break;
1206         case Bytecodes::_aastore :
1207           type = current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1208           type2 = current_frame.pop_stack(
1209             VerificationType::integer_type(), CHECK_VERIFY(this));
1210           atype = current_frame.pop_stack(
1211             VerificationType::reference_check(), CHECK_VERIFY(this));
1212           // more type-checking is done at runtime
<span class="line-modified">1213           if (!atype.is_reference_array()) {</span>
1214             verify_error(ErrorContext::bad_type(bci,
1215                 current_frame.stack_top_ctx(),
1216                 TypeOrigin::implicit(VerificationType::reference_check())),
1217                 bad_type_msg, &quot;aastore&quot;);
1218             return;
1219           }
1220           // 4938384: relaxed constraint in JVMS 3nd edition.
1221           no_control_flow = false; break;
1222         case Bytecodes::_pop :
1223           current_frame.pop_stack(
1224             VerificationType::category1_check(), CHECK_VERIFY(this));
1225           no_control_flow = false; break;
1226         case Bytecodes::_pop2 :
1227           type = current_frame.pop_stack(CHECK_VERIFY(this));
1228           if (type.is_category1()) {
1229             current_frame.pop_stack(
1230               VerificationType::category1_check(), CHECK_VERIFY(this));
1231           } else if (type.is_category2_2nd()) {
1232             current_frame.pop_stack(
1233               VerificationType::category2_check(), CHECK_VERIFY(this));
</pre>
<hr />
<pre>
1593         case Bytecodes::_if_icmpgt:
1594         case Bytecodes::_if_icmple:
1595           current_frame.pop_stack(
1596             VerificationType::integer_type(), CHECK_VERIFY(this));
1597           // fall through
1598         case Bytecodes::_ifeq:
1599         case Bytecodes::_ifne:
1600         case Bytecodes::_iflt:
1601         case Bytecodes::_ifge:
1602         case Bytecodes::_ifgt:
1603         case Bytecodes::_ifle:
1604           current_frame.pop_stack(
1605             VerificationType::integer_type(), CHECK_VERIFY(this));
1606           target = bcs.dest();
1607           stackmap_table.check_jump_target(
1608             &amp;current_frame, target, CHECK_VERIFY(this));
1609           no_control_flow = false; break;
1610         case Bytecodes::_if_acmpeq :
1611         case Bytecodes::_if_acmpne :
1612           current_frame.pop_stack(
<span class="line-modified">1613             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
1614           // fall through
1615         case Bytecodes::_ifnull :
1616         case Bytecodes::_ifnonnull :
1617           current_frame.pop_stack(
<span class="line-modified">1618             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
1619           target = bcs.dest();
1620           stackmap_table.check_jump_target
1621             (&amp;current_frame, target, CHECK_VERIFY(this));
1622           no_control_flow = false; break;
1623         case Bytecodes::_goto :
1624           target = bcs.dest();
1625           stackmap_table.check_jump_target(
1626             &amp;current_frame, target, CHECK_VERIFY(this));
1627           no_control_flow = true; break;
1628         case Bytecodes::_goto_w :
1629           target = bcs.dest_w();
1630           stackmap_table.check_jump_target(
1631             &amp;current_frame, target, CHECK_VERIFY(this));
1632           no_control_flow = true; break;
1633         case Bytecodes::_tableswitch :
1634         case Bytecodes::_lookupswitch :
1635           verify_switch(
1636             &amp;bcs, code_length, code_data, &amp;current_frame,
1637             &amp;stackmap_table, CHECK_VERIFY(this));
1638           no_control_flow = true; break;
</pre>
<hr />
<pre>
1649             VerificationType::long_type(), CHECK_VERIFY(this));
1650           verify_return_value(return_type, type, bci,
1651                               &amp;current_frame, CHECK_VERIFY(this));
1652           no_control_flow = true; break;
1653         case Bytecodes::_freturn :
1654           type = current_frame.pop_stack(
1655             VerificationType::float_type(), CHECK_VERIFY(this));
1656           verify_return_value(return_type, type, bci,
1657                               &amp;current_frame, CHECK_VERIFY(this));
1658           no_control_flow = true; break;
1659         case Bytecodes::_dreturn :
1660           type2 = current_frame.pop_stack(
1661             VerificationType::double2_type(),  CHECK_VERIFY(this));
1662           type = current_frame.pop_stack(
1663             VerificationType::double_type(), CHECK_VERIFY(this));
1664           verify_return_value(return_type, type, bci,
1665                               &amp;current_frame, CHECK_VERIFY(this));
1666           no_control_flow = true; break;
1667         case Bytecodes::_areturn :
1668           type = current_frame.pop_stack(
<span class="line-modified">1669             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
1670           verify_return_value(return_type, type, bci,
1671                               &amp;current_frame, CHECK_VERIFY(this));
1672           no_control_flow = true; break;
1673         case Bytecodes::_return :
1674           if (return_type != VerificationType::bogus_type()) {
1675             verify_error(ErrorContext::bad_code(bci),
1676                          &quot;Method expects a return value&quot;);
1677             return;
1678           }
1679           // Make sure &quot;this&quot; has been initialized if current method is an
1680           // &lt;init&gt;.
<span class="line-modified">1681           if (_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
1682               current_frame.flag_this_uninit()) {
1683             verify_error(ErrorContext::bad_code(bci),
1684                          &quot;Constructor must call super() or this() &quot;
1685                          &quot;before return&quot;);
1686             return;
1687           }
1688           no_control_flow = true; break;
1689         case Bytecodes::_getstatic :
1690         case Bytecodes::_putstatic :
1691           // pass TRUE, operand can be an array type for getstatic/putstatic.
1692           verify_field_instructions(
1693             &amp;bcs, &amp;current_frame, cp, true, CHECK_VERIFY(this));
1694           no_control_flow = false; break;
1695         case Bytecodes::_getfield :
1696         case Bytecodes::_putfield :
1697           // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
1698           verify_field_instructions(
1699             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1700           no_control_flow = false; break;











1701         case Bytecodes::_invokevirtual :
1702         case Bytecodes::_invokespecial :
1703         case Bytecodes::_invokestatic :
<span class="line-removed">1704           verify_invoke_instructions(</span>
<span class="line-removed">1705             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),</span>
<span class="line-removed">1706             &amp;this_uninit, return_type, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
<span class="line-removed">1707           no_control_flow = false; break;</span>
1708         case Bytecodes::_invokeinterface :
1709         case Bytecodes::_invokedynamic :
1710           verify_invoke_instructions(
1711             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
<span class="line-modified">1712             &amp;this_uninit, return_type, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
1713           no_control_flow = false; break;
1714         case Bytecodes::_new :
1715         {
1716           index = bcs.get_index_u2();
1717           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1718           VerificationType new_class_type =
1719             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1720           if (!new_class_type.is_object()) {
1721             verify_error(ErrorContext::bad_type(bci,
1722                 TypeOrigin::cp(index, new_class_type)),
1723                 &quot;Illegal new instruction&quot;);
1724             return;
1725           }
1726           type = VerificationType::uninitialized_type(bci);
1727           current_frame.push_stack(type, CHECK_VERIFY(this));
1728           no_control_flow = false; break;
1729         }






















1730         case Bytecodes::_newarray :
1731           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
1732           current_frame.pop_stack(
1733             VerificationType::integer_type(),  CHECK_VERIFY(this));
1734           current_frame.push_stack(type, CHECK_VERIFY(this));
1735           no_control_flow = false; break;
1736         case Bytecodes::_anewarray :
1737           verify_anewarray(
1738             bci, bcs.get_index_u2(), cp, &amp;current_frame, CHECK_VERIFY(this));
1739           no_control_flow = false; break;
1740         case Bytecodes::_arraylength :
1741           type = current_frame.pop_stack(
1742             VerificationType::reference_check(), CHECK_VERIFY(this));
1743           if (!(type.is_null() || type.is_array())) {
1744             verify_error(ErrorContext::bad_type(
1745                 bci, current_frame.stack_top_ctx()),
1746                 bad_type_msg, &quot;arraylength&quot;);
1747           }
1748           current_frame.push_stack(
1749             VerificationType::integer_type(), CHECK_VERIFY(this));
1750           no_control_flow = false; break;
1751         case Bytecodes::_checkcast :
1752         {
1753           index = bcs.get_index_u2();
1754           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1755           current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1756           VerificationType klass_type = cp_index_to_type(
1757             index, cp, CHECK_VERIFY(this));
1758           current_frame.push_stack(klass_type, CHECK_VERIFY(this));
1759           no_control_flow = false; break;
1760         }
1761         case Bytecodes::_instanceof : {
1762           index = bcs.get_index_u2();
1763           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1764           current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1765           current_frame.push_stack(
1766             VerificationType::integer_type(), CHECK_VERIFY(this));
1767           no_control_flow = false; break;
1768         }
1769         case Bytecodes::_monitorenter :
<span class="line-modified">1770         case Bytecodes::_monitorexit :</span>
<span class="line-modified">1771           current_frame.pop_stack(</span>
<span class="line-modified">1772             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
1773           no_control_flow = false; break;

1774         case Bytecodes::_multianewarray :
1775         {
1776           index = bcs.get_index_u2();
1777           u2 dim = *(bcs.bcp()+3);
1778           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1779           VerificationType new_array_type =
1780             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1781           if (!new_array_type.is_array()) {
1782             verify_error(ErrorContext::bad_type(bci,
1783                 TypeOrigin::cp(index, new_array_type)),
1784                 &quot;Illegal constant pool index in multianewarray instruction&quot;);
1785             return;
1786           }
1787           if (dim &lt; 1 || new_array_type.dimensions() &lt; dim) {
1788             verify_error(ErrorContext::bad_code(bci),
1789                 &quot;Illegal dimension in multianewarray instruction: %d&quot;, dim);
1790             return;
1791           }
1792           for (int i = 0; i &lt; dim; i++) {
1793             current_frame.pop_stack(
</pre>
<hr />
<pre>
2012   int nconstants = cp-&gt;length();
2013   if ((index &lt;= 0) || (index &gt;= nconstants)) {
2014     verify_error(ErrorContext::bad_cp_index(bci, index),
2015         &quot;Illegal constant pool index %d in class %s&quot;,
2016         index, cp-&gt;pool_holder()-&gt;external_name());
2017     return;
2018   }
2019 }
2020 
2021 void ClassVerifier::verify_cp_type(
2022     u2 bci, int index, const constantPoolHandle&amp; cp, unsigned int types, TRAPS) {
2023 
2024   // In some situations, bytecode rewriting may occur while we&#39;re verifying.
2025   // In this case, a constant pool cache exists and some indices refer to that
2026   // instead.  Be sure we don&#39;t pick up such indices by accident.
2027   // We must check was_recursively_verified() before we get here.
2028   guarantee(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
2029 
2030   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2031   unsigned int tag = cp-&gt;tag_at(index).value();

2032   if ((types &amp; (1 &lt;&lt; tag)) == 0) {
2033     verify_error(ErrorContext::bad_cp_index(bci, index),
2034       &quot;Illegal type at constant pool entry %d in class %s&quot;,
2035       index, cp-&gt;pool_holder()-&gt;external_name());
2036     return;
2037   }
2038 }
2039 
2040 void ClassVerifier::verify_cp_class_type(
2041     u2 bci, int index, const constantPoolHandle&amp; cp, TRAPS) {
2042   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2043   constantTag tag = cp-&gt;tag_at(index);
2044   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2045     verify_error(ErrorContext::bad_cp_index(bci, index),
2046         &quot;Illegal type at constant pool entry %d in class %s&quot;,
2047         index, cp-&gt;pool_holder()-&gt;external_name());
2048     return;
2049   }
2050 }
2051 
</pre>
<hr />
<pre>
2126   } else {
2127     Klass* member_klass = target_instance-&gt;find_field(field_name, field_sig, &amp;fd);
2128     if (member_klass != NULL &amp;&amp; fd.is_protected()) {
2129       if (!this_class-&gt;is_same_class_package(member_klass)) {
2130         return true;
2131       }
2132     }
2133   }
2134   return false;
2135 }
2136 
2137 void ClassVerifier::verify_ldc(
2138     int opcode, u2 index, StackMapFrame* current_frame,
2139     const constantPoolHandle&amp; cp, u2 bci, TRAPS) {
2140   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2141   constantTag tag = cp-&gt;tag_at(index);
2142   unsigned int types = 0;
2143   if (opcode == Bytecodes::_ldc || opcode == Bytecodes::_ldc_w) {
2144     if (!tag.is_unresolved_klass()) {
2145       types = (1 &lt;&lt; JVM_CONSTANT_Integer) | (1 &lt;&lt; JVM_CONSTANT_Float)
<span class="line-modified">2146             | (1 &lt;&lt; JVM_CONSTANT_String)  | (1 &lt;&lt; JVM_CONSTANT_Class)</span>
2147             | (1 &lt;&lt; JVM_CONSTANT_MethodHandle) | (1 &lt;&lt; JVM_CONSTANT_MethodType)
2148             | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
2149       // Note:  The class file parser already verified the legality of
2150       // MethodHandle and MethodType constants.
2151       verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2152     }
2153   } else {
2154     assert(opcode == Bytecodes::_ldc2_w, &quot;must be ldc2_w&quot;);
2155     types = (1 &lt;&lt; JVM_CONSTANT_Double) | (1 &lt;&lt; JVM_CONSTANT_Long)
2156           | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
2157     verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2158   }
2159   if (tag.is_string() &amp;&amp; cp-&gt;is_pseudo_string_at(index)) {
2160     current_frame-&gt;push_stack(object_type(), CHECK_VERIFY(this));
2161   } else if (tag.is_string()) {
2162     current_frame-&gt;push_stack(
2163       VerificationType::reference_type(
2164         vmSymbols::java_lang_String()), CHECK_VERIFY(this));
2165   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
2166     current_frame-&gt;push_stack(
</pre>
<hr />
<pre>
2302                                               StackMapFrame* current_frame,
2303                                               const constantPoolHandle&amp; cp,
2304                                               bool allow_arrays,
2305                                               TRAPS) {
2306   u2 index = bcs-&gt;get_index_u2();
2307   verify_cp_type(bcs-&gt;bci(), index, cp,
2308       1 &lt;&lt; JVM_CONSTANT_Fieldref, CHECK_VERIFY(this));
2309 
2310   // Get field name and signature
2311   Symbol* field_name = cp-&gt;name_ref_at(index);
2312   Symbol* field_sig = cp-&gt;signature_ref_at(index);
2313 
2314   // Field signature was checked in ClassFileParser.
2315   assert(SignatureVerifier::is_valid_type_signature(field_sig),
2316          &quot;Invalid field signature&quot;);
2317 
2318   // Get referenced class type
2319   VerificationType ref_class_type = cp_ref_index_to_type(
2320     index, cp, CHECK_VERIFY(this));
2321   if (!ref_class_type.is_object() &amp;&amp;
<span class="line-modified">2322     (!allow_arrays || !ref_class_type.is_array())) {</span>
2323     verify_error(ErrorContext::bad_type(bcs-&gt;bci(),
2324         TypeOrigin::cp(index, ref_class_type)),
2325         &quot;Expecting reference to class in class %s at constant pool index %d&quot;,
2326         _klass-&gt;external_name(), index);
2327     return;
2328   }

2329   VerificationType target_class_type = ref_class_type;
2330 
2331   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2332         &quot;buffer type must match VerificationType size&quot;);
2333   uintptr_t field_type_buffer[2];
2334   VerificationType* field_type = (VerificationType*)field_type_buffer;
2335   // If we make a VerificationType[2] array directly, the compiler calls
2336   // to the c-runtime library to do the allocation instead of just
2337   // stack allocating it.  Plus it would run constructors.  This shows up
2338   // in performance profiles.
2339 
2340   SignatureStream sig_stream(field_sig, false);
2341   VerificationType stack_object_type;
2342   int n = change_sig_to_verificationType(&amp;sig_stream, field_type);
2343   u2 bci = bcs-&gt;bci();
2344   bool is_assignable;
2345   switch (bcs-&gt;raw_code()) {
2346     case Bytecodes::_getstatic: {
2347       for (int i = 0; i &lt; n; i++) {
2348         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2349       }
2350       break;
2351     }
2352     case Bytecodes::_putstatic: {
2353       for (int i = n - 1; i &gt;= 0; i--) {
2354         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2355       }
2356       break;
2357     }



















2358     case Bytecodes::_getfield: {
2359       stack_object_type = current_frame-&gt;pop_stack(
2360         target_class_type, CHECK_VERIFY(this));
2361       for (int i = 0; i &lt; n; i++) {
2362         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2363       }
2364       goto check_protected;
2365     }
2366     case Bytecodes::_putfield: {
2367       for (int i = n - 1; i &gt;= 0; i--) {
2368         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2369       }
2370       stack_object_type = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2371 
2372       // The JVMS 2nd edition allows field initialization before the superclass
2373       // initializer, if the field is defined within the current class.
2374       fieldDescriptor fd;
2375       if (stack_object_type == VerificationType::uninitialized_this_type() &amp;&amp;
2376           target_class_type.equals(current_type()) &amp;&amp;
2377           _klass-&gt;find_local_field(field_name, field_sig, &amp;fd)) {
</pre>
<hr />
<pre>
2746 bool ClassVerifier::is_same_or_direct_interface(
2747     InstanceKlass* klass,
2748     VerificationType klass_type,
2749     VerificationType ref_class_type) {
2750   if (ref_class_type.equals(klass_type)) return true;
2751   Array&lt;InstanceKlass*&gt;* local_interfaces = klass-&gt;local_interfaces();
2752   if (local_interfaces != NULL) {
2753     for (int x = 0; x &lt; local_interfaces-&gt;length(); x++) {
2754       InstanceKlass* k = local_interfaces-&gt;at(x);
2755       assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
2756       if (ref_class_type.equals(VerificationType::reference_type(k-&gt;name()))) {
2757         return true;
2758       }
2759     }
2760   }
2761   return false;
2762 }
2763 
2764 void ClassVerifier::verify_invoke_instructions(
2765     RawBytecodeStream* bcs, u4 code_length, StackMapFrame* current_frame,
<span class="line-modified">2766     bool in_try_block, bool *this_uninit, VerificationType return_type,</span>
2767     const constantPoolHandle&amp; cp, StackMapTable* stackmap_table, TRAPS) {
2768   // Make sure the constant pool item is the right type
2769   u2 index = bcs-&gt;get_index_u2();
2770   Bytecodes::Code opcode = bcs-&gt;raw_code();
2771   unsigned int types = 0;
2772   switch (opcode) {
2773     case Bytecodes::_invokeinterface:
2774       types = 1 &lt;&lt; JVM_CONSTANT_InterfaceMethodref;
2775       break;
2776     case Bytecodes::_invokedynamic:
2777       types = 1 &lt;&lt; JVM_CONSTANT_InvokeDynamic;
2778       break;
2779     case Bytecodes::_invokespecial:
2780     case Bytecodes::_invokestatic:
2781       types = (_klass-&gt;major_version() &lt; STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION) ?
2782         (1 &lt;&lt; JVM_CONSTANT_Methodref) :
2783         ((1 &lt;&lt; JVM_CONSTANT_InterfaceMethodref) | (1 &lt;&lt; JVM_CONSTANT_Methodref));
2784       break;
2785     default:
2786       types = 1 &lt;&lt; JVM_CONSTANT_Methodref;
2787   }
2788   verify_cp_type(bcs-&gt;bci(), index, cp, types, CHECK_VERIFY(this));
2789 
2790   // Get method name and signature
2791   Symbol* method_name = cp-&gt;name_ref_at(index);
2792   Symbol* method_sig = cp-&gt;signature_ref_at(index);
2793 
2794   // Method signature was checked in ClassFileParser.
2795   assert(SignatureVerifier::is_valid_method_signature(method_sig),
2796          &quot;Invalid method signature&quot;);
2797 
<span class="line-modified">2798   // Get referenced class type</span>
2799   VerificationType ref_class_type;
2800   if (opcode == Bytecodes::_invokedynamic) {
2801     if (_klass-&gt;major_version() &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
2802       class_format_error(
2803         &quot;invokedynamic instructions not supported by this class file version (%d), class %s&quot;,
2804         _klass-&gt;major_version(), _klass-&gt;external_name());
2805       return;
2806     }
2807   } else {
2808     ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
2809   }
2810 
2811   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2812         &quot;buffer type must match VerificationType size&quot;);
2813 
2814   // Get the UTF8 index for this signature.
2815   int sig_index = cp-&gt;signature_ref_index_at(cp-&gt;name_and_type_ref_index_at(index));
2816 
2817   // Get the signature&#39;s verification types.
2818   sig_as_verification_types* mth_sig_verif_types;
</pre>
<hr />
<pre>
2844           &quot;Inconsistent args count operand in invokeinterface&quot;);
2845       return;
2846     }
2847     if (*(bcp+4) != 0) {
2848       verify_error(ErrorContext::bad_code(bci),
2849           &quot;Fourth operand byte of invokeinterface must be zero&quot;);
2850       return;
2851     }
2852   }
2853 
2854   if (opcode == Bytecodes::_invokedynamic) {
2855     address bcp = bcs-&gt;bcp();
2856     if (*(bcp+3) != 0 || *(bcp+4) != 0) {
2857       verify_error(ErrorContext::bad_code(bci),
2858           &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
2859       return;
2860     }
2861   }
2862 
2863   if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">2864     // Make sure &lt;init&gt; can only be invoked by invokespecial</span>
<span class="line-modified">2865     if (opcode != Bytecodes::_invokespecial ||</span>


2866         method_name != vmSymbols::object_initializer_name()) {
2867       verify_error(ErrorContext::bad_code(bci),
2868           &quot;Illegal call to internal method&quot;);
2869       return;
2870     }
2871   } else if (opcode == Bytecodes::_invokespecial
2872              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2873              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
<span class="line-modified">2874                   current_class()-&gt;super()-&gt;name()))) {</span>
2875     bool subtype = false;
2876     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2877     if (!current_class()-&gt;is_unsafe_anonymous()) {
2878       subtype = ref_class_type.is_assignable_from(
2879                  current_type(), this, false, CHECK_VERIFY(this));
2880     } else {
<span class="line-modified">2881       VerificationType unsafe_anonymous_host_type =</span>
<span class="line-modified">2882                         VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());</span>
2883       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
2884 
2885       // If invokespecial of IMR, need to recheck for same or
2886       // direct interface relative to the host class
2887       have_imr_indirect = (have_imr_indirect &amp;&amp;
2888                            !is_same_or_direct_interface(
<span class="line-modified">2889                              current_class()-&gt;unsafe_anonymous_host(),</span>
2890                              unsafe_anonymous_host_type, ref_class_type));
2891     }
2892     if (!subtype) {
2893       verify_error(ErrorContext::bad_code(bci),
2894           &quot;Bad invokespecial instruction: &quot;
2895           &quot;current class isn&#39;t assignable to reference class.&quot;);
2896        return;
2897     } else if (have_imr_indirect) {
2898       verify_error(ErrorContext::bad_code(bci),
2899           &quot;Bad invokespecial instruction: &quot;
2900           &quot;interface method reference is in an indirect superinterface.&quot;);
2901       return;
2902     }
2903 
2904   }
2905 
2906   // Get the verification types for the method&#39;s arguments.
2907   GrowableArray&lt;VerificationType&gt;* sig_verif_types = mth_sig_verif_types-&gt;sig_verif_types();
2908   assert(sig_verif_types != NULL, &quot;Missing signature&#39;s array of verification types&quot;);
2909   // Match method descriptor with operand stack
2910   // The arguments are on the stack in descending order.
2911   for (int i = nargs - 1; i &gt;= 0; i--) { // Run backwards
2912     current_frame-&gt;pop_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
2913   }
2914 
2915   // Check objectref on operand stack
2916   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2917       opcode != Bytecodes::_invokedynamic) {
2918     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method

2919       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2920         code_length, in_try_block, this_uninit, cp, stackmap_table,
2921         CHECK_VERIFY(this));
2922       if (was_recursively_verified()) return;
2923     } else {   // other methods
2924       // Ensures that target class is assignable to method class.
2925       if (opcode == Bytecodes::_invokespecial) {
2926         if (!current_class()-&gt;is_unsafe_anonymous()) {
2927           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2928         } else {
2929           // anonymous class invokespecial calls: check if the
2930           // objectref is a subtype of the unsafe_anonymous_host of the current class
2931           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2932           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
<span class="line-modified">2933           VerificationType hosttype =</span>
<span class="line-modified">2934             VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());</span>
<span class="line-modified">2935           bool subtype = hosttype.is_assignable_from(top, this, false, CHECK_VERIFY(this));</span>

2936           if (!subtype) {
2937             verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
2938               current_frame-&gt;stack_top_ctx(),
2939               TypeOrigin::implicit(top)),
2940               &quot;Bad type on operand stack&quot;);
2941             return;
2942           }
2943         }
2944       } else if (opcode == Bytecodes::_invokevirtual) {
2945         VerificationType stack_object_type =
2946           current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
2947         if (current_type() != stack_object_type) {
2948           if (was_recursively_verified()) return;
2949           assert(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
2950           Symbol* ref_class_name =
2951             cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(index));
2952           // See the comments in verify_field_instructions() for
2953           // the rationale behind this.
2954           if (name_in_supers(ref_class_name, current_class())) {
2955             Klass* ref_class = load_class(ref_class_name, CHECK);
</pre>
<hr />
<pre>
2968                 } else {
2969                   verify_error(ErrorContext::bad_type(bci,
2970                       current_frame-&gt;stack_top_ctx(),
2971                       TypeOrigin::implicit(current_type())),
2972                       &quot;Bad access to protected data in invokevirtual&quot;);
2973                   return;
2974                 }
2975               }
2976             }
2977           }
2978         }
2979       } else {
2980         assert(opcode == Bytecodes::_invokeinterface, &quot;Unexpected opcode encountered&quot;);
2981         current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
2982       }
2983     }
2984   }
2985   // Push the result type.
2986   int sig_verif_types_len = sig_verif_types-&gt;length();
2987   if (sig_verif_types_len &gt; nargs) {  // There&#39;s a return type
<span class="line-modified">2988     if (method_name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">2989       // &lt;init&gt; method must have a void return type</span>
<span class="line-modified">2990       /* Unreachable?  Class file parser verifies that methods with &#39;&lt;&#39; have</span>
<span class="line-removed">2991        * void return */</span>
2992       verify_error(ErrorContext::bad_code(bci),
2993           &quot;Return type must be void in &lt;init&gt; method&quot;);
2994       return;
2995     }
2996 
2997     assert(sig_verif_types_len &lt;= nargs + 2,
2998            &quot;Signature verification types array return type is bogus&quot;);
2999     for (int i = nargs; i &lt; sig_verif_types_len; i++) {
3000       assert(i == nargs || sig_verif_types-&gt;at(i).is_long2() ||
3001              sig_verif_types-&gt;at(i).is_double2(), &quot;Unexpected return verificationType&quot;);
3002       current_frame-&gt;push_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
3003     }








3004   }
3005 }
3006 
3007 VerificationType ClassVerifier::get_newarray_type(
3008     u2 index, u2 bci, TRAPS) {
3009   const char* from_bt[] = {
3010     NULL, NULL, NULL, NULL, &quot;[Z&quot;, &quot;[C&quot;, &quot;[F&quot;, &quot;[D&quot;, &quot;[B&quot;, &quot;[S&quot;, &quot;[I&quot;, &quot;[J&quot;,
3011   };
3012   if (index &lt; T_BOOLEAN || index &gt; T_LONG) {
3013     verify_error(ErrorContext::bad_code(bci), &quot;Illegal newarray instruction&quot;);
3014     return VerificationType::bogus_type();
3015   }
3016 
3017   // from_bt[index] contains the array signature which has a length of 2
3018   Symbol* sig = create_temporary_symbol(from_bt[index], 2);
3019   return VerificationType::reference_type(sig);
3020 }
3021 
3022 void ClassVerifier::verify_anewarray(
3023     u2 bci, u2 index, const constantPoolHandle&amp; cp,
</pre>
<hr />
<pre>
3031     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3032   int length;
3033   char* arr_sig_str;
3034   if (component_type.is_array()) {     // it&#39;s an array
3035     const char* component_name = component_type.name()-&gt;as_utf8();
3036     // Check for more than MAX_ARRAY_DIMENSIONS
3037     length = (int)strlen(component_name);
3038     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3039         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3040       verify_error(ErrorContext::bad_code(bci),
3041         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3042     }
3043     // add one dimension to component
3044     length++;
3045     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3046     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3047                          JVM_SIGNATURE_ARRAY, component_name);
3048     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3049   } else {         // it&#39;s an object or interface
3050     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3051     // add one dimension to component with &#39;L&#39; prepended and &#39;;&#39; postpended.</span>

3052     length = (int)strlen(component_name) + 3;
3053     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3054     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
<span class="line-modified">3055                          JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);</span>
3056     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3057   }
3058   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3059   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3060   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3061 }
3062 
3063 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3064   current_frame-&gt;get_local(
3065     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3066   current_frame-&gt;push_stack(
3067     VerificationType::integer_type(), CHECK_VERIFY(this));
3068 }
3069 
3070 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
3071   current_frame-&gt;get_local_2(
3072     index, VerificationType::long_type(),
3073     VerificationType::long2_type(), CHECK_VERIFY(this));
3074   current_frame-&gt;push_stack_2(
3075     VerificationType::long_type(),
</pre>
<hr />
<pre>
3077 }
3078 
3079 void ClassVerifier::verify_fload(u2 index, StackMapFrame* current_frame, TRAPS) {
3080   current_frame-&gt;get_local(
3081     index, VerificationType::float_type(), CHECK_VERIFY(this));
3082   current_frame-&gt;push_stack(
3083     VerificationType::float_type(), CHECK_VERIFY(this));
3084 }
3085 
3086 void ClassVerifier::verify_dload(u2 index, StackMapFrame* current_frame, TRAPS) {
3087   current_frame-&gt;get_local_2(
3088     index, VerificationType::double_type(),
3089     VerificationType::double2_type(), CHECK_VERIFY(this));
3090   current_frame-&gt;push_stack_2(
3091     VerificationType::double_type(),
3092     VerificationType::double2_type(), CHECK_VERIFY(this));
3093 }
3094 
3095 void ClassVerifier::verify_aload(u2 index, StackMapFrame* current_frame, TRAPS) {
3096   VerificationType type = current_frame-&gt;get_local(
<span class="line-modified">3097     index, VerificationType::reference_check(), CHECK_VERIFY(this));</span>
3098   current_frame-&gt;push_stack(type, CHECK_VERIFY(this));
3099 }
3100 
3101 void ClassVerifier::verify_istore(u2 index, StackMapFrame* current_frame, TRAPS) {
3102   current_frame-&gt;pop_stack(
3103     VerificationType::integer_type(), CHECK_VERIFY(this));
3104   current_frame-&gt;set_local(
3105     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3106 }
3107 
3108 void ClassVerifier::verify_lstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3109   current_frame-&gt;pop_stack_2(
3110     VerificationType::long2_type(),
3111     VerificationType::long_type(), CHECK_VERIFY(this));
3112   current_frame-&gt;set_local_2(
3113     index, VerificationType::long_type(),
3114     VerificationType::long2_type(), CHECK_VERIFY(this));
3115 }
3116 
3117 void ClassVerifier::verify_fstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3118   current_frame-&gt;pop_stack(VerificationType::float_type(), CHECK_VERIFY(this));
3119   current_frame-&gt;set_local(
3120     index, VerificationType::float_type(), CHECK_VERIFY(this));
3121 }
3122 
3123 void ClassVerifier::verify_dstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3124   current_frame-&gt;pop_stack_2(
3125     VerificationType::double2_type(),
3126     VerificationType::double_type(), CHECK_VERIFY(this));
3127   current_frame-&gt;set_local_2(
3128     index, VerificationType::double_type(),
3129     VerificationType::double2_type(), CHECK_VERIFY(this));
3130 }
3131 
3132 void ClassVerifier::verify_astore(u2 index, StackMapFrame* current_frame, TRAPS) {
3133   VerificationType type = current_frame-&gt;pop_stack(
<span class="line-modified">3134     VerificationType::reference_check(), CHECK_VERIFY(this));</span>
3135   current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
3136 }
3137 
3138 void ClassVerifier::verify_iinc(u2 index, StackMapFrame* current_frame, TRAPS) {
3139   VerificationType type = current_frame-&gt;get_local(
3140     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3141   current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
3142 }
3143 
3144 void ClassVerifier::verify_return_value(
3145     VerificationType return_type, VerificationType type, u2 bci,
3146     StackMapFrame* current_frame, TRAPS) {
3147   if (return_type == VerificationType::bogus_type()) {
3148     verify_error(ErrorContext::bad_type(bci,
3149         current_frame-&gt;stack_top_ctx(), TypeOrigin::signature(return_type)),
3150         &quot;Method expects a return value&quot;);
3151     return;
3152   }
3153   bool match = return_type.is_assignable_from(type, this, false, CHECK_VERIFY(this));
3154   if (!match) {
</pre>
</td>
<td>
<hr />
<pre>
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
<span class="line-added">  63 #define INLINE_TYPE_MAJOR_VERSION                       56</span>
  64 #define MAX_ARRAY_DIMENSIONS 255
  65 
  66 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  67 
  68 extern &quot;C&quot; {
  69   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
  70 }
  71 
  72 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
  73 
  74 static verify_byte_codes_fn_t verify_byte_codes_fn() {
  75 
  76   if (_verify_byte_codes_fn != NULL)
  77     return _verify_byte_codes_fn;
  78 
  79   MutexLocker locker(Verify_lock);
  80 
  81   if (_verify_byte_codes_fn != NULL)
  82     return _verify_byte_codes_fn;
  83 
</pre>
<hr />
<pre>
 255       }
 256       kls = kls-&gt;super();
 257     }
 258     if (message_buffer != NULL) {
 259       message_buffer[message_buffer_len - 1] = &#39;\0&#39;; // just to be sure
 260     }
 261     assert(exception_message != NULL, &quot;&quot;);
 262     THROW_MSG_(exception_name, exception_message, false);
 263   }
 264 }
 265 
 266 bool Verifier::is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class) {
 267   Symbol* name = klass-&gt;name();
 268   Klass* refl_magic_klass = SystemDictionary::reflect_MagicAccessorImpl_klass();
 269 
 270   bool is_reflect = refl_magic_klass != NULL &amp;&amp; klass-&gt;is_subtype_of(refl_magic_klass);
 271 
 272   return (should_verify_for(klass-&gt;class_loader(), should_verify_class) &amp;&amp;
 273     // return if the class is a bootstrapping class
 274     // or defineClass specified not to verify by default (flags override passed arg)
<span class="line-modified"> 275     // We need to skip the following four for bootstrapping</span>
 276     name != vmSymbols::java_lang_Object() &amp;&amp;
 277     name != vmSymbols::java_lang_Class() &amp;&amp;
 278     name != vmSymbols::java_lang_String() &amp;&amp;
 279     name != vmSymbols::java_lang_Throwable() &amp;&amp;
 280 
 281     // Can not verify the bytecodes for shared classes because they have
 282     // already been rewritten to contain constant pool cache indices,
 283     // which the verifier can&#39;t understand.
 284     // Shared classes shouldn&#39;t have stackmaps either.
 285     !klass-&gt;is_shared() &amp;&amp;
 286 
 287     // As of the fix for 4486457 we disable verification for all of the
 288     // dynamically-generated bytecodes associated with the 1.4
 289     // reflection implementation, not just those associated with
 290     // jdk/internal/reflect/SerializationConstructorAccessor.
 291     // NOTE: this is called too early in the bootstrapping process to be
 292     // guarded by Universe::is_gte_jdk14x_version().
 293     // Also for lambda generated code, gte jdk8
 294     (!is_reflect));
 295 }
</pre>
<hr />
<pre>
 477       ss-&gt;print(&quot;Local index %d is invalid&quot;, _type.index());
 478       break;
 479     case LOCALS_SIZE_MISMATCH:
 480       ss-&gt;print(&quot;Current frame&#39;s local size doesn&#39;t match stackmap.&quot;);
 481       break;
 482     case STACK_SIZE_MISMATCH:
 483       ss-&gt;print(&quot;Current frame&#39;s stack size doesn&#39;t match stackmap.&quot;);
 484       break;
 485     case STACK_OVERFLOW:
 486       ss-&gt;print(&quot;Exceeded max stack size.&quot;);
 487       break;
 488     case STACK_UNDERFLOW:
 489       ss-&gt;print(&quot;Attempt to pop empty stack.&quot;);
 490       break;
 491     case MISSING_STACKMAP:
 492       ss-&gt;print(&quot;Expected stackmap frame at this location.&quot;);
 493       break;
 494     case BAD_STACKMAP:
 495       ss-&gt;print(&quot;Invalid stackmap specification.&quot;);
 496       break;
<span class="line-added"> 497     case WRONG_INLINE_TYPE:</span>
<span class="line-added"> 498       ss-&gt;print(&quot;Type &quot;);</span>
<span class="line-added"> 499       _type.details(ss);</span>
<span class="line-added"> 500       ss-&gt;print(&quot; and type &quot;);</span>
<span class="line-added"> 501       _expected.details(ss);</span>
<span class="line-added"> 502       ss-&gt;print(&quot; must be identical inline types.&quot;);</span>
<span class="line-added"> 503       break;</span>
 504     case UNKNOWN:
 505     default:
 506       ShouldNotReachHere();
 507       ss-&gt;print_cr(&quot;Unknown&quot;);
 508   }
 509   ss-&gt;cr();
 510 }
 511 
 512 void ErrorContext::location_details(outputStream* ss, const Method* method) const {
 513   if (_bci != -1 &amp;&amp; method != NULL) {
 514     streamIndentor si(ss);
 515     const char* bytecode_name = &quot;&lt;invalid&gt;&quot;;
 516     if (method-&gt;validate_bci(_bci) != -1) {
 517       Bytecodes::Code code = Bytecodes::code_or_bp_at(method-&gt;bcp_from(_bci));
 518       if (Bytecodes::is_defined(code)) {
 519           bytecode_name = Bytecodes::name(code);
 520       } else {
 521           bytecode_name = &quot;&lt;illegal&gt;&quot;;
 522       }
 523     }
</pre>
<hr />
<pre>
 578     stack_map_frame* sm_frame = sm_table-&gt;entries();
 579     streamIndentor si2(ss);
 580     int current_offset = -1;
 581     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 582     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 583       ss-&gt;indent();
 584       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 585         sm_frame-&gt;print_truncated(ss, current_offset);
 586         return;
 587       }
 588       sm_frame-&gt;print_on(ss, current_offset);
 589       ss-&gt;cr();
 590       current_offset += sm_frame-&gt;offset_delta();
 591       sm_frame = sm_frame-&gt;next();
 592     }
 593   }
 594 }
 595 
 596 // Methods in ClassVerifier
 597 
<span class="line-added"> 598 VerificationType reference_or_inline_type(InstanceKlass* klass) {</span>
<span class="line-added"> 599   if (klass-&gt;is_inline_klass()) {</span>
<span class="line-added"> 600     return VerificationType::inline_type(klass-&gt;name());</span>
<span class="line-added"> 601   } else {</span>
<span class="line-added"> 602     return VerificationType::reference_type(klass-&gt;name());</span>
<span class="line-added"> 603   }</span>
<span class="line-added"> 604 }</span>
<span class="line-added"> 605 </span>
 606 ClassVerifier::ClassVerifier(
 607     InstanceKlass* klass, TRAPS)
 608     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
 609       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="line-modified"> 610   _this_type = reference_or_inline_type(klass);</span>
 611 }
 612 
 613 ClassVerifier::~ClassVerifier() {
 614   // Decrement the reference count for any symbols created.
 615   if (_symbols != NULL) {
 616     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 617       Symbol* s = _symbols-&gt;at(i);
 618       s-&gt;decrement_refcount();
 619     }
 620   }
 621 }
 622 
 623 VerificationType ClassVerifier::object_type() const {
 624   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 625 }
 626 
 627 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
 628   VerificationType vt = VerificationType::reference_type(
 629                          create_temporary_symbol(sig, (int)strlen(sig)));
 630   return TypeOrigin::implicit(vt);
</pre>
<hr />
<pre>
1035         case Bytecodes::_daload :
1036           type = current_frame.pop_stack(
1037             VerificationType::integer_type(), CHECK_VERIFY(this));
1038           atype = current_frame.pop_stack(
1039             VerificationType::reference_check(), CHECK_VERIFY(this));
1040           if (!atype.is_double_array()) {
1041             verify_error(ErrorContext::bad_type(bci,
1042                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),
1043                 bad_type_msg, &quot;daload&quot;);
1044             return;
1045           }
1046           current_frame.push_stack_2(
1047             VerificationType::double_type(),
1048             VerificationType::double2_type(), CHECK_VERIFY(this));
1049           no_control_flow = false; break;
1050         case Bytecodes::_aaload : {
1051           type = current_frame.pop_stack(
1052             VerificationType::integer_type(), CHECK_VERIFY(this));
1053           atype = current_frame.pop_stack(
1054             VerificationType::reference_check(), CHECK_VERIFY(this));
<span class="line-modified">1055           if (!atype.is_nonscalar_array()) {</span>
1056             verify_error(ErrorContext::bad_type(bci,
1057                 current_frame.stack_top_ctx(),
1058                 TypeOrigin::implicit(VerificationType::reference_check())),
1059                 bad_type_msg, &quot;aaload&quot;);
1060             return;
1061           }
1062           if (atype.is_null()) {
1063             current_frame.push_stack(
1064               VerificationType::null_type(), CHECK_VERIFY(this));
1065           } else {
1066             VerificationType component =
1067               atype.get_component(this, CHECK_VERIFY(this));
1068             current_frame.push_stack(component, CHECK_VERIFY(this));
1069           }
1070           no_control_flow = false; break;
1071         }
1072         case Bytecodes::_istore :
1073           verify_istore(bcs.get_index(), &amp;current_frame, CHECK_VERIFY(this));
1074           no_control_flow = false; break;
1075         case Bytecodes::_istore_0 :
</pre>
<hr />
<pre>
1209             VerificationType::double2_type(),
1210             VerificationType::double_type(), CHECK_VERIFY(this));
1211           current_frame.pop_stack(
1212             VerificationType::integer_type(), CHECK_VERIFY(this));
1213           atype = current_frame.pop_stack(
1214             VerificationType::reference_check(), CHECK_VERIFY(this));
1215           if (!atype.is_double_array()) {
1216             verify_error(ErrorContext::bad_type(bci,
1217                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),
1218                 bad_type_msg, &quot;dastore&quot;);
1219             return;
1220           }
1221           no_control_flow = false; break;
1222         case Bytecodes::_aastore :
1223           type = current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1224           type2 = current_frame.pop_stack(
1225             VerificationType::integer_type(), CHECK_VERIFY(this));
1226           atype = current_frame.pop_stack(
1227             VerificationType::reference_check(), CHECK_VERIFY(this));
1228           // more type-checking is done at runtime
<span class="line-modified">1229           if (!atype.is_nonscalar_array()) {</span>
1230             verify_error(ErrorContext::bad_type(bci,
1231                 current_frame.stack_top_ctx(),
1232                 TypeOrigin::implicit(VerificationType::reference_check())),
1233                 bad_type_msg, &quot;aastore&quot;);
1234             return;
1235           }
1236           // 4938384: relaxed constraint in JVMS 3nd edition.
1237           no_control_flow = false; break;
1238         case Bytecodes::_pop :
1239           current_frame.pop_stack(
1240             VerificationType::category1_check(), CHECK_VERIFY(this));
1241           no_control_flow = false; break;
1242         case Bytecodes::_pop2 :
1243           type = current_frame.pop_stack(CHECK_VERIFY(this));
1244           if (type.is_category1()) {
1245             current_frame.pop_stack(
1246               VerificationType::category1_check(), CHECK_VERIFY(this));
1247           } else if (type.is_category2_2nd()) {
1248             current_frame.pop_stack(
1249               VerificationType::category2_check(), CHECK_VERIFY(this));
</pre>
<hr />
<pre>
1609         case Bytecodes::_if_icmpgt:
1610         case Bytecodes::_if_icmple:
1611           current_frame.pop_stack(
1612             VerificationType::integer_type(), CHECK_VERIFY(this));
1613           // fall through
1614         case Bytecodes::_ifeq:
1615         case Bytecodes::_ifne:
1616         case Bytecodes::_iflt:
1617         case Bytecodes::_ifge:
1618         case Bytecodes::_ifgt:
1619         case Bytecodes::_ifle:
1620           current_frame.pop_stack(
1621             VerificationType::integer_type(), CHECK_VERIFY(this));
1622           target = bcs.dest();
1623           stackmap_table.check_jump_target(
1624             &amp;current_frame, target, CHECK_VERIFY(this));
1625           no_control_flow = false; break;
1626         case Bytecodes::_if_acmpeq :
1627         case Bytecodes::_if_acmpne :
1628           current_frame.pop_stack(
<span class="line-modified">1629             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
1630           // fall through
1631         case Bytecodes::_ifnull :
1632         case Bytecodes::_ifnonnull :
1633           current_frame.pop_stack(
<span class="line-modified">1634             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
1635           target = bcs.dest();
1636           stackmap_table.check_jump_target
1637             (&amp;current_frame, target, CHECK_VERIFY(this));
1638           no_control_flow = false; break;
1639         case Bytecodes::_goto :
1640           target = bcs.dest();
1641           stackmap_table.check_jump_target(
1642             &amp;current_frame, target, CHECK_VERIFY(this));
1643           no_control_flow = true; break;
1644         case Bytecodes::_goto_w :
1645           target = bcs.dest_w();
1646           stackmap_table.check_jump_target(
1647             &amp;current_frame, target, CHECK_VERIFY(this));
1648           no_control_flow = true; break;
1649         case Bytecodes::_tableswitch :
1650         case Bytecodes::_lookupswitch :
1651           verify_switch(
1652             &amp;bcs, code_length, code_data, &amp;current_frame,
1653             &amp;stackmap_table, CHECK_VERIFY(this));
1654           no_control_flow = true; break;
</pre>
<hr />
<pre>
1665             VerificationType::long_type(), CHECK_VERIFY(this));
1666           verify_return_value(return_type, type, bci,
1667                               &amp;current_frame, CHECK_VERIFY(this));
1668           no_control_flow = true; break;
1669         case Bytecodes::_freturn :
1670           type = current_frame.pop_stack(
1671             VerificationType::float_type(), CHECK_VERIFY(this));
1672           verify_return_value(return_type, type, bci,
1673                               &amp;current_frame, CHECK_VERIFY(this));
1674           no_control_flow = true; break;
1675         case Bytecodes::_dreturn :
1676           type2 = current_frame.pop_stack(
1677             VerificationType::double2_type(),  CHECK_VERIFY(this));
1678           type = current_frame.pop_stack(
1679             VerificationType::double_type(), CHECK_VERIFY(this));
1680           verify_return_value(return_type, type, bci,
1681                               &amp;current_frame, CHECK_VERIFY(this));
1682           no_control_flow = true; break;
1683         case Bytecodes::_areturn :
1684           type = current_frame.pop_stack(
<span class="line-modified">1685             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
1686           verify_return_value(return_type, type, bci,
1687                               &amp;current_frame, CHECK_VERIFY(this));
1688           no_control_flow = true; break;
1689         case Bytecodes::_return :
1690           if (return_type != VerificationType::bogus_type()) {
1691             verify_error(ErrorContext::bad_code(bci),
1692                          &quot;Method expects a return value&quot;);
1693             return;
1694           }
1695           // Make sure &quot;this&quot; has been initialized if current method is an
1696           // &lt;init&gt;.
<span class="line-modified">1697           if (_method-&gt;is_object_constructor() &amp;&amp;</span>
1698               current_frame.flag_this_uninit()) {
1699             verify_error(ErrorContext::bad_code(bci),
1700                          &quot;Constructor must call super() or this() &quot;
1701                          &quot;before return&quot;);
1702             return;
1703           }
1704           no_control_flow = true; break;
1705         case Bytecodes::_getstatic :
1706         case Bytecodes::_putstatic :
1707           // pass TRUE, operand can be an array type for getstatic/putstatic.
1708           verify_field_instructions(
1709             &amp;bcs, &amp;current_frame, cp, true, CHECK_VERIFY(this));
1710           no_control_flow = false; break;
1711         case Bytecodes::_getfield :
1712         case Bytecodes::_putfield :
1713           // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
1714           verify_field_instructions(
1715             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1716           no_control_flow = false; break;
<span class="line-added">1717         case Bytecodes::_withfield :</span>
<span class="line-added">1718           if (_klass-&gt;major_version() &lt; INLINE_TYPE_MAJOR_VERSION) {</span>
<span class="line-added">1719             class_format_error(</span>
<span class="line-added">1720               &quot;withfield not supported by this class file version (%d.%d), class %s&quot;,</span>
<span class="line-added">1721               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());</span>
<span class="line-added">1722             return;</span>
<span class="line-added">1723           }</span>
<span class="line-added">1724           // pass FALSE, operand can&#39;t be an array type for withfield.</span>
<span class="line-added">1725           verify_field_instructions(</span>
<span class="line-added">1726             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));</span>
<span class="line-added">1727           no_control_flow = false; break;</span>
1728         case Bytecodes::_invokevirtual :
1729         case Bytecodes::_invokespecial :
1730         case Bytecodes::_invokestatic :




1731         case Bytecodes::_invokeinterface :
1732         case Bytecodes::_invokedynamic :
1733           verify_invoke_instructions(
1734             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
<span class="line-modified">1735             &amp;this_uninit, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
1736           no_control_flow = false; break;
1737         case Bytecodes::_new :
1738         {
1739           index = bcs.get_index_u2();
1740           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1741           VerificationType new_class_type =
1742             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1743           if (!new_class_type.is_object()) {
1744             verify_error(ErrorContext::bad_type(bci,
1745                 TypeOrigin::cp(index, new_class_type)),
1746                 &quot;Illegal new instruction&quot;);
1747             return;
1748           }
1749           type = VerificationType::uninitialized_type(bci);
1750           current_frame.push_stack(type, CHECK_VERIFY(this));
1751           no_control_flow = false; break;
1752         }
<span class="line-added">1753         case Bytecodes::_defaultvalue :</span>
<span class="line-added">1754         {</span>
<span class="line-added">1755           if (_klass-&gt;major_version() &lt; INLINE_TYPE_MAJOR_VERSION) {</span>
<span class="line-added">1756             class_format_error(</span>
<span class="line-added">1757               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,</span>
<span class="line-added">1758               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());</span>
<span class="line-added">1759             return;</span>
<span class="line-added">1760           }</span>
<span class="line-added">1761           index = bcs.get_index_u2();</span>
<span class="line-added">1762           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));</span>
<span class="line-added">1763           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));</span>
<span class="line-added">1764           if (!ref_type.is_object()) {</span>
<span class="line-added">1765             verify_error(ErrorContext::bad_type(bci,</span>
<span class="line-added">1766                 TypeOrigin::cp(index, ref_type)),</span>
<span class="line-added">1767                 &quot;Illegal defaultvalue instruction&quot;);</span>
<span class="line-added">1768             return;</span>
<span class="line-added">1769           }</span>
<span class="line-added">1770           VerificationType inline_type =</span>
<span class="line-added">1771             VerificationType::change_ref_to_inline_type(ref_type);</span>
<span class="line-added">1772           current_frame.push_stack(inline_type, CHECK_VERIFY(this));</span>
<span class="line-added">1773           no_control_flow = false; break;</span>
<span class="line-added">1774         }</span>
1775         case Bytecodes::_newarray :
1776           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
1777           current_frame.pop_stack(
1778             VerificationType::integer_type(),  CHECK_VERIFY(this));
1779           current_frame.push_stack(type, CHECK_VERIFY(this));
1780           no_control_flow = false; break;
1781         case Bytecodes::_anewarray :
1782           verify_anewarray(
1783             bci, bcs.get_index_u2(), cp, &amp;current_frame, CHECK_VERIFY(this));
1784           no_control_flow = false; break;
1785         case Bytecodes::_arraylength :
1786           type = current_frame.pop_stack(
1787             VerificationType::reference_check(), CHECK_VERIFY(this));
1788           if (!(type.is_null() || type.is_array())) {
1789             verify_error(ErrorContext::bad_type(
1790                 bci, current_frame.stack_top_ctx()),
1791                 bad_type_msg, &quot;arraylength&quot;);
1792           }
1793           current_frame.push_stack(
1794             VerificationType::integer_type(), CHECK_VERIFY(this));
1795           no_control_flow = false; break;
1796         case Bytecodes::_checkcast :
1797         {
1798           index = bcs.get_index_u2();
1799           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1800           current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1801           VerificationType klass_type = cp_index_to_type(
1802             index, cp, CHECK_VERIFY(this));
1803           current_frame.push_stack(klass_type, CHECK_VERIFY(this));
1804           no_control_flow = false; break;
1805         }
1806         case Bytecodes::_instanceof : {
1807           index = bcs.get_index_u2();
1808           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1809           current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1810           current_frame.push_stack(
1811             VerificationType::integer_type(), CHECK_VERIFY(this));
1812           no_control_flow = false; break;
1813         }
1814         case Bytecodes::_monitorenter :
<span class="line-modified">1815         case Bytecodes::_monitorexit : {</span>
<span class="line-modified">1816           VerificationType ref = current_frame.pop_stack(</span>
<span class="line-modified">1817             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
1818           no_control_flow = false; break;
<span class="line-added">1819         }</span>
1820         case Bytecodes::_multianewarray :
1821         {
1822           index = bcs.get_index_u2();
1823           u2 dim = *(bcs.bcp()+3);
1824           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1825           VerificationType new_array_type =
1826             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1827           if (!new_array_type.is_array()) {
1828             verify_error(ErrorContext::bad_type(bci,
1829                 TypeOrigin::cp(index, new_array_type)),
1830                 &quot;Illegal constant pool index in multianewarray instruction&quot;);
1831             return;
1832           }
1833           if (dim &lt; 1 || new_array_type.dimensions() &lt; dim) {
1834             verify_error(ErrorContext::bad_code(bci),
1835                 &quot;Illegal dimension in multianewarray instruction: %d&quot;, dim);
1836             return;
1837           }
1838           for (int i = 0; i &lt; dim; i++) {
1839             current_frame.pop_stack(
</pre>
<hr />
<pre>
2058   int nconstants = cp-&gt;length();
2059   if ((index &lt;= 0) || (index &gt;= nconstants)) {
2060     verify_error(ErrorContext::bad_cp_index(bci, index),
2061         &quot;Illegal constant pool index %d in class %s&quot;,
2062         index, cp-&gt;pool_holder()-&gt;external_name());
2063     return;
2064   }
2065 }
2066 
2067 void ClassVerifier::verify_cp_type(
2068     u2 bci, int index, const constantPoolHandle&amp; cp, unsigned int types, TRAPS) {
2069 
2070   // In some situations, bytecode rewriting may occur while we&#39;re verifying.
2071   // In this case, a constant pool cache exists and some indices refer to that
2072   // instead.  Be sure we don&#39;t pick up such indices by accident.
2073   // We must check was_recursively_verified() before we get here.
2074   guarantee(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
2075 
2076   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2077   unsigned int tag = cp-&gt;tag_at(index).value();
<span class="line-added">2078 </span>
2079   if ((types &amp; (1 &lt;&lt; tag)) == 0) {
2080     verify_error(ErrorContext::bad_cp_index(bci, index),
2081       &quot;Illegal type at constant pool entry %d in class %s&quot;,
2082       index, cp-&gt;pool_holder()-&gt;external_name());
2083     return;
2084   }
2085 }
2086 
2087 void ClassVerifier::verify_cp_class_type(
2088     u2 bci, int index, const constantPoolHandle&amp; cp, TRAPS) {
2089   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2090   constantTag tag = cp-&gt;tag_at(index);
2091   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2092     verify_error(ErrorContext::bad_cp_index(bci, index),
2093         &quot;Illegal type at constant pool entry %d in class %s&quot;,
2094         index, cp-&gt;pool_holder()-&gt;external_name());
2095     return;
2096   }
2097 }
2098 
</pre>
<hr />
<pre>
2173   } else {
2174     Klass* member_klass = target_instance-&gt;find_field(field_name, field_sig, &amp;fd);
2175     if (member_klass != NULL &amp;&amp; fd.is_protected()) {
2176       if (!this_class-&gt;is_same_class_package(member_klass)) {
2177         return true;
2178       }
2179     }
2180   }
2181   return false;
2182 }
2183 
2184 void ClassVerifier::verify_ldc(
2185     int opcode, u2 index, StackMapFrame* current_frame,
2186     const constantPoolHandle&amp; cp, u2 bci, TRAPS) {
2187   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2188   constantTag tag = cp-&gt;tag_at(index);
2189   unsigned int types = 0;
2190   if (opcode == Bytecodes::_ldc || opcode == Bytecodes::_ldc_w) {
2191     if (!tag.is_unresolved_klass()) {
2192       types = (1 &lt;&lt; JVM_CONSTANT_Integer) | (1 &lt;&lt; JVM_CONSTANT_Float)
<span class="line-modified">2193             | (1 &lt;&lt; JVM_CONSTANT_String) | (1 &lt;&lt; JVM_CONSTANT_Class)</span>
2194             | (1 &lt;&lt; JVM_CONSTANT_MethodHandle) | (1 &lt;&lt; JVM_CONSTANT_MethodType)
2195             | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
2196       // Note:  The class file parser already verified the legality of
2197       // MethodHandle and MethodType constants.
2198       verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2199     }
2200   } else {
2201     assert(opcode == Bytecodes::_ldc2_w, &quot;must be ldc2_w&quot;);
2202     types = (1 &lt;&lt; JVM_CONSTANT_Double) | (1 &lt;&lt; JVM_CONSTANT_Long)
2203           | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
2204     verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2205   }
2206   if (tag.is_string() &amp;&amp; cp-&gt;is_pseudo_string_at(index)) {
2207     current_frame-&gt;push_stack(object_type(), CHECK_VERIFY(this));
2208   } else if (tag.is_string()) {
2209     current_frame-&gt;push_stack(
2210       VerificationType::reference_type(
2211         vmSymbols::java_lang_String()), CHECK_VERIFY(this));
2212   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
2213     current_frame-&gt;push_stack(
</pre>
<hr />
<pre>
2349                                               StackMapFrame* current_frame,
2350                                               const constantPoolHandle&amp; cp,
2351                                               bool allow_arrays,
2352                                               TRAPS) {
2353   u2 index = bcs-&gt;get_index_u2();
2354   verify_cp_type(bcs-&gt;bci(), index, cp,
2355       1 &lt;&lt; JVM_CONSTANT_Fieldref, CHECK_VERIFY(this));
2356 
2357   // Get field name and signature
2358   Symbol* field_name = cp-&gt;name_ref_at(index);
2359   Symbol* field_sig = cp-&gt;signature_ref_at(index);
2360 
2361   // Field signature was checked in ClassFileParser.
2362   assert(SignatureVerifier::is_valid_type_signature(field_sig),
2363          &quot;Invalid field signature&quot;);
2364 
2365   // Get referenced class type
2366   VerificationType ref_class_type = cp_ref_index_to_type(
2367     index, cp, CHECK_VERIFY(this));
2368   if (!ref_class_type.is_object() &amp;&amp;
<span class="line-modified">2369       (!allow_arrays || !ref_class_type.is_array())) {</span>
2370     verify_error(ErrorContext::bad_type(bcs-&gt;bci(),
2371         TypeOrigin::cp(index, ref_class_type)),
2372         &quot;Expecting reference to class in class %s at constant pool index %d&quot;,
2373         _klass-&gt;external_name(), index);
2374     return;
2375   }
<span class="line-added">2376 </span>
2377   VerificationType target_class_type = ref_class_type;
2378 
2379   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2380         &quot;buffer type must match VerificationType size&quot;);
2381   uintptr_t field_type_buffer[2];
2382   VerificationType* field_type = (VerificationType*)field_type_buffer;
2383   // If we make a VerificationType[2] array directly, the compiler calls
2384   // to the c-runtime library to do the allocation instead of just
2385   // stack allocating it.  Plus it would run constructors.  This shows up
2386   // in performance profiles.
2387 
2388   SignatureStream sig_stream(field_sig, false);
2389   VerificationType stack_object_type;
2390   int n = change_sig_to_verificationType(&amp;sig_stream, field_type);
2391   u2 bci = bcs-&gt;bci();
2392   bool is_assignable;
2393   switch (bcs-&gt;raw_code()) {
2394     case Bytecodes::_getstatic: {
2395       for (int i = 0; i &lt; n; i++) {
2396         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2397       }
2398       break;
2399     }
2400     case Bytecodes::_putstatic: {
2401       for (int i = n - 1; i &gt;= 0; i--) {
2402         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2403       }
2404       break;
2405     }
<span class="line-added">2406     case Bytecodes::_withfield: {</span>
<span class="line-added">2407       for (int i = n - 1; i &gt;= 0; i--) {</span>
<span class="line-added">2408         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));</span>
<span class="line-added">2409       }</span>
<span class="line-added">2410       // stack_object_type and target_class_type must be the same inline type.</span>
<span class="line-added">2411       stack_object_type =</span>
<span class="line-added">2412         current_frame-&gt;pop_stack(VerificationType::inline_type_check(), CHECK_VERIFY(this));</span>
<span class="line-added">2413       VerificationType target_inline_type =</span>
<span class="line-added">2414         VerificationType::change_ref_to_inline_type(target_class_type);</span>
<span class="line-added">2415       if (!stack_object_type.equals(target_inline_type)) {</span>
<span class="line-added">2416         verify_error(ErrorContext::bad_inline_type(bci,</span>
<span class="line-added">2417             current_frame-&gt;stack_top_ctx(),</span>
<span class="line-added">2418             TypeOrigin::cp(index, target_class_type)),</span>
<span class="line-added">2419             &quot;Invalid type on operand stack in withfield instruction&quot;);</span>
<span class="line-added">2420         return;</span>
<span class="line-added">2421       }</span>
<span class="line-added">2422       current_frame-&gt;push_stack(target_inline_type, CHECK_VERIFY(this));</span>
<span class="line-added">2423       break;</span>
<span class="line-added">2424     }</span>
2425     case Bytecodes::_getfield: {
2426       stack_object_type = current_frame-&gt;pop_stack(
2427         target_class_type, CHECK_VERIFY(this));
2428       for (int i = 0; i &lt; n; i++) {
2429         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2430       }
2431       goto check_protected;
2432     }
2433     case Bytecodes::_putfield: {
2434       for (int i = n - 1; i &gt;= 0; i--) {
2435         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2436       }
2437       stack_object_type = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2438 
2439       // The JVMS 2nd edition allows field initialization before the superclass
2440       // initializer, if the field is defined within the current class.
2441       fieldDescriptor fd;
2442       if (stack_object_type == VerificationType::uninitialized_this_type() &amp;&amp;
2443           target_class_type.equals(current_type()) &amp;&amp;
2444           _klass-&gt;find_local_field(field_name, field_sig, &amp;fd)) {
</pre>
<hr />
<pre>
2813 bool ClassVerifier::is_same_or_direct_interface(
2814     InstanceKlass* klass,
2815     VerificationType klass_type,
2816     VerificationType ref_class_type) {
2817   if (ref_class_type.equals(klass_type)) return true;
2818   Array&lt;InstanceKlass*&gt;* local_interfaces = klass-&gt;local_interfaces();
2819   if (local_interfaces != NULL) {
2820     for (int x = 0; x &lt; local_interfaces-&gt;length(); x++) {
2821       InstanceKlass* k = local_interfaces-&gt;at(x);
2822       assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
2823       if (ref_class_type.equals(VerificationType::reference_type(k-&gt;name()))) {
2824         return true;
2825       }
2826     }
2827   }
2828   return false;
2829 }
2830 
2831 void ClassVerifier::verify_invoke_instructions(
2832     RawBytecodeStream* bcs, u4 code_length, StackMapFrame* current_frame,
<span class="line-modified">2833     bool in_try_block, bool *this_uninit,</span>
2834     const constantPoolHandle&amp; cp, StackMapTable* stackmap_table, TRAPS) {
2835   // Make sure the constant pool item is the right type
2836   u2 index = bcs-&gt;get_index_u2();
2837   Bytecodes::Code opcode = bcs-&gt;raw_code();
2838   unsigned int types = 0;
2839   switch (opcode) {
2840     case Bytecodes::_invokeinterface:
2841       types = 1 &lt;&lt; JVM_CONSTANT_InterfaceMethodref;
2842       break;
2843     case Bytecodes::_invokedynamic:
2844       types = 1 &lt;&lt; JVM_CONSTANT_InvokeDynamic;
2845       break;
2846     case Bytecodes::_invokespecial:
2847     case Bytecodes::_invokestatic:
2848       types = (_klass-&gt;major_version() &lt; STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION) ?
2849         (1 &lt;&lt; JVM_CONSTANT_Methodref) :
2850         ((1 &lt;&lt; JVM_CONSTANT_InterfaceMethodref) | (1 &lt;&lt; JVM_CONSTANT_Methodref));
2851       break;
2852     default:
2853       types = 1 &lt;&lt; JVM_CONSTANT_Methodref;
2854   }
2855   verify_cp_type(bcs-&gt;bci(), index, cp, types, CHECK_VERIFY(this));
2856 
2857   // Get method name and signature
2858   Symbol* method_name = cp-&gt;name_ref_at(index);
2859   Symbol* method_sig = cp-&gt;signature_ref_at(index);
2860 
2861   // Method signature was checked in ClassFileParser.
2862   assert(SignatureVerifier::is_valid_method_signature(method_sig),
2863          &quot;Invalid method signature&quot;);
2864 
<span class="line-modified">2865   // Get referenced class</span>
2866   VerificationType ref_class_type;
2867   if (opcode == Bytecodes::_invokedynamic) {
2868     if (_klass-&gt;major_version() &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
2869       class_format_error(
2870         &quot;invokedynamic instructions not supported by this class file version (%d), class %s&quot;,
2871         _klass-&gt;major_version(), _klass-&gt;external_name());
2872       return;
2873     }
2874   } else {
2875     ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
2876   }
2877 
2878   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2879         &quot;buffer type must match VerificationType size&quot;);
2880 
2881   // Get the UTF8 index for this signature.
2882   int sig_index = cp-&gt;signature_ref_index_at(cp-&gt;name_and_type_ref_index_at(index));
2883 
2884   // Get the signature&#39;s verification types.
2885   sig_as_verification_types* mth_sig_verif_types;
</pre>
<hr />
<pre>
2911           &quot;Inconsistent args count operand in invokeinterface&quot;);
2912       return;
2913     }
2914     if (*(bcp+4) != 0) {
2915       verify_error(ErrorContext::bad_code(bci),
2916           &quot;Fourth operand byte of invokeinterface must be zero&quot;);
2917       return;
2918     }
2919   }
2920 
2921   if (opcode == Bytecodes::_invokedynamic) {
2922     address bcp = bcs-&gt;bcp();
2923     if (*(bcp+3) != 0 || *(bcp+4) != 0) {
2924       verify_error(ErrorContext::bad_code(bci),
2925           &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
2926       return;
2927     }
2928   }
2929 
2930   if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">2931     // Make sure &lt;init&gt; can only be invoked by invokespecial or invokestatic.</span>
<span class="line-modified">2932     // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added">2933     if ((opcode != Bytecodes::_invokespecial &amp;&amp;</span>
<span class="line-added">2934          opcode != Bytecodes::_invokestatic) ||</span>
2935         method_name != vmSymbols::object_initializer_name()) {
2936       verify_error(ErrorContext::bad_code(bci),
2937           &quot;Illegal call to internal method&quot;);
2938       return;
2939     }
2940   } else if (opcode == Bytecodes::_invokespecial
2941              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2942              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
<span class="line-modified">2943                   current_class()-&gt;super()-&gt;name()))) { // super() can never be an inline_type.</span>
2944     bool subtype = false;
2945     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2946     if (!current_class()-&gt;is_unsafe_anonymous()) {
2947       subtype = ref_class_type.is_assignable_from(
2948                  current_type(), this, false, CHECK_VERIFY(this));
2949     } else {
<span class="line-modified">2950       InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();</span>
<span class="line-modified">2951       VerificationType unsafe_anonymous_host_type = reference_or_inline_type(unsafe_host);</span>
2952       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
2953 
2954       // If invokespecial of IMR, need to recheck for same or
2955       // direct interface relative to the host class
2956       have_imr_indirect = (have_imr_indirect &amp;&amp;
2957                            !is_same_or_direct_interface(
<span class="line-modified">2958                              unsafe_host,</span>
2959                              unsafe_anonymous_host_type, ref_class_type));
2960     }
2961     if (!subtype) {
2962       verify_error(ErrorContext::bad_code(bci),
2963           &quot;Bad invokespecial instruction: &quot;
2964           &quot;current class isn&#39;t assignable to reference class.&quot;);
2965        return;
2966     } else if (have_imr_indirect) {
2967       verify_error(ErrorContext::bad_code(bci),
2968           &quot;Bad invokespecial instruction: &quot;
2969           &quot;interface method reference is in an indirect superinterface.&quot;);
2970       return;
2971     }
2972 
2973   }
2974 
2975   // Get the verification types for the method&#39;s arguments.
2976   GrowableArray&lt;VerificationType&gt;* sig_verif_types = mth_sig_verif_types-&gt;sig_verif_types();
2977   assert(sig_verif_types != NULL, &quot;Missing signature&#39;s array of verification types&quot;);
2978   // Match method descriptor with operand stack
2979   // The arguments are on the stack in descending order.
2980   for (int i = nargs - 1; i &gt;= 0; i--) { // Run backwards
2981     current_frame-&gt;pop_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
2982   }
2983 
2984   // Check objectref on operand stack
2985   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2986       opcode != Bytecodes::_invokedynamic) {
2987     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
<span class="line-added">2988       // (use of &lt;init&gt; as a static factory is handled under invokestatic)</span>
2989       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2990         code_length, in_try_block, this_uninit, cp, stackmap_table,
2991         CHECK_VERIFY(this));
2992       if (was_recursively_verified()) return;
2993     } else {   // other methods
2994       // Ensures that target class is assignable to method class.
2995       if (opcode == Bytecodes::_invokespecial) {
2996         if (!current_class()-&gt;is_unsafe_anonymous()) {
2997           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2998         } else {
2999           // anonymous class invokespecial calls: check if the
3000           // objectref is a subtype of the unsafe_anonymous_host of the current class
3001           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
3002           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
<span class="line-modified">3003 </span>
<span class="line-modified">3004           InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();</span>
<span class="line-modified">3005           VerificationType host_type = reference_or_inline_type(unsafe_host);</span>
<span class="line-added">3006           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));</span>
3007           if (!subtype) {
3008             verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
3009               current_frame-&gt;stack_top_ctx(),
3010               TypeOrigin::implicit(top)),
3011               &quot;Bad type on operand stack&quot;);
3012             return;
3013           }
3014         }
3015       } else if (opcode == Bytecodes::_invokevirtual) {
3016         VerificationType stack_object_type =
3017           current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
3018         if (current_type() != stack_object_type) {
3019           if (was_recursively_verified()) return;
3020           assert(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
3021           Symbol* ref_class_name =
3022             cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(index));
3023           // See the comments in verify_field_instructions() for
3024           // the rationale behind this.
3025           if (name_in_supers(ref_class_name, current_class())) {
3026             Klass* ref_class = load_class(ref_class_name, CHECK);
</pre>
<hr />
<pre>
3039                 } else {
3040                   verify_error(ErrorContext::bad_type(bci,
3041                       current_frame-&gt;stack_top_ctx(),
3042                       TypeOrigin::implicit(current_type())),
3043                       &quot;Bad access to protected data in invokevirtual&quot;);
3044                   return;
3045                 }
3046               }
3047             }
3048           }
3049         }
3050       } else {
3051         assert(opcode == Bytecodes::_invokeinterface, &quot;Unexpected opcode encountered&quot;);
3052         current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
3053       }
3054     }
3055   }
3056   // Push the result type.
3057   int sig_verif_types_len = sig_verif_types-&gt;length();
3058   if (sig_verif_types_len &gt; nargs) {  // There&#39;s a return type
<span class="line-modified">3059     if (method_name == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="line-modified">3060         opcode != Bytecodes::_invokestatic) {</span>
<span class="line-modified">3061       // an &lt;init&gt; method must have a void return type, unless it&#39;s a static factory</span>

3062       verify_error(ErrorContext::bad_code(bci),
3063           &quot;Return type must be void in &lt;init&gt; method&quot;);
3064       return;
3065     }
3066 
3067     assert(sig_verif_types_len &lt;= nargs + 2,
3068            &quot;Signature verification types array return type is bogus&quot;);
3069     for (int i = nargs; i &lt; sig_verif_types_len; i++) {
3070       assert(i == nargs || sig_verif_types-&gt;at(i).is_long2() ||
3071              sig_verif_types-&gt;at(i).is_double2(), &quot;Unexpected return verificationType&quot;);
3072       current_frame-&gt;push_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
3073     }
<span class="line-added">3074   } else {</span>
<span class="line-added">3075     // an &lt;init&gt; method may not have a void return type, if it&#39;s a static factory</span>
<span class="line-added">3076     if (method_name == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="line-added">3077         opcode != Bytecodes::_invokespecial) {</span>
<span class="line-added">3078       verify_error(ErrorContext::bad_code(bci),</span>
<span class="line-added">3079           &quot;Return type must be non-void in &lt;init&gt; static factory method&quot;);</span>
<span class="line-added">3080       return;</span>
<span class="line-added">3081     }</span>
3082   }
3083 }
3084 
3085 VerificationType ClassVerifier::get_newarray_type(
3086     u2 index, u2 bci, TRAPS) {
3087   const char* from_bt[] = {
3088     NULL, NULL, NULL, NULL, &quot;[Z&quot;, &quot;[C&quot;, &quot;[F&quot;, &quot;[D&quot;, &quot;[B&quot;, &quot;[S&quot;, &quot;[I&quot;, &quot;[J&quot;,
3089   };
3090   if (index &lt; T_BOOLEAN || index &gt; T_LONG) {
3091     verify_error(ErrorContext::bad_code(bci), &quot;Illegal newarray instruction&quot;);
3092     return VerificationType::bogus_type();
3093   }
3094 
3095   // from_bt[index] contains the array signature which has a length of 2
3096   Symbol* sig = create_temporary_symbol(from_bt[index], 2);
3097   return VerificationType::reference_type(sig);
3098 }
3099 
3100 void ClassVerifier::verify_anewarray(
3101     u2 bci, u2 index, const constantPoolHandle&amp; cp,
</pre>
<hr />
<pre>
3109     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3110   int length;
3111   char* arr_sig_str;
3112   if (component_type.is_array()) {     // it&#39;s an array
3113     const char* component_name = component_type.name()-&gt;as_utf8();
3114     // Check for more than MAX_ARRAY_DIMENSIONS
3115     length = (int)strlen(component_name);
3116     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3117         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3118       verify_error(ErrorContext::bad_code(bci),
3119         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3120     }
3121     // add one dimension to component
3122     length++;
3123     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3124     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3125                          JVM_SIGNATURE_ARRAY, component_name);
3126     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3127   } else {         // it&#39;s an object or interface
3128     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3129     char Q_or_L = component_type.is_inline_type() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;</span>
<span class="line-added">3130     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.</span>
3131     length = (int)strlen(component_name) + 3;
3132     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3133     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
<span class="line-modified">3134                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);</span>
3135     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3136   }
3137   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3138   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3139   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3140 }
3141 
3142 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3143   current_frame-&gt;get_local(
3144     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3145   current_frame-&gt;push_stack(
3146     VerificationType::integer_type(), CHECK_VERIFY(this));
3147 }
3148 
3149 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
3150   current_frame-&gt;get_local_2(
3151     index, VerificationType::long_type(),
3152     VerificationType::long2_type(), CHECK_VERIFY(this));
3153   current_frame-&gt;push_stack_2(
3154     VerificationType::long_type(),
</pre>
<hr />
<pre>
3156 }
3157 
3158 void ClassVerifier::verify_fload(u2 index, StackMapFrame* current_frame, TRAPS) {
3159   current_frame-&gt;get_local(
3160     index, VerificationType::float_type(), CHECK_VERIFY(this));
3161   current_frame-&gt;push_stack(
3162     VerificationType::float_type(), CHECK_VERIFY(this));
3163 }
3164 
3165 void ClassVerifier::verify_dload(u2 index, StackMapFrame* current_frame, TRAPS) {
3166   current_frame-&gt;get_local_2(
3167     index, VerificationType::double_type(),
3168     VerificationType::double2_type(), CHECK_VERIFY(this));
3169   current_frame-&gt;push_stack_2(
3170     VerificationType::double_type(),
3171     VerificationType::double2_type(), CHECK_VERIFY(this));
3172 }
3173 
3174 void ClassVerifier::verify_aload(u2 index, StackMapFrame* current_frame, TRAPS) {
3175   VerificationType type = current_frame-&gt;get_local(
<span class="line-modified">3176     index, VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
3177   current_frame-&gt;push_stack(type, CHECK_VERIFY(this));
3178 }
3179 
3180 void ClassVerifier::verify_istore(u2 index, StackMapFrame* current_frame, TRAPS) {
3181   current_frame-&gt;pop_stack(
3182     VerificationType::integer_type(), CHECK_VERIFY(this));
3183   current_frame-&gt;set_local(
3184     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3185 }
3186 
3187 void ClassVerifier::verify_lstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3188   current_frame-&gt;pop_stack_2(
3189     VerificationType::long2_type(),
3190     VerificationType::long_type(), CHECK_VERIFY(this));
3191   current_frame-&gt;set_local_2(
3192     index, VerificationType::long_type(),
3193     VerificationType::long2_type(), CHECK_VERIFY(this));
3194 }
3195 
3196 void ClassVerifier::verify_fstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3197   current_frame-&gt;pop_stack(VerificationType::float_type(), CHECK_VERIFY(this));
3198   current_frame-&gt;set_local(
3199     index, VerificationType::float_type(), CHECK_VERIFY(this));
3200 }
3201 
3202 void ClassVerifier::verify_dstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3203   current_frame-&gt;pop_stack_2(
3204     VerificationType::double2_type(),
3205     VerificationType::double_type(), CHECK_VERIFY(this));
3206   current_frame-&gt;set_local_2(
3207     index, VerificationType::double_type(),
3208     VerificationType::double2_type(), CHECK_VERIFY(this));
3209 }
3210 
3211 void ClassVerifier::verify_astore(u2 index, StackMapFrame* current_frame, TRAPS) {
3212   VerificationType type = current_frame-&gt;pop_stack(
<span class="line-modified">3213     VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
3214   current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
3215 }
3216 
3217 void ClassVerifier::verify_iinc(u2 index, StackMapFrame* current_frame, TRAPS) {
3218   VerificationType type = current_frame-&gt;get_local(
3219     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3220   current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
3221 }
3222 
3223 void ClassVerifier::verify_return_value(
3224     VerificationType return_type, VerificationType type, u2 bci,
3225     StackMapFrame* current_frame, TRAPS) {
3226   if (return_type == VerificationType::bogus_type()) {
3227     verify_error(ErrorContext::bad_type(bci,
3228         current_frame-&gt;stack_top_ctx(), TypeOrigin::signature(return_type)),
3229         &quot;Method expects a return value&quot;);
3230     return;
3231   }
3232   bool match = return_type.is_assignable_from(type, this, false, CHECK_VERIFY(this));
3233   if (!match) {
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
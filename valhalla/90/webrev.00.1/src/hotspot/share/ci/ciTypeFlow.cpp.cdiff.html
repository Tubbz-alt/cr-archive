<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/ci/ciTypeFlow.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/aarch64/sharedRuntime_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classListParser.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciTypeFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  #include &quot;ci/ciMethodData.hpp&quot;
  #include &quot;ci/ciObjArrayKlass.hpp&quot;
  #include &quot;ci/ciStreams.hpp&quot;
  #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  #include &quot;ci/ciTypeFlow.hpp&quot;
<span class="line-added">+ #include &quot;ci/ciValueKlass.hpp&quot;</span>
  #include &quot;compiler/compileLog.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;interpreter/bytecodes.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,11 ***</span>
    assert(t1 != t2, &quot;checked in caller&quot;);
    if (t1-&gt;equals(top_type())) {
      return t2;
    } else if (t2-&gt;equals(top_type())) {
      return t1;
<span class="line-modified">!   } else if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {</span>
      // Special case null_type.  null_type meet any reference type T
      // is T.  null_type meet null_type is null_type.
      if (t1-&gt;equals(null_type())) {
        if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {
          return t2;
<span class="line-new-header">--- 274,22 ---</span>
    assert(t1 != t2, &quot;checked in caller&quot;);
    if (t1-&gt;equals(top_type())) {
      return t2;
    } else if (t2-&gt;equals(top_type())) {
      return t1;
<span class="line-modified">!   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Unwrap after saving nullness information and handling top meets</span>
<span class="line-added">+   bool never_null1 = t1-&gt;is_never_null();</span>
<span class="line-added">+   bool never_null2 = t2-&gt;is_never_null();</span>
<span class="line-added">+   if (t1-&gt;unwrap() == t2-&gt;unwrap() &amp;&amp; never_null1 == never_null2) {</span>
<span class="line-added">+     return t1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   t1 = t1-&gt;unwrap();</span>
<span class="line-added">+   t2 = t2-&gt;unwrap();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {</span>
      // Special case null_type.  null_type meet any reference type T
      // is T.  null_type meet null_type is null_type.
      if (t1-&gt;equals(null_type())) {
        if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {
          return t2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,54 ***</span>
      }
  
      // At least one of the two types is a non-top primitive type.
      // The other type is not equal to it.  Fall to bottom.
      return bottom_type();
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     // Both types are non-top non-primitive types.  That is,</span>
<span class="line-modified">!     // both types are either instanceKlasses or arrayKlasses.</span>
<span class="line-modified">!     ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();</span>
<span class="line-modified">!     ciKlass* k1 = t1-&gt;as_klass();</span>
<span class="line-modified">!     ciKlass* k2 = t2-&gt;as_klass();</span>
<span class="line-modified">!     if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {</span>
<span class="line-modified">!       return object_klass;</span>
<span class="line-modified">!     } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {</span>
<span class="line-modified">!       // Unloaded classes fall to java.lang.Object at a merge.</span>
<span class="line-modified">!       return object_klass;</span>
<span class="line-modified">!     } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {</span>
<span class="line-modified">!       // When an interface meets a non-interface, we get Object;</span>
<span class="line-modified">!       // This is what the verifier does.</span>
<span class="line-modified">!       return object_klass;</span>
<span class="line-modified">!     } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {</span>
<span class="line-modified">!       // When an array meets a non-array, we get Object.</span>
<span class="line-modified">!       // When objArray meets typeArray, we also get Object.</span>
<span class="line-modified">!       // And when typeArray meets different typeArray, we again get Object.</span>
<span class="line-modified">!       // But when objArray meets objArray, we look carefully at element types.</span>
<span class="line-modified">!       if (k1-&gt;is_obj_array_klass() &amp;&amp; k2-&gt;is_obj_array_klass()) {</span>
<span class="line-modified">!         // Meet the element types, then construct the corresponding array type.</span>
<span class="line-modified">!         ciKlass* elem1 = k1-&gt;as_obj_array_klass()-&gt;element_klass();</span>
<span class="line-modified">!         ciKlass* elem2 = k2-&gt;as_obj_array_klass()-&gt;element_klass();</span>
<span class="line-modified">!         ciKlass* elem  = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();</span>
<span class="line-modified">!         // Do an easy shortcut if one type is a super of the other.</span>
<span class="line-modified">!         if (elem == elem1) {</span>
<span class="line-modified">!           assert(k1 == ciObjArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
<span class="line-modified">!           return k1;</span>
<span class="line-modified">!         } else if (elem == elem2) {</span>
<span class="line-modified">!           assert(k2 == ciObjArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
<span class="line-modified">!           return k2;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!           return ciObjArrayKlass::make(elem);</span>
<span class="line-modified">!         }</span>
        } else {
<span class="line-modified">!         return object_klass;</span>
        }
      } else {
<span class="line-modified">!       // Must be two plain old instance klasses.</span>
<span class="line-modified">!       assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);</span>
<span class="line-modified">!       assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);</span>
<span class="line-modified">!       return k1-&gt;least_common_ancestor(k2);</span>
      }
    }
  }
  
  
  // ------------------------------------------------------------------
<span class="line-new-header">--- 301,62 ---</span>
      }
  
      // At least one of the two types is a non-top primitive type.
      // The other type is not equal to it.  Fall to bottom.
      return bottom_type();
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Both types are non-top non-primitive types.  That is,</span>
<span class="line-modified">!   // both types are either instanceKlasses or arrayKlasses.</span>
<span class="line-modified">!   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();</span>
<span class="line-modified">!   ciKlass* k1 = t1-&gt;as_klass();</span>
<span class="line-modified">!   ciKlass* k2 = t2-&gt;as_klass();</span>
<span class="line-modified">!   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {</span>
<span class="line-modified">!     return object_klass;</span>
<span class="line-modified">!   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {</span>
<span class="line-modified">!     // Unloaded classes fall to java.lang.Object at a merge.</span>
<span class="line-modified">!     return object_klass;</span>
<span class="line-modified">!   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {</span>
<span class="line-modified">!     // When an interface meets a non-interface, we get Object;</span>
<span class="line-modified">!     // This is what the verifier does.</span>
<span class="line-modified">!     return object_klass;</span>
<span class="line-modified">!   } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {</span>
<span class="line-modified">!     // When an array meets a non-array, we get Object.</span>
<span class="line-modified">!     // When (obj/value)Array meets typeArray, we also get Object.</span>
<span class="line-modified">!     // And when typeArray meets different typeArray, we again get Object.</span>
<span class="line-modified">!     // But when (obj/value)Array meets (obj/value)Array, we look carefully at element types.</span>
<span class="line-modified">!     if ((k1-&gt;is_obj_array_klass() || k1-&gt;is_value_array_klass()) &amp;&amp;</span>
<span class="line-modified">!         (k2-&gt;is_obj_array_klass() || k2-&gt;is_value_array_klass())) {</span>
<span class="line-modified">!       ciType* elem1 = k1-&gt;as_array_klass()-&gt;element_klass();</span>
<span class="line-modified">!       ciType* elem2 = k2-&gt;as_array_klass()-&gt;element_klass();</span>
<span class="line-modified">!       ciType* elem = elem1;</span>
<span class="line-modified">!       if (elem1 != elem2) {</span>
<span class="line-modified">!         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       // Do an easy shortcut if one type is a super of the other.</span>
<span class="line-modified">!       if (elem == elem1) {</span>
<span class="line-modified">!         assert(k1 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
<span class="line-modified">!         return k1;</span>
<span class="line-modified">!       } else if (elem == elem2) {</span>
<span class="line-modified">!         assert(k2 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
<span class="line-added">+         return k2;</span>
        } else {
<span class="line-modified">!         return ciArrayKlass::make(elem);</span>
        }
      } else {
<span class="line-modified">!       return object_klass;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     // Must be two plain old instance klasses.</span>
<span class="line-added">+     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);</span>
<span class="line-added">+     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);</span>
<span class="line-added">+     ciType* result = k1-&gt;least_common_ancestor(k2);</span>
<span class="line-added">+     if (never_null1 &amp;&amp; never_null2 &amp;&amp; result-&gt;is_valuetype()) {</span>
<span class="line-added">+       // Both value types are never null, mark the result as never null</span>
<span class="line-added">+       result = analyzer-&gt;mark_as_never_null(result);</span>
      }
<span class="line-added">+     return result;</span>
    }
  }
  
  
  // ------------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 394,17 ***</span>
      // even if it were possible for an OSR entry point to be at bci zero.
    }
    // &quot;Push&quot; the method signature into the first few locals.
    state-&gt;set_stack_size(-max_locals());
    if (!method()-&gt;is_static()) {
<span class="line-modified">!     state-&gt;push(method()-&gt;holder());</span>
      assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
    }
    for (ciSignatureStream str(method()-&gt;signature());
         !str.at_return_type();
         str.next()) {
<span class="line-modified">!     state-&gt;push_translate(str.type());</span>
    }
    // Set the rest of the locals to bottom.
    Cell cell = state-&gt;next_cell(state-&gt;tos());
    state-&gt;set_stack_size(0);
    int limit = state-&gt;limit_cell();
<span class="line-new-header">--- 414,26 ---</span>
      // even if it were possible for an OSR entry point to be at bci zero.
    }
    // &quot;Push&quot; the method signature into the first few locals.
    state-&gt;set_stack_size(-max_locals());
    if (!method()-&gt;is_static()) {
<span class="line-modified">!     ciType* holder = method()-&gt;holder();</span>
<span class="line-added">+     if (holder-&gt;is_valuetype()) {</span>
<span class="line-added">+       // The receiver is never null</span>
<span class="line-added">+       holder = mark_as_never_null(holder);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     state-&gt;push(holder);</span>
      assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
    }
    for (ciSignatureStream str(method()-&gt;signature());
         !str.at_return_type();
         str.next()) {
<span class="line-modified">!     ciType* arg = str.type();</span>
<span class="line-added">+     if (str.is_never_null()) {</span>
<span class="line-added">+       arg = mark_as_never_null(arg);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     state-&gt;push_translate(arg);</span>
    }
    // Set the rest of the locals to bottom.
    Cell cell = state-&gt;next_cell(state-&gt;tos());
    state-&gt;set_stack_size(0);
    int limit = state-&gt;limit_cell();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,16 ***</span>
      }
    }
  }
  
  // ------------------------------------------------------------------
<span class="line-modified">! // ciTypeFlow::StateVector::do_aaload</span>
<span class="line-modified">! void ciTypeFlow::StateVector::do_aaload(ciBytecodeStream* str) {</span>
    pop_int();
<span class="line-modified">!   ciObjArrayKlass* array_klass = pop_objArray();</span>
    if (array_klass == NULL) {
<span class="line-modified">!     // Did aaload on a null reference; push a null and ignore the exception.</span>
      // This instruction will never continue normally.  All we have to do
      // is report a value that will meet correctly with any downstream
      // reference types on paths that will truly be executed.  This null type
      // meets with any reference type to yield that same reference type.
      // (The compiler will generate an unconditional exception here.)
<span class="line-new-header">--- 575,16 ---</span>
      }
    }
  }
  
  // ------------------------------------------------------------------
<span class="line-modified">! // ciTypeFlow::StateVector::do_aload</span>
<span class="line-modified">! void ciTypeFlow::StateVector::do_aload(ciBytecodeStream* str) {</span>
    pop_int();
<span class="line-modified">!   ciArrayKlass* array_klass = pop_objOrValueArray();</span>
    if (array_klass == NULL) {
<span class="line-modified">!     // Did aload on a null reference; push a null and ignore the exception.</span>
      // This instruction will never continue normally.  All we have to do
      // is report a value that will meet correctly with any downstream
      // reference types on paths that will truly be executed.  This null type
      // meets with any reference type to yield that same reference type.
      // (The compiler will generate an unconditional exception here.)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,30 ***</span>
      trap(str, element_klass,
           Deoptimization::make_trap_request
           (Deoptimization::Reason_unloaded,
            Deoptimization::Action_reinterpret));
    } else {
<span class="line-modified">!     push_object(element_klass);</span>
    }
  }
  
  
  // ------------------------------------------------------------------
  // ciTypeFlow::StateVector::do_checkcast
  void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
    bool will_link;
    ciKlass* klass = str-&gt;get_klass(will_link);
    if (!will_link) {
<span class="line-modified">!     // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.</span>
<span class="line-modified">!     // Type flow after this block may still be needed in two situations:</span>
<span class="line-modified">!     // 1) C2 uses do_null_assert() and continues compilation for later blocks</span>
<span class="line-modified">!     // 2) C2 does an OSR compile in a later block (see bug 4778368).</span>
<span class="line-modified">!     pop_object();</span>
<span class="line-modified">!     do_null_assert(klass);</span>
    } else {
<span class="line-modified">!     pop_object();</span>
<span class="line-modified">!     push_object(klass);</span>
    }
  }
  
  // ------------------------------------------------------------------
  // ciTypeFlow::StateVector::do_getfield
<span class="line-new-header">--- 605,48 ---</span>
      trap(str, element_klass,
           Deoptimization::make_trap_request
           (Deoptimization::Reason_unloaded,
            Deoptimization::Action_reinterpret));
    } else {
<span class="line-modified">!     if (element_klass-&gt;is_valuetype()) {</span>
<span class="line-added">+       // Value type array elements are never null</span>
<span class="line-added">+       push(outer()-&gt;mark_as_never_null(element_klass));</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       push_object(element_klass);</span>
<span class="line-added">+     }</span>
    }
  }
  
  
  // ------------------------------------------------------------------
  // ciTypeFlow::StateVector::do_checkcast
  void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
    bool will_link;
    ciKlass* klass = str-&gt;get_klass(will_link);
<span class="line-added">+   bool never_null = str-&gt;is_klass_never_null();</span>
    if (!will_link) {
<span class="line-modified">!     if (never_null) {</span>
<span class="line-modified">!       trap(str, klass,</span>
<span class="line-modified">!            Deoptimization::make_trap_request</span>
<span class="line-modified">!            (Deoptimization::Reason_unloaded,</span>
<span class="line-modified">!             Deoptimization::Action_reinterpret));</span>
<span class="line-modified">!     } else {</span>
<span class="line-added">+       // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.</span>
<span class="line-added">+       // Type flow after this block may still be needed in two situations:</span>
<span class="line-added">+       // 1) C2 uses do_null_assert() and continues compilation for later blocks</span>
<span class="line-added">+       // 2) C2 does an OSR compile in a later block (see bug 4778368).</span>
<span class="line-added">+       pop_object();</span>
<span class="line-added">+       do_null_assert(klass);</span>
<span class="line-added">+     }</span>
    } else {
<span class="line-modified">!     ciType* type = pop_value();</span>
<span class="line-modified">!     if (klass-&gt;is_valuetype() &amp;&amp; (never_null || type-&gt;is_never_null())) {</span>
<span class="line-added">+       // Casting to a Q-Type contains a NULL check</span>
<span class="line-added">+       push(outer()-&gt;mark_as_never_null(klass));</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       push_object(klass);</span>
<span class="line-added">+     }</span>
    }
  }
  
  // ------------------------------------------------------------------
  // ciTypeFlow::StateVector::do_getfield
</pre>
<hr />
<pre>
<span class="line-old-header">*** 637,10 ***</span>
<span class="line-new-header">--- 684,14 ---</span>
        // here can make an OSR entry point unreachable, triggering the
        // assert on non_osr_block in ciTypeFlow::get_start_state.
        // (See bug 4379915.)
        do_null_assert(field_type-&gt;as_klass());
      } else {
<span class="line-added">+       if (field-&gt;is_flattenable()) {</span>
<span class="line-added">+         // A flattenable field is never null</span>
<span class="line-added">+         field_type = outer()-&gt;mark_as_never_null(field_type);</span>
<span class="line-added">+       }</span>
        push_translate(field_type);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 704,10 ***</span>
<span class="line-new-header">--- 755,13 ---</span>
          // ever sees a non-null value, loading has occurred.
          //
          // See do_getstatic() for similar explanation, as well as bug 4684993.
          do_null_assert(return_type-&gt;as_klass());
        } else {
<span class="line-added">+         if (sigstr.is_never_null()) {</span>
<span class="line-added">+           return_type = outer()-&gt;mark_as_never_null(return_type);</span>
<span class="line-added">+         }</span>
          push_translate(return_type);
        }
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 733,11 ***</span>
      ciObject* obj = con.as_object();
      if (obj-&gt;is_null_object()) {
        push_null();
      } else {
        assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
<span class="line-modified">!       push_object(obj-&gt;klass());</span>
      }
    } else {
      push_translate(ciType::make(basic_type));
    }
  }
<span class="line-new-header">--- 787,15 ---</span>
      ciObject* obj = con.as_object();
      if (obj-&gt;is_null_object()) {
        push_null();
      } else {
        assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
<span class="line-modified">!       ciType* type = obj-&gt;klass();</span>
<span class="line-added">+       if (type-&gt;is_valuetype()) {</span>
<span class="line-added">+         type = outer()-&gt;mark_as_never_null(type);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       push(type);</span>
      }
    } else {
      push_translate(ciType::make(basic_type));
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 768,10 ***</span>
<span class="line-new-header">--- 826,46 ---</span>
    } else {
      push_object(klass);
    }
  }
  
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // ciTypeFlow::StateVector::do_defaultvalue</span>
<span class="line-added">+ void ciTypeFlow::StateVector::do_defaultvalue(ciBytecodeStream* str) {</span>
<span class="line-added">+   bool will_link;</span>
<span class="line-added">+   ciKlass* klass = str-&gt;get_klass(will_link);</span>
<span class="line-added">+   if (!will_link) {</span>
<span class="line-added">+     trap(str, klass, str-&gt;get_klass_index());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // The default value type is never null</span>
<span class="line-added">+     push(outer()-&gt;mark_as_never_null(klass));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // ciTypeFlow::StateVector::do_withfield</span>
<span class="line-added">+ void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {</span>
<span class="line-added">+   bool will_link;</span>
<span class="line-added">+   ciField* field = str-&gt;get_field(will_link);</span>
<span class="line-added">+   ciKlass* klass = field-&gt;holder();</span>
<span class="line-added">+   if (!will_link) {</span>
<span class="line-added">+     trap(str, klass, str-&gt;get_field_holder_index());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ciType* type = pop_value();</span>
<span class="line-added">+     ciType* field_type = field-&gt;type();</span>
<span class="line-added">+     assert(field_type-&gt;is_loaded(), &quot;field type must be loaded&quot;);</span>
<span class="line-added">+     if (field_type-&gt;is_two_word()) {</span>
<span class="line-added">+       ciType* type2 = pop_value();</span>
<span class="line-added">+       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);</span>
<span class="line-added">+       assert(type == half_type(type2), &quot;must be 2nd half&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     pop_object();</span>
<span class="line-added">+     // The newly created value type can never be null</span>
<span class="line-added">+     push(outer()-&gt;mark_as_never_null(klass));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // ------------------------------------------------------------------
  // ciTypeFlow::StateVector::do_newarray
  void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
    pop_int();
    ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 873,17 ***</span>
      tty-&gt;print_cr(&quot;&gt;&gt; Interpreting bytecode %d:%s&quot;, str-&gt;cur_bci(),
                    Bytecodes::name(str-&gt;cur_bc()));
    }
  
    switch(str-&gt;cur_bc()) {
<span class="line-modified">!   case Bytecodes::_aaload: do_aaload(str);                       break;</span>
  
    case Bytecodes::_aastore:
      {
        pop_object();
        pop_int();
<span class="line-modified">!       pop_objArray();</span>
        break;
      }
    case Bytecodes::_aconst_null:
      {
        push_null();
<span class="line-new-header">--- 967,17 ---</span>
      tty-&gt;print_cr(&quot;&gt;&gt; Interpreting bytecode %d:%s&quot;, str-&gt;cur_bci(),
                    Bytecodes::name(str-&gt;cur_bc()));
    }
  
    switch(str-&gt;cur_bc()) {
<span class="line-modified">!   case Bytecodes::_aaload: do_aload(str);                           break;</span>
  
    case Bytecodes::_aastore:
      {
        pop_object();
        pop_int();
<span class="line-modified">!       pop_objOrValueArray();</span>
        break;
      }
    case Bytecodes::_aconst_null:
      {
        push_null();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 901,11 ***</span>
        bool will_link;
        ciKlass* element_klass = str-&gt;get_klass(will_link);
        if (!will_link) {
          trap(str, element_klass, str-&gt;get_klass_index());
        } else {
<span class="line-modified">!         push_object(ciObjArrayKlass::make(element_klass));</span>
        }
        break;
      }
    case Bytecodes::_areturn:
    case Bytecodes::_ifnonnull:
<span class="line-new-header">--- 995,11 ---</span>
        bool will_link;
        ciKlass* element_klass = str-&gt;get_klass(will_link);
        if (!will_link) {
          trap(str, element_klass, str-&gt;get_klass_index());
        } else {
<span class="line-modified">!         push_object(ciArrayKlass::make(element_klass));</span>
        }
        break;
      }
    case Bytecodes::_areturn:
    case Bytecodes::_ifnonnull:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1433,10 ***</span>
<span class="line-new-header">--- 1527,13 ---</span>
  
    case Bytecodes::_multianewarray: do_multianewarray(str);          break;
  
    case Bytecodes::_new:      do_new(str);                           break;
  
<span class="line-added">+   case Bytecodes::_defaultvalue: do_defaultvalue(str);              break;</span>
<span class="line-added">+   case Bytecodes::_withfield: do_withfield(str);                    break;</span>
<span class="line-added">+ </span>
    case Bytecodes::_newarray: do_newarray(str);                      break;
  
    case Bytecodes::_pop:
      {
        pop();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1460,10 ***</span>
<span class="line-new-header">--- 1557,11 ---</span>
        ciType* value2 = pop_value();
        push(value1);
        push(value2);
        break;
      }
<span class="line-added">+ </span>
    case Bytecodes::_wide:
    default:
      {
        // The iterator should skip this.
        ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1743,13 ***</span>
            _successors-&gt;append_if_missing(block);
          }
          break;
        }
  
<span class="line-modified">!       case Bytecodes::_athrow:     case Bytecodes::_ireturn:</span>
<span class="line-modified">!       case Bytecodes::_lreturn:    case Bytecodes::_freturn:</span>
<span class="line-modified">!       case Bytecodes::_dreturn:    case Bytecodes::_areturn:</span>
        case Bytecodes::_return:
          _successors =
            new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
          // No successors
          break;
<span class="line-new-header">--- 1841,16 ---</span>
            _successors-&gt;append_if_missing(block);
          }
          break;
        }
  
<span class="line-modified">!       case Bytecodes::_athrow:</span>
<span class="line-modified">!       case Bytecodes::_ireturn:</span>
<span class="line-modified">!       case Bytecodes::_lreturn:</span>
<span class="line-added">+       case Bytecodes::_freturn:</span>
<span class="line-added">+       case Bytecodes::_dreturn:</span>
<span class="line-added">+       case Bytecodes::_areturn:</span>
        case Bytecodes::_return:
          _successors =
            new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
          // No successors
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2976,10 ***</span>
<span class="line-new-header">--- 3077,15 ---</span>
      // Record the first failure reason.
      _failure_reason = reason;
    }
  }
  
<span class="line-added">+ ciType* ciTypeFlow::mark_as_never_null(ciType* type) {</span>
<span class="line-added">+   // Wrap the type to carry the information that it is never null</span>
<span class="line-added">+   return env()-&gt;make_never_null_wrapper(type);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #ifndef PRODUCT
  // ------------------------------------------------------------------
  // ciTypeFlow::print_on
  void ciTypeFlow::print_on(outputStream* st) const {
    // Walk through CI blocks
</pre>
<center><a href="../../cpu/aarch64/sharedRuntime_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classListParser.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
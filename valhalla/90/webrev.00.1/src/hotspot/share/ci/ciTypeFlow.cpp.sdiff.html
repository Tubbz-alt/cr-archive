<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciTypeFlow.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/aarch64/sharedRuntime_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classListParser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciTypeFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciConstant.hpp&quot;
  27 #include &quot;ci/ciField.hpp&quot;
  28 #include &quot;ci/ciMethod.hpp&quot;
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciStreams.hpp&quot;
  32 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  33 #include &quot;ci/ciTypeFlow.hpp&quot;

  34 #include &quot;compiler/compileLog.hpp&quot;
  35 #include &quot;interpreter/bytecode.hpp&quot;
  36 #include &quot;interpreter/bytecodes.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;opto/compile.hpp&quot;
  41 #include &quot;opto/node.hpp&quot;
  42 #include &quot;runtime/deoptimization.hpp&quot;
  43 #include &quot;utilities/growableArray.hpp&quot;
  44 
  45 // ciTypeFlow::JsrSet
  46 //
  47 // A JsrSet represents some set of JsrRecords.  This class
  48 // is used to record a set of all jsr routines which we permit
  49 // execution to return (ret) from.
  50 //
  51 // During abstract interpretation, JsrSets are used to determine
  52 // whether two paths which reach a given block are unique, and
  53 // should be cloned apart, or are compatible, and should merge
</pre>
<hr />
<pre>
 258 // ciTypeFlow::StateVector::type_meet
 259 //
 260 // Meet two types.
 261 //
 262 // The semi-lattice of types use by this analysis are modeled on those
 263 // of the verifier.  The lattice is as follows:
 264 //
 265 //        top_type() &gt;= all non-extremal types &gt;= bottom_type
 266 //                             and
 267 //   Every primitive type is comparable only with itself.  The meet of
 268 //   reference types is determined by their kind: instance class,
 269 //   interface, or array class.  The meet of two types of the same
 270 //   kind is their least common ancestor.  The meet of two types of
 271 //   different kinds is always java.lang.Object.
 272 ciType* ciTypeFlow::StateVector::type_meet_internal(ciType* t1, ciType* t2, ciTypeFlow* analyzer) {
 273   assert(t1 != t2, &quot;checked in caller&quot;);
 274   if (t1-&gt;equals(top_type())) {
 275     return t2;
 276   } else if (t2-&gt;equals(top_type())) {
 277     return t1;
<span class="line-modified"> 278   } else if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {</span>











 279     // Special case null_type.  null_type meet any reference type T
 280     // is T.  null_type meet null_type is null_type.
 281     if (t1-&gt;equals(null_type())) {
 282       if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {
 283         return t2;
 284       }
 285     } else if (t2-&gt;equals(null_type())) {
 286       if (!t1-&gt;is_primitive_type()) {
 287         return t1;
 288       }
 289     }
 290 
 291     // At least one of the two types is a non-top primitive type.
 292     // The other type is not equal to it.  Fall to bottom.
 293     return bottom_type();
<span class="line-modified"> 294   } else {</span>
<span class="line-modified"> 295     // Both types are non-top non-primitive types.  That is,</span>
<span class="line-modified"> 296     // both types are either instanceKlasses or arrayKlasses.</span>
<span class="line-modified"> 297     ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();</span>
<span class="line-modified"> 298     ciKlass* k1 = t1-&gt;as_klass();</span>
<span class="line-modified"> 299     ciKlass* k2 = t2-&gt;as_klass();</span>
<span class="line-modified"> 300     if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {</span>
<span class="line-modified"> 301       return object_klass;</span>
<span class="line-modified"> 302     } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {</span>
<span class="line-modified"> 303       // Unloaded classes fall to java.lang.Object at a merge.</span>
<span class="line-modified"> 304       return object_klass;</span>
<span class="line-modified"> 305     } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {</span>
<span class="line-modified"> 306       // When an interface meets a non-interface, we get Object;</span>
<span class="line-modified"> 307       // This is what the verifier does.</span>
<span class="line-modified"> 308       return object_klass;</span>
<span class="line-modified"> 309     } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {</span>
<span class="line-modified"> 310       // When an array meets a non-array, we get Object.</span>
<span class="line-modified"> 311       // When objArray meets typeArray, we also get Object.</span>
<span class="line-modified"> 312       // And when typeArray meets different typeArray, we again get Object.</span>
<span class="line-modified"> 313       // But when objArray meets objArray, we look carefully at element types.</span>
<span class="line-modified"> 314       if (k1-&gt;is_obj_array_klass() &amp;&amp; k2-&gt;is_obj_array_klass()) {</span>
<span class="line-modified"> 315         // Meet the element types, then construct the corresponding array type.</span>
<span class="line-modified"> 316         ciKlass* elem1 = k1-&gt;as_obj_array_klass()-&gt;element_klass();</span>
<span class="line-modified"> 317         ciKlass* elem2 = k2-&gt;as_obj_array_klass()-&gt;element_klass();</span>
<span class="line-modified"> 318         ciKlass* elem  = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();</span>
<span class="line-modified"> 319         // Do an easy shortcut if one type is a super of the other.</span>
<span class="line-modified"> 320         if (elem == elem1) {</span>
<span class="line-modified"> 321           assert(k1 == ciObjArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
<span class="line-modified"> 322           return k1;</span>
<span class="line-modified"> 323         } else if (elem == elem2) {</span>
<span class="line-modified"> 324           assert(k2 == ciObjArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
<span class="line-modified"> 325           return k2;</span>
<span class="line-modified"> 326         } else {</span>
<span class="line-modified"> 327           return ciObjArrayKlass::make(elem);</span>
<span class="line-modified"> 328         }</span>

 329       } else {
<span class="line-modified"> 330         return object_klass;</span>
 331       }
 332     } else {
<span class="line-modified"> 333       // Must be two plain old instance klasses.</span>
<span class="line-modified"> 334       assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);</span>
<span class="line-modified"> 335       assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);</span>
<span class="line-modified"> 336       return k1-&gt;least_common_ancestor(k2);</span>






 337     }

 338   }
 339 }
 340 
 341 
 342 // ------------------------------------------------------------------
 343 // ciTypeFlow::StateVector::StateVector
 344 //
 345 // Build a new state vector
 346 ciTypeFlow::StateVector::StateVector(ciTypeFlow* analyzer) {
 347   _outer = analyzer;
 348   _stack_size = -1;
 349   _monitor_count = -1;
 350   // Allocate the _types array
 351   int max_cells = analyzer-&gt;max_cells();
 352   _types = (ciType**)analyzer-&gt;arena()-&gt;Amalloc(sizeof(ciType*) * max_cells);
 353   for (int i=0; i&lt;max_cells; i++) {
 354     _types[i] = top_type();
 355   }
 356   _trap_bci = -1;
 357   _trap_index = 0;
</pre>
<hr />
<pre>
 379     }
 380     // load up the non-OSR state at this point
 381     non_osr_block-&gt;copy_state_into(state);
 382     int non_osr_start = non_osr_block-&gt;start();
 383     if (non_osr_start != start_bci()) {
 384       // must flow forward from it
 385       if (CITraceTypeFlow) {
 386         tty-&gt;print_cr(&quot;&gt;&gt; Interpreting pre-OSR block %d:&quot;, non_osr_start);
 387       }
 388       Block* block = block_at(non_osr_start, jsrs);
 389       assert(block-&gt;limit() == start_bci(), &quot;must flow forward to start&quot;);
 390       flow_block(block, state, jsrs);
 391     }
 392     return state;
 393     // Note:  The code below would be an incorrect for an OSR flow,
 394     // even if it were possible for an OSR entry point to be at bci zero.
 395   }
 396   // &quot;Push&quot; the method signature into the first few locals.
 397   state-&gt;set_stack_size(-max_locals());
 398   if (!method()-&gt;is_static()) {
<span class="line-modified"> 399     state-&gt;push(method()-&gt;holder());</span>





 400     assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
 401   }
 402   for (ciSignatureStream str(method()-&gt;signature());
 403        !str.at_return_type();
 404        str.next()) {
<span class="line-modified"> 405     state-&gt;push_translate(str.type());</span>




 406   }
 407   // Set the rest of the locals to bottom.
 408   Cell cell = state-&gt;next_cell(state-&gt;tos());
 409   state-&gt;set_stack_size(0);
 410   int limit = state-&gt;limit_cell();
 411   for (; cell &lt; limit; cell = state-&gt;next_cell(cell)) {
 412     state-&gt;set_type_at(cell, state-&gt;bottom_type());
 413   }
 414   // Lock an object, if necessary.
 415   state-&gt;set_monitor_count(method()-&gt;is_synchronized() ? 1 : 0);
 416   return state;
 417 }
 418 
 419 // ------------------------------------------------------------------
 420 // ciTypeFlow::StateVector::copy_into
 421 //
 422 // Copy our value into some other StateVector
 423 void ciTypeFlow::StateVector::copy_into(ciTypeFlow::StateVector* copy)
 424 const {
 425   copy-&gt;set_stack_size(stack_size());
</pre>
<hr />
<pre>
 531 
 532   return different;
 533 }
 534 
 535 // ------------------------------------------------------------------
 536 // ciTypeFlow::StateVector::push_translate
 537 void ciTypeFlow::StateVector::push_translate(ciType* type) {
 538   BasicType basic_type = type-&gt;basic_type();
 539   if (basic_type == T_BOOLEAN || basic_type == T_CHAR ||
 540       basic_type == T_BYTE    || basic_type == T_SHORT) {
 541     push_int();
 542   } else {
 543     push(type);
 544     if (type-&gt;is_two_word()) {
 545       push(half_type(type));
 546     }
 547   }
 548 }
 549 
 550 // ------------------------------------------------------------------
<span class="line-modified"> 551 // ciTypeFlow::StateVector::do_aaload</span>
<span class="line-modified"> 552 void ciTypeFlow::StateVector::do_aaload(ciBytecodeStream* str) {</span>
 553   pop_int();
<span class="line-modified"> 554   ciObjArrayKlass* array_klass = pop_objArray();</span>
 555   if (array_klass == NULL) {
<span class="line-modified"> 556     // Did aaload on a null reference; push a null and ignore the exception.</span>
 557     // This instruction will never continue normally.  All we have to do
 558     // is report a value that will meet correctly with any downstream
 559     // reference types on paths that will truly be executed.  This null type
 560     // meets with any reference type to yield that same reference type.
 561     // (The compiler will generate an unconditional exception here.)
 562     push(null_type());
 563     return;
 564   }
 565   if (!array_klass-&gt;is_loaded()) {
 566     // Only fails for some -Xcomp runs
 567     trap(str, array_klass,
 568          Deoptimization::make_trap_request
 569          (Deoptimization::Reason_unloaded,
 570           Deoptimization::Action_reinterpret));
 571     return;
 572   }
 573   ciKlass* element_klass = array_klass-&gt;element_klass();
 574   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 575     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 576     trap(str, element_klass,
 577          Deoptimization::make_trap_request
 578          (Deoptimization::Reason_unloaded,
 579           Deoptimization::Action_reinterpret));
 580   } else {
<span class="line-modified"> 581     push_object(element_klass);</span>





 582   }
 583 }
 584 
 585 
 586 // ------------------------------------------------------------------
 587 // ciTypeFlow::StateVector::do_checkcast
 588 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 589   bool will_link;
 590   ciKlass* klass = str-&gt;get_klass(will_link);

 591   if (!will_link) {
<span class="line-modified"> 592     // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.</span>
<span class="line-modified"> 593     // Type flow after this block may still be needed in two situations:</span>
<span class="line-modified"> 594     // 1) C2 uses do_null_assert() and continues compilation for later blocks</span>
<span class="line-modified"> 595     // 2) C2 does an OSR compile in a later block (see bug 4778368).</span>
<span class="line-modified"> 596     pop_object();</span>
<span class="line-modified"> 597     do_null_assert(klass);</span>







 598   } else {
<span class="line-modified"> 599     pop_object();</span>
<span class="line-modified"> 600     push_object(klass);</span>





 601   }
 602 }
 603 
 604 // ------------------------------------------------------------------
 605 // ciTypeFlow::StateVector::do_getfield
 606 void ciTypeFlow::StateVector::do_getfield(ciBytecodeStream* str) {
 607   // could add assert here for type of object.
 608   pop_object();
 609   do_getstatic(str);
 610 }
 611 
 612 // ------------------------------------------------------------------
 613 // ciTypeFlow::StateVector::do_getstatic
 614 void ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream* str) {
 615   bool will_link;
 616   ciField* field = str-&gt;get_field(will_link);
 617   if (!will_link) {
 618     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 619   } else {
 620     ciType* field_type = field-&gt;type();
</pre>
<hr />
<pre>
 622       // Normally, we need the field&#39;s type to be loaded if we are to
 623       // do anything interesting with its value.
 624       // We used to do this:  trap(str, str-&gt;get_field_signature_index());
 625       //
 626       // There is one good reason not to trap here.  Execution can
 627       // get past this &quot;getfield&quot; or &quot;getstatic&quot; if the value of
 628       // the field is null.  As long as the value is null, the class
 629       // does not need to be loaded!  The compiler must assume that
 630       // the value of the unloaded class reference is null; if the code
 631       // ever sees a non-null value, loading has occurred.
 632       //
 633       // This actually happens often enough to be annoying.  If the
 634       // compiler throws an uncommon trap at this bytecode, you can
 635       // get an endless loop of recompilations, when all the code
 636       // needs to do is load a series of null values.  Also, a trap
 637       // here can make an OSR entry point unreachable, triggering the
 638       // assert on non_osr_block in ciTypeFlow::get_start_state.
 639       // (See bug 4379915.)
 640       do_null_assert(field_type-&gt;as_klass());
 641     } else {




 642       push_translate(field_type);
 643     }
 644   }
 645 }
 646 
 647 // ------------------------------------------------------------------
 648 // ciTypeFlow::StateVector::do_invoke
 649 void ciTypeFlow::StateVector::do_invoke(ciBytecodeStream* str,
 650                                         bool has_receiver) {
 651   bool will_link;
 652   ciSignature* declared_signature = NULL;
 653   ciMethod* callee = str-&gt;get_method(will_link, &amp;declared_signature);
 654   assert(declared_signature != NULL, &quot;cannot be null&quot;);
 655   if (!will_link) {
 656     // We weren&#39;t able to find the method.
 657     if (str-&gt;cur_bc() == Bytecodes::_invokedynamic) {
 658       trap(str, NULL,
 659            Deoptimization::make_trap_request
 660            (Deoptimization::Reason_uninitialized,
 661             Deoptimization::Action_reinterpret));
</pre>
<hr />
<pre>
 689       // Check this?
 690       pop_object();
 691     }
 692     assert(!sigstr.is_done(), &quot;must have return type&quot;);
 693     ciType* return_type = sigstr.type();
 694     if (!return_type-&gt;is_void()) {
 695       if (!return_type-&gt;is_loaded()) {
 696         // As in do_getstatic(), generally speaking, we need the return type to
 697         // be loaded if we are to do anything interesting with its value.
 698         // We used to do this:  trap(str, str-&gt;get_method_signature_index());
 699         //
 700         // We do not trap here since execution can get past this invoke if
 701         // the return value is null.  As long as the value is null, the class
 702         // does not need to be loaded!  The compiler must assume that
 703         // the value of the unloaded class reference is null; if the code
 704         // ever sees a non-null value, loading has occurred.
 705         //
 706         // See do_getstatic() for similar explanation, as well as bug 4684993.
 707         do_null_assert(return_type-&gt;as_klass());
 708       } else {



 709         push_translate(return_type);
 710       }
 711     }
 712   }
 713 }
 714 
 715 // ------------------------------------------------------------------
 716 // ciTypeFlow::StateVector::do_jsr
 717 void ciTypeFlow::StateVector::do_jsr(ciBytecodeStream* str) {
 718   push(ciReturnAddress::make(str-&gt;next_bci()));
 719 }
 720 
 721 // ------------------------------------------------------------------
 722 // ciTypeFlow::StateVector::do_ldc
 723 void ciTypeFlow::StateVector::do_ldc(ciBytecodeStream* str) {
 724   ciConstant con = str-&gt;get_constant();
 725   BasicType basic_type = con.basic_type();
 726   if (basic_type == T_ILLEGAL) {
 727     // OutOfMemoryError in the CI while loading constant
 728     push_null();
 729     outer()-&gt;record_failure(&quot;ldc did not link&quot;);
 730     return;
 731   }
 732   if (is_reference_type(basic_type)) {
 733     ciObject* obj = con.as_object();
 734     if (obj-&gt;is_null_object()) {
 735       push_null();
 736     } else {
 737       assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
<span class="line-modified"> 738       push_object(obj-&gt;klass());</span>




 739     }
 740   } else {
 741     push_translate(ciType::make(basic_type));
 742   }
 743 }
 744 
 745 // ------------------------------------------------------------------
 746 // ciTypeFlow::StateVector::do_multianewarray
 747 void ciTypeFlow::StateVector::do_multianewarray(ciBytecodeStream* str) {
 748   int dimensions = str-&gt;get_dimensions();
 749   bool will_link;
 750   ciArrayKlass* array_klass = str-&gt;get_klass(will_link)-&gt;as_array_klass();
 751   if (!will_link) {
 752     trap(str, array_klass, str-&gt;get_klass_index());
 753   } else {
 754     for (int i = 0; i &lt; dimensions; i++) {
 755       pop_int();
 756     }
 757     push_object(array_klass);
 758   }
 759 }
 760 
 761 // ------------------------------------------------------------------
 762 // ciTypeFlow::StateVector::do_new
 763 void ciTypeFlow::StateVector::do_new(ciBytecodeStream* str) {
 764   bool will_link;
 765   ciKlass* klass = str-&gt;get_klass(will_link);
 766   if (!will_link || str-&gt;is_unresolved_klass()) {
 767     trap(str, klass, str-&gt;get_klass_index());
 768   } else {
 769     push_object(klass);
 770   }
 771 }
 772 




































 773 // ------------------------------------------------------------------
 774 // ciTypeFlow::StateVector::do_newarray
 775 void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
 776   pop_int();
 777   ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
 778   push_object(klass);
 779 }
 780 
 781 // ------------------------------------------------------------------
 782 // ciTypeFlow::StateVector::do_putfield
 783 void ciTypeFlow::StateVector::do_putfield(ciBytecodeStream* str) {
 784   do_putstatic(str);
 785   if (_trap_bci != -1)  return;  // unloaded field holder, etc.
 786   // could add assert here for type of object.
 787   pop_object();
 788 }
 789 
 790 // ------------------------------------------------------------------
 791 // ciTypeFlow::StateVector::do_putstatic
 792 void ciTypeFlow::StateVector::do_putstatic(ciBytecodeStream* str) {
</pre>
<hr />
<pre>
 858     // class later.
 859     push_null();
 860   }
 861 }
 862 
 863 
 864 // ------------------------------------------------------------------
 865 // ciTypeFlow::StateVector::apply_one_bytecode
 866 //
 867 // Apply the effect of one bytecode to this StateVector
 868 bool ciTypeFlow::StateVector::apply_one_bytecode(ciBytecodeStream* str) {
 869   _trap_bci = -1;
 870   _trap_index = 0;
 871 
 872   if (CITraceTypeFlow) {
 873     tty-&gt;print_cr(&quot;&gt;&gt; Interpreting bytecode %d:%s&quot;, str-&gt;cur_bci(),
 874                   Bytecodes::name(str-&gt;cur_bc()));
 875   }
 876 
 877   switch(str-&gt;cur_bc()) {
<span class="line-modified"> 878   case Bytecodes::_aaload: do_aaload(str);                       break;</span>
 879 
 880   case Bytecodes::_aastore:
 881     {
 882       pop_object();
 883       pop_int();
<span class="line-modified"> 884       pop_objArray();</span>
 885       break;
 886     }
 887   case Bytecodes::_aconst_null:
 888     {
 889       push_null();
 890       break;
 891     }
 892   case Bytecodes::_aload:   load_local_object(str-&gt;get_index());    break;
 893   case Bytecodes::_aload_0: load_local_object(0);                   break;
 894   case Bytecodes::_aload_1: load_local_object(1);                   break;
 895   case Bytecodes::_aload_2: load_local_object(2);                   break;
 896   case Bytecodes::_aload_3: load_local_object(3);                   break;
 897 
 898   case Bytecodes::_anewarray:
 899     {
 900       pop_int();
 901       bool will_link;
 902       ciKlass* element_klass = str-&gt;get_klass(will_link);
 903       if (!will_link) {
 904         trap(str, element_klass, str-&gt;get_klass_index());
 905       } else {
<span class="line-modified"> 906         push_object(ciObjArrayKlass::make(element_klass));</span>
 907       }
 908       break;
 909     }
 910   case Bytecodes::_areturn:
 911   case Bytecodes::_ifnonnull:
 912   case Bytecodes::_ifnull:
 913     {
 914       pop_object();
 915       break;
 916     }
 917   case Bytecodes::_monitorenter:
 918     {
 919       pop_object();
 920       set_monitor_count(monitor_count() + 1);
 921       break;
 922     }
 923   case Bytecodes::_monitorexit:
 924     {
 925       pop_object();
 926       assert(monitor_count() &gt; 0, &quot;must be a monitor to exit from&quot;);
</pre>
<hr />
<pre>
1418     }
1419   case Bytecodes::_lshl:
1420   case Bytecodes::_lshr:
1421   case Bytecodes::_lushr:
1422     {
1423       pop_int();
1424       pop_long();
1425       push_long();
1426       break;
1427     }
1428   case Bytecodes::_lstore:   store_local_long(str-&gt;get_index());    break;
1429   case Bytecodes::_lstore_0: store_local_long(0);                   break;
1430   case Bytecodes::_lstore_1: store_local_long(1);                   break;
1431   case Bytecodes::_lstore_2: store_local_long(2);                   break;
1432   case Bytecodes::_lstore_3: store_local_long(3);                   break;
1433 
1434   case Bytecodes::_multianewarray: do_multianewarray(str);          break;
1435 
1436   case Bytecodes::_new:      do_new(str);                           break;
1437 



1438   case Bytecodes::_newarray: do_newarray(str);                      break;
1439 
1440   case Bytecodes::_pop:
1441     {
1442       pop();
1443       break;
1444     }
1445   case Bytecodes::_pop2:
1446     {
1447       pop();
1448       pop();
1449       break;
1450     }
1451 
1452   case Bytecodes::_putfield:       do_putfield(str);                 break;
1453   case Bytecodes::_putstatic:      do_putstatic(str);                break;
1454 
1455   case Bytecodes::_ret: do_ret(str);                                 break;
1456 
1457   case Bytecodes::_swap:
1458     {
1459       ciType* value1 = pop_value();
1460       ciType* value2 = pop_value();
1461       push(value1);
1462       push(value2);
1463       break;
1464     }

1465   case Bytecodes::_wide:
1466   default:
1467     {
1468       // The iterator should skip this.
1469       ShouldNotReachHere();
1470       break;
1471     }
1472   }
1473 
1474   if (CITraceTypeFlow) {
1475     print_on(tty);
1476   }
1477 
1478   return (_trap_bci != -1);
1479 }
1480 
1481 #ifndef PRODUCT
1482 // ------------------------------------------------------------------
1483 // ciTypeFlow::StateVector::print_cell_on
1484 void ciTypeFlow::StateVector::print_cell_on(outputStream* st, Cell c) const {
</pre>
<hr />
<pre>
1728       case Bytecodes::_lookupswitch: {
1729         Bytecode_lookupswitch lookupswitch(str);
1730 
1731         int npairs = lookupswitch.number_of_pairs();
1732         _successors =
1733           new (arena) GrowableArray&lt;Block*&gt;(arena, npairs+1, 0, NULL);
1734         int bci = current_bci + lookupswitch.default_offset();
1735         Block* block = analyzer-&gt;block_at(bci, jsrs);
1736         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1737         _successors-&gt;append(block);
1738         while(--npairs &gt;= 0) {
1739           LookupswitchPair pair = lookupswitch.pair_at(npairs);
1740           int bci = current_bci + pair.offset();
1741           Block* block = analyzer-&gt;block_at(bci, jsrs);
1742           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1743           _successors-&gt;append_if_missing(block);
1744         }
1745         break;
1746       }
1747 
<span class="line-modified">1748       case Bytecodes::_athrow:     case Bytecodes::_ireturn:</span>
<span class="line-modified">1749       case Bytecodes::_lreturn:    case Bytecodes::_freturn:</span>
<span class="line-modified">1750       case Bytecodes::_dreturn:    case Bytecodes::_areturn:</span>



1751       case Bytecodes::_return:
1752         _successors =
1753           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1754         // No successors
1755         break;
1756 
1757       case Bytecodes::_ret: {
1758         _successors =
1759           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1760 
1761         Cell local = state-&gt;local(str-&gt;get_index());
1762         ciType* return_address = state-&gt;type_at(local);
1763         assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
1764         int bci = return_address-&gt;as_return_address()-&gt;bci();
1765         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1766         _successors-&gt;append(analyzer-&gt;block_at(bci, jsrs));
1767         break;
1768       }
1769 
1770       case Bytecodes::_wide:
</pre>
<hr />
<pre>
2961 
2962 // ------------------------------------------------------------------
2963 // ciTypeFlow::record_failure()
2964 // The ciTypeFlow object keeps track of failure reasons separately from the ciEnv.
2965 // This is required because there is not a 1-1 relation between the ciEnv and
2966 // the TypeFlow passes within a compilation task.  For example, if the compiler
2967 // is considering inlining a method, it will request a TypeFlow.  If that fails,
2968 // the compilation as a whole may continue without the inlining.  Some TypeFlow
2969 // requests are not optional; if they fail the requestor is responsible for
2970 // copying the failure reason up to the ciEnv.  (See Parse::Parse.)
2971 void ciTypeFlow::record_failure(const char* reason) {
2972   if (env()-&gt;log() != NULL) {
2973     env()-&gt;log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;typeflow&#39;&quot;, reason);
2974   }
2975   if (_failure_reason == NULL) {
2976     // Record the first failure reason.
2977     _failure_reason = reason;
2978   }
2979 }
2980 





2981 #ifndef PRODUCT
2982 // ------------------------------------------------------------------
2983 // ciTypeFlow::print_on
2984 void ciTypeFlow::print_on(outputStream* st) const {
2985   // Walk through CI blocks
2986   st-&gt;print_cr(&quot;********************************************************&quot;);
2987   st-&gt;print   (&quot;TypeFlow for &quot;);
2988   method()-&gt;name()-&gt;print_symbol_on(st);
2989   int limit_bci = code_size();
2990   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
2991   ciMethodBlocks  *mblks = _methodBlocks;
2992   ciBlock* current = NULL;
2993   for (int bci = 0; bci &lt; limit_bci; bci++) {
2994     ciBlock* blk = mblks-&gt;block_containing(bci);
2995     if (blk != NULL &amp;&amp; blk != current) {
2996       current = blk;
2997       current-&gt;print_on(st);
2998 
2999       GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[blk-&gt;index()];
3000       int num_blocks = (blocks == NULL) ? 0 : blocks-&gt;length();
</pre>
</td>
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciConstant.hpp&quot;
  27 #include &quot;ci/ciField.hpp&quot;
  28 #include &quot;ci/ciMethod.hpp&quot;
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciStreams.hpp&quot;
  32 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  33 #include &quot;ci/ciTypeFlow.hpp&quot;
<span class="line-added">  34 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  35 #include &quot;compiler/compileLog.hpp&quot;
  36 #include &quot;interpreter/bytecode.hpp&quot;
  37 #include &quot;interpreter/bytecodes.hpp&quot;
  38 #include &quot;memory/allocation.inline.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;opto/compile.hpp&quot;
  42 #include &quot;opto/node.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;utilities/growableArray.hpp&quot;
  45 
  46 // ciTypeFlow::JsrSet
  47 //
  48 // A JsrSet represents some set of JsrRecords.  This class
  49 // is used to record a set of all jsr routines which we permit
  50 // execution to return (ret) from.
  51 //
  52 // During abstract interpretation, JsrSets are used to determine
  53 // whether two paths which reach a given block are unique, and
  54 // should be cloned apart, or are compatible, and should merge
</pre>
<hr />
<pre>
 259 // ciTypeFlow::StateVector::type_meet
 260 //
 261 // Meet two types.
 262 //
 263 // The semi-lattice of types use by this analysis are modeled on those
 264 // of the verifier.  The lattice is as follows:
 265 //
 266 //        top_type() &gt;= all non-extremal types &gt;= bottom_type
 267 //                             and
 268 //   Every primitive type is comparable only with itself.  The meet of
 269 //   reference types is determined by their kind: instance class,
 270 //   interface, or array class.  The meet of two types of the same
 271 //   kind is their least common ancestor.  The meet of two types of
 272 //   different kinds is always java.lang.Object.
 273 ciType* ciTypeFlow::StateVector::type_meet_internal(ciType* t1, ciType* t2, ciTypeFlow* analyzer) {
 274   assert(t1 != t2, &quot;checked in caller&quot;);
 275   if (t1-&gt;equals(top_type())) {
 276     return t2;
 277   } else if (t2-&gt;equals(top_type())) {
 278     return t1;
<span class="line-modified"> 279   }</span>
<span class="line-added"> 280 </span>
<span class="line-added"> 281   // Unwrap after saving nullness information and handling top meets</span>
<span class="line-added"> 282   bool never_null1 = t1-&gt;is_never_null();</span>
<span class="line-added"> 283   bool never_null2 = t2-&gt;is_never_null();</span>
<span class="line-added"> 284   if (t1-&gt;unwrap() == t2-&gt;unwrap() &amp;&amp; never_null1 == never_null2) {</span>
<span class="line-added"> 285     return t1;</span>
<span class="line-added"> 286   }</span>
<span class="line-added"> 287   t1 = t1-&gt;unwrap();</span>
<span class="line-added"> 288   t2 = t2-&gt;unwrap();</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290   if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {</span>
 291     // Special case null_type.  null_type meet any reference type T
 292     // is T.  null_type meet null_type is null_type.
 293     if (t1-&gt;equals(null_type())) {
 294       if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {
 295         return t2;
 296       }
 297     } else if (t2-&gt;equals(null_type())) {
 298       if (!t1-&gt;is_primitive_type()) {
 299         return t1;
 300       }
 301     }
 302 
 303     // At least one of the two types is a non-top primitive type.
 304     // The other type is not equal to it.  Fall to bottom.
 305     return bottom_type();
<span class="line-modified"> 306   }</span>
<span class="line-modified"> 307 </span>
<span class="line-modified"> 308   // Both types are non-top non-primitive types.  That is,</span>
<span class="line-modified"> 309   // both types are either instanceKlasses or arrayKlasses.</span>
<span class="line-modified"> 310   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();</span>
<span class="line-modified"> 311   ciKlass* k1 = t1-&gt;as_klass();</span>
<span class="line-modified"> 312   ciKlass* k2 = t2-&gt;as_klass();</span>
<span class="line-modified"> 313   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {</span>
<span class="line-modified"> 314     return object_klass;</span>
<span class="line-modified"> 315   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {</span>
<span class="line-modified"> 316     // Unloaded classes fall to java.lang.Object at a merge.</span>
<span class="line-modified"> 317     return object_klass;</span>
<span class="line-modified"> 318   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {</span>
<span class="line-modified"> 319     // When an interface meets a non-interface, we get Object;</span>
<span class="line-modified"> 320     // This is what the verifier does.</span>
<span class="line-modified"> 321     return object_klass;</span>
<span class="line-modified"> 322   } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {</span>
<span class="line-modified"> 323     // When an array meets a non-array, we get Object.</span>
<span class="line-modified"> 324     // When (obj/value)Array meets typeArray, we also get Object.</span>
<span class="line-modified"> 325     // And when typeArray meets different typeArray, we again get Object.</span>
<span class="line-modified"> 326     // But when (obj/value)Array meets (obj/value)Array, we look carefully at element types.</span>
<span class="line-modified"> 327     if ((k1-&gt;is_obj_array_klass() || k1-&gt;is_value_array_klass()) &amp;&amp;</span>
<span class="line-modified"> 328         (k2-&gt;is_obj_array_klass() || k2-&gt;is_value_array_klass())) {</span>
<span class="line-modified"> 329       ciType* elem1 = k1-&gt;as_array_klass()-&gt;element_klass();</span>
<span class="line-modified"> 330       ciType* elem2 = k2-&gt;as_array_klass()-&gt;element_klass();</span>
<span class="line-modified"> 331       ciType* elem = elem1;</span>
<span class="line-modified"> 332       if (elem1 != elem2) {</span>
<span class="line-modified"> 333         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();</span>
<span class="line-modified"> 334       }</span>
<span class="line-modified"> 335       // Do an easy shortcut if one type is a super of the other.</span>
<span class="line-modified"> 336       if (elem == elem1) {</span>
<span class="line-modified"> 337         assert(k1 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
<span class="line-modified"> 338         return k1;</span>
<span class="line-modified"> 339       } else if (elem == elem2) {</span>
<span class="line-modified"> 340         assert(k2 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
<span class="line-added"> 341         return k2;</span>
 342       } else {
<span class="line-modified"> 343         return ciArrayKlass::make(elem);</span>
 344       }
 345     } else {
<span class="line-modified"> 346       return object_klass;</span>
<span class="line-modified"> 347     }</span>
<span class="line-modified"> 348   } else {</span>
<span class="line-modified"> 349     // Must be two plain old instance klasses.</span>
<span class="line-added"> 350     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);</span>
<span class="line-added"> 351     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);</span>
<span class="line-added"> 352     ciType* result = k1-&gt;least_common_ancestor(k2);</span>
<span class="line-added"> 353     if (never_null1 &amp;&amp; never_null2 &amp;&amp; result-&gt;is_valuetype()) {</span>
<span class="line-added"> 354       // Both value types are never null, mark the result as never null</span>
<span class="line-added"> 355       result = analyzer-&gt;mark_as_never_null(result);</span>
 356     }
<span class="line-added"> 357     return result;</span>
 358   }
 359 }
 360 
 361 
 362 // ------------------------------------------------------------------
 363 // ciTypeFlow::StateVector::StateVector
 364 //
 365 // Build a new state vector
 366 ciTypeFlow::StateVector::StateVector(ciTypeFlow* analyzer) {
 367   _outer = analyzer;
 368   _stack_size = -1;
 369   _monitor_count = -1;
 370   // Allocate the _types array
 371   int max_cells = analyzer-&gt;max_cells();
 372   _types = (ciType**)analyzer-&gt;arena()-&gt;Amalloc(sizeof(ciType*) * max_cells);
 373   for (int i=0; i&lt;max_cells; i++) {
 374     _types[i] = top_type();
 375   }
 376   _trap_bci = -1;
 377   _trap_index = 0;
</pre>
<hr />
<pre>
 399     }
 400     // load up the non-OSR state at this point
 401     non_osr_block-&gt;copy_state_into(state);
 402     int non_osr_start = non_osr_block-&gt;start();
 403     if (non_osr_start != start_bci()) {
 404       // must flow forward from it
 405       if (CITraceTypeFlow) {
 406         tty-&gt;print_cr(&quot;&gt;&gt; Interpreting pre-OSR block %d:&quot;, non_osr_start);
 407       }
 408       Block* block = block_at(non_osr_start, jsrs);
 409       assert(block-&gt;limit() == start_bci(), &quot;must flow forward to start&quot;);
 410       flow_block(block, state, jsrs);
 411     }
 412     return state;
 413     // Note:  The code below would be an incorrect for an OSR flow,
 414     // even if it were possible for an OSR entry point to be at bci zero.
 415   }
 416   // &quot;Push&quot; the method signature into the first few locals.
 417   state-&gt;set_stack_size(-max_locals());
 418   if (!method()-&gt;is_static()) {
<span class="line-modified"> 419     ciType* holder = method()-&gt;holder();</span>
<span class="line-added"> 420     if (holder-&gt;is_valuetype()) {</span>
<span class="line-added"> 421       // The receiver is never null</span>
<span class="line-added"> 422       holder = mark_as_never_null(holder);</span>
<span class="line-added"> 423     }</span>
<span class="line-added"> 424     state-&gt;push(holder);</span>
 425     assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
 426   }
 427   for (ciSignatureStream str(method()-&gt;signature());
 428        !str.at_return_type();
 429        str.next()) {
<span class="line-modified"> 430     ciType* arg = str.type();</span>
<span class="line-added"> 431     if (str.is_never_null()) {</span>
<span class="line-added"> 432       arg = mark_as_never_null(arg);</span>
<span class="line-added"> 433     }</span>
<span class="line-added"> 434     state-&gt;push_translate(arg);</span>
 435   }
 436   // Set the rest of the locals to bottom.
 437   Cell cell = state-&gt;next_cell(state-&gt;tos());
 438   state-&gt;set_stack_size(0);
 439   int limit = state-&gt;limit_cell();
 440   for (; cell &lt; limit; cell = state-&gt;next_cell(cell)) {
 441     state-&gt;set_type_at(cell, state-&gt;bottom_type());
 442   }
 443   // Lock an object, if necessary.
 444   state-&gt;set_monitor_count(method()-&gt;is_synchronized() ? 1 : 0);
 445   return state;
 446 }
 447 
 448 // ------------------------------------------------------------------
 449 // ciTypeFlow::StateVector::copy_into
 450 //
 451 // Copy our value into some other StateVector
 452 void ciTypeFlow::StateVector::copy_into(ciTypeFlow::StateVector* copy)
 453 const {
 454   copy-&gt;set_stack_size(stack_size());
</pre>
<hr />
<pre>
 560 
 561   return different;
 562 }
 563 
 564 // ------------------------------------------------------------------
 565 // ciTypeFlow::StateVector::push_translate
 566 void ciTypeFlow::StateVector::push_translate(ciType* type) {
 567   BasicType basic_type = type-&gt;basic_type();
 568   if (basic_type == T_BOOLEAN || basic_type == T_CHAR ||
 569       basic_type == T_BYTE    || basic_type == T_SHORT) {
 570     push_int();
 571   } else {
 572     push(type);
 573     if (type-&gt;is_two_word()) {
 574       push(half_type(type));
 575     }
 576   }
 577 }
 578 
 579 // ------------------------------------------------------------------
<span class="line-modified"> 580 // ciTypeFlow::StateVector::do_aload</span>
<span class="line-modified"> 581 void ciTypeFlow::StateVector::do_aload(ciBytecodeStream* str) {</span>
 582   pop_int();
<span class="line-modified"> 583   ciArrayKlass* array_klass = pop_objOrValueArray();</span>
 584   if (array_klass == NULL) {
<span class="line-modified"> 585     // Did aload on a null reference; push a null and ignore the exception.</span>
 586     // This instruction will never continue normally.  All we have to do
 587     // is report a value that will meet correctly with any downstream
 588     // reference types on paths that will truly be executed.  This null type
 589     // meets with any reference type to yield that same reference type.
 590     // (The compiler will generate an unconditional exception here.)
 591     push(null_type());
 592     return;
 593   }
 594   if (!array_klass-&gt;is_loaded()) {
 595     // Only fails for some -Xcomp runs
 596     trap(str, array_klass,
 597          Deoptimization::make_trap_request
 598          (Deoptimization::Reason_unloaded,
 599           Deoptimization::Action_reinterpret));
 600     return;
 601   }
 602   ciKlass* element_klass = array_klass-&gt;element_klass();
 603   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 604     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 605     trap(str, element_klass,
 606          Deoptimization::make_trap_request
 607          (Deoptimization::Reason_unloaded,
 608           Deoptimization::Action_reinterpret));
 609   } else {
<span class="line-modified"> 610     if (element_klass-&gt;is_valuetype()) {</span>
<span class="line-added"> 611       // Value type array elements are never null</span>
<span class="line-added"> 612       push(outer()-&gt;mark_as_never_null(element_klass));</span>
<span class="line-added"> 613     } else {</span>
<span class="line-added"> 614       push_object(element_klass);</span>
<span class="line-added"> 615     }</span>
 616   }
 617 }
 618 
 619 
 620 // ------------------------------------------------------------------
 621 // ciTypeFlow::StateVector::do_checkcast
 622 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 623   bool will_link;
 624   ciKlass* klass = str-&gt;get_klass(will_link);
<span class="line-added"> 625   bool never_null = str-&gt;is_klass_never_null();</span>
 626   if (!will_link) {
<span class="line-modified"> 627     if (never_null) {</span>
<span class="line-modified"> 628       trap(str, klass,</span>
<span class="line-modified"> 629            Deoptimization::make_trap_request</span>
<span class="line-modified"> 630            (Deoptimization::Reason_unloaded,</span>
<span class="line-modified"> 631             Deoptimization::Action_reinterpret));</span>
<span class="line-modified"> 632     } else {</span>
<span class="line-added"> 633       // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.</span>
<span class="line-added"> 634       // Type flow after this block may still be needed in two situations:</span>
<span class="line-added"> 635       // 1) C2 uses do_null_assert() and continues compilation for later blocks</span>
<span class="line-added"> 636       // 2) C2 does an OSR compile in a later block (see bug 4778368).</span>
<span class="line-added"> 637       pop_object();</span>
<span class="line-added"> 638       do_null_assert(klass);</span>
<span class="line-added"> 639     }</span>
 640   } else {
<span class="line-modified"> 641     ciType* type = pop_value();</span>
<span class="line-modified"> 642     if (klass-&gt;is_valuetype() &amp;&amp; (never_null || type-&gt;is_never_null())) {</span>
<span class="line-added"> 643       // Casting to a Q-Type contains a NULL check</span>
<span class="line-added"> 644       push(outer()-&gt;mark_as_never_null(klass));</span>
<span class="line-added"> 645     } else {</span>
<span class="line-added"> 646       push_object(klass);</span>
<span class="line-added"> 647     }</span>
 648   }
 649 }
 650 
 651 // ------------------------------------------------------------------
 652 // ciTypeFlow::StateVector::do_getfield
 653 void ciTypeFlow::StateVector::do_getfield(ciBytecodeStream* str) {
 654   // could add assert here for type of object.
 655   pop_object();
 656   do_getstatic(str);
 657 }
 658 
 659 // ------------------------------------------------------------------
 660 // ciTypeFlow::StateVector::do_getstatic
 661 void ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream* str) {
 662   bool will_link;
 663   ciField* field = str-&gt;get_field(will_link);
 664   if (!will_link) {
 665     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 666   } else {
 667     ciType* field_type = field-&gt;type();
</pre>
<hr />
<pre>
 669       // Normally, we need the field&#39;s type to be loaded if we are to
 670       // do anything interesting with its value.
 671       // We used to do this:  trap(str, str-&gt;get_field_signature_index());
 672       //
 673       // There is one good reason not to trap here.  Execution can
 674       // get past this &quot;getfield&quot; or &quot;getstatic&quot; if the value of
 675       // the field is null.  As long as the value is null, the class
 676       // does not need to be loaded!  The compiler must assume that
 677       // the value of the unloaded class reference is null; if the code
 678       // ever sees a non-null value, loading has occurred.
 679       //
 680       // This actually happens often enough to be annoying.  If the
 681       // compiler throws an uncommon trap at this bytecode, you can
 682       // get an endless loop of recompilations, when all the code
 683       // needs to do is load a series of null values.  Also, a trap
 684       // here can make an OSR entry point unreachable, triggering the
 685       // assert on non_osr_block in ciTypeFlow::get_start_state.
 686       // (See bug 4379915.)
 687       do_null_assert(field_type-&gt;as_klass());
 688     } else {
<span class="line-added"> 689       if (field-&gt;is_flattenable()) {</span>
<span class="line-added"> 690         // A flattenable field is never null</span>
<span class="line-added"> 691         field_type = outer()-&gt;mark_as_never_null(field_type);</span>
<span class="line-added"> 692       }</span>
 693       push_translate(field_type);
 694     }
 695   }
 696 }
 697 
 698 // ------------------------------------------------------------------
 699 // ciTypeFlow::StateVector::do_invoke
 700 void ciTypeFlow::StateVector::do_invoke(ciBytecodeStream* str,
 701                                         bool has_receiver) {
 702   bool will_link;
 703   ciSignature* declared_signature = NULL;
 704   ciMethod* callee = str-&gt;get_method(will_link, &amp;declared_signature);
 705   assert(declared_signature != NULL, &quot;cannot be null&quot;);
 706   if (!will_link) {
 707     // We weren&#39;t able to find the method.
 708     if (str-&gt;cur_bc() == Bytecodes::_invokedynamic) {
 709       trap(str, NULL,
 710            Deoptimization::make_trap_request
 711            (Deoptimization::Reason_uninitialized,
 712             Deoptimization::Action_reinterpret));
</pre>
<hr />
<pre>
 740       // Check this?
 741       pop_object();
 742     }
 743     assert(!sigstr.is_done(), &quot;must have return type&quot;);
 744     ciType* return_type = sigstr.type();
 745     if (!return_type-&gt;is_void()) {
 746       if (!return_type-&gt;is_loaded()) {
 747         // As in do_getstatic(), generally speaking, we need the return type to
 748         // be loaded if we are to do anything interesting with its value.
 749         // We used to do this:  trap(str, str-&gt;get_method_signature_index());
 750         //
 751         // We do not trap here since execution can get past this invoke if
 752         // the return value is null.  As long as the value is null, the class
 753         // does not need to be loaded!  The compiler must assume that
 754         // the value of the unloaded class reference is null; if the code
 755         // ever sees a non-null value, loading has occurred.
 756         //
 757         // See do_getstatic() for similar explanation, as well as bug 4684993.
 758         do_null_assert(return_type-&gt;as_klass());
 759       } else {
<span class="line-added"> 760         if (sigstr.is_never_null()) {</span>
<span class="line-added"> 761           return_type = outer()-&gt;mark_as_never_null(return_type);</span>
<span class="line-added"> 762         }</span>
 763         push_translate(return_type);
 764       }
 765     }
 766   }
 767 }
 768 
 769 // ------------------------------------------------------------------
 770 // ciTypeFlow::StateVector::do_jsr
 771 void ciTypeFlow::StateVector::do_jsr(ciBytecodeStream* str) {
 772   push(ciReturnAddress::make(str-&gt;next_bci()));
 773 }
 774 
 775 // ------------------------------------------------------------------
 776 // ciTypeFlow::StateVector::do_ldc
 777 void ciTypeFlow::StateVector::do_ldc(ciBytecodeStream* str) {
 778   ciConstant con = str-&gt;get_constant();
 779   BasicType basic_type = con.basic_type();
 780   if (basic_type == T_ILLEGAL) {
 781     // OutOfMemoryError in the CI while loading constant
 782     push_null();
 783     outer()-&gt;record_failure(&quot;ldc did not link&quot;);
 784     return;
 785   }
 786   if (is_reference_type(basic_type)) {
 787     ciObject* obj = con.as_object();
 788     if (obj-&gt;is_null_object()) {
 789       push_null();
 790     } else {
 791       assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
<span class="line-modified"> 792       ciType* type = obj-&gt;klass();</span>
<span class="line-added"> 793       if (type-&gt;is_valuetype()) {</span>
<span class="line-added"> 794         type = outer()-&gt;mark_as_never_null(type);</span>
<span class="line-added"> 795       }</span>
<span class="line-added"> 796       push(type);</span>
 797     }
 798   } else {
 799     push_translate(ciType::make(basic_type));
 800   }
 801 }
 802 
 803 // ------------------------------------------------------------------
 804 // ciTypeFlow::StateVector::do_multianewarray
 805 void ciTypeFlow::StateVector::do_multianewarray(ciBytecodeStream* str) {
 806   int dimensions = str-&gt;get_dimensions();
 807   bool will_link;
 808   ciArrayKlass* array_klass = str-&gt;get_klass(will_link)-&gt;as_array_klass();
 809   if (!will_link) {
 810     trap(str, array_klass, str-&gt;get_klass_index());
 811   } else {
 812     for (int i = 0; i &lt; dimensions; i++) {
 813       pop_int();
 814     }
 815     push_object(array_klass);
 816   }
 817 }
 818 
 819 // ------------------------------------------------------------------
 820 // ciTypeFlow::StateVector::do_new
 821 void ciTypeFlow::StateVector::do_new(ciBytecodeStream* str) {
 822   bool will_link;
 823   ciKlass* klass = str-&gt;get_klass(will_link);
 824   if (!will_link || str-&gt;is_unresolved_klass()) {
 825     trap(str, klass, str-&gt;get_klass_index());
 826   } else {
 827     push_object(klass);
 828   }
 829 }
 830 
<span class="line-added"> 831 // ------------------------------------------------------------------</span>
<span class="line-added"> 832 // ciTypeFlow::StateVector::do_defaultvalue</span>
<span class="line-added"> 833 void ciTypeFlow::StateVector::do_defaultvalue(ciBytecodeStream* str) {</span>
<span class="line-added"> 834   bool will_link;</span>
<span class="line-added"> 835   ciKlass* klass = str-&gt;get_klass(will_link);</span>
<span class="line-added"> 836   if (!will_link) {</span>
<span class="line-added"> 837     trap(str, klass, str-&gt;get_klass_index());</span>
<span class="line-added"> 838   } else {</span>
<span class="line-added"> 839     // The default value type is never null</span>
<span class="line-added"> 840     push(outer()-&gt;mark_as_never_null(klass));</span>
<span class="line-added"> 841   }</span>
<span class="line-added"> 842 }</span>
<span class="line-added"> 843 </span>
<span class="line-added"> 844 // ------------------------------------------------------------------</span>
<span class="line-added"> 845 // ciTypeFlow::StateVector::do_withfield</span>
<span class="line-added"> 846 void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {</span>
<span class="line-added"> 847   bool will_link;</span>
<span class="line-added"> 848   ciField* field = str-&gt;get_field(will_link);</span>
<span class="line-added"> 849   ciKlass* klass = field-&gt;holder();</span>
<span class="line-added"> 850   if (!will_link) {</span>
<span class="line-added"> 851     trap(str, klass, str-&gt;get_field_holder_index());</span>
<span class="line-added"> 852   } else {</span>
<span class="line-added"> 853     ciType* type = pop_value();</span>
<span class="line-added"> 854     ciType* field_type = field-&gt;type();</span>
<span class="line-added"> 855     assert(field_type-&gt;is_loaded(), &quot;field type must be loaded&quot;);</span>
<span class="line-added"> 856     if (field_type-&gt;is_two_word()) {</span>
<span class="line-added"> 857       ciType* type2 = pop_value();</span>
<span class="line-added"> 858       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);</span>
<span class="line-added"> 859       assert(type == half_type(type2), &quot;must be 2nd half&quot;);</span>
<span class="line-added"> 860     }</span>
<span class="line-added"> 861     pop_object();</span>
<span class="line-added"> 862     // The newly created value type can never be null</span>
<span class="line-added"> 863     push(outer()-&gt;mark_as_never_null(klass));</span>
<span class="line-added"> 864   }</span>
<span class="line-added"> 865 }</span>
<span class="line-added"> 866 </span>
 867 // ------------------------------------------------------------------
 868 // ciTypeFlow::StateVector::do_newarray
 869 void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
 870   pop_int();
 871   ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
 872   push_object(klass);
 873 }
 874 
 875 // ------------------------------------------------------------------
 876 // ciTypeFlow::StateVector::do_putfield
 877 void ciTypeFlow::StateVector::do_putfield(ciBytecodeStream* str) {
 878   do_putstatic(str);
 879   if (_trap_bci != -1)  return;  // unloaded field holder, etc.
 880   // could add assert here for type of object.
 881   pop_object();
 882 }
 883 
 884 // ------------------------------------------------------------------
 885 // ciTypeFlow::StateVector::do_putstatic
 886 void ciTypeFlow::StateVector::do_putstatic(ciBytecodeStream* str) {
</pre>
<hr />
<pre>
 952     // class later.
 953     push_null();
 954   }
 955 }
 956 
 957 
 958 // ------------------------------------------------------------------
 959 // ciTypeFlow::StateVector::apply_one_bytecode
 960 //
 961 // Apply the effect of one bytecode to this StateVector
 962 bool ciTypeFlow::StateVector::apply_one_bytecode(ciBytecodeStream* str) {
 963   _trap_bci = -1;
 964   _trap_index = 0;
 965 
 966   if (CITraceTypeFlow) {
 967     tty-&gt;print_cr(&quot;&gt;&gt; Interpreting bytecode %d:%s&quot;, str-&gt;cur_bci(),
 968                   Bytecodes::name(str-&gt;cur_bc()));
 969   }
 970 
 971   switch(str-&gt;cur_bc()) {
<span class="line-modified"> 972   case Bytecodes::_aaload: do_aload(str);                           break;</span>
 973 
 974   case Bytecodes::_aastore:
 975     {
 976       pop_object();
 977       pop_int();
<span class="line-modified"> 978       pop_objOrValueArray();</span>
 979       break;
 980     }
 981   case Bytecodes::_aconst_null:
 982     {
 983       push_null();
 984       break;
 985     }
 986   case Bytecodes::_aload:   load_local_object(str-&gt;get_index());    break;
 987   case Bytecodes::_aload_0: load_local_object(0);                   break;
 988   case Bytecodes::_aload_1: load_local_object(1);                   break;
 989   case Bytecodes::_aload_2: load_local_object(2);                   break;
 990   case Bytecodes::_aload_3: load_local_object(3);                   break;
 991 
 992   case Bytecodes::_anewarray:
 993     {
 994       pop_int();
 995       bool will_link;
 996       ciKlass* element_klass = str-&gt;get_klass(will_link);
 997       if (!will_link) {
 998         trap(str, element_klass, str-&gt;get_klass_index());
 999       } else {
<span class="line-modified">1000         push_object(ciArrayKlass::make(element_klass));</span>
1001       }
1002       break;
1003     }
1004   case Bytecodes::_areturn:
1005   case Bytecodes::_ifnonnull:
1006   case Bytecodes::_ifnull:
1007     {
1008       pop_object();
1009       break;
1010     }
1011   case Bytecodes::_monitorenter:
1012     {
1013       pop_object();
1014       set_monitor_count(monitor_count() + 1);
1015       break;
1016     }
1017   case Bytecodes::_monitorexit:
1018     {
1019       pop_object();
1020       assert(monitor_count() &gt; 0, &quot;must be a monitor to exit from&quot;);
</pre>
<hr />
<pre>
1512     }
1513   case Bytecodes::_lshl:
1514   case Bytecodes::_lshr:
1515   case Bytecodes::_lushr:
1516     {
1517       pop_int();
1518       pop_long();
1519       push_long();
1520       break;
1521     }
1522   case Bytecodes::_lstore:   store_local_long(str-&gt;get_index());    break;
1523   case Bytecodes::_lstore_0: store_local_long(0);                   break;
1524   case Bytecodes::_lstore_1: store_local_long(1);                   break;
1525   case Bytecodes::_lstore_2: store_local_long(2);                   break;
1526   case Bytecodes::_lstore_3: store_local_long(3);                   break;
1527 
1528   case Bytecodes::_multianewarray: do_multianewarray(str);          break;
1529 
1530   case Bytecodes::_new:      do_new(str);                           break;
1531 
<span class="line-added">1532   case Bytecodes::_defaultvalue: do_defaultvalue(str);              break;</span>
<span class="line-added">1533   case Bytecodes::_withfield: do_withfield(str);                    break;</span>
<span class="line-added">1534 </span>
1535   case Bytecodes::_newarray: do_newarray(str);                      break;
1536 
1537   case Bytecodes::_pop:
1538     {
1539       pop();
1540       break;
1541     }
1542   case Bytecodes::_pop2:
1543     {
1544       pop();
1545       pop();
1546       break;
1547     }
1548 
1549   case Bytecodes::_putfield:       do_putfield(str);                 break;
1550   case Bytecodes::_putstatic:      do_putstatic(str);                break;
1551 
1552   case Bytecodes::_ret: do_ret(str);                                 break;
1553 
1554   case Bytecodes::_swap:
1555     {
1556       ciType* value1 = pop_value();
1557       ciType* value2 = pop_value();
1558       push(value1);
1559       push(value2);
1560       break;
1561     }
<span class="line-added">1562 </span>
1563   case Bytecodes::_wide:
1564   default:
1565     {
1566       // The iterator should skip this.
1567       ShouldNotReachHere();
1568       break;
1569     }
1570   }
1571 
1572   if (CITraceTypeFlow) {
1573     print_on(tty);
1574   }
1575 
1576   return (_trap_bci != -1);
1577 }
1578 
1579 #ifndef PRODUCT
1580 // ------------------------------------------------------------------
1581 // ciTypeFlow::StateVector::print_cell_on
1582 void ciTypeFlow::StateVector::print_cell_on(outputStream* st, Cell c) const {
</pre>
<hr />
<pre>
1826       case Bytecodes::_lookupswitch: {
1827         Bytecode_lookupswitch lookupswitch(str);
1828 
1829         int npairs = lookupswitch.number_of_pairs();
1830         _successors =
1831           new (arena) GrowableArray&lt;Block*&gt;(arena, npairs+1, 0, NULL);
1832         int bci = current_bci + lookupswitch.default_offset();
1833         Block* block = analyzer-&gt;block_at(bci, jsrs);
1834         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1835         _successors-&gt;append(block);
1836         while(--npairs &gt;= 0) {
1837           LookupswitchPair pair = lookupswitch.pair_at(npairs);
1838           int bci = current_bci + pair.offset();
1839           Block* block = analyzer-&gt;block_at(bci, jsrs);
1840           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1841           _successors-&gt;append_if_missing(block);
1842         }
1843         break;
1844       }
1845 
<span class="line-modified">1846       case Bytecodes::_athrow:</span>
<span class="line-modified">1847       case Bytecodes::_ireturn:</span>
<span class="line-modified">1848       case Bytecodes::_lreturn:</span>
<span class="line-added">1849       case Bytecodes::_freturn:</span>
<span class="line-added">1850       case Bytecodes::_dreturn:</span>
<span class="line-added">1851       case Bytecodes::_areturn:</span>
1852       case Bytecodes::_return:
1853         _successors =
1854           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1855         // No successors
1856         break;
1857 
1858       case Bytecodes::_ret: {
1859         _successors =
1860           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1861 
1862         Cell local = state-&gt;local(str-&gt;get_index());
1863         ciType* return_address = state-&gt;type_at(local);
1864         assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
1865         int bci = return_address-&gt;as_return_address()-&gt;bci();
1866         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1867         _successors-&gt;append(analyzer-&gt;block_at(bci, jsrs));
1868         break;
1869       }
1870 
1871       case Bytecodes::_wide:
</pre>
<hr />
<pre>
3062 
3063 // ------------------------------------------------------------------
3064 // ciTypeFlow::record_failure()
3065 // The ciTypeFlow object keeps track of failure reasons separately from the ciEnv.
3066 // This is required because there is not a 1-1 relation between the ciEnv and
3067 // the TypeFlow passes within a compilation task.  For example, if the compiler
3068 // is considering inlining a method, it will request a TypeFlow.  If that fails,
3069 // the compilation as a whole may continue without the inlining.  Some TypeFlow
3070 // requests are not optional; if they fail the requestor is responsible for
3071 // copying the failure reason up to the ciEnv.  (See Parse::Parse.)
3072 void ciTypeFlow::record_failure(const char* reason) {
3073   if (env()-&gt;log() != NULL) {
3074     env()-&gt;log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;typeflow&#39;&quot;, reason);
3075   }
3076   if (_failure_reason == NULL) {
3077     // Record the first failure reason.
3078     _failure_reason = reason;
3079   }
3080 }
3081 
<span class="line-added">3082 ciType* ciTypeFlow::mark_as_never_null(ciType* type) {</span>
<span class="line-added">3083   // Wrap the type to carry the information that it is never null</span>
<span class="line-added">3084   return env()-&gt;make_never_null_wrapper(type);</span>
<span class="line-added">3085 }</span>
<span class="line-added">3086 </span>
3087 #ifndef PRODUCT
3088 // ------------------------------------------------------------------
3089 // ciTypeFlow::print_on
3090 void ciTypeFlow::print_on(outputStream* st) const {
3091   // Walk through CI blocks
3092   st-&gt;print_cr(&quot;********************************************************&quot;);
3093   st-&gt;print   (&quot;TypeFlow for &quot;);
3094   method()-&gt;name()-&gt;print_symbol_on(st);
3095   int limit_bci = code_size();
3096   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3097   ciMethodBlocks  *mblks = _methodBlocks;
3098   ciBlock* current = NULL;
3099   for (int bci = 0; bci &lt; limit_bci; bci++) {
3100     ciBlock* blk = mblks-&gt;block_containing(bci);
3101     if (blk != NULL &amp;&amp; blk != current) {
3102       current = blk;
3103       current-&gt;print_on(st);
3104 
3105       GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[blk-&gt;index()];
3106       int num_blocks = (blocks == NULL) ? 0 : blocks-&gt;length();
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/aarch64/sharedRuntime_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classListParser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
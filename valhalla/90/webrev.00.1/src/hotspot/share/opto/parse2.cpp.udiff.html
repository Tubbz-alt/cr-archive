<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/parse2.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="output.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phaseX.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -34,73 +34,364 @@</span>
  #include &quot;opto/addnode.hpp&quot;
  #include &quot;opto/castnode.hpp&quot;
  #include &quot;opto/convertnode.hpp&quot;
  #include &quot;opto/divnode.hpp&quot;
  #include &quot;opto/idealGraphPrinter.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/idealKit.hpp&quot;</span>
  #include &quot;opto/matcher.hpp&quot;
  #include &quot;opto/memnode.hpp&quot;
  #include &quot;opto/mulnode.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/valuetypenode.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  
  #ifndef PRODUCT
  extern int explicit_null_checks_inserted,
             explicit_null_checks_elided;
  #endif
  
<span class="udiff-line-added">+ Node* Parse::record_profile_for_speculation_at_array_load(Node* ld) {</span>
<span class="udiff-line-added">+   // Feed unused profile data to type speculation</span>
<span class="udiff-line-added">+   if (UseTypeSpeculation &amp;&amp; UseArrayLoadStoreProfile) {</span>
<span class="udiff-line-added">+     ciKlass* array_type = NULL;</span>
<span class="udiff-line-added">+     ciKlass* element_type = NULL;</span>
<span class="udiff-line-added">+     ProfilePtrKind element_ptr = ProfileMaybeNull;</span>
<span class="udiff-line-added">+     bool flat_array = true;</span>
<span class="udiff-line-added">+     bool null_free_array = true;</span>
<span class="udiff-line-added">+     method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);</span>
<span class="udiff-line-added">+     if (element_type != NULL || element_ptr != ProfileMaybeNull) {</span>
<span class="udiff-line-added">+       ld = record_profile_for_speculation(ld, element_type, element_ptr);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return ld;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  //---------------------------------array_load----------------------------------
  void Parse::array_load(BasicType bt) {
    const Type* elemtype = Type::TOP;
<span class="udiff-line-removed">-   bool big_val = bt == T_DOUBLE || bt == T_LONG;</span>
    Node* adr = array_addressing(bt, 0, elemtype);
    if (stopped())  return;     // guaranteed null or range check
  
<span class="udiff-line-modified-removed">-   pop();                      // index (already used)</span>
<span class="udiff-line-modified-removed">-   Node* array = pop();        // the array itself</span>
<span class="udiff-line-modified-added">+   Node* idx = pop();</span>
<span class="udiff-line-modified-added">+   Node* ary = pop();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Handle value type arrays</span>
<span class="udiff-line-added">+   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();</span>
<span class="udiff-line-added">+   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();</span>
<span class="udiff-line-added">+   if (elemtype-&gt;isa_valuetype() != NULL) {</span>
<span class="udiff-line-added">+     C-&gt;set_flattened_accesses();</span>
<span class="udiff-line-added">+     // Load from flattened value type array</span>
<span class="udiff-line-added">+     Node* vt = ValueTypeNode::make_from_flattened(this, elemtype-&gt;value_klass(), ary, adr);</span>
<span class="udiff-line-added">+     push(vt);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   } else if (elemptr != NULL &amp;&amp; elemptr-&gt;is_valuetypeptr() &amp;&amp; !elemptr-&gt;maybe_null()) {</span>
<span class="udiff-line-added">+     // Load from non-flattened but flattenable value type array (elements can never be null)</span>
<span class="udiff-line-added">+     bt = T_VALUETYPE;</span>
<span class="udiff-line-added">+   } else if (!ary_t-&gt;is_not_flat()) {</span>
<span class="udiff-line-added">+     // Cannot statically determine if array is flattened, emit runtime check</span>
<span class="udiff-line-added">+     assert(ValueArrayFlatten &amp;&amp; is_reference_type(bt) &amp;&amp; elemptr-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free() &amp;&amp;</span>
<span class="udiff-line-added">+            (!elemptr-&gt;is_valuetypeptr() || elemptr-&gt;value_klass()-&gt;flatten_array()), &quot;array can&#39;t be flattened&quot;);</span>
<span class="udiff-line-added">+     IdealKit ideal(this);</span>
<span class="udiff-line-added">+     IdealVariable res(ideal);</span>
<span class="udiff-line-added">+     ideal.declarations_done();</span>
<span class="udiff-line-added">+     ideal.if_then(is_non_flattened_array(ary)); {</span>
<span class="udiff-line-added">+       // non-flattened</span>
<span class="udiff-line-added">+       assert(ideal.ctrl()-&gt;in(0)-&gt;as_If()-&gt;is_non_flattened_array_check(&amp;_gvn), &quot;Should be found&quot;);</span>
<span class="udiff-line-added">+       sync_kit(ideal);</span>
<span class="udiff-line-added">+       const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);</span>
<span class="udiff-line-added">+       Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,</span>
<span class="udiff-line-added">+                                 IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);</span>
<span class="udiff-line-added">+       ideal.sync_kit(this);</span>
<span class="udiff-line-added">+       ideal.set(res, ld);</span>
<span class="udiff-line-added">+     } ideal.else_(); {</span>
<span class="udiff-line-added">+       // flattened</span>
<span class="udiff-line-added">+       sync_kit(ideal);</span>
<span class="udiff-line-added">+       if (elemptr-&gt;is_valuetypeptr()) {</span>
<span class="udiff-line-added">+         // Element type is known, cast and load from flattened representation</span>
<span class="udiff-line-added">+         ciValueKlass* vk = elemptr-&gt;value_klass();</span>
<span class="udiff-line-added">+         assert(vk-&gt;flatten_array() &amp;&amp; elemptr-&gt;maybe_null(), &quot;must be a flattenable and nullable array&quot;);</span>
<span class="udiff-line-added">+         ciArrayKlass* array_klass = ciArrayKlass::make(vk);</span>
<span class="udiff-line-added">+         const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));</span>
<span class="udiff-line-added">+         Node* casted_adr = array_element_address(cast, idx, T_VALUETYPE, ary_t-&gt;size(), control());</span>
<span class="udiff-line-added">+         // Re-execute flattened array load if buffering triggers deoptimization</span>
<span class="udiff-line-added">+         PreserveReexecuteState preexecs(this);</span>
<span class="udiff-line-added">+         jvms()-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+         inc_sp(2);</span>
<span class="udiff-line-added">+         Node* vt = ValueTypeNode::make_from_flattened(this, vk, cast, casted_adr)-&gt;buffer(this, false);</span>
<span class="udiff-line-added">+         ideal.set(res, vt);</span>
<span class="udiff-line-added">+         ideal.sync_kit(this);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         // Element type is unknown, emit runtime call</span>
<span class="udiff-line-added">+         Node* kls = load_object_klass(ary);</span>
<span class="udiff-line-added">+         Node* k_adr = basic_plus_adr(kls, in_bytes(ArrayKlass::element_klass_offset()));</span>
<span class="udiff-line-added">+         Node* elem_klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS));</span>
<span class="udiff-line-added">+         Node* obj_size  = NULL;</span>
<span class="udiff-line-added">+         kill_dead_locals();</span>
<span class="udiff-line-added">+         // Re-execute flattened array load if buffering triggers deoptimization</span>
<span class="udiff-line-added">+         PreserveReexecuteState preexecs(this);</span>
<span class="udiff-line-added">+         jvms()-&gt;set_bci(_bci);</span>
<span class="udiff-line-added">+         jvms()-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+         inc_sp(2);</span>
<span class="udiff-line-added">+         Node* alloc_obj = new_instance(elem_klass, NULL, &amp;obj_size, /*deoptimize_on_exception=*/true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);</span>
<span class="udiff-line-added">+         assert(alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);</span>
<span class="udiff-line-added">+         alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // This membar keeps this access to an unknown flattened array</span>
<span class="udiff-line-added">+         // correctly ordered with other unknown and known flattened</span>
<span class="udiff-line-added">+         // array accesses.</span>
<span class="udiff-line-added">+         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-added">+         // Unknown value type might contain reference fields</span>
<span class="udiff-line-added">+         if (false &amp;&amp; !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing)) {</span>
<span class="udiff-line-added">+           // FIXME 8230656 also merge changes from 8238759 in</span>
<span class="udiff-line-added">+           int base_off = sizeof(instanceOopDesc);</span>
<span class="udiff-line-added">+           Node* dst_base = basic_plus_adr(alloc_obj, base_off);</span>
<span class="udiff-line-added">+           Node* countx = obj_size;</span>
<span class="udiff-line-added">+           countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));</span>
<span class="udiff-line-added">+           countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           assert(Klass::_lh_log2_element_size_shift == 0, &quot;use shift in place&quot;);</span>
<span class="udiff-line-added">+           Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));</span>
<span class="udiff-line-added">+           Node* elem_shift = make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);</span>
<span class="udiff-line-added">+           uint header = arrayOopDesc::base_offset_in_bytes(T_VALUETYPE);</span>
<span class="udiff-line-added">+           Node* base  = basic_plus_adr(ary, header);</span>
<span class="udiff-line-added">+           idx = Compile::conv_I2X_index(&amp;_gvn, idx, TypeInt::POS, control());</span>
<span class="udiff-line-added">+           Node* scale = _gvn.transform(new LShiftXNode(idx, elem_shift));</span>
<span class="udiff-line-added">+           Node* adr = basic_plus_adr(ary, base, scale);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           access_clone(adr, dst_base, countx, false);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           ideal.sync_kit(this);</span>
<span class="udiff-line-added">+           ideal.make_leaf_call(OptoRuntime::load_unknown_value_Type(),</span>
<span class="udiff-line-added">+                                CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_value),</span>
<span class="udiff-line-added">+                                &quot;load_unknown_value&quot;,</span>
<span class="udiff-line-added">+                                ary, idx, alloc_obj);</span>
<span class="udiff-line-added">+           sync_kit(ideal);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // This makes sure no other thread sees a partially initialized buffered value</span>
<span class="udiff-line-added">+         insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Same as MemBarCPUOrder above: keep this unknown flattened</span>
<span class="udiff-line-added">+         // array access correctly ordered with other flattened array</span>
<span class="udiff-line-added">+         // access</span>
<span class="udiff-line-added">+         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Prevent any use of the newly allocated value before it is</span>
<span class="udiff-line-added">+         // fully initialized</span>
<span class="udiff-line-added">+         alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);</span>
<span class="udiff-line-added">+         alloc_obj-&gt;set_req(0, control());</span>
<span class="udiff-line-added">+         alloc_obj = _gvn.transform(alloc_obj);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         const Type* unknown_value = elemptr-&gt;is_instptr()-&gt;cast_to_flat_array();</span>
<span class="udiff-line-added">+         alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ideal.sync_kit(this);</span>
<span class="udiff-line-added">+         ideal.set(res, alloc_obj);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } ideal.end_if();</span>
<span class="udiff-line-added">+     sync_kit(ideal);</span>
<span class="udiff-line-added">+     Node* ld = _gvn.transform(ideal.value(res));</span>
<span class="udiff-line-added">+     ld = record_profile_for_speculation_at_array_load(ld);</span>
<span class="udiff-line-added">+     push_node(bt, ld);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
  
    if (elemtype == TypeInt::BOOL) {
      bt = T_BOOLEAN;
    }
    const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   Node* ld = access_load_at(array, adr, adr_type, elemtype, bt,</span>
<span class="udiff-line-modified-added">+   Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,</span>
                              IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
<span class="udiff-line-modified-removed">-   if (big_val) {</span>
<span class="udiff-line-modified-removed">-     push_pair(ld);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     push(ld);</span>
<span class="udiff-line-modified-added">+   if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-modified-added">+     // Loading a non-flattened (but flattenable) value type from an array</span>
<span class="udiff-line-modified-added">+     assert(!gvn().type(ld)-&gt;maybe_null(), &quot;value type array elements should never be null&quot;);</span>
<span class="udiff-line-modified-added">+     if (elemptr-&gt;value_klass()-&gt;is_scalarizable()) {</span>
<span class="udiff-line-added">+       ld = ValueTypeNode::make_from_oop(this, ld, elemptr-&gt;value_klass());</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-added">+   if (!ld-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+     ld = record_profile_for_speculation_at_array_load(ld);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   push_node(bt, ld);</span>
  }
  
  
  //--------------------------------array_store----------------------------------
  void Parse::array_store(BasicType bt) {
    const Type* elemtype = Type::TOP;
<span class="udiff-line-modified-removed">-   bool big_val = bt == T_DOUBLE || bt == T_LONG;</span>
<span class="udiff-line-removed">-   Node* adr = array_addressing(bt, big_val ? 2 : 1, elemtype);</span>
<span class="udiff-line-modified-added">+   Node* adr = array_addressing(bt, type2size[bt], elemtype);</span>
    if (stopped())  return;     // guaranteed null or range check
<span class="udiff-line-added">+   Node* cast_val = NULL;</span>
    if (bt == T_OBJECT) {
<span class="udiff-line-modified-removed">-     array_store_check();</span>
<span class="udiff-line-modified-added">+     cast_val = array_store_check();</span>
<span class="udiff-line-added">+     if (stopped()) return;</span>
    }
<span class="udiff-line-modified-removed">-   Node* val;                  // Oop to store</span>
<span class="udiff-line-modified-removed">-   if (big_val) {</span>
<span class="udiff-line-modified-removed">-     val = pop_pair();</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     val = pop();</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-removed">-   pop();                      // index (already used)</span>
<span class="udiff-line-removed">-   Node* array = pop();        // the array itself</span>
<span class="udiff-line-modified-added">+   Node* val = pop_node(bt); // Value to store</span>
<span class="udiff-line-modified-added">+   Node* idx = pop();        // Index in the array</span>
<span class="udiff-line-modified-added">+   Node* ary = pop();        // The array itself</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();</span>
<span class="udiff-line-modified-added">+   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);</span>
  
    if (elemtype == TypeInt::BOOL) {
      bt = T_BOOLEAN;
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);</span>
<span class="udiff-line-modified-added">+   } else if (bt == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+     elemtype = elemtype-&gt;make_oopptr();</span>
<span class="udiff-line-added">+     const Type* tval = _gvn.type(cast_val);</span>
<span class="udiff-line-added">+     // We may have lost type information for &#39;val&#39; here due to the casts</span>
<span class="udiff-line-added">+     // emitted by the array_store_check code (see JDK-6312651)</span>
<span class="udiff-line-added">+     // TODO Remove this code once JDK-6312651 is in.</span>
<span class="udiff-line-added">+     const Type* tval_init = _gvn.type(val);</span>
<span class="udiff-line-added">+     bool can_be_value_type = tval-&gt;isa_valuetype() || (tval != TypePtr::NULL_PTR &amp;&amp; tval_init-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp; tval-&gt;is_oopptr()-&gt;can_be_value_type());</span>
<span class="udiff-line-added">+     bool not_flattenable = !can_be_value_type || ((tval_init-&gt;is_valuetypeptr() || tval_init-&gt;isa_valuetype()) &amp;&amp; !tval_init-&gt;value_klass()-&gt;flatten_array());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!ary_t-&gt;is_not_null_free() &amp;&amp; !can_be_value_type &amp;&amp; (!tval-&gt;maybe_null() || !tval_init-&gt;maybe_null())) {</span>
<span class="udiff-line-added">+       // Storing a non-inline-type, mark array as not null-free.</span>
<span class="udiff-line-added">+       // This is only legal for non-null stores because the array_store_check passes for null.</span>
<span class="udiff-line-added">+       ary_t = ary_t-&gt;cast_to_not_null_free();</span>
<span class="udiff-line-added">+       Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));</span>
<span class="udiff-line-added">+       replace_in_map(ary, cast);</span>
<span class="udiff-line-added">+       ary = cast;</span>
<span class="udiff-line-added">+     } else if (!ary_t-&gt;is_not_flat() &amp;&amp; not_flattenable) {</span>
<span class="udiff-line-added">+       // Storing a non-flattenable value, mark array as not flat.</span>
<span class="udiff-line-added">+       ary_t = ary_t-&gt;cast_to_not_flat();</span>
<span class="udiff-line-added">+       if (tval != TypePtr::NULL_PTR) {</span>
<span class="udiff-line-added">+         // For NULL, this transformation is only valid after the null guard below</span>
<span class="udiff-line-added">+         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));</span>
<span class="udiff-line-added">+         replace_in_map(ary, cast);</span>
<span class="udiff-line-added">+         ary = cast;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-   access_store_at(array, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);</span>
<span class="udiff-line-modified-added">+     if (ary_t-&gt;elem()-&gt;isa_valuetype() != NULL) {</span>
<span class="udiff-line-added">+       // Store to flattened value type array</span>
<span class="udiff-line-added">+       C-&gt;set_flattened_accesses();</span>
<span class="udiff-line-added">+       if (!cast_val-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+         inc_sp(3);</span>
<span class="udiff-line-added">+         cast_val = null_check(cast_val);</span>
<span class="udiff-line-added">+         if (stopped()) return;</span>
<span class="udiff-line-added">+         dec_sp(3);</span>
<span class="udiff-line-added">+         cast_val = ValueTypeNode::make_from_oop(this, cast_val, ary_t-&gt;elem()-&gt;value_klass());</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       // Re-execute flattened array store if buffering triggers deoptimization</span>
<span class="udiff-line-added">+       PreserveReexecuteState preexecs(this);</span>
<span class="udiff-line-added">+       inc_sp(3);</span>
<span class="udiff-line-added">+       jvms()-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+       cast_val-&gt;as_ValueType()-&gt;store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     } else if (elemtype-&gt;is_valuetypeptr() &amp;&amp; !elemtype-&gt;maybe_null()) {</span>
<span class="udiff-line-added">+       // Store to non-flattened but flattenable value type array (elements can never be null)</span>
<span class="udiff-line-added">+       if (!cast_val-&gt;is_ValueType() &amp;&amp; tval-&gt;maybe_null()) {</span>
<span class="udiff-line-added">+         inc_sp(3);</span>
<span class="udiff-line-added">+         cast_val = null_check(cast_val);</span>
<span class="udiff-line-added">+         if (stopped()) return;</span>
<span class="udiff-line-added">+         dec_sp(3);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else if (!ary_t-&gt;is_not_flat()) {</span>
<span class="udiff-line-added">+       // Array might be flattened, emit runtime checks</span>
<span class="udiff-line-added">+       assert(ValueArrayFlatten &amp;&amp; !not_flattenable &amp;&amp; elemtype-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp;</span>
<span class="udiff-line-added">+              !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free(), &quot;array can&#39;t be flattened&quot;);</span>
<span class="udiff-line-added">+       IdealKit ideal(this);</span>
<span class="udiff-line-added">+       ideal.if_then(is_non_flattened_array(ary)); {</span>
<span class="udiff-line-added">+         // non-flattened</span>
<span class="udiff-line-added">+         assert(ideal.ctrl()-&gt;in(0)-&gt;as_If()-&gt;is_non_flattened_array_check(&amp;_gvn), &quot;Should be found&quot;);</span>
<span class="udiff-line-added">+         sync_kit(ideal);</span>
<span class="udiff-line-added">+         gen_value_array_null_guard(ary, cast_val, 3);</span>
<span class="udiff-line-added">+         inc_sp(3);</span>
<span class="udiff-line-added">+         access_store_at(ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);</span>
<span class="udiff-line-added">+         dec_sp(3);</span>
<span class="udiff-line-added">+         ideal.sync_kit(this);</span>
<span class="udiff-line-added">+       } ideal.else_(); {</span>
<span class="udiff-line-added">+         Node* val = cast_val;</span>
<span class="udiff-line-added">+         // flattened</span>
<span class="udiff-line-added">+         if (!val-&gt;is_ValueType() &amp;&amp; tval-&gt;maybe_null()) {</span>
<span class="udiff-line-added">+           // Add null check</span>
<span class="udiff-line-added">+           sync_kit(ideal);</span>
<span class="udiff-line-added">+           Node* null_ctl = top();</span>
<span class="udiff-line-added">+           val = null_check_oop(val, &amp;null_ctl);</span>
<span class="udiff-line-added">+           if (null_ctl != top()) {</span>
<span class="udiff-line-added">+             PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+             inc_sp(3);</span>
<span class="udiff-line-added">+             set_control(null_ctl);</span>
<span class="udiff-line-added">+             uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);</span>
<span class="udiff-line-added">+             dec_sp(3);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           ideal.sync_kit(this);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // Try to determine the value klass</span>
<span class="udiff-line-added">+         ciValueKlass* vk = NULL;</span>
<span class="udiff-line-added">+         if (tval-&gt;isa_valuetype() || tval-&gt;is_valuetypeptr()) {</span>
<span class="udiff-line-added">+           vk = tval-&gt;value_klass();</span>
<span class="udiff-line-added">+         } else if (tval_init-&gt;isa_valuetype() || tval_init-&gt;is_valuetypeptr()) {</span>
<span class="udiff-line-added">+           vk = tval_init-&gt;value_klass();</span>
<span class="udiff-line-added">+         } else if (elemtype-&gt;is_valuetypeptr()) {</span>
<span class="udiff-line-added">+           vk = elemtype-&gt;value_klass();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         Node* casted_ary = ary;</span>
<span class="udiff-line-added">+         if (vk != NULL &amp;&amp; !stopped()) {</span>
<span class="udiff-line-added">+           // Element type is known, cast and store to flattened representation</span>
<span class="udiff-line-added">+           sync_kit(ideal);</span>
<span class="udiff-line-added">+           assert(vk-&gt;flatten_array() &amp;&amp; elemtype-&gt;maybe_null(), &quot;must be a flattenable and nullable array&quot;);</span>
<span class="udiff-line-added">+           ciArrayKlass* array_klass = ciArrayKlass::make(vk);</span>
<span class="udiff-line-added">+           const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+           casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));</span>
<span class="udiff-line-added">+           Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype-&gt;size(), control());</span>
<span class="udiff-line-added">+           if (!val-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+             assert(!gvn().type(val)-&gt;maybe_null(), &quot;value type array elements should never be null&quot;);</span>
<span class="udiff-line-added">+             val = ValueTypeNode::make_from_oop(this, val, vk);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           // Re-execute flattened array store if buffering triggers deoptimization</span>
<span class="udiff-line-added">+           PreserveReexecuteState preexecs(this);</span>
<span class="udiff-line-added">+           inc_sp(3);</span>
<span class="udiff-line-added">+           jvms()-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+           val-&gt;as_ValueType()-&gt;store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);</span>
<span class="udiff-line-added">+           ideal.sync_kit(this);</span>
<span class="udiff-line-added">+         } else if (!ideal.ctrl()-&gt;is_top()) {</span>
<span class="udiff-line-added">+           // Element type is unknown, emit runtime call</span>
<span class="udiff-line-added">+           sync_kit(ideal);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           // This membar keeps this access to an unknown flattened</span>
<span class="udiff-line-added">+           // array correctly ordered with other unknown and known</span>
<span class="udiff-line-added">+           // flattened array accesses.</span>
<span class="udiff-line-added">+           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));</span>
<span class="udiff-line-added">+           ideal.sync_kit(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           ideal.make_leaf_call(OptoRuntime::store_unknown_value_Type(),</span>
<span class="udiff-line-added">+                                CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_value),</span>
<span class="udiff-line-added">+                                &quot;store_unknown_value&quot;,</span>
<span class="udiff-line-added">+                                val, casted_ary, idx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           sync_kit(ideal);</span>
<span class="udiff-line-added">+           // Same as MemBarCPUOrder above: keep this unknown</span>
<span class="udiff-line-added">+           // flattened array access correctly ordered with other</span>
<span class="udiff-line-added">+           // flattened array accesses.</span>
<span class="udiff-line-added">+           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));</span>
<span class="udiff-line-added">+           ideal.sync_kit(this);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       ideal.end_if();</span>
<span class="udiff-line-added">+       sync_kit(ideal);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     } else if (!ary_t-&gt;is_not_null_free()) {</span>
<span class="udiff-line-added">+       // Array is not flattened but may be null free</span>
<span class="udiff-line-added">+       assert(elemtype-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact(), &quot;array can&#39;t be null free&quot;);</span>
<span class="udiff-line-added">+       ary = gen_value_array_null_guard(ary, cast_val, 3, true);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   inc_sp(3);</span>
<span class="udiff-line-added">+   access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);</span>
<span class="udiff-line-added">+   dec_sp(3);</span>
  }
  
  
  //------------------------------array_addressing-------------------------------
  // Pull array and index from the stack.  Compute pointer-to-element.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -196,10 +487,130 @@</span>
      }
    }
    // Check for always knowing you are throwing a range-check exception
    if (stopped())  return top();
  
<span class="udiff-line-added">+   // This could be an access to a value array. We can&#39;t tell if it&#39;s</span>
<span class="udiff-line-added">+   // flat or not. Speculating it&#39;s not leads to a much simpler graph</span>
<span class="udiff-line-added">+   // shape. Check profiling.</span>
<span class="udiff-line-added">+   // For aastore, by the time we&#39;re here, the array store check should</span>
<span class="udiff-line-added">+   // have already taken advantage of profiling to cast the array to an</span>
<span class="udiff-line-added">+   // exact type reported by profiling</span>
<span class="udiff-line-added">+   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();</span>
<span class="udiff-line-added">+   if (elemtype-&gt;isa_valuetype() == NULL &amp;&amp;</span>
<span class="udiff-line-added">+       (elemptr == NULL || !elemptr-&gt;is_valuetypeptr() || elemptr-&gt;maybe_null()) &amp;&amp;</span>
<span class="udiff-line-added">+       !arytype-&gt;is_not_flat()) {</span>
<span class="udiff-line-added">+     assert(is_reference_type(type), &quot;Only references&quot;);</span>
<span class="udiff-line-added">+     // First check the speculative type</span>
<span class="udiff-line-added">+     Deoptimization::DeoptReason reason = Deoptimization::Reason_speculate_class_check;</span>
<span class="udiff-line-added">+     ciKlass* array_type = arytype-&gt;speculative_type();</span>
<span class="udiff-line-added">+     if (too_many_traps_or_recompiles(reason) || array_type == NULL) {</span>
<span class="udiff-line-added">+       // No speculative type, check profile data at this bci</span>
<span class="udiff-line-added">+       array_type = NULL;</span>
<span class="udiff-line-added">+       reason = Deoptimization::Reason_class_check;</span>
<span class="udiff-line-added">+       if (UseArrayLoadStoreProfile &amp;&amp; !too_many_traps_or_recompiles(reason)) {</span>
<span class="udiff-line-added">+         ciKlass* element_type = NULL;</span>
<span class="udiff-line-added">+         ProfilePtrKind element_ptr = ProfileMaybeNull;</span>
<span class="udiff-line-added">+         bool flat_array = true;</span>
<span class="udiff-line-added">+         bool null_free_array = true;</span>
<span class="udiff-line-added">+         method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (array_type != NULL) {</span>
<span class="udiff-line-added">+       // Speculate that this array has the exact type reported by profile data</span>
<span class="udiff-line-added">+       Node* better_ary = NULL;</span>
<span class="udiff-line-added">+       Node* slow_ctl = type_check_receiver(ary, array_type, 1.0, &amp;better_ary);</span>
<span class="udiff-line-added">+       { PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+         set_control(slow_ctl);</span>
<span class="udiff-line-added">+         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       replace_in_map(ary, better_ary);</span>
<span class="udiff-line-added">+       ary = better_ary;</span>
<span class="udiff-line-added">+       arytype  = _gvn.type(ary)-&gt;is_aryptr();</span>
<span class="udiff-line-added">+       elemtype = arytype-&gt;elem();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else if (UseTypeSpeculation &amp;&amp; UseArrayLoadStoreProfile) {</span>
<span class="udiff-line-added">+     // No need to speculate: feed profile data at this bci for the</span>
<span class="udiff-line-added">+     // array to type speculation</span>
<span class="udiff-line-added">+     ciKlass* array_type = NULL;</span>
<span class="udiff-line-added">+     ciKlass* element_type = NULL;</span>
<span class="udiff-line-added">+     ProfilePtrKind element_ptr = ProfileMaybeNull;</span>
<span class="udiff-line-added">+     bool flat_array = true;</span>
<span class="udiff-line-added">+     bool null_free_array = true;</span>
<span class="udiff-line-added">+     method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);</span>
<span class="udiff-line-added">+     if (array_type != NULL) {</span>
<span class="udiff-line-added">+       record_profile_for_speculation(ary, array_type, ProfileMaybeNull);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // We have no exact array type from profile data. Check profile data</span>
<span class="udiff-line-added">+   // for a non null free or non flat array. Non null free implies non</span>
<span class="udiff-line-added">+   // flat so check this one first. Speculating on a non null free</span>
<span class="udiff-line-added">+   // array doesn&#39;t help aaload but could be profitable for a</span>
<span class="udiff-line-added">+   // subsequent aastore.</span>
<span class="udiff-line-added">+   elemptr = elemtype-&gt;make_oopptr();</span>
<span class="udiff-line-added">+   if (!arytype-&gt;is_not_null_free() &amp;&amp;</span>
<span class="udiff-line-added">+       elemtype-&gt;isa_valuetype() == NULL &amp;&amp;</span>
<span class="udiff-line-added">+       (elemptr == NULL || !elemptr-&gt;is_valuetypeptr()) &amp;&amp;</span>
<span class="udiff-line-added">+       UseArrayLoadStoreProfile) {</span>
<span class="udiff-line-added">+     assert(is_reference_type(type), &quot;&quot;);</span>
<span class="udiff-line-added">+     bool null_free_array = true;</span>
<span class="udiff-line-added">+     Deoptimization::DeoptReason reason = Deoptimization::Reason_none;</span>
<span class="udiff-line-added">+     if (arytype-&gt;speculative() != NULL &amp;&amp;</span>
<span class="udiff-line-added">+         arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_null_free() &amp;&amp;</span>
<span class="udiff-line-added">+         !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {</span>
<span class="udiff-line-added">+       null_free_array = false;</span>
<span class="udiff-line-added">+       reason = Deoptimization::Reason_speculate_class_check;</span>
<span class="udiff-line-added">+     } else if (!too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {</span>
<span class="udiff-line-added">+       ciKlass* array_type = NULL;</span>
<span class="udiff-line-added">+       ciKlass* element_type = NULL;</span>
<span class="udiff-line-added">+       ProfilePtrKind element_ptr = ProfileMaybeNull;</span>
<span class="udiff-line-added">+       bool flat_array = true;</span>
<span class="udiff-line-added">+       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);</span>
<span class="udiff-line-added">+       reason = Deoptimization::Reason_class_check;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (!null_free_array) {</span>
<span class="udiff-line-added">+       { // Deoptimize if null-free array</span>
<span class="udiff-line-added">+         BuildCutout unless(this, is_nullable_array(ary), PROB_MAX);</span>
<span class="udiff-line-added">+         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype-&gt;cast_to_not_null_free()));</span>
<span class="udiff-line-added">+       replace_in_map(ary, better_ary);</span>
<span class="udiff-line-added">+       ary = better_ary;</span>
<span class="udiff-line-added">+       arytype = _gvn.type(ary)-&gt;is_aryptr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!arytype-&gt;is_not_flat() &amp;&amp; elemtype-&gt;isa_valuetype() == NULL) {</span>
<span class="udiff-line-added">+     assert(is_reference_type(type), &quot;&quot;);</span>
<span class="udiff-line-added">+     bool flat_array = true;</span>
<span class="udiff-line-added">+     Deoptimization::DeoptReason reason = Deoptimization::Reason_none;</span>
<span class="udiff-line-added">+     if (arytype-&gt;speculative() != NULL &amp;&amp;</span>
<span class="udiff-line-added">+         arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_flat() &amp;&amp;</span>
<span class="udiff-line-added">+         !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {</span>
<span class="udiff-line-added">+       flat_array = false;</span>
<span class="udiff-line-added">+       reason = Deoptimization::Reason_speculate_class_check;</span>
<span class="udiff-line-added">+     } else if (UseArrayLoadStoreProfile &amp;&amp; !too_many_traps_or_recompiles(reason)) {</span>
<span class="udiff-line-added">+       ciKlass* array_type = NULL;</span>
<span class="udiff-line-added">+       ciKlass* element_type = NULL;</span>
<span class="udiff-line-added">+       ProfilePtrKind element_ptr = ProfileMaybeNull;</span>
<span class="udiff-line-added">+       bool null_free_array = true;</span>
<span class="udiff-line-added">+       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);</span>
<span class="udiff-line-added">+       reason = Deoptimization::Reason_class_check;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (!flat_array) {</span>
<span class="udiff-line-added">+       { // Deoptimize if flat array</span>
<span class="udiff-line-added">+         BuildCutout unless(this, is_non_flattened_array(ary), PROB_MAX);</span>
<span class="udiff-line-added">+         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype-&gt;cast_to_not_flat()));</span>
<span class="udiff-line-added">+       replace_in_map(ary, better_ary);</span>
<span class="udiff-line-added">+       ary = better_ary;</span>
<span class="udiff-line-added">+       arytype = _gvn.type(ary)-&gt;is_aryptr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Make array address computation control dependent to prevent it
    // from floating above the range check during loop optimizations.
    Node* ptr = array_element_address(ary, idx, type, sizetype, control());
    assert(ptr != top(), &quot;top should go hand-in-hand with stopped&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1484,11 +1895,11 @@</span>
          branch_block-&gt;next_path_num();
        }
      } else {                    // Path is live.
        // Update method data
        profile_taken_branch(target_bci);
<span class="udiff-line-modified-removed">-       adjust_map_after_if(btest, c, prob, branch_block, next_block);</span>
<span class="udiff-line-modified-added">+       adjust_map_after_if(btest, c, prob, branch_block);</span>
        if (!stopped()) {
          merge(target_bci);
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1504,17 +1915,16 @@</span>
        next_block-&gt;next_path_num();
      }
    } else  {                     // Path is live.
      // Update method data
      profile_not_taken_branch();
<span class="udiff-line-modified-removed">-     adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob,</span>
<span class="udiff-line-removed">-                         next_block, branch_block);</span>
<span class="udiff-line-modified-added">+     adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob, next_block);</span>
    }
  }
  
  //------------------------------------do_if------------------------------------
<span class="udiff-line-modified-removed">- void Parse::do_if(BoolTest::mask btest, Node* c) {</span>
<span class="udiff-line-modified-added">+ void Parse::do_if(BoolTest::mask btest, Node* c, bool new_path, Node** ctrl_taken) {</span>
    int target_bci = iter().get_dest();
  
    Block* branch_block = successor_for_bci(target_bci);
    Block* next_block   = successor_for_bci(iter().next_bci());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1599,38 +2009,249 @@</span>
    { PreserveJVMState pjvms(this);
      taken_branch = _gvn.transform(taken_branch);
      set_control(taken_branch);
  
      if (stopped()) {
<span class="udiff-line-modified-removed">-       if (C-&gt;eliminate_boxing()) {</span>
<span class="udiff-line-modified-removed">-         // Mark the successor block as parsed</span>
<span class="udiff-line-modified-added">+       if (C-&gt;eliminate_boxing() &amp;&amp; !new_path) {</span>
<span class="udiff-line-modified-added">+         // Mark the successor block as parsed (if we haven&#39;t created a new path)</span>
          branch_block-&gt;next_path_num();
        }
      } else {
        // Update method data
        profile_taken_branch(target_bci);
<span class="udiff-line-modified-removed">-       adjust_map_after_if(taken_btest, c, prob, branch_block, next_block);</span>
<span class="udiff-line-modified-added">+       adjust_map_after_if(taken_btest, c, prob, branch_block);</span>
        if (!stopped()) {
<span class="udiff-line-modified-removed">-         merge(target_bci);</span>
<span class="udiff-line-modified-added">+         if (new_path) {</span>
<span class="udiff-line-added">+           // Merge by using a new path</span>
<span class="udiff-line-added">+           merge_new_path(target_bci);</span>
<span class="udiff-line-added">+         } else if (ctrl_taken != NULL) {</span>
<span class="udiff-line-added">+           // Don&#39;t merge but save taken branch to be wired by caller</span>
<span class="udiff-line-added">+           *ctrl_taken = control();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           merge(target_bci);</span>
<span class="udiff-line-added">+         }</span>
        }
      }
    }
  
    untaken_branch = _gvn.transform(untaken_branch);
    set_control(untaken_branch);
  
    // Branch not taken.
<span class="udiff-line-modified-removed">-   if (stopped()) {</span>
<span class="udiff-line-modified-added">+   if (stopped() &amp;&amp; ctrl_taken == NULL) {</span>
      if (C-&gt;eliminate_boxing()) {
<span class="udiff-line-modified-removed">-       // Mark the successor block as parsed</span>
<span class="udiff-line-modified-added">+       // Mark the successor block as parsed (if caller does not re-wire control flow)</span>
        next_block-&gt;next_path_num();
      }
    } else {
      // Update method data
      profile_not_taken_branch();
<span class="udiff-line-modified-removed">-     adjust_map_after_if(untaken_btest, c, untaken_prob,</span>
<span class="udiff-line-modified-removed">-                         next_block, branch_block);</span>
<span class="udiff-line-modified-added">+     adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Parse::do_acmp(BoolTest::mask btest, Node* a, Node* b) {</span>
<span class="udiff-line-added">+   ciMethod* subst_method = ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature());</span>
<span class="udiff-line-added">+   // If current method is ValueBootstrapMethods::isSubstitutable(),</span>
<span class="udiff-line-added">+   // compile the acmp as a regular pointer comparison otherwise we</span>
<span class="udiff-line-added">+   // could call ValueBootstrapMethods::isSubstitutable() back</span>
<span class="udiff-line-added">+   if (!EnableValhalla || (method() == subst_method)) {</span>
<span class="udiff-line-added">+     Node* cmp = CmpP(a, b);</span>
<span class="udiff-line-added">+     cmp = optimize_cmp_with_klass(cmp);</span>
<span class="udiff-line-added">+     do_if(btest, cmp);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Allocate value type operands and re-execute on deoptimization</span>
<span class="udiff-line-added">+   if (a-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+     PreserveReexecuteState preexecs(this);</span>
<span class="udiff-line-added">+     inc_sp(2);</span>
<span class="udiff-line-added">+     jvms()-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+     a = a-&gt;as_ValueType()-&gt;buffer(this)-&gt;get_oop();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (b-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+     PreserveReexecuteState preexecs(this);</span>
<span class="udiff-line-added">+     inc_sp(2);</span>
<span class="udiff-line-added">+     jvms()-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+     b = b-&gt;as_ValueType()-&gt;buffer(this)-&gt;get_oop();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // First, do a normal pointer comparison</span>
<span class="udiff-line-added">+   const TypeOopPtr* ta = _gvn.type(a)-&gt;isa_oopptr();</span>
<span class="udiff-line-added">+   const TypeOopPtr* tb = _gvn.type(b)-&gt;isa_oopptr();</span>
<span class="udiff-line-added">+   Node* cmp = CmpP(a, b);</span>
<span class="udiff-line-added">+   cmp = optimize_cmp_with_klass(cmp);</span>
<span class="udiff-line-added">+   if (ta == NULL || !ta-&gt;can_be_value_type() ||</span>
<span class="udiff-line-added">+       tb == NULL || !tb-&gt;can_be_value_type()) {</span>
<span class="udiff-line-added">+     // This is sufficient, if one of the operands can&#39;t be a value type</span>
<span class="udiff-line-added">+     do_if(btest, cmp);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Node* eq_region = NULL;</span>
<span class="udiff-line-added">+   if (btest == BoolTest::eq) {</span>
<span class="udiff-line-added">+     do_if(btest, cmp, true);</span>
<span class="udiff-line-added">+     if (stopped()) {</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(btest == BoolTest::ne, &quot;only eq or ne&quot;);</span>
<span class="udiff-line-added">+     Node* is_not_equal = NULL;</span>
<span class="udiff-line-added">+     eq_region = new RegionNode(3);</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+       do_if(btest, cmp, false, &amp;is_not_equal);</span>
<span class="udiff-line-added">+       if (!stopped()) {</span>
<span class="udiff-line-added">+         eq_region-&gt;init_req(1, control());</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (is_not_equal == NULL || is_not_equal-&gt;is_top()) {</span>
<span class="udiff-line-added">+       record_for_igvn(eq_region);</span>
<span class="udiff-line-added">+       set_control(_gvn.transform(eq_region));</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     set_control(is_not_equal);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Pointers are not equal, check if first operand is non-null</span>
<span class="udiff-line-added">+   Node* ne_region = new RegionNode(6);</span>
<span class="udiff-line-added">+   inc_sp(2);</span>
<span class="udiff-line-added">+   Node* null_ctl = top();</span>
<span class="udiff-line-added">+   Node* not_null_a = null_check_oop(a, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);</span>
<span class="udiff-line-added">+   dec_sp(2);</span>
<span class="udiff-line-added">+   ne_region-&gt;init_req(1, null_ctl);</span>
<span class="udiff-line-added">+   if (stopped()) {</span>
<span class="udiff-line-added">+     record_for_igvn(ne_region);</span>
<span class="udiff-line-added">+     set_control(_gvn.transform(ne_region));</span>
<span class="udiff-line-added">+     if (btest == BoolTest::ne) {</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+         int target_bci = iter().get_dest();</span>
<span class="udiff-line-added">+         merge(target_bci);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       record_for_igvn(eq_region);</span>
<span class="udiff-line-added">+       set_control(_gvn.transform(eq_region));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // First operand is non-null, check if it is a value type</span>
<span class="udiff-line-added">+   Node* is_value = is_value_type(not_null_a);</span>
<span class="udiff-line-added">+   IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);</span>
<span class="udiff-line-added">+   Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));</span>
<span class="udiff-line-added">+   ne_region-&gt;init_req(2, not_value);</span>
<span class="udiff-line-added">+   set_control(_gvn.transform(new IfTrueNode(is_value_iff)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // The first operand is a value type, check if the second operand is non-null</span>
<span class="udiff-line-added">+   inc_sp(2);</span>
<span class="udiff-line-added">+   null_ctl = top();</span>
<span class="udiff-line-added">+   Node* not_null_b = null_check_oop(b, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);</span>
<span class="udiff-line-added">+   dec_sp(2);</span>
<span class="udiff-line-added">+   ne_region-&gt;init_req(3, null_ctl);</span>
<span class="udiff-line-added">+   if (stopped()) {</span>
<span class="udiff-line-added">+     record_for_igvn(ne_region);</span>
<span class="udiff-line-added">+     set_control(_gvn.transform(ne_region));</span>
<span class="udiff-line-added">+     if (btest == BoolTest::ne) {</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+         int target_bci = iter().get_dest();</span>
<span class="udiff-line-added">+         merge(target_bci);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       record_for_igvn(eq_region);</span>
<span class="udiff-line-added">+       set_control(_gvn.transform(eq_region));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Check if both operands are of the same class.</span>
<span class="udiff-line-added">+   Node* kls_a = load_object_klass(not_null_a);</span>
<span class="udiff-line-added">+   Node* kls_b = load_object_klass(not_null_b);</span>
<span class="udiff-line-added">+   Node* kls_cmp = CmpP(kls_a, kls_b);</span>
<span class="udiff-line-added">+   Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));</span>
<span class="udiff-line-added">+   IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);</span>
<span class="udiff-line-added">+   Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));</span>
<span class="udiff-line-added">+   set_control(_gvn.transform(new IfFalseNode(kls_iff)));</span>
<span class="udiff-line-added">+   ne_region-&gt;init_req(4, kls_ne);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (stopped()) {</span>
<span class="udiff-line-added">+     record_for_igvn(ne_region);</span>
<span class="udiff-line-added">+     set_control(_gvn.transform(ne_region));</span>
<span class="udiff-line-added">+     if (btest == BoolTest::ne) {</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+         int target_bci = iter().get_dest();</span>
<span class="udiff-line-added">+         merge(target_bci);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       record_for_igvn(eq_region);</span>
<span class="udiff-line-added">+       set_control(_gvn.transform(eq_region));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Both operands are values types of the same class, we need to perform a</span>
<span class="udiff-line-added">+   // substitutability test. Delegate to ValueBootstrapMethods::isSubstitutable().</span>
<span class="udiff-line-added">+   Node* ne_io_phi = PhiNode::make(ne_region, i_o());</span>
<span class="udiff-line-added">+   Node* mem = reset_memory();</span>
<span class="udiff-line-added">+   Node* ne_mem_phi = PhiNode::make(ne_region, mem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* eq_io_phi = NULL;</span>
<span class="udiff-line-added">+   Node* eq_mem_phi = NULL;</span>
<span class="udiff-line-added">+   if (eq_region != NULL) {</span>
<span class="udiff-line-added">+     eq_io_phi = PhiNode::make(eq_region, i_o());</span>
<span class="udiff-line-added">+     eq_mem_phi = PhiNode::make(eq_region, mem);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   set_all_memory(mem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   kill_dead_locals();</span>
<span class="udiff-line-added">+   CallStaticJavaNode *call = new CallStaticJavaNode(C, TypeFunc::make(subst_method), SharedRuntime::get_resolve_static_call_stub(), subst_method, bci());</span>
<span class="udiff-line-added">+   call-&gt;set_override_symbolic_info(true);</span>
<span class="udiff-line-added">+   call-&gt;init_req(TypeFunc::Parms, not_null_a);</span>
<span class="udiff-line-added">+   call-&gt;init_req(TypeFunc::Parms+1, not_null_b);</span>
<span class="udiff-line-added">+   inc_sp(2);</span>
<span class="udiff-line-added">+   set_edges_for_java_call(call, false, false);</span>
<span class="udiff-line-added">+   Node* ret = set_results_for_java_call(call, false, true);</span>
<span class="udiff-line-added">+   dec_sp(2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Test the return value of ValueBootstrapMethods::isSubstitutable()</span>
<span class="udiff-line-added">+   Node* subst_cmp = _gvn.transform(new CmpINode(ret, intcon(1)));</span>
<span class="udiff-line-added">+   Node* ctl = C-&gt;top();</span>
<span class="udiff-line-added">+   if (btest == BoolTest::eq) {</span>
<span class="udiff-line-added">+     PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+     do_if(btest, subst_cmp);</span>
<span class="udiff-line-added">+     if (!stopped()) {</span>
<span class="udiff-line-added">+       ctl = control();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(btest == BoolTest::ne, &quot;only eq or ne&quot;);</span>
<span class="udiff-line-added">+     PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+     do_if(btest, subst_cmp, false, &amp;ctl);</span>
<span class="udiff-line-added">+     if (!stopped()) {</span>
<span class="udiff-line-added">+       eq_region-&gt;init_req(2, control());</span>
<span class="udiff-line-added">+       eq_io_phi-&gt;init_req(2, i_o());</span>
<span class="udiff-line-added">+       eq_mem_phi-&gt;init_req(2, reset_memory());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ne_region-&gt;init_req(5, ctl);</span>
<span class="udiff-line-added">+   ne_io_phi-&gt;init_req(5, i_o());</span>
<span class="udiff-line-added">+   ne_mem_phi-&gt;init_req(5, reset_memory());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   record_for_igvn(ne_region);</span>
<span class="udiff-line-added">+   set_control(_gvn.transform(ne_region));</span>
<span class="udiff-line-added">+   set_i_o(_gvn.transform(ne_io_phi));</span>
<span class="udiff-line-added">+   set_all_memory(_gvn.transform(ne_mem_phi));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (btest == BoolTest::ne) {</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       PreserveJVMState pjvms(this);</span>
<span class="udiff-line-added">+       int target_bci = iter().get_dest();</span>
<span class="udiff-line-added">+       merge(target_bci);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     record_for_igvn(eq_region);</span>
<span class="udiff-line-added">+     set_control(_gvn.transform(eq_region));</span>
<span class="udiff-line-added">+     set_i_o(_gvn.transform(eq_io_phi));</span>
<span class="udiff-line-added">+     set_all_memory(_gvn.transform(eq_mem_phi));</span>
    }
  }
  
  bool Parse::path_is_suitable_for_uncommon_trap(float prob) const {
    // Don&#39;t want to speculate on uncommon traps when running with -Xcomp
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1656,12 +2277,11 @@</span>
  // Adjust the JVM state to reflect the result of taking this path.
  // Basically, it means inspecting the CmpNode controlling this
  // branch, seeing how it constrains a tested value, and then
  // deciding if it&#39;s worth our while to encode this constraint
  // as graph nodes in the current abstract interpretation map.
<span class="udiff-line-modified-removed">- void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,</span>
<span class="udiff-line-removed">-                                 Block* path, Block* other_path) {</span>
<span class="udiff-line-modified-added">+ void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {</span>
    if (!c-&gt;is_Cmp()) {
      maybe_add_predicate_after_if(path);
      return;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1867,10 +2487,14 @@</span>
        if (obj_type-&gt;speculative_type_not_null() != NULL) {
          ciKlass* k = obj_type-&gt;speculative_type();
          inc_sp(2);
          obj = maybe_cast_profiled_obj(obj, k);
          dec_sp(2);
<span class="udiff-line-added">+         if (obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+           assert(obj-&gt;as_ValueType()-&gt;is_allocated(&amp;_gvn), &quot;must be allocated&quot;);</span>
<span class="udiff-line-added">+           obj = obj-&gt;as_ValueType()-&gt;get_oop();</span>
<span class="udiff-line-added">+         }</span>
          // Make the CmpP use the casted obj
          addp = basic_plus_adr(obj, addp-&gt;in(AddPNode::Offset));
          load_klass = load_klass-&gt;clone();
          load_klass-&gt;set_req(2, addp);
          load_klass = _gvn.transform(load_klass);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2714,37 +3338,40 @@</span>
    handle_if_null:
      // If this is a backwards branch in the bytecodes, add Safepoint
      maybe_add_safepoint(iter().get_dest());
      a = null();
      b = pop();
<span class="udiff-line-modified-removed">-     if (!_gvn.type(b)-&gt;speculative_maybe_null() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         !too_many_traps(Deoptimization::Reason_speculate_null_check)) {</span>
<span class="udiff-line-modified-removed">-       inc_sp(1);</span>
<span class="udiff-line-modified-removed">-       Node* null_ctl = top();</span>
<span class="udiff-line-modified-removed">-       b = null_check_oop(b, &amp;null_ctl, true, true, true);</span>
<span class="udiff-line-modified-removed">-       assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);</span>
<span class="udiff-line-modified-removed">-       dec_sp(1);</span>
<span class="udiff-line-modified-removed">-     } else if (_gvn.type(b)-&gt;speculative_always_null() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {</span>
<span class="udiff-line-modified-removed">-       inc_sp(1);</span>
<span class="udiff-line-modified-removed">-       b = null_assert(b);</span>
<span class="udiff-line-modified-removed">-       dec_sp(1);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     c = _gvn.transform( new CmpPNode(b, a) );</span>
<span class="udiff-line-modified-added">+     if (b-&gt;is_ValueType()) {</span>
<span class="udiff-line-modified-added">+       // Return constant false because &#39;b&#39; is always non-null</span>
<span class="udiff-line-modified-added">+       c = _gvn.makecon(TypeInt::CC_GT);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       if (!_gvn.type(b)-&gt;speculative_maybe_null() &amp;&amp;</span>
<span class="udiff-line-modified-added">+           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {</span>
<span class="udiff-line-modified-added">+         inc_sp(1);</span>
<span class="udiff-line-modified-added">+         Node* null_ctl = top();</span>
<span class="udiff-line-modified-added">+         b = null_check_oop(b, &amp;null_ctl, true, true, true);</span>
<span class="udiff-line-modified-added">+         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);</span>
<span class="udiff-line-modified-added">+         dec_sp(1);</span>
<span class="udiff-line-modified-added">+       } else if (_gvn.type(b)-&gt;speculative_always_null() &amp;&amp;</span>
<span class="udiff-line-modified-added">+                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {</span>
<span class="udiff-line-modified-added">+         inc_sp(1);</span>
<span class="udiff-line-added">+         b = null_assert(b);</span>
<span class="udiff-line-added">+         dec_sp(1);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       c = _gvn.transform( new CmpPNode(b, a) );</span>
<span class="udiff-line-added">+     }</span>
      do_ifnull(btest, c);
      break;
  
    case Bytecodes::_if_acmpeq: btest = BoolTest::eq; goto handle_if_acmp;
    case Bytecodes::_if_acmpne: btest = BoolTest::ne; goto handle_if_acmp;
    handle_if_acmp:
      // If this is a backwards branch in the bytecodes, add Safepoint
      maybe_add_safepoint(iter().get_dest());
      a = pop();
      b = pop();
<span class="udiff-line-modified-removed">-     c = _gvn.transform( new CmpPNode(b, a) );</span>
<span class="udiff-line-removed">-     c = optimize_cmp_with_klass(c);</span>
<span class="udiff-line-removed">-     do_if(btest, c);</span>
<span class="udiff-line-modified-added">+     do_acmp(btest, a, b);</span>
      break;
  
    case Bytecodes::_ifeq: btest = BoolTest::eq; goto handle_ifxx;
    case Bytecodes::_ifne: btest = BoolTest::ne; goto handle_ifxx;
    case Bytecodes::_iflt: btest = BoolTest::lt; goto handle_ifxx;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2795,21 +3422,27 @@</span>
      break;
    case Bytecodes::_instanceof:
      do_instanceof();
      break;
    case Bytecodes::_anewarray:
<span class="udiff-line-modified-removed">-     do_anewarray();</span>
<span class="udiff-line-modified-added">+     do_newarray();</span>
      break;
    case Bytecodes::_newarray:
      do_newarray((BasicType)iter().get_index());
      break;
    case Bytecodes::_multianewarray:
      do_multianewarray();
      break;
    case Bytecodes::_new:
      do_new();
      break;
<span class="udiff-line-added">+   case Bytecodes::_defaultvalue:</span>
<span class="udiff-line-added">+     do_defaultvalue();</span>
<span class="udiff-line-added">+     break;</span>
<span class="udiff-line-added">+   case Bytecodes::_withfield:</span>
<span class="udiff-line-added">+     do_withfield();</span>
<span class="udiff-line-added">+     break;</span>
  
    case Bytecodes::_jsr:
    case Bytecodes::_jsr_w:
      do_jsr();
      break;
</pre>
<center><a href="output.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phaseX.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
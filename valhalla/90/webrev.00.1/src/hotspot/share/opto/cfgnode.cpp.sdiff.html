<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/cfgnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c2_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/cfgnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;gc/shared/barrierSet.hpp&quot;
  28 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;oops/objArrayKlass.hpp&quot;
  32 #include &quot;opto/addnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/connode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/loopnode.hpp&quot;
  38 #include &quot;opto/machnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/narrowptrnode.hpp&quot;
  41 #include &quot;opto/mulnode.hpp&quot;
  42 #include &quot;opto/phaseX.hpp&quot;
  43 #include &quot;opto/regmask.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 #include &quot;opto/subnode.hpp&quot;

  46 #include &quot;utilities/vmError.hpp&quot;
  47 
  48 // Portions of code courtesy of Clifford Click
  49 
  50 // Optimization - Graph Style
  51 
  52 //=============================================================================
  53 //------------------------------Value------------------------------------------
  54 // Compute the type of the RegionNode.
  55 const Type* RegionNode::Value(PhaseGVN* phase) const {
  56   for( uint i=1; i&lt;req(); ++i ) {       // For all paths in
  57     Node *n = in(i);            // Get Control source
  58     if( !n ) continue;          // Missing inputs are TOP
  59     if( phase-&gt;type(n) == Type::CONTROL )
  60       return Type::CONTROL;
  61   }
  62   return Type::TOP;             // All paths dead?  Then so are we
  63 }
  64 
  65 //------------------------------Identity---------------------------------------
</pre>
<hr />
<pre>
 355   nstack.push(n);
 356   visited.set(n-&gt;_idx);
 357   while (nstack.size() != 0) {
 358     n = nstack.pop();
 359     uint max = n-&gt;outcnt();
 360     for (uint i = 0; i &lt; max; i++) {
 361       Node* m = n-&gt;raw_out(i);
 362       if (m != NULL &amp;&amp; m-&gt;is_CFG()) {
 363         if (phase-&gt;eqv(m, this)) {
 364           return false; // We reached the Region node - it is not dead.
 365         }
 366         if (!visited.test_set(m-&gt;_idx))
 367           nstack.push(m);
 368       }
 369     }
 370   }
 371 
 372   return true; // The Region node is unreachable - it is dead.
 373 }
 374 
<span class="line-modified"> 375 bool RegionNode::try_clean_mem_phi(PhaseGVN *phase) {</span>
 376   // Incremental inlining + PhaseStringOpts sometimes produce:
 377   //
 378   // cmpP with 1 top input
 379   //           |
 380   //          If
 381   //         /  \
 382   //   IfFalse  IfTrue  /- Some Node
 383   //         \  /      /    /
 384   //        Region    / /-MergeMem
 385   //             \---Phi
 386   //
 387   //
 388   // It&#39;s expected by PhaseStringOpts that the Region goes away and is
 389   // replaced by If&#39;s control input but because there&#39;s still a Phi,
 390   // the Region stays in the graph. The top input from the cmpP is
 391   // propagated forward and a subgraph that is useful goes away. The
 392   // code below replaces the Phi with the MergeMem so that the Region
 393   // is simplified.
 394 
<span class="line-modified"> 395   PhiNode* phi = has_unique_phi();</span>
<span class="line-removed"> 396   if (phi &amp;&amp; phi-&gt;type() == Type::MEMORY &amp;&amp; req() == 3 &amp;&amp; phi-&gt;is_diamond_phi(true)) {</span>
 397     MergeMemNode* m = NULL;
<span class="line-modified"> 398     assert(phi-&gt;req() == 3, &quot;same as region&quot;);</span>

 399     for (uint i = 1; i &lt; 3; ++i) {
<span class="line-modified"> 400       Node *mem = phi-&gt;in(i);</span>
<span class="line-modified"> 401       if (mem &amp;&amp; mem-&gt;is_MergeMem() &amp;&amp; in(i)-&gt;outcnt() == 1) {</span>
 402         // Nothing is control-dependent on path #i except the region itself.
 403         m = mem-&gt;as_MergeMem();
 404         uint j = 3 - i;
<span class="line-modified"> 405         Node* other = phi-&gt;in(j);</span>
 406         if (other &amp;&amp; other == m-&gt;base_memory()) {
 407           // m is a successor memory to other, and is not pinned inside the diamond, so push it out.
 408           // This will allow the diamond to collapse completely.
<span class="line-modified"> 409           phase-&gt;is_IterGVN()-&gt;replace_node(phi, m);</span>
<span class="line-removed"> 410           return true;</span>
 411         }
 412       }
 413     }
 414   }
<span class="line-modified"> 415   return false;</span>
 416 }
 417 
 418 //------------------------------Ideal------------------------------------------
 419 // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
 420 // the CFG, but we can still strip out dead paths.
 421 Node *RegionNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 422   if( !can_reshape &amp;&amp; !in(0) ) return NULL;     // Already degraded to a Copy
 423   assert(!in(0) || !in(0)-&gt;is_Root(), &quot;not a specially hidden merge&quot;);
 424 
 425   // Check for RegionNode with no Phi users and both inputs come from either
 426   // arm of the same IF.  If found, then the control-flow split is useless.
 427   bool has_phis = false;
 428   if (can_reshape) {            // Need DU info to check for Phi users
 429     has_phis = (has_phi() != NULL);       // Cache result
<span class="line-modified"> 430     if (has_phis &amp;&amp; try_clean_mem_phi(phase)) {</span>
<span class="line-modified"> 431       has_phis = false;</span>







 432     }
 433 
 434     if (!has_phis) {            // No Phi users?  Nothing merging?
 435       for (uint i = 1; i &lt; req()-1; i++) {
 436         Node *if1 = in(i);
 437         if( !if1 ) continue;
 438         Node *iff = if1-&gt;in(0);
 439         if( !iff || !iff-&gt;is_If() ) continue;
 440         for( uint j=i+1; j&lt;req(); j++ ) {
 441           if( in(j) &amp;&amp; in(j)-&gt;in(0) == iff &amp;&amp;
 442               if1-&gt;Opcode() != in(j)-&gt;Opcode() ) {
 443             // Add the IF Projections to the worklist. They (and the IF itself)
 444             // will be eliminated if dead.
 445             phase-&gt;is_IterGVN()-&gt;add_users_to_worklist(iff);
 446             set_req(i, iff-&gt;in(0));// Skip around the useless IF diamond
 447             set_req(j, NULL);
 448             return this;      // Record progress
 449           }
 450         }
 451       }
</pre>
<hr />
<pre>
 879 
 880 //=============================================================================
 881 // note that these functions assume that the _adr_type field is flattened
 882 uint PhiNode::hash() const {
 883   const Type* at = _adr_type;
 884   return TypeNode::hash() + (at ? at-&gt;hash() : 0);
 885 }
 886 bool PhiNode::cmp( const Node &amp;n ) const {
 887   return TypeNode::cmp(n) &amp;&amp; _adr_type == ((PhiNode&amp;)n)._adr_type;
 888 }
 889 static inline
 890 const TypePtr* flatten_phi_adr_type(const TypePtr* at) {
 891   if (at == NULL || at == TypePtr::BOTTOM)  return at;
 892   return Compile::current()-&gt;alias_type(at)-&gt;adr_type();
 893 }
 894 
 895 //----------------------------make---------------------------------------------
 896 // create a new phi with edges matching r and set (initially) to x
 897 PhiNode* PhiNode::make(Node* r, Node* x, const Type *t, const TypePtr* at) {
 898   uint preds = r-&gt;req();   // Number of predecessor paths
<span class="line-modified"> 899   assert(t != Type::MEMORY || at == flatten_phi_adr_type(at), &quot;flatten at&quot;);</span>
 900   PhiNode* p = new PhiNode(r, t, at);
 901   for (uint j = 1; j &lt; preds; j++) {
 902     // Fill in all inputs, except those which the region does not yet have
 903     if (r-&gt;in(j) != NULL)
 904       p-&gt;init_req(j, x);
 905   }
 906   return p;
 907 }
 908 PhiNode* PhiNode::make(Node* r, Node* x) {
 909   const Type*    t  = x-&gt;bottom_type();
 910   const TypePtr* at = NULL;
 911   if (t == Type::MEMORY)  at = flatten_phi_adr_type(x-&gt;adr_type());
 912   return make(r, x, t, at);
 913 }
 914 PhiNode* PhiNode::make_blank(Node* r, Node* x) {
 915   const Type*    t  = x-&gt;bottom_type();
 916   const TypePtr* at = NULL;
 917   if (t == Type::MEMORY)  at = flatten_phi_adr_type(x-&gt;adr_type());
 918   return new PhiNode(r, t, at);
 919 }
</pre>
<hr />
<pre>
1089         }
1090       }
1091     } else if (l-&gt;in(LoopNode::LoopBackControl) != NULL &amp;&amp;
1092                in(LoopNode::EntryControl) != NULL &amp;&amp;
1093                phase-&gt;type(l-&gt;in(LoopNode::LoopBackControl)) == Type::TOP) {
1094       // During CCP, if we saturate the type of a counted loop&#39;s Phi
1095       // before the special code for counted loop above has a chance
1096       // to run (that is as long as the type of the backedge&#39;s control
1097       // is top), we might end up with non monotonic types
1098       return phase-&gt;type(in(LoopNode::EntryControl))-&gt;filter_speculative(_type);
1099     }
1100   }
1101 
1102   // Until we have harmony between classes and interfaces in the type
1103   // lattice, we must tread carefully around phis which implicitly
1104   // convert the one to the other.
1105   const TypePtr* ttp = _type-&gt;make_ptr();
1106   const TypeInstPtr* ttip = (ttp != NULL) ? ttp-&gt;isa_instptr() : NULL;
1107   const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp-&gt;isa_klassptr() : NULL;
1108   bool is_intf = false;
<span class="line-modified">1109   if (ttip != NULL) {</span>
<span class="line-modified">1110     ciKlass* k = ttip-&gt;klass();</span>
<span class="line-modified">1111     if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_interface())</span>
<span class="line-modified">1112       is_intf = true;</span>
<span class="line-removed">1113   }</span>
<span class="line-removed">1114   if (ttkp != NULL) {</span>
<span class="line-removed">1115     ciKlass* k = ttkp-&gt;klass();</span>
<span class="line-removed">1116     if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_interface())</span>
<span class="line-removed">1117       is_intf = true;</span>
1118   }
1119 
1120   // Default case: merge all inputs
1121   const Type *t = Type::TOP;        // Merged type starting value
1122   for (uint i = 1; i &lt; req(); ++i) {// For all paths in
1123     // Reachable control path?
1124     if (r-&gt;in(i) &amp;&amp; phase-&gt;type(r-&gt;in(i)) == Type::CONTROL) {
1125       const Type* ti = phase-&gt;type(in(i));
1126       // We assume that each input of an interface-valued Phi is a true
1127       // subtype of that interface.  This might not be true of the meet
1128       // of all the input types.  The lattice is not distributive in
1129       // such cases.  Ward off asserts in type.cpp by refusing to do
1130       // meets between interfaces and proper classes.
1131       const TypePtr* tip = ti-&gt;make_ptr();
1132       const TypeInstPtr* tiip = (tip != NULL) ? tip-&gt;isa_instptr() : NULL;
1133       if (tiip) {
1134         bool ti_is_intf = false;
1135         ciKlass* k = tiip-&gt;klass();
1136         if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_interface())
1137           ti_is_intf = true;
</pre>
<hr />
<pre>
1154   //   (Occurrences of this case suggest improvements to Value methods.)
1155   //
1156   // It is not possible to see Type::BOTTOM values as phi inputs,
1157   // because the ciTypeFlow pre-pass produces verifier-quality types.
1158   const Type* ft = t-&gt;filter_speculative(_type);  // Worst case type
1159 
1160 #ifdef ASSERT
1161   // The following logic has been moved into TypeOopPtr::filter.
1162   const Type* jt = t-&gt;join_speculative(_type);
1163   if (jt-&gt;empty()) {           // Emptied out???
1164 
1165     // Check for evil case of &#39;t&#39; being a class and &#39;_type&#39; expecting an
1166     // interface.  This can happen because the bytecodes do not contain
1167     // enough type info to distinguish a Java-level interface variable
1168     // from a Java-level object variable.  If we meet 2 classes which
1169     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
1170     // doesn&#39;t implement I, we have no way to tell if the result should
1171     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
1172     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
1173     // uplift the type.
<span class="line-modified">1174     if (!t-&gt;empty() &amp;&amp; ttip &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {</span>
1175       assert(ft == _type, &quot;&quot;); // Uplift to interface
<span class="line-modified">1176     } else if (!t-&gt;empty() &amp;&amp; ttkp &amp;&amp; ttkp-&gt;is_loaded() &amp;&amp; ttkp-&gt;klass()-&gt;is_interface()) {</span>
1177       assert(ft == _type, &quot;&quot;); // Uplift to interface
1178     } else {
1179       // We also have to handle &#39;evil cases&#39; of interface- vs. class-arrays
1180       Type::get_arrays_base_elements(jt, _type, NULL, &amp;ttip);
1181       if (!t-&gt;empty() &amp;&amp; ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {
1182           assert(ft == _type, &quot;&quot;);   // Uplift to array of interface
1183       } else {
1184         // Otherwise it&#39;s something stupid like non-overlapping int ranges
1185         // found on dying counted loops.
1186         assert(ft == Type::TOP, &quot;&quot;); // Canonical empty value
1187       }
1188     }
1189   }
1190 
1191   else {
1192 
1193     // If we have an interface-typed Phi and we narrow to a class type, the join
1194     // should report back the class.  However, if we have a J/L/Object
1195     // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
1196     // join report an interface back out.  This isn&#39;t possible but happens
</pre>
<hr />
<pre>
1318 
1319 //------------------------------Identity---------------------------------------
1320 // Check for Region being Identity.
1321 Node* PhiNode::Identity(PhaseGVN* phase) {
1322   // Check for no merging going on
1323   // (There used to be special-case code here when this-&gt;region-&gt;is_Loop.
1324   // It would check for a tributary phi on the backedge that the main phi
1325   // trivially, perhaps with a single cast.  The unique_input method
1326   // does all this and more, by reducing such tributaries to &#39;this&#39;.)
1327   Node* uin = unique_input(phase, false);
1328   if (uin != NULL) {
1329     return uin;
1330   }
1331 
1332   int true_path = is_diamond_phi();
1333   if (true_path != 0) {
1334     Node* id = is_cmove_id(phase, true_path);
1335     if (id != NULL)  return id;
1336   }
1337 








1338   return this;                     // No identity
1339 }
1340 
1341 //-----------------------------unique_input------------------------------------
1342 // Find the unique value, discounting top, self-loops, and casts.
1343 // Return top if there are no inputs, and self if there are multiple.
1344 Node* PhiNode::unique_input(PhaseTransform* phase, bool uncast) {
1345   //  1) One unique direct input,
1346   // or if uncast is true:
1347   //  2) some of the inputs have an intervening ConstraintCast
1348   //  3) an input is a self loop
1349   //
1350   //  1) input   or   2) input     or   3) input __
1351   //     /   \           /   \               \  /  \
1352   //     \   /          |    cast             phi  cast
1353   //      phi            \   /               /  \  /
1354   //                      phi               /    --
1355 
1356   Node* r = in(0);                      // RegionNode
1357   if (r == NULL)  return in(1);         // Already degraded to a Copy
</pre>
<hr />
<pre>
1841   }
1842   return delay;
1843 }
1844 
1845 //------------------------------Ideal------------------------------------------
1846 // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
1847 // the CFG, but we can still strip out dead paths.
1848 Node *PhiNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1849   // The next should never happen after 6297035 fix.
1850   if( is_copy() )               // Already degraded to a Copy ?
1851     return NULL;                // No change
1852 
1853   Node *r = in(0);              // RegionNode
1854   assert(r-&gt;in(0) == NULL || !r-&gt;in(0)-&gt;is_Root(), &quot;not a specially hidden merge&quot;);
1855 
1856   // Note: During parsing, phis are often transformed before their regions.
1857   // This means we have to use type_or_null to defend against untyped regions.
1858   if( phase-&gt;type_or_null(r) == Type::TOP ) // Dead code?
1859     return NULL;                // No change
1860 


















1861   Node *top = phase-&gt;C-&gt;top();
1862   bool new_phi = (outcnt() == 0); // transforming new Phi
1863   // No change for igvn if new phi is not hooked
1864   if (new_phi &amp;&amp; can_reshape)
1865     return NULL;
1866 
1867   // The are 2 situations when only one valid phi&#39;s input is left
1868   // (in addition to Region input).
1869   // One: region is not loop - replace phi with this input.
1870   // Two: region is loop - replace phi with top since this data path is dead
1871   //                       and we need to break the dead data loop.
1872   Node* progress = NULL;        // Record if any progress made
1873   for( uint j = 1; j &lt; req(); ++j ){ // For all paths in
1874     // Check unreachable control paths
1875     Node* rc = r-&gt;in(j);
1876     Node* n = in(j);            // Get the input
1877     if (rc == NULL || phase-&gt;type(rc) == Type::TOP) {
1878       if (n != top) {           // Not already top?
1879         PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1880         if (can_reshape &amp;&amp; igvn != NULL) {
</pre>
<hr />
<pre>
2139           for (uint i = 1; i &lt; req(); i++) {
2140             offset-&gt;init_req(i, in(i)-&gt;in(AddPNode::Offset));
2141           }
2142           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(offset);
2143         }
2144         return new AddPNode(base, address, offset);
2145       }
2146     }
2147   }
2148 
2149   // Split phis through memory merges, so that the memory merges will go away.
2150   // Piggy-back this transformation on the search for a unique input....
2151   // It will be as if the merged memory is the unique value of the phi.
2152   // (Do not attempt this optimization unless parsing is complete.
2153   // It would make the parser&#39;s memory-merge logic sick.)
2154   // (MergeMemNode is not dead_loop_safe - need to check for dead loop.)
2155   if (progress == NULL &amp;&amp; can_reshape &amp;&amp; type() == Type::MEMORY) {
2156     // see if this phi should be sliced
2157     uint merge_width = 0;
2158     bool saw_self = false;


2159     for( uint i=1; i&lt;req(); ++i ) {// For all paths in
2160       Node *ii = in(i);
2161       // TOP inputs should not be counted as safe inputs because if the
2162       // Phi references itself through all other inputs then splitting the
2163       // Phi through memory merges would create dead loop at later stage.
2164       if (ii == top) {
2165         return NULL; // Delay optimization until graph is cleaned.
2166       }
2167       if (ii-&gt;is_MergeMem()) {
2168         MergeMemNode* n = ii-&gt;as_MergeMem();
2169         merge_width = MAX2(merge_width, n-&gt;req());
2170         saw_self = saw_self || phase-&gt;eqv(n-&gt;base_memory(), this);


2171       }
2172     }
2173 
2174     // This restriction is temporarily necessary to ensure termination:
<span class="line-modified">2175     if (!saw_self &amp;&amp; adr_type() == TypePtr::BOTTOM)  merge_width = 0;</span>
2176 
2177     if (merge_width &gt; Compile::AliasIdxRaw) {
2178       // found at least one non-empty MergeMem
2179       const TypePtr* at = adr_type();
2180       if (at != TypePtr::BOTTOM) {
2181         // Patch the existing phi to select an input from the merge:
2182         // Phi:AT1(...MergeMem(m0, m1, m2)...) into
2183         //     Phi:AT1(...m1...)
2184         int alias_idx = phase-&gt;C-&gt;get_alias_index(at);
2185         for (uint i=1; i&lt;req(); ++i) {
2186           Node *ii = in(i);
2187           if (ii-&gt;is_MergeMem()) {
2188             MergeMemNode* n = ii-&gt;as_MergeMem();
2189             // compress paths and change unreachable cycles to TOP
2190             // If not, we can update the input infinitely along a MergeMem cycle
2191             // Equivalent code is in MemNode::Ideal_common
2192             Node *m  = phase-&gt;transform(n);
2193             if (outcnt() == 0) {  // Above transform() may kill us!
2194               return top;
2195             }
</pre>
<hr />
<pre>
2584   return in(0)-&gt;in(0);
2585 }
2586 
2587 
2588 #ifndef PRODUCT
2589 void CatchProjNode::dump_spec(outputStream *st) const {
2590   ProjNode::dump_spec(st);
2591   st-&gt;print(&quot;@bci %d &quot;,_handler_bci);
2592 }
2593 #endif
2594 
2595 //=============================================================================
2596 //------------------------------Identity---------------------------------------
2597 // Check for CreateEx being Identity.
2598 Node* CreateExNode::Identity(PhaseGVN* phase) {
2599   if( phase-&gt;type(in(1)) == Type::TOP ) return in(1);
2600   if( phase-&gt;type(in(0)) == Type::TOP ) return in(0);
2601   // We only come from CatchProj, unless the CatchProj goes away.
2602   // If the CatchProj is optimized away, then we just carry the
2603   // exception oop through.






2604   CallNode *call = in(1)-&gt;in(0)-&gt;as_Call();
2605 
2606   return ( in(0)-&gt;is_CatchProj() &amp;&amp; in(0)-&gt;in(0)-&gt;in(1) == in(1) )
2607     ? this
2608     : call-&gt;in(TypeFunc::Parms);
2609 }
2610 
2611 //=============================================================================
2612 //------------------------------Value------------------------------------------
2613 // Check for being unreachable.
2614 const Type* NeverBranchNode::Value(PhaseGVN* phase) const {
2615   if (!in(0) || in(0)-&gt;is_top()) return Type::TOP;
2616   return bottom_type();
2617 }
2618 
2619 //------------------------------Ideal------------------------------------------
2620 // Check for no longer being part of a loop
2621 Node *NeverBranchNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2622   if (can_reshape &amp;&amp; !in(0)-&gt;is_Loop()) {
2623     // Dead code elimination can sometimes delete this projection so
</pre>
</td>
<td>
<hr />
<pre>
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;gc/shared/barrierSet.hpp&quot;
  28 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;oops/objArrayKlass.hpp&quot;
  32 #include &quot;opto/addnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/connode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/loopnode.hpp&quot;
  38 #include &quot;opto/machnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/narrowptrnode.hpp&quot;
  41 #include &quot;opto/mulnode.hpp&quot;
  42 #include &quot;opto/phaseX.hpp&quot;
  43 #include &quot;opto/regmask.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 #include &quot;opto/subnode.hpp&quot;
<span class="line-added">  46 #include &quot;opto/valuetypenode.hpp&quot;</span>
  47 #include &quot;utilities/vmError.hpp&quot;
  48 
  49 // Portions of code courtesy of Clifford Click
  50 
  51 // Optimization - Graph Style
  52 
  53 //=============================================================================
  54 //------------------------------Value------------------------------------------
  55 // Compute the type of the RegionNode.
  56 const Type* RegionNode::Value(PhaseGVN* phase) const {
  57   for( uint i=1; i&lt;req(); ++i ) {       // For all paths in
  58     Node *n = in(i);            // Get Control source
  59     if( !n ) continue;          // Missing inputs are TOP
  60     if( phase-&gt;type(n) == Type::CONTROL )
  61       return Type::CONTROL;
  62   }
  63   return Type::TOP;             // All paths dead?  Then so are we
  64 }
  65 
  66 //------------------------------Identity---------------------------------------
</pre>
<hr />
<pre>
 356   nstack.push(n);
 357   visited.set(n-&gt;_idx);
 358   while (nstack.size() != 0) {
 359     n = nstack.pop();
 360     uint max = n-&gt;outcnt();
 361     for (uint i = 0; i &lt; max; i++) {
 362       Node* m = n-&gt;raw_out(i);
 363       if (m != NULL &amp;&amp; m-&gt;is_CFG()) {
 364         if (phase-&gt;eqv(m, this)) {
 365           return false; // We reached the Region node - it is not dead.
 366         }
 367         if (!visited.test_set(m-&gt;_idx))
 368           nstack.push(m);
 369       }
 370     }
 371   }
 372 
 373   return true; // The Region node is unreachable - it is dead.
 374 }
 375 
<span class="line-modified"> 376 Node* PhiNode::try_clean_mem_phi(PhaseGVN *phase) {</span>
 377   // Incremental inlining + PhaseStringOpts sometimes produce:
 378   //
 379   // cmpP with 1 top input
 380   //           |
 381   //          If
 382   //         /  \
 383   //   IfFalse  IfTrue  /- Some Node
 384   //         \  /      /    /
 385   //        Region    / /-MergeMem
 386   //             \---Phi
 387   //
 388   //
 389   // It&#39;s expected by PhaseStringOpts that the Region goes away and is
 390   // replaced by If&#39;s control input but because there&#39;s still a Phi,
 391   // the Region stays in the graph. The top input from the cmpP is
 392   // propagated forward and a subgraph that is useful goes away. The
 393   // code below replaces the Phi with the MergeMem so that the Region
 394   // is simplified.
 395 
<span class="line-modified"> 396   if (type() == Type::MEMORY &amp;&amp; is_diamond_phi(true)) {</span>

 397     MergeMemNode* m = NULL;
<span class="line-modified"> 398     assert(req() == 3, &quot;same as region&quot;);</span>
<span class="line-added"> 399     Node* r = in(0);</span>
 400     for (uint i = 1; i &lt; 3; ++i) {
<span class="line-modified"> 401       Node *mem = in(i);</span>
<span class="line-modified"> 402       if (mem &amp;&amp; mem-&gt;is_MergeMem() &amp;&amp; r-&gt;in(i)-&gt;outcnt() == 1) {</span>
 403         // Nothing is control-dependent on path #i except the region itself.
 404         m = mem-&gt;as_MergeMem();
 405         uint j = 3 - i;
<span class="line-modified"> 406         Node* other = in(j);</span>
 407         if (other &amp;&amp; other == m-&gt;base_memory()) {
 408           // m is a successor memory to other, and is not pinned inside the diamond, so push it out.
 409           // This will allow the diamond to collapse completely.
<span class="line-modified"> 410           return m;</span>

 411         }
 412       }
 413     }
 414   }
<span class="line-modified"> 415   return NULL;</span>
 416 }
 417 
 418 //------------------------------Ideal------------------------------------------
 419 // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
 420 // the CFG, but we can still strip out dead paths.
 421 Node *RegionNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 422   if( !can_reshape &amp;&amp; !in(0) ) return NULL;     // Already degraded to a Copy
 423   assert(!in(0) || !in(0)-&gt;is_Root(), &quot;not a specially hidden merge&quot;);
 424 
 425   // Check for RegionNode with no Phi users and both inputs come from either
 426   // arm of the same IF.  If found, then the control-flow split is useless.
 427   bool has_phis = false;
 428   if (can_reshape) {            // Need DU info to check for Phi users
 429     has_phis = (has_phi() != NULL);       // Cache result
<span class="line-modified"> 430     if (has_phis) {</span>
<span class="line-modified"> 431       PhiNode* phi = has_unique_phi();</span>
<span class="line-added"> 432       if (phi != NULL) {</span>
<span class="line-added"> 433         Node* m = phi-&gt;try_clean_mem_phi(phase);</span>
<span class="line-added"> 434         if (m != NULL) {</span>
<span class="line-added"> 435           phase-&gt;is_IterGVN()-&gt;replace_node(phi, m);</span>
<span class="line-added"> 436           has_phis = false;</span>
<span class="line-added"> 437         }</span>
<span class="line-added"> 438       }</span>
 439     }
 440 
 441     if (!has_phis) {            // No Phi users?  Nothing merging?
 442       for (uint i = 1; i &lt; req()-1; i++) {
 443         Node *if1 = in(i);
 444         if( !if1 ) continue;
 445         Node *iff = if1-&gt;in(0);
 446         if( !iff || !iff-&gt;is_If() ) continue;
 447         for( uint j=i+1; j&lt;req(); j++ ) {
 448           if( in(j) &amp;&amp; in(j)-&gt;in(0) == iff &amp;&amp;
 449               if1-&gt;Opcode() != in(j)-&gt;Opcode() ) {
 450             // Add the IF Projections to the worklist. They (and the IF itself)
 451             // will be eliminated if dead.
 452             phase-&gt;is_IterGVN()-&gt;add_users_to_worklist(iff);
 453             set_req(i, iff-&gt;in(0));// Skip around the useless IF diamond
 454             set_req(j, NULL);
 455             return this;      // Record progress
 456           }
 457         }
 458       }
</pre>
<hr />
<pre>
 886 
 887 //=============================================================================
 888 // note that these functions assume that the _adr_type field is flattened
 889 uint PhiNode::hash() const {
 890   const Type* at = _adr_type;
 891   return TypeNode::hash() + (at ? at-&gt;hash() : 0);
 892 }
 893 bool PhiNode::cmp( const Node &amp;n ) const {
 894   return TypeNode::cmp(n) &amp;&amp; _adr_type == ((PhiNode&amp;)n)._adr_type;
 895 }
 896 static inline
 897 const TypePtr* flatten_phi_adr_type(const TypePtr* at) {
 898   if (at == NULL || at == TypePtr::BOTTOM)  return at;
 899   return Compile::current()-&gt;alias_type(at)-&gt;adr_type();
 900 }
 901 
 902 //----------------------------make---------------------------------------------
 903 // create a new phi with edges matching r and set (initially) to x
 904 PhiNode* PhiNode::make(Node* r, Node* x, const Type *t, const TypePtr* at) {
 905   uint preds = r-&gt;req();   // Number of predecessor paths
<span class="line-modified"> 906   assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::VALUES &amp;&amp; Compile::current()-&gt;flattened_accesses_share_alias()), &quot;flatten at&quot;);</span>
 907   PhiNode* p = new PhiNode(r, t, at);
 908   for (uint j = 1; j &lt; preds; j++) {
 909     // Fill in all inputs, except those which the region does not yet have
 910     if (r-&gt;in(j) != NULL)
 911       p-&gt;init_req(j, x);
 912   }
 913   return p;
 914 }
 915 PhiNode* PhiNode::make(Node* r, Node* x) {
 916   const Type*    t  = x-&gt;bottom_type();
 917   const TypePtr* at = NULL;
 918   if (t == Type::MEMORY)  at = flatten_phi_adr_type(x-&gt;adr_type());
 919   return make(r, x, t, at);
 920 }
 921 PhiNode* PhiNode::make_blank(Node* r, Node* x) {
 922   const Type*    t  = x-&gt;bottom_type();
 923   const TypePtr* at = NULL;
 924   if (t == Type::MEMORY)  at = flatten_phi_adr_type(x-&gt;adr_type());
 925   return new PhiNode(r, t, at);
 926 }
</pre>
<hr />
<pre>
1096         }
1097       }
1098     } else if (l-&gt;in(LoopNode::LoopBackControl) != NULL &amp;&amp;
1099                in(LoopNode::EntryControl) != NULL &amp;&amp;
1100                phase-&gt;type(l-&gt;in(LoopNode::LoopBackControl)) == Type::TOP) {
1101       // During CCP, if we saturate the type of a counted loop&#39;s Phi
1102       // before the special code for counted loop above has a chance
1103       // to run (that is as long as the type of the backedge&#39;s control
1104       // is top), we might end up with non monotonic types
1105       return phase-&gt;type(in(LoopNode::EntryControl))-&gt;filter_speculative(_type);
1106     }
1107   }
1108 
1109   // Until we have harmony between classes and interfaces in the type
1110   // lattice, we must tread carefully around phis which implicitly
1111   // convert the one to the other.
1112   const TypePtr* ttp = _type-&gt;make_ptr();
1113   const TypeInstPtr* ttip = (ttp != NULL) ? ttp-&gt;isa_instptr() : NULL;
1114   const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp-&gt;isa_klassptr() : NULL;
1115   bool is_intf = false;
<span class="line-modified">1116   if (ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {</span>
<span class="line-modified">1117     is_intf = true;</span>
<span class="line-modified">1118   } else if (ttkp != NULL &amp;&amp; ttkp-&gt;is_loaded() &amp;&amp; ttkp-&gt;klass()-&gt;is_interface()) {</span>
<span class="line-modified">1119     is_intf = true;</span>





1120   }
1121 
1122   // Default case: merge all inputs
1123   const Type *t = Type::TOP;        // Merged type starting value
1124   for (uint i = 1; i &lt; req(); ++i) {// For all paths in
1125     // Reachable control path?
1126     if (r-&gt;in(i) &amp;&amp; phase-&gt;type(r-&gt;in(i)) == Type::CONTROL) {
1127       const Type* ti = phase-&gt;type(in(i));
1128       // We assume that each input of an interface-valued Phi is a true
1129       // subtype of that interface.  This might not be true of the meet
1130       // of all the input types.  The lattice is not distributive in
1131       // such cases.  Ward off asserts in type.cpp by refusing to do
1132       // meets between interfaces and proper classes.
1133       const TypePtr* tip = ti-&gt;make_ptr();
1134       const TypeInstPtr* tiip = (tip != NULL) ? tip-&gt;isa_instptr() : NULL;
1135       if (tiip) {
1136         bool ti_is_intf = false;
1137         ciKlass* k = tiip-&gt;klass();
1138         if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_interface())
1139           ti_is_intf = true;
</pre>
<hr />
<pre>
1156   //   (Occurrences of this case suggest improvements to Value methods.)
1157   //
1158   // It is not possible to see Type::BOTTOM values as phi inputs,
1159   // because the ciTypeFlow pre-pass produces verifier-quality types.
1160   const Type* ft = t-&gt;filter_speculative(_type);  // Worst case type
1161 
1162 #ifdef ASSERT
1163   // The following logic has been moved into TypeOopPtr::filter.
1164   const Type* jt = t-&gt;join_speculative(_type);
1165   if (jt-&gt;empty()) {           // Emptied out???
1166 
1167     // Check for evil case of &#39;t&#39; being a class and &#39;_type&#39; expecting an
1168     // interface.  This can happen because the bytecodes do not contain
1169     // enough type info to distinguish a Java-level interface variable
1170     // from a Java-level object variable.  If we meet 2 classes which
1171     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
1172     // doesn&#39;t implement I, we have no way to tell if the result should
1173     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
1174     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
1175     // uplift the type.
<span class="line-modified">1176     if (!t-&gt;empty() &amp;&amp; ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {</span>
1177       assert(ft == _type, &quot;&quot;); // Uplift to interface
<span class="line-modified">1178     } else if (!t-&gt;empty() &amp;&amp; ttkp != NULL &amp;&amp; ttkp-&gt;is_loaded() &amp;&amp; ttkp-&gt;klass()-&gt;is_interface()) {</span>
1179       assert(ft == _type, &quot;&quot;); // Uplift to interface
1180     } else {
1181       // We also have to handle &#39;evil cases&#39; of interface- vs. class-arrays
1182       Type::get_arrays_base_elements(jt, _type, NULL, &amp;ttip);
1183       if (!t-&gt;empty() &amp;&amp; ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {
1184           assert(ft == _type, &quot;&quot;);   // Uplift to array of interface
1185       } else {
1186         // Otherwise it&#39;s something stupid like non-overlapping int ranges
1187         // found on dying counted loops.
1188         assert(ft == Type::TOP, &quot;&quot;); // Canonical empty value
1189       }
1190     }
1191   }
1192 
1193   else {
1194 
1195     // If we have an interface-typed Phi and we narrow to a class type, the join
1196     // should report back the class.  However, if we have a J/L/Object
1197     // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
1198     // join report an interface back out.  This isn&#39;t possible but happens
</pre>
<hr />
<pre>
1320 
1321 //------------------------------Identity---------------------------------------
1322 // Check for Region being Identity.
1323 Node* PhiNode::Identity(PhaseGVN* phase) {
1324   // Check for no merging going on
1325   // (There used to be special-case code here when this-&gt;region-&gt;is_Loop.
1326   // It would check for a tributary phi on the backedge that the main phi
1327   // trivially, perhaps with a single cast.  The unique_input method
1328   // does all this and more, by reducing such tributaries to &#39;this&#39;.)
1329   Node* uin = unique_input(phase, false);
1330   if (uin != NULL) {
1331     return uin;
1332   }
1333 
1334   int true_path = is_diamond_phi();
1335   if (true_path != 0) {
1336     Node* id = is_cmove_id(phase, true_path);
1337     if (id != NULL)  return id;
1338   }
1339 
<span class="line-added">1340   if (phase-&gt;is_IterGVN()) {</span>
<span class="line-added">1341     Node* m = try_clean_mem_phi(phase);</span>
<span class="line-added">1342     if (m != NULL) {</span>
<span class="line-added">1343       return m;</span>
<span class="line-added">1344     }</span>
<span class="line-added">1345   }</span>
<span class="line-added">1346 </span>
<span class="line-added">1347 </span>
1348   return this;                     // No identity
1349 }
1350 
1351 //-----------------------------unique_input------------------------------------
1352 // Find the unique value, discounting top, self-loops, and casts.
1353 // Return top if there are no inputs, and self if there are multiple.
1354 Node* PhiNode::unique_input(PhaseTransform* phase, bool uncast) {
1355   //  1) One unique direct input,
1356   // or if uncast is true:
1357   //  2) some of the inputs have an intervening ConstraintCast
1358   //  3) an input is a self loop
1359   //
1360   //  1) input   or   2) input     or   3) input __
1361   //     /   \           /   \               \  /  \
1362   //     \   /          |    cast             phi  cast
1363   //      phi            \   /               /  \  /
1364   //                      phi               /    --
1365 
1366   Node* r = in(0);                      // RegionNode
1367   if (r == NULL)  return in(1);         // Already degraded to a Copy
</pre>
<hr />
<pre>
1851   }
1852   return delay;
1853 }
1854 
1855 //------------------------------Ideal------------------------------------------
1856 // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
1857 // the CFG, but we can still strip out dead paths.
1858 Node *PhiNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1859   // The next should never happen after 6297035 fix.
1860   if( is_copy() )               // Already degraded to a Copy ?
1861     return NULL;                // No change
1862 
1863   Node *r = in(0);              // RegionNode
1864   assert(r-&gt;in(0) == NULL || !r-&gt;in(0)-&gt;is_Root(), &quot;not a specially hidden merge&quot;);
1865 
1866   // Note: During parsing, phis are often transformed before their regions.
1867   // This means we have to use type_or_null to defend against untyped regions.
1868   if( phase-&gt;type_or_null(r) == Type::TOP ) // Dead code?
1869     return NULL;                // No change
1870 
<span class="line-added">1871   // If all inputs are value types of the same type, push the value type node down</span>
<span class="line-added">1872   // through the phi because value type nodes should be merged through their input values.</span>
<span class="line-added">1873   if (req() &gt; 2 &amp;&amp; in(1) != NULL &amp;&amp; in(1)-&gt;is_ValueTypeBase() &amp;&amp; (can_reshape || in(1)-&gt;is_ValueType())) {</span>
<span class="line-added">1874     int opcode = in(1)-&gt;Opcode();</span>
<span class="line-added">1875     uint i = 2;</span>
<span class="line-added">1876     // Check if inputs are values of the same type</span>
<span class="line-added">1877     for (; i &lt; req() &amp;&amp; in(i) &amp;&amp; in(i)-&gt;is_ValueTypeBase() &amp;&amp; in(i)-&gt;cmp(*in(1)); i++) {</span>
<span class="line-added">1878       assert(in(i)-&gt;Opcode() == opcode, &quot;mixing pointers and values?&quot;);</span>
<span class="line-added">1879     }</span>
<span class="line-added">1880     if (i == req()) {</span>
<span class="line-added">1881       ValueTypeBaseNode* vt = in(1)-&gt;as_ValueTypeBase()-&gt;clone_with_phis(phase, in(0));</span>
<span class="line-added">1882       for (uint i = 2; i &lt; req(); ++i) {</span>
<span class="line-added">1883         vt-&gt;merge_with(phase, in(i)-&gt;as_ValueTypeBase(), i, i == (req()-1));</span>
<span class="line-added">1884       }</span>
<span class="line-added">1885       return vt;</span>
<span class="line-added">1886     }</span>
<span class="line-added">1887   }</span>
<span class="line-added">1888 </span>
1889   Node *top = phase-&gt;C-&gt;top();
1890   bool new_phi = (outcnt() == 0); // transforming new Phi
1891   // No change for igvn if new phi is not hooked
1892   if (new_phi &amp;&amp; can_reshape)
1893     return NULL;
1894 
1895   // The are 2 situations when only one valid phi&#39;s input is left
1896   // (in addition to Region input).
1897   // One: region is not loop - replace phi with this input.
1898   // Two: region is loop - replace phi with top since this data path is dead
1899   //                       and we need to break the dead data loop.
1900   Node* progress = NULL;        // Record if any progress made
1901   for( uint j = 1; j &lt; req(); ++j ){ // For all paths in
1902     // Check unreachable control paths
1903     Node* rc = r-&gt;in(j);
1904     Node* n = in(j);            // Get the input
1905     if (rc == NULL || phase-&gt;type(rc) == Type::TOP) {
1906       if (n != top) {           // Not already top?
1907         PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1908         if (can_reshape &amp;&amp; igvn != NULL) {
</pre>
<hr />
<pre>
2167           for (uint i = 1; i &lt; req(); i++) {
2168             offset-&gt;init_req(i, in(i)-&gt;in(AddPNode::Offset));
2169           }
2170           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(offset);
2171         }
2172         return new AddPNode(base, address, offset);
2173       }
2174     }
2175   }
2176 
2177   // Split phis through memory merges, so that the memory merges will go away.
2178   // Piggy-back this transformation on the search for a unique input....
2179   // It will be as if the merged memory is the unique value of the phi.
2180   // (Do not attempt this optimization unless parsing is complete.
2181   // It would make the parser&#39;s memory-merge logic sick.)
2182   // (MergeMemNode is not dead_loop_safe - need to check for dead loop.)
2183   if (progress == NULL &amp;&amp; can_reshape &amp;&amp; type() == Type::MEMORY) {
2184     // see if this phi should be sliced
2185     uint merge_width = 0;
2186     bool saw_self = false;
<span class="line-added">2187     // TODO revisit this with JDK-8247216</span>
<span class="line-added">2188     bool mergemem_only = true;</span>
2189     for( uint i=1; i&lt;req(); ++i ) {// For all paths in
2190       Node *ii = in(i);
2191       // TOP inputs should not be counted as safe inputs because if the
2192       // Phi references itself through all other inputs then splitting the
2193       // Phi through memory merges would create dead loop at later stage.
2194       if (ii == top) {
2195         return NULL; // Delay optimization until graph is cleaned.
2196       }
2197       if (ii-&gt;is_MergeMem()) {
2198         MergeMemNode* n = ii-&gt;as_MergeMem();
2199         merge_width = MAX2(merge_width, n-&gt;req());
2200         saw_self = saw_self || phase-&gt;eqv(n-&gt;base_memory(), this);
<span class="line-added">2201       } else {</span>
<span class="line-added">2202         mergemem_only = false;</span>
2203       }
2204     }
2205 
2206     // This restriction is temporarily necessary to ensure termination:
<span class="line-modified">2207     if (!mergemem_only &amp;&amp; !saw_self &amp;&amp; adr_type() == TypePtr::BOTTOM)  merge_width = 0;</span>
2208 
2209     if (merge_width &gt; Compile::AliasIdxRaw) {
2210       // found at least one non-empty MergeMem
2211       const TypePtr* at = adr_type();
2212       if (at != TypePtr::BOTTOM) {
2213         // Patch the existing phi to select an input from the merge:
2214         // Phi:AT1(...MergeMem(m0, m1, m2)...) into
2215         //     Phi:AT1(...m1...)
2216         int alias_idx = phase-&gt;C-&gt;get_alias_index(at);
2217         for (uint i=1; i&lt;req(); ++i) {
2218           Node *ii = in(i);
2219           if (ii-&gt;is_MergeMem()) {
2220             MergeMemNode* n = ii-&gt;as_MergeMem();
2221             // compress paths and change unreachable cycles to TOP
2222             // If not, we can update the input infinitely along a MergeMem cycle
2223             // Equivalent code is in MemNode::Ideal_common
2224             Node *m  = phase-&gt;transform(n);
2225             if (outcnt() == 0) {  // Above transform() may kill us!
2226               return top;
2227             }
</pre>
<hr />
<pre>
2616   return in(0)-&gt;in(0);
2617 }
2618 
2619 
2620 #ifndef PRODUCT
2621 void CatchProjNode::dump_spec(outputStream *st) const {
2622   ProjNode::dump_spec(st);
2623   st-&gt;print(&quot;@bci %d &quot;,_handler_bci);
2624 }
2625 #endif
2626 
2627 //=============================================================================
2628 //------------------------------Identity---------------------------------------
2629 // Check for CreateEx being Identity.
2630 Node* CreateExNode::Identity(PhaseGVN* phase) {
2631   if( phase-&gt;type(in(1)) == Type::TOP ) return in(1);
2632   if( phase-&gt;type(in(0)) == Type::TOP ) return in(0);
2633   // We only come from CatchProj, unless the CatchProj goes away.
2634   // If the CatchProj is optimized away, then we just carry the
2635   // exception oop through.
<span class="line-added">2636 </span>
<span class="line-added">2637   // CheckCastPPNode::Ideal() for value types reuses the exception</span>
<span class="line-added">2638   // paths of a call to perform an allocation: we can see a Phi here.</span>
<span class="line-added">2639   if (in(1)-&gt;is_Phi()) {</span>
<span class="line-added">2640     return this;</span>
<span class="line-added">2641   }</span>
2642   CallNode *call = in(1)-&gt;in(0)-&gt;as_Call();
2643 
2644   return ( in(0)-&gt;is_CatchProj() &amp;&amp; in(0)-&gt;in(0)-&gt;in(1) == in(1) )
2645     ? this
2646     : call-&gt;in(TypeFunc::Parms);
2647 }
2648 
2649 //=============================================================================
2650 //------------------------------Value------------------------------------------
2651 // Check for being unreachable.
2652 const Type* NeverBranchNode::Value(PhaseGVN* phase) const {
2653   if (!in(0) || in(0)-&gt;is_top()) return Type::TOP;
2654   return bottom_type();
2655 }
2656 
2657 //------------------------------Ideal------------------------------------------
2658 // Check for no longer being part of a loop
2659 Node *NeverBranchNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2660   if (can_reshape &amp;&amp; !in(0)-&gt;is_Loop()) {
2661     // Dead code elimination can sometimes delete this projection so
</pre>
</td>
</tr>
</table>
<center><a href="c2_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
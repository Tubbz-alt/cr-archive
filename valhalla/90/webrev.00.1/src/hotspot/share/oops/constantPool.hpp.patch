diff a/src/hotspot/share/oops/constantPool.hpp b/src/hotspot/share/oops/constantPool.hpp
--- a/src/hotspot/share/oops/constantPool.hpp
+++ b/src/hotspot/share/oops/constantPool.hpp
@@ -302,20 +302,29 @@
   static int pool_holder_offset_in_bytes()  { return offset_of(ConstantPool, _pool_holder); }
   static int resolved_klasses_offset_in_bytes()    { return offset_of(ConstantPool, _resolved_klasses); }
 
   // Storing constants
 
-  // For temporary use while constructing constant pool
+  // For temporary use while constructing constant pool. Used during a retransform/class redefinition as well.
   void klass_index_at_put(int which, int name_index) {
     tag_at_put(which, JVM_CONSTANT_ClassIndex);
     *int_at_addr(which) = name_index;
   }
 
   // Unsafe anonymous class support:
   void klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name);
   void klass_at_put(int class_index, Klass* k);
 
+  void unresolved_qdescriptor_at_put(int which, int name_index, int resolved_klass_index) {
+      release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);
+
+      assert((name_index & 0xffff0000) == 0, "must be");
+      assert((resolved_klass_index & 0xffff0000) == 0, "must be");
+      *int_at_addr(which) =
+        build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
+    }
+
   void unresolved_klass_at_put(int which, int name_index, int resolved_klass_index) {
     release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass);
 
     assert((name_index & 0xffff0000) == 0, "must be");
     assert((resolved_klass_index & 0xffff0000) == 0, "must be");

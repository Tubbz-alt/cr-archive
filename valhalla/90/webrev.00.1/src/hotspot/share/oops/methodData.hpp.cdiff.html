<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/methodData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 121,11 ***</span>
      multi_branch_data_tag,
      arg_info_data_tag,
      call_type_data_tag,
      virtual_call_type_data_tag,
      parameters_type_data_tag,
<span class="line-modified">!     speculative_trap_data_tag</span>
    };
  
    enum {
      // The trap state breaks down as [recompile:1 | reason:31].
      // This further breakdown is defined in deoptimization.cpp.
<span class="line-new-header">--- 121,12 ---</span>
      multi_branch_data_tag,
      arg_info_data_tag,
      call_type_data_tag,
      virtual_call_type_data_tag,
      parameters_type_data_tag,
<span class="line-modified">!     speculative_trap_data_tag,</span>
<span class="line-added">+     array_load_store_data_tag</span>
    };
  
    enum {
      // The trap state breaks down as [recompile:1 | reason:31].
      // This further breakdown is defined in deoptimization.cpp.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,18 ***</span>
  class   ArrayData;
  class     MultiBranchData;
  class     ArgInfoData;
  class     ParametersTypeData;
  class   SpeculativeTrapData;
  
  // ProfileData
  //
  // A ProfileData object is created to refer to a section of profiling
  // data in a structured way.
  class ProfileData : public ResourceObj {
    friend class TypeEntries;
<span class="line-modified">!   friend class ReturnTypeEntry;</span>
    friend class TypeStackSlotEntries;
  private:
    enum {
      tab_width_one = 16,
      tab_width_two = 36
<span class="line-new-header">--- 260,19 ---</span>
  class   ArrayData;
  class     MultiBranchData;
  class     ArgInfoData;
  class     ParametersTypeData;
  class   SpeculativeTrapData;
<span class="line-added">+ class   ArrayLoadStoreData;</span>
  
  // ProfileData
  //
  // A ProfileData object is created to refer to a section of profiling
  // data in a structured way.
  class ProfileData : public ResourceObj {
    friend class TypeEntries;
<span class="line-modified">!   friend class SingleTypeEntry;</span>
    friend class TypeStackSlotEntries;
  private:
    enum {
      tab_width_one = 16,
      tab_width_two = 36
</pre>
<hr />
<pre>
<span class="line-old-header">*** 387,10 ***</span>
<span class="line-new-header">--- 389,11 ---</span>
    virtual bool is_ArgInfoData()     const { return false; }
    virtual bool is_CallTypeData()    const { return false; }
    virtual bool is_VirtualCallTypeData()const { return false; }
    virtual bool is_ParametersTypeData() const { return false; }
    virtual bool is_SpeculativeTrapData()const { return false; }
<span class="line-added">+   virtual bool is_ArrayLoadStoreData() const { return false; }</span>
  
  
    BitData* as_BitData() const {
      assert(is_BitData(), &quot;wrong type&quot;);
      return is_BitData()         ? (BitData*)        this : NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,10 ***</span>
<span class="line-new-header">--- 448,14 ---</span>
    }
    SpeculativeTrapData* as_SpeculativeTrapData() const {
      assert(is_SpeculativeTrapData(), &quot;wrong type&quot;);
      return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;
    }
<span class="line-added">+   ArrayLoadStoreData* as_ArrayLoadStoreData() const {</span>
<span class="line-added">+     assert(is_ArrayLoadStoreData(), &quot;wrong type&quot;);</span>
<span class="line-added">+     return is_ArrayLoadStoreData() ? (ArrayLoadStoreData*)this : NULL;</span>
<span class="line-added">+   }</span>
  
  
    // Subclass specific initialization
    virtual void post_initialize(BytecodeStream* stream, MethodData* mdo) {}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 839,19 ***</span>
    void print_data_on(outputStream* st) const;
  };
  
  // Type entry used for return from a call. A single cell to record the
  // type.
<span class="line-modified">! class ReturnTypeEntry : public TypeEntries {</span>
  
  private:
    enum {
      cell_count = 1
    };
  
  public:
<span class="line-modified">!   ReturnTypeEntry(int base_off)</span>
      : TypeEntries(base_off) {}
  
    void post_initialize() {
      set_type(type_none());
    }
<span class="line-new-header">--- 846,19 ---</span>
    void print_data_on(outputStream* st) const;
  };
  
  // Type entry used for return from a call. A single cell to record the
  // type.
<span class="line-modified">! class SingleTypeEntry : public TypeEntries {</span>
  
  private:
    enum {
      cell_count = 1
    };
  
  public:
<span class="line-modified">!   SingleTypeEntry(int base_off)</span>
      : TypeEntries(base_off) {}
  
    void post_initialize() {
      set_type(type_none());
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,11 ***</span>
  
    void print_data_on(outputStream* st) const;
  };
  
  // Entries to collect type information at a call: contains arguments
<span class="line-modified">! // (TypeStackSlotEntries), a return type (ReturnTypeEntry) and a</span>
  // number of cells. Because the number of cells for the return type is
  // smaller than the number of cells for the type of an arguments, the
  // number of cells is used to tell how many arguments are profiled and
  // whether a return value is profiled. See has_arguments() and
  // has_return().
<span class="line-new-header">--- 888,11 ---</span>
  
    void print_data_on(outputStream* st) const;
  };
  
  // Entries to collect type information at a call: contains arguments
<span class="line-modified">! // (TypeStackSlotEntries), a return type (SingleTypeEntry) and a</span>
  // number of cells. Because the number of cells for the return type is
  // smaller than the number of cells for the type of an arguments, the
  // number of cells is used to tell how many arguments are profiled and
  // whether a return value is profiled. See has_arguments() and
  // has_return().
</pre>
<hr />
<pre>
<span class="line-old-header">*** 935,11 ***</span>
    static ByteSize argument_type_offset(int i) {
      return in_ByteSize(argument_type_local_offset(i) * DataLayout::cell_size);
    }
  
    static ByteSize return_only_size() {
<span class="line-modified">!     return ReturnTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);</span>
    }
  
  };
  
  // CallTypeData
<span class="line-new-header">--- 942,11 ---</span>
    static ByteSize argument_type_offset(int i) {
      return in_ByteSize(argument_type_local_offset(i) * DataLayout::cell_size);
    }
  
    static ByteSize return_only_size() {
<span class="line-modified">!     return SingleTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);</span>
    }
  
  };
  
  // CallTypeData
</pre>
<hr />
<pre>
<span class="line-old-header">*** 950,11 ***</span>
  class CallTypeData : public CounterData {
  private:
    // entries for arguments if any
    TypeStackSlotEntries _args;
    // entry for return type if any
<span class="line-modified">!   ReturnTypeEntry _ret;</span>
  
    int cell_count_global_offset() const {
      return CounterData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
    }
  
<span class="line-new-header">--- 957,11 ---</span>
  class CallTypeData : public CounterData {
  private:
    // entries for arguments if any
    TypeStackSlotEntries _args;
    // entry for return type if any
<span class="line-modified">!   SingleTypeEntry _ret;</span>
  
    int cell_count_global_offset() const {
      return CounterData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 969,11 ***</span>
  
  public:
    CallTypeData(DataLayout* layout) :
      CounterData(layout),
      _args(CounterData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
<span class="line-modified">!     _ret(cell_count() - ReturnTypeEntry::static_cell_count())</span>
    {
      assert(layout-&gt;tag() == DataLayout::call_type_data_tag, &quot;wrong type&quot;);
      // Some compilers (VC++) don&#39;t want this passed in member initialization list
      _args.set_profile_data(this);
      _ret.set_profile_data(this);
<span class="line-new-header">--- 976,11 ---</span>
  
  public:
    CallTypeData(DataLayout* layout) :
      CounterData(layout),
      _args(CounterData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
<span class="line-modified">!     _ret(cell_count() - SingleTypeEntry::static_cell_count())</span>
    {
      assert(layout-&gt;tag() == DataLayout::call_type_data_tag, &quot;wrong type&quot;);
      // Some compilers (VC++) don&#39;t want this passed in member initialization list
      _args.set_profile_data(this);
      _ret.set_profile_data(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,11 ***</span>
    const TypeStackSlotEntries* args() const {
      assert(has_arguments(), &quot;no profiling of arguments&quot;);
      return &amp;_args;
    }
  
<span class="line-modified">!   const ReturnTypeEntry* ret() const {</span>
      assert(has_return(), &quot;no profiling of return value&quot;);
      return &amp;_ret;
    }
  
    virtual bool is_CallTypeData() const { return true; }
<span class="line-new-header">--- 989,11 ---</span>
    const TypeStackSlotEntries* args() const {
      assert(has_arguments(), &quot;no profiling of arguments&quot;);
      return &amp;_args;
    }
  
<span class="line-modified">!   const SingleTypeEntry* ret() const {</span>
      assert(has_return(), &quot;no profiling of return value&quot;);
      return &amp;_ret;
    }
  
    virtual bool is_CallTypeData() const { return true; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1253,11 ***</span>
  class VirtualCallTypeData : public VirtualCallData {
  private:
    // entries for arguments if any
    TypeStackSlotEntries _args;
    // entry for return type if any
<span class="line-modified">!   ReturnTypeEntry _ret;</span>
  
    int cell_count_global_offset() const {
      return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
    }
  
<span class="line-new-header">--- 1260,11 ---</span>
  class VirtualCallTypeData : public VirtualCallData {
  private:
    // entries for arguments if any
    TypeStackSlotEntries _args;
    // entry for return type if any
<span class="line-modified">!   SingleTypeEntry _ret;</span>
  
    int cell_count_global_offset() const {
      return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1272,11 ***</span>
  
  public:
    VirtualCallTypeData(DataLayout* layout) :
      VirtualCallData(layout),
      _args(VirtualCallData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
<span class="line-modified">!     _ret(cell_count() - ReturnTypeEntry::static_cell_count())</span>
    {
      assert(layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
      // Some compilers (VC++) don&#39;t want this passed in member initialization list
      _args.set_profile_data(this);
      _ret.set_profile_data(this);
<span class="line-new-header">--- 1279,11 ---</span>
  
  public:
    VirtualCallTypeData(DataLayout* layout) :
      VirtualCallData(layout),
      _args(VirtualCallData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
<span class="line-modified">!     _ret(cell_count() - SingleTypeEntry::static_cell_count())</span>
    {
      assert(layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
      // Some compilers (VC++) don&#39;t want this passed in member initialization list
      _args.set_profile_data(this);
      _ret.set_profile_data(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1285,11 ***</span>
    const TypeStackSlotEntries* args() const {
      assert(has_arguments(), &quot;no profiling of arguments&quot;);
      return &amp;_args;
    }
  
<span class="line-modified">!   const ReturnTypeEntry* ret() const {</span>
      assert(has_return(), &quot;no profiling of return value&quot;);
      return &amp;_ret;
    }
  
    virtual bool is_VirtualCallTypeData() const { return true; }
<span class="line-new-header">--- 1292,11 ---</span>
    const TypeStackSlotEntries* args() const {
      assert(has_arguments(), &quot;no profiling of arguments&quot;);
      return &amp;_args;
    }
  
<span class="line-modified">!   const SingleTypeEntry* ret() const {</span>
      assert(has_return(), &quot;no profiling of return value&quot;);
      return &amp;_ret;
    }
  
    virtual bool is_VirtualCallTypeData() const { return true; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1844,10 ***</span>
<span class="line-new-header">--- 1851,83 ---</span>
    }
  
    virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
  };
  
<span class="line-added">+ class ArrayLoadStoreData : public ProfileData {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   enum {</span>
<span class="line-added">+     flat_array_flag = DataLayout::first_flag,</span>
<span class="line-added">+     null_free_array_flag = flat_array_flag + 1,</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   SingleTypeEntry _array;</span>
<span class="line-added">+   SingleTypeEntry _element;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ArrayLoadStoreData(DataLayout* layout) :</span>
<span class="line-added">+     ProfileData(layout),</span>
<span class="line-added">+     _array(0),</span>
<span class="line-added">+     _element(SingleTypeEntry::static_cell_count()) {</span>
<span class="line-added">+     assert(layout-&gt;tag() == DataLayout::array_load_store_data_tag, &quot;wrong type&quot;);</span>
<span class="line-added">+     _array.set_profile_data(this);</span>
<span class="line-added">+     _element.set_profile_data(this);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const SingleTypeEntry* array() const {</span>
<span class="line-added">+     return &amp;_array;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const SingleTypeEntry* element() const {</span>
<span class="line-added">+     return &amp;_element;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual bool is_ArrayLoadStoreData() const { return true; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static int static_cell_count() {</span>
<span class="line-added">+     return SingleTypeEntry::static_cell_count() * 2;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual int cell_count() const {</span>
<span class="line-added">+     return static_cell_count();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_flat_array() { set_flag_at(flat_array_flag); }</span>
<span class="line-added">+   bool flat_array() const { return flag_at(flat_array_flag); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_null_free_array() { set_flag_at(null_free_array_flag); }</span>
<span class="line-added">+   bool null_free_array() const { return flag_at(null_free_array_flag); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Code generation support</span>
<span class="line-added">+   static int flat_array_byte_constant() {</span>
<span class="line-added">+     return flag_number_to_constant(flat_array_flag);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static int null_free_array_byte_constant() {</span>
<span class="line-added">+     return flag_number_to_constant(null_free_array_flag);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static ByteSize array_offset() {</span>
<span class="line-added">+     return cell_offset(0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static ByteSize element_offset() {</span>
<span class="line-added">+     return cell_offset(SingleTypeEntry::static_cell_count());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual void clean_weak_klass_links(bool always_clean) {</span>
<span class="line-added">+     _array.clean_weak_klass_links(always_clean);</span>
<span class="line-added">+     _element.clean_weak_klass_links(always_clean);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static ByteSize array_load_store_data_size() {</span>
<span class="line-added">+     return cell_offset(static_cell_count());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  // MethodData*
  //
  // A MethodData* holds information which has been collected about
  // a method.  Its layout looks like this:
  //
</pre>
<center><a href="methodData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/oops/methodData.cpp b/src/hotspot/share/oops/methodData.cpp
--- a/src/hotspot/share/oops/methodData.cpp
+++ b/src/hotspot/share/oops/methodData.cpp
@@ -135,11 +135,11 @@
   if (extra != NULL) {
     st->print("%s", extra);
   }
   int flags = data()->flags();
   if (flags != 0) {
-    st->print("flags(%d) ", flags);
+    st->print("flags(%d) %p/%d", flags, data(), in_bytes(DataLayout::flags_offset()));
   }
 }
 
 void ProfileData::tab(outputStream* st, bool first) const {
   st->fill_to(first ? tab_width_one : tab_width_two);
@@ -205,21 +205,21 @@
   return args_count * per_arg_cell_count;
 }
 
 int TypeEntriesAtCall::compute_cell_count(BytecodeStream* stream) {
   assert(Bytecodes::is_invoke(stream->code()), "should be invoke");
-  assert(TypeStackSlotEntries::per_arg_count() > ReturnTypeEntry::static_cell_count(), "code to test for arguments/results broken");
+  assert(TypeStackSlotEntries::per_arg_count() > SingleTypeEntry::static_cell_count(), "code to test for arguments/results broken");
   const methodHandle m = stream->method();
   int bci = stream->bci();
   Bytecode_invoke inv(m, bci);
   int args_cell = 0;
   if (MethodData::profile_arguments_for_invoke(m, bci)) {
     args_cell = TypeStackSlotEntries::compute_cell_count(inv.signature(), false, TypeProfileArgsLimit);
   }
   int ret_cell = 0;
   if (MethodData::profile_return_for_invoke(m, bci) && is_reference_type(inv.result_type())) {
-    ret_cell = ReturnTypeEntry::static_cell_count();
+    ret_cell = SingleTypeEntry::static_cell_count();
   }
   int header_cell = 0;
   if (args_cell + ret_cell > 0) {
     header_cell = header_cell_count();
   }
@@ -318,11 +318,11 @@
       set_type(i, with_status((Klass*)NULL, p));
     }
   }
 }
 
-void ReturnTypeEntry::clean_weak_klass_links(bool always_clean) {
+void SingleTypeEntry::clean_weak_klass_links(bool always_clean) {
   intptr_t p = type();
   Klass* k = (Klass*)klass_part(p);
   if (k != NULL && (always_clean || !k->is_loader_alive())) {
     set_type(with_status((Klass*)NULL, p));
   }
@@ -356,11 +356,11 @@
     print_klass(st, type(i));
     st->cr();
   }
 }
 
-void ReturnTypeEntry::print_data_on(outputStream* st) const {
+void SingleTypeEntry::print_data_on(outputStream* st) const {
   _pd->tab(st);
   print_klass(st, type());
   st->cr();
 }
 
@@ -644,10 +644,21 @@
   tab(st);
   method()->print_short_name(st);
   st->cr();
 }
 
+void ArrayLoadStoreData::print_data_on(outputStream* st, const char* extra) const {
+  print_shared(st, "ArrayLoadStore", extra);
+  st->cr();
+  tab(st, true);
+  st->print("array");
+  _array.print_data_on(st);
+  tab(st, true);
+  st->print("element");
+  _element.print_data_on(st);
+}
+
 // ==================================================================
 // MethodData*
 //
 // A MethodData* holds information which has been collected about
 // a method.
@@ -664,16 +675,18 @@
     return no_profile_data;
   }
   switch (code) {
   case Bytecodes::_checkcast:
   case Bytecodes::_instanceof:
-  case Bytecodes::_aastore:
     if (TypeProfileCasts) {
       return ReceiverTypeData::static_cell_count();
     } else {
       return BitData::static_cell_count();
     }
+  case Bytecodes::_aaload:
+  case Bytecodes::_aastore:
+    return ArrayLoadStoreData::static_cell_count();
   case Bytecodes::_invokespecial:
   case Bytecodes::_invokestatic:
     if (MethodData::profile_arguments() || MethodData::profile_return()) {
       return variable_cell_count;
     } else {
@@ -772,10 +785,11 @@
 bool MethodData::is_speculative_trap_bytecode(Bytecodes::Code code) {
   // Bytecodes for which we may use speculation
   switch (code) {
   case Bytecodes::_checkcast:
   case Bytecodes::_instanceof:
+  case Bytecodes::_aaload:
   case Bytecodes::_aastore:
   case Bytecodes::_invokevirtual:
   case Bytecodes::_invokeinterface:
   case Bytecodes::_if_acmpeq:
   case Bytecodes::_if_acmpne:
@@ -975,19 +989,23 @@
   DataLayout* data_layout = data_layout_at(data_index);
   Bytecodes::Code c = stream->code();
   switch (c) {
   case Bytecodes::_checkcast:
   case Bytecodes::_instanceof:
-  case Bytecodes::_aastore:
     if (TypeProfileCasts) {
       cell_count = ReceiverTypeData::static_cell_count();
       tag = DataLayout::receiver_type_data_tag;
     } else {
       cell_count = BitData::static_cell_count();
       tag = DataLayout::bit_data_tag;
     }
     break;
+  case Bytecodes::_aaload:
+  case Bytecodes::_aastore:
+    cell_count = ArrayLoadStoreData::static_cell_count();
+    tag = DataLayout::array_load_store_data_tag;
+    break;
   case Bytecodes::_invokespecial:
   case Bytecodes::_invokestatic: {
     int counter_data_cell_count = CounterData::static_cell_count();
     if (profile_arguments_for_invoke(stream->method(), stream->bci()) ||
         profile_return_for_invoke(stream->method(), stream->bci())) {
@@ -1129,10 +1147,12 @@
     return new VirtualCallTypeData(this);
   case DataLayout::parameters_type_data_tag:
     return new ParametersTypeData(this);
   case DataLayout::speculative_trap_data_tag:
     return new SpeculativeTrapData(this);
+  case DataLayout::array_load_store_data_tag:
+    return new ArrayLoadStoreData(this);
   }
 }
 
 // Iteration over data.
 ProfileData* MethodData::next_data(ProfileData* current) const {

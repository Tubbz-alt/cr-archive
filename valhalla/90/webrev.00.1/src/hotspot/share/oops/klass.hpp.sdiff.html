<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;memory/iterator.hpp&quot;
 30 #include &quot;memory/memRegion.hpp&quot;
 31 #include &quot;oops/markWord.hpp&quot;
 32 #include &quot;oops/metadata.hpp&quot;
 33 #include &quot;oops/oop.hpp&quot;
 34 #include &quot;oops/oopHandle.hpp&quot;
 35 #include &quot;utilities/accessFlags.hpp&quot;
 36 #include &quot;utilities/macros.hpp&quot;
 37 #if INCLUDE_JFR
 38 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 39 #endif
 40 
 41 // Klass IDs for all subclasses of Klass
 42 enum KlassID {
 43   InstanceKlassID,
 44   InstanceRefKlassID,
 45   InstanceMirrorKlassID,
 46   InstanceClassLoaderKlassID,
 47   TypeArrayKlassID,

 48   ObjArrayKlassID
 49 };
 50 
<span class="line-modified"> 51 const uint KLASS_ID_COUNT = 6;</span>
 52 
 53 //
 54 // A Klass provides:
 55 //  1: language level class object (method dictionary etc.)
 56 //  2: provide vm dispatch behavior for the object
 57 // Both functions are combined into one C++ class.
 58 
 59 // One reason for the oop/klass dichotomy in the implementation is
 60 // that we don&#39;t want a C++ vtbl pointer in every object.  Thus,
 61 // normal oops don&#39;t have any virtual functions.  Instead, they
 62 // forward all &quot;virtual&quot; functions to their klass, which does have
 63 // a vtbl and does the C++ dispatch depending on the object&#39;s
 64 // actual type.  (See oop.inline.hpp for some of the forwarding code.)
 65 // ALL FUNCTIONS IMPLEMENTING THIS DISPATCH ARE PREFIXED WITH &quot;oop_&quot;!
 66 
 67 // Forward declarations.
 68 template &lt;class T&gt; class Array;
 69 template &lt;class T&gt; class GrowableArray;
 70 class fieldDescriptor;
 71 class klassVtable;
</pre>
<hr />
<pre>
 81  protected:
 82   // If you add a new field that points to any metaspace object, you
 83   // must add this field to Klass::metaspace_pointers_do().
 84 
 85   // note: put frequently-used fields together at start of klass structure
 86   // for better cache behavior (may not make much of a difference but sure won&#39;t hurt)
 87   enum { _primary_super_limit = 8 };
 88 
 89   // The &quot;layout helper&quot; is a combined descriptor of object layout.
 90   // For klasses which are neither instance nor array, the value is zero.
 91   //
 92   // For instances, layout helper is a positive number, the instance size.
 93   // This size is already passed through align_object_size and scaled to bytes.
 94   // The low order bit is set if instances of this class cannot be
 95   // allocated using the fastpath.
 96   //
 97   // For arrays, layout helper is a negative number, containing four
 98   // distinct bytes, as follows:
 99   //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
100   // where:
<span class="line-modified">101   //    tag is 0x80 if the elements are oops, 0xC0 if non-oops</span>
102   //    hsz is array header size in bytes (i.e., offset of first element)
103   //    ebt is the BasicType of the elements
104   //    esz is the element size in bytes
105   // This packed word is arranged so as to be quickly unpacked by the
106   // various fast paths that use the various subfields.
107   //
108   // The esz bits can be used directly by a SLL instruction, without masking.
109   //
110   // Note that the array-kind tag looks like 0x00 for instance klasses,
111   // since their length in bytes is always less than 24Mb.
112   //
113   // Final note:  This comes first, immediately after C++ vtable,
114   // because it is frequently queried.
115   jint        _layout_helper;
116 
117   // Klass identifier used to implement devirtualized oop closure dispatching.
118   const KlassID _id;
119 
120   // vtable length
121   int _vtable_len;
</pre>
<hr />
<pre>
344   static ByteSize super_offset()                 { return in_ByteSize(offset_of(Klass, _super)); }
345   static ByteSize super_check_offset_offset()    { return in_ByteSize(offset_of(Klass, _super_check_offset)); }
346   static ByteSize primary_supers_offset()        { return in_ByteSize(offset_of(Klass, _primary_supers)); }
347   static ByteSize secondary_super_cache_offset() { return in_ByteSize(offset_of(Klass, _secondary_super_cache)); }
348   static ByteSize secondary_supers_offset()      { return in_ByteSize(offset_of(Klass, _secondary_supers)); }
349   static ByteSize java_mirror_offset()           { return in_ByteSize(offset_of(Klass, _java_mirror)); }
350   static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }
351   static ByteSize modifier_flags_offset()        { return in_ByteSize(offset_of(Klass, _modifier_flags)); }
352   static ByteSize layout_helper_offset()         { return in_ByteSize(offset_of(Klass, _layout_helper)); }
353   static ByteSize access_flags_offset()          { return in_ByteSize(offset_of(Klass, _access_flags)); }
354 
355   // Unpacking layout_helper:
356   static const int _lh_neutral_value           = 0;  // neutral non-array non-instance value
357   static const int _lh_instance_slow_path_bit  = 0x01;
358   static const int _lh_log2_element_size_shift = BitsPerByte*0;
359   static const int _lh_log2_element_size_mask  = BitsPerLong-1;
360   static const int _lh_element_type_shift      = BitsPerByte*1;
361   static const int _lh_element_type_mask       = right_n_bits(BitsPerByte);  // shifted mask
362   static const int _lh_header_size_shift       = BitsPerByte*2;
363   static const int _lh_header_size_mask        = right_n_bits(BitsPerByte);  // shifted mask
<span class="line-modified">364   static const int _lh_array_tag_bits          = 2;</span>
365   static const int _lh_array_tag_shift         = BitsPerInt - _lh_array_tag_bits;
<span class="line-modified">366   static const int _lh_array_tag_obj_value     = ~0x01;   // 0x80000000 &gt;&gt; 30</span>
<span class="line-modified">367 </span>








368   static const unsigned int _lh_array_tag_type_value = 0Xffffffff; // ~0x00,  // 0xC0000000 &gt;&gt; 30
369 
370   static int layout_helper_size_in_bytes(jint lh) {
371     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
372     return (int) lh &amp; ~_lh_instance_slow_path_bit;
373   }
374   static bool layout_helper_needs_slow_path(jint lh) {
375     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
376     return (lh &amp; _lh_instance_slow_path_bit) != 0;
377   }
378   static bool layout_helper_is_instance(jint lh) {
379     return (jint)lh &gt; (jint)_lh_neutral_value;
380   }
381   static bool layout_helper_is_array(jint lh) {
382     return (jint)lh &lt; (jint)_lh_neutral_value;
383   }
384   static bool layout_helper_is_typeArray(jint lh) {
<span class="line-modified">385     // _lh_array_tag_type_value == (lh &gt;&gt; _lh_array_tag_shift);</span>
<span class="line-removed">386     return (juint)lh &gt;= (juint)(_lh_array_tag_type_value &lt;&lt; _lh_array_tag_shift);</span>
387   }
388   static bool layout_helper_is_objArray(jint lh) {
<span class="line-modified">389     // _lh_array_tag_obj_value == (lh &gt;&gt; _lh_array_tag_shift);</span>
<span class="line-modified">390     return (jint)lh &lt; (jint)(_lh_array_tag_type_value &lt;&lt; _lh_array_tag_shift);</span>











391   }
392   static int layout_helper_header_size(jint lh) {
393     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
394     int hsize = (lh &gt;&gt; _lh_header_size_shift) &amp; _lh_header_size_mask;
395     assert(hsize &gt; 0 &amp;&amp; hsize &lt; (int)sizeof(oopDesc)*3, &quot;sanity&quot;);
396     return hsize;
397   }
398   static BasicType layout_helper_element_type(jint lh) {
399     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
400     int btvalue = (lh &gt;&gt; _lh_element_type_shift) &amp; _lh_element_type_mask;
<span class="line-modified">401     assert(btvalue &gt;= T_BOOLEAN &amp;&amp; btvalue &lt;= T_OBJECT, &quot;sanity&quot;);</span>
402     return (BasicType) btvalue;
403   }
404 
405   // Want a pattern to quickly diff against layout header in register
406   // find something less clever!
407   static int layout_helper_boolean_diffbit() {
408     jint zlh = array_layout_helper(T_BOOLEAN);
409     jint blh = array_layout_helper(T_BYTE);
410     assert(zlh != blh, &quot;array layout helpers must differ&quot;);
411     int diffbit = 1;
412     while ((diffbit &amp; (zlh ^ blh)) == 0 &amp;&amp; (diffbit &amp; zlh) == 0) {
413       diffbit &lt;&lt;= 1;
414       assert(diffbit != 0, &quot;make sure T_BOOLEAN has a different bit than T_BYTE&quot;);
415     }
416     return diffbit;
417   }
418 
419   static int layout_helper_log2_element_size(jint lh) {
420     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
421     int l2esz = (lh &gt;&gt; _lh_log2_element_size_shift) &amp; _lh_log2_element_size_mask;
<span class="line-modified">422     assert(l2esz &lt;= LogBytesPerLong,</span>
423            &quot;sanity. l2esz: 0x%x for lh: 0x%x&quot;, (uint)l2esz, (uint)lh);
424     return l2esz;
425   }
<span class="line-modified">426   static jint array_layout_helper(jint tag, int hsize, BasicType etype, int log2_esize) {</span>
427     return (tag        &lt;&lt; _lh_array_tag_shift)

428       |    (hsize      &lt;&lt; _lh_header_size_shift)
429       |    ((int)etype &lt;&lt; _lh_element_type_shift)
430       |    (log2_esize &lt;&lt; _lh_log2_element_size_shift);
431   }
432   static jint instance_layout_helper(jint size, bool slow_path_flag) {
433     return (size &lt;&lt; LogBytesPerWord)
434       |    (slow_path_flag ? _lh_instance_slow_path_bit : 0);
435   }
436   static int layout_helper_to_size_helper(jint lh) {
437     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
438     // Note that the following expression discards _lh_instance_slow_path_bit.
439     return lh &gt;&gt; LogBytesPerWord;
440   }
441   // Out-of-line version computes everything based on the etype:
442   static jint array_layout_helper(BasicType etype);
443 
444   // What is the maximum number of primary superclasses any klass can have?
445   static juint primary_super_limit()         { return _primary_super_limit; }
446 
447   // vtables
</pre>
<hr />
<pre>
548  public:
549   // ALL FUNCTIONS BELOW THIS POINT ARE DISPATCHED FROM AN OOP
550   // These functions describe behavior for the oop not the KLASS.
551 
552   // actual oop size of obj in memory
553   virtual int oop_size(oop obj) const = 0;
554 
555   // Size of klass in word size.
556   virtual int size() const = 0;
557 
558   // Returns the Java name for a class (Resource allocated)
559   // For arrays, this returns the name of the element with a leading &#39;[&#39;.
560   // For classes, this returns the name with the package separators
561   //     turned into &#39;.&#39;s.
562   const char* external_name() const;
563   // Returns the name for a class (Resource allocated) as the class
564   // would appear in a signature.
565   // For arrays, this returns the name of the element with a leading &#39;[&#39;.
566   // For classes, this returns the name with a leading &#39;L&#39; and a trailing &#39;;&#39;
567   //     and the package separators as &#39;/&#39;.


568   virtual const char* signature_name() const;
569 
570   const char* joint_in_module_of_loader(const Klass* class2, bool include_parent_loader = false) const;
571   const char* class_in_module_of_loader(bool use_are = false, bool include_parent_loader = false) const;
572 
573   // Returns &quot;interface&quot;, &quot;abstract class&quot; or &quot;class&quot;.
574   const char* external_kind() const;
575 
576   // type testing operations
577 #ifdef ASSERT
578  protected:
579   virtual bool is_instance_klass_slow()     const { return false; }
580   virtual bool is_array_klass_slow()        const { return false; }
581   virtual bool is_objArray_klass_slow()     const { return false; }
582   virtual bool is_typeArray_klass_slow()    const { return false; }

583 #endif // ASSERT


584  public:
585 
586   // Fast non-virtual versions
587   #ifndef ASSERT
588   #define assert_same_query(xval, xcheck) xval
589   #else
590  private:
591   static bool assert_same_query(bool xval, bool xslow) {
592     assert(xval == xslow, &quot;slow and fast queries agree&quot;);
593     return xval;
594   }
595  public:
596   #endif
597   inline  bool is_instance_klass()            const { return assert_same_query(
598                                                       layout_helper_is_instance(layout_helper()),
599                                                       is_instance_klass_slow()); }
600   inline  bool is_array_klass()               const { return assert_same_query(
601                                                     layout_helper_is_array(layout_helper()),
602                                                     is_array_klass_slow()); }
603   inline  bool is_objArray_klass()            const { return assert_same_query(
604                                                     layout_helper_is_objArray(layout_helper()),
605                                                     is_objArray_klass_slow()); }
606   inline  bool is_typeArray_klass()           const { return assert_same_query(
607                                                     layout_helper_is_typeArray(layout_helper()),
608                                                     is_typeArray_klass_slow()); }





609   #undef assert_same_query
610 


611   // Access flags
612   AccessFlags access_flags() const         { return _access_flags;  }
613   void set_access_flags(AccessFlags flags) { _access_flags = flags; }
614 
615   bool is_public() const                { return _access_flags.is_public(); }
616   bool is_final() const                 { return _access_flags.is_final(); }
617   bool is_interface() const             { return _access_flags.is_interface(); }
618   bool is_abstract() const              { return _access_flags.is_abstract(); }
619   bool is_super() const                 { return _access_flags.is_super(); }
620   bool is_synthetic() const             { return _access_flags.is_synthetic(); }
621   void set_is_synthetic()               { _access_flags.set_is_synthetic(); }
622   bool has_finalizer() const            { return _access_flags.has_finalizer(); }
623   bool has_final_method() const         { return _access_flags.has_final_method(); }
624   void set_has_finalizer()              { _access_flags.set_has_finalizer(); }
625   void set_has_final_method()           { _access_flags.set_has_final_method(); }
626   bool has_vanilla_constructor() const  { return _access_flags.has_vanilla_constructor(); }
627   void set_has_vanilla_constructor()    { _access_flags.set_has_vanilla_constructor(); }
628   bool has_miranda_methods () const     { return access_flags().has_miranda_methods(); }
629   void set_has_miranda_methods()        { _access_flags.set_has_miranda_methods(); }
630   bool is_shared() const                { return access_flags().is_shared_class(); } // shadows MetaspaceObj::is_shared)()
631   void set_is_shared()                  { _access_flags.set_is_shared_class(); }
632   bool is_hidden() const                { return access_flags().is_hidden_class(); }
633   void set_is_hidden()                  { _access_flags.set_is_hidden_class(); }
634   bool is_non_strong_hidden() const     { return access_flags().is_hidden_class() &amp;&amp;
635                                           class_loader_data()-&gt;has_class_mirror_holder(); }
636 
637   bool is_cloneable() const;
638   void set_is_cloneable();
639 
640   // Biased locking support
641   // Note: the prototype header is always set up to be at least the
642   // prototype markWord. If biased locking is enabled it may further be
643   // biasable and have an epoch.
<span class="line-modified">644   markWord prototype_header() const      { return _prototype_header; }</span>




645   // NOTE: once instances of this klass are floating around in the
646   // system, this header must only be updated at a safepoint.
647   // NOTE 2: currently we only ever set the prototype header to the
648   // biasable prototype for instanceKlasses. There is no technical
649   // reason why it could not be done for arrayKlasses aside from
650   // wanting to reduce the initial scope of this optimization. There
651   // are potential problems in setting the bias pattern for
652   // JVM-internal oops.
653   inline void set_prototype_header(markWord header);
654   static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }
655 
656   int  biased_lock_revocation_count() const { return (int) _biased_lock_revocation_count; }
657   // Atomically increments biased_lock_revocation_count and returns updated value
658   int atomic_incr_biased_lock_revocation_count();
659   void set_biased_lock_revocation_count(int val) { _biased_lock_revocation_count = (jint) val; }
660   jlong last_biased_lock_bulk_revocation_time() { return _last_biased_lock_bulk_revocation_time; }
661   void  set_last_biased_lock_bulk_revocation_time(jlong cur_time) { _last_biased_lock_bulk_revocation_time = cur_time; }
662 
663   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
664 
</pre>
</td>
<td>
<hr />
<pre>
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;memory/iterator.hpp&quot;
 30 #include &quot;memory/memRegion.hpp&quot;
 31 #include &quot;oops/markWord.hpp&quot;
 32 #include &quot;oops/metadata.hpp&quot;
 33 #include &quot;oops/oop.hpp&quot;
 34 #include &quot;oops/oopHandle.hpp&quot;
 35 #include &quot;utilities/accessFlags.hpp&quot;
 36 #include &quot;utilities/macros.hpp&quot;
 37 #if INCLUDE_JFR
 38 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 39 #endif
 40 
 41 // Klass IDs for all subclasses of Klass
 42 enum KlassID {
 43   InstanceKlassID,
 44   InstanceRefKlassID,
 45   InstanceMirrorKlassID,
 46   InstanceClassLoaderKlassID,
 47   TypeArrayKlassID,
<span class="line-added"> 48   ValueArrayKlassID,</span>
 49   ObjArrayKlassID
 50 };
 51 
<span class="line-modified"> 52 const uint KLASS_ID_COUNT = 7;</span>
 53 
 54 //
 55 // A Klass provides:
 56 //  1: language level class object (method dictionary etc.)
 57 //  2: provide vm dispatch behavior for the object
 58 // Both functions are combined into one C++ class.
 59 
 60 // One reason for the oop/klass dichotomy in the implementation is
 61 // that we don&#39;t want a C++ vtbl pointer in every object.  Thus,
 62 // normal oops don&#39;t have any virtual functions.  Instead, they
 63 // forward all &quot;virtual&quot; functions to their klass, which does have
 64 // a vtbl and does the C++ dispatch depending on the object&#39;s
 65 // actual type.  (See oop.inline.hpp for some of the forwarding code.)
 66 // ALL FUNCTIONS IMPLEMENTING THIS DISPATCH ARE PREFIXED WITH &quot;oop_&quot;!
 67 
 68 // Forward declarations.
 69 template &lt;class T&gt; class Array;
 70 template &lt;class T&gt; class GrowableArray;
 71 class fieldDescriptor;
 72 class klassVtable;
</pre>
<hr />
<pre>
 82  protected:
 83   // If you add a new field that points to any metaspace object, you
 84   // must add this field to Klass::metaspace_pointers_do().
 85 
 86   // note: put frequently-used fields together at start of klass structure
 87   // for better cache behavior (may not make much of a difference but sure won&#39;t hurt)
 88   enum { _primary_super_limit = 8 };
 89 
 90   // The &quot;layout helper&quot; is a combined descriptor of object layout.
 91   // For klasses which are neither instance nor array, the value is zero.
 92   //
 93   // For instances, layout helper is a positive number, the instance size.
 94   // This size is already passed through align_object_size and scaled to bytes.
 95   // The low order bit is set if instances of this class cannot be
 96   // allocated using the fastpath.
 97   //
 98   // For arrays, layout helper is a negative number, containing four
 99   // distinct bytes, as follows:
100   //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
101   // where:
<span class="line-modified">102   //    tag is 0x80 if the elements are oops, 0xC0 if non-oops, 0xA0 if value types</span>
103   //    hsz is array header size in bytes (i.e., offset of first element)
104   //    ebt is the BasicType of the elements
105   //    esz is the element size in bytes
106   // This packed word is arranged so as to be quickly unpacked by the
107   // various fast paths that use the various subfields.
108   //
109   // The esz bits can be used directly by a SLL instruction, without masking.
110   //
111   // Note that the array-kind tag looks like 0x00 for instance klasses,
112   // since their length in bytes is always less than 24Mb.
113   //
114   // Final note:  This comes first, immediately after C++ vtable,
115   // because it is frequently queried.
116   jint        _layout_helper;
117 
118   // Klass identifier used to implement devirtualized oop closure dispatching.
119   const KlassID _id;
120 
121   // vtable length
122   int _vtable_len;
</pre>
<hr />
<pre>
345   static ByteSize super_offset()                 { return in_ByteSize(offset_of(Klass, _super)); }
346   static ByteSize super_check_offset_offset()    { return in_ByteSize(offset_of(Klass, _super_check_offset)); }
347   static ByteSize primary_supers_offset()        { return in_ByteSize(offset_of(Klass, _primary_supers)); }
348   static ByteSize secondary_super_cache_offset() { return in_ByteSize(offset_of(Klass, _secondary_super_cache)); }
349   static ByteSize secondary_supers_offset()      { return in_ByteSize(offset_of(Klass, _secondary_supers)); }
350   static ByteSize java_mirror_offset()           { return in_ByteSize(offset_of(Klass, _java_mirror)); }
351   static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }
352   static ByteSize modifier_flags_offset()        { return in_ByteSize(offset_of(Klass, _modifier_flags)); }
353   static ByteSize layout_helper_offset()         { return in_ByteSize(offset_of(Klass, _layout_helper)); }
354   static ByteSize access_flags_offset()          { return in_ByteSize(offset_of(Klass, _access_flags)); }
355 
356   // Unpacking layout_helper:
357   static const int _lh_neutral_value           = 0;  // neutral non-array non-instance value
358   static const int _lh_instance_slow_path_bit  = 0x01;
359   static const int _lh_log2_element_size_shift = BitsPerByte*0;
360   static const int _lh_log2_element_size_mask  = BitsPerLong-1;
361   static const int _lh_element_type_shift      = BitsPerByte*1;
362   static const int _lh_element_type_mask       = right_n_bits(BitsPerByte);  // shifted mask
363   static const int _lh_header_size_shift       = BitsPerByte*2;
364   static const int _lh_header_size_mask        = right_n_bits(BitsPerByte);  // shifted mask
<span class="line-modified">365   static const int _lh_array_tag_bits          = 3;</span>
366   static const int _lh_array_tag_shift         = BitsPerInt - _lh_array_tag_bits;
<span class="line-modified">367 </span>
<span class="line-modified">368   static const unsigned int _lh_array_tag_type_value = 0Xfffffffc;</span>
<span class="line-added">369   static const unsigned int _lh_array_tag_vt_value   = 0Xfffffffd;</span>
<span class="line-added">370   static const unsigned int _lh_array_tag_obj_value  = 0Xfffffffe;</span>
<span class="line-added">371 </span>
<span class="line-added">372   // null-free array flag bit under the array tag bits, shift one more to get array tag value</span>
<span class="line-added">373   static const int _lh_null_free_shift = _lh_array_tag_shift - 1;</span>
<span class="line-added">374   static const int _lh_null_free_mask  = 1;</span>
<span class="line-added">375 </span>
<span class="line-added">376   static const jint _lh_array_tag_vt_value_bit_inplace = (jint) (1 &lt;&lt; _lh_array_tag_shift);</span>
377   static const jint _lh_null_free_bit_inplace = (jint) (_lh_null_free_mask &lt;&lt; _lh_null_free_shift);
378 
379   static int layout_helper_size_in_bytes(jint lh) {
380     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
381     return (int) lh &amp; ~_lh_instance_slow_path_bit;
382   }
383   static bool layout_helper_needs_slow_path(jint lh) {
384     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
385     return (lh &amp; _lh_instance_slow_path_bit) != 0;
386   }
387   static bool layout_helper_is_instance(jint lh) {
388     return (jint)lh &gt; (jint)_lh_neutral_value;
389   }
390   static bool layout_helper_is_array(jint lh) {
391     return (jint)lh &lt; (jint)_lh_neutral_value;
392   }
393   static bool layout_helper_is_typeArray(jint lh) {
<span class="line-modified">394     return (juint) _lh_array_tag_type_value == (juint)(lh &gt;&gt; _lh_array_tag_shift);</span>

395   }
396   static bool layout_helper_is_objArray(jint lh) {
<span class="line-modified">397     return (juint)_lh_array_tag_obj_value == (juint)(lh &gt;&gt; _lh_array_tag_shift);</span>
<span class="line-modified">398   }</span>
<span class="line-added">399   static bool layout_helper_is_valueArray(jint lh) {</span>
<span class="line-added">400     return (juint)_lh_array_tag_vt_value == (juint)(lh &gt;&gt; _lh_array_tag_shift);</span>
<span class="line-added">401   }</span>
<span class="line-added">402   static bool layout_helper_is_null_free(jint lh) {</span>
<span class="line-added">403     assert(layout_helper_is_valueArray(lh) || layout_helper_is_objArray(lh), &quot;must be array of inline types&quot;);</span>
<span class="line-added">404     return ((lh &gt;&gt; _lh_null_free_shift) &amp; _lh_null_free_mask);</span>
<span class="line-added">405   }</span>
<span class="line-added">406   static jint layout_helper_set_null_free(jint lh) {</span>
<span class="line-added">407     lh |= (_lh_null_free_mask &lt;&lt; _lh_null_free_shift);</span>
<span class="line-added">408     assert(layout_helper_is_null_free(lh), &quot;Bad encoding&quot;);</span>
<span class="line-added">409     return lh;</span>
410   }
411   static int layout_helper_header_size(jint lh) {
412     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
413     int hsize = (lh &gt;&gt; _lh_header_size_shift) &amp; _lh_header_size_mask;
414     assert(hsize &gt; 0 &amp;&amp; hsize &lt; (int)sizeof(oopDesc)*3, &quot;sanity&quot;);
415     return hsize;
416   }
417   static BasicType layout_helper_element_type(jint lh) {
418     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
419     int btvalue = (lh &gt;&gt; _lh_element_type_shift) &amp; _lh_element_type_mask;
<span class="line-modified">420     assert((btvalue &gt;= T_BOOLEAN &amp;&amp; btvalue &lt;= T_OBJECT) || btvalue == T_VALUETYPE, &quot;sanity&quot;);</span>
421     return (BasicType) btvalue;
422   }
423 
424   // Want a pattern to quickly diff against layout header in register
425   // find something less clever!
426   static int layout_helper_boolean_diffbit() {
427     jint zlh = array_layout_helper(T_BOOLEAN);
428     jint blh = array_layout_helper(T_BYTE);
429     assert(zlh != blh, &quot;array layout helpers must differ&quot;);
430     int diffbit = 1;
431     while ((diffbit &amp; (zlh ^ blh)) == 0 &amp;&amp; (diffbit &amp; zlh) == 0) {
432       diffbit &lt;&lt;= 1;
433       assert(diffbit != 0, &quot;make sure T_BOOLEAN has a different bit than T_BYTE&quot;);
434     }
435     return diffbit;
436   }
437 
438   static int layout_helper_log2_element_size(jint lh) {
439     assert(lh &lt; (jint)_lh_neutral_value, &quot;must be array&quot;);
440     int l2esz = (lh &gt;&gt; _lh_log2_element_size_shift) &amp; _lh_log2_element_size_mask;
<span class="line-modified">441     assert(layout_helper_element_type(lh) == T_VALUETYPE || l2esz &lt;= LogBytesPerLong,</span>
442            &quot;sanity. l2esz: 0x%x for lh: 0x%x&quot;, (uint)l2esz, (uint)lh);
443     return l2esz;
444   }
<span class="line-modified">445   static jint array_layout_helper(jint tag, bool null_free, int hsize, BasicType etype, int log2_esize) {</span>
446     return (tag        &lt;&lt; _lh_array_tag_shift)
<span class="line-added">447       |    ((null_free ? 1 : 0) &lt;&lt;  _lh_null_free_shift)</span>
448       |    (hsize      &lt;&lt; _lh_header_size_shift)
449       |    ((int)etype &lt;&lt; _lh_element_type_shift)
450       |    (log2_esize &lt;&lt; _lh_log2_element_size_shift);
451   }
452   static jint instance_layout_helper(jint size, bool slow_path_flag) {
453     return (size &lt;&lt; LogBytesPerWord)
454       |    (slow_path_flag ? _lh_instance_slow_path_bit : 0);
455   }
456   static int layout_helper_to_size_helper(jint lh) {
457     assert(lh &gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
458     // Note that the following expression discards _lh_instance_slow_path_bit.
459     return lh &gt;&gt; LogBytesPerWord;
460   }
461   // Out-of-line version computes everything based on the etype:
462   static jint array_layout_helper(BasicType etype);
463 
464   // What is the maximum number of primary superclasses any klass can have?
465   static juint primary_super_limit()         { return _primary_super_limit; }
466 
467   // vtables
</pre>
<hr />
<pre>
568  public:
569   // ALL FUNCTIONS BELOW THIS POINT ARE DISPATCHED FROM AN OOP
570   // These functions describe behavior for the oop not the KLASS.
571 
572   // actual oop size of obj in memory
573   virtual int oop_size(oop obj) const = 0;
574 
575   // Size of klass in word size.
576   virtual int size() const = 0;
577 
578   // Returns the Java name for a class (Resource allocated)
579   // For arrays, this returns the name of the element with a leading &#39;[&#39;.
580   // For classes, this returns the name with the package separators
581   //     turned into &#39;.&#39;s.
582   const char* external_name() const;
583   // Returns the name for a class (Resource allocated) as the class
584   // would appear in a signature.
585   // For arrays, this returns the name of the element with a leading &#39;[&#39;.
586   // For classes, this returns the name with a leading &#39;L&#39; and a trailing &#39;;&#39;
587   //     and the package separators as &#39;/&#39;.
<span class="line-added">588   // For value classes, this returns the name with a leading &#39;Q&#39; and a trailing &#39;;&#39;</span>
<span class="line-added">589   //     and the package separators as &#39;/&#39;.</span>
590   virtual const char* signature_name() const;
591 
592   const char* joint_in_module_of_loader(const Klass* class2, bool include_parent_loader = false) const;
593   const char* class_in_module_of_loader(bool use_are = false, bool include_parent_loader = false) const;
594 
595   // Returns &quot;interface&quot;, &quot;abstract class&quot; or &quot;class&quot;.
596   const char* external_kind() const;
597 
598   // type testing operations
599 #ifdef ASSERT
600  protected:
601   virtual bool is_instance_klass_slow()     const { return false; }
602   virtual bool is_array_klass_slow()        const { return false; }
603   virtual bool is_objArray_klass_slow()     const { return false; }
604   virtual bool is_typeArray_klass_slow()    const { return false; }
<span class="line-added">605   virtual bool is_valueArray_klass_slow()   const { return false; }</span>
606 #endif // ASSERT
<span class="line-added">607   // current implementation uses this method even in non debug builds</span>
<span class="line-added">608   virtual bool is_inline_klass_slow()       const { return false; }</span>
609  public:
610 
611   // Fast non-virtual versions
612   #ifndef ASSERT
613   #define assert_same_query(xval, xcheck) xval
614   #else
615  private:
616   static bool assert_same_query(bool xval, bool xslow) {
617     assert(xval == xslow, &quot;slow and fast queries agree&quot;);
618     return xval;
619   }
620  public:
621   #endif
622   inline  bool is_instance_klass()            const { return assert_same_query(
623                                                       layout_helper_is_instance(layout_helper()),
624                                                       is_instance_klass_slow()); }
625   inline  bool is_array_klass()               const { return assert_same_query(
626                                                     layout_helper_is_array(layout_helper()),
627                                                     is_array_klass_slow()); }
628   inline  bool is_objArray_klass()            const { return assert_same_query(
629                                                     layout_helper_is_objArray(layout_helper()),
630                                                     is_objArray_klass_slow()); }
631   inline  bool is_typeArray_klass()           const { return assert_same_query(
632                                                     layout_helper_is_typeArray(layout_helper()),
633                                                     is_typeArray_klass_slow()); }
<span class="line-added">634   inline  bool is_inline_klass()              const { return is_inline_klass_slow(); } //temporary hack</span>
<span class="line-added">635   inline  bool is_valueArray_klass()          const { return assert_same_query(</span>
<span class="line-added">636                                                     layout_helper_is_valueArray(layout_helper()),</span>
<span class="line-added">637                                                     is_valueArray_klass_slow()); }</span>
<span class="line-added">638 </span>
639   #undef assert_same_query
640 
<span class="line-added">641   inline bool is_null_free_array_klass()      const { return layout_helper_is_null_free(layout_helper()); }</span>
<span class="line-added">642 </span>
643   // Access flags
644   AccessFlags access_flags() const         { return _access_flags;  }
645   void set_access_flags(AccessFlags flags) { _access_flags = flags; }
646 
647   bool is_public() const                { return _access_flags.is_public(); }
648   bool is_final() const                 { return _access_flags.is_final(); }
649   bool is_interface() const             { return _access_flags.is_interface(); }
650   bool is_abstract() const              { return _access_flags.is_abstract(); }
651   bool is_super() const                 { return _access_flags.is_super(); }
652   bool is_synthetic() const             { return _access_flags.is_synthetic(); }
653   void set_is_synthetic()               { _access_flags.set_is_synthetic(); }
654   bool has_finalizer() const            { return _access_flags.has_finalizer(); }
655   bool has_final_method() const         { return _access_flags.has_final_method(); }
656   void set_has_finalizer()              { _access_flags.set_has_finalizer(); }
657   void set_has_final_method()           { _access_flags.set_has_final_method(); }
658   bool has_vanilla_constructor() const  { return _access_flags.has_vanilla_constructor(); }
659   void set_has_vanilla_constructor()    { _access_flags.set_has_vanilla_constructor(); }
660   bool has_miranda_methods () const     { return access_flags().has_miranda_methods(); }
661   void set_has_miranda_methods()        { _access_flags.set_has_miranda_methods(); }
662   bool is_shared() const                { return access_flags().is_shared_class(); } // shadows MetaspaceObj::is_shared)()
663   void set_is_shared()                  { _access_flags.set_is_shared_class(); }
664   bool is_hidden() const                { return access_flags().is_hidden_class(); }
665   void set_is_hidden()                  { _access_flags.set_is_hidden_class(); }
666   bool is_non_strong_hidden() const     { return access_flags().is_hidden_class() &amp;&amp;
667                                           class_loader_data()-&gt;has_class_mirror_holder(); }
668 
669   bool is_cloneable() const;
670   void set_is_cloneable();
671 
672   // Biased locking support
673   // Note: the prototype header is always set up to be at least the
674   // prototype markWord. If biased locking is enabled it may further be
675   // biasable and have an epoch.
<span class="line-modified">676   markWord prototype_header() const     { return _prototype_header; }</span>
<span class="line-added">677   static inline markWord default_prototype_header(Klass* k) {</span>
<span class="line-added">678     return (k == NULL) ? markWord::prototype() : k-&gt;prototype_header();</span>
<span class="line-added">679   }</span>
<span class="line-added">680 </span>
681   // NOTE: once instances of this klass are floating around in the
682   // system, this header must only be updated at a safepoint.
683   // NOTE 2: currently we only ever set the prototype header to the
684   // biasable prototype for instanceKlasses. There is no technical
685   // reason why it could not be done for arrayKlasses aside from
686   // wanting to reduce the initial scope of this optimization. There
687   // are potential problems in setting the bias pattern for
688   // JVM-internal oops.
689   inline void set_prototype_header(markWord header);
690   static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }
691 
692   int  biased_lock_revocation_count() const { return (int) _biased_lock_revocation_count; }
693   // Atomically increments biased_lock_revocation_count and returns updated value
694   int atomic_incr_biased_lock_revocation_count();
695   void set_biased_lock_revocation_count(int val) { _biased_lock_revocation_count = (jint) val; }
696   jlong last_biased_lock_bulk_revocation_time() { return _last_biased_lock_bulk_revocation_time; }
697   void  set_last_biased_lock_bulk_revocation_time(jlong cur_time) { _last_biased_lock_bulk_revocation_time = cur_time; }
698 
699   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
700 
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
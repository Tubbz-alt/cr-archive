<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.invoke.MethodHandles;
  32 import java.lang.module.ModuleReader;
  33 import java.lang.ref.SoftReference;
  34 import java.io.IOException;
  35 import java.io.InputStream;
  36 import java.io.ObjectStreamField;
  37 import java.lang.reflect.AnnotatedElement;
  38 import java.lang.reflect.AnnotatedType;
  39 import java.lang.reflect.Array;
  40 import java.lang.reflect.Constructor;
  41 import java.lang.reflect.Executable;
  42 import java.lang.reflect.Field;
  43 import java.lang.reflect.GenericArrayType;
  44 import java.lang.reflect.GenericDeclaration;
  45 import java.lang.reflect.InvocationTargetException;
  46 import java.lang.reflect.Member;
  47 import java.lang.reflect.Method;
  48 import java.lang.reflect.Modifier;
  49 import java.lang.reflect.Proxy;
  50 import java.lang.reflect.RecordComponent;
  51 import java.lang.reflect.Type;
  52 import java.lang.reflect.TypeVariable;
  53 import java.lang.constant.Constable;
  54 import java.net.URL;
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.HashMap;
  61 import java.util.LinkedHashMap;
  62 import java.util.LinkedHashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.Objects;
  66 import java.util.Optional;
  67 import java.util.stream.Collectors;
  68 
  69 import jdk.internal.HotSpotIntrinsicCandidate;
  70 import jdk.internal.loader.BootLoader;
  71 import jdk.internal.loader.BuiltinClassLoader;
  72 import jdk.internal.misc.Unsafe;
  73 import jdk.internal.module.Resources;
  74 import jdk.internal.reflect.CallerSensitive;
  75 import jdk.internal.reflect.ConstantPool;
  76 import jdk.internal.reflect.Reflection;
  77 import jdk.internal.reflect.ReflectionFactory;
  78 import jdk.internal.vm.annotation.ForceInline;
  79 import sun.invoke.util.Wrapper;
  80 import sun.reflect.generics.factory.CoreReflectionFactory;
  81 import sun.reflect.generics.factory.GenericsFactory;
  82 import sun.reflect.generics.repository.ClassRepository;
  83 import sun.reflect.generics.repository.MethodRepository;
  84 import sun.reflect.generics.repository.ConstructorRepository;
  85 import sun.reflect.generics.scope.ClassScope;
  86 import sun.security.util.SecurityConstants;
  87 import sun.reflect.annotation.*;
  88 import sun.reflect.misc.ReflectUtil;
  89 
  90 /**
  91  * Instances of the class {@code Class} represent classes and
  92  * interfaces in a running Java application. An enum type and a record
  93  * type are kinds of class; an annotation type is a kind of
  94  * interface. Every array also belongs to a class that is reflected as
  95  * a {@code Class} object that is shared by all arrays with the same
  96  * element type and number of dimensions.  The primitive Java types
  97  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  98  * int}, {@code long}, {@code float}, and {@code double}), and the
  99  * keyword {@code void} are also represented as {@code Class} objects.
 100  *
 101  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 102  * object is constructed automatically by the Java Virtual Machine when
 103  * a class is derived from the bytes of a {@code class} file through
 104  * the invocation of one of the following methods:
 105  * &lt;ul&gt;
 106  * &lt;li&gt; {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}
 107  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])
 108  *      java.lang.invoke.MethodHandles.Lookup::defineClass}
 109  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 110  *      java.lang.invoke.MethodHandles.Lookup::defineHiddenClass}
 111  * &lt;/ul&gt;
 112  *
 113  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 114  * class or interface. Most characteristics are derived from the {@code class}
 115  * file that the class loader passed to the Java Virtual Machine or
 116  * from the {@code class} file passed to {@code Lookup::defineClass}
 117  * or {@code Lookup::defineHiddenClass}.
 118  * A few characteristics are determined by the class loading environment
 119  * at run time, such as the module returned by {@link #getModule() getModule()}.
 120  *
 121  * &lt;p&gt; The following example uses a {@code Class} object to print the
 122  * class name of an object:
 123  *
 124  * &lt;blockquote&gt;&lt;pre&gt;
 125  *     void printClassName(Object obj) {
 126  *         System.out.println(&quot;The class of &quot; + obj +
 127  *                            &quot; is &quot; + obj.getClass().getName());
 128  *     }
 129  * &lt;/pre&gt;&lt;/blockquote&gt;
 130  *
 131  * It is also possible to get the {@code Class} object for a named
 132  * type (or for {@code void}) using a &lt;i&gt;class literal&lt;/i&gt;.
 133  * For example:
 134  *
 135  * &lt;blockquote&gt;
 136  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 137  * &lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 140  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 141  * another declaration. Other methods describe how a class or interface
 142  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 143  * classes and interfaces, in the same run-time package, that
 144  * allow mutual access to their {@code private} members.
 145  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 146  * One nestmate acts as the
 147  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 148  * belong to the nest; each of them in turn records it as the nest host.
 149  * The classes and interfaces which belong to a nest, including its host, are
 150  * determined when
 151  * {@code class} files are generated, for example, a Java compiler
 152  * will typically record a top-level class as the host of a nest where the
 153  * other members are the classes and interfaces whose declarations are
 154  * enclosed within the top-level class declaration.
 155  *
 156  * &lt;p&gt; A class or interface created by the invocation of
 157  * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 158  * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() &lt;em&gt;hidden&lt;/em&gt;}
 159  * class or interface.
 160  * All kinds of class, including enum types and record types, may be
 161  * hidden classes; all kinds of interface, including annotation types,
 162  * may be hidden interfaces.
 163  *
 164  * The {@linkplain #getName() name of a hidden class or interface} is
 165  * not a &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;,
 166  * which means the following:
 167  * &lt;ul&gt;
 168  * &lt;li&gt;A hidden class or interface cannot be referenced by the constant pools
 169  *     of other classes and interfaces.
 170  * &lt;li&gt;A hidden class or interface cannot be described in
 171  *     {@linkplain java.lang.constant.ConstantDesc &lt;em&gt;nominal form&lt;/em&gt;} by
 172  *     {@link #describeConstable() Class::describeConstable},
 173  *     {@link ClassDesc#of(String) ClassDesc::of}, or
 174  *     {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}.
 175  * &lt;li&gt;A hidden class or interface cannot be discovered by {@link #forName Class::forName}
 176  *     or {@link ClassLoader#loadClass(String, boolean) ClassLoader::loadClass}.
 177  * &lt;/ul&gt;
 178  *
 179  * A hidden class or interface is never an array class, but may be
 180  * the element type of an array. In all other respects, the fact that
 181  * a class or interface is hidden has no bearing on the characteristics
 182  * exposed by the methods of class {@code Class}.
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
 192  * @jls 15.8.2 Class Literals
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
<a name="1" id="anc1"></a><span class="line-modified"> 200     private static final int ANNOTATION = 0x00002000;</span>
<span class="line-modified"> 201     private static final int ENUM       = 0x00004000;</span>
<span class="line-modified"> 202     private static final int SYNTHETIC  = 0x00001000;</span>
<span class="line-added"> 203     private static final int INLINE     = 0x00000100;</span>
 204 
 205     private static final ClassDesc[] EMPTY_CLASS_DESC_ARRAY = new ClassDesc[0];
 206 
 207     private static native void registerNatives();
 208     static {
 209         registerNatives();
 210     }
 211 
 212     /*
 213      * Private constructor. Only the Java Virtual Machine creates Class objects.
 214      * This constructor is not used and prevents the default constructor being
 215      * generated.
 216      */
 217     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 218         // Initialize final field for classLoader.  The initialization value of non-null
 219         // prevents future JIT optimizations from assuming this final field is null.
 220         classLoader = loader;
 221         componentType = arrayComponentType;
 222     }
 223 
 224     /**
 225      * Converts the object to a string. The string representation is the
 226      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 227      * name of the class in the format returned by {@code getName}.
 228      * If this {@code Class} object represents a primitive type,
 229      * this method returns the name of the primitive type.  If
 230      * this {@code Class} object represents void this method returns
 231      * &quot;void&quot;. If this {@code Class} object represents an array type,
 232      * this method returns &quot;class &quot; followed by {@code getName}.
 233      *
 234      * @return a string representation of this {@code Class} object.
 235      */
 236     public String toString() {
<a name="2" id="anc2"></a><span class="line-modified"> 237         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)</span>
<span class="line-modified"> 238                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))</span>
<span class="line-added"> 239                + getName();</span>
 240     }
 241 
 242     /**
 243      * Returns a string describing this {@code Class}, including
 244      * information about modifiers and type parameters.
 245      *
 246      * The string is formatted as a list of type modifiers, if any,
 247      * followed by the kind of type (empty string for primitive types
 248      * and {@code class}, {@code enum}, {@code interface},
 249      * {@code @interface}, or {@code record} as appropriate), followed
 250      * by the type&#39;s name, followed by an angle-bracketed
 251      * comma-separated list of the type&#39;s type parameters, if any,
 252      * including informative bounds on the type parameters, if any.
 253      *
 254      * A space is used to separate modifiers from one another and to
 255      * separate any modifiers from the kind of type. The modifiers
 256      * occur in canonical order. If there are no type parameters, the
 257      * type parameter list is elided.
 258      *
 259      * For an array type, the string starts with the type name,
 260      * followed by an angle-bracketed comma-separated list of the
 261      * type&#39;s type parameters, if any, followed by a sequence of
 262      * {@code []} characters, one set of brackets per dimension of
 263      * the array.
 264      *
 265      * &lt;p&gt;Note that since information about the runtime representation
 266      * of a type is being generated, modifiers not present on the
 267      * originating source code or illegal on the originating source
 268      * code may be present.
 269      *
 270      * @return a string describing this {@code Class}, including
 271      * information about modifiers and type parameters
 272      *
 273      * @since 1.8
 274      */
 275     @SuppressWarnings(&quot;preview&quot;)
 276     public String toGenericString() {
 277         if (isPrimitive()) {
 278             return toString();
 279         } else {
 280             StringBuilder sb = new StringBuilder();
 281             Class&lt;?&gt; component = this;
 282             int arrayDepth = 0;
 283 
 284             if (isArray()) {
 285                 do {
 286                     arrayDepth++;
 287                     component = component.getComponentType();
 288                 } while (component.isArray());
 289                 sb.append(component.getName());
 290             } else {
 291                 // Class modifiers are a superset of interface modifiers
 292                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 293                 if (modifiers != 0) {
 294                     sb.append(Modifier.toString(modifiers));
 295                     sb.append(&#39; &#39;);
 296                 }
 297 
 298                 if (isAnnotation()) {
 299                     sb.append(&#39;@&#39;);
 300                 }
<a name="3" id="anc3"></a><span class="line-added"> 301                 if (isInlineClass()) {</span>
<span class="line-added"> 302                     sb.append(&quot;inline&quot;);</span>
<span class="line-added"> 303                     sb.append(&#39; &#39;);</span>
<span class="line-added"> 304                 }</span>
 305                 if (isInterface()) { // Note: all annotation types are interfaces
 306                     sb.append(&quot;interface&quot;);
 307                 } else {
 308                     if (isEnum())
 309                         sb.append(&quot;enum&quot;);
 310                     else if (isRecord())
 311                         sb.append(&quot;record&quot;);
 312                     else
 313                         sb.append(&quot;class&quot;);
 314                 }
 315                 sb.append(&#39; &#39;);
 316                 sb.append(getName());
 317             }
 318 
 319             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 320             if (typeparms.length &gt; 0) {
 321                 sb.append(Arrays.stream(typeparms)
 322                           .map(Class::typeVarBounds)
 323                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 324             }
 325 
 326             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 327 
 328             return sb.toString();
 329         }
 330     }
 331 
 332     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 333         Type[] bounds = typeVar.getBounds();
 334         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 335             return typeVar.getName();
 336         } else {
 337             return typeVar.getName() + &quot; extends &quot; +
 338                 Arrays.stream(bounds)
 339                 .map(Type::getTypeName)
 340                 .collect(Collectors.joining(&quot; &amp; &quot;));
 341         }
 342     }
 343 
 344     /**
 345      * Returns the {@code Class} object associated with the class or
 346      * interface with the given string name.  Invoking this method is
 347      * equivalent to:
 348      *
 349      * &lt;blockquote&gt;
 350      *  {@code Class.forName(className, true, currentLoader)}
 351      * &lt;/blockquote&gt;
 352      *
 353      * where {@code currentLoader} denotes the defining class loader of
 354      * the current class.
 355      *
 356      * &lt;p&gt; For example, the following code fragment returns the
 357      * runtime {@code Class} descriptor for the class named
 358      * {@code java.lang.Thread}:
 359      *
 360      * &lt;blockquote&gt;
 361      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 362      * &lt;/blockquote&gt;
 363      * &lt;p&gt;
 364      * A call to {@code forName(&quot;X&quot;)} causes the class named
 365      * {@code X} to be initialized.
 366      *
 367      * @param      className   the fully qualified name of the desired class.
 368      * @return     the {@code Class} object for the class with the
 369      *             specified name.
 370      * @throws    LinkageError if the linkage fails
 371      * @throws    ExceptionInInitializerError if the initialization provoked
 372      *            by this method fails
 373      * @throws    ClassNotFoundException if the class cannot be located
 374      *
 375      * @jls 12.2 Loading of Classes and Interfaces
 376      * @jls 12.3 Linking of Classes and Interfaces
 377      * @jls 12.4 Initialization of Classes and Interfaces
 378      */
 379     @CallerSensitive
 380     public static Class&lt;?&gt; forName(String className)
 381                 throws ClassNotFoundException {
 382         Class&lt;?&gt; caller = Reflection.getCallerClass();
 383         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 384     }
 385 
 386 
 387     /**
 388      * Returns the {@code Class} object associated with the class or
 389      * interface with the given string name, using the given class loader.
 390      * Given the fully qualified name for a class or interface (in the same
 391      * format returned by {@code getName}) this method attempts to
 392      * locate and load the class or interface.  The specified class
 393      * loader is used to load the class or interface.  If the parameter
 394      * {@code loader} is null, the class is loaded through the bootstrap
 395      * class loader.  The class is initialized only if the
 396      * {@code initialize} parameter is {@code true} and if it has
 397      * not been initialized earlier.
 398      *
 399      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 400      * will be made to locate a user-defined class in the unnamed package whose
 401      * name is {@code name}. Therefore, this method cannot be used to
 402      * obtain any of the {@code Class} objects representing primitive
 403      * types or void.
 404      *
 405      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 406      * the array class is loaded but not initialized.
 407      *
 408      * &lt;p&gt; For example, in an instance method the expression:
 409      *
 410      * &lt;blockquote&gt;
 411      *  {@code Class.forName(&quot;Foo&quot;)}
 412      * &lt;/blockquote&gt;
 413      *
 414      * is equivalent to:
 415      *
 416      * &lt;blockquote&gt;
 417      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 418      * &lt;/blockquote&gt;
 419      *
 420      * Note that this method throws errors related to loading, linking
 421      * or initializing as specified in Sections {@jls 12.2}, {@jls
 422      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language
 423      * Specification&lt;/cite&gt;.
 424      * Note that this method does not check whether the requested class
 425      * is accessible to its caller.
 426      *
 427      * @param name       fully qualified name of the desired class
 428 
 429      * @param initialize if {@code true} the class will be initialized
 430      *                   (which implies linking). See Section {@jls
 431      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language
 432      *                   Specification&lt;/cite&gt;.
 433      * @param loader     class loader from which the class must be loaded
 434      * @return           class object representing the desired class
 435      *
 436      * @throws    LinkageError if the linkage fails
 437      * @throws    ExceptionInInitializerError if the initialization provoked
 438      *            by this method fails
 439      * @throws    ClassNotFoundException if the class cannot be located by
 440      *            the specified class loader
 441      * @throws    SecurityException
 442      *            if a security manager is present, and the {@code loader} is
 443      *            {@code null}, and the caller&#39;s class loader is not
 444      *            {@code null}, and the caller does not have the
 445      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 446      *
 447      * @see       java.lang.Class#forName(String)
 448      * @see       java.lang.ClassLoader
 449      *
 450      * @jls 12.2 Loading of Classes and Interfaces
 451      * @jls 12.3 Linking of Classes and Interfaces
 452      * @jls 12.4 Initialization of Classes and Interfaces
 453      * @since     1.2
 454      */
 455     @CallerSensitive
 456     public static Class&lt;?&gt; forName(String name, boolean initialize,
 457                                    ClassLoader loader)
 458         throws ClassNotFoundException
 459     {
 460         Class&lt;?&gt; caller = null;
 461         SecurityManager sm = System.getSecurityManager();
 462         if (sm != null) {
 463             // Reflective call to get caller class is only needed if a security manager
 464             // is present.  Avoid the overhead of making this call otherwise.
 465             caller = Reflection.getCallerClass();
 466             if (loader == null) {
 467                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 468                 if (ccl != null) {
 469                     sm.checkPermission(
 470                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 471                 }
 472             }
 473         }
 474         return forName0(name, initialize, loader, caller);
 475     }
 476 
 477     /** Called after security check for system loader access checks have been made. */
 478     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
<a name="4" id="anc4"></a><span class="line-modified"> 479                                     ClassLoader loader,</span>
<span class="line-modified"> 480                                     Class&lt;?&gt; caller)</span>
 481         throws ClassNotFoundException;
 482 
 483 
 484     /**
 485      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 486      * binary name&lt;/a&gt; in the given module.
 487      *
 488      * &lt;p&gt; This method attempts to locate and load the class or interface.
 489      * It does not link the class, and does not run the class initializer.
 490      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 491      *
 492      * &lt;p&gt; If the class loader of the given module defines other modules and
 493      * the given name is a class defined in a different module, this method
 494      * returns {@code null} after the class is loaded. &lt;/p&gt;
 495      *
 496      * &lt;p&gt; This method does not check whether the requested class is
 497      * accessible to its caller. &lt;/p&gt;
 498      *
 499      * @apiNote
 500      * This method returns {@code null} on failure rather than
 501      * throwing a {@link ClassNotFoundException}, as is done by
 502      * the {@link #forName(String, boolean, ClassLoader)} method.
 503      * The security check is a stack-based permission check if the caller
 504      * loads a class in another module.
 505      *
 506      * @param  module   A module
 507      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 508      *                  of the class
 509      * @return {@code Class} object of the given name defined in the given module;
 510      *         {@code null} if not found.
 511      *
 512      * @throws NullPointerException if the given module or name is {@code null}
 513      *
 514      * @throws LinkageError if the linkage fails
 515      *
 516      * @throws SecurityException
 517      *         &lt;ul&gt;
 518      *         &lt;li&gt; if the caller is not the specified module and
 519      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 520      *         &lt;li&gt; access to the module content is denied. For example,
 521      *         permission check will be performed when a class loader calls
 522      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 523      *         in a module.&lt;/li&gt;
 524      *         &lt;/ul&gt;
 525      *
 526      * @jls 12.2 Loading of Classes and Interfaces
 527      * @jls 12.3 Linking of Classes and Interfaces
 528      * @since 9
 529      * @spec JPMS
 530      */
 531     @CallerSensitive
 532     public static Class&lt;?&gt; forName(Module module, String name) {
 533         Objects.requireNonNull(module);
 534         Objects.requireNonNull(name);
 535 
 536         ClassLoader cl;
 537         SecurityManager sm = System.getSecurityManager();
 538         if (sm != null) {
 539             Class&lt;?&gt; caller = Reflection.getCallerClass();
 540             if (caller != null &amp;&amp; caller.getModule() != module) {
 541                 // if caller is null, Class.forName is the last java frame on the stack.
 542                 // java.base has all permissions
 543                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 544             }
 545             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 546             cl = AccessController.doPrivileged(pa);
 547         } else {
 548             cl = module.getClassLoader();
 549         }
 550 
 551         if (cl != null) {
 552             return cl.loadClass(module, name);
 553         } else {
 554             return BootLoader.loadClass(module, name);
 555         }
 556     }
 557 
<a name="5" id="anc5"></a><span class="line-added"> 558     /**</span>
<span class="line-added"> 559      * Returns {@code true} if this class is an inline class.</span>
<span class="line-added"> 560      *</span>
<span class="line-added"> 561      * @return {@code true} if this class is an inline class</span>
<span class="line-added"> 562      * @since Valhalla</span>
<span class="line-added"> 563      */</span>
<span class="line-added"> 564     public boolean isInlineClass() {</span>
<span class="line-added"> 565         return (this.getModifiers() &amp; INLINE) != 0;</span>
<span class="line-added"> 566     }</span>
<span class="line-added"> 567 </span>
<span class="line-added"> 568     /**</span>
<span class="line-added"> 569      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;</span>
<span class="line-added"> 570      * type of this class if this {@code Class} is the reference projection type</span>
<span class="line-added"> 571      * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty</span>
<span class="line-added"> 572      * {@link Optional} is returned.</span>
<span class="line-added"> 573      *</span>
<span class="line-added"> 574      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-added"> 575      *         this class if this class is the reference projection type of an</span>
<span class="line-added"> 576      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-added"> 577      * @since Valhalla</span>
<span class="line-added"> 578      */</span>
<span class="line-added"> 579     public Optional&lt;Class&lt;T&gt;&gt; valueType() {</span>
<span class="line-added"> 580         return Optional.ofNullable(valType);</span>
<span class="line-added"> 581     }</span>
<span class="line-added"> 582 </span>
<span class="line-added"> 583     /**</span>
<span class="line-added"> 584      * Returns a {@code Class} object representing the &lt;em&gt;reference projection&lt;/em&gt;</span>
<span class="line-added"> 585      * type of this class if this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-added"> 586      * with a reference projection.</span>
<span class="line-added"> 587      * If this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-added"> 588      * without a reference projection or this class is not an inline class,</span>
<span class="line-added"> 589      * then this method returns an empty {@link Optional}.</span>
<span class="line-added"> 590      *</span>
<span class="line-added"> 591      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-added"> 592      *         this class if this class is the reference projection type of an</span>
<span class="line-added"> 593      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-added"> 594      * @since Valhalla</span>
<span class="line-added"> 595      */</span>
<span class="line-added"> 596     public Optional&lt;Class&lt;T&gt;&gt; referenceType() {</span>
<span class="line-added"> 597         return valType != null ? Optional.ofNullable(refType) : Optional.of(this);</span>
<span class="line-added"> 598     }</span>
<span class="line-added"> 599 </span>
<span class="line-added"> 600     // set by VM if this class is an inline type</span>
<span class="line-added"> 601     // otherwise, these two fields are null</span>
<span class="line-added"> 602     private transient Class&lt;T&gt; valType;</span>
<span class="line-added"> 603     private transient Class&lt;T&gt; refType;</span>
<span class="line-added"> 604 </span>
 605     /**
 606      * Creates a new instance of the class represented by this {@code Class}
 607      * object.  The class is instantiated as if by a {@code new}
 608      * expression with an empty argument list.  The class is initialized if it
 609      * has not already been initialized.
 610      *
 611      * @deprecated This method propagates any exception thrown by the
 612      * nullary constructor, including a checked exception.  Use of
 613      * this method effectively bypasses the compile-time exception
 614      * checking that would otherwise be performed by the compiler.
 615      * The {@link
 616      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 617      * Constructor.newInstance} method avoids this problem by wrapping
 618      * any exception thrown by the constructor in a (checked) {@link
 619      * java.lang.reflect.InvocationTargetException}.
 620      *
 621      * &lt;p&gt;The call
 622      *
 623      * &lt;pre&gt;{@code
 624      * clazz.newInstance()
 625      * }&lt;/pre&gt;
 626      *
 627      * can be replaced by
 628      *
 629      * &lt;pre&gt;{@code
 630      * clazz.getDeclaredConstructor().newInstance()
 631      * }&lt;/pre&gt;
 632      *
 633      * The latter sequence of calls is inferred to be able to throw
 634      * the additional exception types {@link
 635      * InvocationTargetException} and {@link
 636      * NoSuchMethodException}. Both of these exception types are
 637      * subclasses of {@link ReflectiveOperationException}.
 638      *
 639      * @return  a newly allocated instance of the class represented by this
 640      *          object.
 641      * @throws  IllegalAccessException  if the class or its nullary
 642      *          constructor is not accessible.
 643      * @throws  InstantiationException
 644      *          if this {@code Class} represents an abstract class,
 645      *          an interface, an array class, a primitive type, or void;
 646      *          or if the class has no nullary constructor;
 647      *          or if the instantiation fails for some other reason.
 648      * @throws  ExceptionInInitializerError if the initialization
 649      *          provoked by this method fails.
 650      * @throws  SecurityException
 651      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 652      *          the caller&#39;s class loader is not the same as or an
 653      *          ancestor of the class loader for the current class and
 654      *          invocation of {@link SecurityManager#checkPackageAccess
 655      *          s.checkPackageAccess()} denies access to the package
 656      *          of this class.
 657      */
 658     @CallerSensitive
 659     @Deprecated(since=&quot;9&quot;)
 660     public T newInstance()
 661         throws InstantiationException, IllegalAccessException
 662     {
 663         SecurityManager sm = System.getSecurityManager();
 664         if (sm != null) {
 665             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 666         }
 667 
 668         // Constructor lookup
 669         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 670         if (tmpConstructor == null) {
 671             if (this == Class.class) {
 672                 throw new IllegalAccessException(
 673                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 674                 );
 675             }
 676             try {
 677                 Class&lt;?&gt;[] empty = {};
 678                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 679                     getConstructor0(empty, Member.DECLARED));
 680                 // Disable accessibility checks on the constructor
 681                 // access check is done with the true caller
 682                 java.security.AccessController.doPrivileged(
 683                     new java.security.PrivilegedAction&lt;&gt;() {
 684                         public Void run() {
 685                                 c.setAccessible(true);
 686                                 return null;
 687                             }
 688                         });
 689                 cachedConstructor = tmpConstructor = c;
 690             } catch (NoSuchMethodException e) {
 691                 throw (InstantiationException)
 692                     new InstantiationException(getName()).initCause(e);
 693             }
 694         }
 695 
 696         try {
 697             Class&lt;?&gt; caller = Reflection.getCallerClass();
 698             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 699         } catch (InvocationTargetException e) {
 700             Unsafe.getUnsafe().throwException(e.getTargetException());
 701             // Not reached
 702             return null;
 703         }
 704     }
 705 
 706     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 707 
 708     /**
 709      * Determines if the specified {@code Object} is assignment-compatible
 710      * with the object represented by this {@code Class}.  This method is
 711      * the dynamic equivalent of the Java language {@code instanceof}
 712      * operator. The method returns {@code true} if the specified
 713      * {@code Object} argument is non-null and can be cast to the
 714      * reference type represented by this {@code Class} object without
 715      * raising a {@code ClassCastException.} It returns {@code false}
 716      * otherwise.
 717      *
 718      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 719      * declared class, this method returns {@code true} if the specified
 720      * {@code Object} argument is an instance of the represented class (or
 721      * of any of its subclasses); it returns {@code false} otherwise. If
 722      * this {@code Class} object represents an array class, this method
 723      * returns {@code true} if the specified {@code Object} argument
 724      * can be converted to an object of the array class by an identity
 725      * conversion or by a widening reference conversion; it returns
 726      * {@code false} otherwise. If this {@code Class} object
 727      * represents an interface, this method returns {@code true} if the
 728      * class or any superclass of the specified {@code Object} argument
 729      * implements this interface; it returns {@code false} otherwise. If
 730      * this {@code Class} object represents a primitive type, this method
 731      * returns {@code false}.
 732      *
 733      * @param   obj the object to check
 734      * @return  true if {@code obj} is an instance of this class
 735      *
 736      * @since 1.1
 737      */
 738     @HotSpotIntrinsicCandidate
 739     public native boolean isInstance(Object obj);
 740 
 741 
 742     /**
 743      * Determines if the class or interface represented by this
 744      * {@code Class} object is either the same as, or is a superclass or
 745      * superinterface of, the class or interface represented by the specified
 746      * {@code Class} parameter. It returns {@code true} if so;
 747      * otherwise it returns {@code false}. If this {@code Class}
 748      * object represents a primitive type, this method returns
 749      * {@code true} if the specified {@code Class} parameter is
 750      * exactly this {@code Class} object; otherwise it returns
 751      * {@code false}.
 752      *
 753      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 754      * specified {@code Class} parameter can be converted to the type
 755      * represented by this {@code Class} object via an identity conversion
 756      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 757      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 758      * for details.
 759      *
 760      * @param     cls the {@code Class} object to be checked
 761      * @return    the {@code boolean} value indicating whether objects of the
 762      *            type {@code cls} can be assigned to objects of this class
 763      * @throws    NullPointerException if the specified Class parameter is
 764      *            null.
 765      * @since     1.1
 766      */
 767     @HotSpotIntrinsicCandidate
 768     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 769 
 770 
 771     /**
 772      * Determines if this {@code Class} object represents an
 773      * interface type.
 774      *
 775      * @return  {@code true} if this {@code Class} object represents an interface;
 776      *          {@code false} otherwise.
 777      */
 778     @HotSpotIntrinsicCandidate
 779     public native boolean isInterface();
 780 
 781 
 782     /**
 783      * Determines if this {@code Class} object represents an array class.
 784      *
 785      * @return  {@code true} if this {@code Class} object represents an array class;
 786      *          {@code false} otherwise.
 787      * @since   1.1
 788      */
 789     @HotSpotIntrinsicCandidate
 790     public native boolean isArray();
 791 
 792 
 793     /**
 794      * Determines if the specified {@code Class} object represents a
 795      * primitive type.
 796      *
 797      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 798      * the eight primitive types and void.  These are created by the Java
 799      * Virtual Machine, and have the same names as the primitive types that
 800      * they represent, namely {@code boolean}, {@code byte},
 801      * {@code char}, {@code short}, {@code int},
 802      * {@code long}, {@code float}, and {@code double}.
 803      *
 804      * &lt;p&gt; These objects may only be accessed via the following public static
 805      * final variables, and are the only {@code Class} objects for which
 806      * this method returns {@code true}.
 807      *
 808      * @return true if and only if this class represents a primitive type
 809      *
 810      * @see     java.lang.Boolean#TYPE
 811      * @see     java.lang.Character#TYPE
 812      * @see     java.lang.Byte#TYPE
 813      * @see     java.lang.Short#TYPE
 814      * @see     java.lang.Integer#TYPE
 815      * @see     java.lang.Long#TYPE
 816      * @see     java.lang.Float#TYPE
 817      * @see     java.lang.Double#TYPE
 818      * @see     java.lang.Void#TYPE
 819      * @since 1.1
 820      */
 821     @HotSpotIntrinsicCandidate
 822     public native boolean isPrimitive();
 823 
 824     /**
 825      * Returns true if this {@code Class} object represents an annotation
 826      * type.  Note that if this method returns true, {@link #isInterface()}
 827      * would also return true, as all annotation types are also interfaces.
 828      *
 829      * @return {@code true} if this {@code Class} object represents an annotation
 830      *      type; {@code false} otherwise
 831      * @since 1.5
 832      */
 833     public boolean isAnnotation() {
 834         return (getModifiers() &amp; ANNOTATION) != 0;
 835     }
 836 
 837     /**
 838      * Returns {@code true} if and only if this class has the synthetic modifier
 839      * bit set.
 840      *
 841      * @return {@code true} if and only if this class has the synthetic modifier bit set
 842      * @jls 13.1 The Form of a Binary
 843      * @jvms 4.1 The {@code ClassFile} Structure
 844      * @since 1.5
 845      */
 846     public boolean isSynthetic() {
 847         return (getModifiers() &amp; SYNTHETIC) != 0;
 848     }
 849 
 850     /**
 851      * Returns the  name of the entity (class, interface, array class,
 852      * primitive type, or void) represented by this {@code Class} object.
 853      *
 854      * &lt;p&gt; If this {@code Class} object represents a class or interface,
 855      * not an array class, then:
 856      * &lt;ul&gt;
 857      * &lt;li&gt; If the class or interface is not {@linkplain #isHidden() hidden},
 858      *      then the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 859      *      of the class or interface is returned.
 860      * &lt;li&gt; If the class or interface is hidden, then the result is a string
 861      *      of the form: {@code N + &#39;/&#39; + &lt;suffix&gt;}
 862      *      where {@code N} is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 863      *      indicated by the {@code class} file passed to
 864      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 865      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
 866      * &lt;/ul&gt;
 867      *
 868      * &lt;p&gt; If this {@code Class} object represents an array class, then
 869      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
 870      * representing the depth of the array nesting, followed by the element
 871      * type as encoded using the following table:
 872      *
 873      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 874      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 875      * &lt;thead&gt;
 876      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 877      * &lt;/thead&gt;
 878      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}
 880      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}
 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}
 882      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
 883      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}
<a name="6" id="anc6"></a><span class="line-added"> 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class} with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-added"> 885      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code Q}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
 886      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}
 887      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}
 888      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}
 889      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}
 890      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}
 891      * &lt;/tbody&gt;
 892      * &lt;/table&gt;&lt;/blockquote&gt;
 893      *
 894      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},
 895      * then the result is a string with the same spelling as the Java language
 896      * keyword which corresponds to the primitive type or {@code void}.
 897      *
 898      * &lt;p&gt; Examples:
 899      * &lt;blockquote&gt;&lt;pre&gt;
 900      * String.class.getName()
 901      *     returns &quot;java.lang.String&quot;
 902      * byte.class.getName()
 903      *     returns &quot;byte&quot;
<a name="7" id="anc7"></a><span class="line-added"> 904      * Point.class.getName()</span>
<span class="line-added"> 905      *     returns &quot;Point&quot;</span>
 906      * (new Object[3]).getClass().getName()
 907      *     returns &quot;[Ljava.lang.Object;&quot;
<a name="8" id="anc8"></a><span class="line-added"> 908      * (new Point[3]).getClass().getName()</span>
<span class="line-added"> 909      *     returns &quot;[QPoint;&quot;</span>
<span class="line-added"> 910      * (new Point.ref[3][4]).getClass().getName()</span>
<span class="line-added"> 911      *     returns &quot;[[LPoint$ref;&quot;</span>
 912      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 913      *     returns &quot;[[[[[[[I&quot;
 914      * &lt;/pre&gt;&lt;/blockquote&gt;
 915      *
 916      * @return  the name of the class, interface, or other entity
 917      *          represented by this {@code Class} object.
 918      * @jls 13.1 The Form of a Binary
 919      */
 920     public String getName() {
 921         String name = this.name;
 922         return name != null ? name : initClassName();
 923     }
 924 
 925     // Cache the name to reduce the number of calls into the VM.
 926     // This field would be set by VM itself during initClassName call.
 927     private transient String name;
 928     private native String initClassName();
 929 
 930     /**
 931      * Returns the class loader for the class.  Some implementations may use
 932      * null to represent the bootstrap class loader. This method will return
 933      * null in such implementations if this class was loaded by the bootstrap
 934      * class loader.
 935      *
 936      * &lt;p&gt;If this {@code Class} object
 937      * represents a primitive type or void, null is returned.
 938      *
 939      * @return  the class loader that loaded the class or interface
 940      *          represented by this {@code Class} object.
 941      * @throws  SecurityException
 942      *          if a security manager is present, and the caller&#39;s class loader
 943      *          is not {@code null} and is not the same as or an ancestor of the
 944      *          class loader for the class whose class loader is requested,
 945      *          and the caller does not have the
 946      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 947      * @see java.lang.ClassLoader
 948      * @see SecurityManager#checkPermission
 949      * @see java.lang.RuntimePermission
 950      */
 951     @CallerSensitive
 952     @ForceInline // to ensure Reflection.getCallerClass optimization
 953     public ClassLoader getClassLoader() {
 954         ClassLoader cl = getClassLoader0();
 955         if (cl == null)
 956             return null;
 957         SecurityManager sm = System.getSecurityManager();
 958         if (sm != null) {
 959             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 960         }
 961         return cl;
 962     }
 963 
 964     // Package-private to allow ClassLoader access
 965     ClassLoader getClassLoader0() { return classLoader; }
 966 
 967     /**
 968      * Returns the module that this class or interface is a member of.
 969      *
 970      * If this class represents an array type then this method returns the
 971      * {@code Module} for the element type. If this class represents a
 972      * primitive type or void, then the {@code Module} object for the
 973      * {@code java.base} module is returned.
 974      *
 975      * If this class is in an unnamed module then the {@linkplain
 976      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 977      * loader for this class is returned.
 978      *
 979      * @return the module that this class or interface is a member of
 980      *
 981      * @since 9
 982      * @spec JPMS
 983      */
 984     public Module getModule() {
 985         return module;
 986     }
 987 
 988     // set by VM
 989     private transient Module module;
 990 
 991     // Initialized in JVM not by private constructor
 992     // This field is filtered from reflection access, i.e. getDeclaredField
 993     // will throw NoSuchFieldException
 994     private final ClassLoader classLoader;
 995 
 996     // Set by VM
 997     private transient Object classData;
 998 
 999     // package-private
1000     Object getClassData() {
1001         return classData;
1002     }
1003 
1004     /**
1005      * Returns an array of {@code TypeVariable} objects that represent the
1006      * type variables declared by the generic declaration represented by this
1007      * {@code GenericDeclaration} object, in declaration order.  Returns an
1008      * array of length 0 if the underlying generic declaration declares no type
1009      * variables.
1010      *
1011      * @return an array of {@code TypeVariable} objects that represent
1012      *     the type variables declared by this generic declaration
1013      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1014      *     signature of this generic declaration does not conform to
1015      *     the format specified in section {@jvms 4.7.9} of
1016      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1017      * @since 1.5
1018      */
1019     @SuppressWarnings(&quot;unchecked&quot;)
1020     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1021         ClassRepository info = getGenericInfo();
1022         if (info != null)
1023             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1024         else
1025             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1026     }
1027 
1028 
1029     /**
1030      * Returns the {@code Class} representing the direct superclass of the
1031      * entity (class, interface, primitive type or void) represented by
1032      * this {@code Class}.  If this {@code Class} represents either the
1033      * {@code Object} class, an interface, a primitive type, or void, then
1034      * null is returned.  If this {@code Class} object represents an array class
1035      * then the {@code Class} object representing the {@code Object} class is
1036      * returned.
1037      *
1038      * @return the direct superclass of the class represented by this {@code Class} object
1039      */
1040     @HotSpotIntrinsicCandidate
1041     public native Class&lt;? super T&gt; getSuperclass();
1042 
1043 
1044     /**
1045      * Returns the {@code Type} representing the direct superclass of
1046      * the entity (class, interface, primitive type or void) represented by
1047      * this {@code Class} object.
1048      *
1049      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1050      * object returned must accurately reflect the actual type
1051      * arguments used in the source code. The parameterized type
1052      * representing the superclass is created if it had not been
1053      * created before. See the declaration of {@link
1054      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1055      * semantics of the creation process for parameterized types.  If
1056      * this {@code Class} object represents either the {@code Object}
1057      * class, an interface, a primitive type, or void, then null is
1058      * returned.  If this {@code Class} object represents an array class
1059      * then the {@code Class} object representing the {@code Object} class is
1060      * returned.
1061      *
1062      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1063      *     class signature does not conform to the format specified in
1064      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1065      *     Machine Specification&lt;/cite&gt;
1066      * @throws TypeNotPresentException if the generic superclass
1067      *     refers to a non-existent type declaration
1068      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1069      *     generic superclass refers to a parameterized type that cannot be
1070      *     instantiated  for any reason
1071      * @return the direct superclass of the class represented by this {@code Class} object
1072      * @since 1.5
1073      */
1074     public Type getGenericSuperclass() {
1075         ClassRepository info = getGenericInfo();
1076         if (info == null) {
1077             return getSuperclass();
1078         }
1079 
1080         // Historical irregularity:
1081         // Generic signature marks interfaces with superclass = Object
1082         // but this API returns null for interfaces
1083         if (isInterface()) {
1084             return null;
1085         }
1086 
1087         return info.getSuperclass();
1088     }
1089 
1090     /**
1091      * Gets the package of this class.
1092      *
1093      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1094      * this method returns {@code null}.
1095      *
1096      * @return the package of this class.
1097      * @revised 9
1098      * @spec JPMS
1099      */
1100     public Package getPackage() {
1101         if (isPrimitive() || isArray()) {
1102             return null;
1103         }
1104         ClassLoader cl = getClassLoader0();
1105         return cl != null ? cl.definePackage(this)
1106                           : BootLoader.definePackage(this);
1107     }
1108 
1109     /**
1110      * Returns the fully qualified package name.
1111      *
1112      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1113      * qualified name of the package that the class is a member of, or the
1114      * empty string if the class is in an unnamed package.
1115      *
1116      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1117      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1118      * enclosing class}.
1119      *
1120      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1121      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1122      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1123      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1124      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1125      *
1126      * &lt;p&gt; If this class represents an array type then this method returns the
1127      * package name of the element type. If this class represents a primitive
1128      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1129      *
1130      * @return the fully qualified package name
1131      *
1132      * @since 9
1133      * @spec JPMS
1134      * @jls 6.7 Fully Qualified Names
1135      */
1136     public String getPackageName() {
1137         String pn = this.packageName;
1138         if (pn == null) {
1139             Class&lt;?&gt; c = isArray() ? elementType() : this;
1140             if (c.isPrimitive()) {
1141                 pn = &quot;java.lang&quot;;
1142             } else {
1143                 String cn = c.getName();
1144                 int dot = cn.lastIndexOf(&#39;.&#39;);
1145                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1146             }
1147             this.packageName = pn;
1148         }
1149         return pn;
1150     }
1151 
1152     // cached package name
1153     private transient String packageName;
1154 
1155     /**
1156      * Returns the interfaces directly implemented by the class or interface
1157      * represented by this {@code Class} object.
1158      *
1159      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1160      * containing objects representing all interfaces directly implemented by
1161      * the class.  The order of the interface objects in the array corresponds
1162      * to the order of the interface names in the {@code implements} clause of
1163      * the declaration of the class represented by this {@code Class} object.  For example,
1164      * given the declaration:
1165      * &lt;blockquote&gt;
1166      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1167      * &lt;/blockquote&gt;
1168      * suppose the value of {@code s} is an instance of
1169      * {@code Shimmer}; the value of the expression:
1170      * &lt;blockquote&gt;
1171      * {@code s.getClass().getInterfaces()[0]}
1172      * &lt;/blockquote&gt;
1173      * is the {@code Class} object that represents interface
1174      * {@code FloorWax}; and the value of:
1175      * &lt;blockquote&gt;
1176      * {@code s.getClass().getInterfaces()[1]}
1177      * &lt;/blockquote&gt;
1178      * is the {@code Class} object that represents interface
1179      * {@code DessertTopping}.
1180      *
1181      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1182      * representing all interfaces directly extended by the interface.  The
1183      * order of the interface objects in the array corresponds to the order of
1184      * the interface names in the {@code extends} clause of the declaration of
1185      * the interface represented by this {@code Class} object.
1186      *
1187      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1188      * interfaces, the method returns an array of length 0.
1189      *
1190      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1191      * returns an array of length 0.
1192      *
1193      * &lt;p&gt;If this {@code Class} object represents an array type, the
1194      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1195      * returned in that order.
1196      *
1197      * @return an array of interfaces directly implemented by this class
1198      */
1199     public Class&lt;?&gt;[] getInterfaces() {
1200         // defensively copy before handing over to user code
1201         return getInterfaces(true);
1202     }
1203 
1204     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1205         ReflectionData&lt;T&gt; rd = reflectionData();
1206         if (rd == null) {
1207             // no cloning required
1208             return getInterfaces0();
1209         } else {
1210             Class&lt;?&gt;[] interfaces = rd.interfaces;
1211             if (interfaces == null) {
1212                 interfaces = getInterfaces0();
1213                 rd.interfaces = interfaces;
1214             }
1215             // defensively copy if requested
1216             return cloneArray ? interfaces.clone() : interfaces;
1217         }
1218     }
1219 
1220     private native Class&lt;?&gt;[] getInterfaces0();
1221 
1222     /**
1223      * Returns the {@code Type}s representing the interfaces
1224      * directly implemented by the class or interface represented by
1225      * this {@code Class} object.
1226      *
1227      * &lt;p&gt;If a superinterface is a parameterized type, the
1228      * {@code Type} object returned for it must accurately reflect
1229      * the actual type arguments used in the source code. The
1230      * parameterized type representing each superinterface is created
1231      * if it had not been created before. See the declaration of
1232      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1233      * for the semantics of the creation process for parameterized
1234      * types.
1235      *
1236      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1237      * containing objects representing all interfaces directly implemented by
1238      * the class.  The order of the interface objects in the array corresponds
1239      * to the order of the interface names in the {@code implements} clause of
1240      * the declaration of the class represented by this {@code Class} object.
1241      *
1242      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1243      * representing all interfaces directly extended by the interface.  The
1244      * order of the interface objects in the array corresponds to the order of
1245      * the interface names in the {@code extends} clause of the declaration of
1246      * the interface represented by this {@code Class} object.
1247      *
1248      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1249      * interfaces, the method returns an array of length 0.
1250      *
1251      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1252      * returns an array of length 0.
1253      *
1254      * &lt;p&gt;If this {@code Class} object represents an array type, the
1255      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1256      * returned in that order.
1257      *
1258      * @throws java.lang.reflect.GenericSignatureFormatError
1259      *     if the generic class signature does not conform to the
1260      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1261      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1262      * @throws TypeNotPresentException if any of the generic
1263      *     superinterfaces refers to a non-existent type declaration
1264      * @throws java.lang.reflect.MalformedParameterizedTypeException
1265      *     if any of the generic superinterfaces refer to a parameterized
1266      *     type that cannot be instantiated for any reason
1267      * @return an array of interfaces directly implemented by this class
1268      * @since 1.5
1269      */
1270     public Type[] getGenericInterfaces() {
1271         ClassRepository info = getGenericInfo();
1272         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1273     }
1274 
1275 
1276     /**
1277      * Returns the {@code Class} representing the component type of an
1278      * array.  If this class does not represent an array class this method
1279      * returns null.
1280      *
1281      * @return the {@code Class} representing the component type of this
1282      * class if this class is an array
1283      * @see     java.lang.reflect.Array
1284      * @since 1.1
1285      */
1286     public Class&lt;?&gt; getComponentType() {
1287         // Only return for array types. Storage may be reused for Class for instance types.
1288         if (isArray()) {
1289             return componentType;
1290         } else {
1291             return null;
1292         }
1293     }
1294 
1295     private final Class&lt;?&gt; componentType;
1296 
1297     /*
1298      * Returns the {@code Class} representing the element type of an array class.
1299      * If this class does not represent an array class, then this method returns
1300      * {@code null}.
1301      */
1302     private Class&lt;?&gt; elementType() {
1303         if (!isArray()) return null;
1304 
1305         Class&lt;?&gt; c = this;
1306         while (c.isArray()) {
1307             c = c.getComponentType();
1308         }
1309         return c;
1310     }
1311 
1312     /**
1313      * Returns the Java language modifiers for this class or interface, encoded
1314      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1315      * constants for {@code public}, {@code protected},
1316      * {@code private}, {@code final}, {@code static},
1317      * {@code abstract} and {@code interface}; they should be decoded
1318      * using the methods of class {@code Modifier}.
1319      *
1320      * &lt;p&gt; If the underlying class is an array class, then its
1321      * {@code public}, {@code private} and {@code protected}
1322      * modifiers are the same as those of its component type.  If this
1323      * {@code Class} object represents a primitive type or void, its
1324      * {@code public} modifier is always {@code true}, and its
1325      * {@code protected} and {@code private} modifiers are always
1326      * {@code false}. If this {@code Class} object represents an array class, a
1327      * primitive type or void, then its {@code final} modifier is always
1328      * {@code true} and its interface modifier is always
1329      * {@code false}. The values of its other modifiers are not determined
1330      * by this specification.
1331      *
1332      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1333      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1334      *
1335      * @return the {@code int} representing the modifiers for this class
1336      * @see     java.lang.reflect.Modifier
1337      * @since 1.1
1338      */
1339     @HotSpotIntrinsicCandidate
1340     public native int getModifiers();
1341 
<a name="9" id="anc9"></a>
1342     /**
1343      * Gets the signers of this class.
1344      *
1345      * @return  the signers of this class, or null if there are no signers.  In
1346      *          particular, this method returns null if this {@code Class} object represents
1347      *          a primitive type or void.
1348      * @since   1.1
1349      */
1350     public native Object[] getSigners();
1351 
<a name="10" id="anc10"></a>
1352     /**
1353      * Set the signers of this class.
1354      */
1355     native void setSigners(Object[] signers);
1356 
1357 
1358     /**
1359      * If this {@code Class} object represents a local or anonymous
1360      * class within a method, returns a {@link
1361      * java.lang.reflect.Method Method} object representing the
1362      * immediately enclosing method of the underlying class. Returns
1363      * {@code null} otherwise.
1364      *
1365      * In particular, this method returns {@code null} if the underlying
1366      * class is a local or anonymous class immediately enclosed by a type
1367      * declaration, instance initializer or static initializer.
1368      *
1369      * @return the immediately enclosing method of the underlying class, if
1370      *     that class is a local or anonymous class; otherwise {@code null}.
1371      *
1372      * @throws SecurityException
1373      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1374      *         following conditions is met:
1375      *
1376      *         &lt;ul&gt;
1377      *
1378      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1379      *         class loader of the enclosing class and invocation of
1380      *         {@link SecurityManager#checkPermission
1381      *         s.checkPermission} method with
1382      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1383      *         denies access to the methods within the enclosing class
1384      *
1385      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1386      *         ancestor of the class loader for the enclosing class and
1387      *         invocation of {@link SecurityManager#checkPackageAccess
1388      *         s.checkPackageAccess()} denies access to the package
1389      *         of the enclosing class
1390      *
1391      *         &lt;/ul&gt;
1392      * @since 1.5
1393      */
1394     @CallerSensitive
1395     public Method getEnclosingMethod() throws SecurityException {
1396         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1397 
1398         if (enclosingInfo == null)
1399             return null;
1400         else {
1401             if (!enclosingInfo.isMethod())
1402                 return null;
1403 
1404             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1405                                                               getFactory());
1406             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1407             Type []    parameterTypes   = typeInfo.getParameterTypes();
1408             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1409 
1410             // Convert Types to Classes; returned types *should*
1411             // be class objects since the methodDescriptor&#39;s used
1412             // don&#39;t have generics information
1413             for(int i = 0; i &lt; parameterClasses.length; i++)
1414                 parameterClasses[i] = toClass(parameterTypes[i]);
1415 
1416             // Perform access check
1417             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1418             SecurityManager sm = System.getSecurityManager();
1419             if (sm != null) {
1420                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1421                                                      Reflection.getCallerClass(), true);
1422             }
1423             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1424 
1425             /*
1426              * Loop over all declared methods; match method name,
1427              * number of and type of parameters, *and* return
1428              * type.  Matching return type is also necessary
1429              * because of covariant returns, etc.
1430              */
1431             ReflectionFactory fact = getReflectionFactory();
1432             for (Method m : candidates) {
1433                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1434                     arrayContentsEq(parameterClasses,
1435                                     fact.getExecutableSharedParameterTypes(m))) {
1436                     // finally, check return type
1437                     if (m.getReturnType().equals(returnType)) {
1438                         return fact.copyMethod(m);
1439                     }
1440                 }
1441             }
1442 
1443             throw new InternalError(&quot;Enclosing method not found&quot;);
1444         }
1445     }
1446 
1447     private native Object[] getEnclosingMethod0();
1448 
1449     private EnclosingMethodInfo getEnclosingMethodInfo() {
1450         Object[] enclosingInfo = getEnclosingMethod0();
1451         if (enclosingInfo == null)
1452             return null;
1453         else {
1454             return new EnclosingMethodInfo(enclosingInfo);
1455         }
1456     }
1457 
1458     private static final class EnclosingMethodInfo {
1459         private final Class&lt;?&gt; enclosingClass;
1460         private final String name;
1461         private final String descriptor;
1462 
1463         static void validate(Object[] enclosingInfo) {
1464             if (enclosingInfo.length != 3)
1465                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1466             try {
1467                 // The array is expected to have three elements:
1468 
1469                 // the immediately enclosing class
1470                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1471                 assert(enclosingClass != null);
1472 
1473                 // the immediately enclosing method or constructor&#39;s
1474                 // name (can be null).
1475                 String name = (String)enclosingInfo[1];
1476 
1477                 // the immediately enclosing method or constructor&#39;s
1478                 // descriptor (null iff name is).
1479                 String descriptor = (String)enclosingInfo[2];
1480                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1481             } catch (ClassCastException cce) {
1482                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1483             }
1484         }
1485 
1486         EnclosingMethodInfo(Object[] enclosingInfo) {
1487             validate(enclosingInfo);
1488             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1489             this.name = (String)enclosingInfo[1];
1490             this.descriptor = (String)enclosingInfo[2];
1491         }
1492 
1493         boolean isPartial() {
1494             return enclosingClass == null || name == null || descriptor == null;
1495         }
1496 
1497         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1498 
1499         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1500 
1501         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1502 
1503         String getName() { return name; }
1504 
1505         String getDescriptor() { return descriptor; }
1506 
1507     }
1508 
1509     private static Class&lt;?&gt; toClass(Type o) {
1510         if (o instanceof GenericArrayType)
1511             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1512                                      0)
1513                 .getClass();
1514         return (Class&lt;?&gt;)o;
1515      }
1516 
1517     /**
1518      * If this {@code Class} object represents a local or anonymous
1519      * class within a constructor, returns a {@link
1520      * java.lang.reflect.Constructor Constructor} object representing
1521      * the immediately enclosing constructor of the underlying
1522      * class. Returns {@code null} otherwise.  In particular, this
1523      * method returns {@code null} if the underlying class is a local
1524      * or anonymous class immediately enclosed by a type declaration,
1525      * instance initializer or static initializer.
1526      *
1527      * @return the immediately enclosing constructor of the underlying class, if
1528      *     that class is a local or anonymous class; otherwise {@code null}.
1529      * @throws SecurityException
1530      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1531      *         following conditions is met:
1532      *
1533      *         &lt;ul&gt;
1534      *
1535      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1536      *         class loader of the enclosing class and invocation of
1537      *         {@link SecurityManager#checkPermission
1538      *         s.checkPermission} method with
1539      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1540      *         denies access to the constructors within the enclosing class
1541      *
1542      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1543      *         ancestor of the class loader for the enclosing class and
1544      *         invocation of {@link SecurityManager#checkPackageAccess
1545      *         s.checkPackageAccess()} denies access to the package
1546      *         of the enclosing class
1547      *
1548      *         &lt;/ul&gt;
1549      * @since 1.5
1550      */
1551     @CallerSensitive
1552     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1553         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1554 
1555         if (enclosingInfo == null)
1556             return null;
1557         else {
1558             if (!enclosingInfo.isConstructor())
1559                 return null;
1560 
1561             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1562                                                                         getFactory());
1563             Type []    parameterTypes   = typeInfo.getParameterTypes();
1564             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1565 
1566             // Convert Types to Classes; returned types *should*
1567             // be class objects since the methodDescriptor&#39;s used
1568             // don&#39;t have generics information
1569             for(int i = 0; i &lt; parameterClasses.length; i++)
1570                 parameterClasses[i] = toClass(parameterTypes[i]);
1571 
1572             // Perform access check
1573             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1574             SecurityManager sm = System.getSecurityManager();
1575             if (sm != null) {
1576                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1577                                                      Reflection.getCallerClass(), true);
1578             }
1579 
1580             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1581                     .privateGetDeclaredConstructors(false);
1582             /*
1583              * Loop over all declared constructors; match number
1584              * of and type of parameters.
1585              */
1586             ReflectionFactory fact = getReflectionFactory();
1587             for (Constructor&lt;?&gt; c : candidates) {
1588                 if (arrayContentsEq(parameterClasses,
1589                                     fact.getExecutableSharedParameterTypes(c))) {
1590                     return fact.copyConstructor(c);
1591                 }
1592             }
1593 
1594             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1595         }
1596     }
1597 
1598 
1599     /**
1600      * If the class or interface represented by this {@code Class} object
1601      * is a member of another class, returns the {@code Class} object
1602      * representing the class in which it was declared.  This method returns
1603      * null if this class or interface is not a member of any other class.  If
1604      * this {@code Class} object represents an array class, a primitive
1605      * type, or void,then this method returns null.
1606      *
1607      * @return the declaring class for this class
1608      * @throws SecurityException
1609      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1610      *         class loader is not the same as or an ancestor of the class
1611      *         loader for the declaring class and invocation of {@link
1612      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1613      *         denies access to the package of the declaring class
1614      * @since 1.1
1615      */
1616     @CallerSensitive
1617     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1618         final Class&lt;?&gt; candidate = getDeclaringClass0();
1619 
1620         if (candidate != null) {
1621             SecurityManager sm = System.getSecurityManager();
1622             if (sm != null) {
1623                 candidate.checkPackageAccess(sm,
1624                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1625             }
1626         }
1627         return candidate;
1628     }
1629 
1630     private native Class&lt;?&gt; getDeclaringClass0();
1631 
1632 
1633     /**
1634      * Returns the immediately enclosing class of the underlying
1635      * class.  If the underlying class is a top level class this
1636      * method returns {@code null}.
1637      * @return the immediately enclosing class of the underlying class
1638      * @throws     SecurityException
1639      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1640      *             class loader is not the same as or an ancestor of the class
1641      *             loader for the enclosing class and invocation of {@link
1642      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1643      *             denies access to the package of the enclosing class
1644      * @since 1.5
1645      */
1646     @CallerSensitive
1647     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1648         // There are five kinds of classes (or interfaces):
1649         // a) Top level classes
1650         // b) Nested classes (static member classes)
1651         // c) Inner classes (non-static member classes)
1652         // d) Local classes (named classes declared within a method)
1653         // e) Anonymous classes
1654 
1655 
1656         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1657         // attribute if and only if it is a local class or an
1658         // anonymous class.
1659         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1660         Class&lt;?&gt; enclosingCandidate;
1661 
1662         if (enclosingInfo == null) {
1663             // This is a top level or a nested class or an inner class (a, b, or c)
1664             enclosingCandidate = getDeclaringClass0();
1665         } else {
1666             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1667             // This is a local class or an anonymous class (d or e)
1668             if (enclosingClass == this || enclosingClass == null)
1669                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1670             else
1671                 enclosingCandidate = enclosingClass;
1672         }
1673 
1674         if (enclosingCandidate != null) {
1675             SecurityManager sm = System.getSecurityManager();
1676             if (sm != null) {
1677                 enclosingCandidate.checkPackageAccess(sm,
1678                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1679             }
1680         }
1681         return enclosingCandidate;
1682     }
1683 
1684     /**
1685      * Returns the simple name of the underlying class as given in the
1686      * source code. Returns an empty string if the underlying class is
1687      * anonymous.
1688      *
1689      * &lt;p&gt;The simple name of an array is the simple name of the
1690      * component type with &quot;[]&quot; appended.  In particular the simple
1691      * name of an array whose component type is anonymous is &quot;[]&quot;.
1692      *
1693      * @return the simple name of the underlying class
1694      * @since 1.5
1695      */
1696     public String getSimpleName() {
1697         ReflectionData&lt;T&gt; rd = reflectionData();
1698         String simpleName = rd.simpleName;
1699         if (simpleName == null) {
1700             rd.simpleName = simpleName = getSimpleName0();
1701         }
1702         return simpleName;
1703     }
1704 
1705     private String getSimpleName0() {
1706         if (isArray()) {
1707             return getComponentType().getSimpleName() + &quot;[]&quot;;
1708         }
1709         String simpleName = getSimpleBinaryName();
1710         if (simpleName == null) { // top level class
1711             simpleName = getName();
1712             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1713         }
1714         return simpleName;
1715     }
1716 
1717     /**
1718      * Return an informative string for the name of this type.
1719      *
1720      * @return an informative string for the name of this type
1721      * @since 1.8
1722      */
1723     public String getTypeName() {
1724         if (isArray()) {
1725             try {
1726                 Class&lt;?&gt; cl = this;
1727                 int dimensions = 0;
1728                 do {
1729                     dimensions++;
1730                     cl = cl.getComponentType();
1731                 } while (cl.isArray());
<a name="11" id="anc11"></a><span class="line-modified">1732                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);</span>
1733             } catch (Throwable e) { /*FALLTHRU*/ }
1734         }
1735         return getName();
1736     }
1737 
1738     /**
1739      * Returns the canonical name of the underlying class as
1740      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1741      * Returns {@code null} if the underlying class does not have a canonical
1742      * name. Classes without canonical names include:
1743      * &lt;ul&gt;
1744      * &lt;li&gt;a {@linkplain #isLocalClass() local class}
1745      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}
1746      * &lt;li&gt;a {@linkplain #isHidden() hidden class}
1747      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;
1748      * &lt;/ul&gt;
1749      *
1750      * @return the canonical name of the underlying class if it exists, and
1751      * {@code null} otherwise.
1752      * @since 1.5
1753      */
1754     public String getCanonicalName() {
1755         ReflectionData&lt;T&gt; rd = reflectionData();
1756         String canonicalName = rd.canonicalName;
1757         if (canonicalName == null) {
1758             rd.canonicalName = canonicalName = getCanonicalName0();
1759         }
1760         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1761     }
1762 
1763     private String getCanonicalName0() {
1764         if (isArray()) {
1765             String canonicalName = getComponentType().getCanonicalName();
1766             if (canonicalName != null)
1767                 return canonicalName + &quot;[]&quot;;
1768             else
1769                 return ReflectionData.NULL_SENTINEL;
1770         }
1771         if (isHidden() || isLocalOrAnonymousClass())
1772             return ReflectionData.NULL_SENTINEL;
1773         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1774         if (enclosingClass == null) { // top level class
1775             return getName();
1776         } else {
1777             String enclosingName = enclosingClass.getCanonicalName();
1778             if (enclosingName == null)
1779                 return ReflectionData.NULL_SENTINEL;
1780             return enclosingName + &quot;.&quot; + getSimpleName();
1781         }
1782     }
1783 
1784     /**
1785      * Returns {@code true} if and only if the underlying class
1786      * is an anonymous class.
1787      *
1788      * @apiNote
1789      * An anonymous class is not a {@linkplain #isHidden() hidden class}.
1790      *
1791      * @return {@code true} if and only if this class is an anonymous class.
1792      * @since 1.5
1793      */
1794     public boolean isAnonymousClass() {
1795         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1796                 getSimpleBinaryName0() == null;
1797     }
1798 
1799     /**
1800      * Returns {@code true} if and only if the underlying class
1801      * is a local class.
1802      *
1803      * @return {@code true} if and only if this class is a local class.
1804      * @since 1.5
1805      */
1806     public boolean isLocalClass() {
1807         return isLocalOrAnonymousClass() &amp;&amp;
1808                 (isArray() || getSimpleBinaryName0() != null);
1809     }
1810 
1811     /**
1812      * Returns {@code true} if and only if the underlying class
1813      * is a member class.
1814      *
1815      * @return {@code true} if and only if this class is a member class.
1816      * @since 1.5
1817      */
1818     public boolean isMemberClass() {
1819         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1820     }
1821 
1822     /**
1823      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1824      * the binary name without the leading enclosing class name.
1825      * Returns {@code null} if the underlying class is a top level
1826      * class.
1827      */
1828     private String getSimpleBinaryName() {
1829         if (isTopLevelClass())
1830             return null;
1831         String name = getSimpleBinaryName0();
1832         if (name == null) // anonymous class
1833             return &quot;&quot;;
1834         return name;
1835     }
1836 
1837     private native String getSimpleBinaryName0();
1838 
1839     /**
1840      * Returns {@code true} if this is a top level class.  Returns {@code false}
1841      * otherwise.
1842      */
1843     private boolean isTopLevelClass() {
1844         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1845     }
1846 
1847     /**
1848      * Returns {@code true} if this is a local class or an anonymous
1849      * class.  Returns {@code false} otherwise.
1850      */
1851     private boolean isLocalOrAnonymousClass() {
1852         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1853         // attribute if and only if it is a local class or an
1854         // anonymous class.
1855         return hasEnclosingMethodInfo();
1856     }
1857 
1858     private boolean hasEnclosingMethodInfo() {
1859         Object[] enclosingInfo = getEnclosingMethod0();
1860         if (enclosingInfo != null) {
1861             EnclosingMethodInfo.validate(enclosingInfo);
1862             return true;
1863         }
1864         return false;
1865     }
1866 
1867     /**
1868      * Returns an array containing {@code Class} objects representing all
1869      * the public classes and interfaces that are members of the class
1870      * represented by this {@code Class} object.  This includes public
1871      * class and interface members inherited from superclasses and public class
1872      * and interface members declared by the class.  This method returns an
1873      * array of length 0 if this {@code Class} object has no public member
1874      * classes or interfaces.  This method also returns an array of length 0 if
1875      * this {@code Class} object represents a primitive type, an array
1876      * class, or void.
1877      *
1878      * @return the array of {@code Class} objects representing the public
1879      *         members of this class
1880      * @throws SecurityException
1881      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1882      *         the caller&#39;s class loader is not the same as or an
1883      *         ancestor of the class loader for the current class and
1884      *         invocation of {@link SecurityManager#checkPackageAccess
1885      *         s.checkPackageAccess()} denies access to the package
1886      *         of this class.
1887      *
1888      * @since 1.1
1889      */
1890     @CallerSensitive
1891     public Class&lt;?&gt;[] getClasses() {
1892         SecurityManager sm = System.getSecurityManager();
1893         if (sm != null) {
1894             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
1895         }
1896 
1897         // Privileged so this implementation can look at DECLARED classes,
1898         // something the caller might not have privilege to do.  The code here
1899         // is allowed to look at DECLARED classes because (1) it does not hand
1900         // out anything other than public members and (2) public member access
1901         // has already been ok&#39;d by the SecurityManager.
1902 
1903         return java.security.AccessController.doPrivileged(
1904             new java.security.PrivilegedAction&lt;&gt;() {
1905                 public Class&lt;?&gt;[] run() {
1906                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1907                     Class&lt;?&gt; currentClass = Class.this;
1908                     while (currentClass != null) {
1909                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
1910                             if (Modifier.isPublic(m.getModifiers())) {
1911                                 list.add(m);
1912                             }
1913                         }
1914                         currentClass = currentClass.getSuperclass();
1915                     }
1916                     return list.toArray(new Class&lt;?&gt;[0]);
1917                 }
1918             });
1919     }
1920 
1921 
1922     /**
1923      * Returns an array containing {@code Field} objects reflecting all
1924      * the accessible public fields of the class or interface represented by
1925      * this {@code Class} object.
1926      *
1927      * &lt;p&gt; If this {@code Class} object represents a class or interface with
1928      * no accessible public fields, then this method returns an array of length
1929      * 0.
1930      *
1931      * &lt;p&gt; If this {@code Class} object represents a class, then this method
1932      * returns the public fields of the class and of all its superclasses and
1933      * superinterfaces.
1934      *
1935      * &lt;p&gt; If this {@code Class} object represents an interface, then this
1936      * method returns the fields of the interface and of all its
1937      * superinterfaces.
1938      *
1939      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
1940      * type, or void, then this method returns an array of length 0.
1941      *
1942      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1943      * particular order.
1944      *
1945      * @return the array of {@code Field} objects representing the
1946      *         public fields
1947      * @throws SecurityException
1948      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1949      *         the caller&#39;s class loader is not the same as or an
1950      *         ancestor of the class loader for the current class and
1951      *         invocation of {@link SecurityManager#checkPackageAccess
1952      *         s.checkPackageAccess()} denies access to the package
1953      *         of this class.
1954      *
1955      * @since 1.1
1956      * @jls 8.2 Class Members
1957      * @jls 8.3 Field Declarations
1958      */
1959     @CallerSensitive
1960     public Field[] getFields() throws SecurityException {
1961         SecurityManager sm = System.getSecurityManager();
1962         if (sm != null) {
1963             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1964         }
1965         return copyFields(privateGetPublicFields());
1966     }
1967 
1968 
1969     /**
1970      * Returns an array containing {@code Method} objects reflecting all the
1971      * public methods of the class or interface represented by this {@code
1972      * Class} object, including those declared by the class or interface and
1973      * those inherited from superclasses and superinterfaces.
1974      *
1975      * &lt;p&gt; If this {@code Class} object represents an array type, then the
1976      * returned array has a {@code Method} object for each of the public
1977      * methods inherited by the array type from {@code Object}. It does not
1978      * contain a {@code Method} object for {@code clone()}.
1979      *
1980      * &lt;p&gt; If this {@code Class} object represents an interface then the
1981      * returned array does not contain any implicitly declared methods from
1982      * {@code Object}. Therefore, if no methods are explicitly declared in
1983      * this interface or any of its superinterfaces then the returned array
1984      * has length 0. (Note that a {@code Class} object which represents a class
1985      * always has public methods, inherited from {@code Object}.)
1986      *
1987      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
1988      * or &quot;{@code &lt;clinit&gt;}&quot;.
1989      *
1990      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1991      * particular order.
1992      *
1993      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
1994      * Let C be the class or interface represented by this {@code Class} object:
1995      * &lt;ol&gt;
1996      * &lt;li&gt; A union of methods is composed of:
1997      *   &lt;ol type=&quot;a&quot;&gt;
1998      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
1999      *        {@link #getDeclaredMethods()} and filtered to include only public
2000      *        methods.&lt;/li&gt;
2001      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2002      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2003      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2004      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2005      *   &lt;/ol&gt;&lt;/li&gt;
2006      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
2007      *      signature (name, parameter types) and return type.&lt;/li&gt;
2008      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2009      *      Let method M be a method from a set of methods with same signature
2010      *      and return type. M is most specific if there is no such method
2011      *      N != M from the same set, such that N is more specific than M.
2012      *      N is more specific than M if:
2013      *   &lt;ol type=&quot;a&quot;&gt;
2014      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2015      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2016      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2017      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2018      *        M and N are the same method).&lt;/li&gt;
2019      *   &lt;/ol&gt;&lt;/li&gt;
2020      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
2021      *      step 3.&lt;/li&gt;
2022      * &lt;/ol&gt;
2023      *
2024      * @apiNote There may be more than one method with a particular name
2025      * and parameter types in a class because while the Java language forbids a
2026      * class to declare multiple methods with the same signature but different
2027      * return types, the Java virtual machine does not.  This
2028      * increased flexibility in the virtual machine can be used to
2029      * implement various language features.  For example, covariant
2030      * returns can be implemented with {@linkplain
2031      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2032      * method and the overriding method would have the same
2033      * signature but different return types.
2034      *
2035      * @return the array of {@code Method} objects representing the
2036      *         public methods of this class
2037      * @throws SecurityException
2038      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2039      *         the caller&#39;s class loader is not the same as or an
2040      *         ancestor of the class loader for the current class and
2041      *         invocation of {@link SecurityManager#checkPackageAccess
2042      *         s.checkPackageAccess()} denies access to the package
2043      *         of this class.
2044      *
2045      * @jls 8.2 Class Members
2046      * @jls 8.4 Method Declarations
2047      * @since 1.1
2048      */
2049     @CallerSensitive
2050     public Method[] getMethods() throws SecurityException {
2051         SecurityManager sm = System.getSecurityManager();
2052         if (sm != null) {
2053             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2054         }
2055         return copyMethods(privateGetPublicMethods());
2056     }
2057 
2058 
2059     /**
2060      * Returns an array containing {@code Constructor} objects reflecting
2061      * all the public constructors of the class represented by this
2062      * {@code Class} object.  An array of length 0 is returned if the
2063      * class has no public constructors, or if the class is an array class, or
2064      * if the class reflects a primitive type or void.
2065      *
2066      * @apiNote
2067      * While this method returns an array of {@code
2068      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2069      * this class), the return type of this method is {@code
2070      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2071      * might be expected.  This less informative return type is
2072      * necessary since after being returned from this method, the
2073      * array could be modified to hold {@code Constructor} objects for
2074      * different classes, which would violate the type guarantees of
2075      * {@code Constructor&lt;T&gt;[]}.
2076      *
2077      * @return the array of {@code Constructor} objects representing the
2078      *         public constructors of this class
2079      * @throws SecurityException
2080      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2081      *         the caller&#39;s class loader is not the same as or an
2082      *         ancestor of the class loader for the current class and
2083      *         invocation of {@link SecurityManager#checkPackageAccess
2084      *         s.checkPackageAccess()} denies access to the package
2085      *         of this class.
2086      *
2087      * @since 1.1
2088      */
2089     @CallerSensitive
2090     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2091         SecurityManager sm = System.getSecurityManager();
2092         if (sm != null) {
2093             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2094         }
2095         return copyConstructors(privateGetDeclaredConstructors(true));
2096     }
2097 
2098 
2099     /**
2100      * Returns a {@code Field} object that reflects the specified public member
2101      * field of the class or interface represented by this {@code Class}
2102      * object. The {@code name} parameter is a {@code String} specifying the
2103      * simple name of the desired field.
2104      *
2105      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2106      * follows.  Let C be the class or interface represented by this {@code Class} object:
2107      *
2108      * &lt;OL&gt;
2109      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2110      *      field to be reflected.&lt;/LI&gt;
2111      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2112      *      recursively to each direct superinterface of C. The direct
2113      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2114      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2115      *      superclass S, then this algorithm is invoked recursively upon S.
2116      *      If C has no superclass, then a {@code NoSuchFieldException}
2117      *      is thrown.&lt;/LI&gt;
2118      * &lt;/OL&gt;
2119      *
2120      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2121      * method does not find the {@code length} field of the array type.
2122      *
2123      * @param name the field name
2124      * @return the {@code Field} object of this class specified by
2125      *         {@code name}
2126      * @throws NoSuchFieldException if a field with the specified name is
2127      *         not found.
2128      * @throws NullPointerException if {@code name} is {@code null}
2129      * @throws SecurityException
2130      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2131      *         the caller&#39;s class loader is not the same as or an
2132      *         ancestor of the class loader for the current class and
2133      *         invocation of {@link SecurityManager#checkPackageAccess
2134      *         s.checkPackageAccess()} denies access to the package
2135      *         of this class.
2136      *
2137      * @since 1.1
2138      * @jls 8.2 Class Members
2139      * @jls 8.3 Field Declarations
2140      */
2141     @CallerSensitive
2142     public Field getField(String name)
2143         throws NoSuchFieldException, SecurityException {
2144         Objects.requireNonNull(name);
2145         SecurityManager sm = System.getSecurityManager();
2146         if (sm != null) {
2147             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2148         }
2149         Field field = getField0(name);
2150         if (field == null) {
2151             throw new NoSuchFieldException(name);
2152         }
2153         return getReflectionFactory().copyField(field);
2154     }
2155 
2156 
2157     /**
2158      * Returns a {@code Method} object that reflects the specified public
2159      * member method of the class or interface represented by this
2160      * {@code Class} object. The {@code name} parameter is a
2161      * {@code String} specifying the simple name of the desired method. The
2162      * {@code parameterTypes} parameter is an array of {@code Class}
2163      * objects that identify the method&#39;s formal parameter types, in declared
2164      * order. If {@code parameterTypes} is {@code null}, it is
2165      * treated as if it were an empty array.
2166      *
2167      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2168      * method finds any public method inherited by the array type from
2169      * {@code Object} except method {@code clone()}.
2170      *
2171      * &lt;p&gt; If this {@code Class} object represents an interface then this
2172      * method does not find any implicitly declared method from
2173      * {@code Object}. Therefore, if no methods are explicitly declared in
2174      * this interface or any of its superinterfaces, then this method does not
2175      * find any method.
2176      *
2177      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2178      * &quot;{@code &lt;clinit&gt;}&quot;.
2179      *
2180      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2181      * algorithm that follows.
2182      * Let C be the class or interface represented by this {@code Class} object:
2183      * &lt;ol&gt;
2184      * &lt;li&gt; A union of methods is composed of:
2185      *   &lt;ol type=&quot;a&quot;&gt;
2186      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2187      *        {@link #getDeclaredMethods()} and filtered to include only public
2188      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2189      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2190      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2191      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2192      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2193      *   &lt;/ol&gt;&lt;/li&gt;
2194      * &lt;li&gt; This union is partitioned into subsets of methods with same
2195      *      return type (the selection of methods from step 1 also guarantees that
2196      *      they have the same method name and parameter types).&lt;/li&gt;
2197      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2198      *      Let method M be a method from a set of methods with same VM
2199      *      signature (return type, name, parameter types).
2200      *      M is most specific if there is no such method N != M from the same
2201      *      set, such that N is more specific than M. N is more specific than M
2202      *      if:
2203      *   &lt;ol type=&quot;a&quot;&gt;
2204      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2205      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2206      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2207      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2208      *        M and N are the same method).&lt;/li&gt;
2209      *   &lt;/ol&gt;&lt;/li&gt;
2210      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2211      *      with most specific return type among all selected methods from step 3.
2212      *      Let R be a return type of a method M from the set of all selected methods
2213      *      from step 3. M is a method with most specific return type if there is
2214      *      no such method N != M from the same set, having return type S != R,
2215      *      such that S is a subtype of R as determined by
2216      *      R.class.{@link #isAssignableFrom}(S.class).
2217      * &lt;/ol&gt;
2218      *
2219      * @apiNote There may be more than one method with matching name and
2220      * parameter types in a class because while the Java language forbids a
2221      * class to declare multiple methods with the same signature but different
2222      * return types, the Java virtual machine does not.  This
2223      * increased flexibility in the virtual machine can be used to
2224      * implement various language features.  For example, covariant
2225      * returns can be implemented with {@linkplain
2226      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2227      * method and the overriding method would have the same
2228      * signature but different return types. This method would return the
2229      * overriding method as it would have a more specific return type.
2230      *
2231      * @param name the name of the method
2232      * @param parameterTypes the list of parameters
2233      * @return the {@code Method} object that matches the specified
2234      *         {@code name} and {@code parameterTypes}
2235      * @throws NoSuchMethodException if a matching method is not found
2236      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2237      * @throws NullPointerException if {@code name} is {@code null}
2238      * @throws SecurityException
2239      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2240      *         the caller&#39;s class loader is not the same as or an
2241      *         ancestor of the class loader for the current class and
2242      *         invocation of {@link SecurityManager#checkPackageAccess
2243      *         s.checkPackageAccess()} denies access to the package
2244      *         of this class.
2245      *
2246      * @jls 8.2 Class Members
2247      * @jls 8.4 Method Declarations
2248      * @since 1.1
2249      */
2250     @CallerSensitive
2251     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2252         throws NoSuchMethodException, SecurityException {
2253         Objects.requireNonNull(name);
2254         SecurityManager sm = System.getSecurityManager();
2255         if (sm != null) {
2256             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2257         }
2258         Method method = getMethod0(name, parameterTypes);
2259         if (method == null) {
2260             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2261         }
2262         return getReflectionFactory().copyMethod(method);
2263     }
2264 
2265     /**
2266      * Returns a {@code Constructor} object that reflects the specified
2267      * public constructor of the class represented by this {@code Class}
2268      * object. The {@code parameterTypes} parameter is an array of
2269      * {@code Class} objects that identify the constructor&#39;s formal
2270      * parameter types, in declared order.
2271      *
2272      * If this {@code Class} object represents an inner class
2273      * declared in a non-static context, the formal parameter types
2274      * include the explicit enclosing instance as the first parameter.
2275      *
2276      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2277      * represented by this {@code Class} object whose formal parameter
2278      * types match those specified by {@code parameterTypes}.
2279      *
2280      * @param parameterTypes the parameter array
2281      * @return the {@code Constructor} object of the public constructor that
2282      *         matches the specified {@code parameterTypes}
2283      * @throws NoSuchMethodException if a matching method is not found.
2284      * @throws SecurityException
2285      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2286      *         the caller&#39;s class loader is not the same as or an
2287      *         ancestor of the class loader for the current class and
2288      *         invocation of {@link SecurityManager#checkPackageAccess
2289      *         s.checkPackageAccess()} denies access to the package
2290      *         of this class.
2291      *
2292      * @since 1.1
2293      */
2294     @CallerSensitive
2295     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2296         throws NoSuchMethodException, SecurityException
2297     {
2298         SecurityManager sm = System.getSecurityManager();
2299         if (sm != null) {
2300             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2301         }
2302         return getReflectionFactory().copyConstructor(
2303             getConstructor0(parameterTypes, Member.PUBLIC));
2304     }
2305 
2306 
2307     /**
2308      * Returns an array of {@code Class} objects reflecting all the
2309      * classes and interfaces declared as members of the class represented by
2310      * this {@code Class} object. This includes public, protected, default
2311      * (package) access, and private classes and interfaces declared by the
2312      * class, but excludes inherited classes and interfaces.  This method
2313      * returns an array of length 0 if the class declares no classes or
2314      * interfaces as members, or if this {@code Class} object represents a
2315      * primitive type, an array class, or void.
2316      *
2317      * @return the array of {@code Class} objects representing all the
2318      *         declared members of this class
2319      * @throws SecurityException
2320      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2321      *         following conditions is met:
2322      *
2323      *         &lt;ul&gt;
2324      *
2325      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2326      *         class loader of this class and invocation of
2327      *         {@link SecurityManager#checkPermission
2328      *         s.checkPermission} method with
2329      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2330      *         denies access to the declared classes within this class
2331      *
2332      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2333      *         ancestor of the class loader for the current class and
2334      *         invocation of {@link SecurityManager#checkPackageAccess
2335      *         s.checkPackageAccess()} denies access to the package
2336      *         of this class
2337      *
2338      *         &lt;/ul&gt;
2339      *
2340      * @since 1.1
2341      */
2342     @CallerSensitive
2343     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2344         SecurityManager sm = System.getSecurityManager();
2345         if (sm != null) {
2346             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2347         }
2348         return getDeclaredClasses0();
2349     }
2350 
2351 
2352     /**
2353      * Returns an array of {@code Field} objects reflecting all the fields
2354      * declared by the class or interface represented by this
2355      * {@code Class} object. This includes public, protected, default
2356      * (package) access, and private fields, but excludes inherited fields.
2357      *
2358      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2359      * declared fields, then this method returns an array of length 0.
2360      *
2361      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2362      * type, or void, then this method returns an array of length 0.
2363      *
2364      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2365      * particular order.
2366      *
2367      * @return  the array of {@code Field} objects representing all the
2368      *          declared fields of this class
2369      * @throws  SecurityException
2370      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2371      *          following conditions is met:
2372      *
2373      *          &lt;ul&gt;
2374      *
2375      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2376      *          class loader of this class and invocation of
2377      *          {@link SecurityManager#checkPermission
2378      *          s.checkPermission} method with
2379      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2380      *          denies access to the declared fields within this class
2381      *
2382      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2383      *          ancestor of the class loader for the current class and
2384      *          invocation of {@link SecurityManager#checkPackageAccess
2385      *          s.checkPackageAccess()} denies access to the package
2386      *          of this class
2387      *
2388      *          &lt;/ul&gt;
2389      *
2390      * @since 1.1
2391      * @jls 8.2 Class Members
2392      * @jls 8.3 Field Declarations
2393      */
2394     @CallerSensitive
2395     public Field[] getDeclaredFields() throws SecurityException {
2396         SecurityManager sm = System.getSecurityManager();
2397         if (sm != null) {
2398             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2399         }
2400         return copyFields(privateGetDeclaredFields(false));
2401     }
2402 
2403     /**
2404      * {@preview Associated with records, a preview feature of the Java language.
2405      *
2406      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2407      *           feature of the Java language. Preview features
2408      *           may be removed in a future release, or upgraded to permanent
2409      *           features of the Java language.}
2410      *
2411      * Returns an array of {@code RecordComponent} objects representing all the
2412      * record components of this record class, or {@code null} if this class is
2413      * not a record class.
2414      *
2415      * &lt;p&gt; The components are returned in the same order that they are declared
2416      * in the record header. The array is empty if this record class has no
2417      * components. If the class is not a record class, that is {@link
2418      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2419      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2420      * returns a non-null value.
2421      *
2422      * @return  An array of {@code RecordComponent} objects representing all the
2423      *          record components of this record class, or {@code null} if this
2424      *          class is not a record class
2425      * @throws  SecurityException
2426      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2427      *          following conditions is met:
2428      *
2429      *          &lt;ul&gt;
2430      *
2431      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2432      *          class loader of this class and invocation of
2433      *          {@link SecurityManager#checkPermission
2434      *          s.checkPermission} method with
2435      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2436      *          denies access to the declared methods within this class
2437      *
2438      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2439      *          ancestor of the class loader for the current class and
2440      *          invocation of {@link SecurityManager#checkPackageAccess
2441      *          s.checkPackageAccess()} denies access to the package
2442      *          of this class
2443      *
2444      *          &lt;/ul&gt;
2445      *
2446      * @jls 8.10 Record Types
2447      * @since 14
2448      */
2449     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2450                                  essentialAPI=false)
2451     @SuppressWarnings(&quot;preview&quot;)
2452     @CallerSensitive
2453     public RecordComponent[] getRecordComponents() {
2454         SecurityManager sm = System.getSecurityManager();
2455         if (sm != null) {
2456             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2457         }
2458         if (!isRecord()) {
2459             return null;
2460         }
2461         RecordComponent[] recordComponents = getRecordComponents0();
2462         if (recordComponents == null) {
2463             return new RecordComponent[0];
2464         }
2465         return recordComponents;
2466     }
2467 
2468     /**
2469      * Returns an array containing {@code Method} objects reflecting all the
2470      * declared methods of the class or interface represented by this {@code
2471      * Class} object, including public, protected, default (package)
2472      * access, and private methods, but excluding inherited methods.
2473      *
2474      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2475      * declared methods with the same name and parameter types, but different
2476      * return types, then the returned array has a {@code Method} object for
2477      * each such method.
2478      *
2479      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2480      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2481      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2482      *
2483      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2484      * declared methods, then the returned array has length 0.
2485      *
2486      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2487      * type, or void, then the returned array has length 0.
2488      *
2489      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2490      * particular order.
2491      *
2492      * @return  the array of {@code Method} objects representing all the
2493      *          declared methods of this class
2494      * @throws  SecurityException
2495      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2496      *          following conditions is met:
2497      *
2498      *          &lt;ul&gt;
2499      *
2500      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2501      *          class loader of this class and invocation of
2502      *          {@link SecurityManager#checkPermission
2503      *          s.checkPermission} method with
2504      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2505      *          denies access to the declared methods within this class
2506      *
2507      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2508      *          ancestor of the class loader for the current class and
2509      *          invocation of {@link SecurityManager#checkPackageAccess
2510      *          s.checkPackageAccess()} denies access to the package
2511      *          of this class
2512      *
2513      *          &lt;/ul&gt;
2514      *
2515      * @jls 8.2 Class Members
2516      * @jls 8.4 Method Declarations
2517      * @since 1.1
2518      */
2519     @CallerSensitive
2520     public Method[] getDeclaredMethods() throws SecurityException {
2521         SecurityManager sm = System.getSecurityManager();
2522         if (sm != null) {
2523             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2524         }
2525         return copyMethods(privateGetDeclaredMethods(false));
2526     }
2527 
2528 
2529     /**
2530      * Returns an array of {@code Constructor} objects reflecting all the
2531      * constructors declared by the class represented by this
2532      * {@code Class} object. These are public, protected, default
2533      * (package) access, and private constructors.  The elements in the array
2534      * returned are not sorted and are not in any particular order.  If the
2535      * class has a default constructor, it is included in the returned array.
2536      * This method returns an array of length 0 if this {@code Class}
2537      * object represents an interface, a primitive type, an array class, or
2538      * void.
2539      *
2540      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
2541      * section {@jls 8.2}.
2542      *
2543      * @return  the array of {@code Constructor} objects representing all the
2544      *          declared constructors of this class
2545      * @throws  SecurityException
2546      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2547      *          following conditions is met:
2548      *
2549      *          &lt;ul&gt;
2550      *
2551      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2552      *          class loader of this class and invocation of
2553      *          {@link SecurityManager#checkPermission
2554      *          s.checkPermission} method with
2555      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2556      *          denies access to the declared constructors within this class
2557      *
2558      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2559      *          ancestor of the class loader for the current class and
2560      *          invocation of {@link SecurityManager#checkPackageAccess
2561      *          s.checkPackageAccess()} denies access to the package
2562      *          of this class
2563      *
2564      *          &lt;/ul&gt;
2565      *
2566      * @since 1.1
2567      */
2568     @CallerSensitive
2569     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2570         SecurityManager sm = System.getSecurityManager();
2571         if (sm != null) {
2572             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2573         }
2574         return copyConstructors(privateGetDeclaredConstructors(false));
2575     }
2576 
2577 
2578     /**
2579      * Returns a {@code Field} object that reflects the specified declared
2580      * field of the class or interface represented by this {@code Class}
2581      * object. The {@code name} parameter is a {@code String} that specifies
2582      * the simple name of the desired field.
2583      *
2584      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2585      * method does not find the {@code length} field of the array type.
2586      *
2587      * @param name the name of the field
2588      * @return  the {@code Field} object for the specified field in this
2589      *          class
2590      * @throws  NoSuchFieldException if a field with the specified name is
2591      *          not found.
2592      * @throws  NullPointerException if {@code name} is {@code null}
2593      * @throws  SecurityException
2594      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2595      *          following conditions is met:
2596      *
2597      *          &lt;ul&gt;
2598      *
2599      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2600      *          class loader of this class and invocation of
2601      *          {@link SecurityManager#checkPermission
2602      *          s.checkPermission} method with
2603      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2604      *          denies access to the declared field
2605      *
2606      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2607      *          ancestor of the class loader for the current class and
2608      *          invocation of {@link SecurityManager#checkPackageAccess
2609      *          s.checkPackageAccess()} denies access to the package
2610      *          of this class
2611      *
2612      *          &lt;/ul&gt;
2613      *
2614      * @since 1.1
2615      * @jls 8.2 Class Members
2616      * @jls 8.3 Field Declarations
2617      */
2618     @CallerSensitive
2619     public Field getDeclaredField(String name)
2620         throws NoSuchFieldException, SecurityException {
2621         Objects.requireNonNull(name);
2622         SecurityManager sm = System.getSecurityManager();
2623         if (sm != null) {
2624             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2625         }
2626         Field field = searchFields(privateGetDeclaredFields(false), name);
2627         if (field == null) {
2628             throw new NoSuchFieldException(name);
2629         }
2630         return getReflectionFactory().copyField(field);
2631     }
2632 
2633 
2634     /**
2635      * Returns a {@code Method} object that reflects the specified
2636      * declared method of the class or interface represented by this
2637      * {@code Class} object. The {@code name} parameter is a
2638      * {@code String} that specifies the simple name of the desired
2639      * method, and the {@code parameterTypes} parameter is an array of
2640      * {@code Class} objects that identify the method&#39;s formal parameter
2641      * types, in declared order.  If more than one method with the same
2642      * parameter types is declared in a class, and one of these methods has a
2643      * return type that is more specific than any of the others, that method is
2644      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2645      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2646      * is raised.
2647      *
2648      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2649      * method does not find the {@code clone()} method.
2650      *
2651      * @param name the name of the method
2652      * @param parameterTypes the parameter array
2653      * @return  the {@code Method} object for the method of this class
2654      *          matching the specified name and parameters
2655      * @throws  NoSuchMethodException if a matching method is not found.
2656      * @throws  NullPointerException if {@code name} is {@code null}
2657      * @throws  SecurityException
2658      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2659      *          following conditions is met:
2660      *
2661      *          &lt;ul&gt;
2662      *
2663      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2664      *          class loader of this class and invocation of
2665      *          {@link SecurityManager#checkPermission
2666      *          s.checkPermission} method with
2667      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2668      *          denies access to the declared method
2669      *
2670      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2671      *          ancestor of the class loader for the current class and
2672      *          invocation of {@link SecurityManager#checkPackageAccess
2673      *          s.checkPackageAccess()} denies access to the package
2674      *          of this class
2675      *
2676      *          &lt;/ul&gt;
2677      *
2678      * @jls 8.2 Class Members
2679      * @jls 8.4 Method Declarations
2680      * @since 1.1
2681      */
2682     @CallerSensitive
2683     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2684         throws NoSuchMethodException, SecurityException {
2685         Objects.requireNonNull(name);
2686         SecurityManager sm = System.getSecurityManager();
2687         if (sm != null) {
2688             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2689         }
2690         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2691         if (method == null) {
2692             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2693         }
2694         return getReflectionFactory().copyMethod(method);
2695     }
2696 
2697     /**
2698      * Returns the list of {@code Method} objects for the declared public
2699      * methods of this class or interface that have the specified method name
2700      * and parameter types.
2701      *
2702      * @param name the name of the method
2703      * @param parameterTypes the parameter array
2704      * @return the list of {@code Method} objects for the public methods of
2705      *         this class matching the specified name and parameters
2706      */
2707     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2708         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2709         ReflectionFactory factory = getReflectionFactory();
2710         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2711         for (Method method : methods) {
2712             if (method.getName().equals(name)
2713                 &amp;&amp; Arrays.equals(
2714                     factory.getExecutableSharedParameterTypes(method),
2715                     parameterTypes)) {
2716                 result.add(factory.copyMethod(method));
2717             }
2718         }
2719         return result;
2720     }
2721 
2722     /**
2723      * Returns a {@code Constructor} object that reflects the specified
2724      * constructor of the class or interface represented by this
2725      * {@code Class} object.  The {@code parameterTypes} parameter is
2726      * an array of {@code Class} objects that identify the constructor&#39;s
2727      * formal parameter types, in declared order.
2728      *
2729      * If this {@code Class} object represents an inner class
2730      * declared in a non-static context, the formal parameter types
2731      * include the explicit enclosing instance as the first parameter.
2732      *
2733      * @param parameterTypes the parameter array
2734      * @return  The {@code Constructor} object for the constructor with the
2735      *          specified parameter list
2736      * @throws  NoSuchMethodException if a matching method is not found.
2737      * @throws  SecurityException
2738      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2739      *          following conditions is met:
2740      *
2741      *          &lt;ul&gt;
2742      *
2743      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2744      *          class loader of this class and invocation of
2745      *          {@link SecurityManager#checkPermission
2746      *          s.checkPermission} method with
2747      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2748      *          denies access to the declared constructor
2749      *
2750      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2751      *          ancestor of the class loader for the current class and
2752      *          invocation of {@link SecurityManager#checkPackageAccess
2753      *          s.checkPackageAccess()} denies access to the package
2754      *          of this class
2755      *
2756      *          &lt;/ul&gt;
2757      *
2758      * @since 1.1
2759      */
2760     @CallerSensitive
2761     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2762         throws NoSuchMethodException, SecurityException
2763     {
2764         SecurityManager sm = System.getSecurityManager();
2765         if (sm != null) {
2766             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2767         }
2768 
2769         return getReflectionFactory().copyConstructor(
2770             getConstructor0(parameterTypes, Member.DECLARED));
2771     }
2772 
2773     /**
2774      * Finds a resource with a given name.
2775      *
2776      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2777      * will attempt to find the resource in the module. This is done by
2778      * delegating to the module&#39;s class loader {@link
2779      * ClassLoader#findResource(String,String) findResource(String,String)}
2780      * method, invoking it with the module name and the absolute name of the
2781      * resource. Resources in named modules are subject to the rules for
2782      * encapsulation specified in the {@code Module} {@link
2783      * Module#getResourceAsStream getResourceAsStream} method and so this
2784      * method returns {@code null} when the resource is a
2785      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2786      * caller&#39;s module.
2787      *
2788      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2789      * searching resources associated with a given class are implemented by the
2790      * defining {@linkplain ClassLoader class loader} of the class.  This method
2791      * delegates to this {@code Class} object&#39;s class loader.
2792      * If this {@code Class} object was loaded by the bootstrap class loader,
2793      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
2794      *
2795      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2796      * given resource name using this algorithm:
2797      *
2798      * &lt;ul&gt;
2799      *
2800      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2801      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2802      * portion of the {@code name} following the {@code &#39;/&#39;}.
2803      *
2804      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2805      *
2806      * &lt;blockquote&gt;
2807      *   {@code modified_package_name/name}
2808      * &lt;/blockquote&gt;
2809      *
2810      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2811      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2812      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2813      *
2814      * &lt;/ul&gt;
2815      *
2816      * @param  name name of the desired resource
2817      * @return  A {@link java.io.InputStream} object; {@code null} if no
2818      *          resource with this name is found, the resource is in a package
2819      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2820      *          least the caller module, or access to the resource is denied
2821      *          by the security manager.
2822      * @throws  NullPointerException If {@code name} is {@code null}
2823      *
2824      * @see Module#getResourceAsStream(String)
2825      * @since  1.1
2826      * @revised 9
2827      * @spec JPMS
2828      */
2829     @CallerSensitive
2830     public InputStream getResourceAsStream(String name) {
2831         name = resolveName(name);
2832 
2833         Module thisModule = getModule();
2834         if (thisModule.isNamed()) {
2835             // check if resource can be located by caller
2836             if (Resources.canEncapsulate(name)
2837                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2838                 return null;
2839             }
2840 
2841             // resource not encapsulated or in package open to caller
2842             String mn = thisModule.getName();
2843             ClassLoader cl = getClassLoader0();
2844             try {
2845 
2846                 // special-case built-in class loaders to avoid the
2847                 // need for a URL connection
2848                 if (cl == null) {
2849                     return BootLoader.findResourceAsStream(mn, name);
2850                 } else if (cl instanceof BuiltinClassLoader) {
2851                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2852                 } else {
2853                     URL url = cl.findResource(mn, name);
2854                     return (url != null) ? url.openStream() : null;
2855                 }
2856 
2857             } catch (IOException | SecurityException e) {
2858                 return null;
2859             }
2860         }
2861 
2862         // unnamed module
2863         ClassLoader cl = getClassLoader0();
2864         if (cl == null) {
2865             return ClassLoader.getSystemResourceAsStream(name);
2866         } else {
2867             return cl.getResourceAsStream(name);
2868         }
2869     }
2870 
2871     /**
2872      * Finds a resource with a given name.
2873      *
2874      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2875      * will attempt to find the resource in the module. This is done by
2876      * delegating to the module&#39;s class loader {@link
2877      * ClassLoader#findResource(String,String) findResource(String,String)}
2878      * method, invoking it with the module name and the absolute name of the
2879      * resource. Resources in named modules are subject to the rules for
2880      * encapsulation specified in the {@code Module} {@link
2881      * Module#getResourceAsStream getResourceAsStream} method and so this
2882      * method returns {@code null} when the resource is a
2883      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2884      * caller&#39;s module.
2885      *
2886      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2887      * searching resources associated with a given class are implemented by the
2888      * defining {@linkplain ClassLoader class loader} of the class.  This method
2889      * delegates to this {@code Class} object&#39;s class loader.
2890      * If this {@code Class} object was loaded by the bootstrap class loader,
2891      * the method delegates to {@link ClassLoader#getSystemResource}.
2892      *
2893      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2894      * given resource name using this algorithm:
2895      *
2896      * &lt;ul&gt;
2897      *
2898      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2899      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2900      * portion of the {@code name} following the {@code &#39;/&#39;}.
2901      *
2902      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2903      *
2904      * &lt;blockquote&gt;
2905      *   {@code modified_package_name/name}
2906      * &lt;/blockquote&gt;
2907      *
2908      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2909      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2910      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2911      *
2912      * &lt;/ul&gt;
2913      *
2914      * @param  name name of the desired resource
2915      * @return A {@link java.net.URL} object; {@code null} if no resource with
2916      *         this name is found, the resource cannot be located by a URL, the
2917      *         resource is in a package that is not
2918      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
2919      *         module, or access to the resource is denied by the security
2920      *         manager.
2921      * @throws NullPointerException If {@code name} is {@code null}
2922      * @since  1.1
2923      * @revised 9
2924      * @spec JPMS
2925      */
2926     @CallerSensitive
2927     public URL getResource(String name) {
2928         name = resolveName(name);
2929 
2930         Module thisModule = getModule();
2931         if (thisModule.isNamed()) {
2932             // check if resource can be located by caller
2933             if (Resources.canEncapsulate(name)
2934                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2935                 return null;
2936             }
2937 
2938             // resource not encapsulated or in package open to caller
2939             String mn = thisModule.getName();
2940             ClassLoader cl = getClassLoader0();
2941             try {
2942                 if (cl == null) {
2943                     return BootLoader.findResource(mn, name);
2944                 } else {
2945                     return cl.findResource(mn, name);
2946                 }
2947             } catch (IOException ioe) {
2948                 return null;
2949             }
2950         }
2951 
2952         // unnamed module
2953         ClassLoader cl = getClassLoader0();
2954         if (cl == null) {
2955             return ClassLoader.getSystemResource(name);
2956         } else {
2957             return cl.getResource(name);
2958         }
2959     }
2960 
2961     /**
2962      * Returns true if a resource with the given name can be located by the
2963      * given caller. All resources in a module can be located by code in
2964      * the module. For other callers, then the package needs to be open to
2965      * the caller.
2966      */
2967     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
2968         // assert getModule().isNamed();
2969         Module thisModule = getModule();
2970         Module callerModule = (caller != null) ? caller.getModule() : null;
2971         if (callerModule != thisModule) {
2972             String pn = Resources.toPackageName(name);
2973             if (thisModule.getDescriptor().packages().contains(pn)) {
2974                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
2975                     // no caller, package not open
2976                     return false;
2977                 }
2978                 if (!thisModule.isOpen(pn, callerModule)) {
2979                     // package not open to caller
2980                     return false;
2981                 }
2982             }
2983         }
2984         return true;
2985     }
2986 
2987 
2988     /** protection domain returned when the internal domain is null */
2989     private static java.security.ProtectionDomain allPermDomain;
2990 
2991     /**
2992      * Returns the {@code ProtectionDomain} of this class.  If there is a
2993      * security manager installed, this method first calls the security
2994      * manager&#39;s {@code checkPermission} method with a
2995      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
2996      * ensure it&#39;s ok to get the
2997      * {@code ProtectionDomain}.
2998      *
2999      * @return the ProtectionDomain of this class
3000      *
3001      * @throws SecurityException
3002      *        if a security manager exists and its
3003      *        {@code checkPermission} method doesn&#39;t allow
3004      *        getting the ProtectionDomain.
3005      *
3006      * @see java.security.ProtectionDomain
3007      * @see SecurityManager#checkPermission
3008      * @see java.lang.RuntimePermission
3009      * @since 1.2
3010      */
3011     public java.security.ProtectionDomain getProtectionDomain() {
3012         SecurityManager sm = System.getSecurityManager();
3013         if (sm != null) {
3014             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
3015         }
3016         return protectionDomain();
3017     }
3018 
3019     // package-private
3020     java.security.ProtectionDomain protectionDomain() {
3021         java.security.ProtectionDomain pd = getProtectionDomain0();
3022         if (pd == null) {
3023             if (allPermDomain == null) {
3024                 java.security.Permissions perms =
3025                     new java.security.Permissions();
3026                 perms.add(SecurityConstants.ALL_PERMISSION);
3027                 allPermDomain =
3028                     new java.security.ProtectionDomain(null, perms);
3029             }
3030             pd = allPermDomain;
3031         }
3032         return pd;
3033     }
3034 
3035     /**
3036      * Returns the ProtectionDomain of this class.
3037      */
3038     private native java.security.ProtectionDomain getProtectionDomain0();
3039 
3040     /*
3041      * Return the Virtual Machine&#39;s Class object for the named
3042      * primitive type.
3043      */
3044     static native Class&lt;?&gt; getPrimitiveClass(String name);
3045 
3046     /*
3047      * Check if client is allowed to access members.  If access is denied,
3048      * throw a SecurityException.
3049      *
3050      * This method also enforces package access.
3051      *
3052      * &lt;p&gt; Default policy: allow all clients access with normal Java access
3053      * control.
3054      *
3055      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
3056      */
3057     private void checkMemberAccess(SecurityManager sm, int which,
3058                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
3059         /* Default policy allows access to all {@link Member#PUBLIC} members,
3060          * as well as access to classes that have the same class loader as the caller.
3061          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
3062          * permission.
3063          */
3064         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
3065         if (which != Member.PUBLIC) {
3066             final ClassLoader cl = getClassLoader0();
3067             if (ccl != cl) {
3068                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3069             }
3070         }
3071         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
3072     }
3073 
3074     /*
3075      * Checks if a client loaded in ClassLoader ccl is allowed to access this
3076      * class under the current package access policy. If access is denied,
3077      * throw a SecurityException.
3078      *
3079      * NOTE: this method should only be called if a SecurityManager is active
3080      */
3081     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3082                                     boolean checkProxyInterfaces) {
3083         final ClassLoader cl = getClassLoader0();
3084 
3085         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3086             String pkg = this.getPackageName();
3087             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3088                 // skip the package access check on a proxy class in default proxy package
3089                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3090                     sm.checkPackageAccess(pkg);
3091                 }
3092             }
3093         }
3094         // check package access on the proxy interfaces
3095         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3096             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3097         }
3098     }
3099 
3100     /**
3101      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3102      * if name is absolute
3103      */
3104     private String resolveName(String name) {
3105         if (!name.startsWith(&quot;/&quot;)) {
3106             Class&lt;?&gt; c = isArray() ? elementType() : this;
3107             String baseName = c.getPackageName();
3108             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3109                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3110             }
3111         } else {
3112             name = name.substring(1);
3113         }
3114         return name;
3115     }
3116 
3117     /**
3118      * Atomic operations support.
3119      */
3120     private static class Atomic {
3121         // initialize Unsafe machinery here, since we need to call Class.class instance method
3122         // and have to avoid calling it in the static initializer of the Class class...
3123         private static final Unsafe unsafe = Unsafe.getUnsafe();
3124         // offset of Class.reflectionData instance field
3125         private static final long reflectionDataOffset
3126                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3127         // offset of Class.annotationType instance field
3128         private static final long annotationTypeOffset
3129                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3130         // offset of Class.annotationData instance field
3131         private static final long annotationDataOffset
3132                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3133 
3134         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3135                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3136                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3137             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3138         }
3139 
3140         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3141                                              AnnotationType oldType,
3142                                              AnnotationType newType) {
3143             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3144         }
3145 
3146         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3147                                              AnnotationData oldData,
3148                                              AnnotationData newData) {
3149             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3150         }
3151     }
3152 
3153     /**
3154      * Reflection support.
3155      */
3156 
3157     // Reflection data caches various derived names and reflective members. Cached
3158     // values may be invalidated when JVM TI RedefineClasses() is called
3159     private static class ReflectionData&lt;T&gt; {
3160         volatile Field[] declaredFields;
3161         volatile Field[] publicFields;
3162         volatile Method[] declaredMethods;
3163         volatile Method[] publicMethods;
3164         volatile Constructor&lt;T&gt;[] declaredConstructors;
3165         volatile Constructor&lt;T&gt;[] publicConstructors;
3166         // Intermediate results for getFields and getMethods
3167         volatile Field[] declaredPublicFields;
3168         volatile Method[] declaredPublicMethods;
3169         volatile Class&lt;?&gt;[] interfaces;
3170 
3171         // Cached names
3172         String simpleName;
3173         String canonicalName;
3174         static final String NULL_SENTINEL = new String();
3175 
3176         // Value of classRedefinedCount when we created this ReflectionData instance
3177         final int redefinedCount;
3178 
3179         ReflectionData(int redefinedCount) {
3180             this.redefinedCount = redefinedCount;
3181         }
3182     }
3183 
3184     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3185 
3186     // Incremented by the VM on each call to JVM TI RedefineClasses()
3187     // that redefines this class or a superclass.
3188     private transient volatile int classRedefinedCount;
3189 
3190     // Lazily create and cache ReflectionData
3191     private ReflectionData&lt;T&gt; reflectionData() {
3192         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3193         int classRedefinedCount = this.classRedefinedCount;
3194         ReflectionData&lt;T&gt; rd;
3195         if (reflectionData != null &amp;&amp;
3196             (rd = reflectionData.get()) != null &amp;&amp;
3197             rd.redefinedCount == classRedefinedCount) {
3198             return rd;
3199         }
3200         // else no SoftReference or cleared SoftReference or stale ReflectionData
3201         // -&gt; create and replace new instance
3202         return newReflectionData(reflectionData, classRedefinedCount);
3203     }
3204 
3205     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3206                                                 int classRedefinedCount) {
3207         while (true) {
3208             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3209             // try to CAS it...
3210             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3211                 return rd;
3212             }
3213             // else retry
3214             oldReflectionData = this.reflectionData;
3215             classRedefinedCount = this.classRedefinedCount;
3216             if (oldReflectionData != null &amp;&amp;
3217                 (rd = oldReflectionData.get()) != null &amp;&amp;
3218                 rd.redefinedCount == classRedefinedCount) {
3219                 return rd;
3220             }
3221         }
3222     }
3223 
3224     // Generic signature handling
3225     private native String getGenericSignature0();
3226 
3227     // Generic info repository; lazily initialized
3228     private transient volatile ClassRepository genericInfo;
3229 
3230     // accessor for factory
3231     private GenericsFactory getFactory() {
3232         // create scope and factory
3233         return CoreReflectionFactory.make(this, ClassScope.make(this));
3234     }
3235 
3236     // accessor for generic info repository;
3237     // generic info is lazily initialized
3238     private ClassRepository getGenericInfo() {
3239         ClassRepository genericInfo = this.genericInfo;
3240         if (genericInfo == null) {
3241             String signature = getGenericSignature0();
3242             if (signature == null) {
3243                 genericInfo = ClassRepository.NONE;
3244             } else {
3245                 genericInfo = ClassRepository.make(signature, getFactory());
3246             }
3247             this.genericInfo = genericInfo;
3248         }
3249         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3250     }
3251 
3252     // Annotations handling
3253     native byte[] getRawAnnotations();
3254     // Since 1.8
3255     native byte[] getRawTypeAnnotations();
3256     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3257         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3258     }
3259 
3260     native ConstantPool getConstantPool();
3261 
3262     //
3263     //
3264     // java.lang.reflect.Field handling
3265     //
3266     //
3267 
3268     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3269     // be propagated to the outside world, but must instead be copied
3270     // via ReflectionFactory.copyField.
3271     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3272         Field[] res;
3273         ReflectionData&lt;T&gt; rd = reflectionData();
3274         if (rd != null) {
3275             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3276             if (res != null) return res;
3277         }
3278         // No cached value available; request value from VM
3279         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3280         if (rd != null) {
3281             if (publicOnly) {
3282                 rd.declaredPublicFields = res;
3283             } else {
3284                 rd.declaredFields = res;
3285             }
3286         }
3287         return res;
3288     }
3289 
3290     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3291     // be propagated to the outside world, but must instead be copied
3292     // via ReflectionFactory.copyField.
3293     private Field[] privateGetPublicFields() {
3294         Field[] res;
3295         ReflectionData&lt;T&gt; rd = reflectionData();
3296         if (rd != null) {
3297             res = rd.publicFields;
3298             if (res != null) return res;
3299         }
3300 
3301         // Use a linked hash set to ensure order is preserved and
3302         // fields from common super interfaces are not duplicated
3303         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3304 
3305         // Local fields
3306         addAll(fields, privateGetDeclaredFields(true));
3307 
3308         // Direct superinterfaces, recursively
3309         for (Class&lt;?&gt; si : getInterfaces()) {
3310             addAll(fields, si.privateGetPublicFields());
3311         }
3312 
3313         // Direct superclass, recursively
3314         Class&lt;?&gt; sc = getSuperclass();
3315         if (sc != null) {
3316             addAll(fields, sc.privateGetPublicFields());
3317         }
3318 
3319         res = fields.toArray(new Field[0]);
3320         if (rd != null) {
3321             rd.publicFields = res;
3322         }
3323         return res;
3324     }
3325 
3326     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3327         for (Field f : o) {
3328             c.add(f);
3329         }
3330     }
3331 
3332 
3333     //
3334     //
3335     // java.lang.reflect.Constructor handling
3336     //
3337     //
3338 
3339     // Returns an array of &quot;root&quot; constructors. These Constructor
3340     // objects must NOT be propagated to the outside world, but must
3341     // instead be copied via ReflectionFactory.copyConstructor.
3342     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3343         Constructor&lt;T&gt;[] res;
3344         ReflectionData&lt;T&gt; rd = reflectionData();
3345         if (rd != null) {
3346             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3347             if (res != null) return res;
3348         }
3349         // No cached value available; request value from VM
3350         if (isInterface()) {
3351             @SuppressWarnings(&quot;unchecked&quot;)
3352             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3353             res = temporaryRes;
3354         } else {
3355             res = getDeclaredConstructors0(publicOnly);
3356         }
3357         if (rd != null) {
3358             if (publicOnly) {
3359                 rd.publicConstructors = res;
3360             } else {
3361                 rd.declaredConstructors = res;
3362             }
3363         }
3364         return res;
3365     }
3366 
3367     //
3368     //
3369     // java.lang.reflect.Method handling
3370     //
3371     //
3372 
3373     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3374     // be propagated to the outside world, but must instead be copied
3375     // via ReflectionFactory.copyMethod.
3376     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3377         Method[] res;
3378         ReflectionData&lt;T&gt; rd = reflectionData();
3379         if (rd != null) {
3380             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3381             if (res != null) return res;
3382         }
3383         // No cached value available; request value from VM
3384         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3385         if (rd != null) {
3386             if (publicOnly) {
3387                 rd.declaredPublicMethods = res;
3388             } else {
3389                 rd.declaredMethods = res;
3390             }
3391         }
3392         return res;
3393     }
3394 
3395     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3396     // be propagated to the outside world, but must instead be copied
3397     // via ReflectionFactory.copyMethod.
3398     private Method[] privateGetPublicMethods() {
3399         Method[] res;
3400         ReflectionData&lt;T&gt; rd = reflectionData();
3401         if (rd != null) {
3402             res = rd.publicMethods;
3403             if (res != null) return res;
3404         }
3405 
3406         // No cached value available; compute value recursively.
3407         // Start by fetching public declared methods...
3408         PublicMethods pms = new PublicMethods();
3409         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3410             pms.merge(m);
3411         }
3412         // ...then recur over superclass methods...
3413         Class&lt;?&gt; sc = getSuperclass();
3414         if (sc != null) {
3415             for (Method m : sc.privateGetPublicMethods()) {
3416                 pms.merge(m);
3417             }
3418         }
3419         // ...and finally over direct superinterfaces.
3420         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3421             for (Method m : intf.privateGetPublicMethods()) {
3422                 // static interface methods are not inherited
3423                 if (!Modifier.isStatic(m.getModifiers())) {
3424                     pms.merge(m);
3425                 }
3426             }
3427         }
3428 
3429         res = pms.toArray();
3430         if (rd != null) {
3431             rd.publicMethods = res;
3432         }
3433         return res;
3434     }
3435 
3436 
3437     //
3438     // Helpers for fetchers of one field, method, or constructor
3439     //
3440 
3441     // This method does not copy the returned Field object!
3442     private static Field searchFields(Field[] fields, String name) {
3443         for (Field field : fields) {
3444             if (field.getName().equals(name)) {
3445                 return field;
3446             }
3447         }
3448         return null;
3449     }
3450 
3451     // Returns a &quot;root&quot; Field object. This Field object must NOT
3452     // be propagated to the outside world, but must instead be copied
3453     // via ReflectionFactory.copyField.
3454     private Field getField0(String name) {
3455         // Note: the intent is that the search algorithm this routine
3456         // uses be equivalent to the ordering imposed by
3457         // privateGetPublicFields(). It fetches only the declared
3458         // public fields for each class, however, to reduce the number
3459         // of Field objects which have to be created for the common
3460         // case where the field being requested is declared in the
3461         // class which is being queried.
3462         Field res;
3463         // Search declared public fields
3464         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3465             return res;
3466         }
3467         // Direct superinterfaces, recursively
3468         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3469         for (Class&lt;?&gt; c : interfaces) {
3470             if ((res = c.getField0(name)) != null) {
3471                 return res;
3472             }
3473         }
3474         // Direct superclass, recursively
3475         if (!isInterface()) {
3476             Class&lt;?&gt; c = getSuperclass();
3477             if (c != null) {
3478                 if ((res = c.getField0(name)) != null) {
3479                     return res;
3480                 }
3481             }
3482         }
3483         return null;
3484     }
3485 
3486     // This method does not copy the returned Method object!
3487     private static Method searchMethods(Method[] methods,
3488                                         String name,
3489                                         Class&lt;?&gt;[] parameterTypes)
3490     {
3491         ReflectionFactory fact = getReflectionFactory();
3492         Method res = null;
3493         for (Method m : methods) {
3494             if (m.getName().equals(name)
3495                 &amp;&amp; arrayContentsEq(parameterTypes,
3496                                    fact.getExecutableSharedParameterTypes(m))
3497                 &amp;&amp; (res == null
3498                     || (res.getReturnType() != m.getReturnType()
3499                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3500                 res = m;
3501         }
3502         return res;
3503     }
3504 
3505     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3506 
3507     // Returns a &quot;root&quot; Method object. This Method object must NOT
3508     // be propagated to the outside world, but must instead be copied
3509     // via ReflectionFactory.copyMethod.
3510     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3511         PublicMethods.MethodList res = getMethodsRecursive(
3512             name,
3513             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3514             /* includeStatic */ true);
3515         return res == null ? null : res.getMostSpecific();
3516     }
3517 
3518     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3519     // be propagated to the outside world, but must instead be copied
3520     // via ReflectionFactory.copyMethod.
3521     private PublicMethods.MethodList getMethodsRecursive(String name,
3522                                                          Class&lt;?&gt;[] parameterTypes,
3523                                                          boolean includeStatic) {
3524         // 1st check declared public methods
3525         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3526         PublicMethods.MethodList res = PublicMethods.MethodList
3527             .filter(methods, name, parameterTypes, includeStatic);
3528         // if there is at least one match among declared methods, we need not
3529         // search any further as such match surely overrides matching methods
3530         // declared in superclass(es) or interface(s).
3531         if (res != null) {
3532             return res;
3533         }
3534 
3535         // if there was no match among declared methods,
3536         // we must consult the superclass (if any) recursively...
3537         Class&lt;?&gt; sc = getSuperclass();
3538         if (sc != null) {
3539             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3540         }
3541 
3542         // ...and coalesce the superclass methods with methods obtained
3543         // from directly implemented interfaces excluding static methods...
3544         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3545             res = PublicMethods.MethodList.merge(
3546                 res, intf.getMethodsRecursive(name, parameterTypes,
3547                                               /* includeStatic */ false));
3548         }
3549 
3550         return res;
3551     }
3552 
3553     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3554     // be propagated to the outside world, but must instead be copied
3555     // via ReflectionFactory.copyConstructor.
3556     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3557                                         int which) throws NoSuchMethodException
3558     {
3559         ReflectionFactory fact = getReflectionFactory();
3560         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3561         for (Constructor&lt;T&gt; constructor : constructors) {
3562             if (arrayContentsEq(parameterTypes,
3563                                 fact.getExecutableSharedParameterTypes(constructor))) {
3564                 return constructor;
3565             }
3566         }
3567         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3568     }
3569 
3570     //
3571     // Other helpers and base implementation
3572     //
3573 
3574     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3575         if (a1 == null) {
3576             return a2 == null || a2.length == 0;
3577         }
3578 
3579         if (a2 == null) {
3580             return a1.length == 0;
3581         }
3582 
3583         if (a1.length != a2.length) {
3584             return false;
3585         }
3586 
3587         for (int i = 0; i &lt; a1.length; i++) {
3588             if (a1[i] != a2[i]) {
3589                 return false;
3590             }
3591         }
3592 
3593         return true;
3594     }
3595 
3596     private static Field[] copyFields(Field[] arg) {
3597         Field[] out = new Field[arg.length];
3598         ReflectionFactory fact = getReflectionFactory();
3599         for (int i = 0; i &lt; arg.length; i++) {
3600             out[i] = fact.copyField(arg[i]);
3601         }
3602         return out;
3603     }
3604 
3605     private static Method[] copyMethods(Method[] arg) {
3606         Method[] out = new Method[arg.length];
3607         ReflectionFactory fact = getReflectionFactory();
3608         for (int i = 0; i &lt; arg.length; i++) {
3609             out[i] = fact.copyMethod(arg[i]);
3610         }
3611         return out;
3612     }
3613 
3614     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3615         Constructor&lt;U&gt;[] out = arg.clone();
3616         ReflectionFactory fact = getReflectionFactory();
3617         for (int i = 0; i &lt; out.length; i++) {
3618             out[i] = fact.copyConstructor(out[i]);
3619         }
3620         return out;
3621     }
3622 
3623     private native Field[]       getDeclaredFields0(boolean publicOnly);
3624     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3625     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3626     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3627     @SuppressWarnings(&quot;preview&quot;)
3628     private native RecordComponent[] getRecordComponents0();
3629     private native boolean      isRecord0();
3630 
3631     /**
3632      * Helper method to get the method name from arguments.
3633      */
3634     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3635         return getName() + &#39;.&#39; + name +
3636                 ((argTypes == null || argTypes.length == 0) ?
3637                 &quot;()&quot; :
3638                 Arrays.stream(argTypes)
3639                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())
3640                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3641     }
3642 
3643     /** use serialVersionUID from JDK 1.1 for interoperability */
3644     @java.io.Serial
3645     private static final long serialVersionUID = 3206093459760846163L;
3646 
3647 
3648     /**
3649      * Class Class is special cased within the Serialization Stream Protocol.
3650      *
3651      * A Class instance is written initially into an ObjectOutputStream in the
3652      * following format:
3653      * &lt;pre&gt;
3654      *      {@code TC_CLASS} ClassDescriptor
3655      *      A ClassDescriptor is a special cased serialization of
3656      *      a {@code java.io.ObjectStreamClass} instance.
3657      * &lt;/pre&gt;
3658      * A new handle is generated for the initial time the class descriptor
3659      * is written into the stream. Future references to the class descriptor
3660      * are written as references to the initial class descriptor instance.
3661      *
3662      * @see java.io.ObjectStreamClass
3663      */
3664     @java.io.Serial
3665     private static final ObjectStreamField[] serialPersistentFields =
3666         new ObjectStreamField[0];
3667 
3668 
3669     /**
3670      * Returns the assertion status that would be assigned to this
3671      * class if it were to be initialized at the time this method is invoked.
3672      * If this class has had its assertion status set, the most recent
3673      * setting will be returned; otherwise, if any package default assertion
3674      * status pertains to this class, the most recent setting for the most
3675      * specific pertinent package default assertion status is returned;
3676      * otherwise, if this class is not a system class (i.e., it has a
3677      * class loader) its class loader&#39;s default assertion status is returned;
3678      * otherwise, the system class default assertion status is returned.
3679      *
3680      * @apiNote
3681      * Few programmers will have any need for this method; it is provided
3682      * for the benefit of the JDK itself.  (It allows a class to determine at
3683      * the time that it is initialized whether assertions should be enabled.)
3684      * Note that this method is not guaranteed to return the actual
3685      * assertion status that was (or will be) associated with the specified
3686      * class when it was (or will be) initialized.
3687      *
3688      * @return the desired assertion status of the specified class.
3689      * @see    java.lang.ClassLoader#setClassAssertionStatus
3690      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3691      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3692      * @since  1.4
3693      */
3694     public boolean desiredAssertionStatus() {
3695         ClassLoader loader = getClassLoader0();
3696         // If the loader is null this is a system class, so ask the VM
3697         if (loader == null)
3698             return desiredAssertionStatus0(this);
3699 
3700         // If the classloader has been initialized with the assertion
3701         // directives, ask it. Otherwise, ask the VM.
3702         synchronized(loader.assertionLock) {
3703             if (loader.classAssertionStatus != null) {
3704                 return loader.desiredAssertionStatus(getName());
3705             }
3706         }
3707         return desiredAssertionStatus0(this);
3708     }
3709 
3710     // Retrieves the desired assertion status of this class from the VM
3711     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3712 
3713     /**
3714      * Returns true if and only if this class was declared as an enum in the
3715      * source code.
3716      *
3717      * Note that {@link java.lang.Enum} is not itself an enum type.
3718      *
3719      * Also note that if an enum constant is declared with a class body,
3720      * the class of that enum constant object is an anonymous class
3721      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3722      * {@link Enum#getDeclaringClass} method of an enum constant can
3723      * be used to get the class of the enum type declaring the
3724      * constant.
3725      *
3726      * @return true if and only if this class was declared as an enum in the
3727      *     source code
3728      * @since 1.5
3729      * @jls 8.9.1 Enum Constants
3730      */
3731     public boolean isEnum() {
3732         // An enum must both directly extend java.lang.Enum and have
3733         // the ENUM bit set; classes for specialized enum constants
3734         // don&#39;t do the former.
3735         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3736         this.getSuperclass() == java.lang.Enum.class;
3737     }
3738 
3739     /** java.lang.Record.class */
3740     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3741     private static Class&lt;?&gt; javaLangRecordClass() {
3742         try {
3743             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3744         } catch (ClassNotFoundException e) {
3745             throw new InternalError(&quot;should not reach here&quot;, e);
3746         }
3747     }
3748 
3749     /**
3750      * {@preview Associated with records, a preview feature of the Java language.
3751      *
3752      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3753      *           feature of the Java language. Preview features
3754      *           may be removed in a future release, or upgraded to permanent
3755      *           features of the Java language.}
3756      *
3757      * Returns {@code true} if and only if this class is a record class.
3758      *
3759      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3760      * class is {@code java.lang.Record}. A record class has (possibly zero)
3761      * record components, that is, {@link #getRecordComponents()} returns a
3762      * non-null value.
3763      *
3764      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3765      * this method on class {@code Record} returns {@code false}.
3766      *
3767      * @return true if and only if this class is a record class, otherwise false
3768      * @jls 8.10 Record Types
3769      * @since 14
3770      */
3771     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3772                                  essentialAPI=false)
3773     public boolean isRecord() {
3774         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3775     }
3776 
3777     // Fetches the factory for reflective objects
3778     private static ReflectionFactory getReflectionFactory() {
3779         if (reflectionFactory == null) {
3780             reflectionFactory =
3781                 java.security.AccessController.doPrivileged
3782                     (new ReflectionFactory.GetReflectionFactoryAction());
3783         }
3784         return reflectionFactory;
3785     }
3786     private static ReflectionFactory reflectionFactory;
3787 
3788     /**
3789      * Returns the elements of this enum class or null if this
3790      * Class object does not represent an enum type.
3791      *
3792      * @return an array containing the values comprising the enum class
3793      *     represented by this {@code Class} object in the order they&#39;re
3794      *     declared, or null if this {@code Class} object does not
3795      *     represent an enum type
3796      * @since 1.5
3797      */
3798     public T[] getEnumConstants() {
3799         T[] values = getEnumConstantsShared();
3800         return (values != null) ? values.clone() : null;
3801     }
3802 
3803     /**
3804      * Returns the elements of this enum class or null if this
3805      * Class object does not represent an enum type;
3806      * identical to getEnumConstants except that the result is
3807      * uncloned, cached, and shared by all callers.
3808      */
3809     T[] getEnumConstantsShared() {
3810         T[] constants = enumConstants;
3811         if (constants == null) {
3812             if (!isEnum()) return null;
3813             try {
3814                 final Method values = getMethod(&quot;values&quot;);
3815                 java.security.AccessController.doPrivileged(
3816                     new java.security.PrivilegedAction&lt;&gt;() {
3817                         public Void run() {
3818                                 values.setAccessible(true);
3819                                 return null;
3820                             }
3821                         });
3822                 @SuppressWarnings(&quot;unchecked&quot;)
3823                 T[] temporaryConstants = (T[])values.invoke(null);
3824                 enumConstants = constants = temporaryConstants;
3825             }
3826             // These can happen when users concoct enum-like classes
3827             // that don&#39;t comply with the enum spec.
3828             catch (InvocationTargetException | NoSuchMethodException |
3829                    IllegalAccessException ex) { return null; }
3830         }
3831         return constants;
3832     }
3833     private transient volatile T[] enumConstants;
3834 
3835     /**
3836      * Returns a map from simple name to enum constant.  This package-private
3837      * method is used internally by Enum to implement
3838      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3839      * efficiently.  Note that the map is returned by this method is
3840      * created lazily on first use.  Typically it won&#39;t ever get created.
3841      */
3842     Map&lt;String, T&gt; enumConstantDirectory() {
3843         Map&lt;String, T&gt; directory = enumConstantDirectory;
3844         if (directory == null) {
3845             T[] universe = getEnumConstantsShared();
3846             if (universe == null)
3847                 throw new IllegalArgumentException(
3848                     getName() + &quot; is not an enum type&quot;);
3849             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3850             for (T constant : universe) {
3851                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3852             }
3853             enumConstantDirectory = directory;
3854         }
3855         return directory;
3856     }
3857     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3858 
3859     /**
3860      * Casts an object to the class or interface represented
3861      * by this {@code Class} object.
3862      *
3863      * @param obj the object to be cast
3864      * @return the object after casting, or null if obj is null
3865      *
3866      * @throws ClassCastException if the object is not
<a name="12" id="anc12"></a><span class="line-modified">3867      * {@code null} and is not assignable to the type T.</span>
<span class="line-added">3868      * @throws NullPointerException if this is an {@linkplain #isInlineClass()</span>
<span class="line-added">3869      * inline type} and the object is {@code null}</span>
3870      *
3871      * @since 1.5
3872      */
3873     @SuppressWarnings(&quot;unchecked&quot;)
3874     @HotSpotIntrinsicCandidate
3875     public T cast(Object obj) {
<a name="13" id="anc13"></a><span class="line-added">3876         if (isInlineClass() &amp;&amp; obj == null)</span>
<span class="line-added">3877             throw new NullPointerException(getName() + &quot; is an inline class&quot;);</span>
<span class="line-added">3878 </span>
3879         if (obj != null &amp;&amp; !isInstance(obj))
3880             throw new ClassCastException(cannotCastMsg(obj));
3881         return (T) obj;
3882     }
3883 
3884     private String cannotCastMsg(Object obj) {
3885         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3886     }
3887 
3888     /**
3889      * Casts this {@code Class} object to represent a subclass of the class
3890      * represented by the specified class object.  Checks that the cast
3891      * is valid, and throws a {@code ClassCastException} if it is not.  If
3892      * this method succeeds, it always returns a reference to this {@code Class} object.
3893      *
3894      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3895      * a {@code Class} object to pass it to an API that restricts the
3896      * {@code Class} objects that it is willing to accept.  A cast would
3897      * generate a compile-time warning, as the correctness of the cast
3898      * could not be checked at runtime (because generic types are implemented
3899      * by erasure).
3900      *
3901      * @param &lt;U&gt; the type to cast this {@code Class} object to
3902      * @param clazz the class of the type to cast this {@code Class} object to
3903      * @return this {@code Class} object, cast to represent a subclass of
3904      *    the specified class object.
3905      * @throws ClassCastException if this {@code Class} object does not
3906      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3907      *    the class itself).
3908      * @since 1.5
3909      */
3910     @SuppressWarnings(&quot;unchecked&quot;)
3911     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3912         if (clazz.isAssignableFrom(this))
3913             return (Class&lt;? extends U&gt;) this;
3914         else
3915             throw new ClassCastException(this.toString());
3916     }
3917 
3918     /**
3919      * {@inheritDoc}
3920      * &lt;p&gt;Note that any annotation returned by this method is a
3921      * declaration annotation.
3922      *
3923      * @throws NullPointerException {@inheritDoc}
3924      * @since 1.5
3925      */
3926     @Override
3927     @SuppressWarnings(&quot;unchecked&quot;)
3928     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3929         Objects.requireNonNull(annotationClass);
3930 
3931         return (A) annotationData().annotations.get(annotationClass);
3932     }
3933 
3934     /**
3935      * {@inheritDoc}
3936      * @throws NullPointerException {@inheritDoc}
3937      * @since 1.5
3938      */
3939     @Override
3940     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3941         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3942     }
3943 
3944     /**
3945      * {@inheritDoc}
3946      * &lt;p&gt;Note that any annotations returned by this method are
3947      * declaration annotations.
3948      *
3949      * @throws NullPointerException {@inheritDoc}
3950      * @since 1.8
3951      */
3952     @Override
3953     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3954         Objects.requireNonNull(annotationClass);
3955 
3956         AnnotationData annotationData = annotationData();
3957         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3958                                                           this,
3959                                                           annotationClass);
3960     }
3961 
3962     /**
3963      * {@inheritDoc}
3964      * &lt;p&gt;Note that any annotations returned by this method are
3965      * declaration annotations.
3966      *
3967      * @since 1.5
3968      */
3969     @Override
3970     public Annotation[] getAnnotations() {
3971         return AnnotationParser.toArray(annotationData().annotations);
3972     }
3973 
3974     /**
3975      * {@inheritDoc}
3976      * &lt;p&gt;Note that any annotation returned by this method is a
3977      * declaration annotation.
3978      *
3979      * @throws NullPointerException {@inheritDoc}
3980      * @since 1.8
3981      */
3982     @Override
3983     @SuppressWarnings(&quot;unchecked&quot;)
3984     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3985         Objects.requireNonNull(annotationClass);
3986 
3987         return (A) annotationData().declaredAnnotations.get(annotationClass);
3988     }
3989 
3990     /**
3991      * {@inheritDoc}
3992      * &lt;p&gt;Note that any annotations returned by this method are
3993      * declaration annotations.
3994      *
3995      * @throws NullPointerException {@inheritDoc}
3996      * @since 1.8
3997      */
3998     @Override
3999     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
4000         Objects.requireNonNull(annotationClass);
4001 
4002         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
4003                                                                  annotationClass);
4004     }
4005 
4006     /**
4007      * {@inheritDoc}
4008      * &lt;p&gt;Note that any annotations returned by this method are
4009      * declaration annotations.
4010      *
4011      * @since 1.5
4012      */
4013     @Override
4014     public Annotation[] getDeclaredAnnotations()  {
4015         return AnnotationParser.toArray(annotationData().declaredAnnotations);
4016     }
4017 
4018     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
4019     private static class AnnotationData {
4020         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
4021         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
4022 
4023         // Value of classRedefinedCount when we created this AnnotationData instance
4024         final int redefinedCount;
4025 
4026         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
4027                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
4028                        int redefinedCount) {
4029             this.annotations = annotations;
4030             this.declaredAnnotations = declaredAnnotations;
4031             this.redefinedCount = redefinedCount;
4032         }
4033     }
4034 
4035     // Annotations cache
4036     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4037     private transient volatile AnnotationData annotationData;
4038 
4039     private AnnotationData annotationData() {
4040         while (true) { // retry loop
4041             AnnotationData annotationData = this.annotationData;
4042             int classRedefinedCount = this.classRedefinedCount;
4043             if (annotationData != null &amp;&amp;
4044                 annotationData.redefinedCount == classRedefinedCount) {
4045                 return annotationData;
4046             }
4047             // null or stale annotationData -&gt; optimistically create new instance
4048             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
4049             // try to install it
4050             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
4051                 // successfully installed new AnnotationData
4052                 return newAnnotationData;
4053             }
4054         }
4055     }
4056 
4057     private AnnotationData createAnnotationData(int classRedefinedCount) {
4058         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
4059             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
4060         Class&lt;?&gt; superClass = getSuperclass();
4061         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
4062         if (superClass != null) {
4063             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
4064                 superClass.annotationData().annotations;
4065             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
4066                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
4067                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
4068                     if (annotations == null) { // lazy construction
4069                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
4070                                 declaredAnnotations.size(),
4071                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
4072                             ) * 4 + 2) / 3
4073                         );
4074                     }
4075                     annotations.put(annotationClass, e.getValue());
4076                 }
4077             }
4078         }
4079         if (annotations == null) {
4080             // no inherited annotations -&gt; share the Map with declaredAnnotations
4081             annotations = declaredAnnotations;
4082         } else {
4083             // at least one inherited annotation -&gt; declared may override inherited
4084             annotations.putAll(declaredAnnotations);
4085         }
4086         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4087     }
4088 
4089     // Annotation types cache their internal (AnnotationType) form
4090 
4091     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4092     private transient volatile AnnotationType annotationType;
4093 
4094     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4095         return Atomic.casAnnotationType(this, oldType, newType);
4096     }
4097 
4098     AnnotationType getAnnotationType() {
4099         return annotationType;
4100     }
4101 
4102     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4103         return annotationData().declaredAnnotations;
4104     }
4105 
4106     /* Backing store of user-defined values pertaining to this class.
4107      * Maintained by the ClassValue class.
4108      */
4109     transient ClassValue.ClassValueMap classValueMap;
4110 
4111     /**
4112      * Returns an {@code AnnotatedType} object that represents the use of a
4113      * type to specify the superclass of the entity represented by this {@code
4114      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4115      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4116      * Foo.)
4117      *
4118      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4119      * does not explicitly indicate an annotated superclass, then the return
4120      * value is an {@code AnnotatedType} object representing an element with no
4121      * annotations.
4122      *
4123      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4124      * interface type, an array type, a primitive type, or void, the return
4125      * value is {@code null}.
4126      *
4127      * @return an object representing the superclass
4128      * @since 1.8
4129      */
4130     public AnnotatedType getAnnotatedSuperclass() {
4131         if (this == Object.class ||
4132                 isInterface() ||
4133                 isArray() ||
4134                 isPrimitive() ||
4135                 this == Void.TYPE) {
4136             return null;
4137         }
4138 
4139         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4140     }
4141 
4142     /**
4143      * Returns an array of {@code AnnotatedType} objects that represent the use
4144      * of types to specify superinterfaces of the entity represented by this
4145      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4146      * superinterface in &#39;... implements Foo&#39; is distinct from the
4147      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4148      *
4149      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4150      * an array containing objects representing the uses of interface types to
4151      * specify interfaces implemented by the class. The order of the objects in
4152      * the array corresponds to the order of the interface types used in the
4153      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4154      *
4155      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4156      * value is an array containing objects representing the uses of interface
4157      * types to specify interfaces directly extended by the interface. The
4158      * order of the objects in the array corresponds to the order of the
4159      * interface types used in the &#39;extends&#39; clause of the declaration of this
4160      * {@code Class} object.
4161      *
4162      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4163      * declaration does not explicitly indicate any annotated superinterfaces,
4164      * the return value is an array of length 0.
4165      *
4166      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4167      * class, an array type, a primitive type, or void, the return value is an
4168      * array of length 0.
4169      *
4170      * @return an array representing the superinterfaces
4171      * @since 1.8
4172      */
4173     public AnnotatedType[] getAnnotatedInterfaces() {
<a name="14" id="anc14"></a><span class="line-modified">4174         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);</span>
4175     }
4176 
4177     private native Class&lt;?&gt; getNestHost0();
4178 
4179     /**
4180      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4181      * or interface represented by this {@code Class} object belongs.
4182      * Every class and interface belongs to exactly one nest.
4183      *
4184      * If the nest host of this class or interface has previously
4185      * been determined, then this method returns the nest host.
4186      * If the nest host of this class or interface has
4187      * not previously been determined, then this method determines the nest
4188      * host using the algorithm of JVMS 5.4.4, and returns it.
4189      *
4190      * Often, a class or interface belongs to a nest consisting only of itself,
4191      * in which case this method returns {@code this} to indicate that the class
4192      * or interface is the nest host.
4193      *
4194      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
4195      * or {@code void}, then this method returns {@code this},
4196      * indicating that the represented entity belongs to the nest consisting only of
4197      * itself, and is the nest host.
4198      *
4199      * @return the nest host of this class or interface
4200      *
4201      * @throws SecurityException
4202      *         If the returned class is not the current class, and
4203      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4204      *         class loader is not the same as or an ancestor of the class
4205      *         loader for the returned class and invocation of {@link
4206      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4207      *         denies access to the package of the returned class
4208      * @since 11
4209      * @jvms 4.7.28 The {@code NestHost} Attribute
4210      * @jvms 4.7.29 The {@code NestMembers} Attribute
4211      * @jvms 5.4.4 Access Control
4212      */
4213     @CallerSensitive
4214     public Class&lt;?&gt; getNestHost() {
4215         if (isPrimitive() || isArray()) {
4216             return this;
4217         }
4218 
4219         Class&lt;?&gt; host = getNestHost0();
4220         if (host == this) {
4221             return this;
4222         }
4223         // returning a different class requires a security check
4224         SecurityManager sm = System.getSecurityManager();
4225         if (sm != null) {
4226             checkPackageAccess(sm,
4227                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4228         }
4229         return host;
4230     }
4231 
4232     /**
4233      * Determines if the given {@code Class} is a nestmate of the
4234      * class or interface represented by this {@code Class} object.
4235      * Two classes or interfaces are nestmates
4236      * if they have the same {@linkplain #getNestHost() nest host}.
4237      *
4238      * @param c the class to check
4239      * @return {@code true} if this class and {@code c} are members of
4240      * the same nest; and {@code false} otherwise.
4241      *
4242      * @since 11
4243      */
4244     public boolean isNestmateOf(Class&lt;?&gt; c) {
4245         if (this == c) {
4246             return true;
4247         }
4248         if (isPrimitive() || isArray() ||
4249             c.isPrimitive() || c.isArray()) {
4250             return false;
4251         }
4252 
4253         return getNestHost() == c.getNestHost();
4254     }
4255 
4256     private native Class&lt;?&gt;[] getNestMembers0();
4257 
4258     /**
4259      * Returns an array containing {@code Class} objects representing all the
4260      * classes and interfaces that are members of the nest to which the class
4261      * or interface represented by this {@code Class} object belongs.
4262      *
4263      * First, this method obtains the {@linkplain #getNestHost() nest host},
4264      * {@code H}, of the nest to which the class or interface represented by
4265      * this {@code Class} object belongs. The zeroth element of the returned
4266      * array is {@code H}.
4267      *
4268      * Then, for each class or interface {@code C} which is recorded by {@code H}
4269      * as being a member of its nest, this method attempts to obtain the {@code Class}
4270      * object for {@code C} (using {@linkplain #getClassLoader() the defining class
4271      * loader} of the current {@code Class} object), and then obtains the
4272      * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.
4273      * The classes and interfaces which are recorded by {@code H} as being members
4274      * of its nest, and for which {@code H} can be determined as their nest host,
4275      * are indicated by subsequent elements of the returned array. The order of
4276      * such elements is unspecified. Duplicates are permitted.
4277      *
4278      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
4279      * or {@code void}, then this method returns a single-element array containing
4280      * {@code this}.
4281      *
4282      * @apiNote
4283      * The returned array includes only the nest members recorded in the {@code NestMembers}
4284      * attribute, and not any hidden classes that were added to the nest via
4285      * {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
4286      * Lookup::defineHiddenClass}.
4287      *
4288      * @return an array of all classes and interfaces in the same nest as
4289      * this class or interface
4290      *
4291      * @throws SecurityException
4292      * If any returned class is not the current class, and
4293      * if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4294      * class loader is not the same as or an ancestor of the class
4295      * loader for that returned class and invocation of {@link
4296      * SecurityManager#checkPackageAccess s.checkPackageAccess()}
4297      * denies access to the package of that returned class
4298      *
4299      * @since 11
4300      * @see #getNestHost()
4301      * @jvms 4.7.28 The {@code NestHost} Attribute
4302      * @jvms 4.7.29 The {@code NestMembers} Attribute
4303      */
4304     @CallerSensitive
4305     public Class&lt;?&gt;[] getNestMembers() {
4306         if (isPrimitive() || isArray()) {
4307             return new Class&lt;?&gt;[] { this };
4308         }
4309         Class&lt;?&gt;[] members = getNestMembers0();
4310         // Can&#39;t actually enable this due to bootstrapping issues
4311         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4312 
4313         if (members.length &gt; 1) {
4314             // If we return anything other than the current class we need
4315             // a security check
4316             SecurityManager sm = System.getSecurityManager();
4317             if (sm != null) {
4318                 checkPackageAccess(sm,
4319                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4320             }
4321         }
4322         return members;
4323     }
4324 
4325     /**
4326      * Returns the descriptor string of the entity (class, interface, array class,
4327      * primitive type, or {@code void}) represented by this {@code Class} object.
4328      *
4329      * &lt;p&gt; If this {@code Class} object represents a class or interface,
4330      * not an array class, then:
4331      * &lt;ul&gt;
4332      * &lt;li&gt; If the class or interface is not {@linkplain Class#isHidden() hidden},
4333      *      then the result is a field descriptor (JVMS {@jvms 4.3.2})
4334      *      for the class or interface. Calling
4335      *      {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
4336      *      with the result descriptor string produces a {@link ClassDesc ClassDesc}
4337      *      describing this class or interface.
4338      * &lt;li&gt; If the class or interface is {@linkplain Class#isHidden() hidden},
4339      *      then the result is a string of the form:
4340      *      &lt;blockquote&gt;
4341      *      {@code &quot;L&quot; +} &lt;em&gt;N&lt;/em&gt; {@code + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;}
4342      *      &lt;/blockquote&gt;
4343      *      where &lt;em&gt;N&lt;/em&gt; is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
4344      *      encoded in internal form indicated by the {@code class} file passed to
4345      *      {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
4346      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
4347      *      A hidden class or interface has no {@linkplain ClassDesc nominal descriptor}.
4348      *      The result string is not a type descriptor.
4349      * &lt;/ul&gt;
4350      *
4351      * &lt;p&gt; If this {@code Class} object represents an array class, then
4352      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
4353      * representing the depth of the array nesting, followed by the
4354      * descriptor string of the element type.
4355      * &lt;ul&gt;
4356      * &lt;li&gt; If the element type is not a {@linkplain Class#isHidden() hidden} class
4357      * or interface, then this array class can be described nominally.
4358      * Calling {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
4359      * with the result descriptor string produces a {@link ClassDesc ClassDesc}
4360      * describing this array class.
4361      * &lt;li&gt; If the element type is a {@linkplain Class#isHidden() hidden} class or
4362      * interface, then this array class cannot be described nominally.
4363      * The result string is not a type descriptor.
4364      * &lt;/ul&gt;
4365      *
4366      * &lt;p&gt; If this {@code Class} object represents a primitive type or
4367      * {@code void}, then the result is a field descriptor string which
4368      * is a one-letter code corresponding to a primitive type or {@code void}
4369      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).
4370      *
4371      * @apiNote
4372      * This is not a strict inverse of {@link #forName};
4373      * distinct classes which share a common name but have different class loaders
4374      * will have identical descriptor strings.
4375      *
4376      * @return the descriptor string for this {@code Class} object
4377      * @jvms 4.3.2 Field Descriptors
4378      * @since 12
4379      */
4380     @Override
4381     public String descriptorString() {
4382         if (isPrimitive())
4383             return Wrapper.forPrimitiveType(this).basicTypeString();
4384 
4385         if (isArray()) {
4386             return &quot;[&quot; + componentType.descriptorString();
<a name="15" id="anc15"></a><span class="line-modified">4387         }</span>
<span class="line-added">4388         String typeDesc = isInlineClass() ? &quot;Q&quot; : &quot;L&quot;;</span>
<span class="line-added">4389         if (isHidden()) {</span>
4390             String name = getName();
4391             int index = name.indexOf(&#39;/&#39;);
<a name="16" id="anc16"></a><span class="line-modified">4392             return typeDesc + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)</span>
4393                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;
4394         } else {
<a name="17" id="anc17"></a><span class="line-modified">4395             return typeDesc + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4396         }
4397     }
4398 
4399     /**
4400      * Returns the component type of this {@code Class}, if it describes
4401      * an array type, or {@code null} otherwise.
4402      *
4403      * @implSpec
4404      * Equivalent to {@link Class#getComponentType()}.
4405      *
4406      * @return a {@code Class} describing the component type, or {@code null}
4407      * if this {@code Class} does not describe an array type
4408      * @since 12
4409      */
4410     @Override
4411     public Class&lt;?&gt; componentType() {
4412         return isArray() ? componentType : null;
4413     }
4414 
4415     /**
4416      * Returns a {@code Class} for an array type whose component type
4417      * is described by this {@linkplain Class}.
4418      *
4419      * @return a {@code Class} describing the array type
4420      * @since 12
4421      */
4422     @Override
4423     public Class&lt;?&gt; arrayType() {
4424         return Array.newInstance(this, 0).getClass();
4425     }
4426 
4427     /**
4428      * Returns a nominal descriptor for this instance, if one can be
4429      * constructed, or an empty {@link Optional} if one cannot be.
4430      *
4431      * @return An {@link Optional} containing the resulting nominal descriptor,
4432      * or an empty {@link Optional} if one cannot be constructed.
4433      * @since 12
4434      */
4435     @Override
4436     public Optional&lt;ClassDesc&gt; describeConstable() {
4437         Class&lt;?&gt; c = isArray() ? elementType() : this;
4438         return c.isHidden() ? Optional.empty()
4439                             : Optional.of(ClassDesc.ofDescriptor(descriptorString()));
4440    }
4441 
4442     /**
4443      * Returns {@code true} if and only if the underlying class is a hidden class.
4444      *
4445      * @return {@code true} if and only if this class is a hidden class.
4446      *
4447      * @since 15
4448      * @see MethodHandles.Lookup#defineHiddenClass
4449      */
4450     @HotSpotIntrinsicCandidate
4451     public native boolean isHidden();
4452 
4453     /**
4454      * {@preview Associated with sealed classes, a preview feature of the Java language.
4455      *
4456      *           This method is associated with &lt;i&gt;sealed classes&lt;/i&gt;, a preview
4457      *           feature of the Java language. Preview features
4458      *           may be removed in a future release, or upgraded to permanent
4459      *           features of the Java language.}
4460      *
4461      * Returns an array containing {@code ClassDesc} objects representing all the
4462      * direct subclasses or direct implementation classes permitted to extend or
4463      * implement this class or interface if it is sealed. The order of such elements
4464      * is unspecified. If this {@code Class} object represents a primitive type,
4465      * {@code void}, an array type, or a class or interface that is not sealed,
4466      * an empty array is returned.
4467      *
4468      * @return an array of class descriptors of all the permitted subclasses of this class or interface
4469      *
4470      * @jls 8.1 Class Declarations
4471      * @jls 9.1 Interface Declarations
4472      * @since 15
4473      */
4474     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.SEALED_CLASSES, essentialAPI=false)
4475     public ClassDesc[] permittedSubclasses() {
4476         String[] subclassNames;
4477         if (isArray() || isPrimitive() || (subclassNames = getPermittedSubclasses0()).length == 0) {
4478             return EMPTY_CLASS_DESC_ARRAY;
4479         }
4480         ClassDesc[] constants = new ClassDesc[subclassNames.length];
4481         int i = 0;
4482         for (String subclassName : subclassNames) {
4483             try {
4484                 constants[i++] = ClassDesc.of(subclassName.replace(&#39;/&#39;, &#39;.&#39;));
4485             } catch (IllegalArgumentException iae) {
4486                 throw new InternalError(&quot;Invalid type in permitted subclasses information: &quot; + subclassName, iae);
4487             }
4488         }
4489         return constants;
4490     }
4491 
4492     /**
4493      * * {@preview Associated with sealed classes, a preview feature of the Java language.
4494      *
4495      *           This method is associated with &lt;i&gt;sealed classes&lt;/i&gt;, a preview
4496      *           feature of the Java language. Preview features
4497      *           may be removed in a future release, or upgraded to permanent
4498      *           features of the Java language.}
4499      *
4500      * Returns {@code true} if and only if this {@code Class} object represents a sealed class or interface.
4501      * If this {@code Class} object represents a primitive type, {@code void}, or an array type, this method returns
4502      * {@code false}.
4503      *
4504      * @return {@code true} if and only if this {@code Class} object represents a sealed class or interface.
4505      *
4506      * @jls 8.1 Class Declarations
4507      * @jls 9.1 Interface Declarations
4508      * @since 15
4509      */
4510     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.SEALED_CLASSES, essentialAPI=false)
4511     @SuppressWarnings(&quot;preview&quot;)
4512     public boolean isSealed() {
4513         if (isArray() || isPrimitive()) {
4514             return false;
4515         }
4516         return permittedSubclasses().length != 0;
4517     }
4518 
4519     private native String[] getPermittedSubclasses0();
4520 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
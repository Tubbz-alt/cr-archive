<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/micro/org/openjdk/bench/valhalla/corelibs/XArrayList.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package org.openjdk.bench.valhalla.corelibs;
  27 
  28 import java.util.AbstractList;
  29 import java.util.Arrays;
  30 import java.util.Collection;
  31 import java.util.Comparator;
  32 import java.util.ConcurrentModificationException;
  33 import java.util.Iterator;
  34 import java.util.List;
  35 import java.util.ListIterator;
  36 import java.util.NoSuchElementException;
  37 import java.util.Objects;
  38 import java.util.RandomAccess;
  39 import java.util.Spliterator;
  40 
  41 import java.util.function.Consumer;
  42 import java.util.function.Predicate;
  43 import java.util.function.UnaryOperator;
  44 //import jdk.internal.access.SharedSecrets;
  45 //import jdk.internal.util.ArraysSupport;
  46 
  47 /**
  48  * Resizable-array implementation of the {@code List} interface.  Implements
  49  * all optional list operations, and permits all elements, including
  50  * {@code null}.  In addition to implementing the {@code List} interface,
  51  * this class provides methods to manipulate the size of the array that is
  52  * used internally to store the list.  (This class is roughly equivalent to
  53  * {@code Vector}, except that it is unsynchronized.)
  54  *
  55  * &lt;p&gt;The {@code size}, {@code isEmpty}, {@code get}, {@code set},
  56  * {@code iterator}, and {@code listIterator} operations run in constant
  57  * time.  The {@code add} operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;,
  58  * that is, adding n elements requires O(n) time.  All of the other operations
  59  * run in linear time (roughly speaking).  The constant factor is low compared
  60  * to that for the {@code LinkedList} implementation.
  61  *
  62  * &lt;p&gt;Each {@code XArrayList} instance has a &lt;i&gt;capacity&lt;/i&gt;.  The capacity is
  63  * the size of the array used to store the elements in the list.  It is always
  64  * at least as large as the list size.  As elements are added to an XArrayList,
  65  * its capacity grows automatically.  The details of the growth policy are not
  66  * specified beyond the fact that adding an element has constant amortized
  67  * time cost.
  68  *
  69  * &lt;p&gt;An application can increase the capacity of an {@code XArrayList} instance
  70  * before adding a large number of elements using the {@code ensureCapacity}
  71  * operation.  This may reduce the amount of incremental reallocation.
  72  *
  73  * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
  74  * If multiple threads access an {@code XArrayList} instance concurrently,
  75  * and at least one of the threads modifies the list structurally, it
  76  * &lt;i&gt;must&lt;/i&gt; be synchronized externally.  (A structural modification is
  77  * any operation that adds or deletes one or more elements, or explicitly
  78  * resizes the backing array; merely setting the value of an element is not
  79  * a structural modification.)  This is typically accomplished by
  80  * synchronizing on some object that naturally encapsulates the list.
  81  *
  82  * If no such object exists, the list should be &quot;wrapped&quot; using the
  83  * {@link Collections#synchronizedList Collections.synchronizedList}
  84  * method.  This is best done at creation time, to prevent accidental
  85  * unsynchronized access to the list:&lt;pre&gt;
  86  *   List list = Collections.synchronizedList(new XArrayList(...));&lt;/pre&gt;
  87  *
  88  * &lt;p id=&quot;fail-fast&quot;&gt;
  89  * The iterators returned by this class&#39;s {@link #iterator() iterator} and
  90  * {@link #listIterator(int) listIterator} methods are &lt;em&gt;fail-fast&lt;/em&gt;:
  91  * if the list is structurally modified at any time after the iterator is
  92  * created, in any way except through the iterator&#39;s own
  93  * {@link ListIterator#remove() remove} or
  94  * {@link ListIterator#add(Object) add} methods, the iterator will throw a
  95  * {@link ConcurrentModificationException}.  Thus, in the face of
  96  * concurrent modification, the iterator fails quickly and cleanly, rather
  97  * than risking arbitrary, non-deterministic behavior at an undetermined
  98  * time in the future.
  99  *
 100  * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 101  * as it is, generally speaking, impossible to make any hard guarantees in the
 102  * presence of unsynchronized concurrent modification.  Fail-fast iterators
 103  * throw {@code ConcurrentModificationException} on a best-effort basis.
 104  * Therefore, it would be wrong to write a program that depended on this
 105  * exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators
 106  * should be used only to detect bugs.&lt;/i&gt;
 107  *
 108  * &lt;p&gt;This class is a member of the
 109  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 110  * Java Collections Framework&lt;/a&gt;.
 111  *
 112  * @param &lt;E&gt; the type of elements in this list
 113  *
 114  * @author  Josh Bloch
 115  * @author  Neal Gafter
 116  * @see     Collection
 117  * @see     List
 118  * @see     LinkedList
 119  * @see     Vector
 120  * @since   1.2
 121  */
 122 public class XArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
 123         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
 124 {
 125     private static final long serialVersionUID = 8683452581122892189L;
 126 
 127     /**
 128      * Default initial capacity.
 129      */
 130     private static final int DEFAULT_CAPACITY = 10;
 131 
 132     /**
 133      * Shared empty array instance used for empty instances.
 134      */
 135     private static final Object[] EMPTY_ELEMENTDATA = {};
 136 
 137     /**
 138      * Shared empty array instance used for default sized empty instances. We
 139      * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
 140      * first element is added.
 141      */
 142     private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
 143 
 144     /**
 145      * The array buffer into which the elements of the ArrayList are stored.
 146      * The capacity of the ArrayList is the length of this array buffer. Any
 147      * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
 148      * will be expanded to DEFAULT_CAPACITY when the first element is added.
 149      */
 150     transient Object[] elementData; // non-private to simplify nested class access
 151 
 152     /**
 153      * The size of the ArrayList (the number of elements it contains).
 154      *
 155      * @serial
 156      */
 157     int size;
 158 
 159     /**
 160      * Constructs an empty list with the specified initial capacity.
 161      *
 162      * @param  initialCapacity  the initial capacity of the list
 163      * @throws IllegalArgumentException if the specified initial capacity
 164      *         is negative
 165      */
 166     public XArrayList(int initialCapacity) {
 167         if (initialCapacity &gt; 0) {
 168             this.elementData = new Object[initialCapacity];
 169         } else if (initialCapacity == 0) {
 170             this.elementData = EMPTY_ELEMENTDATA;
 171         } else {
 172             throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
 173                                                initialCapacity);
 174         }
 175     }
 176 
 177     /**
 178      * Constructs an empty list with an initial capacity of ten.
 179      */
 180     public XArrayList() {
 181         this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
 182     }
 183 
 184     /**
 185      * Constructs a list containing the elements of the specified
 186      * collection, in the order they are returned by the collection&#39;s
 187      * iterator.
 188      *
 189      * @param c the collection whose elements are to be placed into this list
 190      * @throws NullPointerException if the specified collection is null
 191      */
 192     public XArrayList(Collection&lt;? extends E&gt; c) {
 193         elementData = c.toArray();
 194         if ((size = elementData.length) != 0) {
 195             // defend against c.toArray (incorrectly) not returning Object[]
 196             // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)
 197             if (elementData.getClass() != Object[].class)
 198                 elementData = Arrays.copyOf(elementData, size, Object[].class);
 199         } else {
 200             // replace with empty array.
 201             this.elementData = EMPTY_ELEMENTDATA;
 202         }
 203     }
 204 
 205     /**
 206      * Trims the capacity of this {@code XArrayList} instance to be the
 207      * list&#39;s current size.  An application can use this operation to minimize
 208      * the storage of an {@code XArrayList} instance.
 209      */
 210     public void trimToSize() {
 211         modCount++;
 212         if (size &lt; elementData.length) {
 213             elementData = (size == 0)
 214               ? EMPTY_ELEMENTDATA
 215               : Arrays.copyOf(elementData, size);
 216         }
 217     }
 218 
 219     /**
 220      * Increases the capacity of this {@code XArrayList} instance, if
 221      * necessary, to ensure that it can hold at least the number of elements
 222      * specified by the minimum capacity argument.
 223      *
 224      * @param minCapacity the desired minimum capacity
 225      */
 226     public void ensureCapacity(int minCapacity) {
 227         if (minCapacity &gt; elementData.length
 228             &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
 229                  &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) {
 230             modCount++;
 231             grow(minCapacity);
 232         }
 233     }
 234 
 235     /**
 236      * Increases the capacity to ensure that it can hold at least the
 237      * number of elements specified by the minimum capacity argument.
 238      *
 239      * @param minCapacity the desired minimum capacity
 240      * @throws OutOfMemoryError if minCapacity is less than zero
 241      */
 242     private Object[] grow(int minCapacity) {
 243         int oldCapacity = elementData.length;
 244         if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
 245             int newCapacity = newLength(oldCapacity,
 246                     minCapacity - oldCapacity, /* minimum growth */
 247                     oldCapacity &gt;&gt; 1           /* preferred growth */);
 248             return elementData = Arrays.copyOf(elementData, newCapacity);
 249         } else {
 250             return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
 251         }
 252     }
 253 
 254     private Object[] grow() {
 255         return grow(size + 1);
 256     }
 257 
 258     /**
 259      * Returns the number of elements in this list.
 260      *
 261      * @return the number of elements in this list
 262      */
 263     public int size() {
 264         return size;
 265     }
 266 
 267     /**
 268      * Returns {@code true} if this list contains no elements.
 269      *
 270      * @return {@code true} if this list contains no elements
 271      */
 272     public boolean isEmpty() {
 273         return size == 0;
 274     }
 275 
 276     /**
 277      * Returns {@code true} if this list contains the specified element.
 278      * More formally, returns {@code true} if and only if this list contains
 279      * at least one element {@code e} such that
 280      * {@code Objects.equals(o, e)}.
 281      *
 282      * @param o element whose presence in this list is to be tested
 283      * @return {@code true} if this list contains the specified element
 284      */
 285     public boolean contains(Object o) {
 286         return indexOf(o) &gt;= 0;
 287     }
 288 
 289     /**
 290      * Returns the index of the first occurrence of the specified element
 291      * in this list, or -1 if this list does not contain the element.
 292      * More formally, returns the lowest index {@code i} such that
 293      * {@code Objects.equals(o, get(i))},
 294      * or -1 if there is no such index.
 295      */
 296     public int indexOf(Object o) {
 297         return indexOfRange(o, 0, size);
 298     }
 299 
 300     int indexOfRange(Object o, int start, int end) {
 301         Object[] es = elementData;
 302         if (o == null) {
 303             for (int i = start; i &lt; end; i++) {
 304                 if (es[i] == null) {
 305                     return i;
 306                 }
 307             }
 308         } else {
 309             for (int i = start; i &lt; end; i++) {
 310                 if (o.equals(es[i])) {
 311                     return i;
 312                 }
 313             }
 314         }
 315         return -1;
 316     }
 317 
 318     /**
 319      * Returns the index of the last occurrence of the specified element
 320      * in this list, or -1 if this list does not contain the element.
 321      * More formally, returns the highest index {@code i} such that
 322      * {@code Objects.equals(o, get(i))},
 323      * or -1 if there is no such index.
 324      */
 325     public int lastIndexOf(Object o) {
 326         return lastIndexOfRange(o, 0, size);
 327     }
 328 
 329     int lastIndexOfRange(Object o, int start, int end) {
 330         Object[] es = elementData;
 331         if (o == null) {
 332             for (int i = end - 1; i &gt;= start; i--) {
 333                 if (es[i] == null) {
 334                     return i;
 335                 }
 336             }
 337         } else {
 338             for (int i = end - 1; i &gt;= start; i--) {
 339                 if (o.equals(es[i])) {
 340                     return i;
 341                 }
 342             }
 343         }
 344         return -1;
 345     }
 346 
 347     /**
 348      * Returns a shallow copy of this {@code XArrayList} instance.  (The
 349      * elements themselves are not copied.)
 350      *
 351      * @return a clone of this {@code XArrayList} instance
 352      */
 353     public Object clone() {
 354         try {
 355             XArrayList&lt;?&gt; v = (XArrayList&lt;?&gt;) super.clone();
 356             v.elementData = Arrays.copyOf(elementData, size);
 357             v.modCount = 0;
 358             return v;
 359         } catch (CloneNotSupportedException e) {
 360             // this shouldn&#39;t happen, since we are Cloneable
 361             throw new InternalError(e);
 362         }
 363     }
 364 
 365     /**
 366      * Returns an array containing all of the elements in this list
 367      * in proper sequence (from first to last element).
 368      *
 369      * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 370      * maintained by this list.  (In other words, this method must allocate
 371      * a new array).  The caller is thus free to modify the returned array.
 372      *
 373      * &lt;p&gt;This method acts as bridge between array-based and collection-based
 374      * APIs.
 375      *
 376      * @return an array containing all of the elements in this list in
 377      *         proper sequence
 378      */
 379     public Object[] toArray() {
 380         return Arrays.copyOf(elementData, size);
 381     }
 382 
 383     /**
 384      * Returns an array containing all of the elements in this list in proper
 385      * sequence (from first to last element); the runtime type of the returned
 386      * array is that of the specified array.  If the list fits in the
 387      * specified array, it is returned therein.  Otherwise, a new array is
 388      * allocated with the runtime type of the specified array and the size of
 389      * this list.
 390      *
 391      * &lt;p&gt;If the list fits in the specified array with room to spare
 392      * (i.e., the array has more elements than the list), the element in
 393      * the array immediately following the end of the collection is set to
 394      * {@code null}.  (This is useful in determining the length of the
 395      * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain
 396      * any null elements.)
 397      *
 398      * @param a the array into which the elements of the list are to
 399      *          be stored, if it is big enough; otherwise, a new array of the
 400      *          same runtime type is allocated for this purpose.
 401      * @return an array containing the elements of the list
 402      * @throws ArrayStoreException if the runtime type of the specified array
 403      *         is not a supertype of the runtime type of every element in
 404      *         this list
 405      * @throws NullPointerException if the specified array is null
 406      */
 407     @SuppressWarnings(&quot;unchecked&quot;)
 408     public &lt;T&gt; T[] toArray(T[] a) {
 409         if (a.length &lt; size)
 410             // Make a new array of a&#39;s runtime type, but my contents:
 411             return (T[]) Arrays.copyOf(elementData, size, a.getClass());
 412         System.arraycopy(elementData, 0, a, 0, size);
 413         if (a.length &gt; size)
 414             a[size] = null;
 415         return a;
 416     }
 417 
 418     // Positional Access Operations
 419 
 420     @SuppressWarnings(&quot;unchecked&quot;)
 421     E elementData(int index) {
 422         return (E) elementData[index];
 423     }
 424 
 425     @SuppressWarnings(&quot;unchecked&quot;)
 426     static &lt;E&gt; E elementAt(Object[] es, int index) {
 427         return (E) es[index];
 428     }
 429 
 430     /**
 431      * Returns the element at the specified position in this list.
 432      *
 433      * @param  index index of the element to return
 434      * @return the element at the specified position in this list
 435      * @throws IndexOutOfBoundsException {@inheritDoc}
 436      */
 437     public E get(int index) {
 438         Objects.checkIndex(index, size);
 439         return elementData(index);
 440     }
 441 
 442     /**
 443      * Replaces the element at the specified position in this list with
 444      * the specified element.
 445      *
 446      * @param index index of the element to replace
 447      * @param element element to be stored at the specified position
 448      * @return the element previously at the specified position
 449      * @throws IndexOutOfBoundsException {@inheritDoc}
 450      */
 451     public E set(int index, E element) {
 452         Objects.checkIndex(index, size);
 453         E oldValue = elementData(index);
 454         elementData[index] = element;
 455         return oldValue;
 456     }
 457 
 458     /**
 459      * This helper method split out from add(E) to keep method
 460      * bytecode size under 35 (the -XX:MaxInlineSize default value),
 461      * which helps when add(E) is called in a C1-compiled loop.
 462      */
 463     private void add(E e, Object[] elementData, int s) {
 464         if (s == elementData.length)
 465             elementData = grow();
 466         elementData[s] = e;
 467         size = s + 1;
 468     }
 469 
 470     /**
 471      * Appends the specified element to the end of this list.
 472      *
 473      * @param e element to be appended to this list
 474      * @return {@code true} (as specified by {@link Collection#add})
 475      */
 476     public boolean add(E e) {
 477         modCount++;
 478         add(e, elementData, size);
 479         return true;
 480     }
 481 
 482     /**
 483      * Inserts the specified element at the specified position in this
 484      * list. Shifts the element currently at that position (if any) and
 485      * any subsequent elements to the right (adds one to their indices).
 486      *
 487      * @param index index at which the specified element is to be inserted
 488      * @param element element to be inserted
 489      * @throws IndexOutOfBoundsException {@inheritDoc}
 490      */
 491     public void add(int index, E element) {
 492         rangeCheckForAdd(index);
 493         modCount++;
 494         final int s;
 495         Object[] elementData;
 496         if ((s = size) == (elementData = this.elementData).length)
 497             elementData = grow();
 498         System.arraycopy(elementData, index,
 499                          elementData, index + 1,
 500                          s - index);
 501         elementData[index] = element;
 502         size = s + 1;
 503     }
 504 
 505     /**
 506      * Removes the element at the specified position in this list.
 507      * Shifts any subsequent elements to the left (subtracts one from their
 508      * indices).
 509      *
 510      * @param index the index of the element to be removed
 511      * @return the element that was removed from the list
 512      * @throws IndexOutOfBoundsException {@inheritDoc}
 513      */
 514     public E remove(int index) {
 515         Objects.checkIndex(index, size);
 516         final Object[] es = elementData;
 517 
 518         @SuppressWarnings(&quot;unchecked&quot;) E oldValue = (E) es[index];
 519         fastRemove(es, index);
 520 
 521         return oldValue;
 522     }
 523 
 524     /**
 525      * {@inheritDoc}
 526      */
 527     public boolean equals(Object o) {
 528         if (o == this) {
 529             return true;
 530         }
 531 
 532         if (!(o instanceof List)) {
 533             return false;
 534         }
 535 
 536         final int expectedModCount = modCount;
 537         // XArrayList can be subclassed and given arbitrary behavior, but we can
 538         // still deal with the common case where o is XArrayList precisely
 539         boolean equal = (o.getClass() == XArrayList.class)
 540             ? equalsArrayList((XArrayList&lt;?&gt;) o)
 541             : equalsRange((List&lt;?&gt;) o, 0, size);
 542 
 543         checkForComodification(expectedModCount);
 544         return equal;
 545     }
 546 
 547     boolean equalsRange(List&lt;?&gt; other, int from, int to) {
 548         final Object[] es = elementData;
 549         if (to &gt; es.length) {
 550             throw new ConcurrentModificationException();
 551         }
 552         var oit = other.iterator();
 553         for (; from &lt; to; from++) {
 554             if (!oit.hasNext() || !Objects.equals(es[from], oit.next())) {
 555                 return false;
 556             }
 557         }
 558         return !oit.hasNext();
 559     }
 560 
 561     private boolean equalsArrayList(XArrayList&lt;?&gt; other) {
 562         final int otherModCount = other.modCount;
 563         final int s = size;
 564         boolean equal;
 565         if (equal = (s == other.size)) {
 566             final Object[] otherEs = other.elementData;
 567             final Object[] es = elementData;
 568             if (s &gt; es.length || s &gt; otherEs.length) {
 569                 throw new ConcurrentModificationException();
 570             }
 571             for (int i = 0; i &lt; s; i++) {
 572                 if (!Objects.equals(es[i], otherEs[i])) {
 573                     equal = false;
 574                     break;
 575                 }
 576             }
 577         }
 578         other.checkForComodification(otherModCount);
 579         return equal;
 580     }
 581 
 582     private void checkForComodification(final int expectedModCount) {
 583         if (modCount != expectedModCount) {
 584             throw new ConcurrentModificationException();
 585         }
 586     }
 587 
 588     /**
 589      * {@inheritDoc}
 590      */
 591     public int hashCode() {
 592         int expectedModCount = modCount;
 593         int hash = hashCodeRange(0, size);
 594         checkForComodification(expectedModCount);
 595         return hash;
 596     }
 597 
 598     int hashCodeRange(int from, int to) {
 599         final Object[] es = elementData;
 600         if (to &gt; es.length) {
 601             throw new ConcurrentModificationException();
 602         }
 603         int hashCode = 1;
 604         for (int i = from; i &lt; to; i++) {
 605             Object e = es[i];
 606             hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());
 607         }
 608         return hashCode;
 609     }
 610 
 611     /**
 612      * Removes the first occurrence of the specified element from this list,
 613      * if it is present.  If the list does not contain the element, it is
 614      * unchanged.  More formally, removes the element with the lowest index
 615      * {@code i} such that
 616      * {@code Objects.equals(o, get(i))}
 617      * (if such an element exists).  Returns {@code true} if this list
 618      * contained the specified element (or equivalently, if this list
 619      * changed as a result of the call).
 620      *
 621      * @param o element to be removed from this list, if present
 622      * @return {@code true} if this list contained the specified element
 623      */
 624     public boolean remove(Object o) {
 625         final Object[] es = elementData;
 626         final int size = this.size;
 627         int i = 0;
 628         found: {
 629             if (o == null) {
 630                 for (; i &lt; size; i++)
 631                     if (es[i] == null)
 632                         break found;
 633             } else {
 634                 for (; i &lt; size; i++)
 635                     if (o.equals(es[i]))
 636                         break found;
 637             }
 638             return false;
 639         }
 640         fastRemove(es, i);
 641         return true;
 642     }
 643 
 644     /**
 645      * Private remove method that skips bounds checking and does not
 646      * return the value removed.
 647      */
 648     private void fastRemove(Object[] es, int i) {
 649         modCount++;
 650         final int newSize;
 651         if ((newSize = size - 1) &gt; i)
 652             System.arraycopy(es, i + 1, es, i, newSize - i);
 653         es[size = newSize] = null;
 654     }
 655 
 656     /**
 657      * Removes all of the elements from this list.  The list will
 658      * be empty after this call returns.
 659      */
 660     public void clear() {
 661         modCount++;
 662         final Object[] es = elementData;
 663         for (int to = size, i = size = 0; i &lt; to; i++)
 664             es[i] = null;
 665     }
 666 
 667     /**
 668      * Appends all of the elements in the specified collection to the end of
 669      * this list, in the order that they are returned by the
 670      * specified collection&#39;s Iterator.  The behavior of this operation is
 671      * undefined if the specified collection is modified while the operation
 672      * is in progress.  (This implies that the behavior of this call is
 673      * undefined if the specified collection is this list, and this
 674      * list is nonempty.)
 675      *
 676      * @param c collection containing elements to be added to this list
 677      * @return {@code true} if this list changed as a result of the call
 678      * @throws NullPointerException if the specified collection is null
 679      */
 680     public boolean addAll(Collection&lt;? extends E&gt; c) {
 681         Object[] a = c.toArray();
 682         modCount++;
 683         int numNew = a.length;
 684         if (numNew == 0)
 685             return false;
 686         Object[] elementData;
 687         final int s;
 688         if (numNew &gt; (elementData = this.elementData).length - (s = size))
 689             elementData = grow(s + numNew);
 690         System.arraycopy(a, 0, elementData, s, numNew);
 691         size = s + numNew;
 692         return true;
 693     }
 694 
 695     /**
 696      * Inserts all of the elements in the specified collection into this
 697      * list, starting at the specified position.  Shifts the element
 698      * currently at that position (if any) and any subsequent elements to
 699      * the right (increases their indices).  The new elements will appear
 700      * in the list in the order that they are returned by the
 701      * specified collection&#39;s iterator.
 702      *
 703      * @param index index at which to insert the first element from the
 704      *              specified collection
 705      * @param c collection containing elements to be added to this list
 706      * @return {@code true} if this list changed as a result of the call
 707      * @throws IndexOutOfBoundsException {@inheritDoc}
 708      * @throws NullPointerException if the specified collection is null
 709      */
 710     public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
 711         rangeCheckForAdd(index);
 712 
 713         Object[] a = c.toArray();
 714         modCount++;
 715         int numNew = a.length;
 716         if (numNew == 0)
 717             return false;
 718         Object[] elementData;
 719         final int s;
 720         if (numNew &gt; (elementData = this.elementData).length - (s = size))
 721             elementData = grow(s + numNew);
 722 
 723         int numMoved = s - index;
 724         if (numMoved &gt; 0)
 725             System.arraycopy(elementData, index,
 726                              elementData, index + numNew,
 727                              numMoved);
 728         System.arraycopy(a, 0, elementData, index, numNew);
 729         size = s + numNew;
 730         return true;
 731     }
 732 
 733     /**
 734      * Removes from this list all of the elements whose index is between
 735      * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
 736      * Shifts any succeeding elements to the left (reduces their index).
 737      * This call shortens the list by {@code (toIndex - fromIndex)} elements.
 738      * (If {@code toIndex==fromIndex}, this operation has no effect.)
 739      *
 740      * @throws IndexOutOfBoundsException if {@code fromIndex} or
 741      *         {@code toIndex} is out of range
 742      *         ({@code fromIndex &lt; 0 ||
 743      *          toIndex &gt; size() ||
 744      *          toIndex &lt; fromIndex})
 745      */
 746     protected void removeRange(int fromIndex, int toIndex) {
 747         if (fromIndex &gt; toIndex) {
 748             throw new IndexOutOfBoundsException(
 749                     outOfBoundsMsg(fromIndex, toIndex));
 750         }
 751         modCount++;
 752         shiftTailOverGap(elementData, fromIndex, toIndex);
 753     }
 754 
 755     /** Erases the gap from lo to hi, by sliding down following elements. */
 756     private void shiftTailOverGap(Object[] es, int lo, int hi) {
 757         System.arraycopy(es, hi, es, lo, size - hi);
 758         for (int to = size, i = (size -= hi - lo); i &lt; to; i++)
 759             es[i] = null;
 760     }
 761 
 762     /**
 763      * A version of rangeCheck used by add and addAll.
 764      */
 765     private void rangeCheckForAdd(int index) {
 766         if (index &gt; size || index &lt; 0)
 767             throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
 768     }
 769 
 770     /**
 771      * Constructs an IndexOutOfBoundsException detail message.
 772      * Of the many possible refactorings of the error handling code,
 773      * this &quot;outlining&quot; performs best with both server and client VMs.
 774      */
 775     private String outOfBoundsMsg(int index) {
 776         return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
 777     }
 778 
 779     /**
 780      * A version used in checking (fromIndex &gt; toIndex) condition
 781      */
 782     private static String outOfBoundsMsg(int fromIndex, int toIndex) {
 783         return &quot;From Index: &quot; + fromIndex + &quot; &gt; To Index: &quot; + toIndex;
 784     }
 785 
 786     /**
 787      * Removes from this list all of its elements that are contained in the
 788      * specified collection.
 789      *
 790      * @param c collection containing elements to be removed from this list
 791      * @return {@code true} if this list changed as a result of the call
 792      * @throws ClassCastException if the class of an element of this list
 793      *         is incompatible with the specified collection
 794      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 795      * @throws NullPointerException if this list contains a null element and the
 796      *         specified collection does not permit null elements
 797      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 798      *         or if the specified collection is null
 799      * @see Collection#contains(Object)
 800      */
 801     public boolean removeAll(Collection&lt;?&gt; c) {
 802         return batchRemove(c, false, 0, size);
 803     }
 804 
 805     /**
 806      * Retains only the elements in this list that are contained in the
 807      * specified collection.  In other words, removes from this list all
 808      * of its elements that are not contained in the specified collection.
 809      *
 810      * @param c collection containing elements to be retained in this list
 811      * @return {@code true} if this list changed as a result of the call
 812      * @throws ClassCastException if the class of an element of this list
 813      *         is incompatible with the specified collection
 814      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 815      * @throws NullPointerException if this list contains a null element and the
 816      *         specified collection does not permit null elements
 817      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 818      *         or if the specified collection is null
 819      * @see Collection#contains(Object)
 820      */
 821     public boolean retainAll(Collection&lt;?&gt; c) {
 822         return batchRemove(c, true, 0, size);
 823     }
 824 
 825     boolean batchRemove(Collection&lt;?&gt; c, boolean complement,
 826                         final int from, final int end) {
 827         Objects.requireNonNull(c);
 828         final Object[] es = elementData;
 829         int r;
 830         // Optimize for initial run of survivors
 831         for (r = from;; r++) {
 832             if (r == end)
 833                 return false;
 834             if (c.contains(es[r]) != complement)
 835                 break;
 836         }
 837         int w = r++;
 838         try {
 839             for (Object e; r &lt; end; r++)
 840                 if (c.contains(e = es[r]) == complement)
 841                     es[w++] = e;
 842         } catch (Throwable ex) {
 843             // Preserve behavioral compatibility with AbstractCollection,
 844             // even if c.contains() throws.
 845             System.arraycopy(es, r, es, w, end - r);
 846             w += end - r;
 847             throw ex;
 848         } finally {
 849             modCount += end - w;
 850             shiftTailOverGap(es, w, end);
 851         }
 852         return true;
 853     }
 854 
 855     /**
 856      * Saves the state of the {@code XArrayList} instance to a stream
 857      * (that is, serializes it).
 858      *
 859      * @param s the stream
 860      * @throws java.io.IOException if an I/O error occurs
 861      * @serialData The length of the array backing the {@code XArrayList}
 862      *             instance is emitted (int), followed by all of its elements
 863      *             (each an {@code Object}) in the proper order.
 864      */
 865     private void writeObject(java.io.ObjectOutputStream s)
 866         throws java.io.IOException {
 867         // Write out element count, and any hidden stuff
 868         int expectedModCount = modCount;
 869         s.defaultWriteObject();
 870 
 871         // Write out size as capacity for behavioral compatibility with clone()
 872         s.writeInt(size);
 873 
 874         // Write out all elements in the proper order.
 875         for (int i=0; i&lt;size; i++) {
 876             s.writeObject(elementData[i]);
 877         }
 878 
 879         if (modCount != expectedModCount) {
 880             throw new ConcurrentModificationException();
 881         }
 882     }
 883 
 884     /**
 885      * Reconstitutes the {@code XArrayList} instance from a stream (that is,
 886      * deserializes it).
 887      * @param s the stream
 888      * @throws ClassNotFoundException if the class of a serialized object
 889      *         could not be found
 890      * @throws java.io.IOException if an I/O error occurs
 891      */
 892     private void readObject(java.io.ObjectInputStream s)
 893         throws java.io.IOException, ClassNotFoundException {
 894 
 895         // Read in size, and any hidden stuff
 896         s.defaultReadObject();
 897 
 898         // Read in capacity
 899         s.readInt(); // ignored
 900 
 901         if (size &gt; 0) {
 902             // like clone(), allocate array based upon size not capacity
 903             //SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
 904             Object[] elements = new Object[size];
 905 
 906             // Read in all elements in the proper order.
 907             for (int i = 0; i &lt; size; i++) {
 908                 elements[i] = s.readObject();
 909             }
 910 
 911             elementData = elements;
 912         } else if (size == 0) {
 913             elementData = EMPTY_ELEMENTDATA;
 914         } else {
 915             throw new java.io.InvalidObjectException(&quot;Invalid size: &quot; + size);
 916         }
 917     }
 918 
 919     /**
 920      * Returns a list iterator over the elements in this list (in proper
 921      * sequence), starting at the specified position in the list.
 922      * The specified index indicates the first element that would be
 923      * returned by an initial call to {@link ListIterator#next next}.
 924      * An initial call to {@link ListIterator#previous previous} would
 925      * return the element with the specified index minus one.
 926      *
 927      * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 928      *
 929      * @throws IndexOutOfBoundsException {@inheritDoc}
 930      */
 931     public ListIterator&lt;E&gt; listIterator(int index) {
 932         rangeCheckForAdd(index);
 933         return new ListItr(index);
 934     }
 935 
 936     /**
 937      * Returns a list iterator over the elements in this list (in proper
 938      * sequence).
 939      *
 940      * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 941      *
 942      * @see #listIterator(int)
 943      */
 944     public ListIterator&lt;E&gt; listIterator() {
 945         return new ListItr(0);
 946     }
 947 
 948     /**
 949      * Returns an iterator over the elements in this list in proper sequence.
 950      *
 951      * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 952      *
 953      * @return an iterator over the elements in this list in proper sequence
 954      */
 955     public Iterator&lt;E&gt; iterator() {
 956         return new Itr();
 957     }
 958 
 959     /**
 960      * An optimized version of AbstractList.Itr
 961      */
 962     private class Itr implements Iterator&lt;E&gt; {
 963         int cursor;       // index of next element to return
 964         int lastRet = -1; // index of last element returned; -1 if no such
 965         int expectedModCount = modCount;
 966 
 967         // prevent creating a synthetic constructor
 968         Itr() {}
 969 
 970         public boolean hasNext() {
 971             return cursor != size;
 972         }
 973 
 974         @SuppressWarnings(&quot;unchecked&quot;)
 975         public E next() {
 976             checkForComodification();
 977             int i = cursor;
 978             if (i &gt;= size)
 979                 throw new NoSuchElementException();
 980             Object[] elementData = XArrayList.this.elementData;
 981             if (i &gt;= elementData.length)
 982                 throw new ConcurrentModificationException();
 983             cursor = i + 1;
 984             return (E) elementData[lastRet = i];
 985         }
 986 
 987         public void remove() {
 988             if (lastRet &lt; 0)
 989                 throw new IllegalStateException();
 990             checkForComodification();
 991 
 992             try {
 993                 XArrayList.this.remove(lastRet);
 994                 cursor = lastRet;
 995                 lastRet = -1;
 996                 expectedModCount = modCount;
 997             } catch (IndexOutOfBoundsException ex) {
 998                 throw new ConcurrentModificationException();
 999             }
1000         }
1001 
1002         @Override
1003         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1004             Objects.requireNonNull(action);
1005             final int size = XArrayList.this.size;
1006             int i = cursor;
1007             if (i &lt; size) {
1008                 final Object[] es = elementData;
1009                 if (i &gt;= es.length)
1010                     throw new ConcurrentModificationException();
1011                 for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++)
1012                     action.accept(elementAt(es, i));
1013                 // update once at end to reduce heap write traffic
1014                 cursor = i;
1015                 lastRet = i - 1;
1016                 checkForComodification();
1017             }
1018         }
1019 
1020         final void checkForComodification() {
1021             if (modCount != expectedModCount)
1022                 throw new ConcurrentModificationException();
1023         }
1024     }
1025 
1026     /**
1027      * An optimized version of AbstractList.ListItr
1028      */
1029     private class ListItr extends Itr implements ListIterator&lt;E&gt; {
1030         ListItr(int index) {
1031             super();
1032             cursor = index;
1033         }
1034 
1035         public boolean hasPrevious() {
1036             return cursor != 0;
1037         }
1038 
1039         public int nextIndex() {
1040             return cursor;
1041         }
1042 
1043         public int previousIndex() {
1044             return cursor - 1;
1045         }
1046 
1047         @SuppressWarnings(&quot;unchecked&quot;)
1048         public E previous() {
1049             checkForComodification();
1050             int i = cursor - 1;
1051             if (i &lt; 0)
1052                 throw new NoSuchElementException();
1053             Object[] elementData = XArrayList.this.elementData;
1054             if (i &gt;= elementData.length)
1055                 throw new ConcurrentModificationException();
1056             cursor = i;
1057             return (E) elementData[lastRet = i];
1058         }
1059 
1060         public void set(E e) {
1061             if (lastRet &lt; 0)
1062                 throw new IllegalStateException();
1063             checkForComodification();
1064 
1065             try {
1066                 XArrayList.this.set(lastRet, e);
1067             } catch (IndexOutOfBoundsException ex) {
1068                 throw new ConcurrentModificationException();
1069             }
1070         }
1071 
1072         public void add(E e) {
1073             checkForComodification();
1074 
1075             try {
1076                 int i = cursor;
1077                 XArrayList.this.add(i, e);
1078                 cursor = i + 1;
1079                 lastRet = -1;
1080                 expectedModCount = modCount;
1081             } catch (IndexOutOfBoundsException ex) {
1082                 throw new ConcurrentModificationException();
1083             }
1084         }
1085     }
1086 
1087     /**
1088      * Return a new cursor for this XArrayList.
1089      * @return a cursor
1090      */
1091     public InlineCursor&lt;E&gt; cursor() {
1092         return new AListCursor&lt;&gt;(0);
1093     }
1094 
1095     /**
1096      * Create an inline cursor for this XArrayList.
1097      */
1098     private inline class AListCursor&lt;E&gt; implements InlineCursor&lt;E&gt; {
1099         // Inner class field &#39;this&#39; is initialized
<a name="1" id="anc1"></a><span class="line-modified">1100         int index;          // index of next element to return; if neg is removed index</span>
1101         int expectedModCount;
1102 
<a name="2" id="anc2"></a><span class="line-removed">1103         /**</span>
<span class="line-removed">1104          * Return true if the element has been removed.</span>
<span class="line-removed">1105          * @return true if the element has been removed</span>
<span class="line-removed">1106          */</span>
<span class="line-removed">1107         private boolean isRemoved() {</span>
<span class="line-removed">1108             return index &lt; 0;</span>
<span class="line-removed">1109         }</span>
<span class="line-removed">1110 </span>
1111         /**
1112          * Create a new Cursor for this XArrayList.
1113          *
<a name="3" id="anc3"></a><span class="line-modified">1114          * @param cursor index if positive;</span>
<span class="line-removed">1115          *               if negative is the inverse (not) of a removed element</span>
1116          */
1117         public AListCursor(int cursor) {
1118             this.index = cursor;
1119             this.expectedModCount = XArrayList.this.modCount;
1120         }
1121 
<a name="4" id="anc4"></a><span class="line-removed">1122         /**</span>
<span class="line-removed">1123          * Return true if the index is in range for the Collection</span>
<span class="line-removed">1124          * and has not been explicitly removed.</span>
<span class="line-removed">1125          * It does NOT check for co-modification.</span>
<span class="line-removed">1126          *</span>
<span class="line-removed">1127          * @param cursor and index</span>
<span class="line-removed">1128          * @return true if the index is a valid index.</span>
<span class="line-removed">1129          */</span>
<span class="line-removed">1130         private boolean validIndex(int cursor) {</span>
<span class="line-removed">1131             return cursor &gt;= 0 &amp;&amp; cursor &lt; XArrayList.this.size;</span>
<span class="line-removed">1132         }</span>
<span class="line-removed">1133 </span>
1134         @Override
1135         public boolean exists() {
<a name="5" id="anc5"></a><span class="line-modified">1136             return validIndex(index);</span>
1137         }
1138 
1139         @SuppressWarnings(&quot;unchecked&quot;)
1140         public E get() {
<a name="6" id="anc6"></a><span class="line-modified">1141             if (!validIndex(index))</span>
<span class="line-modified">1142                 throw new NoSuchElementException();</span>
<span class="line-modified">1143             checkForComodification();</span>
<span class="line-modified">1144             try {</span>
<span class="line-modified">1145                 Object[] elementData = XArrayList.this.elementData;</span>
<span class="line-modified">1146                 return (E) elementData[index];</span>
<span class="line-modified">1147             } catch (ArrayIndexOutOfBoundsException aioobe) {</span>
<span class="line-removed">1148                 throw new ConcurrentModificationException();</span>
1149             }
<a name="7" id="anc7"></a>
1150         }
1151 
1152         @Override
1153         public AListCursor&lt;E&gt; advance() {
<a name="8" id="anc8"></a><span class="line-removed">1154             checkForComodification();   // Reject if Collection has changed</span>
1155             // new Cursor will have a current expectedModCount
1156             // TBD: Saturate index?  So calling adv, adv, adv, prev == last
<a name="9" id="anc9"></a><span class="line-modified">1157             return new AListCursor&lt;&gt;(isRemoved() ? ~index : index + 1);</span>
<span class="line-removed">1158         }</span>
<span class="line-removed">1159 </span>
<span class="line-removed">1160         @Override</span>
<span class="line-removed">1161         public AListCursor&lt;E&gt; remove() {</span>
<span class="line-removed">1162             if (!validIndex(index))</span>
<span class="line-removed">1163                 throw new NoSuchElementException();</span>
<span class="line-removed">1164             checkForComodification();</span>
<span class="line-removed">1165             try {</span>
<span class="line-removed">1166                 XArrayList.this.remove(index);</span>
<span class="line-removed">1167                 return new AListCursor&lt;&gt;(~index); // invert for removed index</span>
<span class="line-removed">1168             } catch (IndexOutOfBoundsException ex) {</span>
<span class="line-removed">1169                 throw new ConcurrentModificationException();</span>
<span class="line-removed">1170             }</span>
1171         }
1172 
1173         final void checkForComodification() {
1174             if (XArrayList.this.modCount != expectedModCount)
1175                 throw new ConcurrentModificationException();
1176         }
1177     }
1178 
1179     /**
1180      * Returns a iterator (Using an InlineCursor) over the elements in this list in proper sequence.
1181      *
1182      * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
1183      *
1184      * @return an iterator over the elements in this list in proper sequence
1185      */
1186     public Iterator&lt;E&gt; iteratorCurs() {
1187         return new CurItr();
1188     }
1189 
1190     /**
1191      * Iterate using a Cursor.
1192      */
1193     private class CurItr implements Iterator&lt;E&gt; {
1194         AListCursor&lt;E&gt; cursor;
1195         AListCursor&lt;E&gt; lastRet;
1196 
1197         // prevent creating a synthetic constructor
1198         CurItr() {
1199             this.cursor = new AListCursor&lt;E&gt;(0);
1200             this.lastRet = this.cursor;
1201         }
1202 
1203         public boolean hasNext() {
1204             return cursor.advance().exists();
1205         }
1206 
1207         @SuppressWarnings(&quot;unchecked&quot;)
1208         public E next() {
1209             E val = cursor.get();
1210             lastRet = cursor;
1211             cursor = cursor.advance();
1212             return val;
1213         }
1214 
<a name="10" id="anc10"></a><span class="line-removed">1215         public void remove() {</span>
<span class="line-removed">1216             if (lastRet.exists())</span>
<span class="line-removed">1217                 lastRet.remove();</span>
<span class="line-removed">1218             else</span>
<span class="line-removed">1219                 throw new IllegalStateException();</span>
<span class="line-removed">1220         }</span>
<span class="line-removed">1221 </span>
1222         @Override
1223         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1224             Objects.requireNonNull(action);
1225 
1226             AListCursor&lt;E&gt; cur = cursor;
1227             while (cur.exists()) {
1228                 E val = cur.get();
1229                 action.accept(val);
1230                 cur = cur.advance();
1231             }
1232             cursor = cur;
1233         }
1234 
1235         public String toString() {
1236             return &quot;cur: &quot; + cursor;
1237         }
1238     }
1239 
1240 
1241     /**
1242      * Returns a view of the portion of this list between the specified
1243      * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If
1244      * {@code fromIndex} and {@code toIndex} are equal, the returned list is
1245      * empty.)  The returned list is backed by this list, so non-structural
1246      * changes in the returned list are reflected in this list, and vice-versa.
1247      * The returned list supports all of the optional list operations.
1248      *
1249      * &lt;p&gt;This method eliminates the need for explicit range operations (of
1250      * the sort that commonly exist for arrays).  Any operation that expects
1251      * a list can be used as a range operation by passing a subList view
1252      * instead of a whole list.  For example, the following idiom
1253      * removes a range of elements from a list:
1254      * &lt;pre&gt;
1255      *      list.subList(from, to).clear();
1256      * &lt;/pre&gt;
1257      * Similar idioms may be constructed for {@link #indexOf(Object)} and
1258      * {@link #lastIndexOf(Object)}, and all of the algorithms in the
1259      * {@link Collections} class can be applied to a subList.
1260      *
1261      * &lt;p&gt;The semantics of the list returned by this method become undefined if
1262      * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in
1263      * any way other than via the returned list.  (Structural modifications are
1264      * those that change the size of this list, or otherwise perturb it in such
1265      * a fashion that iterations in progress may yield incorrect results.)
1266      *
1267      * @throws IndexOutOfBoundsException {@inheritDoc}
1268      * @throws IllegalArgumentException {@inheritDoc}
1269      */
1270     public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1271         subListRangeCheck(fromIndex, toIndex, size);
1272         return new SubList&lt;&gt;(this, fromIndex, toIndex);
1273     }
1274 
1275     private static class SubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess {
1276         private final XArrayList&lt;E&gt; root;
1277         private final SubList&lt;E&gt; parent;
1278         private final int offset;
1279         private int size;
1280 
1281         /**
1282          * Constructs a sublist of an arbitrary XArrayList.
1283          */
1284         public SubList(XArrayList&lt;E&gt; root, int fromIndex, int toIndex) {
1285             this.root = root;
1286             this.parent = null;
1287             this.offset = fromIndex;
1288             this.size = toIndex - fromIndex;
1289             this.modCount = root.modCount;
1290         }
1291 
1292         /**
1293          * Constructs a sublist of another SubList.
1294          */
1295         private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) {
1296             this.root = parent.root;
1297             this.parent = parent;
1298             this.offset = parent.offset + fromIndex;
1299             this.size = toIndex - fromIndex;
1300             this.modCount = root.modCount;
1301         }
1302 
1303         public E set(int index, E element) {
1304             Objects.checkIndex(index, size);
1305             checkForComodification();
1306             E oldValue = root.elementData(offset + index);
1307             root.elementData[offset + index] = element;
1308             return oldValue;
1309         }
1310 
1311         public E get(int index) {
1312             Objects.checkIndex(index, size);
1313             checkForComodification();
1314             return root.elementData(offset + index);
1315         }
1316 
1317         public int size() {
1318             checkForComodification();
1319             return size;
1320         }
1321 
1322         public void add(int index, E element) {
1323             rangeCheckForAdd(index);
1324             checkForComodification();
1325             root.add(offset + index, element);
1326             updateSizeAndModCount(1);
1327         }
1328 
1329         public E remove(int index) {
1330             Objects.checkIndex(index, size);
1331             checkForComodification();
1332             E result = root.remove(offset + index);
1333             updateSizeAndModCount(-1);
1334             return result;
1335         }
1336 
1337         protected void removeRange(int fromIndex, int toIndex) {
1338             checkForComodification();
1339             root.removeRange(offset + fromIndex, offset + toIndex);
1340             updateSizeAndModCount(fromIndex - toIndex);
1341         }
1342 
1343         public boolean addAll(Collection&lt;? extends E&gt; c) {
1344             return addAll(this.size, c);
1345         }
1346 
1347         public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
1348             rangeCheckForAdd(index);
1349             int cSize = c.size();
1350             if (cSize==0)
1351                 return false;
1352             checkForComodification();
1353             root.addAll(offset + index, c);
1354             updateSizeAndModCount(cSize);
1355             return true;
1356         }
1357 
1358         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
1359             root.replaceAllRange(operator, offset, offset + size);
1360         }
1361 
1362         public boolean removeAll(Collection&lt;?&gt; c) {
1363             return batchRemove(c, false);
1364         }
1365 
1366         public boolean retainAll(Collection&lt;?&gt; c) {
1367             return batchRemove(c, true);
1368         }
1369 
1370         private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
1371             checkForComodification();
1372             int oldSize = root.size;
1373             boolean modified =
1374                 root.batchRemove(c, complement, offset, offset + size);
1375             if (modified)
1376                 updateSizeAndModCount(root.size - oldSize);
1377             return modified;
1378         }
1379 
1380         public boolean removeIf(Predicate&lt;? super E&gt; filter) {
1381             checkForComodification();
1382             int oldSize = root.size;
1383             boolean modified = root.removeIf(filter, offset, offset + size);
1384             if (modified)
1385                 updateSizeAndModCount(root.size - oldSize);
1386             return modified;
1387         }
1388 
1389         public Object[] toArray() {
1390             checkForComodification();
1391             return Arrays.copyOfRange(root.elementData, offset, offset + size);
1392         }
1393 
1394         @SuppressWarnings(&quot;unchecked&quot;)
1395         public &lt;T&gt; T[] toArray(T[] a) {
1396             checkForComodification();
1397             if (a.length &lt; size)
1398                 return (T[]) Arrays.copyOfRange(
1399                         root.elementData, offset, offset + size, a.getClass());
1400             System.arraycopy(root.elementData, offset, a, 0, size);
1401             if (a.length &gt; size)
1402                 a[size] = null;
1403             return a;
1404         }
1405 
1406         public boolean equals(Object o) {
1407             if (o == this) {
1408                 return true;
1409             }
1410 
1411             if (!(o instanceof List)) {
1412                 return false;
1413             }
1414 
1415             boolean equal = root.equalsRange((List&lt;?&gt;)o, offset, offset + size);
1416             checkForComodification();
1417             return equal;
1418         }
1419 
1420         public int hashCode() {
1421             int hash = root.hashCodeRange(offset, offset + size);
1422             checkForComodification();
1423             return hash;
1424         }
1425 
1426         public int indexOf(Object o) {
1427             int index = root.indexOfRange(o, offset, offset + size);
1428             checkForComodification();
1429             return index &gt;= 0 ? index - offset : -1;
1430         }
1431 
1432         public int lastIndexOf(Object o) {
1433             int index = root.lastIndexOfRange(o, offset, offset + size);
1434             checkForComodification();
1435             return index &gt;= 0 ? index - offset : -1;
1436         }
1437 
1438         public boolean contains(Object o) {
1439             return indexOf(o) &gt;= 0;
1440         }
1441 
1442         public Iterator&lt;E&gt; iterator() {
1443             return listIterator();
1444         }
1445 
1446         public ListIterator&lt;E&gt; listIterator(int index) {
1447             checkForComodification();
1448             rangeCheckForAdd(index);
1449 
1450             return new ListIterator&lt;E&gt;() {
1451                 int cursor = index;
1452                 int lastRet = -1;
1453                 int expectedModCount = root.modCount;
1454 
1455                 public boolean hasNext() {
1456                     return cursor != SubList.this.size;
1457                 }
1458 
1459                 @SuppressWarnings(&quot;unchecked&quot;)
1460                 public E next() {
1461                     checkForComodification();
1462                     int i = cursor;
1463                     if (i &gt;= SubList.this.size)
1464                         throw new NoSuchElementException();
1465                     Object[] elementData = root.elementData;
1466                     if (offset + i &gt;= elementData.length)
1467                         throw new ConcurrentModificationException();
1468                     cursor = i + 1;
1469                     return (E) elementData[offset + (lastRet = i)];
1470                 }
1471 
1472                 public boolean hasPrevious() {
1473                     return cursor != 0;
1474                 }
1475 
1476                 @SuppressWarnings(&quot;unchecked&quot;)
1477                 public E previous() {
1478                     checkForComodification();
1479                     int i = cursor - 1;
1480                     if (i &lt; 0)
1481                         throw new NoSuchElementException();
1482                     Object[] elementData = root.elementData;
1483                     if (offset + i &gt;= elementData.length)
1484                         throw new ConcurrentModificationException();
1485                     cursor = i;
1486                     return (E) elementData[offset + (lastRet = i)];
1487                 }
1488 
1489                 public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1490                     Objects.requireNonNull(action);
1491                     final int size = SubList.this.size;
1492                     int i = cursor;
1493                     if (i &lt; size) {
1494                         final Object[] es = root.elementData;
1495                         if (offset + i &gt;= es.length)
1496                             throw new ConcurrentModificationException();
1497                         for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++)
1498                             action.accept(elementAt(es, offset + i));
1499                         // update once at end to reduce heap write traffic
1500                         cursor = i;
1501                         lastRet = i - 1;
1502                         checkForComodification();
1503                     }
1504                 }
1505 
1506                 public int nextIndex() {
1507                     return cursor;
1508                 }
1509 
1510                 public int previousIndex() {
1511                     return cursor - 1;
1512                 }
1513 
1514                 public void remove() {
1515                     if (lastRet &lt; 0)
1516                         throw new IllegalStateException();
1517                     checkForComodification();
1518 
1519                     try {
1520                         SubList.this.remove(lastRet);
1521                         cursor = lastRet;
1522                         lastRet = -1;
1523                         expectedModCount = root.modCount;
1524                     } catch (IndexOutOfBoundsException ex) {
1525                         throw new ConcurrentModificationException();
1526                     }
1527                 }
1528 
1529                 public void set(E e) {
1530                     if (lastRet &lt; 0)
1531                         throw new IllegalStateException();
1532                     checkForComodification();
1533 
1534                     try {
1535                         root.set(offset + lastRet, e);
1536                     } catch (IndexOutOfBoundsException ex) {
1537                         throw new ConcurrentModificationException();
1538                     }
1539                 }
1540 
1541                 public void add(E e) {
1542                     checkForComodification();
1543 
1544                     try {
1545                         int i = cursor;
1546                         SubList.this.add(i, e);
1547                         cursor = i + 1;
1548                         lastRet = -1;
1549                         expectedModCount = root.modCount;
1550                     } catch (IndexOutOfBoundsException ex) {
1551                         throw new ConcurrentModificationException();
1552                     }
1553                 }
1554 
1555                 final void checkForComodification() {
1556                     if (root.modCount != expectedModCount)
1557                         throw new ConcurrentModificationException();
1558                 }
1559             };
1560         }
1561 
1562         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1563             subListRangeCheck(fromIndex, toIndex, size);
1564             return new SubList&lt;&gt;(this, fromIndex, toIndex);
1565         }
1566 
1567         private void rangeCheckForAdd(int index) {
1568             if (index &lt; 0 || index &gt; this.size)
1569                 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
1570         }
1571 
1572         private String outOfBoundsMsg(int index) {
1573             return &quot;Index: &quot;+index+&quot;, Size: &quot;+this.size;
1574         }
1575 
1576         private void checkForComodification() {
1577             if (root.modCount != modCount)
1578                 throw new ConcurrentModificationException();
1579         }
1580 
1581         private void updateSizeAndModCount(int sizeChange) {
1582             SubList&lt;E&gt; slist = this;
1583             do {
1584                 slist.size += sizeChange;
1585                 slist.modCount = root.modCount;
1586                 slist = slist.parent;
1587             } while (slist != null);
1588         }
1589 
1590         public Spliterator&lt;E&gt; spliterator() {
1591             checkForComodification();
1592 
1593             // ArrayListSpliterator not used here due to late-binding
1594             return new Spliterator&lt;E&gt;() {
1595                 private int index = offset; // current index, modified on advance/split
1596                 private int fence = -1; // -1 until used; then one past last index
1597                 private int expectedModCount; // initialized when fence set
1598 
1599                 private int getFence() { // initialize fence to size on first use
1600                     int hi; // (a specialized variant appears in method forEach)
1601                     if ((hi = fence) &lt; 0) {
1602                         expectedModCount = modCount;
1603                         hi = fence = offset + size;
1604                     }
1605                     return hi;
1606                 }
1607 
1608                 public XArrayList&lt;E&gt;.ArrayListSpliterator trySplit() {
1609                     int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
1610                     // ArrayListSpliterator can be used here as the source is already bound
1611                     return (lo &gt;= mid) ? null : // divide range in half unless too small
1612                         root.new ArrayListSpliterator(lo, index = mid, expectedModCount);
1613                 }
1614 
1615                 public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
1616                     Objects.requireNonNull(action);
1617                     int hi = getFence(), i = index;
1618                     if (i &lt; hi) {
1619                         index = i + 1;
1620                         @SuppressWarnings(&quot;unchecked&quot;) E e = (E)root.elementData[i];
1621                         action.accept(e);
1622                         if (root.modCount != expectedModCount)
1623                             throw new ConcurrentModificationException();
1624                         return true;
1625                     }
1626                     return false;
1627                 }
1628 
1629                 public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1630                     Objects.requireNonNull(action);
1631                     int i, hi, mc; // hoist accesses and checks from loop
1632                     XArrayList&lt;E&gt; lst = root;
1633                     Object[] a;
1634                     if ((a = lst.elementData) != null) {
1635                         if ((hi = fence) &lt; 0) {
1636                             mc = modCount;
1637                             hi = offset + size;
1638                         }
1639                         else
1640                             mc = expectedModCount;
1641                         if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) {
1642                             for (; i &lt; hi; ++i) {
1643                                 @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i];
1644                                 action.accept(e);
1645                             }
1646                             if (lst.modCount == mc)
1647                                 return;
1648                         }
1649                     }
1650                     throw new ConcurrentModificationException();
1651                 }
1652 
1653                 public long estimateSize() {
1654                     return getFence() - index;
1655                 }
1656 
1657                 public int characteristics() {
1658                     return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
1659                 }
1660             };
1661         }
1662     }
1663 
1664     /**
1665      * @throws NullPointerException {@inheritDoc}
1666      */
1667     @Override
1668     public void forEach(Consumer&lt;? super E&gt; action) {
1669         Objects.requireNonNull(action);
1670         final int expectedModCount = modCount;
1671         final Object[] es = elementData;
1672         final int size = this.size;
1673         for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++)
1674             action.accept(elementAt(es, i));
1675         if (modCount != expectedModCount)
1676             throw new ConcurrentModificationException();
1677     }
1678 
1679     /**
1680      * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
1681      * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this
1682      * list.
1683      *
1684      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED},
1685      * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
1686      * Overriding implementations should document the reporting of additional
1687      * characteristic values.
1688      *
1689      * @return a {@code Spliterator} over the elements in this list
1690      * @since 1.8
1691      */
1692     @Override
1693     public Spliterator&lt;E&gt; spliterator() {
1694         return new ArrayListSpliterator(0, -1, 0);
1695     }
1696 
1697     /** Index-based split-by-two, lazily initialized Spliterator */
1698     final class ArrayListSpliterator implements Spliterator&lt;E&gt; {
1699 
1700         /*
1701          * If XArrayLists were immutable, or structurally immutable (no
1702          * adds, removes, etc), we could implement their spliterators
1703          * with Arrays.spliterator. Instead we detect as much
1704          * interference during traversal as practical without
1705          * sacrificing much performance. We rely primarily on
1706          * modCounts. These are not guaranteed to detect concurrency
1707          * violations, and are sometimes overly conservative about
1708          * within-thread interference, but detect enough problems to
1709          * be worthwhile in practice. To carry this out, we (1) lazily
1710          * initialize fence and expectedModCount until the latest
1711          * point that we need to commit to the state we are checking
1712          * against; thus improving precision.  (This doesn&#39;t apply to
1713          * SubLists, that create spliterators with current non-lazy
1714          * values).  (2) We perform only a single
1715          * ConcurrentModificationException check at the end of forEach
1716          * (the most performance-sensitive method). When using forEach
1717          * (as opposed to iterators), we can normally only detect
1718          * interference after actions, not before. Further
1719          * CME-triggering checks apply to all other possible
1720          * violations of assumptions for example null or too-small
1721          * elementData array given its size(), that could only have
1722          * occurred due to interference.  This allows the inner loop
1723          * of forEach to run without any further checks, and
1724          * simplifies lambda-resolution. While this does entail a
1725          * number of checks, note that in the common case of
1726          * list.stream().forEach(a), no checks or other computation
1727          * occur anywhere other than inside forEach itself.  The other
1728          * less-often-used methods cannot take advantage of most of
1729          * these streamlinings.
1730          */
1731 
1732         private int index; // current index, modified on advance/split
1733         private int fence; // -1 until used; then one past last index
1734         private int expectedModCount; // initialized when fence set
1735 
1736         /** Creates new spliterator covering the given range. */
1737         ArrayListSpliterator(int origin, int fence, int expectedModCount) {
1738             this.index = origin;
1739             this.fence = fence;
1740             this.expectedModCount = expectedModCount;
1741         }
1742 
1743         private int getFence() { // initialize fence to size on first use
1744             int hi; // (a specialized variant appears in method forEach)
1745             if ((hi = fence) &lt; 0) {
1746                 expectedModCount = modCount;
1747                 hi = fence = size;
1748             }
1749             return hi;
1750         }
1751 
1752         public ArrayListSpliterator trySplit() {
1753             int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
1754             return (lo &gt;= mid) ? null : // divide range in half unless too small
1755                 new ArrayListSpliterator(lo, index = mid, expectedModCount);
1756         }
1757 
1758         public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
1759             if (action == null)
1760                 throw new NullPointerException();
1761             int hi = getFence(), i = index;
1762             if (i &lt; hi) {
1763                 index = i + 1;
1764                 @SuppressWarnings(&quot;unchecked&quot;) E e = (E)elementData[i];
1765                 action.accept(e);
1766                 if (modCount != expectedModCount)
1767                     throw new ConcurrentModificationException();
1768                 return true;
1769             }
1770             return false;
1771         }
1772 
1773         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1774             int i, hi, mc; // hoist accesses and checks from loop
1775             Object[] a;
1776             if (action == null)
1777                 throw new NullPointerException();
1778             if ((a = elementData) != null) {
1779                 if ((hi = fence) &lt; 0) {
1780                     mc = modCount;
1781                     hi = size;
1782                 }
1783                 else
1784                     mc = expectedModCount;
1785                 if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) {
1786                     for (; i &lt; hi; ++i) {
1787                         @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i];
1788                         action.accept(e);
1789                     }
1790                     if (modCount == mc)
1791                         return;
1792                 }
1793             }
1794             throw new ConcurrentModificationException();
1795         }
1796 
1797         public long estimateSize() {
1798             return getFence() - index;
1799         }
1800 
1801         public int characteristics() {
1802             return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
1803         }
1804     }
1805 
1806     // A tiny bit set implementation
1807 
1808     private static long[] nBits(int n) {
1809         return new long[((n - 1) &gt;&gt; 6) + 1];
1810     }
1811     private static void setBit(long[] bits, int i) {
1812         bits[i &gt;&gt; 6] |= 1L &lt;&lt; i;
1813     }
1814     private static boolean isClear(long[] bits, int i) {
1815         return (bits[i &gt;&gt; 6] &amp; (1L &lt;&lt; i)) == 0;
1816     }
1817 
1818     /**
1819      * @throws NullPointerException {@inheritDoc}
1820      */
1821     @Override
1822     public boolean removeIf(Predicate&lt;? super E&gt; filter) {
1823         return removeIf(filter, 0, size);
1824     }
1825 
1826     /**
1827      * Removes all elements satisfying the given predicate, from index
1828      * i (inclusive) to index end (exclusive).
1829      */
1830     boolean removeIf(Predicate&lt;? super E&gt; filter, int i, final int end) {
1831         Objects.requireNonNull(filter);
1832         int expectedModCount = modCount;
1833         final Object[] es = elementData;
1834         // Optimize for initial run of survivors
1835         for (; i &lt; end &amp;&amp; !filter.test(elementAt(es, i)); i++)
1836             ;
1837         // Tolerate predicates that reentrantly access the collection for
1838         // read (but writers still get CME), so traverse once to find
1839         // elements to delete, a second pass to physically expunge.
1840         if (i &lt; end) {
1841             final int beg = i;
1842             final long[] deathRow = nBits(end - beg);
1843             deathRow[0] = 1L;   // set bit 0
1844             for (i = beg + 1; i &lt; end; i++)
1845                 if (filter.test(elementAt(es, i)))
1846                     setBit(deathRow, i - beg);
1847             if (modCount != expectedModCount)
1848                 throw new ConcurrentModificationException();
1849             modCount++;
1850             int w = beg;
1851             for (i = beg; i &lt; end; i++)
1852                 if (isClear(deathRow, i - beg))
1853                     es[w++] = es[i];
1854             shiftTailOverGap(es, w, end);
1855             return true;
1856         } else {
1857             if (modCount != expectedModCount)
1858                 throw new ConcurrentModificationException();
1859             return false;
1860         }
1861     }
1862 
1863     @Override
1864     public void replaceAll(UnaryOperator&lt;E&gt; operator) {
1865         replaceAllRange(operator, 0, size);
1866         // TODO(8203662): remove increment of modCount from ...
1867         modCount++;
1868     }
1869 
1870     private void replaceAllRange(UnaryOperator&lt;E&gt; operator, int i, int end) {
1871         Objects.requireNonNull(operator);
1872         final int expectedModCount = modCount;
1873         final Object[] es = elementData;
1874         for (; modCount == expectedModCount &amp;&amp; i &lt; end; i++)
1875             es[i] = operator.apply(elementAt(es, i));
1876         if (modCount != expectedModCount)
1877             throw new ConcurrentModificationException();
1878     }
1879 
1880     @Override
1881     @SuppressWarnings(&quot;unchecked&quot;)
1882     public void sort(Comparator&lt;? super E&gt; c) {
1883         final int expectedModCount = modCount;
1884         Arrays.sort((E[]) elementData, 0, size, c);
1885         if (modCount != expectedModCount)
1886             throw new ConcurrentModificationException();
1887         modCount++;
1888     }
1889 
1890     void checkInvariants() {
1891         // assert size &gt;= 0;
1892         // assert size == elementData.length || elementData[size] == null;
1893     }
1894 
1895     /**
1896      * Calculates a new array length given an array&#39;s current length, a preferred
1897      * growth value, and a minimum growth value.  If the preferred growth value
1898      * is less than the minimum growth value, the minimum growth value is used in
1899      * its place.  If the sum of the current length and the preferred growth
1900      * value does not exceed {@link #MAX_ARRAY_LENGTH}, that sum is returned.
1901      * If the sum of the current length and the minimum growth value does not
1902      * exceed {@code MAX_ARRAY_LENGTH}, then {@code MAX_ARRAY_LENGTH} is returned.
1903      * If the sum does not overflow an int, then {@code Integer.MAX_VALUE} is
1904      * returned.  Otherwise, {@code OutOfMemoryError} is thrown.
1905      *
1906      * @param oldLength   current length of the array (must be non negative)
1907      * @param minGrowth   minimum required growth of the array length (must be
1908      *                    positive)
1909      * @param prefGrowth  preferred growth of the array length (ignored, if less
1910      *                    then {@code minGrowth})
1911      * @return the new length of the array
1912      * @throws OutOfMemoryError if increasing {@code oldLength} by
1913      *                    {@code minGrowth} overflows.
1914      */
1915     private static int newLength(int oldLength, int minGrowth, int prefGrowth) {
1916         // assert oldLength &gt;= 0
1917         // assert minGrowth &gt; 0
1918 
1919         int newLength = Math.max(minGrowth, prefGrowth) + oldLength;
1920         if (newLength - MAX_ARRAY_LENGTH &lt;= 0) {
1921             return newLength;
1922         }
1923         return hugeLength(oldLength, minGrowth);
1924     }
1925 
1926     private static int hugeLength(int oldLength, int minGrowth) {
1927         int minLength = oldLength + minGrowth;
1928         if (minLength &lt; 0) { // overflow
1929             throw new OutOfMemoryError(&quot;Required array length too large&quot;);
1930         }
1931         if (minLength &lt;= MAX_ARRAY_LENGTH) {
1932             return MAX_ARRAY_LENGTH;
1933         }
1934         return Integer.MAX_VALUE;
1935     }
1936 
1937     private static final int MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;
1938 
1939     private static void subListRangeCheck(int fromIndex, int toIndex, int size) {
1940         if (fromIndex &lt; 0)
1941             throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);
1942         if (toIndex &gt; size)
1943             throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);
1944         if (fromIndex &gt; toIndex)
1945             throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +
1946                     &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
1947     }
1948 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
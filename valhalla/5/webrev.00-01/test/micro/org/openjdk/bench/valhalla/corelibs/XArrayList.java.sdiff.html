<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/micro/org/openjdk/bench/valhalla/corelibs/XArrayList.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineCursor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="XArrayListCursorTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/micro/org/openjdk/bench/valhalla/corelibs/XArrayList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1080                 expectedModCount = modCount;
1081             } catch (IndexOutOfBoundsException ex) {
1082                 throw new ConcurrentModificationException();
1083             }
1084         }
1085     }
1086 
1087     /**
1088      * Return a new cursor for this XArrayList.
1089      * @return a cursor
1090      */
1091     public InlineCursor&lt;E&gt; cursor() {
1092         return new AListCursor&lt;&gt;(0);
1093     }
1094 
1095     /**
1096      * Create an inline cursor for this XArrayList.
1097      */
1098     private inline class AListCursor&lt;E&gt; implements InlineCursor&lt;E&gt; {
1099         // Inner class field &#39;this&#39; is initialized
<span class="line-modified">1100         int index;          // index of next element to return; if neg is removed index</span>
1101         int expectedModCount;
1102 
<span class="line-removed">1103         /**</span>
<span class="line-removed">1104          * Return true if the element has been removed.</span>
<span class="line-removed">1105          * @return true if the element has been removed</span>
<span class="line-removed">1106          */</span>
<span class="line-removed">1107         private boolean isRemoved() {</span>
<span class="line-removed">1108             return index &lt; 0;</span>
<span class="line-removed">1109         }</span>
<span class="line-removed">1110 </span>
1111         /**
1112          * Create a new Cursor for this XArrayList.
1113          *
<span class="line-modified">1114          * @param cursor index if positive;</span>
<span class="line-removed">1115          *               if negative is the inverse (not) of a removed element</span>
1116          */
1117         public AListCursor(int cursor) {
1118             this.index = cursor;
1119             this.expectedModCount = XArrayList.this.modCount;
1120         }
1121 
<span class="line-removed">1122         /**</span>
<span class="line-removed">1123          * Return true if the index is in range for the Collection</span>
<span class="line-removed">1124          * and has not been explicitly removed.</span>
<span class="line-removed">1125          * It does NOT check for co-modification.</span>
<span class="line-removed">1126          *</span>
<span class="line-removed">1127          * @param cursor and index</span>
<span class="line-removed">1128          * @return true if the index is a valid index.</span>
<span class="line-removed">1129          */</span>
<span class="line-removed">1130         private boolean validIndex(int cursor) {</span>
<span class="line-removed">1131             return cursor &gt;= 0 &amp;&amp; cursor &lt; XArrayList.this.size;</span>
<span class="line-removed">1132         }</span>
<span class="line-removed">1133 </span>
1134         @Override
1135         public boolean exists() {
<span class="line-modified">1136             return validIndex(index);</span>
1137         }
1138 
1139         @SuppressWarnings(&quot;unchecked&quot;)
1140         public E get() {
<span class="line-modified">1141             if (!validIndex(index))</span>
<span class="line-modified">1142                 throw new NoSuchElementException();</span>
<span class="line-modified">1143             checkForComodification();</span>
<span class="line-modified">1144             try {</span>
<span class="line-modified">1145                 Object[] elementData = XArrayList.this.elementData;</span>
<span class="line-modified">1146                 return (E) elementData[index];</span>
<span class="line-modified">1147             } catch (ArrayIndexOutOfBoundsException aioobe) {</span>
<span class="line-removed">1148                 throw new ConcurrentModificationException();</span>
1149             }

1150         }
1151 
1152         @Override
1153         public AListCursor&lt;E&gt; advance() {
<span class="line-removed">1154             checkForComodification();   // Reject if Collection has changed</span>
1155             // new Cursor will have a current expectedModCount
1156             // TBD: Saturate index?  So calling adv, adv, adv, prev == last
<span class="line-modified">1157             return new AListCursor&lt;&gt;(isRemoved() ? ~index : index + 1);</span>
<span class="line-removed">1158         }</span>
<span class="line-removed">1159 </span>
<span class="line-removed">1160         @Override</span>
<span class="line-removed">1161         public AListCursor&lt;E&gt; remove() {</span>
<span class="line-removed">1162             if (!validIndex(index))</span>
<span class="line-removed">1163                 throw new NoSuchElementException();</span>
<span class="line-removed">1164             checkForComodification();</span>
<span class="line-removed">1165             try {</span>
<span class="line-removed">1166                 XArrayList.this.remove(index);</span>
<span class="line-removed">1167                 return new AListCursor&lt;&gt;(~index); // invert for removed index</span>
<span class="line-removed">1168             } catch (IndexOutOfBoundsException ex) {</span>
<span class="line-removed">1169                 throw new ConcurrentModificationException();</span>
<span class="line-removed">1170             }</span>
1171         }
1172 
1173         final void checkForComodification() {
1174             if (XArrayList.this.modCount != expectedModCount)
1175                 throw new ConcurrentModificationException();
1176         }
1177     }
1178 
1179     /**
1180      * Returns a iterator (Using an InlineCursor) over the elements in this list in proper sequence.
1181      *
1182      * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
1183      *
1184      * @return an iterator over the elements in this list in proper sequence
1185      */
1186     public Iterator&lt;E&gt; iteratorCurs() {
1187         return new CurItr();
1188     }
1189 
1190     /**
</pre>
<hr />
<pre>
1195         AListCursor&lt;E&gt; lastRet;
1196 
1197         // prevent creating a synthetic constructor
1198         CurItr() {
1199             this.cursor = new AListCursor&lt;E&gt;(0);
1200             this.lastRet = this.cursor;
1201         }
1202 
1203         public boolean hasNext() {
1204             return cursor.advance().exists();
1205         }
1206 
1207         @SuppressWarnings(&quot;unchecked&quot;)
1208         public E next() {
1209             E val = cursor.get();
1210             lastRet = cursor;
1211             cursor = cursor.advance();
1212             return val;
1213         }
1214 
<span class="line-removed">1215         public void remove() {</span>
<span class="line-removed">1216             if (lastRet.exists())</span>
<span class="line-removed">1217                 lastRet.remove();</span>
<span class="line-removed">1218             else</span>
<span class="line-removed">1219                 throw new IllegalStateException();</span>
<span class="line-removed">1220         }</span>
<span class="line-removed">1221 </span>
1222         @Override
1223         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1224             Objects.requireNonNull(action);
1225 
1226             AListCursor&lt;E&gt; cur = cursor;
1227             while (cur.exists()) {
1228                 E val = cur.get();
1229                 action.accept(val);
1230                 cur = cur.advance();
1231             }
1232             cursor = cur;
1233         }
1234 
1235         public String toString() {
1236             return &quot;cur: &quot; + cursor;
1237         }
1238     }
1239 
1240 
1241     /**
</pre>
</td>
<td>
<hr />
<pre>
1080                 expectedModCount = modCount;
1081             } catch (IndexOutOfBoundsException ex) {
1082                 throw new ConcurrentModificationException();
1083             }
1084         }
1085     }
1086 
1087     /**
1088      * Return a new cursor for this XArrayList.
1089      * @return a cursor
1090      */
1091     public InlineCursor&lt;E&gt; cursor() {
1092         return new AListCursor&lt;&gt;(0);
1093     }
1094 
1095     /**
1096      * Create an inline cursor for this XArrayList.
1097      */
1098     private inline class AListCursor&lt;E&gt; implements InlineCursor&lt;E&gt; {
1099         // Inner class field &#39;this&#39; is initialized
<span class="line-modified">1100         int index;</span>
1101         int expectedModCount;
1102 








1103         /**
1104          * Create a new Cursor for this XArrayList.
1105          *
<span class="line-modified">1106          * @param cursor index</span>

1107          */
1108         public AListCursor(int cursor) {
1109             this.index = cursor;
1110             this.expectedModCount = XArrayList.this.modCount;
1111         }
1112 












1113         @Override
1114         public boolean exists() {
<span class="line-modified">1115             return index &lt; XArrayList.this.size;</span>
1116         }
1117 
1118         @SuppressWarnings(&quot;unchecked&quot;)
1119         public E get() {
<span class="line-modified">1120             if (exists()) {</span>
<span class="line-modified">1121                 checkForComodification();</span>
<span class="line-modified">1122                 try {</span>
<span class="line-modified">1123                     return (E) XArrayList.this.elementData[index];</span>
<span class="line-modified">1124                 } catch (ArrayIndexOutOfBoundsException aioobe) {</span>
<span class="line-modified">1125                     throw new ConcurrentModificationException();</span>
<span class="line-modified">1126                 }</span>

1127             }
<span class="line-added">1128             throw new NoSuchElementException();</span>
1129         }
1130 
1131         @Override
1132         public AListCursor&lt;E&gt; advance() {

1133             // new Cursor will have a current expectedModCount
1134             // TBD: Saturate index?  So calling adv, adv, adv, prev == last
<span class="line-modified">1135             return new AListCursor&lt;&gt;(Math.min(index + 1, size));</span>













1136         }
1137 
1138         final void checkForComodification() {
1139             if (XArrayList.this.modCount != expectedModCount)
1140                 throw new ConcurrentModificationException();
1141         }
1142     }
1143 
1144     /**
1145      * Returns a iterator (Using an InlineCursor) over the elements in this list in proper sequence.
1146      *
1147      * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
1148      *
1149      * @return an iterator over the elements in this list in proper sequence
1150      */
1151     public Iterator&lt;E&gt; iteratorCurs() {
1152         return new CurItr();
1153     }
1154 
1155     /**
</pre>
<hr />
<pre>
1160         AListCursor&lt;E&gt; lastRet;
1161 
1162         // prevent creating a synthetic constructor
1163         CurItr() {
1164             this.cursor = new AListCursor&lt;E&gt;(0);
1165             this.lastRet = this.cursor;
1166         }
1167 
1168         public boolean hasNext() {
1169             return cursor.advance().exists();
1170         }
1171 
1172         @SuppressWarnings(&quot;unchecked&quot;)
1173         public E next() {
1174             E val = cursor.get();
1175             lastRet = cursor;
1176             cursor = cursor.advance();
1177             return val;
1178         }
1179 







1180         @Override
1181         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1182             Objects.requireNonNull(action);
1183 
1184             AListCursor&lt;E&gt; cur = cursor;
1185             while (cur.exists()) {
1186                 E val = cur.get();
1187                 action.accept(val);
1188                 cur = cur.advance();
1189             }
1190             cursor = cur;
1191         }
1192 
1193         public String toString() {
1194             return &quot;cur: &quot; + cursor;
1195         }
1196     }
1197 
1198 
1199     /**
</pre>
</td>
</tr>
</table>
<center><a href="InlineCursor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="XArrayListCursorTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
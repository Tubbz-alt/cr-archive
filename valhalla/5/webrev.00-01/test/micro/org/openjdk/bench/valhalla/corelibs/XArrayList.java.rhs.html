<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/micro/org/openjdk/bench/valhalla/corelibs/XArrayList.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package org.openjdk.bench.valhalla.corelibs;
  27 
  28 import java.util.AbstractList;
  29 import java.util.Arrays;
  30 import java.util.Collection;
  31 import java.util.Comparator;
  32 import java.util.ConcurrentModificationException;
  33 import java.util.Iterator;
  34 import java.util.List;
  35 import java.util.ListIterator;
  36 import java.util.NoSuchElementException;
  37 import java.util.Objects;
  38 import java.util.RandomAccess;
  39 import java.util.Spliterator;
  40 
  41 import java.util.function.Consumer;
  42 import java.util.function.Predicate;
  43 import java.util.function.UnaryOperator;
  44 //import jdk.internal.access.SharedSecrets;
  45 //import jdk.internal.util.ArraysSupport;
  46 
  47 /**
  48  * Resizable-array implementation of the {@code List} interface.  Implements
  49  * all optional list operations, and permits all elements, including
  50  * {@code null}.  In addition to implementing the {@code List} interface,
  51  * this class provides methods to manipulate the size of the array that is
  52  * used internally to store the list.  (This class is roughly equivalent to
  53  * {@code Vector}, except that it is unsynchronized.)
  54  *
  55  * &lt;p&gt;The {@code size}, {@code isEmpty}, {@code get}, {@code set},
  56  * {@code iterator}, and {@code listIterator} operations run in constant
  57  * time.  The {@code add} operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;,
  58  * that is, adding n elements requires O(n) time.  All of the other operations
  59  * run in linear time (roughly speaking).  The constant factor is low compared
  60  * to that for the {@code LinkedList} implementation.
  61  *
  62  * &lt;p&gt;Each {@code XArrayList} instance has a &lt;i&gt;capacity&lt;/i&gt;.  The capacity is
  63  * the size of the array used to store the elements in the list.  It is always
  64  * at least as large as the list size.  As elements are added to an XArrayList,
  65  * its capacity grows automatically.  The details of the growth policy are not
  66  * specified beyond the fact that adding an element has constant amortized
  67  * time cost.
  68  *
  69  * &lt;p&gt;An application can increase the capacity of an {@code XArrayList} instance
  70  * before adding a large number of elements using the {@code ensureCapacity}
  71  * operation.  This may reduce the amount of incremental reallocation.
  72  *
  73  * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
  74  * If multiple threads access an {@code XArrayList} instance concurrently,
  75  * and at least one of the threads modifies the list structurally, it
  76  * &lt;i&gt;must&lt;/i&gt; be synchronized externally.  (A structural modification is
  77  * any operation that adds or deletes one or more elements, or explicitly
  78  * resizes the backing array; merely setting the value of an element is not
  79  * a structural modification.)  This is typically accomplished by
  80  * synchronizing on some object that naturally encapsulates the list.
  81  *
  82  * If no such object exists, the list should be &quot;wrapped&quot; using the
  83  * {@link Collections#synchronizedList Collections.synchronizedList}
  84  * method.  This is best done at creation time, to prevent accidental
  85  * unsynchronized access to the list:&lt;pre&gt;
  86  *   List list = Collections.synchronizedList(new XArrayList(...));&lt;/pre&gt;
  87  *
  88  * &lt;p id=&quot;fail-fast&quot;&gt;
  89  * The iterators returned by this class&#39;s {@link #iterator() iterator} and
  90  * {@link #listIterator(int) listIterator} methods are &lt;em&gt;fail-fast&lt;/em&gt;:
  91  * if the list is structurally modified at any time after the iterator is
  92  * created, in any way except through the iterator&#39;s own
  93  * {@link ListIterator#remove() remove} or
  94  * {@link ListIterator#add(Object) add} methods, the iterator will throw a
  95  * {@link ConcurrentModificationException}.  Thus, in the face of
  96  * concurrent modification, the iterator fails quickly and cleanly, rather
  97  * than risking arbitrary, non-deterministic behavior at an undetermined
  98  * time in the future.
  99  *
 100  * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 101  * as it is, generally speaking, impossible to make any hard guarantees in the
 102  * presence of unsynchronized concurrent modification.  Fail-fast iterators
 103  * throw {@code ConcurrentModificationException} on a best-effort basis.
 104  * Therefore, it would be wrong to write a program that depended on this
 105  * exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators
 106  * should be used only to detect bugs.&lt;/i&gt;
 107  *
 108  * &lt;p&gt;This class is a member of the
 109  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 110  * Java Collections Framework&lt;/a&gt;.
 111  *
 112  * @param &lt;E&gt; the type of elements in this list
 113  *
 114  * @author  Josh Bloch
 115  * @author  Neal Gafter
 116  * @see     Collection
 117  * @see     List
 118  * @see     LinkedList
 119  * @see     Vector
 120  * @since   1.2
 121  */
 122 public class XArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
 123         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
 124 {
 125     private static final long serialVersionUID = 8683452581122892189L;
 126 
 127     /**
 128      * Default initial capacity.
 129      */
 130     private static final int DEFAULT_CAPACITY = 10;
 131 
 132     /**
 133      * Shared empty array instance used for empty instances.
 134      */
 135     private static final Object[] EMPTY_ELEMENTDATA = {};
 136 
 137     /**
 138      * Shared empty array instance used for default sized empty instances. We
 139      * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
 140      * first element is added.
 141      */
 142     private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
 143 
 144     /**
 145      * The array buffer into which the elements of the ArrayList are stored.
 146      * The capacity of the ArrayList is the length of this array buffer. Any
 147      * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
 148      * will be expanded to DEFAULT_CAPACITY when the first element is added.
 149      */
 150     transient Object[] elementData; // non-private to simplify nested class access
 151 
 152     /**
 153      * The size of the ArrayList (the number of elements it contains).
 154      *
 155      * @serial
 156      */
 157     int size;
 158 
 159     /**
 160      * Constructs an empty list with the specified initial capacity.
 161      *
 162      * @param  initialCapacity  the initial capacity of the list
 163      * @throws IllegalArgumentException if the specified initial capacity
 164      *         is negative
 165      */
 166     public XArrayList(int initialCapacity) {
 167         if (initialCapacity &gt; 0) {
 168             this.elementData = new Object[initialCapacity];
 169         } else if (initialCapacity == 0) {
 170             this.elementData = EMPTY_ELEMENTDATA;
 171         } else {
 172             throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
 173                                                initialCapacity);
 174         }
 175     }
 176 
 177     /**
 178      * Constructs an empty list with an initial capacity of ten.
 179      */
 180     public XArrayList() {
 181         this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
 182     }
 183 
 184     /**
 185      * Constructs a list containing the elements of the specified
 186      * collection, in the order they are returned by the collection&#39;s
 187      * iterator.
 188      *
 189      * @param c the collection whose elements are to be placed into this list
 190      * @throws NullPointerException if the specified collection is null
 191      */
 192     public XArrayList(Collection&lt;? extends E&gt; c) {
 193         elementData = c.toArray();
 194         if ((size = elementData.length) != 0) {
 195             // defend against c.toArray (incorrectly) not returning Object[]
 196             // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)
 197             if (elementData.getClass() != Object[].class)
 198                 elementData = Arrays.copyOf(elementData, size, Object[].class);
 199         } else {
 200             // replace with empty array.
 201             this.elementData = EMPTY_ELEMENTDATA;
 202         }
 203     }
 204 
 205     /**
 206      * Trims the capacity of this {@code XArrayList} instance to be the
 207      * list&#39;s current size.  An application can use this operation to minimize
 208      * the storage of an {@code XArrayList} instance.
 209      */
 210     public void trimToSize() {
 211         modCount++;
 212         if (size &lt; elementData.length) {
 213             elementData = (size == 0)
 214               ? EMPTY_ELEMENTDATA
 215               : Arrays.copyOf(elementData, size);
 216         }
 217     }
 218 
 219     /**
 220      * Increases the capacity of this {@code XArrayList} instance, if
 221      * necessary, to ensure that it can hold at least the number of elements
 222      * specified by the minimum capacity argument.
 223      *
 224      * @param minCapacity the desired minimum capacity
 225      */
 226     public void ensureCapacity(int minCapacity) {
 227         if (minCapacity &gt; elementData.length
 228             &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
 229                  &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) {
 230             modCount++;
 231             grow(minCapacity);
 232         }
 233     }
 234 
 235     /**
 236      * Increases the capacity to ensure that it can hold at least the
 237      * number of elements specified by the minimum capacity argument.
 238      *
 239      * @param minCapacity the desired minimum capacity
 240      * @throws OutOfMemoryError if minCapacity is less than zero
 241      */
 242     private Object[] grow(int minCapacity) {
 243         int oldCapacity = elementData.length;
 244         if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
 245             int newCapacity = newLength(oldCapacity,
 246                     minCapacity - oldCapacity, /* minimum growth */
 247                     oldCapacity &gt;&gt; 1           /* preferred growth */);
 248             return elementData = Arrays.copyOf(elementData, newCapacity);
 249         } else {
 250             return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
 251         }
 252     }
 253 
 254     private Object[] grow() {
 255         return grow(size + 1);
 256     }
 257 
 258     /**
 259      * Returns the number of elements in this list.
 260      *
 261      * @return the number of elements in this list
 262      */
 263     public int size() {
 264         return size;
 265     }
 266 
 267     /**
 268      * Returns {@code true} if this list contains no elements.
 269      *
 270      * @return {@code true} if this list contains no elements
 271      */
 272     public boolean isEmpty() {
 273         return size == 0;
 274     }
 275 
 276     /**
 277      * Returns {@code true} if this list contains the specified element.
 278      * More formally, returns {@code true} if and only if this list contains
 279      * at least one element {@code e} such that
 280      * {@code Objects.equals(o, e)}.
 281      *
 282      * @param o element whose presence in this list is to be tested
 283      * @return {@code true} if this list contains the specified element
 284      */
 285     public boolean contains(Object o) {
 286         return indexOf(o) &gt;= 0;
 287     }
 288 
 289     /**
 290      * Returns the index of the first occurrence of the specified element
 291      * in this list, or -1 if this list does not contain the element.
 292      * More formally, returns the lowest index {@code i} such that
 293      * {@code Objects.equals(o, get(i))},
 294      * or -1 if there is no such index.
 295      */
 296     public int indexOf(Object o) {
 297         return indexOfRange(o, 0, size);
 298     }
 299 
 300     int indexOfRange(Object o, int start, int end) {
 301         Object[] es = elementData;
 302         if (o == null) {
 303             for (int i = start; i &lt; end; i++) {
 304                 if (es[i] == null) {
 305                     return i;
 306                 }
 307             }
 308         } else {
 309             for (int i = start; i &lt; end; i++) {
 310                 if (o.equals(es[i])) {
 311                     return i;
 312                 }
 313             }
 314         }
 315         return -1;
 316     }
 317 
 318     /**
 319      * Returns the index of the last occurrence of the specified element
 320      * in this list, or -1 if this list does not contain the element.
 321      * More formally, returns the highest index {@code i} such that
 322      * {@code Objects.equals(o, get(i))},
 323      * or -1 if there is no such index.
 324      */
 325     public int lastIndexOf(Object o) {
 326         return lastIndexOfRange(o, 0, size);
 327     }
 328 
 329     int lastIndexOfRange(Object o, int start, int end) {
 330         Object[] es = elementData;
 331         if (o == null) {
 332             for (int i = end - 1; i &gt;= start; i--) {
 333                 if (es[i] == null) {
 334                     return i;
 335                 }
 336             }
 337         } else {
 338             for (int i = end - 1; i &gt;= start; i--) {
 339                 if (o.equals(es[i])) {
 340                     return i;
 341                 }
 342             }
 343         }
 344         return -1;
 345     }
 346 
 347     /**
 348      * Returns a shallow copy of this {@code XArrayList} instance.  (The
 349      * elements themselves are not copied.)
 350      *
 351      * @return a clone of this {@code XArrayList} instance
 352      */
 353     public Object clone() {
 354         try {
 355             XArrayList&lt;?&gt; v = (XArrayList&lt;?&gt;) super.clone();
 356             v.elementData = Arrays.copyOf(elementData, size);
 357             v.modCount = 0;
 358             return v;
 359         } catch (CloneNotSupportedException e) {
 360             // this shouldn&#39;t happen, since we are Cloneable
 361             throw new InternalError(e);
 362         }
 363     }
 364 
 365     /**
 366      * Returns an array containing all of the elements in this list
 367      * in proper sequence (from first to last element).
 368      *
 369      * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 370      * maintained by this list.  (In other words, this method must allocate
 371      * a new array).  The caller is thus free to modify the returned array.
 372      *
 373      * &lt;p&gt;This method acts as bridge between array-based and collection-based
 374      * APIs.
 375      *
 376      * @return an array containing all of the elements in this list in
 377      *         proper sequence
 378      */
 379     public Object[] toArray() {
 380         return Arrays.copyOf(elementData, size);
 381     }
 382 
 383     /**
 384      * Returns an array containing all of the elements in this list in proper
 385      * sequence (from first to last element); the runtime type of the returned
 386      * array is that of the specified array.  If the list fits in the
 387      * specified array, it is returned therein.  Otherwise, a new array is
 388      * allocated with the runtime type of the specified array and the size of
 389      * this list.
 390      *
 391      * &lt;p&gt;If the list fits in the specified array with room to spare
 392      * (i.e., the array has more elements than the list), the element in
 393      * the array immediately following the end of the collection is set to
 394      * {@code null}.  (This is useful in determining the length of the
 395      * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain
 396      * any null elements.)
 397      *
 398      * @param a the array into which the elements of the list are to
 399      *          be stored, if it is big enough; otherwise, a new array of the
 400      *          same runtime type is allocated for this purpose.
 401      * @return an array containing the elements of the list
 402      * @throws ArrayStoreException if the runtime type of the specified array
 403      *         is not a supertype of the runtime type of every element in
 404      *         this list
 405      * @throws NullPointerException if the specified array is null
 406      */
 407     @SuppressWarnings(&quot;unchecked&quot;)
 408     public &lt;T&gt; T[] toArray(T[] a) {
 409         if (a.length &lt; size)
 410             // Make a new array of a&#39;s runtime type, but my contents:
 411             return (T[]) Arrays.copyOf(elementData, size, a.getClass());
 412         System.arraycopy(elementData, 0, a, 0, size);
 413         if (a.length &gt; size)
 414             a[size] = null;
 415         return a;
 416     }
 417 
 418     // Positional Access Operations
 419 
 420     @SuppressWarnings(&quot;unchecked&quot;)
 421     E elementData(int index) {
 422         return (E) elementData[index];
 423     }
 424 
 425     @SuppressWarnings(&quot;unchecked&quot;)
 426     static &lt;E&gt; E elementAt(Object[] es, int index) {
 427         return (E) es[index];
 428     }
 429 
 430     /**
 431      * Returns the element at the specified position in this list.
 432      *
 433      * @param  index index of the element to return
 434      * @return the element at the specified position in this list
 435      * @throws IndexOutOfBoundsException {@inheritDoc}
 436      */
 437     public E get(int index) {
 438         Objects.checkIndex(index, size);
 439         return elementData(index);
 440     }
 441 
 442     /**
 443      * Replaces the element at the specified position in this list with
 444      * the specified element.
 445      *
 446      * @param index index of the element to replace
 447      * @param element element to be stored at the specified position
 448      * @return the element previously at the specified position
 449      * @throws IndexOutOfBoundsException {@inheritDoc}
 450      */
 451     public E set(int index, E element) {
 452         Objects.checkIndex(index, size);
 453         E oldValue = elementData(index);
 454         elementData[index] = element;
 455         return oldValue;
 456     }
 457 
 458     /**
 459      * This helper method split out from add(E) to keep method
 460      * bytecode size under 35 (the -XX:MaxInlineSize default value),
 461      * which helps when add(E) is called in a C1-compiled loop.
 462      */
 463     private void add(E e, Object[] elementData, int s) {
 464         if (s == elementData.length)
 465             elementData = grow();
 466         elementData[s] = e;
 467         size = s + 1;
 468     }
 469 
 470     /**
 471      * Appends the specified element to the end of this list.
 472      *
 473      * @param e element to be appended to this list
 474      * @return {@code true} (as specified by {@link Collection#add})
 475      */
 476     public boolean add(E e) {
 477         modCount++;
 478         add(e, elementData, size);
 479         return true;
 480     }
 481 
 482     /**
 483      * Inserts the specified element at the specified position in this
 484      * list. Shifts the element currently at that position (if any) and
 485      * any subsequent elements to the right (adds one to their indices).
 486      *
 487      * @param index index at which the specified element is to be inserted
 488      * @param element element to be inserted
 489      * @throws IndexOutOfBoundsException {@inheritDoc}
 490      */
 491     public void add(int index, E element) {
 492         rangeCheckForAdd(index);
 493         modCount++;
 494         final int s;
 495         Object[] elementData;
 496         if ((s = size) == (elementData = this.elementData).length)
 497             elementData = grow();
 498         System.arraycopy(elementData, index,
 499                          elementData, index + 1,
 500                          s - index);
 501         elementData[index] = element;
 502         size = s + 1;
 503     }
 504 
 505     /**
 506      * Removes the element at the specified position in this list.
 507      * Shifts any subsequent elements to the left (subtracts one from their
 508      * indices).
 509      *
 510      * @param index the index of the element to be removed
 511      * @return the element that was removed from the list
 512      * @throws IndexOutOfBoundsException {@inheritDoc}
 513      */
 514     public E remove(int index) {
 515         Objects.checkIndex(index, size);
 516         final Object[] es = elementData;
 517 
 518         @SuppressWarnings(&quot;unchecked&quot;) E oldValue = (E) es[index];
 519         fastRemove(es, index);
 520 
 521         return oldValue;
 522     }
 523 
 524     /**
 525      * {@inheritDoc}
 526      */
 527     public boolean equals(Object o) {
 528         if (o == this) {
 529             return true;
 530         }
 531 
 532         if (!(o instanceof List)) {
 533             return false;
 534         }
 535 
 536         final int expectedModCount = modCount;
 537         // XArrayList can be subclassed and given arbitrary behavior, but we can
 538         // still deal with the common case where o is XArrayList precisely
 539         boolean equal = (o.getClass() == XArrayList.class)
 540             ? equalsArrayList((XArrayList&lt;?&gt;) o)
 541             : equalsRange((List&lt;?&gt;) o, 0, size);
 542 
 543         checkForComodification(expectedModCount);
 544         return equal;
 545     }
 546 
 547     boolean equalsRange(List&lt;?&gt; other, int from, int to) {
 548         final Object[] es = elementData;
 549         if (to &gt; es.length) {
 550             throw new ConcurrentModificationException();
 551         }
 552         var oit = other.iterator();
 553         for (; from &lt; to; from++) {
 554             if (!oit.hasNext() || !Objects.equals(es[from], oit.next())) {
 555                 return false;
 556             }
 557         }
 558         return !oit.hasNext();
 559     }
 560 
 561     private boolean equalsArrayList(XArrayList&lt;?&gt; other) {
 562         final int otherModCount = other.modCount;
 563         final int s = size;
 564         boolean equal;
 565         if (equal = (s == other.size)) {
 566             final Object[] otherEs = other.elementData;
 567             final Object[] es = elementData;
 568             if (s &gt; es.length || s &gt; otherEs.length) {
 569                 throw new ConcurrentModificationException();
 570             }
 571             for (int i = 0; i &lt; s; i++) {
 572                 if (!Objects.equals(es[i], otherEs[i])) {
 573                     equal = false;
 574                     break;
 575                 }
 576             }
 577         }
 578         other.checkForComodification(otherModCount);
 579         return equal;
 580     }
 581 
 582     private void checkForComodification(final int expectedModCount) {
 583         if (modCount != expectedModCount) {
 584             throw new ConcurrentModificationException();
 585         }
 586     }
 587 
 588     /**
 589      * {@inheritDoc}
 590      */
 591     public int hashCode() {
 592         int expectedModCount = modCount;
 593         int hash = hashCodeRange(0, size);
 594         checkForComodification(expectedModCount);
 595         return hash;
 596     }
 597 
 598     int hashCodeRange(int from, int to) {
 599         final Object[] es = elementData;
 600         if (to &gt; es.length) {
 601             throw new ConcurrentModificationException();
 602         }
 603         int hashCode = 1;
 604         for (int i = from; i &lt; to; i++) {
 605             Object e = es[i];
 606             hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());
 607         }
 608         return hashCode;
 609     }
 610 
 611     /**
 612      * Removes the first occurrence of the specified element from this list,
 613      * if it is present.  If the list does not contain the element, it is
 614      * unchanged.  More formally, removes the element with the lowest index
 615      * {@code i} such that
 616      * {@code Objects.equals(o, get(i))}
 617      * (if such an element exists).  Returns {@code true} if this list
 618      * contained the specified element (or equivalently, if this list
 619      * changed as a result of the call).
 620      *
 621      * @param o element to be removed from this list, if present
 622      * @return {@code true} if this list contained the specified element
 623      */
 624     public boolean remove(Object o) {
 625         final Object[] es = elementData;
 626         final int size = this.size;
 627         int i = 0;
 628         found: {
 629             if (o == null) {
 630                 for (; i &lt; size; i++)
 631                     if (es[i] == null)
 632                         break found;
 633             } else {
 634                 for (; i &lt; size; i++)
 635                     if (o.equals(es[i]))
 636                         break found;
 637             }
 638             return false;
 639         }
 640         fastRemove(es, i);
 641         return true;
 642     }
 643 
 644     /**
 645      * Private remove method that skips bounds checking and does not
 646      * return the value removed.
 647      */
 648     private void fastRemove(Object[] es, int i) {
 649         modCount++;
 650         final int newSize;
 651         if ((newSize = size - 1) &gt; i)
 652             System.arraycopy(es, i + 1, es, i, newSize - i);
 653         es[size = newSize] = null;
 654     }
 655 
 656     /**
 657      * Removes all of the elements from this list.  The list will
 658      * be empty after this call returns.
 659      */
 660     public void clear() {
 661         modCount++;
 662         final Object[] es = elementData;
 663         for (int to = size, i = size = 0; i &lt; to; i++)
 664             es[i] = null;
 665     }
 666 
 667     /**
 668      * Appends all of the elements in the specified collection to the end of
 669      * this list, in the order that they are returned by the
 670      * specified collection&#39;s Iterator.  The behavior of this operation is
 671      * undefined if the specified collection is modified while the operation
 672      * is in progress.  (This implies that the behavior of this call is
 673      * undefined if the specified collection is this list, and this
 674      * list is nonempty.)
 675      *
 676      * @param c collection containing elements to be added to this list
 677      * @return {@code true} if this list changed as a result of the call
 678      * @throws NullPointerException if the specified collection is null
 679      */
 680     public boolean addAll(Collection&lt;? extends E&gt; c) {
 681         Object[] a = c.toArray();
 682         modCount++;
 683         int numNew = a.length;
 684         if (numNew == 0)
 685             return false;
 686         Object[] elementData;
 687         final int s;
 688         if (numNew &gt; (elementData = this.elementData).length - (s = size))
 689             elementData = grow(s + numNew);
 690         System.arraycopy(a, 0, elementData, s, numNew);
 691         size = s + numNew;
 692         return true;
 693     }
 694 
 695     /**
 696      * Inserts all of the elements in the specified collection into this
 697      * list, starting at the specified position.  Shifts the element
 698      * currently at that position (if any) and any subsequent elements to
 699      * the right (increases their indices).  The new elements will appear
 700      * in the list in the order that they are returned by the
 701      * specified collection&#39;s iterator.
 702      *
 703      * @param index index at which to insert the first element from the
 704      *              specified collection
 705      * @param c collection containing elements to be added to this list
 706      * @return {@code true} if this list changed as a result of the call
 707      * @throws IndexOutOfBoundsException {@inheritDoc}
 708      * @throws NullPointerException if the specified collection is null
 709      */
 710     public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
 711         rangeCheckForAdd(index);
 712 
 713         Object[] a = c.toArray();
 714         modCount++;
 715         int numNew = a.length;
 716         if (numNew == 0)
 717             return false;
 718         Object[] elementData;
 719         final int s;
 720         if (numNew &gt; (elementData = this.elementData).length - (s = size))
 721             elementData = grow(s + numNew);
 722 
 723         int numMoved = s - index;
 724         if (numMoved &gt; 0)
 725             System.arraycopy(elementData, index,
 726                              elementData, index + numNew,
 727                              numMoved);
 728         System.arraycopy(a, 0, elementData, index, numNew);
 729         size = s + numNew;
 730         return true;
 731     }
 732 
 733     /**
 734      * Removes from this list all of the elements whose index is between
 735      * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
 736      * Shifts any succeeding elements to the left (reduces their index).
 737      * This call shortens the list by {@code (toIndex - fromIndex)} elements.
 738      * (If {@code toIndex==fromIndex}, this operation has no effect.)
 739      *
 740      * @throws IndexOutOfBoundsException if {@code fromIndex} or
 741      *         {@code toIndex} is out of range
 742      *         ({@code fromIndex &lt; 0 ||
 743      *          toIndex &gt; size() ||
 744      *          toIndex &lt; fromIndex})
 745      */
 746     protected void removeRange(int fromIndex, int toIndex) {
 747         if (fromIndex &gt; toIndex) {
 748             throw new IndexOutOfBoundsException(
 749                     outOfBoundsMsg(fromIndex, toIndex));
 750         }
 751         modCount++;
 752         shiftTailOverGap(elementData, fromIndex, toIndex);
 753     }
 754 
 755     /** Erases the gap from lo to hi, by sliding down following elements. */
 756     private void shiftTailOverGap(Object[] es, int lo, int hi) {
 757         System.arraycopy(es, hi, es, lo, size - hi);
 758         for (int to = size, i = (size -= hi - lo); i &lt; to; i++)
 759             es[i] = null;
 760     }
 761 
 762     /**
 763      * A version of rangeCheck used by add and addAll.
 764      */
 765     private void rangeCheckForAdd(int index) {
 766         if (index &gt; size || index &lt; 0)
 767             throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
 768     }
 769 
 770     /**
 771      * Constructs an IndexOutOfBoundsException detail message.
 772      * Of the many possible refactorings of the error handling code,
 773      * this &quot;outlining&quot; performs best with both server and client VMs.
 774      */
 775     private String outOfBoundsMsg(int index) {
 776         return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
 777     }
 778 
 779     /**
 780      * A version used in checking (fromIndex &gt; toIndex) condition
 781      */
 782     private static String outOfBoundsMsg(int fromIndex, int toIndex) {
 783         return &quot;From Index: &quot; + fromIndex + &quot; &gt; To Index: &quot; + toIndex;
 784     }
 785 
 786     /**
 787      * Removes from this list all of its elements that are contained in the
 788      * specified collection.
 789      *
 790      * @param c collection containing elements to be removed from this list
 791      * @return {@code true} if this list changed as a result of the call
 792      * @throws ClassCastException if the class of an element of this list
 793      *         is incompatible with the specified collection
 794      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 795      * @throws NullPointerException if this list contains a null element and the
 796      *         specified collection does not permit null elements
 797      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 798      *         or if the specified collection is null
 799      * @see Collection#contains(Object)
 800      */
 801     public boolean removeAll(Collection&lt;?&gt; c) {
 802         return batchRemove(c, false, 0, size);
 803     }
 804 
 805     /**
 806      * Retains only the elements in this list that are contained in the
 807      * specified collection.  In other words, removes from this list all
 808      * of its elements that are not contained in the specified collection.
 809      *
 810      * @param c collection containing elements to be retained in this list
 811      * @return {@code true} if this list changed as a result of the call
 812      * @throws ClassCastException if the class of an element of this list
 813      *         is incompatible with the specified collection
 814      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 815      * @throws NullPointerException if this list contains a null element and the
 816      *         specified collection does not permit null elements
 817      * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 818      *         or if the specified collection is null
 819      * @see Collection#contains(Object)
 820      */
 821     public boolean retainAll(Collection&lt;?&gt; c) {
 822         return batchRemove(c, true, 0, size);
 823     }
 824 
 825     boolean batchRemove(Collection&lt;?&gt; c, boolean complement,
 826                         final int from, final int end) {
 827         Objects.requireNonNull(c);
 828         final Object[] es = elementData;
 829         int r;
 830         // Optimize for initial run of survivors
 831         for (r = from;; r++) {
 832             if (r == end)
 833                 return false;
 834             if (c.contains(es[r]) != complement)
 835                 break;
 836         }
 837         int w = r++;
 838         try {
 839             for (Object e; r &lt; end; r++)
 840                 if (c.contains(e = es[r]) == complement)
 841                     es[w++] = e;
 842         } catch (Throwable ex) {
 843             // Preserve behavioral compatibility with AbstractCollection,
 844             // even if c.contains() throws.
 845             System.arraycopy(es, r, es, w, end - r);
 846             w += end - r;
 847             throw ex;
 848         } finally {
 849             modCount += end - w;
 850             shiftTailOverGap(es, w, end);
 851         }
 852         return true;
 853     }
 854 
 855     /**
 856      * Saves the state of the {@code XArrayList} instance to a stream
 857      * (that is, serializes it).
 858      *
 859      * @param s the stream
 860      * @throws java.io.IOException if an I/O error occurs
 861      * @serialData The length of the array backing the {@code XArrayList}
 862      *             instance is emitted (int), followed by all of its elements
 863      *             (each an {@code Object}) in the proper order.
 864      */
 865     private void writeObject(java.io.ObjectOutputStream s)
 866         throws java.io.IOException {
 867         // Write out element count, and any hidden stuff
 868         int expectedModCount = modCount;
 869         s.defaultWriteObject();
 870 
 871         // Write out size as capacity for behavioral compatibility with clone()
 872         s.writeInt(size);
 873 
 874         // Write out all elements in the proper order.
 875         for (int i=0; i&lt;size; i++) {
 876             s.writeObject(elementData[i]);
 877         }
 878 
 879         if (modCount != expectedModCount) {
 880             throw new ConcurrentModificationException();
 881         }
 882     }
 883 
 884     /**
 885      * Reconstitutes the {@code XArrayList} instance from a stream (that is,
 886      * deserializes it).
 887      * @param s the stream
 888      * @throws ClassNotFoundException if the class of a serialized object
 889      *         could not be found
 890      * @throws java.io.IOException if an I/O error occurs
 891      */
 892     private void readObject(java.io.ObjectInputStream s)
 893         throws java.io.IOException, ClassNotFoundException {
 894 
 895         // Read in size, and any hidden stuff
 896         s.defaultReadObject();
 897 
 898         // Read in capacity
 899         s.readInt(); // ignored
 900 
 901         if (size &gt; 0) {
 902             // like clone(), allocate array based upon size not capacity
 903             //SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
 904             Object[] elements = new Object[size];
 905 
 906             // Read in all elements in the proper order.
 907             for (int i = 0; i &lt; size; i++) {
 908                 elements[i] = s.readObject();
 909             }
 910 
 911             elementData = elements;
 912         } else if (size == 0) {
 913             elementData = EMPTY_ELEMENTDATA;
 914         } else {
 915             throw new java.io.InvalidObjectException(&quot;Invalid size: &quot; + size);
 916         }
 917     }
 918 
 919     /**
 920      * Returns a list iterator over the elements in this list (in proper
 921      * sequence), starting at the specified position in the list.
 922      * The specified index indicates the first element that would be
 923      * returned by an initial call to {@link ListIterator#next next}.
 924      * An initial call to {@link ListIterator#previous previous} would
 925      * return the element with the specified index minus one.
 926      *
 927      * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 928      *
 929      * @throws IndexOutOfBoundsException {@inheritDoc}
 930      */
 931     public ListIterator&lt;E&gt; listIterator(int index) {
 932         rangeCheckForAdd(index);
 933         return new ListItr(index);
 934     }
 935 
 936     /**
 937      * Returns a list iterator over the elements in this list (in proper
 938      * sequence).
 939      *
 940      * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 941      *
 942      * @see #listIterator(int)
 943      */
 944     public ListIterator&lt;E&gt; listIterator() {
 945         return new ListItr(0);
 946     }
 947 
 948     /**
 949      * Returns an iterator over the elements in this list in proper sequence.
 950      *
 951      * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 952      *
 953      * @return an iterator over the elements in this list in proper sequence
 954      */
 955     public Iterator&lt;E&gt; iterator() {
 956         return new Itr();
 957     }
 958 
 959     /**
 960      * An optimized version of AbstractList.Itr
 961      */
 962     private class Itr implements Iterator&lt;E&gt; {
 963         int cursor;       // index of next element to return
 964         int lastRet = -1; // index of last element returned; -1 if no such
 965         int expectedModCount = modCount;
 966 
 967         // prevent creating a synthetic constructor
 968         Itr() {}
 969 
 970         public boolean hasNext() {
 971             return cursor != size;
 972         }
 973 
 974         @SuppressWarnings(&quot;unchecked&quot;)
 975         public E next() {
 976             checkForComodification();
 977             int i = cursor;
 978             if (i &gt;= size)
 979                 throw new NoSuchElementException();
 980             Object[] elementData = XArrayList.this.elementData;
 981             if (i &gt;= elementData.length)
 982                 throw new ConcurrentModificationException();
 983             cursor = i + 1;
 984             return (E) elementData[lastRet = i];
 985         }
 986 
 987         public void remove() {
 988             if (lastRet &lt; 0)
 989                 throw new IllegalStateException();
 990             checkForComodification();
 991 
 992             try {
 993                 XArrayList.this.remove(lastRet);
 994                 cursor = lastRet;
 995                 lastRet = -1;
 996                 expectedModCount = modCount;
 997             } catch (IndexOutOfBoundsException ex) {
 998                 throw new ConcurrentModificationException();
 999             }
1000         }
1001 
1002         @Override
1003         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1004             Objects.requireNonNull(action);
1005             final int size = XArrayList.this.size;
1006             int i = cursor;
1007             if (i &lt; size) {
1008                 final Object[] es = elementData;
1009                 if (i &gt;= es.length)
1010                     throw new ConcurrentModificationException();
1011                 for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++)
1012                     action.accept(elementAt(es, i));
1013                 // update once at end to reduce heap write traffic
1014                 cursor = i;
1015                 lastRet = i - 1;
1016                 checkForComodification();
1017             }
1018         }
1019 
1020         final void checkForComodification() {
1021             if (modCount != expectedModCount)
1022                 throw new ConcurrentModificationException();
1023         }
1024     }
1025 
1026     /**
1027      * An optimized version of AbstractList.ListItr
1028      */
1029     private class ListItr extends Itr implements ListIterator&lt;E&gt; {
1030         ListItr(int index) {
1031             super();
1032             cursor = index;
1033         }
1034 
1035         public boolean hasPrevious() {
1036             return cursor != 0;
1037         }
1038 
1039         public int nextIndex() {
1040             return cursor;
1041         }
1042 
1043         public int previousIndex() {
1044             return cursor - 1;
1045         }
1046 
1047         @SuppressWarnings(&quot;unchecked&quot;)
1048         public E previous() {
1049             checkForComodification();
1050             int i = cursor - 1;
1051             if (i &lt; 0)
1052                 throw new NoSuchElementException();
1053             Object[] elementData = XArrayList.this.elementData;
1054             if (i &gt;= elementData.length)
1055                 throw new ConcurrentModificationException();
1056             cursor = i;
1057             return (E) elementData[lastRet = i];
1058         }
1059 
1060         public void set(E e) {
1061             if (lastRet &lt; 0)
1062                 throw new IllegalStateException();
1063             checkForComodification();
1064 
1065             try {
1066                 XArrayList.this.set(lastRet, e);
1067             } catch (IndexOutOfBoundsException ex) {
1068                 throw new ConcurrentModificationException();
1069             }
1070         }
1071 
1072         public void add(E e) {
1073             checkForComodification();
1074 
1075             try {
1076                 int i = cursor;
1077                 XArrayList.this.add(i, e);
1078                 cursor = i + 1;
1079                 lastRet = -1;
1080                 expectedModCount = modCount;
1081             } catch (IndexOutOfBoundsException ex) {
1082                 throw new ConcurrentModificationException();
1083             }
1084         }
1085     }
1086 
1087     /**
1088      * Return a new cursor for this XArrayList.
1089      * @return a cursor
1090      */
1091     public InlineCursor&lt;E&gt; cursor() {
1092         return new AListCursor&lt;&gt;(0);
1093     }
1094 
1095     /**
1096      * Create an inline cursor for this XArrayList.
1097      */
1098     private inline class AListCursor&lt;E&gt; implements InlineCursor&lt;E&gt; {
1099         // Inner class field &#39;this&#39; is initialized
<a name="1" id="anc1"></a><span class="line-modified">1100         int index;</span>
1101         int expectedModCount;
1102 
<a name="2" id="anc2"></a>







1103         /**
1104          * Create a new Cursor for this XArrayList.
1105          *
<a name="3" id="anc3"></a><span class="line-modified">1106          * @param cursor index</span>

1107          */
1108         public AListCursor(int cursor) {
1109             this.index = cursor;
1110             this.expectedModCount = XArrayList.this.modCount;
1111         }
1112 
<a name="4" id="anc4"></a>











1113         @Override
1114         public boolean exists() {
<a name="5" id="anc5"></a><span class="line-modified">1115             return index &lt; XArrayList.this.size;</span>
1116         }
1117 
1118         @SuppressWarnings(&quot;unchecked&quot;)
1119         public E get() {
<a name="6" id="anc6"></a><span class="line-modified">1120             if (exists()) {</span>
<span class="line-modified">1121                 checkForComodification();</span>
<span class="line-modified">1122                 try {</span>
<span class="line-modified">1123                     return (E) XArrayList.this.elementData[index];</span>
<span class="line-modified">1124                 } catch (ArrayIndexOutOfBoundsException aioobe) {</span>
<span class="line-modified">1125                     throw new ConcurrentModificationException();</span>
<span class="line-modified">1126                 }</span>

1127             }
<a name="7" id="anc7"></a><span class="line-added">1128             throw new NoSuchElementException();</span>
1129         }
1130 
1131         @Override
1132         public AListCursor&lt;E&gt; advance() {
<a name="8" id="anc8"></a>
1133             // new Cursor will have a current expectedModCount
1134             // TBD: Saturate index?  So calling adv, adv, adv, prev == last
<a name="9" id="anc9"></a><span class="line-modified">1135             return new AListCursor&lt;&gt;(Math.min(index + 1, size));</span>













1136         }
1137 
1138         final void checkForComodification() {
1139             if (XArrayList.this.modCount != expectedModCount)
1140                 throw new ConcurrentModificationException();
1141         }
1142     }
1143 
1144     /**
1145      * Returns a iterator (Using an InlineCursor) over the elements in this list in proper sequence.
1146      *
1147      * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
1148      *
1149      * @return an iterator over the elements in this list in proper sequence
1150      */
1151     public Iterator&lt;E&gt; iteratorCurs() {
1152         return new CurItr();
1153     }
1154 
1155     /**
1156      * Iterate using a Cursor.
1157      */
1158     private class CurItr implements Iterator&lt;E&gt; {
1159         AListCursor&lt;E&gt; cursor;
1160         AListCursor&lt;E&gt; lastRet;
1161 
1162         // prevent creating a synthetic constructor
1163         CurItr() {
1164             this.cursor = new AListCursor&lt;E&gt;(0);
1165             this.lastRet = this.cursor;
1166         }
1167 
1168         public boolean hasNext() {
1169             return cursor.advance().exists();
1170         }
1171 
1172         @SuppressWarnings(&quot;unchecked&quot;)
1173         public E next() {
1174             E val = cursor.get();
1175             lastRet = cursor;
1176             cursor = cursor.advance();
1177             return val;
1178         }
1179 
<a name="10" id="anc10"></a>






1180         @Override
1181         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1182             Objects.requireNonNull(action);
1183 
1184             AListCursor&lt;E&gt; cur = cursor;
1185             while (cur.exists()) {
1186                 E val = cur.get();
1187                 action.accept(val);
1188                 cur = cur.advance();
1189             }
1190             cursor = cur;
1191         }
1192 
1193         public String toString() {
1194             return &quot;cur: &quot; + cursor;
1195         }
1196     }
1197 
1198 
1199     /**
1200      * Returns a view of the portion of this list between the specified
1201      * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If
1202      * {@code fromIndex} and {@code toIndex} are equal, the returned list is
1203      * empty.)  The returned list is backed by this list, so non-structural
1204      * changes in the returned list are reflected in this list, and vice-versa.
1205      * The returned list supports all of the optional list operations.
1206      *
1207      * &lt;p&gt;This method eliminates the need for explicit range operations (of
1208      * the sort that commonly exist for arrays).  Any operation that expects
1209      * a list can be used as a range operation by passing a subList view
1210      * instead of a whole list.  For example, the following idiom
1211      * removes a range of elements from a list:
1212      * &lt;pre&gt;
1213      *      list.subList(from, to).clear();
1214      * &lt;/pre&gt;
1215      * Similar idioms may be constructed for {@link #indexOf(Object)} and
1216      * {@link #lastIndexOf(Object)}, and all of the algorithms in the
1217      * {@link Collections} class can be applied to a subList.
1218      *
1219      * &lt;p&gt;The semantics of the list returned by this method become undefined if
1220      * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in
1221      * any way other than via the returned list.  (Structural modifications are
1222      * those that change the size of this list, or otherwise perturb it in such
1223      * a fashion that iterations in progress may yield incorrect results.)
1224      *
1225      * @throws IndexOutOfBoundsException {@inheritDoc}
1226      * @throws IllegalArgumentException {@inheritDoc}
1227      */
1228     public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1229         subListRangeCheck(fromIndex, toIndex, size);
1230         return new SubList&lt;&gt;(this, fromIndex, toIndex);
1231     }
1232 
1233     private static class SubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess {
1234         private final XArrayList&lt;E&gt; root;
1235         private final SubList&lt;E&gt; parent;
1236         private final int offset;
1237         private int size;
1238 
1239         /**
1240          * Constructs a sublist of an arbitrary XArrayList.
1241          */
1242         public SubList(XArrayList&lt;E&gt; root, int fromIndex, int toIndex) {
1243             this.root = root;
1244             this.parent = null;
1245             this.offset = fromIndex;
1246             this.size = toIndex - fromIndex;
1247             this.modCount = root.modCount;
1248         }
1249 
1250         /**
1251          * Constructs a sublist of another SubList.
1252          */
1253         private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) {
1254             this.root = parent.root;
1255             this.parent = parent;
1256             this.offset = parent.offset + fromIndex;
1257             this.size = toIndex - fromIndex;
1258             this.modCount = root.modCount;
1259         }
1260 
1261         public E set(int index, E element) {
1262             Objects.checkIndex(index, size);
1263             checkForComodification();
1264             E oldValue = root.elementData(offset + index);
1265             root.elementData[offset + index] = element;
1266             return oldValue;
1267         }
1268 
1269         public E get(int index) {
1270             Objects.checkIndex(index, size);
1271             checkForComodification();
1272             return root.elementData(offset + index);
1273         }
1274 
1275         public int size() {
1276             checkForComodification();
1277             return size;
1278         }
1279 
1280         public void add(int index, E element) {
1281             rangeCheckForAdd(index);
1282             checkForComodification();
1283             root.add(offset + index, element);
1284             updateSizeAndModCount(1);
1285         }
1286 
1287         public E remove(int index) {
1288             Objects.checkIndex(index, size);
1289             checkForComodification();
1290             E result = root.remove(offset + index);
1291             updateSizeAndModCount(-1);
1292             return result;
1293         }
1294 
1295         protected void removeRange(int fromIndex, int toIndex) {
1296             checkForComodification();
1297             root.removeRange(offset + fromIndex, offset + toIndex);
1298             updateSizeAndModCount(fromIndex - toIndex);
1299         }
1300 
1301         public boolean addAll(Collection&lt;? extends E&gt; c) {
1302             return addAll(this.size, c);
1303         }
1304 
1305         public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
1306             rangeCheckForAdd(index);
1307             int cSize = c.size();
1308             if (cSize==0)
1309                 return false;
1310             checkForComodification();
1311             root.addAll(offset + index, c);
1312             updateSizeAndModCount(cSize);
1313             return true;
1314         }
1315 
1316         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
1317             root.replaceAllRange(operator, offset, offset + size);
1318         }
1319 
1320         public boolean removeAll(Collection&lt;?&gt; c) {
1321             return batchRemove(c, false);
1322         }
1323 
1324         public boolean retainAll(Collection&lt;?&gt; c) {
1325             return batchRemove(c, true);
1326         }
1327 
1328         private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
1329             checkForComodification();
1330             int oldSize = root.size;
1331             boolean modified =
1332                 root.batchRemove(c, complement, offset, offset + size);
1333             if (modified)
1334                 updateSizeAndModCount(root.size - oldSize);
1335             return modified;
1336         }
1337 
1338         public boolean removeIf(Predicate&lt;? super E&gt; filter) {
1339             checkForComodification();
1340             int oldSize = root.size;
1341             boolean modified = root.removeIf(filter, offset, offset + size);
1342             if (modified)
1343                 updateSizeAndModCount(root.size - oldSize);
1344             return modified;
1345         }
1346 
1347         public Object[] toArray() {
1348             checkForComodification();
1349             return Arrays.copyOfRange(root.elementData, offset, offset + size);
1350         }
1351 
1352         @SuppressWarnings(&quot;unchecked&quot;)
1353         public &lt;T&gt; T[] toArray(T[] a) {
1354             checkForComodification();
1355             if (a.length &lt; size)
1356                 return (T[]) Arrays.copyOfRange(
1357                         root.elementData, offset, offset + size, a.getClass());
1358             System.arraycopy(root.elementData, offset, a, 0, size);
1359             if (a.length &gt; size)
1360                 a[size] = null;
1361             return a;
1362         }
1363 
1364         public boolean equals(Object o) {
1365             if (o == this) {
1366                 return true;
1367             }
1368 
1369             if (!(o instanceof List)) {
1370                 return false;
1371             }
1372 
1373             boolean equal = root.equalsRange((List&lt;?&gt;)o, offset, offset + size);
1374             checkForComodification();
1375             return equal;
1376         }
1377 
1378         public int hashCode() {
1379             int hash = root.hashCodeRange(offset, offset + size);
1380             checkForComodification();
1381             return hash;
1382         }
1383 
1384         public int indexOf(Object o) {
1385             int index = root.indexOfRange(o, offset, offset + size);
1386             checkForComodification();
1387             return index &gt;= 0 ? index - offset : -1;
1388         }
1389 
1390         public int lastIndexOf(Object o) {
1391             int index = root.lastIndexOfRange(o, offset, offset + size);
1392             checkForComodification();
1393             return index &gt;= 0 ? index - offset : -1;
1394         }
1395 
1396         public boolean contains(Object o) {
1397             return indexOf(o) &gt;= 0;
1398         }
1399 
1400         public Iterator&lt;E&gt; iterator() {
1401             return listIterator();
1402         }
1403 
1404         public ListIterator&lt;E&gt; listIterator(int index) {
1405             checkForComodification();
1406             rangeCheckForAdd(index);
1407 
1408             return new ListIterator&lt;E&gt;() {
1409                 int cursor = index;
1410                 int lastRet = -1;
1411                 int expectedModCount = root.modCount;
1412 
1413                 public boolean hasNext() {
1414                     return cursor != SubList.this.size;
1415                 }
1416 
1417                 @SuppressWarnings(&quot;unchecked&quot;)
1418                 public E next() {
1419                     checkForComodification();
1420                     int i = cursor;
1421                     if (i &gt;= SubList.this.size)
1422                         throw new NoSuchElementException();
1423                     Object[] elementData = root.elementData;
1424                     if (offset + i &gt;= elementData.length)
1425                         throw new ConcurrentModificationException();
1426                     cursor = i + 1;
1427                     return (E) elementData[offset + (lastRet = i)];
1428                 }
1429 
1430                 public boolean hasPrevious() {
1431                     return cursor != 0;
1432                 }
1433 
1434                 @SuppressWarnings(&quot;unchecked&quot;)
1435                 public E previous() {
1436                     checkForComodification();
1437                     int i = cursor - 1;
1438                     if (i &lt; 0)
1439                         throw new NoSuchElementException();
1440                     Object[] elementData = root.elementData;
1441                     if (offset + i &gt;= elementData.length)
1442                         throw new ConcurrentModificationException();
1443                     cursor = i;
1444                     return (E) elementData[offset + (lastRet = i)];
1445                 }
1446 
1447                 public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1448                     Objects.requireNonNull(action);
1449                     final int size = SubList.this.size;
1450                     int i = cursor;
1451                     if (i &lt; size) {
1452                         final Object[] es = root.elementData;
1453                         if (offset + i &gt;= es.length)
1454                             throw new ConcurrentModificationException();
1455                         for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++)
1456                             action.accept(elementAt(es, offset + i));
1457                         // update once at end to reduce heap write traffic
1458                         cursor = i;
1459                         lastRet = i - 1;
1460                         checkForComodification();
1461                     }
1462                 }
1463 
1464                 public int nextIndex() {
1465                     return cursor;
1466                 }
1467 
1468                 public int previousIndex() {
1469                     return cursor - 1;
1470                 }
1471 
1472                 public void remove() {
1473                     if (lastRet &lt; 0)
1474                         throw new IllegalStateException();
1475                     checkForComodification();
1476 
1477                     try {
1478                         SubList.this.remove(lastRet);
1479                         cursor = lastRet;
1480                         lastRet = -1;
1481                         expectedModCount = root.modCount;
1482                     } catch (IndexOutOfBoundsException ex) {
1483                         throw new ConcurrentModificationException();
1484                     }
1485                 }
1486 
1487                 public void set(E e) {
1488                     if (lastRet &lt; 0)
1489                         throw new IllegalStateException();
1490                     checkForComodification();
1491 
1492                     try {
1493                         root.set(offset + lastRet, e);
1494                     } catch (IndexOutOfBoundsException ex) {
1495                         throw new ConcurrentModificationException();
1496                     }
1497                 }
1498 
1499                 public void add(E e) {
1500                     checkForComodification();
1501 
1502                     try {
1503                         int i = cursor;
1504                         SubList.this.add(i, e);
1505                         cursor = i + 1;
1506                         lastRet = -1;
1507                         expectedModCount = root.modCount;
1508                     } catch (IndexOutOfBoundsException ex) {
1509                         throw new ConcurrentModificationException();
1510                     }
1511                 }
1512 
1513                 final void checkForComodification() {
1514                     if (root.modCount != expectedModCount)
1515                         throw new ConcurrentModificationException();
1516                 }
1517             };
1518         }
1519 
1520         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1521             subListRangeCheck(fromIndex, toIndex, size);
1522             return new SubList&lt;&gt;(this, fromIndex, toIndex);
1523         }
1524 
1525         private void rangeCheckForAdd(int index) {
1526             if (index &lt; 0 || index &gt; this.size)
1527                 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
1528         }
1529 
1530         private String outOfBoundsMsg(int index) {
1531             return &quot;Index: &quot;+index+&quot;, Size: &quot;+this.size;
1532         }
1533 
1534         private void checkForComodification() {
1535             if (root.modCount != modCount)
1536                 throw new ConcurrentModificationException();
1537         }
1538 
1539         private void updateSizeAndModCount(int sizeChange) {
1540             SubList&lt;E&gt; slist = this;
1541             do {
1542                 slist.size += sizeChange;
1543                 slist.modCount = root.modCount;
1544                 slist = slist.parent;
1545             } while (slist != null);
1546         }
1547 
1548         public Spliterator&lt;E&gt; spliterator() {
1549             checkForComodification();
1550 
1551             // ArrayListSpliterator not used here due to late-binding
1552             return new Spliterator&lt;E&gt;() {
1553                 private int index = offset; // current index, modified on advance/split
1554                 private int fence = -1; // -1 until used; then one past last index
1555                 private int expectedModCount; // initialized when fence set
1556 
1557                 private int getFence() { // initialize fence to size on first use
1558                     int hi; // (a specialized variant appears in method forEach)
1559                     if ((hi = fence) &lt; 0) {
1560                         expectedModCount = modCount;
1561                         hi = fence = offset + size;
1562                     }
1563                     return hi;
1564                 }
1565 
1566                 public XArrayList&lt;E&gt;.ArrayListSpliterator trySplit() {
1567                     int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
1568                     // ArrayListSpliterator can be used here as the source is already bound
1569                     return (lo &gt;= mid) ? null : // divide range in half unless too small
1570                         root.new ArrayListSpliterator(lo, index = mid, expectedModCount);
1571                 }
1572 
1573                 public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
1574                     Objects.requireNonNull(action);
1575                     int hi = getFence(), i = index;
1576                     if (i &lt; hi) {
1577                         index = i + 1;
1578                         @SuppressWarnings(&quot;unchecked&quot;) E e = (E)root.elementData[i];
1579                         action.accept(e);
1580                         if (root.modCount != expectedModCount)
1581                             throw new ConcurrentModificationException();
1582                         return true;
1583                     }
1584                     return false;
1585                 }
1586 
1587                 public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1588                     Objects.requireNonNull(action);
1589                     int i, hi, mc; // hoist accesses and checks from loop
1590                     XArrayList&lt;E&gt; lst = root;
1591                     Object[] a;
1592                     if ((a = lst.elementData) != null) {
1593                         if ((hi = fence) &lt; 0) {
1594                             mc = modCount;
1595                             hi = offset + size;
1596                         }
1597                         else
1598                             mc = expectedModCount;
1599                         if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) {
1600                             for (; i &lt; hi; ++i) {
1601                                 @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i];
1602                                 action.accept(e);
1603                             }
1604                             if (lst.modCount == mc)
1605                                 return;
1606                         }
1607                     }
1608                     throw new ConcurrentModificationException();
1609                 }
1610 
1611                 public long estimateSize() {
1612                     return getFence() - index;
1613                 }
1614 
1615                 public int characteristics() {
1616                     return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
1617                 }
1618             };
1619         }
1620     }
1621 
1622     /**
1623      * @throws NullPointerException {@inheritDoc}
1624      */
1625     @Override
1626     public void forEach(Consumer&lt;? super E&gt; action) {
1627         Objects.requireNonNull(action);
1628         final int expectedModCount = modCount;
1629         final Object[] es = elementData;
1630         final int size = this.size;
1631         for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++)
1632             action.accept(elementAt(es, i));
1633         if (modCount != expectedModCount)
1634             throw new ConcurrentModificationException();
1635     }
1636 
1637     /**
1638      * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
1639      * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this
1640      * list.
1641      *
1642      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED},
1643      * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
1644      * Overriding implementations should document the reporting of additional
1645      * characteristic values.
1646      *
1647      * @return a {@code Spliterator} over the elements in this list
1648      * @since 1.8
1649      */
1650     @Override
1651     public Spliterator&lt;E&gt; spliterator() {
1652         return new ArrayListSpliterator(0, -1, 0);
1653     }
1654 
1655     /** Index-based split-by-two, lazily initialized Spliterator */
1656     final class ArrayListSpliterator implements Spliterator&lt;E&gt; {
1657 
1658         /*
1659          * If XArrayLists were immutable, or structurally immutable (no
1660          * adds, removes, etc), we could implement their spliterators
1661          * with Arrays.spliterator. Instead we detect as much
1662          * interference during traversal as practical without
1663          * sacrificing much performance. We rely primarily on
1664          * modCounts. These are not guaranteed to detect concurrency
1665          * violations, and are sometimes overly conservative about
1666          * within-thread interference, but detect enough problems to
1667          * be worthwhile in practice. To carry this out, we (1) lazily
1668          * initialize fence and expectedModCount until the latest
1669          * point that we need to commit to the state we are checking
1670          * against; thus improving precision.  (This doesn&#39;t apply to
1671          * SubLists, that create spliterators with current non-lazy
1672          * values).  (2) We perform only a single
1673          * ConcurrentModificationException check at the end of forEach
1674          * (the most performance-sensitive method). When using forEach
1675          * (as opposed to iterators), we can normally only detect
1676          * interference after actions, not before. Further
1677          * CME-triggering checks apply to all other possible
1678          * violations of assumptions for example null or too-small
1679          * elementData array given its size(), that could only have
1680          * occurred due to interference.  This allows the inner loop
1681          * of forEach to run without any further checks, and
1682          * simplifies lambda-resolution. While this does entail a
1683          * number of checks, note that in the common case of
1684          * list.stream().forEach(a), no checks or other computation
1685          * occur anywhere other than inside forEach itself.  The other
1686          * less-often-used methods cannot take advantage of most of
1687          * these streamlinings.
1688          */
1689 
1690         private int index; // current index, modified on advance/split
1691         private int fence; // -1 until used; then one past last index
1692         private int expectedModCount; // initialized when fence set
1693 
1694         /** Creates new spliterator covering the given range. */
1695         ArrayListSpliterator(int origin, int fence, int expectedModCount) {
1696             this.index = origin;
1697             this.fence = fence;
1698             this.expectedModCount = expectedModCount;
1699         }
1700 
1701         private int getFence() { // initialize fence to size on first use
1702             int hi; // (a specialized variant appears in method forEach)
1703             if ((hi = fence) &lt; 0) {
1704                 expectedModCount = modCount;
1705                 hi = fence = size;
1706             }
1707             return hi;
1708         }
1709 
1710         public ArrayListSpliterator trySplit() {
1711             int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
1712             return (lo &gt;= mid) ? null : // divide range in half unless too small
1713                 new ArrayListSpliterator(lo, index = mid, expectedModCount);
1714         }
1715 
1716         public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
1717             if (action == null)
1718                 throw new NullPointerException();
1719             int hi = getFence(), i = index;
1720             if (i &lt; hi) {
1721                 index = i + 1;
1722                 @SuppressWarnings(&quot;unchecked&quot;) E e = (E)elementData[i];
1723                 action.accept(e);
1724                 if (modCount != expectedModCount)
1725                     throw new ConcurrentModificationException();
1726                 return true;
1727             }
1728             return false;
1729         }
1730 
1731         public void forEachRemaining(Consumer&lt;? super E&gt; action) {
1732             int i, hi, mc; // hoist accesses and checks from loop
1733             Object[] a;
1734             if (action == null)
1735                 throw new NullPointerException();
1736             if ((a = elementData) != null) {
1737                 if ((hi = fence) &lt; 0) {
1738                     mc = modCount;
1739                     hi = size;
1740                 }
1741                 else
1742                     mc = expectedModCount;
1743                 if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) {
1744                     for (; i &lt; hi; ++i) {
1745                         @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i];
1746                         action.accept(e);
1747                     }
1748                     if (modCount == mc)
1749                         return;
1750                 }
1751             }
1752             throw new ConcurrentModificationException();
1753         }
1754 
1755         public long estimateSize() {
1756             return getFence() - index;
1757         }
1758 
1759         public int characteristics() {
1760             return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
1761         }
1762     }
1763 
1764     // A tiny bit set implementation
1765 
1766     private static long[] nBits(int n) {
1767         return new long[((n - 1) &gt;&gt; 6) + 1];
1768     }
1769     private static void setBit(long[] bits, int i) {
1770         bits[i &gt;&gt; 6] |= 1L &lt;&lt; i;
1771     }
1772     private static boolean isClear(long[] bits, int i) {
1773         return (bits[i &gt;&gt; 6] &amp; (1L &lt;&lt; i)) == 0;
1774     }
1775 
1776     /**
1777      * @throws NullPointerException {@inheritDoc}
1778      */
1779     @Override
1780     public boolean removeIf(Predicate&lt;? super E&gt; filter) {
1781         return removeIf(filter, 0, size);
1782     }
1783 
1784     /**
1785      * Removes all elements satisfying the given predicate, from index
1786      * i (inclusive) to index end (exclusive).
1787      */
1788     boolean removeIf(Predicate&lt;? super E&gt; filter, int i, final int end) {
1789         Objects.requireNonNull(filter);
1790         int expectedModCount = modCount;
1791         final Object[] es = elementData;
1792         // Optimize for initial run of survivors
1793         for (; i &lt; end &amp;&amp; !filter.test(elementAt(es, i)); i++)
1794             ;
1795         // Tolerate predicates that reentrantly access the collection for
1796         // read (but writers still get CME), so traverse once to find
1797         // elements to delete, a second pass to physically expunge.
1798         if (i &lt; end) {
1799             final int beg = i;
1800             final long[] deathRow = nBits(end - beg);
1801             deathRow[0] = 1L;   // set bit 0
1802             for (i = beg + 1; i &lt; end; i++)
1803                 if (filter.test(elementAt(es, i)))
1804                     setBit(deathRow, i - beg);
1805             if (modCount != expectedModCount)
1806                 throw new ConcurrentModificationException();
1807             modCount++;
1808             int w = beg;
1809             for (i = beg; i &lt; end; i++)
1810                 if (isClear(deathRow, i - beg))
1811                     es[w++] = es[i];
1812             shiftTailOverGap(es, w, end);
1813             return true;
1814         } else {
1815             if (modCount != expectedModCount)
1816                 throw new ConcurrentModificationException();
1817             return false;
1818         }
1819     }
1820 
1821     @Override
1822     public void replaceAll(UnaryOperator&lt;E&gt; operator) {
1823         replaceAllRange(operator, 0, size);
1824         // TODO(8203662): remove increment of modCount from ...
1825         modCount++;
1826     }
1827 
1828     private void replaceAllRange(UnaryOperator&lt;E&gt; operator, int i, int end) {
1829         Objects.requireNonNull(operator);
1830         final int expectedModCount = modCount;
1831         final Object[] es = elementData;
1832         for (; modCount == expectedModCount &amp;&amp; i &lt; end; i++)
1833             es[i] = operator.apply(elementAt(es, i));
1834         if (modCount != expectedModCount)
1835             throw new ConcurrentModificationException();
1836     }
1837 
1838     @Override
1839     @SuppressWarnings(&quot;unchecked&quot;)
1840     public void sort(Comparator&lt;? super E&gt; c) {
1841         final int expectedModCount = modCount;
1842         Arrays.sort((E[]) elementData, 0, size, c);
1843         if (modCount != expectedModCount)
1844             throw new ConcurrentModificationException();
1845         modCount++;
1846     }
1847 
1848     void checkInvariants() {
1849         // assert size &gt;= 0;
1850         // assert size == elementData.length || elementData[size] == null;
1851     }
1852 
1853     /**
1854      * Calculates a new array length given an array&#39;s current length, a preferred
1855      * growth value, and a minimum growth value.  If the preferred growth value
1856      * is less than the minimum growth value, the minimum growth value is used in
1857      * its place.  If the sum of the current length and the preferred growth
1858      * value does not exceed {@link #MAX_ARRAY_LENGTH}, that sum is returned.
1859      * If the sum of the current length and the minimum growth value does not
1860      * exceed {@code MAX_ARRAY_LENGTH}, then {@code MAX_ARRAY_LENGTH} is returned.
1861      * If the sum does not overflow an int, then {@code Integer.MAX_VALUE} is
1862      * returned.  Otherwise, {@code OutOfMemoryError} is thrown.
1863      *
1864      * @param oldLength   current length of the array (must be non negative)
1865      * @param minGrowth   minimum required growth of the array length (must be
1866      *                    positive)
1867      * @param prefGrowth  preferred growth of the array length (ignored, if less
1868      *                    then {@code minGrowth})
1869      * @return the new length of the array
1870      * @throws OutOfMemoryError if increasing {@code oldLength} by
1871      *                    {@code minGrowth} overflows.
1872      */
1873     private static int newLength(int oldLength, int minGrowth, int prefGrowth) {
1874         // assert oldLength &gt;= 0
1875         // assert minGrowth &gt; 0
1876 
1877         int newLength = Math.max(minGrowth, prefGrowth) + oldLength;
1878         if (newLength - MAX_ARRAY_LENGTH &lt;= 0) {
1879             return newLength;
1880         }
1881         return hugeLength(oldLength, minGrowth);
1882     }
1883 
1884     private static int hugeLength(int oldLength, int minGrowth) {
1885         int minLength = oldLength + minGrowth;
1886         if (minLength &lt; 0) { // overflow
1887             throw new OutOfMemoryError(&quot;Required array length too large&quot;);
1888         }
1889         if (minLength &lt;= MAX_ARRAY_LENGTH) {
1890             return MAX_ARRAY_LENGTH;
1891         }
1892         return Integer.MAX_VALUE;
1893     }
1894 
1895     private static final int MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;
1896 
1897     private static void subListRangeCheck(int fromIndex, int toIndex, int size) {
1898         if (fromIndex &lt; 0)
1899             throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);
1900         if (toIndex &gt; size)
1901             throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);
1902         if (fromIndex &gt; toIndex)
1903             throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +
1904                     &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
1905     }
1906 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
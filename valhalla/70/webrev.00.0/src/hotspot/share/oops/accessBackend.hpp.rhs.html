<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_ACCESSBACKEND_HPP
  26 #define SHARE_OOPS_ACCESSBACKEND_HPP
  27 
  28 #include &quot;gc/shared/barrierSetConfig.hpp&quot;
  29 #include &quot;memory/allocation.hpp&quot;
  30 #include &quot;metaprogramming/conditional.hpp&quot;
  31 #include &quot;metaprogramming/decay.hpp&quot;
  32 #include &quot;metaprogramming/enableIf.hpp&quot;
  33 #include &quot;metaprogramming/integralConstant.hpp&quot;
  34 #include &quot;metaprogramming/isFloatingPoint.hpp&quot;
  35 #include &quot;metaprogramming/isIntegral.hpp&quot;
  36 #include &quot;metaprogramming/isPointer.hpp&quot;
  37 #include &quot;metaprogramming/isSame.hpp&quot;
  38 #include &quot;metaprogramming/isVolatile.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/oopsHierarchy.hpp&quot;
  41 #include &quot;runtime/globals.hpp&quot;
  42 #include &quot;utilities/debug.hpp&quot;
  43 #include &quot;utilities/globalDefinitions.hpp&quot;
  44 
  45 
  46 // This metafunction returns either oop or narrowOop depending on whether
  47 // an access needs to use compressed oops or not.
  48 template &lt;DecoratorSet decorators&gt;
  49 struct HeapOopType: AllStatic {
  50   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
  51                                          HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  52   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  53 };
  54 
  55 // This meta-function returns either oop or narrowOop depending on whether
  56 // a back-end needs to consider compressed oops types or not.
  57 template &lt;DecoratorSet decorators&gt;
  58 struct ValueOopType: AllStatic {
  59   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  60   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  61 };
  62 
  63 namespace AccessInternal {
  64   enum BarrierType {
  65     BARRIER_STORE,
  66     BARRIER_STORE_AT,
  67     BARRIER_LOAD,
  68     BARRIER_LOAD_AT,
  69     BARRIER_ATOMIC_CMPXCHG,
  70     BARRIER_ATOMIC_CMPXCHG_AT,
  71     BARRIER_ATOMIC_XCHG,
  72     BARRIER_ATOMIC_XCHG_AT,
  73     BARRIER_ARRAYCOPY,
  74     BARRIER_CLONE,
  75     BARRIER_VALUE_COPY,
  76     BARRIER_RESOLVE
  77   };
  78 
  79   template &lt;DecoratorSet decorators, typename T&gt;
  80   struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
  81     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
  82     IsSame&lt;typename HeapOopType&lt;decorators&gt;::type, narrowOop&gt;::value &amp;&amp;
  83     IsSame&lt;T, oop&gt;::value&gt; {};
  84 
  85   // This metafunction returns an appropriate oop type if the value is oop-like
  86   // and otherwise returns the same type T.
  87   template &lt;DecoratorSet decorators, typename T&gt;
  88   struct EncodedType: AllStatic {
  89     typedef typename Conditional&lt;
  90       HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
  91       typename HeapOopType&lt;decorators&gt;::type, T&gt;::type type;
  92   };
  93 
  94   template &lt;DecoratorSet decorators&gt;
  95   inline typename HeapOopType&lt;decorators&gt;::type*
  96   oop_field_addr(oop base, ptrdiff_t byte_offset) {
  97     return reinterpret_cast&lt;typename HeapOopType&lt;decorators&gt;::type*&gt;(
  98              reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
  99   }
 100 
 101   // This metafunction returns whether it is possible for a type T to require
 102   // locking to support wide atomics or not.
 103   template &lt;typename T&gt;
 104 #ifdef SUPPORTS_NATIVE_CX8
 105   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, false&gt; {};
 106 #else
 107   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, (sizeof(T) &gt; 4)&gt; {};
 108 #endif
 109 
 110   template &lt;DecoratorSet decorators, typename T&gt;
 111   struct AccessFunctionTypes {
 112     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
 113     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
 114     typedef T (*atomic_cmpxchg_at_func_t)(oop base, ptrdiff_t offset, T compare_value, T new_value);
 115     typedef T (*atomic_xchg_at_func_t)(oop base, ptrdiff_t offset, T new_value);
 116 
 117     typedef T (*load_func_t)(void* addr);
 118     typedef void (*store_func_t)(void* addr, T value);
 119     typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);
 120     typedef T (*atomic_xchg_func_t)(void* addr, T new_value);
 121 
 122     typedef void (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 123                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 124                                      size_t length);
 125     typedef void (*clone_func_t)(oop src, oop dst, size_t size);
 126     typedef void (*value_copy_func_t)(void* src, void* dst, ValueKlass* md);
 127     typedef oop (*resolve_func_t)(oop obj);
 128   };
 129 
 130   template &lt;DecoratorSet decorators&gt;
 131   struct AccessFunctionTypes&lt;decorators, void&gt; {
 132     typedef void (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,
 133                                      arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
 134                                      size_t length);
 135   };
 136 
 137   template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
 138 
 139 #define ACCESS_GENERATE_ACCESS_FUNCTION(bt, func)                   \
 140   template &lt;DecoratorSet decorators, typename T&gt;                    \
 141   struct AccessFunction&lt;decorators, T, bt&gt;: AllStatic{              \
 142     typedef typename AccessFunctionTypes&lt;decorators, T&gt;::func type; \
 143   }
 144   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE, store_func_t);
 145   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE_AT, store_at_func_t);
 146   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD, load_func_t);
 147   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD_AT, load_at_func_t);
 148   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG, atomic_cmpxchg_func_t);
 149   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
 150   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
 151   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
 152   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
 153   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
 154   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_VALUE_COPY, value_copy_func_t);
 155   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
 156 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 157 
 158   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 159   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
 160 
 161   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 162   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_oop_barrier();
 163 
 164   class AccessLocker {
 165   public:
 166     AccessLocker();
 167     ~AccessLocker();
 168   };
 169   bool wide_atomic_needs_locking();
 170 
 171   void* field_addr(oop base, ptrdiff_t offset);
 172 
 173   // Forward calls to Copy:: in the cpp file to reduce dependencies and allow
 174   // faster build times, given how frequently included access is.
 175   void arraycopy_arrayof_conjoint_oops(void* src, void* dst, size_t length);
 176   void arraycopy_conjoint_oops(oop* src, oop* dst, size_t length);
 177   void arraycopy_conjoint_oops(narrowOop* src, narrowOop* dst, size_t length);
 178 
 179   void arraycopy_disjoint_words(void* src, void* dst, size_t length);
 180   void arraycopy_disjoint_words_atomic(void* src, void* dst, size_t length);
 181 
 182   template&lt;typename T&gt;
 183   void arraycopy_conjoint(T* src, T* dst, size_t length);
 184   template&lt;typename T&gt;
 185   void arraycopy_arrayof_conjoint(T* src, T* dst, size_t length);
 186   template&lt;typename T&gt;
 187   void arraycopy_conjoint_atomic(T* src, T* dst, size_t length);
 188 }
 189 
 190 // This mask specifies what decorators are relevant for raw accesses. When passing
 191 // accesses to the raw layer, irrelevant decorators are removed.
 192 const DecoratorSet RAW_DECORATOR_MASK = INTERNAL_DECORATOR_MASK | MO_DECORATOR_MASK |
 193                                         ARRAYCOPY_DECORATOR_MASK | IS_NOT_NULL;
 194 
 195 // The RawAccessBarrier performs raw accesses with additional knowledge of
 196 // memory ordering, so that OrderAccess/Atomic is called when necessary.
 197 // It additionally handles compressed oops, and hence is not completely &quot;raw&quot;
 198 // strictly speaking.
 199 template &lt;DecoratorSet decorators&gt;
 200 class RawAccessBarrier: public AllStatic {
 201 protected:
 202   static inline void* field_addr(oop base, ptrdiff_t byte_offset) {
 203     return AccessInternal::field_addr(base, byte_offset);
 204   }
 205 
 206 protected:
 207   // Only encode if INTERNAL_VALUE_IS_OOP
 208   template &lt;DecoratorSet idecorators, typename T&gt;
 209   static inline typename EnableIf&lt;
 210     AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value,
 211     typename HeapOopType&lt;idecorators&gt;::type&gt;::type
 212   encode_internal(T value);
 213 
 214   template &lt;DecoratorSet idecorators, typename T&gt;
 215   static inline typename EnableIf&lt;
 216     !AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 217   encode_internal(T value) {
 218     return value;
 219   }
 220 
 221   template &lt;typename T&gt;
 222   static inline typename AccessInternal::EncodedType&lt;decorators, T&gt;::type
 223   encode(T value) {
 224     return encode_internal&lt;decorators, T&gt;(value);
 225   }
 226 
 227   // Only decode if INTERNAL_VALUE_IS_OOP
 228   template &lt;DecoratorSet idecorators, typename T&gt;
 229   static inline typename EnableIf&lt;
 230     AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 231   decode_internal(typename HeapOopType&lt;idecorators&gt;::type value);
 232 
 233   template &lt;DecoratorSet idecorators, typename T&gt;
 234   static inline typename EnableIf&lt;
 235     !AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 236   decode_internal(T value) {
 237     return value;
 238   }
 239 
 240   template &lt;typename T&gt;
 241   static inline T decode(typename AccessInternal::EncodedType&lt;decorators, T&gt;::type value) {
 242     return decode_internal&lt;decorators, T&gt;(value);
 243   }
 244 
 245 protected:
 246   template &lt;DecoratorSet ds, typename T&gt;
 247   static typename EnableIf&lt;
 248     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 249   load_internal(void* addr);
 250 
 251   template &lt;DecoratorSet ds, typename T&gt;
 252   static typename EnableIf&lt;
 253     HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
 254   load_internal(void* addr);
 255 
 256   template &lt;DecoratorSet ds, typename T&gt;
 257   static typename EnableIf&lt;
 258     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 259   load_internal(void* addr);
 260 
<a name="2" id="anc2"></a>






 261   template &lt;DecoratorSet ds, typename T&gt;
 262   static inline typename EnableIf&lt;
 263     HasDecorator&lt;ds, MO_UNORDERED&gt;::value, T&gt;::type
 264   load_internal(void* addr) {
 265     return *reinterpret_cast&lt;T*&gt;(addr);
 266   }
 267 
 268   template &lt;DecoratorSet ds, typename T&gt;
 269   static typename EnableIf&lt;
 270     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
 271   store_internal(void* addr, T value);
 272 
 273   template &lt;DecoratorSet ds, typename T&gt;
 274   static typename EnableIf&lt;
 275     HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
 276   store_internal(void* addr, T value);
 277 
 278   template &lt;DecoratorSet ds, typename T&gt;
 279   static typename EnableIf&lt;
 280     HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
 281   store_internal(void* addr, T value);
 282 
<a name="3" id="anc3"></a>






 283   template &lt;DecoratorSet ds, typename T&gt;
 284   static inline typename EnableIf&lt;
 285     HasDecorator&lt;ds, MO_UNORDERED&gt;::value&gt;::type
 286   store_internal(void* addr, T value) {
 287     *reinterpret_cast&lt;T*&gt;(addr) = value;
 288   }
 289 
 290   template &lt;DecoratorSet ds, typename T&gt;
 291   static typename EnableIf&lt;
 292     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 293   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 294 
 295   template &lt;DecoratorSet ds, typename T&gt;
 296   static typename EnableIf&lt;
 297     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 298   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 299 
 300   template &lt;DecoratorSet ds, typename T&gt;
 301   static typename EnableIf&lt;
 302     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 303   atomic_xchg_internal(void* addr, T new_value);
 304 
 305   // The following *_locked mechanisms serve the purpose of handling atomic operations
 306   // that are larger than a machine can handle, and then possibly opt for using
 307   // a slower path using a mutex to perform the operation.
 308 
 309   template &lt;DecoratorSet ds, typename T&gt;
 310   static inline typename EnableIf&lt;
 311     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
 312   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {
 313     return atomic_cmpxchg_internal&lt;ds&gt;(addr, compare_value, new_value);
 314   }
 315 
 316   template &lt;DecoratorSet ds, typename T&gt;
 317   static typename EnableIf&lt;
 318     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
 319   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);
 320 
 321   template &lt;DecoratorSet ds, typename T&gt;
 322   static inline typename EnableIf&lt;
 323     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
 324   atomic_xchg_maybe_locked(void* addr, T new_value) {
 325     return atomic_xchg_internal&lt;ds&gt;(addr, new_value);
 326   }
 327 
 328   template &lt;DecoratorSet ds, typename T&gt;
 329   static typename EnableIf&lt;
 330     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
 331   atomic_xchg_maybe_locked(void* addr, T new_value);
 332 
 333 public:
 334   template &lt;typename T&gt;
 335   static inline void store(void* addr, T value) {
 336     store_internal&lt;decorators&gt;(addr, value);
 337   }
 338 
 339   template &lt;typename T&gt;
 340   static inline T load(void* addr) {
 341     return load_internal&lt;decorators, T&gt;(addr);
 342   }
 343 
 344   template &lt;typename T&gt;
 345   static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 346     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(addr, compare_value, new_value);
 347   }
 348 
 349   template &lt;typename T&gt;
 350   static inline T atomic_xchg(void* addr, T new_value) {
 351     return atomic_xchg_maybe_locked&lt;decorators&gt;(addr, new_value);
 352   }
 353 
 354   template &lt;typename T&gt;
 355   static void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 356                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 357                         size_t length);
 358 
 359   template &lt;typename T&gt;
 360   static void oop_store(void* addr, T value);
 361   template &lt;typename T&gt;
 362   static void oop_store_at(oop base, ptrdiff_t offset, T value);
 363 
 364   template &lt;typename T&gt;
 365   static T oop_load(void* addr);
 366   template &lt;typename T&gt;
 367   static T oop_load_at(oop base, ptrdiff_t offset);
 368 
 369   template &lt;typename T&gt;
 370   static T oop_atomic_cmpxchg(void* addr, T compare_value, T new_value);
 371   template &lt;typename T&gt;
 372   static T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value);
 373 
 374   template &lt;typename T&gt;
 375   static T oop_atomic_xchg(void* addr, T new_value);
 376   template &lt;typename T&gt;
 377   static T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value);
 378 
 379   template &lt;typename T&gt;
 380   static void store_at(oop base, ptrdiff_t offset, T value) {
 381     store(field_addr(base, offset), value);
 382   }
 383 
 384   template &lt;typename T&gt;
 385   static T load_at(oop base, ptrdiff_t offset) {
 386     return load&lt;T&gt;(field_addr(base, offset));
 387   }
 388 
 389   template &lt;typename T&gt;
 390   static T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 391     return atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);
 392   }
 393 
 394   template &lt;typename T&gt;
 395   static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 396     return atomic_xchg(field_addr(base, offset), new_value);
 397   }
 398 
 399   template &lt;typename T&gt;
 400   static void oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 401                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 402                             size_t length);
 403 
 404   static void clone(oop src, oop dst, size_t size);
 405 
 406   static void value_copy(void* src, void* dst, ValueKlass* md);
 407 
 408   static oop resolve(oop obj) { return obj; }
 409 };
 410 
 411 // Below is the implementation of the first 4 steps of the template pipeline:
 412 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 413 //           and sets default decorators to sensible values.
 414 // * Step 2: Reduce types. This step makes sure there is only a single T type and not
 415 //           multiple types. The P type of the address and T type of the value must
 416 //           match.
 417 // * Step 3: Pre-runtime dispatch. This step checks whether a runtime call can be
 418 //           avoided, and in that case avoids it (calling raw accesses or
 419 //           primitive accesses in a build that does not require primitive GC barriers)
 420 // * Step 4: Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 421 //           BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 422 //           to the access.
 423 
 424 namespace AccessInternal {
 425   template &lt;typename T&gt;
 426   struct OopOrNarrowOopInternal: AllStatic {
 427     typedef oop type;
 428   };
 429 
 430   template &lt;&gt;
 431   struct OopOrNarrowOopInternal&lt;narrowOop&gt;: AllStatic {
 432     typedef narrowOop type;
 433   };
 434 
 435   // This metafunction returns a canonicalized oop/narrowOop type for a passed
 436   // in oop-like types passed in from oop_* overloads where the user has sworn
 437   // that the passed in values should be oop-like (e.g. oop, oopDesc*, arrayOop,
 438   // narrowOoop, instanceOopDesc*, and random other things).
 439   // In the oop_* overloads, it must hold that if the passed in type T is not
 440   // narrowOop, then it by contract has to be one of many oop-like types implicitly
 441   // convertible to oop, and hence returns oop as the canonical oop type.
 442   // If it turns out it was not, then the implicit conversion to oop will fail
 443   // to compile, as desired.
 444   template &lt;typename T&gt;
 445   struct OopOrNarrowOop: AllStatic {
 446     typedef typename OopOrNarrowOopInternal&lt;typename Decay&lt;T&gt;::type&gt;::type type;
 447   };
 448 
 449   inline void* field_addr(oop base, ptrdiff_t byte_offset) {
 450     return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
 451   }
 452   // Step 4: Runtime dispatch
 453   // The RuntimeDispatch class is responsible for performing a runtime dispatch of the
 454   // accessor. This is required when the access either depends on whether compressed oops
 455   // is being used, or it depends on which GC implementation was chosen (e.g. requires GC
 456   // barriers). The way it works is that a function pointer initially pointing to an
 457   // accessor resolution function gets called for each access. Upon first invocation,
 458   // it resolves which accessor to be used in future invocations and patches the
 459   // function pointer to this new accessor.
 460 
 461   template &lt;DecoratorSet decorators, typename T, BarrierType type&gt;
 462   struct RuntimeDispatch: AllStatic {};
 463 
 464   template &lt;DecoratorSet decorators, typename T&gt;
 465   struct RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;: AllStatic {
 466     typedef typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type func_t;
 467     static func_t _store_func;
 468 
 469     static void store_init(void* addr, T value);
 470 
 471     static inline void store(void* addr, T value) {
 472       _store_func(addr, value);
 473     }
 474   };
 475 
 476   template &lt;DecoratorSet decorators, typename T&gt;
 477   struct RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;: AllStatic {
 478     typedef typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type func_t;
 479     static func_t _store_at_func;
 480 
 481     static void store_at_init(oop base, ptrdiff_t offset, T value);
 482 
 483     static inline void store_at(oop base, ptrdiff_t offset, T value) {
 484       _store_at_func(base, offset, value);
 485     }
 486   };
 487 
 488   template &lt;DecoratorSet decorators, typename T&gt;
 489   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;: AllStatic {
 490     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type func_t;
 491     static func_t _load_func;
 492 
 493     static T load_init(void* addr);
 494 
 495     static inline T load(void* addr) {
 496       return _load_func(addr);
 497     }
 498   };
 499 
 500   template &lt;DecoratorSet decorators, typename T&gt;
 501   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;: AllStatic {
 502     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type func_t;
 503     static func_t _load_at_func;
 504 
 505     static T load_at_init(oop base, ptrdiff_t offset);
 506 
 507     static inline T load_at(oop base, ptrdiff_t offset) {
 508       return _load_at_func(base, offset);
 509     }
 510   };
 511 
 512   template &lt;DecoratorSet decorators, typename T&gt;
 513   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;: AllStatic {
 514     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type func_t;
 515     static func_t _atomic_cmpxchg_func;
 516 
 517     static T atomic_cmpxchg_init(void* addr, T compare_value, T new_value);
 518 
 519     static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 520       return _atomic_cmpxchg_func(addr, compare_value, new_value);
 521     }
 522   };
 523 
 524   template &lt;DecoratorSet decorators, typename T&gt;
 525   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;: AllStatic {
 526     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type func_t;
 527     static func_t _atomic_cmpxchg_at_func;
 528 
 529     static T atomic_cmpxchg_at_init(oop base, ptrdiff_t offset, T compare_value, T new_value);
 530 
 531     static inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 532       return _atomic_cmpxchg_at_func(base, offset, compare_value, new_value);
 533     }
 534   };
 535 
 536   template &lt;DecoratorSet decorators, typename T&gt;
 537   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;: AllStatic {
 538     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type func_t;
 539     static func_t _atomic_xchg_func;
 540 
 541     static T atomic_xchg_init(void* addr, T new_value);
 542 
 543     static inline T atomic_xchg(void* addr, T new_value) {
 544       return _atomic_xchg_func(addr, new_value);
 545     }
 546   };
 547 
 548   template &lt;DecoratorSet decorators, typename T&gt;
 549   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
 550     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
 551     static func_t _atomic_xchg_at_func;
 552 
 553     static T atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value);
 554 
 555     static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 556       return _atomic_xchg_at_func(base, offset, new_value);
 557     }
 558   };
 559 
 560   template &lt;DecoratorSet decorators, typename T&gt;
 561   struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
 562     typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
 563     static func_t _arraycopy_func;
 564 
 565     static void arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 566                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 567                                size_t length);
 568 
 569     static inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 570                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 571                                  size_t length) {
 572       return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
 573                              dst_obj, dst_offset_in_bytes, dst_raw,
 574                              length);
 575     }
 576   };
 577 
 578   template &lt;DecoratorSet decorators, typename T&gt;
 579   struct RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;: AllStatic {
 580     typedef typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type func_t;
 581     static func_t _clone_func;
 582 
 583     static void clone_init(oop src, oop dst, size_t size);
 584 
 585     static inline void clone(oop src, oop dst, size_t size) {
 586       _clone_func(src, dst, size);
 587     }
 588   };
 589 
 590   template &lt;DecoratorSet decorators, typename T&gt;
 591   struct RuntimeDispatch&lt;decorators, T, BARRIER_VALUE_COPY&gt;: AllStatic {
 592     typedef typename AccessFunction&lt;decorators, T, BARRIER_VALUE_COPY&gt;::type func_t;
 593     static func_t _value_copy_func;
 594 
 595     static void value_copy_init(void* src, void* dst, ValueKlass* md);
 596 
 597     static inline void value_copy(void* src, void* dst, ValueKlass* md) {
 598       _value_copy_func(src, dst, md);
 599     }
 600   };
 601 
 602   template &lt;DecoratorSet decorators, typename T&gt;
 603   struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
 604     typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
 605     static func_t _resolve_func;
 606 
 607     static oop resolve_init(oop obj);
 608 
 609     static inline oop resolve(oop obj) {
 610       return _resolve_func(obj);
 611     }
 612   };
 613 
 614   // Initialize the function pointers to point to the resolving function.
 615   template &lt;DecoratorSet decorators, typename T&gt;
 616   typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
 617   RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
 618 
 619   template &lt;DecoratorSet decorators, typename T&gt;
 620   typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type
 621   RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::_store_at_func = &amp;store_at_init;
 622 
 623   template &lt;DecoratorSet decorators, typename T&gt;
 624   typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type
 625   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::_load_func = &amp;load_init;
 626 
 627   template &lt;DecoratorSet decorators, typename T&gt;
 628   typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type
 629   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::_load_at_func = &amp;load_at_init;
 630 
 631   template &lt;DecoratorSet decorators, typename T&gt;
 632   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type
 633   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::_atomic_cmpxchg_func = &amp;atomic_cmpxchg_init;
 634 
 635   template &lt;DecoratorSet decorators, typename T&gt;
 636   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type
 637   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::_atomic_cmpxchg_at_func = &amp;atomic_cmpxchg_at_init;
 638 
 639   template &lt;DecoratorSet decorators, typename T&gt;
 640   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type
 641   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::_atomic_xchg_func = &amp;atomic_xchg_init;
 642 
 643   template &lt;DecoratorSet decorators, typename T&gt;
 644   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type
 645   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::_atomic_xchg_at_func = &amp;atomic_xchg_at_init;
 646 
 647   template &lt;DecoratorSet decorators, typename T&gt;
 648   typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type
 649   RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::_arraycopy_func = &amp;arraycopy_init;
 650 
 651   template &lt;DecoratorSet decorators, typename T&gt;
 652   typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
 653   RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
 654 
 655   template &lt;DecoratorSet decorators, typename T&gt;
 656   typename AccessFunction&lt;decorators, T, BARRIER_VALUE_COPY&gt;::type
 657   RuntimeDispatch&lt;decorators, T, BARRIER_VALUE_COPY&gt;::_value_copy_func = &amp;value_copy_init;
 658 
 659   template &lt;DecoratorSet decorators, typename T&gt;
 660   typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
 661   RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
 662 
 663   // Step 3: Pre-runtime dispatching.
 664   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
 665   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
 666   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
 667   // not possible.
 668   struct PreRuntimeDispatch: AllStatic {
 669     template&lt;DecoratorSet decorators&gt;
 670     struct CanHardwireRaw: public IntegralConstant&lt;
 671       bool,
 672       !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // primitive access
 673       !HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value || // don&#39;t care about compressed oops (oop* address)
 674       HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value&gt; // we can infer we use compressed oops (narrowOop* address)
 675     {};
 676 
 677     static const DecoratorSet convert_compressed_oops = INTERNAL_RT_USE_COMPRESSED_OOPS | INTERNAL_CONVERT_COMPRESSED_OOP;
 678 
 679     template&lt;DecoratorSet decorators&gt;
 680     static bool is_hardwired_primitive() {
 681       return !HasDecorator&lt;decorators, INTERNAL_BT_BARRIER_ON_PRIMITIVES&gt;::value &amp;&amp;
 682              !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value;
 683     }
 684 
 685     template &lt;DecoratorSet decorators, typename T&gt;
 686     inline static typename EnableIf&lt;
 687       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value&gt;::type
 688     store(void* addr, T value) {
 689       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 690       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 691         Raw::oop_store(addr, value);
 692       } else {
 693         Raw::store(addr, value);
 694       }
 695     }
 696 
 697     template &lt;DecoratorSet decorators, typename T&gt;
 698     inline static typename EnableIf&lt;
 699       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value&gt;::type
 700     store(void* addr, T value) {
 701       if (UseCompressedOops) {
 702         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 703         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 704       } else {
 705         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 706         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 707       }
 708     }
 709 
 710     template &lt;DecoratorSet decorators, typename T&gt;
 711     inline static typename EnableIf&lt;
 712       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 713     store(void* addr, T value) {
 714       if (is_hardwired_primitive&lt;decorators&gt;()) {
 715         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 716         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 717       } else {
 718         RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::store(addr, value);
 719       }
 720     }
 721 
 722     template &lt;DecoratorSet decorators, typename T&gt;
 723     inline static typename EnableIf&lt;
 724       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 725     store_at(oop base, ptrdiff_t offset, T value) {
 726       store&lt;decorators&gt;(field_addr(base, offset), value);
 727     }
 728 
 729     template &lt;DecoratorSet decorators, typename T&gt;
 730     inline static typename EnableIf&lt;
 731       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 732     store_at(oop base, ptrdiff_t offset, T value) {
 733       if (is_hardwired_primitive&lt;decorators&gt;()) {
 734         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 735         PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, value);
 736       } else {
 737         RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::store_at(base, offset, value);
 738       }
 739     }
 740 
 741     template &lt;DecoratorSet decorators, typename T&gt;
 742     inline static typename EnableIf&lt;
 743       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 744     load(void* addr) {
 745       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 746       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 747         return Raw::template oop_load&lt;T&gt;(addr);
 748       } else {
 749         return Raw::template load&lt;T&gt;(addr);
 750       }
 751     }
 752 
 753     template &lt;DecoratorSet decorators, typename T&gt;
 754     inline static typename EnableIf&lt;
 755       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 756     load(void* addr) {
 757       if (UseCompressedOops) {
 758         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 759         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 760       } else {
 761         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 762         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 763       }
 764     }
 765 
 766     template &lt;DecoratorSet decorators, typename T&gt;
 767     inline static typename EnableIf&lt;
 768       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 769     load(void* addr) {
 770       if (is_hardwired_primitive&lt;decorators&gt;()) {
 771         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 772         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 773       } else {
 774         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::load(addr);
 775       }
 776     }
 777 
 778     template &lt;DecoratorSet decorators, typename T&gt;
 779     inline static typename EnableIf&lt;
 780       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 781     load_at(oop base, ptrdiff_t offset) {
 782       return load&lt;decorators, T&gt;(field_addr(base, offset));
 783     }
 784 
 785     template &lt;DecoratorSet decorators, typename T&gt;
 786     inline static typename EnableIf&lt;
 787       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 788     load_at(oop base, ptrdiff_t offset) {
 789       if (is_hardwired_primitive&lt;decorators&gt;()) {
 790         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 791         return PreRuntimeDispatch::load_at&lt;expanded_decorators, T&gt;(base, offset);
 792       } else {
 793         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at(base, offset);
 794       }
 795     }
 796 
 797     template &lt;DecoratorSet decorators, typename T&gt;
 798     inline static typename EnableIf&lt;
 799       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 800     atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 801       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 802       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 803         return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);
 804       } else {
 805         return Raw::atomic_cmpxchg(addr, compare_value, new_value);
 806       }
 807     }
 808 
 809     template &lt;DecoratorSet decorators, typename T&gt;
 810     inline static typename EnableIf&lt;
 811       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 812     atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 813       if (UseCompressedOops) {
 814         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 815         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
 816       } else {
 817         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 818         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
 819       }
 820     }
 821 
 822     template &lt;DecoratorSet decorators, typename T&gt;
 823     inline static typename EnableIf&lt;
 824       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 825     atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 826       if (is_hardwired_primitive&lt;decorators&gt;()) {
 827         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 828         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
 829       } else {
 830         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg(addr, compare_value, new_value);
 831       }
 832     }
 833 
 834     template &lt;DecoratorSet decorators, typename T&gt;
 835     inline static typename EnableIf&lt;
 836       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 837     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 838       return atomic_cmpxchg&lt;decorators&gt;(field_addr(base, offset), compare_value, new_value);
 839     }
 840 
 841     template &lt;DecoratorSet decorators, typename T&gt;
 842     inline static typename EnableIf&lt;
 843       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 844     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 845       if (is_hardwired_primitive&lt;decorators&gt;()) {
 846         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 847         return PreRuntimeDispatch::atomic_cmpxchg_at&lt;expanded_decorators&gt;(base, offset, compare_value, new_value);
 848       } else {
 849         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at(base, offset, compare_value, new_value);
 850       }
 851     }
 852 
 853     template &lt;DecoratorSet decorators, typename T&gt;
 854     inline static typename EnableIf&lt;
 855       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 856     atomic_xchg(void* addr, T new_value) {
 857       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 858       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 859         return Raw::oop_atomic_xchg(addr, new_value);
 860       } else {
 861         return Raw::atomic_xchg(addr, new_value);
 862       }
 863     }
 864 
 865     template &lt;DecoratorSet decorators, typename T&gt;
 866     inline static typename EnableIf&lt;
 867       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 868     atomic_xchg(void* addr, T new_value) {
 869       if (UseCompressedOops) {
 870         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 871         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
 872       } else {
 873         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 874         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
 875       }
 876     }
 877 
 878     template &lt;DecoratorSet decorators, typename T&gt;
 879     inline static typename EnableIf&lt;
 880       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 881     atomic_xchg(void* addr, T new_value) {
 882       if (is_hardwired_primitive&lt;decorators&gt;()) {
 883         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 884         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
 885       } else {
 886         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg(addr, new_value);
 887       }
 888     }
 889 
 890     template &lt;DecoratorSet decorators, typename T&gt;
 891     inline static typename EnableIf&lt;
 892       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 893     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 894       return atomic_xchg&lt;decorators&gt;(field_addr(base, offset), new_value);
 895     }
 896 
 897     template &lt;DecoratorSet decorators, typename T&gt;
 898     inline static typename EnableIf&lt;
 899       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 900     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 901       if (is_hardwired_primitive&lt;decorators&gt;()) {
 902         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 903         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(base, offset, new_value);
 904       } else {
 905         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(base, offset, new_value);
 906       }
 907     }
 908 
 909     template &lt;DecoratorSet decorators, typename T&gt;
 910     inline static typename EnableIf&lt;
 911       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, void&gt;::type
 912     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 913               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 914               size_t length) {
 915       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 916       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 917         Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,
 918                            dst_obj, dst_offset_in_bytes, dst_raw,
 919                            length);
 920       } else {
 921         Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,
 922                        dst_obj, dst_offset_in_bytes, dst_raw,
 923                        length);
 924       }
 925     }
 926 
 927     template &lt;DecoratorSet decorators, typename T&gt;
 928     inline static typename EnableIf&lt;
 929       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, void&gt;::type
 930     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 931               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 932               size_t length) {
 933       if (UseCompressedOops) {
 934         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 935         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 936                                                            dst_obj, dst_offset_in_bytes, dst_raw,
 937                                                            length);
 938       } else {
 939         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 940         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 941                                                            dst_obj, dst_offset_in_bytes, dst_raw,
 942                                                            length);
 943       }
 944     }
 945 
 946     template &lt;DecoratorSet decorators, typename T&gt;
 947     inline static typename EnableIf&lt;
 948       !HasDecorator&lt;decorators, AS_RAW&gt;::value, void&gt;::type
 949     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 950               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 951               size_t length) {
 952       if (is_hardwired_primitive&lt;decorators&gt;()) {
 953         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 954         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
 955                                                            dst_obj, dst_offset_in_bytes, dst_raw,
 956                                                            length);
 957       } else {
 958         RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy(src_obj, src_offset_in_bytes, src_raw,
 959                                                                      dst_obj, dst_offset_in_bytes, dst_raw,
 960                                                                      length);
 961       }
 962     }
 963 
 964     template &lt;DecoratorSet decorators&gt;
 965     inline static typename EnableIf&lt;
 966       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 967     clone(oop src, oop dst, size_t size) {
 968       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 969       Raw::clone(src, dst, size);
 970     }
 971 
 972     template &lt;DecoratorSet decorators&gt;
 973     inline static typename EnableIf&lt;
 974       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 975     clone(oop src, oop dst, size_t size) {
 976       RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
 977     }
 978 
 979     template &lt;DecoratorSet decorators&gt;
 980     inline static typename EnableIf&lt;
 981       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 982     value_copy(void* src, void* dst, ValueKlass* md) {
 983       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 984       Raw::value_copy(src, dst, md);
 985     }
 986 
 987     template &lt;DecoratorSet decorators&gt;
 988     inline static typename EnableIf&lt;
 989       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 990       value_copy(void* src, void* dst, ValueKlass* md) {
 991       const DecoratorSet expanded_decorators = decorators;
 992       RuntimeDispatch&lt;expanded_decorators, void*, BARRIER_VALUE_COPY&gt;::value_copy(src, dst, md);
 993     }
 994 
 995 
 996     template &lt;DecoratorSet decorators&gt;
 997     inline static typename EnableIf&lt;
 998       HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 999     resolve(oop obj) {
1000       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
1001       return Raw::resolve(obj);
1002     }
1003 
1004     template &lt;DecoratorSet decorators&gt;
1005     inline static typename EnableIf&lt;
1006       !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
1007     resolve(oop obj) {
1008       return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
1009     }
1010   };
1011 
1012   // Step 2: Reduce types.
1013   // Enforce that for non-oop types, T and P have to be strictly the same.
1014   // P is the type of the address and T is the type of the values.
1015   // As for oop types, it is allow to send T in {narrowOop, oop} and
1016   // P in {narrowOop, oop, HeapWord*}. The following rules apply according to
1017   // the subsequent table. (columns are P, rows are T)
1018   // |           | HeapWord  |   oop   | narrowOop |
1019   // |   oop     |  rt-comp  | hw-none |  hw-comp  |
1020   // | narrowOop |     x     |    x    |  hw-none  |
1021   //
1022   // x means not allowed
1023   // rt-comp means it must be checked at runtime whether the oop is compressed.
1024   // hw-none means it is statically known the oop will not be compressed.
1025   // hw-comp means it is statically known the oop will be compressed.
1026 
1027   template &lt;DecoratorSet decorators, typename T&gt;
1028   inline void store_reduce_types(T* addr, T value) {
1029     PreRuntimeDispatch::store&lt;decorators&gt;(addr, value);
1030   }
1031 
1032   template &lt;DecoratorSet decorators&gt;
1033   inline void store_reduce_types(narrowOop* addr, oop value) {
1034     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1035                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1036     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1037   }
1038 
1039   template &lt;DecoratorSet decorators&gt;
1040   inline void store_reduce_types(narrowOop* addr, narrowOop value) {
1041     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1042                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1043     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1044   }
1045 
1046   template &lt;DecoratorSet decorators&gt;
1047   inline void store_reduce_types(HeapWord* addr, oop value) {
1048     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1049     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1050   }
1051 
1052   template &lt;DecoratorSet decorators, typename T&gt;
1053   inline T atomic_cmpxchg_reduce_types(T* addr, T compare_value, T new_value) {
1054     return PreRuntimeDispatch::atomic_cmpxchg&lt;decorators&gt;(addr, compare_value, new_value);
1055   }
1056 
1057   template &lt;DecoratorSet decorators&gt;
1058   inline oop atomic_cmpxchg_reduce_types(narrowOop* addr, oop compare_value, oop new_value) {
1059     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1060                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1061     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
1062   }
1063 
1064   template &lt;DecoratorSet decorators&gt;
1065   inline narrowOop atomic_cmpxchg_reduce_types(narrowOop* addr, narrowOop compare_value, narrowOop new_value) {
1066     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1067                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1068     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
1069   }
1070 
1071   template &lt;DecoratorSet decorators&gt;
1072   inline oop atomic_cmpxchg_reduce_types(HeapWord* addr,
1073                                          oop compare_value,
1074                                          oop new_value) {
1075     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1076     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
1077   }
1078 
1079   template &lt;DecoratorSet decorators, typename T&gt;
1080   inline T atomic_xchg_reduce_types(T* addr, T new_value) {
1081     const DecoratorSet expanded_decorators = decorators;
1082     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
1083   }
1084 
1085   template &lt;DecoratorSet decorators&gt;
1086   inline oop atomic_xchg_reduce_types(narrowOop* addr, oop new_value) {
1087     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1088                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1089     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
1090   }
1091 
1092   template &lt;DecoratorSet decorators&gt;
1093   inline narrowOop atomic_xchg_reduce_types(narrowOop* addr, narrowOop new_value) {
1094     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1095                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1096     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
1097   }
1098 
1099   template &lt;DecoratorSet decorators&gt;
1100   inline oop atomic_xchg_reduce_types(HeapWord* addr, oop new_value) {
1101     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1102     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
1103   }
1104 
1105   template &lt;DecoratorSet decorators, typename T&gt;
1106   inline T load_reduce_types(T* addr) {
1107     return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
1108   }
1109 
1110   template &lt;DecoratorSet decorators, typename T&gt;
1111   inline typename OopOrNarrowOop&lt;T&gt;::type load_reduce_types(narrowOop* addr) {
1112     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1113                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1114     return PreRuntimeDispatch::load&lt;expanded_decorators, typename OopOrNarrowOop&lt;T&gt;::type&gt;(addr);
1115   }
1116 
1117   template &lt;DecoratorSet decorators, typename T&gt;
1118   inline oop load_reduce_types(HeapWord* addr) {
1119     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1120     return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
1121   }
1122 
1123   template &lt;DecoratorSet decorators, typename T&gt;
1124   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
1125                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1126                                      size_t length) {
1127     PreRuntimeDispatch::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1128                                               dst_obj, dst_offset_in_bytes, dst_raw,
1129                                               length);
1130   }
1131 
1132   template &lt;DecoratorSet decorators&gt;
1133   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,
1134                                      arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
1135                                      size_t length) {
1136     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1137     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1138                                                        dst_obj, dst_offset_in_bytes, dst_raw,
1139                                                        length);
1140   }
1141 
1142   template &lt;DecoratorSet decorators&gt;
1143   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,
1144                                      arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
1145                                      size_t length) {
1146     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1147                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1148     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1149                                                        dst_obj, dst_offset_in_bytes, dst_raw,
1150                                                        length);
1151   }
1152 
1153   // Step 1: Set default decorators. This step remembers if a type was volatile
<a name="4" id="anc4"></a><span class="line-modified">1154   // and then sets the MO_RELAXED decorator by default. Otherwise, a default</span>
1155   // memory ordering is set for the access, and the implied decorator rules
1156   // are applied to select sensible defaults for decorators that have not been
1157   // explicitly set. For example, default object referent strength is set to strong.
1158   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
1159   // and references from the types). This step also perform some type verification
1160   // that the passed in types make sense.
1161 
1162   template &lt;DecoratorSet decorators, typename T&gt;
1163   static void verify_types(){
1164     // If this fails to compile, then you have sent in something that is
1165     // not recognized as a valid primitive type to a primitive Access function.
1166     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // oops have already been validated
1167                    (IsPointer&lt;T&gt;::value || IsIntegral&lt;T&gt;::value) ||
1168                     IsFloatingPoint&lt;T&gt;::value)); // not allowed primitive type
1169   }
1170 
1171   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1172   inline void store(P* addr, T value) {
1173     verify_types&lt;decorators, T&gt;();
1174     typedef typename Decay&lt;P&gt;::type DecayedP;
1175     typedef typename Decay&lt;T&gt;::type DecayedT;
1176     DecayedT decayed_value = value;
1177     // If a volatile address is passed in but no memory ordering decorator,
<a name="5" id="anc5"></a><span class="line-modified">1178     // set the memory ordering to MO_RELAXED by default.</span>
1179     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1180       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
<a name="6" id="anc6"></a><span class="line-modified">1181       (MO_RELAXED | decorators) : decorators&gt;::value;</span>
1182     store_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr), decayed_value);
1183   }
1184 
1185   template &lt;DecoratorSet decorators, typename T&gt;
1186   inline void store_at(oop base, ptrdiff_t offset, T value) {
1187     verify_types&lt;decorators, T&gt;();
1188     typedef typename Decay&lt;T&gt;::type DecayedT;
1189     DecayedT decayed_value = value;
1190     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1191                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1192                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1193     PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, decayed_value);
1194   }
1195 
1196   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1197   inline T load(P* addr) {
1198     verify_types&lt;decorators, T&gt;();
1199     typedef typename Decay&lt;P&gt;::type DecayedP;
1200     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1201                                  typename OopOrNarrowOop&lt;T&gt;::type,
1202                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1203     // If a volatile address is passed in but no memory ordering decorator,
<a name="7" id="anc7"></a><span class="line-modified">1204     // set the memory ordering to MO_RELAXED by default.</span>
1205     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1206       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
<a name="8" id="anc8"></a><span class="line-modified">1207       (MO_RELAXED | decorators) : decorators&gt;::value;</span>
1208     return load_reduce_types&lt;expanded_decorators, DecayedT&gt;(const_cast&lt;DecayedP*&gt;(addr));
1209   }
1210 
1211   template &lt;DecoratorSet decorators, typename T&gt;
1212   inline T load_at(oop base, ptrdiff_t offset) {
1213     verify_types&lt;decorators, T&gt;();
1214     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1215                                  typename OopOrNarrowOop&lt;T&gt;::type,
1216                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1217     // Expand the decorators (figure out sensible defaults)
1218     // Potentially remember if we need compressed oop awareness
1219     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1220                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1221                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1222     return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
1223   }
1224 
1225   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1226   inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {
1227     verify_types&lt;decorators, T&gt;();
1228     typedef typename Decay&lt;P&gt;::type DecayedP;
1229     typedef typename Decay&lt;T&gt;::type DecayedT;
1230     DecayedT new_decayed_value = new_value;
1231     DecayedT compare_decayed_value = compare_value;
1232     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1233       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1234       (MO_SEQ_CST | decorators) : decorators&gt;::value;
1235     return atomic_cmpxchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),
1236                                                             compare_decayed_value,
1237                                                             new_decayed_value);
1238   }
1239 
1240   template &lt;DecoratorSet decorators, typename T&gt;
1241   inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
1242     verify_types&lt;decorators, T&gt;();
1243     typedef typename Decay&lt;T&gt;::type DecayedT;
1244     DecayedT new_decayed_value = new_value;
1245     DecayedT compare_decayed_value = compare_value;
1246     // Determine default memory ordering
1247     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1248       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1249       (MO_SEQ_CST | decorators) : decorators&gt;::value;
1250     // Potentially remember that we need compressed oop awareness
1251     const DecoratorSet final_decorators = expanded_decorators |
1252                                           (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1253                                            INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
1254     return PreRuntimeDispatch::atomic_cmpxchg_at&lt;final_decorators&gt;(base, offset, compare_decayed_value,
1255                                                                    new_decayed_value);
1256   }
1257 
1258   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1259   inline T atomic_xchg(P* addr, T new_value) {
1260     verify_types&lt;decorators, T&gt;();
1261     typedef typename Decay&lt;P&gt;::type DecayedP;
1262     typedef typename Decay&lt;T&gt;::type DecayedT;
1263     DecayedT new_decayed_value = new_value;
1264     // atomic_xchg is only available in SEQ_CST flavour.
1265     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
1266     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),
1267                                                          new_decayed_value);
1268   }
1269 
1270   template &lt;DecoratorSet decorators, typename T&gt;
1271   inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
1272     verify_types&lt;decorators, T&gt;();
1273     typedef typename Decay&lt;T&gt;::type DecayedT;
1274     DecayedT new_decayed_value = new_value;
1275     // atomic_xchg is only available in SEQ_CST flavour.
1276     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
1277                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1278                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1279     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(base, offset, new_decayed_value);
1280   }
1281 
1282   template &lt;DecoratorSet decorators, typename T&gt;
1283   inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
1284                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1285                         size_t length) {
1286     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
1287                    (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
1288                     IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
1289     typedef typename Decay&lt;T&gt;::type DecayedT;
1290     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
1291     arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),
1292                                                 dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),
1293                                                 length);
1294   }
1295 
1296   template &lt;DecoratorSet decorators&gt;
1297   inline void clone(oop src, oop dst, size_t size) {
1298     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1299     PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
1300   }
1301 
1302   template &lt;DecoratorSet decorators&gt;
1303   inline void value_copy(void* src, void* dst, ValueKlass* md) {
1304     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1305     PreRuntimeDispatch::value_copy&lt;expanded_decorators&gt;(src, dst, md);
1306   }
1307 
1308   template &lt;DecoratorSet decorators&gt;
1309   inline oop resolve(oop obj) {
1310     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1311     return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
1312   }
1313 
1314   // Infer the type that should be returned from an Access::oop_load.
1315   template &lt;typename P, DecoratorSet decorators&gt;
1316   class OopLoadProxy: public StackObj {
1317   private:
1318     P *const _addr;
1319   public:
1320     OopLoadProxy(P* addr) : _addr(addr) {}
1321 
1322     inline operator oop() {
1323       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, oop&gt;(_addr);
1324     }
1325 
1326     inline operator narrowOop() {
1327       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, narrowOop&gt;(_addr);
1328     }
1329 
1330     template &lt;typename T&gt;
1331     inline bool operator ==(const T&amp; other) const {
1332       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) == other;
1333     }
1334 
1335     template &lt;typename T&gt;
1336     inline bool operator !=(const T&amp; other) const {
1337       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) != other;
1338     }
1339   };
1340 
1341   // Infer the type that should be returned from an Access::load_at.
1342   template &lt;DecoratorSet decorators&gt;
1343   class LoadAtProxy: public StackObj {
1344   private:
1345     const oop _base;
1346     const ptrdiff_t _offset;
1347   public:
1348     LoadAtProxy(oop base, ptrdiff_t offset) : _base(base), _offset(offset) {}
1349 
1350     template &lt;typename T&gt;
1351     inline operator T() const {
1352       return load_at&lt;decorators, T&gt;(_base, _offset);
1353     }
1354 
1355     template &lt;typename T&gt;
1356     inline bool operator ==(const T&amp; other) const { return load_at&lt;decorators, T&gt;(_base, _offset) == other; }
1357 
1358     template &lt;typename T&gt;
1359     inline bool operator !=(const T&amp; other) const { return load_at&lt;decorators, T&gt;(_base, _offset) != other; }
1360   };
1361 
1362   // Infer the type that should be returned from an Access::oop_load_at.
1363   template &lt;DecoratorSet decorators&gt;
1364   class OopLoadAtProxy: public StackObj {
1365   private:
1366     const oop _base;
1367     const ptrdiff_t _offset;
1368   public:
1369     OopLoadAtProxy(oop base, ptrdiff_t offset) : _base(base), _offset(offset) {}
1370 
1371     inline operator oop() const {
1372       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, oop&gt;(_base, _offset);
1373     }
1374 
1375     inline operator narrowOop() const {
1376       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, narrowOop&gt;(_base, _offset);
1377     }
1378 
1379     template &lt;typename T&gt;
1380     inline bool operator ==(const T&amp; other) const {
1381       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, T&gt;(_base, _offset) == other;
1382     }
1383 
1384     template &lt;typename T&gt;
1385     inline bool operator !=(const T&amp; other) const {
1386       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, T&gt;(_base, _offset) != other;
1387     }
1388   };
1389 }
1390 
1391 #endif // SHARE_OOPS_ACCESSBACKEND_HPP
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
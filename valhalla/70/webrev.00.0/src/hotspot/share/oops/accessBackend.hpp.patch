diff a/src/hotspot/share/oops/accessBackend.hpp b/src/hotspot/share/oops/accessBackend.hpp
--- a/src/hotspot/share/oops/accessBackend.hpp
+++ b/src/hotspot/share/oops/accessBackend.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -256,17 +256,10 @@
   template <DecoratorSet ds, typename T>
   static typename EnableIf<
     HasDecorator<ds, MO_RELAXED>::value, T>::type
   load_internal(void* addr);
 
-  template <DecoratorSet ds, typename T>
-  static inline typename EnableIf<
-    HasDecorator<ds, MO_VOLATILE>::value, T>::type
-  load_internal(void* addr) {
-    return *reinterpret_cast<const volatile T*>(addr);
-  }
-
   template <DecoratorSet ds, typename T>
   static inline typename EnableIf<
     HasDecorator<ds, MO_UNORDERED>::value, T>::type
   load_internal(void* addr) {
     return *reinterpret_cast<T*>(addr);
@@ -285,17 +278,10 @@
   template <DecoratorSet ds, typename T>
   static typename EnableIf<
     HasDecorator<ds, MO_RELAXED>::value>::type
   store_internal(void* addr, T value);
 
-  template <DecoratorSet ds, typename T>
-  static inline typename EnableIf<
-    HasDecorator<ds, MO_VOLATILE>::value>::type
-  store_internal(void* addr, T value) {
-    (void)const_cast<T&>(*reinterpret_cast<volatile T*>(addr) = value);
-  }
-
   template <DecoratorSet ds, typename T>
   static inline typename EnableIf<
     HasDecorator<ds, MO_UNORDERED>::value>::type
   store_internal(void* addr, T value) {
     *reinterpret_cast<T*>(addr) = value;
@@ -1163,11 +1149,11 @@
                                                        dst_obj, dst_offset_in_bytes, dst_raw,
                                                        length);
   }
 
   // Step 1: Set default decorators. This step remembers if a type was volatile
-  // and then sets the MO_VOLATILE decorator by default. Otherwise, a default
+  // and then sets the MO_RELAXED decorator by default. Otherwise, a default
   // memory ordering is set for the access, and the implied decorator rules
   // are applied to select sensible defaults for decorators that have not been
   // explicitly set. For example, default object referent strength is set to strong.
   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
   // and references from the types). This step also perform some type verification
@@ -1187,14 +1173,14 @@
     verify_types<decorators, T>();
     typedef typename Decay<P>::type DecayedP;
     typedef typename Decay<T>::type DecayedT;
     DecayedT decayed_value = value;
     // If a volatile address is passed in but no memory ordering decorator,
-    // set the memory ordering to MO_VOLATILE by default.
+    // set the memory ordering to MO_RELAXED by default.
     const DecoratorSet expanded_decorators = DecoratorFixup<
       (IsVolatile<P>::value && !HasDecorator<decorators, MO_DECORATOR_MASK>::value) ?
-      (MO_VOLATILE | decorators) : decorators>::value;
+      (MO_RELAXED | decorators) : decorators>::value;
     store_reduce_types<expanded_decorators>(const_cast<DecayedP*>(addr), decayed_value);
   }
 
   template <DecoratorSet decorators, typename T>
   inline void store_at(oop base, ptrdiff_t offset, T value) {
@@ -1213,14 +1199,14 @@
     typedef typename Decay<P>::type DecayedP;
     typedef typename Conditional<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,
                                  typename OopOrNarrowOop<T>::type,
                                  typename Decay<T>::type>::type DecayedT;
     // If a volatile address is passed in but no memory ordering decorator,
-    // set the memory ordering to MO_VOLATILE by default.
+    // set the memory ordering to MO_RELAXED by default.
     const DecoratorSet expanded_decorators = DecoratorFixup<
       (IsVolatile<P>::value && !HasDecorator<decorators, MO_DECORATOR_MASK>::value) ?
-      (MO_VOLATILE | decorators) : decorators>::value;
+      (MO_RELAXED | decorators) : decorators>::value;
     return load_reduce_types<expanded_decorators, DecayedT>(const_cast<DecayedP*>(addr));
   }
 
   template <DecoratorSet decorators, typename T>
   inline T load_at(oop base, ptrdiff_t offset) {

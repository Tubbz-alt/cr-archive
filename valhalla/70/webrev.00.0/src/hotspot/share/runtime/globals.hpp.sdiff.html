<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/globals.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="init.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/globals.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 161           &quot;Enable normal processing of flags relating to field diagnostics&quot;)\
 162                                                                             \
 163   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 164           &quot;Enable normal processing of flags relating to experimental &quot;     \
 165           &quot;features&quot;)                                                       \
 166                                                                             \
 167   product(bool, JavaMonitorsInStackTrace, true,                             \
 168           &quot;Print information about Java monitor locks when the stacks are&quot;  \
 169           &quot;dumped&quot;)                                                         \
 170                                                                             \
 171   product_pd(bool, UseLargePages,                                           \
 172           &quot;Use large page memory&quot;)                                          \
 173                                                                             \
 174   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 175           &quot;Allocate large pages individually for better affinity&quot;)          \
 176                                                                             \
 177   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 178           &quot;Fail large pages individual allocation&quot;)                         \
 179                                                                             \
 180   product(bool, UseLargePagesInMetaspace, false,                            \
<span class="line-modified"> 181           &quot;Use large page memory in metaspace. &quot;                            \</span>
 182           &quot;Only used if UseLargePages is enabled.&quot;)                         \
 183                                                                             \
 184   product(bool, UseNUMA, false,                                             \
 185           &quot;Use NUMA if available&quot;)                                          \
 186                                                                             \
 187   product(bool, UseNUMAInterleaving, false,                                 \
 188           &quot;Interleave memory across NUMA nodes if available&quot;)               \
 189                                                                             \
 190   product(size_t, NUMAInterleaveGranularity, 2*M,                           \
 191           &quot;Granularity to use for NUMA interleaving on Windows OS&quot;)         \
 192           range(os::vm_allocation_granularity(), NOT_LP64(2*G) LP64_ONLY(8192*G)) \
 193                                                                             \
 194   product(bool, ForceNUMA, false,                                           \
 195           &quot;(Deprecated) Force NUMA optimizations on single-node/UMA systems&quot;) \
 196                                                                             \
 197   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 198           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
 199           &quot;computing exponentially decaying average for &quot;                   \
 200           &quot;AdaptiveNUMAChunkSizing&quot;)                                        \
 201           range(0, 100)                                                     \
</pre>
<hr />
<pre>
 778           &quot;Max nof embedded object references in an inline type to flatten, &lt;0 no limit&quot;)  \
 779                                                                             \
 780   product(bool, InlineArrayAtomicAccess, false,                             \
 781           &quot;Atomic inline array accesses by-default, for all inline arrays&quot;) \
 782                                                                             \
 783   /* Need to limit the extent of the padding to reasonable size.          */\
 784   /* 8K is well beyond the reasonable HW cache line size, even with       */\
 785   /* aggressive prefetching, while still leaving the room for segregating */\
 786   /* among the distinct pages.                                            */\
 787   product(intx, ContendedPaddingWidth, 128,                                 \
 788           &quot;How many bytes to pad the fields/classes marked @Contended with&quot;)\
 789           range(0, 8192)                                                    \
 790           constraint(ContendedPaddingWidthConstraintFunc,AfterErgo)         \
 791                                                                             \
 792   product(bool, EnableContended, true,                                      \
 793           &quot;Enable @Contended annotation support&quot;)                           \
 794                                                                             \
 795   product(bool, RestrictContended, true,                                    \
 796           &quot;Restrict @Contended to trusted classes&quot;)                         \
 797                                                                             \
<span class="line-modified"> 798   product(bool, UseBiasedLocking, true,                                     \</span>
<span class="line-modified"> 799           &quot;Enable biased locking in JVM&quot;)                                   \</span>
 800                                                                             \
 801   product(intx, BiasedLockingStartupDelay, 0,                               \
<span class="line-modified"> 802           &quot;Number of milliseconds to wait before enabling biased locking&quot;)  \</span>

 803           range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \
 804           constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \
 805                                                                             \
 806   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
<span class="line-modified"> 807           &quot;Print statistics of biased locking in JVM&quot;)                      \</span>
 808                                                                             \
 809   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
<span class="line-modified"> 810           &quot;Threshold of number of revocations per type to try to &quot;          \</span>
<span class="line-modified"> 811           &quot;rebias all objects in the heap of that type&quot;)                    \</span>
 812           range(0, max_intx)                                                \
 813           constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \
 814                                                                             \
 815   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
<span class="line-modified"> 816           &quot;Threshold of number of revocations per type to permanently &quot;     \</span>
<span class="line-modified"> 817           &quot;revoke biases of all objects in the heap of that type&quot;)          \</span>

 818           range(0, max_intx)                                                \
 819           constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \
 820                                                                             \
 821   product(intx, BiasedLockingDecayTime, 25000,                              \
<span class="line-modified"> 822           &quot;Decay time (in milliseconds) to re-enable bulk rebiasing of a &quot;  \</span>
<span class="line-modified"> 823           &quot;type after previous bulk rebias&quot;)                                \</span>
 824           range(500, max_intx)                                              \
 825           constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \
 826                                                                             \
 827   product(bool, ExitOnOutOfMemoryError, false,                              \
 828           &quot;JVM exits on the first occurrence of an out-of-memory error&quot;)    \
 829                                                                             \
 830   product(bool, CrashOnOutOfMemoryError, false,                             \
 831           &quot;JVM aborts, producing an error log and core/mini dump, on the &quot;  \
 832           &quot;first occurrence of an out-of-memory error&quot;)                     \
 833                                                                             \
 834   /* tracing */                                                             \
 835                                                                             \
 836   develop(bool, StressRewriter, false,                                      \
 837           &quot;Stress linktime bytecode rewriting&quot;)                             \
 838                                                                             \
 839   product(ccstr, TraceJVMTI, NULL,                                          \
 840           &quot;Trace flags for JVMTI functions and events&quot;)                     \
 841                                                                             \
 842   /* This option can change an EMCP method into an obsolete method. */      \
 843   /* This can affect tests that except specific methods to be EMCP. */      \
</pre>
<hr />
<pre>
 894                                                                             \
 895   develop(bool, FLSVerifyDictionary, false,                                 \
 896           &quot;Do lots of (expensive) FLS dictionary verification&quot;)             \
 897                                                                             \
 898                                                                             \
 899   notproduct(bool, CheckMemoryInitialization, false,                        \
 900           &quot;Check memory initialization&quot;)                                    \
 901                                                                             \
 902   product(uintx, ProcessDistributionStride, 4,                              \
 903           &quot;Stride through processors when distributing processes&quot;)          \
 904           range(0, max_juint)                                               \
 905                                                                             \
 906   develop(bool, TraceFinalizerRegistration, false,                          \
 907           &quot;Trace registration of final references&quot;)                         \
 908                                                                             \
 909   product(bool, IgnoreEmptyClassPaths, false,                               \
 910           &quot;Ignore empty path elements in -classpath&quot;)                       \
 911                                                                             \
 912   product(size_t, InitialBootClassLoaderMetaspaceSize,                      \
 913           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
<span class="line-modified"> 914           &quot;Initial size of the boot class loader data metaspace&quot;)           \</span>
 915           range(30*K, max_uintx/BytesPerWord)                               \
 916           constraint(InitialBootClassLoaderMetaspaceSizeConstraintFunc, AfterErgo)\
 917                                                                             \
 918   product(bool, PrintHeapAtSIGBREAK, true,                                  \
 919           &quot;Print heap layout in response to SIGBREAK&quot;)                      \
 920                                                                             \
 921   manageable(bool, PrintClassHistogram, false,                              \
 922           &quot;Print a histogram of class instances&quot;)                           \
 923                                                                             \
 924   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
 925           &quot;The percentage of the used heap that the instances of a class &quot;  \
 926           &quot;must occupy for the class to generate a trace event&quot;)            \
 927           range(0.0, 100.0)                                                 \
 928                                                                             \
 929   /* JVMTI heap profiling */                                                \
 930                                                                             \
 931   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
 932           &quot;Trace JVMTI object tagging calls&quot;)                               \
 933                                                                             \
 934   diagnostic(bool, VerifyBeforeIteration, false,                            \
</pre>
<hr />
<pre>
1454           &quot;Number of records in the ring buffer of sweeper activity&quot;)       \
1455                                                                             \
1456   notproduct(intx, MemProfilingInterval, 500,                               \
1457           &quot;Time between each invocation of the MemProfiler&quot;)                \
1458                                                                             \
1459   develop(intx, MallocCatchPtr, -1,                                         \
1460           &quot;Hit breakpoint when mallocing/freeing this pointer&quot;)             \
1461                                                                             \
1462   notproduct(ccstrlist, SuppressErrorAt, &quot;&quot;,                                \
1463           &quot;List of assertions (file:line) to muzzle&quot;)                       \
1464                                                                             \
1465   develop(intx, StackPrintLimit, 100,                                       \
1466           &quot;number of stack frames to print in VM-level stack dump&quot;)         \
1467                                                                             \
1468   notproduct(intx, MaxElementPrintSize, 256,                                \
1469           &quot;maximum number of elements to print&quot;)                            \
1470                                                                             \
1471   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
1472           &quot;maximum number of subklasses to print when printing klass&quot;)      \
1473                                                                             \
<span class="line-removed">1474   product(intx, MaxInlineLevel, 15,                                         \</span>
<span class="line-removed">1475           &quot;maximum number of nested calls that are inlined&quot;)                \</span>
<span class="line-removed">1476           range(0, max_jint)                                                \</span>
<span class="line-removed">1477                                                                             \</span>
<span class="line-removed">1478   product(intx, MaxRecursiveInlineLevel, 1,                                 \</span>
<span class="line-removed">1479           &quot;maximum number of nested recursive calls that are inlined&quot;)      \</span>
<span class="line-removed">1480           range(0, max_jint)                                                \</span>
<span class="line-removed">1481                                                                             \</span>
1482   develop(intx, MaxForceInlineLevel, 100,                                   \
1483           &quot;maximum number of nested calls that are forced for inlining &quot;    \
1484           &quot;(using CompileCommand or marked w/ @ForceInline)&quot;)               \
1485           range(0, max_jint)                                                \
1486                                                                             \
<span class="line-removed">1487   product_pd(intx, InlineSmallCode,                                         \</span>
<span class="line-removed">1488           &quot;Only inline already compiled methods if their code size is &quot;     \</span>
<span class="line-removed">1489           &quot;less than this&quot;)                                                 \</span>
<span class="line-removed">1490           range(0, max_jint)                                                \</span>
<span class="line-removed">1491                                                                             \</span>
<span class="line-removed">1492   product(intx, MaxInlineSize, 35,                                          \</span>
<span class="line-removed">1493           &quot;The maximum bytecode size of a method to be inlined&quot;)            \</span>
<span class="line-removed">1494           range(0, max_jint)                                                \</span>
<span class="line-removed">1495                                                                             \</span>
<span class="line-removed">1496   product_pd(intx, FreqInlineSize,                                          \</span>
<span class="line-removed">1497           &quot;The maximum bytecode size of a frequent method to be inlined&quot;)   \</span>
<span class="line-removed">1498           range(0, max_jint)                                                \</span>
<span class="line-removed">1499                                                                             \</span>
<span class="line-removed">1500   product(intx, MaxTrivialSize, 6,                                          \</span>
<span class="line-removed">1501           &quot;The maximum bytecode size of a trivial method to be inlined&quot;)    \</span>
<span class="line-removed">1502           range(0, max_jint)                                                \</span>
<span class="line-removed">1503                                                                             \</span>
1504   product(intx, MinInliningThreshold, 250,                                  \
1505           &quot;The minimum invocation count a method needs to have to be &quot;      \
1506           &quot;inlined&quot;)                                                        \
1507           range(0, max_jint)                                                \
1508                                                                             \
1509   develop(intx, MethodHistogramCutoff, 100,                                 \
1510           &quot;The cutoff value for method invocation histogram (+CountCalls)&quot;) \
1511                                                                             \
1512   develop(intx, DontYieldALotInterval,    10,                               \
1513           &quot;Interval between which yields will be dropped (milliseconds)&quot;)   \
1514                                                                             \
1515   notproduct(intx, DeoptimizeALotInterval,     5,                           \
1516           &quot;Number of exits until DeoptimizeALot kicks in&quot;)                  \
1517                                                                             \
1518   notproduct(intx, ZombieALotInterval,     5,                               \
1519           &quot;Number of exits until ZombieALot kicks in&quot;)                      \
1520                                                                             \
1521   diagnostic(uintx, MallocMaxTestWords,     0,                              \
1522           &quot;If non-zero, maximum number of words that malloc/realloc can &quot;   \
1523           &quot;allocate (for testing only)&quot;)                                    \
</pre>
</td>
<td>
<hr />
<pre>
 161           &quot;Enable normal processing of flags relating to field diagnostics&quot;)\
 162                                                                             \
 163   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 164           &quot;Enable normal processing of flags relating to experimental &quot;     \
 165           &quot;features&quot;)                                                       \
 166                                                                             \
 167   product(bool, JavaMonitorsInStackTrace, true,                             \
 168           &quot;Print information about Java monitor locks when the stacks are&quot;  \
 169           &quot;dumped&quot;)                                                         \
 170                                                                             \
 171   product_pd(bool, UseLargePages,                                           \
 172           &quot;Use large page memory&quot;)                                          \
 173                                                                             \
 174   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 175           &quot;Allocate large pages individually for better affinity&quot;)          \
 176                                                                             \
 177   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 178           &quot;Fail large pages individual allocation&quot;)                         \
 179                                                                             \
 180   product(bool, UseLargePagesInMetaspace, false,                            \
<span class="line-modified"> 181           &quot;(Deprecated) Use large page memory in metaspace. &quot;               \</span>
 182           &quot;Only used if UseLargePages is enabled.&quot;)                         \
 183                                                                             \
 184   product(bool, UseNUMA, false,                                             \
 185           &quot;Use NUMA if available&quot;)                                          \
 186                                                                             \
 187   product(bool, UseNUMAInterleaving, false,                                 \
 188           &quot;Interleave memory across NUMA nodes if available&quot;)               \
 189                                                                             \
 190   product(size_t, NUMAInterleaveGranularity, 2*M,                           \
 191           &quot;Granularity to use for NUMA interleaving on Windows OS&quot;)         \
 192           range(os::vm_allocation_granularity(), NOT_LP64(2*G) LP64_ONLY(8192*G)) \
 193                                                                             \
 194   product(bool, ForceNUMA, false,                                           \
 195           &quot;(Deprecated) Force NUMA optimizations on single-node/UMA systems&quot;) \
 196                                                                             \
 197   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 198           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
 199           &quot;computing exponentially decaying average for &quot;                   \
 200           &quot;AdaptiveNUMAChunkSizing&quot;)                                        \
 201           range(0, 100)                                                     \
</pre>
<hr />
<pre>
 778           &quot;Max nof embedded object references in an inline type to flatten, &lt;0 no limit&quot;)  \
 779                                                                             \
 780   product(bool, InlineArrayAtomicAccess, false,                             \
 781           &quot;Atomic inline array accesses by-default, for all inline arrays&quot;) \
 782                                                                             \
 783   /* Need to limit the extent of the padding to reasonable size.          */\
 784   /* 8K is well beyond the reasonable HW cache line size, even with       */\
 785   /* aggressive prefetching, while still leaving the room for segregating */\
 786   /* among the distinct pages.                                            */\
 787   product(intx, ContendedPaddingWidth, 128,                                 \
 788           &quot;How many bytes to pad the fields/classes marked @Contended with&quot;)\
 789           range(0, 8192)                                                    \
 790           constraint(ContendedPaddingWidthConstraintFunc,AfterErgo)         \
 791                                                                             \
 792   product(bool, EnableContended, true,                                      \
 793           &quot;Enable @Contended annotation support&quot;)                           \
 794                                                                             \
 795   product(bool, RestrictContended, true,                                    \
 796           &quot;Restrict @Contended to trusted classes&quot;)                         \
 797                                                                             \
<span class="line-modified"> 798   product(bool, UseBiasedLocking, false,                                    \</span>
<span class="line-modified"> 799           &quot;(Deprecated) Enable biased locking in JVM&quot;)                      \</span>
 800                                                                             \
 801   product(intx, BiasedLockingStartupDelay, 0,                               \
<span class="line-modified"> 802           &quot;(Deprecated) Number of milliseconds to wait before enabling &quot;    \</span>
<span class="line-added"> 803           &quot;biased locking&quot;)                                                 \</span>
 804           range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \
 805           constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \
 806                                                                             \
 807   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
<span class="line-modified"> 808           &quot;(Deprecated) Print statistics of biased locking in JVM&quot;)         \</span>
 809                                                                             \
 810   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
<span class="line-modified"> 811           &quot;(Deprecated) Threshold of number of revocations per type to &quot;    \</span>
<span class="line-modified"> 812           &quot;try to rebias all objects in the heap of that type&quot;)             \</span>
 813           range(0, max_intx)                                                \
 814           constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \
 815                                                                             \
 816   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
<span class="line-modified"> 817           &quot;(Deprecated) Threshold of number of revocations per type to &quot;    \</span>
<span class="line-modified"> 818           &quot;permanently revoke biases of all objects in the heap of that &quot;   \</span>
<span class="line-added"> 819           &quot;type&quot;)                                                           \</span>
 820           range(0, max_intx)                                                \
 821           constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \
 822                                                                             \
 823   product(intx, BiasedLockingDecayTime, 25000,                              \
<span class="line-modified"> 824           &quot;(Deprecated) Decay time (in milliseconds) to re-enable bulk &quot;    \</span>
<span class="line-modified"> 825           &quot;rebiasing of a type after previous bulk rebias&quot;)                 \</span>
 826           range(500, max_intx)                                              \
 827           constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \
 828                                                                             \
 829   product(bool, ExitOnOutOfMemoryError, false,                              \
 830           &quot;JVM exits on the first occurrence of an out-of-memory error&quot;)    \
 831                                                                             \
 832   product(bool, CrashOnOutOfMemoryError, false,                             \
 833           &quot;JVM aborts, producing an error log and core/mini dump, on the &quot;  \
 834           &quot;first occurrence of an out-of-memory error&quot;)                     \
 835                                                                             \
 836   /* tracing */                                                             \
 837                                                                             \
 838   develop(bool, StressRewriter, false,                                      \
 839           &quot;Stress linktime bytecode rewriting&quot;)                             \
 840                                                                             \
 841   product(ccstr, TraceJVMTI, NULL,                                          \
 842           &quot;Trace flags for JVMTI functions and events&quot;)                     \
 843                                                                             \
 844   /* This option can change an EMCP method into an obsolete method. */      \
 845   /* This can affect tests that except specific methods to be EMCP. */      \
</pre>
<hr />
<pre>
 896                                                                             \
 897   develop(bool, FLSVerifyDictionary, false,                                 \
 898           &quot;Do lots of (expensive) FLS dictionary verification&quot;)             \
 899                                                                             \
 900                                                                             \
 901   notproduct(bool, CheckMemoryInitialization, false,                        \
 902           &quot;Check memory initialization&quot;)                                    \
 903                                                                             \
 904   product(uintx, ProcessDistributionStride, 4,                              \
 905           &quot;Stride through processors when distributing processes&quot;)          \
 906           range(0, max_juint)                                               \
 907                                                                             \
 908   develop(bool, TraceFinalizerRegistration, false,                          \
 909           &quot;Trace registration of final references&quot;)                         \
 910                                                                             \
 911   product(bool, IgnoreEmptyClassPaths, false,                               \
 912           &quot;Ignore empty path elements in -classpath&quot;)                       \
 913                                                                             \
 914   product(size_t, InitialBootClassLoaderMetaspaceSize,                      \
 915           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
<span class="line-modified"> 916           &quot;(Deprecated) Initial size of the boot class loader data metaspace&quot;) \</span>
 917           range(30*K, max_uintx/BytesPerWord)                               \
 918           constraint(InitialBootClassLoaderMetaspaceSizeConstraintFunc, AfterErgo)\
 919                                                                             \
 920   product(bool, PrintHeapAtSIGBREAK, true,                                  \
 921           &quot;Print heap layout in response to SIGBREAK&quot;)                      \
 922                                                                             \
 923   manageable(bool, PrintClassHistogram, false,                              \
 924           &quot;Print a histogram of class instances&quot;)                           \
 925                                                                             \
 926   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
 927           &quot;The percentage of the used heap that the instances of a class &quot;  \
 928           &quot;must occupy for the class to generate a trace event&quot;)            \
 929           range(0.0, 100.0)                                                 \
 930                                                                             \
 931   /* JVMTI heap profiling */                                                \
 932                                                                             \
 933   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
 934           &quot;Trace JVMTI object tagging calls&quot;)                               \
 935                                                                             \
 936   diagnostic(bool, VerifyBeforeIteration, false,                            \
</pre>
<hr />
<pre>
1456           &quot;Number of records in the ring buffer of sweeper activity&quot;)       \
1457                                                                             \
1458   notproduct(intx, MemProfilingInterval, 500,                               \
1459           &quot;Time between each invocation of the MemProfiler&quot;)                \
1460                                                                             \
1461   develop(intx, MallocCatchPtr, -1,                                         \
1462           &quot;Hit breakpoint when mallocing/freeing this pointer&quot;)             \
1463                                                                             \
1464   notproduct(ccstrlist, SuppressErrorAt, &quot;&quot;,                                \
1465           &quot;List of assertions (file:line) to muzzle&quot;)                       \
1466                                                                             \
1467   develop(intx, StackPrintLimit, 100,                                       \
1468           &quot;number of stack frames to print in VM-level stack dump&quot;)         \
1469                                                                             \
1470   notproduct(intx, MaxElementPrintSize, 256,                                \
1471           &quot;maximum number of elements to print&quot;)                            \
1472                                                                             \
1473   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
1474           &quot;maximum number of subklasses to print when printing klass&quot;)      \
1475                                                                             \








1476   develop(intx, MaxForceInlineLevel, 100,                                   \
1477           &quot;maximum number of nested calls that are forced for inlining &quot;    \
1478           &quot;(using CompileCommand or marked w/ @ForceInline)&quot;)               \
1479           range(0, max_jint)                                                \
1480                                                                             \

















1481   product(intx, MinInliningThreshold, 250,                                  \
1482           &quot;The minimum invocation count a method needs to have to be &quot;      \
1483           &quot;inlined&quot;)                                                        \
1484           range(0, max_jint)                                                \
1485                                                                             \
1486   develop(intx, MethodHistogramCutoff, 100,                                 \
1487           &quot;The cutoff value for method invocation histogram (+CountCalls)&quot;) \
1488                                                                             \
1489   develop(intx, DontYieldALotInterval,    10,                               \
1490           &quot;Interval between which yields will be dropped (milliseconds)&quot;)   \
1491                                                                             \
1492   notproduct(intx, DeoptimizeALotInterval,     5,                           \
1493           &quot;Number of exits until DeoptimizeALot kicks in&quot;)                  \
1494                                                                             \
1495   notproduct(intx, ZombieALotInterval,     5,                               \
1496           &quot;Number of exits until ZombieALot kicks in&quot;)                      \
1497                                                                             \
1498   diagnostic(uintx, MallocMaxTestWords,     0,                              \
1499           &quot;If non-zero, maximum number of words that malloc/realloc can &quot;   \
1500           &quot;allocate (for testing only)&quot;)                                    \
</pre>
</td>
</tr>
</table>
<center><a href="arguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="init.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
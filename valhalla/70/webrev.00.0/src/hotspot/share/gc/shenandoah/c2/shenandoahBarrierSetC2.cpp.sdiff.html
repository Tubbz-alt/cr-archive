<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../parallel/psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 466   fields = TypeTuple::fields(0);
 467   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 468 
 469   return TypeFunc::make(domain, range);
 470 }
 471 
 472 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 473   const Type **fields = TypeTuple::fields(1);
 474   fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; // src oop
 475   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 476 
 477   // create result type (range)
 478   fields = TypeTuple::fields(0);
 479   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 480 
 481   return TypeFunc::make(domain, range);
 482 }
 483 
 484 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {
 485   const Type **fields = TypeTuple::fields(2);
<span class="line-modified"> 486   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value</span>
<span class="line-modified"> 487   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // original load address</span>
 488 
 489   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 490 
 491   // create result type (range)
 492   fields = TypeTuple::fields(1);
<span class="line-modified"> 493   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;</span>
 494   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 495 
 496   return TypeFunc::make(domain, range);
 497 }
 498 
 499 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 500   DecoratorSet decorators = access.decorators();
 501 
 502   const TypePtr* adr_type = access.addr().type();
 503   Node* adr = access.addr().node();
 504 
 505   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 506   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 507 
 508   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 509     return BarrierSetC2::store_at_resolved(access, val);
 510   }
 511 
 512   if (access.is_parse_access()) {
 513     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 514     GraphKit* kit = parse_access.kit();
 515 
 516     uint adr_idx = kit-&gt;C-&gt;get_alias_index(adr_type);
 517     assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
 518     Node* value = val.node();
 519     value = shenandoah_storeval_barrier(kit, value);
 520     val.set_node(value);
 521     shenandoah_write_barrier_pre(kit, true /* do_load */, /*kit-&gt;control(),*/ access.base(), adr, adr_idx, val.node(),
 522                                  static_cast&lt;const TypeOopPtr*&gt;(val.type()), NULL /* pre_val */, access.type());
 523   } else {
 524     assert(access.is_opt_access(), &quot;only for optimization passes&quot;);
 525     assert(((decorators &amp; C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) &amp;&amp; (decorators &amp; C2_ARRAY_COPY) != 0, &quot;unexpected caller of this code&quot;);
 526     C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
 527     PhaseGVN&amp; gvn =  opt_access.gvn();
<span class="line-removed"> 528     MergeMemNode* mm = opt_access.mem();</span>
 529 
 530     if (ShenandoahStoreValEnqueueBarrier) {
 531       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(val.node()));
 532       val.set_node(enqueue);
 533     }
 534   }
 535   return BarrierSetC2::store_at_resolved(access, val);
 536 }
 537 
 538 Node* ShenandoahBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
 539   // 1: non-reference load, no additional barrier is needed
 540   if (!access.is_oop()) {
 541     return BarrierSetC2::load_at_resolved(access, val_type);;
 542   }
 543 
 544   Node* load = BarrierSetC2::load_at_resolved(access, val_type);
 545   DecoratorSet decorators = access.decorators();
 546   BasicType type = access.type();
 547 
 548   // 2: apply LRB if needed
</pre>
</td>
<td>
<hr />
<pre>
 466   fields = TypeTuple::fields(0);
 467   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 468 
 469   return TypeFunc::make(domain, range);
 470 }
 471 
 472 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 473   const Type **fields = TypeTuple::fields(1);
 474   fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; // src oop
 475   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 476 
 477   // create result type (range)
 478   fields = TypeTuple::fields(0);
 479   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 480 
 481   return TypeFunc::make(domain, range);
 482 }
 483 
 484 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {
 485   const Type **fields = TypeTuple::fields(2);
<span class="line-modified"> 486   fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM; // original field value</span>
<span class="line-modified"> 487   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // original load address</span>
 488 
 489   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 490 
 491   // create result type (range)
 492   fields = TypeTuple::fields(1);
<span class="line-modified"> 493   fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM;</span>
 494   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 495 
 496   return TypeFunc::make(domain, range);
 497 }
 498 
 499 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 500   DecoratorSet decorators = access.decorators();
 501 
 502   const TypePtr* adr_type = access.addr().type();
 503   Node* adr = access.addr().node();
 504 
 505   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 506   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 507 
 508   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 509     return BarrierSetC2::store_at_resolved(access, val);
 510   }
 511 
 512   if (access.is_parse_access()) {
 513     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 514     GraphKit* kit = parse_access.kit();
 515 
 516     uint adr_idx = kit-&gt;C-&gt;get_alias_index(adr_type);
 517     assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
 518     Node* value = val.node();
 519     value = shenandoah_storeval_barrier(kit, value);
 520     val.set_node(value);
 521     shenandoah_write_barrier_pre(kit, true /* do_load */, /*kit-&gt;control(),*/ access.base(), adr, adr_idx, val.node(),
 522                                  static_cast&lt;const TypeOopPtr*&gt;(val.type()), NULL /* pre_val */, access.type());
 523   } else {
 524     assert(access.is_opt_access(), &quot;only for optimization passes&quot;);
 525     assert(((decorators &amp; C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) &amp;&amp; (decorators &amp; C2_ARRAY_COPY) != 0, &quot;unexpected caller of this code&quot;);
 526     C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
 527     PhaseGVN&amp; gvn =  opt_access.gvn();

 528 
 529     if (ShenandoahStoreValEnqueueBarrier) {
 530       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(val.node()));
 531       val.set_node(enqueue);
 532     }
 533   }
 534   return BarrierSetC2::store_at_resolved(access, val);
 535 }
 536 
 537 Node* ShenandoahBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
 538   // 1: non-reference load, no additional barrier is needed
 539   if (!access.is_oop()) {
 540     return BarrierSetC2::load_at_resolved(access, val_type);;
 541   }
 542 
 543   Node* load = BarrierSetC2::load_at_resolved(access, val_type);
 544   DecoratorSet decorators = access.decorators();
 545   BasicType type = access.type();
 546 
 547   // 2: apply LRB if needed
</pre>
</td>
</tr>
</table>
<center><a href="../../parallel/psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
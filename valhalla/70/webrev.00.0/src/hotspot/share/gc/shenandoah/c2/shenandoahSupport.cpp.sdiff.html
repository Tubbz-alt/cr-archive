<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../interpreter/templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 771   mem_ctrl = phase-&gt;ctrl_or_self(mem);
 772   while (!phase-&gt;is_dominator(mem_ctrl, ctrl) || mem_ctrl == ctrl) {
 773     mem = next_mem(mem, alias);
 774     if (wq.test_set(mem-&gt;_idx)) {
 775       return NULL;
 776     }
 777     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 778   }
 779   if (mem-&gt;is_MergeMem()) {
 780     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
 781     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 782   }
 783   return mem;
 784 }
 785 
 786 Node* ShenandoahBarrierC2Support::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {
 787   Node* mem = NULL;
 788   Node* c = ctrl;
 789   do {
 790     if (c-&gt;is_Region()) {
<span class="line-removed"> 791       Node* phi_bottom = NULL;</span>
 792       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {
 793         Node* u = c-&gt;fast_out(i);
 794         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {
 795           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
 796             mem = u;
 797           }
 798         }
 799       }
 800     } else {
 801       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {
 802         CallProjections* projs = c-&gt;as_Call()-&gt;extract_projections(true, false);
 803         if (projs-&gt;fallthrough_memproj != NULL) {
 804           if (projs-&gt;fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {
 805             if (projs-&gt;catchall_memproj == NULL) {
 806               mem = projs-&gt;fallthrough_memproj;
 807             } else {
 808               if (phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, ctrl)) {
 809                 mem = projs-&gt;fallthrough_memproj;
 810               } else {
 811                 assert(phase-&gt;is_dominator(projs-&gt;catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);
</pre>
<hr />
<pre>
 901 
 902   const Type* val_t = igvn.type(val);
 903   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {
 904     Node* null_cmp   = new CmpPNode(val, igvn.zerocon(T_OBJECT));
 905     Node* null_test  = new BoolNode(null_cmp, BoolTest::ne);
 906 
 907     IfNode* null_iff = new IfNode(old_ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
 908     ctrl             = new IfTrueNode(null_iff);
 909     null_ctrl        = new IfFalseNode(null_iff);
 910 
 911     IdealLoopTree* loop = phase-&gt;get_loop(old_ctrl);
 912     phase-&gt;register_control(null_iff,  loop, old_ctrl);
 913     phase-&gt;register_control(ctrl,      loop, null_iff);
 914     phase-&gt;register_control(null_ctrl, loop, null_iff);
 915 
 916     phase-&gt;register_new_node(null_cmp,  old_ctrl);
 917     phase-&gt;register_new_node(null_test, old_ctrl);
 918   }
 919 }
 920 
<span class="line-removed"> 921 Node* ShenandoahBarrierC2Support::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-removed"> 922   IdealLoopTree *loop = phase-&gt;get_loop(c);</span>
<span class="line-removed"> 923   Node* iff = unc_ctrl-&gt;in(0);</span>
<span class="line-removed"> 924   assert(iff-&gt;is_If(), &quot;broken&quot;);</span>
<span class="line-removed"> 925   Node* new_iff = iff-&gt;clone();</span>
<span class="line-removed"> 926   new_iff-&gt;set_req(0, c);</span>
<span class="line-removed"> 927   phase-&gt;register_control(new_iff, loop, c);</span>
<span class="line-removed"> 928   Node* iffalse = new IfFalseNode(new_iff-&gt;as_If());</span>
<span class="line-removed"> 929   phase-&gt;register_control(iffalse, loop, new_iff);</span>
<span class="line-removed"> 930   Node* iftrue = new IfTrueNode(new_iff-&gt;as_If());</span>
<span class="line-removed"> 931   phase-&gt;register_control(iftrue, loop, new_iff);</span>
<span class="line-removed"> 932   c = iftrue;</span>
<span class="line-removed"> 933   const Type *t = phase-&gt;igvn().type(val);</span>
<span class="line-removed"> 934   assert(val-&gt;Opcode() == Op_CastPP, &quot;expect cast to non null here&quot;);</span>
<span class="line-removed"> 935   Node* uncasted_val = val-&gt;in(1);</span>
<span class="line-removed"> 936   val = new CastPPNode(uncasted_val, t);</span>
<span class="line-removed"> 937   val-&gt;init_req(0, c);</span>
<span class="line-removed"> 938   phase-&gt;register_new_node(val, c);</span>
<span class="line-removed"> 939   return val;</span>
<span class="line-removed"> 940 }</span>
<span class="line-removed"> 941 </span>
<span class="line-removed"> 942 void ShenandoahBarrierC2Support::fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl,</span>
<span class="line-removed"> 943                                                 Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {</span>
<span class="line-removed"> 944   IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed"> 945   Node* proj = iff-&gt;proj_out(0);</span>
<span class="line-removed"> 946   assert(proj != unc_ctrl, &quot;bad projection&quot;);</span>
<span class="line-removed"> 947   Node* use = proj-&gt;unique_ctrl_out();</span>
<span class="line-removed"> 948 </span>
<span class="line-removed"> 949   assert(use == unc || use-&gt;is_Region(), &quot;what else?&quot;);</span>
<span class="line-removed"> 950 </span>
<span class="line-removed"> 951   uses.clear();</span>
<span class="line-removed"> 952   if (use == unc) {</span>
<span class="line-removed"> 953     phase-&gt;set_idom(use, new_unc_ctrl, phase-&gt;dom_depth(use));</span>
<span class="line-removed"> 954     for (uint i = 1; i &lt; unc-&gt;req(); i++) {</span>
<span class="line-removed"> 955       Node* n = unc-&gt;in(i);</span>
<span class="line-removed"> 956       if (phase-&gt;has_ctrl(n) &amp;&amp; phase-&gt;get_ctrl(n) == proj) {</span>
<span class="line-removed"> 957         uses.push(n);</span>
<span class="line-removed"> 958       }</span>
<span class="line-removed"> 959     }</span>
<span class="line-removed"> 960   } else {</span>
<span class="line-removed"> 961     assert(use-&gt;is_Region(), &quot;what else?&quot;);</span>
<span class="line-removed"> 962     uint idx = 1;</span>
<span class="line-removed"> 963     for (; use-&gt;in(idx) != proj; idx++);</span>
<span class="line-removed"> 964     for (DUIterator_Fast imax, i = use-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 965       Node* u = use-&gt;fast_out(i);</span>
<span class="line-removed"> 966       if (u-&gt;is_Phi() &amp;&amp; phase-&gt;get_ctrl(u-&gt;in(idx)) == proj) {</span>
<span class="line-removed"> 967         uses.push(u-&gt;in(idx));</span>
<span class="line-removed"> 968       }</span>
<span class="line-removed"> 969     }</span>
<span class="line-removed"> 970   }</span>
<span class="line-removed"> 971   for(uint next = 0; next &lt; uses.size(); next++ ) {</span>
<span class="line-removed"> 972     Node *n = uses.at(next);</span>
<span class="line-removed"> 973     assert(phase-&gt;get_ctrl(n) == proj, &quot;bad control&quot;);</span>
<span class="line-removed"> 974     phase-&gt;set_ctrl_and_loop(n, new_unc_ctrl);</span>
<span class="line-removed"> 975     if (n-&gt;in(0) == proj) {</span>
<span class="line-removed"> 976       phase-&gt;igvn().replace_input_of(n, 0, new_unc_ctrl);</span>
<span class="line-removed"> 977     }</span>
<span class="line-removed"> 978     for (uint i = 0; i &lt; n-&gt;req(); i++) {</span>
<span class="line-removed"> 979       Node* m = n-&gt;in(i);</span>
<span class="line-removed"> 980       if (m != NULL &amp;&amp; phase-&gt;has_ctrl(m) &amp;&amp; phase-&gt;get_ctrl(m) == proj) {</span>
<span class="line-removed"> 981         uses.push(m);</span>
<span class="line-removed"> 982       }</span>
<span class="line-removed"> 983     }</span>
<span class="line-removed"> 984   }</span>
<span class="line-removed"> 985 </span>
<span class="line-removed"> 986   phase-&gt;igvn().rehash_node_delayed(use);</span>
<span class="line-removed"> 987   int nb = use-&gt;replace_edge(proj, new_unc_ctrl);</span>
<span class="line-removed"> 988   assert(nb == 1, &quot;only use expected&quot;);</span>
<span class="line-removed"> 989 }</span>
<span class="line-removed"> 990 </span>
 991 void ShenandoahBarrierC2Support::test_in_cset(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {
 992   Node* old_ctrl = ctrl;
 993   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 994 
 995   Node* raw_val        = new CastP2XNode(old_ctrl, val);
 996   Node* cset_idx       = new URShiftXNode(raw_val, igvn.intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
 997   Node* cset_addr      = igvn.makecon(TypeRawPtr::make(ShenandoahHeap::in_cset_fast_test_addr()));
 998   Node* cset_load_addr = new AddPNode(phase-&gt;C-&gt;top(), cset_addr, cset_idx);
 999   Node* cset_load      = new LoadBNode(old_ctrl, raw_mem, cset_load_addr,
1000                                        DEBUG_ONLY(phase-&gt;C-&gt;get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),
1001                                        TypeInt::BYTE, MemNode::unordered);
1002   Node* cset_cmp       = new CmpINode(cset_load, igvn.zerocon(T_INT));
1003   Node* cset_bool      = new BoolNode(cset_cmp, BoolTest::ne);
1004 
1005   IfNode* cset_iff     = new IfNode(old_ctrl, cset_bool, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
1006   ctrl                 = new IfTrueNode(cset_iff);
1007   not_cset_ctrl        = new IfFalseNode(cset_iff);
1008 
1009   IdealLoopTree *loop = phase-&gt;get_loop(old_ctrl);
1010   phase-&gt;register_control(cset_iff,      loop, old_ctrl);
</pre>
<hr />
<pre>
1180             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1181             u-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
1182             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
1183             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
1184             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
1185             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val &amp;&amp;
1186             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
1187           IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1188           IdealLoopTree* unc_loop = phase-&gt;get_loop(u-&gt;in(0));
1189 
1190           if (!unc_loop-&gt;is_member(loop)) {
1191             continue;
1192           }
1193 
1194           Node* branch = no_branches(ctrl, u-&gt;in(0), false, phase);
1195           assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);
1196           if (branch == NodeSentinel) {
1197             continue;
1198           }
1199 
<span class="line-modified">1200           phase-&gt;igvn().replace_input_of(u, 1, val);</span>
<span class="line-modified">1201           phase-&gt;igvn().replace_input_of(lrb, ShenandoahLoadReferenceBarrierNode::ValueIn, u);</span>
<span class="line-modified">1202           phase-&gt;set_ctrl(u, u-&gt;in(0));</span>
<span class="line-modified">1203           phase-&gt;set_ctrl(lrb, u-&gt;in(0));</span>
<span class="line-modified">1204           unc = u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-modified">1205           unc_ctrl = u-&gt;in(0);</span>
<span class="line-modified">1206           val = u;</span>
<span class="line-modified">1207 </span>
<span class="line-modified">1208           for (DUIterator_Fast jmax, j = val-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1209             Node* u = val-&gt;fast_out(j);</span>
<span class="line-removed">1210             if (u == lrb) continue;</span>
<span class="line-removed">1211             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">1212             int nb = u-&gt;replace_edge(val, lrb);</span>
<span class="line-removed">1213             --j; jmax -= nb;</span>
<span class="line-removed">1214           }</span>
<span class="line-removed">1215 </span>
<span class="line-removed">1216           RegionNode* r = new RegionNode(3);</span>
<span class="line-removed">1217           IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed">1218 </span>
<span class="line-removed">1219           Node* ctrl_use = unc_ctrl-&gt;unique_ctrl_out();</span>
<span class="line-removed">1220           Node* unc_ctrl_clone = unc_ctrl-&gt;clone();</span>
<span class="line-removed">1221           phase-&gt;register_control(unc_ctrl_clone, loop, iff);</span>
<span class="line-removed">1222           Node* c = unc_ctrl_clone;</span>
<span class="line-removed">1223           Node* new_cast = clone_null_check(c, val, unc_ctrl_clone, phase);</span>
<span class="line-removed">1224           r-&gt;init_req(1, new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If()-&gt;proj_out(0));</span>
<span class="line-removed">1225 </span>
<span class="line-removed">1226           phase-&gt;igvn().replace_input_of(unc_ctrl, 0, c-&gt;in(0));</span>
<span class="line-removed">1227           phase-&gt;set_idom(unc_ctrl, c-&gt;in(0), phase-&gt;dom_depth(unc_ctrl));</span>
<span class="line-removed">1228           phase-&gt;lazy_replace(c, unc_ctrl);</span>
<span class="line-removed">1229           c = NULL;;</span>
<span class="line-removed">1230           phase-&gt;igvn().replace_input_of(val, 0, unc_ctrl_clone);</span>
<span class="line-removed">1231           phase-&gt;set_ctrl(val, unc_ctrl_clone);</span>
<span class="line-removed">1232 </span>
<span class="line-removed">1233           IfNode* new_iff = new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed">1234           fix_null_check(unc, unc_ctrl_clone, r, uses, phase);</span>
<span class="line-removed">1235           Node* iff_proj = iff-&gt;proj_out(0);</span>
<span class="line-removed">1236           r-&gt;init_req(2, iff_proj);</span>
<span class="line-removed">1237           phase-&gt;register_control(r, phase-&gt;ltree_root(), iff);</span>
<span class="line-removed">1238 </span>
<span class="line-removed">1239           Node* new_bol = new_iff-&gt;in(1)-&gt;clone();</span>
<span class="line-removed">1240           Node* new_cmp = new_bol-&gt;in(1)-&gt;clone();</span>
<span class="line-removed">1241           assert(new_cmp-&gt;Opcode() == Op_CmpP, &quot;broken&quot;);</span>
<span class="line-removed">1242           assert(new_cmp-&gt;in(1) == val-&gt;in(1), &quot;broken&quot;);</span>
<span class="line-removed">1243           new_bol-&gt;set_req(1, new_cmp);</span>
<span class="line-removed">1244           new_cmp-&gt;set_req(1, lrb);</span>
<span class="line-removed">1245           phase-&gt;register_new_node(new_bol, new_iff-&gt;in(0));</span>
<span class="line-removed">1246           phase-&gt;register_new_node(new_cmp, new_iff-&gt;in(0));</span>
<span class="line-removed">1247           phase-&gt;igvn().replace_input_of(new_iff, 1, new_bol);</span>
<span class="line-removed">1248           phase-&gt;igvn().replace_input_of(new_cast, 1, lrb);</span>
<span class="line-removed">1249 </span>
<span class="line-removed">1250           for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1251             Node* u = lrb-&gt;fast_out(i);</span>
<span class="line-removed">1252             if (u == new_cast || u == new_cmp) {</span>
<span class="line-removed">1253               continue;</span>
<span class="line-removed">1254             }</span>
<span class="line-removed">1255             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">1256             int nb = u-&gt;replace_edge(lrb, new_cast);</span>
<span class="line-removed">1257             assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-removed">1258             --i; imax -= nb;</span>
<span class="line-removed">1259           }</span>
<span class="line-removed">1260 </span>
<span class="line-removed">1261           for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1262             Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">1263             if (u == lrb) {</span>
<span class="line-removed">1264               continue;</span>
<span class="line-removed">1265             }</span>
<span class="line-removed">1266             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">1267             int nb = u-&gt;replace_edge(val, new_cast);</span>
<span class="line-removed">1268             assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-removed">1269             --i; imax -= nb;</span>
<span class="line-removed">1270           }</span>
<span class="line-removed">1271 </span>
<span class="line-removed">1272           ctrl = unc_ctrl_clone;</span>
<span class="line-removed">1273           phase-&gt;set_ctrl_and_loop(lrb, ctrl);</span>
1274           break;
1275         }
1276       }
1277     }
1278     if ((ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) || ctrl-&gt;is_CallJava()) {
1279       CallNode* call = ctrl-&gt;is_Proj() ? ctrl-&gt;in(0)-&gt;as_CallJava() : ctrl-&gt;as_CallJava();
1280       if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
1281         // The rethrow call may have too many projections to be
1282         // properly handled here. Given there&#39;s no reason for a
1283         // barrier to depend on the call, move it above the call
1284         stack.push(lrb, 0);
1285         do {
1286           Node* n = stack.node();
1287           uint idx = stack.index();
1288           if (idx &lt; n-&gt;req()) {
1289             Node* in = n-&gt;in(idx);
1290             stack.set_index(idx+1);
1291             if (in != NULL) {
1292               if (phase-&gt;has_ctrl(in)) {
1293                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {
1294 #ifdef ASSERT
1295                   for (uint i = 0; i &lt; stack.size(); i++) {
1296                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);
1297                   }
1298 #endif
1299                   stack.push(in, 0);
1300                 }
1301               } else {
1302                 assert(phase-&gt;is_dominator(in, call-&gt;in(0)), &quot;no dependency on the call&quot;);
1303               }
1304             }
1305           } else {
1306             phase-&gt;set_ctrl(n, call-&gt;in(0));
1307             stack.pop();
1308           }
1309         } while(stack.size() &gt; 0);
1310         continue;
1311       }
1312       CallProjections* projs = call-&gt;extract_projections(false, false);



1313       Node* lrb_clone = lrb-&gt;clone();
1314       phase-&gt;register_new_node(lrb_clone, projs-&gt;catchall_catchproj);
1315       phase-&gt;set_ctrl(lrb, projs-&gt;fallthrough_catchproj);
1316 
1317       stack.push(lrb, 0);
1318       clones.push(lrb_clone);
1319 
1320       do {
1321         assert(stack.size() == clones.size(), &quot;&quot;);
1322         Node* n = stack.node();
1323 #ifdef ASSERT
1324         if (n-&gt;is_Load()) {
1325           Node* mem = n-&gt;in(MemNode::Memory);
1326           for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1327             Node* u = mem-&gt;fast_out(j);
1328             assert(!u-&gt;is_Store() || !u-&gt;is_LoadStore() || phase-&gt;get_ctrl(u) != ctrl, &quot;anti dependent store?&quot;);
1329           }
1330         }
1331 #endif
1332         uint idx = stack.index();
1333         Node* n_clone = clones.at(clones.size()-1);
1334         if (idx &lt; n-&gt;outcnt()) {
1335           Node* u = n-&gt;raw_out(idx);
1336           Node* c = phase-&gt;ctrl_or_self(u);
1337           if (phase-&gt;is_dominator(call, c) &amp;&amp; phase-&gt;is_dominator(c, projs-&gt;fallthrough_proj)) {
1338             stack.set_index(idx+1);
1339             assert(!u-&gt;is_CFG(), &quot;&quot;);
1340             stack.push(u, 0);

1341             Node* u_clone = u-&gt;clone();
1342             int nb = u_clone-&gt;replace_edge(n, n_clone);
1343             assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1344             phase-&gt;register_new_node(u_clone, projs-&gt;catchall_catchproj);
1345             clones.push(u_clone);
1346             phase-&gt;set_ctrl(u, projs-&gt;fallthrough_catchproj);
1347           } else {
1348             bool replaced = false;
1349             if (u-&gt;is_Phi()) {
1350               for (uint k = 1; k &lt; u-&gt;req(); k++) {
1351                 if (u-&gt;in(k) == n) {
1352                   if (phase-&gt;is_dominator(projs-&gt;catchall_catchproj, u-&gt;in(0)-&gt;in(k))) {
1353                     phase-&gt;igvn().replace_input_of(u, k, n_clone);
1354                     replaced = true;
1355                   } else if (!phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, u-&gt;in(0)-&gt;in(k))) {
1356                     phase-&gt;igvn().replace_input_of(u, k, create_phis_on_call_return(ctrl, u-&gt;in(0)-&gt;in(k), n, n_clone, projs, phase));
1357                     replaced = true;
1358                   }
1359                 }
1360               }
1361             } else {
1362               if (phase-&gt;is_dominator(projs-&gt;catchall_catchproj, c)) {
1363                 phase-&gt;igvn().rehash_node_delayed(u);
1364                 int nb = u-&gt;replace_edge(n, n_clone);
1365                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1366                 replaced = true;
1367               } else if (!phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, c)) {
<span class="line-modified">1368                 phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-modified">1369                 int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));</span>
<span class="line-modified">1370                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
























1371                 replaced = true;
1372               }
1373             }
1374             if (!replaced) {
1375               stack.set_index(idx+1);
1376             }
1377           }
1378         } else {
1379           stack.pop();
1380           clones.pop();
1381         }
1382       } while (stack.size() &gt; 0);
1383       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1384     }
1385   }
1386 
1387   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1388     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
1389     if (lrb-&gt;is_redundant()) {
1390       continue;
</pre>
<hr />
<pre>
1404   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1405   Unique_Node_List uses_to_ignore;
1406   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1407     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
1408     if (lrb-&gt;is_redundant()) {
1409       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1410       continue;
1411     }
1412     uint last = phase-&gt;C-&gt;unique();
1413     Node* ctrl = phase-&gt;get_ctrl(lrb);
1414     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1415 
1416 
1417     Node* orig_ctrl = ctrl;
1418 
1419     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1420     Node* init_raw_mem = raw_mem;
1421     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1422 
1423     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
<span class="line-removed">1424     CallStaticJavaNode* unc = lrb-&gt;pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-removed">1425     Node* unc_ctrl = NULL;</span>
<span class="line-removed">1426     if (unc != NULL) {</span>
<span class="line-removed">1427       if (val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control) != ctrl) {</span>
<span class="line-removed">1428         unc = NULL;</span>
<span class="line-removed">1429       } else {</span>
<span class="line-removed">1430         unc_ctrl = val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control);</span>
<span class="line-removed">1431       }</span>
<span class="line-removed">1432     }</span>
<span class="line-removed">1433 </span>
<span class="line-removed">1434     Node* uncasted_val = val;</span>
<span class="line-removed">1435     if (unc != NULL) {</span>
<span class="line-removed">1436       uncasted_val = val-&gt;in(1);</span>
<span class="line-removed">1437     }</span>
1438 
1439     Node* heap_stable_ctrl = NULL;
1440     Node* null_ctrl = NULL;
1441 
1442     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1443     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1444 
<span class="line-modified">1445     enum { _heap_stable = 1, _not_cset, _evac_path, _null_path, PATH_LIMIT };</span>
1446     Node* region = new RegionNode(PATH_LIMIT);
<span class="line-modified">1447     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
1448     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1449 
1450     // Stable path.
1451     test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::HAS_FORWARDED);
1452     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();
1453 
1454     // Heap stable case
1455     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
<span class="line-modified">1456     val_phi-&gt;init_req(_heap_stable, uncasted_val);</span>
1457     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);
1458 
<span class="line-removed">1459     Node* reg2_ctrl = NULL;</span>
<span class="line-removed">1460     // Null case</span>
<span class="line-removed">1461     test_null(ctrl, val, null_ctrl, phase);</span>
<span class="line-removed">1462     if (null_ctrl != NULL) {</span>
<span class="line-removed">1463       reg2_ctrl = null_ctrl-&gt;in(0);</span>
<span class="line-removed">1464       region-&gt;init_req(_null_path, null_ctrl);</span>
<span class="line-removed">1465       val_phi-&gt;init_req(_null_path, uncasted_val);</span>
<span class="line-removed">1466       raw_mem_phi-&gt;init_req(_null_path, raw_mem);</span>
<span class="line-removed">1467     } else {</span>
<span class="line-removed">1468       region-&gt;del_req(_null_path);</span>
<span class="line-removed">1469       val_phi-&gt;del_req(_null_path);</span>
<span class="line-removed">1470       raw_mem_phi-&gt;del_req(_null_path);</span>
<span class="line-removed">1471     }</span>
<span class="line-removed">1472 </span>
1473     // Test for in-cset.
1474     // Wires !in_cset(obj) to slot 2 of region and phis
1475     Node* not_cset_ctrl = NULL;
<span class="line-modified">1476     test_in_cset(ctrl, not_cset_ctrl, uncasted_val, raw_mem, phase);</span>
1477     if (not_cset_ctrl != NULL) {
<span class="line-modified">1478       if (reg2_ctrl == NULL) reg2_ctrl = not_cset_ctrl-&gt;in(0);</span>
<span class="line-removed">1479       region-&gt;init_req(_not_cset, not_cset_ctrl);</span>
1480       val_phi-&gt;init_req(_not_cset, uncasted_val);
1481       raw_mem_phi-&gt;init_req(_not_cset, raw_mem);
1482     }
1483 
1484     // Resolve object when orig-value is in cset.
1485     // Make the unconditional resolve for fwdptr.
<span class="line-removed">1486     Node* new_val = uncasted_val;</span>
<span class="line-removed">1487     if (unc_ctrl != NULL) {</span>
<span class="line-removed">1488       // Clone the null check in this branch to allow implicit null check</span>
<span class="line-removed">1489       new_val = clone_null_check(ctrl, val, unc_ctrl, phase);</span>
<span class="line-removed">1490       fix_null_check(unc, unc_ctrl, ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(0), uses, phase);</span>
<span class="line-removed">1491 </span>
<span class="line-removed">1492       IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed">1493       phase-&gt;igvn().replace_input_of(iff, 1, phase-&gt;igvn().intcon(1));</span>
<span class="line-removed">1494     }</span>
1495 
1496     // Call lrb-stub and wire up that path in slots 4
1497     Node* result_mem = NULL;
1498 
<span class="line-removed">1499     Node* fwd = new_val;</span>
1500     Node* addr;
1501     if (ShenandoahSelfFixing) {
1502       VectorSet visited(Thread::current()-&gt;resource_area());
1503       addr = get_load_addr(phase, visited, lrb);
1504     } else {
1505       addr = phase-&gt;igvn().zerocon(T_OBJECT);
1506     }
1507     if (addr-&gt;Opcode() == Op_AddP) {
1508       Node* orig_base = addr-&gt;in(AddPNode::Base);
1509       Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base-&gt;bottom_type(), true);
1510       phase-&gt;register_new_node(base, ctrl);
1511       if (addr-&gt;in(AddPNode::Base) == addr-&gt;in((AddPNode::Address))) {
1512         // Field access
1513         addr = addr-&gt;clone();
1514         addr-&gt;set_req(AddPNode::Base, base);
1515         addr-&gt;set_req(AddPNode::Address, base);
1516         phase-&gt;register_new_node(addr, ctrl);
1517       } else {
1518         Node* addr2 = addr-&gt;in(AddPNode::Address);
1519         if (addr2-&gt;Opcode() == Op_AddP &amp;&amp; addr2-&gt;in(AddPNode::Base) == addr2-&gt;in(AddPNode::Address) &amp;&amp;
1520               addr2-&gt;in(AddPNode::Base) == orig_base) {
1521           addr2 = addr2-&gt;clone();
1522           addr2-&gt;set_req(AddPNode::Base, base);
1523           addr2-&gt;set_req(AddPNode::Address, base);
1524           phase-&gt;register_new_node(addr2, ctrl);
1525           addr = addr-&gt;clone();
1526           addr-&gt;set_req(AddPNode::Base, base);
1527           addr-&gt;set_req(AddPNode::Address, addr2);
1528           phase-&gt;register_new_node(addr, ctrl);
1529         }
1530       }
1531     }
<span class="line-modified">1532     call_lrb_stub(ctrl, fwd, addr, result_mem, raw_mem, lrb-&gt;is_native(), phase);</span>
1533     region-&gt;init_req(_evac_path, ctrl);
<span class="line-modified">1534     val_phi-&gt;init_req(_evac_path, fwd);</span>
1535     raw_mem_phi-&gt;init_req(_evac_path, result_mem);
1536 
1537     phase-&gt;register_control(region, loop, heap_stable_iff);
1538     Node* out_val = val_phi;
1539     phase-&gt;register_new_node(val_phi, region);
1540     phase-&gt;register_new_node(raw_mem_phi, region);
1541 
1542     fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);
1543 
1544     ctrl = orig_ctrl;
1545 
<span class="line-removed">1546     if (unc != NULL) {</span>
<span class="line-removed">1547       for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1548         Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">1549         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="line-removed">1550         if (u != lrb &amp;&amp; (c != ctrl || is_dominator_same_ctrl(c, lrb, u, phase))) {</span>
<span class="line-removed">1551           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">1552           int nb = u-&gt;replace_edge(val, out_val);</span>
<span class="line-removed">1553           --i, imax -= nb;</span>
<span class="line-removed">1554         }</span>
<span class="line-removed">1555       }</span>
<span class="line-removed">1556       if (val-&gt;outcnt() == 0) {</span>
<span class="line-removed">1557         phase-&gt;igvn()._worklist.push(val);</span>
<span class="line-removed">1558       }</span>
<span class="line-removed">1559     }</span>
1560     phase-&gt;igvn().replace_node(lrb, out_val);
1561 
1562     follow_barrier_uses(out_val, ctrl, uses, phase);
1563 
1564     for(uint next = 0; next &lt; uses.size(); next++ ) {
1565       Node *n = uses.at(next);
1566       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);
1567       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1568       phase-&gt;set_ctrl(n, region);
1569       follow_barrier_uses(n, ctrl, uses, phase);
1570     }
1571 
1572     // The slow path call produces memory: hook the raw memory phi
1573     // from the expanded load reference barrier with the rest of the graph
1574     // which may require adding memory phis at every post dominated
1575     // region and at enclosing loop heads. Use the memory state
1576     // collected in memory_nodes to fix the memory graph. Update that
1577     // memory state as we go.
1578     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);
1579   }
</pre>
<hr />
<pre>
1812   Node* load = andi-&gt;in(1);
1813 
1814   assert(is_gc_state_load(load), &quot;broken&quot;);
1815   if (!phase-&gt;is_dominator(load-&gt;in(0), entry_c)) {
1816     Node* mem_ctrl = NULL;
1817     Node* mem = dom_mem(load-&gt;in(MemNode::Memory), loop_head, Compile::AliasIdxRaw, mem_ctrl, phase);
1818     load = load-&gt;clone();
1819     load-&gt;set_req(MemNode::Memory, mem);
1820     load-&gt;set_req(0, entry_c);
1821     phase-&gt;register_new_node(load, entry_c);
1822     andi = andi-&gt;clone();
1823     andi-&gt;set_req(1, load);
1824     phase-&gt;register_new_node(andi, entry_c);
1825     cmp = cmp-&gt;clone();
1826     cmp-&gt;set_req(1, andi);
1827     phase-&gt;register_new_node(cmp, entry_c);
1828     bol = bol-&gt;clone();
1829     bol-&gt;set_req(1, cmp);
1830     phase-&gt;register_new_node(bol, entry_c);
1831 
<span class="line-removed">1832     Node* old_bol =iff-&gt;in(1);</span>
1833     phase-&gt;igvn().replace_input_of(iff, 1, bol);
1834   }
1835 }
1836 
1837 bool ShenandoahBarrierC2Support::identical_backtoback_ifs(Node* n, PhaseIdealLoop* phase) {
1838   if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
1839     return false;
1840   }
1841   Node* region = n-&gt;in(0);
1842 
1843   if (!region-&gt;is_Region()) {
1844     return false;
1845   }
1846   Node* dom = phase-&gt;idom(region);
1847   if (!dom-&gt;is_If()) {
1848     return false;
1849   }
1850 
1851   if (!is_heap_stable_test(n) || !is_heap_stable_test(dom)) {
1852     return false;
</pre>
<hr />
<pre>
2269           mem = in-&gt;in(TypeFunc::Memory);
2270         } else if (in_opc == Op_Halt) {
2271           if (in-&gt;in(0)-&gt;is_Region()) {
2272             Node* r = in-&gt;in(0);
2273             for (uint j = 1; j &lt; r-&gt;req(); j++) {
2274               assert(r-&gt;in(j)-&gt;Opcode() != Op_NeverBranch, &quot;&quot;);
2275             }
2276           } else {
2277             Node* proj = in-&gt;in(0);
2278             assert(proj-&gt;is_Proj(), &quot;&quot;);
2279             Node* in = proj-&gt;in(0);
2280             assert(in-&gt;is_CallStaticJava() || in-&gt;Opcode() == Op_NeverBranch || in-&gt;Opcode() == Op_Catch || proj-&gt;is_IfProj(), &quot;&quot;);
2281             if (in-&gt;is_CallStaticJava()) {
2282               mem = in-&gt;in(TypeFunc::Memory);
2283             } else if (in-&gt;Opcode() == Op_Catch) {
2284               Node* call = in-&gt;in(0)-&gt;in(0);
2285               assert(call-&gt;is_Call(), &quot;&quot;);
2286               mem = call-&gt;in(TypeFunc::Memory);
2287             } else if (in-&gt;Opcode() == Op_NeverBranch) {
2288               Node* head = in-&gt;in(0);
<span class="line-modified">2289               assert(head-&gt;is_Region() &amp;&amp; head-&gt;req() == 3, &quot;unexpected infinite loop graph shape&quot;);</span>
<span class="line-removed">2290               assert(_phase-&gt;is_dominator(head, head-&gt;in(1)) || _phase-&gt;is_dominator(head, head-&gt;in(2)), &quot;no back branch?&quot;);</span>
<span class="line-removed">2291               Node* tail = _phase-&gt;is_dominator(head, head-&gt;in(1)) ? head-&gt;in(1) : head-&gt;in(2);</span>
<span class="line-removed">2292               Node* c = tail;</span>
<span class="line-removed">2293               while (c != head) {</span>
<span class="line-removed">2294                 if (c-&gt;is_SafePoint() &amp;&amp; !c-&gt;is_CallLeaf()) {</span>
<span class="line-removed">2295                   mem = c-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed">2296                 }</span>
<span class="line-removed">2297                 c = _phase-&gt;idom(c);</span>
<span class="line-removed">2298               }</span>
<span class="line-removed">2299               assert(mem != NULL, &quot;should have found safepoint&quot;);</span>
2300 
2301               Node* phi_mem = NULL;
2302               for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2303                 Node* u = head-&gt;fast_out(j);
2304                 if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {
2305                   if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
2306                     assert(phi_mem == NULL || phi_mem-&gt;adr_type() == TypePtr::BOTTOM, &quot;&quot;);
2307                     phi_mem = u;
2308                   } else if (u-&gt;adr_type() == TypePtr::BOTTOM) {
2309                     assert(phi_mem == NULL || _phase-&gt;C-&gt;get_alias_index(phi_mem-&gt;adr_type()) == _alias, &quot;&quot;);
2310                     if (phi_mem == NULL) {
2311                       phi_mem = u;
2312                     }
2313                   }
2314                 }
2315               }
<span class="line-modified">2316               if (phi_mem != NULL) {</span>





















2317                 mem = phi_mem;
2318               }
2319             }
2320           }
2321         } else {
2322 #ifdef ASSERT
2323           n-&gt;dump();
2324           in-&gt;dump();
2325 #endif
2326           ShouldNotReachHere();
2327         }
2328       } else {
2329         assert(n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2330         assert(n-&gt;adr_type() == TypePtr::BOTTOM || _phase-&gt;C-&gt;get_alias_index(n-&gt;adr_type()) == _alias, &quot;&quot;);
2331         mem = n-&gt;in(i);
2332       }
2333       i++;
2334       stack.set_index(i);
2335       if (mem == NULL) {
2336         continue;
</pre>
<hr />
<pre>
2392   }
2393 #endif
2394   uint last = _phase-&gt;C-&gt;unique();
2395 
2396 #ifdef ASSERT
2397   uint8_t max_depth = 0;
2398   for (LoopTreeIterator iter(_phase-&gt;ltree_root()); !iter.done(); iter.next()) {
2399     IdealLoopTree* lpt = iter.current();
2400     max_depth = MAX2(max_depth, lpt-&gt;_nest);
2401   }
2402 #endif
2403 
2404   bool progress = true;
2405   int iteration = 0;
2406   Node_List dead_phis;
2407   while (progress) {
2408     progress = false;
2409     iteration++;
2410     assert(iteration &lt;= 2+max_depth || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;&quot;);
2411     if (trace) { tty-&gt;print_cr(&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;); }
<span class="line-modified">2412     IdealLoopTree* last_updated_ilt = NULL;</span>
2413     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
2414       Node* c = rpo_list.at(i);
2415 
2416       Node* prev_mem = _memory_nodes[c-&gt;_idx];
2417       if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
2418         Node* prev_region = regions[c-&gt;_idx];
2419         Node* unique = NULL;
2420         for (uint j = 1; j &lt; c-&gt;req() &amp;&amp; unique != NodeSentinel; j++) {
2421           Node* m = _memory_nodes[c-&gt;in(j)-&gt;_idx];
2422           assert(m != NULL || (c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl &amp;&amp; iteration == 1) || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;expect memory state&quot;);
2423           if (m != NULL) {
2424             if (m == prev_region &amp;&amp; ((c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl) || (prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c))) {
<span class="line-modified">2425               assert(c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl || _phase-&gt;C-&gt;has_irreducible_loop(), &quot;&quot;);</span>
2426               // continue
2427             } else if (unique == NULL) {
2428               unique = m;
2429             } else if (m == unique) {
2430               // continue
2431             } else {
2432               unique = NodeSentinel;
2433             }
2434           }
2435         }
2436         assert(unique != NULL, &quot;empty phi???&quot;);
2437         if (unique != NodeSentinel) {
2438           if (prev_region != NULL &amp;&amp; prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c) {
2439             dead_phis.push(prev_region);
2440           }
2441           regions.map(c-&gt;_idx, unique);
2442         } else {
2443           Node* phi = NULL;
2444           if (prev_region != NULL &amp;&amp; prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c &amp;&amp; prev_region-&gt;_idx &gt;= last) {
2445             phi = prev_region;
</pre>
<hr />
<pre>
3307         // Default to have excess barriers, rather than miss some.
3308         return false;
3309 #endif
3310       }
3311     }
3312 
3313     stack.pop();
3314     if (visit_users) {
3315       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3316         Node* user = n-&gt;fast_out(i);
3317         if (user != NULL) {
3318           stack.push(user, 0);
3319         }
3320       }
3321     }
3322   }
3323 
3324   // No need for barrier found.
3325   return true;
3326 }
<span class="line-removed">3327 </span>
<span class="line-removed">3328 CallStaticJavaNode* ShenandoahLoadReferenceBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {</span>
<span class="line-removed">3329   Node* val = in(ValueIn);</span>
<span class="line-removed">3330 </span>
<span class="line-removed">3331   const Type* val_t = igvn.type(val);</span>
<span class="line-removed">3332 </span>
<span class="line-removed">3333   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;</span>
<span class="line-removed">3334       val-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="line-removed">3335       val-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">3336       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="line-removed">3337       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="line-removed">3338       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-removed">3339       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="line-removed">3340       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-removed">3341       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-removed">3342       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;</span>
<span class="line-removed">3343       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-removed">3344     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);</span>
<span class="line-removed">3345     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-removed">3346     return unc;</span>
<span class="line-removed">3347   }</span>
<span class="line-removed">3348   return NULL;</span>
<span class="line-removed">3349 }</span>
</pre>
</td>
<td>
<hr />
<pre>
 771   mem_ctrl = phase-&gt;ctrl_or_self(mem);
 772   while (!phase-&gt;is_dominator(mem_ctrl, ctrl) || mem_ctrl == ctrl) {
 773     mem = next_mem(mem, alias);
 774     if (wq.test_set(mem-&gt;_idx)) {
 775       return NULL;
 776     }
 777     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 778   }
 779   if (mem-&gt;is_MergeMem()) {
 780     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
 781     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 782   }
 783   return mem;
 784 }
 785 
 786 Node* ShenandoahBarrierC2Support::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {
 787   Node* mem = NULL;
 788   Node* c = ctrl;
 789   do {
 790     if (c-&gt;is_Region()) {

 791       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {
 792         Node* u = c-&gt;fast_out(i);
 793         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {
 794           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
 795             mem = u;
 796           }
 797         }
 798       }
 799     } else {
 800       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {
 801         CallProjections* projs = c-&gt;as_Call()-&gt;extract_projections(true, false);
 802         if (projs-&gt;fallthrough_memproj != NULL) {
 803           if (projs-&gt;fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {
 804             if (projs-&gt;catchall_memproj == NULL) {
 805               mem = projs-&gt;fallthrough_memproj;
 806             } else {
 807               if (phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, ctrl)) {
 808                 mem = projs-&gt;fallthrough_memproj;
 809               } else {
 810                 assert(phase-&gt;is_dominator(projs-&gt;catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);
</pre>
<hr />
<pre>
 900 
 901   const Type* val_t = igvn.type(val);
 902   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {
 903     Node* null_cmp   = new CmpPNode(val, igvn.zerocon(T_OBJECT));
 904     Node* null_test  = new BoolNode(null_cmp, BoolTest::ne);
 905 
 906     IfNode* null_iff = new IfNode(old_ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
 907     ctrl             = new IfTrueNode(null_iff);
 908     null_ctrl        = new IfFalseNode(null_iff);
 909 
 910     IdealLoopTree* loop = phase-&gt;get_loop(old_ctrl);
 911     phase-&gt;register_control(null_iff,  loop, old_ctrl);
 912     phase-&gt;register_control(ctrl,      loop, null_iff);
 913     phase-&gt;register_control(null_ctrl, loop, null_iff);
 914 
 915     phase-&gt;register_new_node(null_cmp,  old_ctrl);
 916     phase-&gt;register_new_node(null_test, old_ctrl);
 917   }
 918 }
 919 






































































 920 void ShenandoahBarrierC2Support::test_in_cset(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {
 921   Node* old_ctrl = ctrl;
 922   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 923 
 924   Node* raw_val        = new CastP2XNode(old_ctrl, val);
 925   Node* cset_idx       = new URShiftXNode(raw_val, igvn.intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
 926   Node* cset_addr      = igvn.makecon(TypeRawPtr::make(ShenandoahHeap::in_cset_fast_test_addr()));
 927   Node* cset_load_addr = new AddPNode(phase-&gt;C-&gt;top(), cset_addr, cset_idx);
 928   Node* cset_load      = new LoadBNode(old_ctrl, raw_mem, cset_load_addr,
 929                                        DEBUG_ONLY(phase-&gt;C-&gt;get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),
 930                                        TypeInt::BYTE, MemNode::unordered);
 931   Node* cset_cmp       = new CmpINode(cset_load, igvn.zerocon(T_INT));
 932   Node* cset_bool      = new BoolNode(cset_cmp, BoolTest::ne);
 933 
 934   IfNode* cset_iff     = new IfNode(old_ctrl, cset_bool, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
 935   ctrl                 = new IfTrueNode(cset_iff);
 936   not_cset_ctrl        = new IfFalseNode(cset_iff);
 937 
 938   IdealLoopTree *loop = phase-&gt;get_loop(old_ctrl);
 939   phase-&gt;register_control(cset_iff,      loop, old_ctrl);
</pre>
<hr />
<pre>
1109             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1110             u-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
1111             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
1112             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
1113             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
1114             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val &amp;&amp;
1115             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
1116           IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1117           IdealLoopTree* unc_loop = phase-&gt;get_loop(u-&gt;in(0));
1118 
1119           if (!unc_loop-&gt;is_member(loop)) {
1120             continue;
1121           }
1122 
1123           Node* branch = no_branches(ctrl, u-&gt;in(0), false, phase);
1124           assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);
1125           if (branch == NodeSentinel) {
1126             continue;
1127           }
1128 
<span class="line-modified">1129           Node* iff = u-&gt;in(0)-&gt;in(0);</span>
<span class="line-modified">1130           Node* bol = iff-&gt;in(1)-&gt;clone();</span>
<span class="line-modified">1131           Node* cmp = bol-&gt;in(1)-&gt;clone();</span>
<span class="line-modified">1132           cmp-&gt;set_req(1, lrb);</span>
<span class="line-modified">1133           bol-&gt;set_req(1, cmp);</span>
<span class="line-modified">1134           phase-&gt;igvn().replace_input_of(iff, 1, bol);</span>
<span class="line-modified">1135           phase-&gt;set_ctrl(lrb, iff-&gt;in(0));</span>
<span class="line-modified">1136           phase-&gt;register_new_node(cmp, iff-&gt;in(0));</span>
<span class="line-modified">1137           phase-&gt;register_new_node(bol, iff-&gt;in(0));</span>

































































1138           break;
1139         }
1140       }
1141     }
1142     if ((ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) || ctrl-&gt;is_CallJava()) {
1143       CallNode* call = ctrl-&gt;is_Proj() ? ctrl-&gt;in(0)-&gt;as_CallJava() : ctrl-&gt;as_CallJava();
1144       if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
1145         // The rethrow call may have too many projections to be
1146         // properly handled here. Given there&#39;s no reason for a
1147         // barrier to depend on the call, move it above the call
1148         stack.push(lrb, 0);
1149         do {
1150           Node* n = stack.node();
1151           uint idx = stack.index();
1152           if (idx &lt; n-&gt;req()) {
1153             Node* in = n-&gt;in(idx);
1154             stack.set_index(idx+1);
1155             if (in != NULL) {
1156               if (phase-&gt;has_ctrl(in)) {
1157                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {
1158 #ifdef ASSERT
1159                   for (uint i = 0; i &lt; stack.size(); i++) {
1160                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);
1161                   }
1162 #endif
1163                   stack.push(in, 0);
1164                 }
1165               } else {
1166                 assert(phase-&gt;is_dominator(in, call-&gt;in(0)), &quot;no dependency on the call&quot;);
1167               }
1168             }
1169           } else {
1170             phase-&gt;set_ctrl(n, call-&gt;in(0));
1171             stack.pop();
1172           }
1173         } while(stack.size() &gt; 0);
1174         continue;
1175       }
1176       CallProjections* projs = call-&gt;extract_projections(false, false);
<span class="line-added">1177 #ifdef ASSERT</span>
<span class="line-added">1178       VectorSet cloned(Thread::current()-&gt;resource_area());</span>
<span class="line-added">1179 #endif</span>
1180       Node* lrb_clone = lrb-&gt;clone();
1181       phase-&gt;register_new_node(lrb_clone, projs-&gt;catchall_catchproj);
1182       phase-&gt;set_ctrl(lrb, projs-&gt;fallthrough_catchproj);
1183 
1184       stack.push(lrb, 0);
1185       clones.push(lrb_clone);
1186 
1187       do {
1188         assert(stack.size() == clones.size(), &quot;&quot;);
1189         Node* n = stack.node();
1190 #ifdef ASSERT
1191         if (n-&gt;is_Load()) {
1192           Node* mem = n-&gt;in(MemNode::Memory);
1193           for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1194             Node* u = mem-&gt;fast_out(j);
1195             assert(!u-&gt;is_Store() || !u-&gt;is_LoadStore() || phase-&gt;get_ctrl(u) != ctrl, &quot;anti dependent store?&quot;);
1196           }
1197         }
1198 #endif
1199         uint idx = stack.index();
1200         Node* n_clone = clones.at(clones.size()-1);
1201         if (idx &lt; n-&gt;outcnt()) {
1202           Node* u = n-&gt;raw_out(idx);
1203           Node* c = phase-&gt;ctrl_or_self(u);
1204           if (phase-&gt;is_dominator(call, c) &amp;&amp; phase-&gt;is_dominator(c, projs-&gt;fallthrough_proj)) {
1205             stack.set_index(idx+1);
1206             assert(!u-&gt;is_CFG(), &quot;&quot;);
1207             stack.push(u, 0);
<span class="line-added">1208             assert(!cloned.test_set(u-&gt;_idx), &quot;only one clone&quot;);</span>
1209             Node* u_clone = u-&gt;clone();
1210             int nb = u_clone-&gt;replace_edge(n, n_clone);
1211             assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1212             phase-&gt;register_new_node(u_clone, projs-&gt;catchall_catchproj);
1213             clones.push(u_clone);
1214             phase-&gt;set_ctrl(u, projs-&gt;fallthrough_catchproj);
1215           } else {
1216             bool replaced = false;
1217             if (u-&gt;is_Phi()) {
1218               for (uint k = 1; k &lt; u-&gt;req(); k++) {
1219                 if (u-&gt;in(k) == n) {
1220                   if (phase-&gt;is_dominator(projs-&gt;catchall_catchproj, u-&gt;in(0)-&gt;in(k))) {
1221                     phase-&gt;igvn().replace_input_of(u, k, n_clone);
1222                     replaced = true;
1223                   } else if (!phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, u-&gt;in(0)-&gt;in(k))) {
1224                     phase-&gt;igvn().replace_input_of(u, k, create_phis_on_call_return(ctrl, u-&gt;in(0)-&gt;in(k), n, n_clone, projs, phase));
1225                     replaced = true;
1226                   }
1227                 }
1228               }
1229             } else {
1230               if (phase-&gt;is_dominator(projs-&gt;catchall_catchproj, c)) {
1231                 phase-&gt;igvn().rehash_node_delayed(u);
1232                 int nb = u-&gt;replace_edge(n, n_clone);
1233                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1234                 replaced = true;
1235               } else if (!phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, c)) {
<span class="line-modified">1236                 if (u-&gt;is_If()) {</span>
<span class="line-modified">1237                   // Can&#39;t break If/Bool/Cmp chain</span>
<span class="line-modified">1238                   assert(n-&gt;is_Bool(), &quot;unexpected If shape&quot;);</span>
<span class="line-added">1239                   assert(stack.node_at(stack.size()-2)-&gt;is_Cmp(), &quot;unexpected If shape&quot;);</span>
<span class="line-added">1240                   assert(n_clone-&gt;is_Bool(), &quot;unexpected clone&quot;);</span>
<span class="line-added">1241                   assert(clones.at(clones.size()-2)-&gt;is_Cmp(), &quot;unexpected clone&quot;);</span>
<span class="line-added">1242                   Node* bol_clone = n-&gt;clone();</span>
<span class="line-added">1243                   Node* cmp_clone = stack.node_at(stack.size()-2)-&gt;clone();</span>
<span class="line-added">1244                   bol_clone-&gt;set_req(1, cmp_clone);</span>
<span class="line-added">1245 </span>
<span class="line-added">1246                   Node* nn = stack.node_at(stack.size()-3);</span>
<span class="line-added">1247                   Node* nn_clone = clones.at(clones.size()-3);</span>
<span class="line-added">1248                   assert(nn-&gt;Opcode() == nn_clone-&gt;Opcode(), &quot;mismatch&quot;);</span>
<span class="line-added">1249 </span>
<span class="line-added">1250                   int nb = cmp_clone-&gt;replace_edge(nn, create_phis_on_call_return(ctrl, c, nn, nn_clone, projs, phase));</span>
<span class="line-added">1251                   assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
<span class="line-added">1252 </span>
<span class="line-added">1253                   phase-&gt;register_new_node(bol_clone, u-&gt;in(0));</span>
<span class="line-added">1254                   phase-&gt;register_new_node(cmp_clone, u-&gt;in(0));</span>
<span class="line-added">1255 </span>
<span class="line-added">1256                   phase-&gt;igvn().replace_input_of(u, 1, bol_clone);</span>
<span class="line-added">1257 </span>
<span class="line-added">1258                 } else {</span>
<span class="line-added">1259                   phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1260                   int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));</span>
<span class="line-added">1261                   assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
<span class="line-added">1262                 }</span>
1263                 replaced = true;
1264               }
1265             }
1266             if (!replaced) {
1267               stack.set_index(idx+1);
1268             }
1269           }
1270         } else {
1271           stack.pop();
1272           clones.pop();
1273         }
1274       } while (stack.size() &gt; 0);
1275       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1276     }
1277   }
1278 
1279   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1280     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
1281     if (lrb-&gt;is_redundant()) {
1282       continue;
</pre>
<hr />
<pre>
1296   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1297   Unique_Node_List uses_to_ignore;
1298   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1299     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
1300     if (lrb-&gt;is_redundant()) {
1301       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1302       continue;
1303     }
1304     uint last = phase-&gt;C-&gt;unique();
1305     Node* ctrl = phase-&gt;get_ctrl(lrb);
1306     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1307 
1308 
1309     Node* orig_ctrl = ctrl;
1310 
1311     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1312     Node* init_raw_mem = raw_mem;
1313     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1314 
1315     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);














1316 
1317     Node* heap_stable_ctrl = NULL;
1318     Node* null_ctrl = NULL;
1319 
1320     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1321     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1322 
<span class="line-modified">1323     enum { _heap_stable = 1, _not_cset, _evac_path, PATH_LIMIT };</span>
1324     Node* region = new RegionNode(PATH_LIMIT);
<span class="line-modified">1325     Node* val_phi = new PhiNode(region, val-&gt;bottom_type()-&gt;is_oopptr());</span>
1326     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1327 
1328     // Stable path.
1329     test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::HAS_FORWARDED);
1330     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();
1331 
1332     // Heap stable case
1333     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
<span class="line-modified">1334     val_phi-&gt;init_req(_heap_stable, val);</span>
1335     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);
1336 














1337     // Test for in-cset.
1338     // Wires !in_cset(obj) to slot 2 of region and phis
1339     Node* not_cset_ctrl = NULL;
<span class="line-modified">1340     test_in_cset(ctrl, not_cset_ctrl, val, raw_mem, phase);</span>
1341     if (not_cset_ctrl != NULL) {
<span class="line-modified">1342       region-&gt;init_req(_not_cset, not_cset_ctrl);</span>

1343       val_phi-&gt;init_req(_not_cset, val);
1344       raw_mem_phi-&gt;init_req(_not_cset, raw_mem);
1345     }
1346 
1347     // Resolve object when orig-value is in cset.
1348     // Make the unconditional resolve for fwdptr.









1349 
1350     // Call lrb-stub and wire up that path in slots 4
1351     Node* result_mem = NULL;
1352 

1353     Node* addr;
1354     if (ShenandoahSelfFixing) {
1355       VectorSet visited(Thread::current()-&gt;resource_area());
1356       addr = get_load_addr(phase, visited, lrb);
1357     } else {
1358       addr = phase-&gt;igvn().zerocon(T_OBJECT);
1359     }
1360     if (addr-&gt;Opcode() == Op_AddP) {
1361       Node* orig_base = addr-&gt;in(AddPNode::Base);
1362       Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base-&gt;bottom_type(), true);
1363       phase-&gt;register_new_node(base, ctrl);
1364       if (addr-&gt;in(AddPNode::Base) == addr-&gt;in((AddPNode::Address))) {
1365         // Field access
1366         addr = addr-&gt;clone();
1367         addr-&gt;set_req(AddPNode::Base, base);
1368         addr-&gt;set_req(AddPNode::Address, base);
1369         phase-&gt;register_new_node(addr, ctrl);
1370       } else {
1371         Node* addr2 = addr-&gt;in(AddPNode::Address);
1372         if (addr2-&gt;Opcode() == Op_AddP &amp;&amp; addr2-&gt;in(AddPNode::Base) == addr2-&gt;in(AddPNode::Address) &amp;&amp;
1373               addr2-&gt;in(AddPNode::Base) == orig_base) {
1374           addr2 = addr2-&gt;clone();
1375           addr2-&gt;set_req(AddPNode::Base, base);
1376           addr2-&gt;set_req(AddPNode::Address, base);
1377           phase-&gt;register_new_node(addr2, ctrl);
1378           addr = addr-&gt;clone();
1379           addr-&gt;set_req(AddPNode::Base, base);
1380           addr-&gt;set_req(AddPNode::Address, addr2);
1381           phase-&gt;register_new_node(addr, ctrl);
1382         }
1383       }
1384     }
<span class="line-modified">1385     call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb-&gt;is_native(), phase);</span>
1386     region-&gt;init_req(_evac_path, ctrl);
<span class="line-modified">1387     val_phi-&gt;init_req(_evac_path, val);</span>
1388     raw_mem_phi-&gt;init_req(_evac_path, result_mem);
1389 
1390     phase-&gt;register_control(region, loop, heap_stable_iff);
1391     Node* out_val = val_phi;
1392     phase-&gt;register_new_node(val_phi, region);
1393     phase-&gt;register_new_node(raw_mem_phi, region);
1394 
1395     fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);
1396 
1397     ctrl = orig_ctrl;
1398 














1399     phase-&gt;igvn().replace_node(lrb, out_val);
1400 
1401     follow_barrier_uses(out_val, ctrl, uses, phase);
1402 
1403     for(uint next = 0; next &lt; uses.size(); next++ ) {
1404       Node *n = uses.at(next);
1405       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);
1406       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1407       phase-&gt;set_ctrl(n, region);
1408       follow_barrier_uses(n, ctrl, uses, phase);
1409     }
1410 
1411     // The slow path call produces memory: hook the raw memory phi
1412     // from the expanded load reference barrier with the rest of the graph
1413     // which may require adding memory phis at every post dominated
1414     // region and at enclosing loop heads. Use the memory state
1415     // collected in memory_nodes to fix the memory graph. Update that
1416     // memory state as we go.
1417     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);
1418   }
</pre>
<hr />
<pre>
1651   Node* load = andi-&gt;in(1);
1652 
1653   assert(is_gc_state_load(load), &quot;broken&quot;);
1654   if (!phase-&gt;is_dominator(load-&gt;in(0), entry_c)) {
1655     Node* mem_ctrl = NULL;
1656     Node* mem = dom_mem(load-&gt;in(MemNode::Memory), loop_head, Compile::AliasIdxRaw, mem_ctrl, phase);
1657     load = load-&gt;clone();
1658     load-&gt;set_req(MemNode::Memory, mem);
1659     load-&gt;set_req(0, entry_c);
1660     phase-&gt;register_new_node(load, entry_c);
1661     andi = andi-&gt;clone();
1662     andi-&gt;set_req(1, load);
1663     phase-&gt;register_new_node(andi, entry_c);
1664     cmp = cmp-&gt;clone();
1665     cmp-&gt;set_req(1, andi);
1666     phase-&gt;register_new_node(cmp, entry_c);
1667     bol = bol-&gt;clone();
1668     bol-&gt;set_req(1, cmp);
1669     phase-&gt;register_new_node(bol, entry_c);
1670 

1671     phase-&gt;igvn().replace_input_of(iff, 1, bol);
1672   }
1673 }
1674 
1675 bool ShenandoahBarrierC2Support::identical_backtoback_ifs(Node* n, PhaseIdealLoop* phase) {
1676   if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
1677     return false;
1678   }
1679   Node* region = n-&gt;in(0);
1680 
1681   if (!region-&gt;is_Region()) {
1682     return false;
1683   }
1684   Node* dom = phase-&gt;idom(region);
1685   if (!dom-&gt;is_If()) {
1686     return false;
1687   }
1688 
1689   if (!is_heap_stable_test(n) || !is_heap_stable_test(dom)) {
1690     return false;
</pre>
<hr />
<pre>
2107           mem = in-&gt;in(TypeFunc::Memory);
2108         } else if (in_opc == Op_Halt) {
2109           if (in-&gt;in(0)-&gt;is_Region()) {
2110             Node* r = in-&gt;in(0);
2111             for (uint j = 1; j &lt; r-&gt;req(); j++) {
2112               assert(r-&gt;in(j)-&gt;Opcode() != Op_NeverBranch, &quot;&quot;);
2113             }
2114           } else {
2115             Node* proj = in-&gt;in(0);
2116             assert(proj-&gt;is_Proj(), &quot;&quot;);
2117             Node* in = proj-&gt;in(0);
2118             assert(in-&gt;is_CallStaticJava() || in-&gt;Opcode() == Op_NeverBranch || in-&gt;Opcode() == Op_Catch || proj-&gt;is_IfProj(), &quot;&quot;);
2119             if (in-&gt;is_CallStaticJava()) {
2120               mem = in-&gt;in(TypeFunc::Memory);
2121             } else if (in-&gt;Opcode() == Op_Catch) {
2122               Node* call = in-&gt;in(0)-&gt;in(0);
2123               assert(call-&gt;is_Call(), &quot;&quot;);
2124               mem = call-&gt;in(TypeFunc::Memory);
2125             } else if (in-&gt;Opcode() == Op_NeverBranch) {
2126               Node* head = in-&gt;in(0);
<span class="line-modified">2127               assert(head-&gt;is_Region(), &quot;unexpected infinite loop graph shape&quot;);</span>










2128 
2129               Node* phi_mem = NULL;
2130               for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2131                 Node* u = head-&gt;fast_out(j);
2132                 if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {
2133                   if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
2134                     assert(phi_mem == NULL || phi_mem-&gt;adr_type() == TypePtr::BOTTOM, &quot;&quot;);
2135                     phi_mem = u;
2136                   } else if (u-&gt;adr_type() == TypePtr::BOTTOM) {
2137                     assert(phi_mem == NULL || _phase-&gt;C-&gt;get_alias_index(phi_mem-&gt;adr_type()) == _alias, &quot;&quot;);
2138                     if (phi_mem == NULL) {
2139                       phi_mem = u;
2140                     }
2141                   }
2142                 }
2143               }
<span class="line-modified">2144               if (phi_mem == NULL) {</span>
<span class="line-added">2145                 for (uint j = 1; j &lt; head-&gt;req(); j++) {</span>
<span class="line-added">2146                   Node* tail = head-&gt;in(j);</span>
<span class="line-added">2147                   if (!_phase-&gt;is_dominator(head, tail)) {</span>
<span class="line-added">2148                     continue;</span>
<span class="line-added">2149                   }</span>
<span class="line-added">2150                   Node* c = tail;</span>
<span class="line-added">2151                   while (c != head) {</span>
<span class="line-added">2152                     if (c-&gt;is_SafePoint() &amp;&amp; !c-&gt;is_CallLeaf()) {</span>
<span class="line-added">2153                       Node* m =c-&gt;in(TypeFunc::Memory);</span>
<span class="line-added">2154                       if (m-&gt;is_MergeMem()) {</span>
<span class="line-added">2155                         m = m-&gt;as_MergeMem()-&gt;memory_at(_alias);</span>
<span class="line-added">2156                       }</span>
<span class="line-added">2157                       assert(mem == NULL || mem == m, &quot;several memory states&quot;);</span>
<span class="line-added">2158                       mem = m;</span>
<span class="line-added">2159                     }</span>
<span class="line-added">2160                     c = _phase-&gt;idom(c);</span>
<span class="line-added">2161                   }</span>
<span class="line-added">2162                   assert(mem != NULL, &quot;should have found safepoint&quot;);</span>
<span class="line-added">2163                 }</span>
<span class="line-added">2164                 assert(mem != NULL, &quot;should have found safepoint&quot;);</span>
<span class="line-added">2165               } else {</span>
2166                 mem = phi_mem;
2167               }
2168             }
2169           }
2170         } else {
2171 #ifdef ASSERT
2172           n-&gt;dump();
2173           in-&gt;dump();
2174 #endif
2175           ShouldNotReachHere();
2176         }
2177       } else {
2178         assert(n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2179         assert(n-&gt;adr_type() == TypePtr::BOTTOM || _phase-&gt;C-&gt;get_alias_index(n-&gt;adr_type()) == _alias, &quot;&quot;);
2180         mem = n-&gt;in(i);
2181       }
2182       i++;
2183       stack.set_index(i);
2184       if (mem == NULL) {
2185         continue;
</pre>
<hr />
<pre>
2241   }
2242 #endif
2243   uint last = _phase-&gt;C-&gt;unique();
2244 
2245 #ifdef ASSERT
2246   uint8_t max_depth = 0;
2247   for (LoopTreeIterator iter(_phase-&gt;ltree_root()); !iter.done(); iter.next()) {
2248     IdealLoopTree* lpt = iter.current();
2249     max_depth = MAX2(max_depth, lpt-&gt;_nest);
2250   }
2251 #endif
2252 
2253   bool progress = true;
2254   int iteration = 0;
2255   Node_List dead_phis;
2256   while (progress) {
2257     progress = false;
2258     iteration++;
2259     assert(iteration &lt;= 2+max_depth || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;&quot;);
2260     if (trace) { tty-&gt;print_cr(&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;); }
<span class="line-modified">2261 </span>
2262     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
2263       Node* c = rpo_list.at(i);
2264 
2265       Node* prev_mem = _memory_nodes[c-&gt;_idx];
2266       if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
2267         Node* prev_region = regions[c-&gt;_idx];
2268         Node* unique = NULL;
2269         for (uint j = 1; j &lt; c-&gt;req() &amp;&amp; unique != NodeSentinel; j++) {
2270           Node* m = _memory_nodes[c-&gt;in(j)-&gt;_idx];
2271           assert(m != NULL || (c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl &amp;&amp; iteration == 1) || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;expect memory state&quot;);
2272           if (m != NULL) {
2273             if (m == prev_region &amp;&amp; ((c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl) || (prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c))) {
<span class="line-modified">2274               assert(c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;&quot;);</span>
2275               // continue
2276             } else if (unique == NULL) {
2277               unique = m;
2278             } else if (m == unique) {
2279               // continue
2280             } else {
2281               unique = NodeSentinel;
2282             }
2283           }
2284         }
2285         assert(unique != NULL, &quot;empty phi???&quot;);
2286         if (unique != NodeSentinel) {
2287           if (prev_region != NULL &amp;&amp; prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c) {
2288             dead_phis.push(prev_region);
2289           }
2290           regions.map(c-&gt;_idx, unique);
2291         } else {
2292           Node* phi = NULL;
2293           if (prev_region != NULL &amp;&amp; prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c &amp;&amp; prev_region-&gt;_idx &gt;= last) {
2294             phi = prev_region;
</pre>
<hr />
<pre>
3156         // Default to have excess barriers, rather than miss some.
3157         return false;
3158 #endif
3159       }
3160     }
3161 
3162     stack.pop();
3163     if (visit_users) {
3164       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3165         Node* user = n-&gt;fast_out(i);
3166         if (user != NULL) {
3167           stack.push(user, 0);
3168         }
3169       }
3170     }
3171   }
3172 
3173   // No need for barrier found.
3174   return true;
3175 }























</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../interpreter/templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
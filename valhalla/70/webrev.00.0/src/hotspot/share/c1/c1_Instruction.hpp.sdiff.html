<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_ValueMap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Instruction.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 308 
 309 class Instruction: public CompilationResourceObj {
 310  private:
 311   int          _id;                              // the unique instruction id
 312 #ifndef PRODUCT
 313   int          _printable_bci;                   // the bci of the instruction for printing
 314 #endif
 315   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 316   int          _pin_state;                       // set of PinReason describing the reason for pinning
 317   ValueType*   _type;                            // the instruction value type
 318   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 319   Instruction* _subst;                           // the substitution instruction if any
 320   LIR_Opr      _operand;                         // LIR specific information
 321   unsigned int _flags;                           // Flag bits
 322 
 323   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 324   ValueStack*  _exception_state;                 // Copy of state for exception handling
 325   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 326 
 327   friend class UseCountComputer;
<span class="line-removed"> 328   friend class BlockBegin;</span>
 329 
 330   void update_exception_state(ValueStack* state);
 331 
 332  protected:
 333   BlockBegin*  _block;                           // Block that contains this instruction
 334 
 335   void set_type(ValueType* type) {
 336     assert(type != NULL, &quot;type must exist&quot;);
 337     _type = type;
 338   }
 339 
 340   // Helper class to keep track of which arguments need a null check
 341   class ArgsNonNullState {
 342   private:
 343     int _nonnull_state; // mask identifying which args are nonnull
 344   public:
 345     ArgsNonNullState()
 346       : _nonnull_state(AllBits) {}
 347 
 348     // Does argument number i needs a null check?
</pre>
<hr />
<pre>
 354       }
 355       return true;
 356     }
 357 
 358     // Set whether argument number i needs a null check or not
 359     void set_arg_needs_null_check(int i, bool check) {
 360       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 361         if (check) {
 362           _nonnull_state |= nth_bit(i);
 363         } else {
 364           _nonnull_state &amp;= ~(nth_bit(i));
 365         }
 366       }
 367     }
 368   };
 369 
 370  public:
 371   void* operator new(size_t size) throw() {
 372     Compilation* c = Compilation::current();
 373     void* res = c-&gt;arena()-&gt;Amalloc(size);
<span class="line-removed"> 374     ((Instruction*)res)-&gt;_id = c-&gt;get_next_id();</span>
 375     return res;
 376   }
 377 
 378   static const int no_bci = -99;
 379 
 380   enum InstructionFlag {
 381     NeedsNullCheckFlag = 0,
 382     NeverNullFlag,          // For &quot;Q&quot; signatures
 383     CanTrapFlag,
 384     DirectCompareFlag,
 385     IsEliminatedFlag,
 386     IsSafepointFlag,
 387     IsStaticFlag,
 388     IsStrictfpFlag,
 389     NeedsStoreCheckFlag,
 390     NeedsWriteBarrierFlag,
 391     PreservesStateFlag,
 392     TargetIsFinalFlag,
 393     TargetIsLoadedFlag,
 394     TargetIsStrictfpFlag,
</pre>
<hr />
<pre>
 416   // Instructions may be pinned for many reasons and under certain conditions
 417   // with enough knowledge it&#39;s possible to safely unpin them.
 418   enum PinReason {
 419       PinUnknown           = 1 &lt;&lt; 0
 420     , PinExplicitNullCheck = 1 &lt;&lt; 3
 421     , PinStackForStateSplit= 1 &lt;&lt; 12
 422     , PinStateSplitConstructor= 1 &lt;&lt; 13
 423     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 424   };
 425 
 426   static Condition mirror(Condition cond);
 427   static Condition negate(Condition cond);
 428 
 429   // initialization
 430   static int number_of_instructions() {
 431     return Compilation::current()-&gt;number_of_instructions();
 432   }
 433 
 434   // creation
 435   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
<span class="line-modified"> 436   :</span>
 437 #ifndef PRODUCT
 438   _printable_bci(-99),
 439 #endif
 440     _use_count(0)
 441   , _pin_state(0)
 442   , _type(type)
 443   , _next(NULL)
 444   , _subst(NULL)
 445   , _operand(LIR_OprFact::illegalOpr)
 446   , _flags(0)
 447   , _state_before(state_before)
 448   , _exception_handlers(NULL)
 449   , _block(NULL)
 450   {
 451     check_state(state_before);
 452     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 453     update_exception_state(_state_before);
 454   }
 455 
 456   // accessors
</pre>
<hr />
<pre>
1768 
1769   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1770   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1771   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1772   ResourceBitMap _live_kill;                     // set of registers defined in this block
1773 
1774   ResourceBitMap _fpu_register_usage;
1775   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1776   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1777   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1778 
1779   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1780   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1781 
1782   friend class SuxAndWeightAdjuster;
1783 
1784  public:
1785    void* operator new(size_t size) throw() {
1786     Compilation* c = Compilation::current();
1787     void* res = c-&gt;arena()-&gt;Amalloc(size);
<span class="line-removed">1788     ((BlockBegin*)res)-&gt;_id = c-&gt;get_next_id();</span>
<span class="line-removed">1789     ((BlockBegin*)res)-&gt;_block_id = c-&gt;get_next_block_id();</span>
1790     return res;
1791   }
1792 
1793   // initialization/counting
1794   static int  number_of_blocks() {
1795     return Compilation::current()-&gt;number_of_blocks();
1796   }
1797 
1798   // creation
1799   BlockBegin(int bci)
1800   : StateSplit(illegalType)

1801   , _bci(bci)
1802   , _depth_first_number(-1)
1803   , _linear_scan_number(-1)
1804   , _dominator_depth(-1)
1805   , _loop_depth(0)
1806   , _loop_index(-1)
1807   , _flags(0)
1808   , _total_preds(0)
1809   , _stores_to_locals()
1810   , _successors(2)
1811   , _predecessors(2)
1812   , _dominates(2)
1813   , _dominator(NULL)
1814   , _end(NULL)
1815   , _exception_handlers(1)
1816   , _exception_states(NULL)
1817   , _exception_handler_pco(-1)
1818   , _lir(NULL)
1819   , _live_in()
1820   , _live_out()
</pre>
</td>
<td>
<hr />
<pre>
 308 
 309 class Instruction: public CompilationResourceObj {
 310  private:
 311   int          _id;                              // the unique instruction id
 312 #ifndef PRODUCT
 313   int          _printable_bci;                   // the bci of the instruction for printing
 314 #endif
 315   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 316   int          _pin_state;                       // set of PinReason describing the reason for pinning
 317   ValueType*   _type;                            // the instruction value type
 318   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 319   Instruction* _subst;                           // the substitution instruction if any
 320   LIR_Opr      _operand;                         // LIR specific information
 321   unsigned int _flags;                           // Flag bits
 322 
 323   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 324   ValueStack*  _exception_state;                 // Copy of state for exception handling
 325   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 326 
 327   friend class UseCountComputer;

 328 
 329   void update_exception_state(ValueStack* state);
 330 
 331  protected:
 332   BlockBegin*  _block;                           // Block that contains this instruction
 333 
 334   void set_type(ValueType* type) {
 335     assert(type != NULL, &quot;type must exist&quot;);
 336     _type = type;
 337   }
 338 
 339   // Helper class to keep track of which arguments need a null check
 340   class ArgsNonNullState {
 341   private:
 342     int _nonnull_state; // mask identifying which args are nonnull
 343   public:
 344     ArgsNonNullState()
 345       : _nonnull_state(AllBits) {}
 346 
 347     // Does argument number i needs a null check?
</pre>
<hr />
<pre>
 353       }
 354       return true;
 355     }
 356 
 357     // Set whether argument number i needs a null check or not
 358     void set_arg_needs_null_check(int i, bool check) {
 359       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 360         if (check) {
 361           _nonnull_state |= nth_bit(i);
 362         } else {
 363           _nonnull_state &amp;= ~(nth_bit(i));
 364         }
 365       }
 366     }
 367   };
 368 
 369  public:
 370   void* operator new(size_t size) throw() {
 371     Compilation* c = Compilation::current();
 372     void* res = c-&gt;arena()-&gt;Amalloc(size);

 373     return res;
 374   }
 375 
 376   static const int no_bci = -99;
 377 
 378   enum InstructionFlag {
 379     NeedsNullCheckFlag = 0,
 380     NeverNullFlag,          // For &quot;Q&quot; signatures
 381     CanTrapFlag,
 382     DirectCompareFlag,
 383     IsEliminatedFlag,
 384     IsSafepointFlag,
 385     IsStaticFlag,
 386     IsStrictfpFlag,
 387     NeedsStoreCheckFlag,
 388     NeedsWriteBarrierFlag,
 389     PreservesStateFlag,
 390     TargetIsFinalFlag,
 391     TargetIsLoadedFlag,
 392     TargetIsStrictfpFlag,
</pre>
<hr />
<pre>
 414   // Instructions may be pinned for many reasons and under certain conditions
 415   // with enough knowledge it&#39;s possible to safely unpin them.
 416   enum PinReason {
 417       PinUnknown           = 1 &lt;&lt; 0
 418     , PinExplicitNullCheck = 1 &lt;&lt; 3
 419     , PinStackForStateSplit= 1 &lt;&lt; 12
 420     , PinStateSplitConstructor= 1 &lt;&lt; 13
 421     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 422   };
 423 
 424   static Condition mirror(Condition cond);
 425   static Condition negate(Condition cond);
 426 
 427   // initialization
 428   static int number_of_instructions() {
 429     return Compilation::current()-&gt;number_of_instructions();
 430   }
 431 
 432   // creation
 433   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
<span class="line-modified"> 434   : _id(Compilation::current()-&gt;get_next_id()),</span>
 435 #ifndef PRODUCT
 436   _printable_bci(-99),
 437 #endif
 438     _use_count(0)
 439   , _pin_state(0)
 440   , _type(type)
 441   , _next(NULL)
 442   , _subst(NULL)
 443   , _operand(LIR_OprFact::illegalOpr)
 444   , _flags(0)
 445   , _state_before(state_before)
 446   , _exception_handlers(NULL)
 447   , _block(NULL)
 448   {
 449     check_state(state_before);
 450     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 451     update_exception_state(_state_before);
 452   }
 453 
 454   // accessors
</pre>
<hr />
<pre>
1766 
1767   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1768   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1769   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1770   ResourceBitMap _live_kill;                     // set of registers defined in this block
1771 
1772   ResourceBitMap _fpu_register_usage;
1773   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1774   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1775   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1776 
1777   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1778   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1779 
1780   friend class SuxAndWeightAdjuster;
1781 
1782  public:
1783    void* operator new(size_t size) throw() {
1784     Compilation* c = Compilation::current();
1785     void* res = c-&gt;arena()-&gt;Amalloc(size);


1786     return res;
1787   }
1788 
1789   // initialization/counting
1790   static int  number_of_blocks() {
1791     return Compilation::current()-&gt;number_of_blocks();
1792   }
1793 
1794   // creation
1795   BlockBegin(int bci)
1796   : StateSplit(illegalType)
<span class="line-added">1797   , _block_id(Compilation::current()-&gt;get_next_block_id())</span>
1798   , _bci(bci)
1799   , _depth_first_number(-1)
1800   , _linear_scan_number(-1)
1801   , _dominator_depth(-1)
1802   , _loop_depth(0)
1803   , _loop_index(-1)
1804   , _flags(0)
1805   , _total_preds(0)
1806   , _stores_to_locals()
1807   , _successors(2)
1808   , _predecessors(2)
1809   , _dominates(2)
1810   , _dominator(NULL)
1811   , _end(NULL)
1812   , _exception_handlers(1)
1813   , _exception_states(NULL)
1814   , _exception_handler_pco(-1)
1815   , _lir(NULL)
1816   , _live_in()
1817   , _live_out()
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_ValueMap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
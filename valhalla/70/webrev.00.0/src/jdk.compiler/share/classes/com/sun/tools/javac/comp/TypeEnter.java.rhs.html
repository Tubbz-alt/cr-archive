<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.HashSet;
  29 import java.util.Set;
  30 import java.util.function.BiConsumer;
  31 
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Lint.LintCategory;
  36 import com.sun.tools.javac.code.Scope.ImportFilter;
  37 import com.sun.tools.javac.code.Scope.NamedImportScope;
  38 import com.sun.tools.javac.code.Scope.StarImportScope;
  39 import com.sun.tools.javac.code.Scope.WriteableScope;
  40 import com.sun.tools.javac.code.Source.Feature;
  41 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  42 import com.sun.tools.javac.jvm.Target;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.util.*;
  45 import com.sun.tools.javac.util.DefinedBy.Api;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.code.Type.*;
  49 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  50 import com.sun.tools.javac.tree.JCTree.*;
  51 
  52 import static com.sun.tools.javac.code.Flags.*;
  53 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  54 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  55 import static com.sun.tools.javac.code.Kinds.Kind.*;
  56 import static com.sun.tools.javac.code.TypeTag.CLASS;
  57 import static com.sun.tools.javac.code.TypeTag.ERROR;
  58 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  59 
  60 import static com.sun.tools.javac.code.TypeTag.*;
<a name="1" id="anc1"></a>
  61 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  62 
  63 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  65 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  66 
  67 /** This is the second phase of Enter, in which classes are completed
  68  *  by resolving their headers and entering their members in the into
  69  *  the class scope. See Enter for an overall overview.
  70  *
  71  *  This class uses internal phases to process the classes. When a phase
  72  *  processes classes, the lower phases are not invoked until all classes
  73  *  pass through the current phase. Note that it is possible that upper phases
  74  *  are run due to recursive completion. The internal phases are:
  75  *  - ImportPhase: shallow pass through imports, adds information about imports
  76  *                 the NamedImportScope and StarImportScope, but avoids queries
  77  *                 about class hierarchy.
  78  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  79  *                    type parameters of the class or type argument of the supertypes.
  80  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
  81  *                 type parameters, attributing supertypes including type arguments
  82  *                 and scheduling full annotation attribution. This phase also adds
  83  *                 a synthetic default constructor if needed and synthetic &quot;this&quot; field.
  84  *  - MembersPhase: resolves headers for fields, methods and constructors in the given class.
  85  *                  Also generates synthetic enum members.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class TypeEnter implements Completer {
  93     protected static final Context.Key&lt;TypeEnter&gt; typeEnterKey = new Context.Key&lt;&gt;();
  94 
  95     /** A switch to determine whether we check for package/class conflicts
  96      */
  97     final static boolean checkClash = true;
  98 
  99     private final Names names;
 100     private final Enter enter;
 101     private final MemberEnter memberEnter;
 102     private final Log log;
 103     private final Check chk;
 104     private final Attr attr;
 105     private final Symtab syms;
 106     private final TreeMaker make;
 107     private final Todo todo;
 108     private final Annotate annotate;
 109     private final TypeAnnotations typeAnnotations;
 110     private final Types types;
 111     private final JCDiagnostic.Factory diags;
 112     private final DeferredLintHandler deferredLintHandler;
 113     private final Lint lint;
 114     private final TypeEnvs typeEnvs;
 115     private final Dependencies dependencies;
 116 
 117     public static TypeEnter instance(Context context) {
 118         TypeEnter instance = context.get(typeEnterKey);
 119         if (instance == null)
 120             instance = new TypeEnter(context);
 121         return instance;
 122     }
 123 
 124     protected TypeEnter(Context context) {
 125         context.put(typeEnterKey, this);
 126         names = Names.instance(context);
 127         enter = Enter.instance(context);
 128         memberEnter = MemberEnter.instance(context);
 129         log = Log.instance(context);
 130         chk = Check.instance(context);
 131         attr = Attr.instance(context);
 132         syms = Symtab.instance(context);
 133         make = TreeMaker.instance(context);
 134         todo = Todo.instance(context);
 135         annotate = Annotate.instance(context);
 136         typeAnnotations = TypeAnnotations.instance(context);
 137         types = Types.instance(context);
 138         diags = JCDiagnostic.Factory.instance(context);
 139         deferredLintHandler = DeferredLintHandler.instance(context);
 140         lint = Lint.instance(context);
 141         typeEnvs = TypeEnvs.instance(context);
 142         dependencies = Dependencies.instance(context);
 143         Source source = Source.instance(context);
 144         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 145         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
 146     }
 147 
 148     /** Switch: support type annotations.
 149      */
 150     boolean allowTypeAnnos;
 151 
 152     /**
 153      * Switch: should deprecation warnings be issued on import
 154      */
 155     boolean allowDeprecationOnImport;
 156 
 157     /** A flag to disable completion from time to time during member
 158      *  enter, as we only need to look up types.  This avoids
 159      *  unnecessarily deep recursion.
 160      */
 161     boolean completionEnabled = true;
 162 
 163     /* Verify Imports:
 164      */
 165     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 166         // if there remain any unimported toplevels (these must have
 167         // no classes at all), process their import statements as well.
 168         for (JCCompilationUnit tree : trees) {
 169             if (!tree.starImportScope.isFilled()) {
 170                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 171                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 172             }
 173         }
 174     }
 175 
 176 /* ********************************************************************
 177  * Source completer
 178  *********************************************************************/
 179 
 180     /** Complete entering a class.
 181      *  @param sym         The symbol of the class to be completed.
 182      */
 183     @Override
 184     public void complete(Symbol sym) throws CompletionFailure {
 185         // Suppress some (recursive) MemberEnter invocations
 186         if (!completionEnabled) {
 187             // Re-install same completer for next time around and return.
 188             Assert.check((sym.flags() &amp; Flags.COMPOUND) == 0);
 189             sym.completer = this;
 190             return;
 191         }
 192 
 193         try {
 194             annotate.blockAnnotations();
 195             sym.flags_field |= UNATTRIBUTED;
 196 
 197             List&lt;Env&lt;AttrContext&gt;&gt; queue;
 198 
 199             dependencies.push((ClassSymbol) sym, CompletionCause.MEMBER_ENTER);
 200             try {
 201                 queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));
 202             } finally {
 203                 dependencies.pop();
 204             }
 205 
 206             if (!queue.isEmpty()) {
 207                 Set&lt;JCCompilationUnit&gt; seen = new HashSet&lt;&gt;();
 208 
 209                 for (Env&lt;AttrContext&gt; env : queue) {
 210                     if (env.toplevel.defs.contains(env.enclClass) &amp;&amp; seen.add(env.toplevel)) {
 211                         finishImports(env.toplevel, () -&gt; {});
 212                     }
 213                 }
 214             }
 215         } finally {
 216             annotate.unblockAnnotations();
 217         }
 218     }
 219 
 220     void finishImports(JCCompilationUnit toplevel, Runnable resolve) {
 221         JavaFileObject prev = log.useSource(toplevel.sourcefile);
 222         try {
 223             resolve.run();
 224             chk.checkImportsUnique(toplevel);
 225             chk.checkImportsResolvable(toplevel);
 226             chk.checkImportedPackagesObservable(toplevel);
 227             toplevel.namedImportScope.finalizeScope();
 228             toplevel.starImportScope.finalizeScope();
 229         } catch (CompletionFailure cf) {
 230             chk.completionError(toplevel.pos(), cf);
 231         } finally {
 232             log.useSource(prev);
 233         }
 234     }
 235 
 236     abstract class Phase {
 237         private final ListBuffer&lt;Env&lt;AttrContext&gt;&gt; queue = new ListBuffer&lt;&gt;();
 238         private final Phase next;
 239         private final CompletionCause phaseName;
 240 
 241         Phase(CompletionCause phaseName, Phase next) {
 242             this.phaseName = phaseName;
 243             this.next = next;
 244         }
 245 
 246         public final List&lt;Env&lt;AttrContext&gt;&gt; completeEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 247             boolean firstToComplete = queue.isEmpty();
 248 
 249             Phase prevTopLevelPhase = topLevelPhase;
 250             boolean success = false;
 251 
 252             try {
 253                 topLevelPhase = this;
 254                 doCompleteEnvs(envs);
 255                 success = true;
 256             } finally {
 257                 topLevelPhase = prevTopLevelPhase;
 258                 if (!success &amp;&amp; firstToComplete) {
 259                     //an exception was thrown, e.g. BreakAttr:
 260                     //the queue would become stale, clear it:
 261                     queue.clear();
 262                 }
 263             }
 264 
 265             if (firstToComplete) {
 266                 List&lt;Env&lt;AttrContext&gt;&gt; out = queue.toList();
 267 
 268                 queue.clear();
 269                 return next != null ? next.completeEnvs(out) : out;
 270             } else {
 271                 return List.nil();
 272             }
 273         }
 274 
 275         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 276             for (Env&lt;AttrContext&gt; env : envs) {
 277                 JCClassDecl tree = (JCClassDecl)env.tree;
 278 
 279                 queue.add(env);
 280 
 281                 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 282                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
 283                 try {
 284                     dependencies.push(env.enclClass.sym, phaseName);
 285                     runPhase(env);
 286                 } catch (CompletionFailure ex) {
 287                     chk.completionError(tree.pos(), ex);
 288                 } finally {
 289                     dependencies.pop();
 290                     deferredLintHandler.setPos(prevLintPos);
 291                     log.useSource(prev);
 292                 }
 293             }
 294         }
 295 
 296         protected abstract void runPhase(Env&lt;AttrContext&gt; env);
 297     }
 298 
 299     private final ImportsPhase completeClass = new ImportsPhase();
 300     private Phase topLevelPhase;
 301 
 302     /**Analyze import clauses.
 303      */
 304     private final class ImportsPhase extends Phase {
 305 
 306         public ImportsPhase() {
 307             super(CompletionCause.IMPORTS_PHASE, new HierarchyPhase());
 308         }
 309 
 310         Env&lt;AttrContext&gt; env;
 311         ImportFilter staticImportFilter;
 312         ImportFilter typeImportFilter;
 313         BiConsumer&lt;JCImport, CompletionFailure&gt; cfHandler =
 314                 (imp, cf) -&gt; chk.completionError(imp.pos(), cf);
 315 
 316         @Override
 317         protected void runPhase(Env&lt;AttrContext&gt; env) {
 318             JCClassDecl tree = env.enclClass;
 319             ClassSymbol sym = tree.sym;
 320 
 321             // If sym is a toplevel-class, make sure any import
 322             // clauses in its source file have been seen.
 323             if (sym.owner.kind == PCK) {
 324                 resolveImports(env.toplevel, env.enclosing(TOPLEVEL));
 325                 todo.append(env);
 326             }
 327 
 328             if (sym.owner.kind == TYP)
 329                 sym.owner.complete();
 330         }
 331 
 332         private void resolveImports(JCCompilationUnit tree, Env&lt;AttrContext&gt; env) {
 333             if (tree.starImportScope.isFilled()) {
 334                 // we must have already processed this toplevel
 335                 return;
 336             }
 337 
 338             ImportFilter prevStaticImportFilter = staticImportFilter;
 339             ImportFilter prevTypeImportFilter = typeImportFilter;
 340             DiagnosticPosition prevLintPos = deferredLintHandler.immediate();
 341             Lint prevLint = chk.setLint(lint);
 342             Env&lt;AttrContext&gt; prevEnv = this.env;
 343             try {
 344                 this.env = env;
 345                 final PackageSymbol packge = env.toplevel.packge;
 346                 this.staticImportFilter =
 347                         (origin, sym) -&gt; sym.isStatic() &amp;&amp;
 348                                          chk.importAccessible(sym, packge) &amp;&amp;
 349                                          sym.isMemberOf((TypeSymbol) origin.owner, types);
 350                 this.typeImportFilter =
 351                         (origin, sym) -&gt; sym.kind == TYP &amp;&amp;
 352                                          chk.importAccessible(sym, packge);
 353 
 354                 // Import-on-demand java.lang.
 355                 PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);
 356                 if (javaLang.members().isEmpty() &amp;&amp; !javaLang.exists())
 357                     throw new FatalError(diags.fragment(Fragments.FatalErrNoJavaLang));
 358                 importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);
 359 
 360                 JCModuleDecl decl = tree.getModuleDecl();
 361 
 362                 // Process the package def and all import clauses.
 363                 if (tree.getPackage() != null &amp;&amp; decl == null)
 364                     checkClassPackageClash(tree.getPackage());
 365 
 366                 for (JCImport imp : tree.getImports()) {
 367                     doImport(imp);
 368                 }
 369 
 370                 if (decl != null) {
 371                     //check @Deprecated:
 372                     markDeprecated(decl.sym, decl.mods.annotations, env);
 373                     // process module annotations
 374                     annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, null);
 375                 }
 376             } finally {
 377                 this.env = prevEnv;
 378                 chk.setLint(prevLint);
 379                 deferredLintHandler.setPos(prevLintPos);
 380                 this.staticImportFilter = prevStaticImportFilter;
 381                 this.typeImportFilter = prevTypeImportFilter;
 382             }
 383         }
 384 
 385         private void checkClassPackageClash(JCPackageDecl tree) {
 386             // check that no class exists with same fully qualified name as
 387             // toplevel package
 388             if (checkClash &amp;&amp; tree.pid != null) {
 389                 Symbol p = env.toplevel.packge;
 390                 while (p.owner != syms.rootPackage) {
 391                     p.owner.complete(); // enter all class members of p
 392                     //need to lookup the owning module/package:
 393                     PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, p.owner.getQualifiedName());
 394                     if (syms.getClass(pack.modle, p.getQualifiedName()) != null) {
 395                         log.error(tree.pos,
 396                                   Errors.PkgClashesWithClassOfSameName(p));
 397                     }
 398                     p = p.owner;
 399                 }
 400             }
 401             // process package annotations
 402             annotate.annotateLater(tree.annotations, env, env.toplevel.packge, null);
 403         }
 404 
 405         private void doImport(JCImport tree) {
 406             JCFieldAccess imp = (JCFieldAccess)tree.qualid;
 407             Name name = TreeInfo.name(imp);
 408 
 409             // Create a local environment pointing to this tree to disable
 410             // effects of other imports in Resolve.findGlobalType
 411             Env&lt;AttrContext&gt; localEnv = env.dup(tree);
 412 
 413             TypeSymbol p = attr.attribImportQualifier(tree, localEnv).tsym;
 414             if (name == names.asterisk) {
 415                 // Import on demand.
 416                 chk.checkCanonical(imp.selected);
 417                 if (tree.staticImport)
 418                     importStaticAll(tree, p, env);
 419                 else
 420                     importAll(tree, p, env);
 421             } else {
 422                 // Named type import.
 423                 if (tree.staticImport) {
 424                     importNamedStatic(tree, p, name, localEnv);
 425                     chk.checkCanonical(imp.selected);
 426                 } else {
 427                     Type importedType = attribImportType(imp, localEnv);
 428                     Type originalType = importedType.getOriginalType();
 429                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 430                     chk.checkCanonical(imp);
 431                     importNamed(tree.pos(), c, env, tree);
 432                 }
 433             }
 434         }
 435 
 436         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 437             Assert.check(completionEnabled);
 438             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
 439                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));
 440             try {
 441                 // To prevent deep recursion, suppress completion of some
 442                 // types.
 443                 completionEnabled = false;
 444                 return attr.attribType(tree, env);
 445             } finally {
 446                 completionEnabled = true;
 447                 chk.setLint(prevLint);
 448             }
 449         }
 450 
 451         /** Import all classes of a class or package on demand.
 452          *  @param imp           The import that is being handled.
 453          *  @param tsym          The class or package the members of which are imported.
 454          *  @param env           The env in which the imported classes will be entered.
 455          */
 456         private void importAll(JCImport imp,
 457                                final TypeSymbol tsym,
 458                                Env&lt;AttrContext&gt; env) {
 459             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
 460         }
 461 
 462         /** Import all static members of a class or package on demand.
 463          *  @param imp           The import that is being handled.
 464          *  @param tsym          The class or package the members of which are imported.
 465          *  @param env           The env in which the imported classes will be entered.
 466          */
 467         private void importStaticAll(JCImport imp,
 468                                      final TypeSymbol tsym,
 469                                      Env&lt;AttrContext&gt; env) {
 470             final StarImportScope toScope = env.toplevel.starImportScope;
 471             final TypeSymbol origin = tsym;
 472 
 473             toScope.importAll(types, origin.members(), staticImportFilter, imp, cfHandler);
 474         }
 475 
 476         /** Import statics types of a given name.  Non-types are handled in Attr.
 477          *  @param imp           The import that is being handled.
 478          *  @param tsym          The class from which the name is imported.
 479          *  @param name          The (simple) name being imported.
 480          *  @param env           The environment containing the named import
 481          *                  scope to add to.
 482          */
 483         private void importNamedStatic(final JCImport imp,
 484                                        final TypeSymbol tsym,
 485                                        final Name name,
 486                                        final Env&lt;AttrContext&gt; env) {
 487             if (tsym.kind != TYP) {
 488                 log.error(DiagnosticFlag.RECOVERABLE, imp.pos(), Errors.StaticImpOnlyClassesAndInterfaces);
 489                 return;
 490             }
 491 
 492             final NamedImportScope toScope = env.toplevel.namedImportScope;
 493             final Scope originMembers = tsym.members();
 494 
 495             imp.importScope = toScope.importByName(types, originMembers, name, staticImportFilter, imp, cfHandler);
 496         }
 497 
 498         /** Import given class.
 499          *  @param pos           Position to be used for error reporting.
 500          *  @param tsym          The class to be imported.
 501          *  @param env           The environment containing the named import
 502          *                  scope to add to.
 503          */
 504         private void importNamed(DiagnosticPosition pos, final Symbol tsym, Env&lt;AttrContext&gt; env, JCImport imp) {
 505             if (tsym.kind == TYP)
 506                 imp.importScope = env.toplevel.namedImportScope.importType(tsym.owner.members(), tsym.owner.members(), tsym);
 507         }
 508 
 509     }
 510 
 511     /**Defines common utility methods used by the HierarchyPhase and HeaderPhase.
 512      */
 513     private abstract class AbstractHeaderPhase extends Phase {
 514 
 515         public AbstractHeaderPhase(CompletionCause phaseName, Phase next) {
 516             super(phaseName, next);
 517         }
 518 
 519         protected Env&lt;AttrContext&gt; baseEnv(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 520             WriteableScope baseScope = WriteableScope.create(tree.sym);
 521             //import already entered local classes into base scope
 522             for (Symbol sym : env.outer.info.scope.getSymbols(NON_RECURSIVE)) {
 523                 if (sym.isLocal()) {
 524                     baseScope.enter(sym);
 525                 }
 526             }
 527             //import current type-parameters into base scope
 528             if (tree.typarams != null)
 529                 for (List&lt;JCTypeParameter&gt; typarams = tree.typarams;
 530                      typarams.nonEmpty();
 531                      typarams = typarams.tail)
 532                     baseScope.enter(typarams.head.type.tsym);
 533             Env&lt;AttrContext&gt; outer = env.outer; // the base clause can&#39;t see members of this class
 534             Env&lt;AttrContext&gt; localEnv = outer.dup(tree, outer.info.dup(baseScope));
 535             localEnv.baseClause = true;
 536             localEnv.outer = outer;
 537             localEnv.info.isSelfCall = false;
 538             return localEnv;
 539         }
 540 
 541         /** Generate a base clause for an enum type.
 542          *  @param pos              The position for trees and diagnostics, if any
 543          *  @param c                The class symbol of the enum
 544          */
 545         protected  JCExpression enumBase(int pos, ClassSymbol c) {
 546             JCExpression result = make.at(pos).
 547                 TypeApply(make.QualIdent(syms.enumSym),
 548                           List.of(make.Type(c.type)));
 549             return result;
 550         }
 551 
 552         protected Type modelMissingTypes(Env&lt;AttrContext&gt; env, Type t, final JCExpression tree, final boolean interfaceExpected) {
 553             if (!t.hasTag(ERROR))
 554                 return t;
 555 
 556             return new ErrorType(t.getOriginalType(), t.tsym) {
 557                 private Type modelType;
 558 
 559                 @Override
 560                 public Type getModelType() {
 561                     if (modelType == null)
 562                         modelType = new Synthesizer(env.toplevel.modle, getOriginalType(), interfaceExpected).visit(tree);
 563                     return modelType;
 564                 }
 565             };
 566         }
 567             // where:
 568             private class Synthesizer extends JCTree.Visitor {
 569                 ModuleSymbol msym;
 570                 Type originalType;
 571                 boolean interfaceExpected;
 572                 List&lt;ClassSymbol&gt; synthesizedSymbols = List.nil();
 573                 Type result;
 574 
 575                 Synthesizer(ModuleSymbol msym, Type originalType, boolean interfaceExpected) {
 576                     this.msym = msym;
 577                     this.originalType = originalType;
 578                     this.interfaceExpected = interfaceExpected;
 579                 }
 580 
 581                 Type visit(JCTree tree) {
 582                     tree.accept(this);
 583                     return result;
 584                 }
 585 
 586                 List&lt;Type&gt; visit(List&lt;? extends JCTree&gt; trees) {
 587                     ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 588                     for (JCTree t: trees)
 589                         lb.append(visit(t));
 590                     return lb.toList();
 591                 }
 592 
 593                 @Override
 594                 public void visitTree(JCTree tree) {
 595                     result = syms.errType;
 596                 }
 597 
 598                 @Override
 599                 public void visitIdent(JCIdent tree) {
 600                     if (!tree.type.hasTag(ERROR)) {
 601                         result = tree.type;
 602                     } else {
 603                         result = synthesizeClass(tree.name, msym.unnamedPackage).type;
 604                     }
 605                 }
 606 
 607                 @Override
 608                 public void visitSelect(JCFieldAccess tree) {
 609                     if (!tree.type.hasTag(ERROR)) {
 610                         result = tree.type;
 611                     } else {
 612                         Type selectedType;
 613                         boolean prev = interfaceExpected;
 614                         try {
 615                             interfaceExpected = false;
 616                             selectedType = visit(tree.selected);
 617                         } finally {
 618                             interfaceExpected = prev;
 619                         }
 620                         ClassSymbol c = synthesizeClass(tree.name, selectedType.tsym);
 621                         result = c.type;
 622                     }
 623                 }
 624 
 625                 @Override
 626                 public void visitTypeApply(JCTypeApply tree) {
 627                     if (!tree.type.hasTag(ERROR)) {
 628                         result = tree.type;
 629                     } else {
 630                         ClassType clazzType = (ClassType) visit(tree.clazz);
 631                         if (synthesizedSymbols.contains(clazzType.tsym))
 632                             synthesizeTyparams((ClassSymbol) clazzType.tsym, tree.arguments.size());
 633                         final List&lt;Type&gt; actuals = visit(tree.arguments);
 634                         result = new ErrorType(tree.type, clazzType.tsym) {
 635                             @Override @DefinedBy(Api.LANGUAGE_MODEL)
 636                             public List&lt;Type&gt; getTypeArguments() {
 637                                 return actuals;
 638                             }
 639                         };
 640                     }
 641                 }
 642 
 643                 ClassSymbol synthesizeClass(Name name, Symbol owner) {
 644                     int flags = interfaceExpected ? INTERFACE : 0;
 645                     ClassSymbol c = new ClassSymbol(flags, name, owner);
 646                     c.members_field = new Scope.ErrorScope(c);
 647                     c.type = new ErrorType(originalType, c) {
 648                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 649                         public List&lt;Type&gt; getTypeArguments() {
 650                             return typarams_field;
 651                         }
 652                     };
 653                     synthesizedSymbols = synthesizedSymbols.prepend(c);
 654                     return c;
 655                 }
 656 
 657                 void synthesizeTyparams(ClassSymbol sym, int n) {
 658                     ClassType ct = (ClassType) sym.type;
 659                     Assert.check(ct.typarams_field.isEmpty());
 660                     if (n == 1) {
 661                         TypeVar v = new TypeVar(names.fromString(&quot;T&quot;), sym, syms.botType);
 662                         ct.typarams_field = ct.typarams_field.prepend(v);
 663                     } else {
 664                         for (int i = n; i &gt; 0; i--) {
 665                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 666                                                     syms.botType);
 667                             ct.typarams_field = ct.typarams_field.prepend(v);
 668                         }
 669                     }
 670                 }
 671             }
 672 
 673         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 674             JCClassDecl tree = env.enclClass;
 675             ClassSymbol sym = tree.sym;
 676             ClassType ct = (ClassType)sym.type;
 677             // Determine supertype.
 678             Type supertype;
 679             JCExpression extending;
 680             final boolean isValueType = (tree.mods.flags &amp; Flags.VALUE) != 0;
 681 
 682             if (tree.extending != null) {
 683                 extending = clearTypeParams(tree.extending);
 684                 supertype = attr.attribBase(extending, baseEnv, true, false, true);
 685                 if (supertype == syms.recordType) {
 686                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));
 687                 }
 688             } else {
 689                 extending = null;
 690                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 691                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 692                                   true, false, false)
 693                 : (sym.fullname == names.java_lang_Object)
 694                 ? Type.noType
 695                 : sym.isRecord() ? syms.recordType : syms.objectType;
 696             }
 697             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 698 
 699             // Determine interfaces.
 700             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 701             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 702             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 703             for (JCExpression iface : interfaceTrees) {
 704                 iface = clearTypeParams(iface);
 705                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
 706                 if (it.hasTag(CLASS)) {
 707                     interfaces.append(it);
 708                     if (all_interfaces != null) all_interfaces.append(it);
 709                 } else {
 710                     if (all_interfaces == null)
 711                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 712                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 713                 }
 714             }
 715 
 716             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 717                 ct.interfaces_field = List.of(syms.annotationType);
 718                 ct.all_interfaces_field = ct.interfaces_field;
 719             }  else {
 720                 ct.interfaces_field = interfaces.toList();
 721                 ct.all_interfaces_field = (all_interfaces == null)
 722                         ? ct.interfaces_field : all_interfaces.toList();
 723             }
 724             if (ct.isValue()) {
 725                 ClassSymbol cSym = (ClassSymbol) ct.tsym;
 726                 if (cSym.projection != null) {
 727                     ClassType projectedType = (ClassType) cSym.projection.type;
 728                     projectedType.supertype_field = ct.supertype_field;
 729                     projectedType.interfaces_field = ct.interfaces_field;
 730                     projectedType.all_interfaces_field = ct.all_interfaces_field;
 731                 }
 732             }
 733         }
 734             //where:
 735             protected JCExpression clearTypeParams(JCExpression superType) {
 736                 return superType;
 737             }
 738     }
 739 
 740     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 741 
 742         public HierarchyPhase() {
 743             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 744         }
 745 
 746         @Override
 747         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 748             //The ClassSymbols in the envs list may not be in the dependency order.
 749             //To get proper results, for every class or interface C, the supertypes of
 750             //C must be processed by the HierarchyPhase phase before C.
 751             //To achieve that, the HierarchyPhase is registered as the Completer for
 752             //all the classes first, and then all the classes are completed.
 753             for (Env&lt;AttrContext&gt; env : envs) {
 754                 env.enclClass.sym.completer = this;
 755             }
 756             for (Env&lt;AttrContext&gt; env : envs) {
 757                 env.enclClass.sym.complete();
 758             }
 759         }
 760 
 761         @Override
 762         protected void runPhase(Env&lt;AttrContext&gt; env) {
 763             JCClassDecl tree = env.enclClass;
 764             ClassSymbol sym = tree.sym;
 765             ClassType ct = (ClassType)sym.type;
 766 
 767             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 768 
 769             attribSuperTypes(env, baseEnv);
 770 
 771             if (sym.fullname == names.java_lang_Object) {
 772                 if (tree.extending != null) {
 773                     chk.checkNonCyclic(tree.extending.pos(),
 774                                        ct.supertype_field);
 775                     ct.supertype_field = Type.noType;
 776                 }
 777                 else if (tree.implementing.nonEmpty()) {
 778                     chk.checkNonCyclic(tree.implementing.head.pos(),
 779                                        ct.interfaces_field.head);
 780                     ct.interfaces_field = List.nil();
 781                 }
 782             }
 783 
 784             markDeprecated(sym, tree.mods.annotations, baseEnv);
 785 
 786             chk.checkNonCyclicDecl(tree);
 787         }
 788             //where:
 789             @Override
 790             protected JCExpression clearTypeParams(JCExpression superType) {
 791                 switch (superType.getTag()) {
 792                     case TYPEAPPLY:
 793                         return ((JCTypeApply) superType).clazz;
 794                 }
 795 
 796                 return superType;
 797             }
 798 
 799         @Override
 800         public void complete(Symbol sym) throws CompletionFailure {
 801             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 802                          (topLevelPhase == this));
 803 
 804             if (topLevelPhase != this) {
 805                 //only do the processing based on dependencies in the HierarchyPhase:
 806                 sym.completer = this;
 807                 return ;
 808             }
 809 
 810             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 811 
 812             super.doCompleteEnvs(List.of(env));
 813         }
 814 
 815     }
 816 
 817     private final class HeaderPhase extends AbstractHeaderPhase {
 818 
 819         public HeaderPhase() {
 820             super(CompletionCause.HEADER_PHASE, new RecordPhase());
 821         }
 822 
 823         @Override
 824         protected void runPhase(Env&lt;AttrContext&gt; env) {
 825             JCClassDecl tree = env.enclClass;
 826             ClassSymbol sym = tree.sym;
 827             ClassType ct = (ClassType)sym.type;
 828 
 829             // create an environment for evaluating the base clauses
 830             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 831 
 832             if (tree.extending != null)
 833                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 834             for (JCExpression impl : tree.implementing)
 835                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 836             annotate.flush();
 837 
 838             attribSuperTypes(env, baseEnv);
 839 
 840             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
 841 
 842             for (JCExpression iface : tree.implementing) {
 843                 Type it = iface.type;
 844                 if (it.hasTag(CLASS))
 845                     chk.checkNotRepeated(iface.pos(), types.erasure(it), interfaceSet);
 846             }
 847 
 848             annotate.annotateLater(tree.mods.annotations, baseEnv,
 849                         sym, tree.pos());
 850             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 851 
 852             for (JCTypeParameter tp : tree.typarams)
 853                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 854 
 855             // check that no package exists with same fully qualified name,
 856             // but admit classes in the unnamed package which have the same
 857             // name as a top-level package.
 858             if (checkClash &amp;&amp;
 859                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 860                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 861                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 862             }
 863             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 864                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 865                 sym.flags_field |= AUXILIARY;
 866             }
 867         }
 868     }
 869 
 870     private abstract class AbstractMembersPhase extends Phase {
 871 
 872         public AbstractMembersPhase(CompletionCause completionCause, Phase next) {
 873             super(completionCause, next);
 874         }
 875 
 876         private boolean completing;
 877         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 878 
 879         @Override
 880         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 881             todo = todo.prependList(envs);
 882             if (completing) {
 883                 return ; //the top-level invocation will handle all envs
 884             }
 885             boolean prevCompleting = completing;
 886             completing = true;
 887             try {
 888                 while (todo.nonEmpty()) {
 889                     Env&lt;AttrContext&gt; head = todo.head;
 890                     todo = todo.tail;
 891                     super.doCompleteEnvs(List.of(head));
 892                 }
 893             } finally {
 894                 completing = prevCompleting;
 895             }
 896         }
 897 
 898         void enterThisAndSuper(ClassSymbol sym, Env&lt;AttrContext&gt; env) {
 899             ClassType ct = (ClassType)sym.type;
 900             // enter symbols for &#39;this&#39; into current scope.
 901             VarSymbol thisSym =
 902                     new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);
 903             thisSym.pos = Position.FIRSTPOS;
 904             env.info.scope.enter(thisSym);
 905             // if this is a class, enter symbol for &#39;super&#39; into current scope.
 906             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
 907                     ct.supertype_field.hasTag(CLASS)) {
 908                 VarSymbol superSym =
 909                         new VarSymbol(FINAL | HASINIT, names._super,
 910                                 ct.supertype_field, sym);
 911                 superSym.pos = Position.FIRSTPOS;
 912                 env.info.scope.enter(superSym);
 913             }
 914         }
 915     }
 916 
 917     private final class RecordPhase extends AbstractMembersPhase {
 918 
 919         public RecordPhase() {
 920             super(CompletionCause.RECORD_PHASE, new MembersPhase());
 921         }
 922 
 923         @Override
 924         protected void runPhase(Env&lt;AttrContext&gt; env) {
 925             JCClassDecl tree = env.enclClass;
 926             ClassSymbol sym = tree.sym;
 927             if ((sym.flags_field &amp; RECORD) != 0) {
 928                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
 929                 memberEnter.memberEnter(fields, env);
 930                 for (JCVariableDecl field : fields) {
 931                     sym.getRecordComponent(field, true,
 932                             field.mods.annotations.isEmpty() ?
 933                                     List.nil() :
 934                                     new TreeCopier&lt;JCTree&gt;(make.at(field.pos)).copy(field.mods.annotations));
 935                 }
 936 
 937                 enterThisAndSuper(sym, env);
 938 
 939                 // lets enter all constructors
 940                 for (JCTree def : tree.defs) {
 941                     if (TreeInfo.isConstructor(def)) {
 942                         memberEnter.memberEnter(def, env);
 943                     }
 944                 }
 945             }
 946         }
 947     }
 948 
 949     /** Enter member fields and methods of a class
 950      */
 951     private final class MembersPhase extends AbstractMembersPhase {
 952 
 953         public MembersPhase() {
 954             super(CompletionCause.MEMBERS_PHASE, null);
 955         }
 956 
 957         @Override
 958         protected void runPhase(Env&lt;AttrContext&gt; env) {
 959             JCClassDecl tree = env.enclClass;
 960             ClassSymbol sym = tree.sym;
 961             ClassType ct = (ClassType)sym.type;
 962 
 963             // Add default constructor if needed.
 964             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);
 965             if (helper != null) {
 966                 JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);
 967                 tree.defs = tree.defs.prepend(constrDef);
 968             }
 969             if (!sym.isRecord()) {
 970                 enterThisAndSuper(sym, env);
 971             }
 972 
 973             if (!tree.typarams.isEmpty()) {
 974                 for (JCTypeParameter tvar : tree.typarams) {
 975                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
 976                 }
 977             }
 978 
 979             finishClass(tree, env);
 980 
 981             if (allowTypeAnnos) {
 982                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 983                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 984             }
 985         }
 986 
 987         DefaultConstructorHelper getDefaultConstructorHelper(Env&lt;AttrContext&gt; env) {
 988             JCClassDecl tree = env.enclClass;
 989             ClassSymbol sym = tree.sym;
 990             DefaultConstructorHelper helper = null;
 991             boolean isClassWithoutInit = (sym.flags() &amp; INTERFACE) == 0 &amp;&amp; !TreeInfo.hasConstructors(tree.defs);
 992             boolean isRecord = sym.isRecord();
 993             if (isClassWithoutInit &amp;&amp; !isRecord) {
 994                 helper = new BasicConstructorHelper(sym);
 995                 if (sym.name.isEmpty()) {
 996                     JCNewClass nc = (JCNewClass)env.next.tree;
 997                     if (nc.constructor != null) {
 998                         if (nc.constructor.kind != ERR) {
 999                             helper = new AnonClassConstructorHelper(sym, (MethodSymbol)nc.constructor, nc.encl);
1000                         } else {
1001                             helper = null;
1002                         }
1003                     }
1004                 }
1005             }
1006             if (isRecord) {
1007                 JCMethodDecl canonicalInit = null;
1008                 if (isClassWithoutInit || (canonicalInit = getCanonicalConstructorDecl(env.enclClass)) == null) {
1009                     helper = new RecordConstructorHelper(sym, TreeInfo.recordFields(tree));
1010                 }
1011                 if (canonicalInit != null) {
1012                     canonicalInit.sym.flags_field |= Flags.RECORD;
1013                 }
1014             }
1015             return helper;
1016         }
1017 
1018         /** Enter members for a class.
1019          */
1020         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1021             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
1022                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
1023                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
1024                 addEnumMembers(tree, env);
1025             }
1026             boolean isRecord = (tree.sym.flags_field &amp; RECORD) != 0;
1027             List&lt;JCTree&gt; alreadyEntered = null;
1028             if (isRecord) {
1029                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));
1030                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()
1031                         .filter(t -&gt; TreeInfo.isConstructor(t) &amp;&amp;
1032                                 ((JCMethodDecl)t).sym != null &amp;&amp;
1033                                 (((JCMethodDecl)t).sym.flags_field &amp; Flags.GENERATEDCONSTR) == 0).collect(List.collector()));
1034             }
1035             List&lt;JCTree&gt; defsToEnter = isRecord ?
1036                     tree.defs.diff(alreadyEntered) : tree.defs;
1037             memberEnter.memberEnter(defsToEnter, env);
<a name="2" id="anc2"></a>
1038             if (isRecord) {
1039                 addRecordMembersIfNeeded(tree, env);
1040             }
1041             if ((tree.mods.flags &amp; (Flags.VALUE | Flags.INTERFACE)) == Flags.VALUE &amp;&amp; !tree.sym.type.hasTag(ERROR)) {
1042                 addValueMembers(tree, env);
1043             }
1044             if (tree.sym.isAnnotationType()) {
1045                 Assert.check(tree.sym.isCompleted());
1046                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1047             }
1048         }
1049 
1050         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {
1051             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());
1052             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);
1053             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {
1054                 /* here we are pushing the annotations present in the corresponding field down to the accessor
1055                  * it could be that some of those annotations are not applicable to the accessor, they will be striped
1056                  * away later at Check::validateAnnotation
1057                  */
1058                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos().isEmpty() ?
1059                         rec.getOriginalAnnos() :
1060                         new TreeCopier&lt;JCTree&gt;(make.at(tree.pos)).copy(rec.getOriginalAnnos());
1061                 JCMethodDecl getter = make.at(tree.pos).
1062                         MethodDef(
<a name="3" id="anc3"></a><span class="line-modified">1063                                 make.Modifiers(PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),</span>
1064                           tree.sym.name,
1065                           /* we need to special case for the case when the user declared the type as an ident
1066                            * if we don&#39;t do that then we can have issues if type annotations are applied to the
1067                            * return type: javac issues an error if a type annotation is applied to java.lang.String
1068                            * but applying a type annotation to String is kosher
1069                            */
1070                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),
1071                           List.nil(),
1072                           List.nil(),
1073                           List.nil(), // thrown
1074                           null,
1075                           null);
1076                 memberEnter.memberEnter(getter, env);
1077                 rec.accessor = getter.sym;
1078                 rec.accessorMeth = getter;
1079             } else if (implSym != null) {
1080                 rec.accessor = implSym;
1081             }
1082         }
1083 
1084         /** Add the implicit members for an enum type
1085          *  to the symbol table.
1086          */
1087         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1088             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
1089 
1090             JCMethodDecl values = make.
1091                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1092                           names.values,
1093                           valuesType,
1094                           List.nil(),
1095                           List.nil(),
1096                           List.nil(),
1097                           null,
1098                           null);
1099             memberEnter.memberEnter(values, env);
1100 
1101             JCMethodDecl valueOf = make.
1102                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1103                           names.valueOf,
1104                           make.Type(tree.sym.type),
1105                           List.nil(),
1106                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
1107                                                              Flags.MANDATED),
1108                                                 names.fromString(&quot;name&quot;),
1109                                                 make.Type(syms.stringType), null)),
1110                           List.nil(),
1111                           null,
1112                           null);
1113             memberEnter.memberEnter(valueOf, env);
1114         }
1115 
1116         /** Add the implicit members for a value type to the parse tree and the symbol table.
1117          */
1118         private void addValueMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1119 
1120             boolean requireHashCode = true, requireEquals = true, requireToString = true;
1121 
1122             for (JCTree def : tree.defs) {
1123                 if (def.getTag() == METHODDEF) {
1124                     JCMethodDecl methodDecl = (JCMethodDecl)def;
1125                     if (methodDecl.sym != null
1126                             &amp;&amp; methodDecl.sym.type != null
1127                             &amp;&amp; !methodDecl.sym.type.isErroneous()
1128                             &amp;&amp; (methodDecl.sym.flags() &amp; STATIC) == 0) {
1129                         final List&lt;Type&gt; parameterTypes = methodDecl.sym.type.getParameterTypes();
1130                         switch (parameterTypes.size()) {
1131                             case 0:
1132                                 String name = methodDecl.name.toString();
1133                                 if (name.equals(&quot;hashCode&quot;))
1134                                     requireHashCode = false;
1135                                 else if (name.equals(&quot;toString&quot;))
1136                                     requireToString = false;
1137                                 break;
1138                             case 1:
1139                                 name = methodDecl.name.toString();
1140                                 if (name.equals(&quot;equals&quot;) &amp;&amp; parameterTypes.head.tsym == syms.objectType.tsym)
1141                                     requireEquals = false;
1142                                 break;
1143                         }
1144                     }
1145                 }
1146             }
1147 
1148             make.at(tree.pos);
1149             // Make a body comprising { throw new RuntimeException(&quot;&quot;Internal error: This method must have been replaced by javac&quot;); }
1150             JCBlock body = make.Block(Flags.SYNTHETIC, List.of(make.Throw(
1151                     make.NewClass(null,
1152                             null,
1153                             make.Ident(names.fromString(&quot;RuntimeException&quot;)),
1154                             List.of(make.Literal(CLASS, &quot;Internal error: This method must have been replaced by javac&quot;)),
1155                             null))));
1156 
1157             if (requireHashCode) {
1158                 // public int hashCode() { throw new RuntimeException(message); }
1159                 JCMethodDecl hashCode = make.
1160                         MethodDef(make.Modifiers(Flags.PUBLIC | Flags.FINAL),
1161                                 names.hashCode,
1162                                 make.TypeIdent(TypeTag.INT),
1163                                 List.nil(),
1164                                 List.nil(),
1165                                 List.nil(), // thrown
1166                                 body,
1167                                 null);
1168                 memberEnter.memberEnter(hashCode, env);
1169                 tree.defs = tree.defs.append(hashCode);
1170             }
1171 
1172             if (requireEquals) {
1173                 // public boolean equals(Object o) { throw new RuntimeException(message); }
1174                 JCMethodDecl equals = make.
1175                         MethodDef(make.Modifiers(Flags.PUBLIC | Flags.FINAL),
1176                                 names.equals,
1177                                 make.TypeIdent(TypeTag.BOOLEAN),
1178                                 List.nil(),
1179                                 List.of(make.VarDef(make.Modifiers(PARAMETER), names.fromString(&quot;o&quot;), make.Ident(names.fromString(&quot;Object&quot;)), null )),
1180                                 List.nil(), // thrown
1181                                 body,
1182                                 null);
1183                 memberEnter.memberEnter(equals, env);
1184                 tree.defs = tree.defs.append(equals);
1185             }
1186 
1187             if (requireToString) {
1188                 // public String toString() { throw new RuntimeException(message); }
1189                 JCMethodDecl toString = make.
1190                         MethodDef(make.Modifiers(Flags.PUBLIC | Flags.FINAL),
1191                                 names.toString,
1192                                 make.Ident(names.fromString(&quot;String&quot;)),
1193                                 List.nil(),
1194                                 List.nil(),
1195                                 List.nil(), // thrown
1196                                 body,
1197                                 null);
1198                 memberEnter.memberEnter(toString, env);
1199                 tree.defs = tree.defs.append(toString);
1200             }
1201 
1202         }
1203 
1204         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {
1205             // let&#39;s check if there is a constructor with exactly the same arguments as the record components
1206             List&lt;Type&gt; recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -&gt; vd.sym.type));
1207             JCMethodDecl canonicalDecl = null;
1208             for (JCTree def : tree.defs) {
1209                 if (TreeInfo.isConstructor(def)) {
1210                     JCMethodDecl mdecl = (JCMethodDecl)def;
1211                     if (types.isSameTypes(types.erasure(mdecl.params.stream().map(v -&gt; v.sym.type).collect(List.collector())), recordComponentErasedTypes)) {
1212                         canonicalDecl = mdecl;
1213                         break;
1214                     }
1215                 }
1216             }
1217             return canonicalDecl;
1218         }
1219 
1220         /** Add the implicit members for a record
1221          *  to the symbol table.
1222          */
1223         private void addRecordMembersIfNeeded(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1224             if (lookupMethod(tree.sym, names.toString, List.nil()) == null) {
1225                 JCMethodDecl toString = make.
<a name="4" id="anc4"></a><span class="line-modified">1226                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),</span>
1227                               names.toString,
1228                               make.Type(syms.stringType),
1229                               List.nil(),
1230                               List.nil(),
1231                               List.nil(),
1232                               null,
1233                               null);
1234                 memberEnter.memberEnter(toString, env);
1235             }
1236 
1237             if (lookupMethod(tree.sym, names.hashCode, List.nil()) == null) {
1238                 JCMethodDecl hashCode = make.
1239                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1240                               names.hashCode,
1241                               make.Type(syms.intType),
1242                               List.nil(),
1243                               List.nil(),
1244                               List.nil(),
1245                               null,
1246                               null);
1247                 memberEnter.memberEnter(hashCode, env);
1248             }
1249 
1250             if (lookupMethod(tree.sym, names.equals, List.of(syms.objectType)) == null) {
1251                 JCMethodDecl equals = make.
1252                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1253                               names.equals,
1254                               make.Type(syms.booleanType),
1255                               List.nil(),
1256                               List.of(make.VarDef(make.Modifiers(Flags.PARAMETER),
1257                                                 names.fromString(&quot;o&quot;),
1258                                                 make.Type(syms.objectType), null)),
1259                               List.nil(),
1260                               null,
1261                               null);
1262                 memberEnter.memberEnter(equals, env);
1263             }
1264 
1265             // fields can&#39;t be varargs, lets remove the flag
1266             List&lt;JCVariableDecl&gt; recordFields = TreeInfo.recordFields(tree);
1267             for (JCVariableDecl field: recordFields) {
1268                 field.mods.flags &amp;= ~Flags.VARARGS;
1269                 field.sym.flags_field &amp;= ~Flags.VARARGS;
1270             }
1271             // now lets add the accessors
1272             recordFields.stream()
1273                     .filter(vd -&gt; (lookupMethod(syms.objectType.tsym, vd.name, List.nil()) == null))
1274                     .forEach(vd -&gt; addAccessor(vd, env));
1275         }
1276     }
1277 
1278     private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List&lt;Type&gt; argtypes) {
1279         for (Symbol s : tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1280             if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {
1281                 return (MethodSymbol) s;
1282             }
1283         }
1284         return null;
1285     }
1286 
1287 /* ***************************************************************************
1288  * tree building
1289  ****************************************************************************/
1290 
1291     interface DefaultConstructorHelper {
1292        Type constructorType();
1293        MethodSymbol constructorSymbol();
1294        Type enclosingType();
1295        TypeSymbol owner();
1296        List&lt;Name&gt; superArgs();
1297        default JCMethodDecl finalAdjustment(JCMethodDecl md) { return md; }
1298     }
1299 
1300     class BasicConstructorHelper implements DefaultConstructorHelper {
1301 
1302         TypeSymbol owner;
1303         Type constructorType;
1304         MethodSymbol constructorSymbol;
1305 
1306         BasicConstructorHelper(TypeSymbol owner) {
1307             this.owner = owner;
1308         }
1309 
1310         @Override
1311         public Type constructorType() {
1312             if (constructorType == null) {
1313                 constructorType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);
1314             }
1315             return constructorType;
1316         }
1317 
1318         @Override
1319         public MethodSymbol constructorSymbol() {
1320             if (constructorSymbol == null) {
1321                 long flags;
1322                 if ((owner().flags() &amp; ENUM) != 0 &amp;&amp;
1323                     (types.supertype(owner().type).tsym == syms.enumSym)) {
1324                     // constructors of true enums are private
1325                     flags = PRIVATE | GENERATEDCONSTR;
<a name="5" id="anc5"></a>


1326                 } else {
1327                     flags = (owner().flags() &amp; AccessFlags) | GENERATEDCONSTR;
1328                 }
1329                 constructorSymbol = new MethodSymbol(flags, names.init,
1330                     constructorType(), owner());
1331             }
1332             return constructorSymbol;
1333         }
1334 
1335         @Override
1336         public Type enclosingType() {
1337             return Type.noType;
1338     }
1339 
1340         @Override
1341         public TypeSymbol owner() {
1342             return owner;
1343         }
1344 
1345         @Override
1346         public List&lt;Name&gt; superArgs() {
1347             return List.nil();
1348             }
1349     }
1350 
1351     class AnonClassConstructorHelper extends BasicConstructorHelper {
1352 
1353         MethodSymbol constr;
1354         Type encl;
1355         boolean based = false;
1356 
1357         AnonClassConstructorHelper(TypeSymbol owner, MethodSymbol constr, JCExpression encl) {
1358             super(owner);
1359             this.constr = constr;
1360             this.encl = encl != null ? encl.type : Type.noType;
1361         }
1362 
1363         @Override
1364         public Type constructorType() {
1365             if (constructorType == null) {
1366                 Type ctype = types.memberType(owner.type, constr);
1367                 if (!enclosingType().hasTag(NONE)) {
1368                     ctype = types.createMethodTypeWithParameters(ctype, ctype.getParameterTypes().prepend(enclosingType()));
1369                     based = true;
1370                 }
1371                 constructorType = ctype;
1372             }
1373             return constructorType;
1374         }
1375 
1376         @Override
1377         public MethodSymbol constructorSymbol() {
1378             MethodSymbol csym = super.constructorSymbol();
1379             csym.flags_field |= ANONCONSTR | (constr.flags() &amp; VARARGS);
1380             csym.flags_field |= based ? ANONCONSTR_BASED : 0;
1381             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1382             List&lt;Type&gt; argtypes = constructorType().getParameterTypes();
1383             if (!enclosingType().hasTag(NONE)) {
1384                 argtypes = argtypes.tail;
1385                 params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));
1386             }
1387             if (constr.params != null) {
1388                 for (VarSymbol p : constr.params) {
1389                     params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));
1390                     argtypes = argtypes.tail;
1391                 }
1392             }
1393             csym.params = params.toList();
1394             return csym;
1395         }
1396 
1397         @Override
1398         public Type enclosingType() {
1399             return encl;
1400         }
1401 
1402         @Override
1403         public List&lt;Name&gt; superArgs() {
1404             List&lt;JCVariableDecl&gt; params = make.Params(constructorType().getParameterTypes(), constructorSymbol());
1405             if (!enclosingType().hasTag(NONE)) {
1406                 params = params.tail;
1407             }
1408             return params.map(vd -&gt; vd.name);
1409         }
1410     }
1411 
1412     class RecordConstructorHelper extends BasicConstructorHelper {
<a name="6" id="anc6"></a><span class="line-modified">1413         boolean lastIsVarargs;</span>

1414         List&lt;JCVariableDecl&gt; recordFieldDecls;
1415 
<a name="7" id="anc7"></a><span class="line-modified">1416         RecordConstructorHelper(ClassSymbol owner, List&lt;JCVariableDecl&gt; recordFieldDecls) {</span>
1417             super(owner);
1418             this.recordFieldDecls = recordFieldDecls;
<a name="8" id="anc8"></a><span class="line-modified">1419             this.lastIsVarargs = owner.getRecordComponents().stream().anyMatch(rc -&gt; rc.isVarargs());</span>
1420         }
1421 
1422         @Override
1423         public Type constructorType() {
1424             if (constructorType == null) {
<a name="9" id="anc9"></a><span class="line-modified">1425                 ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">1426                 JCVariableDecl lastField = recordFieldDecls.last();</span>
<span class="line-added">1427                 for (JCVariableDecl field : recordFieldDecls) {</span>
<span class="line-added">1428                     argtypes.add(field == lastField &amp;&amp; lastIsVarargs ? types.elemtype(field.sym.type) : field.sym.type);</span>
<span class="line-added">1429                 }</span>
<span class="line-added">1430 </span>
<span class="line-added">1431                 constructorType = new MethodType(argtypes.toList(), syms.voidType, List.nil(), syms.methodClass);</span>
1432             }
1433             return constructorType;
1434         }
1435 
1436         @Override
1437         public MethodSymbol constructorSymbol() {
1438             MethodSymbol csym = super.constructorSymbol();
1439             /* if we have to generate a default constructor for records we will treat it as the compact one
1440              * to trigger field initialization later on
1441              */
1442             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;
1443             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
<a name="10" id="anc10"></a><span class="line-modified">1444             JCVariableDecl lastField = recordFieldDecls.last();</span>
<span class="line-modified">1445             for (JCVariableDecl field : recordFieldDecls) {</span>
<span class="line-added">1446                 params.add(new VarSymbol(</span>
<span class="line-added">1447                         GENERATED_MEMBER | PARAMETER | RECORD | (field == lastField &amp;&amp; lastIsVarargs ? Flags.VARARGS : 0),</span>
<span class="line-added">1448                         field.name, field.sym.type, csym));</span>
1449             }
1450             csym.params = params.toList();
<a name="11" id="anc11"></a><span class="line-modified">1451             csym.flags_field |= RECORD;</span>
1452             return csym;
1453         }
1454 
1455         @Override
1456         public JCMethodDecl finalAdjustment(JCMethodDecl md) {
1457             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;
1458             for (JCVariableDecl arg : md.params) {
1459                 /* at this point we are passing all the annotations in the field to the corresponding
1460                  * parameter in the constructor.
1461                  */
1462                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);
1463                 arg.mods.annotations = rc.getOriginalAnnos().isEmpty() ?
1464                         List.nil() :
1465                         new TreeCopier&lt;JCTree&gt;(make.at(arg.pos)).copy(rc.getOriginalAnnos());
1466                 arg.vartype = tmpRecordFieldDecls.head.vartype;
1467                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;
1468             }
1469             return md;
1470         }
1471     }
1472 
1473     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {
1474         Type initType = helper.constructorType();
1475         MethodSymbol initSym = helper.constructorSymbol();
1476         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1477         if (helper.owner().type != syms.objectType) {
1478             JCExpression meth;
1479             if (!helper.enclosingType().hasTag(NONE)) {
1480                 meth = make.Select(make.Ident(initSym.params.head), names._super);
1481             } else {
1482                 meth = make.Ident(names._super);
1483             }
1484             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?
1485                     make.Types(initType.getTypeArguments()) : null;
1486             JCStatement superCall = make.Exec(make.Apply(typeargs, meth, helper.superArgs().map(make::Ident)));
1487             stats.add(superCall);
1488         }
1489         JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));
1490         return helper.finalAdjustment(result);
1491     }
1492 
1493     /**
1494      * Mark sym deprecated if annotations contain @Deprecated annotation.
1495      */
1496     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1497         // In general, we cannot fully process annotations yet,  but we
1498         // can attribute the annotation types and then check to see if the
1499         // @Deprecated annotation is present.
1500         attr.attribAnnotationTypes(annotations, env);
1501         handleDeprecatedAnnotations(annotations, sym);
1502     }
1503 
1504     /**
1505      * If a list of annotations contains a reference to java.lang.Deprecated,
1506      * set the DEPRECATED flag.
1507      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1508      **/
1509     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1510         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1511             JCAnnotation a = al.head;
1512             if (a.annotationType.type == syms.deprecatedType) {
1513                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
1514                 setFlagIfAttributeTrue(a, sym, names.forRemoval, DEPRECATED_REMOVAL);
1515             } else if (a.annotationType.type == syms.previewFeatureType) {
1516                 sym.flags_field |= Flags.PREVIEW_API;
1517                 setFlagIfAttributeTrue(a, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1518             }
1519         }
1520     }
1521     //where:
1522         private void setFlagIfAttributeTrue(JCAnnotation a, Symbol sym, Name attribute, long flag) {
1523             a.args.stream()
1524                     .filter(e -&gt; e.hasTag(ASSIGN))
1525                     .map(e -&gt; (JCAssign) e)
1526                     .filter(assign -&gt; TreeInfo.name(assign.lhs) == attribute)
1527                     .findFirst()
1528                     .ifPresent(assign -&gt; {
1529                         JCExpression rhs = TreeInfo.skipParens(assign.rhs);
1530                         if (rhs.hasTag(LITERAL)
1531                                 &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {
1532                             sym.flags_field |= flag;
1533                         }
1534                     });
1535         }
1536 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
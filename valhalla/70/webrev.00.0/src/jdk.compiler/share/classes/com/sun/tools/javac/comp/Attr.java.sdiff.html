<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 273         } else {
 274             owntype = shouldCheck ?
 275             resultInfo.check(tree, found) :
 276             found;
 277         }
 278         if (resultInfo.checkMode.updateTreeType()) {
 279             tree.type = owntype;
 280         }
 281         return owntype;
 282     }
 283 
 284     /** Is given blank final variable assignable, i.e. in a scope where it
 285      *  may be assigned to even though it is final?
 286      *  @param v      The blank final variable.
 287      *  @param env    The current environment.
 288      */
 289     boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {
 290         Symbol owner = env.info.scope.owner;
 291            // owner refers to the innermost variable, method or
 292            // initializer block declaration at this point.
<span class="line-modified"> 293         return</span>
 294             v.owner == owner
 295             ||
 296             ((owner.name == names.init ||    // i.e. we are in a constructor
 297               owner.kind == VAR ||           // i.e. we are in a variable initializer
 298               (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
 299              &amp;&amp;
 300              v.owner == owner.owner
 301              &amp;&amp;
 302              ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));


 303     }
 304 
 305     /** Check that variable can be assigned to.
 306      *  @param pos    The current source code position.
 307      *  @param v      The assigned variable
 308      *  @param base   If the variable is referred to in a Select, the part
 309      *                to the left of the `.&#39;, null otherwise.
 310      *  @param env    The current environment.
 311      */
 312     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 313         if (v.name == names._this) {
 314             log.error(pos, Errors.CantAssignValToThis);
 315         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 316             ((v.flags() &amp; HASINIT) != 0
 317              ||
 318              !((base == null ||
 319                TreeInfo.isThisQualifier(base)) &amp;&amp;
 320                isAssignableAsBlankFinal(v, env)))) {
 321             if (v.isResourceVariable()) { //TWR resource
 322                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
</pre>
<hr />
<pre>
1090                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));
1091                     }
1092                     if (tree.sym.isStatic()) {
1093                         log.error(tree,
1094                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));
1095                     }
1096                 }
1097 
1098                 if (tree.name == names.init) {
1099                     // if this a constructor other than the canonical one
1100                     if ((tree.sym.flags_field &amp; RECORD) == 0) {
1101                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1102                         if (app == null ||
1103                                 TreeInfo.name(app.meth) != names._this ||
1104                                 !checkFirstConstructorStat(app, tree, false)) {
1105                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);
1106                         }
1107                     } else {
1108                         // but if it is the canonical:
1109 
<span class="line-modified">1110                         // if user generated, then it shouldn&#39;t explicitly invoke any other constructor</span>



1111                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {
















1112                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1113                             if (app != null &amp;&amp;
1114                                     (TreeInfo.name(app.meth) == names._this ||
1115                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;
1116                                     checkFirstConstructorStat(app, tree, false)) {
1117                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
<span class="line-modified">1118                                         Fragments.Canonical, tree.sym.name,</span>
1119                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));
1120                             }
1121                         }
1122 
1123                         // also we want to check that no type variables have been defined
1124                         if (!tree.typarams.isEmpty()) {
1125                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
<span class="line-modified">1126                                     Fragments.Canonical, tree.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));</span>
1127                         }
1128 
1129                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the
1130                          * record components
1131                          */
<span class="line-modified">1132                         List&lt;Type&gt; recordComponentTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);</span>

1133                         for (JCVariableDecl param: tree.params) {
<span class="line-modified">1134                             if (!types.isSameType(param.type, recordComponentTypes.head)) {</span>


1135                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(
<span class="line-modified">1136                                         Fragments.Canonical, tree.sym.name, Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));</span>

1137                             }
<span class="line-modified">1138                             recordComponentTypes = recordComponentTypes.tail;</span>

1139                         }
1140                     }
1141                 }
1142             }
1143 
1144             // annotation method checks
1145             if ((owner.flags() &amp; ANNOTATION) != 0) {
1146                 // annotation method cannot have throws clause
1147                 if (tree.thrown.nonEmpty()) {
1148                     log.error(tree.thrown.head.pos(),
1149                               Errors.ThrowsNotAllowedInIntfAnnotation);
1150                 }
1151                 // annotation method cannot declare type-parameters
1152                 if (tree.typarams.nonEmpty()) {
1153                     log.error(tree.typarams.head.pos(),
1154                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1155                 }
1156                 // validate annotation method&#39;s return type (could be an annotation type)
1157                 chk.validateAnnotationType(tree.restype);
1158                 // ensure that annotation method does not clash with members of Object/Annotation
</pre>
<hr />
<pre>
1192                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1193                                 make.Ident(names._super), make.Idents(List.nil())));
1194                         body.stats = body.stats.prepend(supCall);
1195                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1196                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1197                             TreeInfo.isSuperCall(body.stats.head)) {
1198                         // enum constructors are not allowed to call super
1199                         // directly, so make sure there aren&#39;t any super calls
1200                         // in enum constructors, except in the compiler
1201                         // generated one.
1202                         log.error(tree.body.stats.head.pos(),
1203                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1204                     }
1205                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1206                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1207                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1208                         if (!initParamNames.equals(recordComponentNames)) {
1209                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1210                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1211                         }
<span class="line-removed">1212                         if (!tree.sym.isPublic()) {</span>
<span class="line-removed">1213                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-removed">1214                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,</span>
<span class="line-removed">1215                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));</span>
<span class="line-removed">1216                         }</span>
1217                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1218                             log.error(tree,
1219                                     Errors.InvalidCanonicalConstructorInRecord(
1220                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1221                                             env.enclClass.sym.name,
1222                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1223                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1224                         }
1225                     }
1226                 }
1227                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {
1228                     if ((owner.type == syms.objectType) ||
1229                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {
1230                         m.flags_field |= EMPTYNOARGCONSTR;
1231                     }
1232                 }
1233 
1234                 // Attribute all type annotations in the body
1235                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1236                 annotate.flush();
</pre>
</td>
<td>
<hr />
<pre>
 273         } else {
 274             owntype = shouldCheck ?
 275             resultInfo.check(tree, found) :
 276             found;
 277         }
 278         if (resultInfo.checkMode.updateTreeType()) {
 279             tree.type = owntype;
 280         }
 281         return owntype;
 282     }
 283 
 284     /** Is given blank final variable assignable, i.e. in a scope where it
 285      *  may be assigned to even though it is final?
 286      *  @param v      The blank final variable.
 287      *  @param env    The current environment.
 288      */
 289     boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {
 290         Symbol owner = env.info.scope.owner;
 291            // owner refers to the innermost variable, method or
 292            // initializer block declaration at this point.
<span class="line-modified"> 293         boolean isAssignable =</span>
 294             v.owner == owner
 295             ||
 296             ((owner.name == names.init ||    // i.e. we are in a constructor
 297               owner.kind == VAR ||           // i.e. we are in a variable initializer
 298               (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
 299              &amp;&amp;
 300              v.owner == owner.owner
 301              &amp;&amp;
 302              ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));
<span class="line-added"> 303         boolean insideCompactConstructor = env.enclMethod != null &amp;&amp; TreeInfo.isCompactConstructor(env.enclMethod);</span>
<span class="line-added"> 304         return isAssignable &amp; !insideCompactConstructor;</span>
 305     }
 306 
 307     /** Check that variable can be assigned to.
 308      *  @param pos    The current source code position.
 309      *  @param v      The assigned variable
 310      *  @param base   If the variable is referred to in a Select, the part
 311      *                to the left of the `.&#39;, null otherwise.
 312      *  @param env    The current environment.
 313      */
 314     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 315         if (v.name == names._this) {
 316             log.error(pos, Errors.CantAssignValToThis);
 317         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 318             ((v.flags() &amp; HASINIT) != 0
 319              ||
 320              !((base == null ||
 321                TreeInfo.isThisQualifier(base)) &amp;&amp;
 322                isAssignableAsBlankFinal(v, env)))) {
 323             if (v.isResourceVariable()) { //TWR resource
 324                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
</pre>
<hr />
<pre>
1092                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));
1093                     }
1094                     if (tree.sym.isStatic()) {
1095                         log.error(tree,
1096                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));
1097                     }
1098                 }
1099 
1100                 if (tree.name == names.init) {
1101                     // if this a constructor other than the canonical one
1102                     if ((tree.sym.flags_field &amp; RECORD) == 0) {
1103                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1104                         if (app == null ||
1105                                 TreeInfo.name(app.meth) != names._this ||
1106                                 !checkFirstConstructorStat(app, tree, false)) {
1107                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);
1108                         }
1109                     } else {
1110                         // but if it is the canonical:
1111 
<span class="line-modified">1112                         /* if user generated, then it shouldn&#39;t:</span>
<span class="line-added">1113                          *     - have an accessibility stricter than that of the record type</span>
<span class="line-added">1114                          *     - explicitly invoke any other constructor</span>
<span class="line-added">1115                          */</span>
1116                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {
<span class="line-added">1117                             if (Check.protection(m.flags()) &gt; Check.protection(env.enclClass.sym.flags())) {</span>
<span class="line-added">1118                                 log.error(tree,</span>
<span class="line-added">1119                                         (env.enclClass.sym.flags() &amp; AccessFlags) == 0 ?</span>
<span class="line-added">1120                                             Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">1121                                                 Fragments.Canonical,</span>
<span class="line-added">1122                                                 env.enclClass.sym.name,</span>
<span class="line-added">1123                                                 Fragments.CanonicalMustNotHaveStrongerAccess(&quot;package&quot;)</span>
<span class="line-added">1124                                             ) :</span>
<span class="line-added">1125                                             Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">1126                                                     Fragments.Canonical,</span>
<span class="line-added">1127                                                     env.enclClass.sym.name,</span>
<span class="line-added">1128                                                     Fragments.CanonicalMustNotHaveStrongerAccess(asFlagSet(env.enclClass.sym.flags() &amp; AccessFlags))</span>
<span class="line-added">1129                                             )</span>
<span class="line-added">1130                                 );</span>
<span class="line-added">1131                             }</span>
<span class="line-added">1132 </span>
1133                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1134                             if (app != null &amp;&amp;
1135                                     (TreeInfo.name(app.meth) == names._this ||
1136                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;
1137                                     checkFirstConstructorStat(app, tree, false)) {
1138                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
<span class="line-modified">1139                                         Fragments.Canonical, env.enclClass.sym.name,</span>
1140                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));
1141                             }
1142                         }
1143 
1144                         // also we want to check that no type variables have been defined
1145                         if (!tree.typarams.isEmpty()) {
1146                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
<span class="line-modified">1147                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));</span>
1148                         }
1149 
1150                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the
1151                          * record components
1152                          */
<span class="line-modified">1153                         List&lt;? extends RecordComponent&gt; recordComponents = env.enclClass.sym.getRecordComponents();</span>
<span class="line-added">1154                         List&lt;Type&gt; recordFieldTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);</span>
1155                         for (JCVariableDecl param: tree.params) {
<span class="line-modified">1156                             boolean paramIsVarArgs = (param.sym.flags_field &amp; VARARGS) != 0;</span>
<span class="line-added">1157                             if (!types.isSameType(param.type, recordFieldTypes.head) ||</span>
<span class="line-added">1158                                     (recordComponents.head.isVarargs() != paramIsVarArgs)) {</span>
1159                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(
<span class="line-modified">1160                                         Fragments.Canonical, env.enclClass.sym.name,</span>
<span class="line-added">1161                                         Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));</span>
1162                             }
<span class="line-modified">1163                             recordComponents = recordComponents.tail;</span>
<span class="line-added">1164                             recordFieldTypes = recordFieldTypes.tail;</span>
1165                         }
1166                     }
1167                 }
1168             }
1169 
1170             // annotation method checks
1171             if ((owner.flags() &amp; ANNOTATION) != 0) {
1172                 // annotation method cannot have throws clause
1173                 if (tree.thrown.nonEmpty()) {
1174                     log.error(tree.thrown.head.pos(),
1175                               Errors.ThrowsNotAllowedInIntfAnnotation);
1176                 }
1177                 // annotation method cannot declare type-parameters
1178                 if (tree.typarams.nonEmpty()) {
1179                     log.error(tree.typarams.head.pos(),
1180                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1181                 }
1182                 // validate annotation method&#39;s return type (could be an annotation type)
1183                 chk.validateAnnotationType(tree.restype);
1184                 // ensure that annotation method does not clash with members of Object/Annotation
</pre>
<hr />
<pre>
1218                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1219                                 make.Ident(names._super), make.Idents(List.nil())));
1220                         body.stats = body.stats.prepend(supCall);
1221                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1222                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1223                             TreeInfo.isSuperCall(body.stats.head)) {
1224                         // enum constructors are not allowed to call super
1225                         // directly, so make sure there aren&#39;t any super calls
1226                         // in enum constructors, except in the compiler
1227                         // generated one.
1228                         log.error(tree.body.stats.head.pos(),
1229                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1230                     }
1231                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1232                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1233                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1234                         if (!initParamNames.equals(recordComponentNames)) {
1235                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1236                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1237                         }





1238                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1239                             log.error(tree,
1240                                     Errors.InvalidCanonicalConstructorInRecord(
1241                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1242                                             env.enclClass.sym.name,
1243                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1244                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1245                         }
1246                     }
1247                 }
1248                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {
1249                     if ((owner.type == syms.objectType) ||
1250                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {
1251                         m.flags_field |= EMPTYNOARGCONSTR;
1252                     }
1253                 }
1254 
1255                 // Attribute all type annotations in the body
1256                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1257                 annotate.flush();
</pre>
</td>
</tr>
</table>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
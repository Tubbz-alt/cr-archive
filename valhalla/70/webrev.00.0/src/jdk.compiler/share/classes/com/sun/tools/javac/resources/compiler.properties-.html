<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 #
   5 # This code is free software; you can redistribute it and/or modify it
   6 # under the terms of the GNU General Public License version 2 only, as
   7 # published by the Free Software Foundation.  Oracle designates this
   8 # particular file as subject to the &quot;Classpath&quot; exception as provided
   9 # by Oracle in the LICENSE file that accompanied this code.
  10 #
  11 # This code is distributed in the hope that it will be useful, but WITHOUT
  12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14 # version 2 for more details (a copy is included in the LICENSE file that
  15 # accompanied this code).
  16 #
  17 # You should have received a copy of the GNU General Public License version
  18 # 2 along with this work; if not, write to the Free Software Foundation,
  19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20 #
  21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22 # or visit www.oracle.com if you need additional information or have any
  23 # questions.
  24 #
  25 
  26 # Messages in this file which use &quot;placeholders&quot; for values (e.g. {0}, {1})
  27 # are preceded by a stylized comment describing the type of the corresponding
  28 # values.
  29 # The simple types currently in use are:
  30 #
  31 # annotation        annotation compound
  32 # boolean           true or false
  33 # diagnostic        a sub-message; see compiler.misc.*
  34 # fragment          similar to &#39;message segment&#39;, but with more specific type
  35 # modifier          a Java modifier; e.g. public, private, protected
  36 # file              a file URL
  37 # file object       a file URL - similar to &#39;file&#39; but typically used for source/class files, hence more specific
  38 # flag              a Flags.Flag instance
  39 # name              a name, typically a Java identifier
  40 # number            an integer
  41 # option name       the name of a command line option
  42 # path              a path
  43 # profile           a profile name
  44 # source            a source version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.code.Source
  45 # source version    a source version number, such as 1.5, 1.6, 1.7, taken from a javax.lang.model.SourceVersion
  46 # string            a general string
  47 # symbol            the name of a declared type
  48 # symbol kind       the kind of a symbol (i.e. method, variable)
  49 # kind name         an informative description of the kind of a declaration; see compiler.misc.kindname.*
  50 # target            a target version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.jvm.Target
  51 # token             the name of a non-terminal in source code; see compiler.misc.token.*
  52 # tree tag          the name of a non-terminal in source code; see compiler.misc.token.*
  53 # type              a Java type; e.g. int, X, X&lt;T&gt;
  54 # url               a URL
  55 # object            a Java object (unspecified)
  56 # unused            the value is not used in this message
  57 #
  58 # The following compound types are also used:
  59 #
  60 # collection of X   a comma-separated collection of items; e.g. collection of type
  61 # list of X         a comma-separated list of items; e.g. list of type
  62 # set of X          a comma-separated set of items; e.g. set of modifier
  63 #
  64 # These may be composed:
  65 #
  66 # list of type or message segment
  67 #
  68 # The following type aliases are supported:
  69 #
  70 # message segment --&gt; diagnostic or fragment
  71 # file name --&gt; file, path or file object
  72 #
  73 # Custom comments are supported in parenthesis i.e.
  74 #
  75 # number (classfile major version)
  76 #
  77 # These comments are used internally in order to generate an enum-like class declaration containing
  78 # a method/field for each of the diagnostic keys listed here. Those methods/fields can then be used
  79 # by javac code to build diagnostics in a type-safe fashion.
  80 #
  81 # In addition, these comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
  82 # using info derived from the collected set of examples in test/tools/javac/diags/examples.
  83 # MessageInfo can also be run as a standalone utility providing more facilities
  84 # for manipulating this file. For more details, see MessageInfo.java.
  85 
  86 ##
  87 ## errors
  88 ##
  89 
  90 # 0: symbol
  91 compiler.err.abstract.cant.be.instantiated=\
  92     {0} is abstract; cannot be instantiated
  93 
  94 compiler.err.abstract.meth.cant.have.body=\
  95     abstract methods cannot have a body
  96 
  97 # 0: kind name, 1: symbol
  98 compiler.err.already.annotated=\
  99     {0} {1} has already been annotated
 100 
 101 # 0: kind name, 1: symbol, 2: kind name, 3: symbol
 102 compiler.err.already.defined=\
 103     {0} {1} is already defined in {2} {3}
 104 
 105 # 0: kind name, 1: symbol, 2: kind name, 3: kind name, 4: symbol
 106 compiler.err.already.defined.in.clinit=\
 107     {0} {1} is already defined in {2} of {3} {4}
 108 
 109 # 0: symbol
 110 compiler.err.already.defined.single.import=\
 111     a type with the same simple name is already defined by the single-type-import of {0}
 112 
 113 # 0: symbol
 114 compiler.err.already.defined.static.single.import=\
 115     a type with the same simple name is already defined by the static single-type-import of {0}
 116 
 117 # 0: symbol
 118 compiler.err.already.defined.this.unit=\
 119     {0} is already defined in this compilation unit
 120 
 121 # 0: type, 1: list of name
 122 compiler.err.annotation.missing.default.value=\
 123     annotation @{0} is missing a default value for the element &#39;&#39;{1}&#39;&#39;
 124 
 125 # 0: type, 1: list of name
 126 compiler.err.annotation.missing.default.value.1=\
 127     annotation @{0} is missing default values for elements {1}
 128 
 129 # 0: type
 130 compiler.err.annotation.not.valid.for.type=\
 131     annotation not valid for an element of type {0}
 132 
 133 compiler.err.annotation.type.not.applicable=\
 134     annotation type not applicable to this kind of declaration
 135 
 136 # 0: type
 137 compiler.err.annotation.type.not.applicable.to.type=\
 138     annotation @{0} not applicable in this type context
 139 
 140 compiler.err.annotation.value.must.be.annotation=\
 141     annotation value must be an annotation
 142 
 143 compiler.err.annotation.value.must.be.class.literal=\
 144     annotation value must be a class literal
 145 
 146 compiler.err.annotation.value.must.be.name.value=\
 147     annotation values must be of the form &#39;&#39;name=value&#39;&#39;
 148 
 149 compiler.err.annotation.value.not.allowable.type=\
 150     annotation value not of an allowable type
 151 
 152 compiler.err.expression.not.allowable.as.annotation.value=\
 153     expression not allowed as annotation value
 154 
 155 compiler.err.anon.class.impl.intf.no.args=\
 156     anonymous class implements interface; cannot have arguments
 157 
 158 compiler.err.anon.class.impl.intf.no.typeargs=\
 159     anonymous class implements interface; cannot have type arguments
 160 
 161 compiler.err.anon.class.impl.intf.no.qual.for.new=\
 162     anonymous class implements interface; cannot have qualifier for new
 163 
 164 compiler.err.cant.inherit.from.anon=\
 165     cannot inherit from anonymous class
 166 
 167 # 0: symbol, 1: symbol, 2: symbol
 168 compiler.err.array.and.varargs=\
 169     cannot declare both {0} and {1} in {2}
 170 
 171 compiler.err.array.dimension.missing=\
 172     array dimension missing
 173 
 174 compiler.err.illegal.array.creation.both.dimension.and.initialization=\
 175     array creation with both dimension expression and initialization is illegal
 176 
 177 # 0: type
 178 compiler.err.array.req.but.found=\
 179     array required, but {0} found
 180 
 181 compiler.err.attribute.value.must.be.constant=\
 182     element value must be a constant expression
 183 
 184 # 0: string (statement type)
 185 compiler.err.bad.initializer=\
 186     bad initializer for {0}
 187 
 188 compiler.err.break.outside.switch.loop=\
 189     break outside switch or loop
 190 
 191 compiler.err.break.outside.switch.expression=\
 192     attempt to break out of a switch expression
 193 
 194 compiler.err.continue.outside.switch.expression=\
 195     attempt to continue out of a switch expression
 196 
 197 compiler.err.return.outside.switch.expression=\
 198     attempt to return out of a switch expression
 199 
 200 compiler.err.rule.completes.normally=\
 201     switch rule completes without providing a value\n\
 202     (switch rules in switch expressions must either provide a value or throw)
 203 
 204 compiler.err.switch.expression.completes.normally=\
 205     switch expression completes without providing a value\n\
 206     (switch expressions must either provide a value or throw for all possible input values)
 207 
 208 compiler.err.no.switch.expression =\
 209     yield outside of switch expression
 210 
 211 compiler.err.no.switch.expression.qualify=\
 212     yield outside of switch expression\n\
 213     (to invoke a method called yield, qualify the yield with a receiver or type name)
 214 
 215 compiler.err.invalid.yield=\
 216     invalid use of a restricted identifier &#39;&#39;yield&#39;&#39;\n\
 217     (to invoke a method called yield, qualify the yield with a receiver or type name)
 218 
 219 compiler.warn.invalid.yield=\
 220     &#39;&#39;yield&#39;&#39; may become a restricted identifier in a future release\n\
 221     (to invoke a method called yield, qualify the yield with a receiver or type name)
 222 
 223 compiler.err.switch.expression.empty=\
 224     switch expression does not have any case clauses
 225 
 226 compiler.err.switch.expression.no.result.expressions=\
 227     switch expression does not have any result expressions
 228 
 229 # 0: name
 230 compiler.err.call.must.be.first.stmt.in.ctor=\
 231     call to {0} must be first statement in constructor
 232 
 233 # 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
 234 compiler.err.cant.apply.symbol=\
 235     {0} {1} in {4} {5} cannot be applied to given types;\n\
 236     required: {2}\n\
 237     found:    {3}\n\
 238     reason: {6}
 239 
 240 # 0: symbol kind, 1: name, 2: list of type
 241 compiler.err.cant.apply.symbols=\
 242     no suitable {0} found for {1}({2})
 243 
 244 # 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
 245 compiler.misc.cant.apply.symbol=\
 246     {0} {1} in {4} {5} cannot be applied to given types\n\
 247     required: {2}\n\
 248     found:    {3}\n\
 249     reason: {6}
 250 
 251 # 0: symbol kind, 1: name, 2: list of type
 252 compiler.misc.cant.apply.symbols=\
 253     no suitable {0} found for {1}({2})
 254 
 255 # 0: kind name, 1: symbol
 256 compiler.misc.no.abstracts=\
 257     no abstract method found in {0} {1}
 258 
 259 # 0: kind name, 1: symbol
 260 compiler.misc.incompatible.abstracts=\
 261     multiple non-overriding abstract methods found in {0} {1}
 262 
 263 compiler.err.bad.functional.intf.anno=\
 264     Unexpected @FunctionalInterface annotation
 265 
 266 # 0: message segment
 267 compiler.err.bad.functional.intf.anno.1=\
 268     Unexpected @FunctionalInterface annotation\n\
 269     {0}
 270 
 271 # 0: message segment
 272 compiler.err.anonymous.diamond.method.does.not.override.superclass=\
 273     method does not override or implement a method from a supertype\n\
 274     {0}
 275 
 276 # 0: symbol
 277 compiler.misc.not.a.functional.intf=\
 278     {0} is not a functional interface
 279 
 280 # 0: symbol, 1: message segment
 281 compiler.misc.not.a.functional.intf.1=\
 282     {0} is not a functional interface\n\
 283     {1}
 284 
 285 # 0: type, 1: kind name, 2: symbol
 286 compiler.misc.invalid.generic.lambda.target=\
 287     invalid functional descriptor for lambda expression\n\
 288     method {0} in {1} {2} is generic
 289 
 290 # 0: kind name, 1: symbol
 291 compiler.misc.incompatible.descs.in.functional.intf=\
 292     incompatible function descriptors found in {0} {1}
 293 
 294 # 0: name, 1: list of type, 2: type, 3: list of type
 295 compiler.misc.descriptor=\
 296     descriptor: {2} {0}({1})
 297 
 298 # 0: name, 1: list of type, 2: type, 3: list of type
 299 compiler.misc.descriptor.throws=\
 300     descriptor: {2} {0}({1}) throws {3}
 301 
 302 # 0: type
 303 compiler.misc.no.suitable.functional.intf.inst=\
 304     cannot infer functional interface descriptor for {0}
 305 
 306 # 0: message segment
 307 compiler.misc.bad.intersection.target.for.functional.expr=\
 308     bad intersection type target for lambda or method reference\n\
 309     {0}
 310 
 311 # 0: symbol or type
 312 compiler.misc.not.an.intf.component=\
 313     component type {0} is not an interface
 314 
 315 # 0: kind name, 1: message segment
 316 compiler.err.invalid.mref=\
 317     invalid {0} reference\n\
 318     {1}
 319 
 320 # 0: kind name, 1: message segment
 321 compiler.misc.invalid.mref=\
 322     invalid {0} reference\n\
 323     {1}
 324 
 325 compiler.misc.static.mref.with.targs=\
 326     parameterized qualifier on static method reference
 327 
 328 # 0: symbol
 329 compiler.err.cant.assign.val.to.final.var=\
 330     cannot assign a value to final variable {0}
 331 
 332 compiler.err.cant.assign.val.to.this=\
 333     cannot assign to &#39;&#39;this&#39;&#39;
 334 
 335 # 0: symbol, 1: message segment
 336 compiler.err.cant.ref.non.effectively.final.var=\
 337     local variables referenced from {1} must be final or effectively final
 338 
 339 compiler.err.try.with.resources.expr.needs.var=\
 340     the try-with-resources resource must either be a variable declaration or an expression denoting \
 341 a reference to a final or effectively final variable
 342 
 343 # 0: symbol
 344 compiler.err.try.with.resources.expr.effectively.final.var=\
 345     variable {0} used as a try-with-resources resource neither final nor effectively final
 346 
 347 
 348 compiler.misc.lambda=\
 349     a lambda expression
 350 
 351 compiler.misc.inner.cls=\
 352     an inner class
 353 
 354 # 0: type
 355 compiler.err.cant.deref=\
 356     {0} cannot be dereferenced
 357 
 358 compiler.err.cant.extend.intf.annotation=\
 359     &#39;&#39;extends&#39;&#39; not allowed for @interfaces
 360 
 361 compiler.err.annotation.decl.not.allowed.here=\
 362     annotation type declaration not allowed here
 363 
 364 # 0: symbol
 365 compiler.err.cant.inherit.from.final=\
 366     cannot inherit from final {0}
 367 
 368 # 0: symbol or string
 369 compiler.err.cant.ref.before.ctor.called=\
 370     cannot reference {0} before supertype constructor has been called
 371 
 372 compiler.err.cant.select.static.class.from.param.type=\
 373     cannot select a static class from a parameterized type
 374 
 375 # 0: symbol, 1: string, 2: string
 376 compiler.err.cant.inherit.diff.arg=\
 377     {0} cannot be inherited with different arguments: &lt;{1}&gt; and &lt;{2}&gt;
 378 
 379 compiler.err.catch.without.try=\
 380     &#39;&#39;catch&#39;&#39; without &#39;&#39;try&#39;&#39;
 381 
 382 # 0: kind name, 1: symbol
 383 compiler.err.clash.with.pkg.of.same.name=\
 384     {0} {1} clashes with package of same name
 385 
 386 compiler.err.class.not.allowed=\
 387     class, interface or enum declaration not allowed here
 388 
 389 compiler.err.const.expr.req=\
 390     constant expression required
 391 
 392 compiler.err.cont.outside.loop=\
 393     continue outside of loop
 394 
 395 # 0: symbol or type
 396 compiler.err.cyclic.inheritance=\
 397     cyclic inheritance involving {0}
 398 
 399 # 0: symbol
 400 compiler.err.cyclic.value.type.membership=\
 401     cyclic inline type membership involving {0}
 402 
 403 # 0: symbol
 404 compiler.err.cyclic.annotation.element=\
 405     type of element {0} is cyclic
 406 
 407 # 0: symbol
 408 compiler.err.call.to.super.not.allowed.in.enum.ctor=\
 409     call to super not allowed in enum constructor
 410 
 411 # 0: type
 412 compiler.err.no.superclass=\
 413     {0} has no superclass.
 414 
 415 # 0: symbol, 1: type, 2: symbol, 3: type, 4: type
 416 compiler.err.concrete.inheritance.conflict=\
 417     methods {0} from {1} and {2} from {3} are inherited with the same signature
 418 
 419 compiler.err.default.allowed.in.intf.annotation.member=\
 420     default value only allowed in an annotation type declaration
 421 
 422 # 0: symbol
 423 compiler.err.doesnt.exist=\
 424     package {0} does not exist
 425 
 426 # 0: type
 427 compiler.err.duplicate.annotation.invalid.repeated=\
 428     annotation {0} is not a valid repeatable annotation
 429 
 430 # 0: name, 1: type
 431 compiler.err.duplicate.annotation.member.value=\
 432     duplicate element &#39;&#39;{0}&#39;&#39; in annotation @{1}.
 433 
 434 # 0: type
 435 compiler.err.duplicate.annotation.missing.container=\
 436     {0} is not a repeatable annotation type
 437 
 438 # 0: symbol
 439 compiler.err.invalid.repeatable.annotation=\
 440     duplicate annotation: {0} is annotated with an invalid @Repeatable annotation
 441 
 442 # 0: symbol or type
 443 compiler.err.invalid.repeatable.annotation.no.value=\
 444     {0} is not a valid @Repeatable, no value element method declared
 445 
 446 # 0: type, 1: number
 447 compiler.err.invalid.repeatable.annotation.multiple.values=\
 448     {0} is not a valid @Repeatable, {1} element methods named &#39;&#39;value&#39;&#39; declared
 449 
 450 # 0: type
 451 compiler.err.invalid.repeatable.annotation.invalid.value=\
 452     {0} is not a valid @Repeatable: invalid value element
 453 
 454 # 0: symbol or type, 1: type, 2: type
 455 compiler.err.invalid.repeatable.annotation.value.return=\
 456     containing annotation type ({0}) must declare an element named &#39;&#39;value&#39;&#39; of type {2}
 457 
 458 # 0: symbol or type, 1: symbol
 459 compiler.err.invalid.repeatable.annotation.elem.nondefault=\
 460     containing annotation type ({0}) does not have a default value for element {1}
 461 
 462 # 0: symbol, 1: string, 2: symbol, 3: string
 463 compiler.err.invalid.repeatable.annotation.retention=\
 464     retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2})
 465 
 466 # 0: symbol, 1: symbol
 467 compiler.err.invalid.repeatable.annotation.not.documented=\
 468     repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not
 469 
 470 # 0: symbol, 1: symbol
 471 compiler.err.invalid.repeatable.annotation.not.inherited=\
 472     repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not
 473 
 474 # 0: symbol, 1: symbol
 475 compiler.err.invalid.repeatable.annotation.incompatible.target=\
 476     containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1})
 477 
 478 # 0: symbol
 479 compiler.err.invalid.repeatable.annotation.repeated.and.container.present=\
 480     container {0} must not be present at the same time as the element it contains
 481 
 482 # 0: type, 1: symbol
 483 compiler.err.invalid.repeatable.annotation.not.applicable=\
 484     container {0} is not applicable to element {1}
 485 
 486 # 0: type
 487 compiler.err.invalid.repeatable.annotation.not.applicable.in.context=\
 488     container {0} is not applicable in this type context
 489 
 490 # 0: name
 491 compiler.err.duplicate.class=\
 492     duplicate class: {0}
 493 
 494 # 0: name, 1: name
 495 compiler.err.same.binary.name=\
 496     classes: {0} and {1} have the same binary name
 497 
 498 compiler.err.duplicate.case.label=\
 499     duplicate case label
 500 
 501 compiler.err.duplicate.default.label=\
 502     duplicate default label
 503 
 504 compiler.err.else.without.if=\
 505     &#39;&#39;else&#39;&#39; without &#39;&#39;if&#39;&#39;
 506 
 507 compiler.err.empty.char.lit=\
 508     empty character literal
 509 
 510 # 0: symbol
 511 compiler.err.encl.class.required=\
 512     an enclosing instance that contains {0} is required
 513 
 514 compiler.err.enum.annotation.must.be.enum.constant=\
 515     an enum annotation value must be an enum constant
 516 
 517 compiler.err.enum.cant.be.instantiated=\
 518     enum types may not be instantiated
 519 
 520 compiler.err.enum.label.must.be.unqualified.enum=\
 521     an enum switch case label must be the unqualified name of an enumeration constant
 522 
 523 compiler.err.enum.no.subclassing=\
 524     classes cannot directly extend java.lang.Enum
 525 
 526 compiler.err.enum.types.not.extensible=\
 527     enum types are not extensible
 528 
 529 compiler.err.enum.no.finalize=\
 530     enums cannot have finalize methods
 531 
 532 # 0: file name, 1: string
 533 compiler.err.error.reading.file=\
 534     error reading {0}; {1}
 535 
 536 # 0: type
 537 compiler.err.except.already.caught=\
 538     exception {0} has already been caught
 539 
 540 # 0: type
 541 compiler.err.except.never.thrown.in.try=\
 542     exception {0} is never thrown in body of corresponding try statement
 543 
 544 # 0: symbol
 545 compiler.err.final.parameter.may.not.be.assigned=\
 546     final parameter {0} may not be assigned
 547 
 548 # 0: symbol
 549 compiler.err.try.resource.may.not.be.assigned=\
 550     auto-closeable resource {0} may not be assigned
 551 
 552 # 0: symbol
 553 compiler.err.pattern.binding.may.not.be.assigned=\
 554     pattern binding {0} may not be assigned
 555 
 556 # 0: symbol
 557 compiler.err.multicatch.parameter.may.not.be.assigned=\
 558     multi-catch parameter {0} may not be assigned
 559 
 560 # 0: type, 1: type
 561 compiler.err.multicatch.types.must.be.disjoint=\
 562     Alternatives in a multi-catch statement cannot be related by subclassing\n\
 563     Alternative {0} is a subclass of alternative {1}
 564 
 565 compiler.err.finally.without.try=\
 566     &#39;&#39;finally&#39;&#39; without &#39;&#39;try&#39;&#39;
 567 
 568 # 0: type, 1: message segment
 569 compiler.err.foreach.not.applicable.to.type=\
 570     for-each not applicable to expression type\n\
 571     required: {1}\n\
 572     found:    {0}
 573 
 574 compiler.err.fp.number.too.large=\
 575     floating point number too large
 576 
 577 compiler.err.fp.number.too.small=\
 578     floating point number too small
 579 
 580 compiler.err.generic.array.creation=\
 581     generic array creation
 582 
 583 compiler.err.generic.throwable=\
 584     a generic class may not extend java.lang.Throwable
 585 
 586 # 0: symbol
 587 compiler.err.icls.cant.have.static.decl=\
 588     Illegal static declaration in inner class {0}\n\
 589     modifier \&#39;&#39;static\&#39;&#39; is only allowed in constant variable declarations
 590 
 591 # 0: string
 592 compiler.err.illegal.char=\
 593     illegal character: &#39;&#39;{0}&#39;&#39;
 594 
 595 # 0: string, 1: string
 596 compiler.err.illegal.char.for.encoding=\
 597     unmappable character (0x{0}) for encoding {1}
 598 
 599 # 0: set of flag, 1: set of flag
 600 compiler.err.illegal.combination.of.modifiers=\
 601     illegal combination of modifiers: {0} and {1}
 602 
 603 compiler.err.illegal.enum.static.ref=\
 604     illegal reference to static field from initializer
 605 
 606 compiler.err.illegal.esc.char=\
 607     illegal escape character
 608 
 609 compiler.err.illegal.forward.ref=\
 610     illegal forward reference
 611 
 612 # 0: symbol, 1: object
 613 compiler.err.not.in.profile=\
 614     {0} is not available in profile &#39;&#39;{1}&#39;&#39;
 615 
 616 # 0: symbol
 617 compiler.warn.forward.ref=\
 618     reference to variable &#39;&#39;{0}&#39;&#39; before it has been initialized
 619 
 620 compiler.err.illegal.self.ref=\
 621     self-reference in initializer
 622 
 623 # 0: symbol
 624 compiler.warn.self.ref=\
 625     self-reference in initializer of variable &#39;&#39;{0}&#39;&#39;
 626 
 627 compiler.err.illegal.generic.type.for.instof=\
 628     illegal generic type for instanceof
 629 
 630 # 0: type
 631 compiler.err.illegal.initializer.for.type=\
 632     illegal initializer for {0}
 633 
 634 compiler.err.illegal.line.end.in.char.lit=\
 635     illegal line end in character literal
 636 
 637 compiler.err.illegal.text.block.open=\
 638     illegal text block open delimiter sequence, missing line terminator
 639 
 640 compiler.warn.inconsistent.white.space.indentation=\
 641     inconsistent white space indentation
 642 
 643 compiler.warn.trailing.white.space.will.be.removed=\
 644     trailing white space will be removed
 645 
 646 compiler.err.illegal.nonascii.digit=\
 647     illegal non-ASCII digit
 648 
 649 compiler.err.illegal.underscore=\
 650     illegal underscore
 651 
 652 compiler.err.illegal.dot=\
 653     illegal &#39;&#39;.&#39;&#39;
 654 
 655 # 0: symbol
 656 compiler.err.illegal.qual.not.icls=\
 657     illegal qualifier; {0} is not an inner class
 658 
 659 compiler.err.illegal.start.of.expr=\
 660     illegal start of expression
 661 
 662 compiler.err.illegal.start.of.stmt=\
 663     illegal start of statement
 664 
 665 compiler.err.illegal.start.of.type=\
 666     illegal start of type
 667 
 668 compiler.err.illegal.parenthesized.expression=\
 669     illegal parenthesized expression
 670 
 671 compiler.err.illegal.unicode.esc=\
 672     illegal unicode escape
 673 
 674 # 0: symbol
 675 compiler.err.import.requires.canonical=\
 676     import requires canonical name for {0}
 677 
 678 compiler.err.improperly.formed.type.param.missing=\
 679     improperly formed type, some parameters are missing
 680 
 681 compiler.err.improperly.formed.type.inner.raw.param=\
 682     improperly formed type, type arguments given on a raw type
 683 
 684 # 0: type, 1: type
 685 compiler.err.incomparable.types=\
 686     incomparable types: {0} and {1}
 687 
 688 # 0: string
 689 compiler.err.int.number.too.large=\
 690     integer number too large
 691 
 692 compiler.err.intf.annotation.members.cant.have.params=\
 693     elements in annotation type declarations cannot declare formal parameters
 694 
 695 # 0: symbol
 696 compiler.err.intf.annotation.cant.have.type.params=\
 697     annotation type {0} cannot be generic
 698 
 699 compiler.err.intf.annotation.members.cant.have.type.params=\
 700     elements in annotation type declarations cannot be generic methods
 701 
 702 # 0: symbol, 1: type
 703 compiler.err.intf.annotation.member.clash=\
 704     annotation type {1} declares an element with the same name as method {0}
 705 
 706 compiler.err.intf.expected.here=\
 707     interface expected here
 708 
 709 compiler.err.intf.meth.cant.have.body=\
 710     interface abstract methods cannot have body
 711 
 712 compiler.err.invalid.annotation.member.type=\
 713     invalid type for annotation type element
 714 
 715 compiler.err.invalid.binary.number=\
 716     binary numbers must contain at least one binary digit
 717 
 718 compiler.err.invalid.hex.number=\
 719     hexadecimal numbers must contain at least one hexadecimal digit
 720 
 721 compiler.err.invalid.meth.decl.ret.type.req=\
 722     invalid method declaration; return type required
 723 
 724 compiler.err.varargs.and.old.array.syntax=\
 725     legacy array notation not allowed on variable-arity parameter
 726 
 727 compiler.err.varargs.and.receiver =\
 728     varargs notation not allowed on receiver parameter
 729 
 730 compiler.err.varargs.must.be.last =\
 731     varargs parameter must be the last parameter
 732 
 733 compiler.err.array.and.receiver =\
 734     legacy array notation not allowed on receiver parameter
 735 
 736 compiler.err.wrong.receiver =\
 737     wrong receiver parameter name
 738 
 739 compiler.err.variable.not.allowed=\
 740     variable declaration not allowed here
 741 
 742 # 0: name
 743 compiler.err.label.already.in.use=\
 744     label {0} already in use
 745 
 746 # 0: symbol
 747 compiler.err.local.var.accessed.from.icls.needs.final=\
 748     local variable {0} is accessed from within inner class; needs to be declared final
 749 
 750 compiler.err.local.enum=\
 751     enum types must not be local
 752 
 753 compiler.err.cannot.create.array.with.type.arguments=\
 754     cannot create array with type arguments
 755 
 756 compiler.err.cannot.create.array.with.diamond=\
 757     cannot create array with &#39;&#39;&lt;&gt;&#39;&#39;
 758 
 759 compiler.err.invalid.module.directive=\
 760   module directive keyword or &#39;&#39;}&#39;&#39; expected
 761 
 762 #
 763 # limits.  We don&#39;t give the limits in the diagnostic because we expect
 764 # them to change, yet we want to use the same diagnostic.  These are all
 765 # detected during code generation.
 766 #
 767 compiler.err.limit.code=\
 768     code too large
 769 
 770 compiler.err.limit.code.too.large.for.try.stmt=\
 771     code too large for try statement
 772 
 773 compiler.err.limit.dimensions=\
 774     array type has too many dimensions
 775 
 776 compiler.err.limit.locals=\
 777     too many local variables
 778 
 779 compiler.err.limit.parameters=\
 780     too many parameters
 781 
 782 compiler.err.limit.pool=\
 783     too many constants
 784 
 785 compiler.err.limit.pool.in.class=\
 786     too many constants in class {0}
 787 
 788 compiler.err.limit.stack=\
 789     code requires too much stack
 790 
 791 compiler.err.limit.string=\
 792     constant string too long
 793 
 794 # 0: string
 795 compiler.err.limit.string.overflow=\
 796     UTF8 representation for string \&quot;{0}...\&quot; is too long for the constant pool
 797 
 798 compiler.err.malformed.fp.lit=\
 799     malformed floating point literal
 800 
 801 compiler.err.method.does.not.override.superclass=\
 802     method does not override or implement a method from a supertype
 803 
 804 compiler.err.static.methods.cannot.be.annotated.with.override=\
 805     static methods cannot be annotated with @Override
 806 
 807 compiler.err.missing.meth.body.or.decl.abstract=\
 808     missing method body, or declare abstract
 809 
 810 compiler.err.missing.ret.stmt=\
 811     missing return statement
 812 
 813 # 0: type
 814 compiler.misc.missing.ret.val=\
 815     missing return value
 816 
 817 compiler.misc.unexpected.ret.val=\
 818     unexpected return value
 819 
 820 # 0: set of flag
 821 compiler.err.mod.not.allowed.here=\
 822     modifier {0} not allowed here
 823 
 824 # 0: name
 825 compiler.err.modifier.not.allowed.here=\
 826     modifier {0} not allowed here
 827 
 828 compiler.err.intf.not.allowed.here=\
 829     interface not allowed here
 830 
 831 compiler.err.enums.must.be.static=\
 832     enum declarations allowed only in static contexts
 833 
 834 # 0: symbol, 1: symbol
 835 compiler.err.name.clash.same.erasure=\
 836     name clash: {0} and {1} have the same erasure
 837 
 838 # 0: name, 1: list of type, 2: symbol, 3: name, 4: list of type, 5: symbol
 839 compiler.err.name.clash.same.erasure.no.override=\
 840     name clash: {0}({1}) in {2} and {3}({4}) in {5} have the same erasure, yet neither overrides the other
 841 
 842 # 0: string, 1: name, 2: name, 3: list of type, 4: symbol, 5: name, 6: list of type, 7: symbol
 843 compiler.err.name.clash.same.erasure.no.override.1=\
 844     name clash: {0} {1} has two methods with the same erasure, yet neither overrides the other\n\
 845     first method:  {2}({3}) in {4}\n\
 846     second method: {5}({6}) in {7}
 847 
 848 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
 849 compiler.err.name.clash.same.erasure.no.hide=\
 850     name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other
 851 
 852 compiler.err.name.reserved.for.internal.use=\
 853     {0} is reserved for internal use
 854 
 855 compiler.err.native.meth.cant.have.body=\
 856     native methods cannot have a body
 857 
 858 
 859 # 0: message segment
 860 compiler.misc.incompatible.type.in.conditional=\
 861     bad type in conditional expression\n\
 862     {0}
 863 
 864 compiler.misc.conditional.target.cant.be.void=\
 865     target-type for conditional expression cannot be void
 866 
 867 compiler.misc.switch.expression.target.cant.be.void=\
 868     target-type for switch expression cannot be void
 869 
 870 # 0: message segment
 871 compiler.misc.incompatible.type.in.switch.expression=\
 872     bad type in switch expression\n\
 873     {0}
 874 
 875 # 0: message segment
 876 compiler.misc.incompatible.ret.type.in.lambda=\
 877     bad return type in lambda expression\n\
 878     {0}
 879 
 880 compiler.misc.stat.expr.expected=\
 881     lambda body is not compatible with a void functional interface\n\
 882     (consider using a block lambda body, or use a statement expression instead)
 883 
 884 # 0: message segment
 885 compiler.misc.incompatible.ret.type.in.mref=\
 886     bad return type in method reference\n\
 887     {0}
 888 
 889 compiler.err.lambda.body.neither.value.nor.void.compatible=\
 890     lambda body is neither value nor void compatible
 891 
 892 # 0: list of type
 893 compiler.err.incompatible.thrown.types.in.mref=\
 894     incompatible thrown types {0} in functional expression
 895 
 896 compiler.misc.incompatible.arg.types.in.lambda=\
 897     incompatible parameter types in lambda expression
 898 
 899 compiler.misc.incompatible.arg.types.in.mref=\
 900     incompatible parameter types in method reference
 901 
 902 compiler.err.new.not.allowed.in.annotation=\
 903     &#39;&#39;new&#39;&#39; not allowed in an annotation
 904 
 905 # 0: name, 1: type
 906 compiler.err.no.annotation.member=\
 907     no annotation member {0} in {1}
 908 
 909 # 0: symbol
 910 compiler.err.no.encl.instance.of.type.in.scope=\
 911     no enclosing instance of type {0} is in scope
 912 
 913 compiler.err.no.intf.expected.here=\
 914     no interface expected here
 915 
 916 compiler.err.no.match.entry=\
 917     {0} has no match in entry in {1}; required {2}
 918 
 919 # 0: type
 920 compiler.err.not.annotation.type=\
 921     {0} is not an annotation type
 922 
 923 # 0: symbol, 1: symbol, 2: message segment
 924 compiler.err.not.def.access.package.cant.access=\
 925     {0} is not visible\n\
 926     ({2})
 927 
 928 # 0: symbol, 1: symbol, 2: message segment
 929 compiler.misc.not.def.access.package.cant.access=\
 930     {0} is not visible\n\
 931     ({2})
 932 
 933 # 0: symbol, 1: message segment
 934 compiler.err.package.not.visible=\
 935     package {0} is not visible\n\
 936     ({1})
 937 
 938 # 0: symbol, 1: message segment
 939 compiler.misc.package.not.visible=\
 940     package {0} is not visible\n\
 941     ({1})
 942 
 943 # {0} - current module
 944 # {1} - package in which the invisible class is declared
 945 # {2} - module in which {1} is declared
 946 # 0: symbol, 1: symbol, 2: symbol
 947 compiler.misc.not.def.access.does.not.read=\
 948     package {1} is declared in module {2}, but module {0} does not read it
 949 
 950 # {0} - package in which the invisible class is declared
 951 # {1} - module in which {0} is declared
 952 # 0: symbol, 1: symbol
 953 compiler.misc.not.def.access.does.not.read.from.unnamed=\
 954     package {0} is declared in module {1}, which is not in the module graph
 955 
 956 # {0} - package in which the invisible class is declared
 957 # {1} - current module
 958 # 0: symbol, 1: symbol
 959 compiler.misc.not.def.access.does.not.read.unnamed=\
 960     package {0} is declared in the unnamed module, but module {1} does not read it
 961 
 962 # {0} - package in which the invisible class is declared
 963 # {1} - module in which {0} is declared
 964 # 0: symbol, 1: symbol
 965 compiler.misc.not.def.access.not.exported=\
 966     package {0} is declared in module {1}, which does not export it
 967 
 968 # {0} - package in which the invisible class is declared
 969 # {1} - module in which {0} is declared
 970 # 0: symbol, 1: symbol
 971 compiler.misc.not.def.access.not.exported.from.unnamed=\
 972     package {0} is declared in module {1}, which does not export it
 973 
 974 # {0} - package in which the invisible class is declared
 975 # {1} - module in which {0} is declared
 976 # {2} - current module
 977 # 0: symbol, 1: symbol, 2: symbol
 978 compiler.misc.not.def.access.not.exported.to.module=\
 979     package {0} is declared in module {1}, which does not export it to module {2}
 980 
 981 # {0} - package in which the invisible class is declared
 982 # {1} - module in which {0} is declared
 983 # 0: symbol, 1: symbol
 984 compiler.misc.not.def.access.not.exported.to.module.from.unnamed=\
 985     package {0} is declared in module {1}, which does not export it to the unnamed module
 986 
 987 # 0: symbol, 1: symbol
 988 compiler.err.not.def.access.class.intf.cant.access=\
 989     {1}.{0} is defined in an inaccessible class or interface
 990 
 991 # 0: symbol, 1: symbol
 992 compiler.misc.not.def.access.class.intf.cant.access=\
 993     {1}.{0} is defined in an inaccessible class or interface
 994 
 995 # 0: symbol, 1: symbol, 2: symbol, 3: message segment
 996 compiler.err.not.def.access.class.intf.cant.access.reason=\
 997     {1}.{0} in package {2} is not accessible\n\
 998     ({3})
 999 
1000 # 0: symbol, 1: symbol, 2: symbol, 3: message segment
1001 compiler.misc.not.def.access.class.intf.cant.access.reason=\
1002     {1}.{0} in package {2} is not accessible\n\
1003     ({3})
1004 
1005 # 0: symbol, 1: list of type, 2: type
1006 compiler.misc.cant.access.inner.cls.constr=\
1007     cannot access constructor {0}({1})\n\
1008     an enclosing instance of type {2} is not in scope
1009 
1010 # 0: symbol, 1: symbol
1011 compiler.err.not.def.public.cant.access=\
1012     {0} is not public in {1}; cannot be accessed from outside package
1013 
1014 # 0: symbol, 1: symbol
1015 compiler.err.not.def.public=\
1016     {0} is not public in {1}
1017 
1018 # 0: symbol, 1: symbol
1019 compiler.misc.not.def.public.cant.access=\
1020     {0} is not public in {1}; cannot be accessed from outside package
1021 
1022 # 0: name
1023 compiler.err.not.loop.label=\
1024     not a loop label: {0}
1025 
1026 compiler.err.not.stmt=\
1027     not a statement
1028 
1029 # 0: symbol
1030 compiler.err.not.encl.class=\
1031     not an enclosing class: {0}
1032 
1033 # 0: name, 1: type
1034 compiler.err.operator.cant.be.applied=\
1035     bad operand type {1} for unary operator &#39;&#39;{0}&#39;&#39;
1036 
1037 # 0: name, 1: type, 2: type
1038 compiler.err.operator.cant.be.applied.1=\
1039     bad operand types for binary operator &#39;&#39;{0}&#39;&#39;\n\
1040     first type:  {1}\n\
1041     second type: {2}
1042 
1043 compiler.err.pkg.annotations.sb.in.package-info.java=\
1044     package annotations should be in file package-info.java
1045 
1046 compiler.err.no.pkg.in.module-info.java=\
1047     package declarations not allowed in file module-info.java
1048 
1049 # 0: symbol
1050 compiler.err.pkg.clashes.with.class.of.same.name=\
1051     package {0} clashes with class of same name
1052 
1053 compiler.err.warnings.and.werror=\
1054     warnings found and -Werror specified
1055 
1056 # Errors related to annotation processing
1057 
1058 # 0: symbol, 1: message segment, 2: string (stack-trace)
1059 compiler.err.proc.cant.access=\
1060     cannot access {0}\n\
1061     {1}\n\
1062     Consult the following stack trace for details.\n\
1063     {2}
1064 
1065 # 0: symbol, 1: message segment
1066 compiler.err.proc.cant.access.1=\
1067     cannot access {0}\n\
1068     {1}
1069 
1070 # 0: string
1071 compiler.err.proc.cant.find.class=\
1072     Could not find class file for &#39;&#39;{0}&#39;&#39;.
1073 
1074 # 0: string
1075 compiler.err.proc.cant.load.class=\
1076     Could not load processor class file due to &#39;&#39;{0}&#39;&#39;.
1077 
1078 # Print a client-generated error message; assumed to be localized, no translation required
1079 # 0: string
1080 compiler.err.proc.messager=\
1081     {0}
1082 
1083 # 0: string
1084 compiler.misc.exception.message=\
1085     {0}
1086 
1087 compiler.misc.user.selected.completion.failure=\
1088     user-selected completion failure by class name
1089 
1090 # 0: collection of string
1091 compiler.err.proc.no.explicit.annotation.processing.requested=\
1092     Class names, &#39;&#39;{0}&#39;&#39;, are only accepted if annotation processing is explicitly requested
1093 
1094 compiler.err.proc.no.service=\
1095     A ServiceLoader was not usable and is required for annotation processing.
1096 
1097 # 0: string, 1: string
1098 compiler.err.proc.processor.bad.option.name=\
1099     Bad option name &#39;&#39;{0}&#39;&#39; provided by processor &#39;&#39;{1}&#39;&#39;
1100 
1101 # 0: string
1102 compiler.err.proc.processor.cant.instantiate=\
1103     Could not instantiate an instance of processor &#39;&#39;{0}&#39;&#39;
1104 
1105 # 0: string
1106 compiler.err.proc.processor.not.found=\
1107     Annotation processor &#39;&#39;{0}&#39;&#39; not found
1108 
1109 # 0: string
1110 compiler.err.proc.processor.wrong.type=\
1111     Annotation processor &#39;&#39;{0}&#39;&#39; does not implement javax.annotation.processing.Processor
1112 
1113 compiler.err.proc.service.problem=\
1114     Error creating a service loader to load Processors.
1115 
1116 # 0: string
1117 compiler.err.proc.bad.config.file=\
1118     Bad service configuration file, or exception thrown while constructing Processor object: {0}
1119 
1120 compiler.err.proc.cant.create.loader=\
1121     Could not create class loader for annotation processors: {0}
1122 
1123 # 0: symbol
1124 compiler.err.qualified.new.of.static.class=\
1125     qualified new of static class
1126 
1127 compiler.err.recursive.ctor.invocation=\
1128     recursive constructor invocation
1129 
1130 # 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
1131 compiler.err.ref.ambiguous=\
1132     reference to {0} is ambiguous\n\
1133     both {1} {2} in {3} and {4} {5} in {6} match
1134 
1135 # 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
1136 compiler.misc.ref.ambiguous=\
1137     reference to {0} is ambiguous\n\
1138     both {1} {2} in {3} and {4} {5} in {6} match
1139 
1140 compiler.err.repeated.annotation.target=\
1141     repeated annotation target
1142 
1143 compiler.err.repeated.interface=\
1144     repeated interface
1145 
1146 compiler.err.repeated.modifier=\
1147     repeated modifier
1148 
1149 # 0: symbol, 1: set of modifier, 2: symbol
1150 compiler.err.report.access=\
1151     {0} has {1} access in {2}
1152 
1153 # 0: symbol, 1: set of modifier, 2: symbol
1154 compiler.misc.report.access=\
1155     {0} has {1} access in {2}
1156 
1157 compiler.err.ret.outside.meth=\
1158     return outside method
1159 
1160 compiler.err.signature.doesnt.match.supertype=\
1161     signature does not match {0}; incompatible supertype
1162 
1163 compiler.err.signature.doesnt.match.intf=\
1164     signature does not match {0}; incompatible interfaces
1165 
1166 # 0: symbol, 1: symbol, 2: symbol
1167 compiler.err.does.not.override.abstract=\
1168     {0} is not abstract and does not override abstract method {1} in {2}
1169 
1170 # 0: file object
1171 compiler.err.source.cant.overwrite.input.file=\
1172     error writing source; cannot overwrite input file {0}
1173 
1174 # 0: symbol
1175 compiler.err.stack.sim.error=\
1176     Internal error: stack sim error on {0}
1177 
1178 compiler.err.static.imp.only.classes.and.interfaces=\
1179     static import only from classes and interfaces
1180 
1181 compiler.err.string.const.req=\
1182     constant string expression required
1183 
1184 # 0: symbol, 1: fragment
1185 compiler.err.cannot.generate.class=\
1186     error while generating class {0}\n\
1187     ({1})
1188 
1189 # 0: symbol, 1: symbol
1190 compiler.misc.synthetic.name.conflict=\
1191     the symbol {0} conflicts with a compiler-synthesized symbol in {1}
1192 
1193 # 0: symbol, 1: type
1194 compiler.misc.illegal.signature=\
1195     illegal signature attribute for type {1}
1196 
1197 compiler.err.throws.not.allowed.in.intf.annotation=\
1198     throws clause not allowed in @interface members
1199 
1200 compiler.err.try.without.catch.finally.or.resource.decls=\
1201     &#39;&#39;try&#39;&#39; without &#39;&#39;catch&#39;&#39;, &#39;&#39;finally&#39;&#39; or resource declarations
1202 
1203 # 0: symbol
1204 compiler.err.type.doesnt.take.params=\
1205     type {0} does not take parameters
1206 
1207 compiler.err.type.var.cant.be.deref=\
1208     cannot select from a type variable
1209 
1210 compiler.err.type.var.may.not.be.followed.by.other.bounds=\
1211     a type variable may not be followed by other bounds
1212 
1213 compiler.err.type.var.more.than.once=\
1214     type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
1215 
1216 compiler.err.type.var.more.than.once.in.result=\
1217     type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
1218 
1219 # 0: type, 1: type, 2: fragment
1220 compiler.err.types.incompatible=\
1221     types {0} and {1} are incompatible;\n\
1222     {2}
1223 
1224 # 0: name, 1: list of type
1225 compiler.misc.incompatible.diff.ret=\
1226     both define {0}({1}), but with unrelated return types
1227 
1228 # 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
1229 compiler.misc.incompatible.unrelated.defaults=\
1230     {0} {1} inherits unrelated defaults for {2}({3}) from types {4} and {5}
1231 
1232 # 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
1233 compiler.misc.incompatible.abstract.default=\
1234     {0} {1} inherits abstract and default for {2}({3}) from types {4} and {5}
1235 
1236 # 0: name, 1: kind name, 2: symbol
1237 compiler.err.default.overrides.object.member=\
1238     default method {0} in {1} {2} overrides a member of java.lang.Object
1239 
1240 # 0: type
1241 compiler.err.illegal.static.intf.meth.call=\
1242     illegal static interface method call\n\
1243     the receiver expression should be replaced with the type qualifier &#39;&#39;{0}&#39;&#39;
1244 
1245 # 0: symbol or type, 1: message segment
1246 compiler.err.illegal.default.super.call=\
1247     bad type qualifier {0} in default super call\n\
1248     {1}
1249 
1250 # 0: symbol, 1: type
1251 compiler.misc.overridden.default=\
1252     method {0} is overridden in {1}
1253 
1254 # 0: symbol, 1: type or symbol
1255 compiler.misc.redundant.supertype=\
1256     redundant interface {0} is extended by {1}
1257 
1258 compiler.err.unclosed.char.lit=\
1259     unclosed character literal
1260 
1261 compiler.err.unclosed.comment=\
1262     unclosed comment
1263 
1264 compiler.err.unclosed.str.lit=\
1265     unclosed string literal
1266 
1267 compiler.err.unclosed.text.block=\
1268     unclosed text block
1269 
1270 # 0: string
1271 compiler.err.unsupported.encoding=\
1272     unsupported encoding: {0}
1273 
1274 compiler.err.io.exception=\
1275     error reading source file: {0}
1276 
1277 # 0: name
1278 compiler.err.undef.label=\
1279     undefined label: {0}
1280 
1281 # 0: name
1282 compiler.err.illegal.ref.to.restricted.type=\
1283     illegal reference to restricted type &#39;&#39;{0}&#39;&#39;
1284 
1285 # 0: name
1286 compiler.warn.illegal.ref.to.restricted.type=\
1287     illegal reference to restricted type &#39;&#39;{0}&#39;&#39;
1288 
1289 # 0: name, 1: source
1290 compiler.err.restricted.type.not.allowed=\
1291     &#39;&#39;{0}&#39;&#39; not allowed here\n\
1292     as of release {1}, &#39;&#39;{0}&#39;&#39; is a restricted type name and cannot be used for type declarations
1293 
1294 # 0: name, 1: source
1295 compiler.warn.restricted.type.not.allowed=\
1296     as of release {1}, &#39;&#39;{0}&#39;&#39; is a restricted type name and cannot be used for type declarations or as the element type of an array
1297 
1298 # 0: name, 1: source
1299 compiler.warn.restricted.type.not.allowed.preview=\
1300     &#39;&#39;{0}&#39;&#39; may become a restricted type name in a future release and may be unusable for type declarations or as the element type of an array
1301 
1302 # 0: name (variable), 1: message segment
1303 compiler.err.cant.infer.local.var.type=\
1304     cannot infer type for local variable {0}\n\
1305     ({1})
1306 
1307 # 0: name
1308 compiler.err.restricted.type.not.allowed.here=\
1309     &#39;&#39;{0}&#39;&#39; is not allowed here
1310 
1311 # 0: name
1312 compiler.err.restricted.type.not.allowed.array=\
1313     &#39;&#39;{0}&#39;&#39; is not allowed as an element type of an array
1314 
1315 # 0: name
1316 compiler.err.restricted.type.not.allowed.compound=\
1317     &#39;&#39;{0}&#39;&#39; is not allowed in a compound declaration
1318 
1319 # 0: fragment
1320 compiler.err.invalid.lambda.parameter.declaration=\
1321     invalid lambda parameter declaration\n\
1322     ({0})
1323 
1324 compiler.misc.implicit.and.explicit.not.allowed=\
1325     cannot mix implicitly-typed and explicitly-typed parameters
1326 
1327 compiler.misc.var.and.explicit.not.allowed=\
1328     cannot mix &#39;&#39;var&#39;&#39; and explicitly-typed parameters
1329 
1330 compiler.misc.var.and.implicit.not.allowed=\
1331     cannot mix &#39;&#39;var&#39;&#39; and implicitly-typed parameters
1332 
1333 compiler.misc.local.cant.infer.null=\
1334     variable initializer is &#39;&#39;null&#39;&#39;
1335 
1336 compiler.misc.local.cant.infer.void=\
1337     variable initializer is &#39;&#39;void&#39;&#39;
1338 
1339 compiler.misc.local.missing.init=\
1340     cannot use &#39;&#39;var&#39;&#39; on variable without initializer
1341 
1342 compiler.misc.local.lambda.missing.target=\
1343     lambda expression needs an explicit target-type
1344 
1345 compiler.misc.local.mref.missing.target=\
1346     method reference needs an explicit target-type
1347 
1348 compiler.misc.local.array.missing.target=\
1349     array initializer needs an explicit target-type
1350 
1351 compiler.misc.local.self.ref=\
1352     cannot use &#39;&#39;var&#39;&#39; on self-referencing variable
1353 
1354 # 0: message segment, 1: unused
1355 compiler.err.cant.apply.diamond=\
1356     cannot infer type arguments for {0}
1357 
1358 # 0: message segment or type, 1: message segment
1359 compiler.err.cant.apply.diamond.1=\
1360     cannot infer type arguments for {0}\n\
1361     reason: {1}
1362 
1363 # 0: message segment or type, 1: message segment
1364 compiler.misc.cant.apply.diamond.1=\
1365     cannot infer type arguments for {0}\n\
1366     reason: {1}
1367 
1368 compiler.err.unreachable.stmt=\
1369     unreachable statement
1370 
1371 compiler.err.not.exhaustive=\
1372     the switch expression does not cover all possible input values
1373 
1374 compiler.err.initializer.must.be.able.to.complete.normally=\
1375     initializer must be able to complete normally
1376 
1377 compiler.err.initializer.not.allowed=\
1378     initializers not allowed in interfaces
1379 
1380 # 0: type
1381 compiler.err.unreported.exception.need.to.catch.or.throw=\
1382     unreported exception {0}; must be caught or declared to be thrown
1383 
1384 # 0: type
1385 compiler.err.unreported.exception.default.constructor=\
1386     unreported exception {0} in default constructor
1387 
1388 # 0: type, 1: name
1389 compiler.err.unreported.exception.implicit.close=\
1390     unreported exception {0}; must be caught or declared to be thrown\n\
1391     exception thrown from implicit call to close() on resource variable &#39;&#39;{1}&#39;&#39;
1392 
1393 compiler.err.unsupported.cross.fp.lit=\
1394     hexadecimal floating-point literals are not supported on this VM
1395 
1396 compiler.err.void.not.allowed.here=\
1397     &#39;&#39;void&#39;&#39; type not allowed here
1398 
1399 # 0: string
1400 compiler.err.wrong.number.type.args=\
1401     wrong number of type arguments; required {0}
1402 
1403 # 0: symbol
1404 compiler.err.var.might.already.be.assigned=\
1405     variable {0} might already have been assigned
1406 
1407 # 0: symbol
1408 compiler.err.var.might.not.have.been.initialized=\
1409     variable {0} might not have been initialized
1410 
1411 # 0: symbol
1412 compiler.err.var.not.initialized.in.default.constructor=\
1413     variable {0} not initialized in the default constructor
1414 
1415 # 0: symbol
1416 compiler.err.var.might.be.assigned.in.loop=\
1417     variable {0} might be assigned in loop
1418 
1419 # 0: symbol, 1: message segment
1420 compiler.err.varargs.invalid.trustme.anno=\
1421     Invalid {0} annotation. {1}
1422 
1423 # 0: type
1424 compiler.misc.varargs.trustme.on.reifiable.varargs=\
1425     Varargs element type {0} is reifiable.
1426 
1427 # 0: type, 1: type
1428 compiler.err.instanceof.reifiable.not.safe=\
1429     {0} cannot be safely cast to {1}
1430 
1431 # 0: symbol
1432 compiler.misc.varargs.trustme.on.non.varargs.meth=\
1433     Method {0} is not a varargs method.
1434 
1435 # 0: symbol
1436 compiler.misc.varargs.trustme.on.virtual.varargs=\
1437     Instance method {0} is neither final nor private.
1438 
1439 # 0: symbol
1440 compiler.misc.varargs.trustme.on.virtual.varargs.final.only=\
1441     Instance method {0} is not final.
1442 
1443 # 0: type, 1: symbol kind, 2: symbol
1444 compiler.misc.inaccessible.varargs.type=\
1445     formal varargs element type {0} is not accessible from {1} {2}
1446 
1447 # In the following string, {1} will always be the detail message from
1448 # java.io.IOException.
1449 # 0: symbol, 1: string
1450 compiler.err.class.cant.write=\
1451     error while writing {0}: {1}
1452 
1453 # In the following string, {0} is the name of the class in the Java source.
1454 # It really should be used two times..
1455 # 0: kind name, 1: name
1456 compiler.err.class.public.should.be.in.file=\
1457     {0} {1} is public, should be declared in a file named {1}.java
1458 
1459 ## All errors which do not refer to a particular line in the source code are
1460 ## preceded by this string.
1461 compiler.err.error=\
1462     error:\u0020
1463 
1464 # The following error messages do not refer to a line in the source code.
1465 compiler.err.cant.read.file=\
1466     cannot read: {0}
1467 
1468 # 0: string
1469 compiler.err.plugin.not.found=\
1470     plug-in not found: {0}
1471 
1472 # 0: path
1473 compiler.warn.locn.unknown.file.on.module.path=\
1474     unknown file on module path: {0}
1475 
1476 
1477 # 0: path
1478 compiler.err.locn.bad.module-info=\
1479     problem reading module-info.class in {0}
1480 
1481 # 0: path
1482 compiler.err.locn.cant.read.directory=\
1483     cannot read directory {0}
1484 
1485 # 0: path
1486 compiler.err.locn.cant.read.file=\
1487     cannot read file {0}
1488 
1489 # 0: path
1490 compiler.err.locn.cant.get.module.name.for.jar=\
1491     cannot determine module name for {0}
1492 
1493 # 0: path
1494 compiler.err.multi-module.outdir.cannot.be.exploded.module=\
1495     in multi-module mode, the output directory cannot be an exploded module: {0}
1496 
1497 # 0: path
1498 compiler.warn.outdir.is.in.exploded.module=\
1499     the output directory is within an exploded module: {0}
1500 
1501 # 0: file object
1502 compiler.err.locn.module-info.not.allowed.on.patch.path=\
1503     module-info.class not allowed on patch path: {0}
1504 
1505 # 0: string
1506 compiler.err.locn.invalid.arg.for.xpatch=\
1507     invalid argument for --patch-module option: {0}
1508 
1509 compiler.err.file.sb.on.source.or.patch.path.for.module=\
1510     file should be on source path, or on patch path for module
1511 
1512 #####
1513 
1514 # Fatal Errors
1515 
1516 compiler.misc.fatal.err.no.java.lang=\
1517     Fatal Error: Unable to find package java.lang in classpath or bootclasspath
1518 
1519 # 0: name
1520 compiler.misc.fatal.err.cant.locate.meth=\
1521     Fatal Error: Unable to find method {0}
1522 
1523 # 0: name
1524 compiler.misc.fatal.err.cant.locate.field=\
1525     Fatal Error: Unable to find field {0}
1526 
1527 # 0: type
1528 compiler.misc.fatal.err.cant.locate.ctor=\
1529     Fatal Error: Unable to find constructor for {0}
1530 
1531 compiler.misc.fatal.err.cant.close=\
1532     Fatal Error: Cannot close compiler resources
1533 
1534 #####
1535 
1536 ##
1537 ## miscellaneous strings
1538 ##
1539 
1540 compiler.misc.diamond.anonymous.methods.implicitly.override=\
1541     (due to &lt;&gt;, every non-private method declared in this anonymous class must override or implement a method from a supertype)
1542 
1543 compiler.misc.source.unavailable=\
1544     (source unavailable)
1545 
1546 compiler.misc.base.membership=\
1547     all your base class are belong to us
1548 
1549 # 0: string, 1: string, 2: boolean
1550 compiler.misc.x.print.processor.info=\
1551     Processor {0} matches {1} and returns {2}.
1552 
1553 # 0: number, 1: string, 2: set of symbol, 3: boolean
1554 compiler.misc.x.print.rounds=\
1555     Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}
1556 
1557 # 0: file name
1558 compiler.warn.file.from.future=\
1559     Modification date is in the future for file {0}
1560 
1561 #####
1562 
1563 ## The following string will appear before all messages keyed as:
1564 ## &quot;compiler.note&quot;.
1565 
1566 compiler.note.compressed.diags=\
1567     Some messages have been simplified; recompile with -Xdiags:verbose to get full output
1568 
1569 # 0: boolean, 1: symbol
1570 compiler.note.lambda.stat=\
1571     Translating lambda expression\n\
1572     alternate metafactory = {0}\n\
1573     synthetic method = {1}
1574 
1575 # 0: boolean, 1: unused
1576 compiler.note.mref.stat=\
1577     Translating method reference\n\
1578     alternate metafactory = {0}\n\
1579 
1580 # 0: boolean, 1: symbol
1581 compiler.note.mref.stat.1=\
1582     Translating method reference\n\
1583     alternate metafactory = {0}\n\
1584     bridge method = {1}
1585 
1586 compiler.note.note=\
1587     Note:\u0020
1588 
1589 # 0: file name
1590 compiler.note.deprecated.filename=\
1591     {0} uses or overrides a deprecated API.
1592 
1593 compiler.note.deprecated.plural=\
1594     Some input files use or override a deprecated API.
1595 
1596 # The following string may appear after one of the above deprecation
1597 # messages.
1598 compiler.note.deprecated.recompile=\
1599     Recompile with -Xlint:deprecation for details.
1600 
1601 # 0: file name
1602 compiler.note.deprecated.filename.additional=\
1603     {0} has additional uses or overrides of a deprecated API.
1604 
1605 compiler.note.deprecated.plural.additional=\
1606     Some input files additionally use or override a deprecated API.
1607 
1608 # 0: file name
1609 compiler.note.removal.filename=\
1610     {0} uses or overrides a deprecated API that is marked for removal.
1611 
1612 compiler.note.removal.plural=\
1613     Some input files use or override a deprecated API that is marked for removal.
1614 
1615 # The following string may appear after one of the above removal messages.
1616 compiler.note.removal.recompile=\
1617     Recompile with -Xlint:removal for details.
1618 
1619 # 0: file name
1620 compiler.note.removal.filename.additional=\
1621     {0} has additional uses or overrides of a deprecated API that is marked for removal.
1622 
1623 compiler.note.removal.plural.additional=\
1624     Some input files additionally use or override a deprecated API that is marked for removal.
1625 
1626 # 0: file name
1627 compiler.note.unchecked.filename=\
1628     {0} uses unchecked or unsafe operations.
1629 
1630 compiler.note.unchecked.plural=\
1631     Some input files use unchecked or unsafe operations.
1632 
1633 # The following string may appear after one of the above unchecked messages.
1634 compiler.note.unchecked.recompile=\
1635     Recompile with -Xlint:unchecked for details.
1636 
1637 # 0: file name
1638 compiler.note.unchecked.filename.additional=\
1639     {0} has additional unchecked or unsafe operations.
1640 
1641 compiler.note.unchecked.plural.additional=\
1642     Some input files additionally use unchecked or unsafe operations.
1643 
1644 # 0: file name
1645 compiler.note.preview.filename=\
1646     {0} uses preview language features.
1647 
1648 compiler.note.preview.plural=\
1649     Some input files use preview language features.
1650 
1651 # The following string may appear after one of the above deprecation
1652 # messages.
1653 compiler.note.preview.recompile=\
1654     Recompile with -Xlint:preview for details.
1655 
1656 # 0: file name
1657 compiler.note.preview.filename.additional=\
1658     {0} has additional uses of preview language features.
1659 
1660 compiler.note.preview.plural.additional=\
1661     Some input files additionally use preview language features.
1662 
1663 # Notes related to annotation processing
1664 
1665 # Print a client-generated note; assumed to be localized, no translation required
1666 # 0: string
1667 compiler.note.proc.messager=\
1668     {0}
1669 
1670 # 0: string, 1: string, 2: string
1671 compiler.note.multiple.elements=\
1672     Multiple elements named &#39;&#39;{1}&#39;&#39; in modules &#39;&#39;{2}&#39;&#39; were found by javax.lang.model.util.Elements.{0}.
1673 
1674 #####
1675 
1676 # 0: number
1677 compiler.misc.count.error=\
1678     {0} error
1679 
1680 # 0: number
1681 compiler.misc.count.error.plural=\
1682     {0} errors
1683 
1684 # 0: number, 1: number
1685 compiler.misc.count.error.recompile=\
1686     only showing the first {0} errors, of {1} total; use -Xmaxerrs if you would like to see more
1687 
1688 # 0: number, 1: number
1689 compiler.misc.count.warn.recompile=\
1690     only showing the first {0} warnings, of {1} total; use -Xmaxwarns if you would like to see more
1691 
1692 # 0: number
1693 compiler.misc.count.warn=\
1694     {0} warning
1695 
1696 # 0: number
1697 compiler.misc.count.warn.plural=\
1698     {0} warnings
1699 
1700 compiler.misc.version.not.available=\
1701     (version info not available)
1702 
1703 ## extra output when using -verbose (JavaCompiler)
1704 
1705 # 0: symbol
1706 compiler.misc.verbose.checking.attribution=\
1707     [checking {0}]
1708 
1709 # 0: string
1710 compiler.misc.verbose.parsing.done=\
1711     [parsing completed {0}ms]
1712 
1713 # 0: file name
1714 compiler.misc.verbose.parsing.started=\
1715     [parsing started {0}]
1716 
1717 # 0: string
1718 compiler.misc.verbose.total=\
1719     [total {0}ms]
1720 
1721 # 0: file name
1722 compiler.misc.verbose.wrote.file=\
1723     [wrote {0}]
1724 
1725 ## extra output when using -verbose (code/ClassReader)
1726 # 0: string
1727 compiler.misc.verbose.loading=\
1728     [loading {0}]
1729 
1730 # 0: string
1731 compiler.misc.verbose.sourcepath=\
1732     [search path for source files: {0}]
1733 
1734 # 0: string
1735 compiler.misc.verbose.classpath=\
1736     [search path for class files: {0}]
1737 
1738 ## extra output when using -prompt (util/Log)
1739 compiler.misc.resume.abort=\
1740     R)esume, A)bort&gt;
1741 
1742 #####
1743 
1744 ##
1745 ## warnings
1746 ##
1747 
1748 ## All warning messages are preceded by the following string.
1749 compiler.warn.warning=\
1750     warning:\u0020
1751 
1752 ## Warning messages may also include the following prefix to identify a
1753 ## lint option
1754 # 0: option name
1755 compiler.warn.lintOption=\
1756     [{0}]\u0020
1757 
1758 # 0: symbol
1759 compiler.warn.constant.SVUID=\
1760     serialVersionUID must be constant in class {0}
1761 
1762 # 0: path
1763 compiler.warn.dir.path.element.not.found=\
1764     bad path element &quot;{0}&quot;: no such directory
1765 
1766 # 0: file name
1767 compiler.warn.dir.path.element.not.directory=\
1768     bad path element &quot;{0}&quot;: not a directory
1769 
1770 compiler.warn.finally.cannot.complete=\
1771     finally clause cannot complete normally
1772 
1773 # 0: name
1774 compiler.warn.poor.choice.for.module.name=\
1775     module name component {0} should avoid terminal digits
1776 
1777 # 0: string
1778 compiler.warn.incubating.modules=\
1779     using incubating module(s): {0}
1780 
1781 compiler.warn.get.class.compared.with.interface=\
1782     return value of getClass() can never equal the class literal of an interface
1783 
1784 # 0: symbol, 1: symbol
1785 compiler.warn.has.been.deprecated=\
1786     {0} in {1} has been deprecated
1787 
1788 # 0: symbol, 1: symbol
1789 compiler.warn.has.been.deprecated.for.removal=\
1790     {0} in {1} has been deprecated and marked for removal
1791 
1792 # 0: symbol
1793 compiler.warn.is.preview=\
1794     {0} is an API that is part of a preview feature
1795 
1796 # 0: symbol
1797 compiler.err.is.preview=\
1798     {0} is an API that is part of a preview feature
1799 
1800 # 0: symbol
1801 compiler.warn.has.been.deprecated.module=\
1802     module {0} has been deprecated
1803 
1804 # 0: symbol
1805 compiler.warn.has.been.deprecated.for.removal.module=\
1806     module {0} has been deprecated and marked for removal
1807 
1808 # 0: symbol
1809 compiler.warn.sun.proprietary=\
1810     {0} is internal proprietary API and may be removed in a future release
1811 
1812 compiler.warn.illegal.char.for.encoding=\
1813     unmappable character for encoding {0}
1814 
1815 # 0: symbol
1816 compiler.warn.improper.SVUID=\
1817     serialVersionUID must be declared static final in class {0}
1818 
1819 # 0: type, 1: type
1820 compiler.warn.inexact.non-varargs.call=\
1821     non-varargs call of varargs method with inexact argument type for last parameter;\n\
1822     cast to {0} for a varargs call\n\
1823     cast to {1} for a non-varargs call and to suppress this warning
1824 
1825 # 0: list of type
1826 compiler.warn.unreachable.catch=\
1827     unreachable catch clause\n\
1828     thrown type {0} has already been caught
1829 
1830 # 0: list of type
1831 compiler.warn.unreachable.catch.1=\
1832     unreachable catch clause\n\
1833     thrown types {0} have already been caught
1834 
1835 # 0: symbol
1836 compiler.warn.long.SVUID=\
1837     serialVersionUID must be of type long in class {0}
1838 
1839 # 0: symbol
1840 compiler.warn.missing.SVUID=\
1841     serializable class {0} has no definition of serialVersionUID
1842 
1843 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
1844 compiler.warn.potentially.ambiguous.overload=\
1845     {0} in {1} is potentially ambiguous with {2} in {3}
1846 
1847 # 0: message segment
1848 compiler.warn.override.varargs.missing=\
1849     {0}; overridden method has no &#39;&#39;...&#39;&#39;
1850 
1851 # 0: message segment
1852 compiler.warn.override.varargs.extra=\
1853     {0}; overriding method is missing &#39;&#39;...&#39;&#39;
1854 
1855 # 0: message segment
1856 compiler.warn.override.bridge=\
1857     {0}; overridden method is a bridge method
1858 
1859 # 0: symbol
1860 compiler.warn.pkg-info.already.seen=\
1861     a package-info.java file has already been seen for package {0}
1862 
1863 # 0: path
1864 compiler.warn.path.element.not.found=\
1865     bad path element &quot;{0}&quot;: no such file or directory
1866 
1867 compiler.warn.possible.fall-through.into.case=\
1868     possible fall-through into case
1869 
1870 # 0: type
1871 compiler.warn.redundant.cast=\
1872     redundant cast to {0}
1873 
1874 # 0: number
1875 compiler.warn.position.overflow=\
1876     Position encoding overflows at line {0}
1877 
1878 # 0: file name, 1: number, 2: number
1879 compiler.warn.big.major.version=\
1880     {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\
1881     It is recommended that the compiler be upgraded.
1882 
1883 # 0: kind name, 1: symbol
1884 compiler.warn.static.not.qualified.by.type=\
1885     static {0} should be qualified by type name, {1}, instead of by an expression
1886 
1887 # 0: string
1888 compiler.warn.source.no.bootclasspath=\
1889     bootstrap class path not set in conjunction with -source {0}
1890 
1891 # 0: string
1892 compiler.warn.source.no.system.modules.path=\
1893     system modules path not set in conjunction with -source {0}
1894 
1895 # 0: string
1896 compiler.warn.option.obsolete.source=\
1897     source value {0} is obsolete and will be removed in a future release
1898 
1899 # 0: target
1900 compiler.warn.option.obsolete.target=\
1901     target value {0} is obsolete and will be removed in a future release
1902 
1903 # 0: string, 1: string
1904 compiler.err.option.removed.source=\
1905     Source option {0} is no longer supported. Use {1} or later.
1906 
1907 # 0: target, 1: target
1908 compiler.err.option.removed.target=\
1909     Target option {0} is no longer supported. Use {1} or later.
1910 
1911 
1912 # 0: target, 1: target
1913 compiler.warn.option.parameters.unsupported=\
1914     -parameters is not supported for target value {0}. Use {1} or later.
1915 
1916 compiler.warn.option.obsolete.suppression=\
1917     To suppress warnings about obsolete options, use -Xlint:-options.
1918 
1919 # 0: name, 1: number, 2: number, 3: number, 4: number
1920 compiler.warn.future.attr=\
1921     {0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files
1922 
1923 compiler.warn.requires.automatic=\
1924     requires directive for an automatic module
1925 
1926 compiler.warn.requires.transitive.automatic=\
1927     requires transitive directive for an automatic module
1928 
1929 # Warnings related to annotation processing
1930 # 0: string
1931 compiler.warn.proc.package.does.not.exist=\
1932     package {0} does not exist
1933 
1934 # 0: string
1935 compiler.warn.proc.file.reopening=\
1936     Attempt to create a file for &#39;&#39;{0}&#39;&#39; multiple times
1937 
1938 # 0: string
1939 compiler.warn.proc.type.already.exists=\
1940     A file for type &#39;&#39;{0}&#39;&#39; already exists on the sourcepath or classpath
1941 
1942 # 0: string
1943 compiler.warn.proc.type.recreate=\
1944     Attempt to create a file for type &#39;&#39;{0}&#39;&#39; multiple times
1945 
1946 # 0: string
1947 compiler.warn.proc.illegal.file.name=\
1948     Cannot create file for illegal name &#39;&#39;{0}&#39;&#39;.
1949 
1950 # 0: string, 1: string
1951 compiler.warn.proc.suspicious.class.name=\
1952     Creating file for a type whose name ends in {1}: &#39;&#39;{0}&#39;&#39;
1953 
1954 # 0: string
1955 compiler.warn.proc.file.create.last.round=\
1956     File for type &#39;&#39;{0}&#39;&#39; created in the last round will not be subject to annotation processing.
1957 
1958 # 0: string, 1: string
1959 compiler.warn.proc.malformed.supported.string=\
1960     Malformed string &#39;&#39;{0}&#39;&#39; for a supported annotation type returned by processor &#39;&#39;{1}&#39;&#39;
1961 
1962 # 0: set of string
1963 compiler.warn.proc.annotations.without.processors=\
1964     No processor claimed any of these annotations: {0}
1965 
1966 # 0: source version, 1: string, 2: string
1967 compiler.warn.proc.processor.incompatible.source.version=\
1968     Supported source version &#39;&#39;{0}&#39;&#39; from annotation processor &#39;&#39;{1}&#39;&#39; less than -source &#39;&#39;{2}&#39;&#39;
1969 
1970 # 0: string, 1: string
1971 compiler.warn.proc.duplicate.option.name=\
1972     Duplicate supported option &#39;&#39;{0}&#39;&#39; returned by annotation processor &#39;&#39;{1}&#39;&#39;
1973 
1974 # 0: string, 1: string
1975 compiler.warn.proc.duplicate.supported.annotation=\
1976     Duplicate supported annotation type &#39;&#39;{0}&#39;&#39; returned by annotation processor &#39;&#39;{1}&#39;&#39;
1977 
1978 # 0: string
1979 compiler.warn.proc.redundant.types.with.wildcard=\
1980     Annotation processor &#39;&#39;{0}&#39;&#39; redundantly supports both &#39;&#39;*&#39;&#39; and other annotation types
1981 
1982 compiler.warn.proc.proc-only.requested.no.procs=\
1983     Annotation processing without compilation requested but no processors were found.
1984 
1985 compiler.warn.proc.use.implicit=\
1986     Implicitly compiled files were not subject to annotation processing.\n\
1987     Use -implicit to specify a policy for implicit compilation.
1988 
1989 compiler.warn.proc.use.proc.or.implicit=\
1990     Implicitly compiled files were not subject to annotation processing.\n\
1991     Use -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.
1992 
1993 # Print a client-generated warning; assumed to be localized, no translation required
1994 # 0: string
1995 compiler.warn.proc.messager=\
1996     {0}
1997 
1998 # 0: set of string
1999 compiler.warn.proc.unclosed.type.files=\
2000     Unclosed files for the types &#39;&#39;{0}&#39;&#39;; these types will not undergo annotation processing
2001 
2002 # 0: string
2003 compiler.warn.proc.unmatched.processor.options=\
2004     The following options were not recognized by any processor: &#39;&#39;{0}&#39;&#39;
2005 
2006 compiler.warn.try.explicit.close.call=\
2007     explicit call to close() on an auto-closeable resource
2008 
2009 # 0: symbol
2010 compiler.warn.try.resource.not.referenced=\
2011     auto-closeable resource {0} is never referenced in body of corresponding try statement
2012 
2013 # 0: type
2014 compiler.warn.try.resource.throws.interrupted.exc=\
2015     auto-closeable resource {0} has a member method close() that could throw InterruptedException
2016 
2017 compiler.warn.unchecked.assign=\
2018     unchecked assignment: {0} to {1}
2019 
2020 # 0: symbol, 1: type
2021 compiler.warn.unchecked.assign.to.var=\
2022     unchecked assignment to variable {0} as member of raw type {1}
2023 
2024 # 0: symbol, 1: type
2025 compiler.warn.unchecked.call.mbr.of.raw.type=\
2026     unchecked call to {0} as a member of the raw type {1}
2027 
2028 compiler.warn.unchecked.cast.to.type=\
2029     unchecked cast to type {0}
2030 
2031 # 0: kind name, 1: name, 2: object, 3: object, 4: kind name, 5: symbol
2032 compiler.warn.unchecked.meth.invocation.applied=\
2033     unchecked method invocation: {0} {1} in {4} {5} is applied to given types\n\
2034     required: {2}\n\
2035     found:    {3}
2036 
2037 # 0: type
2038 compiler.warn.unchecked.generic.array.creation=\
2039     unchecked generic array creation for varargs parameter of type {0}
2040 
2041 # 0: type
2042 compiler.warn.unchecked.varargs.non.reifiable.type=\
2043     Possible heap pollution from parameterized vararg type {0}
2044 
2045 # 0: symbol
2046 compiler.warn.varargs.unsafe.use.varargs.param=\
2047     Varargs method could cause heap pollution from non-reifiable varargs parameter {0}
2048 
2049 compiler.warn.missing.deprecated.annotation=\
2050     deprecated item is not annotated with @Deprecated
2051 
2052 # 0: kind name
2053 compiler.warn.deprecated.annotation.has.no.effect=\
2054     @Deprecated annotation has no effect on this {0} declaration
2055 
2056 # 0: string
2057 compiler.warn.invalid.path=\
2058     Invalid filename: {0}
2059 
2060 # 0: string
2061 compiler.err.invalid.path=\
2062     Invalid filename: {0}
2063 
2064 
2065 # 0: path
2066 compiler.warn.invalid.archive.file=\
2067     Unexpected file on path: {0}
2068 
2069 # 0: path
2070 compiler.warn.unexpected.archive.file=\
2071     Unexpected extension for archive file: {0}
2072 
2073 # 0: path
2074 compiler.err.no.zipfs.for.archive=\
2075     No file system provider is available to handle this file: {0}
2076 
2077 compiler.warn.div.zero=\
2078     division by zero
2079 
2080 compiler.warn.empty.if=\
2081     empty statement after if
2082 
2083 # 0: type, 1: name
2084 compiler.warn.annotation.method.not.found=\
2085     Cannot find annotation method &#39;&#39;{1}()&#39;&#39; in type &#39;&#39;{0}&#39;&#39;
2086 
2087 # 0: type, 1: name, 2: message segment
2088 compiler.warn.annotation.method.not.found.reason=\
2089     Cannot find annotation method &#39;&#39;{1}()&#39;&#39; in type &#39;&#39;{0}&#39;&#39;: {2}
2090 
2091 # 0: file object, 1: symbol, 2: name
2092 compiler.warn.unknown.enum.constant=\
2093     unknown enum constant {1}.{2}
2094 
2095 # 0: file object, 1: symbol, 2: name, 3: message segment
2096 compiler.warn.unknown.enum.constant.reason=\
2097     unknown enum constant {1}.{2}\n\
2098     reason: {3}
2099 
2100 # 0: type, 1: type
2101 compiler.warn.raw.class.use=\
2102     found raw type: {0}\n\
2103     missing type arguments for generic class {1}
2104 
2105 compiler.warn.diamond.redundant.args=\
2106     Redundant type arguments in new expression (use diamond operator instead).
2107 
2108 compiler.warn.local.redundant.type=\
2109     Redundant type for local variable (replace explicit type with &#39;&#39;var&#39;&#39;).
2110 
2111 compiler.warn.potential.lambda.found=\
2112     This anonymous inner class creation can be turned into a lambda expression.
2113 
2114 compiler.warn.method.redundant.typeargs=\
2115     Redundant type arguments in method call.
2116 
2117 # 0: symbol, 1: message segment
2118 compiler.warn.varargs.redundant.trustme.anno=\
2119     Redundant {0} annotation. {1}
2120 
2121 # 0: symbol
2122 compiler.warn.access.to.member.from.serializable.element=\
2123     access to member {0} from serializable element can be publicly accessible to untrusted code
2124 
2125 # 0: symbol
2126 compiler.warn.access.to.member.from.serializable.lambda=\
2127     access to member {0} from serializable lambda can be publicly accessible to untrusted code
2128 
2129 #####
2130 
2131 ## The following are tokens which are non-terminals in the language. They should
2132 ## be named as JLS3 calls them when translated to the appropriate language.
2133 compiler.misc.token.identifier=\
2134     &lt;identifier&gt;
2135 
2136 compiler.misc.token.character=\
2137     &lt;character&gt;
2138 
2139 compiler.misc.token.string=\
2140     &lt;string&gt;
2141 
2142 compiler.misc.token.integer=\
2143     &lt;integer&gt;
2144 
2145 compiler.misc.token.long-integer=\
2146     &lt;long integer&gt;
2147 
2148 compiler.misc.token.float=\
2149     &lt;float&gt;
2150 
2151 compiler.misc.token.double=\
2152     &lt;double&gt;
2153 
2154 compiler.misc.token.bad-symbol=\
2155     &lt;bad symbol&gt;
2156 
2157 compiler.misc.token.end-of-input=\
2158     &lt;end of input&gt;
2159 
2160 ## The argument to the following string will always be one of the following:
2161 ## 1. one of the above non-terminals
2162 ## 2. a keyword (JLS1.8)
2163 ## 3. a boolean literal (JLS3.10.3)
2164 ## 4. the null literal (JLS3.10.7)
2165 ## 5. a Java separator (JLS3.11)
2166 ## 6. an operator (JLS3.12)
2167 ##
2168 ## This is the only place these tokens will be used.
2169 # 0: token
2170 compiler.err.expected=\
2171     {0} expected
2172 
2173 # 0: string
2174 compiler.err.expected.str=\
2175     {0} expected
2176 
2177 # 0: token, 1: token
2178 compiler.err.expected2=\
2179     {0} or {1} expected
2180 
2181 # 0: token, 1: token, 2: token
2182 compiler.err.expected3=\
2183     {0}, {1}, or {2} expected
2184 
2185 # 0: token, 1: token, 2: token, 3: string
2186 compiler.err.expected4=\
2187     {0}, {1}, {2}, or {3} expected
2188 
2189 compiler.err.premature.eof=\
2190     reached end of file while parsing
2191 
2192 compiler.err.enum.constant.expected=\
2193     enum constant expected here
2194 
2195 compiler.err.enum.constant.not.expected=\
2196     enum constant not expected here
2197 
2198 ## The following are related in form, but do not easily fit the above paradigm.
2199 compiler.err.expected.module=\
2200     &#39;&#39;module&#39;&#39; expected
2201 
2202 compiler.err.expected.module.or.open=\
2203     &#39;&#39;module&#39;&#39; or &#39;&#39;open&#39;&#39; expected
2204 
2205 compiler.err.dot.class.expected=\
2206     &#39;&#39;.class&#39;&#39; expected
2207 
2208 ## The argument to this string will always be either &#39;case&#39; or &#39;default&#39;.
2209 # 0: token
2210 compiler.err.orphaned=\
2211     orphaned {0}
2212 
2213 # 0: name
2214 compiler.misc.anonymous.class=\
2215     &lt;anonymous {0}&gt;
2216 
2217 # 0: name, 1: type
2218 compiler.misc.type.captureof=\
2219     capture#{0} of {1}
2220 
2221 compiler.misc.type.captureof.1=\
2222     capture#{0}
2223 
2224 compiler.misc.type.none=\
2225     &lt;none&gt;
2226 
2227 compiler.misc.unnamed.package=\
2228     unnamed package
2229 
2230 compiler.misc.unnamed.module=\
2231     unnamed module
2232 
2233 #####
2234 
2235 # 0: symbol, 1: message segment
2236 compiler.err.cant.access=\
2237     cannot access {0}\n\
2238     {1}
2239 
2240 # 0: name
2241 compiler.misc.bad.class.file=\
2242     class file is invalid for class {0}
2243 
2244 # 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
2245 compiler.misc.bad.const.pool.entry=\
2246     bad constant pool entry in {0}\n\
2247     expected {1} at index {2}
2248 
2249 # 0: file name, 1: number (constant pool index), 2: number (constant pool size)
2250 compiler.misc.bad.const.pool.index=\
2251     bad constant pool index in {0}\n\
2252     index {1} is not within pool size {2}.
2253 
2254 # 0: file name, 1: message segment
2255 compiler.misc.bad.class.file.header=\
2256     bad class file: {0}\n\
2257     {1}\n\
2258     Please remove or make sure it appears in the correct subdirectory of the classpath.
2259 
2260 # 0: file name, 1: message segment
2261 compiler.misc.bad.source.file.header=\
2262     bad source file: {0}\n\
2263     {1}\n\
2264     Please remove or make sure it appears in the correct subdirectory of the sourcepath.
2265 
2266 ## The following are all possible strings for the second argument ({1}) of the
2267 ## above strings.
2268 compiler.misc.bad.class.signature=\
2269     bad class signature: {0}
2270 
2271 #0: symbol, 1: symbol
2272 compiler.misc.bad.enclosing.class=\
2273     bad enclosing class for {0}: {1}
2274 
2275 # 0: symbol
2276 compiler.misc.bad.enclosing.method=\
2277     bad enclosing method attribute for class {0}
2278 
2279 compiler.misc.bad.runtime.invisible.param.annotations=\
2280     bad RuntimeInvisibleParameterAnnotations attribute: {0}
2281 
2282 compiler.misc.bad.const.pool.tag=\
2283     bad constant pool tag: {0}
2284 
2285 compiler.misc.bad.const.pool.tag.at=\
2286     bad constant pool tag: {0} at {1}
2287 
2288 compiler.misc.bad.signature=\
2289     bad signature: {0}
2290 
2291 compiler.misc.bad.type.annotation.value=\
2292     bad type annotation target type value: {0}
2293 
2294 compiler.misc.bad.module-info.name=\
2295     bad class name
2296 
2297 compiler.misc.class.file.wrong.class=\
2298     class file contains wrong class: {0}
2299 
2300 compiler.misc.module.info.invalid.super.class=\
2301     module-info with invalid super class
2302 
2303 # 0: name
2304 compiler.misc.class.file.not.found=\
2305     class file for {0} not found
2306 
2307 # 0: string (constant value), 1: symbol (constant field), 2: type (field type)
2308 compiler.misc.bad.constant.range=\
2309     constant value &#39;&#39;{0}&#39;&#39; for {1} is outside the expected range for {2}
2310 
2311 # 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
2312 compiler.misc.bad.constant.value=\
2313     bad constant value &#39;&#39;{0}&#39;&#39; for {1}, expected {2}
2314 
2315 # 0: type (field type)
2316 compiler.misc.bad.constant.value.type=\
2317     variable of type &#39;&#39;{0}&#39;&#39; cannot have a constant value, but has one specified
2318 
2319 # 0: string (classfile major version), 1: string (classfile minor version)
2320 compiler.misc.invalid.default.interface=\
2321     default method found in version {0}.{1} classfile
2322 
2323 # 0: string (classfile major version), 1: string (classfile minor version)
2324 compiler.misc.invalid.static.interface=\
2325     static method found in version {0}.{1} classfile
2326 
2327 # 0: string (classfile major version), 1: string (classfile minor version)
2328 compiler.misc.anachronistic.module.info=\
2329     module declaration found in version {0}.{1} classfile
2330 
2331 # 0: name
2332 compiler.misc.file.doesnt.contain.class=\
2333     file does not contain class {0}
2334 
2335 # 0: symbol
2336 compiler.misc.file.does.not.contain.package=\
2337     file does not contain package {0}
2338 
2339 compiler.misc.file.does.not.contain.module=\
2340     file does not contain module declaration
2341 
2342 compiler.misc.illegal.start.of.class.file=\
2343     illegal start of class file
2344 
2345 compiler.misc.unable.to.access.file=\
2346     unable to access file: {0}
2347 
2348 compiler.misc.unicode.str.not.supported=\
2349     unicode string in class file not supported
2350 
2351 compiler.misc.undecl.type.var=\
2352     undeclared type variable: {0}
2353 
2354 compiler.misc.malformed.vararg.method=\
2355     class file contains malformed variable arity method: {0}
2356 
2357 compiler.misc.wrong.version=\
2358     class file has wrong version {0}.{1}, should be {2}.{3}
2359 
2360 #####
2361 
2362 # 0: type, 1: type or symbol
2363 compiler.err.not.within.bounds=\
2364     type argument {0} is not within bounds of type-variable {1}
2365 
2366 ## The following are all possible strings for the second argument ({1}) of the
2367 ## above string.
2368 
2369 ## none yet...
2370 
2371 #####
2372 
2373 # 0: message segment
2374 compiler.err.prob.found.req=\
2375     incompatible types: {0}
2376 
2377 # 0: message segment
2378 compiler.misc.prob.found.req=\
2379     incompatible types: {0}
2380 
2381 # 0: message segment, 1: type, 2: type
2382 compiler.warn.prob.found.req=\
2383     {0}\n\
2384     required: {2}\n\
2385     found:    {1}
2386 
2387 # 0: type, 1: type
2388 compiler.misc.inconvertible.types=\
2389     {0} cannot be converted to {1}
2390 
2391 # 0: type, 1: type
2392 compiler.misc.possible.loss.of.precision=\
2393     possible lossy conversion from {0} to {1}
2394 
2395 compiler.misc.unchecked.assign=\
2396     unchecked conversion
2397 
2398 # compiler.misc.storecheck=\
2399 #     assignment might cause later store checks to fail
2400 # compiler.misc.unchecked=\
2401 #     assigned array cannot dynamically check its stores
2402 compiler.misc.unchecked.cast.to.type=\
2403     unchecked cast
2404 
2405 # compiler.err.star.expected=\
2406 #     &#39;&#39;*&#39;&#39; expected
2407 # compiler.err.no.elem.type=\
2408 #     \[\*\] cannot have a type
2409 
2410 # 0: message segment
2411 compiler.misc.try.not.applicable.to.type=\
2412     try-with-resources not applicable to variable type\n\
2413     ({0})
2414 
2415 #####
2416 
2417 # 0: object, 1: message segment
2418 compiler.err.type.found.req=\
2419     unexpected type\n\
2420     required: {1}\n\
2421     found:    {0}
2422 
2423 ## The following are all possible strings for the first argument ({0}) of the
2424 ## above string.
2425 compiler.misc.type.req.class=\
2426     class
2427 
2428 compiler.misc.type.req.class.array=\
2429     class or array
2430 
2431 compiler.misc.type.req.array.or.iterable=\
2432     array or java.lang.Iterable
2433 
2434 compiler.misc.type.req.ref=\
2435     reference
2436 
2437 compiler.misc.type.req.exact=\
2438     class or interface without bounds
2439 
2440 # 0: type
2441 compiler.misc.type.parameter=\
2442     type parameter {0}
2443 
2444 #####
2445 
2446 ## The following are all possible strings for the last argument of all those
2447 ## diagnostics whose key ends in &quot;.1&quot;
2448 
2449 # 0: type, 1: list of type
2450 compiler.misc.no.unique.maximal.instance.exists=\
2451     no unique maximal instance exists for type variable {0} with upper bounds {1}
2452 
2453 # 0: type, 1: list of type
2454 compiler.misc.no.unique.minimal.instance.exists=\
2455     no unique minimal instance exists for type variable {0} with lower bounds {1}
2456 
2457 # 0: type, 1: list of type
2458 compiler.misc.incompatible.upper.bounds=\
2459     inference variable {0} has incompatible upper bounds {1}
2460 
2461 # 0: type, 1: list of type
2462 compiler.misc.incompatible.eq.bounds=\
2463     inference variable {0} has incompatible equality constraints {1}
2464 
2465 # 0: type, 1: fragment, 2: fragment
2466 compiler.misc.incompatible.bounds=\
2467     inference variable {0} has incompatible bounds\n\
2468     {1}\n\
2469     {2}
2470 
2471 # 0: list of type
2472 compiler.misc.lower.bounds=\
2473         lower bounds: {0}
2474 
2475 # 0: list of type
2476 compiler.misc.eq.bounds=\
2477         equality constraints: {0}
2478 
2479 # 0: list of type
2480 compiler.misc.upper.bounds=\
2481         lower bounds: {0}
2482 
2483 # 0: list of type, 1: type, 2: type
2484 compiler.misc.infer.no.conforming.instance.exists=\
2485     no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}
2486 
2487 # 0: list of type, 1: message segment
2488 compiler.misc.infer.no.conforming.assignment.exists=\
2489     cannot infer type-variable(s) {0}\n\
2490     (argument mismatch; {1})
2491 
2492 # 0: list of type
2493 compiler.misc.infer.arg.length.mismatch=\
2494     cannot infer type-variable(s) {0}\n\
2495     (actual and formal argument lists differ in length)
2496 
2497 # 0: list of type, 1: message segment
2498 compiler.misc.infer.varargs.argument.mismatch=\
2499     cannot infer type-variable(s) {0}\n\
2500     (varargs mismatch; {1})
2501 
2502 # 0: type, 1: list of type
2503 compiler.misc.inferred.do.not.conform.to.upper.bounds=\
2504     inferred type does not conform to upper bound(s)\n\
2505     inferred: {0}\n\
2506     upper bound(s): {1}
2507 
2508 # 0: type, 1: list of type
2509 compiler.misc.inferred.do.not.conform.to.lower.bounds=\
2510     inferred type does not conform to lower bound(s)\n\
2511     inferred: {0}\n\
2512     lower bound(s): {1}
2513 
2514 # 0: type, 1: list of type
2515 compiler.misc.inferred.do.not.conform.to.eq.bounds=\
2516     inferred type does not conform to equality constraint(s)\n\
2517     inferred: {0}\n\
2518     equality constraints(s): {1}
2519 
2520 # 0: symbol
2521 compiler.misc.diamond=\
2522     {0}&lt;&gt;
2523 
2524 # 0: type
2525 compiler.misc.diamond.non.generic=\
2526     cannot use &#39;&#39;&lt;&gt;&#39;&#39; with non-generic class {0}
2527 
2528 # 0: list of type, 1: message segment
2529 compiler.misc.diamond.invalid.arg=\
2530     type argument {0} inferred for {1} is not allowed in this context\n\
2531     inferred argument is not expressible in the Signature attribute
2532 
2533 # 0: list of type, 1: message segment
2534 compiler.misc.diamond.invalid.args=\
2535     type arguments {0} inferred for {1} are not allowed in this context\n\
2536     inferred arguments are not expressible in the Signature attribute
2537 
2538 # 0: type
2539 compiler.misc.diamond.and.explicit.params=\
2540     cannot use &#39;&#39;&lt;&gt;&#39;&#39; with explicit type parameters for constructor
2541 
2542 compiler.misc.mref.infer.and.explicit.params=\
2543     cannot use raw constructor reference with explicit type parameters for constructor
2544 
2545 # 0: type, 1: list of type
2546 compiler.misc.explicit.param.do.not.conform.to.bounds=\
2547     explicit type argument {0} does not conform to declared bound(s) {1}
2548 
2549 compiler.misc.arg.length.mismatch=\
2550     actual and formal argument lists differ in length
2551 
2552 # 0: string
2553 compiler.misc.wrong.number.type.args=\
2554     wrong number of type arguments; required {0}
2555 
2556 # 0: message segment
2557 compiler.misc.no.conforming.assignment.exists=\
2558     argument mismatch; {0}
2559 
2560 # 0: message segment
2561 compiler.misc.varargs.argument.mismatch=\
2562     varargs mismatch; {0}
2563 
2564 #####
2565 
2566 # 0: symbol or type, 1: file name
2567 compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\
2568     auxiliary class {0} in {1} should not be accessed from outside its own source file
2569 
2570 ## The first argument ({0}) is a &quot;kindname&quot;.
2571 # 0: kind name, 1: symbol, 2: symbol
2572 compiler.err.abstract.cant.be.accessed.directly=\
2573     abstract {0} {1} in {2} cannot be accessed directly
2574 
2575 ## The first argument ({0}) is a &quot;kindname&quot;.
2576 # 0: symbol kind, 1: symbol
2577 compiler.err.non-static.cant.be.ref=\
2578     non-static {0} {1} cannot be referenced from a static context
2579 
2580 # 0: symbol kind, 1: symbol
2581 compiler.misc.bad.static.method.in.unbound.lookup=\
2582     unexpected static {0} {1} found in unbound lookup
2583 
2584 # 0: symbol kind, 1: symbol
2585 compiler.misc.bad.instance.method.in.unbound.lookup=\
2586     unexpected instance {0} {1} found in unbound lookup
2587 
2588 # 0: symbol kind, 1: symbol
2589 compiler.misc.bad.static.method.in.bound.lookup=\
2590     unexpected static {0} {1} found in bound lookup
2591 
2592 ## Both arguments ({0}, {1}) are &quot;kindname&quot;s.  {0} is a comma-separated list
2593 ## of kindnames (the list should be identical to that provided in source.
2594 # 0: set of kind name, 1: set of kind name
2595 compiler.err.unexpected.type=\
2596     unexpected type\n\
2597     required: {0}\n\
2598     found:    {1}
2599 
2600 compiler.err.unexpected.lambda=\
2601    lambda expression not expected here
2602 
2603 compiler.err.unexpected.mref=\
2604    method reference not expected here
2605 
2606 ## The first argument {0} is a &quot;kindname&quot; (e.g. &#39;constructor&#39;, &#39;field&#39;, etc.)
2607 ## The second argument {1} is the non-resolved symbol
2608 ## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
2609 ## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
2610 # 0: kind name, 1: name, 2: unused, 3: unused
2611 compiler.err.cant.resolve=\
2612     cannot find symbol\n\
2613     symbol: {0} {1}
2614 
2615 # 0: kind name, 1: name, 2: unused, 3: list of type
2616 compiler.err.cant.resolve.args=\
2617     cannot find symbol\n\
2618     symbol: {0} {1}({3})
2619 
2620 # 0: kind name, 1: name, 2: unused, 3: list of type
2621 compiler.misc.cant.resolve.args=\
2622     cannot find symbol\n\
2623     symbol: {0} {1}({3})
2624 
2625 # 0: kind name, 1: name, 2: list of type, 3: list of type
2626 compiler.err.cant.resolve.args.params=\
2627     cannot find symbol\n\
2628     symbol: {0} &lt;{2}&gt;{1}({3})
2629 
2630 ## arguments from {0} to {3} have the same meaning as above
2631 ## The fifth argument {4} is a location subdiagnostic (see below)
2632 # 0: kind name, 1: name, 2: unused, 3: unused, 4: message segment
2633 compiler.err.cant.resolve.location=\
2634     cannot find symbol\n\
2635     symbol:   {0} {1}\n\
2636     location: {4}
2637 
2638 # 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
2639 compiler.err.cant.resolve.location.args=\
2640     cannot find symbol\n\
2641     symbol:   {0} {1}({3})\n\
2642     location: {4}
2643 
2644 # 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
2645 compiler.err.cant.resolve.location.args.params=\
2646     cannot find symbol\n\
2647     symbol:   {0} &lt;{2}&gt;{1}({3})\n\
2648     location: {4}
2649 
2650 ### Following are replicated/used for method reference diagnostics
2651 
2652 # 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
2653 compiler.misc.cant.resolve.location.args=\
2654     cannot find symbol\n\
2655     symbol:   {0} {1}({3})\n\
2656     location: {4}
2657 
2658 # 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
2659 compiler.misc.cant.resolve.location.args.params=\
2660     cannot find symbol\n\
2661     symbol:   {0} &lt;{2}&gt;{1}({3})\n\
2662     location: {4}
2663 
2664 ##a location subdiagnostic is composed as follows:
2665 ## The first argument {0} is the location &quot;kindname&quot; (e.g. &#39;constructor&#39;, &#39;field&#39;, etc.)
2666 ## The second argument {1} is the location name
2667 ## The third argument {2} is the location type (only when {1} is a variable name)
2668 
2669 # 0: kind name, 1: type or symbol, 2: unused
2670 compiler.misc.location=\
2671     {0} {1}
2672 
2673 # 0: kind name, 1: symbol, 2: type
2674 compiler.misc.location.1=\
2675     {0} {1} of type {2}
2676 
2677 ## The following are all possible string for &quot;kindname&quot;.
2678 ## They should be called whatever the JLS calls them after it been translated
2679 ## to the appropriate language.
2680 # compiler.misc.kindname.constructor=\
2681 #     static member
2682 compiler.misc.kindname.annotation=\
2683     @interface
2684 
2685 compiler.misc.kindname.constructor=\
2686     constructor
2687 
2688 compiler.misc.kindname.enum=\
2689     enum
2690 
2691 compiler.misc.kindname.interface=\
2692     interface
2693 
2694 compiler.misc.kindname.static=\
2695     static
2696 
2697 compiler.misc.kindname.type.variable=\
2698     type variable
2699 
2700 compiler.misc.kindname.type.variable.bound=\
2701     bound of type variable
2702 
2703 compiler.misc.kindname.variable=\
2704     variable
2705 
2706 compiler.misc.kindname.value=\
2707     value
2708 
2709 compiler.misc.kindname.method=\
2710     method
2711 
2712 compiler.misc.kindname.class=\
2713     class
2714 
2715 compiler.misc.kindname.package=\
2716     package
2717 
2718 compiler.misc.kindname.module=\
2719     module
2720 
2721 compiler.misc.kindname.static.init=\
2722     static initializer
2723 
2724 compiler.misc.kindname.instance.init=\
2725     instance initializer
2726 
2727 compiler.misc.kindname.record.component=\
2728     record component
2729 
2730 compiler.misc.kindname.record=\
2731     record
2732 
2733 #####
2734 
2735 compiler.misc.no.args=\
2736     no arguments
2737 
2738 # 0: message segment
2739 compiler.err.override.static=\
2740     {0}\n\
2741     overriding method is static
2742 
2743 # 0: message segment, 1: set of flag
2744 compiler.err.override.meth=\
2745     {0}\n\
2746     overridden method is {1}
2747 
2748 # 0: message segment, 1: type
2749 compiler.err.override.meth.doesnt.throw=\
2750     {0}\n\
2751     overridden method does not throw {1}
2752 
2753 # In the following string {1} is a space separated list of Java Keywords, as
2754 # they would have been declared in the source code
2755 # 0: message segment, 1: set of flag or string
2756 compiler.err.override.weaker.access=\
2757     {0}\n\
2758     attempting to assign weaker access privileges; was {1}
2759 
2760 # 0: message segment, 1: type, 2: type
2761 compiler.err.override.incompatible.ret=\
2762     {0}\n\
2763     return type {1} is not compatible with {2}
2764 
2765 # 0: message segment, 1: type, 2: type
2766 compiler.warn.override.unchecked.ret=\
2767     {0}\n\
2768     return type requires unchecked conversion from {1} to {2}
2769 
2770 # 0: message segment, 1: type
2771 compiler.warn.override.unchecked.thrown=\
2772     {0}\n\
2773     overridden method does not throw {1}
2774 
2775 # 0: symbol
2776 compiler.warn.override.equals.but.not.hashcode=\
2777     Class {0} overrides equals, but neither it nor any superclass overrides hashCode method
2778 
2779 ## The following are all possible strings for the first argument ({0}) of the
2780 ## above strings.
2781 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2782 compiler.misc.cant.override=\
2783     {0} in {1} cannot override {2} in {3}
2784 
2785 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2786 compiler.misc.cant.hide=\
2787     {0} in {1} cannot hide {2} in {3}
2788 
2789 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2790 compiler.misc.cant.implement=\
2791     {0} in {1} cannot implement {2} in {3}
2792 
2793 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2794 compiler.misc.clashes.with=\
2795     {0} in {1} clashes with {2} in {3}
2796 
2797 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2798 compiler.misc.unchecked.override=\
2799     {0} in {1} overrides {2} in {3}
2800 
2801 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2802 compiler.misc.unchecked.implement=\
2803     {0} in {1} implements {2} in {3}
2804 
2805 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2806 compiler.misc.unchecked.clash.with=\
2807     {0} in {1} overrides {2} in {3}
2808 
2809 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2810 compiler.misc.varargs.override=\
2811     {0} in {1} overrides {2} in {3}
2812 
2813 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2814 compiler.misc.varargs.implement=\
2815     {0} in {1} implements {2} in {3}
2816 
2817 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2818 compiler.misc.varargs.clash.with=\
2819     {0} in {1} overrides {2} in {3}
2820 
2821 # 0: kind name, 1: symbol, 2: symbol, 3: message segment
2822 compiler.misc.inapplicable.method=\
2823     {0} {1}.{2} is not applicable\n\
2824     ({3})
2825 
2826 ########################################
2827 # Diagnostics for language feature changes.
2828 # Such diagnostics have a common template which can be customized by using a feature
2829 # diagnostic fragment (one of those given below).
2830 ########################################
2831 
2832 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2833 compiler.err.feature.not.supported.in.source=\
2834    {0} is not supported in -source {1}\n\
2835     (use -source {2} or higher to enable {0})
2836 
2837 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2838 compiler.err.feature.not.supported.in.source.plural=\
2839    {0} are not supported in -source {1}\n\
2840     (use -source {2} or higher to enable {0})
2841 
2842 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2843 compiler.misc.feature.not.supported.in.source=\
2844    {0} is not supported in -source {1}\n\
2845     (use -source {2} or higher to enable {0})
2846 
2847 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2848 compiler.misc.feature.not.supported.in.source.plural=\
2849    {0} are not supported in -source {1}\n\
2850     (use -source {2} or higher to enable {0})
2851 
2852 # 0: message segment (feature)
2853 compiler.err.preview.feature.disabled=\
2854    {0} is a preview feature and is disabled by default.\n\
2855    (use --enable-preview to enable {0})
2856 
2857 # 0: message segment (feature)
2858 compiler.err.preview.feature.disabled.plural=\
2859    {0} are a preview feature and are disabled by default.\n\
2860    (use --enable-preview to enable {0})
2861 
2862 # 0: file object (classfile), 1: string (expected version)
2863 compiler.err.preview.feature.disabled.classfile=\
2864    classfile for {0} uses preview features of Java SE {1}.\n\
2865    (use --enable-preview to allow loading of classfiles which contain preview features)
2866 
2867 # 0: message segment (feature)
2868 compiler.warn.preview.feature.use=\
2869    {0} is a preview feature and may be removed in a future release.
2870 
2871 # 0: message segment (feature)
2872 compiler.warn.preview.feature.use.plural=\
2873    {0} are a preview feature and may be removed in a future release.
2874 
2875 # 0: file object (classfile), 1: string (expected version)
2876 compiler.warn.preview.feature.use.classfile=\
2877    classfile for {0} uses preview features of Java SE {1}.
2878 
2879 
2880 compiler.misc.feature.modules=\
2881     modules
2882 
2883 compiler.misc.feature.diamond.and.anon.class=\
2884     &#39;&#39;&lt;&gt;&#39;&#39; with anonymous inner classes
2885 
2886 compiler.misc.feature.var.in.try.with.resources=\
2887     variables in try-with-resources
2888 
2889 compiler.misc.feature.type.annotations=\
2890     type annotations
2891 
2892 compiler.misc.feature.annotations.after.type.params=\
2893     annotations after method type parameters
2894 
2895 compiler.misc.feature.repeatable.annotations=\
2896     repeated annotations
2897 
2898 compiler.misc.feature.diamond=\
2899     diamond operator
2900 
2901 compiler.misc.feature.lambda=\
2902     lambda expressions
2903 
2904 compiler.misc.feature.method.references=\
2905     method references
2906 
2907 compiler.misc.feature.default.methods=\
2908     default methods
2909 
2910 compiler.misc.feature.intersection.types.in.cast=\
2911     intersection types
2912 
2913 compiler.misc.feature.static.intf.methods=\
2914     static interface methods
2915 
2916 compiler.misc.feature.static.intf.method.invoke=\
2917     static interface method invocations
2918 
2919 compiler.misc.feature.private.intf.methods=\
2920     private interface methods
2921 
2922 compiler.misc.feature.text.blocks=\
2923     text blocks
2924 
2925 compiler.misc.feature.multiple.case.labels=\
2926     multiple case labels
2927 
2928 compiler.misc.feature.switch.rules=\
2929     switch rules
2930 
2931 compiler.misc.feature.switch.expressions=\
2932     switch expressions
2933 
2934 compiler.misc.feature.var.syntax.in.implicit.lambda=\
2935     var syntax in implicit lambdas
2936 
2937 compiler.misc.feature.pattern.matching.instanceof=\
2938     pattern matching in instanceof
2939 
2940 compiler.misc.feature.reifiable.types.instanceof=\
2941     reifiable types in instanceof
2942 
2943 compiler.misc.feature.inline.type=\
2944     inline type
2945 
2946 compiler.misc.feature.records=\
2947     records
2948 
2949 compiler.warn.underscore.as.identifier=\
2950     as of release 9, &#39;&#39;_&#39;&#39; is a keyword, and may not be used as an identifier
2951 
2952 compiler.err.underscore.as.identifier=\
2953     as of release 9, &#39;&#39;_&#39;&#39; is a keyword, and may not be used as an identifier
2954 
2955 compiler.err.underscore.as.identifier.in.lambda=\
2956     &#39;&#39;_&#39;&#39; used as an identifier\n\
2957     (use of &#39;&#39;_&#39;&#39; as an identifier is forbidden for lambda parameters)
2958 
2959 compiler.err.enum.as.identifier=\
2960     as of release 5, &#39;&#39;enum&#39;&#39; is a keyword, and may not be used as an identifier
2961 
2962 compiler.err.assert.as.identifier=\
2963     as of release 1.4, &#39;&#39;assert&#39;&#39; is a keyword, and may not be used as an identifier
2964 
2965 # TODO 308: make a better error message
2966 compiler.err.this.as.identifier=\
2967     as of release 8, &#39;&#39;this&#39;&#39; is allowed as the parameter name for the receiver type only\n\
2968     which has to be the first parameter, and cannot be a lambda parameter
2969 
2970 compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=\
2971     receiver parameter not applicable for constructor of top-level class
2972 
2973 # TODO 308: make a better error message
2974 # 0: annotation
2975 compiler.err.cant.type.annotate.scoping.1=\
2976     scoping construct cannot be annotated with type-use annotation: {0}
2977 
2978 # TODO 308: make a better error message
2979 # 0: list of annotation
2980 compiler.err.cant.type.annotate.scoping=\
2981     scoping construct cannot be annotated with type-use annotations: {0}
2982 
2983 # 0: type, 1: type
2984 compiler.err.incorrect.receiver.name=\
2985     the receiver name does not match the enclosing class type\n\
2986     required: {0}\n\
2987     found:    {1}
2988 
2989 # 0: type, 1: type
2990 compiler.err.incorrect.receiver.type=\
2991     the receiver type does not match the enclosing class type\n\
2992     required: {0}\n\
2993     found:    {1}
2994 
2995 # 0: type, 1: type
2996 compiler.err.incorrect.constructor.receiver.type=\
2997     the receiver type does not match the enclosing outer class type\n\
2998     required: {0}\n\
2999     found:    {1}
3000 
3001 # 0: type, 1: type
3002 compiler.err.incorrect.constructor.receiver.name=\
3003     the receiver name does not match the enclosing outer class type\n\
3004     required: {0}\n\
3005     found:    {1}
3006 
3007 compiler.err.no.annotations.on.dot.class=\
3008     no annotations are allowed in the type of a class literal
3009 
3010 ########################################
3011 # Diagnostics for verbose resolution
3012 # used by Resolve (debug only)
3013 ########################################
3014 
3015 # 0: number, 1: symbol, 2: unused
3016 compiler.misc.applicable.method.found=\
3017     #{0} applicable method found: {1}
3018 
3019 # 0: number, 1: symbol, 2: message segment
3020 compiler.misc.applicable.method.found.1=\
3021     #{0} applicable method found: {1}\n\
3022     ({2})
3023 
3024 # 0: number, 1: symbol, 2: message segment
3025 compiler.misc.not.applicable.method.found=\
3026     #{0} not applicable method found: {1}\n\
3027     ({2})
3028 
3029 # 0: type
3030 compiler.misc.partial.inst.sig=\
3031     partially instantiated to: {0}
3032 
3033 # 0: name, 1: symbol, 2: number, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
3034 compiler.note.verbose.resolve.multi=\
3035     resolving method {0} in type {1} to candidate {2}\n\
3036     phase: {3}\n\
3037     with actuals: {4}\n\
3038     with type-args: {5}\n\
3039     candidates:
3040 
3041 # 0: name, 1: symbol, 2: unused, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
3042 compiler.note.verbose.resolve.multi.1=\
3043     erroneous resolution for method {0} in type {1}\n\
3044     phase: {3}\n\
3045     with actuals: {4}\n\
3046     with type-args: {5}\n\
3047     candidates:
3048 
3049 # 0: symbol, 1: type, 2: type
3050 compiler.note.deferred.method.inst=\
3051     Deferred instantiation of method {0}\n\
3052     instantiated signature: {1}\n\
3053     target-type: {2}
3054 
3055 ########################################
3056 # Diagnostics for lambda deduplication
3057 # used by LambdaToMethod (debug only)
3058 ########################################
3059 
3060 # 0: symbol
3061 compiler.note.verbose.l2m.deduplicate=\
3062     deduplicating lambda implementation method {0}
3063 
3064 ########################################
3065 # Diagnostics for where clause implementation
3066 # used by the RichDiagnosticFormatter.
3067 ########################################
3068 
3069 compiler.misc.type.null=\
3070     &lt;null&gt;
3071 
3072 # X#n (where n is an int id) is disambiguated tvar name
3073 # 0: name, 1: number
3074 compiler.misc.type.var=\
3075     {0}#{1}
3076 
3077 # CAP#n (where n is an int id) is an abbreviation for &#39;captured type&#39;
3078 # 0: number
3079 compiler.misc.captured.type=\
3080     CAP#{0}
3081 
3082 # &lt;INT#n&gt; (where n is an int id) is an abbreviation for &#39;intersection type&#39;
3083 # 0: number
3084 compiler.misc.intersection.type=\
3085     INT#{0}
3086 
3087 # where clause for captured type: contains upper (&#39;extends {1}&#39;) and lower
3088 # (&#39;super {2}&#39;) bound along with the wildcard that generated this captured type ({3})
3089 # 0: type, 1: type, 2: type, 3: type
3090 compiler.misc.where.captured=\
3091     {0} extends {1} super: {2} from capture of {3}
3092 
3093 # compact where clause for captured type: contains upper (&#39;extends {1}&#39;) along
3094 # with the wildcard that generated this captured type ({3})
3095 # 0: type, 1: type, 2: unused, 3: type
3096 compiler.misc.where.captured.1=\
3097     {0} extends {1} from capture of {3}
3098 
3099 # where clause for type variable: contains upper bound(s) (&#39;extends {1}&#39;) along with
3100 # the kindname ({2}) and location ({3}) in which the typevar has been declared
3101 # 0: type, 1: list of type, 2: symbol kind, 3: symbol
3102 compiler.misc.where.typevar=\
3103     {0} extends {1} declared in {2} {3}
3104 
3105 # compact where clause for type variable: contains the kindname ({2}) and location ({3})
3106 # in which the typevar has been declared
3107 # 0: type, 1: list of type, 2: symbol kind, 3: symbol
3108 compiler.misc.where.typevar.1=\
3109     {0} declared in {2} {3}
3110 
3111 # where clause for fresh type variable: contains upper bound(s) (&#39;extends {1}&#39;).
3112 # Since a fresh type-variable is synthetic - there&#39;s no location/kindname here.
3113 # 0: type, 1: list of type
3114 compiler.misc.where.fresh.typevar=\
3115     {0} extends {1}
3116 
3117 # where clause for type variable: contains all the upper bound(s) (&#39;extends {1}&#39;)
3118 # of this intersection type
3119 # 0: type, 1: list of type
3120 compiler.misc.where.intersection=\
3121     {0} extends {1}
3122 
3123 ### Where clause headers ###
3124 compiler.misc.where.description.captured=\
3125     where {0} is a fresh type-variable:
3126 
3127 # 0: set of type
3128 compiler.misc.where.description.typevar=\
3129     where {0} is a type-variable:
3130 
3131 # 0: set of type
3132 compiler.misc.where.description.intersection=\
3133     where {0} is an intersection type:
3134 
3135 # 0: set of type
3136 compiler.misc.where.description.captured.1=\
3137     where {0} are fresh type-variables:
3138 
3139 # 0: set of type
3140 compiler.misc.where.description.typevar.1=\
3141     where {0} are type-variables:
3142 
3143 # 0: set of type
3144 compiler.misc.where.description.intersection.1=\
3145     where {0} are intersection types:
3146 
3147 ###
3148 # errors related to doc comments
3149 
3150 compiler.err.dc.bad.entity=\
3151     bad HTML entity
3152 
3153 compiler.err.dc.bad.gt=\
3154     bad use of &#39;&#39;&gt;&#39;&#39;
3155 
3156 compiler.err.dc.bad.inline.tag=\
3157     incorrect use of inline tag
3158 
3159 compiler.err.dc.identifier.expected=\
3160     identifier expected
3161 
3162 compiler.err.dc.malformed.html=\
3163     malformed HTML
3164 
3165 compiler.err.dc.missing.semicolon=\
3166     semicolon missing
3167 
3168 compiler.err.dc.no.content=\
3169     no content
3170 
3171 compiler.err.dc.no.tag.name=\
3172     no tag name after &#39;@&#39;
3173 
3174 compiler.err.dc.gt.expected=\
3175     &#39;&#39;&gt;&#39;&#39; expected
3176 
3177 compiler.err.dc.ref.bad.parens=\
3178     &#39;&#39;)&#39;&#39; missing in reference
3179 
3180 compiler.err.dc.ref.syntax.error=\
3181     syntax error in reference
3182 
3183 compiler.err.dc.ref.unexpected.input=\
3184     unexpected text
3185 
3186 compiler.err.dc.unexpected.content=\
3187     unexpected content
3188 
3189 compiler.err.dc.unterminated.inline.tag=\
3190     unterminated inline tag
3191 
3192 compiler.err.dc.unterminated.signature=\
3193     unterminated signature
3194 
3195 compiler.err.dc.unterminated.string=\
3196     unterminated string
3197 
3198 ###
3199 # errors related to modules
3200 
3201 compiler.err.expected.module=\
3202     expected &#39;&#39;module&#39;&#39;
3203 
3204 # 0: symbol
3205 compiler.err.module.not.found=\
3206     module not found: {0}
3207 
3208 # 0: symbol
3209 compiler.warn.module.not.found=\
3210     module not found: {0}
3211 
3212 compiler.err.too.many.modules=\
3213     too many module declarations found
3214 
3215 compiler.err.module.not.found.on.module.source.path=\
3216     module not found on module source path
3217 
3218 compiler.err.not.in.module.on.module.source.path=\
3219     not in a module on the module source path
3220 
3221 # 0: symbol
3222 compiler.err.duplicate.module=\
3223     duplicate module: {0}
3224 
3225 # 0: symbol
3226 compiler.err.duplicate.requires=\
3227     duplicate requires: {0}
3228 
3229 # 0: symbol
3230 compiler.err.conflicting.exports=\
3231     duplicate or conflicting exports: {0}
3232 
3233 # 0: symbol
3234 compiler.err.conflicting.opens=\
3235     duplicate or conflicting opens: {0}
3236 
3237 # 0: symbol
3238 compiler.err.conflicting.exports.to.module=\
3239     duplicate or conflicting exports to module: {0}
3240 
3241 # 0: symbol
3242 compiler.err.conflicting.opens.to.module=\
3243     duplicate or conflicting opens to module: {0}
3244 
3245 compiler.err.no.opens.unless.strong=\
3246     &#39;&#39;opens&#39;&#39; only allowed in strong modules
3247 
3248 # 0: symbol
3249 compiler.err.repeated.provides.for.service=\
3250     multiple &#39;&#39;provides&#39;&#39; for service {0}
3251 
3252 # 0: symbol, 1: symbol
3253 compiler.err.duplicate.provides=\
3254     duplicate provides: service {0}, implementation {1}
3255 
3256 # 0: symbol
3257 compiler.err.duplicate.uses=\
3258     duplicate uses: {0}
3259 
3260 # 0: symbol
3261 compiler.err.service.implementation.is.abstract=\
3262     the service implementation is an abstract class: {0}
3263 
3264 compiler.err.service.implementation.must.be.subtype.of.service.interface=\
3265     the service implementation type must be a subtype of the service interface type, or \
3266     have a public static no-args method named &quot;provider&quot; returning the service implementation
3267 
3268 compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface=\
3269     the &quot;provider&quot; method return type must be a subtype of the service interface type
3270 
3271 # 0: symbol
3272 compiler.err.service.implementation.is.inner=\
3273     the service implementation is an inner class: {0}
3274 
3275 # 0: symbol
3276 compiler.err.service.definition.is.enum=\
3277     the service definition is an enum: {0}
3278 
3279 # 0: symbol
3280 compiler.err.service.implementation.doesnt.have.a.no.args.constructor=\
3281     the service implementation does not have a default constructor: {0}
3282 
3283 # 0: symbol
3284 compiler.err.service.implementation.no.args.constructor.not.public=\
3285     the no arguments constructor of the service implementation is not public: {0}
3286 
3287 # 0: symbol
3288 compiler.err.package.empty.or.not.found=\
3289     package is empty or does not exist: {0}
3290 
3291 # 0: symbol
3292 compiler.warn.package.empty.or.not.found=\
3293     package is empty or does not exist: {0}
3294 
3295 compiler.err.no.output.dir=\
3296     no class output directory specified
3297 
3298 compiler.err.unnamed.pkg.not.allowed.named.modules=\
3299     unnamed package is not allowed in named modules
3300 
3301 # 0: name, 1: name
3302 compiler.err.module.name.mismatch=\
3303     module name {0} does not match expected name {1}
3304 
3305 # 0: name, 1: name
3306 compiler.misc.module.name.mismatch=\
3307     module name {0} does not match expected name {1}
3308 
3309 # 0: name
3310 compiler.err.module.non.zero.opens=\
3311     open module {0} has non-zero opens_count
3312 
3313 # 0: name
3314 compiler.misc.module.non.zero.opens=\
3315     open module {0} has non-zero opens_count
3316 
3317 compiler.err.module.decl.sb.in.module-info.java=\
3318     module declarations should be in a file named module-info.java
3319 
3320 # 0: set of string
3321 compiler.err.too.many.patched.modules=\
3322     too many patched modules ({0}), use --module-source-path
3323 
3324 # 0: name, 1: name
3325 compiler.err.file.patched.and.msp=\
3326     file accessible from both --patch-module and --module-source-path, \
3327     but belongs to a different module on each path: {0}, {1}
3328 
3329 compiler.err.processorpath.no.processormodulepath=\
3330     illegal combination of -processorpath and --processor-module-path
3331 
3332 # 0: symbol
3333 compiler.err.package.in.other.module=\
3334     package exists in another module: {0}
3335 
3336 # 0: symbol, 1: name, 2: symbol, 3: symbol
3337 compiler.err.package.clash.from.requires=\
3338     module {0} reads package {1} from both {2} and {3}
3339 
3340 # 0: name, 1: symbol, 2: symbol
3341 compiler.err.package.clash.from.requires.in.unnamed=\
3342     the unnamed module reads package {0} from both {1} and {2}
3343 
3344 # 0: string
3345 compiler.err.module.not.found.in.module.source.path=\
3346     module {0} not found in module source path
3347 
3348 compiler.err.output.dir.must.be.specified.with.dash.m.option=\
3349     class output directory must be specified if -m option is used
3350 
3351 compiler.err.modulesourcepath.must.be.specified.with.dash.m.option=\
3352     module source path must be specified if -m option is used
3353 
3354 # 0: symbol
3355 compiler.err.service.implementation.not.in.right.module=\
3356     service implementation must be defined in the same module as the provides directive
3357 
3358 # 0: symbol
3359 compiler.err.cyclic.requires=\
3360     cyclic dependence involving {0}
3361 
3362 # 0: fragment, 1: name
3363 compiler.err.duplicate.module.on.path=\
3364     duplicate module on {0}\nmodule in {1}
3365 
3366 # 0: option name, 1: string
3367 compiler.warn.bad.name.for.option=\
3368     bad name in value for {0} option: &#39;&#39;{1}&#39;&#39;
3369 
3370 # 0: option name, 1: string
3371 compiler.err.bad.name.for.option=\
3372     bad name in value for {0} option: &#39;&#39;{1}&#39;&#39;
3373 
3374 # 0: option name, 1: symbol
3375 compiler.warn.module.for.option.not.found=\
3376     module name in {0} option not found: {1}
3377 
3378 compiler.err.addmods.all.module.path.invalid=\
3379     --add-modules ALL-MODULE-PATH can only be used when compiling the unnamed module or \
3380     when compiling in the context of an automatic module
3381 
3382 # 0: symbol
3383 compiler.err.add.exports.with.release=\
3384     exporting a package from system module {0} is not allowed with --release
3385 
3386 # 0: symbol
3387 compiler.err.add.reads.with.release=\
3388     adding read edges for system module {0} is not allowed with --release
3389 
3390 compiler.warn.addopens.ignored=\
3391     --add-opens has no effect at compile time
3392 
3393 compiler.misc.locn.module_source_path=\
3394     module source path
3395 
3396 compiler.misc.locn.upgrade_module_path=\
3397     upgrade module path
3398 
3399 compiler.misc.locn.system_modules=\
3400     system modules
3401 
3402 compiler.misc.locn.module_path=\
3403     application module path
3404 
3405 compiler.misc.cant.resolve.modules=\
3406     cannot resolve modules
3407 
3408 compiler.misc.bad.requires.flag=\
3409     bad requires flag: {0}
3410 
3411 # 0: string
3412 compiler.err.invalid.module.specifier=\
3413     module specifier not allowed: {0}
3414 
3415 # 0: symbol
3416 compiler.warn.service.provided.but.not.exported.or.used=\
3417     service interface provided but not exported or used
3418 
3419 # 0: kind name, 1: symbol, 2: symbol
3420 compiler.warn.leaks.not.accessible=\
3421     {0} {1} in module {2} is not accessible to clients that require this module
3422 # 0: kind name, 1: symbol, 2: symbol
3423 compiler.warn.leaks.not.accessible.unexported=\
3424     {0} {1} in module {2} is not exported
3425 # 0: kind name, 1: symbol, 2: symbol
3426 compiler.warn.leaks.not.accessible.not.required.transitive=\
3427     {0} {1} in module {2} is not indirectly exported using &#39;requires transitive&#39;
3428 # 0: kind name, 1: symbol, 2: symbol
3429 compiler.warn.leaks.not.accessible.unexported.qualified=\
3430     {0} {1} in module {2} may not be visible to all clients that require this module
3431 
3432 ###
3433 # errors related to options
3434 
3435 # 0: string, 1: string
3436 compiler.err.illegal.argument.for.option=\
3437     illegal argument for {0}: {1}
3438 
3439 compiler.err.match.binding.exists=\
3440     illegal attempt to redefine an existing match binding
3441 
3442 compiler.err.switch.null.not.allowed=\
3443     null label in case is not allowed
3444 
3445 compiler.err.switch.case.unexpected.statement=\
3446     unexpected statement in case, expected is an expression, a block or a throw statement
3447 
3448 compiler.err.switch.mixing.case.types=\
3449     different case kinds used in the switch
3450 
3451 ###
3452 # errors related to records
3453 
3454 # record components
3455 compiler.err.record.cant.declare.field.modifiers=\
3456     record components cannot have modifiers
3457 
3458 # 0: symbol
3459 compiler.err.illegal.record.component.name=\
3460     illegal record component name {0}
3461 
3462 # accessor methods
3463 # 0: symbol, 1: fragment
3464 compiler.err.invalid.accessor.method.in.record=\
3465     invalid accessor method in record {0}\n\
3466     ({1})
3467 
3468 compiler.misc.method.must.be.public=\
3469     accessor method must be public
3470 
3471 # 0: symbol, 1: symbol
3472 compiler.misc.accessor.return.type.doesnt.match=\
3473     return type of accessor method {0} must match the type of record component {1}
3474 
3475 compiler.misc.accessor.method.cant.throw.exception=\
3476     throws clause not allowed for accessor method
3477 
3478 compiler.misc.accessor.method.must.not.be.generic=\
3479     accessor method must not be generic
3480 
3481 compiler.misc.accessor.method.must.not.be.static=\
3482     accessor method must not be static
3483 
3484 # canonical constructors
3485 # 0: fragment, 1: name, 2: fragment
3486 compiler.err.invalid.canonical.constructor.in.record=\
3487     invalid {0} constructor in record {1}\n\
3488     ({2})
3489 
3490 compiler.misc.canonical=\
3491     canonical
3492 
3493 compiler.misc.compact=\
3494     compact
3495 
3496 compiler.misc.canonical.constructor.must.be.public=\
3497     canonical constructor must be public
3498 
3499 # 0: fragment
3500 compiler.misc.throws.clause.not.allowed.for.canonical.constructor=\
3501     throws clause not allowed for {0} constructor
3502 
3503 compiler.misc.canonical.with.name.mismatch=\
3504     invalid parameter names in canonical constructor
3505 
3506 compiler.misc.canonical.cant.have.return.statement=\
3507     compact constructor must not have return statements
3508 
3509 compiler.misc.canonical.must.not.declare.type.variables=\
3510     canonical constructor must not declare type variables
3511 
3512 compiler.misc.type.must.be.identical.to.corresponding.record.component.type=\
3513     type must match that of the corresponding record component\
3514 
3515 compiler.misc.canonical.must.not.contain.explicit.constructor.invocation=\
3516     canonical constructor must not contain explicit constructor invocation
3517 
3518 # other
3519 compiler.err.record.cannot.declare.instance.fields=\
3520     field declaration must be static\n\
3521     (consider replacing field with record component)
3522 
3523 # 0: symbol
3524 compiler.err.invalid.supertype.record=\
3525     classes cannot directly extend {0}
3526 
3527 compiler.err.first.statement.must.be.call.to.another.constructor=\
3528     constructor is not canonical, so its first statement must invoke another constructor
3529 
3530 compiler.err.instance.initializer.not.allowed.in.records=\
3531     instance initializers not allowed in records
3532 
3533 compiler.err.record.declaration.not.allowed.in.inner.classes=\
3534     record declarations not allowed in inner classes
3535 
3536 compiler.err.record.header.expected=\
3537     record header expected
3538 
3539 ############################################
3540 # messages previously at javac.properties
3541 
3542 compiler.err.empty.A.argument=\
3543     -A requires an argument; use &#39;&#39;-Akey&#39;&#39; or &#39;&#39;-Akey=value&#39;&#39;
3544 
3545 # 0: string
3546 compiler.err.invalid.A.key=\
3547     key in annotation processor option &#39;&#39;{0}&#39;&#39; is not a dot-separated sequence of identifiers
3548 
3549 # 0: string
3550 compiler.err.invalid.flag=\
3551     invalid flag: {0}
3552 
3553 compiler.err.profile.bootclasspath.conflict=\
3554     profile and bootclasspath options cannot be used together
3555 
3556 # 0: string
3557 compiler.err.invalid.profile=\
3558     invalid profile: {0}
3559 
3560 # 0: string
3561 compiler.err.invalid.target=\
3562     invalid target release: {0}
3563 
3564 # 0: option name, 1: target
3565 compiler.err.option.not.allowed.with.target=\
3566     option {0} not allowed with target {1}
3567 
3568 # 0: string
3569 compiler.err.option.too.many=\
3570     option {0} can only be specified once
3571 
3572 compiler.err.no.source.files=\
3573     no source files
3574 
3575 compiler.err.no.source.files.classes=\
3576     no source files or class names
3577 
3578 # 0: string
3579 compiler.err.req.arg=\
3580     {0} requires an argument
3581 
3582 # 0: string
3583 compiler.err.invalid.source=\
3584     invalid source release: {0}
3585 
3586 # 0: string, 1: string
3587 compiler.err.error.writing.file=\
3588     error writing {0}; {1}
3589 
3590 compiler.err.sourcepath.modulesourcepath.conflict=\
3591     cannot specify both --source-path and --module-source-path
3592 
3593 # 0: string, 1: target
3594 compiler.warn.source.target.conflict=\
3595     source release {0} requires target release {1}
3596 
3597 # 0: string, 1: target
3598 compiler.warn.target.default.source.conflict=\
3599     target release {0} conflicts with default source release {1}
3600 
3601 # 0: profile, 1: target
3602 compiler.warn.profile.target.conflict=\
3603     profile {0} is not valid for target release {1}
3604 
3605 # 0: string
3606 compiler.err.file.not.directory=\
3607     not a directory: {0}
3608 
3609 # 0: object
3610 compiler.err.file.not.file=\
3611     not a file: {0}
3612 
3613 compiler.err.two.class.loaders.1=\
3614     javac is split between multiple class loaders: check your configuration
3615 
3616 # 0: url, 1: url
3617 compiler.err.two.class.loaders.2=\
3618     javac is split between multiple class loaders:\n\
3619     one class comes from file: {0}\n\
3620     while javac comes from {1}
3621 
3622 # 0: string, 1: string
3623 compiler.err.bad.value.for.option=\
3624     bad value for {0} option: &#39;&#39;{1}&#39;&#39;
3625 
3626 # 0: string
3627 compiler.err.no.value.for.option=\
3628     no value for {0} option
3629 
3630 # 0: string
3631 compiler.err.repeated.value.for.patch.module=\
3632     --patch-module specified more than once for module {0}
3633 
3634 # 0: string
3635 compiler.err.repeated.value.for.module.source.path=\
3636     --module-source-path specified more than once for module {0}
3637 
3638 compiler.err.multiple.values.for.module.source.path=\
3639     --module-source-path specified more than once with a pattern argument
3640 
3641 # 0: string
3642 compiler.err.unmatched.quote=\
3643     unmatched quote in environment variable {0}
3644 
3645 # 0: option name
3646 compiler.err.release.bootclasspath.conflict=\
3647     option {0} cannot be used together with --release
3648 
3649 # 0: string
3650 compiler.err.unsupported.release.version=\
3651     release version {0} not supported
3652 
3653 # 0: string
3654 compiler.err.file.not.found=\
3655     file not found: {0}
3656 
3657 # 0: string, 1: source
3658 compiler.err.preview.not.latest=\
3659     invalid source release {0} with --enable-preview\n\
3660     (preview language features are only supported for release {1})
3661 
3662 compiler.err.preview.without.source.or.release=\
3663     --enable-preview must be used with either -source or --release
3664 
3665 # 0: name (of method)
3666 compiler.err.inline.class.may.not.override=\
3667     Inline classes may not override the method {0} from Object
3668 
3669 # 0: name (of method)
3670 compiler.err.value.does.not.support=\
3671     Inline types do not support {0}
3672 
3673 compiler.err.value.may.not.extend=\
3674     Inline type may not extend another inline type or class
3675 
3676 compiler.err.value.instance.field.expected.here=\
3677     withfield operator requires an instance field of an inline class here
3678 
3679 compiler.err.bad.value.based.anno=\
3680     Unexpected @ValueBased annotation
3681 
3682 # 0: type
3683 compiler.warn.suspicious.mix.of.null.with.value.based.class=\
3684     Suspicious mix of null with value based class {0}
3685 
3686 # 0: type
3687 compiler.warn.potential.null.pollution=\
3688     Potential null pollution from nullable type {0}
3689 
3690 compiler.err.with.field.operator.disallowed=\
3691     WithField operator is allowed only with -XDallowWithFieldOperator
3692 
3693 compiler.err.empty.value.not.yet=\
3694     Inline types with zero instance size are not supported yet
3695 
3696 compiler.err.this.exposed.prematurely=\
3697     Inine type instance should not be passed around before being fully initialized
3698 
3699 compiler.warn.this.exposed.prematurely=\
3700     value based type instance should not be passed around before being fully initialized
3701 
3702 # 0: type
3703 compiler.err.generic.parameterization.with.value.type=\
3704     Inferred type {0} involves generic parameterization by an inline type
3705 
3706 # 0: type
3707 compiler.err.inline.type.must.not.implement.identity.object=\
3708     The inline type {0} attempts to implement the incompatible interface IdentityObject
3709 
3710 # 0: symbol, 1: type
3711 compiler.err.concrete.supertype.for.inline.class=\
3712     The concrete class {1} is not allowed to be a super class of the inline class {0} either directly or indirectly
3713 
3714 # 0: symbol, 1: symbol, 2: type
3715 compiler.err.super.method.cannot.be.synchronized=\
3716     The method {0} in the super class {2} of the inline type {1} is synchronized. This is disallowed
3717 
3718 # 0: symbol, 1: symbol, 2: type
3719 compiler.err.super.constructor.cannot.take.arguments=\
3720     The super class {2} of the inline type {1} defines a constructor {0} that takes arguments. This is disallowed
3721 
3722 # 0: symbol, 1: symbol, 2: type
3723 compiler.err.super.field.not.allowed=\
3724     The super class {2} of the inline type {1} defines an instance field {0}. This is disallowed
3725 
3726 # 0: symbol, 1: symbol, 2: type
3727 compiler.err.super.no.arg.constructor.must.be.empty=\
3728     The super class {2} of the inline type {1} defines a nonempty no-arg constructor {0}. This is disallowed
3729 
3730 # 0: symbol, 1: type
3731 compiler.err.super.class.declares.init.block=\
3732     The super class {1} of the inline class {0} declares one or more non-empty instance initializer blocks. This is disallowed.
3733 
3734 # 0: symbol, 1: type
3735 compiler.err.super.class.cannot.be.inner=\
3736     The super class {1} of the inline class {0} is an inner class. This is disallowed.
3737 
3738 
3739 
    </pre>
  </body>
</html>
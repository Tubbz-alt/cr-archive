<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdwp.agent/share/native/libjdwp/util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;ctype.h&gt;
  27 
  28 #include &quot;util.h&quot;
  29 #include &quot;transport.h&quot;
  30 #include &quot;eventHandler.h&quot;
  31 #include &quot;threadControl.h&quot;
  32 #include &quot;outStream.h&quot;
  33 #include &quot;inStream.h&quot;
  34 #include &quot;invoker.h&quot;
  35 
  36 /* Global data area */
  37 BackendGlobalData *gdata = NULL;
  38 
  39 /* Forward declarations */
  40 static jboolean isInterface(jclass clazz);
  41 static jboolean isArrayClass(jclass clazz);
  42 static char * getPropertyUTF8(JNIEnv *env, char *propertyName);
  43 
  44 /* Save an object reference for use later (create a NewGlobalRef) */
  45 void
  46 saveGlobalRef(JNIEnv *env, jobject obj, jobject *pobj)
  47 {
  48     jobject newobj;
  49 
  50     if ( pobj == NULL ) {
  51         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef pobj&quot;);
  52     }
  53     if ( *pobj != NULL ) {
  54         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef *pobj&quot;);
  55     }
  56     if ( env == NULL ) {
  57         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef env&quot;);
  58     }
  59     if ( obj == NULL ) {
  60         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef obj&quot;);
  61     }
  62     newobj = JNI_FUNC_PTR(env,NewGlobalRef)(env, obj);
  63     if ( newobj == NULL ) {
  64         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,&quot;NewGlobalRef&quot;);
  65     }
  66     *pobj = newobj;
  67 }
  68 
  69 /* Toss a previously saved object reference */
  70 void
  71 tossGlobalRef(JNIEnv *env, jobject *pobj)
  72 {
  73     jobject obj;
  74 
  75     if ( pobj == NULL ) {
  76         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;tossGlobalRef pobj&quot;);
  77     }
  78     obj = *pobj;
  79     if ( env == NULL ) {
  80         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;tossGlobalRef env&quot;);
  81     }
  82     if ( obj == NULL ) {
  83         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,&quot;tossGlobalRef obj&quot;);
  84     }
  85     JNI_FUNC_PTR(env,DeleteGlobalRef)(env, obj);
  86     *pobj = NULL;
  87 }
  88 
  89 jclass
  90 findClass(JNIEnv *env, const char * name)
  91 {
  92     jclass x;
  93 
  94     if ( env == NULL ) {
  95         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;findClass env&quot;);
  96     }
  97     if ( name == NULL || name[0] == 0 ) {
  98         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;findClass name&quot;);
  99     }
 100     x = JNI_FUNC_PTR(env,FindClass)(env, name);
 101     if (x == NULL) {
 102         ERROR_MESSAGE((&quot;JDWP Can&#39;t find class %s&quot;, name));
 103         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 104     }
 105     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 106         ERROR_MESSAGE((&quot;JDWP Exception occurred finding class %s&quot;, name));
 107         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 108     }
 109     return x;
 110 }
 111 
 112 jmethodID
 113 getMethod(JNIEnv *env, jclass clazz, const char * name, const char *signature)
 114 {
 115     jmethodID method;
 116 
 117     if ( env == NULL ) {
 118         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod env&quot;);
 119     }
 120     if ( clazz == NULL ) {
 121         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod clazz&quot;);
 122     }
 123     if ( name == NULL || name[0] == 0 ) {
 124         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod name&quot;);
 125     }
 126     if ( signature == NULL || signature[0] == 0 ) {
 127         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod signature&quot;);
 128     }
 129     method = JNI_FUNC_PTR(env,GetMethodID)(env, clazz, name, signature);
 130     if (method == NULL) {
 131         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 132                                 name, signature));
 133         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 134     }
 135     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 136         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 137                                 name, signature));
 138         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 139     }
 140     return method;
 141 }
 142 
 143 static jmethodID
 144 getStaticMethod(JNIEnv *env, jclass clazz, const char * name, const char *signature)
 145 {
 146     jmethodID method;
 147 
 148     if ( env == NULL ) {
 149         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod env&quot;);
 150     }
 151     if ( clazz == NULL ) {
 152         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod clazz&quot;);
 153     }
 154     if ( name == NULL || name[0] == 0 ) {
 155         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod name&quot;);
 156     }
 157     if ( signature == NULL || signature[0] == 0 ) {
 158         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod signature&quot;);
 159     }
 160     method = JNI_FUNC_PTR(env,GetStaticMethodID)(env, clazz, name, signature);
 161     if (method == NULL) {
 162         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 163                                 name, signature));
 164         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 165     }
 166     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 167         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 168                                 name, signature));
 169         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 170     }
 171     return method;
 172 }
 173 
 174 void
 175 util_initialize(JNIEnv *env)
 176 {
 177     WITH_LOCAL_REFS(env, 6) {
 178 
 179         jvmtiError error;
 180         jclass localClassClass;
 181         jclass localThreadClass;
 182         jclass localThreadGroupClass;
 183         jclass localClassLoaderClass;
 184         jclass localStringClass;
 185         jclass localSystemClass;
 186         jclass localPropertiesClass;
 187         jclass localVMSupportClass;
 188         jobject localAgentProperties;
 189         jmethodID getAgentProperties;
 190         jint groupCount;
 191         jthreadGroup *groups;
 192         jthreadGroup localSystemThreadGroup;
 193 
 194         /* Find some standard classes */
 195 
 196         localClassClass         = findClass(env,&quot;java/lang/Class&quot;);
 197         localThreadClass        = findClass(env,&quot;java/lang/Thread&quot;);
 198         localThreadGroupClass   = findClass(env,&quot;java/lang/ThreadGroup&quot;);
 199         localClassLoaderClass   = findClass(env,&quot;java/lang/ClassLoader&quot;);
 200         localStringClass        = findClass(env,&quot;java/lang/String&quot;);
 201         localSystemClass        = findClass(env,&quot;java/lang/System&quot;);
 202         localPropertiesClass    = findClass(env,&quot;java/util/Properties&quot;);
 203 
 204         /* Save references */
 205 
 206         saveGlobalRef(env, localClassClass,       &amp;(gdata-&gt;classClass));
 207         saveGlobalRef(env, localThreadClass,      &amp;(gdata-&gt;threadClass));
 208         saveGlobalRef(env, localThreadGroupClass, &amp;(gdata-&gt;threadGroupClass));
 209         saveGlobalRef(env, localClassLoaderClass, &amp;(gdata-&gt;classLoaderClass));
 210         saveGlobalRef(env, localStringClass,      &amp;(gdata-&gt;stringClass));
 211         saveGlobalRef(env, localSystemClass,      &amp;(gdata-&gt;systemClass));
 212 
 213         /* Find some standard methods */
 214 
 215         gdata-&gt;threadConstructor =
 216                 getMethod(env, gdata-&gt;threadClass,
 217                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/ThreadGroup;Ljava/lang/String;)V&quot;);
 218         gdata-&gt;threadSetDaemon =
 219                 getMethod(env, gdata-&gt;threadClass, &quot;setDaemon&quot;, &quot;(Z)V&quot;);
 220         gdata-&gt;threadResume =
 221                 getMethod(env, gdata-&gt;threadClass, &quot;resume&quot;, &quot;()V&quot;);
 222         gdata-&gt;systemGetProperty =
 223                 getStaticMethod(env, gdata-&gt;systemClass,
 224                     &quot;getProperty&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);
 225         gdata-&gt;setProperty =
 226                 getMethod(env, localPropertiesClass,
 227                     &quot;setProperty&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
 228 
 229         /* Find the system thread group */
 230 
 231         groups = NULL;
 232         groupCount = 0;
 233         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetTopThreadGroups)
 234                     (gdata-&gt;jvmti, &amp;groupCount, &amp;groups);
 235         if (error != JVMTI_ERROR_NONE ) {
 236             EXIT_ERROR(error, &quot;Can&#39;t get system thread group&quot;);
 237         }
 238         if ( groupCount == 0 ) {
 239             EXIT_ERROR(AGENT_ERROR_NULL_POINTER, &quot;Can&#39;t get system thread group&quot;);
 240         }
 241         localSystemThreadGroup = groups[0];
 242         saveGlobalRef(env, localSystemThreadGroup, &amp;(gdata-&gt;systemThreadGroup));
 243 
 244         /* Get some basic Java property values we will need at some point */
 245         gdata-&gt;property_java_version
 246                         = getPropertyUTF8(env, &quot;java.version&quot;);
 247         gdata-&gt;property_java_vm_name
 248                         = getPropertyUTF8(env, &quot;java.vm.name&quot;);
 249         gdata-&gt;property_java_vm_info
 250                         = getPropertyUTF8(env, &quot;java.vm.info&quot;);
 251         gdata-&gt;property_java_class_path
 252                         = getPropertyUTF8(env, &quot;java.class.path&quot;);
 253         gdata-&gt;property_sun_boot_library_path
 254                         = getPropertyUTF8(env, &quot;sun.boot.library.path&quot;);
 255         gdata-&gt;property_path_separator
 256                         = getPropertyUTF8(env, &quot;path.separator&quot;);
 257         gdata-&gt;property_user_dir
 258                         = getPropertyUTF8(env, &quot;user.dir&quot;);
 259 
 260         /* Get agent properties: invoke VMSupport.getAgentProperties */
 261         localVMSupportClass = JNI_FUNC_PTR(env,FindClass)
 262                                           (env, &quot;jdk/internal/vm/VMSupport&quot;);
 263         if (localVMSupportClass == NULL) {
 264             gdata-&gt;agent_properties = NULL;
 265             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 266                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 267             }
 268         } else {
 269             getAgentProperties  =
 270                 getStaticMethod(env, localVMSupportClass,
 271                                 &quot;getAgentProperties&quot;, &quot;()Ljava/util/Properties;&quot;);
 272             localAgentProperties =
 273                 JNI_FUNC_PTR(env,CallStaticObjectMethod)
 274                             (env, localVMSupportClass, getAgentProperties);
 275             saveGlobalRef(env, localAgentProperties, &amp;(gdata-&gt;agent_properties));
 276             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 277                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 278                 EXIT_ERROR(AGENT_ERROR_INTERNAL,
 279                     &quot;Exception occurred calling VMSupport.getAgentProperties&quot;);
 280             }
 281         }
 282 
 283     } END_WITH_LOCAL_REFS(env);
 284 
 285 }
 286 
 287 void
 288 util_reset(void)
 289 {
 290 }
 291 
 292 jboolean
 293 isObjectTag(jbyte tag) {
 294     return (tag == JDWP_TAG(OBJECT)) ||
 295            (tag == JDWP_TAG(INLINE_OBJECT)) ||
 296            (tag == JDWP_TAG(STRING)) ||
 297            (tag == JDWP_TAG(THREAD)) ||
 298            (tag == JDWP_TAG(THREAD_GROUP)) ||
 299            (tag == JDWP_TAG(CLASS_LOADER)) ||
 300            (tag == JDWP_TAG(CLASS_OBJECT)) ||
 301            (tag == JDWP_TAG(ARRAY));
 302 }
 303 
 304 jbyte
 305 specificTypeKey(JNIEnv *env, jobject object)
 306 {
 307     if (object == NULL) {
 308         return JDWP_TAG(OBJECT);
 309     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;stringClass)) {
 310         return JDWP_TAG(STRING);
 311     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadClass)) {
 312         return JDWP_TAG(THREAD);
 313     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadGroupClass)) {
 314         return JDWP_TAG(THREAD_GROUP);
 315     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classLoaderClass)) {
 316         return JDWP_TAG(CLASS_LOADER);
 317     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classClass)) {
 318         return JDWP_TAG(CLASS_OBJECT);
 319     } else {
 320         jboolean classIsArray;
 321 
 322         WITH_LOCAL_REFS(env, 1) {
 323             jclass clazz;
 324             clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 325             classIsArray = isArrayClass(clazz);
 326         } END_WITH_LOCAL_REFS(env);
 327 
 328         return (classIsArray ? JDWP_TAG(ARRAY) : JDWP_TAG(OBJECT));
 329     }
 330 }
 331 
 332 static void
 333 writeFieldValue(JNIEnv *env, PacketOutputStream *out, jobject object,
 334                 jfieldID field)
 335 {
 336     jclass clazz;
 337     char *signature = NULL;
 338     jvmtiError error;
 339     jbyte typeKey;
 340 
 341     clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 342     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 343     if (error != JVMTI_ERROR_NONE) {
 344         outStream_setError(out, map2jdwpError(error));
 345         return;
 346     }
 347     typeKey = signature[0];
 348     jvmtiDeallocate(signature);
 349 
 350     /*
 351      * For primitive types, the type key is bounced back as is. Objects
 352      * are handled in the switch statement below.
 353      */
 354     if ((typeKey != JDWP_TAG(OBJECT)) &amp;&amp; (typeKey != JDWP_TAG(ARRAY)) &amp;&amp; (typeKey != JDWP_TAG(INLINE_OBJECT))) {
 355         (void)outStream_writeByte(out, typeKey);
 356     }
 357 
 358     switch (typeKey) {
 359         case JDWP_TAG(OBJECT):
 360         case JDWP_TAG(ARRAY):
 361         case JDWP_TAG(INLINE_OBJECT): {
 362             jobject value = JNI_FUNC_PTR(env,GetObjectField)(env, object, field);
 363             (void)outStream_writeByte(out, specificTypeKey(env, value));
 364             (void)outStream_writeObjectRef(env, out, value);
 365             break;
 366         }
 367 
 368         case JDWP_TAG(BYTE):
 369             (void)outStream_writeByte(out,
 370                       JNI_FUNC_PTR(env,GetByteField)(env, object, field));
 371             break;
 372 
 373         case JDWP_TAG(CHAR):
 374             (void)outStream_writeChar(out,
 375                       JNI_FUNC_PTR(env,GetCharField)(env, object, field));
 376             break;
 377 
 378         case JDWP_TAG(FLOAT):
 379             (void)outStream_writeFloat(out,
 380                       JNI_FUNC_PTR(env,GetFloatField)(env, object, field));
 381             break;
 382 
 383         case JDWP_TAG(DOUBLE):
 384             (void)outStream_writeDouble(out,
 385                       JNI_FUNC_PTR(env,GetDoubleField)(env, object, field));
 386             break;
 387 
 388         case JDWP_TAG(INT):
 389             (void)outStream_writeInt(out,
 390                       JNI_FUNC_PTR(env,GetIntField)(env, object, field));
 391             break;
 392 
 393         case JDWP_TAG(LONG):
 394             (void)outStream_writeLong(out,
 395                       JNI_FUNC_PTR(env,GetLongField)(env, object, field));
 396             break;
 397 
 398         case JDWP_TAG(SHORT):
 399             (void)outStream_writeShort(out,
 400                       JNI_FUNC_PTR(env,GetShortField)(env, object, field));
 401             break;
 402 
 403         case JDWP_TAG(BOOLEAN):
 404             (void)outStream_writeBoolean(out,
 405                       JNI_FUNC_PTR(env,GetBooleanField)(env, object, field));
 406             break;
 407     }
 408 }
 409 
 410 static void
 411 writeStaticFieldValue(JNIEnv *env, PacketOutputStream *out, jclass clazz,
 412                       jfieldID field)
 413 {
 414     jvmtiError error;
 415     char *signature = NULL;
 416     jbyte typeKey;
 417 
 418     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 419     if (error != JVMTI_ERROR_NONE) {
 420         outStream_setError(out, map2jdwpError(error));
 421         return;
 422     }
 423     typeKey = signature[0];
 424     jvmtiDeallocate(signature);
 425 
 426     /*
 427      * For primitive types, the type key is bounced back as is. Objects
 428      * are handled in the switch statement below.
 429      */
 430     if ((typeKey != JDWP_TAG(OBJECT)) &amp;&amp; (typeKey != JDWP_TAG(ARRAY)) &amp;&amp; (typeKey != JDWP_TAG(INLINE_OBJECT))) {
 431         (void)outStream_writeByte(out, typeKey);
 432     }
 433 
 434     switch (typeKey) {
 435         case JDWP_TAG(OBJECT):
 436         case JDWP_TAG(ARRAY):
 437         case JDWP_TAG(INLINE_OBJECT): {
 438             jobject value = JNI_FUNC_PTR(env,GetStaticObjectField)(env, clazz, field);
 439             (void)outStream_writeByte(out, specificTypeKey(env, value));
 440             (void)outStream_writeObjectRef(env, out, value);
 441             break;
 442         }
 443 
 444         case JDWP_TAG(BYTE):
 445             (void)outStream_writeByte(out,
 446                       JNI_FUNC_PTR(env,GetStaticByteField)(env, clazz, field));
 447             break;
 448 
 449         case JDWP_TAG(CHAR):
 450             (void)outStream_writeChar(out,
 451                       JNI_FUNC_PTR(env,GetStaticCharField)(env, clazz, field));
 452             break;
 453 
 454         case JDWP_TAG(FLOAT):
 455             (void)outStream_writeFloat(out,
 456                       JNI_FUNC_PTR(env,GetStaticFloatField)(env, clazz, field));
 457             break;
 458 
 459         case JDWP_TAG(DOUBLE):
 460             (void)outStream_writeDouble(out,
 461                       JNI_FUNC_PTR(env,GetStaticDoubleField)(env, clazz, field));
 462             break;
 463 
 464         case JDWP_TAG(INT):
 465             (void)outStream_writeInt(out,
 466                       JNI_FUNC_PTR(env,GetStaticIntField)(env, clazz, field));
 467             break;
 468 
 469         case JDWP_TAG(LONG):
 470             (void)outStream_writeLong(out,
 471                       JNI_FUNC_PTR(env,GetStaticLongField)(env, clazz, field));
 472             break;
 473 
 474         case JDWP_TAG(SHORT):
 475             (void)outStream_writeShort(out,
 476                       JNI_FUNC_PTR(env,GetStaticShortField)(env, clazz, field));
 477             break;
 478 
 479         case JDWP_TAG(BOOLEAN):
 480             (void)outStream_writeBoolean(out,
 481                       JNI_FUNC_PTR(env,GetStaticBooleanField)(env, clazz, field));
 482             break;
 483     }
 484 }
 485 
 486 void
 487 sharedGetFieldValues(PacketInputStream *in, PacketOutputStream *out,
 488                      jboolean isStatic)
 489 {
 490     JNIEnv *env = getEnv();
 491     jint length;
 492     jobject object;
 493     jclass clazz;
 494 
 495     object = NULL;
 496     clazz  = NULL;
 497 
 498     if (isStatic) {
 499         clazz = inStream_readClassRef(env, in);
 500     } else {
 501         object = inStream_readObjectRef(env, in);
 502     }
 503 
 504     length = inStream_readInt(in);
 505     if (inStream_error(in)) {
 506         return;
 507     }
 508 
 509     WITH_LOCAL_REFS(env, length + 1) { /* +1 for class with instance fields */
 510 
 511         int i;
 512 
 513         (void)outStream_writeInt(out, length);
 514         for (i = 0; (i &lt; length) &amp;&amp; !outStream_error(out); i++) {
 515             jfieldID field = inStream_readFieldID(in);
 516 
 517             if (isStatic) {
 518                 writeStaticFieldValue(env, out, clazz, field);
 519             } else {
 520                 writeFieldValue(env, out, object, field);
 521             }
 522         }
 523 
 524     } END_WITH_LOCAL_REFS(env);
 525 }
 526 
 527 jboolean
 528 sharedInvoke(PacketInputStream *in, PacketOutputStream *out)
 529 {
 530     jvalue *arguments = NULL;
 531     jint options;
 532     jvmtiError error;
 533     jbyte invokeType;
 534     jclass clazz;
 535     jmethodID method;
 536     jint argumentCount;
 537     jobject instance;
 538     jthread thread;
 539     JNIEnv *env;
 540 
 541     /*
 542      * Instance methods start with the instance, thread and class,
 543      * and statics and constructors start with the class and then the
 544      * thread.
 545      */
 546     env = getEnv();
 547     if (inStream_command(in) == JDWP_COMMAND(ObjectReference, InvokeMethod)) {
 548         instance = inStream_readObjectRef(env, in);
 549         thread = inStream_readThreadRef(env, in);
 550         clazz = inStream_readClassRef(env, in);
 551     } else { /* static method or constructor */
 552         instance = NULL;
 553         clazz = inStream_readClassRef(env, in);
 554         thread = inStream_readThreadRef(env, in);
 555     }
 556 
 557     /*
 558      * ... and the rest of the packet is identical for all commands
 559      */
 560     method = inStream_readMethodID(in);
 561     argumentCount = inStream_readInt(in);
 562     if (inStream_error(in)) {
 563         return JNI_TRUE;
 564     }
 565 
 566     /* If count == 0, don&#39;t try and allocate 0 bytes, you&#39;ll get NULL */
 567     if ( argumentCount &gt; 0 ) {
 568         int i;
 569         /*LINTED*/
 570         arguments = jvmtiAllocate(argumentCount * (jint)sizeof(*arguments));
 571         if (arguments == NULL) {
 572             outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
 573             return JNI_TRUE;
 574         }
 575         for (i = 0; (i &lt; argumentCount) &amp;&amp; !inStream_error(in); i++) {
 576             arguments[i] = inStream_readValue(in, NULL);
 577         }
 578         if (inStream_error(in)) {
 579             return JNI_TRUE;
 580         }
 581     }
 582 
 583     options = inStream_readInt(in);
 584     if (inStream_error(in)) {
 585         if ( arguments != NULL ) {
 586             jvmtiDeallocate(arguments);
 587         }
 588         return JNI_TRUE;
 589     }
 590 
 591     if (inStream_command(in) == JDWP_COMMAND(ClassType, NewInstance)) {
 592         invokeType = INVOKE_CONSTRUCTOR;
 593     } else if (inStream_command(in) == JDWP_COMMAND(ClassType, InvokeMethod)) {
 594         invokeType = INVOKE_STATIC;
 595     } else if (inStream_command(in) == JDWP_COMMAND(InterfaceType, InvokeMethod)) {
 596         invokeType = INVOKE_STATIC;
 597     } else if (inStream_command(in) == JDWP_COMMAND(ObjectReference, InvokeMethod)) {
 598         invokeType = INVOKE_INSTANCE;
 599     } else {
 600         outStream_setError(out, JDWP_ERROR(INTERNAL));
 601         if ( arguments != NULL ) {
 602             jvmtiDeallocate(arguments);
 603         }
 604         return JNI_TRUE;
 605     }
 606 
 607     /*
 608      * Request the invoke. If there are no errors in the request,
 609      * the interrupting thread will actually do the invoke and a
 610      * reply will be generated subsequently, so we don&#39;t reply here.
 611      */
 612     error = invoker_requestInvoke(invokeType, (jbyte)options, inStream_id(in),
 613                                   thread, clazz, method,
 614                                   instance, arguments, argumentCount);
 615     if (error != JVMTI_ERROR_NONE) {
 616         outStream_setError(out, map2jdwpError(error));
 617         if ( arguments != NULL ) {
 618             jvmtiDeallocate(arguments);
 619         }
 620         return JNI_TRUE;
 621     }
 622 
 623     return JNI_FALSE;   /* Don&#39;t reply */
 624 }
 625 
 626 jint
 627 uniqueID(void)
 628 {
 629     static jint currentID = 0;
 630     return currentID++;
 631 }
 632 
 633 int
 634 filterDebugThreads(jthread *threads, int count)
 635 {
 636     int i;
 637     int current;
 638 
 639     /* Squish out all of the debugger-spawned threads */
 640     for (i = 0, current = 0; i &lt; count; i++) {
 641         jthread thread = threads[i];
 642         if (!threadControl_isDebugThread(thread)) {
 643             if (i &gt; current) {
 644                 threads[current] = thread;
 645             }
 646             current++;
 647         }
 648     }
 649     return current;
 650 }
 651 
 652 jbyte
 653 referenceTypeTag(jclass clazz)
 654 {
 655     jbyte tag;
 656 
 657     if (isInterface(clazz)) {
 658         tag = JDWP_TYPE_TAG(INTERFACE);
 659     } else if (isArrayClass(clazz)) {
 660         tag = JDWP_TYPE_TAG(ARRAY);
 661     } else {
 662         tag = JDWP_TYPE_TAG(CLASS);
 663     }
 664 
 665     return tag;
 666 }
 667 
 668 /**
 669  * Get field modifiers
 670  */
 671 jvmtiError
 672 fieldModifiers(jclass clazz, jfieldID field, jint *pmodifiers)
 673 {
 674     jvmtiError error;
 675 
 676     *pmodifiers = 0;
 677     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFieldModifiers)
 678             (gdata-&gt;jvmti, clazz, field, pmodifiers);
 679     return error;
 680 }
 681 
 682 /**
 683  * Get method modifiers
 684  */
 685 jvmtiError
 686 methodModifiers(jmethodID method, jint *pmodifiers)
 687 {
 688     jvmtiError error;
 689 
 690     *pmodifiers = 0;
 691     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetMethodModifiers)
 692             (gdata-&gt;jvmti, method, pmodifiers);
 693     return error;
 694 }
 695 
 696 /* Returns a local ref to the declaring class for a method, or NULL. */
 697 jvmtiError
 698 methodClass(jmethodID method, jclass *pclazz)
 699 {
 700     jvmtiError error;
 701 
 702     *pclazz = NULL;
 703     error = FUNC_PTR(gdata-&gt;jvmti,GetMethodDeclaringClass)
 704                                 (gdata-&gt;jvmti, method, pclazz);
 705     return error;
 706 }
 707 
 708 /* Returns a local ref to the declaring class for a method, or NULL. */
 709 jvmtiError
 710 methodLocation(jmethodID method, jlocation *ploc1, jlocation *ploc2)
 711 {
 712     jvmtiError error;
 713 
 714     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetMethodLocation)
 715                                 (gdata-&gt;jvmti, method, ploc1, ploc2);
 716     return error;
 717 }
 718 
 719 /**
 720  * Get method signature
 721  */
 722 jvmtiError
 723 methodSignature(jmethodID method,
 724         char **pname, char **psignature, char **pgeneric_signature)
 725 {
 726     jvmtiError error;
 727     char *name = NULL;
 728     char *signature = NULL;
 729     char *generic_signature = NULL;
 730 
 731     error = FUNC_PTR(gdata-&gt;jvmti,GetMethodName)
 732             (gdata-&gt;jvmti, method, &amp;name, &amp;signature, &amp;generic_signature);
 733 
 734     if ( pname != NULL ) {
 735         *pname = name;
 736     } else if ( name != NULL )  {
 737         jvmtiDeallocate(name);
 738     }
 739     if ( psignature != NULL ) {
 740         *psignature = signature;
 741     } else if ( signature != NULL ) {
 742         jvmtiDeallocate(signature);
 743     }
 744     if ( pgeneric_signature != NULL ) {
 745         *pgeneric_signature = generic_signature;
 746     } else if ( generic_signature != NULL )  {
 747         jvmtiDeallocate(generic_signature);
 748     }
 749     return error;
 750 }
 751 
 752 /*
 753  * Get the return type key of the method
 754  *     V or B C D F I J S Z L  [
 755  */
 756 jvmtiError
 757 methodReturnType(jmethodID method, char *typeKey)
 758 {
 759     char       *signature;
 760     jvmtiError  error;
 761 
 762     signature = NULL;
 763     error     = methodSignature(method, NULL, &amp;signature, NULL);
 764     if (error == JVMTI_ERROR_NONE) {
 765         if (signature == NULL ) {
 766             error = AGENT_ERROR_INVALID_TAG;
 767         } else {
 768             char * xx;
 769 
 770             xx = strchr(signature, &#39;)&#39;);
 771             if (xx == NULL || *(xx + 1) == 0) {
 772                 error = AGENT_ERROR_INVALID_TAG;
 773             } else {
 774                *typeKey = *(xx + 1);
 775             }
 776             jvmtiDeallocate(signature);
 777         }
 778     }
 779     return error;
 780 }
 781 
 782 
 783 /**
 784  * Return class loader for a class (must be inside a WITH_LOCAL_REFS)
 785  */
 786 jvmtiError
 787 classLoader(jclass clazz, jobject *pclazz)
 788 {
 789     jvmtiError error;
 790 
 791     *pclazz = NULL;
 792     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassLoader)
 793             (gdata-&gt;jvmti, clazz, pclazz);
 794     return error;
 795 }
 796 
 797 /**
 798  * Get field signature
 799  */
 800 jvmtiError
 801 fieldSignature(jclass clazz, jfieldID field,
 802         char **pname, char **psignature, char **pgeneric_signature)
 803 {
 804     jvmtiError error;
 805     char *name = NULL;
 806     char *signature = NULL;
 807     char *generic_signature = NULL;
 808 
 809     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFieldName)
 810             (gdata-&gt;jvmti, clazz, field, &amp;name, &amp;signature, &amp;generic_signature);
 811 
 812     if ( pname != NULL ) {
 813         *pname = name;
 814     } else if ( name != NULL )  {
 815         jvmtiDeallocate(name);
 816     }
 817     if ( psignature != NULL ) {
 818         *psignature = signature;
 819     } else if ( signature != NULL )  {
 820         jvmtiDeallocate(signature);
 821     }
 822     if ( pgeneric_signature != NULL ) {
 823         *pgeneric_signature = generic_signature;
 824     } else if ( generic_signature != NULL )  {
 825         jvmtiDeallocate(generic_signature);
 826     }
 827     return error;
 828 }
 829 
 830 JNIEnv *
 831 getEnv(void)
 832 {
 833     JNIEnv *env = NULL;
 834     jint rc;
 835 
 836     rc = FUNC_PTR(gdata-&gt;jvm,GetEnv)
 837                 (gdata-&gt;jvm, (void **)&amp;env, JNI_VERSION_1_2);
 838     if (rc != JNI_OK) {
 839         ERROR_MESSAGE((&quot;JDWP Unable to get JNI 1.2 environment, jvm-&gt;GetEnv() return code = %d&quot;,
 840                 rc));
 841         EXIT_ERROR(AGENT_ERROR_NO_JNI_ENV,NULL);
 842     }
 843     return env;
 844 }
 845 
 846 jvmtiError
 847 spawnNewThread(jvmtiStartFunction func, void *arg, char *name)
 848 {
 849     JNIEnv *env = getEnv();
 850     jvmtiError error;
 851 
 852     LOG_MISC((&quot;Spawning new thread: %s&quot;, name));
 853 
 854     WITH_LOCAL_REFS(env, 3) {
 855 
 856         jthread thread;
 857         jstring nameString;
 858 
 859         nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, name);
 860         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 861             JNI_FUNC_PTR(env,ExceptionClear)(env);
 862             error = AGENT_ERROR_OUT_OF_MEMORY;
 863             goto err;
 864         }
 865 
 866         thread = JNI_FUNC_PTR(env,NewObject)
 867                         (env, gdata-&gt;threadClass, gdata-&gt;threadConstructor,
 868                                    gdata-&gt;systemThreadGroup, nameString);
 869         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 870             JNI_FUNC_PTR(env,ExceptionClear)(env);
 871             error = AGENT_ERROR_OUT_OF_MEMORY;
 872             goto err;
 873         }
 874 
 875         /*
 876          * Make the debugger thread a daemon
 877          */
 878         JNI_FUNC_PTR(env,CallVoidMethod)
 879                         (env, thread, gdata-&gt;threadSetDaemon, JNI_TRUE);
 880         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 881             JNI_FUNC_PTR(env,ExceptionClear)(env);
 882             error = AGENT_ERROR_JNI_EXCEPTION;
 883             goto err;
 884         }
 885 
 886         error = threadControl_addDebugThread(thread);
 887         if (error == JVMTI_ERROR_NONE) {
 888             /*
 889              * Debugger threads need cycles in all sorts of strange
 890              * situations (e.g. infinite cpu-bound loops), so give the
 891              * thread a high priority. Note that if the VM has an application
 892              * thread running at the max priority, there is still a chance
 893              * that debugger threads will be starved. (There needs to be
 894              * a way to give debugger threads a priority higher than any
 895              * application thread).
 896              */
 897             error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,RunAgentThread)
 898                         (gdata-&gt;jvmti, thread, func, arg,
 899                                         JVMTI_THREAD_MAX_PRIORITY);
 900         }
 901 
 902         err: ;
 903 
 904     } END_WITH_LOCAL_REFS(env);
 905 
 906     return error;
 907 }
 908 
 909 jvmtiError
 910 jvmtiGetCapabilities(jvmtiCapabilities *caps)
 911 {
 912     if ( gdata-&gt;vmDead ) {
 913         return AGENT_ERROR_VM_DEAD;
 914     }
 915     if (!gdata-&gt;haveCachedJvmtiCapabilities) {
 916         jvmtiError error;
 917 
 918         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetCapabilities)
 919                         (gdata-&gt;jvmti, &amp;(gdata-&gt;cachedJvmtiCapabilities));
 920         if (error != JVMTI_ERROR_NONE) {
 921             return error;
 922         }
 923         gdata-&gt;haveCachedJvmtiCapabilities = JNI_TRUE;
 924     }
 925 
 926     *caps = gdata-&gt;cachedJvmtiCapabilities;
 927 
 928     return JVMTI_ERROR_NONE;
 929 }
 930 
 931 static jint
 932 jvmtiVersion(void)
 933 {
 934     if (gdata-&gt;cachedJvmtiVersion == 0) {
 935         jvmtiError error;
 936         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetVersionNumber)
 937                         (gdata-&gt;jvmti, &amp;(gdata-&gt;cachedJvmtiVersion));
 938         if (error != JVMTI_ERROR_NONE) {
 939             EXIT_ERROR(error, &quot;on getting the JVMTI version number&quot;);
 940         }
 941     }
 942     return gdata-&gt;cachedJvmtiVersion;
 943 }
 944 
 945 jint
 946 jvmtiMajorVersion(void)
 947 {
 948     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MAJOR)
 949                     &gt;&gt; JVMTI_VERSION_SHIFT_MAJOR;
 950 }
 951 
 952 jint
 953 jvmtiMinorVersion(void)
 954 {
 955     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MINOR)
 956                     &gt;&gt; JVMTI_VERSION_SHIFT_MINOR;
 957 }
 958 
 959 jint
 960 jvmtiMicroVersion(void)
 961 {
 962     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MICRO)
 963                     &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 964 }
 965 
 966 jboolean
 967 canSuspendResumeThreadLists(void)
 968 {
 969     jvmtiError error;
 970     jvmtiCapabilities cap;
 971 
 972     error = jvmtiGetCapabilities(&amp;cap);
 973     return (error == JVMTI_ERROR_NONE &amp;&amp; cap.can_suspend);
 974 }
 975 
 976 jvmtiError
 977 getSourceDebugExtension(jclass clazz, char **extensionPtr)
 978 {
 979     return JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSourceDebugExtension)
 980                 (gdata-&gt;jvmti, clazz, extensionPtr);
 981 }
 982 
 983 /*
 984  * Convert the signature &quot;Ljava/lang/Foo;&quot; to a
 985  * classname &quot;java.lang.Foo&quot; compatible with the pattern.
 986  * Signature is overwritten in-place.
 987  */
 988 void
 989 convertSignatureToClassname(char *convert)
 990 {
 991     char *p;
 992 
 993     p = convert + 1;
 994     while ((*p != &#39;;&#39;) &amp;&amp; (*p != &#39;\0&#39;)) {
 995         char c = *p;
 996         if (c == &#39;/&#39;) {
 997             *(p-1) = &#39;.&#39;;
 998         } else if (c == &#39;.&#39;) {
 999             // class signature of a hidden class is &quot;Ljava/lang/Foo.1234;&quot;
1000             // map to &quot;java.lang.Foo/1234&quot;
1001             *(p-1) = &#39;/&#39;;
1002         } else {
1003             *(p-1) = c;
1004         }
1005         p++;
1006     }
1007     *(p-1) = &#39;\0&#39;;
1008 }
1009 
1010 static void
1011 handleInterrupt(void)
1012 {
1013     /*
1014      * An interrupt is handled:
1015      *
1016      * 1) for running application threads by deferring the interrupt
1017      * until the current event handler has concluded.
1018      *
1019      * 2) for debugger threads by ignoring the interrupt; this is the
1020      * most robust solution since debugger threads don&#39;t use interrupts
1021      * to signal any condition.
1022      *
1023      * 3) for application threads that have not started or already
1024      * ended by ignoring the interrupt. In the former case, the application
1025      * is relying on timing to determine whether or not the thread sees
1026      * the interrupt; in the latter case, the interrupt is meaningless.
1027      */
1028     jthread thread = threadControl_currentThread();
1029     if ((thread != NULL) &amp;&amp; (!threadControl_isDebugThread(thread))) {
1030         threadControl_setPendingInterrupt(thread);
1031     }
1032 }
1033 
1034 static jvmtiError
1035 ignore_vm_death(jvmtiError error)
1036 {
1037     if (error == JVMTI_ERROR_WRONG_PHASE) {
1038         LOG_MISC((&quot;VM_DEAD, in debugMonitor*()?&quot;));
1039         return JVMTI_ERROR_NONE; /* JVMTI does this, not JVMDI? */
1040     }
1041     return error;
1042 }
1043 
1044 void
1045 debugMonitorEnter(jrawMonitorID monitor)
1046 {
1047     jvmtiError error;
1048     while (JNI_TRUE) {
1049         error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorEnter)
1050                         (gdata-&gt;jvmti, monitor);
1051         error = ignore_vm_death(error);
1052         if (error == JVMTI_ERROR_INTERRUPT) {
1053             handleInterrupt();
1054         } else {
1055             break;
1056         }
1057     }
1058     if (error != JVMTI_ERROR_NONE) {
1059         EXIT_ERROR(error, &quot;on raw monitor enter&quot;);
1060     }
1061 }
1062 
1063 void
1064 debugMonitorExit(jrawMonitorID monitor)
1065 {
1066     jvmtiError error;
1067 
1068     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorExit)
1069                 (gdata-&gt;jvmti, monitor);
1070     error = ignore_vm_death(error);
1071     if (error != JVMTI_ERROR_NONE) {
1072         EXIT_ERROR(error, &quot;on raw monitor exit&quot;);
1073     }
1074 }
1075 
1076 void
1077 debugMonitorWait(jrawMonitorID monitor)
1078 {
1079     jvmtiError error;
1080     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorWait)
1081         (gdata-&gt;jvmti, monitor, ((jlong)(-1)));
1082 
1083     /*
1084      * According to the JLS (17.8), here we have
1085      * either :
1086      * a- been notified
1087      * b- gotten a suprious wakeup
1088      * c- been interrupted
1089      * If both a and c have happened, the VM must choose
1090      * which way to return - a or c.  If it chooses c
1091      * then the notify is gone - either to some other
1092      * thread that is also waiting, or it is dropped
1093      * on the floor.
1094      *
1095      * a is what we expect.  b won&#39;t hurt us any -
1096      * callers should be programmed to handle
1097      * spurious wakeups.  In case of c,
1098      * then the interrupt has been cleared, but
1099      * we don&#39;t want to consume it.  It came from
1100      * user code and is intended for user code, not us.
1101      * So, we will remember that the interrupt has
1102      * occurred and re-activate it when this thread
1103      * goes back into user code.
1104      * That being said, what do we do here?  Since
1105      * we could have been notified too, here we will
1106      * just pretend that we have been.  It won&#39;t hurt
1107      * anything to return in the same way as if
1108      * we were notified since callers have to be able to
1109      * handle spurious wakeups anyway.
1110      */
1111     if (error == JVMTI_ERROR_INTERRUPT) {
1112         handleInterrupt();
1113         error = JVMTI_ERROR_NONE;
1114     }
1115     error = ignore_vm_death(error);
1116     if (error != JVMTI_ERROR_NONE) {
1117         EXIT_ERROR(error, &quot;on raw monitor wait&quot;);
1118     }
1119 }
1120 
1121 void
1122 debugMonitorTimedWait(jrawMonitorID monitor, jlong millis)
1123 {
1124     jvmtiError error;
1125     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorWait)
1126         (gdata-&gt;jvmti, monitor, millis);
1127     if (error == JVMTI_ERROR_INTERRUPT) {
1128         /* See comment above */
1129         handleInterrupt();
1130         error = JVMTI_ERROR_NONE;
1131     }
1132     error = ignore_vm_death(error);
1133     if (error != JVMTI_ERROR_NONE) {
1134         EXIT_ERROR(error, &quot;on raw monitor timed wait&quot;);
1135     }
1136 }
1137 
1138 void
1139 debugMonitorNotify(jrawMonitorID monitor)
1140 {
1141     jvmtiError error;
1142 
1143     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorNotify)
1144                 (gdata-&gt;jvmti, monitor);
1145     error = ignore_vm_death(error);
1146     if (error != JVMTI_ERROR_NONE) {
1147         EXIT_ERROR(error, &quot;on raw monitor notify&quot;);
1148     }
1149 }
1150 
1151 void
1152 debugMonitorNotifyAll(jrawMonitorID monitor)
1153 {
1154     jvmtiError error;
1155 
1156     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorNotifyAll)
1157                 (gdata-&gt;jvmti, monitor);
1158     error = ignore_vm_death(error);
1159     if (error != JVMTI_ERROR_NONE) {
1160         EXIT_ERROR(error, &quot;on raw monitor notify all&quot;);
1161     }
1162 }
1163 
1164 jrawMonitorID
1165 debugMonitorCreate(char *name)
1166 {
1167     jrawMonitorID monitor;
1168     jvmtiError error;
1169 
1170     error = FUNC_PTR(gdata-&gt;jvmti,CreateRawMonitor)
1171                 (gdata-&gt;jvmti, name, &amp;monitor);
1172     if (error != JVMTI_ERROR_NONE) {
1173         EXIT_ERROR(error, &quot;on creation of a raw monitor&quot;);
1174     }
1175     return monitor;
1176 }
1177 
1178 void
1179 debugMonitorDestroy(jrawMonitorID monitor)
1180 {
1181     jvmtiError error;
1182 
1183     error = FUNC_PTR(gdata-&gt;jvmti,DestroyRawMonitor)
1184                 (gdata-&gt;jvmti, monitor);
1185     error = ignore_vm_death(error);
1186     if (error != JVMTI_ERROR_NONE) {
1187         EXIT_ERROR(error, &quot;on destruction of raw monitor&quot;);
1188     }
1189 }
1190 
1191 /**
1192  * Return array of all threads (must be inside a WITH_LOCAL_REFS)
1193  */
1194 jthread *
1195 allThreads(jint *count)
1196 {
1197     jthread *threads;
1198     jvmtiError error;
1199 
1200     *count = 0;
1201     threads = NULL;
1202     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetAllThreads)
1203                 (gdata-&gt;jvmti, count, &amp;threads);
1204     if (error == AGENT_ERROR_OUT_OF_MEMORY) {
1205         return NULL; /* Let caller deal with no memory? */
1206     }
1207     if (error != JVMTI_ERROR_NONE) {
1208         EXIT_ERROR(error, &quot;getting all threads&quot;);
1209     }
1210     return threads;
1211 }
1212 
1213 /**
1214  * Fill the passed in structure with thread group info.
1215  * name field is JVMTI allocated.  parent is global ref.
1216  */
1217 void
1218 threadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo *info)
1219 {
1220     jvmtiError error;
1221 
1222     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetThreadGroupInfo)
1223                 (gdata-&gt;jvmti, group, info);
1224     if (error != JVMTI_ERROR_NONE) {
1225         EXIT_ERROR(error, &quot;on getting thread group info&quot;);
1226     }
1227 }
1228 
1229 /**
1230  * Return class signature string
1231  */
1232 jvmtiError
1233 classSignature(jclass clazz, char **psignature, char **pgeneric_signature)
1234 {
1235     jvmtiError error;
1236     char *signature = NULL;
1237 
1238     /*
1239      * pgeneric_signature can be NULL, and GetClassSignature
1240      * accepts NULL.
1241      */
1242     error = FUNC_PTR(gdata-&gt;jvmti,GetClassSignature)
1243                 (gdata-&gt;jvmti, clazz, &amp;signature, pgeneric_signature);
1244 
1245     if ( psignature != NULL ) {
1246         *psignature = signature;
1247     } else if ( signature != NULL )  {
1248         jvmtiDeallocate(signature);
1249     }
1250     return error;
1251 }
1252 
1253 /* Get class name (not signature) */
1254 char *
1255 getClassname(jclass clazz)
1256 {
1257     char *classname;
1258 
1259     classname = NULL;
1260     if ( clazz != NULL ) {
1261         if (classSignature(clazz, &amp;classname, NULL) != JVMTI_ERROR_NONE) {
1262             classname = NULL;
1263         } else {
1264             /* Convert in place */
1265             convertSignatureToClassname(classname);
1266         }
1267     }
1268     return classname; /* Caller must free this memory */
1269 }
1270 
1271 void
1272 writeGenericSignature(PacketOutputStream *out, char *genericSignature)
1273 {
1274     if (genericSignature == NULL) {
1275         (void)outStream_writeString(out, &quot;&quot;);
1276     } else {
1277         (void)outStream_writeString(out, genericSignature);
1278     }
1279 }
1280 
1281 jint
1282 classStatus(jclass clazz)
1283 {
1284     jint status;
1285     jvmtiError error;
1286 
1287     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassStatus)
1288                 (gdata-&gt;jvmti, clazz, &amp;status);
1289     if (error != JVMTI_ERROR_NONE) {
1290         EXIT_ERROR(error, &quot;on getting class status&quot;);
1291     }
1292     return status;
1293 }
1294 
1295 static jboolean
1296 isArrayClass(jclass clazz)
1297 {
1298     jboolean isArray = JNI_FALSE;
1299     jvmtiError error;
1300 
1301     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsArrayClass)
1302                 (gdata-&gt;jvmti, clazz, &amp;isArray);
1303     if (error != JVMTI_ERROR_NONE) {
1304         EXIT_ERROR(error, &quot;on checking for an array class&quot;);
1305     }
1306     return isArray;
1307 }
1308 
1309 static jboolean
1310 isInterface(jclass clazz)
1311 {
1312     jboolean isInterface = JNI_FALSE;
1313     jvmtiError error;
1314 
1315     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsInterface)
1316                 (gdata-&gt;jvmti, clazz, &amp;isInterface);
1317     if (error != JVMTI_ERROR_NONE) {
1318         EXIT_ERROR(error, &quot;on checking for an interface&quot;);
1319     }
1320     return isInterface;
1321 }
1322 
1323 jvmtiError
1324 isFieldSynthetic(jclass clazz, jfieldID field, jboolean *psynthetic)
1325 {
1326     jvmtiError error;
1327 
1328     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsFieldSynthetic)
1329                 (gdata-&gt;jvmti, clazz, field, psynthetic);
1330     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY ) {
1331         /* If the query is not supported, we assume it is not synthetic. */
1332         *psynthetic = JNI_FALSE;
1333         return JVMTI_ERROR_NONE;
1334     }
1335     return error;
1336 }
1337 
1338 jvmtiError
1339 isMethodSynthetic(jmethodID method, jboolean *psynthetic)
1340 {
1341     jvmtiError error;
1342 
1343     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodSynthetic)
1344                 (gdata-&gt;jvmti, method, psynthetic);
1345     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY ) {
1346         /* If the query is not supported, we assume it is not synthetic. */
1347         *psynthetic = JNI_FALSE;
1348         return JVMTI_ERROR_NONE;
1349     }
1350     return error;
1351 }
1352 
1353 jboolean
1354 isMethodNative(jmethodID method)
1355 {
1356     jboolean isNative = JNI_FALSE;
1357     jvmtiError error;
1358 
1359     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodNative)
1360                 (gdata-&gt;jvmti, method, &amp;isNative);
1361     if (error != JVMTI_ERROR_NONE) {
1362         EXIT_ERROR(error, &quot;on checking for a native interface&quot;);
1363     }
1364     return isNative;
1365 }
1366 
1367 jboolean
1368 isSameObject(JNIEnv *env, jobject o1, jobject o2)
1369 {
1370     if ( o1==o2 ) {
1371         return JNI_TRUE;
1372     }
1373     return FUNC_PTR(env,IsSameObject)(env, o1, o2);
1374 }
1375 
1376 jint
1377 objectHashCode(jobject object)
1378 {
1379     jint hashCode = 0;
1380     jvmtiError error;
1381 
1382     if ( object!=NULL ) {
1383         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetObjectHashCode)
1384                     (gdata-&gt;jvmti, object, &amp;hashCode);
1385         if (error != JVMTI_ERROR_NONE) {
1386             EXIT_ERROR(error, &quot;on getting an object hash code&quot;);
1387         }
1388     }
1389     return hashCode;
1390 }
1391 
1392 /* Get all implemented interfaces (must be inside a WITH_LOCAL_REFS) */
1393 jvmtiError
1394 allInterfaces(jclass clazz, jclass **ppinterfaces, jint *pcount)
1395 {
1396     jvmtiError error;
1397 
1398     *pcount = 0;
1399     *ppinterfaces = NULL;
1400     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetImplementedInterfaces)
1401                 (gdata-&gt;jvmti, clazz, pcount, ppinterfaces);
1402     return error;
1403 }
1404 
1405 /* Get all loaded classes (must be inside a WITH_LOCAL_REFS) */
1406 jvmtiError
1407 allLoadedClasses(jclass **ppclasses, jint *pcount)
1408 {
1409     jvmtiError error;
1410 
1411     *pcount = 0;
1412     *ppclasses = NULL;
1413     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetLoadedClasses)
1414                 (gdata-&gt;jvmti, pcount, ppclasses);
1415     return error;
1416 }
1417 
1418 /* Get all loaded classes for a loader (must be inside a WITH_LOCAL_REFS) */
1419 jvmtiError
1420 allClassLoaderClasses(jobject loader, jclass **ppclasses, jint *pcount)
1421 {
1422     jvmtiError error;
1423 
1424     *pcount = 0;
1425     *ppclasses = NULL;
1426     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassLoaderClasses)
1427                 (gdata-&gt;jvmti, loader, pcount, ppclasses);
1428     return error;
1429 }
1430 
1431 static jboolean
1432 is_a_nested_class(char *outer_sig, int outer_sig_len, char *sig, int sep)
1433 {
1434     char *inner;
1435 
1436     /* Assumed outer class signature is  &quot;LOUTERCLASSNAME;&quot;
1437      *         inner class signature is  &quot;LOUTERCLASSNAME$INNERNAME;&quot;
1438      *
1439      * INNERNAME can take the form:
1440      *    [0-9][1-9]*        anonymous class somewhere in the file
1441      *    [0-9][1-9]*NAME    local class somewhere in the OUTER class
1442      *    NAME               nested class in OUTER
1443      *
1444      * If NAME itself contains a $ (sep) then classname is further nested
1445      *    inside another class.
1446      *
1447      */
1448 
1449     /* Check prefix first */
1450     if ( strncmp(sig, outer_sig, outer_sig_len-1) != 0 ) {
1451         return JNI_FALSE;
1452     }
1453 
1454     /* Prefix must be followed by a $ (sep) */
1455     if ( sig[outer_sig_len-1] != sep ) {
1456         return JNI_FALSE;  /* No sep follows the match, must not be nested. */
1457     }
1458 
1459     /* Walk past any digits, if we reach the end, must be pure anonymous */
1460     inner = sig + outer_sig_len;
1461 #if 1 /* We want to return local classes */
1462     while ( *inner &amp;&amp; isdigit(*inner) ) {
1463         inner++;
1464     }
1465     /* But anonymous class names can&#39;t be trusted. */
1466     if ( *inner == &#39;;&#39; ) {
1467         return JNI_FALSE;  /* A pure anonymous class */
1468     }
1469 #else
1470     if ( *inner &amp;&amp; isdigit(*inner) ) {
1471         return JNI_FALSE;  /* A pure anonymous or local class */
1472     }
1473 #endif
1474 
1475     /* Nested deeper? */
1476     if ( strchr(inner, sep) != NULL ) {
1477         return JNI_FALSE;  /* Nested deeper than we want? */
1478     }
1479     return JNI_TRUE;
1480 }
1481 
1482 /* Get all nested classes for a class (must be inside a WITH_LOCAL_REFS) */
1483 jvmtiError
1484 allNestedClasses(jclass parent_clazz, jclass **ppnested, jint *pcount)
1485 {
1486     jvmtiError error;
1487     jobject parent_loader;
1488     jclass *classes;
1489     char *signature;
1490     size_t len;
1491     jint count;
1492     jint ncount;
1493     int i;
1494 
1495     *ppnested   = NULL;
1496     *pcount     = 0;
1497 
1498     parent_loader = NULL;
1499     classes       = NULL;
1500     signature     = NULL;
1501     count         = 0;
1502     ncount        = 0;
1503 
1504     error = classLoader(parent_clazz, &amp;parent_loader);
1505     if (error != JVMTI_ERROR_NONE) {
1506         return error;
1507     }
1508     error = classSignature(parent_clazz, &amp;signature, NULL);
1509     if (error != JVMTI_ERROR_NONE) {
1510         return error;
1511     }
1512     len = strlen(signature);
1513 
1514     error = allClassLoaderClasses(parent_loader, &amp;classes, &amp;count);
1515     if ( error != JVMTI_ERROR_NONE ) {
1516         jvmtiDeallocate(signature);
1517         return error;
1518     }
1519 
1520     for (i=0; i&lt;count; i++) {
1521         jclass clazz;
1522         char *candidate_signature;
1523 
1524         clazz = classes[i];
1525         candidate_signature = NULL;
1526         error = classSignature(clazz, &amp;candidate_signature, NULL);
1527         if (error != JVMTI_ERROR_NONE) {
1528             break;
1529         }
1530 
1531         if ( is_a_nested_class(signature, (int)len, candidate_signature, &#39;$&#39;) ||
1532              is_a_nested_class(signature, (int)len, candidate_signature, &#39;#&#39;) ) {
1533             /* Float nested classes to top */
1534             classes[i] = classes[ncount];
1535             classes[ncount++] = clazz;
1536         }
1537         jvmtiDeallocate(candidate_signature);
1538     }
1539 
1540     jvmtiDeallocate(signature);
1541 
1542     if ( count != 0 &amp;&amp;  ncount == 0 ) {
1543         jvmtiDeallocate(classes);
1544         classes = NULL;
1545     }
1546 
1547     *ppnested = classes;
1548     *pcount = ncount;
1549     return error;
1550 }
1551 
1552 void
1553 createLocalRefSpace(JNIEnv *env, jint capacity)
1554 {
1555     /*
1556      * Save current exception since it might get overwritten by
1557      * the calls below. Note we must depend on space in the existing
1558      * frame because asking for a new frame may generate an exception.
1559      */
1560     jobject throwable = JNI_FUNC_PTR(env,ExceptionOccurred)(env);
1561 
1562     /*
1563      * Use the current frame if necessary; otherwise create a new one
1564      */
1565     if (JNI_FUNC_PTR(env,PushLocalFrame)(env, capacity) &lt; 0) {
1566         EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;PushLocalFrame: Unable to push JNI frame&quot;);
1567     }
1568 
1569     /*
1570      * TO DO: This could be more efficient if it used EnsureLocalCapacity,
1571      * but that would not work if two functions on the call stack
1572      * use this function. We would need to either track reserved
1573      * references on a per-thread basis or come up with a convention
1574      * that would prevent two functions from depending on this function
1575      * at the same time.
1576      */
1577 
1578     /*
1579      * Restore exception state from before call
1580      */
1581     if (throwable != NULL) {
1582         JNI_FUNC_PTR(env,Throw)(env, throwable);
1583     } else {
1584         JNI_FUNC_PTR(env,ExceptionClear)(env);
1585     }
1586 }
1587 
1588 jboolean
1589 isClass(jobject object)
1590 {
1591     JNIEnv *env = getEnv();
1592     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classClass);
1593 }
1594 
1595 jboolean
1596 isThread(jobject object)
1597 {
1598     JNIEnv *env = getEnv();
1599     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadClass);
1600 }
1601 
1602 jboolean
1603 isThreadGroup(jobject object)
1604 {
1605     JNIEnv *env = getEnv();
1606     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadGroupClass);
1607 }
1608 
1609 jboolean
1610 isString(jobject object)
1611 {
1612     JNIEnv *env = getEnv();
1613     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;stringClass);
1614 }
1615 
1616 jboolean
1617 isClassLoader(jobject object)
1618 {
1619     JNIEnv *env = getEnv();
1620     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classLoaderClass);
1621 }
1622 
1623 jboolean
1624 isArray(jobject object)
1625 {
1626     JNIEnv *env = getEnv();
1627     jboolean is;
1628 
1629     WITH_LOCAL_REFS(env, 1) {
1630         jclass clazz;
1631         clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
1632         is = isArrayClass(clazz);
1633     } END_WITH_LOCAL_REFS(env);
1634 
1635     return is;
1636 }
1637 
1638 /**
1639  * Return property value as jstring
1640  */
1641 static jstring
1642 getPropertyValue(JNIEnv *env, char *propertyName)
1643 {
1644     jstring valueString;
1645     jstring nameString;
1646 
1647     valueString = NULL;
1648 
1649     /* Create new String object to hold the property name */
1650     nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, propertyName);
1651     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1652         JNI_FUNC_PTR(env,ExceptionClear)(env);
1653         /* NULL will be returned below */
1654     } else {
1655         /* Call valueString = System.getProperty(nameString) */
1656         valueString = JNI_FUNC_PTR(env,CallStaticObjectMethod)
1657             (env, gdata-&gt;systemClass, gdata-&gt;systemGetProperty, nameString);
1658         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1659             JNI_FUNC_PTR(env,ExceptionClear)(env);
1660             valueString = NULL;
1661         }
1662     }
1663     return valueString;
1664 }
1665 
1666 /**
1667  * Set an agent property
1668  */
1669 void
1670 setAgentPropertyValue(JNIEnv *env, char *propertyName, char* propertyValue)
1671 {
1672     jstring nameString;
1673     jstring valueString;
1674 
1675     if (gdata-&gt;agent_properties == NULL) {
1676         /* VMSupport doesn&#39;t exist; so ignore */
1677         return;
1678     }
1679 
1680     /* Create jstrings for property name and value */
1681     nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, propertyName);
1682     if (nameString != NULL) {
1683         valueString = JNU_NewStringPlatform(env, propertyValue);
1684         if (valueString != NULL) {
1685             /* invoke Properties.setProperty */
1686             JNI_FUNC_PTR(env,CallObjectMethod)
1687                 (env, gdata-&gt;agent_properties,
1688                  gdata-&gt;setProperty,
1689                  nameString, valueString);
1690         }
1691     }
1692     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1693         JNI_FUNC_PTR(env,ExceptionClear)(env);
1694     }
1695 }
1696 
1697 /**
1698  * Return property value as JDWP allocated string in UTF8 encoding
1699  */
1700 static char *
1701 getPropertyUTF8(JNIEnv *env, char *propertyName)
1702 {
1703     jvmtiError  error;
1704     char       *value;
1705 
1706     value = NULL;
1707     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSystemProperty)
1708                 (gdata-&gt;jvmti, (const char *)propertyName, &amp;value);
1709     if (error != JVMTI_ERROR_NONE) {
1710         jstring valueString;
1711 
1712         value = NULL;
1713         valueString = getPropertyValue(env, propertyName);
1714 
1715         if (valueString != NULL) {
1716             const char *utf;
1717 
1718             /* Get the UTF8 encoding for this property value string */
1719             utf = JNI_FUNC_PTR(env,GetStringUTFChars)(env, valueString, NULL);
1720             /* Make a copy for returning, release the JNI copy */
1721             value = jvmtiAllocate((int)strlen(utf) + 1);
1722             if (value != NULL) {
1723                 (void)strcpy(value, utf);
1724             }
1725             JNI_FUNC_PTR(env,ReleaseStringUTFChars)(env, valueString, utf);
1726         }
1727     }
1728     if ( value == NULL ) {
1729         ERROR_MESSAGE((&quot;JDWP Can&#39;t get property value for %s&quot;, propertyName));
1730         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
1731     }
1732     return value;
1733 }
1734 
1735 jboolean
1736 isMethodObsolete(jmethodID method)
1737 {
1738     jvmtiError error;
1739     jboolean obsolete = JNI_TRUE;
1740 
1741     if ( method != NULL ) {
1742         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodObsolete)
1743                     (gdata-&gt;jvmti, method, &amp;obsolete);
1744         if (error != JVMTI_ERROR_NONE) {
1745             obsolete = JNI_TRUE;
1746         }
1747     }
1748     return obsolete;
1749 }
1750 
1751 /* Get the jvmti environment to be used with tags */
1752 jvmtiEnv *
1753 getSpecialJvmti(void)
1754 {
1755     jvmtiEnv  *jvmti;
1756     jvmtiError error;
1757     int        rc;
1758 
1759     /* Get one time use JVMTI Env */
1760     jvmtiCapabilities caps;
1761 
1762     rc = JVM_FUNC_PTR(gdata-&gt;jvm,GetEnv)
1763                      (gdata-&gt;jvm, (void **)&amp;jvmti, JVMTI_VERSION_1);
1764     if (rc != JNI_OK) {
1765         return NULL;
1766     }
1767     (void)memset(&amp;caps, 0, (int)sizeof(caps));
1768     caps.can_tag_objects = 1;
1769     error = JVMTI_FUNC_PTR(jvmti,AddCapabilities)(jvmti, &amp;caps);
1770     if ( error != JVMTI_ERROR_NONE ) {
1771         return NULL;
1772     }
1773     return jvmti;
1774 }
1775 
1776 void
1777 writeCodeLocation(PacketOutputStream *out, jclass clazz,
1778                        jmethodID method, jlocation location)
1779 {
1780     jbyte tag;
1781 
1782     if (clazz != NULL) {
1783         tag = referenceTypeTag(clazz);
1784     } else {
1785         tag = JDWP_TYPE_TAG(CLASS);
1786     }
1787     (void)outStream_writeByte(out, tag);
1788     (void)outStream_writeObjectRef(getEnv(), out, clazz);
1789     (void)outStream_writeMethodID(out, isMethodObsolete(method)?NULL:method);
1790     (void)outStream_writeLocation(out, location);
1791 }
1792 
1793 void *
1794 jvmtiAllocate(jint numBytes)
1795 {
1796     void *ptr;
1797     jvmtiError error;
1798     if ( numBytes == 0 ) {
1799         return NULL;
1800     }
1801     error = FUNC_PTR(gdata-&gt;jvmti,Allocate)
1802                 (gdata-&gt;jvmti, numBytes, (unsigned char**)&amp;ptr);
1803     if (error != JVMTI_ERROR_NONE ) {
1804         EXIT_ERROR(error, &quot;Can&#39;t allocate jvmti memory&quot;);
1805     }
1806     return ptr;
1807 }
1808 
1809 void
1810 jvmtiDeallocate(void *ptr)
1811 {
1812     jvmtiError error;
1813     if ( ptr == NULL ) {
1814         return;
1815     }
1816     error = FUNC_PTR(gdata-&gt;jvmti,Deallocate)
1817                 (gdata-&gt;jvmti, ptr);
1818     if (error != JVMTI_ERROR_NONE ) {
1819         EXIT_ERROR(error, &quot;Can&#39;t deallocate jvmti memory&quot;);
1820     }
1821 }
1822 
1823 /* Rarely needed, transport library uses JDWP errors, only use? */
1824 jvmtiError
1825 map2jvmtiError(jdwpError error)
1826 {
1827     switch ( error ) {
1828         case JDWP_ERROR(NONE):
1829             return JVMTI_ERROR_NONE;
1830         case JDWP_ERROR(INVALID_THREAD):
1831             return JVMTI_ERROR_INVALID_THREAD;
1832         case JDWP_ERROR(INVALID_THREAD_GROUP):
1833             return JVMTI_ERROR_INVALID_THREAD_GROUP;
1834         case JDWP_ERROR(INVALID_PRIORITY):
1835             return JVMTI_ERROR_INVALID_PRIORITY;
1836         case JDWP_ERROR(THREAD_NOT_SUSPENDED):
1837             return JVMTI_ERROR_THREAD_NOT_SUSPENDED;
1838         case JDWP_ERROR(THREAD_SUSPENDED):
1839             return JVMTI_ERROR_THREAD_SUSPENDED;
1840         case JDWP_ERROR(INVALID_OBJECT):
1841             return JVMTI_ERROR_INVALID_OBJECT;
1842         case JDWP_ERROR(INVALID_CLASS):
1843             return JVMTI_ERROR_INVALID_CLASS;
1844         case JDWP_ERROR(CLASS_NOT_PREPARED):
1845             return JVMTI_ERROR_CLASS_NOT_PREPARED;
1846         case JDWP_ERROR(INVALID_METHODID):
1847             return JVMTI_ERROR_INVALID_METHODID;
1848         case JDWP_ERROR(INVALID_LOCATION):
1849             return JVMTI_ERROR_INVALID_LOCATION;
1850         case JDWP_ERROR(INVALID_FIELDID):
1851             return JVMTI_ERROR_INVALID_FIELDID;
1852         case JDWP_ERROR(INVALID_FRAMEID):
1853             return AGENT_ERROR_INVALID_FRAMEID;
1854         case JDWP_ERROR(NO_MORE_FRAMES):
1855             return JVMTI_ERROR_NO_MORE_FRAMES;
1856         case JDWP_ERROR(OPAQUE_FRAME):
1857             return JVMTI_ERROR_OPAQUE_FRAME;
1858         case JDWP_ERROR(NOT_CURRENT_FRAME):
1859             return AGENT_ERROR_NOT_CURRENT_FRAME;
1860         case JDWP_ERROR(TYPE_MISMATCH):
1861             return JVMTI_ERROR_TYPE_MISMATCH;
1862         case JDWP_ERROR(INVALID_SLOT):
1863             return JVMTI_ERROR_INVALID_SLOT;
1864         case JDWP_ERROR(DUPLICATE):
1865             return JVMTI_ERROR_DUPLICATE;
1866         case JDWP_ERROR(NOT_FOUND):
1867             return JVMTI_ERROR_NOT_FOUND;
1868         case JDWP_ERROR(INVALID_MONITOR):
1869             return JVMTI_ERROR_INVALID_MONITOR;
1870         case JDWP_ERROR(NOT_MONITOR_OWNER):
1871             return JVMTI_ERROR_NOT_MONITOR_OWNER;
1872         case JDWP_ERROR(INTERRUPT):
1873             return JVMTI_ERROR_INTERRUPT;
1874         case JDWP_ERROR(INVALID_CLASS_FORMAT):
1875             return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1876         case JDWP_ERROR(CIRCULAR_CLASS_DEFINITION):
1877             return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1878         case JDWP_ERROR(FAILS_VERIFICATION):
1879             return JVMTI_ERROR_FAILS_VERIFICATION;
1880         case JDWP_ERROR(ADD_METHOD_NOT_IMPLEMENTED):
1881             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1882         case JDWP_ERROR(SCHEMA_CHANGE_NOT_IMPLEMENTED):
1883             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
1884         case JDWP_ERROR(INVALID_TYPESTATE):
1885             return JVMTI_ERROR_INVALID_TYPESTATE;
1886         case JDWP_ERROR(HIERARCHY_CHANGE_NOT_IMPLEMENTED):
1887             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
1888         case JDWP_ERROR(DELETE_METHOD_NOT_IMPLEMENTED):
1889             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1890         case JDWP_ERROR(UNSUPPORTED_VERSION):
1891             return JVMTI_ERROR_UNSUPPORTED_VERSION;
1892         case JDWP_ERROR(NAMES_DONT_MATCH):
1893             return JVMTI_ERROR_NAMES_DONT_MATCH;
1894         case JDWP_ERROR(CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED):
1895             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
1896         case JDWP_ERROR(METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED):
1897             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1898         case JDWP_ERROR(CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED):
1899             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
1900         case JDWP_ERROR(NOT_IMPLEMENTED):
1901             return JVMTI_ERROR_NOT_AVAILABLE;
1902         case JDWP_ERROR(NULL_POINTER):
1903             return JVMTI_ERROR_NULL_POINTER;
1904         case JDWP_ERROR(ABSENT_INFORMATION):
1905             return JVMTI_ERROR_ABSENT_INFORMATION;
1906         case JDWP_ERROR(INVALID_EVENT_TYPE):
1907             return JVMTI_ERROR_INVALID_EVENT_TYPE;
1908         case JDWP_ERROR(ILLEGAL_ARGUMENT):
1909             return JVMTI_ERROR_ILLEGAL_ARGUMENT;
1910         case JDWP_ERROR(OUT_OF_MEMORY):
1911             return JVMTI_ERROR_OUT_OF_MEMORY;
1912         case JDWP_ERROR(ACCESS_DENIED):
1913             return JVMTI_ERROR_ACCESS_DENIED;
1914         case JDWP_ERROR(VM_DEAD):
1915             return JVMTI_ERROR_WRONG_PHASE;
1916         case JDWP_ERROR(UNATTACHED_THREAD):
1917             return JVMTI_ERROR_UNATTACHED_THREAD;
1918         case JDWP_ERROR(INVALID_TAG):
1919             return AGENT_ERROR_INVALID_TAG;
1920         case JDWP_ERROR(ALREADY_INVOKING):
1921             return AGENT_ERROR_ALREADY_INVOKING;
1922         case JDWP_ERROR(INVALID_INDEX):
1923             return AGENT_ERROR_INVALID_INDEX;
1924         case JDWP_ERROR(INVALID_LENGTH):
1925             return AGENT_ERROR_INVALID_LENGTH;
1926         case JDWP_ERROR(INVALID_STRING):
1927             return AGENT_ERROR_INVALID_STRING;
1928         case JDWP_ERROR(INVALID_CLASS_LOADER):
1929             return AGENT_ERROR_INVALID_CLASS_LOADER;
1930         case JDWP_ERROR(INVALID_ARRAY):
1931             return AGENT_ERROR_INVALID_ARRAY;
1932         case JDWP_ERROR(TRANSPORT_LOAD):
1933             return AGENT_ERROR_TRANSPORT_LOAD;
1934         case JDWP_ERROR(TRANSPORT_INIT):
1935             return AGENT_ERROR_TRANSPORT_INIT;
1936         case JDWP_ERROR(NATIVE_METHOD):
1937             return AGENT_ERROR_NATIVE_METHOD;
1938         case JDWP_ERROR(INVALID_COUNT):
1939             return AGENT_ERROR_INVALID_COUNT;
1940         case JDWP_ERROR(INTERNAL):
1941             return AGENT_ERROR_JDWP_INTERNAL;
1942     }
1943     return AGENT_ERROR_INTERNAL;
1944 }
1945 
1946 static jvmtiEvent index2jvmti[EI_max-EI_min+1];
1947 static jdwpEvent  index2jdwp [EI_max-EI_min+1];
1948 
1949 void
1950 eventIndexInit(void)
1951 {
1952     (void)memset(index2jvmti, 0, (int)sizeof(index2jvmti));
1953     (void)memset(index2jdwp,  0, (int)sizeof(index2jdwp));
1954 
1955     index2jvmti[EI_SINGLE_STEP        -EI_min] = JVMTI_EVENT_SINGLE_STEP;
1956     index2jvmti[EI_BREAKPOINT         -EI_min] = JVMTI_EVENT_BREAKPOINT;
1957     index2jvmti[EI_FRAME_POP          -EI_min] = JVMTI_EVENT_FRAME_POP;
1958     index2jvmti[EI_EXCEPTION          -EI_min] = JVMTI_EVENT_EXCEPTION;
1959     index2jvmti[EI_THREAD_START       -EI_min] = JVMTI_EVENT_THREAD_START;
1960     index2jvmti[EI_THREAD_END         -EI_min] = JVMTI_EVENT_THREAD_END;
1961     index2jvmti[EI_CLASS_PREPARE      -EI_min] = JVMTI_EVENT_CLASS_PREPARE;
1962     index2jvmti[EI_GC_FINISH          -EI_min] = JVMTI_EVENT_GARBAGE_COLLECTION_FINISH;
1963     index2jvmti[EI_CLASS_LOAD         -EI_min] = JVMTI_EVENT_CLASS_LOAD;
1964     index2jvmti[EI_FIELD_ACCESS       -EI_min] = JVMTI_EVENT_FIELD_ACCESS;
1965     index2jvmti[EI_FIELD_MODIFICATION -EI_min] = JVMTI_EVENT_FIELD_MODIFICATION;
1966     index2jvmti[EI_EXCEPTION_CATCH    -EI_min] = JVMTI_EVENT_EXCEPTION_CATCH;
1967     index2jvmti[EI_METHOD_ENTRY       -EI_min] = JVMTI_EVENT_METHOD_ENTRY;
1968     index2jvmti[EI_METHOD_EXIT        -EI_min] = JVMTI_EVENT_METHOD_EXIT;
1969     index2jvmti[EI_MONITOR_CONTENDED_ENTER      -EI_min] = JVMTI_EVENT_MONITOR_CONTENDED_ENTER;
1970     index2jvmti[EI_MONITOR_CONTENDED_ENTERED    -EI_min] = JVMTI_EVENT_MONITOR_CONTENDED_ENTERED;
1971     index2jvmti[EI_MONITOR_WAIT       -EI_min] = JVMTI_EVENT_MONITOR_WAIT;
1972     index2jvmti[EI_MONITOR_WAITED     -EI_min] = JVMTI_EVENT_MONITOR_WAITED;
1973     index2jvmti[EI_VM_INIT            -EI_min] = JVMTI_EVENT_VM_INIT;
1974     index2jvmti[EI_VM_DEATH           -EI_min] = JVMTI_EVENT_VM_DEATH;
1975 
1976     index2jdwp[EI_SINGLE_STEP         -EI_min] = JDWP_EVENT(SINGLE_STEP);
1977     index2jdwp[EI_BREAKPOINT          -EI_min] = JDWP_EVENT(BREAKPOINT);
1978     index2jdwp[EI_FRAME_POP           -EI_min] = JDWP_EVENT(FRAME_POP);
1979     index2jdwp[EI_EXCEPTION           -EI_min] = JDWP_EVENT(EXCEPTION);
1980     index2jdwp[EI_THREAD_START        -EI_min] = JDWP_EVENT(THREAD_START);
1981     index2jdwp[EI_THREAD_END          -EI_min] = JDWP_EVENT(THREAD_END);
1982     index2jdwp[EI_CLASS_PREPARE       -EI_min] = JDWP_EVENT(CLASS_PREPARE);
1983     index2jdwp[EI_GC_FINISH           -EI_min] = JDWP_EVENT(CLASS_UNLOAD);
1984     index2jdwp[EI_CLASS_LOAD          -EI_min] = JDWP_EVENT(CLASS_LOAD);
1985     index2jdwp[EI_FIELD_ACCESS        -EI_min] = JDWP_EVENT(FIELD_ACCESS);
1986     index2jdwp[EI_FIELD_MODIFICATION  -EI_min] = JDWP_EVENT(FIELD_MODIFICATION);
1987     index2jdwp[EI_EXCEPTION_CATCH     -EI_min] = JDWP_EVENT(EXCEPTION_CATCH);
1988     index2jdwp[EI_METHOD_ENTRY        -EI_min] = JDWP_EVENT(METHOD_ENTRY);
1989     index2jdwp[EI_METHOD_EXIT         -EI_min] = JDWP_EVENT(METHOD_EXIT);
1990     index2jdwp[EI_MONITOR_CONTENDED_ENTER             -EI_min] = JDWP_EVENT(MONITOR_CONTENDED_ENTER);
1991     index2jdwp[EI_MONITOR_CONTENDED_ENTERED           -EI_min] = JDWP_EVENT(MONITOR_CONTENDED_ENTERED);
1992     index2jdwp[EI_MONITOR_WAIT        -EI_min] = JDWP_EVENT(MONITOR_WAIT);
1993     index2jdwp[EI_MONITOR_WAITED      -EI_min] = JDWP_EVENT(MONITOR_WAITED);
1994     index2jdwp[EI_VM_INIT             -EI_min] = JDWP_EVENT(VM_INIT);
1995     index2jdwp[EI_VM_DEATH            -EI_min] = JDWP_EVENT(VM_DEATH);
1996 }
1997 
1998 jdwpEvent
1999 eventIndex2jdwp(EventIndex i)
2000 {
2001     if ( i &lt; EI_min || i &gt; EI_max ) {
2002         EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;bad EventIndex&quot;);
2003     }
2004     return index2jdwp[i-EI_min];
2005 }
2006 
2007 jvmtiEvent
2008 eventIndex2jvmti(EventIndex i)
2009 {
2010     if ( i &lt; EI_min || i &gt; EI_max ) {
2011         EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;bad EventIndex&quot;);
2012     }
2013     return index2jvmti[i-EI_min];
2014 }
2015 
2016 EventIndex
2017 jdwp2EventIndex(jdwpEvent eventType)
2018 {
2019     switch ( eventType ) {
2020         case JDWP_EVENT(SINGLE_STEP):
2021             return EI_SINGLE_STEP;
2022         case JDWP_EVENT(BREAKPOINT):
2023             return EI_BREAKPOINT;
2024         case JDWP_EVENT(FRAME_POP):
2025             return EI_FRAME_POP;
2026         case JDWP_EVENT(EXCEPTION):
2027             return EI_EXCEPTION;
2028         case JDWP_EVENT(THREAD_START):
2029             return EI_THREAD_START;
2030         case JDWP_EVENT(THREAD_END):
2031             return EI_THREAD_END;
2032         case JDWP_EVENT(CLASS_PREPARE):
2033             return EI_CLASS_PREPARE;
2034         case JDWP_EVENT(CLASS_UNLOAD):
2035             return EI_GC_FINISH;
2036         case JDWP_EVENT(CLASS_LOAD):
2037             return EI_CLASS_LOAD;
2038         case JDWP_EVENT(FIELD_ACCESS):
2039             return EI_FIELD_ACCESS;
2040         case JDWP_EVENT(FIELD_MODIFICATION):
2041             return EI_FIELD_MODIFICATION;
2042         case JDWP_EVENT(EXCEPTION_CATCH):
2043             return EI_EXCEPTION_CATCH;
2044         case JDWP_EVENT(METHOD_ENTRY):
2045             return EI_METHOD_ENTRY;
2046         case JDWP_EVENT(METHOD_EXIT):
2047             return EI_METHOD_EXIT;
2048         case JDWP_EVENT(METHOD_EXIT_WITH_RETURN_VALUE):
2049             return EI_METHOD_EXIT;
2050         case JDWP_EVENT(MONITOR_CONTENDED_ENTER):
2051             return EI_MONITOR_CONTENDED_ENTER;
2052         case JDWP_EVENT(MONITOR_CONTENDED_ENTERED):
2053             return EI_MONITOR_CONTENDED_ENTERED;
2054         case JDWP_EVENT(MONITOR_WAIT):
2055             return EI_MONITOR_WAIT;
2056         case JDWP_EVENT(MONITOR_WAITED):
2057             return EI_MONITOR_WAITED;
2058         case JDWP_EVENT(VM_INIT):
2059             return EI_VM_INIT;
2060         case JDWP_EVENT(VM_DEATH):
2061             return EI_VM_DEATH;
2062         default:
2063             break;
2064     }
2065 
2066     /*
2067      * Event type not recognized - don&#39;t exit with error as caller
2068      * may wish to return error to debugger.
2069      */
2070     return (EventIndex)0;
2071 }
2072 
2073 EventIndex
2074 jvmti2EventIndex(jvmtiEvent kind)
2075 {
2076     switch ( kind ) {
2077         case JVMTI_EVENT_SINGLE_STEP:
2078             return EI_SINGLE_STEP;
2079         case JVMTI_EVENT_BREAKPOINT:
2080             return EI_BREAKPOINT;
2081         case JVMTI_EVENT_FRAME_POP:
2082             return EI_FRAME_POP;
2083         case JVMTI_EVENT_EXCEPTION:
2084             return EI_EXCEPTION;
2085         case JVMTI_EVENT_THREAD_START:
2086             return EI_THREAD_START;
2087         case JVMTI_EVENT_THREAD_END:
2088             return EI_THREAD_END;
2089         case JVMTI_EVENT_CLASS_PREPARE:
2090             return EI_CLASS_PREPARE;
2091         case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:
2092             return EI_GC_FINISH;
2093         case JVMTI_EVENT_CLASS_LOAD:
2094             return EI_CLASS_LOAD;
2095         case JVMTI_EVENT_FIELD_ACCESS:
2096             return EI_FIELD_ACCESS;
2097         case JVMTI_EVENT_FIELD_MODIFICATION:
2098             return EI_FIELD_MODIFICATION;
2099         case JVMTI_EVENT_EXCEPTION_CATCH:
2100             return EI_EXCEPTION_CATCH;
2101         case JVMTI_EVENT_METHOD_ENTRY:
2102             return EI_METHOD_ENTRY;
2103         case JVMTI_EVENT_METHOD_EXIT:
2104             return EI_METHOD_EXIT;
2105         /*
2106          * There is no JVMTI_EVENT_METHOD_EXIT_WITH_RETURN_VALUE.
2107          * The normal JVMTI_EVENT_METHOD_EXIT always contains the return value.
2108          */
2109         case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:
2110             return EI_MONITOR_CONTENDED_ENTER;
2111         case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:
2112             return EI_MONITOR_CONTENDED_ENTERED;
2113         case JVMTI_EVENT_MONITOR_WAIT:
2114             return EI_MONITOR_WAIT;
2115         case JVMTI_EVENT_MONITOR_WAITED:
2116             return EI_MONITOR_WAITED;
2117         case JVMTI_EVENT_VM_INIT:
2118             return EI_VM_INIT;
2119         case JVMTI_EVENT_VM_DEATH:
2120             return EI_VM_DEATH;
2121         default:
2122             EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;JVMTI to EventIndex mapping&quot;);
2123             break;
2124     }
2125     return (EventIndex)0;
2126 }
2127 
2128 /* This routine is commonly used, maps jvmti and agent errors to the best
2129  *    jdwp error code we can map to.
2130  */
2131 jdwpError
2132 map2jdwpError(jvmtiError error)
2133 {
2134     switch ( (int)error ) {
2135         case JVMTI_ERROR_NONE:
2136             return JDWP_ERROR(NONE);
2137         case AGENT_ERROR_INVALID_THREAD:
2138         case JVMTI_ERROR_INVALID_THREAD:
2139             return JDWP_ERROR(INVALID_THREAD);
2140         case JVMTI_ERROR_INVALID_THREAD_GROUP:
2141             return JDWP_ERROR(INVALID_THREAD_GROUP);
2142         case JVMTI_ERROR_INVALID_PRIORITY:
2143             return JDWP_ERROR(INVALID_PRIORITY);
2144         case JVMTI_ERROR_THREAD_NOT_SUSPENDED:
2145             return JDWP_ERROR(THREAD_NOT_SUSPENDED);
2146         case JVMTI_ERROR_THREAD_SUSPENDED:
2147             return JDWP_ERROR(THREAD_SUSPENDED);
2148         case JVMTI_ERROR_THREAD_NOT_ALIVE:
2149             return JDWP_ERROR(INVALID_THREAD);
2150         case AGENT_ERROR_INVALID_OBJECT:
2151         case JVMTI_ERROR_INVALID_OBJECT:
2152             return JDWP_ERROR(INVALID_OBJECT);
2153         case JVMTI_ERROR_INVALID_CLASS:
2154             return JDWP_ERROR(INVALID_CLASS);
2155         case JVMTI_ERROR_CLASS_NOT_PREPARED:
2156             return JDWP_ERROR(CLASS_NOT_PREPARED);
2157         case JVMTI_ERROR_INVALID_METHODID:
2158             return JDWP_ERROR(INVALID_METHODID);
2159         case JVMTI_ERROR_INVALID_LOCATION:
2160             return JDWP_ERROR(INVALID_LOCATION);
2161         case JVMTI_ERROR_INVALID_FIELDID:
2162             return JDWP_ERROR(INVALID_FIELDID);
2163         case AGENT_ERROR_NO_MORE_FRAMES:
2164         case JVMTI_ERROR_NO_MORE_FRAMES:
2165             return JDWP_ERROR(NO_MORE_FRAMES);
2166         case JVMTI_ERROR_OPAQUE_FRAME:
2167             return JDWP_ERROR(OPAQUE_FRAME);
2168         case JVMTI_ERROR_TYPE_MISMATCH:
2169             return JDWP_ERROR(TYPE_MISMATCH);
2170         case JVMTI_ERROR_INVALID_SLOT:
2171             return JDWP_ERROR(INVALID_SLOT);
2172         case JVMTI_ERROR_DUPLICATE:
2173             return JDWP_ERROR(DUPLICATE);
2174         case JVMTI_ERROR_NOT_FOUND:
2175             return JDWP_ERROR(NOT_FOUND);
2176         case JVMTI_ERROR_INVALID_MONITOR:
2177             return JDWP_ERROR(INVALID_MONITOR);
2178         case JVMTI_ERROR_NOT_MONITOR_OWNER:
2179             return JDWP_ERROR(NOT_MONITOR_OWNER);
2180         case JVMTI_ERROR_INTERRUPT:
2181             return JDWP_ERROR(INTERRUPT);
2182         case JVMTI_ERROR_INVALID_CLASS_FORMAT:
2183             return JDWP_ERROR(INVALID_CLASS_FORMAT);
2184         case JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION:
2185             return JDWP_ERROR(CIRCULAR_CLASS_DEFINITION);
2186         case JVMTI_ERROR_FAILS_VERIFICATION:
2187             return JDWP_ERROR(FAILS_VERIFICATION);
2188         case JVMTI_ERROR_INVALID_TYPESTATE:
2189             return JDWP_ERROR(INVALID_TYPESTATE);
2190         case JVMTI_ERROR_UNSUPPORTED_VERSION:
2191             return JDWP_ERROR(UNSUPPORTED_VERSION);
2192         case JVMTI_ERROR_NAMES_DONT_MATCH:
2193             return JDWP_ERROR(NAMES_DONT_MATCH);
2194         case AGENT_ERROR_NULL_POINTER:
2195         case JVMTI_ERROR_NULL_POINTER:
2196             return JDWP_ERROR(NULL_POINTER);
2197         case JVMTI_ERROR_ABSENT_INFORMATION:
2198             return JDWP_ERROR(ABSENT_INFORMATION);
2199         case AGENT_ERROR_INVALID_EVENT_TYPE:
2200         case JVMTI_ERROR_INVALID_EVENT_TYPE:
2201             return JDWP_ERROR(INVALID_EVENT_TYPE);
2202         case AGENT_ERROR_ILLEGAL_ARGUMENT:
2203         case JVMTI_ERROR_ILLEGAL_ARGUMENT:
2204             return JDWP_ERROR(ILLEGAL_ARGUMENT);
2205         case JVMTI_ERROR_OUT_OF_MEMORY:
2206         case AGENT_ERROR_OUT_OF_MEMORY:
2207             return JDWP_ERROR(OUT_OF_MEMORY);
2208         case JVMTI_ERROR_ACCESS_DENIED:
2209             return JDWP_ERROR(ACCESS_DENIED);
2210         case JVMTI_ERROR_WRONG_PHASE:
2211         case AGENT_ERROR_VM_DEAD:
2212         case AGENT_ERROR_NO_JNI_ENV:
2213             return JDWP_ERROR(VM_DEAD);
2214         case AGENT_ERROR_JNI_EXCEPTION:
2215         case JVMTI_ERROR_UNATTACHED_THREAD:
2216             return JDWP_ERROR(UNATTACHED_THREAD);
2217         case JVMTI_ERROR_NOT_AVAILABLE:
2218         case JVMTI_ERROR_MUST_POSSESS_CAPABILITY:
2219             return JDWP_ERROR(NOT_IMPLEMENTED);
2220         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED:
2221             return JDWP_ERROR(HIERARCHY_CHANGE_NOT_IMPLEMENTED);
2222         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED:
2223             return JDWP_ERROR(DELETE_METHOD_NOT_IMPLEMENTED);
2224         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED:
2225             return JDWP_ERROR(ADD_METHOD_NOT_IMPLEMENTED);
2226         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED:
2227             return JDWP_ERROR(SCHEMA_CHANGE_NOT_IMPLEMENTED);
2228         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED:
2229             return JDWP_ERROR(CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED);
2230         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED:
2231             return JDWP_ERROR(METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED);
2232         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED:
2233             return JDWP_ERROR(CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED);
2234         case AGENT_ERROR_NOT_CURRENT_FRAME:
2235             return JDWP_ERROR(NOT_CURRENT_FRAME);
2236         case AGENT_ERROR_INVALID_TAG:
2237             return JDWP_ERROR(INVALID_TAG);
2238         case AGENT_ERROR_ALREADY_INVOKING:
2239             return JDWP_ERROR(ALREADY_INVOKING);
2240         case AGENT_ERROR_INVALID_INDEX:
2241             return JDWP_ERROR(INVALID_INDEX);
2242         case AGENT_ERROR_INVALID_LENGTH:
2243             return JDWP_ERROR(INVALID_LENGTH);
2244         case AGENT_ERROR_INVALID_STRING:
2245             return JDWP_ERROR(INVALID_STRING);
2246         case AGENT_ERROR_INVALID_CLASS_LOADER:
2247             return JDWP_ERROR(INVALID_CLASS_LOADER);
2248         case AGENT_ERROR_INVALID_ARRAY:
2249             return JDWP_ERROR(INVALID_ARRAY);
2250         case AGENT_ERROR_TRANSPORT_LOAD:
2251             return JDWP_ERROR(TRANSPORT_LOAD);
2252         case AGENT_ERROR_TRANSPORT_INIT:
2253             return JDWP_ERROR(TRANSPORT_INIT);
2254         case AGENT_ERROR_NATIVE_METHOD:
2255             return JDWP_ERROR(NATIVE_METHOD);
2256         case AGENT_ERROR_INVALID_COUNT:
2257             return JDWP_ERROR(INVALID_COUNT);
2258         case AGENT_ERROR_INVALID_FRAMEID:
2259             return JDWP_ERROR(INVALID_FRAMEID);
2260         case JVMTI_ERROR_INTERNAL:
2261         case JVMTI_ERROR_INVALID_ENVIRONMENT:
2262         case AGENT_ERROR_INTERNAL:
2263         case AGENT_ERROR_JVMTI_INTERNAL:
2264         case AGENT_ERROR_JDWP_INTERNAL:
2265             return JDWP_ERROR(INTERNAL);
2266         default:
2267             break;
2268     }
2269     return JDWP_ERROR(INTERNAL);
2270 }
2271 
2272 jint
2273 map2jdwpSuspendStatus(jint state)
2274 {
2275     jint status = 0;
2276     if ( ( state &amp; JVMTI_THREAD_STATE_SUSPENDED ) != 0 )  {
2277         status = JDWP_SUSPEND_STATUS(SUSPENDED);
2278     }
2279     return status;
2280 }
2281 
2282 jdwpThreadStatus
2283 map2jdwpThreadStatus(jint state)
2284 {
2285     jdwpThreadStatus status;
2286 
2287     status = (jdwpThreadStatus)(-1);
2288 
2289     if ( ! ( state &amp; JVMTI_THREAD_STATE_ALIVE ) ) {
2290         if ( state &amp; JVMTI_THREAD_STATE_TERMINATED ) {
2291             status = JDWP_THREAD_STATUS(ZOMBIE);
2292         } else {
2293             /* FIXUP? New JDWP #define for not started? */
2294             status = (jdwpThreadStatus)(-1);
2295         }
2296     } else {
2297         if ( state &amp; JVMTI_THREAD_STATE_SLEEPING ) {
2298             status = JDWP_THREAD_STATUS(SLEEPING);
2299         } else if ( state &amp; JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER ) {
2300             status = JDWP_THREAD_STATUS(MONITOR);
2301         } else if ( state &amp; JVMTI_THREAD_STATE_WAITING ) {
2302             status = JDWP_THREAD_STATUS(WAIT);
2303         } else if ( state &amp; JVMTI_THREAD_STATE_RUNNABLE ) {
2304             status = JDWP_THREAD_STATUS(RUNNING);
2305         }
2306     }
2307     return status;
2308 }
2309 
2310 jint
2311 map2jdwpClassStatus(jint classStatus)
2312 {
2313     jint status = 0;
2314     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_VERIFIED ) != 0 ) {
2315         status |= JDWP_CLASS_STATUS(VERIFIED);
2316     }
2317     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_PREPARED ) != 0 ) {
2318         status |= JDWP_CLASS_STATUS(PREPARED);
2319     }
2320     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_INITIALIZED ) != 0 ) {
2321         status |= JDWP_CLASS_STATUS(INITIALIZED);
2322     }
2323     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_ERROR ) != 0 ) {
2324         status |= JDWP_CLASS_STATUS(ERROR);
2325     }
2326     return status;
2327 }
2328 
2329 void
2330 log_debugee_location(const char *func,
2331         jthread thread, jmethodID method, jlocation location)
2332 {
2333     int logging_locations = LOG_TEST(JDWP_LOG_LOC);
2334 
2335     if ( logging_locations ) {
2336         char *method_name;
2337         char *class_sig;
2338         jvmtiError error;
2339         jvmtiThreadInfo info;
2340         jint state;
2341 
2342         /* Get thread information */
2343         info.name = NULL;
2344         error = FUNC_PTR(gdata-&gt;jvmti,GetThreadInfo)
2345                                 (gdata-&gt;jvmti, thread, &amp;info);
2346         if ( error != JVMTI_ERROR_NONE) {
2347             info.name = NULL;
2348         }
2349         error = FUNC_PTR(gdata-&gt;jvmti,GetThreadState)
2350                                 (gdata-&gt;jvmti, thread, &amp;state);
2351         if ( error != JVMTI_ERROR_NONE) {
2352             state = 0;
2353         }
2354 
2355         /* Get method if necessary */
2356         if ( method==NULL ) {
2357             error = FUNC_PTR(gdata-&gt;jvmti,GetFrameLocation)
2358                         (gdata-&gt;jvmti, thread, 0, &amp;method, &amp;location);
2359             if ( error != JVMTI_ERROR_NONE ) {
2360                 method = NULL;
2361                 location = 0;
2362             }
2363         }
2364 
2365         /* Get method name */
2366         method_name = NULL;
2367         if ( method != NULL ) {
2368             error = methodSignature(method, &amp;method_name, NULL, NULL);
2369             if ( error != JVMTI_ERROR_NONE ) {
2370                 method_name = NULL;
2371             }
2372         }
2373 
2374         /* Get class signature */
2375         class_sig = NULL;
2376         if ( method != NULL ) {
2377             jclass clazz;
2378 
2379             error = methodClass(method, &amp;clazz);
2380             if ( error == JVMTI_ERROR_NONE ) {
2381                 error = classSignature(clazz, &amp;class_sig, NULL);
2382                 if ( error != JVMTI_ERROR_NONE ) {
2383                     class_sig = NULL;
2384                 }
2385             }
2386         }
2387 
2388         /* Issue log message */
2389         LOG_LOC((&quot;%s: debugee: thread=%p(%s:0x%x),method=%p(%s@%d;%s)&quot;,
2390                 func,
2391                 thread, info.name==NULL ? &quot;?&quot; : info.name, state,
2392                 method, method_name==NULL ? &quot;?&quot; : method_name,
2393                 (int)location, class_sig==NULL ? &quot;?&quot; : class_sig));
2394 
2395         /* Free memory */
2396         if ( class_sig != NULL ) {
2397             jvmtiDeallocate(class_sig);
2398         }
2399         if ( method_name != NULL ) {
2400             jvmtiDeallocate(method_name);
2401         }
2402         if ( info.name != NULL ) {
2403             jvmtiDeallocate(info.name);
2404         }
2405     }
2406 }
2407 
2408 /* ********************************************************************* */
2409 /* JDK 6.0: Use of new Heap Iteration functions */
2410 /* ********************************************************************* */
2411 
2412 /* ********************************************************************* */
2413 /* Instances */
2414 
2415 /* Structure to hold class instances heap iteration data (arg user_data) */
2416 typedef struct ClassInstancesData {
2417     jint         instCount;
2418     jint         maxInstances;
2419     jlong        objTag;
2420     jvmtiError   error;
2421 } ClassInstancesData;
2422 
2423 /* Callback for instance object tagging (heap_reference_callback). */
2424 static jint JNICALL
2425 cbObjectTagInstance(jvmtiHeapReferenceKind reference_kind,
2426      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2427      jlong referrer_class_tag, jlong size,
2428      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2429 {
2430     ClassInstancesData  *data;
2431 
2432     /* Check data structure */
2433     data = (ClassInstancesData*)user_data;
2434     if (data == NULL) {
2435         return JVMTI_VISIT_ABORT;
2436     }
2437 
2438     /* If we have tagged enough objects, just abort */
2439     if ( data-&gt;maxInstances != 0 &amp;&amp; data-&gt;instCount &gt;= data-&gt;maxInstances ) {
2440         return JVMTI_VISIT_ABORT;
2441     }
2442 
2443     /* If tagged already, just continue */
2444     if ( (*tag_ptr) != (jlong)0 ) {
2445         return JVMTI_VISIT_OBJECTS;
2446     }
2447 
2448     /* Tag the object so we don&#39;t count it again, and so we can retrieve it */
2449     (*tag_ptr) = data-&gt;objTag;
2450     data-&gt;instCount++;
2451     return JVMTI_VISIT_OBJECTS;
2452 }
2453 
2454 /* Get instances for one class */
2455 jvmtiError
2456 classInstances(jclass klass, ObjectBatch *instances, int maxInstances)
2457 {
2458     ClassInstancesData data;
2459     jvmtiHeapCallbacks heap_callbacks;
2460     jvmtiError         error;
2461     jvmtiEnv          *jvmti;
2462 
2463     /* Check interface assumptions */
2464 
2465     if (klass == NULL) {
2466         return AGENT_ERROR_INVALID_OBJECT;
2467     }
2468 
2469     if ( maxInstances &lt; 0 || instances == NULL) {
2470         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2471     }
2472 
2473     /* Initialize return information */
2474     instances-&gt;count   = 0;
2475     instances-&gt;objects = NULL;
2476 
2477     /* Get jvmti environment to use */
2478     jvmti = getSpecialJvmti();
2479     if ( jvmti == NULL ) {
2480         return AGENT_ERROR_INTERNAL;
2481     }
2482 
2483     /* Setup data to passed around the callbacks */
2484     data.instCount    = 0;
2485     data.maxInstances = maxInstances;
2486     data.objTag       = (jlong)1;
2487     data.error        = JVMTI_ERROR_NONE;
2488 
2489     /* Clear out callbacks structure */
2490     (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2491 
2492     /* Set the callbacks we want */
2493     heap_callbacks.heap_reference_callback = &amp;cbObjectTagInstance;
2494 
2495     /* Follow references, no initiating object, just this class, all objects */
2496     error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2497                  (jvmti, 0, klass, NULL, &amp;heap_callbacks, &amp;data);
2498     if ( error == JVMTI_ERROR_NONE ) {
2499         error = data.error;
2500     }
2501 
2502     /* Get all the instances now that they are tagged */
2503     if ( error == JVMTI_ERROR_NONE ) {
2504         error = JVMTI_FUNC_PTR(jvmti,GetObjectsWithTags)
2505                       (jvmti, 1, &amp;(data.objTag), &amp;(instances-&gt;count),
2506                        &amp;(instances-&gt;objects), NULL);
2507         /* Verify we got the count we expected */
2508         if ( data.instCount != instances-&gt;count ) {
2509             error = AGENT_ERROR_INTERNAL;
2510         }
2511     }
2512 
2513     /* Dispose of any special jvmti environment */
2514     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2515     return error;
2516 }
2517 
2518 /* ********************************************************************* */
2519 /* Instance counts. */
2520 
2521 /* Macros to convert a class or instance tag to an index and back again */
2522 #define INDEX2CLASSTAG(i)      ((jlong)((i)+1))
2523 #define CLASSTAG2INDEX(t)      (((int)(t))-1)
2524 #define JLONG_ABS(x)           (((x)&lt;(jlong)0)?-(x):(x))
2525 
2526 /* Structure to hold class count heap traversal data (arg user_data) */
2527 typedef struct ClassCountData {
2528     int          classCount;
2529     jlong       *counts;
2530     jlong        negObjTag;
2531     jvmtiError   error;
2532 } ClassCountData;
2533 
2534 /* Two different cbObjectCounter&#39;s, one for FollowReferences, one for
2535  *    IterateThroughHeap. Pick a card, any card.
2536  */
2537 
2538 /* Callback for object count heap traversal (heap_reference_callback) */
2539 static jint JNICALL
2540 cbObjectCounterFromRef(jvmtiHeapReferenceKind reference_kind,
2541      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2542      jlong referrer_class_tag, jlong size,
2543      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2544 {
2545     ClassCountData  *data;
2546     int              index;
2547     jlong            jindex;
2548     jlong            tag;
2549 
2550     /* Check data structure */
2551     data = (ClassCountData*)user_data;
2552     if (data == NULL) {
2553         return JVMTI_VISIT_ABORT;
2554     }
2555 
2556     /* Classes with no class_tag should have been filtered out. */
2557     if ( class_tag == (jlong)0 ) {
2558         data-&gt;error = AGENT_ERROR_INTERNAL;
2559         return JVMTI_VISIT_ABORT;
2560     }
2561 
2562     /* Class tag not one we really want (jclass not in supplied list) */
2563     if ( class_tag == data-&gt;negObjTag ) {
2564         return JVMTI_VISIT_OBJECTS;
2565     }
2566 
2567     /* If object tag is negative, just continue, we counted it */
2568     tag = (*tag_ptr);
2569     if ( tag &lt; (jlong)0 ) {
2570         return JVMTI_VISIT_OBJECTS;
2571     }
2572 
2573     /* Tag the object with a negative value just so we don&#39;t count it again */
2574     if ( tag == (jlong)0 ) {
2575         /* This object had no tag value, so we give it the negObjTag value */
2576         (*tag_ptr) = data-&gt;negObjTag;
2577     } else {
2578         /* If this object had a positive tag value, it must be one of the
2579          *    jclass objects we tagged. We need to preserve the value of
2580          *    this tag for later objects that might have this as a class
2581          *    tag, so we just make the existing tag value negative.
2582          */
2583         (*tag_ptr) = -tag;
2584     }
2585 
2586     /* Absolute value of class tag is an index into the counts[] array */
2587     jindex = JLONG_ABS(class_tag);
2588     index = CLASSTAG2INDEX(jindex);
2589     if (index &lt; 0 || index &gt;= data-&gt;classCount) {
2590         data-&gt;error = AGENT_ERROR_ILLEGAL_ARGUMENT;
2591         return JVMTI_VISIT_ABORT;
2592     }
2593 
2594     /* Bump instance count on this class */
2595     data-&gt;counts[index]++;
2596     return JVMTI_VISIT_OBJECTS;
2597 }
2598 
2599 /* Callback for instance count heap traversal (heap_iteration_callback) */
2600 static jint JNICALL
2601 cbObjectCounter(jlong class_tag, jlong size, jlong* tag_ptr, jint length,
2602                         void* user_data)
2603 {
2604     ClassCountData  *data;
2605     int              index;
2606 
2607     /* Check data structure */
2608     data = (ClassCountData*)user_data;
2609     if (data == NULL) {
2610         return JVMTI_VISIT_ABORT;
2611     }
2612 
2613     /* Classes with no tag should be filtered out. */
2614     if ( class_tag == (jlong)0 ) {
2615         data-&gt;error = AGENT_ERROR_INTERNAL;
2616         return JVMTI_VISIT_ABORT;
2617     }
2618 
2619     /* Class tag is actually an index into data arrays */
2620     index = CLASSTAG2INDEX(class_tag);
2621     if (index &lt; 0 || index &gt;= data-&gt;classCount) {
2622         data-&gt;error = AGENT_ERROR_ILLEGAL_ARGUMENT;
2623         return JVMTI_VISIT_ABORT;
2624     }
2625 
2626     /* Bump instance count on this class */
2627     data-&gt;counts[index]++;
2628     return JVMTI_VISIT_OBJECTS;
2629 }
2630 
2631 /* Get instance counts for a set of classes */
2632 jvmtiError
2633 classInstanceCounts(jint classCount, jclass *classes, jlong *counts)
2634 {
2635     jvmtiHeapCallbacks heap_callbacks;
2636     ClassCountData     data;
2637     jvmtiError         error;
2638     jvmtiEnv          *jvmti;
2639     int                i;
2640 
2641     /* Check interface assumptions */
2642     if ( classes == NULL || classCount &lt;= 0 || counts == NULL ) {
2643         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2644     }
2645 
2646     /* Initialize return information */
2647     for ( i = 0 ; i &lt; classCount ; i++ ) {
2648         counts[i] = (jlong)0;
2649     }
2650 
2651     /* Get jvmti environment to use */
2652     jvmti = getSpecialJvmti();
2653     if ( jvmti == NULL ) {
2654         return AGENT_ERROR_INTERNAL;
2655     }
2656 
2657     /* Setup class data structure */
2658     data.error        = JVMTI_ERROR_NONE;
2659     data.classCount   = classCount;
2660     data.counts       = counts;
2661 
2662     error = JVMTI_ERROR_NONE;
2663     /* Set tags on classes, use index in classes[] as the tag value. */
2664     error             = JVMTI_ERROR_NONE;
2665     for ( i = 0 ; i &lt; classCount ; i++ ) {
2666         if (classes[i] != NULL) {
2667             jlong tag;
2668 
2669             tag = INDEX2CLASSTAG(i);
2670             error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, classes[i], tag);
2671             if ( error != JVMTI_ERROR_NONE ) {
2672                 break;
2673             }
2674         }
2675     }
2676 
2677     /* Traverse heap, two ways to do this for instance counts. */
2678     if ( error == JVMTI_ERROR_NONE ) {
2679 
2680         /* Clear out callbacks structure */
2681         (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2682 
2683         /* Check debug flags to see how to do this. */
2684         if ( (gdata-&gt;debugflags &amp; USE_ITERATE_THROUGH_HEAP) == 0 ) {
2685 
2686             /* Using FollowReferences only gives us live objects, but we
2687              *   need to tag the objects to avoid counting them twice since
2688              *   the callback is per reference.
2689              *   The jclass objects have been tagged with their index in the
2690              *   supplied list, and that tag may flip to negative if it
2691              *   is also an object of interest.
2692              *   All other objects being counted that weren&#39;t in the
2693              *   supplied classes list will have a negative classCount
2694              *   tag value. So all objects counted will have negative tags.
2695              *   If the absolute tag value is an index in the supplied
2696              *   list, then it&#39;s one of the supplied classes.
2697              */
2698             data.negObjTag = -INDEX2CLASSTAG(classCount);
2699 
2700             /* Setup callbacks, only using object reference callback */
2701             heap_callbacks.heap_reference_callback = &amp;cbObjectCounterFromRef;
2702 
2703             /* Follow references, no initiating object, tagged classes only */
2704             error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2705                           (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
2706                            NULL, NULL, &amp;heap_callbacks, &amp;data);
2707 
2708         } else {
2709 
2710             /* Using IterateThroughHeap means that we will visit each object
2711              *   once, so no special tag tricks here. Just simple counting.
2712              *   However in this case the object might not be live, so we do
2713              *   a GC beforehand to make sure we minimize this.
2714              */
2715 
2716             /* FIXUP: Need some kind of trigger here to avoid excessive GC&#39;s? */
2717             error = JVMTI_FUNC_PTR(jvmti,ForceGarbageCollection)(jvmti);
2718             if ( error != JVMTI_ERROR_NONE ) {
2719 
2720                 /* Setup callbacks, just need object callback */
2721                 heap_callbacks.heap_iteration_callback = &amp;cbObjectCounter;
2722 
2723                 /* Iterate through entire heap, tagged classes only */
2724                 error = JVMTI_FUNC_PTR(jvmti,IterateThroughHeap)
2725                               (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
2726                                NULL, &amp;heap_callbacks, &amp;data);
2727 
2728             }
2729         }
2730 
2731         /* Use data error if needed */
2732         if ( error == JVMTI_ERROR_NONE ) {
2733             error = data.error;
2734         }
2735 
2736     }
2737 
2738     /* Dispose of any special jvmti environment */
2739     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2740     return error;
2741 }
2742 
2743 /* ********************************************************************* */
2744 /* Referrers */
2745 
2746 /* Structure to hold object referrer heap traversal data (arg user_data) */
2747 typedef struct ReferrerData {
2748   int        refCount;
2749   int        maxObjects;
2750   jlong      refTag;
2751   jlong      objTag;
2752   jboolean   selfRef;
2753   jvmtiError error;
2754 } ReferrerData;
2755 
2756 /* Callback for referrers object tagging (heap_reference_callback). */
2757 static jint JNICALL
2758 cbObjectTagReferrer(jvmtiHeapReferenceKind reference_kind,
2759      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2760      jlong referrer_class_tag, jlong size,
2761      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2762 {
2763     ReferrerData  *data;
2764 
2765     /* Check data structure */
2766     data = (ReferrerData*)user_data;
2767     if (data == NULL) {
2768         return JVMTI_VISIT_ABORT;
2769     }
2770 
2771     /* If we have tagged enough objects, just abort */
2772     if ( data-&gt;maxObjects != 0 &amp;&amp; data-&gt;refCount &gt;= data-&gt;maxObjects ) {
2773         return JVMTI_VISIT_ABORT;
2774     }
2775 
2776     /* If not of interest, just continue */
2777     if ( (*tag_ptr) != data-&gt;objTag ) {
2778         return JVMTI_VISIT_OBJECTS;
2779     }
2780 
2781     /* Self reference that we haven&#39;t counted? */
2782     if ( tag_ptr == referrer_tag_ptr ) {
2783         if ( data-&gt;selfRef == JNI_FALSE ) {
2784             data-&gt;selfRef = JNI_TRUE;
2785             data-&gt;refCount++;
2786         }
2787         return JVMTI_VISIT_OBJECTS;
2788     }
2789 
2790     /* If the referrer can be tagged, and hasn&#39;t been tagged, tag it */
2791     if ( referrer_tag_ptr != NULL ) {
2792         if ( (*referrer_tag_ptr) == (jlong)0 ) {
2793             *referrer_tag_ptr = data-&gt;refTag;
2794             data-&gt;refCount++;
2795         }
2796     }
2797     return JVMTI_VISIT_OBJECTS;
2798 }
2799 
2800 /* Heap traversal to find referrers of an object */
2801 jvmtiError
2802 objectReferrers(jobject obj, ObjectBatch *referrers, int maxObjects)
2803 {
2804     jvmtiHeapCallbacks heap_callbacks;
2805     ReferrerData       data;
2806     jvmtiError         error;
2807     jvmtiEnv          *jvmti;
2808 
2809     /* Check interface assumptions */
2810     if (obj == NULL) {
2811         return AGENT_ERROR_INVALID_OBJECT;
2812     }
2813     if (referrers == NULL || maxObjects &lt; 0 ) {
2814         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2815     }
2816 
2817     /* Initialize return information */
2818     referrers-&gt;count = 0;
2819     referrers-&gt;objects = NULL;
2820 
2821     /* Get jvmti environment to use */
2822     jvmti = getSpecialJvmti();
2823     if ( jvmti == NULL ) {
2824         return AGENT_ERROR_INTERNAL;
2825     }
2826 
2827     /* Fill in the data structure passed around the callbacks */
2828     data.refCount   = 0;
2829     data.maxObjects = maxObjects;
2830     data.objTag     = (jlong)1;
2831     data.refTag     = (jlong)2;
2832     data.selfRef    = JNI_FALSE;
2833     data.error      = JVMTI_ERROR_NONE;
2834 
2835     /* Tag the object of interest */
2836     error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, obj, data.objTag);
2837 
2838     /* No need to go any further if we can&#39;t tag the object */
2839     if ( error == JVMTI_ERROR_NONE ) {
2840 
2841         /* Clear out callbacks structure */
2842         (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2843 
2844         /* Setup callbacks we want */
2845         heap_callbacks.heap_reference_callback = &amp;cbObjectTagReferrer;
2846 
2847         /* Follow references, no initiating object, all classes, 1 tagged objs */
2848         error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2849                       (jvmti, JVMTI_HEAP_FILTER_UNTAGGED,
2850                        NULL, NULL, &amp;heap_callbacks, &amp;data);
2851 
2852         /* Use data error if needed */
2853         if ( error == JVMTI_ERROR_NONE ) {
2854             error = data.error;
2855         }
2856 
2857     }
2858 
2859     /* Watch out for self-reference */
2860     if ( error == JVMTI_ERROR_NONE &amp;&amp; data.selfRef == JNI_TRUE ) {
2861         /* Tag itself as a referer */
2862         error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, obj, data.refTag);
2863     }
2864 
2865     /* Get the jobjects for the tagged referrer objects.  */
2866     if ( error == JVMTI_ERROR_NONE ) {
2867         error = JVMTI_FUNC_PTR(jvmti,GetObjectsWithTags)
2868                     (jvmti, 1, &amp;(data.refTag), &amp;(referrers-&gt;count),
2869                           &amp;(referrers-&gt;objects), NULL);
2870         /* Verify we got the count we expected */
2871         if ( data.refCount != referrers-&gt;count ) {
2872             error = AGENT_ERROR_INTERNAL;
2873         }
2874     }
2875 
2876     /* Dispose of any special jvmti environment */
2877     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2878     return error;
2879 }
    </pre>
  </body>
</html>
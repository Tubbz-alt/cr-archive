<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdwp.agent/share/native/libjdwp/util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../jdk.jdi/share/classes/com/sun/tools/jdi/ValueImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../../test/hotspot/jtreg/ProblemList.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdwp.agent/share/native/libjdwp/util.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;ctype.h&gt;
  27 
  28 #include &quot;util.h&quot;
  29 #include &quot;transport.h&quot;
  30 #include &quot;eventHandler.h&quot;
  31 #include &quot;threadControl.h&quot;
  32 #include &quot;outStream.h&quot;
  33 #include &quot;inStream.h&quot;
  34 #include &quot;invoker.h&quot;


  35 
  36 /* Global data area */
  37 BackendGlobalData *gdata = NULL;
  38 
  39 /* Forward declarations */
  40 static jboolean isInterface(jclass clazz);
  41 static jboolean isArrayClass(jclass clazz);
  42 static char * getPropertyUTF8(JNIEnv *env, char *propertyName);
  43 
  44 /* Save an object reference for use later (create a NewGlobalRef) */
  45 void
  46 saveGlobalRef(JNIEnv *env, jobject obj, jobject *pobj)
  47 {
  48     jobject newobj;
  49 
  50     if ( pobj == NULL ) {
  51         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef pobj&quot;);
  52     }
  53     if ( *pobj != NULL ) {
  54         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef *pobj&quot;);
</pre>
<hr />
<pre>
 154     if ( name == NULL || name[0] == 0 ) {
 155         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod name&quot;);
 156     }
 157     if ( signature == NULL || signature[0] == 0 ) {
 158         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod signature&quot;);
 159     }
 160     method = JNI_FUNC_PTR(env,GetStaticMethodID)(env, clazz, name, signature);
 161     if (method == NULL) {
 162         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 163                                 name, signature));
 164         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 165     }
 166     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 167         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 168                                 name, signature));
 169         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 170     }
 171     return method;
 172 }
 173 


 174 void
 175 util_initialize(JNIEnv *env)
 176 {
 177     WITH_LOCAL_REFS(env, 6) {
 178 
 179         jvmtiError error;
 180         jclass localClassClass;
 181         jclass localThreadClass;
 182         jclass localThreadGroupClass;
 183         jclass localClassLoaderClass;
 184         jclass localStringClass;
 185         jclass localSystemClass;
 186         jclass localPropertiesClass;
 187         jclass localVMSupportClass;
 188         jobject localAgentProperties;
 189         jmethodID getAgentProperties;
 190         jint groupCount;
 191         jthreadGroup *groups;
 192         jthreadGroup localSystemThreadGroup;
 193 
</pre>
<hr />
<pre>
 327 
 328         return (classIsArray ? JDWP_TAG(ARRAY) : JDWP_TAG(OBJECT));
 329     }
 330 }
 331 
 332 static void
 333 writeFieldValue(JNIEnv *env, PacketOutputStream *out, jobject object,
 334                 jfieldID field)
 335 {
 336     jclass clazz;
 337     char *signature = NULL;
 338     jvmtiError error;
 339     jbyte typeKey;
 340 
 341     clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 342     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 343     if (error != JVMTI_ERROR_NONE) {
 344         outStream_setError(out, map2jdwpError(error));
 345         return;
 346     }
<span class="line-modified"> 347     typeKey = signature[0];</span>
 348     jvmtiDeallocate(signature);
 349 









 350     /*
<span class="line-modified"> 351      * For primitive types, the type key is bounced back as is. Objects</span>
<span class="line-removed"> 352      * are handled in the switch statement below.</span>
 353      */
<span class="line-modified"> 354     if ((typeKey != JDWP_TAG(OBJECT)) &amp;&amp; (typeKey != JDWP_TAG(ARRAY)) &amp;&amp; (typeKey != JDWP_TAG(INLINE_OBJECT))) {</span>
<span class="line-removed"> 355         (void)outStream_writeByte(out, typeKey);</span>
<span class="line-removed"> 356     }</span>
 357 
 358     switch (typeKey) {
<span class="line-removed"> 359         case JDWP_TAG(OBJECT):</span>
<span class="line-removed"> 360         case JDWP_TAG(ARRAY):</span>
<span class="line-removed"> 361         case JDWP_TAG(INLINE_OBJECT): {</span>
<span class="line-removed"> 362             jobject value = JNI_FUNC_PTR(env,GetObjectField)(env, object, field);</span>
<span class="line-removed"> 363             (void)outStream_writeByte(out, specificTypeKey(env, value));</span>
<span class="line-removed"> 364             (void)outStream_writeObjectRef(env, out, value);</span>
<span class="line-removed"> 365             break;</span>
<span class="line-removed"> 366         }</span>
<span class="line-removed"> 367 </span>
 368         case JDWP_TAG(BYTE):
 369             (void)outStream_writeByte(out,
 370                       JNI_FUNC_PTR(env,GetByteField)(env, object, field));
 371             break;
 372 
 373         case JDWP_TAG(CHAR):
 374             (void)outStream_writeChar(out,
 375                       JNI_FUNC_PTR(env,GetCharField)(env, object, field));
 376             break;
 377 
 378         case JDWP_TAG(FLOAT):
 379             (void)outStream_writeFloat(out,
 380                       JNI_FUNC_PTR(env,GetFloatField)(env, object, field));
 381             break;
 382 
 383         case JDWP_TAG(DOUBLE):
 384             (void)outStream_writeDouble(out,
 385                       JNI_FUNC_PTR(env,GetDoubleField)(env, object, field));
 386             break;
 387 
</pre>
<hr />
<pre>
 403         case JDWP_TAG(BOOLEAN):
 404             (void)outStream_writeBoolean(out,
 405                       JNI_FUNC_PTR(env,GetBooleanField)(env, object, field));
 406             break;
 407     }
 408 }
 409 
 410 static void
 411 writeStaticFieldValue(JNIEnv *env, PacketOutputStream *out, jclass clazz,
 412                       jfieldID field)
 413 {
 414     jvmtiError error;
 415     char *signature = NULL;
 416     jbyte typeKey;
 417 
 418     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 419     if (error != JVMTI_ERROR_NONE) {
 420         outStream_setError(out, map2jdwpError(error));
 421         return;
 422     }
<span class="line-modified"> 423     typeKey = signature[0];</span>
 424     jvmtiDeallocate(signature);
 425 
<span class="line-modified"> 426     /*</span>
<span class="line-modified"> 427      * For primitive types, the type key is bounced back as is. Objects</span>
<span class="line-modified"> 428      * are handled in the switch statement below.</span>
<span class="line-modified"> 429      */</span>
<span class="line-modified"> 430     if ((typeKey != JDWP_TAG(OBJECT)) &amp;&amp; (typeKey != JDWP_TAG(ARRAY)) &amp;&amp; (typeKey != JDWP_TAG(INLINE_OBJECT))) {</span>
<span class="line-modified"> 431         (void)outStream_writeByte(out, typeKey);</span>


 432     }
 433 




 434     switch (typeKey) {
<span class="line-removed"> 435         case JDWP_TAG(OBJECT):</span>
<span class="line-removed"> 436         case JDWP_TAG(ARRAY):</span>
<span class="line-removed"> 437         case JDWP_TAG(INLINE_OBJECT): {</span>
<span class="line-removed"> 438             jobject value = JNI_FUNC_PTR(env,GetStaticObjectField)(env, clazz, field);</span>
<span class="line-removed"> 439             (void)outStream_writeByte(out, specificTypeKey(env, value));</span>
<span class="line-removed"> 440             (void)outStream_writeObjectRef(env, out, value);</span>
<span class="line-removed"> 441             break;</span>
<span class="line-removed"> 442         }</span>
<span class="line-removed"> 443 </span>
 444         case JDWP_TAG(BYTE):
 445             (void)outStream_writeByte(out,
 446                       JNI_FUNC_PTR(env,GetStaticByteField)(env, clazz, field));
 447             break;
 448 
 449         case JDWP_TAG(CHAR):
 450             (void)outStream_writeChar(out,
 451                       JNI_FUNC_PTR(env,GetStaticCharField)(env, clazz, field));
 452             break;
 453 
 454         case JDWP_TAG(FLOAT):
 455             (void)outStream_writeFloat(out,
 456                       JNI_FUNC_PTR(env,GetStaticFloatField)(env, clazz, field));
 457             break;
 458 
 459         case JDWP_TAG(DOUBLE):
 460             (void)outStream_writeDouble(out,
 461                       JNI_FUNC_PTR(env,GetStaticDoubleField)(env, clazz, field));
 462             break;
 463 
</pre>
<hr />
<pre>
 556 
 557     /*
 558      * ... and the rest of the packet is identical for all commands
 559      */
 560     method = inStream_readMethodID(in);
 561     argumentCount = inStream_readInt(in);
 562     if (inStream_error(in)) {
 563         return JNI_TRUE;
 564     }
 565 
 566     /* If count == 0, don&#39;t try and allocate 0 bytes, you&#39;ll get NULL */
 567     if ( argumentCount &gt; 0 ) {
 568         int i;
 569         /*LINTED*/
 570         arguments = jvmtiAllocate(argumentCount * (jint)sizeof(*arguments));
 571         if (arguments == NULL) {
 572             outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
 573             return JNI_TRUE;
 574         }
 575         for (i = 0; (i &lt; argumentCount) &amp;&amp; !inStream_error(in); i++) {
<span class="line-modified"> 576             arguments[i] = inStream_readValue(in, NULL);</span>
 577         }
 578         if (inStream_error(in)) {
 579             return JNI_TRUE;
 580         }
 581     }
 582 
 583     options = inStream_readInt(in);
 584     if (inStream_error(in)) {
 585         if ( arguments != NULL ) {
 586             jvmtiDeallocate(arguments);
 587         }
 588         return JNI_TRUE;
 589     }
 590 
 591     if (inStream_command(in) == JDWP_COMMAND(ClassType, NewInstance)) {
 592         invokeType = INVOKE_CONSTRUCTOR;
 593     } else if (inStream_command(in) == JDWP_COMMAND(ClassType, InvokeMethod)) {
 594         invokeType = INVOKE_STATIC;
 595     } else if (inStream_command(in) == JDWP_COMMAND(InterfaceType, InvokeMethod)) {
 596         invokeType = INVOKE_STATIC;
</pre>
<hr />
<pre>
 963                     &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 964 }
 965 
 966 jboolean
 967 canSuspendResumeThreadLists(void)
 968 {
 969     jvmtiError error;
 970     jvmtiCapabilities cap;
 971 
 972     error = jvmtiGetCapabilities(&amp;cap);
 973     return (error == JVMTI_ERROR_NONE &amp;&amp; cap.can_suspend);
 974 }
 975 
 976 jvmtiError
 977 getSourceDebugExtension(jclass clazz, char **extensionPtr)
 978 {
 979     return JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSourceDebugExtension)
 980                 (gdata-&gt;jvmti, clazz, extensionPtr);
 981 }
 982 
<span class="line-removed"> 983 /*</span>
<span class="line-removed"> 984  * Convert the signature &quot;Ljava/lang/Foo;&quot; to a</span>
<span class="line-removed"> 985  * classname &quot;java.lang.Foo&quot; compatible with the pattern.</span>
<span class="line-removed"> 986  * Signature is overwritten in-place.</span>
<span class="line-removed"> 987  */</span>
<span class="line-removed"> 988 void</span>
<span class="line-removed"> 989 convertSignatureToClassname(char *convert)</span>
<span class="line-removed"> 990 {</span>
<span class="line-removed"> 991     char *p;</span>
<span class="line-removed"> 992 </span>
<span class="line-removed"> 993     p = convert + 1;</span>
<span class="line-removed"> 994     while ((*p != &#39;;&#39;) &amp;&amp; (*p != &#39;\0&#39;)) {</span>
<span class="line-removed"> 995         char c = *p;</span>
<span class="line-removed"> 996         if (c == &#39;/&#39;) {</span>
<span class="line-removed"> 997             *(p-1) = &#39;.&#39;;</span>
<span class="line-removed"> 998         } else if (c == &#39;.&#39;) {</span>
<span class="line-removed"> 999             // class signature of a hidden class is &quot;Ljava/lang/Foo.1234;&quot;</span>
<span class="line-removed">1000             // map to &quot;java.lang.Foo/1234&quot;</span>
<span class="line-removed">1001             *(p-1) = &#39;/&#39;;</span>
<span class="line-removed">1002         } else {</span>
<span class="line-removed">1003             *(p-1) = c;</span>
<span class="line-removed">1004         }</span>
<span class="line-removed">1005         p++;</span>
<span class="line-removed">1006     }</span>
<span class="line-removed">1007     *(p-1) = &#39;\0&#39;;</span>
<span class="line-removed">1008 }</span>
1009 
1010 static void
1011 handleInterrupt(void)
1012 {
1013     /*
1014      * An interrupt is handled:
1015      *
1016      * 1) for running application threads by deferring the interrupt
1017      * until the current event handler has concluded.
1018      *
1019      * 2) for debugger threads by ignoring the interrupt; this is the
1020      * most robust solution since debugger threads don&#39;t use interrupts
1021      * to signal any condition.
1022      *
1023      * 3) for application threads that have not started or already
1024      * ended by ignoring the interrupt. In the former case, the application
1025      * is relying on timing to determine whether or not the thread sees
1026      * the interrupt; in the latter case, the interrupt is meaningless.
1027      */
1028     jthread thread = threadControl_currentThread();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;ctype.h&gt;
  27 
  28 #include &quot;util.h&quot;
  29 #include &quot;transport.h&quot;
  30 #include &quot;eventHandler.h&quot;
  31 #include &quot;threadControl.h&quot;
  32 #include &quot;outStream.h&quot;
  33 #include &quot;inStream.h&quot;
  34 #include &quot;invoker.h&quot;
<span class="line-added">  35 #include &quot;signature.h&quot;</span>
<span class="line-added">  36 </span>
  37 
  38 /* Global data area */
  39 BackendGlobalData *gdata = NULL;
  40 
  41 /* Forward declarations */
  42 static jboolean isInterface(jclass clazz);
  43 static jboolean isArrayClass(jclass clazz);
  44 static char * getPropertyUTF8(JNIEnv *env, char *propertyName);
  45 
  46 /* Save an object reference for use later (create a NewGlobalRef) */
  47 void
  48 saveGlobalRef(JNIEnv *env, jobject obj, jobject *pobj)
  49 {
  50     jobject newobj;
  51 
  52     if ( pobj == NULL ) {
  53         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef pobj&quot;);
  54     }
  55     if ( *pobj != NULL ) {
  56         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef *pobj&quot;);
</pre>
<hr />
<pre>
 156     if ( name == NULL || name[0] == 0 ) {
 157         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod name&quot;);
 158     }
 159     if ( signature == NULL || signature[0] == 0 ) {
 160         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod signature&quot;);
 161     }
 162     method = JNI_FUNC_PTR(env,GetStaticMethodID)(env, clazz, name, signature);
 163     if (method == NULL) {
 164         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 165                                 name, signature));
 166         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 167     }
 168     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 169         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 170                                 name, signature));
 171         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 172     }
 173     return method;
 174 }
 175 
<span class="line-added"> 176 </span>
<span class="line-added"> 177 </span>
 178 void
 179 util_initialize(JNIEnv *env)
 180 {
 181     WITH_LOCAL_REFS(env, 6) {
 182 
 183         jvmtiError error;
 184         jclass localClassClass;
 185         jclass localThreadClass;
 186         jclass localThreadGroupClass;
 187         jclass localClassLoaderClass;
 188         jclass localStringClass;
 189         jclass localSystemClass;
 190         jclass localPropertiesClass;
 191         jclass localVMSupportClass;
 192         jobject localAgentProperties;
 193         jmethodID getAgentProperties;
 194         jint groupCount;
 195         jthreadGroup *groups;
 196         jthreadGroup localSystemThreadGroup;
 197 
</pre>
<hr />
<pre>
 331 
 332         return (classIsArray ? JDWP_TAG(ARRAY) : JDWP_TAG(OBJECT));
 333     }
 334 }
 335 
 336 static void
 337 writeFieldValue(JNIEnv *env, PacketOutputStream *out, jobject object,
 338                 jfieldID field)
 339 {
 340     jclass clazz;
 341     char *signature = NULL;
 342     jvmtiError error;
 343     jbyte typeKey;
 344 
 345     clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 346     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 347     if (error != JVMTI_ERROR_NONE) {
 348         outStream_setError(out, map2jdwpError(error));
 349         return;
 350     }
<span class="line-modified"> 351     typeKey = jdwpTag(signature);</span>
 352     jvmtiDeallocate(signature);
 353 
<span class="line-added"> 354     if (isReferenceTag(typeKey)) {</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356         jobject value = JNI_FUNC_PTR(env,GetObjectField)(env, object, field);</span>
<span class="line-added"> 357         (void)outStream_writeByte(out, specificTypeKey(env, value));</span>
<span class="line-added"> 358         (void)outStream_writeObjectRef(env, out, value);</span>
<span class="line-added"> 359         return;</span>
<span class="line-added"> 360 </span>
<span class="line-added"> 361     }</span>
<span class="line-added"> 362 </span>
 363     /*
<span class="line-modified"> 364      * For primitive types, the type key is bounced back as is.</span>

 365      */
<span class="line-modified"> 366     (void)outStream_writeByte(out, typeKey);</span>


 367 
 368     switch (typeKey) {









 369         case JDWP_TAG(BYTE):
 370             (void)outStream_writeByte(out,
 371                       JNI_FUNC_PTR(env,GetByteField)(env, object, field));
 372             break;
 373 
 374         case JDWP_TAG(CHAR):
 375             (void)outStream_writeChar(out,
 376                       JNI_FUNC_PTR(env,GetCharField)(env, object, field));
 377             break;
 378 
 379         case JDWP_TAG(FLOAT):
 380             (void)outStream_writeFloat(out,
 381                       JNI_FUNC_PTR(env,GetFloatField)(env, object, field));
 382             break;
 383 
 384         case JDWP_TAG(DOUBLE):
 385             (void)outStream_writeDouble(out,
 386                       JNI_FUNC_PTR(env,GetDoubleField)(env, object, field));
 387             break;
 388 
</pre>
<hr />
<pre>
 404         case JDWP_TAG(BOOLEAN):
 405             (void)outStream_writeBoolean(out,
 406                       JNI_FUNC_PTR(env,GetBooleanField)(env, object, field));
 407             break;
 408     }
 409 }
 410 
 411 static void
 412 writeStaticFieldValue(JNIEnv *env, PacketOutputStream *out, jclass clazz,
 413                       jfieldID field)
 414 {
 415     jvmtiError error;
 416     char *signature = NULL;
 417     jbyte typeKey;
 418 
 419     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 420     if (error != JVMTI_ERROR_NONE) {
 421         outStream_setError(out, map2jdwpError(error));
 422         return;
 423     }
<span class="line-modified"> 424     typeKey = jdwpTag(signature);</span>
 425     jvmtiDeallocate(signature);
 426 
<span class="line-modified"> 427 </span>
<span class="line-modified"> 428     if (isReferenceTag(typeKey)) {</span>
<span class="line-modified"> 429 </span>
<span class="line-modified"> 430         jobject value = JNI_FUNC_PTR(env,GetStaticObjectField)(env, clazz, field);</span>
<span class="line-modified"> 431         (void)outStream_writeByte(out, specificTypeKey(env, value));</span>
<span class="line-modified"> 432         (void)outStream_writeObjectRef(env, out, value);</span>
<span class="line-added"> 433 </span>
<span class="line-added"> 434         return;</span>
 435     }
 436 
<span class="line-added"> 437     /*</span>
<span class="line-added"> 438      * For primitive types, the type key is bounced back as is.</span>
<span class="line-added"> 439      */</span>
<span class="line-added"> 440     (void)outStream_writeByte(out, typeKey);</span>
 441     switch (typeKey) {









 442         case JDWP_TAG(BYTE):
 443             (void)outStream_writeByte(out,
 444                       JNI_FUNC_PTR(env,GetStaticByteField)(env, clazz, field));
 445             break;
 446 
 447         case JDWP_TAG(CHAR):
 448             (void)outStream_writeChar(out,
 449                       JNI_FUNC_PTR(env,GetStaticCharField)(env, clazz, field));
 450             break;
 451 
 452         case JDWP_TAG(FLOAT):
 453             (void)outStream_writeFloat(out,
 454                       JNI_FUNC_PTR(env,GetStaticFloatField)(env, clazz, field));
 455             break;
 456 
 457         case JDWP_TAG(DOUBLE):
 458             (void)outStream_writeDouble(out,
 459                       JNI_FUNC_PTR(env,GetStaticDoubleField)(env, clazz, field));
 460             break;
 461 
</pre>
<hr />
<pre>
 554 
 555     /*
 556      * ... and the rest of the packet is identical for all commands
 557      */
 558     method = inStream_readMethodID(in);
 559     argumentCount = inStream_readInt(in);
 560     if (inStream_error(in)) {
 561         return JNI_TRUE;
 562     }
 563 
 564     /* If count == 0, don&#39;t try and allocate 0 bytes, you&#39;ll get NULL */
 565     if ( argumentCount &gt; 0 ) {
 566         int i;
 567         /*LINTED*/
 568         arguments = jvmtiAllocate(argumentCount * (jint)sizeof(*arguments));
 569         if (arguments == NULL) {
 570             outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
 571             return JNI_TRUE;
 572         }
 573         for (i = 0; (i &lt; argumentCount) &amp;&amp; !inStream_error(in); i++) {
<span class="line-modified"> 574             arguments[i] = inStream_readValue(in);</span>
 575         }
 576         if (inStream_error(in)) {
 577             return JNI_TRUE;
 578         }
 579     }
 580 
 581     options = inStream_readInt(in);
 582     if (inStream_error(in)) {
 583         if ( arguments != NULL ) {
 584             jvmtiDeallocate(arguments);
 585         }
 586         return JNI_TRUE;
 587     }
 588 
 589     if (inStream_command(in) == JDWP_COMMAND(ClassType, NewInstance)) {
 590         invokeType = INVOKE_CONSTRUCTOR;
 591     } else if (inStream_command(in) == JDWP_COMMAND(ClassType, InvokeMethod)) {
 592         invokeType = INVOKE_STATIC;
 593     } else if (inStream_command(in) == JDWP_COMMAND(InterfaceType, InvokeMethod)) {
 594         invokeType = INVOKE_STATIC;
</pre>
<hr />
<pre>
 961                     &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 962 }
 963 
 964 jboolean
 965 canSuspendResumeThreadLists(void)
 966 {
 967     jvmtiError error;
 968     jvmtiCapabilities cap;
 969 
 970     error = jvmtiGetCapabilities(&amp;cap);
 971     return (error == JVMTI_ERROR_NONE &amp;&amp; cap.can_suspend);
 972 }
 973 
 974 jvmtiError
 975 getSourceDebugExtension(jclass clazz, char **extensionPtr)
 976 {
 977     return JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSourceDebugExtension)
 978                 (gdata-&gt;jvmti, clazz, extensionPtr);
 979 }
 980 


























 981 
 982 static void
 983 handleInterrupt(void)
 984 {
 985     /*
 986      * An interrupt is handled:
 987      *
 988      * 1) for running application threads by deferring the interrupt
 989      * until the current event handler has concluded.
 990      *
 991      * 2) for debugger threads by ignoring the interrupt; this is the
 992      * most robust solution since debugger threads don&#39;t use interrupts
 993      * to signal any condition.
 994      *
 995      * 3) for application threads that have not started or already
 996      * ended by ignoring the interrupt. In the former case, the application
 997      * is relying on timing to determine whether or not the thread sees
 998      * the interrupt; in the latter case, the interrupt is meaningless.
 999      */
1000     jthread thread = threadControl_currentThread();
</pre>
</td>
</tr>
</table>
<center><a href="../../../../jdk.jdi/share/classes/com/sun/tools/jdi/ValueImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../../test/hotspot/jtreg/ProblemList.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
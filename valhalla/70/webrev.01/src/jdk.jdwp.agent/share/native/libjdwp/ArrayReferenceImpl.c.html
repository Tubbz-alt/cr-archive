<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdwp.agent/share/native/libjdwp/ArrayReferenceImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;util.h&quot;
 27 #include &quot;ArrayReferenceImpl.h&quot;
 28 #include &quot;inStream.h&quot;
 29 #include &quot;outStream.h&quot;
 30 #include &quot;signature.h&quot;
 31 
 32 static jboolean
 33 length(PacketInputStream *in, PacketOutputStream *out)
 34 {
 35     JNIEnv *env = getEnv();
 36     jsize arrayLength;
 37 
 38     jarray  array = inStream_readArrayRef(env, in);
 39     if (inStream_error(in)) {
 40         return JNI_TRUE;
 41     }
 42 
 43     arrayLength = JNI_FUNC_PTR(env,GetArrayLength)(env, array);
 44     (void)outStream_writeInt(out, arrayLength);
 45     return JNI_TRUE;
 46 }
 47 
 48 static void *
 49 newComponents(PacketOutputStream *out, jint length, size_t nbytes)
 50 {
 51     void *ptr = NULL;
 52 
 53     if ( length &gt; 0 ) {
 54         ptr = jvmtiAllocate(length*((jint)nbytes));
 55         if ( ptr == NULL ) {
 56             outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
 57         } else {
 58             (void)memset(ptr, 0, length*nbytes);
 59         }
 60     }
 61     return ptr;
 62 }
 63 
 64 static void
 65 deleteComponents(void *ptr)
 66 {
 67     jvmtiDeallocate(ptr);
 68 }
 69 
 70 static void
 71 writeBooleanComponents(JNIEnv *env, PacketOutputStream *out,
 72                     jarray array, jint index, jint length)
 73 {
 74     jboolean *components;
 75 
 76     components = newComponents(out, length, sizeof(jboolean));
 77     if (components != NULL) {
 78         jint i;
 79         JNI_FUNC_PTR(env,GetBooleanArrayRegion)(env, array, index, length, components);
 80         for (i = 0; i &lt; length; i++) {
 81             (void)outStream_writeBoolean(out, components[i]);
 82         }
 83         deleteComponents(components);
 84     }
 85 }
 86 
 87 static void
 88 writeByteComponents(JNIEnv *env, PacketOutputStream *out,
 89                     jarray array, jint index, jint length)
 90 {
 91     jbyte *components;
 92 
 93     components = newComponents(out, length, sizeof(jbyte));
 94     if (components != NULL) {
 95         jint i;
 96         JNI_FUNC_PTR(env,GetByteArrayRegion)(env, array, index, length, components);
 97         for (i = 0; i &lt; length; i++) {
 98             (void)outStream_writeByte(out, components[i]);
 99         }
100         deleteComponents(components);
101     }
102 }
103 
104 static void
105 writeCharComponents(JNIEnv *env, PacketOutputStream *out,
106                     jarray array, jint index, jint length)
107 {
108     jchar *components;
109 
110     components = newComponents(out, length, sizeof(jchar));
111     if (components != NULL) {
112         jint i;
113         JNI_FUNC_PTR(env,GetCharArrayRegion)(env, array, index, length, components);
114         for (i = 0; i &lt; length; i++) {
115             (void)outStream_writeChar(out, components[i]);
116         }
117         deleteComponents(components);
118     }
119 }
120 
121 static void
122 writeShortComponents(JNIEnv *env, PacketOutputStream *out,
123                     jarray array, jint index, jint length)
124 {
125     jshort *components;
126 
127     components = newComponents(out, length, sizeof(jshort));
128     if (components != NULL) {
129         jint i;
130         JNI_FUNC_PTR(env,GetShortArrayRegion)(env, array, index, length, components);
131         for (i = 0; i &lt; length; i++) {
132             (void)outStream_writeShort(out, components[i]);
133         }
134         deleteComponents(components);
135     }
136 }
137 
138 static void
139 writeIntComponents(JNIEnv *env, PacketOutputStream *out,
140                     jarray array, jint index, jint length)
141 {
142     jint *components;
143 
144     components = newComponents(out, length, sizeof(jint));
145     if (components != NULL) {
146         jint i;
147         JNI_FUNC_PTR(env,GetIntArrayRegion)(env, array, index, length, components);
148         for (i = 0; i &lt; length; i++) {
149             (void)outStream_writeInt(out, components[i]);
150         }
151         deleteComponents(components);
152     }
153 }
154 
155 static void
156 writeLongComponents(JNIEnv *env, PacketOutputStream *out,
157                     jarray array, jint index, jint length)
158 {
159     jlong *components;
160 
161     components = newComponents(out, length, sizeof(jlong));
162     if (components != NULL) {
163         jint i;
164         JNI_FUNC_PTR(env,GetLongArrayRegion)(env, array, index, length, components);
165         for (i = 0; i &lt; length; i++) {
166             (void)outStream_writeLong(out, components[i]);
167         }
168         deleteComponents(components);
169     }
170 }
171 
172 static void
173 writeFloatComponents(JNIEnv *env, PacketOutputStream *out,
174                     jarray array, jint index, jint length)
175 {
176     jfloat *components;
177 
178     components = newComponents(out, length, sizeof(jfloat));
179     if (components != NULL) {
180         jint i;
181         JNI_FUNC_PTR(env,GetFloatArrayRegion)(env, array, index, length, components);
182         for (i = 0; i &lt; length; i++) {
183             (void)outStream_writeFloat(out, components[i]);
184         }
185         deleteComponents(components);
186     }
187 }
188 
189 static void
190 writeDoubleComponents(JNIEnv *env, PacketOutputStream *out,
191                     jarray array, jint index, jint length)
192 {
193     jdouble *components;
194 
195     components = newComponents(out, length, sizeof(jdouble));
196     if (components != NULL) {
197         jint i;
198         JNI_FUNC_PTR(env,GetDoubleArrayRegion)(env, array, index, length, components);
199         for (i = 0; i &lt; length; i++) {
200             (void)outStream_writeDouble(out, components[i]);
201         }
202         deleteComponents(components);
203     }
204 }
205 
206 static void
207 writeObjectComponents(JNIEnv *env, PacketOutputStream *out,
208                       jarray array, jint index, jint length)
209 {
210 
211     WITH_LOCAL_REFS(env, length) {
212 
213         int i;
214         jobject component;
215 
216         for (i = 0; i &lt; length; i++) {
217             component = JNI_FUNC_PTR(env,GetObjectArrayElement)(env, array, index + i);
218             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
219                 /* cleared by caller */
220                 break;
221             }
222             (void)outStream_writeByte(out, specificTypeKey(env, component));
223             (void)outStream_writeObjectRef(env, out, component);
224         }
225 
226     } END_WITH_LOCAL_REFS(env);
227 }
228 
229 static void writeComponents(JNIEnv *env, PacketOutputStream *out, char *signature,
230                             jarray array, jint index, jint length);
231 
232 static jboolean
233 getValues(PacketInputStream *in, PacketOutputStream *out)
234 {
235     JNIEnv *env = getEnv();
236     jint arrayLength;
237     jarray array;
238     jint index;
239     jint length;
240 
241     array = inStream_readArrayRef(env, in);
242     if (inStream_error(in)) {
243         return JNI_TRUE;
244     }
245     index = inStream_readInt(in);
246     if (inStream_error(in)) {
247         return JNI_TRUE;
248     }
249     length = inStream_readInt(in);
250     if (inStream_error(in)) {
251         return JNI_TRUE;
252     }
253 
254     arrayLength = JNI_FUNC_PTR(env,GetArrayLength)(env, array);
255 
256     if (length == -1) {
257         length = arrayLength - index;
258     }
259 
260     if ((index &lt; 0) || (index &gt; arrayLength - 1)) {
261         outStream_setError(out, JDWP_ERROR(INVALID_INDEX));
262         return JNI_TRUE;
263     }
264 
265     if ((length &lt; 0) || (length + index &gt; arrayLength)) {
266         outStream_setError(out, JDWP_ERROR(INVALID_LENGTH));
267         return JNI_TRUE;
268     }
269 
270     WITH_LOCAL_REFS(env, 1) {
271 
272         char *signature = NULL;
273 
274         jclass arrayClass = JNI_FUNC_PTR(env,GetObjectClass)(env, array);
275         jvmtiError error = classSignature(arrayClass, &amp;signature, NULL);
276         if (error == JVMTI_ERROR_NONE) {
277             writeComponents(env, out, signature, array, index, length);
278             jvmtiDeallocate(signature);
279         }
280 
281     } END_WITH_LOCAL_REFS(env);
282 
283     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
284         outStream_setError(out, JDWP_ERROR(INTERNAL));
285         JNI_FUNC_PTR(env,ExceptionClear)(env);
286     }
287 
288     return JNI_TRUE;
289 }
290 
291 static void writeComponents(JNIEnv *env, PacketOutputStream *out, char *signature,
292                             jarray array, jint index, jint length) {
293 
294     char * componentSignature = componentTypeSignature(signature);
295     jbyte typeKey = jdwpTag(componentSignature);
296 
297     (void)outStream_writeByte(out, typeKey);
298     (void)outStream_writeInt(out, length);
299 
300     if (isReferenceTag(typeKey)) {
301         writeObjectComponents(env, out, array, index, length);
302         return;
303     }
304     switch (typeKey) {
305         case JDWP_TAG(BYTE):
306             writeByteComponents(env, out, array, index, length);
307             break;
308 
309         case JDWP_TAG(CHAR):
310             writeCharComponents(env, out, array, index, length);
311             break;
312 
313         case JDWP_TAG(FLOAT):
314             writeFloatComponents(env, out, array, index, length);
315             break;
316 
317         case JDWP_TAG(DOUBLE):
318             writeDoubleComponents(env, out, array, index, length);
319             break;
320 
321         case JDWP_TAG(INT):
322             writeIntComponents(env, out, array, index, length);
323             break;
324 
325         case JDWP_TAG(LONG):
326             writeLongComponents(env, out, array, index, length);
327             break;
328 
329         case JDWP_TAG(SHORT):
330             writeShortComponents(env, out, array, index, length);
331             break;
332 
333         case JDWP_TAG(BOOLEAN):
334             writeBooleanComponents(env, out, array, index, length);
335             break;
336 
337         default:
338             outStream_setError(out, JDWP_ERROR(INVALID_TAG));
339             break;
340     }
341 }
342 
343 static jdwpError
344 readBooleanComponents(JNIEnv *env, PacketInputStream *in,
345                    jarray array, int index, int length)
346 {
347     int i;
348     jboolean component;
349 
350     for (i = 0; (i &lt; length) &amp;&amp; !inStream_error(in); i++) {
351         component = inStream_readBoolean(in);
352         JNI_FUNC_PTR(env,SetBooleanArrayRegion)(env, array, index + i, 1, &amp;component);
353     }
354     return inStream_error(in);
355 }
356 
357 static jdwpError
358 readByteComponents(JNIEnv *env, PacketInputStream *in,
359                    jarray array, int index, int length)
360 {
361     int i;
362     jbyte component;
363 
364     for (i = 0; (i &lt; length) &amp;&amp; !inStream_error(in); i++) {
365         component = inStream_readByte(in);
366         JNI_FUNC_PTR(env,SetByteArrayRegion)(env, array, index + i, 1, &amp;component);
367     }
368     return inStream_error(in);
369 }
370 
371 static jdwpError
372 readCharComponents(JNIEnv *env, PacketInputStream *in,
373                    jarray array, int index, int length)
374 {
375     int i;
376     jchar component;
377 
378     for (i = 0; (i &lt; length) &amp;&amp; !inStream_error(in); i++) {
379         component = inStream_readChar(in);
380         JNI_FUNC_PTR(env,SetCharArrayRegion)(env, array, index + i, 1, &amp;component);
381     }
382     return inStream_error(in);
383 }
384 
385 static jdwpError
386 readShortComponents(JNIEnv *env, PacketInputStream *in,
387                    jarray array, int index, int length)
388 {
389     int i;
390     jshort component;
391 
392     for (i = 0; (i &lt; length) &amp;&amp; !inStream_error(in); i++) {
393         component = inStream_readShort(in);
394         JNI_FUNC_PTR(env,SetShortArrayRegion)(env, array, index + i, 1, &amp;component);
395     }
396     return inStream_error(in);
397 }
398 
399 static jdwpError
400 readIntComponents(JNIEnv *env, PacketInputStream *in,
401                    jarray array, int index, int length)
402 {
403     int i;
404     jint component;
405 
406     for (i = 0; (i &lt; length) &amp;&amp; !inStream_error(in); i++) {
407         component = inStream_readInt(in);
408         JNI_FUNC_PTR(env,SetIntArrayRegion)(env, array, index + i, 1, &amp;component);
409     }
410     return inStream_error(in);
411 }
412 
413 static jdwpError
414 readLongComponents(JNIEnv *env, PacketInputStream *in,
415                    jarray array, int index, int length)
416 {
417     int i;
418 #if defined (_WIN32) &amp;&amp; defined (_MSC_VER)
419     __declspec(align(8))
420 #endif
421     jlong component;
422 
423     for (i = 0; (i &lt; length) &amp;&amp; !inStream_error(in); i++) {
424         component = inStream_readLong(in);
425         JNI_FUNC_PTR(env,SetLongArrayRegion)(env, array, index + i, 1, &amp;component);
426     }
427     return inStream_error(in);
428 }
429 
430 static jdwpError
431 readFloatComponents(JNIEnv *env, PacketInputStream *in,
432                    jarray array, int index, int length)
433 {
434     int i;
435     jfloat component;
436 
437     for (i = 0; (i &lt; length) &amp;&amp; !inStream_error(in); i++) {
438         component = inStream_readFloat(in);
439         JNI_FUNC_PTR(env,SetFloatArrayRegion)(env, array, index + i, 1, &amp;component);
440     }
441     return inStream_error(in);
442 }
443 
444 static jdwpError
445 readDoubleComponents(JNIEnv *env, PacketInputStream *in,
446                    jarray array, int index, int length)
447 {
448     int i;
449 #if defined (_WIN32) &amp;&amp; defined (_MSC_VER)
450     __declspec(align(8))
451 #endif
452     jdouble component;
453 
454     for (i = 0; (i &lt; length) &amp;&amp; !inStream_error(in); i++) {
455         component = inStream_readDouble(in);
456         JNI_FUNC_PTR(env,SetDoubleArrayRegion)(env, array, index + i, 1, &amp;component);
457     }
458     return inStream_error(in);
459 }
460 
461 
462 static jdwpError
463 readObjectComponents(JNIEnv *env, PacketInputStream *in,
464                    jarray array, int index, int length)
465                    /* char *componentSignature) */
466 {
467     int i;
468 
469     for (i = 0; i &lt; length; i++) {
470         jobject object = inStream_readObjectRef(env, in);
471 
472         JNI_FUNC_PTR(env,SetObjectArrayElement)(env, array, index + i, object);
473         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
474             /* caller will clear */
475             break;
476         }
477     }
478 
479     return JDWP_ERROR(NONE);
480 }
481 
482 static jdwpError readComponents(JNIEnv *env, PacketInputStream *in, char *signature,
483                                 jarray array, jint index, jint length);
484 
485 static jboolean
486 setValues(PacketInputStream *in, PacketOutputStream *out)
487 {
488     JNIEnv *env = getEnv();
489     jdwpError serror = JDWP_ERROR(NONE);
490     int arrayLength;
491     jarray array;
492     jint index;
493     jint length;
494 
495     array = inStream_readArrayRef(env, in);
496     if (inStream_error(in)) {
497         return JNI_TRUE;
498     }
499     index = inStream_readInt(in);
500     if (inStream_error(in)) {
501         return JNI_TRUE;
502     }
503     length = inStream_readInt(in);
504     if (inStream_error(in)) {
505         return JNI_TRUE;
506     }
507 
508     arrayLength = JNI_FUNC_PTR(env,GetArrayLength)(env, array);
509 
510     if ((index &lt; 0) || (index &gt; arrayLength - 1)) {
511         outStream_setError(out, JDWP_ERROR(INVALID_INDEX));
512         return JNI_TRUE;
513     }
514 
515     if ((length &lt; 0) || (length + index &gt; arrayLength)) {
516         outStream_setError(out, JDWP_ERROR(INVALID_LENGTH));
517         return JNI_TRUE;
518     }
519 
520     WITH_LOCAL_REFS(env, 1)  {
521 
522         char *signature = NULL;
523 
524         jclass arrayClass = JNI_FUNC_PTR(env,GetObjectClass)(env, array);
525         jvmtiError error = classSignature(arrayClass, &amp;signature, NULL);
526         if (error == JVMTI_ERROR_NONE) {
527             serror = readComponents(env, in, signature, array, index, length);
528             jvmtiDeallocate(signature);
529         }
530     } END_WITH_LOCAL_REFS(env);
531 
532     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
533         /*
534          * TO DO: Check exception type
535          */
536         serror = JDWP_ERROR(TYPE_MISMATCH);
537         JNI_FUNC_PTR(env,ExceptionClear)(env);
538     }
539 
540     outStream_setError(out, serror);
541     return JNI_TRUE;
542 }
543 
544 static jdwpError readComponents(JNIEnv *env, PacketInputStream *in, char *signature,
545 jarray array, jint index, jint length) {
546     jdwpError serror = JDWP_ERROR(NONE);
547 
548     char *componentSignature = componentTypeSignature(signature);
549     jbyte typeKey = jdwpTag(componentSignature);
550     if (isReferenceTag(typeKey)) {
551         serror = readObjectComponents(env, in, array, index, length);
552         return serror;
553     }
554     switch (typeKey) {
555         case JDWP_TAG(BYTE):
556             serror = readByteComponents(env, in, array, index, length);
557             break;
558 
559         case JDWP_TAG(CHAR):
560             serror = readCharComponents(env, in, array, index, length);
561             break;
562 
563         case JDWP_TAG(FLOAT):
564             serror = readFloatComponents(env, in, array, index, length);
565             break;
566 
567         case JDWP_TAG(DOUBLE):
568             serror = readDoubleComponents(env, in, array, index, length);
569             break;
570 
571         case JDWP_TAG(INT):
572             serror = readIntComponents(env, in, array, index, length);
573             break;
574 
575         case JDWP_TAG(LONG):
576             serror = readLongComponents(env, in, array, index, length);
577             break;
578 
579         case JDWP_TAG(SHORT):
580             serror = readShortComponents(env, in, array, index, length);
581             break;
582 
583         case JDWP_TAG(BOOLEAN):
584             serror = readBooleanComponents(env, in, array, index, length);
585             break;
586 
587         default:
588             {
589                 ERROR_MESSAGE((&quot;Invalid array component signature: %s&quot;,
590                                     componentSignature));
591                 EXIT_ERROR(AGENT_ERROR_INVALID_OBJECT,NULL);
592             }
593             break;
594     }
595 
596     return serror;
597 }
598 
599 Command ArrayReference_Commands[] = {
600     {length, &quot;Length&quot;},
601     {getValues, &quot;GetValues&quot;},
602     {setValues, &quot;SetValues&quot;}
603 };
604 
605 DEBUG_DISPATCH_DEFINE_CMDSET(ArrayReference)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdwp.agent/share/native/libjdwp/ArrayTypeImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;ArrayTypeImpl.h&quot;
 27 #include &quot;util.h&quot;
 28 #include &quot;inStream.h&quot;
 29 #include &quot;outStream.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 30 #include &quot;signature.h&quot;</span>
<span class="line-added"> 31 </span>
 32 
 33 /*
 34  * Determine the component class by looking thru all classes for
 35  * one that has the signature of the component and the same class loadeer
 36  * as the array.  See JVM spec 5.3.3:
 37  *     If the component type is a reference type, C is marked as having
 38  *     been defined by the defining class loader of the component type.
 39  */
 40 static jdwpError
 41 getComponentClass(JNIEnv *env, jclass arrayClass, char *componentSignature,
 42                 jclass *componentClassPtr)
 43 {
 44     jobject arrayClassLoader;
 45     jclass *classes;
 46     jint count;
 47     jclass componentClass = NULL;
 48     jdwpError serror;
 49     jvmtiError error;
 50 
 51     serror = JDWP_ERROR(NONE);
 52 
 53     error = classLoader(arrayClass, &amp;arrayClassLoader);
 54     if (error != JVMTI_ERROR_NONE) {
 55         return map2jdwpError(error);
 56     }
 57 
 58     error = allLoadedClasses(&amp;classes, &amp;count);
 59     if (error != JVMTI_ERROR_NONE) {
 60         serror = map2jdwpError(error);
 61     } else {
 62         int i;
 63         for (i = 0; (i &lt; count) &amp;&amp; (componentClass == NULL); i++) {
 64             char *signature = NULL;
 65             jclass clazz = classes[i];
 66             jboolean match;
 67             jvmtiError error;
 68 
 69             /* signature must match */
 70             error = classSignature(clazz, &amp;signature, NULL);
 71             if (error != JVMTI_ERROR_NONE) {
 72                 serror = map2jdwpError(error);
 73                 break;
 74             }
 75             match = strcmp(signature, componentSignature) == 0;
 76             jvmtiDeallocate(signature);
 77 
 78             /* if signature matches, get class loader to check if
 79              * it matches
 80              */
 81             if (match) {
 82                 jobject loader;
 83                 error = classLoader(clazz, &amp;loader);
 84                 if (error != JVMTI_ERROR_NONE) {
 85                     return map2jdwpError(error);
 86                 }
 87                 match = isSameObject(env, loader, arrayClassLoader);
 88             }
 89 
 90             if (match) {
 91                 componentClass = clazz;
 92             }
 93         }
 94         jvmtiDeallocate(classes);
 95 
 96         *componentClassPtr = componentClass;
 97     }
 98 
 99     if (serror == JDWP_ERROR(NONE) &amp;&amp; componentClass == NULL) {
100         /* per JVM spec, component class is always loaded
101          * before array class, so this should never occur.
102          */
103         serror = JDWP_ERROR(NOT_FOUND);
104     }
105 
106     return serror;
107 }
108 
109 static void
110 writeNewObjectArray(JNIEnv *env, PacketOutputStream *out,
111                  jclass arrayClass, jint size, char *componentSignature)
112 {
113 
114     WITH_LOCAL_REFS(env, 1) {
115 
116         jarray array;
117         jclass componentClass = NULL;
118         jdwpError serror;
119 
120         serror = getComponentClass(env, arrayClass,
121                                        componentSignature, &amp;componentClass);
122         if (serror != JDWP_ERROR(NONE)) {
123             outStream_setError(out, serror);
124         } else {
125 
126             array = JNI_FUNC_PTR(env,NewObjectArray)(env, size, componentClass, 0);
127             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
128                 JNI_FUNC_PTR(env,ExceptionClear)(env);
129                 array = NULL;
130             }
131 
132             if (array == NULL) {
133                 outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
134             } else {
135                 (void)outStream_writeByte(out, specificTypeKey(env, array));
136                 (void)outStream_writeObjectRef(env, out, array);
137             }
138 
139         }
140 
141     } END_WITH_LOCAL_REFS(env);
142 }
143 
144 static void
145 writeNewPrimitiveArray(JNIEnv *env, PacketOutputStream *out,
146                        jclass arrayClass, jint size, char *componentSignature)
147 {
148 
149     WITH_LOCAL_REFS(env, 1) {
150 
151         jarray array = NULL;
152 
<a name="2" id="anc2"></a><span class="line-modified">153         switch (jdwpTag(componentSignature)) {</span>
154             case JDWP_TAG(BYTE):
155                 array = JNI_FUNC_PTR(env,NewByteArray)(env, size);
156                 break;
157 
158             case JDWP_TAG(CHAR):
159                 array = JNI_FUNC_PTR(env,NewCharArray)(env, size);
160                 break;
161 
162             case JDWP_TAG(FLOAT):
163                 array = JNI_FUNC_PTR(env,NewFloatArray)(env, size);
164                 break;
165 
166             case JDWP_TAG(DOUBLE):
167                 array = JNI_FUNC_PTR(env,NewDoubleArray)(env, size);
168                 break;
169 
170             case JDWP_TAG(INT):
171                 array = JNI_FUNC_PTR(env,NewIntArray)(env, size);
172                 break;
173 
174             case JDWP_TAG(LONG):
175                 array = JNI_FUNC_PTR(env,NewLongArray)(env, size);
176                 break;
177 
178             case JDWP_TAG(SHORT):
179                 array = JNI_FUNC_PTR(env,NewShortArray)(env, size);
180                 break;
181 
182             case JDWP_TAG(BOOLEAN):
183                 array = JNI_FUNC_PTR(env,NewBooleanArray)(env, size);
184                 break;
185 
186             default:
187                 outStream_setError(out, JDWP_ERROR(TYPE_MISMATCH));
188                 break;
189         }
190 
191         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
192             JNI_FUNC_PTR(env,ExceptionClear)(env);
193             array = NULL;
194         }
195 
196         if (array == NULL) {
197             outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
198         } else {
199             (void)outStream_writeByte(out, specificTypeKey(env, array));
200             (void)outStream_writeObjectRef(env, out, array);
201         }
202 
203     } END_WITH_LOCAL_REFS(env);
204 }
205 
206 static jboolean
207 newInstance(PacketInputStream *in, PacketOutputStream *out)
208 {
209     JNIEnv *env;
210     char *signature = NULL;
211     char *componentSignature;
212     jclass arrayClass;
213     jint size;
214     jvmtiError error;
215 
216     env = getEnv();
217 
218     arrayClass = inStream_readClassRef(env, in);
219     if (inStream_error(in)) {
220         return JNI_TRUE;
221     }
222     size = inStream_readInt(in);
223     if (inStream_error(in)) {
224         return JNI_TRUE;
225     }
226 
227     error = classSignature(arrayClass, &amp;signature, NULL);
228     if ( error != JVMTI_ERROR_NONE ) {
229         outStream_setError(out, map2jdwpError(error));
230         return JNI_FALSE;
231     }
<a name="3" id="anc3"></a><span class="line-modified">232     componentSignature = componentTypeSignature(signature);</span>
233 
<a name="4" id="anc4"></a><span class="line-modified">234     jbyte typeKey = jdwpTag(componentSignature);</span>
<span class="line-modified">235     if (isReferenceTag(typeKey)) {</span>

236         writeNewObjectArray(env, out, arrayClass, size, componentSignature);
237     } else {
238         writeNewPrimitiveArray(env, out, arrayClass, size, componentSignature);
239     }
240 
241     jvmtiDeallocate(signature);
242     return JNI_TRUE;
243 }
244 
245 Command ArrayType_Commands[] = {
246     {newInstance, &quot;NewInstance&quot;}
247 };
248 
249 DEBUG_DISPATCH_DEFINE_CMDSET(ArrayType)
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
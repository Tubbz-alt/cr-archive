<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdwp.agent/share/native/libjdwp/ObjectReferenceImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;util.h&quot;
 27 #include &quot;ObjectReferenceImpl.h&quot;
 28 #include &quot;commonRef.h&quot;
 29 #include &quot;inStream.h&quot;
 30 #include &quot;outStream.h&quot;
 31 
 32 static jboolean
 33 referenceType(PacketInputStream *in, PacketOutputStream *out)
 34 {
 35     JNIEnv *env;
 36     jobject object;
 37 
 38     env = getEnv();
 39 
 40     object = inStream_readObjectRef(env, in);
 41     if (inStream_error(in)) {
 42         return JNI_TRUE;
 43     }
 44 
 45     WITH_LOCAL_REFS(env, 1) {
 46 
 47         jbyte tag;
 48         jclass clazz;
 49 
 50         clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 51         tag = referenceTypeTag(clazz);
 52 
 53         (void)outStream_writeByte(out, tag);
 54         (void)outStream_writeObjectRef(env, out, clazz);
 55 
 56     } END_WITH_LOCAL_REFS(env);
 57 
 58     return JNI_TRUE;
 59 }
 60 
 61 static jboolean
 62 getValues(PacketInputStream *in, PacketOutputStream *out)
 63 {
 64     sharedGetFieldValues(in, out, JNI_FALSE);
 65     return JNI_TRUE;
 66 }
 67 
 68 
 69 static jvmtiError
 70 readFieldValue(JNIEnv *env, PacketInputStream *in, jclass clazz,
 71                jobject object, jfieldID field, char *signature)
 72 {
 73     jvalue value;
 74     jvmtiError error;
 75 
 76     switch (signature[0]) {
 77         case JDWP_TAG(ARRAY):
 78         case JDWP_TAG(OBJECT):
 79 	case JDWP_TAG(INLINE_OBJECT):
 80             value.l = inStream_readObjectRef(env, in);
 81             JNI_FUNC_PTR(env,SetObjectField)(env, object, field, value.l);
 82             break;
 83 
 84         case JDWP_TAG(BYTE):
 85             value.b = inStream_readByte(in);
 86             JNI_FUNC_PTR(env,SetByteField)(env, object, field, value.b);
 87             break;
 88 
 89         case JDWP_TAG(CHAR):
 90             value.c = inStream_readChar(in);
 91             JNI_FUNC_PTR(env,SetCharField)(env, object, field, value.c);
 92             break;
 93 
 94         case JDWP_TAG(FLOAT):
 95             value.f = inStream_readFloat(in);
 96             JNI_FUNC_PTR(env,SetFloatField)(env, object, field, value.f);
 97             break;
 98 
 99         case JDWP_TAG(DOUBLE):
100             value.d = inStream_readDouble(in);
101             JNI_FUNC_PTR(env,SetDoubleField)(env, object, field, value.d);
102             break;
103 
104         case JDWP_TAG(INT):
105             value.i = inStream_readInt(in);
106             JNI_FUNC_PTR(env,SetIntField)(env, object, field, value.i);
107             break;
108 
109         case JDWP_TAG(LONG):
110             value.j = inStream_readLong(in);
111             JNI_FUNC_PTR(env,SetLongField)(env, object, field, value.j);
112             break;
113 
114         case JDWP_TAG(SHORT):
115             value.s = inStream_readShort(in);
116             JNI_FUNC_PTR(env,SetShortField)(env, object, field, value.s);
117             break;
118 
119         case JDWP_TAG(BOOLEAN):
120             value.z = inStream_readBoolean(in);
121             JNI_FUNC_PTR(env,SetBooleanField)(env, object, field, value.z);
122             break;
123     }
124 
125     error = JVMTI_ERROR_NONE;
126     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
127         error = AGENT_ERROR_JNI_EXCEPTION;
128     }
129 
130     return error;
131 }
132 
133 static jboolean
134 setValues(PacketInputStream *in, PacketOutputStream *out)
135 {
136     JNIEnv *env;
137     jint count;
138     jvmtiError error;
139     jobject object;
140 
141     env = getEnv();
142 
143     object = inStream_readObjectRef(env, in);
144     if (inStream_error(in)) {
145         return JNI_TRUE;
146     }
147     count = inStream_readInt(in);
148     if (inStream_error(in)) {
149         return JNI_TRUE;
150     }
151 
152     error = JVMTI_ERROR_NONE;
153 
154     WITH_LOCAL_REFS(env, count + 1) {
155 
156         jclass clazz;
157 
158         clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
159 
160         if (clazz != NULL ) {
161 
162             int i;
163 
164             for (i = 0; (i &lt; count) &amp;&amp; !inStream_error(in); i++) {
165 
166                 jfieldID field;
167                 char *signature = NULL;
168 
169                 field = inStream_readFieldID(in);
170                 if (inStream_error(in))
171                     break;
172 
173                 error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
174                 if (error != JVMTI_ERROR_NONE) {
175                     break;
176                 }
177 
178                 error = readFieldValue(env, in, clazz, object, field, signature);
179                 jvmtiDeallocate(signature);
180 
181                 if (error != JVMTI_ERROR_NONE) {
182                     break;
183                 }
184             }
185         }
186 
187         if (error != JVMTI_ERROR_NONE) {
188             outStream_setError(out, map2jdwpError(error));
189         }
190 
191     } END_WITH_LOCAL_REFS(env);
192 
193     return JNI_TRUE;
194 }
195 
196 static jboolean
197 monitorInfo(PacketInputStream *in, PacketOutputStream *out)
198 {
199     JNIEnv *env;
200     jobject object;
201 
202     env = getEnv();
203 
204     object = inStream_readObjectRef(env, in);
205     if (inStream_error(in)) {
206         return JNI_TRUE;
207     }
208 
209     WITH_LOCAL_REFS(env, 1) {
210 
211         jvmtiError error;
212         jvmtiMonitorUsage info;
213 
214         (void)memset(&amp;info, 0, sizeof(info));
215         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetObjectMonitorUsage)
216                         (gdata-&gt;jvmti, object, &amp;info);
217         if (error != JVMTI_ERROR_NONE) {
218             outStream_setError(out, map2jdwpError(error));
219         } else {
220             int i;
221             (void)outStream_writeObjectRef(env, out, info.owner);
222             (void)outStream_writeInt(out, info.entry_count);
223             (void)outStream_writeInt(out, info.waiter_count);
224             for (i = 0; i &lt; info.waiter_count; i++) {
225                 (void)outStream_writeObjectRef(env, out, info.waiters[i]);
226             }
227         }
228 
229         if (info.waiters != NULL )
230             jvmtiDeallocate(info.waiters);
231 
232     } END_WITH_LOCAL_REFS(env);
233 
234     return JNI_TRUE;
235 }
236 
237 static jboolean
238 invokeInstance(PacketInputStream *in, PacketOutputStream *out)
239 {
240     return sharedInvoke(in, out);
241 }
242 
243 static jboolean
244 disableCollection(PacketInputStream *in, PacketOutputStream *out)
245 {
246     jlong id;
247     jvmtiError error;
248 
249     id = inStream_readObjectID(in);
250     if (inStream_error(in)) {
251         return JNI_TRUE;
252     }
253 
254     error = commonRef_pin(id);
255     if (error != JVMTI_ERROR_NONE) {
256         outStream_setError(out, map2jdwpError(error));
257     }
258 
259     return JNI_TRUE;
260 }
261 
262 static jboolean
263 enableCollection(PacketInputStream *in, PacketOutputStream *out)
264 {
265     jvmtiError error;
266     jlong id;
267 
268     id = inStream_readObjectID(in);
269     if (inStream_error(in)) {
270         return JNI_TRUE;
271     }
272 
273     error = commonRef_unpin(id);
274     if (error != JVMTI_ERROR_NONE) {
275         outStream_setError(out, map2jdwpError(error));
276     }
277 
278     return JNI_TRUE;
279 }
280 
281 static jboolean
282 isCollected(PacketInputStream *in, PacketOutputStream *out)
283 {
284     jobject ref;
285     jlong id;
286     JNIEnv *env;
287 
288     env = getEnv();
289     id = inStream_readObjectID(in);
290     if (inStream_error(in)) {
291         return JNI_TRUE;
292     }
293 
294     if (id == NULL_OBJECT_ID) {
295         outStream_setError(out, JDWP_ERROR(INVALID_OBJECT));
296         return JNI_TRUE;
297     }
298 
299     ref = commonRef_idToRef(env, id);
300     (void)outStream_writeBoolean(out, (jboolean)(ref == NULL));
301 
302     commonRef_idToRef_delete(env, ref);
303 
304     return JNI_TRUE;
305 }
306 
307 
308 static jboolean
309 referringObjects(PacketInputStream *in, PacketOutputStream *out)
310 {
311     jobject object;
312     jint    maxReferrers;
313     JNIEnv *env;
314 
315     env = getEnv();
316 
317     if (gdata-&gt;vmDead) {
318         outStream_setError(out, JDWP_ERROR(VM_DEAD));
319         return JNI_TRUE;
320     }
321 
322     object = inStream_readObjectRef(env,in);
323     if (inStream_error(in)) {
324         return JNI_TRUE;
325     }
326 
327     maxReferrers = inStream_readInt(in);
328     if (inStream_error(in)) {
329         return JNI_TRUE;
330     }
331 
332     WITH_LOCAL_REFS(env, 1) {
333         jvmtiError   error;
334         ObjectBatch  referrerBatch;
335 
336         error = objectReferrers(object, &amp;referrerBatch, maxReferrers);
337         if (error != JVMTI_ERROR_NONE) {
338             outStream_setError(out, map2jdwpError(error));
339         } else {
340             int kk;
341 
342             (void)outStream_writeInt(out, referrerBatch.count);
343             for (kk = 0; kk &lt; referrerBatch.count; kk++) {
344                 jobject ref;
345 
346                 ref = referrerBatch.objects[kk];
347                 (void)outStream_writeByte(out, specificTypeKey(env, ref));
348                 (void)outStream_writeObjectRef(env, out, ref);
349             }
350             jvmtiDeallocate(referrerBatch.objects);
351         }
352     } END_WITH_LOCAL_REFS(env);
353     return JNI_TRUE;
354 }
355 
356 Command ObjectReference_Commands[] = {
357     {referenceType, &quot;ReferenceType&quot;},
358     {getValues, &quot;GetValues&quot;},
359     {setValues, &quot;SetValues&quot;},
360     {NULL, &quot;&lt;unused&gt;&quot;},
361     {monitorInfo, &quot;MonitorInfo&quot;},
362     {invokeInstance, &quot;InvokeInstance&quot;},
363     {disableCollection, &quot;DisableCollection&quot;},
364     {enableCollection, &quot;EnableCollection&quot;},
365     {isCollected, &quot;IsCollected&quot;},
366     {referringObjects, &quot;ReferringObjects&quot;}
367 };
368 
369 DEBUG_DISPATCH_DEFINE_CMDSET(ObjectReference)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdwp.agent/share/native/libjdwp/eventHandler.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 /*
  26  * eventHandler
  27  *
  28  * This module handles events as they come in directly from JVMTI
  29  * and also maps them to JDI events.  JDI events are those requested
  30  * at the JDI or JDWP level and seen on those levels.  Mapping is
  31  * one-to-many, a JVMTI event may map to several JDI events, or
  32  * to none.  Part of that mapping process is filteration, which
  33  * eventFilter sub-module handles.  A JDI EventRequest corresponds
  34  * to a HandlerNode and a JDI filter to the hidden HandlerNode data
  35  * used by eventFilter.  For example, if at the JDI level the user
  36  * executed:
  37  *
  38  *   EventRequestManager erm = vm.eventRequestManager();
  39  *   BreakpointRequest bp = erm.createBreakpointRequest();
  40  *   bp.enable();
  41  *   ClassPrepareRequest req = erm.createClassPrepareRequest();
  42  *   req.enable();
  43  *   req = erm.createClassPrepareRequest();
  44  *   req.addClassFilter(&quot;Foo*&quot;);
  45  *   req.enable();
  46  *
  47  * Three handlers would be created, the first with a LocationOnly
  48  * filter and the last with a ClassMatch  filter.
  49  * When a JVMTI class prepare event for &quot;Foobar&quot;
  50  * comes in, the second handler will create one JDI event, the
  51  * third handler will compare the class signature, and since
  52  * it matchs create a second event.  There may also be internal
  53  * events as there are in this case, one created by the front-end
  54  * and one by the back-end.
  55  *
  56  * Each event kind has a handler chain, which is a doublely linked
  57  * list of handlers for that kind of event.
  58  */
  59 #include &quot;util.h&quot;
  60 #include &quot;eventHandler.h&quot;
  61 #include &quot;eventHandlerRestricted.h&quot;
  62 #include &quot;eventFilter.h&quot;
  63 #include &quot;eventFilterRestricted.h&quot;
  64 #include &quot;standardHandlers.h&quot;
  65 #include &quot;threadControl.h&quot;
  66 #include &quot;eventHelper.h&quot;
  67 #include &quot;classTrack.h&quot;
  68 #include &quot;commonRef.h&quot;
  69 #include &quot;debugLoop.h&quot;
  70 #include &quot;signature.h&quot;
  71 
  72 static HandlerID requestIdCounter;
  73 static jbyte currentSessionID;
  74 
  75 /* Counter of active callbacks and flag for vm_death */
  76 static int      active_callbacks   = 0;
  77 static jboolean vm_death_callback_active = JNI_FALSE;
  78 static jrawMonitorID callbackLock;
  79 static jrawMonitorID callbackBlock;
  80 
  81 /* Macros to surround callback code (non-VM_DEATH callbacks).
  82  *   Note that this just keeps a count of the non-VM_DEATH callbacks that
  83  *   are currently active, it does not prevent these callbacks from
  84  *   operating in parallel. It&#39;s the VM_DEATH callback that will wait
  85  *   for all these callbacks to finish up, so that it can report the
  86  *   VM_DEATH in a clean state.
  87  *   If the VM_DEATH callback is active in the BEGIN macro then this
  88  *   callback just blocks until released by the VM_DEATH callback.
  89  *   If the VM_DEATH callback is active in the END macro, then this
  90  *   callback will notify the VM_DEATH callback if it&#39;s the last one,
  91  *   and then block until released by the VM_DEATH callback.
  92  *   Why block? These threads are often the threads of the Java program,
  93  *   not blocking might mean that a return would continue execution of
  94  *   some java thread in the middle of VM_DEATH, this seems troubled.
  95  *
  96  *   WARNING: No not &#39;return&#39; or &#39;goto&#39; out of the BEGIN_CALLBACK/END_CALLBACK
  97  *            block, this will mess up the count.
  98  */
  99 
 100 #define BEGIN_CALLBACK()                                                \
 101 { /* BEGIN OF CALLBACK */                                               \
 102     jboolean bypass = JNI_TRUE;                                         \
 103     debugMonitorEnter(callbackLock); {                                  \
 104         if (vm_death_callback_active) {                                 \
 105             /* allow VM_DEATH callback to finish */                     \
 106             debugMonitorExit(callbackLock);                             \
 107             /* Now block because VM is about to die */                  \
 108             debugMonitorEnter(callbackBlock);                           \
 109             debugMonitorExit(callbackBlock);                            \
 110         } else {                                                        \
 111             active_callbacks++;                                         \
 112             bypass = JNI_FALSE;                                         \
 113             debugMonitorExit(callbackLock);                             \
 114         }                                                               \
 115     }                                                                   \
 116     if ( !bypass ) {                                                    \
 117         /* BODY OF CALLBACK CODE */
 118 
 119 #define END_CALLBACK() /* Part of bypass if body */                     \
 120         debugMonitorEnter(callbackLock); {                              \
 121             active_callbacks--;                                         \
 122             if (active_callbacks &lt; 0) {                                 \
 123                 EXIT_ERROR(0, &quot;Problems tracking active callbacks&quot;);    \
 124             }                                                           \
 125             if (vm_death_callback_active) {                             \
 126                 if (active_callbacks == 0) {                            \
 127                     debugMonitorNotifyAll(callbackLock);                \
 128                 }                                                       \
 129                 /* allow VM_DEATH callback to finish */                 \
 130                 debugMonitorExit(callbackLock);                         \
 131                 /* Now block because VM is about to die */              \
 132                 debugMonitorEnter(callbackBlock);                       \
 133                 debugMonitorExit(callbackBlock);                        \
 134             } else {                                                    \
 135                 debugMonitorExit(callbackLock);                         \
 136             }                                                           \
 137         }                                                               \
 138     }                                                                   \
 139 } /* END OF CALLBACK */
 140 
 141 /*
 142  * We are starting with a very simple locking scheme
 143  * for event handling.  All readers and writers of data in
 144  * the handlers[] chain must own this lock for the duration
 145  * of its use. If contention becomes a problem, we can:
 146  *
 147  * 1) create a lock per event type.
 148  * 2) move to a readers/writers approach where multiple threads
 149  * can access the chains simultaneously while reading (the
 150  * normal activity of an event callback).
 151  */
 152 static jrawMonitorID handlerLock;
 153 
 154 typedef struct HandlerChain_ {
 155     HandlerNode *first;
 156     /* add lock here */
 157 } HandlerChain;
 158 
 159 /*
 160  * This array maps event kinds to handler chains.
 161  * Protected by handlerLock.
 162  */
 163 
 164 static HandlerChain __handlers[EI_max-EI_min+1];
 165 
 166 /* Given a HandlerNode, these access our private data.
 167  */
 168 #define PRIVATE_DATA(node) \
 169        (&amp;(((EventHandlerRestricted_HandlerNode*)(void*)(node))-&gt;private_ehpd))
 170 
 171 #define NEXT(node) (PRIVATE_DATA(node)-&gt;private_next)
 172 #define PREV(node) (PRIVATE_DATA(node)-&gt;private_prev)
 173 #define CHAIN(node) (PRIVATE_DATA(node)-&gt;private_chain)
 174 #define HANDLER_FUNCTION(node) (PRIVATE_DATA(node)-&gt;private_handlerFunction)
 175 
 176 static jclass getObjectClass(jobject object);
 177 static jvmtiError freeHandler(HandlerNode *node);
 178 
 179 static jvmtiError freeHandlerChain(HandlerChain *chain);
 180 
 181 static HandlerChain *
 182 getHandlerChain(EventIndex i)
 183 {
 184     if ( i &lt; EI_min || i &gt; EI_max ) {
 185         EXIT_ERROR(AGENT_ERROR_INVALID_EVENT_TYPE,&quot;bad index for handler&quot;);
 186     }
 187     return &amp;(__handlers[i-EI_min]);
 188 }
 189 
 190 static void
 191 insert(HandlerChain *chain, HandlerNode *node)
 192 {
 193     HandlerNode *oldHead = chain-&gt;first;
 194     NEXT(node) = oldHead;
 195     PREV(node) = NULL;
 196     CHAIN(node) = chain;
 197     if (oldHead != NULL) {
 198         PREV(oldHead) = node;
 199     }
 200     chain-&gt;first = node;
 201 }
 202 
 203 static HandlerNode *
 204 findInChain(HandlerChain *chain, HandlerID handlerID)
 205 {
 206     HandlerNode *node = chain-&gt;first;
 207     while (node != NULL) {
 208         if (node-&gt;handlerID == handlerID) {
 209             return node;
 210         }
 211         node = NEXT(node);
 212     }
 213     return NULL;
 214 }
 215 
 216 static HandlerNode *
 217 find(EventIndex ei, HandlerID handlerID)
 218 {
 219     return findInChain(getHandlerChain(ei), handlerID);
 220 }
 221 
 222 /**
 223  * Deinsert.  Safe for non-inserted nodes.
 224  */
 225 static void
 226 deinsert(HandlerNode *node)
 227 {
 228     HandlerChain *chain = CHAIN(node);
 229 
 230     if (chain == NULL) {
 231         return;
 232     }
 233     if (chain-&gt;first == node) {
 234         chain-&gt;first = NEXT(node);
 235     }
 236     if (NEXT(node) != NULL) {
 237         PREV(NEXT(node)) = PREV(node);
 238     }
 239     if (PREV(node) != NULL) {
 240         NEXT(PREV(node)) = NEXT(node);
 241     }
 242     CHAIN(node) = NULL;
 243 }
 244 
 245 jboolean
 246 eventHandlerRestricted_iterator(EventIndex ei,
 247                               IteratorFunction func, void *arg)
 248 {
 249     HandlerChain *chain;
 250     HandlerNode *node;
 251     JNIEnv *env;
 252 
 253     chain = getHandlerChain(ei);
 254     node = chain-&gt;first;
 255     env = getEnv();
 256 
 257     if ( func == NULL ) {
 258         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;iterator function NULL&quot;);
 259     }
 260 
 261     while (node != NULL) {
 262         if (((func)(env, node, arg))) {
 263             return JNI_TRUE;
 264         }
 265         node = NEXT(node);
 266     }
 267     return JNI_FALSE;
 268 }
 269 
 270 /* BREAKPOINT, METHOD_ENTRY and SINGLE_STEP events are covered by
 271  * the co-location of events policy. Of these three co-located
 272  * events, METHOD_ENTRY is  always reported first and BREAKPOINT
 273  * is always reported last. Here are the possible combinations and
 274  * their order:
 275  *
 276  * (p1) METHOD_ENTRY, BREAKPOINT (existing)
 277  * (p2) METHOD_ENTRY, BREAKPOINT (new)
 278  * (p1) METHOD_ENTRY, SINGLE_STEP
 279  * (p1) METHOD_ENTRY, SINGLE_STEP, BREAKPOINT (existing)
 280  * (p1/p2) METHOD_ENTRY, SINGLE_STEP, BREAKPOINT (new)
 281  * (p1) SINGLE_STEP, BREAKPOINT (existing)
 282  * (p2) SINGLE_STEP, BREAKPOINT (new)
 283  *
 284  * BREAKPOINT (existing) indicates a BREAKPOINT that is set before
 285  * the other co-located event is posted. BREAKPOINT (new) indicates
 286  * a BREAKPOINT that is set after the other co-located event is
 287  * posted and before the thread has resumed execution.
 288  *
 289  * Co-location of events policy used to be implemented via
 290  * temporary BREAKPOINTs along with deferring the reporting of
 291  * non-BREAKPOINT co-located events, but the temporary BREAKPOINTs
 292  * caused performance problems on VMs where setting or clearing
 293  * BREAKPOINTs is expensive, e.g., HotSpot.
 294  *
 295  * The policy is now implemented in two phases. Phase 1: when a
 296  * METHOD_ENTRY or SINGLE_STEP event is received, if there is an
 297  * existing co-located BREAKPOINT, then the current event is
 298  * deferred. When the BREAKPOINT event is processed, the event
 299  * bag will contain the deferred METHOD_ENTRY and/or SINGLE_STEP
 300  * events along with the BREAKPOINT event. For a METHOD_ENTRY
 301  * event where there is not an existing co-located BREAKPOINT,
 302  * if SINGLE_STEP events are also enabled for the thread, then
 303  * the METHOD_ENTRY event is deferred. When the SINGLE_STEP event
 304  * is processed, the event bag will also contain the deferred
 305  * METHOD_ENTRY event. This covers each of the combinations
 306  * marked with &#39;p1&#39; above.
 307  *
 308  * Phase 2: if there is no existing co-located BREAKPOINT, then the
 309  * location information for the METHOD_ENTRY or SINGLE_STEP event
 310  * is recorded in the ThreadNode. If the next event for the thread
 311  * is a co-located BREAKPOINT, then the first BREAKPOINT event will
 312  * be skipped since it cannot be delivered in the same event set.
 313  * This covers each of the combinations marked with &#39;p2&#39; above.
 314  *
 315  * For the combination marked p1/p2, part of the case is handled
 316  * during phase 1 and the rest is handled during phase 2.
 317  *
 318  * The recording of information in the ThreadNode is handled in
 319  * this routine. The special handling of the next event for the
 320  * thread is handled in skipEventReport().
 321  */
 322 
 323 static jboolean
 324 deferEventReport(JNIEnv *env, jthread thread,
 325             EventIndex ei, jclass clazz, jmethodID method, jlocation location)
 326 {
 327     jboolean deferring = JNI_FALSE;
 328 
 329     switch (ei) {
 330         case EI_METHOD_ENTRY:
 331             if (!isMethodNative(method)) {
 332                 jvmtiError error;
 333                 jlocation start;
 334                 jlocation end;
 335                 error = methodLocation(method, &amp;start, &amp;end);
 336                 if (error == JVMTI_ERROR_NONE) {
 337                     deferring = isBreakpointSet(clazz, method, start) ||
 338                                 threadControl_getInstructionStepMode(thread)
 339                                     == JVMTI_ENABLE;
 340                     if (!deferring) {
 341                         threadControl_saveCLEInfo(env, thread, ei,
 342                                                   clazz, method, start);
 343                     }
 344                 }
 345             }
 346             break;
 347         case EI_SINGLE_STEP:
 348             deferring = isBreakpointSet(clazz, method, location);
 349             if (!deferring) {
 350                 threadControl_saveCLEInfo(env, thread, ei,
 351                                           clazz, method, location);
 352             }
 353             break;
 354         default:
 355             break;
 356     }
 357     /* TO DO: Once JVMTI supports a way to know if we&#39;re
 358      * at the end of a method, we should check here for
 359      * break and step events which precede a method exit
 360      * event.
 361      */
 362     return deferring;
 363 }
 364 
 365 /* Handle phase 2 of the co-located events policy. See detailed
 366  * comments in deferEventReport() above.
 367  */
 368 static jboolean
 369 skipEventReport(JNIEnv *env, jthread thread, EventIndex ei,
 370                         jclass clazz, jmethodID method, jlocation location)
 371 {
 372     jboolean skipping = JNI_FALSE;
 373 
 374     if (ei == EI_BREAKPOINT) {
 375         if (threadControl_cmpCLEInfo(env, thread, clazz, method, location)) {
 376             LOG_MISC((&quot;Co-located breakpoint event found: &quot;
 377                 &quot;%s,thread=%p,clazz=%p,method=%p,location=%d&quot;,
 378                 eventText(ei), thread, clazz, method, location));
 379             skipping = JNI_TRUE;
 380         }
 381     }
 382 
 383     threadControl_clearCLEInfo(env, thread);
 384 
 385     return skipping;
 386 }
 387 
 388 static void
 389 reportEvents(JNIEnv *env, jbyte sessionID, jthread thread, EventIndex ei,
 390              jclass clazz, jmethodID method, jlocation location,
 391              struct bag *eventBag)
 392 {
 393     jbyte suspendPolicy;
 394     jboolean invoking;
 395 
 396     if (bagSize(eventBag) &lt; 1) {
 397         return;
 398     }
 399 
 400     /*
 401      * Never report events before initialization completes
 402      */
 403     if (!debugInit_isInitComplete()) {
 404         return;
 405     }
 406 
 407     /*
 408      * Check to see if we should skip reporting this event due to
 409      * co-location of events policy.
 410      */
 411     if (thread != NULL &amp;&amp;
 412            skipEventReport(env, thread, ei, clazz, method, location)) {
 413         LOG_MISC((&quot;event report being skipped: &quot;
 414             &quot;ei=%s,thread=%p,clazz=%p,method=%p,location=%d&quot;,
 415             eventText(ei), thread, clazz, method, location));
 416         bagDeleteAll(eventBag);
 417         return;
 418     }
 419 
 420     /* We delay the reporting of some events so that they can be
 421      * properly grouped into event sets with upcoming events. If
 422      * the reporting is to be deferred, the event commands remain
 423      * in the event bag until a subsequent event occurs.  Event is
 424      * NULL for synthetic events (e.g. unload).
 425      */
 426     if (thread == NULL
 427          || !deferEventReport(env, thread, ei,
 428                         clazz, method, location)) {
 429         struct bag *completedBag = bagDup(eventBag);
 430         bagDeleteAll(eventBag);
 431         if (completedBag == NULL) {
 432             /*
 433              * TO DO: Report, but don&#39;t terminate?
 434              */
 435             return;
 436         } else {
 437             suspendPolicy = eventHelper_reportEvents(sessionID, completedBag);
 438             if (thread != NULL &amp;&amp; suspendPolicy != JDWP_SUSPEND_POLICY(NONE)) {
 439                 do {
 440                     /* The events have been reported and this
 441                      * thread is about to continue, but it may
 442                      * have been started up just to perform a
 443                      * requested method invocation. If so, we do
 444                      * the invoke now and then stop again waiting
 445                      * for another continue. By then another
 446                      * invoke request can be in place, so there is
 447                      * a loop around this code.
 448                      */
 449                     invoking = invoker_doInvoke(thread);
 450                     if (invoking) {
 451                         eventHelper_reportInvokeDone(sessionID, thread);
 452                     }
 453                 } while (invoking);
 454             }
 455             bagDestroyBag(completedBag);
 456         }
 457     }
 458 }
 459 
 460 /* A bagEnumerateFunction.  Create a synthetic class unload event
 461  * for every class no longer present.  Analogous to event_callback
 462  * combined with a handler in a unload specific (no event
 463  * structure) kind of way.
 464  */
 465 static jboolean
 466 synthesizeUnloadEvent(void *signatureVoid, void *envVoid)
 467 {
 468     JNIEnv *env = (JNIEnv *)envVoid;
 469     char *signature = *(char **)signatureVoid;
 470     char *classname;
 471     HandlerNode *node;
 472     jbyte eventSessionID = currentSessionID;
 473     struct bag *eventBag = eventHelper_createEventBag();
 474 
 475     /* TO DO: Report null error, but don&#39;t die */
 476     JDI_ASSERT(eventBag != NULL);
 477 
 478     /* Signature needs to last, so convert extra copy to
 479      * classname
 480      */
 481     classname = jvmtiAllocate((int)strlen(signature)+1);
 482     (void)strcpy(classname, signature);
 483     convertSignatureToClassname(classname);
 484 
 485     debugMonitorEnter(handlerLock);
 486 
 487     node = getHandlerChain(EI_GC_FINISH)-&gt;first;
 488     while (node != NULL) {
 489         /* save next so handlers can remove themselves */
 490         HandlerNode *next = NEXT(node);
 491         jboolean shouldDelete;
 492 
 493         if (eventFilterRestricted_passesUnloadFilter(env, classname,
 494                                                      node,
 495                                                      &amp;shouldDelete)) {
 496             /* There may be multiple handlers, the signature will
 497              * be freed when the event helper thread has written
 498              * it.  So each event needs a separate allocation.
 499              */
 500             char *durableSignature = jvmtiAllocate((int)strlen(signature)+1);
 501             (void)strcpy(durableSignature, signature);
 502 
 503             eventHelper_recordClassUnload(node-&gt;handlerID,
 504                                           durableSignature,
 505                                           eventBag);
 506         }
 507         if (shouldDelete) {
 508             /* We can safely free the node now that we are done
 509              * using it.
 510              */
 511             (void)freeHandler(node);
 512         }
 513         node = next;
 514     }
 515 
 516     debugMonitorExit(handlerLock);
 517 
 518     if (eventBag != NULL) {
 519         reportEvents(env, eventSessionID, (jthread)NULL, 0,
 520                             (jclass)NULL, (jmethodID)NULL, 0, eventBag);
 521 
 522         /*
 523          * bag was created locally, destroy it here.
 524          */
 525         bagDestroyBag(eventBag);
 526     }
 527 
 528     jvmtiDeallocate(signature);
 529     jvmtiDeallocate(classname);
 530 
 531     return JNI_TRUE;
 532 }
 533 
 534 /* Garbage Collection Happened */
 535 static unsigned int garbageCollected = 0;
 536 
 537 /* The JVMTI generic event callback. Each event is passed to a sequence of
 538  * handlers in a chain until the chain ends or one handler
 539  * consumes the event.
 540  */
 541 static void
 542 event_callback(JNIEnv *env, EventInfo *evinfo)
 543 {
 544     struct bag *eventBag;
 545     jbyte eventSessionID = currentSessionID; /* session could change */
 546     jthrowable currentException;
 547     jthread thread;
 548 
 549     LOG_MISC((&quot;event_callback(): ei=%s&quot;, eventText(evinfo-&gt;ei)));
 550     log_debugee_location(&quot;event_callback()&quot;, evinfo-&gt;thread, evinfo-&gt;method, evinfo-&gt;location);
 551 
 552     /* We want to preserve any current exception that might get
 553      * wiped out during event handling (e.g. JNI calls). We have
 554      * to rely on space for the local reference on the current
 555      * frame because doing a PushLocalFrame here might itself
 556      * generate an exception.
 557      */
 558     currentException = JNI_FUNC_PTR(env,ExceptionOccurred)(env);
 559     JNI_FUNC_PTR(env,ExceptionClear)(env);
 560 
 561     /* See if a garbage collection finish event happened earlier.
 562      *
 563      * Note: The &quot;if&quot; is an optimization to avoid entering the lock on every
 564      *       event; garbageCollected may be zapped before we enter
 565      *       the lock but then this just becomes one big no-op.
 566      */
 567     if ( garbageCollected &gt; 0 ) {
 568         struct bag *unloadedSignatures = NULL;
 569 
 570         /* We want to compact the hash table of all
 571          * objects sent to the front end by removing objects that have
 572          * been collected.
 573          */
 574         commonRef_compact();
 575 
 576         /* We also need to simulate the class unload events. */
 577 
 578         debugMonitorEnter(handlerLock);
 579 
 580         /* Clear garbage collection counter */
 581         garbageCollected = 0;
 582 
 583         /* Analyze which class unloads occurred */
 584         unloadedSignatures = classTrack_processUnloads(env);
 585 
 586         debugMonitorExit(handlerLock);
 587 
 588         /* Generate the synthetic class unload events and/or just cleanup.  */
 589         if ( unloadedSignatures != NULL ) {
 590             (void)bagEnumerateOver(unloadedSignatures, synthesizeUnloadEvent,
 591                              (void *)env);
 592             bagDestroyBag(unloadedSignatures);
 593         }
 594     }
 595 
 596     thread = evinfo-&gt;thread;
 597     if (thread != NULL) {
 598         /*
 599          * Record the fact that we&#39;re entering an event
 600          * handler so that thread operations (status, interrupt,
 601          * stop) can be done correctly and so that thread
 602          * resources can be allocated.  This must be done before
 603          * grabbing any locks.
 604          */
 605         eventBag = threadControl_onEventHandlerEntry(eventSessionID,
 606                                  evinfo-&gt;ei, thread, currentException);
 607         if ( eventBag == NULL ) {
 608             jboolean invoking;
 609             do {
 610                 /* The event has been &#39;handled&#39; and this
 611                  * thread is about to continue, but it may
 612                  * have been started up just to perform a
 613                  * requested method invocation. If so, we do
 614                  * the invoke now and then stop again waiting
 615                  * for another continue. By then another
 616                  * invoke request can be in place, so there is
 617                  * a loop around this code.
 618                  */
 619                 invoking = invoker_doInvoke(thread);
 620                 if (invoking) {
 621                     eventHelper_reportInvokeDone(eventSessionID, thread);
 622                 }
 623             } while (invoking);
 624             return; /* Do nothing, event was consumed */
 625         }
 626     } else {
 627         eventBag = eventHelper_createEventBag();
 628         if (eventBag == NULL) {
 629             /*
 630              * TO DO: Report, but don&#39;t die
 631              */
 632             eventBag = NULL;  /* to shut up lint */
 633         }
 634     }
 635 
 636     debugMonitorEnter(handlerLock);
 637     {
 638         HandlerNode *node;
 639         char        *classname;
 640 
 641         /* We must keep track of all classes prepared to know what&#39;s unloaded */
 642         if (evinfo-&gt;ei == EI_CLASS_PREPARE) {
 643             classTrack_addPreparedClass(env, evinfo-&gt;clazz);
 644         }
 645 
 646         node = getHandlerChain(evinfo-&gt;ei)-&gt;first;
 647         classname = getClassname(evinfo-&gt;clazz);
 648 
 649         while (node != NULL) {
 650             /* save next so handlers can remove themselves */
 651             HandlerNode *next = NEXT(node);
 652             jboolean shouldDelete;
 653 
 654             if (eventFilterRestricted_passesFilter(env, classname,
 655                                                    evinfo, node,
 656                                                    &amp;shouldDelete)) {
 657                 HandlerFunction func;
 658 
 659                 func = HANDLER_FUNCTION(node);
 660                 if ( func == NULL ) {
 661                     EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;handler function NULL&quot;);
 662                 }
 663                 (*func)(env, evinfo, node, eventBag);
 664             }
 665             if (shouldDelete) {
 666                 /* We can safely free the node now that we are done
 667                  * using it.
 668                  */
 669                 (void)freeHandler(node);
 670             }
 671             node = next;
 672         }
 673         jvmtiDeallocate(classname);
 674     }
 675     debugMonitorExit(handlerLock);
 676 
 677     if (eventBag != NULL) {
 678         reportEvents(env, eventSessionID, thread, evinfo-&gt;ei,
 679                 evinfo-&gt;clazz, evinfo-&gt;method, evinfo-&gt;location, eventBag);
 680     }
 681 
 682     /* we are continuing after VMDeathEvent - now we are dead */
 683     if (evinfo-&gt;ei == EI_VM_DEATH) {
 684         gdata-&gt;vmDead = JNI_TRUE;
 685     }
 686 
 687     /*
 688      * If the bag was created locally, destroy it here.
 689      */
 690     if (thread == NULL) {
 691         bagDestroyBag(eventBag);
 692     }
 693 
 694     /* Always restore any exception that was set beforehand.  If
 695      * there is a pending async exception, StopThread will be
 696      * called from threadControl_onEventHandlerExit immediately
 697      * below.  Depending on VM implementation and state, the async
 698      * exception might immediately overwrite the currentException,
 699      * or it might be delayed until later.  */
 700     if (currentException != NULL) {
 701         JNI_FUNC_PTR(env,Throw)(env, currentException);
 702     } else {
 703         JNI_FUNC_PTR(env,ExceptionClear)(env);
 704     }
 705 
 706     /*
 707      * Release thread resources and perform any delayed operations.
 708      */
 709     if (thread != NULL) {
 710         threadControl_onEventHandlerExit(evinfo-&gt;ei, thread, eventBag);
 711     }
 712 }
 713 
 714 /* Returns a local ref to the declaring class for an object. */
 715 static jclass
 716 getObjectClass(jobject object)
 717 {
 718     jclass clazz;
 719     JNIEnv *env = getEnv();
 720 
 721     clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 722 
 723     return clazz;
 724 }
 725 
 726 /* Returns a local ref to the declaring class for a method, or NULL. */
 727 jclass
 728 getMethodClass(jvmtiEnv *jvmti_env, jmethodID method)
 729 {
 730     jclass clazz = NULL;
 731     jvmtiError error;
 732 
 733     if ( method == NULL ) {
 734         return NULL;
 735     }
 736     error = methodClass(method, &amp;clazz);
 737     if ( error != JVMTI_ERROR_NONE ) {
 738         EXIT_ERROR(error,&quot;Can&#39;t get jclass for a methodID, invalid?&quot;);
 739         return NULL;
 740     }
 741     return clazz;
 742 }
 743 
 744 /* Event callback for JVMTI_EVENT_SINGLE_STEP */
 745 static void JNICALL
 746 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv *env,
 747                         jthread thread, jmethodID method, jlocation location)
 748 {
 749     EventInfo info;
 750 
 751     LOG_CB((&quot;cbSingleStep: thread=%p&quot;, thread));
 752 
 753     BEGIN_CALLBACK() {
 754         (void)memset(&amp;info,0,sizeof(info));
 755         info.ei         = EI_SINGLE_STEP;
 756         info.thread     = thread;
 757         info.clazz      = getMethodClass(jvmti_env, method);
 758         info.method     = method;
 759         info.location   = location;
 760         event_callback(env, &amp;info);
 761     } END_CALLBACK();
 762 
 763     LOG_MISC((&quot;END cbSingleStep&quot;));
 764 }
 765 
 766 /* Event callback for JVMTI_EVENT_BREAKPOINT */
 767 static void JNICALL
 768 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv *env,
 769                         jthread thread, jmethodID method, jlocation location)
 770 {
 771     EventInfo info;
 772 
 773     LOG_CB((&quot;cbBreakpoint: thread=%p&quot;, thread));
 774 
 775     BEGIN_CALLBACK() {
 776         (void)memset(&amp;info,0,sizeof(info));
 777         info.ei         = EI_BREAKPOINT;
 778         info.thread     = thread;
 779         info.clazz      = getMethodClass(jvmti_env, method);
 780         info.method     = method;
 781         info.location   = location;
 782         event_callback(env, &amp;info);
 783     } END_CALLBACK();
 784 
 785     LOG_MISC((&quot;END cbBreakpoint&quot;));
 786 }
 787 
 788 /* Event callback for JVMTI_EVENT_FRAME_POP */
 789 static void JNICALL
 790 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv *env,
 791                         jthread thread, jmethodID method,
 792                         jboolean wasPoppedByException)
 793 {
 794     EventInfo info;
 795 
 796     /* JDWP does not return these events when popped due to an exception. */
 797     if ( wasPoppedByException ) {
 798         return;
 799     }
 800 
 801     LOG_CB((&quot;cbFramePop: thread=%p&quot;, thread));
 802 
 803     BEGIN_CALLBACK() {
 804         (void)memset(&amp;info,0,sizeof(info));
 805         info.ei         = EI_FRAME_POP;
 806         info.thread     = thread;
 807         info.clazz      = getMethodClass(jvmti_env, method);
 808         info.method     = method;
 809         event_callback(env, &amp;info);
 810     } END_CALLBACK();
 811 
 812     LOG_MISC((&quot;END cbFramePop&quot;));
 813 }
 814 
 815 /* Event callback for JVMTI_EVENT_EXCEPTION */
 816 static void JNICALL
 817 cbException(jvmtiEnv *jvmti_env, JNIEnv *env,
 818                         jthread thread, jmethodID method,
 819                         jlocation location, jobject exception,
 820                         jmethodID catch_method, jlocation catch_location)
 821 {
 822     EventInfo info;
 823 
 824     LOG_CB((&quot;cbException: thread=%p&quot;, thread));
 825 
 826     BEGIN_CALLBACK() {
 827         (void)memset(&amp;info,0,sizeof(info));
 828         info.ei                         = EI_EXCEPTION;
 829         info.thread                     = thread;
 830         info.clazz                      = getMethodClass(jvmti_env, method);
 831         info.method                     = method;
 832         info.location                   = location;
 833         info.object                     = exception;
 834         info.u.exception.catch_clazz    = getMethodClass(jvmti_env, catch_method);
 835         info.u.exception.catch_method   = catch_method;
 836         info.u.exception.catch_location = catch_location;
 837         event_callback(env, &amp;info);
 838     } END_CALLBACK();
 839 
 840     LOG_MISC((&quot;END cbException&quot;));
 841 }
 842 
 843 /* Event callback for JVMTI_EVENT_THREAD_START */
 844 static void JNICALL
 845 cbThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread)
 846 {
 847     EventInfo info;
 848 
 849     LOG_CB((&quot;cbThreadStart: thread=%p&quot;, thread));
 850 
 851     BEGIN_CALLBACK() {
 852         (void)memset(&amp;info,0,sizeof(info));
 853         info.ei         = EI_THREAD_START;
 854         info.thread     = thread;
 855         event_callback(env, &amp;info);
 856     } END_CALLBACK();
 857 
 858     LOG_MISC((&quot;END cbThreadStart&quot;));
 859 }
 860 
 861 /* Event callback for JVMTI_EVENT_THREAD_END */
 862 static void JNICALL
 863 cbThreadEnd(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread)
 864 {
 865     EventInfo info;
 866 
 867     LOG_CB((&quot;cbThreadEnd: thread=%p&quot;, thread));
 868 
 869     BEGIN_CALLBACK() {
 870         (void)memset(&amp;info,0,sizeof(info));
 871         info.ei         = EI_THREAD_END;
 872         info.thread     = thread;
 873         event_callback(env, &amp;info);
 874     } END_CALLBACK();
 875 
 876     LOG_MISC((&quot;END cbThreadEnd&quot;));
 877 }
 878 
 879 /* Event callback for JVMTI_EVENT_CLASS_PREPARE */
 880 static void JNICALL
 881 cbClassPrepare(jvmtiEnv *jvmti_env, JNIEnv *env,
 882                         jthread thread, jclass klass)
 883 {
 884     EventInfo info;
 885 
 886     LOG_CB((&quot;cbClassPrepare: thread=%p&quot;, thread));
 887 
 888     BEGIN_CALLBACK() {
 889         (void)memset(&amp;info,0,sizeof(info));
 890         info.ei         = EI_CLASS_PREPARE;
 891         info.thread     = thread;
 892         info.clazz      = klass;
 893         event_callback(env, &amp;info);
 894     } END_CALLBACK();
 895 
 896     LOG_MISC((&quot;END cbClassPrepare&quot;));
 897 }
 898 
 899 /* Event callback for JVMTI_EVENT_GARBAGE_COLLECTION_FINISH */
 900 static void JNICALL
 901 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env)
 902 {
 903     LOG_CB((&quot;cbGarbageCollectionFinish&quot;));
 904     ++garbageCollected;
 905     LOG_MISC((&quot;END cbGarbageCollectionFinish&quot;));
 906 }
 907 
 908 /* Event callback for JVMTI_EVENT_CLASS_LOAD */
 909 static void JNICALL
 910 cbClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env,
 911                         jthread thread, jclass klass)
 912 {
 913     EventInfo info;
 914 
 915     LOG_CB((&quot;cbClassLoad: thread=%p&quot;, thread));
 916 
 917     BEGIN_CALLBACK() {
 918         (void)memset(&amp;info,0,sizeof(info));
 919         info.ei         = EI_CLASS_LOAD;
 920         info.thread     = thread;
 921         info.clazz      = klass;
 922         event_callback(env, &amp;info);
 923     } END_CALLBACK();
 924 
 925     LOG_MISC((&quot;END cbClassLoad&quot;));
 926 }
 927 
 928 /* Event callback for JVMTI_EVENT_FIELD_ACCESS */
 929 static void JNICALL
 930 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv *env,
 931                         jthread thread, jmethodID method,
 932                         jlocation location, jclass field_klass,
 933                         jobject object, jfieldID field)
 934 {
 935     EventInfo info;
 936 
 937     LOG_CB((&quot;cbFieldAccess: thread=%p&quot;, thread));
 938 
 939     BEGIN_CALLBACK() {
 940         (void)memset(&amp;info,0,sizeof(info));
 941         info.ei                         = EI_FIELD_ACCESS;
 942         info.thread                     = thread;
 943         info.clazz                      = getMethodClass(jvmti_env, method);
 944         info.method                     = method;
 945         info.location                   = location;
 946         info.u.field_access.field_clazz = field_klass;
 947         info.object                     = object;
 948         info.u.field_access.field       = field;
 949         event_callback(env, &amp;info);
 950     } END_CALLBACK();
 951 
 952     LOG_MISC((&quot;END cbFieldAccess&quot;));
 953 }
 954 
 955 /* Event callback for JVMTI_EVENT_FIELD_MODIFICATION */
 956 static void JNICALL
 957 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv *env,
 958         jthread thread, jmethodID method,
 959         jlocation location, jclass field_klass, jobject object, jfieldID field,
 960         char signature_type, jvalue new_value)
 961 {
 962     EventInfo info;
 963 
 964     LOG_CB((&quot;cbFieldModification: thread=%p&quot;, thread));
 965 
 966     BEGIN_CALLBACK() {
 967         (void)memset(&amp;info,0,sizeof(info));
 968         info.ei                                 = EI_FIELD_MODIFICATION;
 969         info.thread                             = thread;
 970         info.clazz                              = getMethodClass(jvmti_env, method);
 971         info.method                             = method;
 972         info.location                           = location;
 973         info.u.field_modification.field         = field;
 974         info.u.field_modification.field_clazz   = field_klass;
 975         info.object                             = object;
 976         info.u.field_modification.signature_type= signature_type;
 977         info.u.field_modification.new_value     = new_value;
 978         event_callback(env, &amp;info);
 979     } END_CALLBACK();
 980 
 981     LOG_MISC((&quot;END cbFieldModification&quot;));
 982 }
 983 
 984 /* Event callback for JVMTI_EVENT_EXCEPTION_CATCH */
 985 static void JNICALL
 986 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread,
 987         jmethodID method, jlocation location, jobject exception)
 988 {
 989     EventInfo info;
 990 
 991     LOG_CB((&quot;cbExceptionCatch: thread=%p&quot;, thread));
 992 
 993     BEGIN_CALLBACK() {
 994         (void)memset(&amp;info,0,sizeof(info));
 995         info.ei         = EI_EXCEPTION_CATCH;
 996         info.thread     = thread;
 997         info.clazz      = getMethodClass(jvmti_env, method);
 998         info.method     = method;
 999         info.location   = location;
1000         info.object     = exception;
1001         event_callback(env, &amp;info);
1002     } END_CALLBACK();
1003 
1004     LOG_MISC((&quot;END cbExceptionCatch&quot;));
1005 }
1006 
1007 /* Event callback for JVMTI_EVENT_METHOD_ENTRY */
1008 static void JNICALL
1009 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,
1010                         jthread thread, jmethodID method)
1011 {
1012     EventInfo info;
1013 
1014     LOG_CB((&quot;cbMethodEntry: thread=%p&quot;, thread));
1015 
1016     BEGIN_CALLBACK() {
1017         (void)memset(&amp;info,0,sizeof(info));
1018         info.ei         = EI_METHOD_ENTRY;
1019         info.thread     = thread;
1020         info.clazz      = getMethodClass(jvmti_env, method);
1021         info.method     = method;
1022         event_callback(env, &amp;info);
1023     } END_CALLBACK();
1024 
1025     LOG_MISC((&quot;END cbMethodEntry&quot;));
1026 }
1027 
1028 /* Event callback for JVMTI_EVENT_METHOD_EXIT */
1029 static void JNICALL
1030 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv *env,
1031                         jthread thread, jmethodID method,
1032                         jboolean wasPoppedByException, jvalue return_value)
1033 {
1034     EventInfo info;
1035 
1036     /* JDWP does not return these events when popped due to an exception. */
1037     if ( wasPoppedByException ) {
1038         return;
1039     }
1040 
1041     LOG_CB((&quot;cbMethodExit: thread=%p&quot;, thread));
1042 
1043     BEGIN_CALLBACK() {
1044         (void)memset(&amp;info,0,sizeof(info));
1045         info.ei         = EI_METHOD_EXIT;
1046         info.thread     = thread;
1047         info.clazz      = getMethodClass(jvmti_env, method);
1048         info.method     = method;
1049         info.u.method_exit.return_value = return_value;
1050         event_callback(env, &amp;info);
1051     } END_CALLBACK();
1052 
1053     LOG_MISC((&quot;END cbMethodExit&quot;));
1054 }
1055 
1056 /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTER */
1057 static void JNICALL
1058 cbMonitorContendedEnter(jvmtiEnv *jvmti_env, JNIEnv *env,
1059                         jthread thread, jobject object)
1060 {
1061     EventInfo info;
1062     jvmtiError error;
1063     jmethodID  method;
1064     jlocation  location;
1065 
1066     LOG_CB((&quot;cbMonitorContendedEnter: thread=%p&quot;, thread));
1067 
1068     BEGIN_CALLBACK() {
1069         (void)memset(&amp;info,0,sizeof(info));
1070         info.ei         = EI_MONITOR_CONTENDED_ENTER;
1071         info.thread     = thread;
1072         info.object     = object;
1073         /* get current location of contended monitor enter */
1074         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFrameLocation)
1075                 (gdata-&gt;jvmti, thread, 0, &amp;method, &amp;location);
1076         if (error == JVMTI_ERROR_NONE) {
1077             info.location = location;
1078             info.method   = method;
1079             info.clazz    = getMethodClass(jvmti_env, method);
1080         } else {
1081             info.location = -1;
1082         }
1083         event_callback(env, &amp;info);
1084     } END_CALLBACK();
1085 
1086     LOG_MISC((&quot;END cbMonitorContendedEnter&quot;));
1087 }
1088 
1089 /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTERED */
1090 static void JNICALL
1091 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv *env,
1092                         jthread thread, jobject object)
1093 {
1094     EventInfo info;
1095     jvmtiError error;
1096     jmethodID  method;
1097     jlocation  location;
1098 
1099     LOG_CB((&quot;cbMonitorContendedEntered: thread=%p&quot;, thread));
1100 
1101     BEGIN_CALLBACK() {
1102         (void)memset(&amp;info,0,sizeof(info));
1103         info.ei         = EI_MONITOR_CONTENDED_ENTERED;
1104         info.thread     = thread;
1105         info.object     = object;
1106         /* get current location of contended monitor enter */
1107         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFrameLocation)
1108                 (gdata-&gt;jvmti, thread, 0, &amp;method, &amp;location);
1109         if (error == JVMTI_ERROR_NONE) {
1110             info.location = location;
1111             info.method   = method;
1112             info.clazz    = getMethodClass(jvmti_env, method);
1113         } else {
1114             info.location = -1;
1115         }
1116         event_callback(env, &amp;info);
1117     } END_CALLBACK();
1118 
1119     LOG_MISC((&quot;END cbMonitorContendedEntered&quot;));
1120 }
1121 
1122 /* Event callback for JVMTI_EVENT_MONITOR_WAIT */
1123 static void JNICALL
1124 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv *env,
1125                         jthread thread, jobject object,
1126                         jlong timeout)
1127 {
1128     EventInfo info;
1129     jvmtiError error;
1130     jmethodID  method;
1131     jlocation  location;
1132 
1133     LOG_CB((&quot;cbMonitorWait: thread=%p&quot;, thread));
1134 
1135     BEGIN_CALLBACK() {
1136         (void)memset(&amp;info,0,sizeof(info));
1137         info.ei         = EI_MONITOR_WAIT;
1138         info.thread     = thread;
1139         info.object     = object;
1140         /* The info.clazz is used for both class filtering and for location info.
1141          * For monitor wait event the class filtering is done for class of monitor
1142          * object. So here info.clazz is set to class of monitor object here and it
1143          * is reset to class of method before writing location info.
1144          * See writeMonitorEvent in eventHelper.c
1145          */
1146         info.clazz      = getObjectClass(object);
1147         info.u.monitor.timeout = timeout;
1148 
1149         /* get location of monitor wait() method. */
1150         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFrameLocation)
1151                 (gdata-&gt;jvmti, thread, 0, &amp;method, &amp;location);
1152         if (error == JVMTI_ERROR_NONE) {
1153             info.location = location;
1154             info.method   = method;
1155         } else {
1156             info.location = -1;
1157         }
1158         event_callback(env, &amp;info);
1159     } END_CALLBACK();
1160 
1161     LOG_MISC((&quot;END cbMonitorWait&quot;));
1162 }
1163 
1164 /* Event callback for JVMTI_EVENT_MONITOR_WAIT */
1165 static void JNICALL
1166 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv *env,
1167                         jthread thread, jobject object,
1168                         jboolean timed_out)
1169 {
1170     EventInfo info;
1171     jvmtiError error;
1172     jmethodID  method;
1173     jlocation  location;
1174 
1175     LOG_CB((&quot;cbMonitorWaited: thread=%p&quot;, thread));
1176 
1177     BEGIN_CALLBACK() {
1178         (void)memset(&amp;info,0,sizeof(info));
1179         info.ei         = EI_MONITOR_WAITED;
1180         info.thread     = thread;
1181         info.object     = object;
1182         /* The info.clazz is used for both class filtering and for location info.
1183          * For monitor waited event the class filtering is done for class of monitor
1184          * object. So here info.clazz is set to class of monitor object here and it
1185          * is reset to class of method before writing location info.
1186          * See writeMonitorEvent in eventHelper.c
1187          */
1188         info.clazz      = getObjectClass(object);
1189         info.u.monitor.timed_out = timed_out;
1190 
1191         /* get location of monitor wait() method */
1192         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFrameLocation)
1193                 (gdata-&gt;jvmti, thread, 0, &amp;method, &amp;location);
1194         if (error == JVMTI_ERROR_NONE) {
1195             info.location = location;
1196             info.method   = method;
1197         } else {
1198             info.location = -1;
1199         }
1200         event_callback(env, &amp;info);
1201     } END_CALLBACK();
1202 
1203     LOG_MISC((&quot;END cbMonitorWaited&quot;));
1204 }
1205 
1206 /* Event callback for JVMTI_EVENT_VM_INIT */
1207 static void JNICALL
1208 cbVMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread)
1209 {
1210     EventInfo info;
1211 
1212     LOG_CB((&quot;cbVMInit&quot;));
1213 
1214     BEGIN_CALLBACK() {
1215         (void)memset(&amp;info,0,sizeof(info));
1216         info.ei         = EI_VM_INIT;
1217         info.thread     = thread;
1218         event_callback(env, &amp;info);
1219     } END_CALLBACK();
1220 
1221     LOG_MISC((&quot;END cbVMInit&quot;));
1222 }
1223 
1224 /* Event callback for JVMTI_EVENT_VM_DEATH */
1225 static void JNICALL
1226 cbVMDeath(jvmtiEnv *jvmti_env, JNIEnv *env)
1227 {
1228     jvmtiError error;
1229     EventInfo info;
1230     LOG_CB((&quot;cbVMDeath&quot;));
1231 
1232     /* Clear out ALL callbacks at this time, we don&#39;t want any more. */
1233     /*    This should prevent any new BEGIN_CALLBACK() calls. */
1234     (void)memset(&amp;(gdata-&gt;callbacks),0,sizeof(gdata-&gt;callbacks));
1235     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,SetEventCallbacks)
1236                 (gdata-&gt;jvmti, &amp;(gdata-&gt;callbacks), sizeof(gdata-&gt;callbacks));
1237     if (error != JVMTI_ERROR_NONE) {
1238         EXIT_ERROR(error,&quot;Can&#39;t clear event callbacks on vm death&quot;);
1239     }
1240 
1241     /* Now that no new callbacks will be made, we need to wait for the ones
1242      *   that are still active to complete.
1243      *   The BEGIN_CALLBACK/END_CALLBACK macros implement the VM_DEATH
1244      *   callback protocol. Once the callback table is cleared (above),
1245      *   we can have callback threads in different stages:
1246      *   1) after callback function entry and before BEGIN_CALLBACK
1247      *      macro; we catch these threads with callbackBlock in the
1248      *      BEGIN_CALLBACK macro
1249      *   2) after BEGIN_CALLBACK macro and before END_CALLBACK macro; we
1250      *      catch these threads with callbackBlock in the END_CALLBACK
1251      *      macro
1252      *   3) after END_CALLBACK macro; these threads have made it past
1253      *      callbackBlock and callbackLock and don&#39;t count as active
1254      *
1255      *   Since some of the callback threads could be blocked or suspended
1256      *   we will resume all threads suspended by the debugger for a short
1257      *   time to flush out all callbacks. Note that the callback threads
1258      *   will block from returning to the VM in both macros. Some threads
1259      *   not associated with callbacks, but suspended by the debugger may
1260      *   continue on, but not for long.
1261      *   Once the last callback finishes, it will notify this thread and
1262      *   we fall out of the loop below and actually process the VM_DEATH
1263      *   event.
1264      */
1265     debugMonitorEnter(callbackBlock); {
1266         debugMonitorEnter(callbackLock); {
1267             vm_death_callback_active = JNI_TRUE;
1268             (void)threadControl_resumeAll();
1269             while (active_callbacks &gt; 0) {
1270                 /* wait for active CALLBACKs to check in (and block) */
1271                 debugMonitorWait(callbackLock);
1272             }
1273         } debugMonitorExit(callbackLock);
1274 
1275         /* Only now should we actually process the VM death event */
1276         (void)memset(&amp;info,0,sizeof(info));
1277         info.ei                 = EI_VM_DEATH;
1278         event_callback(env, &amp;info);
1279 
1280         /* Here we unblock all the callbacks and let them return to the
1281          *   VM.  It&#39;s not clear this is necessary, but leaving threads
1282          *   blocked doesn&#39;t seem like a good idea. They don&#39;t have much
1283          *   life left anyway.
1284          */
1285     } debugMonitorExit(callbackBlock);
1286 
1287     /*
1288      * The VM will die soon after the completion of this callback -
1289      * we synchronize with both the command loop and the debug loop
1290      * for a more orderly shutdown.
1291      */
1292     commandLoop_sync();
1293     debugLoop_sync();
1294 
1295     LOG_MISC((&quot;END cbVMDeath&quot;));
1296 }
1297 
1298 /**
1299  * Delete this handler (do not delete permanent handlers):
1300  * Deinsert handler from active list,
1301  * make it inactive, and free it&#39;s memory
1302  * Assumes handlerLock held.
1303  */
1304 static jvmtiError
1305 freeHandler(HandlerNode *node) {
1306     jvmtiError error = JVMTI_ERROR_NONE;
1307 
1308     /* deinsert the handler node before disableEvents() to make
1309      * sure the event will be disabled when no other event
1310      * handlers are installed.
1311      */
1312     if (node != NULL &amp;&amp; (!node-&gt;permanent)) {
1313         deinsert(node);
1314         error = eventFilterRestricted_deinstall(node);
1315         jvmtiDeallocate(node);
1316     }
1317 
1318     return error;
1319 }
1320 
1321 /**
1322  * Delete all the handlers on this chain (do not delete permanent handlers).
1323  * Assumes handlerLock held.
1324  */
1325 static jvmtiError
1326 freeHandlerChain(HandlerChain *chain)
1327 {
1328     HandlerNode *node;
1329     jvmtiError   error;
1330 
1331     error = JVMTI_ERROR_NONE;
1332     node  = chain-&gt;first;
1333     while ( node != NULL ) {
1334         HandlerNode *next;
1335         jvmtiError   singleError;
1336 
1337         next = NEXT(node);
1338         singleError = freeHandler(node);
1339         if ( singleError != JVMTI_ERROR_NONE ) {
1340             error = singleError;
1341         }
1342         node = next;
1343     }
1344     return error;
1345 }
1346 
1347 /**
1348  * Deinsert and free all memory.  Safe for non-inserted nodes.
1349  */
1350 jvmtiError
1351 eventHandler_free(HandlerNode *node)
1352 {
1353     jvmtiError error;
1354 
1355     debugMonitorEnter(handlerLock);
1356 
1357     error = freeHandler(node);
1358 
1359     debugMonitorExit(handlerLock);
1360 
1361     return error;
1362 }
1363 
1364 /**
1365  * Free all handlers of this kind created by the JDWP client,
1366  * that is, doesn&#39;t free handlers internally created by back-end.
1367  */
1368 jvmtiError
1369 eventHandler_freeAll(EventIndex ei)
1370 {
1371     jvmtiError error = JVMTI_ERROR_NONE;
1372     HandlerNode *node;
1373 
1374     debugMonitorEnter(handlerLock);
1375     node = getHandlerChain(ei)-&gt;first;
1376     while (node != NULL) {
1377         HandlerNode *next = NEXT(node);    /* allows node removal */
1378         if (node-&gt;handlerID != 0) {        /* don&#39;t free internal handlers */
1379             error = freeHandler(node);
1380             if (error != JVMTI_ERROR_NONE) {
1381                 break;
1382             }
1383         }
1384         node = next;
1385     }
1386     debugMonitorExit(handlerLock);
1387     return error;
1388 }
1389 
1390 /***
1391  * Delete all breakpoints on &quot;clazz&quot;.
1392  */
1393 void
1394 eventHandler_freeClassBreakpoints(jclass clazz)
1395 {
1396     HandlerNode *node;
1397     JNIEnv *env = getEnv();
1398 
1399     debugMonitorEnter(handlerLock);
1400     node = getHandlerChain(EI_BREAKPOINT)-&gt;first;
1401     while (node != NULL) {
1402         HandlerNode *next = NEXT(node); /* allows node removal */
1403         if (eventFilterRestricted_isBreakpointInClass(env, clazz,
1404                                                       node)) {
1405             (void)freeHandler(node);
1406         }
1407         node = next;
1408     }
1409     debugMonitorExit(handlerLock);
1410 }
1411 
1412 jvmtiError
1413 eventHandler_freeByID(EventIndex ei, HandlerID handlerID)
1414 {
1415     jvmtiError error;
1416     HandlerNode *node;
1417 
1418     debugMonitorEnter(handlerLock);
1419     node = find(ei, handlerID);
1420     if (node != NULL) {
1421         error = freeHandler(node);
1422     } else {
1423         /* already freed */
1424         error = JVMTI_ERROR_NONE;
1425     }
1426     debugMonitorExit(handlerLock);
1427     return error;
1428 }
1429 
1430 void
1431 eventHandler_initialize(jbyte sessionID)
1432 {
1433     jvmtiError error;
1434     jint i;
1435 
1436     requestIdCounter = 1;
1437     currentSessionID = sessionID;
1438 
1439     /* This is for BEGIN_CALLBACK/END_CALLBACK handling, make sure this
1440      *   is done while none of these callbacks are active.
1441      */
1442     active_callbacks = 0;
1443     vm_death_callback_active = JNI_FALSE;
1444     callbackLock = debugMonitorCreate(&quot;JDWP Callback Lock&quot;);
1445     callbackBlock = debugMonitorCreate(&quot;JDWP Callback Block&quot;);
1446 
1447     handlerLock = debugMonitorCreate(&quot;JDWP Event Handler Lock&quot;);
1448 
1449     for (i = EI_min; i &lt;= EI_max; ++i) {
1450         getHandlerChain(i)-&gt;first = NULL;
1451     }
1452 
1453     /*
1454      * Permanently enabled some events.
1455      */
1456     error = threadControl_setEventMode(JVMTI_ENABLE,
1457                                       EI_VM_INIT, NULL);
1458     if (error != JVMTI_ERROR_NONE) {
1459         EXIT_ERROR(error,&quot;Can&#39;t enable vm init events&quot;);
1460     }
1461     error = threadControl_setEventMode(JVMTI_ENABLE,
1462                                       EI_VM_DEATH, NULL);
1463     if (error != JVMTI_ERROR_NONE) {
1464         EXIT_ERROR(error,&quot;Can&#39;t enable vm death events&quot;);
1465     }
1466     error = threadControl_setEventMode(JVMTI_ENABLE,
1467                                       EI_THREAD_START, NULL);
1468     if (error != JVMTI_ERROR_NONE) {
1469         EXIT_ERROR(error,&quot;Can&#39;t enable thread start events&quot;);
1470     }
1471     error = threadControl_setEventMode(JVMTI_ENABLE,
1472                                        EI_THREAD_END, NULL);
1473     if (error != JVMTI_ERROR_NONE) {
1474         EXIT_ERROR(error,&quot;Can&#39;t enable thread end events&quot;);
1475     }
1476     error = threadControl_setEventMode(JVMTI_ENABLE,
1477                                        EI_CLASS_PREPARE, NULL);
1478     if (error != JVMTI_ERROR_NONE) {
1479         EXIT_ERROR(error,&quot;Can&#39;t enable class prepare events&quot;);
1480     }
1481     error = threadControl_setEventMode(JVMTI_ENABLE,
1482                                        EI_GC_FINISH, NULL);
1483     if (error != JVMTI_ERROR_NONE) {
1484         EXIT_ERROR(error,&quot;Can&#39;t enable garbage collection finish events&quot;);
1485     }
1486 
1487     (void)memset(&amp;(gdata-&gt;callbacks),0,sizeof(gdata-&gt;callbacks));
1488     /* Event callback for JVMTI_EVENT_SINGLE_STEP */
1489     gdata-&gt;callbacks.SingleStep                 = &amp;cbSingleStep;
1490     /* Event callback for JVMTI_EVENT_BREAKPOINT */
1491     gdata-&gt;callbacks.Breakpoint                 = &amp;cbBreakpoint;
1492     /* Event callback for JVMTI_EVENT_FRAME_POP */
1493     gdata-&gt;callbacks.FramePop                   = &amp;cbFramePop;
1494     /* Event callback for JVMTI_EVENT_EXCEPTION */
1495     gdata-&gt;callbacks.Exception                  = &amp;cbException;
1496     /* Event callback for JVMTI_EVENT_THREAD_START */
1497     gdata-&gt;callbacks.ThreadStart                = &amp;cbThreadStart;
1498     /* Event callback for JVMTI_EVENT_THREAD_END */
1499     gdata-&gt;callbacks.ThreadEnd                  = &amp;cbThreadEnd;
1500     /* Event callback for JVMTI_EVENT_CLASS_PREPARE */
1501     gdata-&gt;callbacks.ClassPrepare               = &amp;cbClassPrepare;
1502     /* Event callback for JVMTI_EVENT_CLASS_LOAD */
1503     gdata-&gt;callbacks.ClassLoad                  = &amp;cbClassLoad;
1504     /* Event callback for JVMTI_EVENT_FIELD_ACCESS */
1505     gdata-&gt;callbacks.FieldAccess                = &amp;cbFieldAccess;
1506     /* Event callback for JVMTI_EVENT_FIELD_MODIFICATION */
1507     gdata-&gt;callbacks.FieldModification          = &amp;cbFieldModification;
1508     /* Event callback for JVMTI_EVENT_EXCEPTION_CATCH */
1509     gdata-&gt;callbacks.ExceptionCatch             = &amp;cbExceptionCatch;
1510     /* Event callback for JVMTI_EVENT_METHOD_ENTRY */
1511     gdata-&gt;callbacks.MethodEntry                = &amp;cbMethodEntry;
1512     /* Event callback for JVMTI_EVENT_METHOD_EXIT */
1513     gdata-&gt;callbacks.MethodExit                 = &amp;cbMethodExit;
1514     /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTER */
1515     gdata-&gt;callbacks.MonitorContendedEnter      = &amp;cbMonitorContendedEnter;
1516     /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTERED */
1517     gdata-&gt;callbacks.MonitorContendedEntered    = &amp;cbMonitorContendedEntered;
1518     /* Event callback for JVMTI_EVENT_MONITOR_WAIT */
1519     gdata-&gt;callbacks.MonitorWait                = &amp;cbMonitorWait;
1520     /* Event callback for JVMTI_EVENT_MONITOR_WAITED */
1521     gdata-&gt;callbacks.MonitorWaited              = &amp;cbMonitorWaited;
1522     /* Event callback for JVMTI_EVENT_VM_INIT */
1523     gdata-&gt;callbacks.VMInit                     = &amp;cbVMInit;
1524     /* Event callback for JVMTI_EVENT_VM_DEATH */
1525     gdata-&gt;callbacks.VMDeath                    = &amp;cbVMDeath;
1526     /* Event callback for JVMTI_EVENT_GARBAGE_COLLECTION_FINISH */
1527     gdata-&gt;callbacks.GarbageCollectionFinish    = &amp;cbGarbageCollectionFinish;
1528 
1529     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,SetEventCallbacks)
1530                 (gdata-&gt;jvmti, &amp;(gdata-&gt;callbacks), sizeof(gdata-&gt;callbacks));
1531     if (error != JVMTI_ERROR_NONE) {
1532         EXIT_ERROR(error,&quot;Can&#39;t set event callbacks&quot;);
1533     }
1534 
1535     /* Notify other modules that the event callbacks are in place */
1536     threadControl_onHook();
1537 
1538     /* Get the event helper thread initialized */
1539     eventHelper_initialize(sessionID);
1540 }
1541 
1542 void
1543 eventHandler_reset(jbyte sessionID)
1544 {
1545     int i;
1546 
1547     debugMonitorEnter(handlerLock);
1548 
1549     /* We must do this first so that if any invokes complete,
1550      * there will be no attempt to send them to the front
1551      * end. Waiting for threadControl_reset leaves a window where
1552      * the invoke completions can sneak through.
1553      */
1554     threadControl_detachInvokes();
1555 
1556     /* Reset the event helper thread, purging all queued and
1557      * in-process commands.
1558      */
1559     eventHelper_reset(sessionID);
1560 
1561     /* delete all handlers */
1562     for (i = EI_min; i &lt;= EI_max; i++) {
1563         (void)freeHandlerChain(getHandlerChain(i));
1564     }
1565 
1566     requestIdCounter = 1;
1567     currentSessionID = sessionID;
1568 
1569     debugMonitorExit(handlerLock);
1570 }
1571 
1572 void
1573 eventHandler_lock(void)
1574 {
1575     debugMonitorEnter(handlerLock);
1576 }
1577 
1578 void
1579 eventHandler_unlock(void)
1580 {
1581     debugMonitorExit(handlerLock);
1582 }
1583 
1584 /***** handler creation *****/
1585 
1586 HandlerNode *
1587 eventHandler_alloc(jint filterCount, EventIndex ei, jbyte suspendPolicy)
1588 {
1589     HandlerNode *node = eventFilterRestricted_alloc(filterCount);
1590 
1591     if (node != NULL) {
1592         node-&gt;ei = ei;
1593         node-&gt;suspendPolicy = suspendPolicy;
1594         node-&gt;permanent = JNI_FALSE;
1595     }
1596 
1597     return node;
1598 }
1599 
1600 
1601 HandlerID
1602 eventHandler_allocHandlerID(void)
1603 {
1604     jint handlerID;
1605     debugMonitorEnter(handlerLock);
1606     handlerID = ++requestIdCounter;
1607     debugMonitorExit(handlerLock);
1608     return handlerID;
1609 }
1610 
1611 
1612 static jvmtiError
1613 installHandler(HandlerNode *node,
1614               HandlerFunction func,
1615               jboolean external)
1616 {
1617     jvmtiError error;
1618 
1619     if ( func == NULL ) {
1620         return AGENT_ERROR_INVALID_EVENT_TYPE;
1621     }
1622 
1623     debugMonitorEnter(handlerLock);
1624 
1625     HANDLER_FUNCTION(node) = func;
1626 
1627     node-&gt;handlerID = external? ++requestIdCounter : 0;
1628     error = eventFilterRestricted_install(node);
1629     if (node-&gt;ei == EI_GC_FINISH) {
1630         classTrack_activate(getEnv());
1631     }
1632     if (error == JVMTI_ERROR_NONE) {
1633         insert(getHandlerChain(node-&gt;ei), node);
1634     }
1635 
1636     debugMonitorExit(handlerLock);
1637 
1638     return error;
1639 }
1640 
1641 static HandlerNode *
1642 createInternal(EventIndex ei, HandlerFunction func,
1643                jthread thread, jclass clazz, jmethodID method,
1644                jlocation location, jboolean permanent)
1645 {
1646     jint index = 0;
1647     jvmtiError error = JVMTI_ERROR_NONE;
1648     HandlerNode *node;
1649 
1650     /*
1651      * Start with necessary allocations
1652      */
1653     node = eventHandler_alloc(
1654         ((thread == NULL)? 0 : 1) + ((clazz == NULL)? 0 : 1),
1655         ei, JDWP_SUSPEND_POLICY(NONE));
1656     if (node == NULL) {
1657         return NULL;
1658     }
1659 
1660     node-&gt;permanent = permanent;
1661 
1662     if (thread != NULL) {
1663         error = eventFilter_setThreadOnlyFilter(node, index++, thread);
1664     }
1665 
1666     if ((error == JVMTI_ERROR_NONE) &amp;&amp; (clazz != NULL)) {
1667         error = eventFilter_setLocationOnlyFilter(node, index++, clazz,
1668                                                   method, location);
1669     }
1670     /*
1671      * Create the new handler node
1672      */
1673     error = installHandler(node, func, JNI_FALSE);
1674 
1675     if (error != JVMTI_ERROR_NONE) {
1676         (void)eventHandler_free(node);
1677         node = NULL;
1678     }
1679     return node;
1680 }
1681 
1682 HandlerNode *
1683 eventHandler_createPermanentInternal(EventIndex ei, HandlerFunction func)
1684 {
1685     return createInternal(ei, func, NULL,
1686                           NULL, NULL, 0, JNI_TRUE);
1687 }
1688 
1689 HandlerNode *
1690 eventHandler_createInternalThreadOnly(EventIndex ei,
1691                                       HandlerFunction func,
1692                                       jthread thread)
1693 {
1694     return createInternal(ei, func, thread,
1695                           NULL, NULL, 0, JNI_FALSE);
1696 }
1697 
1698 HandlerNode *
1699 eventHandler_createInternalBreakpoint(HandlerFunction func,
1700                                       jthread thread,
1701                                       jclass clazz,
1702                                       jmethodID method,
1703                                       jlocation location)
1704 {
1705     return createInternal(EI_BREAKPOINT, func, thread,
1706                           clazz, method, location, JNI_FALSE);
1707 }
1708 
1709 jvmtiError
1710 eventHandler_installExternal(HandlerNode *node)
1711 {
1712     return installHandler(node,
1713                           standardHandlers_defaultHandler(node-&gt;ei),
1714                           JNI_TRUE);
1715 }
    </pre>
  </body>
</html>
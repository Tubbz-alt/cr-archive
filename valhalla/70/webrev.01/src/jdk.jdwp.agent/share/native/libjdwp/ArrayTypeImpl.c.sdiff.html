<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdwp.agent/share/native/libjdwp/ArrayTypeImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayReferenceImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ClassTypeImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdwp.agent/share/native/libjdwp/ArrayTypeImpl.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;ArrayTypeImpl.h&quot;
 27 #include &quot;util.h&quot;
 28 #include &quot;inStream.h&quot;
 29 #include &quot;outStream.h&quot;


 30 
 31 /*
 32  * Determine the component class by looking thru all classes for
 33  * one that has the signature of the component and the same class loadeer
 34  * as the array.  See JVM spec 5.3.3:
 35  *     If the component type is a reference type, C is marked as having
 36  *     been defined by the defining class loader of the component type.
 37  */
 38 static jdwpError
 39 getComponentClass(JNIEnv *env, jclass arrayClass, char *componentSignature,
 40                 jclass *componentClassPtr)
 41 {
 42     jobject arrayClassLoader;
 43     jclass *classes;
 44     jint count;
 45     jclass componentClass = NULL;
 46     jdwpError serror;
 47     jvmtiError error;
 48 
 49     serror = JDWP_ERROR(NONE);
</pre>
<hr />
<pre>
131                 outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
132             } else {
133                 (void)outStream_writeByte(out, specificTypeKey(env, array));
134                 (void)outStream_writeObjectRef(env, out, array);
135             }
136 
137         }
138 
139     } END_WITH_LOCAL_REFS(env);
140 }
141 
142 static void
143 writeNewPrimitiveArray(JNIEnv *env, PacketOutputStream *out,
144                        jclass arrayClass, jint size, char *componentSignature)
145 {
146 
147     WITH_LOCAL_REFS(env, 1) {
148 
149         jarray array = NULL;
150 
<span class="line-modified">151         switch (componentSignature[0]) {</span>
152             case JDWP_TAG(BYTE):
153                 array = JNI_FUNC_PTR(env,NewByteArray)(env, size);
154                 break;
155 
156             case JDWP_TAG(CHAR):
157                 array = JNI_FUNC_PTR(env,NewCharArray)(env, size);
158                 break;
159 
160             case JDWP_TAG(FLOAT):
161                 array = JNI_FUNC_PTR(env,NewFloatArray)(env, size);
162                 break;
163 
164             case JDWP_TAG(DOUBLE):
165                 array = JNI_FUNC_PTR(env,NewDoubleArray)(env, size);
166                 break;
167 
168             case JDWP_TAG(INT):
169                 array = JNI_FUNC_PTR(env,NewIntArray)(env, size);
170                 break;
171 
</pre>
<hr />
<pre>
210     jclass arrayClass;
211     jint size;
212     jvmtiError error;
213 
214     env = getEnv();
215 
216     arrayClass = inStream_readClassRef(env, in);
217     if (inStream_error(in)) {
218         return JNI_TRUE;
219     }
220     size = inStream_readInt(in);
221     if (inStream_error(in)) {
222         return JNI_TRUE;
223     }
224 
225     error = classSignature(arrayClass, &amp;signature, NULL);
226     if ( error != JVMTI_ERROR_NONE ) {
227         outStream_setError(out, map2jdwpError(error));
228         return JNI_FALSE;
229     }
<span class="line-modified">230     componentSignature = &amp;signature[1];</span>
231 
<span class="line-modified">232     if ((componentSignature[0] == JDWP_TAG(OBJECT)) ||</span>
<span class="line-modified">233         (componentSignature[0] == JDWP_TAG(ARRAY))  ||</span>
<span class="line-removed">234 	(componentSignature[0] == JDWP_TAG(INLINE_OBJECT))) {</span>
235         writeNewObjectArray(env, out, arrayClass, size, componentSignature);
236     } else {
237         writeNewPrimitiveArray(env, out, arrayClass, size, componentSignature);
238     }
239 
240     jvmtiDeallocate(signature);
241     return JNI_TRUE;
242 }
243 
244 Command ArrayType_Commands[] = {
245     {newInstance, &quot;NewInstance&quot;}
246 };
247 
248 DEBUG_DISPATCH_DEFINE_CMDSET(ArrayType)
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;ArrayTypeImpl.h&quot;
 27 #include &quot;util.h&quot;
 28 #include &quot;inStream.h&quot;
 29 #include &quot;outStream.h&quot;
<span class="line-added"> 30 #include &quot;signature.h&quot;</span>
<span class="line-added"> 31 </span>
 32 
 33 /*
 34  * Determine the component class by looking thru all classes for
 35  * one that has the signature of the component and the same class loadeer
 36  * as the array.  See JVM spec 5.3.3:
 37  *     If the component type is a reference type, C is marked as having
 38  *     been defined by the defining class loader of the component type.
 39  */
 40 static jdwpError
 41 getComponentClass(JNIEnv *env, jclass arrayClass, char *componentSignature,
 42                 jclass *componentClassPtr)
 43 {
 44     jobject arrayClassLoader;
 45     jclass *classes;
 46     jint count;
 47     jclass componentClass = NULL;
 48     jdwpError serror;
 49     jvmtiError error;
 50 
 51     serror = JDWP_ERROR(NONE);
</pre>
<hr />
<pre>
133                 outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
134             } else {
135                 (void)outStream_writeByte(out, specificTypeKey(env, array));
136                 (void)outStream_writeObjectRef(env, out, array);
137             }
138 
139         }
140 
141     } END_WITH_LOCAL_REFS(env);
142 }
143 
144 static void
145 writeNewPrimitiveArray(JNIEnv *env, PacketOutputStream *out,
146                        jclass arrayClass, jint size, char *componentSignature)
147 {
148 
149     WITH_LOCAL_REFS(env, 1) {
150 
151         jarray array = NULL;
152 
<span class="line-modified">153         switch (jdwpTag(componentSignature)) {</span>
154             case JDWP_TAG(BYTE):
155                 array = JNI_FUNC_PTR(env,NewByteArray)(env, size);
156                 break;
157 
158             case JDWP_TAG(CHAR):
159                 array = JNI_FUNC_PTR(env,NewCharArray)(env, size);
160                 break;
161 
162             case JDWP_TAG(FLOAT):
163                 array = JNI_FUNC_PTR(env,NewFloatArray)(env, size);
164                 break;
165 
166             case JDWP_TAG(DOUBLE):
167                 array = JNI_FUNC_PTR(env,NewDoubleArray)(env, size);
168                 break;
169 
170             case JDWP_TAG(INT):
171                 array = JNI_FUNC_PTR(env,NewIntArray)(env, size);
172                 break;
173 
</pre>
<hr />
<pre>
212     jclass arrayClass;
213     jint size;
214     jvmtiError error;
215 
216     env = getEnv();
217 
218     arrayClass = inStream_readClassRef(env, in);
219     if (inStream_error(in)) {
220         return JNI_TRUE;
221     }
222     size = inStream_readInt(in);
223     if (inStream_error(in)) {
224         return JNI_TRUE;
225     }
226 
227     error = classSignature(arrayClass, &amp;signature, NULL);
228     if ( error != JVMTI_ERROR_NONE ) {
229         outStream_setError(out, map2jdwpError(error));
230         return JNI_FALSE;
231     }
<span class="line-modified">232     componentSignature = componentTypeSignature(signature);</span>
233 
<span class="line-modified">234     jbyte typeKey = jdwpTag(componentSignature);</span>
<span class="line-modified">235     if (isReferenceTag(typeKey)) {</span>

236         writeNewObjectArray(env, out, arrayClass, size, componentSignature);
237     } else {
238         writeNewPrimitiveArray(env, out, arrayClass, size, componentSignature);
239     }
240 
241     jvmtiDeallocate(signature);
242     return JNI_TRUE;
243 }
244 
245 Command ArrayType_Commands[] = {
246     {newInstance, &quot;NewInstance&quot;}
247 };
248 
249 DEBUG_DISPATCH_DEFINE_CMDSET(ArrayType)
</pre>
</td>
</tr>
</table>
<center><a href="ArrayReferenceImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ClassTypeImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
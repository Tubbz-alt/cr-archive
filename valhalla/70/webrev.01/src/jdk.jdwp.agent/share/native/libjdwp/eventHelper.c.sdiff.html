<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdwp.agent/share/native/libjdwp/eventHelper.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="eventHandler.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="inStream.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdwp.agent/share/native/libjdwp/eventHelper.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;util.h&quot;
  27 #include &quot;outStream.h&quot;
  28 #include &quot;eventHandler.h&quot;
  29 #include &quot;threadControl.h&quot;
  30 #include &quot;invoker.h&quot;

  31 
  32 
  33 #define COMMAND_LOOP_THREAD_NAME &quot;JDWP Event Helper Thread&quot;
  34 
  35 /*
  36  * Event helper thread command commandKinds
  37  */
  38 #define COMMAND_REPORT_EVENT_COMPOSITE          1
  39 #define COMMAND_REPORT_INVOKE_DONE              2
  40 #define COMMAND_REPORT_VM_INIT                  3
  41 #define COMMAND_SUSPEND_THREAD                  4
  42 
  43 /*
  44  * Event helper thread command singleKinds
  45  */
  46 #define COMMAND_SINGLE_EVENT                    11
  47 #define COMMAND_SINGLE_UNLOAD                   12
  48 #define COMMAND_SINGLE_FRAME_EVENT              13
  49 
  50 typedef struct EventCommandSingle {
</pre>
<hr />
<pre>
 462     (void)outStream_writeInt(out, command-&gt;id);
 463     (void)outStream_writeString(out, command-&gt;classSignature);
 464     jvmtiDeallocate(command-&gt;classSignature);
 465     command-&gt;classSignature = NULL;
 466 }
 467 
 468 static void
 469 handleFrameEventCommandSingle(JNIEnv* env, PacketOutputStream *out,
 470                               FrameEventCommandSingle *command)
 471 {
 472     if (command-&gt;typeKey) {
 473         (void)outStream_writeByte(out, JDWP_EVENT(METHOD_EXIT_WITH_RETURN_VALUE));
 474     } else {
 475         (void)outStream_writeByte(out, eventIndex2jdwp(command-&gt;ei));
 476     }
 477     (void)outStream_writeInt(out, command-&gt;id);
 478     (void)outStream_writeObjectRef(env, out, command-&gt;thread);
 479     writeCodeLocation(out, command-&gt;clazz, command-&gt;method, command-&gt;location);
 480     if (command-&gt;typeKey) {
 481         (void)outStream_writeValue(env, out, command-&gt;typeKey, command-&gt;returnValue);
<span class="line-modified"> 482         if (isObjectTag(command-&gt;typeKey) &amp;&amp;</span>
 483             command-&gt;returnValue.l != NULL) {
 484             tossGlobalRef(env, &amp;(command-&gt;returnValue.l));
 485         }
 486     }
 487     tossGlobalRef(env, &amp;(command-&gt;thread));
 488     tossGlobalRef(env, &amp;(command-&gt;clazz));
 489 }
 490 
 491 static void
 492 suspendWithInvokeEnabled(jbyte policy, jthread thread)
 493 {
 494     invoker_enableInvokeRequests(thread);
 495 
 496     if (policy == JDWP_SUSPEND_POLICY(ALL)) {
 497         (void)threadControl_suspendAll();
 498     } else {
 499         (void)threadControl_suspendThread(thread, JNI_FALSE);
 500     }
 501 }
 502 
</pre>
<hr />
<pre>
 834         clazz = *pclazz;
 835         *pclazz = NULL;
 836         saveGlobalRef(env, clazz, pclazz);
 837     }
 838     if ( evinfo-&gt;object != NULL ) {
 839         pobject = &amp;(evinfo-&gt;object);
 840         object = *pobject;
 841         *pobject = NULL;
 842         saveGlobalRef(env, object, pobject);
 843     }
 844 
 845     switch (evinfo-&gt;ei) {
 846         case EI_FIELD_MODIFICATION:
 847             if ( evinfo-&gt;u.field_modification.field_clazz != NULL ) {
 848                 pclazz = &amp;(evinfo-&gt;u.field_modification.field_clazz);
 849                 clazz = *pclazz;
 850                 *pclazz = NULL;
 851                 saveGlobalRef(env, clazz, pclazz);
 852             }
 853             sig = evinfo-&gt;u.field_modification.signature_type;
<span class="line-modified"> 854             if ((sig == JDWP_TAG(ARRAY)) || (sig == JDWP_TAG(OBJECT)) || (sig == JDWP_TAG(INLINE_OBJECT))) {</span>
 855                 if ( evinfo-&gt;u.field_modification.new_value.l != NULL ) {
 856                     pobject = &amp;(evinfo-&gt;u.field_modification.new_value.l);
 857                     object = *pobject;
 858                     *pobject = NULL;
 859                     saveGlobalRef(env, object, pobject);
 860                 }
 861             }
 862             break;
 863         case EI_FIELD_ACCESS:
 864             if ( evinfo-&gt;u.field_access.field_clazz != NULL ) {
 865                 pclazz = &amp;(evinfo-&gt;u.field_access.field_clazz);
 866                 clazz = *pclazz;
 867                 *pclazz = NULL;
 868                 saveGlobalRef(env, clazz, pclazz);
 869             }
 870             break;
 871         case EI_EXCEPTION:
 872             if ( evinfo-&gt;u.exception.catch_clazz != NULL ) {
 873                 pclazz = &amp;(evinfo-&gt;u.exception.catch_clazz);
 874                 clazz = *pclazz;
</pre>
<hr />
<pre>
 887 
 888 static void
 889 tossEventInfoRefs(JNIEnv *env, EventInfo *evinfo)
 890 {
 891     char sig;
 892     if ( evinfo-&gt;thread != NULL ) {
 893         tossGlobalRef(env, &amp;(evinfo-&gt;thread));
 894     }
 895     if ( evinfo-&gt;clazz != NULL ) {
 896         tossGlobalRef(env, &amp;(evinfo-&gt;clazz));
 897     }
 898     if ( evinfo-&gt;object != NULL ) {
 899         tossGlobalRef(env, &amp;(evinfo-&gt;object));
 900     }
 901     switch (evinfo-&gt;ei) {
 902         case EI_FIELD_MODIFICATION:
 903             if ( evinfo-&gt;u.field_modification.field_clazz != NULL ) {
 904                 tossGlobalRef(env, &amp;(evinfo-&gt;u.field_modification.field_clazz));
 905             }
 906             sig = evinfo-&gt;u.field_modification.signature_type;
<span class="line-modified"> 907             if ((sig == JDWP_TAG(ARRAY)) || (sig == JDWP_TAG(OBJECT)) || (sig == JDWP_TAG(INLINE_OBJECT))) {</span>
 908                 if ( evinfo-&gt;u.field_modification.new_value.l != NULL ) {
 909                     tossGlobalRef(env, &amp;(evinfo-&gt;u.field_modification.new_value.l));
 910                 }
 911             }
 912             break;
 913         case EI_FIELD_ACCESS:
 914             if ( evinfo-&gt;u.field_access.field_clazz != NULL ) {
 915                 tossGlobalRef(env, &amp;(evinfo-&gt;u.field_access.field_clazz));
 916             }
 917             break;
 918         case EI_EXCEPTION:
 919             if ( evinfo-&gt;u.exception.catch_clazz != NULL ) {
 920                 tossGlobalRef(env, &amp;(evinfo-&gt;u.exception.catch_clazz));
 921             }
 922             break;
 923         default:
 924             break;
 925     }
 926 }
 927 
</pre>
<hr />
<pre>
1091     if (command == NULL) {
1092         EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;bagAdd(eventBag)&quot;);
1093     }
1094 
1095     command-&gt;singleKind = COMMAND_SINGLE_FRAME_EVENT;
1096     frameCommand = &amp;command-&gt;u.frameEventCommand;
1097     frameCommand-&gt;suspendPolicy = suspendPolicy;
1098     frameCommand-&gt;id = id;
1099     frameCommand-&gt;ei = ei;
1100     saveGlobalRef(env, thread, &amp;(frameCommand-&gt;thread));
1101     saveGlobalRef(env, clazz, &amp;(frameCommand-&gt;clazz));
1102     frameCommand-&gt;method = method;
1103     frameCommand-&gt;location = location;
1104     if (needReturnValue) {
1105         err = methodReturnType(method, &amp;frameCommand-&gt;typeKey);
1106         JDI_ASSERT(err == JVMTI_ERROR_NONE);
1107 
1108         /*
1109          * V or B C D F I J S Z L &lt;classname&gt; ;    [ ComponentType
1110          */
<span class="line-modified">1111         if (isObjectTag(frameCommand-&gt;typeKey) &amp;&amp;</span>
1112             returnValue.l != NULL) {
1113             saveGlobalRef(env, returnValue.l, &amp;(frameCommand-&gt;returnValue.l));
1114         } else {
1115             frameCommand-&gt;returnValue = returnValue;
1116         }
1117     } else {
1118       /* This is not a JDWP METHOD_EXIT_WITH_RETURN_VALUE request,
1119        * so signal this by setting typeKey = 0 which is not
1120        * a legal typekey.
1121        */
1122        frameCommand-&gt;typeKey = 0;
1123     }
1124 }
1125 
1126 void
1127 eventHelper_reportInvokeDone(jbyte sessionID, jthread thread)
1128 {
1129     JNIEnv *env = getEnv();
1130     HelperCommand *command = jvmtiAllocate(sizeof(*command));
1131     if (command == NULL) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;util.h&quot;
  27 #include &quot;outStream.h&quot;
  28 #include &quot;eventHandler.h&quot;
  29 #include &quot;threadControl.h&quot;
  30 #include &quot;invoker.h&quot;
<span class="line-added">  31 #include &quot;signature.h&quot;</span>
  32 
  33 
  34 #define COMMAND_LOOP_THREAD_NAME &quot;JDWP Event Helper Thread&quot;
  35 
  36 /*
  37  * Event helper thread command commandKinds
  38  */
  39 #define COMMAND_REPORT_EVENT_COMPOSITE          1
  40 #define COMMAND_REPORT_INVOKE_DONE              2
  41 #define COMMAND_REPORT_VM_INIT                  3
  42 #define COMMAND_SUSPEND_THREAD                  4
  43 
  44 /*
  45  * Event helper thread command singleKinds
  46  */
  47 #define COMMAND_SINGLE_EVENT                    11
  48 #define COMMAND_SINGLE_UNLOAD                   12
  49 #define COMMAND_SINGLE_FRAME_EVENT              13
  50 
  51 typedef struct EventCommandSingle {
</pre>
<hr />
<pre>
 463     (void)outStream_writeInt(out, command-&gt;id);
 464     (void)outStream_writeString(out, command-&gt;classSignature);
 465     jvmtiDeallocate(command-&gt;classSignature);
 466     command-&gt;classSignature = NULL;
 467 }
 468 
 469 static void
 470 handleFrameEventCommandSingle(JNIEnv* env, PacketOutputStream *out,
 471                               FrameEventCommandSingle *command)
 472 {
 473     if (command-&gt;typeKey) {
 474         (void)outStream_writeByte(out, JDWP_EVENT(METHOD_EXIT_WITH_RETURN_VALUE));
 475     } else {
 476         (void)outStream_writeByte(out, eventIndex2jdwp(command-&gt;ei));
 477     }
 478     (void)outStream_writeInt(out, command-&gt;id);
 479     (void)outStream_writeObjectRef(env, out, command-&gt;thread);
 480     writeCodeLocation(out, command-&gt;clazz, command-&gt;method, command-&gt;location);
 481     if (command-&gt;typeKey) {
 482         (void)outStream_writeValue(env, out, command-&gt;typeKey, command-&gt;returnValue);
<span class="line-modified"> 483         if (isReferenceTag(command-&gt;typeKey) &amp;&amp;</span>
 484             command-&gt;returnValue.l != NULL) {
 485             tossGlobalRef(env, &amp;(command-&gt;returnValue.l));
 486         }
 487     }
 488     tossGlobalRef(env, &amp;(command-&gt;thread));
 489     tossGlobalRef(env, &amp;(command-&gt;clazz));
 490 }
 491 
 492 static void
 493 suspendWithInvokeEnabled(jbyte policy, jthread thread)
 494 {
 495     invoker_enableInvokeRequests(thread);
 496 
 497     if (policy == JDWP_SUSPEND_POLICY(ALL)) {
 498         (void)threadControl_suspendAll();
 499     } else {
 500         (void)threadControl_suspendThread(thread, JNI_FALSE);
 501     }
 502 }
 503 
</pre>
<hr />
<pre>
 835         clazz = *pclazz;
 836         *pclazz = NULL;
 837         saveGlobalRef(env, clazz, pclazz);
 838     }
 839     if ( evinfo-&gt;object != NULL ) {
 840         pobject = &amp;(evinfo-&gt;object);
 841         object = *pobject;
 842         *pobject = NULL;
 843         saveGlobalRef(env, object, pobject);
 844     }
 845 
 846     switch (evinfo-&gt;ei) {
 847         case EI_FIELD_MODIFICATION:
 848             if ( evinfo-&gt;u.field_modification.field_clazz != NULL ) {
 849                 pclazz = &amp;(evinfo-&gt;u.field_modification.field_clazz);
 850                 clazz = *pclazz;
 851                 *pclazz = NULL;
 852                 saveGlobalRef(env, clazz, pclazz);
 853             }
 854             sig = evinfo-&gt;u.field_modification.signature_type;
<span class="line-modified"> 855             if (isReferenceTag(sig)) {</span>
 856                 if ( evinfo-&gt;u.field_modification.new_value.l != NULL ) {
 857                     pobject = &amp;(evinfo-&gt;u.field_modification.new_value.l);
 858                     object = *pobject;
 859                     *pobject = NULL;
 860                     saveGlobalRef(env, object, pobject);
 861                 }
 862             }
 863             break;
 864         case EI_FIELD_ACCESS:
 865             if ( evinfo-&gt;u.field_access.field_clazz != NULL ) {
 866                 pclazz = &amp;(evinfo-&gt;u.field_access.field_clazz);
 867                 clazz = *pclazz;
 868                 *pclazz = NULL;
 869                 saveGlobalRef(env, clazz, pclazz);
 870             }
 871             break;
 872         case EI_EXCEPTION:
 873             if ( evinfo-&gt;u.exception.catch_clazz != NULL ) {
 874                 pclazz = &amp;(evinfo-&gt;u.exception.catch_clazz);
 875                 clazz = *pclazz;
</pre>
<hr />
<pre>
 888 
 889 static void
 890 tossEventInfoRefs(JNIEnv *env, EventInfo *evinfo)
 891 {
 892     char sig;
 893     if ( evinfo-&gt;thread != NULL ) {
 894         tossGlobalRef(env, &amp;(evinfo-&gt;thread));
 895     }
 896     if ( evinfo-&gt;clazz != NULL ) {
 897         tossGlobalRef(env, &amp;(evinfo-&gt;clazz));
 898     }
 899     if ( evinfo-&gt;object != NULL ) {
 900         tossGlobalRef(env, &amp;(evinfo-&gt;object));
 901     }
 902     switch (evinfo-&gt;ei) {
 903         case EI_FIELD_MODIFICATION:
 904             if ( evinfo-&gt;u.field_modification.field_clazz != NULL ) {
 905                 tossGlobalRef(env, &amp;(evinfo-&gt;u.field_modification.field_clazz));
 906             }
 907             sig = evinfo-&gt;u.field_modification.signature_type;
<span class="line-modified"> 908             if (isReferenceTag(sig)) {</span>
 909                 if ( evinfo-&gt;u.field_modification.new_value.l != NULL ) {
 910                     tossGlobalRef(env, &amp;(evinfo-&gt;u.field_modification.new_value.l));
 911                 }
 912             }
 913             break;
 914         case EI_FIELD_ACCESS:
 915             if ( evinfo-&gt;u.field_access.field_clazz != NULL ) {
 916                 tossGlobalRef(env, &amp;(evinfo-&gt;u.field_access.field_clazz));
 917             }
 918             break;
 919         case EI_EXCEPTION:
 920             if ( evinfo-&gt;u.exception.catch_clazz != NULL ) {
 921                 tossGlobalRef(env, &amp;(evinfo-&gt;u.exception.catch_clazz));
 922             }
 923             break;
 924         default:
 925             break;
 926     }
 927 }
 928 
</pre>
<hr />
<pre>
1092     if (command == NULL) {
1093         EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;bagAdd(eventBag)&quot;);
1094     }
1095 
1096     command-&gt;singleKind = COMMAND_SINGLE_FRAME_EVENT;
1097     frameCommand = &amp;command-&gt;u.frameEventCommand;
1098     frameCommand-&gt;suspendPolicy = suspendPolicy;
1099     frameCommand-&gt;id = id;
1100     frameCommand-&gt;ei = ei;
1101     saveGlobalRef(env, thread, &amp;(frameCommand-&gt;thread));
1102     saveGlobalRef(env, clazz, &amp;(frameCommand-&gt;clazz));
1103     frameCommand-&gt;method = method;
1104     frameCommand-&gt;location = location;
1105     if (needReturnValue) {
1106         err = methodReturnType(method, &amp;frameCommand-&gt;typeKey);
1107         JDI_ASSERT(err == JVMTI_ERROR_NONE);
1108 
1109         /*
1110          * V or B C D F I J S Z L &lt;classname&gt; ;    [ ComponentType
1111          */
<span class="line-modified">1112         if (isReferenceTag(frameCommand-&gt;typeKey) &amp;&amp;</span>
1113             returnValue.l != NULL) {
1114             saveGlobalRef(env, returnValue.l, &amp;(frameCommand-&gt;returnValue.l));
1115         } else {
1116             frameCommand-&gt;returnValue = returnValue;
1117         }
1118     } else {
1119       /* This is not a JDWP METHOD_EXIT_WITH_RETURN_VALUE request,
1120        * so signal this by setting typeKey = 0 which is not
1121        * a legal typekey.
1122        */
1123        frameCommand-&gt;typeKey = 0;
1124     }
1125 }
1126 
1127 void
1128 eventHelper_reportInvokeDone(jbyte sessionID, jthread thread)
1129 {
1130     JNIEnv *env = getEnv();
1131     HelperCommand *command = jvmtiAllocate(sizeof(*command));
1132     if (command == NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="eventHandler.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="inStream.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
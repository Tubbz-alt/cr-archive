<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xpath/internal/axes/UnionPathIterator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xpath.internal.axes;
 22 
 23 import com.sun.org.apache.xml.internal.dtm.Axis;
 24 import com.sun.org.apache.xml.internal.dtm.DTM;
 25 import com.sun.org.apache.xml.internal.dtm.DTMIterator;
 26 import com.sun.org.apache.xml.internal.utils.QName;
 27 import com.sun.org.apache.xpath.internal.Expression;
 28 import com.sun.org.apache.xpath.internal.ExpressionOwner;
 29 import com.sun.org.apache.xpath.internal.XPathVisitor;
 30 import com.sun.org.apache.xpath.internal.compiler.Compiler;
 31 import com.sun.org.apache.xpath.internal.compiler.OpCodes;
 32 import com.sun.org.apache.xpath.internal.compiler.OpMap;
 33 import java.util.List;
 34 
 35 /**
 36  * This class extends NodeSetDTM, which implements DTMIterator,
 37  * and fetches nodes one at a time in document order based on a XPath
 38  * &lt;a href=&quot;http://www.w3.org/TR/xpath#NT-UnionExpr&quot;&gt;UnionExpr&lt;/a&gt;.
 39  * As each node is iterated via nextNode(), the node is also stored
 40  * in the NodeVector, so that previousNode() can easily be done.
 41  * @xsl.usage advanced
<a name="2" id="anc2"></a><span class="line-modified"> 42  * @LastModified: May 2020</span>
 43  */
 44 public class UnionPathIterator extends LocPathIterator
 45         implements Cloneable, DTMIterator, java.io.Serializable, PathComponent
 46 {
 47     static final long serialVersionUID = -3910351546843826781L;
 48 
 49   /**
 50    * Constructor to create an instance which you can add location paths to.
 51    */
 52   public UnionPathIterator()
 53   {
 54 
 55     super();
 56 
 57     // m_mutable = false;
 58     // m_cacheNodes = false;
 59     m_iterators = null;
 60     m_exprs = null;
 61   }
 62 
 63   /**
 64    * Initialize the context values for this expression
 65    * after it is cloned.
 66    *
 67    * @param context The XPath runtime context for this
 68    * transformation.
 69    */
 70   public void setRoot(int context, Object environment)
 71   {
 72     super.setRoot(context, environment);
 73 
 74     try
 75     {
 76       if (null != m_exprs)
 77       {
 78         int n = m_exprs.length;
 79         DTMIterator newIters[] = new DTMIterator[n];
 80 
 81         for (int i = 0; i &lt; n; i++)
 82         {
 83           DTMIterator iter = m_exprs[i].asIterator(m_execContext, context);
 84           newIters[i] = iter;
 85           iter.nextNode();
 86         }
 87         m_iterators = newIters;
 88       }
 89     }
 90     catch(Exception e)
 91     {
 92       throw new com.sun.org.apache.xml.internal.utils.WrappedRuntimeException(e);
 93     }
 94   }
 95 
 96   /**
 97    * Add an iterator to the union list.
 98    *
 99    * @param expr non-null reference to a location path iterator.
100    */
101   public void addIterator(DTMIterator expr)
102   {
103 
104     // Increase array size by only 1 at a time.  Fix this
105     // if it looks to be a problem.
106     if (null == m_iterators)
107     {
108       m_iterators = new DTMIterator[1];
109       m_iterators[0] = expr;
110     }
111     else
112     {
113       DTMIterator[] exprs = m_iterators;
114       int len = m_iterators.length;
115 
116       m_iterators = new DTMIterator[len + 1];
117 
118       System.arraycopy(exprs, 0, m_iterators, 0, len);
119 
120       m_iterators[len] = expr;
121     }
122     expr.nextNode();
123     if(expr instanceof Expression)
124         ((Expression)expr).exprSetParent(this);
125   }
126 
127   /**
128    *  Detaches the iterator from the set which it iterated over, releasing
129    * any computational resources and placing the iterator in the INVALID
130    * state. After&lt;code&gt;detach&lt;/code&gt; has been invoked, calls to
131    * &lt;code&gt;nextNode&lt;/code&gt; or&lt;code&gt;previousNode&lt;/code&gt; will raise the
132    * exception INVALID_STATE_ERR.
133    */
134   public void detach()
135   {
136           if(m_allowDetach &amp;&amp; null != m_iterators){
137                   int n = m_iterators.length;
138                   for(int i = 0; i &lt; n; i++)
139                   {
140                           m_iterators[i].detach();
141                   }
142                   m_iterators = null;
143           }
144   }
145 
146 
147   /**
148    * Create a UnionPathIterator object, including creation
149    * of location path iterators from the opcode list, and call back
150    * into the Compiler to create predicate expressions.
151    *
152    * @param compiler The Compiler which is creating
153    * this expression.
154    * @param opPos The position of this iterator in the
155    * opcode list from the compiler.
156    *
157    * @throws javax.xml.transform.TransformerException
158    */
159   public UnionPathIterator(Compiler compiler, int opPos)
160           throws javax.xml.transform.TransformerException
161   {
162 
163     super();
164 
165     opPos = OpMap.getFirstChildPos(opPos);
166 
167     loadLocationPaths(compiler, opPos, 0);
168   }
169 
170   /**
171    * This will return an iterator capable of handling the union of paths given.
172    *
173    * @param compiler The Compiler which is creating
174    * this expression.
175    * @param opPos The position of this iterator in the
176    * opcode list from the compiler.
177    *
178    * @return Object that is derived from LocPathIterator.
179    *
180    * @throws javax.xml.transform.TransformerException
181    */
182   public static LocPathIterator createUnionIterator(Compiler compiler, int opPos)
183           throws javax.xml.transform.TransformerException
184   {
185         // For the moment, I&#39;m going to first create a full UnionPathIterator, and
186         // then see if I can reduce it to a UnionChildIterator.  It would obviously
187         // be more effecient to just test for the conditions for a UnionChildIterator,
188         // and then create that directly.
189         UnionPathIterator upi = new UnionPathIterator(compiler, opPos);
190         int nPaths = upi.m_exprs.length;
191         boolean isAllChildIterators = true;
192         for(int i = 0; i &lt; nPaths; i++)
193         {
194                 LocPathIterator lpi = upi.m_exprs[i];
195 
196                 if(lpi.getAxis() != Axis.CHILD)
197                 {
198                         isAllChildIterators = false;
199                         break;
200                 }
201                 else
202                 {
203                         // check for positional predicates or position function, which won&#39;t work.
204                         if(HasPositionalPredChecker.check(lpi))
205                         {
206                                 isAllChildIterators = false;
207                                 break;
208                         }
209                 }
210         }
211         if(isAllChildIterators)
212         {
213                 UnionChildIterator uci = new UnionChildIterator();
214 
215                 for(int i = 0; i &lt; nPaths; i++)
216                 {
217                         PredicatedNodeTest lpi = upi.m_exprs[i];
218                         // I could strip the lpi down to a pure PredicatedNodeTest, but
219                         // I don&#39;t think it&#39;s worth it.  Note that the test can be used
220                         // as a static object... so it doesn&#39;t have to be cloned.
221                         uci.addNodeTest(lpi);
222                 }
223                 return uci;
224 
225         }
226         else
227                 return upi;
228   }
229 
230   /**
231    * Get the analysis bits for this walker, as defined in the WalkerFactory.
232    * @return One of WalkerFactory#BIT_DESCENDANT, etc.
233    */
234   public int getAnalysisBits()
235   {
236     int bits = 0;
237 
238     if (m_exprs != null)
239     {
240       int n = m_exprs.length;
241 
242       for (int i = 0; i &lt; n; i++)
243       {
244         int bit = m_exprs[i].getAnalysisBits();
245         bits |= bit;
246       }
247     }
248 
249     return bits;
250   }
251 
252   /**
253    * Read the object from a serialization stream.
254    *
255    * @param stream Input stream to read from
256    *
<a name="3" id="anc3"></a><span class="line-modified">257    * @throws java.io.IOException in case of any IO related exceptions</span>
<span class="line-modified">258    * @throws ClassNotFoundException if Class of the serialized object cannot be found</span>
259    */
260   private void readObject(java.io.ObjectInputStream stream)
<a name="4" id="anc4"></a><span class="line-modified">261           throws java.io.IOException, ClassNotFoundException</span>
262   {
<a name="5" id="anc5"></a><span class="line-modified">263     stream.defaultReadObject();</span>
<span class="line-modified">264     m_clones =  new IteratorPool(this);</span>







265   }
266 
267   /**
268    * Get a cloned LocPathIterator that holds the same
269    * position as this iterator.
270    *
271    * @return A clone of this iterator that holds the same node position.
272    *
273    * @throws CloneNotSupportedException
274    */
275   public Object clone() throws CloneNotSupportedException
276   {
277 
278     UnionPathIterator clone = (UnionPathIterator) super.clone();
279     if (m_iterators != null)
280     {
281       int n = m_iterators.length;
282 
283       clone.m_iterators = new DTMIterator[n];
284 
285       for (int i = 0; i &lt; n; i++)
286       {
287         clone.m_iterators[i] = (DTMIterator)m_iterators[i].clone();
288       }
289     }
290 
291     return clone;
292   }
293 
294 
295   /**
296    * Create a new location path iterator.
297    *
298    * @param compiler The Compiler which is creating
299    * this expression.
300    * @param opPos The position of this iterator in the
301    *
302    * @return New location path iterator.
303    *
304    * @throws javax.xml.transform.TransformerException
305    */
306   protected LocPathIterator createDTMIterator(
307           Compiler compiler, int opPos) throws javax.xml.transform.TransformerException
308   {
309     LocPathIterator lpi = (LocPathIterator)WalkerFactory.newDTMIterator(compiler, opPos,
310                                       (compiler.getLocationPathDepth() &lt;= 0));
311     return lpi;
312   }
313 
314   /**
315    * Initialize the location path iterators.  Recursive.
316    *
317    * @param compiler The Compiler which is creating
318    * this expression.
319    * @param opPos The position of this iterator in the
320    * opcode list from the compiler.
321    * @param count The insert position of the iterator.
322    *
323    * @throws javax.xml.transform.TransformerException
324    */
325   protected void loadLocationPaths(Compiler compiler, int opPos, int count)
326           throws javax.xml.transform.TransformerException
327   {
328 
329     // TODO: Handle unwrapped FilterExpr
330     int steptype = compiler.getOp(opPos);
331 
332     if (steptype == OpCodes.OP_LOCATIONPATH)
333     {
334       loadLocationPaths(compiler, compiler.getNextOpPos(opPos), count + 1);
335 
336       m_exprs[count] = createDTMIterator(compiler, opPos);
337       m_exprs[count].exprSetParent(this);
338     }
339     else
340     {
341 
342       // Have to check for unwrapped functions, which the LocPathIterator
343       // doesn&#39;t handle.
344       switch (steptype)
345       {
346       case OpCodes.OP_VARIABLE :
347       case OpCodes.OP_EXTFUNCTION :
348       case OpCodes.OP_FUNCTION :
349       case OpCodes.OP_GROUP :
350         loadLocationPaths(compiler, compiler.getNextOpPos(opPos), count + 1);
351 
352         WalkingIterator iter =
353           new WalkingIterator(compiler.getNamespaceContext());
354         iter.exprSetParent(this);
355 
356         if(compiler.getLocationPathDepth() &lt;= 0)
357           iter.setIsTopLevel(true);
358 
359         iter.m_firstWalker = new com.sun.org.apache.xpath.internal.axes.FilterExprWalker(iter);
360 
361         iter.m_firstWalker.init(compiler, opPos, steptype);
362 
363         m_exprs[count] = iter;
364         break;
365       default :
366         m_exprs = new LocPathIterator[count];
367       }
368     }
369   }
370 
371   /**
372    *  Returns the next node in the set and advances the position of the
373    * iterator in the set. After a DTMIterator is created, the first call
374    * to nextNode() returns the first node in the set.
375    * @return  The next &lt;code&gt;Node&lt;/code&gt; in the set being iterated over, or
376    *   &lt;code&gt;null&lt;/code&gt; if there are no more members in that set.
377    */
378   public int nextNode()
379   {
380         if(m_foundLast)
381                 return DTM.NULL;
382 
383     // Loop through the iterators getting the current fetched
384     // node, and get the earliest occuring in document order
385     int earliestNode = DTM.NULL;
386 
387     if (null != m_iterators)
388     {
389       int n = m_iterators.length;
390       int iteratorUsed = -1;
391 
392       for (int i = 0; i &lt; n; i++)
393       {
394         int node = m_iterators[i].getCurrentNode();
395 
396         if (DTM.NULL == node)
397           continue;
398         else if (DTM.NULL == earliestNode)
399         {
400           iteratorUsed = i;
401           earliestNode = node;
402         }
403         else
404         {
405           if (node == earliestNode)
406           {
407 
408             // Found a duplicate, so skip past it.
409             m_iterators[i].nextNode();
410           }
411           else
412           {
413             DTM dtm = getDTM(node);
414 
415             if (dtm.isNodeAfter(node, earliestNode))
416             {
417               iteratorUsed = i;
418               earliestNode = node;
419             }
420           }
421         }
422       }
423 
424       if (DTM.NULL != earliestNode)
425       {
426         m_iterators[iteratorUsed].nextNode();
427 
428         incrementCurrentPos();
429       }
430       else
431         m_foundLast = true;
432     }
433 
434     m_lastFetched = earliestNode;
435 
436     return earliestNode;
437   }
438 
439   /**
440    * This function is used to fixup variables from QNames to stack frame
441    * indexes at stylesheet build time.
442    * @param vars List of QNames that correspond to variables.  This list
443    * should be searched backwards for the first qualified name that
444    * corresponds to the variable reference qname.  The position of the
445    * QName in the vector from the start of the vector will be its position
446    * in the stack frame (but variables above the globalsTop value will need
447    * to be offset to the current stack frame).
448    */
449   public void fixupVariables(List&lt;QName&gt; vars, int globalsSize)
450   {
451     for (int i = 0; i &lt; m_exprs.length; i++)
452     {
453       m_exprs[i].fixupVariables(vars, globalsSize);
454     }
455 
456   }
457 
458   /**
459    * The location path iterators, one for each
460    * &lt;a href=&quot;http://www.w3.org/TR/xpath#NT-LocationPath&quot;&gt;location
461    * path&lt;/a&gt; contained in the union expression.
462    * @serial
463    */
464   protected LocPathIterator[] m_exprs;
465 
466 
467   /**
468    * The location path iterators, one for each
469    * &lt;a href=&quot;http://www.w3.org/TR/xpath#NT-LocationPath&quot;&gt;location
470    * path&lt;/a&gt; contained in the union expression.
471    * @serial
472    */
473   protected DTMIterator[] m_iterators;
474 
475   /**
476    * Returns the axis being iterated, if it is known.
477    *
478    * @return Axis.CHILD, etc., or -1 if the axis is not known or is of multiple
479    * types.
480    */
481   public int getAxis()
482   {
483     // Could be smarter.
484     return -1;
485   }
486 
487   class iterOwner implements ExpressionOwner
488   {
489         int m_index;
490 
491         iterOwner(int index)
492         {
493                 m_index = index;
494         }
495 
496     /**
497      * @see ExpressionOwner#getExpression()
498      */
499     public Expression getExpression()
500     {
501       return m_exprs[m_index];
502     }
503 
504     /**
505      * @see ExpressionOwner#setExpression(Expression)
506      */
507     public void setExpression(Expression exp)
508     {
509 
510         if(!(exp instanceof LocPathIterator))
511         {
512                 // Yuck.  Need FilterExprIter.  Or make it so m_exprs can be just
513                 // plain expressions?
514                 WalkingIterator wi = new WalkingIterator(getPrefixResolver());
515                 FilterExprWalker few = new FilterExprWalker(wi);
516                 wi.setFirstWalker(few);
517                 few.setInnerExpression(exp);
518                 wi.exprSetParent(UnionPathIterator.this);
519                 few.exprSetParent(wi);
520                 exp.exprSetParent(few);
521                 exp = wi;
522         }
523         else
524                 exp.exprSetParent(UnionPathIterator.this);
525         m_exprs[m_index] = (LocPathIterator)exp;
526     }
527 
528   }
529 
530   /**
531    * @see com.sun.org.apache.xpath.internal.XPathVisitable#callVisitors(ExpressionOwner, XPathVisitor)
532    */
533   public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
534   {
535                 if(visitor.visitUnionPath(owner, this))
536                 {
537                         if(null != m_exprs)
538                         {
539                                 int n = m_exprs.length;
540                                 for(int i = 0; i &lt; n; i++)
541                                 {
542                                         m_exprs[i].callVisitors(new iterOwner(i), visitor);
543                                 }
544                         }
545                 }
546   }
547 
548     /**
549      * @see Expression#deepEquals(Expression)
550      */
551     public boolean deepEquals(Expression expr)
552     {
553       if (!super.deepEquals(expr))
554             return false;
555 
556       UnionPathIterator upi = (UnionPathIterator) expr;
557 
558       if (null != m_exprs)
559       {
560         int n = m_exprs.length;
561 
562         if((null == upi.m_exprs) || (upi.m_exprs.length != n))
563                 return false;
564 
565         for (int i = 0; i &lt; n; i++)
566         {
567           if(!m_exprs[i].deepEquals(upi.m_exprs[i]))
568                 return false;
569         }
570       }
571       else if (null != upi.m_exprs)
572       {
573           return false;
574       }
575 
576       return true;
577     }
578 
579 
580 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xpath/internal/axes/LocPathIterator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xpath.internal.axes;
  22 
  23 import com.sun.org.apache.xalan.internal.res.XSLMessages;
  24 import com.sun.org.apache.xml.internal.dtm.DTM;
  25 import com.sun.org.apache.xml.internal.dtm.DTMFilter;
  26 import com.sun.org.apache.xml.internal.dtm.DTMIterator;
  27 import com.sun.org.apache.xml.internal.dtm.DTMManager;
  28 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
  29 import com.sun.org.apache.xpath.internal.ExpressionOwner;
  30 import com.sun.org.apache.xpath.internal.XPathContext;
  31 import com.sun.org.apache.xpath.internal.XPathVisitor;
  32 import com.sun.org.apache.xpath.internal.compiler.Compiler;
  33 import com.sun.org.apache.xpath.internal.objects.XNodeSet;
  34 import com.sun.org.apache.xpath.internal.objects.XObject;
  35 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
  36 
  37 /**
  38  * This class extends NodeSetDTM, which implements NodeIterator,
  39  * and fetches nodes one at a time in document order based on a XPath
  40  * &lt;a href=&quot;http://www.w3.org/TR/xpath#NT-LocationPath&gt;LocationPath&lt;/a&gt;.
  41  *
  42  * &lt;p&gt;If setShouldCacheNodes(true) is called,
  43  * as each node is iterated via nextNode(), the node is also stored
  44  * in the NodeVector, so that previousNode() can easily be done, except in
  45  * the case where the LocPathIterator is &quot;owned&quot; by a UnionPathIterator,
  46  * in which case the UnionPathIterator will cache the nodes.&lt;/p&gt;
  47  * @xsl.usage advanced
<a name="2" id="anc2"></a><span class="line-modified">  48  * @LastModified: May 2020</span>
  49  */
  50 public abstract class LocPathIterator extends PredicatedNodeTest
  51         implements Cloneable, DTMIterator, java.io.Serializable, PathComponent
  52 {
  53     static final long serialVersionUID = -4602476357268405754L;
  54 
  55   /**
  56    * Create a LocPathIterator object.
  57    *
  58    */
  59   protected LocPathIterator()
  60   {
  61   }
  62 
  63 
  64   /**
  65    * Create a LocPathIterator object.
  66    *
  67    * @param nscontext The namespace context for this iterator,
  68    * should be OK if null.
  69    */
  70   protected LocPathIterator(PrefixResolver nscontext)
  71   {
  72 
  73     setLocPathIterator(this);
  74     m_prefixResolver = nscontext;
  75   }
  76 
  77   /**
  78    * Create a LocPathIterator object, including creation
  79    * of step walkers from the opcode list, and call back
  80    * into the Compiler to create predicate expressions.
  81    *
  82    * @param compiler The Compiler which is creating
  83    * this expression.
  84    * @param opPos The position of this iterator in the
  85    * opcode list from the compiler.
  86    *
  87    * @throws javax.xml.transform.TransformerException
  88    */
  89   protected LocPathIterator(Compiler compiler, int opPos, int analysis)
  90           throws javax.xml.transform.TransformerException
  91   {
  92     this(compiler, opPos, analysis, true);
  93   }
  94 
  95   /**
  96    * Create a LocPathIterator object, including creation
  97    * of step walkers from the opcode list, and call back
  98    * into the Compiler to create predicate expressions.
  99    *
 100    * @param compiler The Compiler which is creating
 101    * this expression.
 102    * @param opPos The position of this iterator in the
 103    * opcode list from the compiler.
 104    * @param shouldLoadWalkers True if walkers should be
 105    * loaded, or false if this is a derived iterator and
 106    * it doesn&#39;t wish to load child walkers.
 107    *
 108    * @throws javax.xml.transform.TransformerException
 109    */
 110   protected LocPathIterator(
 111           Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
 112             throws javax.xml.transform.TransformerException
 113   {
 114     setLocPathIterator(this);
 115   }
 116 
 117   /**
 118    * Get the analysis bits for this walker, as defined in the WalkerFactory.
 119    * @return One of WalkerFactory#BIT_DESCENDANT, etc.
 120    */
 121   public int getAnalysisBits()
 122   {
 123         int axis = getAxis();
 124         int bit = WalkerFactory.getAnalysisBitFromAxes(axis);
 125         return bit;
 126   }
 127 
 128   /**
 129    * Read the object from a serialization stream.
 130    *
 131    * @param stream Input stream to read from
 132    *
<a name="3" id="anc3"></a><span class="line-modified"> 133    * @throws java.io.IOException in case of any IO related exceptions</span>
<span class="line-modified"> 134    * @throws ClassNotFoundException if Class of the serialized object cannot be found</span>
 135    */
 136   private void readObject(java.io.ObjectInputStream stream)
<a name="4" id="anc4"></a><span class="line-modified"> 137           throws java.io.IOException, ClassNotFoundException</span>
 138   {
<a name="5" id="anc5"></a><span class="line-modified"> 139     stream.defaultReadObject();</span>
<span class="line-modified"> 140     m_clones =  new IteratorPool(this);</span>







 141   }
 142 
 143   /**
 144    * Set the environment in which this iterator operates, which should provide:
 145    * a node (the context node... same value as &quot;root&quot; defined below)
 146    * a pair of non-zero positive integers (the context position and the context size)
 147    * a set of variable bindings
 148    * a function library
 149    * the set of namespace declarations in scope for the expression.
 150    *
 151    * &lt;p&gt;At this time the exact implementation of this environment is application
 152    * dependent.  Probably a proper interface will be created fairly soon.&lt;/p&gt;
 153    *
 154    * @param environment The environment object.
 155    */
 156   public void setEnvironment(Object environment)
 157   {
 158     // no-op for now.
 159   }
 160 
 161   /**
 162    * Get an instance of a DTM that &quot;owns&quot; a node handle.  Since a node
 163    * iterator may be passed without a DTMManager, this allows the
 164    * caller to easily get the DTM using just the iterator.
 165    *
 166    * @param nodeHandle the nodeHandle.
 167    *
 168    * @return a non-null DTM reference.
 169    */
 170   public DTM getDTM(int nodeHandle)
 171   {
 172     // %OPT%
 173     return m_execContext.getDTM(nodeHandle);
 174   }
 175 
 176   /**
 177    * Get an instance of the DTMManager.  Since a node
 178    * iterator may be passed without a DTMManager, this allows the
 179    * caller to easily get the DTMManager using just the iterator.
 180    *
 181    * @return a non-null DTMManager reference.
 182    */
 183   public DTMManager getDTMManager()
 184   {
 185     return m_execContext.getDTMManager();
 186   }
 187 
 188   /**
 189    * Execute this iterator, meaning create a clone that can
 190    * store state, and initialize it for fast execution from
 191    * the current runtime state.  When this is called, no actual
 192    * query from the current context node is performed.
 193    *
 194    * @param xctxt The XPath execution context.
 195    *
 196    * @return An XNodeSet reference that holds this iterator.
 197    *
 198    * @throws javax.xml.transform.TransformerException
 199    */
 200   public XObject execute(XPathContext xctxt)
 201           throws javax.xml.transform.TransformerException
 202   {
 203 
 204     XNodeSet iter = new XNodeSet((LocPathIterator)m_clones.getInstance());
 205 
 206     iter.setRoot(xctxt.getCurrentNode(), xctxt);
 207 
 208     return iter;
 209   }
 210 
 211   /**
 212    * Execute an expression in the XPath runtime context, and return the
 213    * result of the expression.
 214    *
 215    *
 216    * @param xctxt The XPath runtime context.
 217    * @param handler The target content handler.
 218    *
 219    * @return The result of the expression in the form of a &lt;code&gt;XObject&lt;/code&gt;.
 220    *
 221    * @throws javax.xml.transform.TransformerException if a runtime exception
 222    *         occurs.
 223    * @throws org.xml.sax.SAXException
 224    */
 225   public void executeCharsToContentHandler(
 226           XPathContext xctxt, org.xml.sax.ContentHandler handler)
 227             throws javax.xml.transform.TransformerException,
 228                    org.xml.sax.SAXException
 229   {
 230     LocPathIterator clone = (LocPathIterator)m_clones.getInstance();
 231 
 232     int current = xctxt.getCurrentNode();
 233     clone.setRoot(current, xctxt);
 234 
 235     int node = clone.nextNode();
 236     DTM dtm = clone.getDTM(node);
 237     clone.detach();
 238 
 239     if(node != DTM.NULL)
 240     {
 241       dtm.dispatchCharactersEvents(node, handler, false);
 242     }
 243   }
 244 
 245   /**
 246    * Given an select expression and a context, evaluate the XPath
 247    * and return the resulting iterator.
 248    *
 249    * @param xctxt The execution context.
 250    * @param contextNode The node that &quot;.&quot; expresses.
 251    * @throws TransformerException thrown if the active ProblemListener decides
 252    * the error condition is severe enough to halt processing.
 253    *
 254    * @throws javax.xml.transform.TransformerException
 255    * @xsl.usage experimental
 256    */
 257   public DTMIterator asIterator(
 258           XPathContext xctxt, int contextNode)
 259             throws javax.xml.transform.TransformerException
 260   {
 261     XNodeSet iter = new XNodeSet((LocPathIterator)m_clones.getInstance());
 262 
 263     iter.setRoot(contextNode, xctxt);
 264 
 265     return iter;
 266   }
 267 
 268 
 269   /**
 270    * Tell if the expression is a nodeset expression.
 271    *
 272    * @return true if the expression can be represented as a nodeset.
 273    */
 274   public boolean isNodesetExpr()
 275   {
 276     return true;
 277   }
 278 
 279   /**
 280    * Return the first node out of the nodeset, if this expression is
 281    * a nodeset expression.  This is the default implementation for
 282    * nodesets.  Derived classes should try and override this and return a
 283    * value without having to do a clone operation.
 284    * @param xctxt The XPath runtime context.
 285    * @return the first node out of the nodeset, or DTM.NULL.
 286    */
 287   public int asNode(XPathContext xctxt)
 288     throws javax.xml.transform.TransformerException
 289   {
 290     DTMIterator iter = m_clones.getInstance();
 291 
 292     int current = xctxt.getCurrentNode();
 293 
 294     iter.setRoot(current, xctxt);
 295 
 296     int next = iter.nextNode();
 297     // m_clones.freeInstance(iter);
 298     iter.detach();
 299     return next;
 300   }
 301 
 302   /**
 303    * Evaluate this operation directly to a boolean.
 304    *
 305    * @param xctxt The runtime execution context.
 306    *
 307    * @return The result of the operation as a boolean.
 308    *
 309    * @throws javax.xml.transform.TransformerException
 310    */
 311   public boolean bool(XPathContext xctxt)
 312           throws javax.xml.transform.TransformerException
 313   {
 314     return (asNode(xctxt) != DTM.NULL);
 315   }
 316 
 317 
 318   /**
 319    * Set if this is an iterator at the upper level of
 320    * the XPath.
 321    *
 322    * @param b true if this location path is at the top level of the
 323    *          expression.
 324    * @xsl.usage advanced
 325    */
 326   public void setIsTopLevel(boolean b)
 327   {
 328     m_isTopLevel = b;
 329   }
 330 
 331   /**
 332    * Get if this is an iterator at the upper level of
 333    * the XPath.
 334    *
 335    * @return true if this location path is at the top level of the
 336    *          expression.
 337    * @xsl.usage advanced
 338    */
 339   public boolean getIsTopLevel()
 340   {
 341     return m_isTopLevel;
 342   }
 343 
 344   /**
 345    * Initialize the context values for this expression
 346    * after it is cloned.
 347    *
 348    * @param context The XPath runtime context for this
 349    * transformation.
 350    */
 351   public void setRoot(int context, Object environment)
 352   {
 353 
 354     m_context = context;
 355 
 356     XPathContext xctxt = (XPathContext)environment;
 357     m_execContext = xctxt;
 358     m_cdtm = xctxt.getDTM(context);
 359 
 360     m_currentContextNode = context; // only if top level?
 361 
 362     // Yech, shouldn&#39;t have to do this.  -sb
 363     if(null == m_prefixResolver)
 364         m_prefixResolver = xctxt.getNamespaceContext();
 365 
 366     m_lastFetched = DTM.NULL;
 367     m_foundLast = false;
 368     m_pos = 0;
 369     m_length = -1;
 370 
 371     if (m_isTopLevel)
 372       this.m_stackFrame = xctxt.getVarStack().getStackFrame();
 373 
 374     // reset();
 375   }
 376 
 377   /**
 378    * Set the next position index of this iterator.
 379    *
 380    * @param next A value greater than or equal to zero that indicates the next
 381    * node position to fetch.
 382    */
 383   protected void setNextPosition(int next)
 384   {
 385     assertion(false, &quot;setNextPosition not supported in this iterator!&quot;);
 386   }
 387 
 388   /**
 389    * Get the current position, which is one less than
 390    * the next nextNode() call will retrieve.  i.e. if
 391    * you call getCurrentPos() and the return is 0, the next
 392    * fetch will take place at index 1.
 393    *
 394    * @return A value greater than or equal to zero that indicates the next
 395    * node position to fetch.
 396    */
 397   public final int getCurrentPos()
 398   {
 399     return m_pos;
 400   }
 401 
 402 
 403   /**
 404    * If setShouldCacheNodes(true) is called, then nodes will
 405    * be cached.  They are not cached by default.
 406    *
 407    * @param b True if this iterator should cache nodes.
 408    */
 409   public void setShouldCacheNodes(boolean b)
 410   {
 411 
 412     assertion(false, &quot;setShouldCacheNodes not supported by this iterater!&quot;);
 413   }
 414 
 415   /**
 416    * Tells if this iterator can have nodes added to it or set via
 417    * the &lt;code&gt;setItem(int node, int index)&lt;/code&gt; method.
 418    *
 419    * @return True if the nodelist can be mutated.
 420    */
 421   public boolean isMutable()
 422   {
 423     return false;
 424   }
 425 
 426   /**
 427    * Set the current position in the node set.
 428    *
 429    * @param i Must be a valid index greater
 430    * than or equal to zero and less than m_cachedNodes.size().
 431    */
 432   public void setCurrentPos(int i)
 433   {
 434         assertion(false, &quot;setCurrentPos not supported by this iterator!&quot;);
 435   }
 436 
 437   /**
 438    * Increment the current position in the node set.
 439    */
 440   public void incrementCurrentPos()
 441   {
 442         m_pos++;
 443   }
 444 
 445 
 446   /**
 447    * Get the length of the cached nodes.
 448    *
 449    * &lt;p&gt;Note: for the moment at least, this only returns
 450    * the size of the nodes that have been fetched to date,
 451    * it doesn&#39;t attempt to run to the end to make sure we
 452    * have found everything.  This should be reviewed.&lt;/p&gt;
 453    *
 454    * @return The size of the current cache list.
 455    */
 456   public int size()
 457   {
 458         assertion(false, &quot;size() not supported by this iterator!&quot;);
 459         return 0;
 460   }
 461 
 462   /**
 463    *  Returns the &lt;code&gt;index&lt;/code&gt; th item in the collection. If
 464    * &lt;code&gt;index&lt;/code&gt; is greater than or equal to the number of nodes in
 465    * the list, this returns &lt;code&gt;null&lt;/code&gt; .
 466    * @param index  Index into the collection.
 467    * @return  The node at the &lt;code&gt;index&lt;/code&gt; th position in the
 468    *   &lt;code&gt;NodeList&lt;/code&gt; , or &lt;code&gt;null&lt;/code&gt; if that is not a valid
 469    *   index.
 470    */
 471   public int item(int index)
 472   {
 473         assertion(false, &quot;item(int index) not supported by this iterator!&quot;);
 474         return 0;
 475   }
 476 
 477   /**
 478    * Sets the node at the specified index of this vector to be the
 479    * specified node. The previous component at that position is discarded.
 480    *
 481    * &lt;p&gt;The index must be a value greater than or equal to 0 and less
 482    * than the current size of the vector.
 483    * The iterator must be in cached mode.&lt;/p&gt;
 484    *
 485    * &lt;p&gt;Meant to be used for sorted iterators.&lt;/p&gt;
 486    *
 487    * @param node Node to set
 488    * @param index Index of where to set the node
 489    */
 490   public void setItem(int node, int index)
 491   {
 492         assertion(false, &quot;setItem not supported by this iterator!&quot;);
 493   }
 494 
 495   /**
 496    *  The number of nodes in the list. The range of valid child node indices
 497    * is 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive.
 498    *
 499    * @return The number of nodes in the list, always greater or equal to zero.
 500    */
 501   public int getLength()
 502   {
 503     // Tell if this is being called from within a predicate.
 504         boolean isPredicateTest = (this == m_execContext.getSubContextList());
 505 
 506     // And get how many total predicates are part of this step.
 507         int predCount = getPredicateCount();
 508 
 509     // If we have already calculated the length, and the current predicate
 510     // is the first predicate, then return the length.  We don&#39;t cache
 511     // the anything but the length of the list to the first predicate.
 512     if (-1 != m_length &amp;&amp; isPredicateTest &amp;&amp; m_predicateIndex &lt; 1)
 513                 return m_length;
 514 
 515     // I&#39;m a bit worried about this one, since it doesn&#39;t have the
 516     // checks found above.  I suspect it&#39;s fine.  -sb
 517     if (m_foundLast)
 518                 return m_pos;
 519 
 520     // Create a clone, and count from the current position to the end
 521     // of the list, not taking into account the current predicate and
 522     // predicates after the current one.
 523     int pos = (m_predicateIndex &gt;= 0) ? getProximityPosition() : m_pos;
 524 
 525     LocPathIterator clone;
 526 
 527     try
 528     {
 529       clone = (LocPathIterator) clone();
 530     }
 531     catch (CloneNotSupportedException cnse)
 532     {
 533       return -1;
 534     }
 535 
 536     // We want to clip off the last predicate, but only if we are a sub
 537     // context node list, NOT if we are a context list.  See pos68 test,
 538     // also test against bug4638.
 539     if (predCount &gt; 0 &amp;&amp; isPredicateTest)
 540     {
 541       // Don&#39;t call setPredicateCount, because it clones and is slower.
 542       clone.m_predCount = m_predicateIndex;
 543       // The line above used to be:
 544       // clone.m_predCount = predCount - 1;
 545       // ...which looks like a dumb bug to me. -sb
 546     }
 547 
 548     int next;
 549 
 550     while (DTM.NULL != (next = clone.nextNode()))
 551     {
 552       pos++;
 553     }
 554 
 555     if (isPredicateTest &amp;&amp; m_predicateIndex &lt; 1)
 556       m_length = pos;
 557 
 558     return pos;
 559   }
 560 
 561   /**
 562    * Tells if this NodeSetDTM is &quot;fresh&quot;, in other words, if
 563    * the first nextNode() that is called will return the
 564    * first node in the set.
 565    *
 566    * @return true of nextNode has not been called.
 567    */
 568   public boolean isFresh()
 569   {
 570     return (m_pos == 0);
 571   }
 572 
 573   /**
 574    *  Returns the previous node in the set and moves the position of the
 575    * iterator backwards in the set.
 576    * @return  The previous &lt;code&gt;Node&lt;/code&gt; in the set being iterated over,
 577    *   or&lt;code&gt;null&lt;/code&gt; if there are no more members in that set.
 578    */
 579   public int previousNode()
 580   {
 581     throw new RuntimeException(
 582       XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE, null)); //&quot;This NodeSetDTM can not iterate to a previous node!&quot;);
 583   }
 584 
 585   /**
 586    * This attribute determines which node types are presented via the
 587    * iterator. The available set of constants is defined in the
 588    * &lt;code&gt;NodeFilter&lt;/code&gt; interface.
 589    *
 590    * &lt;p&gt;This is somewhat useless at this time, since it doesn&#39;t
 591    * really return information that tells what this iterator will
 592    * show.  It is here only to fullfill the DOM NodeIterator
 593    * interface.&lt;/p&gt;
 594    *
 595    * @return For now, always NodeFilter.SHOW_ALL &amp; ~NodeFilter.SHOW_ENTITY_REFERENCE.
 596    * @see org.w3c.dom.traversal.NodeIterator
 597    */
 598   public int getWhatToShow()
 599   {
 600 
 601     // TODO: ??
 602     return DTMFilter.SHOW_ALL &amp; ~DTMFilter.SHOW_ENTITY_REFERENCE;
 603   }
 604 
 605   /**
 606    *  The filter used to screen nodes.  Not used at this time,
 607    * this is here only to fullfill the DOM NodeIterator
 608    * interface.
 609    *
 610    * @return Always null.
 611    * @see org.w3c.dom.traversal.NodeIterator
 612    */
 613   public DTMFilter getFilter()
 614   {
 615     return null;
 616   }
 617 
 618   /**
 619    * The root node of the Iterator, as specified when it was created.
 620    *
 621    * @return The &quot;root&quot; of this iterator, which, in XPath terms,
 622    * is the node context for this iterator.
 623    */
 624   public int getRoot()
 625   {
 626     return m_context;
 627   }
 628 
 629   /**
 630    *  The value of this flag determines whether the children of entity
 631    * reference nodes are visible to the iterator. If false, they will be
 632    * skipped over.
 633    * &lt;br&gt; To produce a view of the document that has entity references
 634    * expanded and does not expose the entity reference node itself, use the
 635    * whatToShow flags to hide the entity reference node and set
 636    * expandEntityReferences to true when creating the iterator. To produce
 637    * a view of the document that has entity reference nodes but no entity
 638    * expansion, use the whatToShow flags to show the entity reference node
 639    * and set expandEntityReferences to false.
 640    *
 641    * @return Always true, since entity reference nodes are not
 642    * visible in the XPath model.
 643    */
 644   public boolean getExpandEntityReferences()
 645   {
 646     return true;
 647   }
 648 
 649   /** Control over whether it is OK for detach to reset the iterator. */
 650   protected boolean m_allowDetach = true;
 651 
 652   /**
 653    * Specify if it&#39;s OK for detach to release the iterator for reuse.
 654    *
 655    * @param allowRelease true if it is OK for detach to release this iterator
 656    * for pooling.
 657    */
 658   public void allowDetachToRelease(boolean allowRelease)
 659   {
 660     m_allowDetach = allowRelease;
 661   }
 662 
 663   /**
 664    *  Detaches the iterator from the set which it iterated over, releasing
 665    * any computational resources and placing the iterator in the INVALID
 666    * state. After&lt;code&gt;detach&lt;/code&gt; has been invoked, calls to
 667    * &lt;code&gt;nextNode&lt;/code&gt; or&lt;code&gt;previousNode&lt;/code&gt; will raise the
 668    * exception INVALID_STATE_ERR.
 669    */
 670   public void detach()
 671   {
 672     if(m_allowDetach)
 673     {
 674       // sb: allow reusing of cached nodes when possible?
 675       // m_cachedNodes = null;
 676       m_execContext = null;
 677       // m_prefixResolver = null;  sb: Why would this ever want to be null?
 678       m_cdtm = null;
 679       m_length = -1;
 680       m_pos = 0;
 681       m_lastFetched = DTM.NULL;
 682       m_context = DTM.NULL;
 683       m_currentContextNode = DTM.NULL;
 684 
 685       m_clones.freeInstance(this);
 686     }
 687   }
 688 
 689   /**
 690    * Reset the iterator.
 691    */
 692   public void reset()
 693   {
 694         assertion(false, &quot;This iterator can not reset!&quot;);
 695   }
 696 
 697   /**
 698    * Get a cloned Iterator that is reset to the beginning
 699    * of the query.
 700    *
 701    * @return A cloned NodeIterator set of the start of the query.
 702    *
 703    * @throws CloneNotSupportedException
 704    */
 705   public DTMIterator cloneWithReset() throws CloneNotSupportedException
 706   {
 707     LocPathIterator clone;
 708 //    clone = (LocPathIterator) clone();
 709     clone = (LocPathIterator)m_clones.getInstanceOrThrow();
 710     clone.m_execContext = m_execContext;
 711     clone.m_cdtm = m_cdtm;
 712 
 713     clone.m_context = m_context;
 714     clone.m_currentContextNode = m_currentContextNode;
 715     clone.m_stackFrame = m_stackFrame;
 716 
 717     // clone.reset();
 718 
 719     return clone;
 720   }
 721 
 722 //  /**
 723 //   * Get a cloned LocPathIterator that holds the same
 724 //   * position as this iterator.
 725 //   *
 726 //   * @return A clone of this iterator that holds the same node position.
 727 //   *
 728 //   * @throws CloneNotSupportedException
 729 //   */
 730 //  public Object clone() throws CloneNotSupportedException
 731 //  {
 732 //
 733 //    LocPathIterator clone = (LocPathIterator) super.clone();
 734 //
 735 //    return clone;
 736 //  }
 737 
 738   /**
 739    *  Returns the next node in the set and advances the position of the
 740    * iterator in the set. After a NodeIterator is created, the first call
 741    * to nextNode() returns the first node in the set.
 742    * @return  The next &lt;code&gt;Node&lt;/code&gt; in the set being iterated over, or
 743    *   &lt;code&gt;null&lt;/code&gt; if there are no more members in that set.
 744    */
 745   public abstract int nextNode();
 746 
 747   /**
 748    * Bottleneck the return of a next node, to make returns
 749    * easier from nextNode().
 750    *
 751    * @param nextNode The next node found, may be null.
 752    *
 753    * @return The same node that was passed as an argument.
 754    */
 755   protected int returnNextNode(int nextNode)
 756   {
 757 
 758     if (DTM.NULL != nextNode)
 759     {
 760       m_pos++;
 761     }
 762 
 763     m_lastFetched = nextNode;
 764 
 765     if (DTM.NULL == nextNode)
 766       m_foundLast = true;
 767 
 768     return nextNode;
 769   }
 770 
 771   /**
 772    * Return the last fetched node.  Needed to support the UnionPathIterator.
 773    *
 774    * @return The last fetched node, or null if the last fetch was null.
 775    */
 776   public int getCurrentNode()
 777   {
 778     return m_lastFetched;
 779   }
 780 
 781   /**
 782    * If an index is requested, NodeSetDTM will call this method
 783    * to run the iterator to the index.  By default this sets
 784    * m_next to the index.  If the index argument is -1, this
 785    * signals that the iterator should be run to the end.
 786    *
 787    * @param index The index to run to, or -1 if the iterator
 788    * should run to the end.
 789    */
 790   public void runTo(int index)
 791   {
 792 
 793     if (m_foundLast || ((index &gt;= 0) &amp;&amp; (index &lt;= getCurrentPos())))
 794       return;
 795 
 796     int n;
 797 
 798     if (-1 == index)
 799     {
 800       while (DTM.NULL != (n = nextNode()));
 801     }
 802     else
 803     {
 804       while (DTM.NULL != (n = nextNode()))
 805       {
 806         if (getCurrentPos() &gt;= index)
 807           break;
 808       }
 809     }
 810   }
 811 
 812   /**
 813    * Tells if we&#39;ve found the last node yet.
 814    *
 815    * @return true if the last nextNode returned null.
 816    */
 817   public final boolean getFoundLast()
 818   {
 819     return m_foundLast;
 820   }
 821 
 822   /**
 823    * The XPath execution context we are operating on.
 824    *
 825    * @return XPath execution context this iterator is operating on,
 826    * or null if setRoot has not been called.
 827    */
 828   public final XPathContext getXPathContext()
 829   {
 830     return m_execContext;
 831   }
 832 
 833   /**
 834    * The node context for the iterator.
 835    *
 836    * @return The node context, same as getRoot().
 837    */
 838   public final int getContext()
 839   {
 840     return m_context;
 841   }
 842 
 843   /**
 844    * The node context from where the expression is being
 845    * executed from (i.e. for current() support).
 846    *
 847    * @return The top-level node context of the entire expression.
 848    */
 849   public final int getCurrentContextNode()
 850   {
 851     return m_currentContextNode;
 852   }
 853 
 854   /**
 855    * Set the current context node for this iterator.
 856    *
 857    * @param n Must be a non-null reference to the node context.
 858    */
 859   public final void setCurrentContextNode(int n)
 860   {
 861     m_currentContextNode = n;
 862   }
 863 
 864 //  /**
 865 //   * Set the current context node for this iterator.
 866 //   *
 867 //   * @param n Must be a non-null reference to the node context.
 868 //   */
 869 //  public void setRoot(int n)
 870 //  {
 871 //    m_context = n;
 872 //    m_cdtm = m_execContext.getDTM(n);
 873 //  }
 874 
 875   /**
 876    * Return the saved reference to the prefix resolver that
 877    * was in effect when this iterator was created.
 878    *
 879    * @return The prefix resolver or this iterator, which may be null.
 880    */
 881   public final PrefixResolver getPrefixResolver()
 882   {
 883         if(null == m_prefixResolver)
 884         {
 885         m_prefixResolver = (PrefixResolver)getExpressionOwner();
 886         }
 887 
 888     return m_prefixResolver;
 889   }
 890 
 891 //  /**
 892 //   * Get the analysis pattern built by the WalkerFactory.
 893 //   *
 894 //   * @return The analysis pattern built by the WalkerFactory.
 895 //   */
 896 //  int getAnalysis()
 897 //  {
 898 //    return m_analysis;
 899 //  }
 900 
 901 //  /**
 902 //   * Set the analysis pattern built by the WalkerFactory.
 903 //   *
 904 //   * @param a The analysis pattern built by the WalkerFactory.
 905 //   */
 906 //  void setAnalysis(int a)
 907 //  {
 908 //    m_analysis = a;
 909 //  }
 910 
 911   /**
 912    * @see com.sun.org.apache.xpath.internal.XPathVisitable#callVisitors(ExpressionOwner, XPathVisitor)
 913    */
 914   public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
 915   {
 916                 if(visitor.visitLocationPath(owner, this))
 917                 {
 918                         visitor.visitStep(owner, this);
 919                         callPredicateVisitors(visitor);
 920                 }
 921   }
 922 
 923 
 924   //============= State Data =============
 925 
 926   /**
 927    * The pool for cloned iterators.  Iterators need to be cloned
 928    * because the hold running state, and thus the original iterator
 929    * expression from the stylesheet pool can not be used.
 930    */
 931   transient protected IteratorPool m_clones = new IteratorPool(this);
 932 
 933   /**
 934    * The dtm of the context node.  Careful about using this... it may not
 935    * be the dtm of the current node.
 936    */
 937   transient protected DTM m_cdtm;
 938 
 939   /**
 940    * The stack frame index for this iterator.
 941    */
 942   transient int m_stackFrame = -1;
 943 
 944   /**
 945    * Value determined at compile time, indicates that this is an
 946    * iterator at the top level of the expression, rather than inside
 947    * a predicate.
 948    * @serial
 949    */
 950   private boolean m_isTopLevel = false;
 951 
 952   /** The last node that was fetched, usually by nextNode. */
 953   transient public int m_lastFetched = DTM.NULL;
 954 
 955   /**
 956    * The context node for this iterator, which doesn&#39;t change through
 957    * the course of the iteration.
 958    */
 959   transient protected int m_context = DTM.NULL;
 960 
 961   /**
 962    * The node context from where the expression is being
 963    * executed from (i.e. for current() support).  Different
 964    * from m_context in that this is the context for the entire
 965    * expression, rather than the context for the subexpression.
 966    */
 967   transient protected int m_currentContextNode = DTM.NULL;
 968 
 969   /**
 970    * The current position of the context node.
 971    */
 972   transient protected int m_pos = 0;
 973 
 974   transient protected int m_length = -1;
 975 
 976   /**
 977    * Fast access to the current prefix resolver.  It isn&#39;t really
 978    * clear that this is needed.
 979    * @serial
 980    */
 981   private PrefixResolver m_prefixResolver;
 982 
 983   /**
 984    * The XPathContext reference, needed for execution of many
 985    * operations.
 986    */
 987   transient protected XPathContext m_execContext;
 988 
 989   /**
 990    * Returns true if all the nodes in the iteration well be returned in document
 991    * order.
 992    *
 993    * @return true as a default.
 994    */
 995   public boolean isDocOrdered()
 996   {
 997     return true;
 998   }
 999 
1000   /**
1001    * Returns the axis being iterated, if it is known.
1002    *
1003    * @return Axis.CHILD, etc., or -1 if the axis is not known or is of multiple
1004    * types.
1005    */
1006   public int getAxis()
1007   {
1008     return -1;
1009   }
1010 
1011 
1012 //  /**
1013 //   * The analysis pattern built by the WalkerFactory.
1014 //   * TODO: Move to LocPathIterator.
1015 //   * @see com.sun.org.apache.xpath.internal.axes.WalkerFactory
1016 //   * @serial
1017 //   */
1018 //  protected int m_analysis = 0x00000000;
1019   /**
1020    * @see PredicatedNodeTest#getLastPos(XPathContext)
1021    */
1022   public int getLastPos(XPathContext xctxt)
1023   {
1024     return getLength();
1025   }
1026 
1027 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xpath/internal/axes/PredicatedNodeTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xpath.internal.axes;
 22 
 23 import com.sun.org.apache.xml.internal.dtm.DTM;
 24 import com.sun.org.apache.xml.internal.dtm.DTMIterator;
 25 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
 26 import com.sun.org.apache.xml.internal.utils.QName;
 27 import com.sun.org.apache.xpath.internal.Expression;
 28 import com.sun.org.apache.xpath.internal.ExpressionOwner;
 29 import com.sun.org.apache.xpath.internal.XPathContext;
 30 import com.sun.org.apache.xpath.internal.XPathVisitor;
 31 import com.sun.org.apache.xpath.internal.compiler.Compiler;
 32 import com.sun.org.apache.xpath.internal.objects.XObject;
 33 import com.sun.org.apache.xpath.internal.patterns.NodeTest;
 34 import java.util.List;
 35 
 36 /**
<a name="2" id="anc2"></a><span class="line-modified"> 37  * @LastModified: May 2020</span>
 38  */
 39 public abstract class PredicatedNodeTest extends NodeTest implements SubContextList
 40 {
 41     static final long serialVersionUID = -6193530757296377351L;
 42 
 43   /**
 44    * Construct an AxesWalker using a LocPathIterator.
 45    *
 46    * @param locPathIterator non-null reference to the parent iterator.
 47    */
 48   PredicatedNodeTest(LocPathIterator locPathIterator)
 49   {
 50     m_lpi = locPathIterator;
 51   }
 52 
 53   /**
 54    * Construct an AxesWalker.  The location path iterator will have to be set
 55    * before use.
 56    */
 57   PredicatedNodeTest()
 58   {
 59   }
 60 
 61   /**
 62    * Read the object from a serialization stream.
 63    *
 64    * @param stream Input stream to read from
 65    *
<a name="3" id="anc3"></a><span class="line-modified"> 66    * @throws java.io.IOException in case of any IO related exceptions</span>
<span class="line-modified"> 67    * @throws ClassNotFoundException if Class of the serialized object cannot be found</span>
 68    */
 69   private void readObject(java.io.ObjectInputStream stream)
<a name="4" id="anc4"></a><span class="line-modified"> 70           throws java.io.IOException, ClassNotFoundException</span>
 71   {
<a name="5" id="anc5"></a><span class="line-modified"> 72     stream.defaultReadObject();</span>
<span class="line-modified"> 73     m_predicateIndex = -1;</span>


 74 
<a name="6" id="anc6"></a><span class="line-modified"> 75     /**</span>
<span class="line-modified"> 76      * Initialize to the declared value.</span>
<span class="line-modified"> 77      * As noted at declaration, this variable is used only for clones for getLastPos,</span>
<span class="line-modified"> 78      * it should have been excluded from serialization. For compatibility, we&#39;ll</span>
<span class="line-modified"> 79      * keep it as is but initializing to the declared value.</span>
<span class="line-modified"> 80      */</span>
<span class="line-modified"> 81     m_predCount = -1;</span>
<span class="line-modified"> 82     resetProximityPositions();</span>





 83   }
 84 
 85   /**
 86    * Get a cloned PrdicatedNodeTest.
 87    *
 88    * @return A new PredicatedNodeTest that can be used without mutating this one.
 89    *
 90    * @throws CloneNotSupportedException
 91    */
 92   public Object clone() throws CloneNotSupportedException
 93   {
 94     // Do not access the location path itterator during this operation!
 95 
 96     PredicatedNodeTest clone = (PredicatedNodeTest) super.clone();
 97 
 98     if ((null != this.m_proximityPositions)
 99             &amp;&amp; (this.m_proximityPositions == clone.m_proximityPositions))
100     {
101       clone.m_proximityPositions = new int[this.m_proximityPositions.length];
102 
103       System.arraycopy(this.m_proximityPositions, 0,
104                        clone.m_proximityPositions, 0,
105                        this.m_proximityPositions.length);
106     }
107 
108     if(clone.m_lpi == this)
109       clone.m_lpi = (LocPathIterator)clone;
110 
111     return clone;
112   }
113 
114   // Only for clones for findLastPos.  See bug4638.
115   protected int m_predCount = -1;
116 
117   /**
118    * Get the number of predicates that this walker has.
119    *
120    * @return the number of predicates that this walker has.
121    */
122   public int getPredicateCount()
123   {
124     if(-1 == m_predCount)
125       return (null == m_predicates) ? 0 : m_predicates.length;
126     else
127       return m_predCount;
128   }
129 
130   /**
131    * Set the number of predicates that this walker has.  This does more
132    * that one would think, as it creates a new predicate array of the
133    * size of the count argument, and copies count predicates into the new
134    * one from the old, and then reassigns the predicates value.  All this
135    * to keep from having to have a predicate count value.
136    *
137    * @param count The number of predicates, which must be equal or less
138    *               than the existing count.
139    */
140   public void setPredicateCount(int count)
141   {
142     if(count &gt; 0)
143     {
144       Expression[] newPredicates = new Expression[count];
145       for (int i = 0; i &lt; count; i++)
146       {
147         newPredicates[i] = m_predicates[i];
148       }
149       m_predicates = newPredicates;
150     }
151     else
152       m_predicates = null;
153 
154   }
155 
156   /**
157    * Init predicate info.
158    *
159    * @param compiler The Compiler object that has information about this
160    *                 walker in the op map.
161    * @param opPos The op code position of this location step.
162    *
163    * @throws javax.xml.transform.TransformerException
164    */
165   protected void initPredicateInfo(Compiler compiler, int opPos)
166           throws javax.xml.transform.TransformerException
167   {
168 
169     int pos = compiler.getFirstPredicateOpPos(opPos);
170 
171     if(pos &gt; 0)
172     {
173       m_predicates = compiler.getCompiledPredicates(pos);
174       if(null != m_predicates)
175       {
176         for(int i = 0; i &lt; m_predicates.length; i++)
177         {
178                 m_predicates[i].exprSetParent(this);
179         }
180       }
181     }
182   }
183 
184   /**
185    * Get a predicate expression at the given index.
186    *
187    *
188    * @param index Index of the predicate.
189    *
190    * @return A predicate expression.
191    */
192   public Expression getPredicate(int index)
193   {
194     return m_predicates[index];
195   }
196 
197   /**
198    * Get the current sub-context position.
199    *
200    * @return The node position of this walker in the sub-context node list.
201    */
202   public int getProximityPosition()
203   {
204 
205     // System.out.println(&quot;getProximityPosition - m_predicateIndex: &quot;+m_predicateIndex);
206     return getProximityPosition(m_predicateIndex);
207   }
208 
209   /**
210    * Get the current sub-context position.
211    *
212    * @param xctxt The XPath runtime context.
213    *
214    * @return The node position of this walker in the sub-context node list.
215    */
216   public int getProximityPosition(XPathContext xctxt)
217   {
218     return getProximityPosition();
219   }
220 
221   /**
222    * Get the index of the last node that can be itterated to.
223    *
224    *
225    * @param xctxt XPath runtime context.
226    *
227    * @return the index of the last node that can be itterated to.
228    */
229   public abstract int getLastPos(XPathContext xctxt);
230 
231   /**
232    * Get the current sub-context position.
233    *
234    * @param predicateIndex The index of the predicate where the proximity
235    *                       should be taken from.
236    *
237    * @return The node position of this walker in the sub-context node list.
238    */
239   protected int getProximityPosition(int predicateIndex)
240   {
241     return (predicateIndex &gt;= 0) ? m_proximityPositions[predicateIndex] : 0;
242   }
243 
244   /**
245    * Reset the proximity positions counts.
246    */
247   public void resetProximityPositions()
248   {
249     int nPredicates = getPredicateCount();
250     if (nPredicates &gt; 0)
251     {
252       if (null == m_proximityPositions)
253         m_proximityPositions = new int[nPredicates];
254 
255       for (int i = 0; i &lt; nPredicates; i++)
256       {
257         try
258         {
259           initProximityPosition(i);
260         }
261         catch(Exception e)
262         {
263           // TODO: Fix this...
264           throw new com.sun.org.apache.xml.internal.utils.WrappedRuntimeException(e);
265         }
266       }
267     }
268   }
269 
270   /**
271    * Init the proximity position to zero for a forward axes.
272    *
273    * @param i The index into the m_proximityPositions array.
274    *
275    * @throws javax.xml.transform.TransformerException
276    */
277   public void initProximityPosition(int i) throws javax.xml.transform.TransformerException
278   {
279     m_proximityPositions[i] = 0;
280   }
281 
282   /**
283    * Count forward one proximity position.
284    *
285    * @param i The index into the m_proximityPositions array, where the increment
286    *          will occur.
287    */
288   protected void countProximityPosition(int i)
289   {
290         // Note that in the case of a UnionChildIterator, this may be a
291         // static object and so m_proximityPositions may indeed be null!
292         int[] pp = m_proximityPositions;
293     if ((null != pp) &amp;&amp; (i &lt; pp.length))
294       pp[i]++;
295   }
296 
297   /**
298    * Tells if this is a reverse axes.
299    *
300    * @return false, unless a derived class overrides.
301    */
302   public boolean isReverseAxes()
303   {
304     return false;
305   }
306 
307   /**
308    * Get which predicate is executing.
309    *
310    * @return The current predicate index, or -1 if no predicate is executing.
311    */
312   public int getPredicateIndex()
313   {
314     return m_predicateIndex;
315   }
316 
317   /**
318    * Process the predicates.
319    *
320    * @param context The current context node.
321    * @param xctxt The XPath runtime context.
322    *
323    * @return the result of executing the predicate expressions.
324    *
325    * @throws javax.xml.transform.TransformerException
326    */
327   boolean executePredicates(int context, XPathContext xctxt)
328           throws javax.xml.transform.TransformerException
329   {
330 
331     int nPredicates = getPredicateCount();
332     // System.out.println(&quot;nPredicates: &quot;+nPredicates);
333     if (nPredicates == 0)
334       return true;
335 
336     PrefixResolver savedResolver = xctxt.getNamespaceContext();
337 
338     try
339     {
340       m_predicateIndex = 0;
341       xctxt.pushSubContextList(this);
342       xctxt.pushNamespaceContext(m_lpi.getPrefixResolver());
343       xctxt.pushCurrentNode(context);
344 
345       for (int i = 0; i &lt; nPredicates; i++)
346       {
347         // System.out.println(&quot;Executing predicate expression - waiting count: &quot;+m_lpi.getWaitingCount());
348         XObject pred = m_predicates[i].execute(xctxt);
349         // System.out.println(&quot;\nBack from executing predicate expression - waiting count: &quot;+m_lpi.getWaitingCount());
350         // System.out.println(&quot;pred.getType(): &quot;+pred.getType());
351         if (XObject.CLASS_NUMBER == pred.getType())
352         {
353           if (DEBUG_PREDICATECOUNTING)
354           {
355             System.out.flush();
356             System.out.println(&quot;\n===== start predicate count ========&quot;);
357             System.out.println(&quot;m_predicateIndex: &quot; + m_predicateIndex);
358             // System.out.println(&quot;getProximityPosition(m_predicateIndex): &quot;
359             //                   + getProximityPosition(m_predicateIndex));
360             System.out.println(&quot;pred.num(): &quot; + pred.num());
361           }
362 
363           int proxPos = this.getProximityPosition(m_predicateIndex);
364           int predIndex = (int) pred.num();
365           if (proxPos != predIndex)
366           {
367             if (DEBUG_PREDICATECOUNTING)
368             {
369               System.out.println(&quot;\nnode context: &quot;+nodeToString(context));
370               System.out.println(&quot;index predicate is false: &quot;+proxPos);
371               System.out.println(&quot;\n===== end predicate count ========&quot;);
372             }
373             return false;
374           }
375           else if (DEBUG_PREDICATECOUNTING)
376           {
377             System.out.println(&quot;\nnode context: &quot;+nodeToString(context));
378             System.out.println(&quot;index predicate is true: &quot;+proxPos);
379             System.out.println(&quot;\n===== end predicate count ========&quot;);
380           }
381 
382           // If there is a proximity index that will not change during the
383           // course of itteration, then we know there can be no more true
384           // occurances of this predicate, so flag that we&#39;re done after
385           // this.
386           //
387           // bugzilla 14365
388           // We can&#39;t set m_foundLast = true unless we&#39;re sure that -all-
389           // remaining parameters are stable, or else last() fails. Fixed so
390           // only sets m_foundLast if on the last predicate
391           if(m_predicates[i].isStableNumber() &amp;&amp; i == nPredicates - 1)
392           {
393             m_foundLast = true;
394           }
395         }
396         else if (!pred.bool())
397           return false;
398 
399         countProximityPosition(++m_predicateIndex);
400       }
401     }
402     finally
403     {
404       xctxt.popCurrentNode();
405       xctxt.popNamespaceContext();
406       xctxt.popSubContextList();
407       m_predicateIndex = -1;
408     }
409 
410     return true;
411   }
412 
413   /**
414    * This function is used to fixup variables from QNames to stack frame
415    * indexes at stylesheet build time.
416    * @param vars List of QNames that correspond to variables.  This list
417    * should be searched backwards for the first qualified name that
418    * corresponds to the variable reference qname.  The position of the
419    * QName in the vector from the start of the vector will be its position
420    * in the stack frame (but variables above the globalsTop value will need
421    * to be offset to the current stack frame).
422    */
423   public void fixupVariables(List&lt;QName&gt; vars, int globalsSize)
424   {
425     super.fixupVariables(vars, globalsSize);
426 
427     int nPredicates = getPredicateCount();
428 
429     for (int i = 0; i &lt; nPredicates; i++)
430     {
431       m_predicates[i].fixupVariables(vars, globalsSize);
432     }
433   }
434 
435 
436   /**
437    * Diagnostics.
438    *
439    * @param n Node to give diagnostic information about, or null.
440    *
441    * @return Informative string about the argument.
442    */
443   protected String nodeToString(int n)
444   {
445     if(DTM.NULL != n)
446     {
447       DTM dtm = m_lpi.getXPathContext().getDTM(n);
448       return dtm.getNodeName(n) + &quot;{&quot; + (n+1) + &quot;}&quot;;
449     }
450     else
451     {
452       return &quot;null&quot;;
453     }
454   }
455 
456   //=============== NodeFilter Implementation ===============
457 
458   /**
459    *  Test whether a specified node is visible in the logical view of a
460    * TreeWalker or NodeIterator. This function will be called by the
461    * implementation of TreeWalker and NodeIterator; it is not intended to
462    * be called directly from user code.
463    * @param n  The node to check to see if it passes the filter or not.
464    * @return  a constant to determine whether the node is accepted,
465    *   rejected, or skipped, as defined  above .
466    */
467   public short acceptNode(int n)
468   {
469 
470     XPathContext xctxt = m_lpi.getXPathContext();
471 
472     try
473     {
474       xctxt.pushCurrentNode(n);
475 
476       XObject score = execute(xctxt, n);
477 
478       // System.out.println(&quot;\n::acceptNode - score: &quot;+score.num()+&quot;::&quot;);
479       if (score != NodeTest.SCORE_NONE)
480       {
481         if (getPredicateCount() &gt; 0)
482         {
483           countProximityPosition(0);
484 
485           if (!executePredicates(n, xctxt))
486             return DTMIterator.FILTER_SKIP;
487         }
488 
489         return DTMIterator.FILTER_ACCEPT;
490       }
491     }
492     catch (javax.xml.transform.TransformerException se)
493     {
494 
495       // TODO: Fix this.
496       throw new RuntimeException(se.getMessage());
497     }
498     finally
499     {
500       xctxt.popCurrentNode();
501     }
502 
503     return DTMIterator.FILTER_SKIP;
504   }
505 
506 
507   /**
508    * Get the owning location path iterator.
509    *
510    * @return the owning location path iterator, which should not be null.
511    */
512   public LocPathIterator getLocPathIterator()
513   {
514     return m_lpi;
515   }
516 
517   /**
518    * Set the location path iterator owner for this walker.  Besides
519    * initialization, this function is called during cloning operations.
520    *
521    * @param li non-null reference to the owning location path iterator.
522    */
523   public void setLocPathIterator(LocPathIterator li)
524   {
525     m_lpi = li;
526     if(this != li)
527       li.exprSetParent(this);
528   }
529 
530   /**
531    * Tell if this expression or it&#39;s subexpressions can traverse outside
532    * the current subtree.
533    *
534    * @return true if traversal outside the context node&#39;s subtree can occur.
535    */
536    public boolean canTraverseOutsideSubtree()
537    {
538     int n = getPredicateCount();
539     for (int i = 0; i &lt; n; i++)
540     {
541       if(getPredicate(i).canTraverseOutsideSubtree())
542         return true;
543     }
544     return false;
545    }
546 
547         /**
548          * This will traverse the heararchy, calling the visitor for
549          * each member.  If the called visitor method returns
550          * false, the subtree should not be called.
551          *
552          * @param visitor The visitor whose appropriate method will be called.
553          */
554         public void callPredicateVisitors(XPathVisitor visitor)
555         {
556           if (null != m_predicates)
557             {
558             int n = m_predicates.length;
559             for (int i = 0; i &lt; n; i++)
560               {
561               ExpressionOwner predOwner = new PredOwner(i);
562               if (visitor.visitPredicate(predOwner, m_predicates[i]))
563                 {
564                 m_predicates[i].callVisitors(predOwner, visitor);
565               }
566 
567             }
568           }
569         }
570 
571     /**
572      * @see Expression#deepEquals(Expression)
573      */
574     public boolean deepEquals(Expression expr)
575     {
576       if (!super.deepEquals(expr))
577             return false;
578 
579       PredicatedNodeTest pnt = (PredicatedNodeTest) expr;
580       if (null != m_predicates)
581       {
582 
583         int n = m_predicates.length;
584         if ((null == pnt.m_predicates) || (pnt.m_predicates.length != n))
585               return false;
586         for (int i = 0; i &lt; n; i++)
587         {
588           if (!m_predicates[i].deepEquals(pnt.m_predicates[i]))
589                 return false;
590         }
591       }
592       else if (null != pnt.m_predicates)
593               return false;
594 
595       return true;
596     }
597 
598   /** This is true if nextNode returns null. */
599   transient protected boolean m_foundLast = false;
600 
601   /** The owning location path iterator.
602    *  @serial */
603   protected LocPathIterator m_lpi;
604 
605   /**
606    * Which predicate we are executing.
607    */
608   transient int m_predicateIndex = -1;
609 
610   /** The list of predicate expressions. Is static and does not need
611    *  to be deep cloned.
612    *  @serial
613    */
614   private Expression[] m_predicates;
615 
616   /**
617    * An array of counts that correspond to the number
618    * of predicates the step contains.
619    */
620   transient protected int[] m_proximityPositions;
621 
622   /** If true, diagnostic messages about predicate execution will be posted.  */
623   static final boolean DEBUG_PREDICATECOUNTING = false;
624 
625   class PredOwner implements ExpressionOwner
626   {
627         int m_index;
628 
629         PredOwner(int index)
630         {
631                 m_index = index;
632         }
633 
634     /**
635      * @see ExpressionOwner#getExpression()
636      */
637     public Expression getExpression()
638     {
639       return m_predicates[m_index];
640     }
641 
642 
643     /**
644      * @see ExpressionOwner#setExpression(Expression)
645      */
646     public void setExpression(Expression exp)
647     {
648         exp.exprSetParent(PredicatedNodeTest.this);
649         m_predicates[m_index] = exp;
650     }
651   }
652 
653 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
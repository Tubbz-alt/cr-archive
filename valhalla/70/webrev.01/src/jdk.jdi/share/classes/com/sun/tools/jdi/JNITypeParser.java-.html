<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdi/share/classes/com/sun/tools/jdi/JNITypeParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.jdi;
 27 
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 public class JNITypeParser {
 32 
 33     static final char SIGNATURE_ENDCLASS = &#39;;&#39;;
 34     static final char SIGNATURE_FUNC = &#39;(&#39;;
 35     static final char SIGNATURE_ENDFUNC = &#39;)&#39;;
 36 
 37     private String signature;
 38     private List&lt;String&gt; typeNameList;
 39     private List&lt;String&gt; signatureList;
 40     private int currentIndex;
 41 
 42     JNITypeParser(String signature) {
 43         this.signature = signature;
 44     }
 45 
 46     static String typeNameToSignature(String typeName) {
 47         StringBuilder sb = new StringBuilder();
 48         int firstIndex = typeName.indexOf(&#39;[&#39;);
 49         int index = firstIndex;
 50         while (index != -1) {
 51             sb.append(&#39;[&#39;);
 52             index = typeName.indexOf(&#39;[&#39;, index + 1);
 53         }
 54 
 55         if (firstIndex != -1) {
 56             typeName = typeName.substring(0, firstIndex);
 57         }
 58 
 59         if (typeName.equals(&quot;boolean&quot;)) {
 60             sb.append(&#39;Z&#39;);
 61         } else if (typeName.equals(&quot;byte&quot;)) {
 62             sb.append(&#39;B&#39;);
 63         } else if (typeName.equals(&quot;char&quot;)) {
 64             sb.append(&#39;C&#39;);
 65         } else if (typeName.equals(&quot;short&quot;)) {
 66             sb.append(&#39;S&#39;);
 67         } else if (typeName.equals(&quot;int&quot;)) {
 68             sb.append(&#39;I&#39;);
 69         } else if (typeName.equals(&quot;long&quot;)) {
 70             sb.append(&#39;J&#39;);
 71         } else if (typeName.equals(&quot;float&quot;)) {
 72             sb.append(&#39;F&#39;);
 73         } else if (typeName.equals(&quot;double&quot;)) {
 74             sb.append(&#39;D&#39;);
 75         } else {
 76             sb.append(&#39;L&#39;);
 77             index = typeName.indexOf(&quot;/&quot;);   // check if it&#39;s a hidden class
 78             if (index &lt; 0) {
 79                 sb.append(typeName.replace(&#39;.&#39;, &#39;/&#39;));
 80             } else {
 81                 sb.append(typeName.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;));
 82                 sb.append(&quot;.&quot;);
 83                 sb.append(typeName.substring(index + 1));
 84             }
 85             sb.append(&#39;;&#39;);
 86         }
 87 
 88         return sb.toString();
 89     }
 90 
 91     String typeName() {
 92         return typeNameList().get(typeNameList().size()-1);
 93     }
 94 
 95     List&lt;String&gt; argumentTypeNames() {
 96         return typeNameList().subList(0, typeNameList().size() - 1);
 97     }
 98 
 99     String signature() {
100         return signatureList().get(signatureList().size()-1);
101     }
102 
103     List&lt;String&gt; argumentSignatures() {
104         return signatureList().subList(0, signatureList().size() - 1);
105     }
106 
107     int dimensionCount() {
108         int count = 0;
109         String signature = signature();
110         while (signature.charAt(count) == &#39;[&#39;) {
111             count++;
112         }
113         return count;
114     }
115 
116     String componentSignature(int level) {
117         return signature().substring(level);
118     }
119 
120     private synchronized List&lt;String&gt; signatureList() {
121         if (signatureList == null) {
122             signatureList = new ArrayList&lt;&gt;(10);
123             String elem;
124 
125             currentIndex = 0;
126 
127             while(currentIndex &lt; signature.length()) {
128                 elem = nextSignature();
129                 signatureList.add(elem);
130             }
131             if (signatureList.size() == 0) {
132                 throw new IllegalArgumentException(&quot;Invalid JNI signature &#39;&quot; +
133                                                    signature + &quot;&#39;&quot;);
134             }
135         }
136         return signatureList;
137     }
138 
139     private synchronized List&lt;String&gt; typeNameList() {
140         if (typeNameList == null) {
141             typeNameList = new ArrayList&lt;&gt;(10);
142             String elem;
143 
144             currentIndex = 0;
145 
146             while(currentIndex &lt; signature.length()) {
147                 elem = nextTypeName();
148                 typeNameList.add(elem);
149             }
150             if (typeNameList.size() == 0) {
151                 throw new IllegalArgumentException(&quot;Invalid JNI signature &#39;&quot; +
152                                                    signature + &quot;&#39;&quot;);
153             }
154         }
155         return typeNameList;
156     }
157 
158     private String nextSignature() {
159         char key = signature.charAt(currentIndex++);
160 
161         switch(key) {
162             case (JDWP.Tag.ARRAY):
163                 return  key + nextSignature();
164 
165             case (JDWP.Tag.OBJECT):
166             case (JDWP.Tag.INLINE_OBJECT):
167                 int endClass = signature.indexOf(SIGNATURE_ENDCLASS,
168                                                  currentIndex);
169                 String retVal = signature.substring(currentIndex - 1,
170                                                     endClass + 1);
171                 currentIndex = endClass + 1;
172                 return retVal;
173 
174             case (JDWP.Tag.VOID):
175             case (JDWP.Tag.BOOLEAN):
176             case (JDWP.Tag.BYTE):
177             case (JDWP.Tag.CHAR):
178             case (JDWP.Tag.SHORT):
179             case (JDWP.Tag.INT):
180             case (JDWP.Tag.LONG):
181             case (JDWP.Tag.FLOAT):
182             case (JDWP.Tag.DOUBLE):
183                 return String.valueOf(key);
184 
185             case SIGNATURE_ENDFUNC:
186             case SIGNATURE_FUNC:
187                 return nextSignature();
188 
189             default:
190                 throw new IllegalArgumentException(
191                     &quot;Invalid JNI signature character &#39;&quot; + key + &quot;&#39;&quot;);
192 
193         }
194     }
195 
196     private String nextTypeName() {
197         char key = signature.charAt(currentIndex++);
198 
199         switch(key) {
200             case (JDWP.Tag.ARRAY):
201                 return  nextTypeName() + &quot;[]&quot;;
202 
203             case (JDWP.Tag.BYTE):
204                 return &quot;byte&quot;;
205 
206             case (JDWP.Tag.CHAR):
207                 return &quot;char&quot;;
208 
209             case (JDWP.Tag.OBJECT):
210             case (JDWP.Tag.INLINE_OBJECT):
211                 int endClass = signature.indexOf(SIGNATURE_ENDCLASS,
212                                                  currentIndex);
213                 String retVal = signature.substring(currentIndex,
214                                                     endClass);
215                 int index = retVal.indexOf(&quot;.&quot;);
216                 if (index &lt; 0) {
217                     retVal = retVal.replace(&#39;/&#39;, &#39;.&#39;);
218                 } else {
219                     // hidden class
220                     retVal = retVal.substring(0, index).replace(&#39;/&#39;, &#39;.&#39;)
221                                 + &quot;/&quot; + retVal.substring(index + 1);
222                 }
223                 currentIndex = endClass + 1;
224                 return retVal;
225 
226             case (JDWP.Tag.FLOAT):
227                 return &quot;float&quot;;
228 
229             case (JDWP.Tag.DOUBLE):
230                 return &quot;double&quot;;
231 
232             case (JDWP.Tag.INT):
233                 return &quot;int&quot;;
234 
235             case (JDWP.Tag.LONG):
236                 return &quot;long&quot;;
237 
238             case (JDWP.Tag.SHORT):
239                 return &quot;short&quot;;
240 
241             case (JDWP.Tag.VOID):
242                 return &quot;void&quot;;
243 
244             case (JDWP.Tag.BOOLEAN):
245                 return &quot;boolean&quot;;
246 
247             case SIGNATURE_ENDFUNC:
248             case SIGNATURE_FUNC:
249                 return nextTypeName();
250 
251             default:
252                 throw new IllegalArgumentException(
253                     &quot;Invalid JNI signature character &#39;&quot; + key + &quot;&#39;&quot;);
254         }
255     }
256 }
    </pre>
  </body>
</html>
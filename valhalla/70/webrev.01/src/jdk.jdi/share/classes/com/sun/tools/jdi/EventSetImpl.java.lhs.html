<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdi/share/classes/com/sun/tools/jdi/EventSetImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.jdi;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collection;
 30 import java.util.Iterator;
 31 import java.util.NoSuchElementException;
 32 import java.util.Spliterator;
 33 import java.util.Spliterators;
 34 
 35 import com.sun.jdi.Field;
 36 import com.sun.jdi.InternalException;
 37 import com.sun.jdi.Locatable;
 38 import com.sun.jdi.Location;
 39 import com.sun.jdi.Method;
 40 import com.sun.jdi.ObjectReference;
 41 import com.sun.jdi.ReferenceType;
 42 import com.sun.jdi.ThreadReference;
 43 import com.sun.jdi.VMDisconnectedException;
 44 import com.sun.jdi.Value;
 45 import com.sun.jdi.VirtualMachine;
 46 import com.sun.jdi.event.AccessWatchpointEvent;
 47 import com.sun.jdi.event.BreakpointEvent;
 48 import com.sun.jdi.event.ClassPrepareEvent;
 49 import com.sun.jdi.event.ClassUnloadEvent;
 50 import com.sun.jdi.event.Event;
 51 import com.sun.jdi.event.EventIterator;
 52 import com.sun.jdi.event.EventSet;
 53 import com.sun.jdi.event.ExceptionEvent;
 54 import com.sun.jdi.event.MethodEntryEvent;
 55 import com.sun.jdi.event.MethodExitEvent;
 56 import com.sun.jdi.event.ModificationWatchpointEvent;
 57 import com.sun.jdi.event.MonitorContendedEnterEvent;
 58 import com.sun.jdi.event.MonitorContendedEnteredEvent;
 59 import com.sun.jdi.event.MonitorWaitEvent;
 60 import com.sun.jdi.event.MonitorWaitedEvent;
 61 import com.sun.jdi.event.StepEvent;
 62 import com.sun.jdi.event.ThreadDeathEvent;
 63 import com.sun.jdi.event.ThreadStartEvent;
 64 import com.sun.jdi.event.VMDeathEvent;
 65 import com.sun.jdi.event.VMDisconnectEvent;
 66 import com.sun.jdi.event.VMStartEvent;
 67 import com.sun.jdi.event.WatchpointEvent;
 68 import com.sun.jdi.request.EventRequest;
 69 
 70 enum EventDestination {UNKNOWN_EVENT, INTERNAL_EVENT, CLIENT_EVENT};
 71 
 72 /*
 73  * An EventSet is normally created by the transport reader thread when
 74  * it reads a JDWP Composite command.  The constructor doesn&#39;t unpack
 75  * the events contained in the Composite command and create EventImpls
 76  * for them because that process might involve calling back into the back-end
 77  * which should not be done by the transport reader thread.  Instead,
 78  * the raw bytes of the packet are read and stored in the EventSet.
 79  * The EventSet is then added to each EventQueue. When an EventSet is
 80  * removed from an EventQueue, the EventSetImpl.build() method is called.
 81  * This method reads the packet bytes and creates the actual EventImpl objects.
 82  * build() also filters out events for our internal handler and puts them in
 83  * their own EventSet.  This means that the EventImpls that are in the EventSet
 84  * that is on the queues are all for client requests.
 85  */
 86 public class EventSetImpl extends ArrayList&lt;Event&gt; implements EventSet {
 87     private static final long serialVersionUID = -4857338819787924570L;
 88     private VirtualMachineImpl vm; // we implement Mirror
 89     private Packet pkt;
 90     private byte suspendPolicy;
 91     private EventSetImpl internalEventSet;
 92 
 93     public String toString() {
 94         String string = &quot;event set, policy:&quot; + suspendPolicy +
 95                         &quot;, count:&quot; + this.size() + &quot; = {&quot;;
 96         boolean first = true;
 97         for (Event event : this) {
 98             if (!first) {
 99                 string += &quot;, &quot;;
100             }
101             string += event.toString();
102             first = false;
103         }
104         string += &quot;}&quot;;
105         return string;
106     }
107 
108     abstract class EventImpl extends MirrorImpl implements Event {
109 
110         private final byte eventCmd;
111         private final int requestID;
112         // This is set only for client requests, not internal requests.
113         private final EventRequest request;
114 
115         /**
116          * Constructor for events.
117          */
118         protected EventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
119                             int requestID) {
120             super(EventSetImpl.this.vm);
121             this.eventCmd = evt.eventKind();
122             this.requestID = requestID;
123             EventRequestManagerImpl ermi = EventSetImpl.this.
124                 vm.eventRequestManagerImpl();
125             this.request =  ermi.request(eventCmd, requestID);
126         }
127 
128         /*
129          * Override superclass back to default equality
130          */
131         public boolean equals(Object obj) {
132             return this == obj;
133         }
134 
135         public int hashCode() {
136             return System.identityHashCode(this);
137         }
138 
139         /**
140          * Constructor for VM disconnected events.
141          */
142         protected EventImpl(byte eventCmd) {
143             super(EventSetImpl.this.vm);
144             this.eventCmd = eventCmd;
145             this.requestID = 0;
146             this.request = null;
147         }
148 
149         public EventRequest request() {
150             return request;
151         }
152 
153         int requestID() {
154             return requestID;
155         }
156 
157         EventDestination destination() {
158             /*
159              * We need to decide if this event is for
160              * 1. an internal request
161              * 2. a client request that is no longer available, ie
162              *    it has been deleted, or disabled and re-enabled
163              *    which gives it a new ID.
164              * 3. a current client request that is disabled
165              * 4. a current enabled client request.
166              *
167              * We will filter this set into a set
168              * that contains only 1s for our internal queue
169              * and a set that contains only 4s for our client queue.
170              * If we get an EventSet that contains only 2 and 3
171              * then we have to resume it if it is not SUSPEND_NONE
172              * because no one else will.
173              */
174             if (requestID == 0) {
175                 /* An unsolicited event.  These have traditionally
176                  * been treated as client events.
177                  */
178                 return EventDestination.CLIENT_EVENT;
179             }
180 
181             // Is this an event for a current client request?
182             if (request == null) {
183                 // Nope.  Is it an event for an internal request?
184                 EventRequestManagerImpl ermi = this.vm.getInternalEventRequestManager();
185                 if (ermi.request(eventCmd, requestID) != null) {
186                     // Yep
187                     return EventDestination.INTERNAL_EVENT;
188                 }
189                 return EventDestination.UNKNOWN_EVENT;
190             }
191 
192             // We found a client request
193             if (request.isEnabled()) {
194                 return EventDestination.CLIENT_EVENT;
195             }
196             return EventDestination.UNKNOWN_EVENT;
197         }
198 
199         abstract String eventName();
200 
201         public String toString() {
202             return eventName();
203         }
204 
205     }
206 
207     abstract class ThreadedEventImpl extends EventImpl {
208         private ThreadReference thread;
209 
210         ThreadedEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
211                           int requestID, ThreadReference thread) {
212             super(evt, requestID);
213             this.thread = thread;
214         }
215 
216         public ThreadReference thread() {
217             return thread;
218         }
219 
220         public String toString() {
221             return eventName() + &quot; in thread &quot; + thread.name();
222         }
223     }
224 
225     abstract class LocatableEventImpl extends ThreadedEventImpl
226                                       implements Locatable {
227         private Location location;
228 
229         LocatableEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
230                            int requestID,
231                            ThreadReference thread, Location location) {
232             super(evt, requestID, thread);
233             this.location = location;
234         }
235 
236         public Location location() {
237             return location;
238         }
239 
240         /**
241          * For MethodEntry and MethodExit
242          */
243         public Method method() {
244             return location.method();
245         }
246 
247         public String toString() {
248             return eventName() + &quot;@&quot; +
249                    ((location() == null) ? &quot; null&quot; : location().toString()) +
250                    &quot; in thread &quot; + thread().name();
251         }
252     }
253 
254     class BreakpointEventImpl extends LocatableEventImpl
255                               implements BreakpointEvent {
256         BreakpointEventImpl(JDWP.Event.Composite.Events.Breakpoint evt) {
257             super(evt, evt.requestID, evt.thread, evt.location);
258         }
259 
260         String eventName() {
261             return &quot;BreakpointEvent&quot;;
262         }
263     }
264 
265     class StepEventImpl extends LocatableEventImpl implements StepEvent {
266         StepEventImpl(JDWP.Event.Composite.Events.SingleStep evt) {
267             super(evt, evt.requestID, evt.thread, evt.location);
268         }
269 
270         String eventName() {
271             return &quot;StepEvent&quot;;
272         }
273     }
274 
275     class MethodEntryEventImpl extends LocatableEventImpl
276                                implements MethodEntryEvent {
277         MethodEntryEventImpl(JDWP.Event.Composite.Events.MethodEntry evt) {
278             super(evt, evt.requestID, evt.thread, evt.location);
279         }
280 
281         String eventName() {
282             return &quot;MethodEntryEvent&quot;;
283         }
284     }
285 
286     class MethodExitEventImpl extends LocatableEventImpl
287                             implements MethodExitEvent {
288         private Value returnVal = null;
289 
290         MethodExitEventImpl(JDWP.Event.Composite.Events.MethodExit evt) {
291             super(evt, evt.requestID, evt.thread, evt.location);
292         }
293 
294         MethodExitEventImpl(JDWP.Event.Composite.Events.MethodExitWithReturnValue evt) {
295             super(evt, evt.requestID, evt.thread, evt.location);
296             returnVal = evt.value;
297         }
298 
299         String eventName() {
300             return &quot;MethodExitEvent&quot;;
301         }
302 
303         public Value returnValue() {
304             if (!this.vm.canGetMethodReturnValues()) {
305                 throw new UnsupportedOperationException(
306                 &quot;target does not support return values in MethodExit events&quot;);
307             }
308             return returnVal;
309         }
310 
311     }
312 
313     class MonitorContendedEnterEventImpl extends LocatableEventImpl
314                             implements MonitorContendedEnterEvent {
315         private ObjectReference monitor = null;
316 
317         MonitorContendedEnterEventImpl(JDWP.Event.Composite.Events.MonitorContendedEnter evt) {
318             super(evt, evt.requestID, evt.thread, evt.location);
319             this.monitor = evt.object;
320         }
321 
322         String eventName() {
323             return &quot;MonitorContendedEnter&quot;;
324         }
325 
326         public ObjectReference  monitor() {
327             return monitor;
328         };
329 
330     }
331 
332     class MonitorContendedEnteredEventImpl extends LocatableEventImpl
333                             implements MonitorContendedEnteredEvent {
334         private ObjectReference monitor = null;
335 
336         MonitorContendedEnteredEventImpl(JDWP.Event.Composite.Events.MonitorContendedEntered evt) {
337             super(evt, evt.requestID, evt.thread, evt.location);
338             this.monitor = evt.object;
339         }
340 
341         String eventName() {
342             return &quot;MonitorContendedEntered&quot;;
343         }
344 
345         public ObjectReference  monitor() {
346             return monitor;
347         };
348 
349     }
350 
351     class MonitorWaitEventImpl extends LocatableEventImpl
352                             implements MonitorWaitEvent {
353         private ObjectReference monitor = null;
354         private long timeout;
355 
356         MonitorWaitEventImpl(JDWP.Event.Composite.Events.MonitorWait evt) {
357             super(evt, evt.requestID, evt.thread, evt.location);
358             this.monitor = evt.object;
359             this.timeout = evt.timeout;
360         }
361 
362         String eventName() {
363             return &quot;MonitorWait&quot;;
364         }
365 
366         public ObjectReference  monitor() {
367             return monitor;
368         };
369 
370         public long timeout() {
371             return timeout;
372         }
373     }
374 
375     class MonitorWaitedEventImpl extends LocatableEventImpl
376                             implements MonitorWaitedEvent {
377         private ObjectReference monitor = null;
378         private boolean timed_out;
379 
380         MonitorWaitedEventImpl(JDWP.Event.Composite.Events.MonitorWaited evt) {
381             super(evt, evt.requestID, evt.thread, evt.location);
382             this.monitor = evt.object;
383             this.timed_out = evt.timed_out;
384         }
385 
386         String eventName() {
387             return &quot;MonitorWaited&quot;;
388         }
389 
390         public ObjectReference  monitor() {
391             return monitor;
392         };
393 
394         public boolean timedout() {
395             return timed_out;
396         }
397     }
398 
399     class ClassPrepareEventImpl extends ThreadedEventImpl
400                             implements ClassPrepareEvent {
401         private ReferenceType referenceType;
402 
403         ClassPrepareEventImpl(JDWP.Event.Composite.Events.ClassPrepare evt) {
404             super(evt, evt.requestID, evt.thread);
405             referenceType = this.vm.referenceType(evt.typeID, evt.refTypeTag,
406                                                   evt.signature);
407             ((ReferenceTypeImpl)referenceType).setStatus(evt.status);
408         }
409 
410         public ReferenceType referenceType() {
411             return referenceType;
412         }
413 
414         String eventName() {
415             return &quot;ClassPrepareEvent&quot;;
416         }
417     }
418 
419     class ClassUnloadEventImpl extends EventImpl implements ClassUnloadEvent {
420         private String classSignature;
421 
422         ClassUnloadEventImpl(JDWP.Event.Composite.Events.ClassUnload evt) {
423             super(evt, evt.requestID);
424             this.classSignature = evt.signature;
425         }
426 
427         public String className() {
<a name="1" id="anc1"></a><span class="line-modified">428             assert classSignature.startsWith(&quot;L&quot;) &amp;&amp; classSignature.endsWith(&quot;;&quot;);</span>
<span class="line-removed">429 </span>
<span class="line-removed">430             // trim leading &quot;L&quot; and trailing &quot;;&quot;</span>
<span class="line-removed">431             String name = classSignature.substring(1, classSignature.length() - 1);</span>
<span class="line-removed">432             int index = name.indexOf(&quot;.&quot;);  // check if it is a hidden class</span>
<span class="line-removed">433             if (index &lt; 0) {</span>
<span class="line-removed">434                 return name.replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-removed">435             }  else {</span>
<span class="line-removed">436                 // map the type descriptor from: &quot;L&quot; + N + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;</span>
<span class="line-removed">437                 // to class name: N.replace(&#39;/&#39;, &#39;.&#39;) + &quot;/&quot; + &lt;suffix&gt;</span>
<span class="line-removed">438                 return name.substring(0, index).replace(&#39;/&#39;, &#39;.&#39;)</span>
<span class="line-removed">439                         + &quot;/&quot; + name.substring(index + 1);</span>
<span class="line-removed">440             }</span>
441         }
442 
443         public String classSignature() {
444             return classSignature;
445         }
446 
447         String eventName() {
448             return &quot;ClassUnloadEvent&quot;;
449         }
450     }
451 
452     class ExceptionEventImpl extends LocatableEventImpl
453                                              implements ExceptionEvent {
454         private ObjectReference exception;
455         private Location catchLocation;
456 
457         ExceptionEventImpl(JDWP.Event.Composite.Events.Exception evt) {
458             super(evt, evt.requestID, evt.thread, evt.location);
459             this.exception = evt.exception;
460             this.catchLocation = evt.catchLocation;
461         }
462 
463         public ObjectReference exception() {
464             return exception;
465         }
466 
467         public Location catchLocation() {
468             return catchLocation;
469         }
470 
471         String eventName() {
472             return &quot;ExceptionEvent&quot;;
473         }
474     }
475 
476     class ThreadDeathEventImpl extends ThreadedEventImpl
477                                         implements ThreadDeathEvent {
478         ThreadDeathEventImpl(JDWP.Event.Composite.Events.ThreadDeath evt) {
479             super(evt, evt.requestID, evt.thread);
480         }
481 
482         String eventName() {
483             return &quot;ThreadDeathEvent&quot;;
484         }
485     }
486 
487     class ThreadStartEventImpl extends ThreadedEventImpl
488                                         implements ThreadStartEvent {
489         ThreadStartEventImpl(JDWP.Event.Composite.Events.ThreadStart evt) {
490             super(evt, evt.requestID, evt.thread);
491         }
492 
493         String eventName() {
494             return &quot;ThreadStartEvent&quot;;
495         }
496     }
497 
498     class VMStartEventImpl extends ThreadedEventImpl
499                                         implements VMStartEvent {
500         VMStartEventImpl(JDWP.Event.Composite.Events.VMStart evt) {
501             super(evt, evt.requestID, evt.thread);
502         }
503 
504         String eventName() {
505             return &quot;VMStartEvent&quot;;
506         }
507     }
508 
509     class VMDeathEventImpl extends EventImpl implements VMDeathEvent {
510 
511         VMDeathEventImpl(JDWP.Event.Composite.Events.VMDeath evt) {
512             super(evt, evt.requestID);
513         }
514 
515         String eventName() {
516             return &quot;VMDeathEvent&quot;;
517         }
518     }
519 
520     class VMDisconnectEventImpl extends EventImpl
521                                          implements VMDisconnectEvent {
522 
523         VMDisconnectEventImpl() {
524             super((byte)JDWP.EventKind.VM_DISCONNECTED);
525         }
526 
527         String eventName() {
528             return &quot;VMDisconnectEvent&quot;;
529         }
530     }
531 
532     abstract class WatchpointEventImpl extends LocatableEventImpl
533                                             implements WatchpointEvent {
534         private final ReferenceTypeImpl refType;
535         private final long fieldID;
536         private final ObjectReference object;
537         private Field field = null;
538 
539         WatchpointEventImpl(JDWP.Event.Composite.Events.EventsCommon evt,
540                             int requestID,
541                             ThreadReference thread, Location location,
542                             byte refTypeTag, long typeID, long fieldID,
543                             ObjectReference object) {
544             super(evt, requestID, thread, location);
545             this.refType = this.vm.referenceType(typeID, refTypeTag);
546             this.fieldID = fieldID;
547             this.object = object;
548         }
549 
550         public Field field() {
551             if (field == null) {
552                 field = refType.getFieldMirror(fieldID);
553             }
554             return field;
555         }
556 
557         public ObjectReference object() {
558             return object;
559         }
560 
561         public Value valueCurrent() {
562             if (object == null) {
563                 return refType.getValue(field());
564             } else {
565                 return object.getValue(field());
566             }
567         }
568     }
569 
570     class AccessWatchpointEventImpl extends WatchpointEventImpl
571                                             implements AccessWatchpointEvent {
572 
573         AccessWatchpointEventImpl(JDWP.Event.Composite.Events.FieldAccess evt) {
574             super(evt, evt.requestID, evt.thread, evt.location,
575                   evt.refTypeTag, evt.typeID, evt.fieldID, evt.object);
576         }
577 
578         String eventName() {
579             return &quot;AccessWatchpoint&quot;;
580         }
581     }
582 
583     class ModificationWatchpointEventImpl extends WatchpointEventImpl
584                            implements ModificationWatchpointEvent {
585         Value newValue;
586 
587         ModificationWatchpointEventImpl(
588                         JDWP.Event.Composite.Events.FieldModification evt) {
589             super(evt, evt.requestID, evt.thread, evt.location,
590                   evt.refTypeTag, evt.typeID, evt.fieldID, evt.object);
591             this.newValue = evt.valueToBe;
592         }
593 
594         public Value valueToBe() {
595             return newValue;
596         }
597 
598         String eventName() {
599             return &quot;ModificationWatchpoint&quot;;
600         }
601     }
602 
603     /**
604      * Events are constructed on the thread which reads all data from the
605      * transport. This means that the packet cannot be converted to real
606      * JDI objects as that may involve further communications with the
607      * back end which would deadlock.
608      *
609      * Hence the {@link #build()} method below called by EventQueue.
610      */
611     EventSetImpl(VirtualMachine aVm, Packet pkt) {
612         super();
613 
614         // From &quot;MirrorImpl&quot;:
615         // Yes, its a bit of a hack. But by doing it this
616         // way, this is the only place we have to change
617         // typing to substitute a new impl.
618         vm = (VirtualMachineImpl)aVm;
619 
620         this.pkt = pkt;
621     }
622 
623     /**
624      * Constructor for special events like VM disconnected
625      */
626     EventSetImpl(VirtualMachine aVm, byte eventCmd) {
627         this(aVm, null);
628         suspendPolicy = JDWP.SuspendPolicy.NONE;
629         switch (eventCmd) {
630             case JDWP.EventKind.VM_DISCONNECTED:
631                 addEvent(new VMDisconnectEventImpl());
632                 break;
633 
634             default:
635                 throw new InternalException(&quot;Bad singleton event code&quot;);
636         }
637     }
638 
639     private void addEvent(EventImpl evt) {
640         // Note that this class has a public add method that throws
641         // an exception so that clients can&#39;t modify the EventSet
642         super.add(evt);
643     }
644 
645     /*
646      * Complete the construction of an EventSet.  This is called from
647      * an event handler thread.  It upacks the JDWP events inside
648      * the packet and creates EventImpls for them.  The EventSet is already
649      * on EventQueues when this is called, so it has to be synch.
650      */
651     synchronized void build() {
652         if (pkt == null) {
653             return;
654         }
655         PacketStream ps = new PacketStream(vm, pkt);
656         JDWP.Event.Composite compEvt = new JDWP.Event.Composite(vm, ps);
657         suspendPolicy = compEvt.suspendPolicy;
658         if ((vm.traceFlags &amp; VirtualMachine.TRACE_EVENTS) != 0) {
659             switch(suspendPolicy) {
660                 case JDWP.SuspendPolicy.ALL:
661                     vm.printTrace(&quot;EventSet: SUSPEND_ALL&quot;);
662                     break;
663 
664                 case JDWP.SuspendPolicy.EVENT_THREAD:
665                     vm.printTrace(&quot;EventSet: SUSPEND_EVENT_THREAD&quot;);
666                     break;
667 
668                 case JDWP.SuspendPolicy.NONE:
669                     vm.printTrace(&quot;EventSet: SUSPEND_NONE&quot;);
670                     break;
671             }
672         }
673 
674         ThreadReference fix6485605 = null;
675         for (int i = 0; i &lt; compEvt.events.length; i++) {
676             EventImpl evt = createEvent(compEvt.events[i]);
677             if ((vm.traceFlags &amp; VirtualMachine.TRACE_EVENTS) != 0) {
678                 try {
679                     vm.printTrace(&quot;Event: &quot; + evt);
680                 } catch (VMDisconnectedException ee) {
681                     // ignore - see bug 6502716
682                 }
683             }
684 
685             switch (evt.destination()) {
686                 case UNKNOWN_EVENT:
687                     // Ignore disabled, deleted, unknown events, but
688                     // save the thread if there is one since we might
689                     // have to resume it.  Note that events for different
690                     // threads can&#39;t be in the same event set.
691                     if (evt instanceof ThreadedEventImpl &amp;&amp;
692                         suspendPolicy == JDWP.SuspendPolicy.EVENT_THREAD) {
693                         fix6485605 = ((ThreadedEventImpl)evt).thread();
694                     }
695                     continue;
696                 case CLIENT_EVENT:
697                     addEvent(evt);
698                     break;
699                 case INTERNAL_EVENT:
700                     if (internalEventSet == null) {
701                         internalEventSet = new EventSetImpl(this.vm, null);
702                     }
703                     internalEventSet.addEvent(evt);
704                     break;
705                 default:
706                     throw new InternalException(&quot;Invalid event destination&quot;);
707             }
708         }
709         pkt = null; // No longer needed - free it up
710 
711         // Avoid hangs described in 6296125, 6293795
712         if (super.size() == 0) {
713             // This set has no client events.  If we don&#39;t do
714             // needed resumes, no one else is going to.
715             if (suspendPolicy == JDWP.SuspendPolicy.ALL) {
716                 vm.resume();
717             } else if (suspendPolicy == JDWP.SuspendPolicy.EVENT_THREAD) {
718                 // See bug 6485605.
719                 if (fix6485605 != null) {
720                     fix6485605.resume();
721                 } else {
722                     // apparently, there is nothing to resume.
723                 }
724             }
725             suspendPolicy = JDWP.SuspendPolicy.NONE;
726 
727         }
728 
729     }
730 
731     /**
732      * Filter out internal events
733      */
734     EventSet userFilter() {
735         return this;
736     }
737 
738     /**
739      * Filter out user events.
740      */
741     EventSet internalFilter() {
742         return this.internalEventSet;
743     }
744 
745     EventImpl createEvent(JDWP.Event.Composite.Events evt) {
746         JDWP.Event.Composite.Events.EventsCommon comm = evt.aEventsCommon;
747         switch (evt.eventKind) {
748             case JDWP.EventKind.THREAD_START:
749                 return new ThreadStartEventImpl(
750                       (JDWP.Event.Composite.Events.ThreadStart)comm);
751 
752             case JDWP.EventKind.THREAD_END:
753                 return new ThreadDeathEventImpl(
754                       (JDWP.Event.Composite.Events.ThreadDeath)comm);
755 
756             case JDWP.EventKind.EXCEPTION:
757                 return new ExceptionEventImpl(
758                       (JDWP.Event.Composite.Events.Exception)comm);
759 
760             case JDWP.EventKind.BREAKPOINT:
761                 return new BreakpointEventImpl(
762                       (JDWP.Event.Composite.Events.Breakpoint)comm);
763 
764             case JDWP.EventKind.METHOD_ENTRY:
765                 return new MethodEntryEventImpl(
766                       (JDWP.Event.Composite.Events.MethodEntry)comm);
767 
768             case JDWP.EventKind.METHOD_EXIT:
769                 return new MethodExitEventImpl(
770                       (JDWP.Event.Composite.Events.MethodExit)comm);
771 
772             case JDWP.EventKind.METHOD_EXIT_WITH_RETURN_VALUE:
773                 return new MethodExitEventImpl(
774                       (JDWP.Event.Composite.Events.MethodExitWithReturnValue)comm);
775 
776             case JDWP.EventKind.FIELD_ACCESS:
777                 return new AccessWatchpointEventImpl(
778                       (JDWP.Event.Composite.Events.FieldAccess)comm);
779 
780             case JDWP.EventKind.FIELD_MODIFICATION:
781                 return new ModificationWatchpointEventImpl(
782                       (JDWP.Event.Composite.Events.FieldModification)comm);
783 
784             case JDWP.EventKind.SINGLE_STEP:
785                 return new StepEventImpl(
786                       (JDWP.Event.Composite.Events.SingleStep)comm);
787 
788             case JDWP.EventKind.CLASS_PREPARE:
789                 return new ClassPrepareEventImpl(
790                       (JDWP.Event.Composite.Events.ClassPrepare)comm);
791 
792             case JDWP.EventKind.CLASS_UNLOAD:
793                 return new ClassUnloadEventImpl(
794                       (JDWP.Event.Composite.Events.ClassUnload)comm);
795 
796             case JDWP.EventKind.MONITOR_CONTENDED_ENTER:
797                 return new MonitorContendedEnterEventImpl(
798                       (JDWP.Event.Composite.Events.MonitorContendedEnter)comm);
799 
800             case JDWP.EventKind.MONITOR_CONTENDED_ENTERED:
801                 return new MonitorContendedEnteredEventImpl(
802                       (JDWP.Event.Composite.Events.MonitorContendedEntered)comm);
803 
804             case JDWP.EventKind.MONITOR_WAIT:
805                 return new MonitorWaitEventImpl(
806                       (JDWP.Event.Composite.Events.MonitorWait)comm);
807 
808             case JDWP.EventKind.MONITOR_WAITED:
809                 return new MonitorWaitedEventImpl(
810                       (JDWP.Event.Composite.Events.MonitorWaited)comm);
811 
812             case JDWP.EventKind.VM_START:
813                 return new VMStartEventImpl(
814                       (JDWP.Event.Composite.Events.VMStart)comm);
815 
816             case JDWP.EventKind.VM_DEATH:
817                 return new VMDeathEventImpl(
818                       (JDWP.Event.Composite.Events.VMDeath)comm);
819 
820             default:
821                 // Ignore unknown event types
822                 System.err.println(&quot;Ignoring event cmd &quot; +
823                                    evt.eventKind + &quot; from the VM&quot;);
824                 return null;
825         }
826     }
827 
828     public VirtualMachine virtualMachine() {
829         return vm;
830     }
831 
832     public int suspendPolicy() {
833         return EventRequestManagerImpl.JDWPtoJDISuspendPolicy(suspendPolicy);
834     }
835 
836     private ThreadReference eventThread() {
837         for (Event event : this) {
838             if (event instanceof ThreadedEventImpl) {
839                 return ((ThreadedEventImpl)event).thread();
840             }
841         }
842         return null;
843     }
844 
845     public void resume() {
846         switch (suspendPolicy()) {
847             case EventRequest.SUSPEND_ALL:
848                 vm.resume();
849                 break;
850             case EventRequest.SUSPEND_EVENT_THREAD:
851                 ThreadReference thread = eventThread();
852                 if (thread == null) {
853                     throw new InternalException(&quot;Inconsistent suspend policy&quot;);
854                 }
855                 thread.resume();
856                 break;
857             case EventRequest.SUSPEND_NONE:
858                 // Do nothing
859                 break;
860             default:
861                 throw new InternalException(&quot;Invalid suspend policy&quot;);
862         }
863     }
864 
865     public Iterator&lt;Event&gt; iterator() {
866         return new Itr();
867     }
868 
869     public EventIterator eventIterator() {
870         return new Itr();
871     }
872 
873     public class Itr implements EventIterator {
874         /**
875          * Index of element to be returned by subsequent call to next.
876          */
877         int cursor = 0;
878 
879         public boolean hasNext() {
880             return cursor != size();
881         }
882 
883         public Event next() {
884             try {
885                 Event nxt = get(cursor);
886                 ++cursor;
887                 return nxt;
888             } catch(IndexOutOfBoundsException e) {
889                 throw new NoSuchElementException();
890             }
891         }
892 
893         public Event nextEvent() {
894             return next();
895         }
896 
897         public void remove() {
898             throw new UnsupportedOperationException();
899         }
900     }
901 
902     @Override
903     public Spliterator&lt;Event&gt; spliterator() {
904         return Spliterators.spliterator(this, Spliterator.DISTINCT);
905     }
906 
907     /* below make this unmodifiable */
908 
909     public boolean add(Event o){
910         throw new UnsupportedOperationException();
911     }
912     public boolean remove(Object o) {
913         throw new UnsupportedOperationException();
914     }
915     public boolean addAll(Collection&lt;? extends Event&gt; coll) {
916         throw new UnsupportedOperationException();
917     }
918     public boolean removeAll(Collection&lt;?&gt; coll) {
919         throw new UnsupportedOperationException();
920     }
921     public boolean retainAll(Collection&lt;?&gt; coll) {
922         throw new UnsupportedOperationException();
923     }
924     public void clear() {
925         throw new UnsupportedOperationException();
926     }
927 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
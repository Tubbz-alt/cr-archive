diff a/src/jdk.jdi/share/classes/com/sun/tools/jdi/ReferenceTypeImpl.java b/src/jdk.jdi/share/classes/com/sun/tools/jdi/ReferenceTypeImpl.java
--- a/src/jdk.jdi/share/classes/com/sun/tools/jdi/ReferenceTypeImpl.java
+++ b/src/jdk.jdi/share/classes/com/sun/tools/jdi/ReferenceTypeImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -1149,44 +1149,32 @@
         }
         this.genericSignatureGotten = true;
     }
 
     private static boolean isOneDimensionalPrimitiveArray(String signature) {
-        int i = signature.lastIndexOf('[');
-        /*
-         * TO DO: Centralize JNI signature knowledge.
-         *
-         * Ref:
-         *  jdk1.4/doc/guide/jpda/jdi/com/sun/jdi/doc-files/signature.html
-         */
-        boolean isPA;
-        if (i < 0 || signature.startsWith("[[")) {
-            isPA = false;
-        } else {
-            char c = signature.charAt(i + 1);
-            isPA = (c != 'L' && c != 'Q');
+        JNITypeParser sig = new JNITypeParser(signature);
+        if (sig.isArray()) {
+            JNITypeParser componentSig = new JNITypeParser(sig.componentSignature());
+            return componentSig.isPrimitive();
         }
-        return isPA;
+        return false;
     }
 
     Type findType(String signature) throws ClassNotLoadedException {
         Type type;
-        if (signature.length() == 1) {
-            /* OTI FIX: Must be a primitive type or the void type */
-            char sig = signature.charAt(0);
-            if (sig == 'V') {
-                type = vm.theVoidType();
-            } else {
-                type = vm.primitiveTypeMirror((byte)sig);
-            }
+        JNITypeParser sig = new JNITypeParser(signature);
+        if (sig.isVoid()) {
+            type = vm.theVoidType();
+        } else if (sig.isPrimitive()) {
+            type = vm.primitiveTypeMirror(sig.jdwpTag());
         } else {
             // Must be a reference type.
             ClassLoaderReferenceImpl loader =
-                       (ClassLoaderReferenceImpl)classLoader();
+                    (ClassLoaderReferenceImpl) classLoader();
             if ((loader == null) ||
-                (isOneDimensionalPrimitiveArray(signature)) //Work around 4450091
-                ) {
+                    (isOneDimensionalPrimitiveArray(signature)) //Work around 4450091
+            ) {
                 // Caller wants type of boot class field
                 type = vm.findBootType(signature);
             } else {
                 // Caller wants type of non-boot class field
                 type = loader.findType(signature);

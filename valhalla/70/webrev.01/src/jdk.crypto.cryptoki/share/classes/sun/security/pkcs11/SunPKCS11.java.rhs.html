<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/SunPKCS11.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.pkcs11;
  27 
  28 import java.io.*;
  29 import java.util.*;
  30 
  31 import java.security.*;
  32 import java.security.interfaces.*;
  33 
  34 import javax.crypto.interfaces.*;
  35 
  36 import javax.security.auth.Subject;
  37 import javax.security.auth.login.LoginException;
  38 import javax.security.auth.login.FailedLoginException;
  39 import javax.security.auth.callback.Callback;
  40 import javax.security.auth.callback.CallbackHandler;
  41 import javax.security.auth.callback.ConfirmationCallback;
  42 import javax.security.auth.callback.PasswordCallback;
  43 import javax.security.auth.callback.TextOutputCallback;
  44 
  45 import sun.security.util.Debug;
  46 import sun.security.util.ResourcesMgr;
  47 import static sun.security.util.SecurityConstants.PROVIDER_VER;
<a name="2" id="anc2"></a><span class="line-added">  48 import static sun.security.util.SecurityProviderConstants.getAliases;</span>
  49 
  50 import sun.security.pkcs11.Secmod.*;
  51 
  52 import sun.security.pkcs11.wrapper.*;
  53 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
  54 
  55 /**
  56  * PKCS#11 provider main class.
  57  *
  58  * @author  Andreas Sterbenz
  59  * @since   1.5
  60  */
  61 public final class SunPKCS11 extends AuthProvider {
  62 
  63     private static final long serialVersionUID = -1354835039035306505L;
  64 
  65     static final Debug debug = Debug.getInstance(&quot;sunpkcs11&quot;);
  66     // the PKCS11 object through which we make the native calls
  67     final PKCS11 p11;
  68 
  69     // configuration information
  70     final Config config;
  71 
  72     // id of the PKCS#11 slot we are using
  73     final long slotID;
  74 
  75     private CallbackHandler pHandler;
  76     private final Object LOCK_HANDLER = new Object();
  77 
  78     final boolean removable;
  79 
  80     final Secmod.Module nssModule;
  81 
  82     final boolean nssUseSecmodTrust;
  83 
  84     private volatile Token token;
  85 
  86     private TokenPoller poller;
  87 
  88     Token getToken() {
  89         return token;
  90     }
  91 
  92     public SunPKCS11() {
  93         super(&quot;SunPKCS11&quot;, PROVIDER_VER,
  94             &quot;Unconfigured and unusable PKCS11 provider&quot;);
  95         p11 = null;
  96         config = null;
  97         slotID = 0;
  98         pHandler = null;
  99         removable = false;
 100         nssModule = null;
 101         nssUseSecmodTrust = false;
 102         token = null;
 103         poller = null;
 104     }
 105 
 106     @Override
 107     public Provider configure(String configArg) throws InvalidParameterException {
 108         final String newConfigName = checkNull(configArg);
 109         try {
 110             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt;() {
 111                 @Override
 112                 public SunPKCS11 run() throws Exception {
 113                     return new SunPKCS11(new Config(newConfigName));
 114                 }
 115             });
 116         } catch (PrivilegedActionException pae) {
 117             InvalidParameterException ipe =
 118                 new InvalidParameterException(&quot;Error configuring SunPKCS11 provider&quot;);
 119             throw (InvalidParameterException) ipe.initCause(pae.getException());
 120         }
 121     }
 122 
 123     @Override
 124     public boolean isConfigured() {
 125         return (config != null);
 126     }
 127 
 128     private static &lt;T&gt; T checkNull(T obj) {
 129         if (obj == null) {
 130             throw new NullPointerException();
 131         }
 132         return obj;
 133     }
 134 
 135     // Used by Secmod
 136     SunPKCS11(Config c) {
 137         super(&quot;SunPKCS11-&quot; + c.getName(), PROVIDER_VER, c.getDescription());
 138         this.config = c;
 139 
 140         if (debug != null) {
 141             System.out.println(&quot;SunPKCS11 loading &quot; + config.getFileName());
 142         }
 143 
 144         String library = config.getLibrary();
 145         String functionList = config.getFunctionList();
 146         long slotID = config.getSlotID();
 147         int slotListIndex = config.getSlotListIndex();
 148 
 149         boolean useSecmod = config.getNssUseSecmod();
 150         boolean nssUseSecmodTrust = config.getNssUseSecmodTrust();
 151         Secmod.Module nssModule = null;
 152 
 153         //
 154         // Initialization via Secmod. The way this works is as follows:
 155         // SunPKCS11 is either in normal mode or in NSS Secmod mode.
 156         // Secmod is activated by specifying one or more of the following
 157         // options in the config file:
 158         // nssUseSecmod, nssSecmodDirectory, nssLibrary, nssModule
 159         //
 160         // XXX add more explanation here
 161         //
 162         // If we are in Secmod mode and configured to use either the
 163         // nssKeyStore or the nssTrustAnchors module, we automatically
 164         // switch to using the NSS trust attributes for trusted certs
 165         // (KeyStore).
 166         //
 167 
 168         if (useSecmod) {
 169             // note: Config ensures library/slot/slotListIndex not specified
 170             // in secmod mode.
 171             Secmod secmod = Secmod.getInstance();
 172             DbMode nssDbMode = config.getNssDbMode();
 173             try {
 174                 String nssLibraryDirectory = config.getNssLibraryDirectory();
 175                 String nssSecmodDirectory = config.getNssSecmodDirectory();
 176                 boolean nssOptimizeSpace = config.getNssOptimizeSpace();
 177 
 178                 if (secmod.isInitialized()) {
 179                     if (nssSecmodDirectory != null) {
 180                         String s = secmod.getConfigDir();
 181                         if ((s != null) &amp;&amp;
 182                                 (s.equals(nssSecmodDirectory) == false)) {
 183                             throw new ProviderException(&quot;Secmod directory &quot;
 184                                 + nssSecmodDirectory
 185                                 + &quot; invalid, NSS already initialized with &quot;
 186                                 + s);
 187                         }
 188                     }
 189                     if (nssLibraryDirectory != null) {
 190                         String s = secmod.getLibDir();
 191                         if ((s != null) &amp;&amp;
 192                                 (s.equals(nssLibraryDirectory) == false)) {
 193                             throw new ProviderException(&quot;NSS library directory &quot;
 194                                 + nssLibraryDirectory
 195                                 + &quot; invalid, NSS already initialized with &quot;
 196                                 + s);
 197                         }
 198                     }
 199                 } else {
 200                     if (nssDbMode != DbMode.NO_DB) {
 201                         if (nssSecmodDirectory == null) {
 202                             throw new ProviderException(
 203                                 &quot;Secmod not initialized and &quot;
 204                                  + &quot;nssSecmodDirectory not specified&quot;);
 205                         }
 206                     } else {
 207                         if (nssSecmodDirectory != null) {
 208                             throw new ProviderException(
 209                                 &quot;nssSecmodDirectory must not be &quot;
 210                                 + &quot;specified in noDb mode&quot;);
 211                         }
 212                     }
 213                     secmod.initialize(nssDbMode, nssSecmodDirectory,
 214                         nssLibraryDirectory, nssOptimizeSpace);
 215                 }
 216             } catch (IOException e) {
 217                 // XXX which exception to throw
 218                 throw new ProviderException(&quot;Could not initialize NSS&quot;, e);
 219             }
 220             List&lt;Secmod.Module&gt; modules = secmod.getModules();
 221             if (config.getShowInfo()) {
 222                 System.out.println(&quot;NSS modules: &quot; + modules);
 223             }
 224 
 225             String moduleName = config.getNssModule();
 226             if (moduleName == null) {
 227                 nssModule = secmod.getModule(ModuleType.FIPS);
 228                 if (nssModule != null) {
 229                     moduleName = &quot;fips&quot;;
 230                 } else {
 231                     moduleName = (nssDbMode == DbMode.NO_DB) ?
 232                         &quot;crypto&quot; : &quot;keystore&quot;;
 233                 }
 234             }
 235             if (moduleName.equals(&quot;fips&quot;)) {
 236                 nssModule = secmod.getModule(ModuleType.FIPS);
 237                 nssUseSecmodTrust = true;
 238                 functionList = &quot;FC_GetFunctionList&quot;;
 239             } else if (moduleName.equals(&quot;keystore&quot;)) {
 240                 nssModule = secmod.getModule(ModuleType.KEYSTORE);
 241                 nssUseSecmodTrust = true;
 242             } else if (moduleName.equals(&quot;crypto&quot;)) {
 243                 nssModule = secmod.getModule(ModuleType.CRYPTO);
 244             } else if (moduleName.equals(&quot;trustanchors&quot;)) {
 245                 // XXX should the option be called trustanchor or trustanchors??
 246                 nssModule = secmod.getModule(ModuleType.TRUSTANCHOR);
 247                 nssUseSecmodTrust = true;
 248             } else if (moduleName.startsWith(&quot;external-&quot;)) {
 249                 int moduleIndex;
 250                 try {
 251                     moduleIndex = Integer.parseInt
 252                             (moduleName.substring(&quot;external-&quot;.length()));
 253                 } catch (NumberFormatException e) {
 254                     moduleIndex = -1;
 255                 }
 256                 if (moduleIndex &lt; 1) {
 257                     throw new ProviderException
 258                             (&quot;Invalid external module: &quot; + moduleName);
 259                 }
 260                 int k = 0;
 261                 for (Secmod.Module module : modules) {
 262                     if (module.getType() == ModuleType.EXTERNAL) {
 263                         if (++k == moduleIndex) {
 264                             nssModule = module;
 265                             break;
 266                         }
 267                     }
 268                 }
 269                 if (nssModule == null) {
 270                     throw new ProviderException(&quot;Invalid module &quot; + moduleName
 271                         + &quot;: only &quot; + k + &quot; external NSS modules available&quot;);
 272                 }
 273             } else {
 274                 throw new ProviderException(
 275                     &quot;Unknown NSS module: &quot; + moduleName);
 276             }
 277             if (nssModule == null) {
 278                 throw new ProviderException(
 279                     &quot;NSS module not available: &quot; + moduleName);
 280             }
 281             if (nssModule.hasInitializedProvider()) {
 282                 throw new ProviderException(&quot;Secmod module already configured&quot;);
 283             }
 284             library = nssModule.libraryName;
 285             slotListIndex = nssModule.slot;
 286         }
 287         this.nssUseSecmodTrust = nssUseSecmodTrust;
 288         this.nssModule = nssModule;
 289 
 290         File libraryFile = new File(library);
 291         // if the filename is a simple filename without path
 292         // (e.g. &quot;libpkcs11.so&quot;), it may refer to a library somewhere on the
 293         // OS library search path. Omit the test for file existance as that
 294         // only looks in the current directory.
 295         if (libraryFile.getName().equals(library) == false) {
 296             if (new File(library).isFile() == false) {
 297                 String msg = &quot;Library &quot; + library + &quot; does not exist&quot;;
 298                 if (config.getHandleStartupErrors() == Config.ERR_HALT) {
 299                     throw new ProviderException(msg);
 300                 } else {
 301                     throw new UnsupportedOperationException(msg);
 302                 }
 303             }
 304         }
 305 
 306         try {
 307             if (debug != null) {
 308                 debug.println(&quot;Initializing PKCS#11 library &quot; + library);
 309             }
 310             CK_C_INITIALIZE_ARGS initArgs = new CK_C_INITIALIZE_ARGS();
 311             String nssArgs = config.getNssArgs();
 312             if (nssArgs != null) {
 313                 initArgs.pReserved = nssArgs;
 314             }
 315             // request multithreaded access first
 316             initArgs.flags = CKF_OS_LOCKING_OK;
 317             PKCS11 tmpPKCS11;
 318             try {
 319                 tmpPKCS11 = PKCS11.getInstance(
 320                     library, functionList, initArgs,
 321                     config.getOmitInitialize());
 322             } catch (PKCS11Exception e) {
 323                 if (debug != null) {
 324                     debug.println(&quot;Multi-threaded initialization failed: &quot; + e);
 325                 }
 326                 if (config.getAllowSingleThreadedModules() == false) {
 327                     throw e;
 328                 }
 329                 // fall back to single threaded access
 330                 if (nssArgs == null) {
 331                     // if possible, use null initArgs for better compatibility
 332                     initArgs = null;
 333                 } else {
 334                     initArgs.flags = 0;
 335                 }
 336                 tmpPKCS11 = PKCS11.getInstance(library,
 337                     functionList, initArgs, config.getOmitInitialize());
 338             }
 339             p11 = tmpPKCS11;
 340 
 341             CK_INFO p11Info = p11.C_GetInfo();
 342             if (p11Info.cryptokiVersion.major &lt; 2) {
 343                 throw new ProviderException(&quot;Only PKCS#11 v2.0 and later &quot;
 344                 + &quot;supported, library version is v&quot; + p11Info.cryptokiVersion);
 345             }
 346             boolean showInfo = config.getShowInfo();
 347             if (showInfo) {
 348                 System.out.println(&quot;Information for provider &quot; + getName());
 349                 System.out.println(&quot;Library info:&quot;);
 350                 System.out.println(p11Info);
 351             }
 352 
 353             if ((slotID &lt; 0) || showInfo) {
 354                 long[] slots = p11.C_GetSlotList(false);
 355                 if (showInfo) {
 356                     System.out.println(&quot;All slots: &quot; + toString(slots));
 357                     slots = p11.C_GetSlotList(true);
 358                     System.out.println(&quot;Slots with tokens: &quot; + toString(slots));
 359                 }
 360                 if (slotID &lt; 0) {
 361                     if ((slotListIndex &lt; 0)
 362                             || (slotListIndex &gt;= slots.length)) {
 363                         throw new ProviderException(&quot;slotListIndex is &quot;
 364                             + slotListIndex
 365                             + &quot; but token only has &quot; + slots.length + &quot; slots&quot;);
 366                     }
 367                     slotID = slots[slotListIndex];
 368                 }
 369             }
 370             this.slotID = slotID;
 371             CK_SLOT_INFO slotInfo = p11.C_GetSlotInfo(slotID);
 372             removable = (slotInfo.flags &amp; CKF_REMOVABLE_DEVICE) != 0;
 373             initToken(slotInfo);
 374             if (nssModule != null) {
 375                 nssModule.setProvider(this);
 376             }
 377         } catch (Exception e) {
 378             if (config.getHandleStartupErrors() == Config.ERR_IGNORE_ALL) {
 379                 throw new UnsupportedOperationException
 380                         (&quot;Initialization failed&quot;, e);
 381             } else {
 382                 throw new ProviderException
 383                         (&quot;Initialization failed&quot;, e);
 384             }
 385         }
 386     }
 387 
 388     private static String toString(long[] longs) {
 389         if (longs.length == 0) {
 390             return &quot;(none)&quot;;
 391         }
 392         StringBuilder sb = new StringBuilder();
 393         sb.append(longs[0]);
 394         for (int i = 1; i &lt; longs.length; i++) {
 395             sb.append(&quot;, &quot;);
 396             sb.append(longs[i]);
 397         }
 398         return sb.toString();
 399     }
 400 
 401     public boolean equals(Object obj) {
 402         return this == obj;
 403     }
 404 
 405     public int hashCode() {
 406         return System.identityHashCode(this);
 407     }
 408 
<a name="3" id="anc3"></a>



 409     private static final class Descriptor {
 410         final String type;
 411         final String algorithm;
 412         final String className;
<a name="4" id="anc4"></a><span class="line-modified"> 413         final List&lt;String&gt; aliases;</span>
 414         final int[] mechanisms;
 415 
 416         private Descriptor(String type, String algorithm, String className,
<a name="5" id="anc5"></a><span class="line-modified"> 417                 List&lt;String&gt; aliases, int[] mechanisms) {</span>
 418             this.type = type;
 419             this.algorithm = algorithm;
 420             this.className = className;
 421             this.aliases = aliases;
 422             this.mechanisms = mechanisms;
 423         }
 424         private P11Service service(Token token, int mechanism) {
 425             return new P11Service
 426                 (token, type, algorithm, className, aliases, mechanism);
 427         }
 428         public String toString() {
 429             return type + &quot;.&quot; + algorithm;
 430         }
 431     }
 432 
 433     // Map from mechanism to List of Descriptors that should be
 434     // registered if the mechanism is supported
 435     private final static Map&lt;Integer,List&lt;Descriptor&gt;&gt; descriptors =
 436         new HashMap&lt;Integer,List&lt;Descriptor&gt;&gt;();
 437 
 438     private static int[] m(long m1) {
 439         return new int[] {(int)m1};
 440     }
 441 
 442     private static int[] m(long m1, long m2) {
 443         return new int[] {(int)m1, (int)m2};
 444     }
 445 
 446     private static int[] m(long m1, long m2, long m3) {
 447         return new int[] {(int)m1, (int)m2, (int)m3};
 448     }
 449 
 450     private static int[] m(long m1, long m2, long m3, long m4) {
 451         return new int[] {(int)m1, (int)m2, (int)m3, (int)m4};
 452     }
 453 
 454     private static void d(String type, String algorithm, String className,
 455             int[] m) {
 456         register(new Descriptor(type, algorithm, className, null, m));
 457     }
 458 
 459     private static void d(String type, String algorithm, String className,
<a name="6" id="anc6"></a><span class="line-modified"> 460             List&lt;String&gt; aliases, int[] m) {</span>
 461         register(new Descriptor(type, algorithm, className, aliases, m));
 462     }
 463 
<a name="7" id="anc7"></a><span class="line-added"> 464     private static void dA(String type, String algorithm, String className,</span>
<span class="line-added"> 465             int[] m) {</span>
<span class="line-added"> 466         register(new Descriptor(type, algorithm, className,</span>
<span class="line-added"> 467                 getAliases(algorithm), m));</span>
<span class="line-added"> 468     }</span>
<span class="line-added"> 469 </span>
 470     private static void register(Descriptor d) {
 471         for (int i = 0; i &lt; d.mechanisms.length; i++) {
 472             int m = d.mechanisms[i];
 473             Integer key = Integer.valueOf(m);
 474             List&lt;Descriptor&gt; list = descriptors.get(key);
 475             if (list == null) {
 476                 list = new ArrayList&lt;Descriptor&gt;();
 477                 descriptors.put(key, list);
 478             }
 479             list.add(d);
 480         }
 481     }
 482 
 483     private final static String MD  = &quot;MessageDigest&quot;;
 484 
 485     private final static String SIG = &quot;Signature&quot;;
 486 
 487     private final static String KPG = &quot;KeyPairGenerator&quot;;
 488 
 489     private final static String KG  = &quot;KeyGenerator&quot;;
 490 
 491     private final static String AGP = &quot;AlgorithmParameters&quot;;
 492 
 493     private final static String KF  = &quot;KeyFactory&quot;;
 494 
 495     private final static String SKF = &quot;SecretKeyFactory&quot;;
 496 
 497     private final static String CIP = &quot;Cipher&quot;;
 498 
 499     private final static String MAC = &quot;Mac&quot;;
 500 
 501     private final static String KA  = &quot;KeyAgreement&quot;;
 502 
 503     private final static String KS  = &quot;KeyStore&quot;;
 504 
 505     private final static String SR  = &quot;SecureRandom&quot;;
 506 
 507     static {
 508         // names of all the implementation classes
 509         // use local variables, only used here
 510         String P11Digest           = &quot;sun.security.pkcs11.P11Digest&quot;;
 511         String P11MAC              = &quot;sun.security.pkcs11.P11MAC&quot;;
 512         String P11KeyPairGenerator = &quot;sun.security.pkcs11.P11KeyPairGenerator&quot;;
 513         String P11KeyGenerator     = &quot;sun.security.pkcs11.P11KeyGenerator&quot;;
 514         String P11RSAKeyFactory    = &quot;sun.security.pkcs11.P11RSAKeyFactory&quot;;
 515         String P11DSAKeyFactory    = &quot;sun.security.pkcs11.P11DSAKeyFactory&quot;;
 516         String P11DHKeyFactory     = &quot;sun.security.pkcs11.P11DHKeyFactory&quot;;
 517         String P11KeyAgreement     = &quot;sun.security.pkcs11.P11KeyAgreement&quot;;
 518         String P11SecretKeyFactory = &quot;sun.security.pkcs11.P11SecretKeyFactory&quot;;
 519         String P11Cipher           = &quot;sun.security.pkcs11.P11Cipher&quot;;
 520         String P11RSACipher        = &quot;sun.security.pkcs11.P11RSACipher&quot;;
 521         String P11AEADCipher       = &quot;sun.security.pkcs11.P11AEADCipher&quot;;
 522         String P11Signature        = &quot;sun.security.pkcs11.P11Signature&quot;;
 523         String P11PSSSignature     = &quot;sun.security.pkcs11.P11PSSSignature&quot;;
 524 
 525         // XXX register all aliases
 526 
 527         d(MD, &quot;MD2&quot;,            P11Digest,
 528                 m(CKM_MD2));
 529         d(MD, &quot;MD5&quot;,            P11Digest,
 530                 m(CKM_MD5));
<a name="8" id="anc8"></a><span class="line-modified"> 531         dA(MD, &quot;SHA-1&quot;,           P11Digest,</span>

 532                 m(CKM_SHA_1));
 533 
<a name="9" id="anc9"></a><span class="line-modified"> 534         dA(MD, &quot;SHA-224&quot;,        P11Digest,</span>

 535                 m(CKM_SHA224));
<a name="10" id="anc10"></a><span class="line-modified"> 536         dA(MD, &quot;SHA-256&quot;,        P11Digest,</span>

 537                 m(CKM_SHA256));
<a name="11" id="anc11"></a><span class="line-modified"> 538         dA(MD, &quot;SHA-384&quot;,        P11Digest,</span>

 539                 m(CKM_SHA384));
<a name="12" id="anc12"></a><span class="line-modified"> 540         dA(MD, &quot;SHA-512&quot;,        P11Digest,</span>

 541                 m(CKM_SHA512));
<a name="13" id="anc13"></a><span class="line-modified"> 542         dA(MD, &quot;SHA-512/224&quot;,        P11Digest,</span>

 543                 m(CKM_SHA512_224));
<a name="14" id="anc14"></a><span class="line-modified"> 544         dA(MD, &quot;SHA-512/256&quot;,        P11Digest,</span>

 545                 m(CKM_SHA512_256));
 546 
 547         d(MAC, &quot;HmacMD5&quot;,       P11MAC,
 548                 m(CKM_MD5_HMAC));
<a name="15" id="anc15"></a><span class="line-modified"> 549         dA(MAC, &quot;HmacSHA1&quot;,      P11MAC,</span>

 550                 m(CKM_SHA_1_HMAC));
<a name="16" id="anc16"></a><span class="line-modified"> 551         dA(MAC, &quot;HmacSHA224&quot;,    P11MAC,</span>

 552                 m(CKM_SHA224_HMAC));
<a name="17" id="anc17"></a><span class="line-modified"> 553         dA(MAC, &quot;HmacSHA256&quot;,    P11MAC,</span>

 554                 m(CKM_SHA256_HMAC));
<a name="18" id="anc18"></a><span class="line-modified"> 555         dA(MAC, &quot;HmacSHA384&quot;,    P11MAC,</span>

 556                 m(CKM_SHA384_HMAC));
<a name="19" id="anc19"></a><span class="line-modified"> 557         dA(MAC, &quot;HmacSHA512&quot;,    P11MAC,</span>

 558                 m(CKM_SHA512_HMAC));
<a name="20" id="anc20"></a><span class="line-modified"> 559         dA(MAC, &quot;HmacSHA512/224&quot;,    P11MAC,</span>

 560                 m(CKM_SHA512_224_HMAC));
<a name="21" id="anc21"></a><span class="line-modified"> 561         dA(MAC, &quot;HmacSHA512/256&quot;,    P11MAC,</span>

 562                 m(CKM_SHA512_256_HMAC));
 563 
 564         d(MAC, &quot;SslMacMD5&quot;,     P11MAC,
 565                 m(CKM_SSL3_MD5_MAC));
 566         d(MAC, &quot;SslMacSHA1&quot;,    P11MAC,
 567                 m(CKM_SSL3_SHA1_MAC));
 568 
 569         d(KPG, &quot;RSA&quot;,           P11KeyPairGenerator,
<a name="22" id="anc22"></a><span class="line-modified"> 570                 getAliases(&quot;PKCS1&quot;),</span>
 571                 m(CKM_RSA_PKCS_KEY_PAIR_GEN));
 572 
<a name="23" id="anc23"></a><span class="line-modified"> 573         List&lt;String&gt; dhAlias = List.of(&quot;DiffieHellman&quot;);</span>
<span class="line-modified"> 574 </span>
<span class="line-added"> 575         dA(KPG, &quot;DSA&quot;,           P11KeyPairGenerator,</span>
 576                 m(CKM_DSA_KEY_PAIR_GEN));
<a name="24" id="anc24"></a><span class="line-modified"> 577         d(KPG, &quot;DH&quot;,            P11KeyPairGenerator,</span>
<span class="line-added"> 578                 dhAlias,</span>
 579                 m(CKM_DH_PKCS_KEY_PAIR_GEN));
 580         d(KPG, &quot;EC&quot;,            P11KeyPairGenerator,
 581                 m(CKM_EC_KEY_PAIR_GEN));
 582 
<a name="25" id="anc25"></a><span class="line-modified"> 583         dA(KG,  &quot;ARCFOUR&quot;,       P11KeyGenerator,</span>
 584                 m(CKM_RC4_KEY_GEN));
 585         d(KG,  &quot;DES&quot;,           P11KeyGenerator,
 586                 m(CKM_DES_KEY_GEN));
 587         d(KG,  &quot;DESede&quot;,        P11KeyGenerator,
 588                 m(CKM_DES3_KEY_GEN, CKM_DES2_KEY_GEN));
 589         d(KG,  &quot;AES&quot;,           P11KeyGenerator,
 590                 m(CKM_AES_KEY_GEN));
 591         d(KG,  &quot;Blowfish&quot;,      P11KeyGenerator,
 592                 m(CKM_BLOWFISH_KEY_GEN));
 593 
 594         // register (Secret)KeyFactories if there are any mechanisms
 595         // for a particular algorithm that we support
 596         d(KF, &quot;RSA&quot;,            P11RSAKeyFactory,
<a name="26" id="anc26"></a><span class="line-modified"> 597                 getAliases(&quot;PKCS1&quot;),</span>
 598                 m(CKM_RSA_PKCS_KEY_PAIR_GEN, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="27" id="anc27"></a><span class="line-modified"> 599         dA(KF, &quot;DSA&quot;,            P11DSAKeyFactory,</span>

 600                 m(CKM_DSA_KEY_PAIR_GEN, CKM_DSA, CKM_DSA_SHA1));
<a name="28" id="anc28"></a><span class="line-modified"> 601         d(KF, &quot;DH&quot;,             P11DHKeyFactory,</span>
<span class="line-added"> 602                 dhAlias,</span>
 603                 m(CKM_DH_PKCS_KEY_PAIR_GEN, CKM_DH_PKCS_DERIVE));
 604         d(KF, &quot;EC&quot;,             P11DHKeyFactory,
 605                 m(CKM_EC_KEY_PAIR_GEN, CKM_ECDH1_DERIVE,
 606                     CKM_ECDSA, CKM_ECDSA_SHA1));
 607 
 608         // AlgorithmParameters for EC.
 609         // Only needed until we have an EC implementation in the SUN provider.
<a name="29" id="anc29"></a><span class="line-modified"> 610         dA(AGP, &quot;EC&quot;,            &quot;sun.security.util.ECParameters&quot;,</span>

 611                 m(CKM_EC_KEY_PAIR_GEN, CKM_ECDH1_DERIVE,
 612                     CKM_ECDSA, CKM_ECDSA_SHA1));
 613 
 614 
 615         d(AGP, &quot;GCM&quot;,            &quot;sun.security.util.GCMParameters&quot;,
 616                 m(CKM_AES_GCM));
 617 
<a name="30" id="anc30"></a><span class="line-modified"> 618         d(KA, &quot;DH&quot;,             P11KeyAgreement,</span>
<span class="line-added"> 619                 dhAlias,</span>
 620                 m(CKM_DH_PKCS_DERIVE));
 621         d(KA, &quot;ECDH&quot;,           &quot;sun.security.pkcs11.P11ECDHKeyAgreement&quot;,
 622                 m(CKM_ECDH1_DERIVE));
 623 
<a name="31" id="anc31"></a><span class="line-modified"> 624         dA(SKF, &quot;ARCFOUR&quot;,       P11SecretKeyFactory,</span>
 625                 m(CKM_RC4));
 626         d(SKF, &quot;DES&quot;,           P11SecretKeyFactory,
 627                 m(CKM_DES_CBC));
 628         d(SKF, &quot;DESede&quot;,        P11SecretKeyFactory,
 629                 m(CKM_DES3_CBC));
<a name="32" id="anc32"></a><span class="line-modified"> 630         dA(SKF, &quot;AES&quot;,           P11SecretKeyFactory,</span>

 631                 m(CKM_AES_CBC));
 632         d(SKF, &quot;Blowfish&quot;,      P11SecretKeyFactory,
 633                 m(CKM_BLOWFISH_CBC));
 634 
 635         // XXX attributes for Ciphers (supported modes, padding)
<a name="33" id="anc33"></a><span class="line-modified"> 636         dA(CIP, &quot;ARCFOUR&quot;,                      P11Cipher,</span>
 637                 m(CKM_RC4));
 638         d(CIP, &quot;DES/CBC/NoPadding&quot;,             P11Cipher,
 639                 m(CKM_DES_CBC));
 640         d(CIP, &quot;DES/CBC/PKCS5Padding&quot;,          P11Cipher,
 641                 m(CKM_DES_CBC_PAD, CKM_DES_CBC));
 642         d(CIP, &quot;DES/ECB/NoPadding&quot;,             P11Cipher,
 643                 m(CKM_DES_ECB));
<a name="34" id="anc34"></a><span class="line-modified"> 644         d(CIP, &quot;DES/ECB/PKCS5Padding&quot;,          P11Cipher,</span>
<span class="line-added"> 645                 List.of(&quot;DES&quot;),</span>
 646                 m(CKM_DES_ECB));
 647 
 648         d(CIP, &quot;DESede/CBC/NoPadding&quot;,          P11Cipher,
 649                 m(CKM_DES3_CBC));
 650         d(CIP, &quot;DESede/CBC/PKCS5Padding&quot;,       P11Cipher,
 651                 m(CKM_DES3_CBC_PAD, CKM_DES3_CBC));
 652         d(CIP, &quot;DESede/ECB/NoPadding&quot;,          P11Cipher,
 653                 m(CKM_DES3_ECB));
<a name="35" id="anc35"></a><span class="line-modified"> 654         d(CIP, &quot;DESede/ECB/PKCS5Padding&quot;,       P11Cipher,</span>
<span class="line-added"> 655                 List.of(&quot;DESede&quot;),</span>
 656                 m(CKM_DES3_ECB));
 657         d(CIP, &quot;AES/CBC/NoPadding&quot;,             P11Cipher,
 658                 m(CKM_AES_CBC));
<a name="36" id="anc36"></a><span class="line-modified"> 659         dA(CIP, &quot;AES_128/CBC/NoPadding&quot;,          P11Cipher,</span>

 660                 m(CKM_AES_CBC));
<a name="37" id="anc37"></a><span class="line-modified"> 661         dA(CIP, &quot;AES_192/CBC/NoPadding&quot;,          P11Cipher,</span>

 662                 m(CKM_AES_CBC));
<a name="38" id="anc38"></a><span class="line-modified"> 663         dA(CIP, &quot;AES_256/CBC/NoPadding&quot;,          P11Cipher,</span>

 664                 m(CKM_AES_CBC));
 665         d(CIP, &quot;AES/CBC/PKCS5Padding&quot;,          P11Cipher,
 666                 m(CKM_AES_CBC_PAD, CKM_AES_CBC));
 667         d(CIP, &quot;AES/ECB/NoPadding&quot;,             P11Cipher,
 668                 m(CKM_AES_ECB));
<a name="39" id="anc39"></a><span class="line-modified"> 669         dA(CIP, &quot;AES_128/ECB/NoPadding&quot;,          P11Cipher,</span>

 670                 m(CKM_AES_ECB));
<a name="40" id="anc40"></a><span class="line-modified"> 671         dA(CIP, &quot;AES_192/ECB/NoPadding&quot;,          P11Cipher,</span>

 672                 m(CKM_AES_ECB));
<a name="41" id="anc41"></a><span class="line-modified"> 673         dA(CIP, &quot;AES_256/ECB/NoPadding&quot;,          P11Cipher,</span>

 674                 m(CKM_AES_ECB));
<a name="42" id="anc42"></a><span class="line-modified"> 675         d(CIP, &quot;AES/ECB/PKCS5Padding&quot;,          P11Cipher,</span>
<span class="line-added"> 676                 List.of(&quot;AES&quot;),</span>
 677                 m(CKM_AES_ECB));
 678         d(CIP, &quot;AES/CTR/NoPadding&quot;,             P11Cipher,
 679                 m(CKM_AES_CTR));
 680 
 681         d(CIP, &quot;AES/GCM/NoPadding&quot;,             P11AEADCipher,
 682                 m(CKM_AES_GCM));
<a name="43" id="anc43"></a><span class="line-modified"> 683         dA(CIP, &quot;AES_128/GCM/NoPadding&quot;,          P11AEADCipher,</span>

 684                 m(CKM_AES_GCM));
<a name="44" id="anc44"></a><span class="line-modified"> 685         dA(CIP, &quot;AES_192/GCM/NoPadding&quot;,          P11AEADCipher,</span>

 686                 m(CKM_AES_GCM));
<a name="45" id="anc45"></a><span class="line-modified"> 687         dA(CIP, &quot;AES_256/GCM/NoPadding&quot;,          P11AEADCipher,</span>

 688                 m(CKM_AES_GCM));
 689 
 690         d(CIP, &quot;Blowfish/CBC/NoPadding&quot;,        P11Cipher,
 691                 m(CKM_BLOWFISH_CBC));
 692         d(CIP, &quot;Blowfish/CBC/PKCS5Padding&quot;,     P11Cipher,
 693                 m(CKM_BLOWFISH_CBC));
 694 
<a name="46" id="anc46"></a><span class="line-modified"> 695         d(CIP, &quot;RSA/ECB/PKCS1Padding&quot;,          P11RSACipher,</span>
<span class="line-added"> 696                 List.of(&quot;RSA&quot;),</span>
 697                 m(CKM_RSA_PKCS));
 698         d(CIP, &quot;RSA/ECB/NoPadding&quot;,             P11RSACipher,
 699                 m(CKM_RSA_X_509));
 700 
<a name="47" id="anc47"></a><span class="line-modified"> 701         d(SIG, &quot;RawDSA&quot;,        P11Signature,</span>
<span class="line-added"> 702                 List.of(&quot;NONEwithDSA&quot;),</span>
 703                 m(CKM_DSA));
<a name="48" id="anc48"></a><span class="line-modified"> 704         dA(SIG, &quot;SHA1withDSA&quot;,           P11Signature,</span>


 705                 m(CKM_DSA_SHA1, CKM_DSA));
<a name="49" id="anc49"></a><span class="line-modified"> 706         dA(SIG, &quot;SHA224withDSA&quot;, P11Signature,</span>

 707                 m(CKM_DSA_SHA224));
<a name="50" id="anc50"></a><span class="line-modified"> 708         dA(SIG, &quot;SHA256withDSA&quot;, P11Signature,</span>

 709                 m(CKM_DSA_SHA256));
<a name="51" id="anc51"></a><span class="line-modified"> 710         dA(SIG, &quot;SHA384withDSA&quot;, P11Signature,</span>

 711                 m(CKM_DSA_SHA384));
<a name="52" id="anc52"></a><span class="line-modified"> 712         dA(SIG, &quot;SHA512withDSA&quot;, P11Signature,</span>

 713                 m(CKM_DSA_SHA512));
 714         d(SIG, &quot;RawDSAinP1363Format&quot;,   P11Signature,
<a name="53" id="anc53"></a><span class="line-modified"> 715                 List.of(&quot;NONEwithDSAinP1363Format&quot;),</span>
 716                 m(CKM_DSA));
 717         d(SIG, &quot;DSAinP1363Format&quot;,      P11Signature,
<a name="54" id="anc54"></a><span class="line-modified"> 718                 List.of(&quot;SHA1withDSAinP1363Format&quot;),</span>
 719                 m(CKM_DSA_SHA1, CKM_DSA));
 720 
 721         d(SIG, &quot;NONEwithECDSA&quot;, P11Signature,
 722                 m(CKM_ECDSA));
<a name="55" id="anc55"></a><span class="line-modified"> 723         dA(SIG, &quot;SHA1withECDSA&quot;, P11Signature,</span>

 724                 m(CKM_ECDSA_SHA1, CKM_ECDSA));
<a name="56" id="anc56"></a><span class="line-modified"> 725         dA(SIG, &quot;SHA224withECDSA&quot;,       P11Signature,</span>

 726                 m(CKM_ECDSA));
<a name="57" id="anc57"></a><span class="line-modified"> 727         dA(SIG, &quot;SHA256withECDSA&quot;,       P11Signature,</span>

 728                 m(CKM_ECDSA));
<a name="58" id="anc58"></a><span class="line-modified"> 729         dA(SIG, &quot;SHA384withECDSA&quot;,       P11Signature,</span>

 730                 m(CKM_ECDSA));
<a name="59" id="anc59"></a><span class="line-modified"> 731         dA(SIG, &quot;SHA512withECDSA&quot;,       P11Signature,</span>

 732                 m(CKM_ECDSA));
 733         d(SIG, &quot;NONEwithECDSAinP1363Format&quot;,   P11Signature,
 734                 m(CKM_ECDSA));
 735         d(SIG, &quot;SHA1withECDSAinP1363Format&quot;,   P11Signature,
 736                 m(CKM_ECDSA_SHA1, CKM_ECDSA));
 737         d(SIG, &quot;SHA224withECDSAinP1363Format&quot;, P11Signature,
 738                 m(CKM_ECDSA));
 739         d(SIG, &quot;SHA256withECDSAinP1363Format&quot;, P11Signature,
 740                 m(CKM_ECDSA));
 741         d(SIG, &quot;SHA384withECDSAinP1363Format&quot;, P11Signature,
 742                 m(CKM_ECDSA));
 743         d(SIG, &quot;SHA512withECDSAinP1363Format&quot;, P11Signature,
 744                 m(CKM_ECDSA));
<a name="60" id="anc60"></a><span class="line-modified"> 745         dA(SIG, &quot;MD2withRSA&quot;,    P11Signature,</span>

 746                 m(CKM_MD2_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="61" id="anc61"></a><span class="line-modified"> 747         dA(SIG, &quot;MD5withRSA&quot;,    P11Signature,</span>

 748                 m(CKM_MD5_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="62" id="anc62"></a><span class="line-modified"> 749         dA(SIG, &quot;SHA1withRSA&quot;,   P11Signature,</span>


 750                 m(CKM_SHA1_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="63" id="anc63"></a><span class="line-modified"> 751         dA(SIG, &quot;SHA224withRSA&quot;, P11Signature,</span>

 752                 m(CKM_SHA224_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="64" id="anc64"></a><span class="line-modified"> 753         dA(SIG, &quot;SHA256withRSA&quot;, P11Signature,</span>

 754                 m(CKM_SHA256_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="65" id="anc65"></a><span class="line-modified"> 755         dA(SIG, &quot;SHA384withRSA&quot;, P11Signature,</span>

 756                 m(CKM_SHA384_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="66" id="anc66"></a><span class="line-modified"> 757         dA(SIG, &quot;SHA512withRSA&quot;, P11Signature,</span>

 758                 m(CKM_SHA512_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="67" id="anc67"></a><span class="line-modified"> 759         dA(SIG, &quot;RSASSA-PSS&quot;, P11PSSSignature,</span>

 760                 m(CKM_RSA_PKCS_PSS));
 761         d(SIG, &quot;SHA1withRSASSA-PSS&quot;, P11PSSSignature,
 762                 m(CKM_SHA1_RSA_PKCS_PSS));
 763         d(SIG, &quot;SHA224withRSASSA-PSS&quot;, P11PSSSignature,
 764                 m(CKM_SHA224_RSA_PKCS_PSS));
 765         d(SIG, &quot;SHA256withRSASSA-PSS&quot;, P11PSSSignature,
 766                 m(CKM_SHA256_RSA_PKCS_PSS));
 767         d(SIG, &quot;SHA384withRSASSA-PSS&quot;, P11PSSSignature,
 768                 m(CKM_SHA384_RSA_PKCS_PSS));
 769         d(SIG, &quot;SHA512withRSASSA-PSS&quot;, P11PSSSignature,
 770                 m(CKM_SHA512_RSA_PKCS_PSS));
 771 
 772         d(KG, &quot;SunTlsRsaPremasterSecret&quot;,
 773                     &quot;sun.security.pkcs11.P11TlsRsaPremasterSecretGenerator&quot;,
<a name="68" id="anc68"></a><span class="line-modified"> 774                 List.of(&quot;SunTls12RsaPremasterSecret&quot;),</span>
 775                 m(CKM_SSL3_PRE_MASTER_KEY_GEN, CKM_TLS_PRE_MASTER_KEY_GEN));
 776         d(KG, &quot;SunTlsMasterSecret&quot;,
 777                     &quot;sun.security.pkcs11.P11TlsMasterSecretGenerator&quot;,
 778                 m(CKM_SSL3_MASTER_KEY_DERIVE, CKM_TLS_MASTER_KEY_DERIVE,
 779                     CKM_SSL3_MASTER_KEY_DERIVE_DH,
 780                     CKM_TLS_MASTER_KEY_DERIVE_DH));
 781         d(KG, &quot;SunTls12MasterSecret&quot;,
 782                 &quot;sun.security.pkcs11.P11TlsMasterSecretGenerator&quot;,
 783             m(CKM_TLS12_MASTER_KEY_DERIVE, CKM_TLS12_MASTER_KEY_DERIVE_DH));
 784         d(KG, &quot;SunTlsKeyMaterial&quot;,
 785                     &quot;sun.security.pkcs11.P11TlsKeyMaterialGenerator&quot;,
 786                 m(CKM_SSL3_KEY_AND_MAC_DERIVE, CKM_TLS_KEY_AND_MAC_DERIVE));
 787         d(KG, &quot;SunTls12KeyMaterial&quot;,
 788                 &quot;sun.security.pkcs11.P11TlsKeyMaterialGenerator&quot;,
 789             m(CKM_TLS12_KEY_AND_MAC_DERIVE));
 790         d(KG, &quot;SunTlsPrf&quot;, &quot;sun.security.pkcs11.P11TlsPrfGenerator&quot;,
 791                 m(CKM_TLS_PRF, CKM_NSS_TLS_PRF_GENERAL));
 792         d(KG, &quot;SunTls12Prf&quot;, &quot;sun.security.pkcs11.P11TlsPrfGenerator&quot;,
 793                 m(CKM_TLS_MAC));
 794     }
 795 
 796     // background thread that periodically checks for token insertion
 797     // if no token is present. We need to do that in a separate thread because
 798     // the insertion check may block for quite a long time on some tokens.
 799     private static class TokenPoller implements Runnable {
 800         private final SunPKCS11 provider;
 801         private volatile boolean enabled;
 802         private TokenPoller(SunPKCS11 provider) {
 803             this.provider = provider;
 804             enabled = true;
 805         }
 806         public void run() {
 807             int interval = provider.config.getInsertionCheckInterval();
 808             while (enabled) {
 809                 try {
 810                     Thread.sleep(interval);
 811                 } catch (InterruptedException e) {
 812                     break;
 813                 }
 814                 if (enabled == false) {
 815                     break;
 816                 }
 817                 try {
 818                     provider.initToken(null);
 819                 } catch (PKCS11Exception e) {
 820                     // ignore
 821                 }
 822             }
 823         }
 824         void disable() {
 825             enabled = false;
 826         }
 827     }
 828 
 829     // create the poller thread, if not already active
 830     private void createPoller() {
 831         if (poller != null) {
 832             return;
 833         }
 834         final TokenPoller poller = new TokenPoller(this);
 835         Thread t = new Thread(null, poller, &quot;Poller &quot; + getName(), 0, false);
 836         t.setContextClassLoader(null);
 837         t.setDaemon(true);
 838         t.setPriority(Thread.MIN_PRIORITY);
 839         t.start();
 840         this.poller = poller;
 841     }
 842 
 843     // destroy the poller thread, if active
 844     private void destroyPoller() {
 845         if (poller != null) {
 846             poller.disable();
 847             poller = null;
 848         }
 849     }
 850 
 851     private boolean hasValidToken() {
 852         /* Commented out to work with Solaris softtoken impl which
 853            returns 0-value flags, e.g. both REMOVABLE_DEVICE and
 854            TOKEN_PRESENT are false, when it can&#39;t access the token.
 855         if (removable == false) {
 856             return true;
 857         }
 858         */
 859         Token token = this.token;
 860         return (token != null) &amp;&amp; token.isValid();
 861     }
 862 
 863     // destroy the token. Called if we detect that it has been removed
 864     synchronized void uninitToken(Token token) {
 865         if (this.token != token) {
 866             // mismatch, our token must already be destroyed
 867             return;
 868         }
 869         destroyPoller();
 870         this.token = null;
 871         // unregister all algorithms
 872         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 873             public Object run() {
 874                 clear();
 875                 return null;
 876             }
 877         });
 878         createPoller();
 879     }
 880 
 881     private static boolean isLegacy(CK_MECHANISM_INFO mechInfo)
 882             throws PKCS11Exception {
 883         // assume full support if no mech info available
 884         // For vendor-specific mechanisms, often no mech info is provided
 885         boolean partialSupport = false;
 886 
 887         if (mechInfo != null) {
 888             if ((mechInfo.flags &amp; CKF_DECRYPT) != 0) {
 889                 // non-legacy cipher mechs should support encryption
 890                 partialSupport |= ((mechInfo.flags &amp; CKF_ENCRYPT) == 0);
 891             }
 892             if ((mechInfo.flags &amp; CKF_VERIFY) != 0) {
 893                 // non-legacy signature mechs should support signing
 894                 partialSupport |= ((mechInfo.flags &amp; CKF_SIGN) == 0);
 895             }
 896         }
 897         return partialSupport;
 898     }
 899 
 900     // test if a token is present and initialize this provider for it if so.
 901     // does nothing if no token is found
 902     // called from constructor and by poller
 903     private void initToken(CK_SLOT_INFO slotInfo) throws PKCS11Exception {
 904         if (slotInfo == null) {
 905             slotInfo = p11.C_GetSlotInfo(slotID);
 906         }
 907         if (removable &amp;&amp; (slotInfo.flags &amp; CKF_TOKEN_PRESENT) == 0) {
 908             createPoller();
 909             return;
 910         }
 911         destroyPoller();
 912         boolean showInfo = config.getShowInfo();
 913         if (showInfo) {
 914             System.out.println(&quot;Slot info for slot &quot; + slotID + &quot;:&quot;);
 915             System.out.println(slotInfo);
 916         }
 917         final Token token = new Token(this);
 918         if (showInfo) {
 919             System.out.println
 920                 (&quot;Token info for token in slot &quot; + slotID + &quot;:&quot;);
 921             System.out.println(token.tokenInfo);
 922         }
 923         long[] supportedMechanisms = p11.C_GetMechanismList(slotID);
 924 
 925         // Create a map from the various Descriptors to the &quot;most
 926         // preferred&quot; mechanism that was defined during the
 927         // static initialization.  For example, DES/CBC/PKCS5Padding
 928         // could be mapped to CKM_DES_CBC_PAD or CKM_DES_CBC.  Prefer
 929         // the earliest entry.  When asked for &quot;DES/CBC/PKCS5Padding&quot;, we
 930         // return a CKM_DES_CBC_PAD.
 931         final Map&lt;Descriptor,Integer&gt; supportedAlgs =
 932                                         new HashMap&lt;Descriptor,Integer&gt;();
 933 
 934         for (int i = 0; i &lt; supportedMechanisms.length; i++) {
 935             long longMech = supportedMechanisms[i];
 936             CK_MECHANISM_INFO mechInfo = token.getMechanismInfo(longMech);
 937             if (showInfo) {
 938                 System.out.println(&quot;Mechanism &quot; +
 939                     Functions.getMechanismName(longMech) + &quot;:&quot;);
 940                 System.out.println(mechInfo == null?
 941                     (Constants.INDENT + &quot;info n/a&quot;) :
 942                     mechInfo);
 943             }
 944             if (!config.isEnabled(longMech)) {
 945                 if (showInfo) {
 946                     System.out.println(&quot;DISABLED in configuration&quot;);
 947                 }
 948                 continue;
 949             }
 950             if (isLegacy(mechInfo)) {
 951                 if (showInfo) {
 952                     System.out.println(&quot;DISABLED due to legacy&quot;);
 953                 }
 954                 continue;
 955             }
 956 
 957             // we do not know of mechs with the upper 32 bits set
 958             if (longMech &gt;&gt;&gt; 32 != 0) {
 959                 if (showInfo) {
 960                     System.out.println(&quot;DISABLED due to unknown mech value&quot;);
 961                 }
 962                 continue;
 963             }
 964             int mech = (int)longMech;
 965             Integer integerMech = Integer.valueOf(mech);
 966             List&lt;Descriptor&gt; ds = descriptors.get(integerMech);
 967             if (ds == null) {
 968                 continue;
 969             }
 970             for (Descriptor d : ds) {
 971                 Integer oldMech = supportedAlgs.get(d);
 972                 if (oldMech == null) {
 973                     supportedAlgs.put(d, integerMech);
 974                     continue;
 975                 }
 976                 // See if there is something &quot;more preferred&quot;
 977                 // than what we currently have in the supportedAlgs
 978                 // map.
 979                 int intOldMech = oldMech.intValue();
 980                 for (int j = 0; j &lt; d.mechanisms.length; j++) {
 981                     int nextMech = d.mechanisms[j];
 982                     if (mech == nextMech) {
 983                         supportedAlgs.put(d, integerMech);
 984                         break;
 985                     } else if (intOldMech == nextMech) {
 986                         break;
 987                     }
 988                 }
 989             }
 990 
 991         }
 992 
 993         // register algorithms in provider
 994         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 995             public Object run() {
 996                 for (Map.Entry&lt;Descriptor,Integer&gt; entry
 997                         : supportedAlgs.entrySet()) {
 998                     Descriptor d = entry.getKey();
 999                     int mechanism = entry.getValue().intValue();
1000                     Service s = d.service(token, mechanism);
1001                     putService(s);
1002                 }
1003                 if (((token.tokenInfo.flags &amp; CKF_RNG) != 0)
1004                         &amp;&amp; config.isEnabled(PCKM_SECURERANDOM)
1005                         &amp;&amp; !token.sessionManager.lowMaxSessions()) {
1006                     // do not register SecureRandom if the token does
1007                     // not support many sessions. if we did, we might
1008                     // run out of sessions in the middle of a
1009                     // nextBytes() call where we cannot fail over.
1010                     putService(new P11Service(token, SR, &quot;PKCS11&quot;,
1011                         &quot;sun.security.pkcs11.P11SecureRandom&quot;, null,
1012                         PCKM_SECURERANDOM));
1013                 }
1014                 if (config.isEnabled(PCKM_KEYSTORE)) {
1015                     putService(new P11Service(token, KS, &quot;PKCS11&quot;,
1016                         &quot;sun.security.pkcs11.P11KeyStore&quot;,
<a name="69" id="anc69"></a><span class="line-modified">1017                         List.of(&quot;PKCS11-&quot; + config.getName()),</span>
1018                         PCKM_KEYSTORE));
1019                 }
1020                 return null;
1021             }
1022         });
1023 
1024         this.token = token;
1025     }
1026 
1027     private static final class P11Service extends Service {
1028 
1029         private final Token token;
1030 
1031         private final long mechanism;
1032 
1033         P11Service(Token token, String type, String algorithm,
<a name="70" id="anc70"></a><span class="line-modified">1034                 String className, List&lt;String&gt; al, long mechanism) {</span>
<span class="line-modified">1035             super(token.provider, type, algorithm, className, al,</span>
1036                     type.equals(SR) ? Map.of(&quot;ThreadSafe&quot;, &quot;true&quot;) : null);
1037             this.token = token;
1038             this.mechanism = mechanism &amp; 0xFFFFFFFFL;
1039         }
1040 
<a name="71" id="anc71"></a>



1041         public Object newInstance(Object param)
1042                 throws NoSuchAlgorithmException {
1043             if (token.isValid() == false) {
1044                 throw new NoSuchAlgorithmException(&quot;Token has been removed&quot;);
1045             }
1046             try {
1047                 return newInstance0(param);
1048             } catch (PKCS11Exception e) {
1049                 throw new NoSuchAlgorithmException(e);
1050             }
1051         }
1052 
1053         public Object newInstance0(Object param) throws
1054                 PKCS11Exception, NoSuchAlgorithmException {
1055             String algorithm = getAlgorithm();
1056             String type = getType();
1057             if (type == MD) {
1058                 return new P11Digest(token, algorithm, mechanism);
1059             } else if (type == CIP) {
1060                 if (algorithm.startsWith(&quot;RSA&quot;)) {
1061                     return new P11RSACipher(token, algorithm, mechanism);
1062                 } else if (algorithm.endsWith(&quot;GCM/NoPadding&quot;)) {
1063                     return new P11AEADCipher(token, algorithm, mechanism);
1064                 } else {
1065                     return new P11Cipher(token, algorithm, mechanism);
1066                 }
1067             } else if (type == SIG) {
1068                 if (algorithm.indexOf(&quot;RSASSA-PSS&quot;) != -1) {
1069                     return new P11PSSSignature(token, algorithm, mechanism);
1070                 } else {
1071                     return new P11Signature(token, algorithm, mechanism);
1072                 }
1073             } else if (type == MAC) {
1074                 return new P11Mac(token, algorithm, mechanism);
1075             } else if (type == KPG) {
1076                 return new P11KeyPairGenerator(token, algorithm, mechanism);
1077             } else if (type == KA) {
1078                 if (algorithm.equals(&quot;ECDH&quot;)) {
1079                     return new P11ECDHKeyAgreement(token, algorithm, mechanism);
1080                 } else {
1081                     return new P11KeyAgreement(token, algorithm, mechanism);
1082                 }
1083             } else if (type == KF) {
1084                 return token.getKeyFactory(algorithm);
1085             } else if (type == SKF) {
1086                 return new P11SecretKeyFactory(token, algorithm);
1087             } else if (type == KG) {
1088                 // reference equality
1089                 if (algorithm == &quot;SunTlsRsaPremasterSecret&quot;) {
1090                     return new P11TlsRsaPremasterSecretGenerator(
1091                         token, algorithm, mechanism);
1092                 } else if (algorithm == &quot;SunTlsMasterSecret&quot;
1093                         || algorithm == &quot;SunTls12MasterSecret&quot;) {
1094                     return new P11TlsMasterSecretGenerator(
1095                         token, algorithm, mechanism);
1096                 } else if (algorithm == &quot;SunTlsKeyMaterial&quot;
1097                         || algorithm == &quot;SunTls12KeyMaterial&quot;) {
1098                     return new P11TlsKeyMaterialGenerator(
1099                         token, algorithm, mechanism);
1100                 } else if (algorithm == &quot;SunTlsPrf&quot;
1101                         || algorithm == &quot;SunTls12Prf&quot;) {
1102                     return new P11TlsPrfGenerator(token, algorithm, mechanism);
1103                 } else {
1104                     return new P11KeyGenerator(token, algorithm, mechanism);
1105                 }
1106             } else if (type == SR) {
1107                 return token.getRandom();
1108             } else if (type == KS) {
1109                 return token.getKeyStore();
1110             } else if (type == AGP) {
1111                 if (algorithm == &quot;EC&quot;) {
1112                     return new sun.security.util.ECParameters();
1113                 } else if (algorithm == &quot;GCM&quot;) {
1114                     return new sun.security.util.GCMParameters();
1115                 } else {
1116                     throw new NoSuchAlgorithmException(&quot;Unsupported algorithm: &quot;
1117                             + algorithm);
1118                 }
1119             } else {
1120                 throw new NoSuchAlgorithmException(&quot;Unknown type: &quot; + type);
1121             }
1122         }
1123 
1124         public boolean supportsParameter(Object param) {
1125             if ((param == null) || (token.isValid() == false)) {
1126                 return false;
1127             }
1128             if (param instanceof Key == false) {
1129                 throw new InvalidParameterException(&quot;Parameter must be a Key&quot;);
1130             }
1131             String algorithm = getAlgorithm();
1132             String type = getType();
1133             Key key = (Key)param;
1134             String keyAlgorithm = key.getAlgorithm();
1135             // RSA signatures and cipher
1136             if (((type == CIP) &amp;&amp; algorithm.startsWith(&quot;RSA&quot;))
1137                     || (type == SIG) &amp;&amp; (algorithm.indexOf(&quot;RSA&quot;) != -1)) {
1138                 if (keyAlgorithm.equals(&quot;RSA&quot;) == false) {
1139                     return false;
1140                 }
1141                 return isLocalKey(key)
1142                         || (key instanceof RSAPrivateKey)
1143                         || (key instanceof RSAPublicKey);
1144             }
1145             // EC
1146             if (((type == KA) &amp;&amp; algorithm.equals(&quot;ECDH&quot;))
1147                     || ((type == SIG) &amp;&amp; algorithm.contains(&quot;ECDSA&quot;))) {
1148                 if (keyAlgorithm.equals(&quot;EC&quot;) == false) {
1149                     return false;
1150                 }
1151                 return isLocalKey(key)
1152                         || (key instanceof ECPrivateKey)
1153                         || (key instanceof ECPublicKey);
1154             }
1155             // DSA signatures
1156             if ((type == SIG) &amp;&amp; algorithm.contains(&quot;DSA&quot;) &amp;&amp;
1157                     !algorithm.contains(&quot;ECDSA&quot;)) {
1158                 if (keyAlgorithm.equals(&quot;DSA&quot;) == false) {
1159                     return false;
1160                 }
1161                 return isLocalKey(key)
1162                         || (key instanceof DSAPrivateKey)
1163                         || (key instanceof DSAPublicKey);
1164             }
1165             // MACs and symmetric ciphers
1166             if ((type == CIP) || (type == MAC)) {
1167                 // do not check algorithm name, mismatch is unlikely anyway
1168                 return isLocalKey(key) || &quot;RAW&quot;.equals(key.getFormat());
1169             }
1170             // DH key agreement
1171             if (type == KA) {
1172                 if (keyAlgorithm.equals(&quot;DH&quot;) == false) {
1173                     return false;
1174                 }
1175                 return isLocalKey(key)
1176                         || (key instanceof DHPrivateKey)
1177                         || (key instanceof DHPublicKey);
1178             }
1179             // should not reach here,
1180             // unknown engine type or algorithm
1181             throw new AssertionError
1182                 (&quot;SunPKCS11 error: &quot; + type + &quot;, &quot; + algorithm);
1183         }
1184 
1185         private boolean isLocalKey(Key key) {
1186             return (key instanceof P11Key) &amp;&amp; (((P11Key)key).token == token);
1187         }
1188 
1189         public String toString() {
1190             return super.toString() +
1191                 &quot; (&quot; + Functions.getMechanismName(mechanism) + &quot;)&quot;;
1192         }
1193 
1194     }
1195 
1196     /**
1197      * Log in to this provider.
1198      *
1199      * &lt;p&gt; If the token expects a PIN to be supplied by the caller,
1200      * the &lt;code&gt;handler&lt;/code&gt; implementation must support
1201      * a &lt;code&gt;PasswordCallback&lt;/code&gt;.
1202      *
1203      * &lt;p&gt; To determine if the token supports a protected authentication path,
1204      * the CK_TOKEN_INFO flag, CKF_PROTECTED_AUTHENTICATION_PATH, is consulted.
1205      *
1206      * @param subject this parameter is ignored
1207      * @param handler the &lt;code&gt;CallbackHandler&lt;/code&gt; used by
1208      *  this provider to communicate with the caller
1209      *
1210      * @throws IllegalStateException if the provider requires configuration
1211      * and Provider.configure has not been called
1212      * @throws LoginException if the login operation fails
1213      * @throws SecurityException if the does not pass a security check for
1214      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1215      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1216      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1217      */
1218     public void login(Subject subject, CallbackHandler handler)
1219         throws LoginException {
1220 
1221         if (!isConfigured()) {
1222             throw new IllegalStateException(&quot;Configuration is required&quot;);
1223         }
1224 
1225         // security check
1226         SecurityManager sm = System.getSecurityManager();
1227         if (sm != null) {
1228             if (debug != null) {
1229                 debug.println(&quot;checking login permission&quot;);
1230             }
1231             sm.checkPermission(new SecurityPermission
1232                         (&quot;authProvider.&quot; + this.getName()));
1233         }
1234 
1235         if (hasValidToken() == false) {
1236             throw new LoginException(&quot;No token present&quot;);
1237         }
1238 
1239         // see if a login is required
1240 
1241         if ((token.tokenInfo.flags &amp; CKF_LOGIN_REQUIRED) == 0) {
1242             if (debug != null) {
1243                 debug.println(&quot;login operation not required for token - &quot; +
1244                                 &quot;ignoring login request&quot;);
1245             }
1246             return;
1247         }
1248 
1249         // see if user already logged in
1250 
1251         try {
1252             if (token.isLoggedInNow(null)) {
1253                 // user already logged in
1254                 if (debug != null) {
1255                     debug.println(&quot;user already logged in&quot;);
1256                 }
1257                 return;
1258             }
1259         } catch (PKCS11Exception e) {
1260             // ignore - fall thru and attempt login
1261         }
1262 
1263         // get the pin if necessary
1264 
1265         char[] pin = null;
1266         if ((token.tokenInfo.flags &amp; CKF_PROTECTED_AUTHENTICATION_PATH) == 0) {
1267 
1268             // get password
1269 
1270             CallbackHandler myHandler = getCallbackHandler(handler);
1271             if (myHandler == null) {
1272                 throw new LoginException
1273                         (&quot;no password provided, and no callback handler &quot; +
1274                         &quot;available for retrieving password&quot;);
1275             }
1276 
1277             java.text.MessageFormat form = new java.text.MessageFormat
1278                         (ResourcesMgr.getString
1279                         (&quot;PKCS11.Token.providerName.Password.&quot;));
1280             Object[] source = { getName() };
1281 
1282             PasswordCallback pcall = new PasswordCallback(form.format(source),
1283                                                         false);
1284             Callback[] callbacks = { pcall };
1285             try {
1286                 myHandler.handle(callbacks);
1287             } catch (Exception e) {
1288                 LoginException le = new LoginException
1289                         (&quot;Unable to perform password callback&quot;);
1290                 le.initCause(e);
1291                 throw le;
1292             }
1293 
1294             pin = pcall.getPassword();
1295             pcall.clearPassword();
1296             if (pin == null) {
1297                 if (debug != null) {
1298                     debug.println(&quot;caller passed NULL pin&quot;);
1299                 }
1300             }
1301         }
1302 
1303         // perform token login
1304 
1305         Session session = null;
1306         try {
1307             session = token.getOpSession();
1308 
1309             // pin is NULL if using CKF_PROTECTED_AUTHENTICATION_PATH
1310             p11.C_Login(session.id(), CKU_USER, pin);
1311             if (debug != null) {
1312                 debug.println(&quot;login succeeded&quot;);
1313             }
1314         } catch (PKCS11Exception pe) {
1315             if (pe.getErrorCode() == CKR_USER_ALREADY_LOGGED_IN) {
1316                 // let this one go
1317                 if (debug != null) {
1318                     debug.println(&quot;user already logged in&quot;);
1319                 }
1320                 return;
1321             } else if (pe.getErrorCode() == CKR_PIN_INCORRECT) {
1322                 FailedLoginException fle = new FailedLoginException();
1323                 fle.initCause(pe);
1324                 throw fle;
1325             } else {
1326                 LoginException le = new LoginException();
1327                 le.initCause(pe);
1328                 throw le;
1329             }
1330         } finally {
1331             token.releaseSession(session);
1332             if (pin != null) {
1333                 Arrays.fill(pin, &#39; &#39;);
1334             }
1335         }
1336 
1337         // we do not store the PIN in the subject for now
1338     }
1339 
1340     /**
1341      * Log out from this provider
1342      *
1343      * @throws IllegalStateException if the provider requires configuration
1344      * and Provider.configure has not been called
1345      * @throws LoginException if the logout operation fails
1346      * @throws SecurityException if the does not pass a security check for
1347      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1348      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1349      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1350      */
1351     public void logout() throws LoginException {
1352 
1353         if (!isConfigured()) {
1354             throw new IllegalStateException(&quot;Configuration is required&quot;);
1355         }
1356 
1357         // security check
1358         SecurityManager sm = System.getSecurityManager();
1359         if (sm != null) {
1360             sm.checkPermission
1361                 (new SecurityPermission(&quot;authProvider.&quot; + this.getName()));
1362         }
1363 
1364         if (hasValidToken() == false) {
1365             // app may call logout for cleanup, allow
1366             return;
1367         }
1368 
1369         if ((token.tokenInfo.flags &amp; CKF_LOGIN_REQUIRED) == 0) {
1370             if (debug != null) {
1371                 debug.println(&quot;logout operation not required for token - &quot; +
1372                                 &quot;ignoring logout request&quot;);
1373             }
1374             return;
1375         }
1376 
1377         try {
1378             if (token.isLoggedInNow(null) == false) {
1379                 if (debug != null) {
1380                     debug.println(&quot;user not logged in&quot;);
1381                 }
1382                 return;
1383             }
1384         } catch (PKCS11Exception e) {
1385             // ignore
1386         }
1387 
1388         // perform token logout
1389 
1390         Session session = null;
1391         try {
1392             session = token.getOpSession();
1393             p11.C_Logout(session.id());
1394             if (debug != null) {
1395                 debug.println(&quot;logout succeeded&quot;);
1396             }
1397         } catch (PKCS11Exception pe) {
1398             if (pe.getErrorCode() == CKR_USER_NOT_LOGGED_IN) {
1399                 // let this one go
1400                 if (debug != null) {
1401                     debug.println(&quot;user not logged in&quot;);
1402                 }
1403                 return;
1404             }
1405             LoginException le = new LoginException();
1406             le.initCause(pe);
1407             throw le;
1408         } finally {
1409             token.releaseSession(session);
1410         }
1411     }
1412 
1413     /**
1414      * Set a &lt;code&gt;CallbackHandler&lt;/code&gt;
1415      *
1416      * &lt;p&gt; The provider uses this handler if one is not passed to the
1417      * &lt;code&gt;login&lt;/code&gt; method.  The provider also uses this handler
1418      * if it invokes &lt;code&gt;login&lt;/code&gt; on behalf of callers.
1419      * In either case if a handler is not set via this method,
1420      * the provider queries the
1421      * &lt;i&gt;auth.login.defaultCallbackHandler&lt;/i&gt; security property
1422      * for the fully qualified class name of a default handler implementation.
1423      * If the security property is not set,
1424      * the provider is assumed to have alternative means
1425      * for obtaining authentication information.
1426      *
1427      * @param handler a &lt;code&gt;CallbackHandler&lt;/code&gt; for obtaining
1428      *          authentication information, which may be &lt;code&gt;null&lt;/code&gt;
1429      *
1430      * @throws IllegalStateException if the provider requires configuration
1431      * and Provider.configure has not been called
1432      * @throws SecurityException if the caller does not pass a
1433      *  security check for
1434      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1435      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1436      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1437      */
1438     public void setCallbackHandler(CallbackHandler handler) {
1439 
1440         if (!isConfigured()) {
1441             throw new IllegalStateException(&quot;Configuration is required&quot;);
1442         }
1443 
1444         // security check
1445         SecurityManager sm = System.getSecurityManager();
1446         if (sm != null) {
1447             sm.checkPermission
1448                 (new SecurityPermission(&quot;authProvider.&quot; + this.getName()));
1449         }
1450 
1451         synchronized (LOCK_HANDLER) {
1452             pHandler = handler;
1453         }
1454     }
1455 
1456     private CallbackHandler getCallbackHandler(CallbackHandler handler) {
1457 
1458         // get default handler if necessary
1459 
1460         if (handler != null) {
1461             return handler;
1462         }
1463 
1464         if (debug != null) {
1465             debug.println(&quot;getting provider callback handler&quot;);
1466         }
1467 
1468         synchronized (LOCK_HANDLER) {
1469             // see if handler was set via setCallbackHandler
1470             if (pHandler != null) {
1471                 return pHandler;
1472             }
1473 
1474             try {
1475                 if (debug != null) {
1476                     debug.println(&quot;getting default callback handler&quot;);
1477                 }
1478 
1479                 CallbackHandler myHandler = AccessController.doPrivileged
1480                     (new PrivilegedExceptionAction&lt;CallbackHandler&gt;() {
1481                     public CallbackHandler run() throws Exception {
1482 
1483                         String defaultHandler =
1484                                 java.security.Security.getProperty
1485                                 (&quot;auth.login.defaultCallbackHandler&quot;);
1486 
1487                         if (defaultHandler == null ||
1488                             defaultHandler.length() == 0) {
1489 
1490                             // ok
1491                             if (debug != null) {
1492                                 debug.println(&quot;no default handler set&quot;);
1493                             }
1494                             return null;
1495                         }
1496 
1497                         Class&lt;?&gt; c = Class.forName
1498                                    (defaultHandler,
1499                                    true,
1500                                    Thread.currentThread().getContextClassLoader());
1501                         if (!javax.security.auth.callback.CallbackHandler.class.isAssignableFrom(c)) {
1502                             // not the right subtype
1503                             if (debug != null) {
1504                                 debug.println(&quot;default handler &quot; + defaultHandler +
1505                                               &quot; is not a CallbackHandler&quot;);
1506                             }
1507                             return null;
1508                         }
1509                         @SuppressWarnings(&quot;deprecation&quot;)
1510                         Object result = c.newInstance();
1511                         return (CallbackHandler)result;
1512                     }
1513                 });
1514                 // save it
1515                 pHandler = myHandler;
1516                 return myHandler;
1517 
1518             } catch (PrivilegedActionException pae) {
1519                 // ok
1520                 if (debug != null) {
1521                     debug.println(&quot;Unable to load default callback handler&quot;);
1522                     pae.printStackTrace();
1523                 }
1524             }
1525         }
1526         return null;
1527     }
1528 
1529     private Object writeReplace() throws ObjectStreamException {
1530         return new SunPKCS11Rep(this);
1531     }
1532 
1533     /**
1534      * Serialized representation of the SunPKCS11 provider.
1535      */
1536     private static class SunPKCS11Rep implements Serializable {
1537 
1538         static final long serialVersionUID = -2896606995897745419L;
1539 
1540         private final String providerName;
1541 
1542         private final String configName;
1543 
1544         SunPKCS11Rep(SunPKCS11 provider) throws NotSerializableException {
1545             providerName = provider.getName();
1546             configName = provider.config.getFileName();
1547             if (Security.getProvider(providerName) != provider) {
1548                 throw new NotSerializableException(&quot;Only SunPKCS11 providers &quot;
1549                     + &quot;installed in java.security.Security can be serialized&quot;);
1550             }
1551         }
1552 
1553         private Object readResolve() throws ObjectStreamException {
1554             SunPKCS11 p = (SunPKCS11)Security.getProvider(providerName);
1555             if ((p == null) || (p.config.getFileName().equals(configName) == false)) {
1556                 throw new NotSerializableException(&quot;Could not find &quot;
1557                         + providerName + &quot; in installed providers&quot;);
1558             }
1559             return p;
1560         }
1561     }
1562 }
<a name="72" id="anc72"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="72" type="hidden" />
</body>
</html>
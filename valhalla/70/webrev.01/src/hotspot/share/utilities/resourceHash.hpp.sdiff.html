<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/resourceHash.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../runtime/threadSMR.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmError.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/resourceHash.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 34     //typename ResourceHashtableFns&lt;K&gt;::hash_fn   HASH   = primitive_hash&lt;K&gt;,
 35     //typename ResourceHashtableFns&lt;K&gt;::equals_fn EQUALS = primitive_equals&lt;K&gt;,
 36     unsigned (*HASH)  (K const&amp;)           = primitive_hash&lt;K&gt;,
 37     bool     (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;,
 38     unsigned SIZE = 256,
 39     ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,
 40     MEMFLAGS MEM_TYPE = mtInternal
 41     &gt;
 42 class ResourceHashtable : public ResourceObj {
 43  private:
 44 
 45   class Node : public ResourceObj {
 46    public:
 47     unsigned _hash;
 48     K _key;
 49     V _value;
 50     Node* _next;
 51 
 52     Node(unsigned hash, K const&amp; key, V const&amp; value) :
 53         _hash(hash), _key(key), _value(value), _next(NULL) {}





 54   };
 55 
 56   Node* _table[SIZE];
 57 
 58   // Returns a pointer to where the node where the value would reside if
 59   // it&#39;s in the table.
 60   Node** lookup_node(unsigned hash, K const&amp; key) {
 61     unsigned index = hash % SIZE;
 62     Node** ptr = &amp;_table[index];
 63     while (*ptr != NULL) {
 64       Node* node = *ptr;
 65       if (node-&gt;_hash == hash &amp;&amp; EQUALS(key, node-&gt;_key)) {
 66         break;
 67       }
 68       ptr = &amp;(node-&gt;_next);
 69     }
 70     return ptr;
 71   }
 72 
 73   Node const** lookup_node(unsigned hash, K const&amp; key) const {
</pre>
<hr />
<pre>
107     }
108   }
109 
110  /**
111   * Inserts or replaces a value in the table.
112   * @return: true:  if a new item is added
113   *          false: if the item already existed and the value is updated
114   */
115   bool put(K const&amp; key, V const&amp; value) {
116     unsigned hv = HASH(key);
117     Node** ptr = lookup_node(hv, key);
118     if (*ptr != NULL) {
119       (*ptr)-&gt;_value = value;
120       return false;
121     } else {
122       *ptr = new (ALLOC_TYPE, MEM_TYPE) Node(hv, key, value);
123       return true;
124     }
125   }
126 



































127   bool remove(K const&amp; key) {
128     unsigned hv = HASH(key);
129     Node** ptr = lookup_node(hv, key);
130 
131     Node* node = *ptr;
132     if (node != NULL) {
133       *ptr = node-&gt;_next;
134       if (ALLOC_TYPE == C_HEAP) {
135         delete node;
136       }
137       return true;
138     }
139     return false;
140   }
141 
142   // ITER contains bool do_entry(K const&amp;, V const&amp;), which will be
143   // called for each entry in the table.  If do_entry() returns false,
144   // the iteration is cancelled.
145   template&lt;class ITER&gt;
146   void iterate(ITER* iter) const {
</pre>
</td>
<td>
<hr />
<pre>
 34     //typename ResourceHashtableFns&lt;K&gt;::hash_fn   HASH   = primitive_hash&lt;K&gt;,
 35     //typename ResourceHashtableFns&lt;K&gt;::equals_fn EQUALS = primitive_equals&lt;K&gt;,
 36     unsigned (*HASH)  (K const&amp;)           = primitive_hash&lt;K&gt;,
 37     bool     (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;,
 38     unsigned SIZE = 256,
 39     ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,
 40     MEMFLAGS MEM_TYPE = mtInternal
 41     &gt;
 42 class ResourceHashtable : public ResourceObj {
 43  private:
 44 
 45   class Node : public ResourceObj {
 46    public:
 47     unsigned _hash;
 48     K _key;
 49     V _value;
 50     Node* _next;
 51 
 52     Node(unsigned hash, K const&amp; key, V const&amp; value) :
 53         _hash(hash), _key(key), _value(value), _next(NULL) {}
<span class="line-added"> 54 </span>
<span class="line-added"> 55     // Create a node with a default-constructed value.</span>
<span class="line-added"> 56     Node(unsigned hash, K const&amp; key) :</span>
<span class="line-added"> 57         _hash(hash), _key(key), _value(), _next(NULL) {}</span>
<span class="line-added"> 58 </span>
 59   };
 60 
 61   Node* _table[SIZE];
 62 
 63   // Returns a pointer to where the node where the value would reside if
 64   // it&#39;s in the table.
 65   Node** lookup_node(unsigned hash, K const&amp; key) {
 66     unsigned index = hash % SIZE;
 67     Node** ptr = &amp;_table[index];
 68     while (*ptr != NULL) {
 69       Node* node = *ptr;
 70       if (node-&gt;_hash == hash &amp;&amp; EQUALS(key, node-&gt;_key)) {
 71         break;
 72       }
 73       ptr = &amp;(node-&gt;_next);
 74     }
 75     return ptr;
 76   }
 77 
 78   Node const** lookup_node(unsigned hash, K const&amp; key) const {
</pre>
<hr />
<pre>
112     }
113   }
114 
115  /**
116   * Inserts or replaces a value in the table.
117   * @return: true:  if a new item is added
118   *          false: if the item already existed and the value is updated
119   */
120   bool put(K const&amp; key, V const&amp; value) {
121     unsigned hv = HASH(key);
122     Node** ptr = lookup_node(hv, key);
123     if (*ptr != NULL) {
124       (*ptr)-&gt;_value = value;
125       return false;
126     } else {
127       *ptr = new (ALLOC_TYPE, MEM_TYPE) Node(hv, key, value);
128       return true;
129     }
130   }
131 
<span class="line-added">132   // Look up the key.</span>
<span class="line-added">133   // If an entry for the key exists, leave map unchanged and return a pointer to its value.</span>
<span class="line-added">134   // If no entry for the key exists, create a new entry from key and a default-created value</span>
<span class="line-added">135   //  and return a pointer to the value.</span>
<span class="line-added">136   // *p_created is new if entry was created, false if entry pre-existed.</span>
<span class="line-added">137   V* put_if_absent(K const&amp; key, bool* p_created) {</span>
<span class="line-added">138     unsigned hv = HASH(key);</span>
<span class="line-added">139     Node** ptr = lookup_node(hv, key);</span>
<span class="line-added">140     if (*ptr == NULL) {</span>
<span class="line-added">141       *ptr = new (ALLOC_TYPE, MEM_TYPE) Node(hv, key);</span>
<span class="line-added">142       *p_created = true;</span>
<span class="line-added">143     } else {</span>
<span class="line-added">144       *p_created = false;</span>
<span class="line-added">145     }</span>
<span class="line-added">146     return &amp;(*ptr)-&gt;_value;</span>
<span class="line-added">147   }</span>
<span class="line-added">148 </span>
<span class="line-added">149   // Look up the key.</span>
<span class="line-added">150   // If an entry for the key exists, leave map unchanged and return a pointer to its value.</span>
<span class="line-added">151   // If no entry for the key exists, create a new entry from key and value and return a</span>
<span class="line-added">152   //  pointer to the value.</span>
<span class="line-added">153   // *p_created is new if entry was created, false if entry pre-existed.</span>
<span class="line-added">154   V* put_if_absent(K const&amp; key, V const&amp; value, bool* p_created) {</span>
<span class="line-added">155     unsigned hv = HASH(key);</span>
<span class="line-added">156     Node** ptr = lookup_node(hv, key);</span>
<span class="line-added">157     if (*ptr == NULL) {</span>
<span class="line-added">158       *ptr = new (ALLOC_TYPE, MEM_TYPE) Node(hv, key, value);</span>
<span class="line-added">159       *p_created = true;</span>
<span class="line-added">160     } else {</span>
<span class="line-added">161       *p_created = false;</span>
<span class="line-added">162     }</span>
<span class="line-added">163     return &amp;(*ptr)-&gt;_value;</span>
<span class="line-added">164   }</span>
<span class="line-added">165 </span>
<span class="line-added">166 </span>
167   bool remove(K const&amp; key) {
168     unsigned hv = HASH(key);
169     Node** ptr = lookup_node(hv, key);
170 
171     Node* node = *ptr;
172     if (node != NULL) {
173       *ptr = node-&gt;_next;
174       if (ALLOC_TYPE == C_HEAP) {
175         delete node;
176       }
177       return true;
178     }
179     return false;
180   }
181 
182   // ITER contains bool do_entry(K const&amp;, V const&amp;), which will be
183   // called for each entry in the table.  If do_entry() returns false,
184   // the iteration is cancelled.
185   template&lt;class ITER&gt;
186   void iterate(ITER* iter) const {
</pre>
</td>
</tr>
</table>
<center><a href="../runtime/threadSMR.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmError.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/resourceHash.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_RESOURCEHASH_HPP
 26 #define SHARE_UTILITIES_RESOURCEHASH_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 
 30 template&lt;
 31     typename K, typename V,
 32     // xlC does not compile this:
 33     // http://stackoverflow.com/questions/8532961/template-argument-of-type-that-is-defined-by-inner-typedef-from-other-template-c
 34     //typename ResourceHashtableFns&lt;K&gt;::hash_fn   HASH   = primitive_hash&lt;K&gt;,
 35     //typename ResourceHashtableFns&lt;K&gt;::equals_fn EQUALS = primitive_equals&lt;K&gt;,
 36     unsigned (*HASH)  (K const&amp;)           = primitive_hash&lt;K&gt;,
 37     bool     (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;,
 38     unsigned SIZE = 256,
 39     ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,
 40     MEMFLAGS MEM_TYPE = mtInternal
 41     &gt;
 42 class ResourceHashtable : public ResourceObj {
 43  private:
 44 
 45   class Node : public ResourceObj {
 46    public:
 47     unsigned _hash;
 48     K _key;
 49     V _value;
 50     Node* _next;
 51 
 52     Node(unsigned hash, K const&amp; key, V const&amp; value) :
 53         _hash(hash), _key(key), _value(value), _next(NULL) {}
<a name="1" id="anc1"></a>




 54   };
 55 
 56   Node* _table[SIZE];
 57 
 58   // Returns a pointer to where the node where the value would reside if
 59   // it&#39;s in the table.
 60   Node** lookup_node(unsigned hash, K const&amp; key) {
 61     unsigned index = hash % SIZE;
 62     Node** ptr = &amp;_table[index];
 63     while (*ptr != NULL) {
 64       Node* node = *ptr;
 65       if (node-&gt;_hash == hash &amp;&amp; EQUALS(key, node-&gt;_key)) {
 66         break;
 67       }
 68       ptr = &amp;(node-&gt;_next);
 69     }
 70     return ptr;
 71   }
 72 
 73   Node const** lookup_node(unsigned hash, K const&amp; key) const {
 74     return const_cast&lt;Node const**&gt;(
 75         const_cast&lt;ResourceHashtable*&gt;(this)-&gt;lookup_node(hash, key));
 76   }
 77 
 78  public:
 79   ResourceHashtable() { memset(_table, 0, SIZE * sizeof(Node*)); }
 80 
 81   ~ResourceHashtable() {
 82     if (ALLOC_TYPE == C_HEAP) {
 83       Node* const* bucket = _table;
 84       while (bucket &lt; &amp;_table[SIZE]) {
 85         Node* node = *bucket;
 86         while (node != NULL) {
 87           Node* cur = node;
 88           node = node-&gt;_next;
 89           delete cur;
 90         }
 91         ++bucket;
 92       }
 93     }
 94   }
 95 
 96   bool contains(K const&amp; key) const {
 97     return get(key) != NULL;
 98   }
 99 
100   V* get(K const&amp; key) const {
101     unsigned hv = HASH(key);
102     Node const** ptr = lookup_node(hv, key);
103     if (*ptr != NULL) {
104       return const_cast&lt;V*&gt;(&amp;(*ptr)-&gt;_value);
105     } else {
106       return NULL;
107     }
108   }
109 
110  /**
111   * Inserts or replaces a value in the table.
112   * @return: true:  if a new item is added
113   *          false: if the item already existed and the value is updated
114   */
115   bool put(K const&amp; key, V const&amp; value) {
116     unsigned hv = HASH(key);
117     Node** ptr = lookup_node(hv, key);
118     if (*ptr != NULL) {
119       (*ptr)-&gt;_value = value;
120       return false;
121     } else {
122       *ptr = new (ALLOC_TYPE, MEM_TYPE) Node(hv, key, value);
123       return true;
124     }
125   }
126 
<a name="2" id="anc2"></a>


































127   bool remove(K const&amp; key) {
128     unsigned hv = HASH(key);
129     Node** ptr = lookup_node(hv, key);
130 
131     Node* node = *ptr;
132     if (node != NULL) {
133       *ptr = node-&gt;_next;
134       if (ALLOC_TYPE == C_HEAP) {
135         delete node;
136       }
137       return true;
138     }
139     return false;
140   }
141 
142   // ITER contains bool do_entry(K const&amp;, V const&amp;), which will be
143   // called for each entry in the table.  If do_entry() returns false,
144   // the iteration is cancelled.
145   template&lt;class ITER&gt;
146   void iterate(ITER* iter) const {
147     Node* const* bucket = _table;
148     while (bucket &lt; &amp;_table[SIZE]) {
149       Node* node = *bucket;
150       while (node != NULL) {
151         bool cont = iter-&gt;do_entry(node-&gt;_key, node-&gt;_value);
152         if (!cont) { return; }
153         node = node-&gt;_next;
154       }
155       ++bucket;
156     }
157   }
158 };
159 
160 
161 #endif // SHARE_UTILITIES_RESOURCEHASH_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
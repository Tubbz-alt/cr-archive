<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/vmError.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="resourceHash.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/macosx/classes/apple/security/KeychainStore.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/vmError.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/gcConfig.hpp&quot;
  31 #include &quot;logging/logConfiguration.hpp&quot;
<span class="line-removed">  32 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/compressedOops.hpp&quot;
  36 #include &quot;prims/whitebox.hpp&quot;
  37 #include &quot;runtime/arguments.hpp&quot;
  38 #include &quot;runtime/atomic.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/init.hpp&quot;
  41 #include &quot;runtime/os.hpp&quot;
  42 #include &quot;runtime/safepointMechanism.hpp&quot;
  43 #include &quot;runtime/thread.inline.hpp&quot;
  44 #include &quot;runtime/threadSMR.hpp&quot;
  45 #include &quot;runtime/vmThread.hpp&quot;
  46 #include &quot;runtime/vmOperations.hpp&quot;
  47 #include &quot;runtime/vm_version.hpp&quot;
  48 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  49 #include &quot;services/memTracker.hpp&quot;
  50 #include &quot;utilities/debug.hpp&quot;
  51 #include &quot;utilities/decoder.hpp&quot;
  52 #include &quot;utilities/defaultStream.hpp&quot;
</pre>
<hr />
<pre>
 603        frame fr = os::fetch_frame_from_context(_context);
 604        fr.print_on_error(st, buf, sizeof(buf));
 605        st-&gt;cr();
 606        st-&gt;print_cr(&quot;#&quot;);
 607      }
 608 
 609   STEP(&quot;printing core file information&quot;)
 610     st-&gt;print(&quot;# &quot;);
 611     if (CreateCoredumpOnCrash) {
 612       if (coredump_status) {
 613         st-&gt;print(&quot;Core dump will be written. Default location: %s&quot;, coredump_message);
 614       } else {
 615         st-&gt;print(&quot;No core dump will be written. %s&quot;, coredump_message);
 616       }
 617     } else {
 618       st-&gt;print(&quot;CreateCoredumpOnCrash turned off, no core file dumped&quot;);
 619     }
 620     st-&gt;cr();
 621     st-&gt;print_cr(&quot;#&quot;);
 622 



 623   STEP(&quot;printing bug submit message&quot;)
 624 
 625      if (should_report_bug(_id) &amp;&amp; _verbose) {
 626        print_bug_submit_message(st, _thread);
 627      }
 628 
 629   STEP(&quot;printing summary&quot;)
 630 
 631      if (_verbose) {
 632        st-&gt;cr();
 633        st-&gt;print_cr(&quot;---------------  S U M M A R Y ------------&quot;);
 634        st-&gt;cr();
 635      }
 636 
 637   STEP(&quot;printing VM option summary&quot;)
 638 
 639      if (_verbose) {
 640        // VM options
 641        Arguments::print_summary_on(st);
 642        st-&gt;cr();
</pre>
<hr />
<pre>
1393       // TestUnresponsiveErrorHandler test. For that test we record
1394       // reporting_start_time at the beginning of the test.
1395       record_reporting_start_time();
1396     } else {
1397       out.print_raw_cr(&quot;Delaying recording reporting_start_time for TestUnresponsiveErrorHandler.&quot;);
1398     }
1399 
1400     if (ShowMessageBoxOnError || PauseAtExit) {
1401       show_message_box(buffer, sizeof(buffer));
1402 
1403       // User has asked JVM to abort. Reset ShowMessageBoxOnError so the
1404       // WatcherThread can kill JVM if the error handler hangs.
1405       ShowMessageBoxOnError = false;
1406     }
1407 
1408     os::check_dump_limit(buffer, sizeof(buffer));
1409 
1410     // reset signal handlers or exception filter; make sure recursive crashes
1411     // are handled properly.
1412     reset_signal_handlers();
<span class="line-removed">1413 </span>
<span class="line-removed">1414     EventShutdown e;</span>
<span class="line-removed">1415     if (e.should_commit()) {</span>
<span class="line-removed">1416       e.set_reason(&quot;VM Error&quot;);</span>
<span class="line-removed">1417       e.commit();</span>
<span class="line-removed">1418     }</span>
<span class="line-removed">1419 </span>
<span class="line-removed">1420     JFR_ONLY(Jfr::on_vm_shutdown(true);)</span>
<span class="line-removed">1421 </span>
1422   } else {
1423     // If UseOsErrorReporting we call this for each level of the call stack
1424     // while searching for the exception handler.  Only the first level needs
1425     // to be reported.
1426     if (UseOSErrorReporting &amp;&amp; log_done) return;
1427 
1428     // This is not the first error, see if it happened in a different thread
1429     // or in the same thread during error reporting.
1430     if (_first_error_tid != mytid) {
1431       char msgbuf[64];
1432       jio_snprintf(msgbuf, sizeof(msgbuf),
1433                    &quot;[thread &quot; INTX_FORMAT &quot; also had an error]&quot;,
1434                    mytid);
1435       out.print_raw_cr(msgbuf);
1436 
1437       // error reporting is not MT-safe, block current thread
1438       os::infinite_sleep();
1439 
1440     } else {
1441       if (recursive_error_count++ &gt; 30) {
</pre>
<hr />
<pre>
1523           out.print_raw_cr(&quot;# Can not save log file, dump to screen..&quot;);
1524           fd_log = 1;
1525         }
1526       }
1527       log.set_fd(fd_log);
1528     }
1529 
1530     report(&amp;log, true);
1531     log_done = true;
1532     _current_step = 0;
1533     _current_step_info = &quot;&quot;;
1534 
1535     if (fd_log &gt; 3) {
1536       close(fd_log);
1537       fd_log = -1;
1538     }
1539 
1540     log.set_fd(-1);
1541   }
1542 


1543   if (PrintNMTStatistics) {
1544     fdStream fds(fd_out);
1545     MemTracker::final_report(&amp;fds);
1546   }
1547 
1548   static bool skip_replay = ReplayCompiles; // Do not overwrite file during replay
1549   if (DumpReplayDataOnError &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Compiler_thread() &amp;&amp; !skip_replay) {
1550     skip_replay = true;
1551     ciEnv* env = ciEnv::current();
1552     if (env != NULL) {
1553       const bool overwrite = false; // We do not overwrite an existing replay file.
1554       int fd = prepare_log_file(ReplayDataFile, &quot;replay_pid%p.log&quot;, overwrite, buffer, sizeof(buffer));
1555       if (fd != -1) {
1556         FILE* replay_data_file = os::open(fd, &quot;w&quot;);
1557         if (replay_data_file != NULL) {
1558           fileStream replay_data_stream(replay_data_file, /*need_close=*/true);
1559           env-&gt;dump_replay_data_unsafe(&amp;replay_data_stream);
1560           out.print_raw(&quot;#\n# Compiler replay data is saved as:\n# &quot;);
1561           out.print_raw_cr(buffer);
1562         } else {
</pre>
</td>
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/gcConfig.hpp&quot;
  31 #include &quot;logging/logConfiguration.hpp&quot;

  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/compressedOops.hpp&quot;
  35 #include &quot;prims/whitebox.hpp&quot;
  36 #include &quot;runtime/arguments.hpp&quot;
  37 #include &quot;runtime/atomic.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/init.hpp&quot;
  40 #include &quot;runtime/os.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/thread.inline.hpp&quot;
  43 #include &quot;runtime/threadSMR.hpp&quot;
  44 #include &quot;runtime/vmThread.hpp&quot;
  45 #include &quot;runtime/vmOperations.hpp&quot;
  46 #include &quot;runtime/vm_version.hpp&quot;
  47 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  48 #include &quot;services/memTracker.hpp&quot;
  49 #include &quot;utilities/debug.hpp&quot;
  50 #include &quot;utilities/decoder.hpp&quot;
  51 #include &quot;utilities/defaultStream.hpp&quot;
</pre>
<hr />
<pre>
 602        frame fr = os::fetch_frame_from_context(_context);
 603        fr.print_on_error(st, buf, sizeof(buf));
 604        st-&gt;cr();
 605        st-&gt;print_cr(&quot;#&quot;);
 606      }
 607 
 608   STEP(&quot;printing core file information&quot;)
 609     st-&gt;print(&quot;# &quot;);
 610     if (CreateCoredumpOnCrash) {
 611       if (coredump_status) {
 612         st-&gt;print(&quot;Core dump will be written. Default location: %s&quot;, coredump_message);
 613       } else {
 614         st-&gt;print(&quot;No core dump will be written. %s&quot;, coredump_message);
 615       }
 616     } else {
 617       st-&gt;print(&quot;CreateCoredumpOnCrash turned off, no core file dumped&quot;);
 618     }
 619     st-&gt;cr();
 620     st-&gt;print_cr(&quot;#&quot;);
 621 
<span class="line-added"> 622   JFR_ONLY(STEP(&quot;printing jfr information&quot;))</span>
<span class="line-added"> 623   JFR_ONLY(Jfr::on_vm_error_report(st);)</span>
<span class="line-added"> 624 </span>
 625   STEP(&quot;printing bug submit message&quot;)
 626 
 627      if (should_report_bug(_id) &amp;&amp; _verbose) {
 628        print_bug_submit_message(st, _thread);
 629      }
 630 
 631   STEP(&quot;printing summary&quot;)
 632 
 633      if (_verbose) {
 634        st-&gt;cr();
 635        st-&gt;print_cr(&quot;---------------  S U M M A R Y ------------&quot;);
 636        st-&gt;cr();
 637      }
 638 
 639   STEP(&quot;printing VM option summary&quot;)
 640 
 641      if (_verbose) {
 642        // VM options
 643        Arguments::print_summary_on(st);
 644        st-&gt;cr();
</pre>
<hr />
<pre>
1395       // TestUnresponsiveErrorHandler test. For that test we record
1396       // reporting_start_time at the beginning of the test.
1397       record_reporting_start_time();
1398     } else {
1399       out.print_raw_cr(&quot;Delaying recording reporting_start_time for TestUnresponsiveErrorHandler.&quot;);
1400     }
1401 
1402     if (ShowMessageBoxOnError || PauseAtExit) {
1403       show_message_box(buffer, sizeof(buffer));
1404 
1405       // User has asked JVM to abort. Reset ShowMessageBoxOnError so the
1406       // WatcherThread can kill JVM if the error handler hangs.
1407       ShowMessageBoxOnError = false;
1408     }
1409 
1410     os::check_dump_limit(buffer, sizeof(buffer));
1411 
1412     // reset signal handlers or exception filter; make sure recursive crashes
1413     // are handled properly.
1414     reset_signal_handlers();









1415   } else {
1416     // If UseOsErrorReporting we call this for each level of the call stack
1417     // while searching for the exception handler.  Only the first level needs
1418     // to be reported.
1419     if (UseOSErrorReporting &amp;&amp; log_done) return;
1420 
1421     // This is not the first error, see if it happened in a different thread
1422     // or in the same thread during error reporting.
1423     if (_first_error_tid != mytid) {
1424       char msgbuf[64];
1425       jio_snprintf(msgbuf, sizeof(msgbuf),
1426                    &quot;[thread &quot; INTX_FORMAT &quot; also had an error]&quot;,
1427                    mytid);
1428       out.print_raw_cr(msgbuf);
1429 
1430       // error reporting is not MT-safe, block current thread
1431       os::infinite_sleep();
1432 
1433     } else {
1434       if (recursive_error_count++ &gt; 30) {
</pre>
<hr />
<pre>
1516           out.print_raw_cr(&quot;# Can not save log file, dump to screen..&quot;);
1517           fd_log = 1;
1518         }
1519       }
1520       log.set_fd(fd_log);
1521     }
1522 
1523     report(&amp;log, true);
1524     log_done = true;
1525     _current_step = 0;
1526     _current_step_info = &quot;&quot;;
1527 
1528     if (fd_log &gt; 3) {
1529       close(fd_log);
1530       fd_log = -1;
1531     }
1532 
1533     log.set_fd(-1);
1534   }
1535 
<span class="line-added">1536   JFR_ONLY(Jfr::on_vm_shutdown(true);)</span>
<span class="line-added">1537 </span>
1538   if (PrintNMTStatistics) {
1539     fdStream fds(fd_out);
1540     MemTracker::final_report(&amp;fds);
1541   }
1542 
1543   static bool skip_replay = ReplayCompiles; // Do not overwrite file during replay
1544   if (DumpReplayDataOnError &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Compiler_thread() &amp;&amp; !skip_replay) {
1545     skip_replay = true;
1546     ciEnv* env = ciEnv::current();
1547     if (env != NULL) {
1548       const bool overwrite = false; // We do not overwrite an existing replay file.
1549       int fd = prepare_log_file(ReplayDataFile, &quot;replay_pid%p.log&quot;, overwrite, buffer, sizeof(buffer));
1550       if (fd != -1) {
1551         FILE* replay_data_file = os::open(fd, &quot;w&quot;);
1552         if (replay_data_file != NULL) {
1553           fileStream replay_data_stream(replay_data_file, /*need_close=*/true);
1554           env-&gt;dump_replay_data_unsafe(&amp;replay_data_stream);
1555           out.print_raw(&quot;#\n# Compiler replay data is saved as:\n# &quot;);
1556           out.print_raw_cr(buffer);
1557         } else {
</pre>
</td>
</tr>
</table>
<center><a href="resourceHash.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/macosx/classes/apple/security/KeychainStore.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
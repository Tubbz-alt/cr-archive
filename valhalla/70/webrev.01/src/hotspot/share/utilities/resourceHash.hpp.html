<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/utilities/resourceHash.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_RESOURCEHASH_HPP
 26 #define SHARE_UTILITIES_RESOURCEHASH_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 
 30 template&lt;
 31     typename K, typename V,
 32     // xlC does not compile this:
 33     // http://stackoverflow.com/questions/8532961/template-argument-of-type-that-is-defined-by-inner-typedef-from-other-template-c
 34     //typename ResourceHashtableFns&lt;K&gt;::hash_fn   HASH   = primitive_hash&lt;K&gt;,
 35     //typename ResourceHashtableFns&lt;K&gt;::equals_fn EQUALS = primitive_equals&lt;K&gt;,
 36     unsigned (*HASH)  (K const&amp;)           = primitive_hash&lt;K&gt;,
 37     bool     (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;,
 38     unsigned SIZE = 256,
 39     ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,
 40     MEMFLAGS MEM_TYPE = mtInternal
 41     &gt;
 42 class ResourceHashtable : public ResourceObj {
 43  private:
 44 
 45   class Node : public ResourceObj {
 46    public:
 47     unsigned _hash;
 48     K _key;
 49     V _value;
 50     Node* _next;
 51 
 52     Node(unsigned hash, K const&amp; key, V const&amp; value) :
 53         _hash(hash), _key(key), _value(value), _next(NULL) {}
 54 
 55     // Create a node with a default-constructed value.
 56     Node(unsigned hash, K const&amp; key) :
 57         _hash(hash), _key(key), _value(), _next(NULL) {}
 58 
 59   };
 60 
 61   Node* _table[SIZE];
 62 
 63   // Returns a pointer to where the node where the value would reside if
 64   // it&#39;s in the table.
 65   Node** lookup_node(unsigned hash, K const&amp; key) {
 66     unsigned index = hash % SIZE;
 67     Node** ptr = &amp;_table[index];
 68     while (*ptr != NULL) {
 69       Node* node = *ptr;
 70       if (node-&gt;_hash == hash &amp;&amp; EQUALS(key, node-&gt;_key)) {
 71         break;
 72       }
 73       ptr = &amp;(node-&gt;_next);
 74     }
 75     return ptr;
 76   }
 77 
 78   Node const** lookup_node(unsigned hash, K const&amp; key) const {
 79     return const_cast&lt;Node const**&gt;(
 80         const_cast&lt;ResourceHashtable*&gt;(this)-&gt;lookup_node(hash, key));
 81   }
 82 
 83  public:
 84   ResourceHashtable() { memset(_table, 0, SIZE * sizeof(Node*)); }
 85 
 86   ~ResourceHashtable() {
 87     if (ALLOC_TYPE == C_HEAP) {
 88       Node* const* bucket = _table;
 89       while (bucket &lt; &amp;_table[SIZE]) {
 90         Node* node = *bucket;
 91         while (node != NULL) {
 92           Node* cur = node;
 93           node = node-&gt;_next;
 94           delete cur;
 95         }
 96         ++bucket;
 97       }
 98     }
 99   }
100 
101   bool contains(K const&amp; key) const {
102     return get(key) != NULL;
103   }
104 
105   V* get(K const&amp; key) const {
106     unsigned hv = HASH(key);
107     Node const** ptr = lookup_node(hv, key);
108     if (*ptr != NULL) {
109       return const_cast&lt;V*&gt;(&amp;(*ptr)-&gt;_value);
110     } else {
111       return NULL;
112     }
113   }
114 
115  /**
116   * Inserts or replaces a value in the table.
117   * @return: true:  if a new item is added
118   *          false: if the item already existed and the value is updated
119   */
120   bool put(K const&amp; key, V const&amp; value) {
121     unsigned hv = HASH(key);
122     Node** ptr = lookup_node(hv, key);
123     if (*ptr != NULL) {
124       (*ptr)-&gt;_value = value;
125       return false;
126     } else {
127       *ptr = new (ALLOC_TYPE, MEM_TYPE) Node(hv, key, value);
128       return true;
129     }
130   }
131 
132   // Look up the key.
133   // If an entry for the key exists, leave map unchanged and return a pointer to its value.
134   // If no entry for the key exists, create a new entry from key and a default-created value
135   //  and return a pointer to the value.
136   // *p_created is new if entry was created, false if entry pre-existed.
137   V* put_if_absent(K const&amp; key, bool* p_created) {
138     unsigned hv = HASH(key);
139     Node** ptr = lookup_node(hv, key);
140     if (*ptr == NULL) {
141       *ptr = new (ALLOC_TYPE, MEM_TYPE) Node(hv, key);
142       *p_created = true;
143     } else {
144       *p_created = false;
145     }
146     return &amp;(*ptr)-&gt;_value;
147   }
148 
149   // Look up the key.
150   // If an entry for the key exists, leave map unchanged and return a pointer to its value.
151   // If no entry for the key exists, create a new entry from key and value and return a
152   //  pointer to the value.
153   // *p_created is new if entry was created, false if entry pre-existed.
154   V* put_if_absent(K const&amp; key, V const&amp; value, bool* p_created) {
155     unsigned hv = HASH(key);
156     Node** ptr = lookup_node(hv, key);
157     if (*ptr == NULL) {
158       *ptr = new (ALLOC_TYPE, MEM_TYPE) Node(hv, key, value);
159       *p_created = true;
160     } else {
161       *p_created = false;
162     }
163     return &amp;(*ptr)-&gt;_value;
164   }
165 
166 
167   bool remove(K const&amp; key) {
168     unsigned hv = HASH(key);
169     Node** ptr = lookup_node(hv, key);
170 
171     Node* node = *ptr;
172     if (node != NULL) {
173       *ptr = node-&gt;_next;
174       if (ALLOC_TYPE == C_HEAP) {
175         delete node;
176       }
177       return true;
178     }
179     return false;
180   }
181 
182   // ITER contains bool do_entry(K const&amp;, V const&amp;), which will be
183   // called for each entry in the table.  If do_entry() returns false,
184   // the iteration is cancelled.
185   template&lt;class ITER&gt;
186   void iterate(ITER* iter) const {
187     Node* const* bucket = _table;
188     while (bucket &lt; &amp;_table[SIZE]) {
189       Node* node = *bucket;
190       while (node != NULL) {
191         bool cont = iter-&gt;do_entry(node-&gt;_key, node-&gt;_value);
192         if (!cont) { return; }
193         node = node-&gt;_next;
194       }
195       ++bucket;
196     }
197   }
198 };
199 
200 
201 #endif // SHARE_UTILITIES_RESOURCEHASH_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/threadSMR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/threadSMR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;logging/logStream.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;runtime/atomic.hpp&quot;
  29 #include &quot;runtime/jniHandles.inline.hpp&quot;
  30 #include &quot;runtime/orderAccess.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 #include &quot;runtime/thread.inline.hpp&quot;
  33 #include &quot;runtime/threadSMR.inline.hpp&quot;
  34 #include &quot;runtime/vmOperations.hpp&quot;
  35 #include &quot;services/threadIdTable.hpp&quot;
  36 #include &quot;services/threadService.hpp&quot;
  37 #include &quot;utilities/copy.hpp&quot;
  38 #include &quot;utilities/globalDefinitions.hpp&quot;
  39 #include &quot;utilities/ostream.hpp&quot;
  40 #include &quot;utilities/powerOfTwo.hpp&quot;
  41 #include &quot;utilities/resourceHash.hpp&quot;
  42 #include &quot;utilities/vmError.hpp&quot;
  43 



  44 // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
  45 // -XX:+EnableThreadSMRStatistics:
  46 
  47 // # of parallel threads in _delete_lock-&gt;wait().
  48 // Impl note: Hard to imagine &gt; 64K waiting threads so this could be 16-bit,
  49 // but there is no nice 16-bit _FORMAT support.
  50 uint                  ThreadsSMRSupport::_delete_lock_wait_cnt = 0;
  51 
  52 // Max # of parallel threads in _delete_lock-&gt;wait().
  53 // Impl note: See _delete_lock_wait_cnt note.
  54 uint                  ThreadsSMRSupport::_delete_lock_wait_max = 0;
  55 
  56 // Flag to indicate when an _delete_lock-&gt;notify() is needed.
  57 // Impl note: See _delete_lock_wait_cnt note.
  58 volatile uint         ThreadsSMRSupport::_delete_notify = 0;
  59 
  60 // # of threads deleted over VM lifetime.
  61 // Impl note: Atomically incremented over VM lifetime so use unsigned for more
  62 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
  63 // isn&#39;t available everywhere (or is it?).
</pre>
<hr />
<pre>
 906   const char* log_str = is_nested ? &quot;nested hazard ptr&quot; : &quot;regular hazard ptr&quot;;
 907 
 908   // Note: delete_lock is held in smr_delete() for the entire
 909   // hazard ptr search so that we do not lose this notify() if
 910   // the exiting thread has to wait. That code path also holds
 911   // Threads_lock (which was grabbed before delete_lock) so that
 912   // threads_do() can be called. This means the system can&#39;t start a
 913   // safepoint which means this thread can&#39;t take too long to get to
 914   // a safepoint because of being blocked on delete_lock.
 915   //
 916   MonitorLocker ml(ThreadsSMRSupport::delete_lock(), Monitor::_no_safepoint_check_flag);
 917   if (ThreadsSMRSupport::delete_notify()) {
 918     // Notify any exiting JavaThreads that are waiting in smr_delete()
 919     // that we&#39;ve released a ThreadsList.
 920     ml.notify_all();
 921     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
 922   }
 923 }
 924 
 925 void ThreadsSMRSupport::remove_thread(JavaThread *thread) {



 926   if (ThreadIdTable::is_initialized()) {
 927     jlong tid = SharedRuntime::get_java_tid(thread);
 928     ThreadIdTable::remove_thread(tid);
 929   }

 930   ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
 931   if (EnableThreadSMRStatistics) {
 932     ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
 933     // This list is smaller so no need to check for a &quot;longest&quot; update.
 934   }
 935 
 936   // Final _java_thread_list will not generate a &quot;Threads::remove&quot; mesg.
 937   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::remove: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 938 
 939   ThreadsList *old_list = ThreadsSMRSupport::xchg_java_thread_list(new_list);
 940   ThreadsSMRSupport::free_list(old_list);
 941 }
 942 
 943 // See note for clear_delete_notify().
 944 //
 945 void ThreadsSMRSupport::set_delete_notify() {
 946   Atomic::inc(&amp;_delete_notify);
 947 }
 948 
 949 // Safely delete a JavaThread when it is no longer in use by a
</pre>
<hr />
<pre>
 974 
 975   bool has_logged_once = false;
 976 
 977   while (true) {
 978     {
 979       // Will not make a safepoint check because this JavaThread
 980       // is not on the current ThreadsList.
 981       MutexLocker ml(Threads_lock);
 982       // Cannot use a MonitorLocker helper here because we have
 983       // to drop the Threads_lock first if we wait.
 984       ThreadsSMRSupport::delete_lock()-&gt;lock_without_safepoint_check();
 985       // Set the delete_notify flag after we grab delete_lock
 986       // and before we scan hazard ptrs because we&#39;re doing
 987       // double-check locking in release_stable_list().
 988       ThreadsSMRSupport::set_delete_notify();
 989 
 990       if (!is_a_protected_JavaThread(thread)) {
 991         // This is the common case.
 992         ThreadsSMRSupport::clear_delete_notify();
 993         ThreadsSMRSupport::delete_lock()-&gt;unlock();

 994         break;
 995       }
 996       if (!has_logged_once) {
 997         has_logged_once = true;
 998         log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::wait_until_not_protected: thread=&quot; INTPTR_FORMAT &quot; is not deleted.&quot;, os::current_thread_id(), p2i(thread));
 999         if (log_is_enabled(Debug, os, thread)) {
1000           ScanHazardPtrPrintMatchingThreadsClosure scan_cl(thread);
1001           threads_do(&amp;scan_cl);
1002           ThreadsList* current = _to_delete_list;
1003           while (current != NULL) {
1004             if (current-&gt;_nested_handle_cnt != 0 &amp;&amp; current-&gt;includes(thread)) {
1005               log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::wait_until_not_protected: found nested hazard pointer to thread=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(thread));
1006             }
1007             current = current-&gt;next_list();
1008           }
1009         }
1010       }
1011     } // We have to drop the Threads_lock to wait or delete the thread
1012 
1013     if (EnableThreadSMRStatistics) {
</pre>
<hr />
<pre>
1163   JavaThreadIterator jti(t_list);
1164   for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {
1165     st-&gt;print(INTPTR_FORMAT, p2i(jt));
1166     if (cnt &lt; t_list-&gt;length() - 1) {
1167       // Separate with comma or comma-space except for the last one.
1168       if (((cnt + 1) % 4) == 0) {
1169         // Four INTPTR_FORMAT fit on an 80 column line so end the
1170         // current line with just a comma.
1171         st-&gt;print_cr(&quot;,&quot;);
1172       } else {
1173         // Not the last one on the current line so use comma-space:
1174         st-&gt;print(&quot;, &quot;);
1175       }
1176     } else {
1177       // Last one so just end the current line.
1178       st-&gt;cr();
1179     }
1180     cnt++;
1181   }
1182 }












































</pre>
</td>
<td>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;logging/logStream.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;runtime/atomic.hpp&quot;
  29 #include &quot;runtime/jniHandles.inline.hpp&quot;
  30 #include &quot;runtime/orderAccess.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 #include &quot;runtime/thread.inline.hpp&quot;
  33 #include &quot;runtime/threadSMR.inline.hpp&quot;
  34 #include &quot;runtime/vmOperations.hpp&quot;
  35 #include &quot;services/threadIdTable.hpp&quot;
  36 #include &quot;services/threadService.hpp&quot;
  37 #include &quot;utilities/copy.hpp&quot;
  38 #include &quot;utilities/globalDefinitions.hpp&quot;
  39 #include &quot;utilities/ostream.hpp&quot;
  40 #include &quot;utilities/powerOfTwo.hpp&quot;
  41 #include &quot;utilities/resourceHash.hpp&quot;
  42 #include &quot;utilities/vmError.hpp&quot;
  43 
<span class="line-added">  44 // List of exiting threads</span>
<span class="line-added">  45 ThreadsSMRSupport::Holder* ThreadsSMRSupport::_exiting_threads = NULL;</span>
<span class="line-added">  46 </span>
  47 // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
  48 // -XX:+EnableThreadSMRStatistics:
  49 
  50 // # of parallel threads in _delete_lock-&gt;wait().
  51 // Impl note: Hard to imagine &gt; 64K waiting threads so this could be 16-bit,
  52 // but there is no nice 16-bit _FORMAT support.
  53 uint                  ThreadsSMRSupport::_delete_lock_wait_cnt = 0;
  54 
  55 // Max # of parallel threads in _delete_lock-&gt;wait().
  56 // Impl note: See _delete_lock_wait_cnt note.
  57 uint                  ThreadsSMRSupport::_delete_lock_wait_max = 0;
  58 
  59 // Flag to indicate when an _delete_lock-&gt;notify() is needed.
  60 // Impl note: See _delete_lock_wait_cnt note.
  61 volatile uint         ThreadsSMRSupport::_delete_notify = 0;
  62 
  63 // # of threads deleted over VM lifetime.
  64 // Impl note: Atomically incremented over VM lifetime so use unsigned for more
  65 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
  66 // isn&#39;t available everywhere (or is it?).
</pre>
<hr />
<pre>
 909   const char* log_str = is_nested ? &quot;nested hazard ptr&quot; : &quot;regular hazard ptr&quot;;
 910 
 911   // Note: delete_lock is held in smr_delete() for the entire
 912   // hazard ptr search so that we do not lose this notify() if
 913   // the exiting thread has to wait. That code path also holds
 914   // Threads_lock (which was grabbed before delete_lock) so that
 915   // threads_do() can be called. This means the system can&#39;t start a
 916   // safepoint which means this thread can&#39;t take too long to get to
 917   // a safepoint because of being blocked on delete_lock.
 918   //
 919   MonitorLocker ml(ThreadsSMRSupport::delete_lock(), Monitor::_no_safepoint_check_flag);
 920   if (ThreadsSMRSupport::delete_notify()) {
 921     // Notify any exiting JavaThreads that are waiting in smr_delete()
 922     // that we&#39;ve released a ThreadsList.
 923     ml.notify_all();
 924     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
 925   }
 926 }
 927 
 928 void ThreadsSMRSupport::remove_thread(JavaThread *thread) {
<span class="line-added"> 929 </span>
<span class="line-added"> 930   ThreadsSMRSupport::add_exiting_thread(thread);</span>
<span class="line-added"> 931 </span>
 932   if (ThreadIdTable::is_initialized()) {
 933     jlong tid = SharedRuntime::get_java_tid(thread);
 934     ThreadIdTable::remove_thread(tid);
 935   }
<span class="line-added"> 936 </span>
 937   ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
 938   if (EnableThreadSMRStatistics) {
 939     ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
 940     // This list is smaller so no need to check for a &quot;longest&quot; update.
 941   }
 942 
 943   // Final _java_thread_list will not generate a &quot;Threads::remove&quot; mesg.
 944   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::remove: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 945 
 946   ThreadsList *old_list = ThreadsSMRSupport::xchg_java_thread_list(new_list);
 947   ThreadsSMRSupport::free_list(old_list);
 948 }
 949 
 950 // See note for clear_delete_notify().
 951 //
 952 void ThreadsSMRSupport::set_delete_notify() {
 953   Atomic::inc(&amp;_delete_notify);
 954 }
 955 
 956 // Safely delete a JavaThread when it is no longer in use by a
</pre>
<hr />
<pre>
 981 
 982   bool has_logged_once = false;
 983 
 984   while (true) {
 985     {
 986       // Will not make a safepoint check because this JavaThread
 987       // is not on the current ThreadsList.
 988       MutexLocker ml(Threads_lock);
 989       // Cannot use a MonitorLocker helper here because we have
 990       // to drop the Threads_lock first if we wait.
 991       ThreadsSMRSupport::delete_lock()-&gt;lock_without_safepoint_check();
 992       // Set the delete_notify flag after we grab delete_lock
 993       // and before we scan hazard ptrs because we&#39;re doing
 994       // double-check locking in release_stable_list().
 995       ThreadsSMRSupport::set_delete_notify();
 996 
 997       if (!is_a_protected_JavaThread(thread)) {
 998         // This is the common case.
 999         ThreadsSMRSupport::clear_delete_notify();
1000         ThreadsSMRSupport::delete_lock()-&gt;unlock();
<span class="line-added">1001         ThreadsSMRSupport::remove_exiting_thread(thread);</span>
1002         break;
1003       }
1004       if (!has_logged_once) {
1005         has_logged_once = true;
1006         log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::wait_until_not_protected: thread=&quot; INTPTR_FORMAT &quot; is not deleted.&quot;, os::current_thread_id(), p2i(thread));
1007         if (log_is_enabled(Debug, os, thread)) {
1008           ScanHazardPtrPrintMatchingThreadsClosure scan_cl(thread);
1009           threads_do(&amp;scan_cl);
1010           ThreadsList* current = _to_delete_list;
1011           while (current != NULL) {
1012             if (current-&gt;_nested_handle_cnt != 0 &amp;&amp; current-&gt;includes(thread)) {
1013               log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::wait_until_not_protected: found nested hazard pointer to thread=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(thread));
1014             }
1015             current = current-&gt;next_list();
1016           }
1017         }
1018       }
1019     } // We have to drop the Threads_lock to wait or delete the thread
1020 
1021     if (EnableThreadSMRStatistics) {
</pre>
<hr />
<pre>
1171   JavaThreadIterator jti(t_list);
1172   for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {
1173     st-&gt;print(INTPTR_FORMAT, p2i(jt));
1174     if (cnt &lt; t_list-&gt;length() - 1) {
1175       // Separate with comma or comma-space except for the last one.
1176       if (((cnt + 1) % 4) == 0) {
1177         // Four INTPTR_FORMAT fit on an 80 column line so end the
1178         // current line with just a comma.
1179         st-&gt;print_cr(&quot;,&quot;);
1180       } else {
1181         // Not the last one on the current line so use comma-space:
1182         st-&gt;print(&quot;, &quot;);
1183       }
1184     } else {
1185       // Last one so just end the current line.
1186       st-&gt;cr();
1187     }
1188     cnt++;
1189   }
1190 }
<span class="line-added">1191 </span>
<span class="line-added">1192 void ThreadsSMRSupport::add_exiting_thread(JavaThread* thread) {</span>
<span class="line-added">1193   assert(thread == JavaThread::current(), &quot;invariant&quot;);</span>
<span class="line-added">1194   assert(Threads_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">1195   assert(!contains_exiting_thread(thread), &quot;invariant&quot;);</span>
<span class="line-added">1196   Holder* h = new Holder(thread, _exiting_threads);</span>
<span class="line-added">1197   _exiting_threads = h;</span>
<span class="line-added">1198 }</span>
<span class="line-added">1199 </span>
<span class="line-added">1200 void ThreadsSMRSupport::remove_exiting_thread(JavaThread* thread) {</span>
<span class="line-added">1201   assert(thread == JavaThread::current(), &quot;invariant&quot;);</span>
<span class="line-added">1202   assert(Threads_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">1203   // If a thread fails to initialize fully it can be deleted immediately</span>
<span class="line-added">1204   // so we won&#39;t remove it from the ThreadsList and so never add it to the</span>
<span class="line-added">1205   // exiting thread list - so we can&#39;t assert(contains_exiting_thread(p)) here.</span>
<span class="line-added">1206 </span>
<span class="line-added">1207   for (Holder* current = _exiting_threads, **prev_next = &amp;_exiting_threads;</span>
<span class="line-added">1208        current != NULL;</span>
<span class="line-added">1209        prev_next = &amp;current-&gt;_next, current = current-&gt;_next) {</span>
<span class="line-added">1210     if (current-&gt;_thread == thread) {</span>
<span class="line-added">1211       *prev_next = current-&gt;_next;</span>
<span class="line-added">1212       delete current;</span>
<span class="line-added">1213       break;</span>
<span class="line-added">1214     }</span>
<span class="line-added">1215   }</span>
<span class="line-added">1216 }</span>
<span class="line-added">1217 </span>
<span class="line-added">1218 #ifdef ASSERT</span>
<span class="line-added">1219 bool ThreadsSMRSupport::contains_exiting_thread(JavaThread* thread) {</span>
<span class="line-added">1220   for (Holder* current = _exiting_threads; current != NULL; current = current-&gt;_next) {</span>
<span class="line-added">1221     if (current-&gt;_thread == thread) {</span>
<span class="line-added">1222       return true;</span>
<span class="line-added">1223     }</span>
<span class="line-added">1224   }</span>
<span class="line-added">1225   return false;</span>
<span class="line-added">1226 }</span>
<span class="line-added">1227 #endif</span>
<span class="line-added">1228 </span>
<span class="line-added">1229 void ThreadsSMRSupport::exiting_threads_oops_do(OopClosure* f) {</span>
<span class="line-added">1230   assert_locked_or_safepoint(Threads_lock);</span>
<span class="line-added">1231   for (Holder* current = _exiting_threads; current != NULL; current = current-&gt;_next) {</span>
<span class="line-added">1232     f-&gt;do_oop((oop*) &amp;current-&gt;_thread-&gt;_threadObj);</span>
<span class="line-added">1233   }</span>
<span class="line-added">1234 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="thread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
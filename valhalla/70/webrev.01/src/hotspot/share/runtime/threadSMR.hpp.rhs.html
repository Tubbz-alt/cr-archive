<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/threadSMR.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_THREADSMR_HPP
 26 #define SHARE_RUNTIME_THREADSMR_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/timer.hpp&quot;
 30 
 31 class JavaThread;
 32 class Monitor;
 33 class outputStream;
 34 class Thread;
 35 class ThreadClosure;
 36 
 37 // Thread Safe Memory Reclamation (Thread-SMR) support.
 38 //
 39 // ThreadsListHandles are used to safely perform operations on one or more
 40 // threads without the risk of the thread or threads exiting during the
 41 // operation. It is no longer necessary to hold the Threads_lock to safely
 42 // perform an operation on a target thread.
 43 //
 44 // There are several different ways to refer to java.lang.Thread objects
 45 // so we have a few ways to get a protected JavaThread *:
 46 //
 47 // JNI jobject example:
 48 //   jobject jthread = ...;
 49 //   :
 50 //   ThreadsListHandle tlh;
 51 //   JavaThread* jt = NULL;
 52 //   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;jt, NULL);
 53 //   if (is_alive) {
 54 //     :  // do stuff with &#39;jt&#39;...
 55 //   }
 56 //
 57 // JVM/TI jthread example:
 58 //   jthread thread = ...;
 59 //   :
 60 //   JavaThread* jt = NULL;
 61 //   ThreadsListHandle tlh;
 62 //   jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &amp;jt, NULL);
 63 //   if (err != JVMTI_ERROR_NONE) {
 64 //     return err;
 65 //   }
 66 //   :  // do stuff with &#39;jt&#39;...
 67 //
 68 // JVM/TI oop example (this one should be very rare):
 69 //   oop thread_obj = ...;
 70 //   :
 71 //   JavaThread *jt = NULL;
 72 //   ThreadsListHandle tlh;
 73 //   jvmtiError err = JvmtiExport::cv_oop_to_JavaThread(tlh.list(), thread_obj, &amp;jt);
 74 //   if (err != JVMTI_ERROR_NONE) {
 75 //     return err;
 76 //   }
 77 //   :  // do stuff with &#39;jt&#39;...
 78 //
 79 // A JavaThread * that is included in the ThreadsList that is held by
 80 // a ThreadsListHandle is protected as long as the ThreadsListHandle
 81 // remains in scope. The target JavaThread * may have logically exited,
 82 // but that target JavaThread * will not be deleted until it is no
 83 // longer protected by a ThreadsListHandle.
<a name="1" id="anc1"></a><span class="line-modified"> 84 //</span>
<span class="line-added"> 85 // Once a JavaThread has removed itself from the main ThreadsList it is</span>
<span class="line-added"> 86 // no longer visited by GC. To ensure that thread&#39;s threadObj() oop remains</span>
<span class="line-added"> 87 // valid while the thread is still accessible from a ThreadsListHandle we</span>
<span class="line-added"> 88 // maintain a special list of exiting threads:</span>
<span class="line-added"> 89 // - In remove() we add the exiting thread to the list (under the Threads_lock).</span>
<span class="line-added"> 90 // - In wait_until_not_protected() we remove it from the list (again under the</span>
<span class="line-added"> 91 //   Threads_lock).</span>
<span class="line-added"> 92 // - Universe::oops_do walks the list (at a safepoint so VMThread holds</span>
<span class="line-added"> 93 //   Threads_lock) and visits the _threadObj oop of each JavaThread.</span>
 94 
 95 // SMR Support for the Threads class.
 96 //
 97 class ThreadsSMRSupport : AllStatic {
 98   friend class VMStructs;
 99   friend class SafeThreadsListPtr;  // for _nested_thread_list_max, delete_notify(), release_stable_list_wake_up() access
100 
<a name="2" id="anc2"></a><span class="line-added">101   // Helper class for the exiting thread list</span>
<span class="line-added">102   class Holder : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-added">103    public:</span>
<span class="line-added">104     JavaThread* _thread;</span>
<span class="line-added">105     Holder* _next;</span>
<span class="line-added">106     Holder(JavaThread* thread, Holder* next) : _thread(thread), _next(next) {}</span>
<span class="line-added">107   };</span>
<span class="line-added">108 </span>
<span class="line-added">109   // The list of exiting threads</span>
<span class="line-added">110   static Holder* _exiting_threads;</span>
<span class="line-added">111 </span>
112   // The coordination between ThreadsSMRSupport::release_stable_list() and
113   // ThreadsSMRSupport::smr_delete() uses the delete_lock in order to
114   // reduce the traffic on the Threads_lock.
115   static Monitor* delete_lock() { return ThreadsSMRDelete_lock; }
116 
117   // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
118   // -XX:+EnableThreadSMRStatistics (see thread.cpp for a
119   // description about each field):
120   static uint                  _delete_lock_wait_cnt;
121   static uint                  _delete_lock_wait_max;
122   // The delete_notify flag is used for proper double-check
123   // locking in order to reduce the traffic on the system wide
124   // Thread-SMR delete_lock.
125   static volatile uint         _delete_notify;
126   static volatile uint         _deleted_thread_cnt;
127   static volatile uint         _deleted_thread_time_max;
128   static volatile uint         _deleted_thread_times;
129   static ThreadsList           _bootstrap_list;
130   static ThreadsList* volatile _java_thread_list;
131   static uint64_t              _java_thread_list_alloc_cnt;
132   static uint64_t              _java_thread_list_free_cnt;
133   static uint                  _java_thread_list_max;
134   static uint                  _nested_thread_list_max;
135   static volatile uint         _tlh_cnt;
136   static volatile uint         _tlh_time_max;
137   static volatile uint         _tlh_times;
138   static ThreadsList*          _to_delete_list;
139   static uint                  _to_delete_list_cnt;
140   static uint                  _to_delete_list_max;
141 
142   static ThreadsList *acquire_stable_list_fast_path(Thread *self);
143   static ThreadsList *acquire_stable_list_nested_path(Thread *self);
144   static void add_deleted_thread_times(uint add_value);
145   static void add_tlh_times(uint add_value);
146   static void clear_delete_notify();
147   static bool delete_notify();
148   static void free_list(ThreadsList* threads);
149   static void inc_deleted_thread_cnt();
150   static void inc_java_thread_list_alloc_cnt();
151   static void inc_tlh_cnt();
152   static void release_stable_list_wake_up(bool is_nested);
153   static void set_delete_notify();
154   static void threads_do(ThreadClosure *tc);
155   static void threads_do(ThreadClosure *tc, ThreadsList *list);
156   static void update_deleted_thread_time_max(uint new_value);
157   static void update_java_thread_list_max(uint new_value);
158   static void update_tlh_time_max(uint new_value);
159   static void verify_hazard_ptr_scanned(Thread *self, ThreadsList *threads);
160   static ThreadsList* xchg_java_thread_list(ThreadsList* new_list);
161 
162  public:
163   static void add_thread(JavaThread *thread);
164   static ThreadsList* get_java_thread_list();
165   static bool is_a_protected_JavaThread(JavaThread *thread);
166   static bool is_a_protected_JavaThread_with_lock(JavaThread *thread);
167   static void wait_until_not_protected(JavaThread *thread);
168   static bool is_bootstrap_list(ThreadsList* list);
169   static void remove_thread(JavaThread *thread);
170   static void smr_delete(JavaThread *thread);
171   static void update_tlh_stats(uint millis);
172 
<a name="3" id="anc3"></a><span class="line-added">173   // Exiting thread list maintenance</span>
<span class="line-added">174   static void add_exiting_thread(JavaThread* thread);</span>
<span class="line-added">175   static void remove_exiting_thread(JavaThread* thread);</span>
<span class="line-added">176   DEBUG_ONLY(static bool contains_exiting_thread(JavaThread* thread);)</span>
<span class="line-added">177   static void exiting_threads_oops_do(OopClosure* f);</span>
<span class="line-added">178 </span>
179   // Logging and printing support:
180   static void log_statistics();
181   static void print_info_elements_on(outputStream* st, ThreadsList* t_list);
182   static void print_info_on(outputStream* st);
183   static void print_info_on(const Thread* thread, outputStream* st);
184 };
185 
186 // A fast list of JavaThreads.
187 //
188 class ThreadsList : public CHeapObj&lt;mtThread&gt; {
189   friend class VMStructs;
190   friend class SafeThreadsListPtr;  // for {dec,inc}_nested_handle_cnt() access
191   friend class ThreadsSMRSupport;  // for _nested_handle_cnt, {add,remove}_thread(), {,set_}next_list() access
192 
193   const uint _length;
194   ThreadsList* _next_list;
195   JavaThread *const *const _threads;
196   volatile intx _nested_handle_cnt;
197 
198   template &lt;class T&gt;
199   void threads_do_dispatch(T *cl, JavaThread *const thread) const;
200 
201   ThreadsList *next_list() const        { return _next_list; }
202   void set_next_list(ThreadsList *list) { _next_list = list; }
203 
204   void inc_nested_handle_cnt();
205   void dec_nested_handle_cnt();
206 
207   static ThreadsList* add_thread(ThreadsList* list, JavaThread* java_thread);
208   static ThreadsList* remove_thread(ThreadsList* list, JavaThread* java_thread);
209 
210 public:
211   ThreadsList(int entries);
212   ~ThreadsList();
213 
214   template &lt;class T&gt;
215   void threads_do(T *cl) const;
216 
217   uint length() const                       { return _length; }
218 
219   JavaThread *const thread_at(uint i) const { return _threads[i]; }
220 
221   JavaThread *const *threads() const        { return _threads; }
222 
223   // Returns -1 if target is not found.
224   int find_index_of_JavaThread(JavaThread* target);
225   JavaThread* find_JavaThread_from_java_tid(jlong java_tid) const;
226   bool includes(const JavaThread * const p) const;
227 };
228 
229 // An abstract safe ptr to a ThreadsList comprising either a stable hazard ptr
230 // for leaves, or a retained reference count for nested uses. The user of this
231 // API does not need to know which mechanism is providing the safety.
232 class SafeThreadsListPtr {
233   friend class ThreadsListSetter;
234 
235   SafeThreadsListPtr* _previous;
236   Thread*                 _thread;
237   ThreadsList*            _list;
238   bool                    _has_ref_count;
239   bool                    _needs_release;
240 
241   void acquire_stable_list();
242   void acquire_stable_list_fast_path();
243   void acquire_stable_list_nested_path();
244 
245   void release_stable_list();
246 
247   void verify_hazard_ptr_scanned();
248 
249 public:
250   // Constructor that attaches the list onto a thread.
251   SafeThreadsListPtr(Thread *thread, bool acquire) :
252     _previous(NULL),
253     _thread(thread),
254     _list(NULL),
255     _has_ref_count(false),
256     _needs_release(false)
257   {
258     if (acquire) {
259       acquire_stable_list();
260     }
261   }
262 
263   // Constructor that transfers ownership of the pointer.
264   SafeThreadsListPtr(SafeThreadsListPtr&amp; other) :
265     _previous(other._previous),
266     _thread(other._thread),
267     _list(other._list),
268     _has_ref_count(other._has_ref_count),
269     _needs_release(other._needs_release)
270   {
271     other._needs_release = false;
272   }
273 
274   ~SafeThreadsListPtr() {
275     if (_needs_release) {
276       release_stable_list();
277     }
278   }
279 
280   ThreadsList* list() const { return _list; }
281   SafeThreadsListPtr* previous() const { return _previous; }
282   void print_on(outputStream* st);
283 };
284 
285 // A helper to optionally set the hazard ptr in ourself. This helper can
286 // be used by ourself or by another thread. If the hazard ptr is set(),
287 // then the destructor will release it.
288 //
289 class ThreadsListSetter : public StackObj {
290 private:
291   SafeThreadsListPtr _list_ptr;
292 
293 public:
294   ThreadsListSetter() : _list_ptr(Thread::current(), /* acquire */ false) {}
295   ThreadsList* list() { return _list_ptr.list(); }
296   void set() { _list_ptr.acquire_stable_list(); }
297   bool is_set() { return _list_ptr._needs_release; }
298 };
299 
300 // This stack allocated ThreadsListHandle keeps all JavaThreads in the
301 // ThreadsList from being deleted until it is safe.
302 //
303 class ThreadsListHandle : public StackObj {
304   SafeThreadsListPtr _list_ptr;
305   elapsedTimer _timer;  // Enabled via -XX:+EnableThreadSMRStatistics.
306 
307 public:
308   ThreadsListHandle(Thread *self = Thread::current());
309   ~ThreadsListHandle();
310 
311   ThreadsList *list() const {
312     return _list_ptr.list();
313   }
314 
315   template &lt;class T&gt;
316   void threads_do(T *cl) const {
317     return list()-&gt;threads_do(cl);
318   }
319 
320   bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p);
321 
322   bool includes(JavaThread* p) {
323     return list()-&gt;includes(p);
324   }
325 
326   uint length() const {
327     return list()-&gt;length();
328   }
329 
330   JavaThread *thread_at(uint i) const {
331     return list()-&gt;thread_at(i);
332   }
333 };
334 
335 // This stack allocated JavaThreadIterator is used to walk the
336 // specified ThreadsList using the following style:
337 //
338 //   JavaThreadIterator jti(t_list);
339 //   for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {
340 //     ...
341 //   }
342 //
343 class JavaThreadIterator : public StackObj {
344   ThreadsList * _list;
345   uint _index;
346 
347 public:
348   JavaThreadIterator(ThreadsList *list) : _list(list), _index(0) {
349     assert(list != NULL, &quot;ThreadsList must not be NULL.&quot;);
350   }
351 
352   JavaThread *first() {
353     _index = 0;
354     return _list-&gt;thread_at(_index);
355   }
356 
357   uint length() const {
358     return _list-&gt;length();
359   }
360 
361   ThreadsList *list() const {
362     return _list;
363   }
364 
365   JavaThread *next() {
366     if (++_index &gt;= length()) {
367       return NULL;
368     }
369     return _list-&gt;thread_at(_index);
370   }
371 };
372 
373 // This stack allocated ThreadsListHandle and JavaThreadIterator combo
374 // is used to walk the ThreadsList in the included ThreadsListHandle
375 // using the following style:
376 //
377 //   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
378 //     ...
379 //   }
380 //
381 class JavaThreadIteratorWithHandle : public StackObj {
382   ThreadsListHandle _tlh;
383   uint _index;
384 
385 public:
386   JavaThreadIteratorWithHandle() : _index(0) {}
387 
388   uint length() const {
389     return _tlh.length();
390   }
391 
392   ThreadsList *list() const {
393     return _tlh.list();
394   }
395 
396   JavaThread *next() {
397     if (_index &gt;= length()) {
398       return NULL;
399     }
400     return _tlh.list()-&gt;thread_at(_index++);
401   }
402 
403   void rewind() {
404     _index = 0;
405   }
406 };
407 
408 #endif // SHARE_RUNTIME_THREADSMR_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/os.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/os.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
102 
103  public:
104   enum { page_sizes_max = 9 }; // Size of _page_sizes array (8 plus a sentinel)
105 
106  private:
107   static OSThread*          _starting_thread;
108   static address            _polling_page;
109  public:
110   static size_t             _page_sizes[page_sizes_max];
111 
112  private:
113   static void init_page_sizes(size_t default_page_size) {
114     _page_sizes[0] = default_page_size;
115     _page_sizes[1] = 0; // sentinel
116   }
117 
118   static char*  pd_reserve_memory(size_t bytes, char* addr = 0,
119                                   size_t alignment_hint = 0);
120   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr);
121   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc);
<span class="line-removed">122   static void   pd_split_reserved_memory(char *base, size_t size,</span>
<span class="line-removed">123                                       size_t split, bool realloc);</span>
124   static bool   pd_commit_memory(char* addr, size_t bytes, bool executable);
125   static bool   pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
126                                  bool executable);
127   // Same as pd_commit_memory() that either succeeds or calls
128   // vm_exit_out_of_memory() with the specified mesg.
129   static void   pd_commit_memory_or_exit(char* addr, size_t bytes,
130                                          bool executable, const char* mesg);
131   static void   pd_commit_memory_or_exit(char* addr, size_t size,
132                                          size_t alignment_hint,
133                                          bool executable, const char* mesg);
134   static bool   pd_uncommit_memory(char* addr, size_t bytes);
135   static bool   pd_release_memory(char* addr, size_t bytes);
136 
137   static char*  pd_map_memory(int fd, const char* file_name, size_t file_offset,
138                            char *addr, size_t bytes, bool read_only = false,
139                            bool allow_exec = false);
140   static char*  pd_remap_memory(int fd, const char* file_name, size_t file_offset,
141                              char *addr, size_t bytes, bool read_only,
142                              bool allow_exec);
143   static bool   pd_unmap_memory(char *addr, size_t bytes);
</pre>
<hr />
<pre>
303   static void trace_page_sizes(const char* str,
304                                const size_t region_min_size,
305                                const size_t region_max_size,
306                                const size_t page_size,
307                                const char* base,
308                                const size_t size);
309   static void trace_page_sizes_for_requested_size(const char* str,
310                                                   const size_t requested_size,
311                                                   const size_t page_size,
312                                                   const size_t alignment,
313                                                   const char* base,
314                                                   const size_t size);
315 
316   static int    vm_allocation_granularity();
317   static char*  reserve_memory(size_t bytes, char* addr = 0,
318                                size_t alignment_hint = 0, int file_desc = -1);
319   static char*  reserve_memory(size_t bytes, char* addr,
320                                size_t alignment_hint, MEMFLAGS flags);
321   static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);
322   static char*  attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc = -1);
<span class="line-modified">323   static void   split_reserved_memory(char *base, size_t size,</span>
<span class="line-modified">324                                       size_t split, bool realloc);</span>









325   static bool   commit_memory(char* addr, size_t bytes, bool executable);
326   static bool   commit_memory(char* addr, size_t size, size_t alignment_hint,
327                               bool executable);
328   // Same as commit_memory() that either succeeds or calls
329   // vm_exit_out_of_memory() with the specified mesg.
330   static void   commit_memory_or_exit(char* addr, size_t bytes,
331                                       bool executable, const char* mesg);
332   static void   commit_memory_or_exit(char* addr, size_t size,
333                                       size_t alignment_hint,
334                                       bool executable, const char* mesg);
335   static bool   uncommit_memory(char* addr, size_t bytes);
336   static bool   release_memory(char* addr, size_t bytes);
337 
338   // Touch memory pages that cover the memory range from start to end (exclusive)
339   // to make the OS back the memory range with actual memory.
340   // Current implementation may not touch the last page if unaligned addresses
341   // are passed.
342   static void   pretouch_memory(void* start, void* end, size_t page_size = vm_page_size());
343 
344   enum ProtType { MEM_PROT_NONE, MEM_PROT_READ, MEM_PROT_RW, MEM_PROT_RWX };
</pre>
</td>
<td>
<hr />
<pre>
102 
103  public:
104   enum { page_sizes_max = 9 }; // Size of _page_sizes array (8 plus a sentinel)
105 
106  private:
107   static OSThread*          _starting_thread;
108   static address            _polling_page;
109  public:
110   static size_t             _page_sizes[page_sizes_max];
111 
112  private:
113   static void init_page_sizes(size_t default_page_size) {
114     _page_sizes[0] = default_page_size;
115     _page_sizes[1] = 0; // sentinel
116   }
117 
118   static char*  pd_reserve_memory(size_t bytes, char* addr = 0,
119                                   size_t alignment_hint = 0);
120   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr);
121   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc);


122   static bool   pd_commit_memory(char* addr, size_t bytes, bool executable);
123   static bool   pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
124                                  bool executable);
125   // Same as pd_commit_memory() that either succeeds or calls
126   // vm_exit_out_of_memory() with the specified mesg.
127   static void   pd_commit_memory_or_exit(char* addr, size_t bytes,
128                                          bool executable, const char* mesg);
129   static void   pd_commit_memory_or_exit(char* addr, size_t size,
130                                          size_t alignment_hint,
131                                          bool executable, const char* mesg);
132   static bool   pd_uncommit_memory(char* addr, size_t bytes);
133   static bool   pd_release_memory(char* addr, size_t bytes);
134 
135   static char*  pd_map_memory(int fd, const char* file_name, size_t file_offset,
136                            char *addr, size_t bytes, bool read_only = false,
137                            bool allow_exec = false);
138   static char*  pd_remap_memory(int fd, const char* file_name, size_t file_offset,
139                              char *addr, size_t bytes, bool read_only,
140                              bool allow_exec);
141   static bool   pd_unmap_memory(char *addr, size_t bytes);
</pre>
<hr />
<pre>
301   static void trace_page_sizes(const char* str,
302                                const size_t region_min_size,
303                                const size_t region_max_size,
304                                const size_t page_size,
305                                const char* base,
306                                const size_t size);
307   static void trace_page_sizes_for_requested_size(const char* str,
308                                                   const size_t requested_size,
309                                                   const size_t page_size,
310                                                   const size_t alignment,
311                                                   const char* base,
312                                                   const size_t size);
313 
314   static int    vm_allocation_granularity();
315   static char*  reserve_memory(size_t bytes, char* addr = 0,
316                                size_t alignment_hint = 0, int file_desc = -1);
317   static char*  reserve_memory(size_t bytes, char* addr,
318                                size_t alignment_hint, MEMFLAGS flags);
319   static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);
320   static char*  attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc = -1);
<span class="line-modified">321 </span>
<span class="line-modified">322 </span>
<span class="line-added">323   // Split a reserved memory region [base, base+size) into two regions [base, base+split) and</span>
<span class="line-added">324   //  [base+split, base+size).</span>
<span class="line-added">325   //  This may remove the original mapping, so its content may be lost.</span>
<span class="line-added">326   // Both base and split point must be aligned to allocation granularity; split point shall</span>
<span class="line-added">327   //  be &gt;0 and &lt;size.</span>
<span class="line-added">328   // Splitting guarantees that the resulting two memory regions can be released independently</span>
<span class="line-added">329   //  from each other using os::release_memory().</span>
<span class="line-added">330   static void   split_reserved_memory(char *base, size_t size, size_t split);</span>
<span class="line-added">331 </span>
332   static bool   commit_memory(char* addr, size_t bytes, bool executable);
333   static bool   commit_memory(char* addr, size_t size, size_t alignment_hint,
334                               bool executable);
335   // Same as commit_memory() that either succeeds or calls
336   // vm_exit_out_of_memory() with the specified mesg.
337   static void   commit_memory_or_exit(char* addr, size_t bytes,
338                                       bool executable, const char* mesg);
339   static void   commit_memory_or_exit(char* addr, size_t size,
340                                       size_t alignment_hint,
341                                       bool executable, const char* mesg);
342   static bool   uncommit_memory(char* addr, size_t bytes);
343   static bool   release_memory(char* addr, size_t bytes);
344 
345   // Touch memory pages that cover the memory range from start to end (exclusive)
346   // to make the OS back the memory range with actual memory.
347   // Current implementation may not touch the last page if unaligned addresses
348   // are passed.
349   static void   pretouch_memory(void* start, void* end, size_t page_size = vm_page_size());
350 
351   enum ProtType { MEM_PROT_NONE, MEM_PROT_READ, MEM_PROT_RW, MEM_PROT_RWX };
</pre>
</td>
</tr>
</table>
<center><a href="os.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
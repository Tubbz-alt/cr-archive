diff a/src/hotspot/share/runtime/threadSMR.cpp b/src/hotspot/share/runtime/threadSMR.cpp
--- a/src/hotspot/share/runtime/threadSMR.cpp
+++ b/src/hotspot/share/runtime/threadSMR.cpp
@@ -39,10 +39,13 @@
 #include "utilities/ostream.hpp"
 #include "utilities/powerOfTwo.hpp"
 #include "utilities/resourceHash.hpp"
 #include "utilities/vmError.hpp"
 
+// List of exiting threads
+ThreadsSMRSupport::Holder* ThreadsSMRSupport::_exiting_threads = NULL;
+
 // The '_cnt', '_max' and '_times" fields are enabled via
 // -XX:+EnableThreadSMRStatistics:
 
 // # of parallel threads in _delete_lock->wait().
 // Impl note: Hard to imagine > 64K waiting threads so this could be 16-bit,
@@ -921,14 +924,18 @@
     log_debug(thread, smr)("tid=" UINTX_FORMAT ": ThreadsSMRSupport::release_stable_list notified %s", os::current_thread_id(), log_str);
   }
 }
 
 void ThreadsSMRSupport::remove_thread(JavaThread *thread) {
+
+  ThreadsSMRSupport::add_exiting_thread(thread);
+
   if (ThreadIdTable::is_initialized()) {
     jlong tid = SharedRuntime::get_java_tid(thread);
     ThreadIdTable::remove_thread(tid);
   }
+
   ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
   if (EnableThreadSMRStatistics) {
     ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
     // This list is smaller so no need to check for a "longest" update.
   }
@@ -989,10 +996,11 @@
 
       if (!is_a_protected_JavaThread(thread)) {
         // This is the common case.
         ThreadsSMRSupport::clear_delete_notify();
         ThreadsSMRSupport::delete_lock()->unlock();
+        ThreadsSMRSupport::remove_exiting_thread(thread);
         break;
       }
       if (!has_logged_once) {
         has_logged_once = true;
         log_debug(thread, smr)("tid=" UINTX_FORMAT ": ThreadsSMRSupport::wait_until_not_protected: thread=" INTPTR_FORMAT " is not deleted.", os::current_thread_id(), p2i(thread));
@@ -1178,5 +1186,49 @@
       st->cr();
     }
     cnt++;
   }
 }
+
+void ThreadsSMRSupport::add_exiting_thread(JavaThread* thread) {
+  assert(thread == JavaThread::current(), "invariant");
+  assert(Threads_lock->owned_by_self(), "invariant");
+  assert(!contains_exiting_thread(thread), "invariant");
+  Holder* h = new Holder(thread, _exiting_threads);
+  _exiting_threads = h;
+}
+
+void ThreadsSMRSupport::remove_exiting_thread(JavaThread* thread) {
+  assert(thread == JavaThread::current(), "invariant");
+  assert(Threads_lock->owned_by_self(), "invariant");
+  // If a thread fails to initialize fully it can be deleted immediately
+  // so we won't remove it from the ThreadsList and so never add it to the
+  // exiting thread list - so we can't assert(contains_exiting_thread(p)) here.
+
+  for (Holder* current = _exiting_threads, **prev_next = &_exiting_threads;
+       current != NULL;
+       prev_next = &current->_next, current = current->_next) {
+    if (current->_thread == thread) {
+      *prev_next = current->_next;
+      delete current;
+      break;
+    }
+  }
+}
+
+#ifdef ASSERT
+bool ThreadsSMRSupport::contains_exiting_thread(JavaThread* thread) {
+  for (Holder* current = _exiting_threads; current != NULL; current = current->_next) {
+    if (current->_thread == thread) {
+      return true;
+    }
+  }
+  return false;
+}
+#endif
+
+void ThreadsSMRSupport::exiting_threads_oops_do(OopClosure* f) {
+  assert_locked_or_safepoint(Threads_lock);
+  for (Holder* current = _exiting_threads; current != NULL; current = current->_next) {
+    f->do_oop((oop*) &current->_thread->_threadObj);
+  }
+}

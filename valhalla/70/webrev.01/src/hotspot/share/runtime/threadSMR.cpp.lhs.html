<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/threadSMR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;logging/logStream.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;runtime/atomic.hpp&quot;
  29 #include &quot;runtime/jniHandles.inline.hpp&quot;
  30 #include &quot;runtime/orderAccess.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 #include &quot;runtime/thread.inline.hpp&quot;
  33 #include &quot;runtime/threadSMR.inline.hpp&quot;
  34 #include &quot;runtime/vmOperations.hpp&quot;
  35 #include &quot;services/threadIdTable.hpp&quot;
  36 #include &quot;services/threadService.hpp&quot;
  37 #include &quot;utilities/copy.hpp&quot;
  38 #include &quot;utilities/globalDefinitions.hpp&quot;
  39 #include &quot;utilities/ostream.hpp&quot;
  40 #include &quot;utilities/powerOfTwo.hpp&quot;
  41 #include &quot;utilities/resourceHash.hpp&quot;
  42 #include &quot;utilities/vmError.hpp&quot;
  43 
<a name="1" id="anc1"></a>


  44 // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
  45 // -XX:+EnableThreadSMRStatistics:
  46 
  47 // # of parallel threads in _delete_lock-&gt;wait().
  48 // Impl note: Hard to imagine &gt; 64K waiting threads so this could be 16-bit,
  49 // but there is no nice 16-bit _FORMAT support.
  50 uint                  ThreadsSMRSupport::_delete_lock_wait_cnt = 0;
  51 
  52 // Max # of parallel threads in _delete_lock-&gt;wait().
  53 // Impl note: See _delete_lock_wait_cnt note.
  54 uint                  ThreadsSMRSupport::_delete_lock_wait_max = 0;
  55 
  56 // Flag to indicate when an _delete_lock-&gt;notify() is needed.
  57 // Impl note: See _delete_lock_wait_cnt note.
  58 volatile uint         ThreadsSMRSupport::_delete_notify = 0;
  59 
  60 // # of threads deleted over VM lifetime.
  61 // Impl note: Atomically incremented over VM lifetime so use unsigned for more
  62 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
  63 // isn&#39;t available everywhere (or is it?).
  64 volatile uint         ThreadsSMRSupport::_deleted_thread_cnt = 0;
  65 
  66 // Max time in millis to delete a thread.
  67 // Impl note: 16-bit might be too small on an overloaded machine. Use
  68 // unsigned since this is a time value. Set via Atomic::cmpxchg() in a
  69 // loop for correctness.
  70 volatile uint         ThreadsSMRSupport::_deleted_thread_time_max = 0;
  71 
  72 // Cumulative time in millis to delete threads.
  73 // Impl note: Atomically added to over VM lifetime so use unsigned for more
  74 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
  75 // isn&#39;t available everywhere (or is it?).
  76 volatile uint         ThreadsSMRSupport::_deleted_thread_times = 0;
  77 
  78 // The bootstrap list is empty and cannot be freed.
  79 ThreadsList ThreadsSMRSupport::_bootstrap_list = ThreadsList(0);
  80 
  81 // This is the VM&#39;s current &quot;threads list&quot; and it contains all of
  82 // the JavaThreads the VM considers to be alive at this moment in
  83 // time. The other ThreadsList objects in the VM contain past
  84 // snapshots of the &quot;threads list&quot;. _java_thread_list is initially
  85 // set to _bootstrap_list so that we can detect when we have a very
  86 // early use of a ThreadsListHandle.
  87 ThreadsList* volatile ThreadsSMRSupport::_java_thread_list = &amp;_bootstrap_list;
  88 
  89 // # of ThreadsLists allocated over VM lifetime.
  90 // Impl note: We allocate a new ThreadsList for every thread create and
  91 // every thread delete so we need a bigger type than the
  92 // _deleted_thread_cnt field.
  93 uint64_t              ThreadsSMRSupport::_java_thread_list_alloc_cnt = 1;
  94 
  95 // # of ThreadsLists freed over VM lifetime.
  96 // Impl note: See _java_thread_list_alloc_cnt note.
  97 uint64_t              ThreadsSMRSupport::_java_thread_list_free_cnt = 0;
  98 
  99 // Max size ThreadsList allocated.
 100 // Impl note: Max # of threads alive at one time should fit in unsigned 32-bit.
 101 uint                  ThreadsSMRSupport::_java_thread_list_max = 0;
 102 
 103 // Max # of nested ThreadsLists for a thread.
 104 // Impl note: Hard to imagine &gt; 64K nested ThreadsLists so this could be
 105 // 16-bit, but there is no nice 16-bit _FORMAT support.
 106 uint                  ThreadsSMRSupport::_nested_thread_list_max = 0;
 107 
 108 // # of ThreadsListHandles deleted over VM lifetime.
 109 // Impl note: Atomically incremented over VM lifetime so use unsigned for
 110 // more range. There will be fewer ThreadsListHandles than threads so
 111 // unsigned 32-bit should be fine.
 112 volatile uint         ThreadsSMRSupport::_tlh_cnt = 0;
 113 
 114 // Max time in millis to delete a ThreadsListHandle.
 115 // Impl note: 16-bit might be too small on an overloaded machine. Use
 116 // unsigned since this is a time value. Set via Atomic::cmpxchg() in a
 117 // loop for correctness.
 118 volatile uint         ThreadsSMRSupport::_tlh_time_max = 0;
 119 
 120 // Cumulative time in millis to delete ThreadsListHandles.
 121 // Impl note: Atomically added to over VM lifetime so use unsigned for more
 122 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
 123 // isn&#39;t available everywhere (or is it?).
 124 volatile uint         ThreadsSMRSupport::_tlh_times = 0;
 125 
 126 ThreadsList*          ThreadsSMRSupport::_to_delete_list = NULL;
 127 
 128 // # of parallel ThreadsLists on the to-delete list.
 129 // Impl note: Hard to imagine &gt; 64K ThreadsLists needing to be deleted so
 130 // this could be 16-bit, but there is no nice 16-bit _FORMAT support.
 131 uint                  ThreadsSMRSupport::_to_delete_list_cnt = 0;
 132 
 133 // Max # of parallel ThreadsLists on the to-delete list.
 134 // Impl note: See _to_delete_list_cnt note.
 135 uint                  ThreadsSMRSupport::_to_delete_list_max = 0;
 136 
 137 // &#39;inline&#39; functions first so the definitions are before first use:
 138 
 139 inline void ThreadsSMRSupport::add_deleted_thread_times(uint add_value) {
 140   Atomic::add(&amp;_deleted_thread_times, add_value);
 141 }
 142 
 143 inline void ThreadsSMRSupport::inc_deleted_thread_cnt() {
 144   Atomic::inc(&amp;_deleted_thread_cnt);
 145 }
 146 
 147 inline void ThreadsSMRSupport::inc_java_thread_list_alloc_cnt() {
 148   _java_thread_list_alloc_cnt++;
 149 }
 150 
 151 inline bool ThreadsSMRSupport::is_bootstrap_list(ThreadsList* list) {
 152   return list == &amp;_bootstrap_list;
 153 }
 154 
 155 inline void ThreadsSMRSupport::update_deleted_thread_time_max(uint new_value) {
 156   while (true) {
 157     uint cur_value = _deleted_thread_time_max;
 158     if (new_value &lt;= cur_value) {
 159       // No need to update max value so we&#39;re done.
 160       break;
 161     }
 162     if (Atomic::cmpxchg(&amp;_deleted_thread_time_max, cur_value, new_value) == cur_value) {
 163       // Updated max value so we&#39;re done. Otherwise try it all again.
 164       break;
 165     }
 166   }
 167 }
 168 
 169 inline void ThreadsSMRSupport::update_java_thread_list_max(uint new_value) {
 170   if (new_value &gt; _java_thread_list_max) {
 171     _java_thread_list_max = new_value;
 172   }
 173 }
 174 
 175 inline ThreadsList* ThreadsSMRSupport::xchg_java_thread_list(ThreadsList* new_list) {
 176   return (ThreadsList*)Atomic::xchg(&amp;_java_thread_list, new_list);
 177 }
 178 
 179 // Hash table of pointers found by a scan. Used for collecting hazard
 180 // pointers (ThreadsList references). Also used for collecting JavaThreads
 181 // that are indirectly referenced by hazard ptrs. An instance of this
 182 // class only contains one type of pointer.
 183 //
 184 class ThreadScanHashtable : public CHeapObj&lt;mtThread&gt; {
 185  private:
 186   static bool ptr_equals(void * const&amp; s1, void * const&amp; s2) {
 187     return s1 == s2;
 188   }
 189 
 190   static unsigned int ptr_hash(void * const&amp; s1) {
 191     // 2654435761 = 2^32 * Phi (golden ratio)
 192     return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);
 193   }
 194 
 195   int _table_size;
 196   // ResourceHashtable SIZE is specified at compile time so our
 197   // dynamic _table_size is unused for now; 1031 is the first prime
 198   // after 1024.
 199   typedef ResourceHashtable&lt;void *, int, &amp;ThreadScanHashtable::ptr_hash,
 200                             &amp;ThreadScanHashtable::ptr_equals, 1031,
 201                             ResourceObj::C_HEAP, mtThread&gt; PtrTable;
 202   PtrTable * _ptrs;
 203 
 204  public:
 205   // ResourceHashtable is passed to various functions and populated in
 206   // different places so we allocate it using C_HEAP to make it immune
 207   // from any ResourceMarks that happen to be in the code paths.
 208   ThreadScanHashtable(int table_size) : _table_size(table_size), _ptrs(new (ResourceObj::C_HEAP, mtThread) PtrTable()) {}
 209 
 210   ~ThreadScanHashtable() { delete _ptrs; }
 211 
 212   bool has_entry(void *pointer) {
 213     int *val_ptr = _ptrs-&gt;get(pointer);
 214     return val_ptr != NULL &amp;&amp; *val_ptr == 1;
 215   }
 216 
 217   void add_entry(void *pointer) {
 218     _ptrs-&gt;put(pointer, 1);
 219   }
 220 };
 221 
 222 // Closure to gather JavaThreads indirectly referenced by hazard ptrs
 223 // (ThreadsList references) into a hash table. This closure handles part 2
 224 // of the dance - adding all the JavaThreads referenced by the hazard
 225 // pointer (ThreadsList reference) to the hash table.
 226 //
 227 class AddThreadHazardPointerThreadClosure : public ThreadClosure {
 228  private:
 229   ThreadScanHashtable *_table;
 230 
 231  public:
 232   AddThreadHazardPointerThreadClosure(ThreadScanHashtable *table) : _table(table) {}
 233 
 234   virtual void do_thread(Thread *thread) {
 235     if (!_table-&gt;has_entry((void*)thread)) {
 236       // The same JavaThread might be on more than one ThreadsList or
 237       // more than one thread might be using the same ThreadsList. In
 238       // either case, we only need a single entry for a JavaThread.
 239       _table-&gt;add_entry((void*)thread);
 240     }
 241   }
 242 };
 243 
 244 // Closure to gather JavaThreads indirectly referenced by hazard ptrs
 245 // (ThreadsList references) into a hash table. This closure handles part 1
 246 // of the dance - hazard ptr chain walking and dispatch to another
 247 // closure.
 248 //
 249 class ScanHazardPtrGatherProtectedThreadsClosure : public ThreadClosure {
 250  private:
 251   ThreadScanHashtable *_table;
 252  public:
 253   ScanHazardPtrGatherProtectedThreadsClosure(ThreadScanHashtable *table) : _table(table) {}
 254 
 255   virtual void do_thread(Thread *thread) {
 256     assert_locked_or_safepoint(Threads_lock);
 257 
 258     if (thread == NULL) return;
 259 
 260     // This code races with ThreadsSMRSupport::acquire_stable_list() which
 261     // is lock-free so we have to handle some special situations.
 262     //
 263     ThreadsList *current_list = NULL;
 264     while (true) {
 265       current_list = thread-&gt;get_threads_hazard_ptr();
 266       // No hazard ptr so nothing more to do.
 267       if (current_list == NULL) {
 268         return;
 269       }
 270 
 271       // If the hazard ptr is verified as stable (since it is not tagged),
 272       // then it is safe to use.
 273       if (!Thread::is_hazard_ptr_tagged(current_list)) break;
 274 
 275       // The hazard ptr is tagged as not yet verified as being stable
 276       // so we are racing with acquire_stable_list(). This exchange
 277       // attempts to invalidate the hazard ptr. If we win the race,
 278       // then we can ignore this unstable hazard ptr and the other
 279       // thread will retry the attempt to publish a stable hazard ptr.
 280       // If we lose the race, then we retry our attempt to look at the
 281       // hazard ptr.
 282       if (thread-&gt;cmpxchg_threads_hazard_ptr(NULL, current_list) == current_list) return;
 283     }
 284 
 285     // The current JavaThread has a hazard ptr (ThreadsList reference)
 286     // which might be _java_thread_list or it might be an older
 287     // ThreadsList that has been removed but not freed. In either case,
 288     // the hazard ptr is protecting all the JavaThreads on that
 289     // ThreadsList.
 290     AddThreadHazardPointerThreadClosure add_cl(_table);
 291     current_list-&gt;threads_do(&amp;add_cl);
 292   }
 293 };
 294 
 295 // Closure to gather hazard ptrs (ThreadsList references) into a hash table.
 296 //
 297 class ScanHazardPtrGatherThreadsListClosure : public ThreadClosure {
 298  private:
 299   ThreadScanHashtable *_table;
 300  public:
 301   ScanHazardPtrGatherThreadsListClosure(ThreadScanHashtable *table) : _table(table) {}
 302 
 303   virtual void do_thread(Thread* thread) {
 304     assert_locked_or_safepoint(Threads_lock);
 305 
 306     if (thread == NULL) return;
 307     ThreadsList *threads = thread-&gt;get_threads_hazard_ptr();
 308     if (threads == NULL) {
 309       return;
 310     }
 311     // In this closure we always ignore the tag that might mark this
 312     // hazard ptr as not yet verified. If we happen to catch an
 313     // unverified hazard ptr that is subsequently discarded (not
 314     // published), then the only side effect is that we might keep a
 315     // to-be-deleted ThreadsList alive a little longer.
 316     threads = Thread::untag_hazard_ptr(threads);
 317     if (!_table-&gt;has_entry((void*)threads)) {
 318       _table-&gt;add_entry((void*)threads);
 319     }
 320   }
 321 };
 322 
 323 // Closure to print JavaThreads that have a hazard ptr (ThreadsList
 324 // reference) that contains an indirect reference to a specific JavaThread.
 325 //
 326 class ScanHazardPtrPrintMatchingThreadsClosure : public ThreadClosure {
 327  private:
 328   JavaThread *_thread;
 329  public:
 330   ScanHazardPtrPrintMatchingThreadsClosure(JavaThread *thread) : _thread(thread) {}
 331 
 332   virtual void do_thread(Thread *thread) {
 333     assert_locked_or_safepoint(Threads_lock);
 334 
 335     if (thread == NULL) return;
 336     ThreadsList *current_list = thread-&gt;get_threads_hazard_ptr();
 337     if (current_list == NULL) {
 338       return;
 339     }
 340     // If the hazard ptr is unverified, then ignore it.
 341     if (Thread::is_hazard_ptr_tagged(current_list)) return;
 342 
 343     // The current JavaThread has a hazard ptr (ThreadsList reference)
 344     // which might be _java_thread_list or it might be an older
 345     // ThreadsList that has been removed but not freed. In either case,
 346     // the hazard ptr is protecting all the JavaThreads on that
 347     // ThreadsList, but we only care about matching a specific JavaThread.
 348     JavaThreadIterator jti(current_list);
 349     for (JavaThread *p = jti.first(); p != NULL; p = jti.next()) {
 350       if (p == _thread) {
 351         log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread1=&quot; INTPTR_FORMAT &quot; has a hazard pointer for thread2=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(thread), p2i(_thread));
 352         break;
 353       }
 354     }
 355   }
 356 };
 357 
 358 // Closure to determine if the specified JavaThread is found by
 359 // threads_do().
 360 //
 361 class VerifyHazardPtrThreadClosure : public ThreadClosure {
 362  private:
 363   bool _found;
 364   Thread *_self;
 365 
 366  public:
 367   VerifyHazardPtrThreadClosure(Thread *self) : _found(false), _self(self) {}
 368 
 369   bool found() const { return _found; }
 370 
 371   virtual void do_thread(Thread *thread) {
 372     if (thread == _self) {
 373       _found = true;
 374     }
 375   }
 376 };
 377 
 378 
 379 // Acquire a stable ThreadsList.
 380 //
 381 void SafeThreadsListPtr::acquire_stable_list() {
 382   assert(_thread != NULL, &quot;sanity check&quot;);
 383   _needs_release = true;
 384   _previous = _thread-&gt;_threads_list_ptr;
 385   _thread-&gt;_threads_list_ptr = this;
 386 
 387   if (_thread-&gt;get_threads_hazard_ptr() == NULL) {
 388     // The typical case is first.
 389     acquire_stable_list_fast_path();
 390     return;
 391   }
 392 
 393   // The nested case is rare.
 394   acquire_stable_list_nested_path();
 395 }
 396 
 397 // Fast path way to acquire a stable ThreadsList.
 398 //
 399 void SafeThreadsListPtr::acquire_stable_list_fast_path() {
 400   assert(_thread != NULL, &quot;sanity check&quot;);
 401   assert(_thread-&gt;get_threads_hazard_ptr() == NULL, &quot;sanity check&quot;);
 402 
 403   ThreadsList* threads;
 404 
 405   // Stable recording of a hazard ptr for SMR. This code does not use
 406   // locks so its use of the _smr_java_thread_list &amp; _threads_hazard_ptr
 407   // fields is racy relative to code that uses those fields with locks.
 408   // OrderAccess and Atomic functions are used to deal with those races.
 409   //
 410   while (true) {
 411     threads = ThreadsSMRSupport::get_java_thread_list();
 412 
 413     // Publish a tagged hazard ptr to denote that the hazard ptr is not
 414     // yet verified as being stable. Due to the fence after the hazard
 415     // ptr write, it will be sequentially consistent w.r.t. the
 416     // sequentially consistent writes of the ThreadsList, even on
 417     // non-multiple copy atomic machines where stores can be observed
 418     // in different order from different observer threads.
 419     ThreadsList* unverified_threads = Thread::tag_hazard_ptr(threads);
 420     _thread-&gt;set_threads_hazard_ptr(unverified_threads);
 421 
 422     // If _smr_java_thread_list has changed, we have lost a race with
 423     // Threads::add() or Threads::remove() and have to try again.
 424     if (ThreadsSMRSupport::get_java_thread_list() != threads) {
 425       continue;
 426     }
 427 
 428     // We try to remove the tag which will verify the hazard ptr as
 429     // being stable. This exchange can race with a scanning thread
 430     // which might invalidate the tagged hazard ptr to keep it from
 431     // being followed to access JavaThread ptrs. If we lose the race,
 432     // we simply retry. If we win the race, then the stable hazard
 433     // ptr is officially published.
 434     if (_thread-&gt;cmpxchg_threads_hazard_ptr(threads, unverified_threads) == unverified_threads) {
 435       break;
 436     }
 437   }
 438 
 439   // A stable hazard ptr has been published letting other threads know
 440   // that the ThreadsList and the JavaThreads reachable from this list
 441   // are protected and hence they should not be deleted until everyone
 442   // agrees it is safe to do so.
 443 
 444   _list = threads;
 445 
 446   verify_hazard_ptr_scanned();
 447 }
 448 
 449 // Acquire a nested stable ThreadsList; this is rare so it uses
 450 // reference counting.
 451 //
 452 void SafeThreadsListPtr::acquire_stable_list_nested_path() {
 453   assert(_thread != NULL, &quot;sanity check&quot;);
 454   assert(_thread-&gt;get_threads_hazard_ptr() != NULL,
 455          &quot;cannot have a NULL regular hazard ptr when acquiring a nested hazard ptr&quot;);
 456 
 457   // The thread already has a hazard ptr (ThreadsList ref) so we need
 458   // to create a nested ThreadsListHandle with the current ThreadsList
 459   // since it might be different than our current hazard ptr. To remedy
 460   // the situation, the ThreadsList pointed to by the pre-existing
 461   // stable hazard ptr is reference counted before the hazard ptr may
 462   // be released and moved to a new ThreadsList. The old ThreadsList
 463   // is remembered in the ThreadsListHandle.
 464 
 465   ThreadsList* current_list = _previous-&gt;_list;
 466   if (EnableThreadSMRStatistics) {
 467     _thread-&gt;inc_nested_threads_hazard_ptr_cnt();
 468   }
 469   current_list-&gt;inc_nested_handle_cnt();
 470   _previous-&gt;_has_ref_count = true;  // promote SafeThreadsListPtr to be reference counted
 471   _thread-&gt;_threads_hazard_ptr = NULL;  // clear the hazard ptr so we can go through the fast path below
 472 
 473   if (EnableThreadSMRStatistics &amp;&amp; _thread-&gt;nested_threads_hazard_ptr_cnt() &gt; ThreadsSMRSupport::_nested_thread_list_max) {
 474     ThreadsSMRSupport::_nested_thread_list_max = _thread-&gt;nested_threads_hazard_ptr_cnt();
 475   }
 476 
 477   acquire_stable_list_fast_path();
 478 
 479   verify_hazard_ptr_scanned();
 480 
 481   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: SafeThreadsListPtr::acquire_stable_list: add nested list pointer to ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(_list));
 482 }
 483 
 484 // Release a stable ThreadsList.
 485 //
 486 void SafeThreadsListPtr::release_stable_list() {
 487   assert(_thread != NULL, &quot;sanity check&quot;);
 488   assert(_thread-&gt;_threads_list_ptr == this, &quot;sanity check&quot;);
 489   _thread-&gt;_threads_list_ptr = _previous;
 490 
 491   if (_has_ref_count) {
 492     // If a SafeThreadsListPtr has been promoted to use reference counting
 493     // due to nesting of ThreadsListHandles, then the reference count must be
 494     // decremented, at which point it may be freed. The forgotten value of
 495     // the list no longer matters at this point and should already be NULL.
 496     assert(_thread-&gt;get_threads_hazard_ptr() == NULL, &quot;sanity check&quot;);
 497     if (EnableThreadSMRStatistics) {
 498       _thread-&gt;dec_nested_threads_hazard_ptr_cnt();
 499     }
 500     _list-&gt;dec_nested_handle_cnt();
 501 
 502     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: SafeThreadsListPtr::release_stable_list: delete nested list pointer to ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(_list));
 503   } else {
 504     // The normal case: a leaf ThreadsListHandle. This merely requires setting
 505     // the thread hazard ptr back to NULL.
 506     assert(_thread-&gt;get_threads_hazard_ptr() != NULL, &quot;sanity check&quot;);
 507     _thread-&gt;set_threads_hazard_ptr(NULL);
 508   }
 509 
 510   // After releasing the hazard ptr, other threads may go ahead and
 511   // free up some memory temporarily used by a ThreadsList snapshot.
 512 
 513   // We use double-check locking to reduce traffic on the system
 514   // wide Thread-SMR delete_lock.
 515   if (ThreadsSMRSupport::delete_notify()) {
 516     // An exiting thread might be waiting in smr_delete(); we need to
 517     // check with delete_lock to be sure.
 518     ThreadsSMRSupport::release_stable_list_wake_up(_has_ref_count);
 519   }
 520 }
 521 
 522 // Verify that the stable hazard ptr used to safely keep threads
 523 // alive is scanned by threads_do() which is a key piece of honoring
 524 // the Thread-SMR protocol.
 525 void SafeThreadsListPtr::verify_hazard_ptr_scanned() {
 526 #ifdef ASSERT
 527   assert(_list != NULL, &quot;_list must not be NULL&quot;);
 528 
 529   if (ThreadsSMRSupport::is_bootstrap_list(_list)) {
 530     // We are early in VM bootstrapping so nothing to do here.
 531     return;
 532   }
 533 
 534   if ( _thread == VM_Exit::shutdown_thread()) {
 535     // The shutdown thread has removed itself from the Threads
 536     // list and is safe to have a waiver from this check because
 537     // VM_Exit::_shutdown_thread is not set until after the VMThread
 538     // has started the final safepoint which holds the Threads_lock
 539     // for the remainder of the VM&#39;s life.
 540     return;
 541   }
 542 
 543   if (VMError::is_error_reported() &amp;&amp;
 544       VMError::get_first_error_tid() == os::current_thread_id()) {
 545     // If there is an error reported by this thread it may use ThreadsList even
 546     // if it&#39;s unsafe.
 547     return;
 548   }
 549 
 550   // The closure will attempt to verify that the calling thread can
 551   // be found by threads_do() on the specified ThreadsList. If it
 552   // is successful, then the specified ThreadsList was acquired as
 553   // a stable hazard ptr by the calling thread in a way that honored
 554   // the Thread-SMR protocol.
 555   //
 556   // If the calling thread cannot be found by threads_do() and if
 557   // it is not the shutdown thread, then the calling thread is not
 558   // honoring the Thread-SMR ptotocol. This means that the specified
 559   // ThreadsList is not a stable hazard ptr and can be freed by
 560   // another thread from the to-be-deleted list at any time.
 561   //
 562   VerifyHazardPtrThreadClosure cl(_thread);
 563   ThreadsSMRSupport::threads_do(&amp;cl, _list);
 564 
 565   // If the calling thread is not honoring the Thread-SMR protocol,
 566   // then we will either crash in threads_do() above because &#39;threads&#39;
 567   // was freed by another thread or we will fail the assert() below.
 568   // In either case, we won&#39;t get past this point with a badly placed
 569   // ThreadsListHandle.
 570 
 571   assert(cl.found(), &quot;Acquired a ThreadsList snapshot from a thread not recognized by the Thread-SMR protocol.&quot;);
 572 #endif
 573 }
 574 
 575 // &#39;entries + 1&#39; so we always have at least one entry.
 576 ThreadsList::ThreadsList(int entries) :
 577   _length(entries),
 578   _next_list(NULL),
 579   _threads(NEW_C_HEAP_ARRAY(JavaThread*, entries + 1, mtThread)),
 580   _nested_handle_cnt(0)
 581 {
 582   *(JavaThread**)(_threads + entries) = NULL;  // Make sure the extra entry is NULL.
 583 }
 584 
 585 ThreadsList::~ThreadsList() {
 586   FREE_C_HEAP_ARRAY(JavaThread*, _threads);
 587 }
 588 
 589 // Add a JavaThread to a ThreadsList. The returned ThreadsList is a
 590 // new copy of the specified ThreadsList with the specified JavaThread
 591 // appended to the end.
 592 ThreadsList *ThreadsList::add_thread(ThreadsList *list, JavaThread *java_thread) {
 593   const uint index = list-&gt;_length;
 594   const uint new_length = index + 1;
 595   const uint head_length = index;
 596   ThreadsList *const new_list = new ThreadsList(new_length);
 597 
 598   if (head_length &gt; 0) {
 599     Copy::disjoint_words((HeapWord*)list-&gt;_threads, (HeapWord*)new_list-&gt;_threads, head_length);
 600   }
 601   *(JavaThread**)(new_list-&gt;_threads + index) = java_thread;
 602 
 603   return new_list;
 604 }
 605 
 606 void ThreadsList::dec_nested_handle_cnt() {
 607   Atomic::dec(&amp;_nested_handle_cnt);
 608 }
 609 
 610 int ThreadsList::find_index_of_JavaThread(JavaThread *target) {
 611   if (target == NULL) {
 612     return -1;
 613   }
 614   for (uint i = 0; i &lt; length(); i++) {
 615     if (target == thread_at(i)) {
 616       return (int)i;
 617     }
 618   }
 619   return -1;
 620 }
 621 
 622 JavaThread* ThreadsList::find_JavaThread_from_java_tid(jlong java_tid) const {
 623   ThreadIdTable::lazy_initialize(this);
 624   JavaThread* thread = ThreadIdTable::find_thread_by_tid(java_tid);
 625   if (thread == NULL) {
 626     // If the thread is not found in the table find it
 627     // with a linear search and add to the table.
 628     for (uint i = 0; i &lt; length(); i++) {
 629       thread = thread_at(i);
 630       oop tobj = thread-&gt;threadObj();
 631       // Ignore the thread if it hasn&#39;t run yet, has exited
 632       // or is starting to exit.
 633       if (tobj != NULL &amp;&amp; java_tid == java_lang_Thread::thread_id(tobj)) {
 634         MutexLocker ml(Threads_lock);
 635         // Must be inside the lock to ensure that we don&#39;t add a thread to the table
 636         // that has just passed the removal point in ThreadsSMRSupport::remove_thread()
 637         if (!thread-&gt;is_exiting()) {
 638           ThreadIdTable::add_thread(java_tid, thread);
 639           return thread;
 640         }
 641       }
 642     }
 643   } else if (!thread-&gt;is_exiting()) {
 644     return thread;
 645   }
 646   return NULL;
 647 }
 648 
 649 void ThreadsList::inc_nested_handle_cnt() {
 650   Atomic::inc(&amp;_nested_handle_cnt);
 651 }
 652 
 653 bool ThreadsList::includes(const JavaThread * const p) const {
 654   if (p == NULL) {
 655     return false;
 656   }
 657   for (uint i = 0; i &lt; length(); i++) {
 658     if (thread_at(i) == p) {
 659       return true;
 660     }
 661   }
 662   return false;
 663 }
 664 
 665 // Remove a JavaThread from a ThreadsList. The returned ThreadsList is a
 666 // new copy of the specified ThreadsList with the specified JavaThread
 667 // removed.
 668 ThreadsList *ThreadsList::remove_thread(ThreadsList* list, JavaThread* java_thread) {
 669   assert(list-&gt;_length &gt; 0, &quot;sanity&quot;);
 670 
 671   uint i = (uint)list-&gt;find_index_of_JavaThread(java_thread);
 672   assert(i &lt; list-&gt;_length, &quot;did not find JavaThread on the list&quot;);
 673   const uint index = i;
 674   const uint new_length = list-&gt;_length - 1;
 675   const uint head_length = index;
 676   const uint tail_length = (new_length &gt;= index) ? (new_length - index) : 0;
 677   ThreadsList *const new_list = new ThreadsList(new_length);
 678 
 679   if (head_length &gt; 0) {
 680     Copy::disjoint_words((HeapWord*)list-&gt;_threads, (HeapWord*)new_list-&gt;_threads, head_length);
 681   }
 682   if (tail_length &gt; 0) {
 683     Copy::disjoint_words((HeapWord*)list-&gt;_threads + index + 1, (HeapWord*)new_list-&gt;_threads + index, tail_length);
 684   }
 685 
 686   return new_list;
 687 }
 688 
 689 ThreadsListHandle::ThreadsListHandle(Thread *self) : _list_ptr(self, /* acquire */ true) {
 690   assert(self == Thread::current(), &quot;sanity check&quot;);
 691   if (EnableThreadSMRStatistics) {
 692     _timer.start();
 693   }
 694 }
 695 
 696 ThreadsListHandle::~ThreadsListHandle() {
 697   if (EnableThreadSMRStatistics) {
 698     _timer.stop();
 699     uint millis = (uint)_timer.milliseconds();
 700     ThreadsSMRSupport::update_tlh_stats(millis);
 701   }
 702 }
 703 
 704 // Convert an internal thread reference to a JavaThread found on the
 705 // associated ThreadsList. This ThreadsListHandle &quot;protects&quot; the
 706 // returned JavaThread *.
 707 //
 708 // If thread_oop_p is not NULL, then the caller wants to use the oop
 709 // after this call so the oop is returned. On success, *jt_pp is set
 710 // to the converted JavaThread * and true is returned. On error,
 711 // returns false.
 712 //
 713 bool ThreadsListHandle::cv_internal_thread_to_JavaThread(jobject jthread,
 714                                                          JavaThread ** jt_pp,
 715                                                          oop * thread_oop_p) {
 716   assert(this-&gt;list() != NULL, &quot;must have a ThreadsList&quot;);
 717   assert(jt_pp != NULL, &quot;must have a return JavaThread pointer&quot;);
 718   // thread_oop_p is optional so no assert()
 719 
 720   // The JVM_* interfaces don&#39;t allow a NULL thread parameter; JVM/TI
 721   // allows a NULL thread parameter to signify &quot;current thread&quot; which
 722   // allows us to avoid calling cv_external_thread_to_JavaThread().
 723   // The JVM_* interfaces have no such leeway.
 724 
 725   oop thread_oop = JNIHandles::resolve_non_null(jthread);
 726   // Looks like an oop at this point.
 727   if (thread_oop_p != NULL) {
 728     // Return the oop to the caller; the caller may still want
 729     // the oop even if this function returns false.
 730     *thread_oop_p = thread_oop;
 731   }
 732 
 733   JavaThread *java_thread = java_lang_Thread::thread(thread_oop);
 734   if (java_thread == NULL) {
 735     // The java.lang.Thread does not contain a JavaThread * so it has
 736     // not yet run or it has died.
 737     return false;
 738   }
 739   // Looks like a live JavaThread at this point.
 740 
 741   if (java_thread != JavaThread::current()) {
 742     // jthread is not for the current JavaThread so have to verify
 743     // the JavaThread * against the ThreadsList.
 744     if (EnableThreadSMRExtraValidityChecks &amp;&amp; !includes(java_thread)) {
 745       // Not on the JavaThreads list so it is not alive.
 746       return false;
 747     }
 748   }
 749 
 750   // Return a live JavaThread that is &quot;protected&quot; by the
 751   // ThreadsListHandle in the caller.
 752   *jt_pp = java_thread;
 753   return true;
 754 }
 755 
 756 void ThreadsSMRSupport::add_thread(JavaThread *thread){
 757   ThreadsList *new_list = ThreadsList::add_thread(get_java_thread_list(), thread);
 758   if (EnableThreadSMRStatistics) {
 759     inc_java_thread_list_alloc_cnt();
 760     update_java_thread_list_max(new_list-&gt;length());
 761   }
 762   // Initial _java_thread_list will not generate a &quot;Threads::add&quot; mesg.
 763   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::add: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 764 
 765   ThreadsList *old_list = xchg_java_thread_list(new_list);
 766   free_list(old_list);
 767   if (ThreadIdTable::is_initialized()) {
 768     jlong tid = SharedRuntime::get_java_tid(thread);
 769     ThreadIdTable::add_thread(tid, thread);
 770   }
 771 }
 772 
 773 // set_delete_notify() and clear_delete_notify() are called
 774 // under the protection of the delete_lock, but we also use an
 775 // Atomic operation to ensure the memory update is seen earlier than
 776 // when the delete_lock is dropped.
 777 //
 778 void ThreadsSMRSupport::clear_delete_notify() {
 779   Atomic::dec(&amp;_delete_notify);
 780 }
 781 
 782 bool ThreadsSMRSupport::delete_notify() {
 783   // Use load_acquire() in order to see any updates to _delete_notify
 784   // earlier than when delete_lock is grabbed.
 785   return (Atomic::load_acquire(&amp;_delete_notify) != 0);
 786 }
 787 
 788 // Safely free a ThreadsList after a Threads::add() or Threads::remove().
 789 // The specified ThreadsList may not get deleted during this call if it
 790 // is still in-use (referenced by a hazard ptr). Other ThreadsLists
 791 // in the chain may get deleted by this call if they are no longer in-use.
 792 void ThreadsSMRSupport::free_list(ThreadsList* threads) {
 793   assert_locked_or_safepoint(Threads_lock);
 794 
 795   if (is_bootstrap_list(threads)) {
 796     // The bootstrap list cannot be freed and is empty so
 797     // it does not need to be scanned. Nothing to do here.
 798     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: bootstrap ThreadsList=&quot; INTPTR_FORMAT &quot; is no longer in use.&quot;, os::current_thread_id(), p2i(threads));
 799     return;
 800   }
 801 
 802   threads-&gt;set_next_list(_to_delete_list);
 803   _to_delete_list = threads;
 804   if (EnableThreadSMRStatistics) {
 805     _to_delete_list_cnt++;
 806     if (_to_delete_list_cnt &gt; _to_delete_list_max) {
 807       _to_delete_list_max = _to_delete_list_cnt;
 808     }
 809   }
 810 
 811   // Hash table size should be first power of two higher than twice the length of the ThreadsList
 812   int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
 813   hash_table_size = round_up_power_of_2(hash_table_size);
 814 
 815   // Gather a hash table of the current hazard ptrs:
 816   ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
 817   ScanHazardPtrGatherThreadsListClosure scan_cl(scan_table);
 818   threads_do(&amp;scan_cl);
 819   OrderAccess::acquire(); // Must order reads of hazard ptr before reads of
 820                           // nested reference counters
 821 
 822   // Walk through the linked list of pending freeable ThreadsLists
 823   // and free the ones that are not referenced from hazard ptrs.
 824   ThreadsList* current = _to_delete_list;
 825   ThreadsList* prev = NULL;
 826   ThreadsList* next = NULL;
 827   bool threads_is_freed = false;
 828   while (current != NULL) {
 829     next = current-&gt;next_list();
 830     if (!scan_table-&gt;has_entry((void*)current) &amp;&amp; current-&gt;_nested_handle_cnt == 0) {
 831       // This ThreadsList is not referenced by a hazard ptr.
 832       if (prev != NULL) {
 833         prev-&gt;set_next_list(next);
 834       }
 835       if (_to_delete_list == current) {
 836         _to_delete_list = next;
 837       }
 838 
 839       log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: threads=&quot; INTPTR_FORMAT &quot; is freed.&quot;, os::current_thread_id(), p2i(current));
 840       if (current == threads) threads_is_freed = true;
 841       delete current;
 842       if (EnableThreadSMRStatistics) {
 843         _java_thread_list_free_cnt++;
 844         _to_delete_list_cnt--;
 845       }
 846     } else {
 847       prev = current;
 848     }
 849     current = next;
 850   }
 851 
 852   if (!threads_is_freed) {
 853     // Only report &quot;is not freed&quot; on the original call to
 854     // free_list() for this ThreadsList.
 855     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: threads=&quot; INTPTR_FORMAT &quot; is not freed.&quot;, os::current_thread_id(), p2i(threads));
 856   }
 857 
 858   delete scan_table;
 859 }
 860 
 861 // Return true if the specified JavaThread is protected by a hazard
 862 // pointer (ThreadsList reference). Otherwise, returns false.
 863 //
 864 bool ThreadsSMRSupport::is_a_protected_JavaThread(JavaThread *thread) {
 865   assert_locked_or_safepoint(Threads_lock);
 866 
 867   // Hash table size should be first power of two higher than twice
 868   // the length of the Threads list.
 869   int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
 870   hash_table_size = round_up_power_of_2(hash_table_size);
 871 
 872   // Gather a hash table of the JavaThreads indirectly referenced by
 873   // hazard ptrs.
 874   ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
 875   ScanHazardPtrGatherProtectedThreadsClosure scan_cl(scan_table);
 876   threads_do(&amp;scan_cl);
 877   OrderAccess::acquire(); // Must order reads of hazard ptr before reads of
 878                           // nested reference counters
 879 
 880   // Walk through the linked list of pending freeable ThreadsLists
 881   // and include the ones that are currently in use by a nested
 882   // ThreadsListHandle in the search set.
 883   ThreadsList* current = _to_delete_list;
 884   while (current != NULL) {
 885     if (current-&gt;_nested_handle_cnt != 0) {
 886       // &#39;current&#39; is in use by a nested ThreadsListHandle so the hazard
 887       // ptr is protecting all the JavaThreads on that ThreadsList.
 888       AddThreadHazardPointerThreadClosure add_cl(scan_table);
 889       current-&gt;threads_do(&amp;add_cl);
 890     }
 891     current = current-&gt;next_list();
 892   }
 893 
 894   bool thread_is_protected = false;
 895   if (scan_table-&gt;has_entry((void*)thread)) {
 896     thread_is_protected = true;
 897   }
 898   delete scan_table;
 899   return thread_is_protected;
 900 }
 901 
 902 // Wake up portion of the release stable ThreadsList protocol;
 903 // uses the delete_lock().
 904 //
 905 void ThreadsSMRSupport::release_stable_list_wake_up(bool is_nested) {
 906   const char* log_str = is_nested ? &quot;nested hazard ptr&quot; : &quot;regular hazard ptr&quot;;
 907 
 908   // Note: delete_lock is held in smr_delete() for the entire
 909   // hazard ptr search so that we do not lose this notify() if
 910   // the exiting thread has to wait. That code path also holds
 911   // Threads_lock (which was grabbed before delete_lock) so that
 912   // threads_do() can be called. This means the system can&#39;t start a
 913   // safepoint which means this thread can&#39;t take too long to get to
 914   // a safepoint because of being blocked on delete_lock.
 915   //
 916   MonitorLocker ml(ThreadsSMRSupport::delete_lock(), Monitor::_no_safepoint_check_flag);
 917   if (ThreadsSMRSupport::delete_notify()) {
 918     // Notify any exiting JavaThreads that are waiting in smr_delete()
 919     // that we&#39;ve released a ThreadsList.
 920     ml.notify_all();
 921     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
 922   }
 923 }
 924 
 925 void ThreadsSMRSupport::remove_thread(JavaThread *thread) {
<a name="2" id="anc2"></a>


 926   if (ThreadIdTable::is_initialized()) {
 927     jlong tid = SharedRuntime::get_java_tid(thread);
 928     ThreadIdTable::remove_thread(tid);
 929   }
<a name="3" id="anc3"></a>
 930   ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
 931   if (EnableThreadSMRStatistics) {
 932     ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
 933     // This list is smaller so no need to check for a &quot;longest&quot; update.
 934   }
 935 
 936   // Final _java_thread_list will not generate a &quot;Threads::remove&quot; mesg.
 937   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::remove: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 938 
 939   ThreadsList *old_list = ThreadsSMRSupport::xchg_java_thread_list(new_list);
 940   ThreadsSMRSupport::free_list(old_list);
 941 }
 942 
 943 // See note for clear_delete_notify().
 944 //
 945 void ThreadsSMRSupport::set_delete_notify() {
 946   Atomic::inc(&amp;_delete_notify);
 947 }
 948 
 949 // Safely delete a JavaThread when it is no longer in use by a
 950 // ThreadsListHandle.
 951 //
 952 void ThreadsSMRSupport::smr_delete(JavaThread *thread) {
 953   elapsedTimer timer;
 954   if (EnableThreadSMRStatistics) {
 955     timer.start();
 956   }
 957 
 958   wait_until_not_protected(thread);
 959 
 960   delete thread;
 961   if (EnableThreadSMRStatistics) {
 962     timer.stop();
 963     uint millis = (uint)timer.milliseconds();
 964     ThreadsSMRSupport::inc_deleted_thread_cnt();
 965     ThreadsSMRSupport::add_deleted_thread_times(millis);
 966     ThreadsSMRSupport::update_deleted_thread_time_max(millis);
 967   }
 968 
 969   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread=&quot; INTPTR_FORMAT &quot; is deleted.&quot;, os::current_thread_id(), p2i(thread));
 970 }
 971 
 972 void ThreadsSMRSupport::wait_until_not_protected(JavaThread *thread) {
 973   assert(!Threads_lock-&gt;owned_by_self(), &quot;sanity&quot;);
 974 
 975   bool has_logged_once = false;
 976 
 977   while (true) {
 978     {
 979       // Will not make a safepoint check because this JavaThread
 980       // is not on the current ThreadsList.
 981       MutexLocker ml(Threads_lock);
 982       // Cannot use a MonitorLocker helper here because we have
 983       // to drop the Threads_lock first if we wait.
 984       ThreadsSMRSupport::delete_lock()-&gt;lock_without_safepoint_check();
 985       // Set the delete_notify flag after we grab delete_lock
 986       // and before we scan hazard ptrs because we&#39;re doing
 987       // double-check locking in release_stable_list().
 988       ThreadsSMRSupport::set_delete_notify();
 989 
 990       if (!is_a_protected_JavaThread(thread)) {
 991         // This is the common case.
 992         ThreadsSMRSupport::clear_delete_notify();
 993         ThreadsSMRSupport::delete_lock()-&gt;unlock();
<a name="4" id="anc4"></a>
 994         break;
 995       }
 996       if (!has_logged_once) {
 997         has_logged_once = true;
 998         log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::wait_until_not_protected: thread=&quot; INTPTR_FORMAT &quot; is not deleted.&quot;, os::current_thread_id(), p2i(thread));
 999         if (log_is_enabled(Debug, os, thread)) {
1000           ScanHazardPtrPrintMatchingThreadsClosure scan_cl(thread);
1001           threads_do(&amp;scan_cl);
1002           ThreadsList* current = _to_delete_list;
1003           while (current != NULL) {
1004             if (current-&gt;_nested_handle_cnt != 0 &amp;&amp; current-&gt;includes(thread)) {
1005               log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::wait_until_not_protected: found nested hazard pointer to thread=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(thread));
1006             }
1007             current = current-&gt;next_list();
1008           }
1009         }
1010       }
1011     } // We have to drop the Threads_lock to wait or delete the thread
1012 
1013     if (EnableThreadSMRStatistics) {
1014       _delete_lock_wait_cnt++;
1015       if (_delete_lock_wait_cnt &gt; _delete_lock_wait_max) {
1016         _delete_lock_wait_max = _delete_lock_wait_cnt;
1017       }
1018     }
1019     // Wait for a release_stable_list() call before we check again. No
1020     // safepoint check, no timeout, and not as suspend equivalent flag
1021     // because this JavaThread is not on the Threads list.
1022     ThreadsSMRSupport::delete_lock()-&gt;wait_without_safepoint_check();
1023     if (EnableThreadSMRStatistics) {
1024       _delete_lock_wait_cnt--;
1025     }
1026 
1027     ThreadsSMRSupport::clear_delete_notify();
1028     ThreadsSMRSupport::delete_lock()-&gt;unlock();
1029     // Retry the whole scenario.
1030   }
1031 }
1032 
1033 // Apply the closure to all threads in the system, with a snapshot of
1034 // all JavaThreads provided by the list parameter.
1035 void ThreadsSMRSupport::threads_do(ThreadClosure *tc, ThreadsList *list) {
1036   list-&gt;threads_do(tc);
1037   Threads::non_java_threads_do(tc);
1038 }
1039 
1040 // Apply the closure to all threads in the system.
1041 void ThreadsSMRSupport::threads_do(ThreadClosure *tc) {
1042   threads_do(tc, _java_thread_list);
1043 }
1044 
1045 
1046 // Debug, logging, and printing stuff at the end:
1047 
1048 // Print SMR info for a SafeThreadsListPtr to a given output stream.
1049 void SafeThreadsListPtr::print_on(outputStream* st) {
1050   if (this == _thread-&gt;_threads_list_ptr) {
1051     // The top level hazard ptr.
1052     st-&gt;print(&quot; _threads_hazard_ptr=&quot; INTPTR_FORMAT, p2i(_list));
1053   } else {
1054     // Nested hazard ptrs.
1055     st-&gt;print(&quot;, _nested_threads_hazard_ptr=&quot; INTPTR_FORMAT, p2i(_list));
1056   }
1057 }
1058 
1059 // Log Threads class SMR info.
1060 void ThreadsSMRSupport::log_statistics() {
1061   LogTarget(Info, thread, smr) log;
1062   if (log.is_enabled()) {
1063     LogStream out(log);
1064     print_info_on(&amp;out);
1065   }
1066 }
1067 
1068 // Print SMR info for a thread to a given output stream.
1069 void ThreadsSMRSupport::print_info_on(const Thread* thread, outputStream* st) {
1070   if (thread-&gt;_threads_hazard_ptr != NULL) {
1071     st-&gt;print(&quot; _threads_hazard_ptr=&quot; INTPTR_FORMAT, p2i(thread-&gt;_threads_hazard_ptr));
1072   }
1073   if (EnableThreadSMRStatistics &amp;&amp; thread-&gt;_threads_list_ptr != NULL) {
1074     // The count is only interesting if we have a _threads_list_ptr.
1075     st-&gt;print(&quot;, _nested_threads_hazard_ptr_cnt=%u&quot;, thread-&gt;_nested_threads_hazard_ptr_cnt);
1076   }
1077   if (SafepointSynchronize::is_at_safepoint() || Thread::current() == thread) {
1078     // It is only safe to walk the list if we&#39;re at a safepoint or the
1079     // calling thread is walking its own list.
1080     SafeThreadsListPtr* current = thread-&gt;_threads_list_ptr;
1081     if (current != NULL) {
1082       // Skip the top nesting level as it is always printed above.
1083       current = current-&gt;previous();
1084     }
1085     while (current != NULL) {
1086       current-&gt;print_on(st);
1087       current = current-&gt;previous();
1088     }
1089   }
1090 }
1091 
1092 // Print Threads class SMR info.
1093 void ThreadsSMRSupport::print_info_on(outputStream* st) {
1094   // Only grab the Threads_lock if we don&#39;t already own it and if we
1095   // are not reporting an error.
1096   // Note: Not grabbing the Threads_lock during error reporting is
1097   // dangerous because the data structures we want to print can be
1098   // freed concurrently. However, grabbing the Threads_lock during
1099   // error reporting can be equally dangerous since this thread might
1100   // block during error reporting or a nested error could leave the
1101   // Threads_lock held. The classic no win scenario.
1102   //
1103   MutexLocker ml((Threads_lock-&gt;owned_by_self() || VMError::is_error_reported()) ? NULL : Threads_lock);
1104 
1105   st-&gt;print_cr(&quot;Threads class SMR info:&quot;);
1106   st-&gt;print_cr(&quot;_java_thread_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1107                &quot;elements={&quot;, p2i(_java_thread_list),
1108                _java_thread_list-&gt;length());
1109   print_info_elements_on(st, _java_thread_list);
1110   st-&gt;print_cr(&quot;}&quot;);
1111   if (_to_delete_list != NULL) {
1112     st-&gt;print_cr(&quot;_to_delete_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1113                  &quot;elements={&quot;, p2i(_to_delete_list),
1114                  _to_delete_list-&gt;length());
1115     print_info_elements_on(st, _to_delete_list);
1116     st-&gt;print_cr(&quot;}&quot;);
1117     for (ThreadsList *t_list = _to_delete_list-&gt;next_list();
1118          t_list != NULL; t_list = t_list-&gt;next_list()) {
1119       st-&gt;print(&quot;next-&gt; &quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1120                 &quot;elements={&quot;, p2i(t_list), t_list-&gt;length());
1121       print_info_elements_on(st, t_list);
1122       st-&gt;print_cr(&quot;}&quot;);
1123     }
1124   }
1125   if (!EnableThreadSMRStatistics) {
1126     return;
1127   }
1128   st-&gt;print_cr(&quot;_java_thread_list_alloc_cnt=&quot; UINT64_FORMAT &quot;, &quot;
1129                &quot;_java_thread_list_free_cnt=&quot; UINT64_FORMAT &quot;, &quot;
1130                &quot;_java_thread_list_max=%u, &quot;
1131                &quot;_nested_thread_list_max=%u&quot;,
1132                _java_thread_list_alloc_cnt,
1133                _java_thread_list_free_cnt,
1134                _java_thread_list_max,
1135                _nested_thread_list_max);
1136   if (_tlh_cnt &gt; 0) {
1137     st-&gt;print_cr(&quot;_tlh_cnt=%u&quot;
1138                  &quot;, _tlh_times=%u&quot;
1139                  &quot;, avg_tlh_time=%0.2f&quot;
1140                  &quot;, _tlh_time_max=%u&quot;,
1141                  _tlh_cnt, _tlh_times,
1142                  ((double) _tlh_times / _tlh_cnt),
1143                  _tlh_time_max);
1144   }
1145   if (_deleted_thread_cnt &gt; 0) {
1146     st-&gt;print_cr(&quot;_deleted_thread_cnt=%u&quot;
1147                  &quot;, _deleted_thread_times=%u&quot;
1148                  &quot;, avg_deleted_thread_time=%0.2f&quot;
1149                  &quot;, _deleted_thread_time_max=%u&quot;,
1150                  _deleted_thread_cnt, _deleted_thread_times,
1151                  ((double) _deleted_thread_times / _deleted_thread_cnt),
1152                  _deleted_thread_time_max);
1153   }
1154   st-&gt;print_cr(&quot;_delete_lock_wait_cnt=%u, _delete_lock_wait_max=%u&quot;,
1155                _delete_lock_wait_cnt, _delete_lock_wait_max);
1156   st-&gt;print_cr(&quot;_to_delete_list_cnt=%u, _to_delete_list_max=%u&quot;,
1157                _to_delete_list_cnt, _to_delete_list_max);
1158 }
1159 
1160 // Print ThreadsList elements (4 per line).
1161 void ThreadsSMRSupport::print_info_elements_on(outputStream* st, ThreadsList* t_list) {
1162   uint cnt = 0;
1163   JavaThreadIterator jti(t_list);
1164   for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {
1165     st-&gt;print(INTPTR_FORMAT, p2i(jt));
1166     if (cnt &lt; t_list-&gt;length() - 1) {
1167       // Separate with comma or comma-space except for the last one.
1168       if (((cnt + 1) % 4) == 0) {
1169         // Four INTPTR_FORMAT fit on an 80 column line so end the
1170         // current line with just a comma.
1171         st-&gt;print_cr(&quot;,&quot;);
1172       } else {
1173         // Not the last one on the current line so use comma-space:
1174         st-&gt;print(&quot;, &quot;);
1175       }
1176     } else {
1177       // Last one so just end the current line.
1178       st-&gt;cr();
1179     }
1180     cnt++;
1181   }
1182 }
<a name="5" id="anc5"></a>











































<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
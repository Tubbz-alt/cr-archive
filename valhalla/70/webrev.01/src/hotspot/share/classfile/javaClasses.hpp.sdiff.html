<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.
<span class="line-removed">  36 //</span>
<span class="line-removed">  37 // All dependencies on layout of actual Java classes should be kept here.</span>
<span class="line-removed">  38 // If the layout of any of the classes above changes the offsets must be adjusted.</span>
<span class="line-removed">  39 //</span>
<span class="line-removed">  40 // For most classes we hardwire the offsets for performance reasons. In certain</span>
<span class="line-removed">  41 // cases (e.g. java.security.AccessControlContext) we compute the offsets at</span>
<span class="line-removed">  42 // startup since the layout here differs between JDK1.2 and JDK1.3.</span>
<span class="line-removed">  43 //</span>
<span class="line-removed">  44 // Note that fields (static and non-static) are arranged with oops before non-oops</span>
<span class="line-removed">  45 // on a per class basis. The offsets below have to reflect this ordering.</span>
<span class="line-removed">  46 //</span>
<span class="line-removed">  47 // When editing the layouts please update the check_offset verification code</span>
<span class="line-removed">  48 // correspondingly. The names in the enums must be identical to the actual field</span>
<span class="line-removed">  49 // names in order for the verification code to work.</span>
  50 
  51 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  52   f(java_lang_Class) \
  53   f(java_lang_String) \

  54   //end
  55 
  56 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  57   f(java_lang_System) \
  58   f(java_lang_ClassLoader) \
  59   f(java_lang_Throwable) \
  60   f(java_lang_Thread) \
  61   f(java_lang_ThreadGroup) \
  62   f(java_lang_AssertionStatusDirectives) \
  63   f(java_lang_ref_SoftReference) \
  64   f(java_lang_invoke_MethodHandle) \
  65   f(java_lang_invoke_DirectMethodHandle) \
  66   f(java_lang_invoke_MemberName) \
  67   f(java_lang_invoke_ResolvedMethodName) \
  68   f(java_lang_invoke_LambdaForm) \
  69   f(java_lang_invoke_MethodType) \
  70   f(java_lang_invoke_CallSite) \
  71   f(java_lang_invoke_ConstantCallSite) \
  72   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  73   f(java_security_AccessControlContext) \
  74   f(java_lang_reflect_AccessibleObject) \
  75   f(java_lang_reflect_Method) \
  76   f(java_lang_reflect_Constructor) \
  77   f(java_lang_reflect_Field) \
  78   f(java_lang_reflect_RecordComponent) \
  79   f(java_nio_Buffer) \
  80   f(reflect_ConstantPool) \
  81   f(reflect_UnsafeStaticFieldAccessorImpl) \
  82   f(java_lang_reflect_Parameter) \
  83   f(java_lang_Module) \
  84   f(java_lang_StackTraceElement) \
  85   f(java_lang_StackFrameInfo) \
  86   f(java_lang_LiveStackFrameInfo) \
  87   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  88   f(jdk_internal_misc_UnsafeConstants) \
  89   f(jdk_internal_vm_jni_SubElementSelector) \

  90   //end
  91 
  92 #define BASIC_JAVA_CLASSES_DO(f) \
  93         BASIC_JAVA_CLASSES_DO_PART1(f) \
  94         BASIC_JAVA_CLASSES_DO_PART2(f)
  95 
  96 // Interface to java.lang.Object objects
  97 
  98 class java_lang_Object : AllStatic {
  99  public:
 100   static void register_natives(TRAPS);
 101 };
 102 
 103 // Interface to java.lang.String objects
 104 
 105 class java_lang_String : AllStatic {
 106  private:
 107   static int value_offset;
 108   static int hash_offset;
 109   static int hashIsZero_offset;
</pre>
<hr />
<pre>
 522   static objArrayOop groups(oop java_thread_group);
 523   // maxPriority in group
 524   static ThreadPriority maxPriority(oop java_thread_group);
 525   // Destroyed
 526   static bool is_destroyed(oop java_thread_group);
 527   // Daemon
 528   static bool is_daemon(oop java_thread_group);
 529   // Debugging
 530   friend class JavaClasses;
 531 };
 532 
 533 
 534 
 535 // Interface to java.lang.Throwable objects
 536 
 537 class java_lang_Throwable: AllStatic {
 538   friend class BacktraceBuilder;
 539   friend class BacktraceIterator;
 540 
 541  private:
<span class="line-removed"> 542   // Offsets</span>
<span class="line-removed"> 543   enum {</span>
<span class="line-removed"> 544     hc_backtrace_offset     =  0,</span>
<span class="line-removed"> 545     hc_detailMessage_offset =  1,</span>
<span class="line-removed"> 546     hc_cause_offset         =  2,  // New since 1.4</span>
<span class="line-removed"> 547     hc_stackTrace_offset    =  3   // New since 1.4</span>
<span class="line-removed"> 548   };</span>
 549   // Trace constants
 550   enum {
 551     trace_methods_offset = 0,
 552     trace_bcis_offset    = 1,
 553     trace_mirrors_offset = 2,
 554     trace_names_offset   = 3,
 555     trace_next_offset    = 4,
 556     trace_hidden_offset  = 5,
 557     trace_size           = 6,
 558     trace_chunk_size     = 32
 559   };
 560 
 561   static int backtrace_offset;
 562   static int detailMessage_offset;
 563   static int stackTrace_offset;
 564   static int depth_offset;
 565   static int static_unassigned_stacktrace_offset;
 566 
 567   // StackTrace (programmatic access, new since 1.4)
 568   static void clear_stacktrace(oop throwable);
</pre>
<hr />
<pre>
 879   }
 880 
 881   // Debugging
 882   friend class JavaClasses;
 883 };
 884 
 885 // Interface to java.lang primitive type boxing objects:
 886 //  - java.lang.Boolean
 887 //  - java.lang.Character
 888 //  - java.lang.Float
 889 //  - java.lang.Double
 890 //  - java.lang.Byte
 891 //  - java.lang.Short
 892 //  - java.lang.Integer
 893 //  - java.lang.Long
 894 
 895 // This could be separated out into 8 individual classes.
 896 
 897 class java_lang_boxing_object: AllStatic {
 898  private:
<span class="line-removed"> 899   enum {</span>
<span class="line-removed"> 900    hc_value_offset = 0</span>
<span class="line-removed"> 901   };</span>
 902   static int value_offset;
 903   static int long_value_offset;
 904 
 905   static oop initialize_and_allocate(BasicType type, TRAPS);
 906  public:
 907   // Allocation. Returns a boxed value, or NULL for invalid type.
 908   static oop create(BasicType type, jvalue* value, TRAPS);
 909   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 910   static BasicType get_value(oop box, jvalue* value);
 911   static BasicType set_value(oop box, jvalue* value);
 912   static BasicType basic_type(oop box);
 913   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 914   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 915   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 916   static void print(BasicType type, jvalue* value, outputStream* st);
 917 
 918   static int value_offset_in_bytes(BasicType type) {
 919     return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :
 920                                                     value_offset;
 921   }
 922 



 923   // Debugging
 924   friend class JavaClasses;
 925 };
 926 
 927 
 928 
 929 // Interface to java.lang.ref.Reference objects
 930 
 931 class java_lang_ref_Reference: AllStatic {
<span class="line-modified"> 932  public:</span>
<span class="line-removed"> 933   enum {</span>
<span class="line-removed"> 934    hc_referent_offset   = 0,</span>
<span class="line-removed"> 935    hc_queue_offset      = 1,</span>
<span class="line-removed"> 936    hc_next_offset       = 2,</span>
<span class="line-removed"> 937    hc_discovered_offset = 3  // Is not last, see SoftRefs.</span>
<span class="line-removed"> 938   };</span>
 939 

 940   static int referent_offset;
 941   static int queue_offset;
 942   static int next_offset;
 943   static int discovered_offset;
 944 
 945   // Accessors
 946   static inline oop referent(oop ref);
 947   static inline void set_referent(oop ref, oop value);
 948   static inline void set_referent_raw(oop ref, oop value);
 949   static inline HeapWord* referent_addr_raw(oop ref);
 950   static inline oop next(oop ref);
 951   static inline void set_next(oop ref, oop value);
 952   static inline void set_next_raw(oop ref, oop value);
 953   static inline HeapWord* next_addr_raw(oop ref);
 954   static inline oop discovered(oop ref);
 955   static inline void set_discovered(oop ref, oop value);
 956   static inline void set_discovered_raw(oop ref, oop value);
 957   static inline HeapWord* discovered_addr_raw(oop ref);
 958   static inline oop queue(oop ref);
 959   static inline void set_queue(oop ref, oop value);
 960   static bool is_referent_field(oop obj, ptrdiff_t offset);
 961   static inline bool is_final(oop ref);
 962   static inline bool is_phantom(oop ref);



 963 };
 964 
 965 
 966 // Interface to java.lang.ref.SoftReference objects
 967 
 968 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 969  public:
 970   static int timestamp_offset;
 971   static int static_clock_offset;
 972 
 973   // Accessors
 974   static jlong timestamp(oop ref);
 975 
 976   // Accessors for statics
 977   static jlong clock();
 978   static void set_clock(jlong value);
 979 
 980   static void compute_offsets();
 981   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 982 };
</pre>
<hr />
<pre>
1748   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1749   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1750   MODULE_INJECTED_FIELDS(macro)
1751 
1752 // Interface to hard-coded offset checking
1753 
1754 class JavaClasses : AllStatic {
1755  private:
1756 
1757   static InjectedField _injected_fields[];
1758 
1759   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1760  public:
1761   enum InjectedFieldID {
1762     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1763     MAX_enum
1764   };
1765 
1766   static int compute_injected_offset(InjectedFieldID id);
1767 
<span class="line-removed">1768   static void compute_hard_coded_offsets();</span>
1769   static void compute_offsets();
1770   static void check_offsets() PRODUCT_RETURN;
1771   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1772   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1773   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1774 };
1775 
1776 #undef DECLARE_INJECTED_FIELD_ENUM
1777 
1778 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
</pre>
</td>
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.














  36 
  37 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  38   f(java_lang_Class) \
  39   f(java_lang_String) \
<span class="line-added">  40   f(java_lang_ref_Reference) \</span>
  41   //end
  42 
  43 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  44   f(java_lang_System) \
  45   f(java_lang_ClassLoader) \
  46   f(java_lang_Throwable) \
  47   f(java_lang_Thread) \
  48   f(java_lang_ThreadGroup) \
  49   f(java_lang_AssertionStatusDirectives) \
  50   f(java_lang_ref_SoftReference) \
  51   f(java_lang_invoke_MethodHandle) \
  52   f(java_lang_invoke_DirectMethodHandle) \
  53   f(java_lang_invoke_MemberName) \
  54   f(java_lang_invoke_ResolvedMethodName) \
  55   f(java_lang_invoke_LambdaForm) \
  56   f(java_lang_invoke_MethodType) \
  57   f(java_lang_invoke_CallSite) \
  58   f(java_lang_invoke_ConstantCallSite) \
  59   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  60   f(java_security_AccessControlContext) \
  61   f(java_lang_reflect_AccessibleObject) \
  62   f(java_lang_reflect_Method) \
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  75   f(jdk_internal_misc_UnsafeConstants) \
  76   f(jdk_internal_vm_jni_SubElementSelector) \
<span class="line-added">  77   f(java_lang_boxing_object) \</span>
  78   //end
  79 
  80 #define BASIC_JAVA_CLASSES_DO(f) \
  81         BASIC_JAVA_CLASSES_DO_PART1(f) \
  82         BASIC_JAVA_CLASSES_DO_PART2(f)
  83 
  84 // Interface to java.lang.Object objects
  85 
  86 class java_lang_Object : AllStatic {
  87  public:
  88   static void register_natives(TRAPS);
  89 };
  90 
  91 // Interface to java.lang.String objects
  92 
  93 class java_lang_String : AllStatic {
  94  private:
  95   static int value_offset;
  96   static int hash_offset;
  97   static int hashIsZero_offset;
</pre>
<hr />
<pre>
 510   static objArrayOop groups(oop java_thread_group);
 511   // maxPriority in group
 512   static ThreadPriority maxPriority(oop java_thread_group);
 513   // Destroyed
 514   static bool is_destroyed(oop java_thread_group);
 515   // Daemon
 516   static bool is_daemon(oop java_thread_group);
 517   // Debugging
 518   friend class JavaClasses;
 519 };
 520 
 521 
 522 
 523 // Interface to java.lang.Throwable objects
 524 
 525 class java_lang_Throwable: AllStatic {
 526   friend class BacktraceBuilder;
 527   friend class BacktraceIterator;
 528 
 529  private:







 530   // Trace constants
 531   enum {
 532     trace_methods_offset = 0,
 533     trace_bcis_offset    = 1,
 534     trace_mirrors_offset = 2,
 535     trace_names_offset   = 3,
 536     trace_next_offset    = 4,
 537     trace_hidden_offset  = 5,
 538     trace_size           = 6,
 539     trace_chunk_size     = 32
 540   };
 541 
 542   static int backtrace_offset;
 543   static int detailMessage_offset;
 544   static int stackTrace_offset;
 545   static int depth_offset;
 546   static int static_unassigned_stacktrace_offset;
 547 
 548   // StackTrace (programmatic access, new since 1.4)
 549   static void clear_stacktrace(oop throwable);
</pre>
<hr />
<pre>
 860   }
 861 
 862   // Debugging
 863   friend class JavaClasses;
 864 };
 865 
 866 // Interface to java.lang primitive type boxing objects:
 867 //  - java.lang.Boolean
 868 //  - java.lang.Character
 869 //  - java.lang.Float
 870 //  - java.lang.Double
 871 //  - java.lang.Byte
 872 //  - java.lang.Short
 873 //  - java.lang.Integer
 874 //  - java.lang.Long
 875 
 876 // This could be separated out into 8 individual classes.
 877 
 878 class java_lang_boxing_object: AllStatic {
 879  private:



 880   static int value_offset;
 881   static int long_value_offset;
 882 
 883   static oop initialize_and_allocate(BasicType type, TRAPS);
 884  public:
 885   // Allocation. Returns a boxed value, or NULL for invalid type.
 886   static oop create(BasicType type, jvalue* value, TRAPS);
 887   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 888   static BasicType get_value(oop box, jvalue* value);
 889   static BasicType set_value(oop box, jvalue* value);
 890   static BasicType basic_type(oop box);
 891   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 892   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 893   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 894   static void print(BasicType type, jvalue* value, outputStream* st);
 895 
 896   static int value_offset_in_bytes(BasicType type) {
 897     return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :
 898                                                     value_offset;
 899   }
 900 
<span class="line-added"> 901   static void compute_offsets();</span>
<span class="line-added"> 902   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added"> 903 </span>
 904   // Debugging
 905   friend class JavaClasses;
 906 };
 907 
 908 
 909 
 910 // Interface to java.lang.ref.Reference objects
 911 
 912 class java_lang_ref_Reference: AllStatic {
<span class="line-modified"> 913   static bool _offsets_initialized;</span>






 914 
<span class="line-added"> 915  public:</span>
 916   static int referent_offset;
 917   static int queue_offset;
 918   static int next_offset;
 919   static int discovered_offset;
 920 
 921   // Accessors
 922   static inline oop referent(oop ref);
 923   static inline void set_referent(oop ref, oop value);
 924   static inline void set_referent_raw(oop ref, oop value);
 925   static inline HeapWord* referent_addr_raw(oop ref);
 926   static inline oop next(oop ref);
 927   static inline void set_next(oop ref, oop value);
 928   static inline void set_next_raw(oop ref, oop value);
 929   static inline HeapWord* next_addr_raw(oop ref);
 930   static inline oop discovered(oop ref);
 931   static inline void set_discovered(oop ref, oop value);
 932   static inline void set_discovered_raw(oop ref, oop value);
 933   static inline HeapWord* discovered_addr_raw(oop ref);
 934   static inline oop queue(oop ref);
 935   static inline void set_queue(oop ref, oop value);
 936   static bool is_referent_field(oop obj, ptrdiff_t offset);
 937   static inline bool is_final(oop ref);
 938   static inline bool is_phantom(oop ref);
<span class="line-added"> 939 </span>
<span class="line-added"> 940   static void compute_offsets();</span>
<span class="line-added"> 941   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
 942 };
 943 
 944 
 945 // Interface to java.lang.ref.SoftReference objects
 946 
 947 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 948  public:
 949   static int timestamp_offset;
 950   static int static_clock_offset;
 951 
 952   // Accessors
 953   static jlong timestamp(oop ref);
 954 
 955   // Accessors for statics
 956   static jlong clock();
 957   static void set_clock(jlong value);
 958 
 959   static void compute_offsets();
 960   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 961 };
</pre>
<hr />
<pre>
1727   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1728   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1729   MODULE_INJECTED_FIELDS(macro)
1730 
1731 // Interface to hard-coded offset checking
1732 
1733 class JavaClasses : AllStatic {
1734  private:
1735 
1736   static InjectedField _injected_fields[];
1737 
1738   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1739  public:
1740   enum InjectedFieldID {
1741     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1742     MAX_enum
1743   };
1744 
1745   static int compute_injected_offset(InjectedFieldID id);
1746 

1747   static void compute_offsets();
1748   static void check_offsets() PRODUCT_RETURN;
1749   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1750   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1751   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1752 };
1753 
1754 #undef DECLARE_INJECTED_FIELD_ENUM
1755 
1756 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classFileStream.hpp&quot;
  27 #include &quot;classfile/classListParser.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/systemDictionary.hpp&quot;
  36 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  37 #include &quot;classfile/verificationType.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;memory/allocation.hpp&quot;
  41 #include &quot;memory/archiveUtils.hpp&quot;
  42 #include &quot;memory/filemap.hpp&quot;
  43 #include &quot;memory/heapShared.hpp&quot;
  44 #include &quot;memory/metadataFactory.hpp&quot;
  45 #include &quot;memory/metaspaceClosure.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;memory/dynamicArchive.hpp&quot;
  50 #include &quot;oops/instanceKlass.hpp&quot;
  51 #include &quot;oops/klass.inline.hpp&quot;
  52 #include &quot;oops/objArrayOop.inline.hpp&quot;
  53 #include &quot;oops/oop.inline.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/java.hpp&quot;
  57 #include &quot;runtime/javaCalls.hpp&quot;
  58 #include &quot;runtime/mutexLocker.hpp&quot;
  59 #include &quot;utilities/hashtable.inline.hpp&quot;
  60 #include &quot;utilities/resourceHash.hpp&quot;
  61 #include &quot;utilities/stringUtils.hpp&quot;
  62 
  63 
  64 objArrayOop SystemDictionaryShared::_shared_protection_domains  =  NULL;
  65 objArrayOop SystemDictionaryShared::_shared_jar_urls            =  NULL;
  66 objArrayOop SystemDictionaryShared::_shared_jar_manifests       =  NULL;
  67 DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)
  68 
  69 class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  70   bool                         _excluded;
  71 public:
  72   struct DTLoaderConstraint {
  73     Symbol* _name;
  74     char _loader_type1;
  75     char _loader_type2;
  76     DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {
  77       _name-&gt;increment_refcount();
  78     }
  79     DTLoaderConstraint() : _name(NULL), _loader_type1(&#39;0&#39;), _loader_type2(&#39;0&#39;) {}
  80     bool equals(const DTLoaderConstraint&amp; t) {
  81       return t._name == _name &amp;&amp;
  82              ((t._loader_type1 == _loader_type1 &amp;&amp; t._loader_type2 == _loader_type2) ||
  83               (t._loader_type2 == _loader_type1 &amp;&amp; t._loader_type1 == _loader_type2));
  84     }
  85   };
  86 
  87   struct DTVerifierConstraint {
  88     Symbol* _name;
  89     Symbol* _from_name;
  90     DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}
  91     DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {
  92       _name-&gt;increment_refcount();
  93       _from_name-&gt;increment_refcount();
  94     }
  95   };
  96 
  97   InstanceKlass*               _klass;
  98   bool                         _failed_verification;
  99   int                          _id;
 100   int                          _clsfile_size;
 101   int                          _clsfile_crc32;
 102   GrowableArray&lt;DTVerifierConstraint&gt;* _verifier_constraints;
 103   GrowableArray&lt;char&gt;*                 _verifier_constraint_flags;
 104   GrowableArray&lt;DTLoaderConstraint&gt;* _loader_constraints;
 105 
 106   DumpTimeSharedClassInfo() {
 107     _klass = NULL;
 108     _failed_verification = false;
 109     _id = -1;
 110     _clsfile_size = -1;
 111     _clsfile_crc32 = -1;
 112     _excluded = false;
 113     _verifier_constraints = NULL;
 114     _verifier_constraint_flags = NULL;
 115     _loader_constraints = NULL;
 116   }
 117 
 118   void add_verification_constraint(InstanceKlass* k, Symbol* name,
 119          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);
 120   void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);
 121 
 122   bool is_builtin() {
 123     return SystemDictionaryShared::is_builtin(_klass);
 124   }
 125 
 126   int num_verifier_constraints() {
 127     if (_verifier_constraint_flags != NULL) {
 128       return _verifier_constraint_flags-&gt;length();
 129     } else {
 130       return 0;
 131     }
 132   }
 133 
 134   int num_loader_constraints() {
 135     if (_loader_constraints != NULL) {
 136       return _loader_constraints-&gt;length();
 137     } else {
 138       return 0;
 139     }
 140   }
 141 
 142   void metaspace_pointers_do(MetaspaceClosure* it) {
 143     it-&gt;push(&amp;_klass);
 144     if (_verifier_constraints != NULL) {
 145       for (int i = 0; i &lt; _verifier_constraints-&gt;length(); i++) {
 146         DTVerifierConstraint* cons = _verifier_constraints-&gt;adr_at(i);
 147         it-&gt;push(&amp;cons-&gt;_name);
 148         it-&gt;push(&amp;cons-&gt;_from_name);
 149       }
 150     }
 151     if (_loader_constraints != NULL) {
 152       for (int i = 0; i &lt; _loader_constraints-&gt;length(); i++) {
 153         DTLoaderConstraint* lc = _loader_constraints-&gt;adr_at(i);
 154         it-&gt;push(&amp;lc-&gt;_name);
 155       }
 156     }
 157   }
 158 
 159   void set_excluded() {
 160     _excluded = true;
 161   }
 162 
 163   bool is_excluded() {
 164     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null
 165     return _excluded || _failed_verification || _klass == NULL;
 166   }
 167 
 168   void set_failed_verification() {
 169     _failed_verification = true;
 170   }
 171 
 172   bool failed_verification() {
 173     return _failed_verification;
 174   }
 175 };
 176 
 177 inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const&amp; k) {
 178   if (DumpSharedSpaces) {
 179     // Deterministic archive contents
 180     uintx delta = k-&gt;name() - MetaspaceShared::symbol_rs_base();
 181     return primitive_hash&lt;uintx&gt;(delta);
 182   } else {
 183     // Deterministic archive is not possible because classes can be loaded
 184     // in multiple threads.
 185     return primitive_hash&lt;InstanceKlass*&gt;(k);
 186   }
 187 }
 188 
 189 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 190   InstanceKlass*,
 191   DumpTimeSharedClassInfo,
 192   &amp;DumpTimeSharedClassTable_hash,
 193   primitive_equals&lt;InstanceKlass*&gt;,
 194   15889, // prime number
 195   ResourceObj::C_HEAP&gt;
 196 {
 197   int _builtin_count;
 198   int _unregistered_count;
 199 public:
 200   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
<a name="1" id="anc1"></a><span class="line-modified"> 201     DumpTimeSharedClassInfo* p = get(k);</span>
<span class="line-modified"> 202     if (p == NULL) {</span>

 203       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 204              &quot;no new classes can be loaded while dumping archive&quot;);
<a name="2" id="anc2"></a><span class="line-removed"> 205       put(k, DumpTimeSharedClassInfo());</span>
<span class="line-removed"> 206       p = get(k);</span>
<span class="line-removed"> 207       assert(p != NULL, &quot;sanity&quot;);</span>
 208       p-&gt;_klass = k;
<a name="3" id="anc3"></a>

 209     }
 210     return p;
 211   }
 212 
 213   class CountClassByCategory : StackObj {
 214     DumpTimeSharedClassTable* _table;
 215   public:
 216     CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}
 217     bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
 218       if (!info.is_excluded()) {
 219         if (info.is_builtin()) {
 220           ++ _table-&gt;_builtin_count;
 221         } else {
 222           ++ _table-&gt;_unregistered_count;
 223         }
 224       }
 225       return true; // keep on iterating
 226     }
 227   };
 228 
 229   void update_counts() {
 230     _builtin_count = 0;
 231     _unregistered_count = 0;
 232     CountClassByCategory counter(this);
 233     iterate(&amp;counter);
 234   }
 235 
 236   int count_of(bool is_builtin) const {
 237     if (is_builtin) {
 238       return _builtin_count;
 239     } else {
 240       return _unregistered_count;
 241     }
 242   }
 243 };
 244 
 245 class RunTimeSharedClassInfo {
 246 public:
 247   struct CrcInfo {
 248     int _clsfile_size;
 249     int _clsfile_crc32;
 250   };
 251 
 252   // This is different than  DumpTimeSharedClassInfo::DTVerifierConstraint. We use
 253   // u4 instead of Symbol* to save space on 64-bit CPU.
 254   struct RTVerifierConstraint {
 255     u4 _name;
 256     u4 _from_name;
 257     Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}
 258     Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }
 259   };
 260 
 261   struct RTLoaderConstraint {
 262     u4   _name;
 263     char _loader_type1;
 264     char _loader_type2;
 265     Symbol* constraint_name() {
 266       return (Symbol*)(SharedBaseAddress + _name);
 267     }
 268   };
 269 
 270   InstanceKlass* _klass;
 271   int _num_verifier_constraints;
 272   int _num_loader_constraints;
 273 
 274   // optional CrcInfo              _crc;  (only for UNREGISTERED classes)
 275   // optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]
 276   // optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]
 277   // optional char                 _verifier_constraint_flags[_num_verifier_constraints]
 278 
 279 private:
 280   static size_t header_size_size() {
 281     return sizeof(RunTimeSharedClassInfo);
 282   }
 283   static size_t crc_size(InstanceKlass* klass) {
 284     if (!SystemDictionaryShared::is_builtin(klass)) {
 285       return sizeof(CrcInfo);
 286     } else {
 287       return 0;
 288     }
 289   }
 290   static size_t verifier_constraints_size(int num_verifier_constraints) {
 291     return sizeof(RTVerifierConstraint) * num_verifier_constraints;
 292   }
 293   static size_t verifier_constraint_flags_size(int num_verifier_constraints) {
 294     return sizeof(char) * num_verifier_constraints;
 295   }
 296   static size_t loader_constraints_size(int num_loader_constraints) {
 297     return sizeof(RTLoaderConstraint) * num_loader_constraints;
 298   }
 299 
 300 public:
 301   static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {
 302     return header_size_size() +
 303            crc_size(klass) +
 304            loader_constraints_size(num_loader_constraints) +
 305            verifier_constraints_size(num_verifier_constraints) +
 306            verifier_constraint_flags_size(num_verifier_constraints);
 307   }
 308 
 309 private:
 310   size_t crc_offset() const {
 311     return header_size_size();
 312   }
 313 
 314   size_t loader_constraints_offset() const  {
 315     return crc_offset() + crc_size(_klass);
 316   }
 317   size_t verifier_constraints_offset() const {
 318     return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);
 319   }
 320   size_t verifier_constraint_flags_offset() const {
 321     return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);
 322   }
 323 
 324   void check_verifier_constraint_offset(int i) const {
 325     assert(0 &lt;= i &amp;&amp; i &lt; _num_verifier_constraints, &quot;sanity&quot;);
 326   }
 327 
 328   void check_loader_constraint_offset(int i) const {
 329     assert(0 &lt;= i &amp;&amp; i &lt; _num_loader_constraints, &quot;sanity&quot;);
 330   }
 331 
 332 public:
 333   CrcInfo* crc() const {
 334     assert(crc_size(_klass) &gt; 0, &quot;must be&quot;);
 335     return (CrcInfo*)(address(this) + crc_offset());
 336   }
 337   RTVerifierConstraint* verifier_constraints() {
 338     assert(_num_verifier_constraints &gt; 0, &quot;sanity&quot;);
 339     return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());
 340   }
 341   RTVerifierConstraint* verifier_constraint_at(int i) {
 342     check_verifier_constraint_offset(i);
 343     return verifier_constraints() + i;
 344   }
 345 
 346   char* verifier_constraint_flags() {
 347     assert(_num_verifier_constraints &gt; 0, &quot;sanity&quot;);
 348     return (char*)(address(this) + verifier_constraint_flags_offset());
 349   }
 350 
 351   RTLoaderConstraint* loader_constraints() {
 352     assert(_num_loader_constraints &gt; 0, &quot;sanity&quot;);
 353     return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());
 354   }
 355 
 356   RTLoaderConstraint* loader_constraint_at(int i) {
 357     check_loader_constraint_offset(i);
 358     return loader_constraints() + i;
 359   }
 360 
 361   static u4 object_delta_u4(Symbol* sym) {
 362     if (DynamicDumpSharedSpaces) {
 363       sym = DynamicArchive::original_to_target(sym);
 364     }
 365     return MetaspaceShared::object_delta_u4(sym);
 366   }
 367 
 368   void init(DumpTimeSharedClassInfo&amp; info) {
 369     _klass = info._klass;
 370     if (!SystemDictionaryShared::is_builtin(_klass)) {
 371       CrcInfo* c = crc();
 372       c-&gt;_clsfile_size = info._clsfile_size;
 373       c-&gt;_clsfile_crc32 = info._clsfile_crc32;
 374     }
 375     _num_verifier_constraints = info.num_verifier_constraints();
 376     _num_loader_constraints   = info.num_loader_constraints();
 377     int i;
 378     if (_num_verifier_constraints &gt; 0) {
 379       RTVerifierConstraint* vf_constraints = verifier_constraints();
 380       char* flags = verifier_constraint_flags();
 381       for (i = 0; i &lt; _num_verifier_constraints; i++) {
 382         vf_constraints[i]._name      = object_delta_u4(info._verifier_constraints-&gt;at(i)._name);
 383         vf_constraints[i]._from_name = object_delta_u4(info._verifier_constraints-&gt;at(i)._from_name);
 384       }
 385       for (i = 0; i &lt; _num_verifier_constraints; i++) {
 386         flags[i] = info._verifier_constraint_flags-&gt;at(i);
 387       }
 388     }
 389 
 390     if (_num_loader_constraints &gt; 0) {
 391       RTLoaderConstraint* ld_constraints = loader_constraints();
 392       for (i = 0; i &lt; _num_loader_constraints; i++) {
 393         ld_constraints[i]._name = object_delta_u4(info._loader_constraints-&gt;at(i)._name);
 394         ld_constraints[i]._loader_type1 = info._loader_constraints-&gt;at(i)._loader_type1;
 395         ld_constraints[i]._loader_type2 = info._loader_constraints-&gt;at(i)._loader_type2;
 396       }
 397     }
 398     if (DynamicDumpSharedSpaces) {
 399       _klass = DynamicArchive::original_to_target(info._klass);
 400     }
 401     ArchivePtrMarker::mark_pointer(&amp;_klass);
 402   }
 403 
 404   bool matches(int clsfile_size, int clsfile_crc32) const {
 405     return crc()-&gt;_clsfile_size  == clsfile_size &amp;&amp;
 406            crc()-&gt;_clsfile_crc32 == clsfile_crc32;
 407   }
 408 
 409   char verifier_constraint_flag(int i) {
 410     check_verifier_constraint_offset(i);
 411     return verifier_constraint_flags()[i];
 412   }
 413 
 414 private:
 415   // ArchiveCompactor::allocate() has reserved a pointer immediately before
 416   // archived InstanceKlasses. We can use this slot to do a quick
 417   // lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo* without
 418   // building a new hashtable.
 419   //
 420   //  info_pointer_addr(klass) --&gt; 0x0100   RunTimeSharedClassInfo*
 421   //  InstanceKlass* klass     --&gt; 0x0108   &lt;C++ vtbl&gt;
 422   //                               0x0110   fields from Klass ...
 423   static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {
 424     return &amp;((RunTimeSharedClassInfo**)klass)[-1];
 425   }
 426 
 427 public:
 428   static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {
 429     return *info_pointer_addr(klass);
 430   }
 431   static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {
 432     if (DynamicDumpSharedSpaces) {
 433       klass = DynamicArchive::original_to_buffer(klass);
 434       *info_pointer_addr(klass) = DynamicArchive::buffer_to_target(record);
 435     } else {
 436       *info_pointer_addr(klass) = record;
 437     }
 438 
 439     ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));
 440   }
 441 
 442   // Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS
 443   static inline bool EQUALS(
 444        const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {
 445     return (value-&gt;_klass-&gt;name() == key);
 446   }
 447 };
 448 
 449 class RunTimeSharedDictionary : public OffsetCompactHashtable&lt;
 450   Symbol*,
 451   const RunTimeSharedClassInfo*,
 452   RunTimeSharedClassInfo::EQUALS&gt; {};
 453 
 454 static DumpTimeSharedClassTable* _dumptime_table = NULL;
 455 // SystemDictionaries in the base layer static archive
 456 static RunTimeSharedDictionary _builtin_dictionary;
 457 static RunTimeSharedDictionary _unregistered_dictionary;
 458 // SystemDictionaries in the top layer dynamic archive
 459 static RunTimeSharedDictionary _dynamic_builtin_dictionary;
 460 static RunTimeSharedDictionary _dynamic_unregistered_dictionary;
 461 
 462 oop SystemDictionaryShared::shared_protection_domain(int index) {
 463   return _shared_protection_domains-&gt;obj_at(index);
 464 }
 465 
 466 oop SystemDictionaryShared::shared_jar_url(int index) {
 467   return _shared_jar_urls-&gt;obj_at(index);
 468 }
 469 
 470 oop SystemDictionaryShared::shared_jar_manifest(int index) {
 471   return _shared_jar_manifests-&gt;obj_at(index);
 472 }
 473 
 474 Handle SystemDictionaryShared::get_shared_jar_manifest(int shared_path_index, TRAPS) {
 475   Handle manifest ;
 476   if (shared_jar_manifest(shared_path_index) == NULL) {
 477     SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);
 478     long size = ent-&gt;manifest_size();
 479     if (size &lt;= 0) {
 480       return Handle();
 481     }
 482 
 483     // ByteArrayInputStream bais = new ByteArrayInputStream(buf);
 484     const char* src = ent-&gt;manifest();
 485     assert(src != NULL, &quot;No Manifest data&quot;);
 486     typeArrayOop buf = oopFactory::new_byteArray(size, CHECK_NH);
 487     typeArrayHandle bufhandle(THREAD, buf);
 488     ArrayAccess&lt;&gt;::arraycopy_from_native(reinterpret_cast&lt;const jbyte*&gt;(src),
 489                                          buf, typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), size);
 490 
 491     Handle bais = JavaCalls::construct_new_instance(SystemDictionary::ByteArrayInputStream_klass(),
 492                       vmSymbols::byte_array_void_signature(),
 493                       bufhandle, CHECK_NH);
 494 
 495     // manifest = new Manifest(bais)
 496     manifest = JavaCalls::construct_new_instance(SystemDictionary::Jar_Manifest_klass(),
 497                       vmSymbols::input_stream_void_signature(),
 498                       bais, CHECK_NH);
 499     atomic_set_shared_jar_manifest(shared_path_index, manifest());
 500   }
 501 
 502   manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));
 503   assert(manifest.not_null(), &quot;sanity&quot;);
 504   return manifest;
 505 }
 506 
 507 Handle SystemDictionaryShared::get_shared_jar_url(int shared_path_index, TRAPS) {
 508   Handle url_h;
 509   if (shared_jar_url(shared_path_index) == NULL) {
 510     JavaValue result(T_OBJECT);
 511     const char* path = FileMapInfo::shared_path_name(shared_path_index);
 512     Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));
 513     Klass* classLoaders_klass =
 514         SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 515     JavaCalls::call_static(&amp;result, classLoaders_klass,
 516                            vmSymbols::toFileURL_name(),
 517                            vmSymbols::toFileURL_signature(),
 518                            path_string, CHECK_(url_h));
 519 
 520     atomic_set_shared_jar_url(shared_path_index, (oop)result.get_jobject());
 521   }
 522 
 523   url_h = Handle(THREAD, shared_jar_url(shared_path_index));
 524   assert(url_h.not_null(), &quot;sanity&quot;);
 525   return url_h;
 526 }
 527 
 528 Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {
 529   ResourceMark rm(THREAD);
 530   Handle pkgname_string;
 531   Symbol* pkg = ClassLoader::package_from_class_name(class_name);
 532   if (pkg != NULL) { // Package prefix found
 533     const char* pkgname = pkg-&gt;as_klass_external_name();
 534     pkgname_string = java_lang_String::create_from_str(pkgname,
 535                                                        CHECK_(pkgname_string));
 536   }
 537   return pkgname_string;
 538 }
 539 
 540 // Define Package for shared app classes from JAR file and also checks for
 541 // package sealing (all done in Java code)
 542 // See http://docs.oracle.com/javase/tutorial/deployment/jar/sealman.html
 543 void SystemDictionaryShared::define_shared_package(Symbol*  class_name,
 544                                                    Handle class_loader,
 545                                                    Handle manifest,
 546                                                    Handle url,
 547                                                    TRAPS) {
 548   assert(SystemDictionary::is_system_class_loader(class_loader()), &quot;unexpected class loader&quot;);
 549   // get_package_name() returns a NULL handle if the class is in unnamed package
 550   Handle pkgname_string = get_package_name(class_name, CHECK);
 551   if (pkgname_string.not_null()) {
 552     Klass* app_classLoader_klass = SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();
 553     JavaValue result(T_OBJECT);
 554     JavaCallArguments args(3);
 555     args.set_receiver(class_loader);
 556     args.push_oop(pkgname_string);
 557     args.push_oop(manifest);
 558     args.push_oop(url);
 559     JavaCalls::call_virtual(&amp;result, app_classLoader_klass,
 560                             vmSymbols::defineOrCheckPackage_name(),
 561                             vmSymbols::defineOrCheckPackage_signature(),
 562                             &amp;args,
 563                             CHECK);
 564   }
 565 }
 566 
 567 // Get the ProtectionDomain associated with the CodeSource from the classloader.
 568 Handle SystemDictionaryShared::get_protection_domain_from_classloader(Handle class_loader,
 569                                                                       Handle url, TRAPS) {
 570   // CodeSource cs = new CodeSource(url, null);
 571   Handle cs = JavaCalls::construct_new_instance(SystemDictionary::CodeSource_klass(),
 572                   vmSymbols::url_code_signer_array_void_signature(),
 573                   url, Handle(), CHECK_NH);
 574 
 575   // protection_domain = SecureClassLoader.getProtectionDomain(cs);
 576   Klass* secureClassLoader_klass = SystemDictionary::SecureClassLoader_klass();
 577   JavaValue obj_result(T_OBJECT);
 578   JavaCalls::call_virtual(&amp;obj_result, class_loader, secureClassLoader_klass,
 579                           vmSymbols::getProtectionDomain_name(),
 580                           vmSymbols::getProtectionDomain_signature(),
 581                           cs, CHECK_NH);
 582   return Handle(THREAD, (oop)obj_result.get_jobject());
 583 }
 584 
 585 // Returns the ProtectionDomain associated with the JAR file identified by the url.
 586 Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,
 587                                                             int shared_path_index,
 588                                                             Handle url,
 589                                                             TRAPS) {
 590   Handle protection_domain;
 591   if (shared_protection_domain(shared_path_index) == NULL) {
 592     Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);
 593     atomic_set_shared_protection_domain(shared_path_index, pd());
 594   }
 595 
 596   // Acquire from the cache because if another thread beats the current one to
 597   // set the shared protection_domain and the atomic_set fails, the current thread
 598   // needs to get the updated protection_domain from the cache.
 599   protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));
 600   assert(protection_domain.not_null(), &quot;sanity&quot;);
 601   return protection_domain;
 602 }
 603 
 604 // Returns the ProtectionDomain associated with the moduleEntry.
 605 Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,
 606                                                             ModuleEntry* mod, TRAPS) {
 607   ClassLoaderData *loader_data = mod-&gt;loader_data();
 608   if (mod-&gt;shared_protection_domain() == NULL) {
 609     Symbol* location = mod-&gt;location();
 610     if (location != NULL) {
 611       Handle location_string = java_lang_String::create_from_symbol(
 612                                      location, CHECK_NH);
 613       Handle url;
 614       JavaValue result(T_OBJECT);
 615       if (location-&gt;starts_with(&quot;jrt:/&quot;)) {
 616         url = JavaCalls::construct_new_instance(SystemDictionary::URL_klass(),
 617                                                 vmSymbols::string_void_signature(),
 618                                                 location_string, CHECK_NH);
 619       } else {
 620         Klass* classLoaders_klass =
 621           SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 622         JavaCalls::call_static(&amp;result, classLoaders_klass, vmSymbols::toFileURL_name(),
 623                                vmSymbols::toFileURL_signature(),
 624                                location_string, CHECK_NH);
 625         url = Handle(THREAD, (oop)result.get_jobject());
 626       }
 627 
 628       Handle pd = get_protection_domain_from_classloader(class_loader, url,
 629                                                          CHECK_NH);
 630       mod-&gt;set_shared_protection_domain(loader_data, pd);
 631     }
 632   }
 633 
 634   Handle protection_domain(THREAD, mod-&gt;shared_protection_domain());
 635   assert(protection_domain.not_null(), &quot;sanity&quot;);
 636   return protection_domain;
 637 }
 638 
 639 // Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with
 640 // the given InstanceKlass.
 641 // Returns the ProtectionDomain for the InstanceKlass.
 642 Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {
 643   Handle pd;
 644 
 645   if (ik != NULL) {
 646     int index = ik-&gt;shared_classpath_index();
 647     assert(index &gt;= 0, &quot;Sanity&quot;);
 648     SharedClassPathEntry* ent = FileMapInfo::shared_path(index);
 649     Symbol* class_name = ik-&gt;name();
 650 
 651     if (ent-&gt;is_modules_image()) {
 652       // For shared app/platform classes originated from the run-time image:
 653       //   The ProtectionDomains are cached in the corresponding ModuleEntries
 654       //   for fast access by the VM.
 655       // all packages from module image are already created during VM bootstrap in
 656       // Modules::define_module().
 657       assert(pkg_entry != NULL, &quot;archived class in module image cannot be from unnamed package&quot;);
 658       ModuleEntry* mod_entry = pkg_entry-&gt;module();
 659       pd = get_shared_protection_domain(class_loader, mod_entry, THREAD);
 660     } else {
 661       // For shared app/platform classes originated from JAR files on the class path:
 662       //   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length
 663       //   as the shared classpath table in the shared archive (see
 664       //   FileMap::_shared_path_table in filemap.hpp for details).
 665       //
 666       //   If a shared InstanceKlass k is loaded from the class path, let
 667       //
 668       //     index = k-&gt;shared_classpath_index():
 669       //
 670       //   FileMap::_shared_path_table[index] identifies the JAR file that contains k.
 671       //
 672       //   k&#39;s protection domain is:
 673       //
 674       //     ProtectionDomain pd = _shared_protection_domains[index];
 675       //
 676       //   and k&#39;s Package is initialized using
 677       //
 678       //     manifest = _shared_jar_manifests[index];
 679       //     url = _shared_jar_urls[index];
 680       //     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 681       //
 682       //   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by
 683       //   the corresponding SystemDictionaryShared::get_shared_xxx() function.
 684       Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));
 685       Handle url = get_shared_jar_url(index, CHECK_(pd));
 686       define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 687       pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));
 688     }
 689   }
 690   return pd;
 691 }
 692 
 693 bool SystemDictionaryShared::is_sharing_possible(ClassLoaderData* loader_data) {
 694   oop class_loader = loader_data-&gt;class_loader();
 695   return (class_loader == NULL ||
 696           SystemDictionary::is_system_class_loader(class_loader) ||
 697           SystemDictionary::is_platform_class_loader(class_loader));
 698 }
 699 
 700 // Currently AppCDS only archives classes from the run-time image, the
 701 // -Xbootclasspath/a path, the class path, and the module path.
 702 //
 703 // Check if a shared class can be loaded by the specific classloader. Following
 704 // are the &quot;visible&quot; archived classes for different classloaders.
 705 //
 706 // NULL classloader:
 707 //   - see SystemDictionary::is_shared_class_visible()
 708 // Platform classloader:
 709 //   - Module class from runtime image. ModuleEntry must be defined in the
 710 //     classloader.
 711 // App classloader:
 712 //   - Module Class from runtime image and module path. ModuleEntry must be defined in the
 713 //     classloader.
 714 //   - Class from -cp. The class must have no PackageEntry defined in any of the
 715 //     boot/platform/app classloader, or must be in the unnamed module defined in the
 716 //     AppClassLoader.
 717 bool SystemDictionaryShared::is_shared_class_visible_for_classloader(
 718                                                      InstanceKlass* ik,
 719                                                      Handle class_loader,
 720                                                      Symbol* pkg_name,
 721                                                      PackageEntry* pkg_entry,
 722                                                      ModuleEntry* mod_entry,
 723                                                      TRAPS) {
 724   assert(class_loader.not_null(), &quot;Class loader should not be NULL&quot;);
 725   assert(Universe::is_module_initialized(), &quot;Module system is not initialized&quot;);
 726   ResourceMark rm(THREAD);
 727 
 728   int path_index = ik-&gt;shared_classpath_index();
 729   SharedClassPathEntry* ent =
 730             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
 731 
 732   if (SystemDictionary::is_platform_class_loader(class_loader())) {
 733     assert(ent != NULL, &quot;shared class for PlatformClassLoader should have valid SharedClassPathEntry&quot;);
 734     // The PlatformClassLoader can only load archived class originated from the
 735     // run-time image. The class&#39; PackageEntry/ModuleEntry must be
 736     // defined by the PlatformClassLoader.
 737     if (mod_entry != NULL) {
 738       // PackageEntry/ModuleEntry is found in the classloader. Check if the
 739       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
 740       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
 741         return true; // Module class from the runtime image
 742       }
 743     }
 744   } else if (SystemDictionary::is_system_class_loader(class_loader())) {
 745     assert(ent != NULL, &quot;shared class for system loader should have valid SharedClassPathEntry&quot;);
 746     if (pkg_name == NULL) {
 747       // The archived class is in the unnamed package. Currently, the boot image
 748       // does not contain any class in the unnamed package.
 749       assert(!ent-&gt;is_modules_image(), &quot;Class in the unnamed package must be from the classpath&quot;);
 750       if (path_index &gt;= ClassLoaderExt::app_class_paths_start_index()) {
 751         assert(path_index &lt; ClassLoaderExt::app_module_paths_start_index(), &quot;invalid path_index&quot;);
 752         return true;
 753       }
 754     } else {
 755       // Check if this is from a PackageEntry/ModuleEntry defined in the AppClassloader.
 756       if (pkg_entry == NULL) {
 757         // It&#39;s not guaranteed that the class is from the classpath if the
 758         // PackageEntry cannot be found from the AppClassloader. Need to check
 759         // the boot and platform classloader as well.
 760         ClassLoaderData* platform_loader_data =
 761           ClassLoaderData::class_loader_data_or_null(SystemDictionary::java_platform_loader()); // can be NULL during bootstrap
 762         if ((platform_loader_data == NULL ||
 763              ClassLoader::get_package_entry(pkg_name, platform_loader_data) == NULL) &amp;&amp;
 764              ClassLoader::get_package_entry(pkg_name, ClassLoaderData::the_null_class_loader_data()) == NULL) {
 765           // The PackageEntry is not defined in any of the boot/platform/app classloaders.
 766           // The archived class must from -cp path and not from the runtime image.
 767           if (!ent-&gt;is_modules_image() &amp;&amp; path_index &gt;= ClassLoaderExt::app_class_paths_start_index() &amp;&amp;
 768                                           path_index &lt; ClassLoaderExt::app_module_paths_start_index()) {
 769             return true;
 770           }
 771         }
 772       } else if (mod_entry != NULL) {
 773         // The package/module is defined in the AppClassLoader. We support
 774         // archiving application module class from the runtime image or from
 775         // a named module from a module path.
 776         // Packages from the -cp path are in the unnamed_module.
 777         if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
 778           // shared module class from runtime image
 779           return true;
 780         } else if (pkg_entry-&gt;in_unnamed_module() &amp;&amp; path_index &gt;= ClassLoaderExt::app_class_paths_start_index() &amp;&amp;
 781             path_index &lt; ClassLoaderExt::app_module_paths_start_index()) {
 782           // shared class from -cp
 783           DEBUG_ONLY( \
 784             ClassLoaderData* loader_data = class_loader_data(class_loader); \
 785             assert(mod_entry == loader_data-&gt;unnamed_module(), &quot;the unnamed module is not defined in the classloader&quot;);)
 786           return true;
 787         } else {
 788           if(!pkg_entry-&gt;in_unnamed_module() &amp;&amp;
 789               (path_index &gt;= ClassLoaderExt::app_module_paths_start_index())&amp;&amp;
 790               (path_index &lt; FileMapInfo::get_number_of_shared_paths()) &amp;&amp;
 791               (strcmp(ent-&gt;name(), ClassLoader::skip_uri_protocol(mod_entry-&gt;location()-&gt;as_C_string())) == 0)) {
 792             // shared module class from module path
 793             return true;
 794           } else {
 795             assert(path_index &lt; FileMapInfo::get_number_of_shared_paths(), &quot;invalid path_index&quot;);
 796           }
 797         }
 798       }
 799     }
 800   } else {
 801     // TEMP: if a shared class can be found by a custom loader, consider it visible now.
 802     // FIXME: is this actually correct?
 803     return true;
 804   }
 805   return false;
 806 }
 807 
 808 bool SystemDictionaryShared::has_platform_or_app_classes() {
 809   if (FileMapInfo::current_info()-&gt;has_platform_or_app_classes()) {
 810     return true;
 811   }
 812   if (DynamicArchive::is_mapped() &amp;&amp;
 813       FileMapInfo::dynamic_info()-&gt;has_platform_or_app_classes()) {
 814     return true;
 815   }
 816   return false;
 817 }
 818 
 819 // The following stack shows how this code is reached:
 820 //
 821 //   [0] SystemDictionaryShared::find_or_load_shared_class()
 822 //   [1] JVM_FindLoadedClass
 823 //   [2] java.lang.ClassLoader.findLoadedClass0()
 824 //   [3] java.lang.ClassLoader.findLoadedClass()
 825 //   [4] jdk.internal.loader.BuiltinClassLoader.loadClassOrNull()
 826 //   [5] jdk.internal.loader.BuiltinClassLoader.loadClass()
 827 //   [6] jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(), or
 828 //       jdk.internal.loader.ClassLoaders$PlatformClassLoader.loadClass()
 829 //
 830 // AppCDS supports fast class loading for these 2 built-in class loaders:
 831 //    jdk.internal.loader.ClassLoaders$PlatformClassLoader
 832 //    jdk.internal.loader.ClassLoaders$AppClassLoader
 833 // with the following assumptions (based on the JDK core library source code):
 834 //
 835 // [a] these two loaders use the BuiltinClassLoader.loadClassOrNull() to
 836 //     load the named class.
 837 // [b] BuiltinClassLoader.loadClassOrNull() first calls findLoadedClass(name).
 838 // [c] At this point, if we can find the named class inside the
 839 //     shared_dictionary, we can perform further checks (see
 840 //     is_shared_class_visible_for_classloader() to ensure that this class
 841 //     was loaded by the same class loader during dump time.
 842 //
 843 // Given these assumptions, we intercept the findLoadedClass() call to invoke
 844 // SystemDictionaryShared::find_or_load_shared_class() to load the shared class from
 845 // the archive for the 2 built-in class loaders. This way,
 846 // we can improve start-up because we avoid decoding the classfile,
 847 // and avoid delegating to the parent loader.
 848 //
 849 // NOTE: there&#39;s a lot of assumption about the Java code. If any of that change, this
 850 // needs to be redesigned.
 851 
 852 InstanceKlass* SystemDictionaryShared::find_or_load_shared_class(
 853                  Symbol* name, Handle class_loader, TRAPS) {
 854   InstanceKlass* k = NULL;
 855   if (UseSharedSpaces) {
 856     if (!has_platform_or_app_classes()) {
 857       return NULL;
 858     }
 859 
 860     if (SystemDictionary::is_system_class_loader(class_loader()) ||
 861         SystemDictionary::is_platform_class_loader(class_loader())) {
 862       // Fix for 4474172; see evaluation for more details
 863       class_loader = Handle(
 864         THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 865       ClassLoaderData *loader_data = register_loader(class_loader);
 866       Dictionary* dictionary = loader_data-&gt;dictionary();
 867 
 868       unsigned int d_hash = dictionary-&gt;compute_hash(name);
 869 
 870       bool DoObjectLock = true;
 871       if (is_parallelCapable(class_loader)) {
 872         DoObjectLock = false;
 873       }
 874 
 875       // Make sure we are synchronized on the class loader before we proceed
 876       //
 877       // Note: currently, find_or_load_shared_class is called only from
 878       // JVM_FindLoadedClass and used for PlatformClassLoader and AppClassLoader,
 879       // which are parallel-capable loaders, so this lock is NOT taken.
 880       Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 881       check_loader_lock_contention(lockObject, THREAD);
 882       ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 883 
 884       {
 885         MutexLocker mu(THREAD, SystemDictionary_lock);
 886         InstanceKlass* check = find_class(d_hash, name, dictionary);
 887         if (check != NULL) {
 888           return check;
 889         }
 890       }
 891 
 892       k = load_shared_class_for_builtin_loader(name, class_loader, THREAD);
 893       if (k != NULL) {
 894         define_instance_class(k, CHECK_NULL);
 895       }
 896     }
 897   }
 898   return k;
 899 }
 900 
 901 PackageEntry* SystemDictionaryShared::get_package_entry_from_class_name(Handle class_loader, Symbol* class_name) {
 902   PackageEntry* pkg_entry = NULL;
 903   TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
 904   if (pkg_name != NULL) {
 905     pkg_entry = class_loader_data(class_loader)-&gt;packages()-&gt;lookup_only(pkg_name);
 906   }
 907   return pkg_entry;
 908 }
 909 
 910 InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(
 911                  Symbol* class_name, Handle class_loader, TRAPS) {
 912   assert(UseSharedSpaces, &quot;must be&quot;);
 913   InstanceKlass* ik = find_builtin_class(class_name);
 914 
 915   if (ik != NULL) {
 916     if ((ik-&gt;is_shared_app_class() &amp;&amp;
 917          SystemDictionary::is_system_class_loader(class_loader()))  ||
 918         (ik-&gt;is_shared_platform_class() &amp;&amp;
 919          SystemDictionary::is_platform_class_loader(class_loader()))) {
 920       PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, class_name);
 921       Handle protection_domain =
 922         SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);
 923       return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);
 924     }
 925   }
 926   return NULL;
 927 }
 928 
 929 void SystemDictionaryShared::oops_do(OopClosure* f) {
 930   f-&gt;do_oop((oop*)&amp;_shared_protection_domains);
 931   f-&gt;do_oop((oop*)&amp;_shared_jar_urls);
 932   f-&gt;do_oop((oop*)&amp;_shared_jar_manifests);
 933 }
 934 
 935 void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {
 936   if (_shared_protection_domains == NULL) {
 937     _shared_protection_domains = oopFactory::new_objArray(
 938         SystemDictionary::ProtectionDomain_klass(), size, CHECK);
 939   }
 940 }
 941 
 942 void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {
 943   if (_shared_jar_urls == NULL) {
 944     _shared_jar_urls = oopFactory::new_objArray(
 945         SystemDictionary::URL_klass(), size, CHECK);
 946   }
 947 }
 948 
 949 void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {
 950   if (_shared_jar_manifests == NULL) {
 951     _shared_jar_manifests = oopFactory::new_objArray(
 952         SystemDictionary::Jar_Manifest_klass(), size, CHECK);
 953   }
 954 }
 955 
 956 void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {
 957   allocate_shared_protection_domain_array(size, CHECK);
 958   allocate_shared_jar_url_array(size, CHECK);
 959   allocate_shared_jar_manifest_array(size, CHECK);
 960 }
 961 
 962 // This function is called for loading only UNREGISTERED classes
 963 InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,
 964                                                           Handle class_loader,
 965                                                           Handle protection_domain,
 966                                                           const ClassFileStream* cfs,
 967                                                           TRAPS) {
 968   if (!UseSharedSpaces) {
 969     return NULL;
 970   }
 971   if (class_name == NULL) {  // don&#39;t do this for hidden and unsafe anonymous classes
 972     return NULL;
 973   }
 974   if (class_loader.is_null() ||
 975       SystemDictionary::is_system_class_loader(class_loader()) ||
 976       SystemDictionary::is_platform_class_loader(class_loader())) {
 977     // Do nothing for the BUILTIN loaders.
 978     return NULL;
 979   }
 980 
 981   const RunTimeSharedClassInfo* record = find_record(&amp;_unregistered_dictionary, &amp;_dynamic_unregistered_dictionary, class_name);
 982   if (record == NULL) {
 983     return NULL;
 984   }
 985 
 986   int clsfile_size  = cfs-&gt;length();
 987   int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
 988 
 989   if (!record-&gt;matches(clsfile_size, clsfile_crc32)) {
 990     return NULL;
 991   }
 992 
 993   return acquire_class_for_current_thread(record-&gt;_klass, class_loader,
 994                                           protection_domain, cfs,
 995                                           THREAD);
 996 }
 997 
 998 InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(
 999                    InstanceKlass *ik,
1000                    Handle class_loader,
1001                    Handle protection_domain,
1002                    const ClassFileStream *cfs,
1003                    TRAPS) {
1004   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1005 
1006   {
1007     MutexLocker mu(THREAD, SharedDictionary_lock);
1008     if (ik-&gt;class_loader_data() != NULL) {
1009       //    ik is already loaded (by this loader or by a different loader)
1010       // or ik is being loaded by a different thread (by this loader or by a different loader)
1011       return NULL;
1012     }
1013 
1014     // No other thread has acquired this yet, so give it to *this thread*
1015     ik-&gt;set_class_loader_data(loader_data);
1016   }
1017 
1018   // No longer holding SharedDictionary_lock
1019   // No need to lock, as &lt;ik&gt; can be held only by a single thread.
1020   loader_data-&gt;add_class(ik);
1021 
1022   // Get the package entry.
1023   PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, ik-&gt;name());
1024 
1025   // Load and check super/interfaces, restore unsharable info
1026   InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,
1027                                                   cfs, pkg_entry, THREAD);
1028   if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {
1029     // TODO: clean up &lt;ik&gt; so it can be used again
1030     return NULL;
1031   }
1032 
1033   return shared_klass;
1034 }
1035 
1036 static ResourceHashtable&lt;
1037   Symbol*, bool,
1038   primitive_hash&lt;Symbol*&gt;,
1039   primitive_equals&lt;Symbol*&gt;,
1040   6661,                             // prime number
1041   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
1042 
1043 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
<a name="4" id="anc4"></a>
1044   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
<a name="5" id="anc5"></a><span class="line-removed">1045 </span>
1046   Symbol* name = k-&gt;name();
<a name="6" id="anc6"></a><span class="line-modified">1047   if (_loaded_unregistered_classes.get(name) != NULL) {</span>
<span class="line-modified">1048     // We don&#39;t allow duplicated unregistered classes of the same name.</span>
<span class="line-modified">1049     return false;</span>
<span class="line-removed">1050   } else {</span>
<span class="line-removed">1051     bool isnew = _loaded_unregistered_classes.put(name, true);</span>
<span class="line-removed">1052     assert(isnew, &quot;sanity&quot;);</span>
1053     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
1054     SystemDictionary::add_to_hierarchy(k, CHECK_false);
<a name="7" id="anc7"></a><span class="line-removed">1055     return true;</span>
1056   }
<a name="8" id="anc8"></a>
1057 }
1058 
1059 // This function is called to resolve the super/interfaces of shared classes for
1060 // non-built-in loaders. E.g., ChildClass in the below example
1061 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
1062 //
1063 // java/lang/Object id: 0
1064 // Interface   id: 2 super: 0 source: cust.jar
1065 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
1066 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
1067     Symbol* child_name, Symbol* class_name, Handle class_loader,
1068     Handle protection_domain, bool is_superclass, TRAPS) {
1069 
1070   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1071 
1072   ClassListParser* parser = ClassListParser::instance();
1073   if (parser == NULL) {
1074     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
1075     return NULL;
1076   }
1077   if (child_name-&gt;equals(parser-&gt;current_class_name())) {
1078     // When this function is called, all the numbered super and interface types
1079     // must have already been loaded. Hence this function is never recursively called.
1080     if (is_superclass) {
1081       return parser-&gt;lookup_super_for_current_class(class_name);
1082     } else {
1083       return parser-&gt;lookup_interface_for_current_class(class_name);
1084     }
1085   } else {
1086     // The VM is not trying to resolve a super type of parser-&gt;current_class_name().
1087     // Instead, it&#39;s resolving an error class (because parser-&gt;current_class_name() has
1088     // failed parsing or verification). Don&#39;t do anything here.
1089     return NULL;
1090   }
1091 }
1092 
1093 DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {
1094   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1095   if (_dumptime_table == NULL) {
1096     _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();
1097   }
1098   return _dumptime_table-&gt;find_or_allocate_info_for(k);
1099 }
1100 
1101 void SystemDictionaryShared::set_shared_class_misc_info(InstanceKlass* k, ClassFileStream* cfs) {
1102   Arguments::assert_is_dumping_archive();
1103   assert(!is_builtin(k), &quot;must be unregistered class&quot;);
1104   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1105   info-&gt;_clsfile_size  = cfs-&gt;length();
1106   info-&gt;_clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
1107 }
1108 
1109 void SystemDictionaryShared::init_dumptime_info(InstanceKlass* k) {
1110   (void)find_or_allocate_info_for(k);
1111 }
1112 
1113 void SystemDictionaryShared::remove_dumptime_info(InstanceKlass* k) {
1114   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1115   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(k);
1116   if (p == NULL) {
1117     return;
1118   }
1119   if (p-&gt;_verifier_constraints != NULL) {
1120     for (int i = 0; i &lt; p-&gt;_verifier_constraints-&gt;length(); i++) {
1121       DumpTimeSharedClassInfo::DTVerifierConstraint constraint = p-&gt;_verifier_constraints-&gt;at(i);
1122       if (constraint._name != NULL ) {
1123         constraint._name-&gt;decrement_refcount();
1124       }
1125       if (constraint._from_name != NULL ) {
1126         constraint._from_name-&gt;decrement_refcount();
1127       }
1128     }
1129     FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTVerifierConstraint, p-&gt;_verifier_constraints);
1130     p-&gt;_verifier_constraints = NULL;
1131     FREE_C_HEAP_ARRAY(char, p-&gt;_verifier_constraint_flags);
1132     p-&gt;_verifier_constraint_flags = NULL;
1133   }
1134   if (p-&gt;_loader_constraints != NULL) {
1135     for (int i = 0; i &lt; p-&gt;_loader_constraints-&gt;length(); i++) {
1136       DumpTimeSharedClassInfo::DTLoaderConstraint ld =  p-&gt;_loader_constraints-&gt;at(i);
1137       if (ld._name != NULL) {
1138         ld._name-&gt;decrement_refcount();
1139       }
1140     }
1141     FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTLoaderConstraint, p-&gt;_loader_constraints);
1142     p-&gt;_loader_constraints = NULL;
1143   }
1144   _dumptime_table-&gt;remove(k);
1145 }
1146 
1147 bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {
1148   while (k) {
1149     if (k-&gt;name()-&gt;equals(&quot;jdk/internal/event/Event&quot;)) {
1150       return true;
1151     }
1152     k = k-&gt;java_super();
1153   }
1154   return false;
1155 }
1156 
1157 void SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {
1158   ResourceMark rm;
1159   log_warning(cds)(&quot;Skipping %s: %s&quot;, k-&gt;name()-&gt;as_C_string(), reason);
1160 }
1161 
1162 bool SystemDictionaryShared::should_be_excluded(InstanceKlass* k) {
1163   if (k-&gt;is_hidden() || k-&gt;is_unsafe_anonymous()) {
1164     warn_excluded(k, &quot;Hidden or Unsafe anonymous class&quot;);
1165     return true; // hidden and unsafe anonymous classes are not archived, skip
1166   }
1167   if (k-&gt;is_in_error_state()) {
1168     warn_excluded(k, &quot;In error state&quot;);
1169     return true;
1170   }
1171   if (k-&gt;has_been_redefined()) {
1172     warn_excluded(k, &quot;Has been redefined&quot;);
1173     return true;
1174   }
1175   if (k-&gt;shared_classpath_index() &lt; 0 &amp;&amp; is_builtin(k)) {
1176     // These are classes loaded from unsupported locations (such as those loaded by JVMTI native
1177     // agent during dump time).
1178     warn_excluded(k, &quot;Unsupported location&quot;);
1179     return true;
1180   }
1181   if (k-&gt;signers() != NULL) {
1182     // We cannot include signed classes in the archive because the certificates
1183     // used during dump time may be different than those used during
1184     // runtime (due to expiration, etc).
1185     warn_excluded(k, &quot;Signed JAR&quot;);
1186     return true;
1187   }
1188   if (is_jfr_event_class(k)) {
1189     // We cannot include JFR event classes because they need runtime-specific
1190     // instrumentation in order to work with -XX:FlightRecorderOptions=retransform=false.
1191     // There are only a small number of these classes, so it&#39;s not worthwhile to
1192     // support them and make CDS more complicated.
1193     warn_excluded(k, &quot;JFR event class&quot;);
1194     return true;
1195   }
1196   if (k-&gt;init_state() &lt; InstanceKlass::linked) {
1197     // In CDS dumping, we will attempt to link all classes. Those that fail to link will
1198     // be recorded in DumpTimeSharedClassInfo.
1199     Arguments::assert_is_dumping_archive();
1200 
1201     // TODO -- rethink how this can be handled.
1202     // We should try to link ik, however, we can&#39;t do it here because
1203     // 1. We are at VM exit
1204     // 2. linking a class may cause other classes to be loaded, which means
1205     //    a custom ClassLoader.loadClass() may be called, at a point where the
1206     //    class loader doesn&#39;t expect it.
1207     if (has_class_failed_verification(k)) {
1208       warn_excluded(k, &quot;Failed verification&quot;);
1209     } else {
1210       warn_excluded(k, &quot;Not linked&quot;);
1211     }
1212     return true;
1213   }
1214   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {
1215     ResourceMark rm;
1216     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
1217                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());
1218     return true;
1219   }
1220 
1221   InstanceKlass* super = k-&gt;java_super();
1222   if (super != NULL &amp;&amp; should_be_excluded(super)) {
1223     ResourceMark rm;
1224     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());
1225     return true;
1226   }
1227 
1228   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();
1229   int len = interfaces-&gt;length();
1230   for (int i = 0; i &lt; len; i++) {
1231     InstanceKlass* intf = interfaces-&gt;at(i);
1232     if (should_be_excluded(intf)) {
1233       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());
1234       return true;
1235     }
1236   }
1237 
1238   return false;
1239 }
1240 
1241 // k is a class before relocating by ArchiveCompactor
1242 void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
1243   ResourceMark rm;
1244   const char* name = k-&gt;name()-&gt;as_C_string();
1245   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
1246   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);
1247   guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
1248   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);
1249   if (is_builtin(k)) {
1250     guarantee(!k-&gt;is_shared_unregistered_class(),
1251               &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
1252   } else {
1253     guarantee(k-&gt;is_shared_unregistered_class(),
1254               &quot;Class loader type must not be set for UNREGISTERED class %s&quot;, name);
1255   }
1256 }
1257 
1258 class ExcludeDumpTimeSharedClasses : StackObj {
1259 public:
1260   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1261     if (SystemDictionaryShared::should_be_excluded(k)) {
1262       info.set_excluded();
1263     }
1264     return true; // keep on iterating
1265   }
1266 };
1267 
1268 void SystemDictionaryShared::check_excluded_classes() {
1269   ExcludeDumpTimeSharedClasses excl;
1270   _dumptime_table-&gt;iterate(&amp;excl);
1271   _dumptime_table-&gt;update_counts();
1272 }
1273 
1274 bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
1275   assert(_no_class_loading_should_happen, &quot;sanity&quot;);
1276   Arguments::assert_is_dumping_archive();
1277   return find_or_allocate_info_for(k)-&gt;is_excluded();
1278 }
1279 
1280 void SystemDictionaryShared::set_class_has_failed_verification(InstanceKlass* ik) {
1281   Arguments::assert_is_dumping_archive();
1282   find_or_allocate_info_for(ik)-&gt;set_failed_verification();
1283 }
1284 
1285 bool SystemDictionaryShared::has_class_failed_verification(InstanceKlass* ik) {
1286   Arguments::assert_is_dumping_archive();
1287   if (_dumptime_table == NULL) {
1288     assert(DynamicDumpSharedSpaces, &quot;sanity&quot;);
1289     assert(ik-&gt;is_shared(), &quot;must be a shared class in the static archive&quot;);
1290     return false;
1291   }
1292   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(ik);
1293   return (p == NULL) ? false : p-&gt;failed_verification();
1294 }
1295 
1296 class IterateDumpTimeSharedClassTable : StackObj {
1297   MetaspaceClosure *_it;
1298 public:
1299   IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
1300 
1301   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1302     if (!info.is_excluded()) {
1303       info.metaspace_pointers_do(_it);
1304     }
1305     return true; // keep on iterating
1306   }
1307 };
1308 
1309 void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {
1310   IterateDumpTimeSharedClassTable iter(it);
1311   _dumptime_table-&gt;iterate(&amp;iter);
1312 }
1313 
1314 bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
1315          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
1316   Arguments::assert_is_dumping_archive();
1317   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1318   info-&gt;add_verification_constraint(k, name, from_name, from_field_is_protected,
1319                                     from_is_array, from_is_object);
1320 
1321   if (DynamicDumpSharedSpaces) {
1322     // For dynamic dumping, we can resolve all the constraint classes for all class loaders during
1323     // the initial run prior to creating the archive before vm exit. We will also perform verification
1324     // check when running with the archive.
1325     return false;
1326   } else {
1327     if (is_builtin(k)) {
1328       // For builtin class loaders, we can try to complete the verification check at dump time,
1329       // because we can resolve all the constraint classes. We will also perform verification check
1330       // when running with the archive.
1331       return false;
1332     } else {
1333       // For non-builtin class loaders, we cannot complete the verification check at dump time,
1334       // because at dump time we don&#39;t know how to resolve classes for such loaders.
1335       return true;
1336     }
1337   }
1338 }
1339 
1340 void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,
1341          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
1342   if (_verifier_constraints == NULL) {
1343     _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;DTVerifierConstraint&gt;(4, true, mtClass);
1344   }
1345   if (_verifier_constraint_flags == NULL) {
1346     _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;char&gt;(4, true, mtClass);
1347   }
1348   GrowableArray&lt;DTVerifierConstraint&gt;* vc_array = _verifier_constraints;
1349   for (int i = 0; i &lt; vc_array-&gt;length(); i++) {
1350     DTVerifierConstraint* p = vc_array-&gt;adr_at(i);
1351     if (name == p-&gt;_name &amp;&amp; from_name == p-&gt;_from_name) {
1352       return;
1353     }
1354   }
1355   DTVerifierConstraint cons(name, from_name);
1356   vc_array-&gt;append(cons);
1357 
1358   GrowableArray&lt;char&gt;* vcflags_array = _verifier_constraint_flags;
1359   char c = 0;
1360   c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;
1361   c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;
1362   c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;
1363   vcflags_array-&gt;append(c);
1364 
1365   if (log_is_enabled(Trace, cds, verification)) {
1366     ResourceMark rm;
1367     log_trace(cds, verification)(&quot;add_verification_constraint: %s: %s must be subclass of %s [0x%x]&quot;,
1368                                  k-&gt;external_name(), from_name-&gt;as_klass_external_name(),
1369                                  name-&gt;as_klass_external_name(), c);
1370   }
1371 }
1372 
1373 static char get_loader_type_by(oop  loader) {
1374   assert(SystemDictionary::is_builtin_class_loader(loader), &quot;Must be built-in loader&quot;);
1375   if (SystemDictionary::is_boot_class_loader(loader)) {
1376     return (char)ClassLoader::BOOT_LOADER;
1377   } else if (SystemDictionary::is_platform_class_loader(loader)) {
1378     return (char)ClassLoader::PLATFORM_LOADER;
1379   } else {
1380     assert(SystemDictionary::is_system_class_loader(loader), &quot;Class loader mismatch&quot;);
1381     return (char)ClassLoader::APP_LOADER;
1382   }
1383 }
1384 
1385 static oop get_class_loader_by(char type) {
1386   if (type == (char)ClassLoader::BOOT_LOADER) {
1387     return (oop)NULL;
1388   } else if (type == (char)ClassLoader::PLATFORM_LOADER) {
1389     return SystemDictionary::java_platform_loader();
1390   } else {
1391     assert (type == (char)ClassLoader::APP_LOADER, &quot;Sanity&quot;);
1392     return SystemDictionary::java_system_loader();
1393   }
1394 }
1395 
1396 void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {
1397   assert(loader1 != loader2, &quot;sanity&quot;);
1398   LogTarget(Info, class, loader, constraints) log;
1399   if (_loader_constraints == NULL) {
1400     _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;DTLoaderConstraint&gt;(4, true, mtClass);
1401   }
1402   char lt1 = get_loader_type_by(loader1());
1403   char lt2 = get_loader_type_by(loader2());
1404   DTLoaderConstraint lc(name, lt1, lt2);
1405   for (int i = 0; i &lt; _loader_constraints-&gt;length(); i++) {
1406     DTLoaderConstraint dt = _loader_constraints-&gt;at(i);
1407     if (lc.equals(dt)) {
1408       if (log.is_enabled()) {
1409         ResourceMark rm;
1410         // Use loader[0]/loader[1] to be consistent with the logs in loaderConstraints.cpp
1411         log.print(&quot;[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]&quot;,
1412                   _klass-&gt;external_name(), name-&gt;as_C_string(),
1413                   ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1414                   ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id());
1415       }
1416       return;
1417     }
1418   }
1419   _loader_constraints-&gt;append(lc);
1420   if (log.is_enabled()) {
1421     ResourceMark rm;
1422     // Use loader[0]/loader[1] to be consistent with the logs in loaderConstraints.cpp
1423     log.print(&quot;[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]&quot;,
1424               _klass-&gt;external_name(), name-&gt;as_C_string(),
1425               ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1426               ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id(),
1427               _loader_constraints-&gt;length());
1428   }
1429 }
1430 
1431 void SystemDictionaryShared::check_verification_constraints(InstanceKlass* klass,
1432                                                             TRAPS) {
1433   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1434   RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(klass);
1435 
1436   int length = record-&gt;_num_verifier_constraints;
1437   if (length &gt; 0) {
1438     for (int i = 0; i &lt; length; i++) {
1439       RunTimeSharedClassInfo::RTVerifierConstraint* vc = record-&gt;verifier_constraint_at(i);
1440       Symbol* name      = vc-&gt;name();
1441       Symbol* from_name = vc-&gt;from_name();
1442       char c            = record-&gt;verifier_constraint_flag(i);
1443 
1444       if (log_is_enabled(Trace, cds, verification)) {
1445         ResourceMark rm(THREAD);
1446         log_trace(cds, verification)(&quot;check_verification_constraint: %s: %s must be subclass of %s [0x%x]&quot;,
1447                                      klass-&gt;external_name(), from_name-&gt;as_klass_external_name(),
1448                                      name-&gt;as_klass_external_name(), c);
1449       }
1450 
1451       bool from_field_is_protected = (c &amp; SystemDictionaryShared::FROM_FIELD_IS_PROTECTED) ? true : false;
1452       bool from_is_array           = (c &amp; SystemDictionaryShared::FROM_IS_ARRAY)           ? true : false;
1453       bool from_is_object          = (c &amp; SystemDictionaryShared::FROM_IS_OBJECT)          ? true : false;
1454 
1455       bool ok = VerificationType::resolve_and_check_assignability(klass, name,
1456          from_name, from_field_is_protected, from_is_array, from_is_object, CHECK);
1457       if (!ok) {
1458         ResourceMark rm(THREAD);
1459         stringStream ss;
1460 
1461         ss.print_cr(&quot;Bad type on operand stack&quot;);
1462         ss.print_cr(&quot;Exception Details:&quot;);
1463         ss.print_cr(&quot;  Location:\n    %s&quot;, klass-&gt;name()-&gt;as_C_string());
1464         ss.print_cr(&quot;  Reason:\n    Type &#39;%s&#39; is not assignable to &#39;%s&#39;&quot;,
1465                     from_name-&gt;as_quoted_ascii(), name-&gt;as_quoted_ascii());
1466         THROW_MSG(vmSymbols::java_lang_VerifyError(), ss.as_string());
1467       }
1468     }
1469   }
1470 }
1471 
1472 // Record class loader constraints that are checked inside
1473 // InstanceKlass::link_class(), so that these can be checked quickly
1474 // at runtime without laying out the vtable/itables.
1475 void SystemDictionaryShared::record_linking_constraint(Symbol* name, InstanceKlass* klass,
1476                                                     Handle loader1, Handle loader2, TRAPS) {
1477   // A linking constraint check is executed when:
1478   //   - klass extends or implements type S
1479   //   - klass overrides method S.M(...) with X.M
1480   //     - If klass defines the method M, X is
1481   //       the same as klass.
1482   //     - If klass does not define the method M,
1483   //       X must be a supertype of klass and X.M is
1484   //       a default method defined by X.
1485   //   - loader1 = X-&gt;class_loader()
1486   //   - loader2 = S-&gt;class_loader()
1487   //   - loader1 != loader2
1488   //   - M&#39;s paramater(s) include an object type T
1489   // We require that
1490   //   - whenever loader1 and loader2 try to
1491   //     resolve the type T, they must always resolve to
1492   //     the same InstanceKlass.
1493   // NOTE: type T may or may not be currently resolved in
1494   // either of these two loaders. The check itself does not
1495   // try to resolve T.
1496   oop klass_loader = klass-&gt;class_loader();
1497   assert(klass_loader != NULL, &quot;should not be called for boot loader&quot;);
1498   assert(loader1 != loader2, &quot;must be&quot;);
1499 
1500   if (!is_system_class_loader(klass_loader) &amp;&amp;
1501       !is_platform_class_loader(klass_loader)) {
1502     // If klass is loaded by system/platform loaders, we can
1503     // guarantee that klass and S must be loaded by the same
1504     // respective loader between dump time and run time, and
1505     // the exact same check on (name, loader1, loader2) will
1506     // be executed. Hence, we can cache this check and execute
1507     // it at runtime without walking the vtable/itables.
1508     //
1509     // This cannot be guaranteed for classes loaded by other
1510     // loaders, so we bail.
1511     return;
1512   }
1513 
1514   if (THREAD-&gt;is_VM_thread()) {
1515     assert(DynamicDumpSharedSpaces, &quot;must be&quot;);
1516     // We are re-laying out the vtable/itables of the *copy* of
1517     // a class during the final stage of dynamic dumping. The
1518     // linking constraints for this class has already been recorded.
1519     return;
1520   }
1521   Arguments::assert_is_dumping_archive();
1522   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(klass);
1523   info-&gt;record_linking_constraint(name, loader1, loader2);
1524 }
1525 
1526 // returns true IFF there&#39;s no need to re-initialize the i/v-tables for klass for
1527 // the purpose of checking class loader constraints.
1528 bool SystemDictionaryShared::check_linking_constraints(InstanceKlass* klass, TRAPS) {
1529   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1530   LogTarget(Info, class, loader, constraints) log;
1531   if (klass-&gt;is_shared_boot_class()) {
1532     // No class loader constraint check performed for boot classes.
1533     return true;
1534   }
1535   if (klass-&gt;is_shared_platform_class() || klass-&gt;is_shared_app_class()) {
1536     RunTimeSharedClassInfo* info = RunTimeSharedClassInfo::get_for(klass);
1537     assert(info != NULL, &quot;Sanity&quot;);
1538     if (info-&gt;_num_loader_constraints &gt; 0) {
1539       HandleMark hm;
1540       for (int i = 0; i &lt; info-&gt;_num_loader_constraints; i++) {
1541         RunTimeSharedClassInfo::RTLoaderConstraint* lc = info-&gt;loader_constraint_at(i);
1542         Symbol* name = lc-&gt;constraint_name();
1543         Handle loader1(THREAD, get_class_loader_by(lc-&gt;_loader_type1));
1544         Handle loader2(THREAD, get_class_loader_by(lc-&gt;_loader_type2));
1545         if (log.is_enabled()) {
1546           ResourceMark rm(THREAD);
1547           log.print(&quot;[CDS add loader constraint for class %s symbol %s loader[0] %s loader[1] %s&quot;,
1548                     klass-&gt;external_name(), name-&gt;as_C_string(),
1549                     ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1550                     ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id());
1551         }
1552         if (!SystemDictionary::add_loader_constraint(name, klass, loader1, loader2, THREAD)) {
1553           // Loader constraint violation has been found. The caller
1554           // will re-layout the vtable/itables to produce the correct
1555           // exception.
1556           if (log.is_enabled()) {
1557             log.print(&quot; failed]&quot;);
1558           }
1559           return false;
1560         }
1561         if (log.is_enabled()) {
1562             log.print(&quot; succeeded]&quot;);
1563         }
1564       }
1565       return true; // for all recorded constraints added successully.
1566     }
1567   }
1568   if (log.is_enabled()) {
1569     ResourceMark rm(THREAD);
1570     log.print(&quot;[CDS has not recorded loader constraint for class %s]&quot;, klass-&gt;external_name());
1571   }
1572   return false;
1573 }
1574 
1575 class EstimateSizeForArchive : StackObj {
1576   size_t _shared_class_info_size;
1577   int _num_builtin_klasses;
1578   int _num_unregistered_klasses;
1579 
1580 public:
1581   EstimateSizeForArchive() {
1582     _shared_class_info_size = 0;
1583     _num_builtin_klasses = 0;
1584     _num_unregistered_klasses = 0;
1585   }
1586 
1587   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1588     if (!info.is_excluded()) {
1589       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());
1590       _shared_class_info_size += align_up(byte_size, BytesPerWord);
1591     }
1592     return true; // keep on iterating
1593   }
1594 
1595   size_t total() {
1596     return _shared_class_info_size;
1597   }
1598 };
1599 
1600 size_t SystemDictionaryShared::estimate_size_for_archive() {
1601   EstimateSizeForArchive est;
1602   _dumptime_table-&gt;iterate(&amp;est);
1603   return est.total() +
1604     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(true)) +
1605     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(false));
1606 }
1607 
1608 class CopySharedClassInfoToArchive : StackObj {
1609   CompactHashtableWriter* _writer;
1610   bool _is_builtin;
1611 public:
1612   CopySharedClassInfoToArchive(CompactHashtableWriter* writer,
1613                                bool is_builtin,
1614                                bool is_static_archive)
1615     : _writer(writer), _is_builtin(is_builtin) {}
1616 
1617   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1618     if (!info.is_excluded() &amp;&amp; info.is_builtin() == _is_builtin) {
1619       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());
1620       RunTimeSharedClassInfo* record;
1621       record = (RunTimeSharedClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);
1622       record-&gt;init(info);
1623 
1624       unsigned int hash;
1625       Symbol* name = info._klass-&gt;name();
1626       if (DynamicDumpSharedSpaces) {
1627         name = DynamicArchive::original_to_target(name);
1628       }
1629       hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1630       u4 delta;
1631       if (DynamicDumpSharedSpaces) {
1632         delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(record));
1633       } else {
1634         delta = MetaspaceShared::object_delta_u4(record);
1635       }
1636       _writer-&gt;add(hash, delta);
1637       if (log_is_enabled(Trace, cds, hashtables)) {
1638         ResourceMark rm;
1639         log_trace(cds,hashtables)(&quot;%s dictionary: %s&quot;, (_is_builtin ? &quot;builtin&quot; : &quot;unregistered&quot;), info._klass-&gt;external_name());
1640       }
1641 
1642       // Save this for quick runtime lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo*
1643       RunTimeSharedClassInfo::set_for(info._klass, record);
1644     }
1645     return true; // keep on iterating
1646   }
1647 };
1648 
1649 void SystemDictionaryShared::write_dictionary(RunTimeSharedDictionary* dictionary,
1650                                               bool is_builtin,
1651                                               bool is_static_archive) {
1652   CompactHashtableStats stats;
1653   dictionary-&gt;reset();
1654   CompactHashtableWriter writer(_dumptime_table-&gt;count_of(is_builtin), &amp;stats);
1655   CopySharedClassInfoToArchive copy(&amp;writer, is_builtin, is_static_archive);
1656   _dumptime_table-&gt;iterate(&amp;copy);
1657   writer.dump(dictionary, is_builtin ? &quot;builtin dictionary&quot; : &quot;unregistered dictionary&quot;);
1658 }
1659 
1660 void SystemDictionaryShared::write_to_archive(bool is_static_archive) {
1661   if (is_static_archive) {
1662     write_dictionary(&amp;_builtin_dictionary, true);
1663     write_dictionary(&amp;_unregistered_dictionary, false);
1664   } else {
1665     write_dictionary(&amp;_dynamic_builtin_dictionary, true);
1666     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);
1667   }
1668 }
1669 
1670 void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,
1671                                                           bool is_static_archive) {
1672   if (is_static_archive) {
1673     _builtin_dictionary.serialize_header(soc);
1674     _unregistered_dictionary.serialize_header(soc);
1675   } else {
1676     _dynamic_builtin_dictionary.serialize_header(soc);
1677     _dynamic_unregistered_dictionary.serialize_header(soc);
1678   }
1679 }
1680 
1681 void SystemDictionaryShared::serialize_well_known_klasses(SerializeClosure* soc) {
1682   for (int i = FIRST_WKID; i &lt; WKID_LIMIT; i++) {
1683     soc-&gt;do_ptr((void**)&amp;_well_known_klasses[i]);
1684   }
1685 }
1686 
1687 const RunTimeSharedClassInfo*
1688 SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {
1689   if (!UseSharedSpaces || !name-&gt;is_shared()) {
1690     // The names of all shared classes must also be a shared Symbol.
1691     return NULL;
1692   }
1693 
1694   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1695   const RunTimeSharedClassInfo* record = NULL;
1696   if (!MetaspaceShared::is_shared_dynamic(name)) {
1697     // The names of all shared classes in the static dict must also be in the
1698     // static archive
1699     record = static_dict-&gt;lookup(name, hash, 0);
1700   }
1701 
1702   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {
1703     record = dynamic_dict-&gt;lookup(name, hash, 0);
1704   }
1705 
1706   return record;
1707 }
1708 
1709 InstanceKlass* SystemDictionaryShared::find_builtin_class(Symbol* name) {
1710   const RunTimeSharedClassInfo* record = find_record(&amp;_builtin_dictionary, &amp;_dynamic_builtin_dictionary, name);
1711   if (record != NULL) {
1712     return record-&gt;_klass;
1713   } else {
1714     return NULL;
1715   }
1716 }
1717 
1718 void SystemDictionaryShared::update_shared_entry(InstanceKlass* k, int id) {
1719   assert(DumpSharedSpaces, &quot;supported only when dumping&quot;);
1720   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1721   info-&gt;_id = id;
1722 }
1723 
1724 class SharedDictionaryPrinter : StackObj {
1725   outputStream* _st;
1726   int _index;
1727 public:
1728   SharedDictionaryPrinter(outputStream* st) : _st(st), _index(0) {}
1729 
1730   void do_value(const RunTimeSharedClassInfo* record) {
1731     ResourceMark rm;
1732     _st-&gt;print_cr(&quot;%4d:  %s&quot;, (_index++), record-&gt;_klass-&gt;external_name());
1733   }
1734 };
1735 
1736 void SystemDictionaryShared::print_on(outputStream* st) {
1737   if (UseSharedSpaces) {
1738     st-&gt;print_cr(&quot;Shared Dictionary&quot;);
1739     SharedDictionaryPrinter p(st);
1740     _builtin_dictionary.iterate(&amp;p);
1741     _unregistered_dictionary.iterate(&amp;p);
1742     if (DynamicArchive::is_mapped()) {
1743       _dynamic_builtin_dictionary.iterate(&amp;p);
1744       _unregistered_dictionary.iterate(&amp;p);
1745     }
1746   }
1747 }
1748 
1749 void SystemDictionaryShared::print_table_statistics(outputStream* st) {
1750   if (UseSharedSpaces) {
1751     _builtin_dictionary.print_table_statistics(st, &quot;Builtin Shared Dictionary&quot;);
1752     _unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
1753     if (DynamicArchive::is_mapped()) {
1754       _dynamic_builtin_dictionary.print_table_statistics(st, &quot;Dynamic Builtin Shared Dictionary&quot;);
1755       _dynamic_unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
1756     }
1757   }
1758 }
1759 
1760 bool SystemDictionaryShared::empty_dumptime_table() {
1761   if (_dumptime_table == NULL) {
1762     return true;
1763   }
1764   _dumptime_table-&gt;update_counts();
1765   if (_dumptime_table-&gt;count_of(true) == 0 &amp;&amp; _dumptime_table-&gt;count_of(false) == 0){
1766     return true;
1767   }
1768   return false;
1769 }
1770 
1771 #if INCLUDE_CDS_JAVA_HEAP
1772 
1773 class ArchivedMirrorPatcher {
1774   static void update(Klass* k) {
1775     if (k-&gt;has_raw_archived_mirror()) {
1776       oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1777       if (m != NULL) {
1778         java_lang_Class::update_archived_mirror_native_pointers(m);
1779       }
1780     }
1781   }
1782 
1783 public:
1784   static void update_array_klasses(Klass* ak) {
1785     while (ak != NULL) {
1786       update(ak);
1787       ak = ArrayKlass::cast(ak)-&gt;higher_dimension();
1788     }
1789   }
1790 
1791   void do_value(const RunTimeSharedClassInfo* info) {
1792     InstanceKlass* ik = info-&gt;_klass;
1793     update(ik);
1794     update_array_klasses(ik-&gt;array_klasses());
1795   }
1796 };
1797 
1798 void SystemDictionaryShared::update_archived_mirror_native_pointers_for(RunTimeSharedDictionary* dict) {
1799   ArchivedMirrorPatcher patcher;
1800   dict-&gt;iterate(&amp;patcher);
1801 }
1802 
1803 void SystemDictionaryShared::update_archived_mirror_native_pointers() {
1804   if (!HeapShared::open_archive_heap_region_mapped()) {
1805     return;
1806   }
1807   if (MetaspaceShared::relocation_delta() == 0) {
1808     return;
1809   }
1810   update_archived_mirror_native_pointers_for(&amp;_builtin_dictionary);
1811   update_archived_mirror_native_pointers_for(&amp;_unregistered_dictionary);
1812 
1813   for (int t = T_BOOLEAN; t &lt;= T_LONG; t++) {
1814     Klass* k = Universe::typeArrayKlassObj((BasicType)t);
1815     ArchivedMirrorPatcher::update_array_klasses(k);
1816   }
1817 }
1818 #endif
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderStats.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderStats.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderStats.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/classLoaderStats.hpp&quot;
 29 #include &quot;oops/objArrayKlass.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 
 34 class ClassStatsClosure : public KlassClosure {
 35 public:
 36   int _num_classes;
 37 
 38   ClassStatsClosure() :
 39     _num_classes(0) {
 40   }
 41 
 42   virtual void do_klass(Klass* k) {
 43     _num_classes++;
 44   }
 45 };
 46 
<span class="line-removed"> 47 </span>
 48 void ClassLoaderStatsClosure::do_cld(ClassLoaderData* cld) {
 49   oop cl = cld-&gt;class_loader();
<span class="line-removed"> 50   ClassLoaderStats* cls;</span>
 51 
 52   // The hashtable key is the ClassLoader oop since we want to account
 53   // for &quot;real&quot; classes and anonymous classes together
<span class="line-modified"> 54   ClassLoaderStats** cls_ptr = _stats-&gt;get(cl);</span>
<span class="line-modified"> 55   if (cls_ptr == NULL) {</span>
<span class="line-modified"> 56     cls = new ClassLoaderStats();</span>
<span class="line-modified"> 57     _stats-&gt;put(cl, cls);</span>
 58     _total_loaders++;
<span class="line-removed"> 59   } else {</span>
<span class="line-removed"> 60     cls = *cls_ptr;</span>
 61   }

 62 
 63   if (!cld-&gt;has_class_mirror_holder()) {
 64     cls-&gt;_cld = cld;
 65   }
 66 
<span class="line-removed"> 67   cls-&gt;_class_loader = cl;</span>
 68   if (cl != NULL) {
 69     cls-&gt;_parent = java_lang_ClassLoader::parent(cl);
 70     addEmptyParents(cls-&gt;_parent);
 71   }
 72 
 73   ClassStatsClosure csc;
 74   cld-&gt;classes_do(&amp;csc);
 75   bool is_hidden = false;
 76   if(cld-&gt;has_class_mirror_holder()) {
 77     // If cld has a class holder then it must be either hidden or unsafe anonymous.
 78     // Either way, count it as a hidden class.
 79     cls-&gt;_hidden_classes_count += csc._num_classes;
 80   } else {
 81     cls-&gt;_classes_count = csc._num_classes;
 82   }
 83   _total_classes += csc._num_classes;
 84 
 85   ClassLoaderMetaspace* ms = cld-&gt;metaspace_or_null();
 86   if (ms != NULL) {
 87     if(cld-&gt;has_class_mirror_holder()) {
 88       cls-&gt;_hidden_chunk_sz += ms-&gt;allocated_chunks_bytes();
 89       cls-&gt;_hidden_block_sz += ms-&gt;allocated_blocks_bytes();
 90     } else {
 91       cls-&gt;_chunk_sz = ms-&gt;allocated_chunks_bytes();
 92       cls-&gt;_block_sz = ms-&gt;allocated_blocks_bytes();
 93     }
 94     _total_chunk_sz += ms-&gt;allocated_chunks_bytes();
 95     _total_block_sz += ms-&gt;allocated_blocks_bytes();
 96   }
 97 }
 98 
 99 
100 // Handles the difference in pointer width on 32 and 64 bit platforms
101 #ifdef _LP64
102   #define SPACE &quot;%8s&quot;
103 #else
104   #define SPACE &quot;%s&quot;
105 #endif
106 
107 
<span class="line-modified">108 bool ClassLoaderStatsClosure::do_entry(oop const&amp; key, ClassLoaderStats* const&amp; cls) {</span>
<span class="line-modified">109   Klass* class_loader_klass = (cls-&gt;_class_loader == NULL ? NULL : cls-&gt;_class_loader-&gt;klass());</span>
<span class="line-modified">110   Klass* parent_klass = (cls-&gt;_parent == NULL ? NULL : cls-&gt;_parent-&gt;klass());</span>
111 
112   _out-&gt;print(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  &quot; UINTX_FORMAT_W(6) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot;,
<span class="line-modified">113       p2i(class_loader_klass), p2i(parent_klass), p2i(cls-&gt;_cld),</span>
<span class="line-modified">114       cls-&gt;_classes_count,</span>
<span class="line-modified">115       cls-&gt;_chunk_sz, cls-&gt;_block_sz);</span>
116   if (class_loader_klass != NULL) {
117     _out-&gt;print(&quot;%s&quot;, class_loader_klass-&gt;external_name());
118   } else {
119     _out-&gt;print(&quot;&lt;boot class loader&gt;&quot;);
120   }
121   _out-&gt;cr();
<span class="line-modified">122   if (cls-&gt;_hidden_classes_count &gt; 0) {</span>
123     _out-&gt;print_cr(SPACE SPACE SPACE &quot;                                    &quot; UINTX_FORMAT_W(6) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot; SIZE_FORMAT_W(8) &quot;   + hidden classes&quot;,
124         &quot;&quot;, &quot;&quot;, &quot;&quot;,
<span class="line-modified">125         cls-&gt;_hidden_classes_count,</span>
<span class="line-modified">126         cls-&gt;_hidden_chunk_sz, cls-&gt;_hidden_block_sz);</span>
127   }
128   return true;
129 }
130 
131 
132 void ClassLoaderStatsClosure::print() {
133   _out-&gt;print_cr(&quot;ClassLoader&quot; SPACE &quot; Parent&quot; SPACE &quot;      CLD*&quot; SPACE &quot;       Classes   ChunkSz   BlockSz  Type&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
134   _stats-&gt;iterate(this);
135   _out-&gt;print(&quot;Total = &quot; UINTX_FORMAT_W(-6), _total_loaders);
136   _out-&gt;print(SPACE SPACE SPACE &quot;                      &quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
137   _out-&gt;print_cr(UINTX_FORMAT_W(6) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot;,
138       _total_classes,
139       _total_chunk_sz,
140       _total_block_sz);
141   _out-&gt;print_cr(&quot;ChunkSz: Total size of all allocated metaspace chunks&quot;);
142   _out-&gt;print_cr(&quot;BlockSz: Total size of all allocated metaspace blocks (each chunk has several blocks)&quot;);
143 }
144 
145 
146 void ClassLoaderStatsClosure::addEmptyParents(oop cl) {
147   while (cl != NULL &amp;&amp; java_lang_ClassLoader::loader_data_acquire(cl) == NULL) {
148     // This classloader has not loaded any classes
<span class="line-modified">149     ClassLoaderStats** cls_ptr = _stats-&gt;get(cl);</span>
<span class="line-modified">150     if (cls_ptr == NULL) {</span>
<span class="line-modified">151       // It does not exist in our table - add it</span>
<span class="line-removed">152       ClassLoaderStats* cls = new ClassLoaderStats();</span>
153       cls-&gt;_class_loader = cl;
154       cls-&gt;_parent = java_lang_ClassLoader::parent(cl);
<span class="line-removed">155       _stats-&gt;put(cl, cls);</span>
156       _total_loaders++;
157     }

158 
159     cl = java_lang_ClassLoader::parent(cl);
160   }
161 }
162 
163 
164 void ClassLoaderStatsVMOperation::doit() {
165   ClassLoaderStatsClosure clsc (_out);
166   ClassLoaderDataGraph::loaded_cld_do(&amp;clsc);
167   clsc.print();
168 }
169 
170 
171 void ClassLoaderStatsDCmd::execute(DCmdSource source, TRAPS) {
172   ClassLoaderStatsVMOperation op(output());
173   VMThread::execute(&amp;op);
174 }
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/classLoaderStats.hpp&quot;
 29 #include &quot;oops/objArrayKlass.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 
 34 class ClassStatsClosure : public KlassClosure {
 35 public:
 36   int _num_classes;
 37 
 38   ClassStatsClosure() :
 39     _num_classes(0) {
 40   }
 41 
 42   virtual void do_klass(Klass* k) {
 43     _num_classes++;
 44   }
 45 };
 46 

 47 void ClassLoaderStatsClosure::do_cld(ClassLoaderData* cld) {
 48   oop cl = cld-&gt;class_loader();

 49 
 50   // The hashtable key is the ClassLoader oop since we want to account
 51   // for &quot;real&quot; classes and anonymous classes together
<span class="line-modified"> 52   bool added = false;</span>
<span class="line-modified"> 53   ClassLoaderStats* cls = _stats-&gt;put_if_absent(cl, &amp;added);</span>
<span class="line-modified"> 54   if (added) {</span>
<span class="line-modified"> 55     cls-&gt;_class_loader = cl;</span>
 56     _total_loaders++;


 57   }
<span class="line-added"> 58   assert(cls-&gt;_class_loader == cl, &quot;Sanity&quot;);</span>
 59 
 60   if (!cld-&gt;has_class_mirror_holder()) {
 61     cls-&gt;_cld = cld;
 62   }
 63 

 64   if (cl != NULL) {
 65     cls-&gt;_parent = java_lang_ClassLoader::parent(cl);
 66     addEmptyParents(cls-&gt;_parent);
 67   }
 68 
 69   ClassStatsClosure csc;
 70   cld-&gt;classes_do(&amp;csc);
 71   bool is_hidden = false;
 72   if(cld-&gt;has_class_mirror_holder()) {
 73     // If cld has a class holder then it must be either hidden or unsafe anonymous.
 74     // Either way, count it as a hidden class.
 75     cls-&gt;_hidden_classes_count += csc._num_classes;
 76   } else {
 77     cls-&gt;_classes_count = csc._num_classes;
 78   }
 79   _total_classes += csc._num_classes;
 80 
 81   ClassLoaderMetaspace* ms = cld-&gt;metaspace_or_null();
 82   if (ms != NULL) {
 83     if(cld-&gt;has_class_mirror_holder()) {
 84       cls-&gt;_hidden_chunk_sz += ms-&gt;allocated_chunks_bytes();
 85       cls-&gt;_hidden_block_sz += ms-&gt;allocated_blocks_bytes();
 86     } else {
 87       cls-&gt;_chunk_sz = ms-&gt;allocated_chunks_bytes();
 88       cls-&gt;_block_sz = ms-&gt;allocated_blocks_bytes();
 89     }
 90     _total_chunk_sz += ms-&gt;allocated_chunks_bytes();
 91     _total_block_sz += ms-&gt;allocated_blocks_bytes();
 92   }
 93 }
 94 
 95 
 96 // Handles the difference in pointer width on 32 and 64 bit platforms
 97 #ifdef _LP64
 98   #define SPACE &quot;%8s&quot;
 99 #else
100   #define SPACE &quot;%s&quot;
101 #endif
102 
103 
<span class="line-modified">104 bool ClassLoaderStatsClosure::do_entry(oop const&amp; key, ClassLoaderStats const&amp; cls) {</span>
<span class="line-modified">105   Klass* class_loader_klass = (cls._class_loader == NULL ? NULL : cls._class_loader-&gt;klass());</span>
<span class="line-modified">106   Klass* parent_klass = (cls._parent == NULL ? NULL : cls._parent-&gt;klass());</span>
107 
108   _out-&gt;print(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  &quot; UINTX_FORMAT_W(6) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot;,
<span class="line-modified">109       p2i(class_loader_klass), p2i(parent_klass), p2i(cls._cld),</span>
<span class="line-modified">110       cls._classes_count,</span>
<span class="line-modified">111       cls._chunk_sz, cls._block_sz);</span>
112   if (class_loader_klass != NULL) {
113     _out-&gt;print(&quot;%s&quot;, class_loader_klass-&gt;external_name());
114   } else {
115     _out-&gt;print(&quot;&lt;boot class loader&gt;&quot;);
116   }
117   _out-&gt;cr();
<span class="line-modified">118   if (cls._hidden_classes_count &gt; 0) {</span>
119     _out-&gt;print_cr(SPACE SPACE SPACE &quot;                                    &quot; UINTX_FORMAT_W(6) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot; SIZE_FORMAT_W(8) &quot;   + hidden classes&quot;,
120         &quot;&quot;, &quot;&quot;, &quot;&quot;,
<span class="line-modified">121         cls._hidden_classes_count,</span>
<span class="line-modified">122         cls._hidden_chunk_sz, cls._hidden_block_sz);</span>
123   }
124   return true;
125 }
126 
127 
128 void ClassLoaderStatsClosure::print() {
129   _out-&gt;print_cr(&quot;ClassLoader&quot; SPACE &quot; Parent&quot; SPACE &quot;      CLD*&quot; SPACE &quot;       Classes   ChunkSz   BlockSz  Type&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
130   _stats-&gt;iterate(this);
131   _out-&gt;print(&quot;Total = &quot; UINTX_FORMAT_W(-6), _total_loaders);
132   _out-&gt;print(SPACE SPACE SPACE &quot;                      &quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
133   _out-&gt;print_cr(UINTX_FORMAT_W(6) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot; SIZE_FORMAT_W(8) &quot;  &quot;,
134       _total_classes,
135       _total_chunk_sz,
136       _total_block_sz);
137   _out-&gt;print_cr(&quot;ChunkSz: Total size of all allocated metaspace chunks&quot;);
138   _out-&gt;print_cr(&quot;BlockSz: Total size of all allocated metaspace blocks (each chunk has several blocks)&quot;);
139 }
140 
141 
142 void ClassLoaderStatsClosure::addEmptyParents(oop cl) {
143   while (cl != NULL &amp;&amp; java_lang_ClassLoader::loader_data_acquire(cl) == NULL) {
144     // This classloader has not loaded any classes
<span class="line-modified">145     bool added = false;</span>
<span class="line-modified">146     ClassLoaderStats* cls = _stats-&gt;put_if_absent(cl, &amp;added);</span>
<span class="line-modified">147     if (added) {</span>

148       cls-&gt;_class_loader = cl;
149       cls-&gt;_parent = java_lang_ClassLoader::parent(cl);

150       _total_loaders++;
151     }
<span class="line-added">152     assert(cls-&gt;_class_loader == cl, &quot;Sanity&quot;);</span>
153 
154     cl = java_lang_ClassLoader::parent(cl);
155   }
156 }
157 
158 
159 void ClassLoaderStatsVMOperation::doit() {
160   ClassLoaderStatsClosure clsc (_out);
161   ClassLoaderDataGraph::loaded_cld_do(&amp;clsc);
162   clsc.print();
163 }
164 
165 
166 void ClassLoaderStatsDCmd::execute(DCmdSource source, TRAPS) {
167   ClassLoaderStatsVMOperation op(output());
168   VMThread::execute(&amp;op);
169 }
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderStats.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
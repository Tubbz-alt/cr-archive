<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderStats.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3621 
3622 // Support for java_lang_ref_Reference
3623 
3624 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3625   assert(obj != NULL, &quot;sanity&quot;);
3626   if (offset != java_lang_ref_Reference::referent_offset) {
3627     return false;
3628   }
3629 
3630   Klass* k = obj-&gt;klass();
3631   if (!k-&gt;is_instance_klass()) {
3632     return false;
3633   }
3634 
3635   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3636   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3637   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3638   return is_reference;
3639 }
3640 






































3641 // Support for java_lang_ref_SoftReference
3642 //
3643 
3644 #define SOFTREFERENCE_FIELDS_DO(macro) \
3645   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3646   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3647 
3648 void java_lang_ref_SoftReference::compute_offsets() {
3649   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3650   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3651 }
3652 
3653 #if INCLUDE_CDS
3654 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3655   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3656 }
3657 #endif
3658 
3659 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3660   return ref-&gt;long_field(timestamp_offset);
</pre>
<hr />
<pre>
4387 int java_lang_reflect_Constructor::parameterTypes_offset;
4388 int java_lang_reflect_Constructor::exceptionTypes_offset;
4389 int java_lang_reflect_Constructor::slot_offset;
4390 int java_lang_reflect_Constructor::modifiers_offset;
4391 int java_lang_reflect_Constructor::signature_offset;
4392 int java_lang_reflect_Constructor::annotations_offset;
4393 int java_lang_reflect_Constructor::parameter_annotations_offset;
4394 int java_lang_reflect_Field::clazz_offset;
4395 int java_lang_reflect_Field::name_offset;
4396 int java_lang_reflect_Field::type_offset;
4397 int java_lang_reflect_Field::slot_offset;
4398 int java_lang_reflect_Field::modifiers_offset;
4399 int java_lang_reflect_Field::signature_offset;
4400 int java_lang_reflect_Field::annotations_offset;
4401 int java_lang_reflect_Parameter::name_offset;
4402 int java_lang_reflect_Parameter::modifiers_offset;
4403 int java_lang_reflect_Parameter::index_offset;
4404 int java_lang_reflect_Parameter::executable_offset;
4405 int java_lang_boxing_object::value_offset;
4406 int java_lang_boxing_object::long_value_offset;

4407 int java_lang_ref_Reference::referent_offset;
4408 int java_lang_ref_Reference::queue_offset;
4409 int java_lang_ref_Reference::next_offset;
4410 int java_lang_ref_Reference::discovered_offset;
4411 int java_lang_ref_SoftReference::timestamp_offset;
4412 int java_lang_ref_SoftReference::static_clock_offset;
4413 int java_lang_ClassLoader::parent_offset;
4414 int java_lang_System::static_in_offset;
4415 int java_lang_System::static_out_offset;
4416 int java_lang_System::static_err_offset;
4417 int java_lang_System::static_security_offset;
4418 int java_lang_StackTraceElement::methodName_offset;
4419 int java_lang_StackTraceElement::fileName_offset;
4420 int java_lang_StackTraceElement::lineNumber_offset;
4421 int java_lang_StackTraceElement::moduleName_offset;
4422 int java_lang_StackTraceElement::moduleVersion_offset;
4423 int java_lang_StackTraceElement::classLoaderName_offset;
4424 int java_lang_StackTraceElement::declaringClass_offset;
4425 int java_lang_StackTraceElement::declaringClassObject_offset;
4426 int java_lang_StackFrameInfo::_memberName_offset;
</pre>
<hr />
<pre>
4851   return base-&gt;obj_field(_static_FALSE_offset);
4852 }
4853 
4854 Symbol* java_lang_Boolean::symbol() {
4855   return vmSymbols::java_lang_Boolean();
4856 }
4857 
4858 #if INCLUDE_CDS
4859 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4860   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4861 }
4862 #endif
4863 #undef BOOLEAN_CACHE_FIELDS_DO
4864 
4865 jboolean java_lang_Boolean::value(oop obj) {
4866    jvalue v;
4867    java_lang_boxing_object::get_value(obj, &amp;v);
4868    return v.z;
4869 }
4870 
<span class="line-removed">4871 // Use with care. This function makes a lot of assumptions about the contents of the object.</span>
<span class="line-removed">4872 // So naturally, only hardcode offsets if you know what you are doing.</span>
<span class="line-removed">4873 static int member_offset(int hardcoded_offset, int elementSize) {</span>
<span class="line-removed">4874   return align_up((hardcoded_offset * elementSize) + instanceOopDesc::base_offset_in_bytes(), elementSize);</span>
<span class="line-removed">4875 }</span>
<span class="line-removed">4876 </span>
4877 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4878   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4879   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
4880   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4881   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4882   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4883   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4884   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4885 
4886 // Support for java_lang_reflect_RecordComponent
4887 void java_lang_reflect_RecordComponent::compute_offsets() {
4888   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4889   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4890 }
4891 
4892 #if INCLUDE_CDS
4893 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4894   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4895 }
4896 #endif
</pre>
<hr />
<pre>
4906 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
4907   element-&gt;obj_field_put(type_offset, value);
4908 }
4909 
4910 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
4911   element-&gt;obj_field_put(accessor_offset, value);
4912 }
4913 
4914 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4915   element-&gt;obj_field_put(signature_offset, value);
4916 }
4917 
4918 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4919   element-&gt;obj_field_put(annotations_offset, value);
4920 }
4921 
4922 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4923   element-&gt;obj_field_put(typeAnnotations_offset, value);
4924 }
4925 
<span class="line-removed">4926 // Compute hard-coded offsets</span>
<span class="line-removed">4927 // Invoked before SystemDictionary::initialize, so pre-loaded classes</span>
<span class="line-removed">4928 // are not available to determine the offset_of_static_fields.</span>
<span class="line-removed">4929 void JavaClasses::compute_hard_coded_offsets() {</span>
<span class="line-removed">4930 </span>
<span class="line-removed">4931   // java_lang_boxing_object</span>
<span class="line-removed">4932   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset, BytesPerInt);</span>
<span class="line-removed">4933   java_lang_boxing_object::long_value_offset = member_offset(java_lang_boxing_object::hc_value_offset, BytesPerLong);</span>
<span class="line-removed">4934 </span>
<span class="line-removed">4935   // java_lang_ref_Reference</span>
<span class="line-removed">4936   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset, heapOopSize);</span>
<span class="line-removed">4937   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset, heapOopSize);</span>
<span class="line-removed">4938   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset, heapOopSize);</span>
<span class="line-removed">4939   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset, heapOopSize);</span>
<span class="line-removed">4940 }</span>
<span class="line-removed">4941 </span>
4942 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4943 
4944 // Compute non-hard-coded field offsets of all the classes in this file
4945 void JavaClasses::compute_offsets() {
4946   if (UseSharedSpaces) {
4947     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4948                                                          JvmtiExport::has_early_class_hook_env()),
4949                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4950     // None of the classes used by the rest of this function can be replaced by
4951     // JMVTI ClassFileLoadHook.
4952     // We are safe to use the archived offsets, which have already been restored
4953     // by JavaClasses::serialize_offsets, without computing the offsets again.
4954     return;
4955   }
4956 
4957   // We have already called the compute_offsets() of the
<span class="line-modified">4958   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)</span>
<span class="line-modified">4959   // earlier inside SystemDictionary::resolve_well_known_classes()</span>
4960   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4961 }
4962 
4963 #if INCLUDE_CDS
4964 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4965 
4966 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4967   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4968 }
4969 #endif
4970 
4971 #if INCLUDE_CDS_JAVA_HEAP
4972 bool JavaClasses::is_supported_for_archiving(oop obj) {
4973   Klass* klass = obj-&gt;klass();
4974 
4975   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
4976       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4977       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4978       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4979       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
</pre>
<hr />
<pre>
5026 void JavaClasses::check_offsets() {
5027   bool valid = true;
5028 
5029 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5030   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
5031 
5032 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5033   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
5034 
5035   // Boxed primitive objects (java_lang_boxing_object)
5036 
5037   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
5038   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
5039   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
5040   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
5041   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
5042   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
5043   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
5044   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
5045 
<span class="line-removed">5046   // java.lang.ref.Reference</span>
<span class="line-removed">5047 </span>
<span class="line-removed">5048   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, referent, &quot;Ljava/lang/Object;&quot;);</span>
<span class="line-removed">5049   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, queue, &quot;Ljava/lang/ref/ReferenceQueue;&quot;);</span>
<span class="line-removed">5050   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, next, &quot;Ljava/lang/ref/Reference;&quot;);</span>
<span class="line-removed">5051   // Fake field</span>
<span class="line-removed">5052   //CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, discovered, &quot;Ljava/lang/ref/Reference;&quot;);</span>
<span class="line-removed">5053 </span>
5054   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);
5055 }
5056 
5057 #endif // PRODUCT
5058 
5059 int InjectedField::compute_offset() {
5060   InstanceKlass* ik = InstanceKlass::cast(klass());
5061   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5062     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
5063       // Only look at injected fields
5064       continue;
5065     }
5066     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
5067       return fs.offset();
5068     }
5069   }
5070   ResourceMark rm;
5071   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
5072 #ifndef PRODUCT
5073   ik-&gt;print();
</pre>
</td>
<td>
<hr />
<pre>
3621 
3622 // Support for java_lang_ref_Reference
3623 
3624 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3625   assert(obj != NULL, &quot;sanity&quot;);
3626   if (offset != java_lang_ref_Reference::referent_offset) {
3627     return false;
3628   }
3629 
3630   Klass* k = obj-&gt;klass();
3631   if (!k-&gt;is_instance_klass()) {
3632     return false;
3633   }
3634 
3635   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3636   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3637   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3638   return is_reference;
3639 }
3640 
<span class="line-added">3641 #define REFERENCE_FIELDS_DO(macro) \</span>
<span class="line-added">3642   macro(referent_offset,   k, &quot;referent&quot;, object_signature, false); \</span>
<span class="line-added">3643   macro(queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \</span>
<span class="line-added">3644   macro(next_offset,       k, &quot;next&quot;, reference_signature, false); \</span>
<span class="line-added">3645   macro(discovered_offset, k, &quot;discovered&quot;, reference_signature, false);</span>
<span class="line-added">3646 </span>
<span class="line-added">3647 void java_lang_ref_Reference::compute_offsets() {</span>
<span class="line-added">3648   if (_offsets_initialized) {</span>
<span class="line-added">3649     return;</span>
<span class="line-added">3650   }</span>
<span class="line-added">3651   _offsets_initialized = true;</span>
<span class="line-added">3652   InstanceKlass* k = SystemDictionary::Reference_klass();</span>
<span class="line-added">3653   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">3654 }</span>
<span class="line-added">3655 </span>
<span class="line-added">3656 #if INCLUDE_CDS</span>
<span class="line-added">3657 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">3658   f-&gt;do_bool(&amp;_offsets_initialized);</span>
<span class="line-added">3659   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">3660 }</span>
<span class="line-added">3661 #endif</span>
<span class="line-added">3662 </span>
<span class="line-added">3663 #define BOXING_FIELDS_DO(macro) \</span>
<span class="line-added">3664   macro(value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \</span>
<span class="line-added">3665   macro(long_value_offset, longKlass, &quot;value&quot;, long_signature, false);</span>
<span class="line-added">3666 </span>
<span class="line-added">3667 void java_lang_boxing_object::compute_offsets() {</span>
<span class="line-added">3668   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();</span>
<span class="line-added">3669   InstanceKlass* longKlass = SystemDictionary::Long_klass();</span>
<span class="line-added">3670   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">3671 }</span>
<span class="line-added">3672 </span>
<span class="line-added">3673 #if INCLUDE_CDS</span>
<span class="line-added">3674 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">3675   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">3676 }</span>
<span class="line-added">3677 #endif</span>
<span class="line-added">3678 </span>
3679 // Support for java_lang_ref_SoftReference
3680 //
3681 
3682 #define SOFTREFERENCE_FIELDS_DO(macro) \
3683   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3684   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3685 
3686 void java_lang_ref_SoftReference::compute_offsets() {
3687   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3688   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3689 }
3690 
3691 #if INCLUDE_CDS
3692 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3693   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3694 }
3695 #endif
3696 
3697 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3698   return ref-&gt;long_field(timestamp_offset);
</pre>
<hr />
<pre>
4425 int java_lang_reflect_Constructor::parameterTypes_offset;
4426 int java_lang_reflect_Constructor::exceptionTypes_offset;
4427 int java_lang_reflect_Constructor::slot_offset;
4428 int java_lang_reflect_Constructor::modifiers_offset;
4429 int java_lang_reflect_Constructor::signature_offset;
4430 int java_lang_reflect_Constructor::annotations_offset;
4431 int java_lang_reflect_Constructor::parameter_annotations_offset;
4432 int java_lang_reflect_Field::clazz_offset;
4433 int java_lang_reflect_Field::name_offset;
4434 int java_lang_reflect_Field::type_offset;
4435 int java_lang_reflect_Field::slot_offset;
4436 int java_lang_reflect_Field::modifiers_offset;
4437 int java_lang_reflect_Field::signature_offset;
4438 int java_lang_reflect_Field::annotations_offset;
4439 int java_lang_reflect_Parameter::name_offset;
4440 int java_lang_reflect_Parameter::modifiers_offset;
4441 int java_lang_reflect_Parameter::index_offset;
4442 int java_lang_reflect_Parameter::executable_offset;
4443 int java_lang_boxing_object::value_offset;
4444 int java_lang_boxing_object::long_value_offset;
<span class="line-added">4445 bool java_lang_ref_Reference::_offsets_initialized;</span>
4446 int java_lang_ref_Reference::referent_offset;
4447 int java_lang_ref_Reference::queue_offset;
4448 int java_lang_ref_Reference::next_offset;
4449 int java_lang_ref_Reference::discovered_offset;
4450 int java_lang_ref_SoftReference::timestamp_offset;
4451 int java_lang_ref_SoftReference::static_clock_offset;
4452 int java_lang_ClassLoader::parent_offset;
4453 int java_lang_System::static_in_offset;
4454 int java_lang_System::static_out_offset;
4455 int java_lang_System::static_err_offset;
4456 int java_lang_System::static_security_offset;
4457 int java_lang_StackTraceElement::methodName_offset;
4458 int java_lang_StackTraceElement::fileName_offset;
4459 int java_lang_StackTraceElement::lineNumber_offset;
4460 int java_lang_StackTraceElement::moduleName_offset;
4461 int java_lang_StackTraceElement::moduleVersion_offset;
4462 int java_lang_StackTraceElement::classLoaderName_offset;
4463 int java_lang_StackTraceElement::declaringClass_offset;
4464 int java_lang_StackTraceElement::declaringClassObject_offset;
4465 int java_lang_StackFrameInfo::_memberName_offset;
</pre>
<hr />
<pre>
4890   return base-&gt;obj_field(_static_FALSE_offset);
4891 }
4892 
4893 Symbol* java_lang_Boolean::symbol() {
4894   return vmSymbols::java_lang_Boolean();
4895 }
4896 
4897 #if INCLUDE_CDS
4898 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4899   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4900 }
4901 #endif
4902 #undef BOOLEAN_CACHE_FIELDS_DO
4903 
4904 jboolean java_lang_Boolean::value(oop obj) {
4905    jvalue v;
4906    java_lang_boxing_object::get_value(obj, &amp;v);
4907    return v.z;
4908 }
4909 






4910 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4911   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4912   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
4913   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4914   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4915   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4916   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4917   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4918 
4919 // Support for java_lang_reflect_RecordComponent
4920 void java_lang_reflect_RecordComponent::compute_offsets() {
4921   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4922   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4923 }
4924 
4925 #if INCLUDE_CDS
4926 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4927   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4928 }
4929 #endif
</pre>
<hr />
<pre>
4939 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
4940   element-&gt;obj_field_put(type_offset, value);
4941 }
4942 
4943 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
4944   element-&gt;obj_field_put(accessor_offset, value);
4945 }
4946 
4947 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4948   element-&gt;obj_field_put(signature_offset, value);
4949 }
4950 
4951 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4952   element-&gt;obj_field_put(annotations_offset, value);
4953 }
4954 
4955 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4956   element-&gt;obj_field_put(typeAnnotations_offset, value);
4957 }
4958 
















4959 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4960 
4961 // Compute non-hard-coded field offsets of all the classes in this file
4962 void JavaClasses::compute_offsets() {
4963   if (UseSharedSpaces) {
4964     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4965                                                          JvmtiExport::has_early_class_hook_env()),
4966                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4967     // None of the classes used by the rest of this function can be replaced by
4968     // JMVTI ClassFileLoadHook.
4969     // We are safe to use the archived offsets, which have already been restored
4970     // by JavaClasses::serialize_offsets, without computing the offsets again.
4971     return;
4972   }
4973 
4974   // We have already called the compute_offsets() of the
<span class="line-modified">4975   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and</span>
<span class="line-modified">4976   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()</span>
4977   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4978 }
4979 
4980 #if INCLUDE_CDS
4981 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4982 
4983 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4984   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4985 }
4986 #endif
4987 
4988 #if INCLUDE_CDS_JAVA_HEAP
4989 bool JavaClasses::is_supported_for_archiving(oop obj) {
4990   Klass* klass = obj-&gt;klass();
4991 
4992   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
4993       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4994       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4995       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4996       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
</pre>
<hr />
<pre>
5043 void JavaClasses::check_offsets() {
5044   bool valid = true;
5045 
5046 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5047   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
5048 
5049 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5050   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
5051 
5052   // Boxed primitive objects (java_lang_boxing_object)
5053 
5054   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
5055   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
5056   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
5057   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
5058   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
5059   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
5060   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
5061   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
5062 








5063   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);
5064 }
5065 
5066 #endif // PRODUCT
5067 
5068 int InjectedField::compute_offset() {
5069   InstanceKlass* ik = InstanceKlass::cast(klass());
5070   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5071     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
5072       // Only look at injected fields
5073       continue;
5074     }
5075     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
5076       return fs.offset();
5077     }
5078   }
5079   ResourceMark rm;
5080   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
5081 #ifndef PRODUCT
5082   ik-&gt;print();
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderStats.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
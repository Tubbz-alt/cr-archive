<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionaryShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 181     return primitive_hash&lt;uintx&gt;(delta);
 182   } else {
 183     // Deterministic archive is not possible because classes can be loaded
 184     // in multiple threads.
 185     return primitive_hash&lt;InstanceKlass*&gt;(k);
 186   }
 187 }
 188 
 189 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 190   InstanceKlass*,
 191   DumpTimeSharedClassInfo,
 192   &amp;DumpTimeSharedClassTable_hash,
 193   primitive_equals&lt;InstanceKlass*&gt;,
 194   15889, // prime number
 195   ResourceObj::C_HEAP&gt;
 196 {
 197   int _builtin_count;
 198   int _unregistered_count;
 199 public:
 200   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
<span class="line-modified"> 201     DumpTimeSharedClassInfo* p = get(k);</span>
<span class="line-modified"> 202     if (p == NULL) {</span>

 203       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 204              &quot;no new classes can be loaded while dumping archive&quot;);
<span class="line-removed"> 205       put(k, DumpTimeSharedClassInfo());</span>
<span class="line-removed"> 206       p = get(k);</span>
<span class="line-removed"> 207       assert(p != NULL, &quot;sanity&quot;);</span>
 208       p-&gt;_klass = k;


 209     }
 210     return p;
 211   }
 212 
 213   class CountClassByCategory : StackObj {
 214     DumpTimeSharedClassTable* _table;
 215   public:
 216     CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}
 217     bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
 218       if (!info.is_excluded()) {
 219         if (info.is_builtin()) {
 220           ++ _table-&gt;_builtin_count;
 221         } else {
 222           ++ _table-&gt;_unregistered_count;
 223         }
 224       }
 225       return true; // keep on iterating
 226     }
 227   };
 228 
</pre>
<hr />
<pre>
1024 
1025   // Load and check super/interfaces, restore unsharable info
1026   InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,
1027                                                   cfs, pkg_entry, THREAD);
1028   if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {
1029     // TODO: clean up &lt;ik&gt; so it can be used again
1030     return NULL;
1031   }
1032 
1033   return shared_klass;
1034 }
1035 
1036 static ResourceHashtable&lt;
1037   Symbol*, bool,
1038   primitive_hash&lt;Symbol*&gt;,
1039   primitive_equals&lt;Symbol*&gt;,
1040   6661,                             // prime number
1041   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
1042 
1043 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {

1044   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
<span class="line-removed">1045 </span>
1046   Symbol* name = k-&gt;name();
<span class="line-modified">1047   if (_loaded_unregistered_classes.get(name) != NULL) {</span>
<span class="line-modified">1048     // We don&#39;t allow duplicated unregistered classes of the same name.</span>
<span class="line-modified">1049     return false;</span>
<span class="line-removed">1050   } else {</span>
<span class="line-removed">1051     bool isnew = _loaded_unregistered_classes.put(name, true);</span>
<span class="line-removed">1052     assert(isnew, &quot;sanity&quot;);</span>
1053     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
1054     SystemDictionary::add_to_hierarchy(k, CHECK_false);
<span class="line-removed">1055     return true;</span>
1056   }

1057 }
1058 
1059 // This function is called to resolve the super/interfaces of shared classes for
1060 // non-built-in loaders. E.g., ChildClass in the below example
1061 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
1062 //
1063 // java/lang/Object id: 0
1064 // Interface   id: 2 super: 0 source: cust.jar
1065 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
1066 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
1067     Symbol* child_name, Symbol* class_name, Handle class_loader,
1068     Handle protection_domain, bool is_superclass, TRAPS) {
1069 
1070   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1071 
1072   ClassListParser* parser = ClassListParser::instance();
1073   if (parser == NULL) {
1074     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
1075     return NULL;
1076   }
</pre>
</td>
<td>
<hr />
<pre>
 181     return primitive_hash&lt;uintx&gt;(delta);
 182   } else {
 183     // Deterministic archive is not possible because classes can be loaded
 184     // in multiple threads.
 185     return primitive_hash&lt;InstanceKlass*&gt;(k);
 186   }
 187 }
 188 
 189 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 190   InstanceKlass*,
 191   DumpTimeSharedClassInfo,
 192   &amp;DumpTimeSharedClassTable_hash,
 193   primitive_equals&lt;InstanceKlass*&gt;,
 194   15889, // prime number
 195   ResourceObj::C_HEAP&gt;
 196 {
 197   int _builtin_count;
 198   int _unregistered_count;
 199 public:
 200   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
<span class="line-modified"> 201     bool created = false;</span>
<span class="line-modified"> 202     DumpTimeSharedClassInfo* p = put_if_absent(k, &amp;created);</span>
<span class="line-added"> 203     if (created) {</span>
 204       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 205              &quot;no new classes can be loaded while dumping archive&quot;);



 206       p-&gt;_klass = k;
<span class="line-added"> 207     } else {</span>
<span class="line-added"> 208       assert(p-&gt;_klass == k, &quot;Sanity&quot;);</span>
 209     }
 210     return p;
 211   }
 212 
 213   class CountClassByCategory : StackObj {
 214     DumpTimeSharedClassTable* _table;
 215   public:
 216     CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}
 217     bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
 218       if (!info.is_excluded()) {
 219         if (info.is_builtin()) {
 220           ++ _table-&gt;_builtin_count;
 221         } else {
 222           ++ _table-&gt;_unregistered_count;
 223         }
 224       }
 225       return true; // keep on iterating
 226     }
 227   };
 228 
</pre>
<hr />
<pre>
1024 
1025   // Load and check super/interfaces, restore unsharable info
1026   InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,
1027                                                   cfs, pkg_entry, THREAD);
1028   if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {
1029     // TODO: clean up &lt;ik&gt; so it can be used again
1030     return NULL;
1031   }
1032 
1033   return shared_klass;
1034 }
1035 
1036 static ResourceHashtable&lt;
1037   Symbol*, bool,
1038   primitive_hash&lt;Symbol*&gt;,
1039   primitive_equals&lt;Symbol*&gt;,
1040   6661,                             // prime number
1041   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
1042 
1043 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
<span class="line-added">1044   // We don&#39;t allow duplicated unregistered classes of the same name.</span>
1045   assert(DumpSharedSpaces, &quot;only when dumping&quot;);

1046   Symbol* name = k-&gt;name();
<span class="line-modified">1047   bool created = false;</span>
<span class="line-modified">1048   _loaded_unregistered_classes.put_if_absent(name, true, &amp;created);</span>
<span class="line-modified">1049   if (created) {</span>



1050     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
1051     SystemDictionary::add_to_hierarchy(k, CHECK_false);

1052   }
<span class="line-added">1053   return created;</span>
1054 }
1055 
1056 // This function is called to resolve the super/interfaces of shared classes for
1057 // non-built-in loaders. E.g., ChildClass in the below example
1058 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
1059 //
1060 // java/lang/Object id: 0
1061 // Interface   id: 2 super: 0 source: cust.jar
1062 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
1063 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
1064     Symbol* child_name, Symbol* class_name, Handle class_loader,
1065     Handle protection_domain, bool is_superclass, TRAPS) {
1066 
1067   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1068 
1069   ClassListParser* parser = ClassListParser::instance();
1070   if (parser == NULL) {
1071     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
1072     return NULL;
1073   }
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
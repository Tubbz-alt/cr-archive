<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectedHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectedHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;
  38 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  39 #include &quot;gc/g1/g1HeapTransition.hpp&quot;
  40 #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
  41 #include &quot;gc/g1/g1HRPrinter.hpp&quot;
  42 #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;
  43 #include &quot;gc/g1/g1MonitoringSupport.hpp&quot;
  44 #include &quot;gc/g1/g1NUMA.hpp&quot;
  45 #include &quot;gc/g1/g1RedirtyCardsQueue.hpp&quot;
  46 #include &quot;gc/g1/g1SurvivorRegions.hpp&quot;
  47 #include &quot;gc/g1/g1YCTypes.hpp&quot;
  48 #include &quot;gc/g1/heapRegionManager.hpp&quot;
  49 #include &quot;gc/g1/heapRegionSet.hpp&quot;
  50 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  51 #include &quot;gc/shared/barrierSet.hpp&quot;
  52 #include &quot;gc/shared/collectedHeap.hpp&quot;
  53 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  54 #include &quot;gc/shared/plab.hpp&quot;
  55 #include &quot;gc/shared/preservedMarks.hpp&quot;
  56 #include &quot;gc/shared/softRefPolicy.hpp&quot;

  57 #include &quot;memory/memRegion.hpp&quot;
  58 #include &quot;utilities/stack.hpp&quot;
  59 
  60 // A &quot;G1CollectedHeap&quot; is an implementation of a java heap for HotSpot.
  61 // It uses the &quot;Garbage First&quot; heap organization and algorithm, which
  62 // may combine concurrent marking with parallel, incremental compaction of
  63 // heap subsets that will yield large amounts of garbage.
  64 
  65 // Forward declarations
  66 class HeapRegion;
  67 class GenerationSpec;
  68 class G1ParScanThreadState;
  69 class G1ParScanThreadStateSet;
  70 class G1ParScanThreadState;
  71 class MemoryPool;
  72 class MemoryManager;
  73 class ObjectClosure;
  74 class SpaceClosure;
  75 class CompactibleSpaceClosure;
  76 class Space;
</pre>
<hr />
<pre>
  80 class G1HotCardCache;
  81 class G1RemSet;
  82 class G1YoungRemSetSamplingThread;
  83 class G1ConcurrentMark;
  84 class G1ConcurrentMarkThread;
  85 class G1ConcurrentRefine;
  86 class GenerationCounters;
  87 class STWGCTimer;
  88 class G1NewTracer;
  89 class EvacuationFailedInfo;
  90 class nmethod;
  91 class WorkGang;
  92 class G1Allocator;
  93 class G1ArchiveAllocator;
  94 class G1FullGCScope;
  95 class G1HeapVerifier;
  96 class G1HeapSizingPolicy;
  97 class G1HeapSummary;
  98 class G1EvacSummary;
  99 
<span class="line-modified"> 100 typedef OverflowTaskQueue&lt;StarTask, mtGC&gt;         RefToScanQueue;</span>
<span class="line-modified"> 101 typedef GenericTaskQueueSet&lt;RefToScanQueue, mtGC&gt; RefToScanQueueSet;</span>
 102 
 103 typedef int RegionIdx_t;   // needs to hold [ 0..max_regions() )
 104 typedef int CardIdx_t;     // needs to hold [ 0..CardsPerRegion )
 105 
 106 // The G1 STW is alive closure.
 107 // An instance is embedded into the G1CH and used as the
 108 // (optional) _is_alive_non_header closure in the STW
 109 // reference processor. It is also extensively used during
 110 // reference processing during STW evacuation pauses.
 111 class G1STWIsAliveClosure : public BoolObjectClosure {
 112   G1CollectedHeap* _g1h;
 113 public:
 114   G1STWIsAliveClosure(G1CollectedHeap* g1h) : _g1h(g1h) {}
 115   bool do_object_b(oop p);
 116 };
 117 
 118 class G1STWSubjectToDiscoveryClosure : public BoolObjectClosure {
 119   G1CollectedHeap* _g1h;
 120 public:
 121   G1STWSubjectToDiscoveryClosure(G1CollectedHeap* g1h) : _g1h(g1h) {}
</pre>
<hr />
<pre>
 797 
 798   // The g1 remembered set of the heap.
 799   G1RemSet* _rem_set;
 800 
 801   // After a collection pause, convert the regions in the collection set into free
 802   // regions.
 803   void free_collection_set(G1CollectionSet* collection_set, G1EvacuationInfo&amp; evacuation_info, const size_t* surviving_young_words);
 804 
 805   // Abandon the current collection set without recording policy
 806   // statistics or updating free lists.
 807   void abandon_collection_set(G1CollectionSet* collection_set);
 808 
 809   // The concurrent marker (and the thread it runs in.)
 810   G1ConcurrentMark* _cm;
 811   G1ConcurrentMarkThread* _cm_thread;
 812 
 813   // The concurrent refiner.
 814   G1ConcurrentRefine* _cr;
 815 
 816   // The parallel task queues
<span class="line-modified"> 817   RefToScanQueueSet *_task_queues;</span>
 818 
 819   // True iff a evacuation has failed in the current collection.
 820   bool _evacuation_failed;
 821 
 822   EvacuationFailedInfo* _evacuation_failed_info_array;
 823 
 824   // Failed evacuations cause some logical from-space objects to have
 825   // forwarding pointers to themselves.  Reset them.
 826   void remove_self_forwarding_pointers(G1RedirtyCardsQueueSet* rdcqs);
 827 
 828   // Restore the objects in the regions in the collection set after an
 829   // evacuation failure.
 830   void restore_after_evac_failure(G1RedirtyCardsQueueSet* rdcqs);
 831 
 832   PreservedMarksSet _preserved_marks_set;
 833 
 834   // Preserve the mark of &quot;obj&quot;, if necessary, in preparation for its mark
 835   // word being overwritten with a self-forwarding-pointer.
 836   void preserve_mark_during_evac_failure(uint worker_id, oop obj, markWord m);
 837 
</pre>
<hr />
<pre>
 934   // optional but doing so prevents unnecessary additions to
 935   // the discovered lists during reference discovery.
 936   G1STWIsAliveClosure _is_alive_closure_stw;
 937 
 938   G1STWSubjectToDiscoveryClosure _is_subject_to_discovery_stw;
 939 
 940   // The (concurrent marking) reference processor...
 941   ReferenceProcessor* _ref_processor_cm;
 942 
 943   // Instance of the concurrent mark is_alive closure for embedding
 944   // into the Concurrent Marking reference processor as the
 945   // _is_alive_non_header field. Supplying a value for the
 946   // _is_alive_non_header field is optional but doing so prevents
 947   // unnecessary additions to the discovered lists during reference
 948   // discovery.
 949   G1CMIsAliveClosure _is_alive_closure_cm;
 950 
 951   G1CMSubjectToDiscoveryClosure _is_subject_to_discovery_cm;
 952 public:
 953 
<span class="line-modified"> 954   RefToScanQueue *task_queue(uint i) const;</span>
 955 
 956   uint num_task_queues() const;
 957 
 958   // Create a G1CollectedHeap.
 959   // Must call the initialize method afterwards.
 960   // May not return if something goes wrong.
 961   G1CollectedHeap();
 962 
 963 private:
 964   jint initialize_concurrent_refinement();
 965   jint initialize_young_gen_sampling_thread();
 966 public:
 967   // Initialize the G1CollectedHeap to have the initial and
 968   // maximum sizes and remembered and barrier sets
 969   // specified by the policy object.
 970   jint initialize();
 971 
 972   virtual void stop();
 973   virtual void safepoint_synchronize_begin();
 974   virtual void safepoint_synchronize_end();
</pre>
<hr />
<pre>
1461 
1462   // The following two methods are helpful for debugging RSet issues.
1463   void print_cset_rsets() PRODUCT_RETURN;
1464   void print_all_rsets() PRODUCT_RETURN;
1465 
1466   // Used to print information about locations in the hs_err file.
1467   virtual bool print_location(outputStream* st, void* addr) const;
1468 };
1469 
1470 class G1ParEvacuateFollowersClosure : public VoidClosure {
1471 private:
1472   double _start_term;
1473   double _term_time;
1474   size_t _term_attempts;
1475 
1476   void start_term_time() { _term_attempts++; _start_term = os::elapsedTime(); }
1477   void end_term_time() { _term_time += (os::elapsedTime() - _start_term); }
1478 protected:
1479   G1CollectedHeap*              _g1h;
1480   G1ParScanThreadState*         _par_scan_state;
<span class="line-modified">1481   RefToScanQueueSet*            _queues;</span>
1482   TaskTerminator*               _terminator;
1483   G1GCPhaseTimes::GCParPhases   _phase;
1484 
1485   G1ParScanThreadState*   par_scan_state() { return _par_scan_state; }
<span class="line-modified">1486   RefToScanQueueSet*      queues()         { return _queues; }</span>
1487   TaskTerminator*         terminator()     { return _terminator; }
1488 
1489 public:
1490   G1ParEvacuateFollowersClosure(G1CollectedHeap* g1h,
1491                                 G1ParScanThreadState* par_scan_state,
<span class="line-modified">1492                                 RefToScanQueueSet* queues,</span>
1493                                 TaskTerminator* terminator,
1494                                 G1GCPhaseTimes::GCParPhases phase)
1495     : _start_term(0.0), _term_time(0.0), _term_attempts(0),
1496       _g1h(g1h), _par_scan_state(par_scan_state),
1497       _queues(queues), _terminator(terminator), _phase(phase) {}
1498 
1499   void do_void();
1500 
1501   double term_time() const { return _term_time; }
1502   size_t term_attempts() const { return _term_attempts; }
1503 
1504 private:
1505   inline bool offer_termination();
1506 };
1507 
1508 #endif // SHARE_GC_G1_G1COLLECTEDHEAP_HPP
</pre>
</td>
<td>
<hr />
<pre>
  37 #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;
  38 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  39 #include &quot;gc/g1/g1HeapTransition.hpp&quot;
  40 #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
  41 #include &quot;gc/g1/g1HRPrinter.hpp&quot;
  42 #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;
  43 #include &quot;gc/g1/g1MonitoringSupport.hpp&quot;
  44 #include &quot;gc/g1/g1NUMA.hpp&quot;
  45 #include &quot;gc/g1/g1RedirtyCardsQueue.hpp&quot;
  46 #include &quot;gc/g1/g1SurvivorRegions.hpp&quot;
  47 #include &quot;gc/g1/g1YCTypes.hpp&quot;
  48 #include &quot;gc/g1/heapRegionManager.hpp&quot;
  49 #include &quot;gc/g1/heapRegionSet.hpp&quot;
  50 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  51 #include &quot;gc/shared/barrierSet.hpp&quot;
  52 #include &quot;gc/shared/collectedHeap.hpp&quot;
  53 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  54 #include &quot;gc/shared/plab.hpp&quot;
  55 #include &quot;gc/shared/preservedMarks.hpp&quot;
  56 #include &quot;gc/shared/softRefPolicy.hpp&quot;
<span class="line-added">  57 #include &quot;gc/shared/taskqueue.hpp&quot;</span>
  58 #include &quot;memory/memRegion.hpp&quot;
  59 #include &quot;utilities/stack.hpp&quot;
  60 
  61 // A &quot;G1CollectedHeap&quot; is an implementation of a java heap for HotSpot.
  62 // It uses the &quot;Garbage First&quot; heap organization and algorithm, which
  63 // may combine concurrent marking with parallel, incremental compaction of
  64 // heap subsets that will yield large amounts of garbage.
  65 
  66 // Forward declarations
  67 class HeapRegion;
  68 class GenerationSpec;
  69 class G1ParScanThreadState;
  70 class G1ParScanThreadStateSet;
  71 class G1ParScanThreadState;
  72 class MemoryPool;
  73 class MemoryManager;
  74 class ObjectClosure;
  75 class SpaceClosure;
  76 class CompactibleSpaceClosure;
  77 class Space;
</pre>
<hr />
<pre>
  81 class G1HotCardCache;
  82 class G1RemSet;
  83 class G1YoungRemSetSamplingThread;
  84 class G1ConcurrentMark;
  85 class G1ConcurrentMarkThread;
  86 class G1ConcurrentRefine;
  87 class GenerationCounters;
  88 class STWGCTimer;
  89 class G1NewTracer;
  90 class EvacuationFailedInfo;
  91 class nmethod;
  92 class WorkGang;
  93 class G1Allocator;
  94 class G1ArchiveAllocator;
  95 class G1FullGCScope;
  96 class G1HeapVerifier;
  97 class G1HeapSizingPolicy;
  98 class G1HeapSummary;
  99 class G1EvacSummary;
 100 
<span class="line-modified"> 101 typedef OverflowTaskQueue&lt;ScannerTask, mtGC&gt;         ScannerTasksQueue;</span>
<span class="line-modified"> 102 typedef GenericTaskQueueSet&lt;ScannerTasksQueue, mtGC&gt; ScannerTasksQueueSet;</span>
 103 
 104 typedef int RegionIdx_t;   // needs to hold [ 0..max_regions() )
 105 typedef int CardIdx_t;     // needs to hold [ 0..CardsPerRegion )
 106 
 107 // The G1 STW is alive closure.
 108 // An instance is embedded into the G1CH and used as the
 109 // (optional) _is_alive_non_header closure in the STW
 110 // reference processor. It is also extensively used during
 111 // reference processing during STW evacuation pauses.
 112 class G1STWIsAliveClosure : public BoolObjectClosure {
 113   G1CollectedHeap* _g1h;
 114 public:
 115   G1STWIsAliveClosure(G1CollectedHeap* g1h) : _g1h(g1h) {}
 116   bool do_object_b(oop p);
 117 };
 118 
 119 class G1STWSubjectToDiscoveryClosure : public BoolObjectClosure {
 120   G1CollectedHeap* _g1h;
 121 public:
 122   G1STWSubjectToDiscoveryClosure(G1CollectedHeap* g1h) : _g1h(g1h) {}
</pre>
<hr />
<pre>
 798 
 799   // The g1 remembered set of the heap.
 800   G1RemSet* _rem_set;
 801 
 802   // After a collection pause, convert the regions in the collection set into free
 803   // regions.
 804   void free_collection_set(G1CollectionSet* collection_set, G1EvacuationInfo&amp; evacuation_info, const size_t* surviving_young_words);
 805 
 806   // Abandon the current collection set without recording policy
 807   // statistics or updating free lists.
 808   void abandon_collection_set(G1CollectionSet* collection_set);
 809 
 810   // The concurrent marker (and the thread it runs in.)
 811   G1ConcurrentMark* _cm;
 812   G1ConcurrentMarkThread* _cm_thread;
 813 
 814   // The concurrent refiner.
 815   G1ConcurrentRefine* _cr;
 816 
 817   // The parallel task queues
<span class="line-modified"> 818   ScannerTasksQueueSet *_task_queues;</span>
 819 
 820   // True iff a evacuation has failed in the current collection.
 821   bool _evacuation_failed;
 822 
 823   EvacuationFailedInfo* _evacuation_failed_info_array;
 824 
 825   // Failed evacuations cause some logical from-space objects to have
 826   // forwarding pointers to themselves.  Reset them.
 827   void remove_self_forwarding_pointers(G1RedirtyCardsQueueSet* rdcqs);
 828 
 829   // Restore the objects in the regions in the collection set after an
 830   // evacuation failure.
 831   void restore_after_evac_failure(G1RedirtyCardsQueueSet* rdcqs);
 832 
 833   PreservedMarksSet _preserved_marks_set;
 834 
 835   // Preserve the mark of &quot;obj&quot;, if necessary, in preparation for its mark
 836   // word being overwritten with a self-forwarding-pointer.
 837   void preserve_mark_during_evac_failure(uint worker_id, oop obj, markWord m);
 838 
</pre>
<hr />
<pre>
 935   // optional but doing so prevents unnecessary additions to
 936   // the discovered lists during reference discovery.
 937   G1STWIsAliveClosure _is_alive_closure_stw;
 938 
 939   G1STWSubjectToDiscoveryClosure _is_subject_to_discovery_stw;
 940 
 941   // The (concurrent marking) reference processor...
 942   ReferenceProcessor* _ref_processor_cm;
 943 
 944   // Instance of the concurrent mark is_alive closure for embedding
 945   // into the Concurrent Marking reference processor as the
 946   // _is_alive_non_header field. Supplying a value for the
 947   // _is_alive_non_header field is optional but doing so prevents
 948   // unnecessary additions to the discovered lists during reference
 949   // discovery.
 950   G1CMIsAliveClosure _is_alive_closure_cm;
 951 
 952   G1CMSubjectToDiscoveryClosure _is_subject_to_discovery_cm;
 953 public:
 954 
<span class="line-modified"> 955   ScannerTasksQueue* task_queue(uint i) const;</span>
 956 
 957   uint num_task_queues() const;
 958 
 959   // Create a G1CollectedHeap.
 960   // Must call the initialize method afterwards.
 961   // May not return if something goes wrong.
 962   G1CollectedHeap();
 963 
 964 private:
 965   jint initialize_concurrent_refinement();
 966   jint initialize_young_gen_sampling_thread();
 967 public:
 968   // Initialize the G1CollectedHeap to have the initial and
 969   // maximum sizes and remembered and barrier sets
 970   // specified by the policy object.
 971   jint initialize();
 972 
 973   virtual void stop();
 974   virtual void safepoint_synchronize_begin();
 975   virtual void safepoint_synchronize_end();
</pre>
<hr />
<pre>
1462 
1463   // The following two methods are helpful for debugging RSet issues.
1464   void print_cset_rsets() PRODUCT_RETURN;
1465   void print_all_rsets() PRODUCT_RETURN;
1466 
1467   // Used to print information about locations in the hs_err file.
1468   virtual bool print_location(outputStream* st, void* addr) const;
1469 };
1470 
1471 class G1ParEvacuateFollowersClosure : public VoidClosure {
1472 private:
1473   double _start_term;
1474   double _term_time;
1475   size_t _term_attempts;
1476 
1477   void start_term_time() { _term_attempts++; _start_term = os::elapsedTime(); }
1478   void end_term_time() { _term_time += (os::elapsedTime() - _start_term); }
1479 protected:
1480   G1CollectedHeap*              _g1h;
1481   G1ParScanThreadState*         _par_scan_state;
<span class="line-modified">1482   ScannerTasksQueueSet*         _queues;</span>
1483   TaskTerminator*               _terminator;
1484   G1GCPhaseTimes::GCParPhases   _phase;
1485 
1486   G1ParScanThreadState*   par_scan_state() { return _par_scan_state; }
<span class="line-modified">1487   ScannerTasksQueueSet*   queues()         { return _queues; }</span>
1488   TaskTerminator*         terminator()     { return _terminator; }
1489 
1490 public:
1491   G1ParEvacuateFollowersClosure(G1CollectedHeap* g1h,
1492                                 G1ParScanThreadState* par_scan_state,
<span class="line-modified">1493                                 ScannerTasksQueueSet* queues,</span>
1494                                 TaskTerminator* terminator,
1495                                 G1GCPhaseTimes::GCParPhases phase)
1496     : _start_term(0.0), _term_time(0.0), _term_attempts(0),
1497       _g1h(g1h), _par_scan_state(par_scan_state),
1498       _queues(queues), _terminator(terminator), _phase(phase) {}
1499 
1500   void do_void();
1501 
1502   double term_time() const { return _term_time; }
1503   size_t term_attempts() const { return _term_attempts; }
1504 
1505 private:
1506   inline bool offer_termination();
1507 };
1508 
1509 #endif // SHARE_GC_G1_G1COLLECTEDHEAP_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1CollectedHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psScavenge.hpp&quot;
 29 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
 31 #include &quot;gc/shared/genArguments.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 PSYoungGen::PSYoungGen(ReservedSpace rs, size_t initial_size, size_t min_size, size_t max_size) :
 39   _reserved(),
 40   _virtual_space(NULL),
 41   _eden_space(NULL),
 42   _from_space(NULL),
 43   _to_space(NULL),
<a name="1" id="anc1"></a><span class="line-removed"> 44   _init_gen_size(initial_size),</span>
 45   _min_gen_size(min_size),
 46   _max_gen_size(max_size),
 47   _gen_counters(NULL),
 48   _eden_counters(NULL),
 49   _from_counters(NULL),
 50   _to_counters(NULL)
 51 {
<a name="2" id="anc2"></a><span class="line-modified"> 52   initialize(rs, GenAlignment);</span>
 53 }
 54 
<a name="3" id="anc3"></a><span class="line-modified"> 55 void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {</span>
<span class="line-modified"> 56   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);</span>


 57   _virtual_space = new PSVirtualSpace(rs, alignment);
<a name="4" id="anc4"></a><span class="line-modified"> 58   if (!virtual_space()-&gt;expand_by(_init_gen_size)) {</span>
<span class="line-modified"> 59     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;</span>
<span class="line-removed"> 60                                   &quot;object heap&quot;);</span>
 61   }
 62 }
 63 
<a name="5" id="anc5"></a><span class="line-modified"> 64 void PSYoungGen::initialize(ReservedSpace rs, size_t alignment) {</span>
<span class="line-modified"> 65   initialize_virtual_space(rs, alignment);</span>
 66   initialize_work();
 67 }
 68 
 69 void PSYoungGen::initialize_work() {
 70 
 71   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 72                         (HeapWord*)virtual_space()-&gt;high_boundary());
<a name="6" id="anc6"></a>
 73 
 74   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 75                 (HeapWord*)virtual_space()-&gt;high());
 76   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 77 
 78   if (ZapUnusedHeapArea) {
 79     // Mangle newly committed space immediately because it
 80     // can be done here more simply that after the new
 81     // spaces have been computed.
 82     SpaceMangler::mangle_region(cmr);
 83   }
 84 
 85   if (UseNUMA) {
 86     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 87   } else {
 88     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 89   }
 90   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 91   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 92 
 93   // Generation Counters - generation 0, 3 subspaces
<a name="7" id="anc7"></a><span class="line-modified"> 94   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,</span>
<span class="line-modified"> 95                                            _max_gen_size, _virtual_space);</span>
 96 
 97   // Compute maximum space sizes for performance counters
 98   size_t alignment = SpaceAlignment;
 99   size_t size = virtual_space()-&gt;reserved_size();
100 
101   size_t max_survivor_size;
102   size_t max_eden_size;
103 
104   if (UseAdaptiveSizePolicy) {
105     max_survivor_size = size / MinSurvivorRatio;
106 
107     // round the survivor space size down to the nearest alignment
108     // and make sure its size is greater than 0.
109     max_survivor_size = align_down(max_survivor_size, alignment);
110     max_survivor_size = MAX2(max_survivor_size, alignment);
111 
112     // set the maximum size of eden to be the size of the young gen
113     // less two times the minimum survivor size. The minimum survivor
114     // size for UseAdaptiveSizePolicy is one alignment.
115     max_eden_size = size - 2 * alignment;
116   } else {
117     max_survivor_size = size / InitialSurvivorRatio;
118 
119     // round the survivor space size down to the nearest alignment
120     // and make sure its size is greater than 0.
121     max_survivor_size = align_down(max_survivor_size, alignment);
122     max_survivor_size = MAX2(max_survivor_size, alignment);
123 
124     // set the maximum size of eden to be the size of the young gen
125     // less two times the survivor size when the generation is 100%
126     // committed. The minimum survivor size for -UseAdaptiveSizePolicy
127     // is dependent on the committed portion (current capacity) of the
128     // generation - the less space committed, the smaller the survivor
129     // space, possibly as small as an alignment. However, we are interested
130     // in the case where the young generation is 100% committed, as this
131     // is the point where eden reaches its maximum size. At this point,
132     // the size of a survivor space is max_survivor_size.
133     max_eden_size = size - 2 * max_survivor_size;
134   }
135 
136   _eden_counters = new SpaceCounters(&quot;eden&quot;, 0, max_eden_size, _eden_space,
137                                      _gen_counters);
138   _from_counters = new SpaceCounters(&quot;s0&quot;, 1, max_survivor_size, _from_space,
139                                      _gen_counters);
140   _to_counters = new SpaceCounters(&quot;s1&quot;, 2, max_survivor_size, _to_space,
141                                    _gen_counters);
142 
143   compute_initial_space_boundaries();
144 }
145 
146 void PSYoungGen::compute_initial_space_boundaries() {
147   // Compute sizes
148   size_t size = virtual_space()-&gt;committed_size();
149   assert(size &gt;= 3 * SpaceAlignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);
150 
151   size_t survivor_size = size / InitialSurvivorRatio;
152   survivor_size = align_down(survivor_size, SpaceAlignment);
153   // ... but never less than an alignment
154   survivor_size = MAX2(survivor_size, SpaceAlignment);
155 
156   // Young generation is eden + 2 survivor spaces
157   size_t eden_size = size - (2 * survivor_size);
158 
159   // Now go ahead and set &#39;em.
160   set_space_boundaries(eden_size, survivor_size);
161   space_invariants();
162 
163   if (UsePerfData) {
164     _eden_counters-&gt;update_capacity();
165     _from_counters-&gt;update_capacity();
166     _to_counters-&gt;update_capacity();
167   }
168 }
169 
170 void PSYoungGen::set_space_boundaries(size_t eden_size, size_t survivor_size) {
171   assert(eden_size &lt; virtual_space()-&gt;committed_size(), &quot;just checking&quot;);
172   assert(eden_size &gt; 0  &amp;&amp; survivor_size &gt; 0, &quot;just checking&quot;);
173 
174   // Initial layout is Eden, to, from. After swapping survivor spaces,
175   // that leaves us with Eden, from, to, which is step one in our two
176   // step resize-with-live-data procedure.
177   char *eden_start = virtual_space()-&gt;low();
178   char *to_start   = eden_start + eden_size;
179   char *from_start = to_start   + survivor_size;
180   char *from_end   = from_start + survivor_size;
181 
182   assert(from_end == virtual_space()-&gt;high(), &quot;just checking&quot;);
183   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
184   assert(is_object_aligned(to_start),   &quot;checking alignment&quot;);
185   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
186 
187   MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
188   MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
189   MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);
190 
191   eden_space()-&gt;initialize(eden_mr, true, ZapUnusedHeapArea);
192     to_space()-&gt;initialize(to_mr  , true, ZapUnusedHeapArea);
193   from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
194 }
195 
196 #ifndef PRODUCT
197 void PSYoungGen::space_invariants() {
198   // Currently, our eden size cannot shrink to zero
199   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;eden too small&quot;);
200   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;from too small&quot;);
201   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;to too small&quot;);
202 
203   // Relationship of spaces to each other
204   char* eden_start = (char*)eden_space()-&gt;bottom();
205   char* eden_end   = (char*)eden_space()-&gt;end();
206   char* from_start = (char*)from_space()-&gt;bottom();
207   char* from_end   = (char*)from_space()-&gt;end();
208   char* to_start   = (char*)to_space()-&gt;bottom();
209   char* to_end     = (char*)to_space()-&gt;end();
210 
211   guarantee(eden_start &gt;= virtual_space()-&gt;low(), &quot;eden bottom&quot;);
212   guarantee(eden_start &lt; eden_end, &quot;eden space consistency&quot;);
213   guarantee(from_start &lt; from_end, &quot;from space consistency&quot;);
214   guarantee(to_start &lt; to_end, &quot;to space consistency&quot;);
215 
216   // Check whether from space is below to space
217   if (from_start &lt; to_start) {
218     // Eden, from, to
219     guarantee(eden_end &lt;= from_start, &quot;eden/from boundary&quot;);
220     guarantee(from_end &lt;= to_start,   &quot;from/to boundary&quot;);
221     guarantee(to_end &lt;= virtual_space()-&gt;high(), &quot;to end&quot;);
222   } else {
223     // Eden, to, from
224     guarantee(eden_end &lt;= to_start, &quot;eden/to boundary&quot;);
225     guarantee(to_end &lt;= from_start, &quot;to/from boundary&quot;);
226     guarantee(from_end &lt;= virtual_space()-&gt;high(), &quot;from end&quot;);
227   }
228 
229   // More checks that the virtual space is consistent with the spaces
230   assert(virtual_space()-&gt;committed_size() &gt;=
231     (eden_space()-&gt;capacity_in_bytes() +
232      to_space()-&gt;capacity_in_bytes() +
233      from_space()-&gt;capacity_in_bytes()), &quot;Committed size is inconsistent&quot;);
234   assert(virtual_space()-&gt;committed_size() &lt;= virtual_space()-&gt;reserved_size(),
235     &quot;Space invariant&quot;);
236   char* eden_top = (char*)eden_space()-&gt;top();
237   char* from_top = (char*)from_space()-&gt;top();
238   char* to_top = (char*)to_space()-&gt;top();
239   assert(eden_top &lt;= virtual_space()-&gt;high(), &quot;eden top&quot;);
240   assert(from_top &lt;= virtual_space()-&gt;high(), &quot;from top&quot;);
241   assert(to_top &lt;= virtual_space()-&gt;high(), &quot;to top&quot;);
242 
243   virtual_space()-&gt;verify();
244 }
245 #endif
246 
247 void PSYoungGen::resize(size_t eden_size, size_t survivor_size) {
248   // Resize the generation if needed. If the generation resize
249   // reports false, do not attempt to resize the spaces.
250   if (resize_generation(eden_size, survivor_size)) {
251     // Then we lay out the spaces inside the generation
252     resize_spaces(eden_size, survivor_size);
253 
254     space_invariants();
255 
256     log_trace(gc, ergo)(&quot;Young generation size: &quot;
257                         &quot;desired eden: &quot; SIZE_FORMAT &quot; survivor: &quot; SIZE_FORMAT
258                         &quot; used: &quot; SIZE_FORMAT &quot; capacity: &quot; SIZE_FORMAT
259                         &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
260                         eden_size, survivor_size, used_in_bytes(), capacity_in_bytes(),
<a name="8" id="anc8"></a><span class="line-modified">261                         _max_gen_size, min_gen_size());</span>
262   }
263 }
264 
265 
266 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
267   const size_t alignment = virtual_space()-&gt;alignment();
268   size_t orig_size = virtual_space()-&gt;committed_size();
269   bool size_changed = false;
270 
271   // There used to be this guarantee there.
<a name="9" id="anc9"></a><span class="line-modified">272   // guarantee ((eden_size + 2*survivor_size)  &lt;= _max_gen_size, &quot;incorrect input arguments&quot;);</span>
273   // Code below forces this requirement.  In addition the desired eden
274   // size and desired survivor sizes are desired goals and may
275   // exceed the total generation size.
276 
<a name="10" id="anc10"></a><span class="line-modified">277   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);</span>
278 
279   // Adjust new generation size
280   const size_t eden_plus_survivors =
281           align_up(eden_size + 2 * survivor_size, alignment);
<a name="11" id="anc11"></a><span class="line-modified">282   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), max_size());</span>
<span class="line-modified">283   assert(desired_size &lt;= max_size(), &quot;just checking&quot;);</span>
284 
285   if (desired_size &gt; orig_size) {
286     // Grow the generation
287     size_t change = desired_size - orig_size;
288     assert(change % alignment == 0, &quot;just checking&quot;);
289     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
290     if (!virtual_space()-&gt;expand_by(change)) {
291       return false; // Error if we fail to resize!
292     }
293     if (ZapUnusedHeapArea) {
294       // Mangle newly committed space immediately because it
295       // can be done here more simply that after the new
296       // spaces have been computed.
297       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
298       MemRegion mangle_region(prev_high, new_high);
299       SpaceMangler::mangle_region(mangle_region);
300     }
301     size_changed = true;
302   } else if (desired_size &lt; orig_size) {
303     size_t desired_change = orig_size - desired_size;
304     assert(desired_change % alignment == 0, &quot;just checking&quot;);
305 
306     desired_change = limit_gen_shrink(desired_change);
307 
308     if (desired_change &gt; 0) {
309       virtual_space()-&gt;shrink_by(desired_change);
310       reset_survivors_after_shrink();
311 
312       size_changed = true;
313     }
314   } else {
<a name="12" id="anc12"></a><span class="line-modified">315     if (orig_size == gen_size_limit()) {</span>
316       log_trace(gc)(&quot;PSYoung generation size at maximum: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
317     } else if (orig_size == min_gen_size()) {
318       log_trace(gc)(&quot;PSYoung generation size at minium: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
319     }
320   }
321 
322   if (size_changed) {
323     post_resize();
324     log_trace(gc)(&quot;PSYoung generation size changed: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K&quot;,
325                   orig_size/K, virtual_space()-&gt;committed_size()/K);
326   }
327 
328   guarantee(eden_plus_survivors &lt;= virtual_space()-&gt;committed_size() ||
<a name="13" id="anc13"></a><span class="line-modified">329             virtual_space()-&gt;committed_size() == max_size(), &quot;Sanity&quot;);</span>
330 
331   return true;
332 }
333 
334 #ifndef PRODUCT
335 // In the numa case eden is not mangled so a survivor space
336 // moving into a region previously occupied by a survivor
337 // may find an unmangled region.  Also in the PS case eden
338 // to-space and from-space may not touch (i.e., there may be
339 // gaps between them due to movement while resizing the
340 // spaces).  Those gaps must be mangled.
341 void PSYoungGen::mangle_survivors(MutableSpace* s1,
342                                   MemRegion s1MR,
343                                   MutableSpace* s2,
344                                   MemRegion s2MR) {
345   // Check eden and gap between eden and from-space, in deciding
346   // what to mangle in from-space.  Check the gap between from-space
347   // and to-space when deciding what to mangle.
348   //
349   //      +--------+   +----+    +---+
350   //      | eden   |   |s1  |    |s2 |
351   //      +--------+   +----+    +---+
352   //                 +-------+ +-----+
353   //                 |s1MR   | |s2MR |
354   //                 +-------+ +-----+
355   // All of survivor-space is properly mangled so find the
356   // upper bound on the mangling for any portion above current s1.
357   HeapWord* delta_end = MIN2(s1-&gt;bottom(), s1MR.end());
358   MemRegion delta1_left;
359   if (s1MR.start() &lt; delta_end) {
360     delta1_left = MemRegion(s1MR.start(), delta_end);
361     s1-&gt;mangle_region(delta1_left);
362   }
363   // Find any portion to the right of the current s1.
364   HeapWord* delta_start = MAX2(s1-&gt;end(), s1MR.start());
365   MemRegion delta1_right;
366   if (delta_start &lt; s1MR.end()) {
367     delta1_right = MemRegion(delta_start, s1MR.end());
368     s1-&gt;mangle_region(delta1_right);
369   }
370 
371   // Similarly for the second survivor space except that
372   // any of the new region that overlaps with the current
373   // region of the first survivor space has already been
374   // mangled.
375   delta_end = MIN2(s2-&gt;bottom(), s2MR.end());
376   delta_start = MAX2(s2MR.start(), s1-&gt;end());
377   MemRegion delta2_left;
378   if (s2MR.start() &lt; delta_end) {
379     delta2_left = MemRegion(s2MR.start(), delta_end);
380     s2-&gt;mangle_region(delta2_left);
381   }
382   delta_start = MAX2(s2-&gt;end(), s2MR.start());
383   MemRegion delta2_right;
384   if (delta_start &lt; s2MR.end()) {
385     s2-&gt;mangle_region(delta2_right);
386   }
387 
388   // s1
389   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
390     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
391     p2i(s1-&gt;bottom()), p2i(s1-&gt;end()),
392     p2i(s1MR.start()), p2i(s1MR.end()));
393   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
394     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
395     p2i(delta1_left.start()), p2i(delta1_left.end()),
396     p2i(delta1_right.start()), p2i(delta1_right.end()));
397 
398   // s2
399   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
400     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
401     p2i(s2-&gt;bottom()), p2i(s2-&gt;end()),
402     p2i(s2MR.start()), p2i(s2MR.end()));
403   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
404     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
405     p2i(delta2_left.start()), p2i(delta2_left.end()),
406     p2i(delta2_right.start()), p2i(delta2_right.end()));
407 }
408 #endif // NOT PRODUCT
409 
410 void PSYoungGen::resize_spaces(size_t requested_eden_size,
411                                size_t requested_survivor_size) {
412   assert(UseAdaptiveSizePolicy, &quot;sanity check&quot;);
413   assert(requested_eden_size &gt; 0  &amp;&amp; requested_survivor_size &gt; 0,
414          &quot;just checking&quot;);
415 
416   // We require eden and to space to be empty
417   if ((!eden_space()-&gt;is_empty()) || (!to_space()-&gt;is_empty())) {
418     return;
419   }
420 
421   log_trace(gc, ergo)(&quot;PSYoungGen::resize_spaces(requested_eden_size: &quot; SIZE_FORMAT &quot;, requested_survivor_size: &quot; SIZE_FORMAT &quot;)&quot;,
422                       requested_eden_size, requested_survivor_size);
423   log_trace(gc, ergo)(&quot;    eden: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
424                       p2i(eden_space()-&gt;bottom()),
425                       p2i(eden_space()-&gt;end()),
426                       pointer_delta(eden_space()-&gt;end(),
427                                     eden_space()-&gt;bottom(),
428                                     sizeof(char)));
429   log_trace(gc, ergo)(&quot;    from: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
430                       p2i(from_space()-&gt;bottom()),
431                       p2i(from_space()-&gt;end()),
432                       pointer_delta(from_space()-&gt;end(),
433                                     from_space()-&gt;bottom(),
434                                     sizeof(char)));
435   log_trace(gc, ergo)(&quot;      to: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
436                       p2i(to_space()-&gt;bottom()),
437                       p2i(to_space()-&gt;end()),
438                       pointer_delta(  to_space()-&gt;end(),
439                                       to_space()-&gt;bottom(),
440                                       sizeof(char)));
441 
442   // There&#39;s nothing to do if the new sizes are the same as the current
443   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
444       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
445       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
446     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
447     return;
448   }
449 
450   char* eden_start = (char*)eden_space()-&gt;bottom();
451   char* eden_end   = (char*)eden_space()-&gt;end();
452   char* from_start = (char*)from_space()-&gt;bottom();
453   char* from_end   = (char*)from_space()-&gt;end();
454   char* to_start   = (char*)to_space()-&gt;bottom();
455   char* to_end     = (char*)to_space()-&gt;end();
456 
457   const bool maintain_minimum =
458     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
459 
460   bool eden_from_to_order = from_start &lt; to_start;
461   // Check whether from space is below to space
462   if (eden_from_to_order) {
463     // Eden, from, to
464     eden_from_to_order = true;
465     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
466 
467     // Set eden
468     // &quot;requested_eden_size&quot; is a goal for the size of eden
469     // and may not be attainable.  &quot;eden_size&quot; below is
470     // calculated based on the location of from-space and
471     // the goal for the size of eden.  from-space is
472     // fixed in place because it contains live data.
473     // The calculation is done this way to avoid 32bit
474     // overflow (i.e., eden_start + requested_eden_size
475     // may too large for representation in 32bits).
476     size_t eden_size;
477     if (maintain_minimum) {
478       // Only make eden larger than the requested size if
479       // the minimum size of the generation has to be maintained.
480       // This could be done in general but policy at a higher
481       // level is determining a requested size for eden and that
482       // should be honored unless there is a fundamental reason.
483       eden_size = pointer_delta(from_start,
484                                 eden_start,
485                                 sizeof(char));
486     } else {
487       eden_size = MIN2(requested_eden_size,
488                        pointer_delta(from_start, eden_start, sizeof(char)));
489     }
490 
491     eden_end = eden_start + eden_size;
492     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
493 
494     // To may resize into from space as long as it is clear of live data.
495     // From space must remain page aligned, though, so we need to do some
496     // extra calculations.
497 
498     // First calculate an optimal to-space
499     to_end   = (char*)virtual_space()-&gt;high();
500     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
501                                     sizeof(char));
502 
503     // Does the optimal to-space overlap from-space?
504     if (to_start &lt; (char*)from_space()-&gt;end()) {
505       // Calculate the minimum offset possible for from_end
506       size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
507 
508       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
509       if (from_size == 0) {
510         from_size = SpaceAlignment;
511       } else {
512         from_size = align_up(from_size, SpaceAlignment);
513       }
514 
515       from_end = from_start + from_size;
516       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
517 
518       guarantee(from_end &lt;= (char*)from_space()-&gt;end(), &quot;from_end moved to the right&quot;);
519 
520       // Now update to_start with the new from_end
521       to_start = MAX2(from_end, to_start);
522     }
523 
524     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
525 
526     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
527                         p2i(eden_start),
528                         p2i(eden_end),
529                         pointer_delta(eden_end, eden_start, sizeof(char)));
530     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
531                         p2i(from_start),
532                         p2i(from_end),
533                         pointer_delta(from_end, from_start, sizeof(char)));
534     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
535                         p2i(to_start),
536                         p2i(to_end),
537                         pointer_delta(  to_end,   to_start, sizeof(char)));
538   } else {
539     // Eden, to, from
540     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
541 
542     // To space gets priority over eden resizing. Note that we position
543     // to space as if we were able to resize from space, even though from
544     // space is not modified.
545     // Giving eden priority was tried and gave poorer performance.
546     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
547                                     (char*)requested_survivor_size,
548                                     sizeof(char));
549     to_end   = MIN2(to_end, from_start);
550     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
551                                     sizeof(char));
552     // if the space sizes are to be increased by several times then
553     // &#39;to_start&#39; will point beyond the young generation. In this case
554     // &#39;to_start&#39; should be adjusted.
555     to_start = MAX2(to_start, eden_start + SpaceAlignment);
556 
557     // Compute how big eden can be, then adjust end.
558     // See  comments above on calculating eden_end.
559     size_t eden_size;
560     if (maintain_minimum) {
561       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
562     } else {
563       eden_size = MIN2(requested_eden_size,
564                        pointer_delta(to_start, eden_start, sizeof(char)));
565     }
566     eden_end = eden_start + eden_size;
567     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
568 
569     // Could choose to not let eden shrink
570     // to_start = MAX2(to_start, eden_end);
571 
572     // Don&#39;t let eden shrink down to 0 or less.
573     eden_end = MAX2(eden_end, eden_start + SpaceAlignment);
574     to_start = MAX2(to_start, eden_end);
575 
576     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
577                         p2i(eden_start),
578                         p2i(eden_end),
579                         pointer_delta(eden_end, eden_start, sizeof(char)));
580     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
581                         p2i(to_start),
582                         p2i(to_end),
583                         pointer_delta(  to_end,   to_start, sizeof(char)));
584     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
585                         p2i(from_start),
586                         p2i(from_end),
587                         pointer_delta(from_end, from_start, sizeof(char)));
588   }
589 
590 
591   guarantee((HeapWord*)from_start &lt;= from_space()-&gt;bottom(),
592             &quot;from start moved to the right&quot;);
593   guarantee((HeapWord*)from_end &gt;= from_space()-&gt;top(),
594             &quot;from end moved into live data&quot;);
595   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
596   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
597   assert(is_object_aligned(to_start), &quot;checking alignment&quot;);
598 
599   MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);
600   MemRegion toMR  ((HeapWord*)to_start,   (HeapWord*)to_end);
601   MemRegion fromMR((HeapWord*)from_start, (HeapWord*)from_end);
602 
603   // Let&#39;s make sure the call to initialize doesn&#39;t reset &quot;top&quot;!
604   HeapWord* old_from_top = from_space()-&gt;top();
605 
606   // For logging block  below
607   size_t old_from = from_space()-&gt;capacity_in_bytes();
608   size_t old_to   = to_space()-&gt;capacity_in_bytes();
609 
610   if (ZapUnusedHeapArea) {
611     // NUMA is a special case because a numa space is not mangled
612     // in order to not prematurely bind its address to memory to
613     // the wrong memory (i.e., don&#39;t want the GC thread to first
614     // touch the memory).  The survivor spaces are not numa
615     // spaces and are mangled.
616     if (UseNUMA) {
617       if (eden_from_to_order) {
618         mangle_survivors(from_space(), fromMR, to_space(), toMR);
619       } else {
620         mangle_survivors(to_space(), toMR, from_space(), fromMR);
621       }
622     }
623 
624     // If not mangling the spaces, do some checking to verify that
625     // the spaces are already mangled.
626     // The spaces should be correctly mangled at this point so
627     // do some checking here. Note that they are not being mangled
628     // in the calls to initialize().
629     // Must check mangling before the spaces are reshaped.  Otherwise,
630     // the bottom or end of one space may have moved into an area
631     // covered by another space and a failure of the check may
632     // not correctly indicate which space is not properly mangled.
633     HeapWord* limit = (HeapWord*) virtual_space()-&gt;high();
634     eden_space()-&gt;check_mangled_unused_area(limit);
635     from_space()-&gt;check_mangled_unused_area(limit);
636       to_space()-&gt;check_mangled_unused_area(limit);
637   }
638   // When an existing space is being initialized, it is not
639   // mangled because the space has been previously mangled.
640   eden_space()-&gt;initialize(edenMR,
641                            SpaceDecorator::Clear,
642                            SpaceDecorator::DontMangle);
643     to_space()-&gt;initialize(toMR,
644                            SpaceDecorator::Clear,
645                            SpaceDecorator::DontMangle);
646   from_space()-&gt;initialize(fromMR,
647                            SpaceDecorator::DontClear,
648                            SpaceDecorator::DontMangle);
649 
650   assert(from_space()-&gt;top() == old_from_top, &quot;from top changed!&quot;);
651 
652   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::survivor space sizes: collection: %d (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) -&gt; (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) &quot;,
653                       ParallelScavengeHeap::heap()-&gt;total_collections(),
654                       old_from, old_to,
655                       from_space()-&gt;capacity_in_bytes(),
656                       to_space()-&gt;capacity_in_bytes());
657 }
658 
659 void PSYoungGen::swap_spaces() {
660   MutableSpace* s    = from_space();
661   _from_space        = to_space();
662   _to_space          = s;
663 }
664 
665 size_t PSYoungGen::capacity_in_bytes() const {
666   return eden_space()-&gt;capacity_in_bytes()
667        + from_space()-&gt;capacity_in_bytes();  // to_space() is only used during scavenge
668 }
669 
670 
671 size_t PSYoungGen::used_in_bytes() const {
672   return eden_space()-&gt;used_in_bytes()
673        + from_space()-&gt;used_in_bytes();      // to_space() is only used during scavenge
674 }
675 
676 
677 size_t PSYoungGen::free_in_bytes() const {
678   return eden_space()-&gt;free_in_bytes()
679        + from_space()-&gt;free_in_bytes();      // to_space() is only used during scavenge
680 }
681 
682 size_t PSYoungGen::capacity_in_words() const {
683   return eden_space()-&gt;capacity_in_words()
684        + from_space()-&gt;capacity_in_words();  // to_space() is only used during scavenge
685 }
686 
687 
688 size_t PSYoungGen::used_in_words() const {
689   return eden_space()-&gt;used_in_words()
690        + from_space()-&gt;used_in_words();      // to_space() is only used during scavenge
691 }
692 
693 
694 size_t PSYoungGen::free_in_words() const {
695   return eden_space()-&gt;free_in_words()
696        + from_space()-&gt;free_in_words();      // to_space() is only used during scavenge
697 }
698 
699 void PSYoungGen::object_iterate(ObjectClosure* blk) {
700   eden_space()-&gt;object_iterate(blk);
701   from_space()-&gt;object_iterate(blk);
702   to_space()-&gt;object_iterate(blk);
703 }
704 
705 void PSYoungGen::print() const { print_on(tty); }
706 void PSYoungGen::print_on(outputStream* st) const {
707   st-&gt;print(&quot; %-15s&quot;, &quot;PSYoungGen&quot;);
708   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
709              capacity_in_bytes()/K, used_in_bytes()/K);
710   virtual_space()-&gt;print_space_boundaries_on(st);
711   st-&gt;print(&quot;  eden&quot;); eden_space()-&gt;print_on(st);
712   st-&gt;print(&quot;  from&quot;); from_space()-&gt;print_on(st);
713   st-&gt;print(&quot;  to  &quot;); to_space()-&gt;print_on(st);
714 }
715 
716 size_t PSYoungGen::available_to_min_gen() {
717   assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(), &quot;Invariant&quot;);
718   return virtual_space()-&gt;committed_size() - min_gen_size();
719 }
720 
721 // This method assumes that from-space has live data and that
722 // any shrinkage of the young gen is limited by location of
723 // from-space.
724 size_t PSYoungGen::available_to_live() {
725   size_t delta_in_survivor = 0;
726   MutableSpace* space_shrinking = NULL;
727   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
728     space_shrinking = from_space();
729   } else {
730     space_shrinking = to_space();
731   }
732 
733   // Include any space that is committed but not included in
734   // the survivor spaces.
735   assert(((HeapWord*)virtual_space()-&gt;high()) &gt;= space_shrinking-&gt;end(),
736     &quot;Survivor space beyond high end&quot;);
737   size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
738     space_shrinking-&gt;end(), sizeof(char));
739 
740   if (space_shrinking-&gt;is_empty()) {
741     // Don&#39;t let the space shrink to 0
742     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= SpaceAlignment,
743       &quot;Space is too small&quot;);
744     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - SpaceAlignment;
745   } else {
746     delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
747                                       space_shrinking-&gt;top(),
748                                       sizeof(char));
749   }
750 
751   size_t delta_in_bytes = unused_committed + delta_in_survivor;
752   delta_in_bytes = align_down(delta_in_bytes, GenAlignment);
753   return delta_in_bytes;
754 }
755 
756 // Return the number of bytes available for resizing down the young
757 // generation.  This is the minimum of
758 //      input &quot;bytes&quot;
759 //      bytes to the minimum young gen size
760 //      bytes to the size currently being used + some small extra
761 size_t PSYoungGen::limit_gen_shrink(size_t bytes) {
762   // Allow shrinkage into the current eden but keep eden large enough
763   // to maintain the minimum young gen size
764   bytes = MIN3(bytes, available_to_min_gen(), available_to_live());
765   return align_down(bytes, virtual_space()-&gt;alignment());
766 }
767 
768 void PSYoungGen::reset_survivors_after_shrink() {
769   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
770                         (HeapWord*)virtual_space()-&gt;high_boundary());
771   PSScavenge::set_subject_to_discovery_span(_reserved);
772 
773   MutableSpace* space_shrinking = NULL;
774   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
775     space_shrinking = from_space();
776   } else {
777     space_shrinking = to_space();
778   }
779 
780   HeapWord* new_end = (HeapWord*)virtual_space()-&gt;high();
781   assert(new_end &gt;= space_shrinking-&gt;bottom(), &quot;Shrink was too large&quot;);
782   // Was there a shrink of the survivor space?
783   if (new_end &lt; space_shrinking-&gt;end()) {
784     MemRegion mr(space_shrinking-&gt;bottom(), new_end);
785     space_shrinking-&gt;initialize(mr,
786                                 SpaceDecorator::DontClear,
787                                 SpaceDecorator::Mangle);
788   }
789 }
790 
791 // This method currently does not expect to expand into eden (i.e.,
792 // the virtual space boundaries is expected to be consistent
793 // with the eden boundaries..
794 void PSYoungGen::post_resize() {
795   assert_locked_or_safepoint(Heap_lock);
796   assert((eden_space()-&gt;bottom() &lt; to_space()-&gt;bottom()) &amp;&amp;
797          (eden_space()-&gt;bottom() &lt; from_space()-&gt;bottom()),
798          &quot;Eden is assumed to be below the survivor spaces&quot;);
799 
800   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
801                 (HeapWord*)virtual_space()-&gt;high());
802   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
803   space_invariants();
804 }
805 
806 
807 
808 void PSYoungGen::update_counters() {
809   if (UsePerfData) {
810     _eden_counters-&gt;update_all();
811     _from_counters-&gt;update_all();
812     _to_counters-&gt;update_all();
813     _gen_counters-&gt;update_all();
814   }
815 }
816 
817 void PSYoungGen::verify() {
818   eden_space()-&gt;verify();
819   from_space()-&gt;verify();
820   to_space()-&gt;verify();
821 }
822 
823 #ifndef PRODUCT
824 void PSYoungGen::record_spaces_top() {
825   assert(ZapUnusedHeapArea, &quot;Not mangling unused space&quot;);
826   eden_space()-&gt;set_top_for_allocations();
827   from_space()-&gt;set_top_for_allocations();
828   to_space()-&gt;set_top_for_allocations();
829 }
830 #endif
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
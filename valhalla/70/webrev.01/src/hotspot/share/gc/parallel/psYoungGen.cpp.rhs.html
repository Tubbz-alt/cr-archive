<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psScavenge.hpp&quot;
 29 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
 31 #include &quot;gc/shared/genArguments.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 PSYoungGen::PSYoungGen(ReservedSpace rs, size_t initial_size, size_t min_size, size_t max_size) :
 39   _reserved(),
 40   _virtual_space(NULL),
 41   _eden_space(NULL),
 42   _from_space(NULL),
 43   _to_space(NULL),
<a name="1" id="anc1"></a>
 44   _min_gen_size(min_size),
 45   _max_gen_size(max_size),
 46   _gen_counters(NULL),
 47   _eden_counters(NULL),
 48   _from_counters(NULL),
 49   _to_counters(NULL)
 50 {
<a name="2" id="anc2"></a><span class="line-modified"> 51   initialize(rs, initial_size, GenAlignment);</span>
 52 }
 53 
<a name="3" id="anc3"></a><span class="line-modified"> 54 void PSYoungGen::initialize_virtual_space(ReservedSpace rs,</span>
<span class="line-modified"> 55                                           size_t initial_size,</span>
<span class="line-added"> 56                                           size_t alignment) {</span>
<span class="line-added"> 57   assert(initial_size != 0, &quot;Should have a finite size&quot;);</span>
 58   _virtual_space = new PSVirtualSpace(rs, alignment);
<a name="4" id="anc4"></a><span class="line-modified"> 59   if (!virtual_space()-&gt;expand_by(initial_size)) {</span>
<span class="line-modified"> 60     vm_exit_during_initialization(&quot;Could not reserve enough space for object heap&quot;);</span>

 61   }
 62 }
 63 
<a name="5" id="anc5"></a><span class="line-modified"> 64 void PSYoungGen::initialize(ReservedSpace rs, size_t initial_size, size_t alignment) {</span>
<span class="line-modified"> 65   initialize_virtual_space(rs, initial_size, alignment);</span>
 66   initialize_work();
 67 }
 68 
 69 void PSYoungGen::initialize_work() {
 70 
 71   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 72                         (HeapWord*)virtual_space()-&gt;high_boundary());
<a name="6" id="anc6"></a><span class="line-added"> 73   assert(_reserved.byte_size() == max_gen_size(), &quot;invariant&quot;);</span>
 74 
 75   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 76                 (HeapWord*)virtual_space()-&gt;high());
 77   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 78 
 79   if (ZapUnusedHeapArea) {
 80     // Mangle newly committed space immediately because it
 81     // can be done here more simply that after the new
 82     // spaces have been computed.
 83     SpaceMangler::mangle_region(cmr);
 84   }
 85 
 86   if (UseNUMA) {
 87     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 88   } else {
 89     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 90   }
 91   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 92   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 93 
 94   // Generation Counters - generation 0, 3 subspaces
<a name="7" id="anc7"></a><span class="line-modified"> 95   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, min_gen_size(),</span>
<span class="line-modified"> 96                                            max_gen_size(), virtual_space());</span>
 97 
 98   // Compute maximum space sizes for performance counters
 99   size_t alignment = SpaceAlignment;
100   size_t size = virtual_space()-&gt;reserved_size();
101 
102   size_t max_survivor_size;
103   size_t max_eden_size;
104 
105   if (UseAdaptiveSizePolicy) {
106     max_survivor_size = size / MinSurvivorRatio;
107 
108     // round the survivor space size down to the nearest alignment
109     // and make sure its size is greater than 0.
110     max_survivor_size = align_down(max_survivor_size, alignment);
111     max_survivor_size = MAX2(max_survivor_size, alignment);
112 
113     // set the maximum size of eden to be the size of the young gen
114     // less two times the minimum survivor size. The minimum survivor
115     // size for UseAdaptiveSizePolicy is one alignment.
116     max_eden_size = size - 2 * alignment;
117   } else {
118     max_survivor_size = size / InitialSurvivorRatio;
119 
120     // round the survivor space size down to the nearest alignment
121     // and make sure its size is greater than 0.
122     max_survivor_size = align_down(max_survivor_size, alignment);
123     max_survivor_size = MAX2(max_survivor_size, alignment);
124 
125     // set the maximum size of eden to be the size of the young gen
126     // less two times the survivor size when the generation is 100%
127     // committed. The minimum survivor size for -UseAdaptiveSizePolicy
128     // is dependent on the committed portion (current capacity) of the
129     // generation - the less space committed, the smaller the survivor
130     // space, possibly as small as an alignment. However, we are interested
131     // in the case where the young generation is 100% committed, as this
132     // is the point where eden reaches its maximum size. At this point,
133     // the size of a survivor space is max_survivor_size.
134     max_eden_size = size - 2 * max_survivor_size;
135   }
136 
137   _eden_counters = new SpaceCounters(&quot;eden&quot;, 0, max_eden_size, _eden_space,
138                                      _gen_counters);
139   _from_counters = new SpaceCounters(&quot;s0&quot;, 1, max_survivor_size, _from_space,
140                                      _gen_counters);
141   _to_counters = new SpaceCounters(&quot;s1&quot;, 2, max_survivor_size, _to_space,
142                                    _gen_counters);
143 
144   compute_initial_space_boundaries();
145 }
146 
147 void PSYoungGen::compute_initial_space_boundaries() {
148   // Compute sizes
149   size_t size = virtual_space()-&gt;committed_size();
150   assert(size &gt;= 3 * SpaceAlignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);
151 
152   size_t survivor_size = size / InitialSurvivorRatio;
153   survivor_size = align_down(survivor_size, SpaceAlignment);
154   // ... but never less than an alignment
155   survivor_size = MAX2(survivor_size, SpaceAlignment);
156 
157   // Young generation is eden + 2 survivor spaces
158   size_t eden_size = size - (2 * survivor_size);
159 
160   // Now go ahead and set &#39;em.
161   set_space_boundaries(eden_size, survivor_size);
162   space_invariants();
163 
164   if (UsePerfData) {
165     _eden_counters-&gt;update_capacity();
166     _from_counters-&gt;update_capacity();
167     _to_counters-&gt;update_capacity();
168   }
169 }
170 
171 void PSYoungGen::set_space_boundaries(size_t eden_size, size_t survivor_size) {
172   assert(eden_size &lt; virtual_space()-&gt;committed_size(), &quot;just checking&quot;);
173   assert(eden_size &gt; 0  &amp;&amp; survivor_size &gt; 0, &quot;just checking&quot;);
174 
175   // Initial layout is Eden, to, from. After swapping survivor spaces,
176   // that leaves us with Eden, from, to, which is step one in our two
177   // step resize-with-live-data procedure.
178   char *eden_start = virtual_space()-&gt;low();
179   char *to_start   = eden_start + eden_size;
180   char *from_start = to_start   + survivor_size;
181   char *from_end   = from_start + survivor_size;
182 
183   assert(from_end == virtual_space()-&gt;high(), &quot;just checking&quot;);
184   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
185   assert(is_object_aligned(to_start),   &quot;checking alignment&quot;);
186   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
187 
188   MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
189   MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
190   MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);
191 
192   eden_space()-&gt;initialize(eden_mr, true, ZapUnusedHeapArea);
193     to_space()-&gt;initialize(to_mr  , true, ZapUnusedHeapArea);
194   from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
195 }
196 
197 #ifndef PRODUCT
198 void PSYoungGen::space_invariants() {
199   // Currently, our eden size cannot shrink to zero
200   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;eden too small&quot;);
201   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;from too small&quot;);
202   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;to too small&quot;);
203 
204   // Relationship of spaces to each other
205   char* eden_start = (char*)eden_space()-&gt;bottom();
206   char* eden_end   = (char*)eden_space()-&gt;end();
207   char* from_start = (char*)from_space()-&gt;bottom();
208   char* from_end   = (char*)from_space()-&gt;end();
209   char* to_start   = (char*)to_space()-&gt;bottom();
210   char* to_end     = (char*)to_space()-&gt;end();
211 
212   guarantee(eden_start &gt;= virtual_space()-&gt;low(), &quot;eden bottom&quot;);
213   guarantee(eden_start &lt; eden_end, &quot;eden space consistency&quot;);
214   guarantee(from_start &lt; from_end, &quot;from space consistency&quot;);
215   guarantee(to_start &lt; to_end, &quot;to space consistency&quot;);
216 
217   // Check whether from space is below to space
218   if (from_start &lt; to_start) {
219     // Eden, from, to
220     guarantee(eden_end &lt;= from_start, &quot;eden/from boundary&quot;);
221     guarantee(from_end &lt;= to_start,   &quot;from/to boundary&quot;);
222     guarantee(to_end &lt;= virtual_space()-&gt;high(), &quot;to end&quot;);
223   } else {
224     // Eden, to, from
225     guarantee(eden_end &lt;= to_start, &quot;eden/to boundary&quot;);
226     guarantee(to_end &lt;= from_start, &quot;to/from boundary&quot;);
227     guarantee(from_end &lt;= virtual_space()-&gt;high(), &quot;from end&quot;);
228   }
229 
230   // More checks that the virtual space is consistent with the spaces
231   assert(virtual_space()-&gt;committed_size() &gt;=
232     (eden_space()-&gt;capacity_in_bytes() +
233      to_space()-&gt;capacity_in_bytes() +
234      from_space()-&gt;capacity_in_bytes()), &quot;Committed size is inconsistent&quot;);
235   assert(virtual_space()-&gt;committed_size() &lt;= virtual_space()-&gt;reserved_size(),
236     &quot;Space invariant&quot;);
237   char* eden_top = (char*)eden_space()-&gt;top();
238   char* from_top = (char*)from_space()-&gt;top();
239   char* to_top = (char*)to_space()-&gt;top();
240   assert(eden_top &lt;= virtual_space()-&gt;high(), &quot;eden top&quot;);
241   assert(from_top &lt;= virtual_space()-&gt;high(), &quot;from top&quot;);
242   assert(to_top &lt;= virtual_space()-&gt;high(), &quot;to top&quot;);
243 
244   virtual_space()-&gt;verify();
245 }
246 #endif
247 
248 void PSYoungGen::resize(size_t eden_size, size_t survivor_size) {
249   // Resize the generation if needed. If the generation resize
250   // reports false, do not attempt to resize the spaces.
251   if (resize_generation(eden_size, survivor_size)) {
252     // Then we lay out the spaces inside the generation
253     resize_spaces(eden_size, survivor_size);
254 
255     space_invariants();
256 
257     log_trace(gc, ergo)(&quot;Young generation size: &quot;
258                         &quot;desired eden: &quot; SIZE_FORMAT &quot; survivor: &quot; SIZE_FORMAT
259                         &quot; used: &quot; SIZE_FORMAT &quot; capacity: &quot; SIZE_FORMAT
260                         &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
261                         eden_size, survivor_size, used_in_bytes(), capacity_in_bytes(),
<a name="8" id="anc8"></a><span class="line-modified">262                         max_gen_size(), min_gen_size());</span>
263   }
264 }
265 
266 
267 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
268   const size_t alignment = virtual_space()-&gt;alignment();
269   size_t orig_size = virtual_space()-&gt;committed_size();
270   bool size_changed = false;
271 
272   // There used to be this guarantee there.
<a name="9" id="anc9"></a><span class="line-modified">273   // guarantee ((eden_size + 2*survivor_size)  &lt;= max_gen_size(), &quot;incorrect input arguments&quot;);</span>
274   // Code below forces this requirement.  In addition the desired eden
275   // size and desired survivor sizes are desired goals and may
276   // exceed the total generation size.
277 
<a name="10" id="anc10"></a><span class="line-modified">278   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_gen_size(), &quot;just checking&quot;);</span>
279 
280   // Adjust new generation size
281   const size_t eden_plus_survivors =
282           align_up(eden_size + 2 * survivor_size, alignment);
<a name="11" id="anc11"></a><span class="line-modified">283   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), max_gen_size());</span>
<span class="line-modified">284   assert(desired_size &lt;= max_gen_size(), &quot;just checking&quot;);</span>
285 
286   if (desired_size &gt; orig_size) {
287     // Grow the generation
288     size_t change = desired_size - orig_size;
289     assert(change % alignment == 0, &quot;just checking&quot;);
290     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
291     if (!virtual_space()-&gt;expand_by(change)) {
292       return false; // Error if we fail to resize!
293     }
294     if (ZapUnusedHeapArea) {
295       // Mangle newly committed space immediately because it
296       // can be done here more simply that after the new
297       // spaces have been computed.
298       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
299       MemRegion mangle_region(prev_high, new_high);
300       SpaceMangler::mangle_region(mangle_region);
301     }
302     size_changed = true;
303   } else if (desired_size &lt; orig_size) {
304     size_t desired_change = orig_size - desired_size;
305     assert(desired_change % alignment == 0, &quot;just checking&quot;);
306 
307     desired_change = limit_gen_shrink(desired_change);
308 
309     if (desired_change &gt; 0) {
310       virtual_space()-&gt;shrink_by(desired_change);
311       reset_survivors_after_shrink();
312 
313       size_changed = true;
314     }
315   } else {
<a name="12" id="anc12"></a><span class="line-modified">316     if (orig_size == max_gen_size()) {</span>
317       log_trace(gc)(&quot;PSYoung generation size at maximum: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
318     } else if (orig_size == min_gen_size()) {
319       log_trace(gc)(&quot;PSYoung generation size at minium: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
320     }
321   }
322 
323   if (size_changed) {
324     post_resize();
325     log_trace(gc)(&quot;PSYoung generation size changed: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K&quot;,
326                   orig_size/K, virtual_space()-&gt;committed_size()/K);
327   }
328 
329   guarantee(eden_plus_survivors &lt;= virtual_space()-&gt;committed_size() ||
<a name="13" id="anc13"></a><span class="line-modified">330             virtual_space()-&gt;committed_size() == max_gen_size(), &quot;Sanity&quot;);</span>
331 
332   return true;
333 }
334 
335 #ifndef PRODUCT
336 // In the numa case eden is not mangled so a survivor space
337 // moving into a region previously occupied by a survivor
338 // may find an unmangled region.  Also in the PS case eden
339 // to-space and from-space may not touch (i.e., there may be
340 // gaps between them due to movement while resizing the
341 // spaces).  Those gaps must be mangled.
342 void PSYoungGen::mangle_survivors(MutableSpace* s1,
343                                   MemRegion s1MR,
344                                   MutableSpace* s2,
345                                   MemRegion s2MR) {
346   // Check eden and gap between eden and from-space, in deciding
347   // what to mangle in from-space.  Check the gap between from-space
348   // and to-space when deciding what to mangle.
349   //
350   //      +--------+   +----+    +---+
351   //      | eden   |   |s1  |    |s2 |
352   //      +--------+   +----+    +---+
353   //                 +-------+ +-----+
354   //                 |s1MR   | |s2MR |
355   //                 +-------+ +-----+
356   // All of survivor-space is properly mangled so find the
357   // upper bound on the mangling for any portion above current s1.
358   HeapWord* delta_end = MIN2(s1-&gt;bottom(), s1MR.end());
359   MemRegion delta1_left;
360   if (s1MR.start() &lt; delta_end) {
361     delta1_left = MemRegion(s1MR.start(), delta_end);
362     s1-&gt;mangle_region(delta1_left);
363   }
364   // Find any portion to the right of the current s1.
365   HeapWord* delta_start = MAX2(s1-&gt;end(), s1MR.start());
366   MemRegion delta1_right;
367   if (delta_start &lt; s1MR.end()) {
368     delta1_right = MemRegion(delta_start, s1MR.end());
369     s1-&gt;mangle_region(delta1_right);
370   }
371 
372   // Similarly for the second survivor space except that
373   // any of the new region that overlaps with the current
374   // region of the first survivor space has already been
375   // mangled.
376   delta_end = MIN2(s2-&gt;bottom(), s2MR.end());
377   delta_start = MAX2(s2MR.start(), s1-&gt;end());
378   MemRegion delta2_left;
379   if (s2MR.start() &lt; delta_end) {
380     delta2_left = MemRegion(s2MR.start(), delta_end);
381     s2-&gt;mangle_region(delta2_left);
382   }
383   delta_start = MAX2(s2-&gt;end(), s2MR.start());
384   MemRegion delta2_right;
385   if (delta_start &lt; s2MR.end()) {
386     s2-&gt;mangle_region(delta2_right);
387   }
388 
389   // s1
390   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
391     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
392     p2i(s1-&gt;bottom()), p2i(s1-&gt;end()),
393     p2i(s1MR.start()), p2i(s1MR.end()));
394   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
395     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
396     p2i(delta1_left.start()), p2i(delta1_left.end()),
397     p2i(delta1_right.start()), p2i(delta1_right.end()));
398 
399   // s2
400   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
401     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
402     p2i(s2-&gt;bottom()), p2i(s2-&gt;end()),
403     p2i(s2MR.start()), p2i(s2MR.end()));
404   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
405     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
406     p2i(delta2_left.start()), p2i(delta2_left.end()),
407     p2i(delta2_right.start()), p2i(delta2_right.end()));
408 }
409 #endif // NOT PRODUCT
410 
411 void PSYoungGen::resize_spaces(size_t requested_eden_size,
412                                size_t requested_survivor_size) {
413   assert(UseAdaptiveSizePolicy, &quot;sanity check&quot;);
414   assert(requested_eden_size &gt; 0  &amp;&amp; requested_survivor_size &gt; 0,
415          &quot;just checking&quot;);
416 
417   // We require eden and to space to be empty
418   if ((!eden_space()-&gt;is_empty()) || (!to_space()-&gt;is_empty())) {
419     return;
420   }
421 
422   log_trace(gc, ergo)(&quot;PSYoungGen::resize_spaces(requested_eden_size: &quot; SIZE_FORMAT &quot;, requested_survivor_size: &quot; SIZE_FORMAT &quot;)&quot;,
423                       requested_eden_size, requested_survivor_size);
424   log_trace(gc, ergo)(&quot;    eden: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
425                       p2i(eden_space()-&gt;bottom()),
426                       p2i(eden_space()-&gt;end()),
427                       pointer_delta(eden_space()-&gt;end(),
428                                     eden_space()-&gt;bottom(),
429                                     sizeof(char)));
430   log_trace(gc, ergo)(&quot;    from: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
431                       p2i(from_space()-&gt;bottom()),
432                       p2i(from_space()-&gt;end()),
433                       pointer_delta(from_space()-&gt;end(),
434                                     from_space()-&gt;bottom(),
435                                     sizeof(char)));
436   log_trace(gc, ergo)(&quot;      to: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
437                       p2i(to_space()-&gt;bottom()),
438                       p2i(to_space()-&gt;end()),
439                       pointer_delta(  to_space()-&gt;end(),
440                                       to_space()-&gt;bottom(),
441                                       sizeof(char)));
442 
443   // There&#39;s nothing to do if the new sizes are the same as the current
444   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
445       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
446       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
447     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
448     return;
449   }
450 
451   char* eden_start = (char*)eden_space()-&gt;bottom();
452   char* eden_end   = (char*)eden_space()-&gt;end();
453   char* from_start = (char*)from_space()-&gt;bottom();
454   char* from_end   = (char*)from_space()-&gt;end();
455   char* to_start   = (char*)to_space()-&gt;bottom();
456   char* to_end     = (char*)to_space()-&gt;end();
457 
458   const bool maintain_minimum =
459     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
460 
461   bool eden_from_to_order = from_start &lt; to_start;
462   // Check whether from space is below to space
463   if (eden_from_to_order) {
464     // Eden, from, to
465     eden_from_to_order = true;
466     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
467 
468     // Set eden
469     // &quot;requested_eden_size&quot; is a goal for the size of eden
470     // and may not be attainable.  &quot;eden_size&quot; below is
471     // calculated based on the location of from-space and
472     // the goal for the size of eden.  from-space is
473     // fixed in place because it contains live data.
474     // The calculation is done this way to avoid 32bit
475     // overflow (i.e., eden_start + requested_eden_size
476     // may too large for representation in 32bits).
477     size_t eden_size;
478     if (maintain_minimum) {
479       // Only make eden larger than the requested size if
480       // the minimum size of the generation has to be maintained.
481       // This could be done in general but policy at a higher
482       // level is determining a requested size for eden and that
483       // should be honored unless there is a fundamental reason.
484       eden_size = pointer_delta(from_start,
485                                 eden_start,
486                                 sizeof(char));
487     } else {
488       eden_size = MIN2(requested_eden_size,
489                        pointer_delta(from_start, eden_start, sizeof(char)));
490     }
491 
492     eden_end = eden_start + eden_size;
493     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
494 
495     // To may resize into from space as long as it is clear of live data.
496     // From space must remain page aligned, though, so we need to do some
497     // extra calculations.
498 
499     // First calculate an optimal to-space
500     to_end   = (char*)virtual_space()-&gt;high();
501     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
502                                     sizeof(char));
503 
504     // Does the optimal to-space overlap from-space?
505     if (to_start &lt; (char*)from_space()-&gt;end()) {
506       // Calculate the minimum offset possible for from_end
507       size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
508 
509       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
510       if (from_size == 0) {
511         from_size = SpaceAlignment;
512       } else {
513         from_size = align_up(from_size, SpaceAlignment);
514       }
515 
516       from_end = from_start + from_size;
517       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
518 
519       guarantee(from_end &lt;= (char*)from_space()-&gt;end(), &quot;from_end moved to the right&quot;);
520 
521       // Now update to_start with the new from_end
522       to_start = MAX2(from_end, to_start);
523     }
524 
525     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
526 
527     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
528                         p2i(eden_start),
529                         p2i(eden_end),
530                         pointer_delta(eden_end, eden_start, sizeof(char)));
531     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
532                         p2i(from_start),
533                         p2i(from_end),
534                         pointer_delta(from_end, from_start, sizeof(char)));
535     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
536                         p2i(to_start),
537                         p2i(to_end),
538                         pointer_delta(  to_end,   to_start, sizeof(char)));
539   } else {
540     // Eden, to, from
541     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
542 
543     // To space gets priority over eden resizing. Note that we position
544     // to space as if we were able to resize from space, even though from
545     // space is not modified.
546     // Giving eden priority was tried and gave poorer performance.
547     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
548                                     (char*)requested_survivor_size,
549                                     sizeof(char));
550     to_end   = MIN2(to_end, from_start);
551     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
552                                     sizeof(char));
553     // if the space sizes are to be increased by several times then
554     // &#39;to_start&#39; will point beyond the young generation. In this case
555     // &#39;to_start&#39; should be adjusted.
556     to_start = MAX2(to_start, eden_start + SpaceAlignment);
557 
558     // Compute how big eden can be, then adjust end.
559     // See  comments above on calculating eden_end.
560     size_t eden_size;
561     if (maintain_minimum) {
562       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
563     } else {
564       eden_size = MIN2(requested_eden_size,
565                        pointer_delta(to_start, eden_start, sizeof(char)));
566     }
567     eden_end = eden_start + eden_size;
568     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
569 
570     // Could choose to not let eden shrink
571     // to_start = MAX2(to_start, eden_end);
572 
573     // Don&#39;t let eden shrink down to 0 or less.
574     eden_end = MAX2(eden_end, eden_start + SpaceAlignment);
575     to_start = MAX2(to_start, eden_end);
576 
577     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
578                         p2i(eden_start),
579                         p2i(eden_end),
580                         pointer_delta(eden_end, eden_start, sizeof(char)));
581     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
582                         p2i(to_start),
583                         p2i(to_end),
584                         pointer_delta(  to_end,   to_start, sizeof(char)));
585     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
586                         p2i(from_start),
587                         p2i(from_end),
588                         pointer_delta(from_end, from_start, sizeof(char)));
589   }
590 
591 
592   guarantee((HeapWord*)from_start &lt;= from_space()-&gt;bottom(),
593             &quot;from start moved to the right&quot;);
594   guarantee((HeapWord*)from_end &gt;= from_space()-&gt;top(),
595             &quot;from end moved into live data&quot;);
596   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
597   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
598   assert(is_object_aligned(to_start), &quot;checking alignment&quot;);
599 
600   MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);
601   MemRegion toMR  ((HeapWord*)to_start,   (HeapWord*)to_end);
602   MemRegion fromMR((HeapWord*)from_start, (HeapWord*)from_end);
603 
604   // Let&#39;s make sure the call to initialize doesn&#39;t reset &quot;top&quot;!
605   HeapWord* old_from_top = from_space()-&gt;top();
606 
607   // For logging block  below
608   size_t old_from = from_space()-&gt;capacity_in_bytes();
609   size_t old_to   = to_space()-&gt;capacity_in_bytes();
610 
611   if (ZapUnusedHeapArea) {
612     // NUMA is a special case because a numa space is not mangled
613     // in order to not prematurely bind its address to memory to
614     // the wrong memory (i.e., don&#39;t want the GC thread to first
615     // touch the memory).  The survivor spaces are not numa
616     // spaces and are mangled.
617     if (UseNUMA) {
618       if (eden_from_to_order) {
619         mangle_survivors(from_space(), fromMR, to_space(), toMR);
620       } else {
621         mangle_survivors(to_space(), toMR, from_space(), fromMR);
622       }
623     }
624 
625     // If not mangling the spaces, do some checking to verify that
626     // the spaces are already mangled.
627     // The spaces should be correctly mangled at this point so
628     // do some checking here. Note that they are not being mangled
629     // in the calls to initialize().
630     // Must check mangling before the spaces are reshaped.  Otherwise,
631     // the bottom or end of one space may have moved into an area
632     // covered by another space and a failure of the check may
633     // not correctly indicate which space is not properly mangled.
634     HeapWord* limit = (HeapWord*) virtual_space()-&gt;high();
635     eden_space()-&gt;check_mangled_unused_area(limit);
636     from_space()-&gt;check_mangled_unused_area(limit);
637       to_space()-&gt;check_mangled_unused_area(limit);
638   }
639   // When an existing space is being initialized, it is not
640   // mangled because the space has been previously mangled.
641   eden_space()-&gt;initialize(edenMR,
642                            SpaceDecorator::Clear,
643                            SpaceDecorator::DontMangle);
644     to_space()-&gt;initialize(toMR,
645                            SpaceDecorator::Clear,
646                            SpaceDecorator::DontMangle);
647   from_space()-&gt;initialize(fromMR,
648                            SpaceDecorator::DontClear,
649                            SpaceDecorator::DontMangle);
650 
651   assert(from_space()-&gt;top() == old_from_top, &quot;from top changed!&quot;);
652 
653   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::survivor space sizes: collection: %d (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) -&gt; (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) &quot;,
654                       ParallelScavengeHeap::heap()-&gt;total_collections(),
655                       old_from, old_to,
656                       from_space()-&gt;capacity_in_bytes(),
657                       to_space()-&gt;capacity_in_bytes());
658 }
659 
660 void PSYoungGen::swap_spaces() {
661   MutableSpace* s    = from_space();
662   _from_space        = to_space();
663   _to_space          = s;
664 }
665 
666 size_t PSYoungGen::capacity_in_bytes() const {
667   return eden_space()-&gt;capacity_in_bytes()
668        + from_space()-&gt;capacity_in_bytes();  // to_space() is only used during scavenge
669 }
670 
671 
672 size_t PSYoungGen::used_in_bytes() const {
673   return eden_space()-&gt;used_in_bytes()
674        + from_space()-&gt;used_in_bytes();      // to_space() is only used during scavenge
675 }
676 
677 
678 size_t PSYoungGen::free_in_bytes() const {
679   return eden_space()-&gt;free_in_bytes()
680        + from_space()-&gt;free_in_bytes();      // to_space() is only used during scavenge
681 }
682 
683 size_t PSYoungGen::capacity_in_words() const {
684   return eden_space()-&gt;capacity_in_words()
685        + from_space()-&gt;capacity_in_words();  // to_space() is only used during scavenge
686 }
687 
688 
689 size_t PSYoungGen::used_in_words() const {
690   return eden_space()-&gt;used_in_words()
691        + from_space()-&gt;used_in_words();      // to_space() is only used during scavenge
692 }
693 
694 
695 size_t PSYoungGen::free_in_words() const {
696   return eden_space()-&gt;free_in_words()
697        + from_space()-&gt;free_in_words();      // to_space() is only used during scavenge
698 }
699 
700 void PSYoungGen::object_iterate(ObjectClosure* blk) {
701   eden_space()-&gt;object_iterate(blk);
702   from_space()-&gt;object_iterate(blk);
703   to_space()-&gt;object_iterate(blk);
704 }
705 
706 void PSYoungGen::print() const { print_on(tty); }
707 void PSYoungGen::print_on(outputStream* st) const {
708   st-&gt;print(&quot; %-15s&quot;, &quot;PSYoungGen&quot;);
709   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
710              capacity_in_bytes()/K, used_in_bytes()/K);
711   virtual_space()-&gt;print_space_boundaries_on(st);
712   st-&gt;print(&quot;  eden&quot;); eden_space()-&gt;print_on(st);
713   st-&gt;print(&quot;  from&quot;); from_space()-&gt;print_on(st);
714   st-&gt;print(&quot;  to  &quot;); to_space()-&gt;print_on(st);
715 }
716 
717 size_t PSYoungGen::available_to_min_gen() {
718   assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(), &quot;Invariant&quot;);
719   return virtual_space()-&gt;committed_size() - min_gen_size();
720 }
721 
722 // This method assumes that from-space has live data and that
723 // any shrinkage of the young gen is limited by location of
724 // from-space.
725 size_t PSYoungGen::available_to_live() {
726   size_t delta_in_survivor = 0;
727   MutableSpace* space_shrinking = NULL;
728   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
729     space_shrinking = from_space();
730   } else {
731     space_shrinking = to_space();
732   }
733 
734   // Include any space that is committed but not included in
735   // the survivor spaces.
736   assert(((HeapWord*)virtual_space()-&gt;high()) &gt;= space_shrinking-&gt;end(),
737     &quot;Survivor space beyond high end&quot;);
738   size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
739     space_shrinking-&gt;end(), sizeof(char));
740 
741   if (space_shrinking-&gt;is_empty()) {
742     // Don&#39;t let the space shrink to 0
743     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= SpaceAlignment,
744       &quot;Space is too small&quot;);
745     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - SpaceAlignment;
746   } else {
747     delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
748                                       space_shrinking-&gt;top(),
749                                       sizeof(char));
750   }
751 
752   size_t delta_in_bytes = unused_committed + delta_in_survivor;
753   delta_in_bytes = align_down(delta_in_bytes, GenAlignment);
754   return delta_in_bytes;
755 }
756 
757 // Return the number of bytes available for resizing down the young
758 // generation.  This is the minimum of
759 //      input &quot;bytes&quot;
760 //      bytes to the minimum young gen size
761 //      bytes to the size currently being used + some small extra
762 size_t PSYoungGen::limit_gen_shrink(size_t bytes) {
763   // Allow shrinkage into the current eden but keep eden large enough
764   // to maintain the minimum young gen size
765   bytes = MIN3(bytes, available_to_min_gen(), available_to_live());
766   return align_down(bytes, virtual_space()-&gt;alignment());
767 }
768 
769 void PSYoungGen::reset_survivors_after_shrink() {
770   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
771                         (HeapWord*)virtual_space()-&gt;high_boundary());
772   PSScavenge::set_subject_to_discovery_span(_reserved);
773 
774   MutableSpace* space_shrinking = NULL;
775   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
776     space_shrinking = from_space();
777   } else {
778     space_shrinking = to_space();
779   }
780 
781   HeapWord* new_end = (HeapWord*)virtual_space()-&gt;high();
782   assert(new_end &gt;= space_shrinking-&gt;bottom(), &quot;Shrink was too large&quot;);
783   // Was there a shrink of the survivor space?
784   if (new_end &lt; space_shrinking-&gt;end()) {
785     MemRegion mr(space_shrinking-&gt;bottom(), new_end);
786     space_shrinking-&gt;initialize(mr,
787                                 SpaceDecorator::DontClear,
788                                 SpaceDecorator::Mangle);
789   }
790 }
791 
792 // This method currently does not expect to expand into eden (i.e.,
793 // the virtual space boundaries is expected to be consistent
794 // with the eden boundaries..
795 void PSYoungGen::post_resize() {
796   assert_locked_or_safepoint(Heap_lock);
797   assert((eden_space()-&gt;bottom() &lt; to_space()-&gt;bottom()) &amp;&amp;
798          (eden_space()-&gt;bottom() &lt; from_space()-&gt;bottom()),
799          &quot;Eden is assumed to be below the survivor spaces&quot;);
800 
801   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
802                 (HeapWord*)virtual_space()-&gt;high());
803   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
804   space_invariants();
805 }
806 
807 
808 
809 void PSYoungGen::update_counters() {
810   if (UsePerfData) {
811     _eden_counters-&gt;update_all();
812     _from_counters-&gt;update_all();
813     _to_counters-&gt;update_all();
814     _gen_counters-&gt;update_all();
815   }
816 }
817 
818 void PSYoungGen::verify() {
819   eden_space()-&gt;verify();
820   from_space()-&gt;verify();
821   to_space()-&gt;verify();
822 }
823 
824 #ifndef PRODUCT
825 void PSYoungGen::record_spaces_top() {
826   assert(ZapUnusedHeapArea, &quot;Not mangling unused space&quot;);
827   eden_space()-&gt;set_top_for_allocations();
828   from_space()-&gt;set_top_for_allocations();
829   to_space()-&gt;set_top_for_allocations();
830 }
831 #endif
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
diff a/src/hotspot/share/gc/parallel/psOldGen.cpp b/src/hotspot/share/gc/parallel/psOldGen.cpp
--- a/src/hotspot/share/gc/parallel/psOldGen.cpp
+++ b/src/hotspot/share/gc/parallel/psOldGen.cpp
@@ -38,39 +38,41 @@
 #include "runtime/java.hpp"
 #include "utilities/align.hpp"
 
 PSOldGen::PSOldGen(ReservedSpace rs, size_t initial_size, size_t min_size,
                    size_t max_size, const char* perf_data_name, int level):
-  _init_gen_size(initial_size), _min_gen_size(min_size),
+  _min_gen_size(min_size),
   _max_gen_size(max_size)
 {
-  initialize(rs, GenAlignment, perf_data_name, level);
+  initialize(rs, initial_size, GenAlignment, perf_data_name, level);
 }
 
-void PSOldGen::initialize(ReservedSpace rs, size_t alignment,
+void PSOldGen::initialize(ReservedSpace rs, size_t initial_size, size_t alignment,
                           const char* perf_data_name, int level) {
-  initialize_virtual_space(rs, alignment);
+  initialize_virtual_space(rs, initial_size, alignment);
   initialize_work(perf_data_name, level);
 
-  // The old gen can grow to gen_size_limit().  _reserve reflects only
+  // The old gen can grow to max_gen_size().  _reserve reflects only
   // the current maximum that can be committed.
-  assert(_reserved.byte_size() <= gen_size_limit(), "Consistency check");
+  assert(_reserved.byte_size() <= max_gen_size(), "Consistency check");
 
   initialize_performance_counters(perf_data_name, level);
 }
 
-void PSOldGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
+void PSOldGen::initialize_virtual_space(ReservedSpace rs,
+                                        size_t initial_size,
+                                        size_t alignment) {
 
   if(ParallelArguments::is_heterogeneous_heap()) {
     _virtual_space = new PSFileBackedVirtualSpace(rs, alignment, AllocateOldGenAt);
     if (!(static_cast <PSFileBackedVirtualSpace*>(_virtual_space))->initialize()) {
       vm_exit_during_initialization("Could not map space for PSOldGen at given AllocateOldGenAt path");
     }
   } else {
     _virtual_space = new PSVirtualSpace(rs, alignment);
   }
-  if (!_virtual_space->expand_by(_init_gen_size)) {
+  if (!_virtual_space->expand_by(initial_size)) {
     vm_exit_during_initialization("Could not reserve enough space for "
                                   "object heap");
   }
 }
 
@@ -78,12 +80,12 @@
   //
   // Basic memory initialization
   //
 
   MemRegion limit_reserved((HeapWord*)virtual_space()->low_boundary(),
-    heap_word_size(_max_gen_size));
-  assert(limit_reserved.byte_size() == _max_gen_size,
+                           heap_word_size(max_gen_size()));
+  assert(limit_reserved.byte_size() == max_gen_size(),
     "word vs bytes confusion");
   //
   // Object start stuff
   //
 
@@ -135,12 +137,12 @@
   start_array()->set_covered_region(cmr);
 }
 
 void PSOldGen::initialize_performance_counters(const char* perf_data_name, int level) {
   // Generation Counters, generation 'level', 1 subspace
-  _gen_counters = new PSGenerationCounters(perf_data_name, level, 1, _min_gen_size,
-                                           _max_gen_size, virtual_space());
+  _gen_counters = new PSGenerationCounters(perf_data_name, level, 1, min_gen_size(),
+                                           max_gen_size(), virtual_space());
   _space_counters = new SpaceCounters(perf_data_name, 0,
                                       virtual_space()->reserved_size(),
                                       _object_space, _gen_counters);
 }
 
@@ -297,26 +299,26 @@
   const size_t alignment = virtual_space()->alignment();
   const size_t size_before = virtual_space()->committed_size();
   size_t new_size = used_in_bytes() + desired_free_space;
   if (new_size < used_in_bytes()) {
     // Overflowed the addition.
-    new_size = gen_size_limit();
+    new_size = max_gen_size();
   }
   // Adjust according to our min and max
-  new_size = clamp(new_size, min_gen_size(), gen_size_limit());
+  new_size = clamp(new_size, min_gen_size(), max_gen_size());
 
-  assert(gen_size_limit() >= reserved().byte_size(), "max new size problem?");
+  assert(max_gen_size() >= reserved().byte_size(), "max new size problem?");
   new_size = align_up(new_size, alignment);
 
   const size_t current_size = capacity_in_bytes();
 
   log_trace(gc, ergo)("AdaptiveSizePolicy::old generation size: "
     "desired free: " SIZE_FORMAT " used: " SIZE_FORMAT
     " new size: " SIZE_FORMAT " current size " SIZE_FORMAT
     " gen limits: " SIZE_FORMAT " / " SIZE_FORMAT,
     desired_free_space, used_in_bytes(), new_size, current_size,
-    gen_size_limit(), min_gen_size());
+    max_gen_size(), min_gen_size());
 
   if (new_size == current_size) {
     // No change requested
     return;
   }
@@ -356,14 +358,10 @@
 
   assert(new_word_size == heap_word_size(object_space()->capacity_in_bytes()),
     "Sanity");
 }
 
-size_t PSOldGen::gen_size_limit() {
-  return _max_gen_size;
-}
-
 void PSOldGen::print() const { print_on(tty);}
 void PSOldGen::print_on(outputStream* st) const {
   st->print(" %-15s", name());
   st->print(" total " SIZE_FORMAT "K, used " SIZE_FORMAT "K",
               capacity_in_bytes()/K, used_in_bytes()/K);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psParallelCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psOldGen.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psParallelCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1848     if (UseAdaptiveSizePolicy) {
1849       log_debug(gc, ergo)(&quot;AdaptiveSizeStart: collection: %d &quot;, heap-&gt;total_collections());
1850       log_trace(gc, ergo)(&quot;old_gen_capacity: &quot; SIZE_FORMAT &quot; young_gen_capacity: &quot; SIZE_FORMAT,
1851                           old_gen-&gt;capacity_in_bytes(), young_gen-&gt;capacity_in_bytes());
1852 
1853       // Don&#39;t check if the size_policy is ready here.  Let
1854       // the size_policy check that internally.
1855       if (UseAdaptiveGenerationSizePolicyAtMajorCollection &amp;&amp;
1856           AdaptiveSizePolicy::should_update_promo_stats(gc_cause)) {
1857         // Swap the survivor spaces if from_space is empty. The
1858         // resize_young_gen() called below is normally used after
1859         // a successful young GC and swapping of survivor spaces;
1860         // otherwise, it will fail to resize the young gen with
1861         // the current implementation.
1862         if (young_gen-&gt;from_space()-&gt;is_empty()) {
1863           young_gen-&gt;from_space()-&gt;clear(SpaceDecorator::Mangle);
1864           young_gen-&gt;swap_spaces();
1865         }
1866 
1867         // Calculate optimal free space amounts
<span class="line-modified">1868         assert(young_gen-&gt;max_size() &gt;</span>
1869           young_gen-&gt;from_space()-&gt;capacity_in_bytes() +
1870           young_gen-&gt;to_space()-&gt;capacity_in_bytes(),
1871           &quot;Sizes of space in young gen are out-of-bounds&quot;);
1872 
1873         size_t young_live = young_gen-&gt;used_in_bytes();
1874         size_t eden_live = young_gen-&gt;eden_space()-&gt;used_in_bytes();
1875         size_t old_live = old_gen-&gt;used_in_bytes();
1876         size_t cur_eden = young_gen-&gt;eden_space()-&gt;capacity_in_bytes();
1877         size_t max_old_gen_size = old_gen-&gt;max_gen_size();
<span class="line-modified">1878         size_t max_eden_size = young_gen-&gt;max_size() -</span>
1879           young_gen-&gt;from_space()-&gt;capacity_in_bytes() -
1880           young_gen-&gt;to_space()-&gt;capacity_in_bytes();
1881 
1882         // Used for diagnostics
1883         size_policy-&gt;clear_generation_free_space_flags();
1884 
1885         size_policy-&gt;compute_generations_free_space(young_live,
1886                                                     eden_live,
1887                                                     old_live,
1888                                                     cur_eden,
1889                                                     max_old_gen_size,
1890                                                     max_eden_size,
1891                                                     true /* full gc*/);
1892 
1893         size_policy-&gt;check_gc_overhead_limit(eden_live,
1894                                              max_old_gen_size,
1895                                              max_eden_size,
1896                                              true /* full gc*/,
1897                                              gc_cause,
1898                                              heap-&gt;soft_ref_policy());
</pre>
</td>
<td>
<hr />
<pre>
1848     if (UseAdaptiveSizePolicy) {
1849       log_debug(gc, ergo)(&quot;AdaptiveSizeStart: collection: %d &quot;, heap-&gt;total_collections());
1850       log_trace(gc, ergo)(&quot;old_gen_capacity: &quot; SIZE_FORMAT &quot; young_gen_capacity: &quot; SIZE_FORMAT,
1851                           old_gen-&gt;capacity_in_bytes(), young_gen-&gt;capacity_in_bytes());
1852 
1853       // Don&#39;t check if the size_policy is ready here.  Let
1854       // the size_policy check that internally.
1855       if (UseAdaptiveGenerationSizePolicyAtMajorCollection &amp;&amp;
1856           AdaptiveSizePolicy::should_update_promo_stats(gc_cause)) {
1857         // Swap the survivor spaces if from_space is empty. The
1858         // resize_young_gen() called below is normally used after
1859         // a successful young GC and swapping of survivor spaces;
1860         // otherwise, it will fail to resize the young gen with
1861         // the current implementation.
1862         if (young_gen-&gt;from_space()-&gt;is_empty()) {
1863           young_gen-&gt;from_space()-&gt;clear(SpaceDecorator::Mangle);
1864           young_gen-&gt;swap_spaces();
1865         }
1866 
1867         // Calculate optimal free space amounts
<span class="line-modified">1868         assert(young_gen-&gt;max_gen_size() &gt;</span>
1869           young_gen-&gt;from_space()-&gt;capacity_in_bytes() +
1870           young_gen-&gt;to_space()-&gt;capacity_in_bytes(),
1871           &quot;Sizes of space in young gen are out-of-bounds&quot;);
1872 
1873         size_t young_live = young_gen-&gt;used_in_bytes();
1874         size_t eden_live = young_gen-&gt;eden_space()-&gt;used_in_bytes();
1875         size_t old_live = old_gen-&gt;used_in_bytes();
1876         size_t cur_eden = young_gen-&gt;eden_space()-&gt;capacity_in_bytes();
1877         size_t max_old_gen_size = old_gen-&gt;max_gen_size();
<span class="line-modified">1878         size_t max_eden_size = young_gen-&gt;max_gen_size() -</span>
1879           young_gen-&gt;from_space()-&gt;capacity_in_bytes() -
1880           young_gen-&gt;to_space()-&gt;capacity_in_bytes();
1881 
1882         // Used for diagnostics
1883         size_policy-&gt;clear_generation_free_space_flags();
1884 
1885         size_policy-&gt;compute_generations_free_space(young_live,
1886                                                     eden_live,
1887                                                     old_live,
1888                                                     cur_eden,
1889                                                     max_old_gen_size,
1890                                                     max_eden_size,
1891                                                     true /* full gc*/);
1892 
1893         size_policy-&gt;check_gc_overhead_limit(eden_live,
1894                                              max_old_gen_size,
1895                                              max_eden_size,
1896                                              true /* full gc*/,
1897                                              gc_cause,
1898                                              heap-&gt;soft_ref_policy());
</pre>
</td>
</tr>
</table>
<center><a href="psOldGen.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
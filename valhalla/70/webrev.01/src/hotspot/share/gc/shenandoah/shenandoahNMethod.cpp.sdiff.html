<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93   if (oops.length() != _oops_count) {
 94     if (_oops != NULL) {
 95       FREE_C_HEAP_ARRAY(oop*, _oops);
 96       _oops = NULL;
 97     }
 98 
 99     _oops_count = oops.length();
100     if (_oops_count &gt; 0) {
101       _oops = NEW_C_HEAP_ARRAY(oop*, _oops_count, mtGC);
102     }
103   }
104 
105   for (int index = 0; index &lt; _oops_count; index ++) {
106     _oops[index] = oops.at(index);
107   }
108   _has_non_immed_oops = non_immediate_oops;
109 
110   assert_same_oops();
111 }
112 
<span class="line-removed">113 void ShenandoahNMethod::oops_do(OopClosure* oops, bool fix_relocations) {</span>
<span class="line-removed">114   for (int c = 0; c &lt; _oops_count; c ++) {</span>
<span class="line-removed">115     oops-&gt;do_oop(_oops[c]);</span>
<span class="line-removed">116   }</span>
<span class="line-removed">117 </span>
<span class="line-removed">118   oop* const begin = _nm-&gt;oops_begin();</span>
<span class="line-removed">119   oop* const end = _nm-&gt;oops_end();</span>
<span class="line-removed">120   for (oop* p = begin; p &lt; end; p++) {</span>
<span class="line-removed">121     if (*p != Universe::non_oop_word()) {</span>
<span class="line-removed">122       oops-&gt;do_oop(p);</span>
<span class="line-removed">123     }</span>
<span class="line-removed">124   }</span>
<span class="line-removed">125 </span>
<span class="line-removed">126   if (fix_relocations &amp;&amp; _has_non_immed_oops) {</span>
<span class="line-removed">127     _nm-&gt;fix_oop_relocations();</span>
<span class="line-removed">128   }</span>
<span class="line-removed">129 }</span>
<span class="line-removed">130 </span>
131 void ShenandoahNMethod::detect_reloc_oops(nmethod* nm, GrowableArray&lt;oop*&gt;&amp; oops, bool&amp; has_non_immed_oops) {
132   has_non_immed_oops = false;
133   // Find all oops relocations
134   RelocIterator iter(nm);
135   while (iter.next()) {
136     if (iter.type() != relocInfo::oop_type) {
137       // Not an oop
138       continue;
139     }
140 
141     oop_Relocation* r = iter.oop_reloc();
142     if (!r-&gt;oop_is_immediate()) {
143       // Non-immediate oop found
144       has_non_immed_oops = true;
145       continue;
146     }
147 
148     oop value = r-&gt;oop_value();
149     if (value != NULL) {
150       oop* addr = r-&gt;oop_addr();
</pre>
<hr />
<pre>
198     ShouldNotReachHere();
199   }
200 };
201 
202 void ShenandoahNMethod::heal_nmethod(nmethod* nm) {
203   ShenandoahNMethod* data = gc_data(nm);
204   assert(data != NULL, &quot;Sanity&quot;);
205   assert(data-&gt;lock()-&gt;owned_by_self(), &quot;Must hold the lock&quot;);
206 
207   ShenandoahHeap* const heap = ShenandoahHeap::heap();
208   if (heap-&gt;is_concurrent_mark_in_progress()) {
209     if (heap-&gt;has_forwarded_objects()) {
210       ShenandoahKeepNMethodMetadataAliveClosure&lt;true&gt; cl;
211       data-&gt;oops_do(&amp;cl);
212     } else {
213       ShenandoahKeepNMethodMetadataAliveClosure&lt;false&gt; cl;
214       data-&gt;oops_do(&amp;cl);
215     }
216   } else if (heap-&gt;is_concurrent_weak_root_in_progress()) {
217     ShenandoahEvacOOMScope evac_scope;
<span class="line-modified">218     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>
<span class="line-removed">219     data-&gt;oops_do(&amp;cl, true /*fix relocation*/);</span>
220   } else {
221     // There is possibility that GC is cancelled when it arrives final mark.
222     // In this case, concurrent root phase is skipped and degenerated GC should be
223     // followed, where nmethods are disarmed.
224     assert(heap-&gt;cancelled_gc(), &quot;What else?&quot;);
225   }
226 }
227 
228 #ifdef ASSERT
229 void ShenandoahNMethod::assert_alive_and_correct() {
230   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);
231   ShenandoahHeap* heap = ShenandoahHeap::heap();
232   for (int c = 0; c &lt; _oops_count; c++) {
233     oop *loc = _oops[c];
234     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);
235     oop o = RawAccess&lt;&gt;::oop_load(loc);
236     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
237   }
238 
239   oop* const begin = _nm-&gt;oops_begin();
</pre>
</td>
<td>
<hr />
<pre>
 93   if (oops.length() != _oops_count) {
 94     if (_oops != NULL) {
 95       FREE_C_HEAP_ARRAY(oop*, _oops);
 96       _oops = NULL;
 97     }
 98 
 99     _oops_count = oops.length();
100     if (_oops_count &gt; 0) {
101       _oops = NEW_C_HEAP_ARRAY(oop*, _oops_count, mtGC);
102     }
103   }
104 
105   for (int index = 0; index &lt; _oops_count; index ++) {
106     _oops[index] = oops.at(index);
107   }
108   _has_non_immed_oops = non_immediate_oops;
109 
110   assert_same_oops();
111 }
112 


















113 void ShenandoahNMethod::detect_reloc_oops(nmethod* nm, GrowableArray&lt;oop*&gt;&amp; oops, bool&amp; has_non_immed_oops) {
114   has_non_immed_oops = false;
115   // Find all oops relocations
116   RelocIterator iter(nm);
117   while (iter.next()) {
118     if (iter.type() != relocInfo::oop_type) {
119       // Not an oop
120       continue;
121     }
122 
123     oop_Relocation* r = iter.oop_reloc();
124     if (!r-&gt;oop_is_immediate()) {
125       // Non-immediate oop found
126       has_non_immed_oops = true;
127       continue;
128     }
129 
130     oop value = r-&gt;oop_value();
131     if (value != NULL) {
132       oop* addr = r-&gt;oop_addr();
</pre>
<hr />
<pre>
180     ShouldNotReachHere();
181   }
182 };
183 
184 void ShenandoahNMethod::heal_nmethod(nmethod* nm) {
185   ShenandoahNMethod* data = gc_data(nm);
186   assert(data != NULL, &quot;Sanity&quot;);
187   assert(data-&gt;lock()-&gt;owned_by_self(), &quot;Must hold the lock&quot;);
188 
189   ShenandoahHeap* const heap = ShenandoahHeap::heap();
190   if (heap-&gt;is_concurrent_mark_in_progress()) {
191     if (heap-&gt;has_forwarded_objects()) {
192       ShenandoahKeepNMethodMetadataAliveClosure&lt;true&gt; cl;
193       data-&gt;oops_do(&amp;cl);
194     } else {
195       ShenandoahKeepNMethodMetadataAliveClosure&lt;false&gt; cl;
196       data-&gt;oops_do(&amp;cl);
197     }
198   } else if (heap-&gt;is_concurrent_weak_root_in_progress()) {
199     ShenandoahEvacOOMScope evac_scope;
<span class="line-modified">200     heal_nmethod_metadata(data);</span>

201   } else {
202     // There is possibility that GC is cancelled when it arrives final mark.
203     // In this case, concurrent root phase is skipped and degenerated GC should be
204     // followed, where nmethods are disarmed.
205     assert(heap-&gt;cancelled_gc(), &quot;What else?&quot;);
206   }
207 }
208 
209 #ifdef ASSERT
210 void ShenandoahNMethod::assert_alive_and_correct() {
211   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);
212   ShenandoahHeap* heap = ShenandoahHeap::heap();
213   for (int c = 0; c &lt; _oops_count; c++) {
214     oop *loc = _oops[c];
215     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);
216     oop o = RawAccess&lt;&gt;::oop_load(loc);
217     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
218   }
219 
220   oop* const begin = _nm-&gt;oops_begin();
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
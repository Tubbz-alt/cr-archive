<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahNMethod.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, 2020, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHNMETHOD_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHNMETHOD_HPP
 27 
 28 #include &quot;code/nmethod.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahLock.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahPadding.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;utilities/growableArray.hpp&quot;
 34 
 35 // ShenandoahNMethod tuple records the internal locations of oop slots within reclocation stream in
 36 // the nmethod. This allows us to quickly scan the oops without doing the nmethod-internal scans,
 37 // that sometimes involves parsing the machine code. Note it does not record the oops themselves,
 38 // because it would then require handling these tuples as the new class of roots.
 39 class ShenandoahNMethod : public CHeapObj&lt;mtGC&gt; {
 40 private:
 41   nmethod* const          _nm;
 42   oop**                   _oops;
 43   int                     _oops_count;
 44   bool                    _has_non_immed_oops;
 45   bool                    _unregistered;
 46   ShenandoahReentrantLock _lock;
 47 
 48 public:
 49   ShenandoahNMethod(nmethod *nm, GrowableArray&lt;oop*&gt;&amp; oops, bool has_non_immed_oops);
 50   ~ShenandoahNMethod();
 51 
 52   inline nmethod* nm() const;
 53   inline ShenandoahReentrantLock* lock();
<a name="1" id="anc1"></a><span class="line-modified"> 54   void oops_do(OopClosure* oops, bool fix_relocations = false);</span>
 55   // Update oops when the nmethod is re-registered
 56   void update();
 57 
 58   bool has_cset_oops(ShenandoahHeap* heap);
 59 
 60   inline int oop_count() const;
 61   inline bool has_oops() const;
 62 
 63   inline void mark_unregistered();
 64   inline bool is_unregistered() const;
 65 
 66   static ShenandoahNMethod* for_nmethod(nmethod* nm);
 67   static inline ShenandoahReentrantLock* lock_for_nmethod(nmethod* nm);
 68 
 69   static void heal_nmethod(nmethod* nm);
<a name="2" id="anc2"></a>
 70   static inline void disarm_nmethod(nmethod* nm);
 71 
 72   static inline ShenandoahNMethod* gc_data(nmethod* nm);
 73   static inline void attach_gc_data(nmethod* nm, ShenandoahNMethod* gc_data);
 74 
 75   void assert_alive_and_correct() NOT_DEBUG_RETURN;
 76   void assert_same_oops(bool allow_dead = false) NOT_DEBUG_RETURN;
 77   static void assert_no_oops(nmethod* nm, bool allow_dea = false) NOT_DEBUG_RETURN;
 78 
 79 private:
 80   bool has_non_immed_oops() const { return _has_non_immed_oops; }
 81   static void detect_reloc_oops(nmethod* nm, GrowableArray&lt;oop*&gt;&amp; oops, bool&amp; _has_non_immed_oops);
 82 };
 83 
 84 class ShenandoahNMethodTable;
 85 
 86 // ShenandoahNMethodList holds registered nmethod data. The list is reference counted.
 87 class ShenandoahNMethodList : public CHeapObj&lt;mtGC&gt; {
 88 private:
 89   ShenandoahNMethod** _list;
 90   const int           _size;
 91   uint                _ref_count;
 92 
 93 private:
 94   ~ShenandoahNMethodList();
 95 
 96 public:
 97   ShenandoahNMethodList(int size);
 98 
 99   // Reference counting with CoceCache_lock held
100   ShenandoahNMethodList* acquire();
101   void release();
102 
103   // Transfer content from other list to &#39;this&#39; list, up to the limit
104   void transfer(ShenandoahNMethodList* const other, int limit);
105 
106   inline int size() const;
107   inline ShenandoahNMethod** list() const;
108   inline ShenandoahNMethod* at(int index) const;
109   inline void set(int index, ShenandoahNMethod* snm);
110 };
111 
112 // An opaque snapshot of current nmethod table for iteration
113 class ShenandoahNMethodTableSnapshot : public CHeapObj&lt;mtGC&gt; {
114   friend class ShenandoahNMethodTable;
115 private:
116   ShenandoahHeap* const       _heap;
117   ShenandoahNMethodList*      _list;
118   /* snapshot iteration limit */
119   int                         _limit;
120 
121   shenandoah_padding(0);
122   volatile size_t       _claimed;
123   shenandoah_padding(1);
124 
125 public:
126   ShenandoahNMethodTableSnapshot(ShenandoahNMethodTable* table);
127   ~ShenandoahNMethodTableSnapshot();
128 
129   template&lt;bool CSET_FILTER&gt;
130   void parallel_blobs_do(CodeBlobClosure *f);
131 
132   void concurrent_nmethods_do(NMethodClosure* cl);
133 };
134 
135 class ShenandoahNMethodTable : public CHeapObj&lt;mtGC&gt; {
136   friend class ShenandoahNMethodTableSnapshot;
137 private:
138   enum {
139     minSize = 1024
140   };
141 
142   ShenandoahHeap* const  _heap;
143   ShenandoahNMethodList* _list;
144 
145   int                    _index;
146   ShenandoahLock         _lock;
147   int                    _itr_cnt;
148 
149 public:
150   ShenandoahNMethodTable();
151   ~ShenandoahNMethodTable();
152 
153   void register_nmethod(nmethod* nm);
154   void unregister_nmethod(nmethod* nm);
155   void flush_nmethod(nmethod* nm);
156 
157   bool contain(nmethod* nm) const;
158   int length() const { return _index; }
159 
160   // Table iteration support
161   ShenandoahNMethodTableSnapshot* snapshot_for_iteration();
162   void finish_iteration(ShenandoahNMethodTableSnapshot* snapshot);
163 
164   void assert_nmethods_alive_and_correct() NOT_DEBUG_RETURN;
165 private:
166   // Rebuild table and replace current one
167   void rebuild(int size);
168 
169   bool is_full() const {
170     assert(_index &lt;= _list-&gt;size(), &quot;Sanity&quot;);
171     return _index == _list-&gt;size();
172   }
173 
174   ShenandoahNMethod* at(int index) const;
175   int  index_of(nmethod* nm) const;
176   void remove(int index);
177   void append(ShenandoahNMethod* snm);
178 
179   inline bool iteration_in_progress() const;
180   void wait_until_concurrent_iteration_done();
181 
182   // Logging support
183   void log_register_nmethod(nmethod* nm);
184   void log_unregister_nmethod(nmethod* nm);
185   void log_flush_nmethod(nmethod* nm);
186 };
187 
188 class ShenandoahConcurrentNMethodIterator {
189 private:
190   ShenandoahNMethodTable*         const _table;
191   ShenandoahNMethodTableSnapshot*       _table_snapshot;
192 
193 public:
194   ShenandoahConcurrentNMethodIterator(ShenandoahNMethodTable* table);
195 
196   void nmethods_do_begin();
197   void nmethods_do(NMethodClosure* cl);
198   void nmethods_do_end();
199 };
200 
201 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHNMETHOD_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
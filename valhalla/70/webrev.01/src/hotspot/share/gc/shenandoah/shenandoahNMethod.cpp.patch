diff a/src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp b/src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp
@@ -108,28 +108,10 @@
   _has_non_immed_oops = non_immediate_oops;
 
   assert_same_oops();
 }
 
-void ShenandoahNMethod::oops_do(OopClosure* oops, bool fix_relocations) {
-  for (int c = 0; c < _oops_count; c ++) {
-    oops->do_oop(_oops[c]);
-  }
-
-  oop* const begin = _nm->oops_begin();
-  oop* const end = _nm->oops_end();
-  for (oop* p = begin; p < end; p++) {
-    if (*p != Universe::non_oop_word()) {
-      oops->do_oop(p);
-    }
-  }
-
-  if (fix_relocations && _has_non_immed_oops) {
-    _nm->fix_oop_relocations();
-  }
-}
-
 void ShenandoahNMethod::detect_reloc_oops(nmethod* nm, GrowableArray<oop*>& oops, bool& has_non_immed_oops) {
   has_non_immed_oops = false;
   // Find all oops relocations
   RelocIterator iter(nm);
   while (iter.next()) {
@@ -213,12 +195,11 @@
       ShenandoahKeepNMethodMetadataAliveClosure<false> cl;
       data->oops_do(&cl);
     }
   } else if (heap->is_concurrent_weak_root_in_progress()) {
     ShenandoahEvacOOMScope evac_scope;
-    ShenandoahEvacuateUpdateRootsClosure<> cl;
-    data->oops_do(&cl, true /*fix relocation*/);
+    heal_nmethod_metadata(data);
   } else {
     // There is possibility that GC is cancelled when it arrives final mark.
     // In this case, concurrent root phase is skipped and degenerated GC should be
     // followed, where nmethods are disarmed.
     assert(heap->cancelled_gc(), "What else?");

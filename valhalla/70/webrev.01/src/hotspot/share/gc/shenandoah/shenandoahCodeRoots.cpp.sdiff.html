<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/icBuffer.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;

 29 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahNMethod.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;memory/universe.hpp&quot;
 36 #include &quot;runtime/atomic.hpp&quot;
 37 #include &quot;utilities/powerOfTwo.hpp&quot;
 38 
 39 ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps) {
 40   _length = heaps-&gt;length();
 41   _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);
 42   for (int h = 0; h &lt; _length; h++) {
 43     _iters[h] = ShenandoahParallelCodeHeapIterator(heaps-&gt;at(h));
 44   }
 45 }
 46 
 47 ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {
 48   FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);
</pre>
<hr />
<pre>
255       return;
256     }
257 
258     ShenandoahNMethod* nm_data = ShenandoahNMethod::gc_data(nm);
259     assert(!nm_data-&gt;is_unregistered(), &quot;Should not see unregistered entry&quot;);
260 
261     if (!nm-&gt;is_alive()) {
262       return;
263     }
264 
265     if (nm-&gt;is_unloading()) {
266       ShenandoahReentrantLocker locker(nm_data-&gt;lock());
267       unlink(nm);
268       return;
269     }
270 
271     ShenandoahReentrantLocker locker(nm_data-&gt;lock());
272 
273     // Heal oops and disarm
274     if (_bs-&gt;is_armed(nm)) {
<span class="line-modified">275       ShenandoahNMethod::heal_nmethod(nm);</span>

276       _bs-&gt;disarm(nm);
277     }
278 
279     // Clear compiled ICs and exception caches
280     if (!nm-&gt;unload_nmethod_caches(_unloading_occurred)) {
281       set_failed();
282     }
283   }
284 
285   bool failed() const {
286     return Atomic::load(&amp;_failed);
287   }
288 };
289 
290 class ShenandoahUnlinkTask : public AbstractGangTask {
291 private:
292   ShenandoahNMethodUnlinkClosure      _cl;
293   ICRefillVerifier*                   _verifier;
294   ShenandoahConcurrentNMethodIterator _iterator;
295 
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/icBuffer.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;
<span class="line-added"> 29 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;</span>
 30 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahNMethod.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;memory/universe.hpp&quot;
 37 #include &quot;runtime/atomic.hpp&quot;
 38 #include &quot;utilities/powerOfTwo.hpp&quot;
 39 
 40 ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps) {
 41   _length = heaps-&gt;length();
 42   _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);
 43   for (int h = 0; h &lt; _length; h++) {
 44     _iters[h] = ShenandoahParallelCodeHeapIterator(heaps-&gt;at(h));
 45   }
 46 }
 47 
 48 ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {
 49   FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);
</pre>
<hr />
<pre>
256       return;
257     }
258 
259     ShenandoahNMethod* nm_data = ShenandoahNMethod::gc_data(nm);
260     assert(!nm_data-&gt;is_unregistered(), &quot;Should not see unregistered entry&quot;);
261 
262     if (!nm-&gt;is_alive()) {
263       return;
264     }
265 
266     if (nm-&gt;is_unloading()) {
267       ShenandoahReentrantLocker locker(nm_data-&gt;lock());
268       unlink(nm);
269       return;
270     }
271 
272     ShenandoahReentrantLocker locker(nm_data-&gt;lock());
273 
274     // Heal oops and disarm
275     if (_bs-&gt;is_armed(nm)) {
<span class="line-modified">276       ShenandoahEvacOOMScope oom_evac_scope;</span>
<span class="line-added">277       ShenandoahNMethod::heal_nmethod_metadata(nm_data);</span>
278       _bs-&gt;disarm(nm);
279     }
280 
281     // Clear compiled ICs and exception caches
282     if (!nm-&gt;unload_nmethod_caches(_unloading_occurred)) {
283       set_failed();
284     }
285   }
286 
287   bool failed() const {
288     return Atomic::load(&amp;_failed);
289   }
290 };
291 
292 class ShenandoahUnlinkTask : public AbstractGangTask {
293 private:
294   ShenandoahNMethodUnlinkClosure      _cl;
295   ICRefillVerifier*                   _verifier;
296   ShenandoahConcurrentNMethodIterator _iterator;
297 
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/icBuffer.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;
<a name="1" id="anc1"></a>
 29 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahNMethod.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;memory/universe.hpp&quot;
 36 #include &quot;runtime/atomic.hpp&quot;
 37 #include &quot;utilities/powerOfTwo.hpp&quot;
 38 
 39 ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps) {
 40   _length = heaps-&gt;length();
 41   _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);
 42   for (int h = 0; h &lt; _length; h++) {
 43     _iters[h] = ShenandoahParallelCodeHeapIterator(heaps-&gt;at(h));
 44   }
 45 }
 46 
 47 ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {
 48   FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);
 49 }
 50 
 51 void ShenandoahParallelCodeCacheIterator::parallel_blobs_do(CodeBlobClosure* f) {
 52   for (int c = 0; c &lt; _length; c++) {
 53     _iters[c].parallel_blobs_do(f);
 54   }
 55 }
 56 
 57 ShenandoahParallelCodeHeapIterator::ShenandoahParallelCodeHeapIterator(CodeHeap* heap) :
 58         _heap(heap), _claimed_idx(0), _finished(false) {
 59 }
 60 
 61 void ShenandoahParallelCodeHeapIterator::parallel_blobs_do(CodeBlobClosure* f) {
 62   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
 63 
 64   /*
 65    * Parallel code heap walk.
 66    *
 67    * This code makes all threads scan all code heaps, but only one thread would execute the
 68    * closure on given blob. This is achieved by recording the &quot;claimed&quot; blocks: if a thread
 69    * had claimed the block, it can process all blobs in it. Others have to fast-forward to
 70    * next attempt without processing.
 71    *
 72    * Late threads would return immediately if iterator is finished.
 73    */
 74 
 75   if (_finished) {
 76     return;
 77   }
 78 
 79   int stride = 256; // educated guess
 80   int stride_mask = stride - 1;
 81   assert (is_power_of_2(stride), &quot;sanity&quot;);
 82 
 83   int count = 0;
 84   bool process_block = true;
 85 
 86   for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != NULL; cb = CodeCache::next_blob(_heap, cb)) {
 87     int current = count++;
 88     if ((current &amp; stride_mask) == 0) {
 89       process_block = (current &gt;= _claimed_idx) &amp;&amp;
 90                       (Atomic::cmpxchg(&amp;_claimed_idx, current, current + stride) == current);
 91     }
 92     if (process_block) {
 93       if (cb-&gt;is_alive()) {
 94         f-&gt;do_code_blob(cb);
 95 #ifdef ASSERT
 96         if (cb-&gt;is_nmethod())
 97           Universe::heap()-&gt;verify_nmethod((nmethod*)cb);
 98 #endif
 99       }
100     }
101   }
102 
103   _finished = true;
104 }
105 
106 ShenandoahNMethodTable* ShenandoahCodeRoots::_nmethod_table;
107 int ShenandoahCodeRoots::_disarmed_value = 1;
108 
109 void ShenandoahCodeRoots::initialize() {
110   _nmethod_table = new ShenandoahNMethodTable();
111 }
112 
113 void ShenandoahCodeRoots::register_nmethod(nmethod* nm) {
114   switch (ShenandoahCodeRootsStyle) {
115     case 0:
116     case 1:
117       break;
118     case 2: {
119       assert_locked_or_safepoint(CodeCache_lock);
120       _nmethod_table-&gt;register_nmethod(nm);
121       break;
122     }
123     default:
124       ShouldNotReachHere();
125   }
126 }
127 
128 void ShenandoahCodeRoots::unregister_nmethod(nmethod* nm) {
129   switch (ShenandoahCodeRootsStyle) {
130     case 0:
131     case 1: {
132       break;
133     }
134     case 2: {
135       assert_locked_or_safepoint(CodeCache_lock);
136       _nmethod_table-&gt;unregister_nmethod(nm);
137       break;
138     }
139     default:
140       ShouldNotReachHere();
141   }
142 }
143 
144 void ShenandoahCodeRoots::flush_nmethod(nmethod* nm) {
145   switch (ShenandoahCodeRootsStyle) {
146     case 0:
147     case 1: {
148       break;
149     }
150     case 2: {
151       assert_locked_or_safepoint(CodeCache_lock);
152       _nmethod_table-&gt;flush_nmethod(nm);
153       break;
154     }
155     default:
156       ShouldNotReachHere();
157   }
158 }
159 
160 void ShenandoahCodeRoots::arm_nmethods() {
161   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
162   _disarmed_value ++;
163   // 0 is reserved for new nmethod
164   if (_disarmed_value == 0) {
165     _disarmed_value = 1;
166   }
167 
168   JavaThreadIteratorWithHandle jtiwh;
169   for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
170     ShenandoahThreadLocalData::set_disarmed_value(thr, _disarmed_value);
171   }
172 }
173 
174 class ShenandoahDisarmNMethodClosure : public NMethodClosure {
175 private:
176   BarrierSetNMethod* const _bs;
177 
178 public:
179   ShenandoahDisarmNMethodClosure() :
180     _bs(BarrierSet::barrier_set()-&gt;barrier_set_nmethod()) {
181   }
182 
183   virtual void do_nmethod(nmethod* nm) {
184     _bs-&gt;disarm(nm);
185   }
186 };
187 
188 class ShenandoahDisarmNMethodsTask : public AbstractGangTask {
189 private:
190   ShenandoahDisarmNMethodClosure      _cl;
191   ShenandoahConcurrentNMethodIterator _iterator;
192 
193 public:
194   ShenandoahDisarmNMethodsTask() :
195     AbstractGangTask(&quot;ShenandoahDisarmNMethodsTask&quot;),
196     _iterator(ShenandoahCodeRoots::table()) {
197     assert(SafepointSynchronize::is_at_safepoint(), &quot;Only at a safepoint&quot;);
198     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
199     _iterator.nmethods_do_begin();
200   }
201 
202   ~ShenandoahDisarmNMethodsTask() {
203     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
204     _iterator.nmethods_do_end();
205   }
206 
207   virtual void work(uint worker_id) {
208     ShenandoahParallelWorkerSession worker_session(worker_id);
209     _iterator.nmethods_do(&amp;_cl);
210   }
211 };
212 
213 void ShenandoahCodeRoots::disarm_nmethods() {
214   ShenandoahDisarmNMethodsTask task;
215   ShenandoahHeap::heap()-&gt;workers()-&gt;run_task(&amp;task);
216 }
217 
218 class ShenandoahNMethodUnlinkClosure : public NMethodClosure {
219 private:
220   bool                      _unloading_occurred;
221   volatile bool             _failed;
222   ShenandoahHeap* const     _heap;
223   BarrierSetNMethod* const  _bs;
224 
225   void set_failed() {
226     Atomic::store(&amp;_failed, true);
227   }
228 
229    void unlink(nmethod* nm) {
230      // Unlinking of the dependencies must happen before the
231      // handshake separating unlink and purge.
232      nm-&gt;flush_dependencies(false /* delete_immediately */);
233 
234      // unlink_from_method will take the CompiledMethod_lock.
235      // In this case we don&#39;t strictly need it when unlinking nmethods from
236      // the Method, because it is only concurrently unlinked by
237      // the entry barrier, which acquires the per nmethod lock.
238      nm-&gt;unlink_from_method();
239 
240      if (nm-&gt;is_osr_method()) {
241        // Invalidate the osr nmethod only once
242        nm-&gt;invalidate_osr_method();
243      }
244    }
245 public:
246   ShenandoahNMethodUnlinkClosure(bool unloading_occurred) :
247       _unloading_occurred(unloading_occurred),
248       _failed(false),
249       _heap(ShenandoahHeap::heap()),
250       _bs(ShenandoahBarrierSet::barrier_set()-&gt;barrier_set_nmethod()) {}
251 
252   virtual void do_nmethod(nmethod* nm) {
253     assert(_heap-&gt;is_concurrent_weak_root_in_progress(), &quot;Only this phase&quot;);
254     if (failed()) {
255       return;
256     }
257 
258     ShenandoahNMethod* nm_data = ShenandoahNMethod::gc_data(nm);
259     assert(!nm_data-&gt;is_unregistered(), &quot;Should not see unregistered entry&quot;);
260 
261     if (!nm-&gt;is_alive()) {
262       return;
263     }
264 
265     if (nm-&gt;is_unloading()) {
266       ShenandoahReentrantLocker locker(nm_data-&gt;lock());
267       unlink(nm);
268       return;
269     }
270 
271     ShenandoahReentrantLocker locker(nm_data-&gt;lock());
272 
273     // Heal oops and disarm
274     if (_bs-&gt;is_armed(nm)) {
<a name="2" id="anc2"></a><span class="line-modified">275       ShenandoahNMethod::heal_nmethod(nm);</span>

276       _bs-&gt;disarm(nm);
277     }
278 
279     // Clear compiled ICs and exception caches
280     if (!nm-&gt;unload_nmethod_caches(_unloading_occurred)) {
281       set_failed();
282     }
283   }
284 
285   bool failed() const {
286     return Atomic::load(&amp;_failed);
287   }
288 };
289 
290 class ShenandoahUnlinkTask : public AbstractGangTask {
291 private:
292   ShenandoahNMethodUnlinkClosure      _cl;
293   ICRefillVerifier*                   _verifier;
294   ShenandoahConcurrentNMethodIterator _iterator;
295 
296 public:
297   ShenandoahUnlinkTask(bool unloading_occurred, ICRefillVerifier* verifier) :
298     AbstractGangTask(&quot;ShenandoahNMethodUnlinkTask&quot;),
299     _cl(unloading_occurred),
300     _verifier(verifier),
301     _iterator(ShenandoahCodeRoots::table()) {
302     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
303     _iterator.nmethods_do_begin();
304   }
305 
306   ~ShenandoahUnlinkTask() {
307     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
308     _iterator.nmethods_do_end();
309   }
310 
311   virtual void work(uint worker_id) {
312     ICRefillVerifierMark mark(_verifier);
313     _iterator.nmethods_do(&amp;_cl);
314   }
315 
316   bool success() const {
317     return !_cl.failed();
318   }
319 };
320 
321 void ShenandoahCodeRoots::unlink(WorkGang* workers, bool unloading_occurred) {
322   assert(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),
323          &quot;Only when running concurrent class unloading&quot;);
324 
325   for (;;) {
326     ICRefillVerifier verifier;
327 
328     {
329       ShenandoahUnlinkTask task(unloading_occurred, &amp;verifier);
330       workers-&gt;run_task(&amp;task);
331       if (task.success()) {
332         return;
333       }
334     }
335 
336     // Cleaning failed because we ran out of transitional IC stubs,
337     // so we have to refill and try again. Refilling requires taking
338     // a safepoint, so we temporarily leave the suspendible thread set.
339     SuspendibleThreadSetLeaver sts;
340     InlineCacheBuffer::refill_ic_stubs();
341   }
342 }
343 
344 class ShenandoahNMethodPurgeClosure : public NMethodClosure {
345 public:
346   virtual void do_nmethod(nmethod* nm) {
347     if (nm-&gt;is_alive() &amp;&amp; nm-&gt;is_unloading()) {
348       nm-&gt;make_unloaded();
349     }
350   }
351 };
352 
353 class ShenandoahNMethodPurgeTask : public AbstractGangTask {
354 private:
355   ShenandoahNMethodPurgeClosure       _cl;
356   ShenandoahConcurrentNMethodIterator _iterator;
357 
358 public:
359   ShenandoahNMethodPurgeTask() :
360     AbstractGangTask(&quot;ShenandoahNMethodPurgeTask&quot;),
361     _cl(),
362     _iterator(ShenandoahCodeRoots::table()) {
363     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
364     _iterator.nmethods_do_begin();
365   }
366 
367   ~ShenandoahNMethodPurgeTask() {
368     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
369     _iterator.nmethods_do_end();
370   }
371 
372   virtual void work(uint worker_id) {
373     _iterator.nmethods_do(&amp;_cl);
374   }
375 };
376 
377 void ShenandoahCodeRoots::purge(WorkGang* workers) {
378   assert(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),
379          &quot;Only when running concurrent class unloading&quot;);
380 
381   ShenandoahNMethodPurgeTask task;
382   workers-&gt;run_task(&amp;task);
383 }
384 
385 ShenandoahCodeRootsIterator::ShenandoahCodeRootsIterator() :
386         _par_iterator(CodeCache::heaps()),
387         _table_snapshot(NULL) {
388   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
389   assert(!Thread::current()-&gt;is_Worker_thread(), &quot;Should not be acquired by workers&quot;);
390   switch (ShenandoahCodeRootsStyle) {
391     case 0:
392     case 1: {
393       // No need to do anything here
394       break;
395     }
396     case 2: {
397       CodeCache_lock-&gt;lock_without_safepoint_check();
398       _table_snapshot = ShenandoahCodeRoots::table()-&gt;snapshot_for_iteration();
399       break;
400     }
401     default:
402       ShouldNotReachHere();
403   }
404 }
405 
406 ShenandoahCodeRootsIterator::~ShenandoahCodeRootsIterator() {
407   switch (ShenandoahCodeRootsStyle) {
408     case 0:
409     case 1: {
410       // No need to do anything here
411       break;
412     }
413     case 2: {
414       ShenandoahCodeRoots::table()-&gt;finish_iteration(_table_snapshot);
415       _table_snapshot = NULL;
416       CodeCache_lock-&gt;unlock();
417       break;
418     }
419     default:
420       ShouldNotReachHere();
421   }
422 }
423 
424 template&lt;bool CSET_FILTER&gt;
425 void ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do(CodeBlobClosure *f) {
426   switch (ShenandoahCodeRootsStyle) {
427     case 0: {
428       if (_seq_claimed.try_set()) {
429         CodeCache::blobs_do(f);
430       }
431       break;
432     }
433     case 1: {
434       _par_iterator.parallel_blobs_do(f);
435       break;
436     }
437     case 2: {
438       ShenandoahCodeRootsIterator::fast_parallel_blobs_do&lt;CSET_FILTER&gt;(f);
439       break;
440     }
441     default:
442       ShouldNotReachHere();
443   }
444 }
445 
446 void ShenandoahAllCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {
447   ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do&lt;false&gt;(f);
448 }
449 
450 void ShenandoahCsetCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {
451   ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do&lt;true&gt;(f);
452 }
453 
454 template &lt;bool CSET_FILTER&gt;
455 void ShenandoahCodeRootsIterator::fast_parallel_blobs_do(CodeBlobClosure *f) {
456   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
457   assert(_table_snapshot != NULL, &quot;Sanity&quot;);
458   _table_snapshot-&gt;parallel_blobs_do&lt;CSET_FILTER&gt;(f);
459 }
460 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
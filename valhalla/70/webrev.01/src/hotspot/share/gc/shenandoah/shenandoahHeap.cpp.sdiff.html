<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahCodeRoots.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1813     // cleanup the weak oops in CLD and determinate nmethod&#39;s unloading state, so that we
1814     // can cleanup immediate garbage sooner.
1815     if (_concurrent_class_unloading) {
1816       // Applies ShenandoahIsCLDAlive closure to CLDs, native barrier will either NULL the
1817       // CLD&#39;s holder or evacuate it.
1818       ShenandoahIsCLDAliveClosure is_cld_alive;
1819       _cld_roots.cld_do(&amp;is_cld_alive, worker_id);
1820 
1821       // Applies ShenandoahIsNMethodAliveClosure to registered nmethods.
1822       // The closure calls nmethod-&gt;is_unloading(). The is_unloading
1823       // state is cached, therefore, during concurrent class unloading phase,
1824       // we will not touch the metadata of unloading nmethods
1825       ShenandoahIsNMethodAliveClosure is_nmethod_alive;
1826       _nmethod_itr.nmethods_do(&amp;is_nmethod_alive);
1827     }
1828   }
1829 };
1830 
1831 void ShenandoahHeap::op_weak_roots() {
1832   if (is_concurrent_weak_root_in_progress()) {
<span class="line-modified">1833     // Concurrent weak root processing</span>
<span class="line-modified">1834     ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots);</span>
<span class="line-modified">1835     workers()-&gt;run_task(&amp;task);</span>
<span class="line-modified">1836     if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-modified">1837       set_concurrent_weak_root_in_progress(false);</span>










1838     }
1839   }
1840 }
1841 
1842 void ShenandoahHeap::op_class_unloading() {
1843   assert (is_concurrent_weak_root_in_progress() &amp;&amp;
1844           ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),
1845           &quot;Checked by caller&quot;);
1846   _unloader.unload();
1847   set_concurrent_weak_root_in_progress(false);
1848 }
1849 
1850 void ShenandoahHeap::op_strong_roots() {
1851   assert(is_concurrent_strong_root_in_progress(), &quot;Checked by caller&quot;);
1852   ShenandoahConcurrentRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_strong_roots);
1853   workers()-&gt;run_task(&amp;task);
1854   set_concurrent_strong_root_in_progress(false);
1855 }
1856 
1857 class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
</pre>
<hr />
<pre>
2849 }
2850 
2851 void ShenandoahHeap::entry_updaterefs() {
2852   static const char* msg = &quot;Concurrent update references&quot;;
2853   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_update_refs);
2854   EventMark em(&quot;%s&quot;, msg);
2855 
2856   ShenandoahWorkerScope scope(workers(),
2857                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2858                               &quot;concurrent reference update&quot;);
2859 
2860   try_inject_alloc_failure();
2861   op_updaterefs();
2862 }
2863 
2864 void ShenandoahHeap::entry_weak_roots() {
2865   static const char* msg = &quot;Concurrent weak roots&quot;;
2866   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_weak_roots);
2867   EventMark em(&quot;%s&quot;, msg);
2868 
<span class="line-removed">2869   ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots);</span>
<span class="line-removed">2870 </span>
2871   ShenandoahWorkerScope scope(workers(),
2872                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2873                               &quot;concurrent weak root&quot;);
2874 
2875   try_inject_alloc_failure();
2876   op_weak_roots();
2877 }
2878 
2879 void ShenandoahHeap::entry_class_unloading() {
2880   static const char* msg = &quot;Concurrent class unloading&quot;;
2881   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_class_unload);
2882   EventMark em(&quot;%s&quot;, msg);
2883 
2884   ShenandoahWorkerScope scope(workers(),
2885                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2886                               &quot;concurrent class unloading&quot;);
2887 
2888   try_inject_alloc_failure();
2889   op_class_unloading();
2890 }
</pre>
</td>
<td>
<hr />
<pre>
1813     // cleanup the weak oops in CLD and determinate nmethod&#39;s unloading state, so that we
1814     // can cleanup immediate garbage sooner.
1815     if (_concurrent_class_unloading) {
1816       // Applies ShenandoahIsCLDAlive closure to CLDs, native barrier will either NULL the
1817       // CLD&#39;s holder or evacuate it.
1818       ShenandoahIsCLDAliveClosure is_cld_alive;
1819       _cld_roots.cld_do(&amp;is_cld_alive, worker_id);
1820 
1821       // Applies ShenandoahIsNMethodAliveClosure to registered nmethods.
1822       // The closure calls nmethod-&gt;is_unloading(). The is_unloading
1823       // state is cached, therefore, during concurrent class unloading phase,
1824       // we will not touch the metadata of unloading nmethods
1825       ShenandoahIsNMethodAliveClosure is_nmethod_alive;
1826       _nmethod_itr.nmethods_do(&amp;is_nmethod_alive);
1827     }
1828   }
1829 };
1830 
1831 void ShenandoahHeap::op_weak_roots() {
1832   if (is_concurrent_weak_root_in_progress()) {
<span class="line-modified">1833     {</span>
<span class="line-modified">1834       // Concurrent weak root processing</span>
<span class="line-modified">1835       ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots_work);</span>
<span class="line-modified">1836       ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);</span>
<span class="line-modified">1837       workers()-&gt;run_task(&amp;task);</span>
<span class="line-added">1838       if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">1839         set_concurrent_weak_root_in_progress(false);</span>
<span class="line-added">1840       }</span>
<span class="line-added">1841     }</span>
<span class="line-added">1842 </span>
<span class="line-added">1843     // Perform handshake to flush out dead oops</span>
<span class="line-added">1844     {</span>
<span class="line-added">1845       ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_rendezvous);</span>
<span class="line-added">1846       ShenandoahRendezvousClosure cl;</span>
<span class="line-added">1847       Handshake::execute(&amp;cl);</span>
1848     }
1849   }
1850 }
1851 
1852 void ShenandoahHeap::op_class_unloading() {
1853   assert (is_concurrent_weak_root_in_progress() &amp;&amp;
1854           ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),
1855           &quot;Checked by caller&quot;);
1856   _unloader.unload();
1857   set_concurrent_weak_root_in_progress(false);
1858 }
1859 
1860 void ShenandoahHeap::op_strong_roots() {
1861   assert(is_concurrent_strong_root_in_progress(), &quot;Checked by caller&quot;);
1862   ShenandoahConcurrentRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_strong_roots);
1863   workers()-&gt;run_task(&amp;task);
1864   set_concurrent_strong_root_in_progress(false);
1865 }
1866 
1867 class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
</pre>
<hr />
<pre>
2859 }
2860 
2861 void ShenandoahHeap::entry_updaterefs() {
2862   static const char* msg = &quot;Concurrent update references&quot;;
2863   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_update_refs);
2864   EventMark em(&quot;%s&quot;, msg);
2865 
2866   ShenandoahWorkerScope scope(workers(),
2867                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2868                               &quot;concurrent reference update&quot;);
2869 
2870   try_inject_alloc_failure();
2871   op_updaterefs();
2872 }
2873 
2874 void ShenandoahHeap::entry_weak_roots() {
2875   static const char* msg = &quot;Concurrent weak roots&quot;;
2876   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_weak_roots);
2877   EventMark em(&quot;%s&quot;, msg);
2878 


2879   ShenandoahWorkerScope scope(workers(),
2880                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2881                               &quot;concurrent weak root&quot;);
2882 
2883   try_inject_alloc_failure();
2884   op_weak_roots();
2885 }
2886 
2887 void ShenandoahHeap::entry_class_unloading() {
2888   static const char* msg = &quot;Concurrent class unloading&quot;;
2889   ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_class_unload);
2890   EventMark em(&quot;%s&quot;, msg);
2891 
2892   ShenandoahWorkerScope scope(workers(),
2893                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2894                               &quot;concurrent class unloading&quot;);
2895 
2896   try_inject_alloc_failure();
2897   op_class_unloading();
2898 }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahCodeRoots.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
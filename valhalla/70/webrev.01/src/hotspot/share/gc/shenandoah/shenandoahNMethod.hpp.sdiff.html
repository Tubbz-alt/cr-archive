<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahNMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 34 
 35 // ShenandoahNMethod tuple records the internal locations of oop slots within reclocation stream in
 36 // the nmethod. This allows us to quickly scan the oops without doing the nmethod-internal scans,
 37 // that sometimes involves parsing the machine code. Note it does not record the oops themselves,
 38 // because it would then require handling these tuples as the new class of roots.
 39 class ShenandoahNMethod : public CHeapObj&lt;mtGC&gt; {
 40 private:
 41   nmethod* const          _nm;
 42   oop**                   _oops;
 43   int                     _oops_count;
 44   bool                    _has_non_immed_oops;
 45   bool                    _unregistered;
 46   ShenandoahReentrantLock _lock;
 47 
 48 public:
 49   ShenandoahNMethod(nmethod *nm, GrowableArray&lt;oop*&gt;&amp; oops, bool has_non_immed_oops);
 50   ~ShenandoahNMethod();
 51 
 52   inline nmethod* nm() const;
 53   inline ShenandoahReentrantLock* lock();
<span class="line-modified"> 54   void oops_do(OopClosure* oops, bool fix_relocations = false);</span>
 55   // Update oops when the nmethod is re-registered
 56   void update();
 57 
 58   bool has_cset_oops(ShenandoahHeap* heap);
 59 
 60   inline int oop_count() const;
 61   inline bool has_oops() const;
 62 
 63   inline void mark_unregistered();
 64   inline bool is_unregistered() const;
 65 
 66   static ShenandoahNMethod* for_nmethod(nmethod* nm);
 67   static inline ShenandoahReentrantLock* lock_for_nmethod(nmethod* nm);
 68 
 69   static void heal_nmethod(nmethod* nm);

 70   static inline void disarm_nmethod(nmethod* nm);
 71 
 72   static inline ShenandoahNMethod* gc_data(nmethod* nm);
 73   static inline void attach_gc_data(nmethod* nm, ShenandoahNMethod* gc_data);
 74 
 75   void assert_alive_and_correct() NOT_DEBUG_RETURN;
 76   void assert_same_oops(bool allow_dead = false) NOT_DEBUG_RETURN;
 77   static void assert_no_oops(nmethod* nm, bool allow_dea = false) NOT_DEBUG_RETURN;
 78 
 79 private:
 80   bool has_non_immed_oops() const { return _has_non_immed_oops; }
 81   static void detect_reloc_oops(nmethod* nm, GrowableArray&lt;oop*&gt;&amp; oops, bool&amp; _has_non_immed_oops);
 82 };
 83 
 84 class ShenandoahNMethodTable;
 85 
 86 // ShenandoahNMethodList holds registered nmethod data. The list is reference counted.
 87 class ShenandoahNMethodList : public CHeapObj&lt;mtGC&gt; {
 88 private:
 89   ShenandoahNMethod** _list;
</pre>
</td>
<td>
<hr />
<pre>
 34 
 35 // ShenandoahNMethod tuple records the internal locations of oop slots within reclocation stream in
 36 // the nmethod. This allows us to quickly scan the oops without doing the nmethod-internal scans,
 37 // that sometimes involves parsing the machine code. Note it does not record the oops themselves,
 38 // because it would then require handling these tuples as the new class of roots.
 39 class ShenandoahNMethod : public CHeapObj&lt;mtGC&gt; {
 40 private:
 41   nmethod* const          _nm;
 42   oop**                   _oops;
 43   int                     _oops_count;
 44   bool                    _has_non_immed_oops;
 45   bool                    _unregistered;
 46   ShenandoahReentrantLock _lock;
 47 
 48 public:
 49   ShenandoahNMethod(nmethod *nm, GrowableArray&lt;oop*&gt;&amp; oops, bool has_non_immed_oops);
 50   ~ShenandoahNMethod();
 51 
 52   inline nmethod* nm() const;
 53   inline ShenandoahReentrantLock* lock();
<span class="line-modified"> 54   inline void oops_do(OopClosure* oops, bool fix_relocations = false);</span>
 55   // Update oops when the nmethod is re-registered
 56   void update();
 57 
 58   bool has_cset_oops(ShenandoahHeap* heap);
 59 
 60   inline int oop_count() const;
 61   inline bool has_oops() const;
 62 
 63   inline void mark_unregistered();
 64   inline bool is_unregistered() const;
 65 
 66   static ShenandoahNMethod* for_nmethod(nmethod* nm);
 67   static inline ShenandoahReentrantLock* lock_for_nmethod(nmethod* nm);
 68 
 69   static void heal_nmethod(nmethod* nm);
<span class="line-added"> 70   static inline void heal_nmethod_metadata(ShenandoahNMethod* nmethod_data);</span>
 71   static inline void disarm_nmethod(nmethod* nm);
 72 
 73   static inline ShenandoahNMethod* gc_data(nmethod* nm);
 74   static inline void attach_gc_data(nmethod* nm, ShenandoahNMethod* gc_data);
 75 
 76   void assert_alive_and_correct() NOT_DEBUG_RETURN;
 77   void assert_same_oops(bool allow_dead = false) NOT_DEBUG_RETURN;
 78   static void assert_no_oops(nmethod* nm, bool allow_dea = false) NOT_DEBUG_RETURN;
 79 
 80 private:
 81   bool has_non_immed_oops() const { return _has_non_immed_oops; }
 82   static void detect_reloc_oops(nmethod* nm, GrowableArray&lt;oop*&gt;&amp; oops, bool&amp; _has_non_immed_oops);
 83 };
 84 
 85 class ShenandoahNMethodTable;
 86 
 87 // ShenandoahNMethodList holds registered nmethod data. The list is reference counted.
 88 class ShenandoahNMethodList : public CHeapObj&lt;mtGC&gt; {
 89 private:
 90   ShenandoahNMethod** _list;
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahNMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
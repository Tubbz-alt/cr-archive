<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewValueTypeInstance;
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
  96 class         LookupSwitch;
  97 class       Return;
  98 class       Throw;
  99 class       Base;
 100 class   RoundFP;
 101 class   UnsafeOp;
 102 class     UnsafeRawOp;
 103 class       UnsafeGetRaw;
 104 class       UnsafePutRaw;
 105 class     UnsafeObjectOp;
 106 class       UnsafeGetObject;
 107 class       UnsafePutObject;
 108 class         UnsafeGetAndSetObject;
 109 class   ProfileCall;
 110 class   ProfileReturnType;
 111 class   ProfileInvoke;
 112 class   RuntimeCall;
 113 class   MemBar;
 114 class   RangeCheckPredicate;
 115 #ifdef ASSERT
 116 class   Assert;
 117 #endif
 118 
 119 // A Value is a reference to the instruction creating the value
 120 typedef Instruction* Value;
 121 typedef GrowableArray&lt;Value&gt; Values;
 122 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 123 
 124 // BlockClosure is the base class for block traversal/iteration.
 125 
 126 class BlockClosure: public CompilationResourceObj {
 127  public:
 128   virtual void block_do(BlockBegin* block)       = 0;
 129 };
 130 
 131 
 132 // A simple closure class for visiting the values of an Instruction
 133 class ValueVisitor: public StackObj {
 134  public:
 135   virtual void visit(Value* v) = 0;
 136 };
 137 
 138 
 139 // Some array and list classes
 140 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 141 
 142 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 143  public:
 144   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 145   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 146   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 147 
 148   void iterate_forward(BlockClosure* closure);
 149   void iterate_backward(BlockClosure* closure);
 150   void blocks_do(void f(BlockBegin*));
 151   void values_do(ValueVisitor* f);
 152   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 153 };
 154 
 155 
 156 // InstructionVisitors provide type-based dispatch for instructions.
 157 // For each concrete Instruction class X, a virtual function do_X is
 158 // provided. Functionality that needs to be implemented for all classes
 159 // (e.g., printing, code generation) is factored out into a specialised
 160 // visitor instead of added to the Instruction classes itself.
 161 
 162 class InstructionVisitor: public StackObj {
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
 183   virtual void do_NewValueTypeInstance(NewValueTypeInstance* x) = 0;
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 204   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 205   virtual void do_RoundFP        (RoundFP*         x) = 0;
 206   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 207   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 208   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 209   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 210   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 211   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 212   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 213   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 214   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 215   virtual void do_MemBar         (MemBar*          x) = 0;
 216   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 217 #ifdef ASSERT
 218   virtual void do_Assert         (Assert*          x) = 0;
 219 #endif
 220 };
 221 
 222 
 223 // Hashing support
 224 //
 225 // Note: This hash functions affect the performance
 226 //       of ValueMap - make changes carefully!
 227 
 228 #define HASH1(x1            )                    ((intx)(x1))
 229 #define HASH2(x1, x2        )                    ((HASH1(x1            ) &lt;&lt; 7) ^ HASH1(x2))
 230 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2        ) &lt;&lt; 7) ^ HASH1(x3))
 231 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3    ) &lt;&lt; 7) ^ HASH1(x4))
 232 #define HASH5(x1, x2, x3, x4, x5)                ((HASH4(x1, x2, x3, x4) &lt;&lt; 7) ^ HASH1(x5))
 233 
 234 
 235 // The following macros are used to implement instruction-specific hashing.
 236 // By default, each instruction implements hash() and is_equal(Value), used
 237 // for value numbering/common subexpression elimination. The default imple-
 238 // mentation disables value numbering. Each instruction which can be value-
 239 // numbered, should define corresponding hash() and is_equal(Value) functions
 240 // via the macros below. The f arguments specify all the values/op codes, etc.
 241 // that need to be identical for two instructions to be identical.
 242 //
 243 // Note: The default implementation of hash() returns 0 in order to indicate
 244 //       that the instruction should not be considered for value numbering.
 245 //       The currently used hash functions do not guarantee that never a 0
 246 //       is produced. While this is still correct, it may be a performance
 247 //       bug (no value numbering for that node). However, this situation is
 248 //       so unlikely, that we are not going to handle it specially.
 249 
 250 #define HASHING1(class_name, enabled, f1)             \
 251   virtual intx hash() const {                         \
 252     return (enabled) ? HASH2(name(), f1) : 0;         \
 253   }                                                   \
 254   virtual bool is_equal(Value v) const {              \
 255     if (!(enabled)  ) return false;                   \
 256     class_name* _v = v-&gt;as_##class_name();            \
 257     if (_v == NULL  ) return false;                   \
 258     if (f1 != _v-&gt;f1) return false;                   \
 259     return true;                                      \
 260   }                                                   \
 261 
 262 
 263 #define HASHING2(class_name, enabled, f1, f2)         \
 264   virtual intx hash() const {                         \
 265     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 266   }                                                   \
 267   virtual bool is_equal(Value v) const {              \
 268     if (!(enabled)  ) return false;                   \
 269     class_name* _v = v-&gt;as_##class_name();            \
 270     if (_v == NULL  ) return false;                   \
 271     if (f1 != _v-&gt;f1) return false;                   \
 272     if (f2 != _v-&gt;f2) return false;                   \
 273     return true;                                      \
 274   }                                                   \
 275 
 276 
 277 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 278   virtual intx hash() const {                         \
 279     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 280   }                                                   \
 281   virtual bool is_equal(Value v) const {              \
 282     if (!(enabled)  ) return false;                   \
 283     class_name* _v = v-&gt;as_##class_name();            \
 284     if (_v == NULL  ) return false;                   \
 285     if (f1 != _v-&gt;f1) return false;                   \
 286     if (f2 != _v-&gt;f2) return false;                   \
 287     if (f3 != _v-&gt;f3) return false;                   \
 288     return true;                                      \
 289   }                                                   \
 290 
 291 #define HASHING4(class_name, enabled, f1, f2, f3, f4) \
 292   virtual intx hash() const {                         \
 293     return (enabled) ? HASH5(name(), f1, f2, f3, f4) : 0; \
 294   }                                                   \
 295   virtual bool is_equal(Value v) const {              \
 296     if (!(enabled)  ) return false;                   \
 297     class_name* _v = v-&gt;as_##class_name();            \
 298     if (_v == NULL  ) return false;                   \
 299     if (f1 != _v-&gt;f1) return false;                   \
 300     if (f2 != _v-&gt;f2) return false;                   \
 301     if (f3 != _v-&gt;f3) return false;                   \
 302     if (f4 != _v-&gt;f4) return false;                   \
 303     return true;                                      \
 304   }                                                   \
 305 
 306 
 307 // The mother of all instructions...
 308 
 309 class Instruction: public CompilationResourceObj {
 310  private:
 311   int          _id;                              // the unique instruction id
 312 #ifndef PRODUCT
 313   int          _printable_bci;                   // the bci of the instruction for printing
 314 #endif
 315   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 316   int          _pin_state;                       // set of PinReason describing the reason for pinning
 317   ValueType*   _type;                            // the instruction value type
 318   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 319   Instruction* _subst;                           // the substitution instruction if any
 320   LIR_Opr      _operand;                         // LIR specific information
 321   unsigned int _flags;                           // Flag bits
 322 
 323   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 324   ValueStack*  _exception_state;                 // Copy of state for exception handling
 325   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 326 
 327   friend class UseCountComputer;
<a name="1" id="anc1"></a><span class="line-removed"> 328   friend class BlockBegin;</span>
 329 
 330   void update_exception_state(ValueStack* state);
 331 
 332  protected:
 333   BlockBegin*  _block;                           // Block that contains this instruction
 334 
 335   void set_type(ValueType* type) {
 336     assert(type != NULL, &quot;type must exist&quot;);
 337     _type = type;
 338   }
 339 
 340   // Helper class to keep track of which arguments need a null check
 341   class ArgsNonNullState {
 342   private:
 343     int _nonnull_state; // mask identifying which args are nonnull
 344   public:
 345     ArgsNonNullState()
 346       : _nonnull_state(AllBits) {}
 347 
 348     // Does argument number i needs a null check?
 349     bool arg_needs_null_check(int i) const {
 350       // No data is kept for arguments starting at position 33 so
 351       // conservatively assume that they need a null check.
 352       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 353         return is_set_nth_bit(_nonnull_state, i);
 354       }
 355       return true;
 356     }
 357 
 358     // Set whether argument number i needs a null check or not
 359     void set_arg_needs_null_check(int i, bool check) {
 360       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 361         if (check) {
 362           _nonnull_state |= nth_bit(i);
 363         } else {
 364           _nonnull_state &amp;= ~(nth_bit(i));
 365         }
 366       }
 367     }
 368   };
 369 
 370  public:
 371   void* operator new(size_t size) throw() {
 372     Compilation* c = Compilation::current();
 373     void* res = c-&gt;arena()-&gt;Amalloc(size);
<a name="2" id="anc2"></a><span class="line-removed"> 374     ((Instruction*)res)-&gt;_id = c-&gt;get_next_id();</span>
 375     return res;
 376   }
 377 
 378   static const int no_bci = -99;
 379 
 380   enum InstructionFlag {
 381     NeedsNullCheckFlag = 0,
 382     NeverNullFlag,          // For &quot;Q&quot; signatures
 383     CanTrapFlag,
 384     DirectCompareFlag,
 385     IsEliminatedFlag,
 386     IsSafepointFlag,
 387     IsStaticFlag,
 388     IsStrictfpFlag,
 389     NeedsStoreCheckFlag,
 390     NeedsWriteBarrierFlag,
 391     PreservesStateFlag,
 392     TargetIsFinalFlag,
 393     TargetIsLoadedFlag,
 394     TargetIsStrictfpFlag,
 395     UnorderedIsTrueFlag,
 396     NeedsPatchingFlag,
 397     ThrowIncompatibleClassChangeErrorFlag,
 398     InvokeSpecialReceiverCheckFlag,
 399     ProfileMDOFlag,
 400     IsLinkedInBlockFlag,
 401     NeedsRangeCheckFlag,
 402     InWorkListFlag,
 403     DeoptimizeOnException,
 404     InstructionLastFlag
 405   };
 406 
 407  public:
 408   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 409   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 410 
 411   // &#39;globally&#39; used condition values
 412   enum Condition {
 413     eql, neq, lss, leq, gtr, geq, aeq, beq
 414   };
 415 
 416   // Instructions may be pinned for many reasons and under certain conditions
 417   // with enough knowledge it&#39;s possible to safely unpin them.
 418   enum PinReason {
 419       PinUnknown           = 1 &lt;&lt; 0
 420     , PinExplicitNullCheck = 1 &lt;&lt; 3
 421     , PinStackForStateSplit= 1 &lt;&lt; 12
 422     , PinStateSplitConstructor= 1 &lt;&lt; 13
 423     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 424   };
 425 
 426   static Condition mirror(Condition cond);
 427   static Condition negate(Condition cond);
 428 
 429   // initialization
 430   static int number_of_instructions() {
 431     return Compilation::current()-&gt;number_of_instructions();
 432   }
 433 
 434   // creation
 435   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
<a name="3" id="anc3"></a><span class="line-modified"> 436   :</span>
 437 #ifndef PRODUCT
 438   _printable_bci(-99),
 439 #endif
 440     _use_count(0)
 441   , _pin_state(0)
 442   , _type(type)
 443   , _next(NULL)
 444   , _subst(NULL)
 445   , _operand(LIR_OprFact::illegalOpr)
 446   , _flags(0)
 447   , _state_before(state_before)
 448   , _exception_handlers(NULL)
 449   , _block(NULL)
 450   {
 451     check_state(state_before);
 452     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 453     update_exception_state(_state_before);
 454   }
 455 
 456   // accessors
 457   int id() const                                 { return _id; }
 458 #ifndef PRODUCT
 459   bool has_printable_bci() const                 { return _printable_bci != -99; }
 460   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 461   void set_printable_bci(int bci)                { _printable_bci = bci; }
 462 #endif
 463   int dominator_depth();
 464   int use_count() const                          { return _use_count; }
 465   int pin_state() const                          { return _pin_state; }
 466   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 467   ValueType* type() const                        { return _type; }
 468   BlockBegin *block() const                      { return _block; }
 469   Instruction* prev();                           // use carefully, expensive operation
 470   Instruction* next() const                      { return _next; }
 471   bool has_subst() const                         { return _subst != NULL; }
 472   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 473   LIR_Opr operand() const                        { return _operand; }
 474 
 475   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 476   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 477   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }
 478   bool is_never_null() const                     { return check_flag(NeverNullFlag); }
 479   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 480   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 481 
 482   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 483 
 484   bool has_uses() const                          { return use_count() &gt; 0; }
 485   ValueStack* state_before() const               { return _state_before; }
 486   ValueStack* exception_state() const            { return _exception_state; }
 487   virtual bool needs_exception_state() const     { return true; }
 488   XHandlers* exception_handlers() const          { return _exception_handlers; }
 489   ciKlass* as_loaded_klass_or_null() const;
 490 
 491   // withfield optimization
 492   virtual void set_escaped()                     { }
 493   virtual void set_local_index(int index)        { }
 494   virtual bool is_optimizable_for_withfield() const { return false; }
 495 
 496 
 497   // manipulation
 498   void pin(PinReason reason)                     { _pin_state |= reason; }
 499   void pin()                                     { _pin_state |= PinUnknown; }
 500   // DANGEROUS: only used by EliminateStores
 501   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 502 
 503   Instruction* set_next(Instruction* next) {
 504     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 505     assert(next != NULL, &quot;must not be NULL&quot;);
 506     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 507     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 508 
 509     BlockBegin *block = this-&gt;block();
 510     next-&gt;_block = block;
 511 
 512     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 513     _next = next;
 514     return next;
 515   }
 516 
 517   Instruction* set_next(Instruction* next, int bci) {
 518 #ifndef PRODUCT
 519     next-&gt;set_printable_bci(bci);
 520 #endif
 521     return set_next(next);
 522   }
 523 
 524   // when blocks are merged
 525   void fixup_block_pointers() {
 526     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 527     while (cur &amp;&amp; cur-&gt;_block != block()) {
 528       cur-&gt;_block = block();
 529       cur = cur-&gt;next();
 530     }
 531   }
 532 
 533   Instruction *insert_after(Instruction *i) {
 534     Instruction* n = _next;
 535     set_next(i);
 536     i-&gt;set_next(n);
 537     return _next;
 538   }
 539 
 540   bool is_loaded_flattened_array() const;
 541   bool maybe_flattened_array();
 542   bool maybe_null_free_array();
 543 
 544   Instruction *insert_after_same_bci(Instruction *i) {
 545 #ifndef PRODUCT
 546     i-&gt;set_printable_bci(printable_bci());
 547 #endif
 548     return insert_after(i);
 549   }
 550 
 551   void set_subst(Instruction* subst)             {
 552     assert(subst == NULL ||
 553            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 554            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 555     _subst = subst;
 556   }
 557   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 558   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 559   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 560 
 561   // machine-specifics
 562   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 563   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 564 
 565   // generic
 566   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 567   virtual Phi*              as_Phi()             { return NULL; }
 568   virtual Local*            as_Local()           { return NULL; }
 569   virtual Constant*         as_Constant()        { return NULL; }
 570   virtual AccessField*      as_AccessField()     { return NULL; }
 571   virtual LoadField*        as_LoadField()       { return NULL; }
 572   virtual StoreField*       as_StoreField()      { return NULL; }
 573   virtual AccessArray*      as_AccessArray()     { return NULL; }
 574   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 575   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 576   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 577   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 578   virtual NegateOp*         as_NegateOp()        { return NULL; }
 579   virtual Op2*              as_Op2()             { return NULL; }
 580   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 581   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 582   virtual LogicOp*          as_LogicOp()         { return NULL; }
 583   virtual CompareOp*        as_CompareOp()       { return NULL; }
 584   virtual IfOp*             as_IfOp()            { return NULL; }
 585   virtual Convert*          as_Convert()         { return NULL; }
 586   virtual NullCheck*        as_NullCheck()       { return NULL; }
 587   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 588   virtual StateSplit*       as_StateSplit()      { return NULL; }
 589   virtual Invoke*           as_Invoke()          { return NULL; }
 590   virtual NewInstance*      as_NewInstance()     { return NULL; }
 591   virtual NewValueTypeInstance* as_NewValueTypeInstance() { return NULL; }
 592   virtual NewArray*         as_NewArray()        { return NULL; }
 593   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 594   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 595   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 596   virtual WithField*        as_WithField()       { return NULL; }
 597   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 598   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 599   virtual CheckCast*        as_CheckCast()       { return NULL; }
 600   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 601   virtual TypeCast*         as_TypeCast()        { return NULL; }
 602   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 603   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 604   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 605   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 606   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 607   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 608   virtual Goto*             as_Goto()            { return NULL; }
 609   virtual If*               as_If()              { return NULL; }
 610   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 611   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 612   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 613   virtual Return*           as_Return()          { return NULL; }
 614   virtual Throw*            as_Throw()           { return NULL; }
 615   virtual Base*             as_Base()            { return NULL; }
 616   virtual RoundFP*          as_RoundFP()         { return NULL; }
 617   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 618   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 619   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 620   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 621 
 622 #ifdef ASSERT
 623   virtual Assert*           as_Assert()          { return NULL; }
 624 #endif
 625 
 626   virtual void visit(InstructionVisitor* v)      = 0;
 627 
 628   virtual bool can_trap() const                  { return false; }
 629 
 630   virtual void input_values_do(ValueVisitor* f)   = 0;
 631   virtual void state_values_do(ValueVisitor* f);
 632   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 633           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 634 
 635   virtual ciType* exact_type() const;
 636   virtual ciType* declared_type() const          { return NULL; }
 637 
 638   // hashing
 639   virtual const char* name() const               = 0;
 640   HASHING1(Instruction, false, id())             // hashing disabled by default
 641 
 642   // debugging
 643   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 644   void print()                                   PRODUCT_RETURN;
 645   void print_line()                              PRODUCT_RETURN;
 646   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 647 };
 648 
 649 
 650 // The following macros are used to define base (i.e., non-leaf)
 651 // and leaf instruction classes. They define class-name related
 652 // generic functionality in one place.
 653 
 654 #define BASE(class_name, super_class_name)       \
 655   class class_name: public super_class_name {    \
 656    public:                                       \
 657     virtual class_name* as_##class_name()        { return this; }              \
 658 
 659 
 660 #define LEAF(class_name, super_class_name)       \
 661   BASE(class_name, super_class_name)             \
 662    public:                                       \
 663     virtual const char* name() const             { return #class_name; }       \
 664     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 665 
 666 
 667 // Debugging support
 668 
 669 
 670 #ifdef ASSERT
 671 class AssertValues: public ValueVisitor {
 672   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 673 };
 674   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 675 #else
 676   #define ASSERT_VALUES
 677 #endif // ASSERT
 678 
 679 
 680 // A Phi is a phi function in the sense of SSA form. It stands for
 681 // the value of a local variable at the beginning of a join block.
 682 // A Phi consists of n operands, one for every incoming branch.
 683 
 684 LEAF(Phi, Instruction)
 685  private:
 686   int         _pf_flags; // the flags of the phi function
 687   int         _index;    // to value on operand stack (index &lt; 0) or to local
 688  public:
 689   // creation
 690   Phi(ValueType* type, BlockBegin* b, int index)
 691   : Instruction(type-&gt;base())
 692   , _pf_flags(0)
 693   , _index(index)
 694   {
 695     _block = b;
 696     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 697     if (type-&gt;is_illegal()) {
 698       make_illegal();
 699     }
 700   }
 701 
 702   // flags
 703   enum Flag {
 704     no_flag         = 0,
 705     visited         = 1 &lt;&lt; 0,
 706     cannot_simplify = 1 &lt;&lt; 1
 707   };
 708 
 709   // accessors
 710   bool  is_local() const          { return _index &gt;= 0; }
 711   bool  is_on_stack() const       { return !is_local(); }
 712   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 713   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 714 
 715   Value operand_at(int i) const;
 716   int   operand_count() const;
 717 
 718   void   set(Flag f)              { _pf_flags |=  f; }
 719   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 720   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 721 
 722   // Invalidates phis corresponding to merges of locals of two different types
 723   // (these should never be referenced, otherwise the bytecodes are illegal)
 724   void   make_illegal() {
 725     set(cannot_simplify);
 726     set_type(illegalType);
 727   }
 728 
 729   bool is_illegal() const {
 730     return type()-&gt;is_illegal();
 731   }
 732 
 733   // generic
 734   virtual void input_values_do(ValueVisitor* f) {
 735   }
 736 };
 737 
 738 
 739 // A local is a placeholder for an incoming argument to a function call.
 740 LEAF(Local, Instruction)
 741  private:
 742   int      _java_index;                          // the local index within the method to which the local belongs
 743   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 744   ciType*  _declared_type;
 745  public:
 746   // creation
 747   Local(ciType* declared, ValueType* type, int index, bool receiver, bool never_null)
 748     : Instruction(type)
 749     , _java_index(index)
 750     , _is_receiver(receiver)
 751     , _declared_type(declared)
 752   {
 753     set_never_null(never_null);
 754     NOT_PRODUCT(set_printable_bci(-1));
 755   }
 756 
 757   // accessors
 758   int java_index() const                         { return _java_index; }
 759   bool is_receiver() const                       { return _is_receiver; }
 760 
 761   virtual ciType* declared_type() const          { return _declared_type; }
 762 
 763   // generic
 764   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 765 };
 766 
 767 
 768 LEAF(Constant, Instruction)
 769  public:
 770   // creation
 771   Constant(ValueType* type):
 772       Instruction(type, NULL, /*type_is_constant*/ true)
 773   {
 774     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 775   }
 776 
 777   Constant(ValueType* type, ValueStack* state_before):
 778     Instruction(type, state_before, /*type_is_constant*/ true)
 779   {
 780     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 781     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 782     // since it&#39;s patching it needs to be pinned
 783     pin();
 784   }
 785 
 786   // generic
 787   virtual bool can_trap() const                  { return state_before() != NULL; }
 788   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 789 
 790   virtual intx hash() const;
 791   virtual bool is_equal(Value v) const;
 792 
 793   virtual ciType* exact_type() const;
 794 
 795   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 796 
 797   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 798   BlockBegin* compare(Instruction::Condition cond, Value right,
 799                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 800     switch (compare(cond, right)) {
 801     case not_comparable:
 802       return NULL;
 803     case cond_false:
 804       return false_sux;
 805     case cond_true:
 806       return true_sux;
 807     default:
 808       ShouldNotReachHere();
 809       return NULL;
 810     }
 811   }
 812 };
 813 
 814 
 815 BASE(AccessField, Instruction)
 816  private:
 817   Value       _obj;
 818   int         _offset;
 819   ciField*    _field;
 820   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 821 
 822  public:
 823   // creation
 824   AccessField(Value obj, int offset, ciField* field, bool is_static,
 825               ValueStack* state_before, bool needs_patching)
 826   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 827   , _obj(obj)
 828   , _offset(offset)
 829   , _field(field)
 830   , _explicit_null_check(NULL)
 831   {
 832     set_needs_null_check(!is_static);
 833     set_flag(IsStaticFlag, is_static);
 834     set_flag(NeedsPatchingFlag, needs_patching);
 835     ASSERT_VALUES
 836     // pin of all instructions with memory access
 837     pin();
 838   }
 839 
 840   // accessors
 841   Value obj() const                              { return _obj; }
 842   int offset() const                             { return _offset; }
 843   ciField* field() const                         { return _field; }
 844   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 845   bool is_static() const                         { return check_flag(IsStaticFlag); }
 846   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 847   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 848 
 849   // Unresolved getstatic and putstatic can cause initialization.
 850   // Technically it occurs at the Constant that materializes the base
 851   // of the static fields but it&#39;s simpler to model it here.
 852   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 853 
 854   // manipulation
 855 
 856   // Under certain circumstances, if a previous NullCheck instruction
 857   // proved the target object non-null, we can eliminate the explicit
 858   // null check and do an implicit one, simply specifying the debug
 859   // information from the NullCheck. This field should only be consulted
 860   // if needs_null_check() is true.
 861   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 862 
 863   // generic
 864   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 865   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 866 };
 867 
 868 
 869 LEAF(LoadField, AccessField)
 870  public:
 871   // creation
 872   LoadField(Value obj, int offset, ciField* field, bool is_static,
 873             ValueStack* state_before, bool needs_patching,
 874             ciValueKlass* value_klass = NULL, Value default_value = NULL )
 875   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 876   {}
 877 
 878   ciType* declared_type() const;
 879 
 880   // generic; cannot be eliminated if needs patching or if volatile.
 881   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 882 };
 883 
 884 
 885 LEAF(StoreField, AccessField)
 886  private:
 887   Value _value;
 888 
 889  public:
 890   // creation
 891   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 892              ValueStack* state_before, bool needs_patching)
 893   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 894   , _value(value)
 895   {
 896     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 897     ASSERT_VALUES
 898     pin();
 899   }
 900 
 901   // accessors
 902   Value value() const                            { return _value; }
 903   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 904 
 905   // generic
 906   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 907 };
 908 
 909 
 910 BASE(AccessArray, Instruction)
 911  private:
 912   Value       _array;
 913 
 914  public:
 915   // creation
 916   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 917   : Instruction(type, state_before)
 918   , _array(array)
 919   {
 920     set_needs_null_check(true);
 921     ASSERT_VALUES
 922     pin(); // instruction with side effect (null exception or range check throwing)
 923   }
 924 
 925   Value array() const                            { return _array; }
 926 
 927   // generic
 928   virtual bool can_trap() const                  { return needs_null_check(); }
 929   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 930 };
 931 
 932 
 933 LEAF(ArrayLength, AccessArray)
 934  private:
 935   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 936 
 937  public:
 938   // creation
 939   ArrayLength(Value array, ValueStack* state_before)
 940   : AccessArray(intType, array, state_before)
 941   , _explicit_null_check(NULL) {}
 942 
 943   // accessors
 944   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 945 
 946   // setters
 947   // See LoadField::set_explicit_null_check for documentation
 948   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 949 
 950   // generic
 951   HASHING1(ArrayLength, true, array()-&gt;subst())
 952 };
 953 
 954 
 955 BASE(AccessIndexed, AccessArray)
 956  private:
 957   Value     _index;
 958   Value     _length;
 959   BasicType _elt_type;
 960   bool      _mismatched;
 961   ciMethod* _profiled_method;
 962   int       _profiled_bci;
 963 
 964  public:
 965   // creation
 966   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 967   : AccessArray(as_ValueType(elt_type), array, state_before)
 968   , _index(index)
 969   , _length(length)
 970   , _elt_type(elt_type)
 971   , _mismatched(mismatched)
 972   , _profiled_method(NULL), _profiled_bci(0)
 973   {
 974     set_flag(Instruction::NeedsRangeCheckFlag, true);
 975     ASSERT_VALUES
 976   }
 977 
 978   // accessors
 979   Value index() const                            { return _index; }
 980   Value length() const                           { return _length; }
 981   BasicType elt_type() const                     { return _elt_type; }
 982   bool mismatched() const                        { return _mismatched; }
 983 
 984   void clear_length()                            { _length = NULL; }
 985   // perform elimination of range checks involving constants
 986   bool compute_needs_range_check();
 987 
 988   // Helpers for MethodData* profiling
 989   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 990   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 991   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 992   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 993   ciMethod* profiled_method() const                  { return _profiled_method;     }
 994   int       profiled_bci() const                     { return _profiled_bci;        }
 995 
 996 
 997 // generic
 998   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 999 };
1000 
1001 
1002 LEAF(LoadIndexed, AccessIndexed)
1003  private:
1004   NullCheck*  _explicit_null_check;              // For explicit null check elimination
1005   NewValueTypeInstance* _vt;
1006 
1007  public:
1008   // creation
1009   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
1010   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1011   , _explicit_null_check(NULL), _vt(NULL) {}
1012 
1013   // accessors
1014   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
1015 
1016   // setters
1017   // See LoadField::set_explicit_null_check for documentation
1018   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1019 
1020   ciType* exact_type() const;
1021   ciType* declared_type() const;
1022 
1023   NewValueTypeInstance* vt() const { return _vt; }
1024   void set_vt(NewValueTypeInstance* vt) { _vt = vt; }
1025 
1026   // generic
1027   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())
1028 };
1029 
1030 
1031 LEAF(StoreIndexed, AccessIndexed)
1032  private:
1033   Value       _value;
1034 
1035   bool      _check_boolean;
1036 
1037  public:
1038   // creation
1039   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1040                bool check_boolean, bool mismatched = false)
1041   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1042   , _value(value), _check_boolean(check_boolean)
1043   {
1044     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
1045     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
1046     ASSERT_VALUES
1047     pin();
1048   }
1049 
1050   // accessors
1051   Value value() const                            { return _value; }
1052   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
1053   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
1054   bool check_boolean() const                     { return _check_boolean; }
1055 
1056   // Flattened array support
1057   bool is_exact_flattened_array_store() const;
1058   // generic
1059   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1060 };
1061 
1062 
1063 LEAF(NegateOp, Instruction)
1064  private:
1065   Value _x;
1066 
1067  public:
1068   // creation
1069   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1070     ASSERT_VALUES
1071   }
1072 
1073   // accessors
1074   Value x() const                                { return _x; }
1075 
1076   // generic
1077   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1078 };
1079 
1080 
1081 BASE(Op2, Instruction)
1082  private:
1083   Bytecodes::Code _op;
1084   Value           _x;
1085   Value           _y;
1086 
1087  public:
1088   // creation
1089   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1090   : Instruction(type, state_before)
1091   , _op(op)
1092   , _x(x)
1093   , _y(y)
1094   {
1095     ASSERT_VALUES
1096   }
1097 
1098   // accessors
1099   Bytecodes::Code op() const                     { return _op; }
1100   Value x() const                                { return _x; }
1101   Value y() const                                { return _y; }
1102 
1103   // manipulators
1104   void swap_operands() {
1105     assert(is_commutative(), &quot;operation must be commutative&quot;);
1106     Value t = _x; _x = _y; _y = t;
1107   }
1108 
1109   // generic
1110   virtual bool is_commutative() const            { return false; }
1111   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1112 };
1113 
1114 
1115 LEAF(ArithmeticOp, Op2)
1116  public:
1117   // creation
1118   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1119   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1120   {
1121     set_flag(IsStrictfpFlag, is_strictfp);
1122     if (can_trap()) pin();
1123   }
1124 
1125   // accessors
1126   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1127 
1128   // generic
1129   virtual bool is_commutative() const;
1130   virtual bool can_trap() const;
1131   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1132 };
1133 
1134 
1135 LEAF(ShiftOp, Op2)
1136  public:
1137   // creation
1138   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1139 
1140   // generic
1141   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1142 };
1143 
1144 
1145 LEAF(LogicOp, Op2)
1146  public:
1147   // creation
1148   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1149 
1150   // generic
1151   virtual bool is_commutative() const;
1152   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1153 };
1154 
1155 
1156 LEAF(CompareOp, Op2)
1157  public:
1158   // creation
1159   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1160   : Op2(intType, op, x, y, state_before)
1161   {}
1162 
1163   // generic
1164   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1165 };
1166 
1167 
1168 LEAF(IfOp, Op2)
1169  private:
1170   Value _tval;
1171   Value _fval;
1172   bool _substitutability_check;
1173 
1174  public:
1175   // creation
1176   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)
1177   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1178   , _tval(tval)
1179   , _fval(fval)
1180   , _substitutability_check(substitutability_check)
1181   {
1182     ASSERT_VALUES
1183     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1184     set_state_before(state_before);
1185   }
1186 
1187   // accessors
1188   virtual bool is_commutative() const;
1189   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1190   Condition cond() const                         { return (Condition)Op2::op(); }
1191   Value tval() const                             { return _tval; }
1192   Value fval() const                             { return _fval; }
1193   bool substitutability_check() const             { return _substitutability_check; }
1194   // generic
1195   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1196 };
1197 
1198 
1199 LEAF(Convert, Instruction)
1200  private:
1201   Bytecodes::Code _op;
1202   Value           _value;
1203 
1204  public:
1205   // creation
1206   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1207     ASSERT_VALUES
1208   }
1209 
1210   // accessors
1211   Bytecodes::Code op() const                     { return _op; }
1212   Value value() const                            { return _value; }
1213 
1214   // generic
1215   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1216   HASHING2(Convert, true, op(), value()-&gt;subst())
1217 };
1218 
1219 
1220 LEAF(NullCheck, Instruction)
1221  private:
1222   Value       _obj;
1223 
1224  public:
1225   // creation
1226   NullCheck(Value obj, ValueStack* state_before)
1227   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1228   , _obj(obj)
1229   {
1230     ASSERT_VALUES
1231     set_can_trap(true);
1232     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1233     pin(Instruction::PinExplicitNullCheck);
1234   }
1235 
1236   // accessors
1237   Value obj() const                              { return _obj; }
1238 
1239   // setters
1240   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1241 
1242   // generic
1243   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1244   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1245   HASHING1(NullCheck, true, obj()-&gt;subst())
1246 };
1247 
1248 
1249 // This node is supposed to cast the type of another node to a more precise
1250 // declared type.
1251 LEAF(TypeCast, Instruction)
1252  private:
1253   ciType* _declared_type;
1254   Value   _obj;
1255 
1256  public:
1257   // The type of this node is the same type as the object type (and it might be constant).
1258   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1259   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1260     _declared_type(type),
1261     _obj(obj) {}
1262 
1263   // accessors
1264   ciType* declared_type() const                  { return _declared_type; }
1265   Value   obj() const                            { return _obj; }
1266 
1267   // generic
1268   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1269 };
1270 
1271 
1272 BASE(StateSplit, Instruction)
1273  private:
1274   ValueStack* _state;
1275 
1276  protected:
1277   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1278 
1279  public:
1280   // creation
1281   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1282   : Instruction(type, state_before)
1283   , _state(NULL)
1284   {
1285     pin(PinStateSplitConstructor);
1286   }
1287 
1288   // accessors
1289   ValueStack* state() const                      { return _state; }
1290   IRScope* scope() const;                        // the state&#39;s scope
1291 
1292   // manipulation
1293   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1294 
1295   // generic
1296   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1297   virtual void state_values_do(ValueVisitor* f);
1298 };
1299 
1300 
1301 LEAF(Invoke, StateSplit)
1302  private:
1303   Bytecodes::Code _code;
1304   Value           _recv;
1305   Values*         _args;
1306   BasicTypeList*  _signature;
1307   int             _vtable_index;
1308   ciMethod*       _target;
1309 
1310  public:
1311   // creation
1312   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1313          int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null);
1314 
1315   // accessors
1316   Bytecodes::Code code() const                   { return _code; }
1317   Value receiver() const                         { return _recv; }
1318   bool has_receiver() const                      { return receiver() != NULL; }
1319   int number_of_arguments() const                { return _args-&gt;length(); }
1320   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1321   int vtable_index() const                       { return _vtable_index; }
1322   BasicTypeList* signature() const               { return _signature; }
1323   ciMethod* target() const                       { return _target; }
1324 
1325   ciType* declared_type() const;
1326 
1327   // Returns false if target is not loaded
1328   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1329   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1330   // Returns false if target is not loaded
1331   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1332 
1333   // JSR 292 support
1334   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1335   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1336 
1337   virtual bool needs_exception_state() const     { return false; }
1338 
1339   // generic
1340   virtual bool can_trap() const                  { return true; }
1341   virtual void input_values_do(ValueVisitor* f) {
1342     StateSplit::input_values_do(f);
1343     if (has_receiver()) f-&gt;visit(&amp;_recv);
1344     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1345   }
1346   virtual void state_values_do(ValueVisitor *f);
1347 };
1348 
1349 
1350 LEAF(NewInstance, StateSplit)
1351  private:
1352   ciInstanceKlass* _klass;
1353   bool _is_unresolved;
1354 
1355  public:
1356   // creation
1357   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1358   : StateSplit(instanceType, state_before)
1359   , _klass(klass), _is_unresolved(is_unresolved)
1360   {}
1361 
1362   // accessors
1363   ciInstanceKlass* klass() const                 { return _klass; }
1364   bool is_unresolved() const                     { return _is_unresolved; }
1365 
1366   virtual bool needs_exception_state() const     { return false; }
1367 
1368   // generic
1369   virtual bool can_trap() const                  { return true; }
1370   ciType* exact_type() const;
1371   ciType* declared_type() const;
1372 };
1373 
1374 LEAF(NewValueTypeInstance, StateSplit)
1375   bool _is_unresolved;
1376   ciValueKlass* _klass;
1377   Value _depends_on;      // Link to instance on with withfield was called on
1378   bool _is_optimizable_for_withfield;
1379   int _first_local_index;
1380 public:
1381 
1382   // Default creation, always allocated for now
1383   NewValueTypeInstance(ciValueKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1384   : StateSplit(instanceType, state_before)
1385    , _is_unresolved(is_unresolved)
1386    , _klass(klass)
1387    , _is_optimizable_for_withfield(from_default_value)
1388    , _first_local_index(-1)
1389   {
1390     if (depends_on == NULL) {
1391       _depends_on = this;
1392     } else {
1393       _depends_on = depends_on;
1394     }
1395     set_never_null(true);
1396   }
1397 
1398   // accessors
1399   bool is_unresolved() const                     { return _is_unresolved; }
1400   Value depends_on();
1401 
1402   ciValueKlass* klass() const { return _klass; }
1403 
1404   virtual bool needs_exception_state() const     { return false; }
1405 
1406   // generic
1407   virtual bool can_trap() const                  { return true; }
1408   ciType* exact_type() const;
1409   ciType* declared_type() const;
1410 
1411   // Only done in LIR Generator -&gt; map everything to object
1412   void set_to_object_type() { set_type(instanceType); }
1413 
1414   // withfield optimization
1415   virtual void set_escaped() {
1416     _is_optimizable_for_withfield = false;
1417   }
1418   virtual void set_local_index(int index) {
1419     if (_first_local_index != index) {
1420       if (_first_local_index == -1) {
1421         _first_local_index = index;
1422       } else {
1423         _is_optimizable_for_withfield = false;
1424       }
1425     }
1426   }
1427   virtual bool is_optimizable_for_withfield() const {  return _is_optimizable_for_withfield; }
1428 };
1429 
1430 BASE(NewArray, StateSplit)
1431  private:
1432   Value       _length;
1433 
1434  public:
1435   // creation
1436   NewArray(Value length, ValueStack* state_before)
1437   : StateSplit(objectType, state_before)
1438   , _length(length)
1439   {
1440     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1441   }
1442 
1443   // accessors
1444   Value length() const                           { return _length; }
1445 
1446   virtual bool needs_exception_state() const     { return false; }
1447 
1448   ciType* exact_type() const                     { return NULL; }
1449   ciType* declared_type() const;
1450 
1451   // generic
1452   virtual bool can_trap() const                  { return true; }
1453   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1454 };
1455 
1456 
1457 LEAF(NewTypeArray, NewArray)
1458  private:
1459   BasicType _elt_type;
1460 
1461  public:
1462   // creation
1463   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1464   : NewArray(length, state_before)
1465   , _elt_type(elt_type)
1466   {}
1467 
1468   // accessors
1469   BasicType elt_type() const                     { return _elt_type; }
1470   ciType* exact_type() const;
1471 };
1472 
1473 
1474 LEAF(NewObjectArray, NewArray)
1475  private:
1476   ciKlass* _klass;
1477 
1478  public:
1479   // creation
1480   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool never_null)
1481   : NewArray(length, state_before), _klass(klass) {
1482     set_never_null(never_null);
1483   }
1484 
1485   // accessors
1486   ciKlass* klass() const                         { return _klass; }
1487   ciType* exact_type() const;
1488 };
1489 
1490 
1491 LEAF(NewMultiArray, NewArray)
1492  private:
1493   ciKlass* _klass;
1494   Values*  _dims;
1495 
1496  public:
1497   // creation
1498   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1499     ASSERT_VALUES
1500   }
1501 
1502   // accessors
1503   ciKlass* klass() const                         { return _klass; }
1504   Values* dims() const                           { return _dims; }
1505   int rank() const                               { return dims()-&gt;length(); }
1506 
1507   // generic
1508   virtual void input_values_do(ValueVisitor* f) {
1509     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1510     // is meaningless for a multi-dimensional array; passing the
1511     // zeroth element down to NewArray as its length is a bad idea
1512     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1513     // get updated, and the value must not be traversed twice. Was bug
1514     // - kbr 4/10/2001
1515     StateSplit::input_values_do(f);
1516     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1517   }
1518 
1519   ciType* exact_type() const;
1520 };
1521 
1522 LEAF(WithField, StateSplit)
1523  public:
1524   // creation
1525   WithField(ValueStack* state_before)
1526   : StateSplit(objectType, state_before) {}
1527 };
1528 
1529 LEAF(DefaultValue, StateSplit)
1530  public:
1531   // creation
1532   DefaultValue(ValueStack* state_before)
1533   : StateSplit(objectType, state_before) {}
1534 };
1535 
1536 BASE(TypeCheck, StateSplit)
1537  private:
1538   ciKlass*    _klass;
1539   Value       _obj;
1540 
1541   ciMethod* _profiled_method;
1542   int       _profiled_bci;
1543 
1544  public:
1545   // creation
1546   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1547   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1548     _profiled_method(NULL), _profiled_bci(0) {
1549     ASSERT_VALUES
1550     set_direct_compare(false);
1551   }
1552 
1553   // accessors
1554   ciKlass* klass() const                         { return _klass; }
1555   Value obj() const                              { return _obj; }
1556   bool is_loaded() const                         { return klass() != NULL; }
1557   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1558 
1559   // manipulation
1560   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1561 
1562   // generic
1563   virtual bool can_trap() const                  { return true; }
1564   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1565 
1566   // Helpers for MethodData* profiling
1567   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1568   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1569   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1570   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1571   ciMethod* profiled_method() const                  { return _profiled_method;     }
1572   int       profiled_bci() const                     { return _profiled_bci;        }
1573 };
1574 
1575 
1576 LEAF(CheckCast, TypeCheck)
1577  public:
1578   // creation
1579   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool never_null = false)
1580   : TypeCheck(klass, obj, objectType, state_before) {
1581     set_never_null(never_null);
1582   }
1583 
1584   void set_incompatible_class_change_check() {
1585     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1586   }
1587   bool is_incompatible_class_change_check() const {
1588     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1589   }
1590   void set_invokespecial_receiver_check() {
1591     set_flag(InvokeSpecialReceiverCheckFlag, true);
1592   }
1593   bool is_invokespecial_receiver_check() const {
1594     return check_flag(InvokeSpecialReceiverCheckFlag);
1595   }
1596 
1597   virtual bool needs_exception_state() const {
1598     return !is_invokespecial_receiver_check();
1599   }
1600 
1601   ciType* declared_type() const;
1602 };
1603 
1604 
1605 LEAF(InstanceOf, TypeCheck)
1606  public:
1607   // creation
1608   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1609 
1610   virtual bool needs_exception_state() const     { return false; }
1611 };
1612 
1613 
1614 BASE(AccessMonitor, StateSplit)
1615  private:
1616   Value       _obj;
1617   int         _monitor_no;
1618 
1619  public:
1620   // creation
1621   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1622   : StateSplit(illegalType, state_before)
1623   , _obj(obj)
1624   , _monitor_no(monitor_no)
1625   {
1626     set_needs_null_check(true);
1627     ASSERT_VALUES
1628   }
1629 
1630   // accessors
1631   Value obj() const                              { return _obj; }
1632   int monitor_no() const                         { return _monitor_no; }
1633 
1634   // generic
1635   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1636 };
1637 
1638 
1639 LEAF(MonitorEnter, AccessMonitor)
1640   bool _maybe_valuetype;
1641  public:
1642   // creation
1643   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_valuetype)
1644   : AccessMonitor(obj, monitor_no, state_before)
1645   , _maybe_valuetype(maybe_valuetype)
1646   {
1647     ASSERT_VALUES
1648   }
1649 
1650   // accessors
1651   bool maybe_valuetype() const                   { return _maybe_valuetype; }
1652 
1653   // generic
1654   virtual bool can_trap() const                  { return true; }
1655 };
1656 
1657 
1658 LEAF(MonitorExit, AccessMonitor)
1659  public:
1660   // creation
1661   MonitorExit(Value obj, int monitor_no)
1662   : AccessMonitor(obj, monitor_no, NULL)
1663   {
1664     ASSERT_VALUES
1665   }
1666 };
1667 
1668 
1669 LEAF(Intrinsic, StateSplit)
1670  private:
1671   vmIntrinsics::ID _id;
1672   Values*          _args;
1673   Value            _recv;
1674   ArgsNonNullState _nonnull_state;
1675 
1676  public:
1677   // preserves_state can be set to true for Intrinsics
1678   // which are guaranteed to preserve register state across any slow
1679   // cases; setting it to true does not mean that the Intrinsic can
1680   // not trap, only that if we continue execution in the same basic
1681   // block after the Intrinsic, all of the registers are intact. This
1682   // allows load elimination and common expression elimination to be
1683   // performed across the Intrinsic.  The default value is false.
1684   Intrinsic(ValueType* type,
1685             vmIntrinsics::ID id,
1686             Values* args,
1687             bool has_receiver,
1688             ValueStack* state_before,
1689             bool preserves_state,
1690             bool cantrap = true)
1691   : StateSplit(type, state_before)
1692   , _id(id)
1693   , _args(args)
1694   , _recv(NULL)
1695   {
1696     assert(args != NULL, &quot;args must exist&quot;);
1697     ASSERT_VALUES
1698     set_flag(PreservesStateFlag, preserves_state);
1699     set_flag(CanTrapFlag,        cantrap);
1700     if (has_receiver) {
1701       _recv = argument_at(0);
1702     }
1703     set_needs_null_check(has_receiver);
1704 
1705     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1706     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1707       unpin(PinStateSplitConstructor);
1708     }
1709   }
1710 
1711   // accessors
1712   vmIntrinsics::ID id() const                    { return _id; }
1713   int number_of_arguments() const                { return _args-&gt;length(); }
1714   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1715 
1716   bool has_receiver() const                      { return (_recv != NULL); }
1717   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1718   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1719 
1720   bool arg_needs_null_check(int i) const {
1721     return _nonnull_state.arg_needs_null_check(i);
1722   }
1723 
1724   void set_arg_needs_null_check(int i, bool check) {
1725     _nonnull_state.set_arg_needs_null_check(i, check);
1726   }
1727 
1728   // generic
1729   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1730   virtual void input_values_do(ValueVisitor* f) {
1731     StateSplit::input_values_do(f);
1732     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1733   }
1734 };
1735 
1736 
1737 class LIR_List;
1738 
1739 LEAF(BlockBegin, StateSplit)
1740  private:
1741   int        _block_id;                          // the unique block id
1742   int        _bci;                               // start-bci of block
1743   int        _depth_first_number;                // number of this block in a depth-first ordering
1744   int        _linear_scan_number;                // number of this block in linear-scan ordering
1745   int        _dominator_depth;
1746   int        _loop_depth;                        // the loop nesting level of this block
1747   int        _loop_index;                        // number of the innermost loop of this block
1748   int        _flags;                             // the flags associated with this block
1749 
1750   // fields used by BlockListBuilder
1751   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1752   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1753 
1754   // SSA specific fields: (factor out later)
1755   BlockList   _successors;                       // the successors of this block
1756   BlockList   _predecessors;                     // the predecessors of this block
1757   BlockList   _dominates;                        // list of blocks that are dominated by this block
1758   BlockBegin* _dominator;                        // the dominator of this block
1759   // SSA specific ends
1760   BlockEnd*  _end;                               // the last instruction of this block
1761   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1762   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1763   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1764                                                  // this records the PC offset in the assembly code of the
1765                                                  // first instruction in this block
1766   Label      _label;                             // the label associated with this block
1767   LIR_List*  _lir;                               // the low level intermediate representation for this block
1768 
1769   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1770   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1771   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1772   ResourceBitMap _live_kill;                     // set of registers defined in this block
1773 
1774   ResourceBitMap _fpu_register_usage;
1775   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1776   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1777   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1778 
1779   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1780   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1781 
1782   friend class SuxAndWeightAdjuster;
1783 
1784  public:
1785    void* operator new(size_t size) throw() {
1786     Compilation* c = Compilation::current();
1787     void* res = c-&gt;arena()-&gt;Amalloc(size);
<a name="4" id="anc4"></a><span class="line-removed">1788     ((BlockBegin*)res)-&gt;_id = c-&gt;get_next_id();</span>
<span class="line-removed">1789     ((BlockBegin*)res)-&gt;_block_id = c-&gt;get_next_block_id();</span>
1790     return res;
1791   }
1792 
1793   // initialization/counting
1794   static int  number_of_blocks() {
1795     return Compilation::current()-&gt;number_of_blocks();
1796   }
1797 
1798   // creation
1799   BlockBegin(int bci)
1800   : StateSplit(illegalType)
<a name="5" id="anc5"></a>
1801   , _bci(bci)
1802   , _depth_first_number(-1)
1803   , _linear_scan_number(-1)
1804   , _dominator_depth(-1)
1805   , _loop_depth(0)
1806   , _loop_index(-1)
1807   , _flags(0)
1808   , _total_preds(0)
1809   , _stores_to_locals()
1810   , _successors(2)
1811   , _predecessors(2)
1812   , _dominates(2)
1813   , _dominator(NULL)
1814   , _end(NULL)
1815   , _exception_handlers(1)
1816   , _exception_states(NULL)
1817   , _exception_handler_pco(-1)
1818   , _lir(NULL)
1819   , _live_in()
1820   , _live_out()
1821   , _live_gen()
1822   , _live_kill()
1823   , _fpu_register_usage()
1824   , _fpu_stack_state(NULL)
1825   , _first_lir_instruction_id(-1)
1826   , _last_lir_instruction_id(-1)
1827   {
1828     _block = this;
1829 #ifndef PRODUCT
1830     set_printable_bci(bci);
1831 #endif
1832   }
1833 
1834   // accessors
1835   int block_id() const                           { return _block_id; }
1836   int bci() const                                { return _bci; }
1837   BlockList* successors()                        { return &amp;_successors; }
1838   BlockList* dominates()                         { return &amp;_dominates; }
1839   BlockBegin* dominator() const                  { return _dominator; }
1840   int loop_depth() const                         { return _loop_depth; }
1841   int dominator_depth() const                    { return _dominator_depth; }
1842   int depth_first_number() const                 { return _depth_first_number; }
1843   int linear_scan_number() const                 { return _linear_scan_number; }
1844   BlockEnd* end() const                          { return _end; }
1845   Label* label()                                 { return &amp;_label; }
1846   LIR_List* lir() const                          { return _lir; }
1847   int exception_handler_pco() const              { return _exception_handler_pco; }
1848   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1849   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1850   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1851   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1852   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1853   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1854   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1855   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1856   int total_preds() const                        { return _total_preds; }
1857   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1858 
1859   // manipulation
1860   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1861   void set_loop_depth(int d)                     { _loop_depth = d; }
1862   void set_dominator_depth(int d)                { _dominator_depth = d; }
1863   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1864   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1865   void set_end(BlockEnd* end);
1866   void clear_end();
1867   void disconnect_from_graph();
1868   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1869   BlockBegin* insert_block_between(BlockBegin* sux);
1870   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1871   void set_lir(LIR_List* lir)                    { _lir = lir; }
1872   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1873   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1874   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1875   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1876   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1877   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1878   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1879   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1880   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1881   void increment_total_preds(int n = 1)          { _total_preds += n; }
1882   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1883 
1884   // generic
1885   virtual void state_values_do(ValueVisitor* f);
1886 
1887   // successors and predecessors
1888   int number_of_sux() const;
1889   BlockBegin* sux_at(int i) const;
1890   void add_successor(BlockBegin* sux);
1891   void remove_successor(BlockBegin* pred);
1892   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1893 
1894   void add_predecessor(BlockBegin* pred);
1895   void remove_predecessor(BlockBegin* pred);
1896   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1897   int number_of_preds() const                    { return _predecessors.length(); }
1898   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1899 
1900   // exception handlers potentially invoked by this block
1901   void add_exception_handler(BlockBegin* b);
1902   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1903   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1904   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1905 
1906   // states of the instructions that have an edge to this exception handler
1907   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1908   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1909   int add_exception_state(ValueStack* state);
1910 
1911   // flags
1912   enum Flag {
1913     no_flag                       = 0,
1914     std_entry_flag                = 1 &lt;&lt; 0,
1915     osr_entry_flag                = 1 &lt;&lt; 1,
1916     exception_entry_flag          = 1 &lt;&lt; 2,
1917     subroutine_entry_flag         = 1 &lt;&lt; 3,
1918     backward_branch_target_flag   = 1 &lt;&lt; 4,
1919     is_on_work_list_flag          = 1 &lt;&lt; 5,
1920     was_visited_flag              = 1 &lt;&lt; 6,
1921     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1922     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1923     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1924     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1925     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1926   };
1927 
1928   void set(Flag f)                               { _flags |= f; }
1929   void clear(Flag f)                             { _flags &amp;= ~f; }
1930   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1931   bool is_entry_block() const {
1932     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1933     return (_flags &amp; entry_mask) != 0;
1934   }
1935 
1936   // iteration
1937   void iterate_preorder   (BlockClosure* closure);
1938   void iterate_postorder  (BlockClosure* closure);
1939 
1940   void block_values_do(ValueVisitor* f);
1941 
1942   // loops
1943   void set_loop_index(int ix)                    { _loop_index = ix;        }
1944   int  loop_index() const                        { return _loop_index;      }
1945 
1946   // merging
1947   bool try_merge(ValueStack* state);             // try to merge states at block begin
1948   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1949 
1950   // debugging
1951   void print_block()                             PRODUCT_RETURN;
1952   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1953 };
1954 
1955 
1956 BASE(BlockEnd, StateSplit)
1957  private:
1958   BlockList*  _sux;
1959 
1960  protected:
1961   BlockList* sux() const                         { return _sux; }
1962 
1963   void set_sux(BlockList* sux) {
1964 #ifdef ASSERT
1965     assert(sux != NULL, &quot;sux must exist&quot;);
1966     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1967 #endif
1968     _sux = sux;
1969   }
1970 
1971  public:
1972   // creation
1973   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1974   : StateSplit(type, state_before)
1975   , _sux(NULL)
1976   {
1977     set_flag(IsSafepointFlag, is_safepoint);
1978   }
1979 
1980   // accessors
1981   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1982   // For compatibility with old code, for new code use block()
1983   BlockBegin* begin() const                      { return _block; }
1984 
1985   // manipulation
1986   void set_begin(BlockBegin* begin);
1987 
1988   // successors
1989   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1990   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1991   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
1992   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
1993   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
1994   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1995 };
1996 
1997 
1998 LEAF(Goto, BlockEnd)
1999  public:
2000   enum Direction {
2001     none,            // Just a regular goto
2002     taken, not_taken // Goto produced from If
2003   };
2004  private:
2005   ciMethod*   _profiled_method;
2006   int         _profiled_bci;
2007   Direction   _direction;
2008  public:
2009   // creation
2010   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
2011     : BlockEnd(illegalType, state_before, is_safepoint)
2012     , _profiled_method(NULL)
2013     , _profiled_bci(0)
2014     , _direction(none) {
2015     BlockList* s = new BlockList(1);
2016     s-&gt;append(sux);
2017     set_sux(s);
2018   }
2019 
2020   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
2021                                            , _profiled_method(NULL)
2022                                            , _profiled_bci(0)
2023                                            , _direction(none) {
2024     BlockList* s = new BlockList(1);
2025     s-&gt;append(sux);
2026     set_sux(s);
2027   }
2028 
2029   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2030   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2031   int profiled_bci() const                       { return _profiled_bci; }
2032   Direction direction() const                    { return _direction; }
2033 
2034   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
2035   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
2036   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
2037   void set_direction(Direction d)                { _direction = d; }
2038 };
2039 
2040 #ifdef ASSERT
2041 LEAF(Assert, Instruction)
2042   private:
2043   Value       _x;
2044   Condition   _cond;
2045   Value       _y;
2046   char        *_message;
2047 
2048  public:
2049   // creation
2050   // unordered_is_true is valid for float/double compares only
2051    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
2052 
2053   // accessors
2054   Value x() const                                { return _x; }
2055   Condition cond() const                         { return _cond; }
2056   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2057   Value y() const                                { return _y; }
2058   const char *message() const                    { return _message; }
2059 
2060   // generic
2061   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2062 };
2063 #endif
2064 
2065 LEAF(RangeCheckPredicate, StateSplit)
2066  private:
2067   Value       _x;
2068   Condition   _cond;
2069   Value       _y;
2070 
2071   void check_state();
2072 
2073  public:
2074   // creation
2075   // unordered_is_true is valid for float/double compares only
2076    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
2077   , _x(x)
2078   , _cond(cond)
2079   , _y(y)
2080   {
2081     ASSERT_VALUES
2082     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2083     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2084     this-&gt;set_state(state);
2085     check_state();
2086   }
2087 
2088   // Always deoptimize
2089   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
2090   {
2091     this-&gt;set_state(state);
2092     _x = _y = NULL;
2093     check_state();
2094   }
2095 
2096   // accessors
2097   Value x() const                                { return _x; }
2098   Condition cond() const                         { return _cond; }
2099   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2100   Value y() const                                { return _y; }
2101 
2102   void always_fail()                             { _x = _y = NULL; }
2103 
2104   // generic
2105   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2106   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
2107 };
2108 
2109 LEAF(If, BlockEnd)
2110  private:
2111   Value       _x;
2112   Condition   _cond;
2113   Value       _y;
2114   ciMethod*   _profiled_method;
2115   int         _profiled_bci; // Canonicalizer may alter bci of If node
2116   bool        _swapped;      // Is the order reversed with respect to the original If in the
2117                              // bytecode stream?
2118   bool        _substitutability_check;
2119  public:
2120   // creation
2121   // unordered_is_true is valid for float/double compares only
2122   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)
2123     : BlockEnd(illegalType, state_before, is_safepoint)
2124   , _x(x)
2125   , _cond(cond)
2126   , _y(y)
2127   , _profiled_method(NULL)
2128   , _profiled_bci(0)
2129   , _swapped(false)
2130   , _substitutability_check(substitutability_check)
2131   {
2132     ASSERT_VALUES
2133     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2134     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2135     BlockList* s = new BlockList(2);
2136     s-&gt;append(tsux);
2137     s-&gt;append(fsux);
2138     set_sux(s);
2139   }
2140 
2141   // accessors
2142   Value x() const                                { return _x; }
2143   Condition cond() const                         { return _cond; }
2144   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2145   Value y() const                                { return _y; }
2146   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2147   BlockBegin* tsux() const                       { return sux_for(true); }
2148   BlockBegin* fsux() const                       { return sux_for(false); }
2149   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2150   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2151   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2152   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2153   bool is_swapped() const                        { return _swapped; }
2154 
2155   // manipulation
2156   void swap_operands() {
2157     Value t = _x; _x = _y; _y = t;
2158     _cond = mirror(_cond);
2159   }
2160 
2161   void swap_sux() {
2162     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2163     BlockList* s = sux();
2164     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2165     _cond = negate(_cond);
2166     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2167   }
2168 
2169   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2170   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2171   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2172   void set_swapped(bool value)                    { _swapped = value;         }
2173   bool substitutability_check() const              { return _substitutability_check; }
2174   // generic
2175   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2176 };
2177 
2178 
2179 LEAF(IfInstanceOf, BlockEnd)
2180  private:
2181   ciKlass* _klass;
2182   Value    _obj;
2183   bool     _test_is_instance;                    // jump if instance
2184   int      _instanceof_bci;
2185 
2186  public:
2187   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2188   : BlockEnd(illegalType, NULL, false) // temporary set to false
2189   , _klass(klass)
2190   , _obj(obj)
2191   , _test_is_instance(test_is_instance)
2192   , _instanceof_bci(instanceof_bci)
2193   {
2194     ASSERT_VALUES
2195     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2196     BlockList* s = new BlockList(2);
2197     s-&gt;append(tsux);
2198     s-&gt;append(fsux);
2199     set_sux(s);
2200   }
2201 
2202   // accessors
2203   //
2204   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2205   //         instance of klass; otherwise it tests if it is *not* and instance
2206   //         of klass.
2207   //
2208   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2209   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2210   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2211   //         the bci of the original InstanceOf instruction.
2212   ciKlass* klass() const                         { return _klass; }
2213   Value obj() const                              { return _obj; }
2214   int instanceof_bci() const                     { return _instanceof_bci; }
2215   bool test_is_instance() const                  { return _test_is_instance; }
2216   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2217   BlockBegin* tsux() const                       { return sux_for(true); }
2218   BlockBegin* fsux() const                       { return sux_for(false); }
2219 
2220   // manipulation
2221   void swap_sux() {
2222     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2223     BlockList* s = sux();
2224     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2225     _test_is_instance = !_test_is_instance;
2226   }
2227 
2228   // generic
2229   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2230 };
2231 
2232 
2233 BASE(Switch, BlockEnd)
2234  private:
2235   Value       _tag;
2236 
2237  public:
2238   // creation
2239   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2240   : BlockEnd(illegalType, state_before, is_safepoint)
2241   , _tag(tag) {
2242     ASSERT_VALUES
2243     set_sux(sux);
2244   }
2245 
2246   // accessors
2247   Value tag() const                              { return _tag; }
2248   int length() const                             { return number_of_sux() - 1; }
2249 
2250   virtual bool needs_exception_state() const     { return false; }
2251 
2252   // generic
2253   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2254 };
2255 
2256 
2257 LEAF(TableSwitch, Switch)
2258  private:
2259   int _lo_key;
2260 
2261  public:
2262   // creation
2263   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2264     : Switch(tag, sux, state_before, is_safepoint)
2265   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2266 
2267   // accessors
2268   int lo_key() const                             { return _lo_key; }
2269   int hi_key() const                             { return _lo_key + (length() - 1); }
2270 };
2271 
2272 
2273 LEAF(LookupSwitch, Switch)
2274  private:
2275   intArray* _keys;
2276 
2277  public:
2278   // creation
2279   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2280   : Switch(tag, sux, state_before, is_safepoint)
2281   , _keys(keys) {
2282     assert(keys != NULL, &quot;keys must exist&quot;);
2283     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2284   }
2285 
2286   // accessors
2287   int key_at(int i) const                        { return _keys-&gt;at(i); }
2288 };
2289 
2290 
2291 LEAF(Return, BlockEnd)
2292  private:
2293   Value _result;
2294 
2295  public:
2296   // creation
2297   Return(Value result) :
2298     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2299     _result(result) {}
2300 
2301   // accessors
2302   Value result() const                           { return _result; }
2303   bool has_result() const                        { return result() != NULL; }
2304 
2305   // generic
2306   virtual void input_values_do(ValueVisitor* f) {
2307     BlockEnd::input_values_do(f);
2308     if (has_result()) f-&gt;visit(&amp;_result);
2309   }
2310 };
2311 
2312 
2313 LEAF(Throw, BlockEnd)
2314  private:
2315   Value _exception;
2316 
2317  public:
2318   // creation
2319   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2320     ASSERT_VALUES
2321   }
2322 
2323   // accessors
2324   Value exception() const                        { return _exception; }
2325 
2326   // generic
2327   virtual bool can_trap() const                  { return true; }
2328   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2329 };
2330 
2331 
2332 LEAF(Base, BlockEnd)
2333  public:
2334   // creation
2335   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2336     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2337     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2338     BlockList* s = new BlockList(2);
2339     if (osr_entry != NULL) s-&gt;append(osr_entry);
2340     s-&gt;append(std_entry); // must be default sux!
2341     set_sux(s);
2342   }
2343 
2344   // accessors
2345   BlockBegin* std_entry() const                  { return default_sux(); }
2346   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2347 };
2348 
2349 
2350 LEAF(OsrEntry, Instruction)
2351  public:
2352   // creation
2353 #ifdef _LP64
2354   OsrEntry() : Instruction(longType) { pin(); }
2355 #else
2356   OsrEntry() : Instruction(intType)  { pin(); }
2357 #endif
2358 
2359   // generic
2360   virtual void input_values_do(ValueVisitor* f)   { }
2361 };
2362 
2363 
2364 // Models the incoming exception at a catch site
2365 LEAF(ExceptionObject, Instruction)
2366  public:
2367   // creation
2368   ExceptionObject() : Instruction(objectType) {
2369     pin();
2370   }
2371 
2372   // generic
2373   virtual void input_values_do(ValueVisitor* f)   { }
2374 };
2375 
2376 
2377 // Models needed rounding for floating-point values on Intel.
2378 // Currently only used to represent rounding of double-precision
2379 // values stored into local variables, but could be used to model
2380 // intermediate rounding of single-precision values as well.
2381 LEAF(RoundFP, Instruction)
2382  private:
2383   Value _input;             // floating-point value to be rounded
2384 
2385  public:
2386   RoundFP(Value input)
2387   : Instruction(input-&gt;type()) // Note: should not be used for constants
2388   , _input(input)
2389   {
2390     ASSERT_VALUES
2391   }
2392 
2393   // accessors
2394   Value input() const                            { return _input; }
2395 
2396   // generic
2397   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2398 };
2399 
2400 
2401 BASE(UnsafeOp, Instruction)
2402  private:
2403   BasicType _basic_type;    // ValueType can not express byte-sized integers
2404 
2405  protected:
2406   // creation
2407   UnsafeOp(BasicType basic_type, bool is_put)
2408   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2409   , _basic_type(basic_type)
2410   {
2411     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2412     // Convservatively, Unsafe operations must be pinned though we could be
2413     // looser about this if we wanted to..
2414     pin();
2415   }
2416 
2417  public:
2418   // accessors
2419   BasicType basic_type()                         { return _basic_type; }
2420 
2421   // generic
2422   virtual void input_values_do(ValueVisitor* f)   { }
2423 };
2424 
2425 
2426 BASE(UnsafeRawOp, UnsafeOp)
2427  private:
2428   Value _base;                                   // Base address (a Java long)
2429   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2430   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2431                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2432                                                  // to scale index by.
2433 
2434  protected:
2435   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2436   : UnsafeOp(basic_type, is_put)
2437   , _base(addr)
2438   , _index(NULL)
2439   , _log2_scale(0)
2440   {
2441     // Can not use ASSERT_VALUES because index may be NULL
2442     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2443   }
2444 
2445   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2446   : UnsafeOp(basic_type, is_put)
2447   , _base(base)
2448   , _index(index)
2449   , _log2_scale(log2_scale)
2450   {
2451   }
2452 
2453  public:
2454   // accessors
2455   Value base()                                   { return _base; }
2456   Value index()                                  { return _index; }
2457   bool  has_index()                              { return (_index != NULL); }
2458   int   log2_scale()                             { return _log2_scale; }
2459 
2460   // setters
2461   void set_base (Value base)                     { _base  = base; }
2462   void set_index(Value index)                    { _index = index; }
2463   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2464 
2465   // generic
2466   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2467                                                    f-&gt;visit(&amp;_base);
2468                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2469 };
2470 
2471 
2472 LEAF(UnsafeGetRaw, UnsafeRawOp)
2473  private:
2474  bool _may_be_unaligned, _is_wide;  // For OSREntry
2475 
2476  public:
2477  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2478   : UnsafeRawOp(basic_type, addr, false) {
2479     _may_be_unaligned = may_be_unaligned;
2480     _is_wide = is_wide;
2481   }
2482 
2483  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2484   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2485     _may_be_unaligned = may_be_unaligned;
2486     _is_wide = is_wide;
2487   }
2488 
2489   bool may_be_unaligned()                         { return _may_be_unaligned; }
2490   bool is_wide()                                  { return _is_wide; }
2491 };
2492 
2493 
2494 LEAF(UnsafePutRaw, UnsafeRawOp)
2495  private:
2496   Value _value;                                  // Value to be stored
2497 
2498  public:
2499   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2500   : UnsafeRawOp(basic_type, addr, true)
2501   , _value(value)
2502   {
2503     assert(value != NULL, &quot;just checking&quot;);
2504     ASSERT_VALUES
2505   }
2506 
2507   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2508   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2509   , _value(value)
2510   {
2511     assert(value != NULL, &quot;just checking&quot;);
2512     ASSERT_VALUES
2513   }
2514 
2515   // accessors
2516   Value value()                                  { return _value; }
2517 
2518   // generic
2519   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2520                                                    f-&gt;visit(&amp;_value); }
2521 };
2522 
2523 
2524 BASE(UnsafeObjectOp, UnsafeOp)
2525  private:
2526   Value _object;                                 // Object to be fetched from or mutated
2527   Value _offset;                                 // Offset within object
2528   bool  _is_volatile;                            // true if volatile - dl/JSR166
2529  public:
2530   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2531     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2532   {
2533   }
2534 
2535   // accessors
2536   Value object()                                 { return _object; }
2537   Value offset()                                 { return _offset; }
2538   bool  is_volatile()                            { return _is_volatile; }
2539   // generic
2540   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2541                                                    f-&gt;visit(&amp;_object);
2542                                                    f-&gt;visit(&amp;_offset); }
2543 };
2544 
2545 
2546 LEAF(UnsafeGetObject, UnsafeObjectOp)
2547  public:
2548   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2549   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2550   {
2551     ASSERT_VALUES
2552   }
2553 };
2554 
2555 
2556 LEAF(UnsafePutObject, UnsafeObjectOp)
2557  private:
2558   Value _value;                                  // Value to be stored
2559  public:
2560   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2561   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2562     , _value(value)
2563   {
2564     ASSERT_VALUES
2565   }
2566 
2567   // accessors
2568   Value value()                                  { return _value; }
2569 
2570   // generic
2571   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2572                                                    f-&gt;visit(&amp;_value); }
2573 };
2574 
2575 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2576  private:
2577   Value _value;                                  // Value to be stored
2578   bool  _is_add;
2579  public:
2580   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2581   : UnsafeObjectOp(basic_type, object, offset, false, false)
2582     , _value(value)
2583     , _is_add(is_add)
2584   {
2585     ASSERT_VALUES
2586   }
2587 
2588   // accessors
2589   bool is_add() const                            { return _is_add; }
2590   Value value()                                  { return _value; }
2591 
2592   // generic
2593   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2594                                                    f-&gt;visit(&amp;_value); }
2595 };
2596 
2597 LEAF(ProfileCall, Instruction)
2598  private:
2599   ciMethod*        _method;
2600   int              _bci_of_invoke;
2601   ciMethod*        _callee;         // the method that is called at the given bci
2602   Value            _recv;
2603   ciKlass*         _known_holder;
2604   Values*          _obj_args;       // arguments for type profiling
2605   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2606   bool             _inlined;        // Are we profiling a call that is inlined
2607 
2608  public:
2609   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2610     : Instruction(voidType)
2611     , _method(method)
2612     , _bci_of_invoke(bci)
2613     , _callee(callee)
2614     , _recv(recv)
2615     , _known_holder(known_holder)
2616     , _obj_args(obj_args)
2617     , _inlined(inlined)
2618   {
2619     // The ProfileCall has side-effects and must occur precisely where located
2620     pin();
2621   }
2622 
2623   ciMethod* method()             const { return _method; }
2624   int bci_of_invoke()            const { return _bci_of_invoke; }
2625   ciMethod* callee()             const { return _callee; }
2626   Value recv()                   const { return _recv; }
2627   ciKlass* known_holder()        const { return _known_holder; }
2628   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2629   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2630   bool arg_needs_null_check(int i) const {
2631     return _nonnull_state.arg_needs_null_check(i);
2632   }
2633   bool inlined()                 const { return _inlined; }
2634 
2635   void set_arg_needs_null_check(int i, bool check) {
2636     _nonnull_state.set_arg_needs_null_check(i, check);
2637   }
2638 
2639   virtual void input_values_do(ValueVisitor* f)   {
2640     if (_recv != NULL) {
2641       f-&gt;visit(&amp;_recv);
2642     }
2643     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2644       f-&gt;visit(_obj_args-&gt;adr_at(i));
2645     }
2646   }
2647 };
2648 
2649 LEAF(ProfileReturnType, Instruction)
2650  private:
2651   ciMethod*        _method;
2652   ciMethod*        _callee;
2653   int              _bci_of_invoke;
2654   Value            _ret;
2655 
2656  public:
2657   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2658     : Instruction(voidType)
2659     , _method(method)
2660     , _callee(callee)
2661     , _bci_of_invoke(bci)
2662     , _ret(ret)
2663   {
2664     set_needs_null_check(true);
2665     // The ProfileType has side-effects and must occur precisely where located
2666     pin();
2667   }
2668 
2669   ciMethod* method()             const { return _method; }
2670   ciMethod* callee()             const { return _callee; }
2671   int bci_of_invoke()            const { return _bci_of_invoke; }
2672   Value ret()                    const { return _ret; }
2673 
2674   virtual void input_values_do(ValueVisitor* f)   {
2675     if (_ret != NULL) {
2676       f-&gt;visit(&amp;_ret);
2677     }
2678   }
2679 };
2680 
2681 // Call some C runtime function that doesn&#39;t safepoint,
2682 // optionally passing the current thread as the first argument.
2683 LEAF(RuntimeCall, Instruction)
2684  private:
2685   const char* _entry_name;
2686   address     _entry;
2687   Values*     _args;
2688   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2689 
2690  public:
2691   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2692     : Instruction(type)
2693     , _entry_name(entry_name)
2694     , _entry(entry)
2695     , _args(args)
2696     , _pass_thread(pass_thread) {
2697     ASSERT_VALUES
2698     pin();
2699   }
2700 
2701   const char* entry_name() const  { return _entry_name; }
2702   address entry() const           { return _entry; }
2703   int number_of_arguments() const { return _args-&gt;length(); }
2704   Value argument_at(int i) const  { return _args-&gt;at(i); }
2705   bool pass_thread() const        { return _pass_thread; }
2706 
2707   virtual void input_values_do(ValueVisitor* f)   {
2708     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2709   }
2710 };
2711 
2712 // Use to trip invocation counter of an inlined method
2713 
2714 LEAF(ProfileInvoke, Instruction)
2715  private:
2716   ciMethod*   _inlinee;
2717   ValueStack* _state;
2718 
2719  public:
2720   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2721     : Instruction(voidType)
2722     , _inlinee(inlinee)
2723     , _state(state)
2724   {
2725     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2726     pin();
2727   }
2728 
2729   ciMethod* inlinee()      { return _inlinee; }
2730   ValueStack* state()      { return _state; }
2731   virtual void input_values_do(ValueVisitor*)   {}
2732   virtual void state_values_do(ValueVisitor*);
2733 };
2734 
2735 LEAF(MemBar, Instruction)
2736  private:
2737   LIR_Code _code;
2738 
2739  public:
2740   MemBar(LIR_Code code)
2741     : Instruction(voidType)
2742     , _code(code)
2743   {
2744     pin();
2745   }
2746 
2747   LIR_Code code()           { return _code; }
2748 
2749   virtual void input_values_do(ValueVisitor*)   {}
2750 };
2751 
2752 class BlockPair: public CompilationResourceObj {
2753  private:
2754   BlockBegin* _from;
2755   BlockBegin* _to;
2756  public:
2757   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2758   BlockBegin* from() const { return _from; }
2759   BlockBegin* to() const   { return _to;   }
2760   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2761   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2762   void set_to(BlockBegin* b)   { _to = b; }
2763   void set_from(BlockBegin* b) { _from = b; }
2764 };
2765 
2766 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2767 
2768 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2769 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2770 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2771 
2772 #undef ASSERT_VALUES
2773 
2774 #endif // SHARE_C1_C1_INSTRUCTION_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
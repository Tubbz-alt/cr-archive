<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="access.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessBackend.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 241   static inline T decode(typename AccessInternal::EncodedType&lt;decorators, T&gt;::type value) {
 242     return decode_internal&lt;decorators, T&gt;(value);
 243   }
 244 
 245 protected:
 246   template &lt;DecoratorSet ds, typename T&gt;
 247   static typename EnableIf&lt;
 248     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 249   load_internal(void* addr);
 250 
 251   template &lt;DecoratorSet ds, typename T&gt;
 252   static typename EnableIf&lt;
 253     HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
 254   load_internal(void* addr);
 255 
 256   template &lt;DecoratorSet ds, typename T&gt;
 257   static typename EnableIf&lt;
 258     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 259   load_internal(void* addr);
 260 
<span class="line-removed"> 261   template &lt;DecoratorSet ds, typename T&gt;</span>
<span class="line-removed"> 262   static inline typename EnableIf&lt;</span>
<span class="line-removed"> 263     HasDecorator&lt;ds, MO_VOLATILE&gt;::value, T&gt;::type</span>
<span class="line-removed"> 264   load_internal(void* addr) {</span>
<span class="line-removed"> 265     return *reinterpret_cast&lt;const volatile T*&gt;(addr);</span>
<span class="line-removed"> 266   }</span>
<span class="line-removed"> 267 </span>
 268   template &lt;DecoratorSet ds, typename T&gt;
 269   static inline typename EnableIf&lt;
 270     HasDecorator&lt;ds, MO_UNORDERED&gt;::value, T&gt;::type
 271   load_internal(void* addr) {
 272     return *reinterpret_cast&lt;T*&gt;(addr);
 273   }
 274 
 275   template &lt;DecoratorSet ds, typename T&gt;
 276   static typename EnableIf&lt;
 277     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
 278   store_internal(void* addr, T value);
 279 
 280   template &lt;DecoratorSet ds, typename T&gt;
 281   static typename EnableIf&lt;
 282     HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
 283   store_internal(void* addr, T value);
 284 
 285   template &lt;DecoratorSet ds, typename T&gt;
 286   static typename EnableIf&lt;
 287     HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
 288   store_internal(void* addr, T value);
 289 
<span class="line-removed"> 290   template &lt;DecoratorSet ds, typename T&gt;</span>
<span class="line-removed"> 291   static inline typename EnableIf&lt;</span>
<span class="line-removed"> 292     HasDecorator&lt;ds, MO_VOLATILE&gt;::value&gt;::type</span>
<span class="line-removed"> 293   store_internal(void* addr, T value) {</span>
<span class="line-removed"> 294     (void)const_cast&lt;T&amp;&gt;(*reinterpret_cast&lt;volatile T*&gt;(addr) = value);</span>
<span class="line-removed"> 295   }</span>
<span class="line-removed"> 296 </span>
 297   template &lt;DecoratorSet ds, typename T&gt;
 298   static inline typename EnableIf&lt;
 299     HasDecorator&lt;ds, MO_UNORDERED&gt;::value&gt;::type
 300   store_internal(void* addr, T value) {
 301     *reinterpret_cast&lt;T*&gt;(addr) = value;
 302   }
 303 
 304   template &lt;DecoratorSet ds, typename T&gt;
 305   static typename EnableIf&lt;
 306     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 307   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 308 
 309   template &lt;DecoratorSet ds, typename T&gt;
 310   static typename EnableIf&lt;
 311     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 312   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 313 
 314   template &lt;DecoratorSet ds, typename T&gt;
 315   static typename EnableIf&lt;
 316     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
</pre>
<hr />
<pre>
1148                                      arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
1149                                      size_t length) {
1150     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1151     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1152                                                        dst_obj, dst_offset_in_bytes, dst_raw,
1153                                                        length);
1154   }
1155 
1156   template &lt;DecoratorSet decorators&gt;
1157   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,
1158                                      arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
1159                                      size_t length) {
1160     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1161                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1162     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1163                                                        dst_obj, dst_offset_in_bytes, dst_raw,
1164                                                        length);
1165   }
1166 
1167   // Step 1: Set default decorators. This step remembers if a type was volatile
<span class="line-modified">1168   // and then sets the MO_VOLATILE decorator by default. Otherwise, a default</span>
1169   // memory ordering is set for the access, and the implied decorator rules
1170   // are applied to select sensible defaults for decorators that have not been
1171   // explicitly set. For example, default object referent strength is set to strong.
1172   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
1173   // and references from the types). This step also perform some type verification
1174   // that the passed in types make sense.
1175 
1176   template &lt;DecoratorSet decorators, typename T&gt;
1177   static void verify_types(){
1178     // If this fails to compile, then you have sent in something that is
1179     // not recognized as a valid primitive type to a primitive Access function.
1180     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // oops have already been validated
1181                    (IsPointer&lt;T&gt;::value || IsIntegral&lt;T&gt;::value) ||
1182                     IsFloatingPoint&lt;T&gt;::value)); // not allowed primitive type
1183   }
1184 
1185   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1186   inline void store(P* addr, T value) {
1187     verify_types&lt;decorators, T&gt;();
1188     typedef typename Decay&lt;P&gt;::type DecayedP;
1189     typedef typename Decay&lt;T&gt;::type DecayedT;
1190     DecayedT decayed_value = value;
1191     // If a volatile address is passed in but no memory ordering decorator,
<span class="line-modified">1192     // set the memory ordering to MO_VOLATILE by default.</span>
1193     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1194       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
<span class="line-modified">1195       (MO_VOLATILE | decorators) : decorators&gt;::value;</span>
1196     store_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr), decayed_value);
1197   }
1198 
1199   template &lt;DecoratorSet decorators, typename T&gt;
1200   inline void store_at(oop base, ptrdiff_t offset, T value) {
1201     verify_types&lt;decorators, T&gt;();
1202     typedef typename Decay&lt;T&gt;::type DecayedT;
1203     DecayedT decayed_value = value;
1204     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1205                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1206                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1207     PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, decayed_value);
1208   }
1209 
1210   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1211   inline T load(P* addr) {
1212     verify_types&lt;decorators, T&gt;();
1213     typedef typename Decay&lt;P&gt;::type DecayedP;
1214     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1215                                  typename OopOrNarrowOop&lt;T&gt;::type,
1216                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1217     // If a volatile address is passed in but no memory ordering decorator,
<span class="line-modified">1218     // set the memory ordering to MO_VOLATILE by default.</span>
1219     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1220       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
<span class="line-modified">1221       (MO_VOLATILE | decorators) : decorators&gt;::value;</span>
1222     return load_reduce_types&lt;expanded_decorators, DecayedT&gt;(const_cast&lt;DecayedP*&gt;(addr));
1223   }
1224 
1225   template &lt;DecoratorSet decorators, typename T&gt;
1226   inline T load_at(oop base, ptrdiff_t offset) {
1227     verify_types&lt;decorators, T&gt;();
1228     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1229                                  typename OopOrNarrowOop&lt;T&gt;::type,
1230                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1231     // Expand the decorators (figure out sensible defaults)
1232     // Potentially remember if we need compressed oop awareness
1233     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1234                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1235                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1236     return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
1237   }
1238 
1239   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1240   inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {
1241     verify_types&lt;decorators, T&gt;();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 241   static inline T decode(typename AccessInternal::EncodedType&lt;decorators, T&gt;::type value) {
 242     return decode_internal&lt;decorators, T&gt;(value);
 243   }
 244 
 245 protected:
 246   template &lt;DecoratorSet ds, typename T&gt;
 247   static typename EnableIf&lt;
 248     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 249   load_internal(void* addr);
 250 
 251   template &lt;DecoratorSet ds, typename T&gt;
 252   static typename EnableIf&lt;
 253     HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
 254   load_internal(void* addr);
 255 
 256   template &lt;DecoratorSet ds, typename T&gt;
 257   static typename EnableIf&lt;
 258     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 259   load_internal(void* addr);
 260 







 261   template &lt;DecoratorSet ds, typename T&gt;
 262   static inline typename EnableIf&lt;
 263     HasDecorator&lt;ds, MO_UNORDERED&gt;::value, T&gt;::type
 264   load_internal(void* addr) {
 265     return *reinterpret_cast&lt;T*&gt;(addr);
 266   }
 267 
 268   template &lt;DecoratorSet ds, typename T&gt;
 269   static typename EnableIf&lt;
 270     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
 271   store_internal(void* addr, T value);
 272 
 273   template &lt;DecoratorSet ds, typename T&gt;
 274   static typename EnableIf&lt;
 275     HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
 276   store_internal(void* addr, T value);
 277 
 278   template &lt;DecoratorSet ds, typename T&gt;
 279   static typename EnableIf&lt;
 280     HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
 281   store_internal(void* addr, T value);
 282 







 283   template &lt;DecoratorSet ds, typename T&gt;
 284   static inline typename EnableIf&lt;
 285     HasDecorator&lt;ds, MO_UNORDERED&gt;::value&gt;::type
 286   store_internal(void* addr, T value) {
 287     *reinterpret_cast&lt;T*&gt;(addr) = value;
 288   }
 289 
 290   template &lt;DecoratorSet ds, typename T&gt;
 291   static typename EnableIf&lt;
 292     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 293   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 294 
 295   template &lt;DecoratorSet ds, typename T&gt;
 296   static typename EnableIf&lt;
 297     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 298   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 299 
 300   template &lt;DecoratorSet ds, typename T&gt;
 301   static typename EnableIf&lt;
 302     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
</pre>
<hr />
<pre>
1134                                      arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
1135                                      size_t length) {
1136     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1137     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1138                                                        dst_obj, dst_offset_in_bytes, dst_raw,
1139                                                        length);
1140   }
1141 
1142   template &lt;DecoratorSet decorators&gt;
1143   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,
1144                                      arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
1145                                      size_t length) {
1146     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1147                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1148     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,
1149                                                        dst_obj, dst_offset_in_bytes, dst_raw,
1150                                                        length);
1151   }
1152 
1153   // Step 1: Set default decorators. This step remembers if a type was volatile
<span class="line-modified">1154   // and then sets the MO_RELAXED decorator by default. Otherwise, a default</span>
1155   // memory ordering is set for the access, and the implied decorator rules
1156   // are applied to select sensible defaults for decorators that have not been
1157   // explicitly set. For example, default object referent strength is set to strong.
1158   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
1159   // and references from the types). This step also perform some type verification
1160   // that the passed in types make sense.
1161 
1162   template &lt;DecoratorSet decorators, typename T&gt;
1163   static void verify_types(){
1164     // If this fails to compile, then you have sent in something that is
1165     // not recognized as a valid primitive type to a primitive Access function.
1166     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // oops have already been validated
1167                    (IsPointer&lt;T&gt;::value || IsIntegral&lt;T&gt;::value) ||
1168                     IsFloatingPoint&lt;T&gt;::value)); // not allowed primitive type
1169   }
1170 
1171   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1172   inline void store(P* addr, T value) {
1173     verify_types&lt;decorators, T&gt;();
1174     typedef typename Decay&lt;P&gt;::type DecayedP;
1175     typedef typename Decay&lt;T&gt;::type DecayedT;
1176     DecayedT decayed_value = value;
1177     // If a volatile address is passed in but no memory ordering decorator,
<span class="line-modified">1178     // set the memory ordering to MO_RELAXED by default.</span>
1179     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1180       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
<span class="line-modified">1181       (MO_RELAXED | decorators) : decorators&gt;::value;</span>
1182     store_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr), decayed_value);
1183   }
1184 
1185   template &lt;DecoratorSet decorators, typename T&gt;
1186   inline void store_at(oop base, ptrdiff_t offset, T value) {
1187     verify_types&lt;decorators, T&gt;();
1188     typedef typename Decay&lt;T&gt;::type DecayedT;
1189     DecayedT decayed_value = value;
1190     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1191                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1192                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1193     PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, decayed_value);
1194   }
1195 
1196   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1197   inline T load(P* addr) {
1198     verify_types&lt;decorators, T&gt;();
1199     typedef typename Decay&lt;P&gt;::type DecayedP;
1200     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1201                                  typename OopOrNarrowOop&lt;T&gt;::type,
1202                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1203     // If a volatile address is passed in but no memory ordering decorator,
<span class="line-modified">1204     // set the memory ordering to MO_RELAXED by default.</span>
1205     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1206       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
<span class="line-modified">1207       (MO_RELAXED | decorators) : decorators&gt;::value;</span>
1208     return load_reduce_types&lt;expanded_decorators, DecayedT&gt;(const_cast&lt;DecayedP*&gt;(addr));
1209   }
1210 
1211   template &lt;DecoratorSet decorators, typename T&gt;
1212   inline T load_at(oop base, ptrdiff_t offset) {
1213     verify_types&lt;decorators, T&gt;();
1214     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1215                                  typename OopOrNarrowOop&lt;T&gt;::type,
1216                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1217     // Expand the decorators (figure out sensible defaults)
1218     // Potentially remember if we need compressed oop awareness
1219     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1220                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1221                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1222     return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
1223   }
1224 
1225   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1226   inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {
1227     verify_types&lt;decorators, T&gt;();
</pre>
</td>
</tr>
</table>
<center><a href="access.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
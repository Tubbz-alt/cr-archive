<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/access.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/virtualspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessBackend.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/access.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
113   static void verify_oop_decorators() {
114     const DecoratorSet oop_decorators = AS_DECORATOR_MASK | IN_DECORATOR_MASK |
115                                         (ON_DECORATOR_MASK ^ ON_UNKNOWN_OOP_REF) | // no unknown oop refs outside of the heap
116                                         IS_ARRAY | IS_NOT_NULL | IS_DEST_UNINITIALIZED;
117     verify_decorators&lt;expected_mo_decorators | oop_decorators&gt;();
118   }
119 
120   template &lt;DecoratorSet expected_mo_decorators&gt;
121   static void verify_heap_oop_decorators() {
122     const DecoratorSet heap_oop_decorators = AS_DECORATOR_MASK | ON_DECORATOR_MASK |
123                                              IN_HEAP | IS_ARRAY | IS_NOT_NULL;
124     verify_decorators&lt;expected_mo_decorators | heap_oop_decorators&gt;();
125   }
126 
127   template &lt;DecoratorSet expected_mo_decorators&gt;
128   static void verify_heap_value_decorators() {
129     const DecoratorSet heap_value_decorators = IN_HEAP | IS_DEST_UNINITIALIZED;
130     verify_decorators&lt;expected_mo_decorators | heap_value_decorators&gt;();
131   }
132 
<span class="line-modified">133   static const DecoratorSet load_mo_decorators = MO_UNORDERED | MO_VOLATILE | MO_RELAXED | MO_ACQUIRE | MO_SEQ_CST;</span>
<span class="line-modified">134   static const DecoratorSet store_mo_decorators = MO_UNORDERED | MO_VOLATILE | MO_RELAXED | MO_RELEASE | MO_SEQ_CST;</span>
135   static const DecoratorSet atomic_xchg_mo_decorators = MO_SEQ_CST;
136   static const DecoratorSet atomic_cmpxchg_mo_decorators = MO_RELAXED | MO_SEQ_CST;
137 
138 protected:
139   template &lt;typename T&gt;
140   static inline void oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
141                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
142                                    size_t length) {
143     verify_decorators&lt;ARRAYCOPY_DECORATOR_MASK | IN_HEAP |
144                       AS_DECORATOR_MASK | IS_ARRAY | IS_DEST_UNINITIALIZED&gt;();
145     AccessInternal::arraycopy&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(src_obj, src_offset_in_bytes, src_raw,
146                                                                   dst_obj, dst_offset_in_bytes, dst_raw,
147                                                                   length);
148   }
149 
150   template &lt;typename T&gt;
151   static inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
152                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
153                                size_t length) {
154     verify_decorators&lt;ARRAYCOPY_DECORATOR_MASK | IN_HEAP |
</pre>
<hr />
<pre>
358 template &lt;DecoratorSet decorators&gt;
359 template &lt;DecoratorSet expected_decorators&gt;
360 void Access&lt;decorators&gt;::verify_decorators() {
361   STATIC_ASSERT((~expected_decorators &amp; decorators) == 0); // unexpected decorator used
362   const DecoratorSet barrier_strength_decorators = decorators &amp; AS_DECORATOR_MASK;
363   STATIC_ASSERT(barrier_strength_decorators == 0 || ( // make sure barrier strength decorators are disjoint if set
364     (barrier_strength_decorators ^ AS_NO_KEEPALIVE) == 0 ||
365     (barrier_strength_decorators ^ AS_RAW) == 0 ||
366     (barrier_strength_decorators ^ AS_NORMAL) == 0
367   ));
368   const DecoratorSet ref_strength_decorators = decorators &amp; ON_DECORATOR_MASK;
369   STATIC_ASSERT(ref_strength_decorators == 0 || ( // make sure ref strength decorators are disjoint if set
370     (ref_strength_decorators ^ ON_STRONG_OOP_REF) == 0 ||
371     (ref_strength_decorators ^ ON_WEAK_OOP_REF) == 0 ||
372     (ref_strength_decorators ^ ON_PHANTOM_OOP_REF) == 0 ||
373     (ref_strength_decorators ^ ON_UNKNOWN_OOP_REF) == 0
374   ));
375   const DecoratorSet memory_ordering_decorators = decorators &amp; MO_DECORATOR_MASK;
376   STATIC_ASSERT(memory_ordering_decorators == 0 || ( // make sure memory ordering decorators are disjoint if set
377     (memory_ordering_decorators ^ MO_UNORDERED) == 0 ||
<span class="line-removed">378     (memory_ordering_decorators ^ MO_VOLATILE) == 0 ||</span>
379     (memory_ordering_decorators ^ MO_RELAXED) == 0 ||
380     (memory_ordering_decorators ^ MO_ACQUIRE) == 0 ||
381     (memory_ordering_decorators ^ MO_RELEASE) == 0 ||
382     (memory_ordering_decorators ^ MO_SEQ_CST) == 0
383   ));
384   const DecoratorSet location_decorators = decorators &amp; IN_DECORATOR_MASK;
385   STATIC_ASSERT(location_decorators == 0 || ( // make sure location decorators are disjoint if set
386     (location_decorators ^ IN_NATIVE) == 0 ||
387     (location_decorators ^ IN_HEAP) == 0
388   ));
389 }
390 
391 #endif // SHARE_OOPS_ACCESS_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
113   static void verify_oop_decorators() {
114     const DecoratorSet oop_decorators = AS_DECORATOR_MASK | IN_DECORATOR_MASK |
115                                         (ON_DECORATOR_MASK ^ ON_UNKNOWN_OOP_REF) | // no unknown oop refs outside of the heap
116                                         IS_ARRAY | IS_NOT_NULL | IS_DEST_UNINITIALIZED;
117     verify_decorators&lt;expected_mo_decorators | oop_decorators&gt;();
118   }
119 
120   template &lt;DecoratorSet expected_mo_decorators&gt;
121   static void verify_heap_oop_decorators() {
122     const DecoratorSet heap_oop_decorators = AS_DECORATOR_MASK | ON_DECORATOR_MASK |
123                                              IN_HEAP | IS_ARRAY | IS_NOT_NULL;
124     verify_decorators&lt;expected_mo_decorators | heap_oop_decorators&gt;();
125   }
126 
127   template &lt;DecoratorSet expected_mo_decorators&gt;
128   static void verify_heap_value_decorators() {
129     const DecoratorSet heap_value_decorators = IN_HEAP | IS_DEST_UNINITIALIZED;
130     verify_decorators&lt;expected_mo_decorators | heap_value_decorators&gt;();
131   }
132 
<span class="line-modified">133   static const DecoratorSet load_mo_decorators = MO_UNORDERED | MO_RELAXED | MO_ACQUIRE | MO_SEQ_CST;</span>
<span class="line-modified">134   static const DecoratorSet store_mo_decorators = MO_UNORDERED | MO_RELAXED | MO_RELEASE | MO_SEQ_CST;</span>
135   static const DecoratorSet atomic_xchg_mo_decorators = MO_SEQ_CST;
136   static const DecoratorSet atomic_cmpxchg_mo_decorators = MO_RELAXED | MO_SEQ_CST;
137 
138 protected:
139   template &lt;typename T&gt;
140   static inline void oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
141                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
142                                    size_t length) {
143     verify_decorators&lt;ARRAYCOPY_DECORATOR_MASK | IN_HEAP |
144                       AS_DECORATOR_MASK | IS_ARRAY | IS_DEST_UNINITIALIZED&gt;();
145     AccessInternal::arraycopy&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(src_obj, src_offset_in_bytes, src_raw,
146                                                                   dst_obj, dst_offset_in_bytes, dst_raw,
147                                                                   length);
148   }
149 
150   template &lt;typename T&gt;
151   static inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,
152                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
153                                size_t length) {
154     verify_decorators&lt;ARRAYCOPY_DECORATOR_MASK | IN_HEAP |
</pre>
<hr />
<pre>
358 template &lt;DecoratorSet decorators&gt;
359 template &lt;DecoratorSet expected_decorators&gt;
360 void Access&lt;decorators&gt;::verify_decorators() {
361   STATIC_ASSERT((~expected_decorators &amp; decorators) == 0); // unexpected decorator used
362   const DecoratorSet barrier_strength_decorators = decorators &amp; AS_DECORATOR_MASK;
363   STATIC_ASSERT(barrier_strength_decorators == 0 || ( // make sure barrier strength decorators are disjoint if set
364     (barrier_strength_decorators ^ AS_NO_KEEPALIVE) == 0 ||
365     (barrier_strength_decorators ^ AS_RAW) == 0 ||
366     (barrier_strength_decorators ^ AS_NORMAL) == 0
367   ));
368   const DecoratorSet ref_strength_decorators = decorators &amp; ON_DECORATOR_MASK;
369   STATIC_ASSERT(ref_strength_decorators == 0 || ( // make sure ref strength decorators are disjoint if set
370     (ref_strength_decorators ^ ON_STRONG_OOP_REF) == 0 ||
371     (ref_strength_decorators ^ ON_WEAK_OOP_REF) == 0 ||
372     (ref_strength_decorators ^ ON_PHANTOM_OOP_REF) == 0 ||
373     (ref_strength_decorators ^ ON_UNKNOWN_OOP_REF) == 0
374   ));
375   const DecoratorSet memory_ordering_decorators = decorators &amp; MO_DECORATOR_MASK;
376   STATIC_ASSERT(memory_ordering_decorators == 0 || ( // make sure memory ordering decorators are disjoint if set
377     (memory_ordering_decorators ^ MO_UNORDERED) == 0 ||

378     (memory_ordering_decorators ^ MO_RELAXED) == 0 ||
379     (memory_ordering_decorators ^ MO_ACQUIRE) == 0 ||
380     (memory_ordering_decorators ^ MO_RELEASE) == 0 ||
381     (memory_ordering_decorators ^ MO_SEQ_CST) == 0
382   ));
383   const DecoratorSet location_decorators = decorators &amp; IN_DECORATOR_MASK;
384   STATIC_ASSERT(location_decorators == 0 || ( // make sure location decorators are disjoint if set
385     (location_decorators ^ IN_NATIVE) == 0 ||
386     (location_decorators ^ IN_HEAP) == 0
387   ));
388 }
389 
390 #endif // SHARE_OOPS_ACCESS_HPP
</pre>
</td>
</tr>
</table>
<center><a href="../memory/virtualspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessBackend.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
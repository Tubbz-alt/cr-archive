<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/virtualspace.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="virtualspace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/access.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/virtualspace.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58   // Initialize the reserved space with the given size. If preferred_page_size
 59   // is set, use this as minimum page size/alignment. This may waste some space
 60   // if the given size is not aligned to that value, as the reservation will be
 61   // aligned up to the final alignment in this case.
 62   ReservedSpace(size_t size, size_t preferred_page_size = 0);
 63   ReservedSpace(size_t size, size_t alignment, bool large,
 64                 char* requested_address = NULL);
 65 
 66   // Accessors
 67   char*  base()            const { return _base;      }
 68   size_t size()            const { return _size;      }
 69   char*  end()             const { return _base + _size; }
 70   size_t alignment()       const { return _alignment; }
 71   bool   special()         const { return _special;   }
 72   bool   executable()      const { return _executable;   }
 73   size_t noaccess_prefix() const { return _noaccess_prefix;   }
 74   bool is_reserved()       const { return _base != NULL; }
 75   void release();
 76 
 77   // Splitting
<span class="line-modified"> 78   ReservedSpace first_part(size_t partition_size, size_t alignment,</span>
<span class="line-modified"> 79                            bool split = false, bool realloc = true);</span>




 80   ReservedSpace last_part (size_t partition_size, size_t alignment);
 81 
 82   // These simply call the above using the default alignment.
<span class="line-modified"> 83   inline ReservedSpace first_part(size_t partition_size,</span>
<span class="line-removed"> 84                                   bool split = false, bool realloc = true);</span>
 85   inline ReservedSpace last_part (size_t partition_size);
 86 
 87   // Alignment
 88   static size_t page_align_size_up(size_t size);
 89   static size_t page_align_size_down(size_t size);
 90   static size_t allocation_align_size_up(size_t size);
 91   bool contains(const void* p) const {
 92     return (base() &lt;= ((char*)p)) &amp;&amp; (((char*)p) &lt; (base() + size()));
 93   }
 94 };
 95 
 96 ReservedSpace
<span class="line-modified"> 97 ReservedSpace::first_part(size_t partition_size, bool split, bool realloc)</span>
 98 {
<span class="line-modified"> 99   return first_part(partition_size, alignment(), split, realloc);</span>
100 }
101 
102 ReservedSpace ReservedSpace::last_part(size_t partition_size)
103 {
104   return last_part(partition_size, alignment());
105 }
106 
107 // Class encapsulating behavior specific of memory space reserved for Java heap.
108 class ReservedHeapSpace : public ReservedSpace {
109  private:
110   void try_reserve_heap(size_t size, size_t alignment, bool large,
111                         char *requested_address);
112   void try_reserve_range(char *highest_start, char *lowest_start,
113                          size_t attach_point_alignment, char *aligned_HBMA,
114                          char *upper_bound, size_t size, size_t alignment, bool large);
115   void initialize_compressed_heap(const size_t size, size_t alignment, bool large);
116   // Create protection page at the beginning of the space.
117   void establish_noaccess_prefix();
118  public:
119   // Constructor. Tries to find a heap that is good for compressed oops.
</pre>
</td>
<td>
<hr />
<pre>
 58   // Initialize the reserved space with the given size. If preferred_page_size
 59   // is set, use this as minimum page size/alignment. This may waste some space
 60   // if the given size is not aligned to that value, as the reservation will be
 61   // aligned up to the final alignment in this case.
 62   ReservedSpace(size_t size, size_t preferred_page_size = 0);
 63   ReservedSpace(size_t size, size_t alignment, bool large,
 64                 char* requested_address = NULL);
 65 
 66   // Accessors
 67   char*  base()            const { return _base;      }
 68   size_t size()            const { return _size;      }
 69   char*  end()             const { return _base + _size; }
 70   size_t alignment()       const { return _alignment; }
 71   bool   special()         const { return _special;   }
 72   bool   executable()      const { return _executable;   }
 73   size_t noaccess_prefix() const { return _noaccess_prefix;   }
 74   bool is_reserved()       const { return _base != NULL; }
 75   void release();
 76 
 77   // Splitting
<span class="line-modified"> 78   // This splits the space into two spaces, the first part of which will be returned.</span>
<span class="line-modified"> 79   // If split==true, the resulting two spaces can be released independently from each other.</span>
<span class="line-added"> 80   //  This may cause the original space to loose its content.</span>
<span class="line-added"> 81   // If split==false, the resulting space will be just a hotspot-internal representation</span>
<span class="line-added"> 82   //  of a sub section of the underlying mapping.</span>
<span class="line-added"> 83   ReservedSpace first_part(size_t partition_size, size_t alignment, bool split = false);</span>
 84   ReservedSpace last_part (size_t partition_size, size_t alignment);
 85 
 86   // These simply call the above using the default alignment.
<span class="line-modified"> 87   inline ReservedSpace first_part(size_t partition_size, bool split = false);</span>

 88   inline ReservedSpace last_part (size_t partition_size);
 89 
 90   // Alignment
 91   static size_t page_align_size_up(size_t size);
 92   static size_t page_align_size_down(size_t size);
 93   static size_t allocation_align_size_up(size_t size);
 94   bool contains(const void* p) const {
 95     return (base() &lt;= ((char*)p)) &amp;&amp; (((char*)p) &lt; (base() + size()));
 96   }
 97 };
 98 
 99 ReservedSpace
<span class="line-modified">100 ReservedSpace::first_part(size_t partition_size, bool split)</span>
101 {
<span class="line-modified">102   return first_part(partition_size, alignment(), split);</span>
103 }
104 
105 ReservedSpace ReservedSpace::last_part(size_t partition_size)
106 {
107   return last_part(partition_size, alignment());
108 }
109 
110 // Class encapsulating behavior specific of memory space reserved for Java heap.
111 class ReservedHeapSpace : public ReservedSpace {
112  private:
113   void try_reserve_heap(size_t size, size_t alignment, bool large,
114                         char *requested_address);
115   void try_reserve_range(char *highest_start, char *lowest_start,
116                          size_t attach_point_alignment, char *aligned_HBMA,
117                          char *upper_bound, size_t size, size_t alignment, bool large);
118   void initialize_compressed_heap(const size_t size, size_t alignment, bool large);
119   // Create protection page at the beginning of the space.
120   void establish_noaccess_prefix();
121  public:
122   // Constructor. Tries to find a heap that is good for compressed oops.
</pre>
</td>
</tr>
</table>
<center><a href="virtualspace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/access.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/memory/virtualspace.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_VIRTUALSPACE_HPP
 26 #define SHARE_MEMORY_VIRTUALSPACE_HPP
 27 
 28 #include &quot;memory/memRegion.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 class outputStream;
 32 
 33 // ReservedSpace is a data structure for reserving a contiguous address range.
 34 
 35 class ReservedSpace {
 36   friend class VMStructs;
 37  protected:
 38   char*  _base;
 39   size_t _size;
 40   size_t _noaccess_prefix;
 41   size_t _alignment;
 42   bool   _special;
 43   int    _fd_for_heap;
 44  private:
 45   bool   _executable;
 46 
 47   // ReservedSpace
 48   ReservedSpace(char* base, size_t size, size_t alignment, bool special,
 49                 bool executable);
 50  protected:
 51   void initialize(size_t size, size_t alignment, bool large,
 52                   char* requested_address,
 53                   bool executable);
 54 
 55  public:
 56   // Constructor
 57   ReservedSpace();
 58   // Initialize the reserved space with the given size. If preferred_page_size
 59   // is set, use this as minimum page size/alignment. This may waste some space
 60   // if the given size is not aligned to that value, as the reservation will be
 61   // aligned up to the final alignment in this case.
 62   ReservedSpace(size_t size, size_t preferred_page_size = 0);
 63   ReservedSpace(size_t size, size_t alignment, bool large,
 64                 char* requested_address = NULL);
 65 
 66   // Accessors
 67   char*  base()            const { return _base;      }
 68   size_t size()            const { return _size;      }
 69   char*  end()             const { return _base + _size; }
 70   size_t alignment()       const { return _alignment; }
 71   bool   special()         const { return _special;   }
 72   bool   executable()      const { return _executable;   }
 73   size_t noaccess_prefix() const { return _noaccess_prefix;   }
 74   bool is_reserved()       const { return _base != NULL; }
 75   void release();
 76 
 77   // Splitting
 78   // This splits the space into two spaces, the first part of which will be returned.
 79   // If split==true, the resulting two spaces can be released independently from each other.
 80   //  This may cause the original space to loose its content.
 81   // If split==false, the resulting space will be just a hotspot-internal representation
 82   //  of a sub section of the underlying mapping.
 83   ReservedSpace first_part(size_t partition_size, size_t alignment, bool split = false);
 84   ReservedSpace last_part (size_t partition_size, size_t alignment);
 85 
 86   // These simply call the above using the default alignment.
 87   inline ReservedSpace first_part(size_t partition_size, bool split = false);
 88   inline ReservedSpace last_part (size_t partition_size);
 89 
 90   // Alignment
 91   static size_t page_align_size_up(size_t size);
 92   static size_t page_align_size_down(size_t size);
 93   static size_t allocation_align_size_up(size_t size);
 94   bool contains(const void* p) const {
 95     return (base() &lt;= ((char*)p)) &amp;&amp; (((char*)p) &lt; (base() + size()));
 96   }
 97 };
 98 
 99 ReservedSpace
100 ReservedSpace::first_part(size_t partition_size, bool split)
101 {
102   return first_part(partition_size, alignment(), split);
103 }
104 
105 ReservedSpace ReservedSpace::last_part(size_t partition_size)
106 {
107   return last_part(partition_size, alignment());
108 }
109 
110 // Class encapsulating behavior specific of memory space reserved for Java heap.
111 class ReservedHeapSpace : public ReservedSpace {
112  private:
113   void try_reserve_heap(size_t size, size_t alignment, bool large,
114                         char *requested_address);
115   void try_reserve_range(char *highest_start, char *lowest_start,
116                          size_t attach_point_alignment, char *aligned_HBMA,
117                          char *upper_bound, size_t size, size_t alignment, bool large);
118   void initialize_compressed_heap(const size_t size, size_t alignment, bool large);
119   // Create protection page at the beginning of the space.
120   void establish_noaccess_prefix();
121  public:
122   // Constructor. Tries to find a heap that is good for compressed oops.
123   // heap_allocation_directory is the path to the backing memory for Java heap. When set, Java heap will be allocated
124   // on the device which is managed by the file system where the directory resides.
125   ReservedHeapSpace(size_t size, size_t forced_base_alignment, bool large, const char* heap_allocation_directory = NULL);
126   // Returns the base to be used for compression, i.e. so that null can be
127   // encoded safely and implicit null checks can work.
128   char *compressed_oop_base() const { return _base - _noaccess_prefix; }
129   MemRegion region() const;
130 };
131 
132 // Class encapsulating behavior specific memory space for Code
133 class ReservedCodeSpace : public ReservedSpace {
134  public:
135   // Constructor
136   ReservedCodeSpace(size_t r_size, size_t rs_align, bool large);
137 };
138 
139 // VirtualSpace is data structure for committing a previously reserved address range in smaller chunks.
140 
141 class VirtualSpace {
142   friend class VMStructs;
143  private:
144   // Reserved area
145   char* _low_boundary;
146   char* _high_boundary;
147 
148   // Committed area
149   char* _low;
150   char* _high;
151 
152   // The entire space has been committed and pinned in memory, no
153   // os::commit_memory() or os::uncommit_memory().
154   bool _special;
155 
156   // Need to know if commit should be executable.
157   bool   _executable;
158 
159   // MPSS Support
160   // Each virtualspace region has a lower, middle, and upper region.
161   // Each region has an end boundary and a high pointer which is the
162   // high water mark for the last allocated byte.
163   // The lower and upper unaligned to LargePageSizeInBytes uses default page.
164   // size.  The middle region uses large page size.
165   char* _lower_high;
166   char* _middle_high;
167   char* _upper_high;
168 
169   char* _lower_high_boundary;
170   char* _middle_high_boundary;
171   char* _upper_high_boundary;
172 
173   size_t _lower_alignment;
174   size_t _middle_alignment;
175   size_t _upper_alignment;
176 
177   // MPSS Accessors
178   char* lower_high() const { return _lower_high; }
179   char* middle_high() const { return _middle_high; }
180   char* upper_high() const { return _upper_high; }
181 
182   char* lower_high_boundary() const { return _lower_high_boundary; }
183   char* middle_high_boundary() const { return _middle_high_boundary; }
184   char* upper_high_boundary() const { return _upper_high_boundary; }
185 
186   size_t lower_alignment() const { return _lower_alignment; }
187   size_t middle_alignment() const { return _middle_alignment; }
188   size_t upper_alignment() const { return _upper_alignment; }
189 
190  public:
191   // Committed area
192   char* low()  const { return _low; }
193   char* high() const { return _high; }
194 
195   // Reserved area
196   char* low_boundary()  const { return _low_boundary; }
197   char* high_boundary() const { return _high_boundary; }
198 
199 #if INCLUDE_AOT
200   // Set boundaries for code section in AOT library.
201   void set_low_boundary(char *p)  { _low_boundary = p; }
202   void set_high_boundary(char *p) { _high_boundary = p; }
203   void set_low(char *p)           { _low = p; }
204   void set_high(char *p)          { _high = p; }
205 #endif
206 
207   bool special() const { return _special; }
208 
209  public:
210   // Initialization
211   VirtualSpace();
212   bool initialize_with_granularity(ReservedSpace rs, size_t committed_byte_size, size_t max_commit_ganularity);
213   bool initialize(ReservedSpace rs, size_t committed_byte_size);
214 
215   // Destruction
216   ~VirtualSpace();
217 
218   // Reserved memory
219   size_t reserved_size() const;
220   // Actually committed OS memory
221   size_t actual_committed_size() const;
222   // Memory used/expanded in this virtual space
223   size_t committed_size() const;
224   // Memory left to use/expand in this virtual space
225   size_t uncommitted_size() const;
226 
227   bool   contains(const void* p) const;
228 
229   // Operations
230   // returns true on success, false otherwise
231   bool expand_by(size_t bytes, bool pre_touch = false);
232   void shrink_by(size_t bytes);
233   void release();
234 
235   void check_for_contiguity() PRODUCT_RETURN;
236 
237   // Debugging
238   void print_on(outputStream* out) PRODUCT_RETURN;
239   void print();
240 };
241 
242 #endif // SHARE_MEMORY_VIRTUALSPACE_HPP
    </pre>
  </body>
</html>
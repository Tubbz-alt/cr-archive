<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/filemap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../jvmci/jvmciCompilerToVM.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/filemap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 190   } else {
 191     assert(_dynamic_archive_info == this, &quot;must be singleton&quot;); // not thread safe
 192     _dynamic_archive_info = NULL;
 193   }
 194 }
 195 
 196 void FileMapInfo::populate_header(size_t alignment) {
 197   header()-&gt;populate(this, alignment);
 198 }
 199 
 200 void FileMapHeader::populate(FileMapInfo* mapinfo, size_t alignment) {
 201   if (DynamicDumpSharedSpaces) {
 202     _magic = CDS_DYNAMIC_ARCHIVE_MAGIC;
 203   } else {
 204     _magic = CDS_ARCHIVE_MAGIC;
 205   }
 206   _version = CURRENT_CDS_ARCHIVE_VERSION;
 207   _alignment = alignment;
 208   _obj_alignment = ObjectAlignmentInBytes;
 209   _compact_strings = CompactStrings;
<span class="line-modified"> 210   _narrow_oop_mode = CompressedOops::mode();</span>
<span class="line-modified"> 211   _narrow_oop_base = CompressedOops::base();</span>
<span class="line-modified"> 212   _narrow_oop_shift = CompressedOops::shift();</span>



 213   _compressed_oops = UseCompressedOops;
 214   _compressed_class_ptrs = UseCompressedClassPointers;
 215   _max_heap_size = MaxHeapSize;
 216   _narrow_klass_shift = CompressedKlassPointers::shift();
<span class="line-removed"> 217   if (HeapShared::is_heap_object_archiving_allowed()) {</span>
<span class="line-removed"> 218     _heap_end = CompressedOops::end();</span>
<span class="line-removed"> 219   }</span>
 220 
 221   // The following fields are for sanity checks for whether this archive
 222   // will function correctly with this JVM and the bootclasspath it&#39;s
 223   // invoked with.
 224 
 225   // JVM version string ... changes on each build.
 226   get_header_version(_jvm_ident);
 227 
 228   _app_class_paths_start_index = ClassLoaderExt::app_class_paths_start_index();
 229   _app_module_paths_start_index = ClassLoaderExt::app_module_paths_start_index();
 230   _num_module_paths = ClassLoader::num_module_path_entries();
 231   _max_used_path_index = ClassLoaderExt::max_used_path_index();
 232 
 233   _verify_local = BytecodeVerificationLocal;
 234   _verify_remote = BytecodeVerificationRemote;
 235   _has_platform_or_app_classes = ClassLoaderExt::has_platform_or_app_classes();
 236   _requested_base_address = (char*)SharedBaseAddress;
 237   _mapped_base_address = (char*)SharedBaseAddress;
 238   _allow_archiving_with_java_agent = AllowArchivingWithJavaAgent;
 239   // the following 2 fields will be set in write_header for dynamic archive header
</pre>
<hr />
<pre>
1052 
1053   return true;
1054 }
1055 
1056 void FileMapInfo::seek_to_position(size_t pos) {
1057   if (lseek(_fd, (long)pos, SEEK_SET) &lt; 0) {
1058     fail_stop(&quot;Unable to seek to position &quot; SIZE_FORMAT, pos);
1059   }
1060 }
1061 
1062 // Read the FileMapInfo information from the file.
1063 bool FileMapInfo::open_for_read() {
1064   if (_file_open) {
1065     return true;
1066   }
1067   if (is_static()) {
1068     _full_path = Arguments::GetSharedArchivePath();
1069   } else {
1070     _full_path = Arguments::GetSharedDynamicArchivePath();
1071   }

1072   int fd = os::open(_full_path, O_RDONLY | O_BINARY, 0);
1073   if (fd &lt; 0) {
1074     if (errno == ENOENT) {
1075       fail_continue(&quot;Specified shared archive not found (%s).&quot;, _full_path);
1076     } else {
1077       fail_continue(&quot;Failed to open shared archive file (%s).&quot;,
1078                     os::strerror(errno));
1079     }
1080     return false;
1081   }
1082 
1083   _fd = fd;
1084   _file_open = true;
1085   return true;
1086 }
1087 
1088 // Write the FileMapInfo information to the file.
1089 
1090 void FileMapInfo::open_for_write(const char* path) {
1091   if (path == NULL) {
</pre>
</td>
<td>
<hr />
<pre>
 190   } else {
 191     assert(_dynamic_archive_info == this, &quot;must be singleton&quot;); // not thread safe
 192     _dynamic_archive_info = NULL;
 193   }
 194 }
 195 
 196 void FileMapInfo::populate_header(size_t alignment) {
 197   header()-&gt;populate(this, alignment);
 198 }
 199 
 200 void FileMapHeader::populate(FileMapInfo* mapinfo, size_t alignment) {
 201   if (DynamicDumpSharedSpaces) {
 202     _magic = CDS_DYNAMIC_ARCHIVE_MAGIC;
 203   } else {
 204     _magic = CDS_ARCHIVE_MAGIC;
 205   }
 206   _version = CURRENT_CDS_ARCHIVE_VERSION;
 207   _alignment = alignment;
 208   _obj_alignment = ObjectAlignmentInBytes;
 209   _compact_strings = CompactStrings;
<span class="line-modified"> 210   if (HeapShared::is_heap_object_archiving_allowed()) {</span>
<span class="line-modified"> 211     _narrow_oop_mode = CompressedOops::mode();</span>
<span class="line-modified"> 212     _narrow_oop_base = CompressedOops::base();</span>
<span class="line-added"> 213     _narrow_oop_shift = CompressedOops::shift();</span>
<span class="line-added"> 214     _heap_end = CompressedOops::end();</span>
<span class="line-added"> 215   }</span>
 216   _compressed_oops = UseCompressedOops;
 217   _compressed_class_ptrs = UseCompressedClassPointers;
 218   _max_heap_size = MaxHeapSize;
 219   _narrow_klass_shift = CompressedKlassPointers::shift();



 220 
 221   // The following fields are for sanity checks for whether this archive
 222   // will function correctly with this JVM and the bootclasspath it&#39;s
 223   // invoked with.
 224 
 225   // JVM version string ... changes on each build.
 226   get_header_version(_jvm_ident);
 227 
 228   _app_class_paths_start_index = ClassLoaderExt::app_class_paths_start_index();
 229   _app_module_paths_start_index = ClassLoaderExt::app_module_paths_start_index();
 230   _num_module_paths = ClassLoader::num_module_path_entries();
 231   _max_used_path_index = ClassLoaderExt::max_used_path_index();
 232 
 233   _verify_local = BytecodeVerificationLocal;
 234   _verify_remote = BytecodeVerificationRemote;
 235   _has_platform_or_app_classes = ClassLoaderExt::has_platform_or_app_classes();
 236   _requested_base_address = (char*)SharedBaseAddress;
 237   _mapped_base_address = (char*)SharedBaseAddress;
 238   _allow_archiving_with_java_agent = AllowArchivingWithJavaAgent;
 239   // the following 2 fields will be set in write_header for dynamic archive header
</pre>
<hr />
<pre>
1052 
1053   return true;
1054 }
1055 
1056 void FileMapInfo::seek_to_position(size_t pos) {
1057   if (lseek(_fd, (long)pos, SEEK_SET) &lt; 0) {
1058     fail_stop(&quot;Unable to seek to position &quot; SIZE_FORMAT, pos);
1059   }
1060 }
1061 
1062 // Read the FileMapInfo information from the file.
1063 bool FileMapInfo::open_for_read() {
1064   if (_file_open) {
1065     return true;
1066   }
1067   if (is_static()) {
1068     _full_path = Arguments::GetSharedArchivePath();
1069   } else {
1070     _full_path = Arguments::GetSharedDynamicArchivePath();
1071   }
<span class="line-added">1072   log_info(cds)(&quot;trying to map %s&quot;, _full_path);</span>
1073   int fd = os::open(_full_path, O_RDONLY | O_BINARY, 0);
1074   if (fd &lt; 0) {
1075     if (errno == ENOENT) {
1076       fail_continue(&quot;Specified shared archive not found (%s).&quot;, _full_path);
1077     } else {
1078       fail_continue(&quot;Failed to open shared archive file (%s).&quot;,
1079                     os::strerror(errno));
1080     }
1081     return false;
1082   }
1083 
1084   _fd = fd;
1085   _file_open = true;
1086   return true;
1087 }
1088 
1089 // Write the FileMapInfo information to the file.
1090 
1091 void FileMapInfo::open_for_write(const char* path) {
1092   if (path == NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="../jvmci/jvmciCompilerToVM.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
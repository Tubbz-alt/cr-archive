diff a/src/hotspot/share/interpreter/cppInterpreter.cpp b/src/hotspot/share/interpreter/cppInterpreter.cpp
--- a/src/hotspot/share/interpreter/cppInterpreter.cpp
+++ b/src/hotspot/share/interpreter/cppInterpreter.cpp
@@ -36,21 +36,26 @@
 # include "entry_zero.hpp"
 #else
 #error "Only Zero CppInterpreter is supported"
 #endif
 
-void CppInterpreter::initialize() {
+void CppInterpreter::initialize_stub() {
   if (_code != NULL) return;
+
+  // generate interpreter
+  int code_size = InterpreterCodeSize;
+  NOT_PRODUCT(code_size *= 4;)  // debug uses extra interpreter code space
+  _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,
+                         "Interpreter");
+}
+
+void CppInterpreter::initialize_code() {
   AbstractInterpreter::initialize();
 
   // generate interpreter
   { ResourceMark rm;
     TraceTime timer("Interpreter generation", TRACETIME_LOG(Info, startuptime));
-    int code_size = InterpreterCodeSize;
-    NOT_PRODUCT(code_size *= 4;)  // debug uses extra interpreter code space
-    _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,
-                           "Interpreter");
     CppInterpreterGenerator g(_code);
     if (PrintInterpreter) print();
   }
 
   // Allow c++ interpreter to do one initialization now that switches are set, etc.
@@ -59,11 +64,10 @@
     BytecodeInterpreter::runWithChecks(&start_msg);
   else
     BytecodeInterpreter::run(&start_msg);
 }
 
-
 void CppInterpreter::invoke_method(Method* method, address entry_point, TRAPS) {
   ((ZeroEntry *) entry_point)->invoke(method, THREAD);
 }
 
 void CppInterpreter::invoke_osr(Method* method,

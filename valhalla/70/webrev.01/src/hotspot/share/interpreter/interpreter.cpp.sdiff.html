<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/interpreter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cppInterpreter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 96   // Create assembler for code generation.
 97   masm = new InterpreterMacroAssembler(&amp;_cb);
 98   _masm = &amp;masm;
 99 }
100 
101 CodeletMark::~CodeletMark() {
102   // Align so printing shows nop&#39;s instead of random code at the end (Codelets are aligned).
103   (*_masm)-&gt;align(wordSize);
104   // Make sure all code is in code buffer.
105   (*_masm)-&gt;flush();
106 
107   // Commit Codelet.
108   int committed_code_size = (*_masm)-&gt;code()-&gt;pure_insts_size();
109   if (committed_code_size) {
110     AbstractInterpreter::code()-&gt;commit(committed_code_size, (*_masm)-&gt;code()-&gt;strings());
111   }
112   // Make sure nobody can use _masm outside a CodeletMark lifespan.
113   *_masm = NULL;
114 }
115 













116 
<span class="line-modified">117 void interpreter_init() {</span>
<span class="line-modified">118   Interpreter::initialize();</span>
119 #ifndef PRODUCT
120   if (TraceBytecodes) BytecodeTracer::set_closure(BytecodeTracer::std_closure());
121 #endif // PRODUCT
122   // need to hit every safepoint in order to call zapping routine
123   // register the interpreter
124   Forte::register_stub(
125     &quot;Interpreter&quot;,
126     AbstractInterpreter::code()-&gt;code_start(),
127     AbstractInterpreter::code()-&gt;code_end()
128   );
129 
130   // notify JVMTI profiler
131   if (JvmtiExport::should_post_dynamic_code_generated()) {
132     JvmtiExport::post_dynamic_code_generated(&quot;Interpreter&quot;,
133                                              AbstractInterpreter::code()-&gt;code_start(),
134                                              AbstractInterpreter::code()-&gt;code_end());
135   }
136 }
</pre>
</td>
<td>
<hr />
<pre>
 96   // Create assembler for code generation.
 97   masm = new InterpreterMacroAssembler(&amp;_cb);
 98   _masm = &amp;masm;
 99 }
100 
101 CodeletMark::~CodeletMark() {
102   // Align so printing shows nop&#39;s instead of random code at the end (Codelets are aligned).
103   (*_masm)-&gt;align(wordSize);
104   // Make sure all code is in code buffer.
105   (*_masm)-&gt;flush();
106 
107   // Commit Codelet.
108   int committed_code_size = (*_masm)-&gt;code()-&gt;pure_insts_size();
109   if (committed_code_size) {
110     AbstractInterpreter::code()-&gt;commit(committed_code_size, (*_masm)-&gt;code()-&gt;strings());
111   }
112   // Make sure nobody can use _masm outside a CodeletMark lifespan.
113   *_masm = NULL;
114 }
115 
<span class="line-added">116 // The reason that interpreter initialization is split into two parts is that the first part</span>
<span class="line-added">117 // needs to run before methods are loaded (which with CDS implies linked also), and the other</span>
<span class="line-added">118 // part needs to run after. The reason is that when methods are loaded (with CDS) or linked</span>
<span class="line-added">119 // (without CDS), the i2c adapters are generated that assert we are currently in the interpreter.</span>
<span class="line-added">120 // Asserting that requires knowledge about where the interpreter is in memory. Therefore,</span>
<span class="line-added">121 // establishing the interpreter address must be done before methods are loaded. However,</span>
<span class="line-added">122 // we would like to actually generate the interpreter after methods are loaded. That allows</span>
<span class="line-added">123 // us to remove otherwise hardcoded offsets regarding fields that are needed in the interpreter</span>
<span class="line-added">124 // code. This leads to a split if 1. reserving the memory for the interpreter, 2. loading methods</span>
<span class="line-added">125 // and 3. generating the interpreter.</span>
<span class="line-added">126 void interpreter_init_stub() {</span>
<span class="line-added">127   Interpreter::initialize_stub();</span>
<span class="line-added">128 }</span>
129 
<span class="line-modified">130 void interpreter_init_code() {</span>
<span class="line-modified">131   Interpreter::initialize_code();</span>
132 #ifndef PRODUCT
133   if (TraceBytecodes) BytecodeTracer::set_closure(BytecodeTracer::std_closure());
134 #endif // PRODUCT
135   // need to hit every safepoint in order to call zapping routine
136   // register the interpreter
137   Forte::register_stub(
138     &quot;Interpreter&quot;,
139     AbstractInterpreter::code()-&gt;code_start(),
140     AbstractInterpreter::code()-&gt;code_end()
141   );
142 
143   // notify JVMTI profiler
144   if (JvmtiExport::should_post_dynamic_code_generated()) {
145     JvmtiExport::post_dynamic_code_generated(&quot;Interpreter&quot;,
146                                              AbstractInterpreter::code()-&gt;code_start(),
147                                              AbstractInterpreter::code()-&gt;code_end());
148   }
149 }
</pre>
</td>
</tr>
</table>
<center><a href="cppInterpreter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
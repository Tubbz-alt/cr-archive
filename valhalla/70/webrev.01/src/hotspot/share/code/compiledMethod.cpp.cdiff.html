<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/code/compiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/vmSymbols.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/compiledMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 504,21 ***</span>
    if (nm != NULL) {
      // Clean inline caches pointing to both zombie and not_entrant methods
      if (clean_all || !nm-&gt;is_in_use() || nm-&gt;is_unloading() || (nm-&gt;method()-&gt;code() != nm)) {
        // Inline cache cleaning should only be initiated on CompiledMethods that have been
        // observed to be is_alive(). However, with concurrent code cache unloading, it is
<span class="line-modified">!       // possible that by now, the state has been racingly flipped to unloaded if the nmethod</span>
<span class="line-modified">!       // being cleaned is_unloading(). This is fine, because if that happens, then the inline</span>
        // caches have already been cleaned under the same CompiledICLocker that we now hold during
        // inline cache cleaning, and we will simply walk the inline caches again, and likely not
        // find much of interest to clean. However, this race prevents us from asserting that the
        // nmethod is_alive(). The is_unloading() function is completely monotonic; once set due
        // to an oop dying, it remains set forever until freed. Because of that, all unloaded
        // nmethods are is_unloading(), but notably, an unloaded nmethod may also subsequently
<span class="line-modified">!       // become zombie (when the sweeper converts it to zombie). Therefore, the most precise</span>
<span class="line-modified">!       // sanity check we can check for in this context is to not allow zombies.</span>
<span class="line-modified">!       assert(!from-&gt;is_zombie(), &quot;should not clean inline caches on zombies&quot;);</span>
        if (!ic-&gt;set_to_clean(!from-&gt;is_unloading())) {
          return false;
        }
        assert(ic-&gt;is_clean(), &quot;nmethod &quot; PTR_FORMAT &quot;not clean %s&quot;, p2i(from), from-&gt;method()-&gt;name_and_sig_as_C_string());
      }
<span class="line-new-header">--- 504,43 ---</span>
    if (nm != NULL) {
      // Clean inline caches pointing to both zombie and not_entrant methods
      if (clean_all || !nm-&gt;is_in_use() || nm-&gt;is_unloading() || (nm-&gt;method()-&gt;code() != nm)) {
        // Inline cache cleaning should only be initiated on CompiledMethods that have been
        // observed to be is_alive(). However, with concurrent code cache unloading, it is
<span class="line-modified">!       // possible that by now, the state has become !is_alive. This can happen in two ways:</span>
<span class="line-modified">!       // 1) It can be racingly flipped to unloaded if the nmethod // being cleaned (from the</span>
<span class="line-added">+       // sweeper) is_unloading(). This is fine, because if that happens, then the inline</span>
        // caches have already been cleaned under the same CompiledICLocker that we now hold during
        // inline cache cleaning, and we will simply walk the inline caches again, and likely not
        // find much of interest to clean. However, this race prevents us from asserting that the
        // nmethod is_alive(). The is_unloading() function is completely monotonic; once set due
        // to an oop dying, it remains set forever until freed. Because of that, all unloaded
        // nmethods are is_unloading(), but notably, an unloaded nmethod may also subsequently
<span class="line-modified">!       // become zombie (when the sweeper converts it to zombie).</span>
<span class="line-modified">!       // 2) It can be racingly flipped to zombie if the nmethod being cleaned (by the concurrent</span>
<span class="line-modified">!       // GC) cleans a zombie nmethod that is concurrently made zombie by the sweeper. In this</span>
<span class="line-added">+       // scenario, the sweeper will first transition the nmethod to zombie, and then when</span>
<span class="line-added">+       // unregistering from the GC, it will wait until the GC is done. The GC will then clean</span>
<span class="line-added">+       // the inline caches *with IC stubs*, even though no IC stubs are needed. This is fine,</span>
<span class="line-added">+       // as long as the IC stubs are guaranteed to be released until the next safepoint, where</span>
<span class="line-added">+       // IC finalization requires live IC stubs to not be associated with zombie nmethods.</span>
<span class="line-added">+       // This is guaranteed, because the sweeper does not have a single safepoint check until</span>
<span class="line-added">+       // after it completes the whole transition function; it will wake up after the GC is</span>
<span class="line-added">+       // done with concurrent code cache cleaning (which blocks out safepoints using the</span>
<span class="line-added">+       // suspendible threads set), and then call clear_ic_callsites, which will release the</span>
<span class="line-added">+       // associated IC stubs, before a subsequent safepoint poll can be reached. This</span>
<span class="line-added">+       // guarantees that the spuriously created IC stubs are released appropriately before</span>
<span class="line-added">+       // IC finalization in a safepoint gets to run. Therefore, this race is fine. This is also</span>
<span class="line-added">+       // valid in a scenario where an inline cache of a zombie nmethod gets a spurious IC stub,</span>
<span class="line-added">+       // and then when cleaning another inline cache, fails to request an IC stub because we</span>
<span class="line-added">+       // exhausted the IC stub buffer. In this scenario, the GC will request a safepoint after</span>
<span class="line-added">+       // yielding the suspendible therad set, effectively unblocking safepoints. Before such</span>
<span class="line-added">+       // a safepoint can be reached, the sweeper similarly has to wake up, clear the IC stubs,</span>
<span class="line-added">+       // and reach the next safepoint poll, after the whole transition function has completed.</span>
<span class="line-added">+       // Due to the various races that can cause an nmethod to first be is_alive() and then</span>
<span class="line-added">+       // racingly become !is_alive(), it is unfortunately not possible to assert the nmethod</span>
<span class="line-added">+       // is_alive(), !is_unloaded() or !is_zombie() here.</span>
        if (!ic-&gt;set_to_clean(!from-&gt;is_unloading())) {
          return false;
        }
        assert(ic-&gt;is_clean(), &quot;nmethod &quot; PTR_FORMAT &quot;not clean %s&quot;, p2i(from), from-&gt;method()-&gt;name_and_sig_as_C_string());
      }
</pre>
<center><a href="../classfile/vmSymbols.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
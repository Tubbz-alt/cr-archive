<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../periodic/jfrPeriodic.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrEmergencyDump.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,29 ***</span>
  #include &quot;jfr/recorder/repository/jfrEmergencyDump.hpp&quot;
  #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
  #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
  #include &quot;jfr/utilities/jfrTypes.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="line-removed">- #include &quot;memory/resourceArea.hpp&quot;</span>
  #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed">- #include &quot;runtime/handles.inline.hpp&quot;</span>
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  
  static const char vm_error_filename_fmt[] = &quot;hs_err_pid%p.jfr&quot;;
  static const char vm_oom_filename_fmt[] = &quot;hs_oom_pid%p.jfr&quot;;
  static const char vm_soe_filename_fmt[] = &quot;hs_soe_pid%p.jfr&quot;;
  static const char chunk_file_jfr_ext[] = &quot;.jfr&quot;;
  static const size_t iso8601_len = 19; // &quot;YYYY-MM-DDTHH:MM:SS&quot;
  
  static fio_fd open_exclusivly(const char* path) {
    return os::open(path, O_CREAT | O_RDWR, S_IREAD | S_IWRITE);
  }
  
  static int file_sort(const char** const file1, const char** file2) {
    assert(NULL != *file1 &amp;&amp; NULL != *file2, &quot;invariant&quot;);
    int cmp = strncmp(*file1, *file2, iso8601_len);
    if (0 == cmp) {
      const char* const dot1 = strchr(*file1, &#39;.&#39;);
<span class="line-new-header">--- 29,138 ---</span>
  #include &quot;jfr/recorder/repository/jfrEmergencyDump.hpp&quot;
  #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
  #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
  #include &quot;jfr/utilities/jfrTypes.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
<span class="line-added">+ #include &quot;utilities/ostream.hpp&quot;</span>
  
  static const char vm_error_filename_fmt[] = &quot;hs_err_pid%p.jfr&quot;;
  static const char vm_oom_filename_fmt[] = &quot;hs_oom_pid%p.jfr&quot;;
  static const char vm_soe_filename_fmt[] = &quot;hs_soe_pid%p.jfr&quot;;
  static const char chunk_file_jfr_ext[] = &quot;.jfr&quot;;
  static const size_t iso8601_len = 19; // &quot;YYYY-MM-DDTHH:MM:SS&quot;
<span class="line-added">+ static fio_fd emergency_fd = invalid_fd;</span>
<span class="line-added">+ static const int64_t chunk_file_header_size = 68;</span>
<span class="line-added">+ static const size_t chunk_file_extension_length = sizeof chunk_file_jfr_ext - 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * The emergency dump logic is restrictive when it comes to</span>
<span class="line-added">+  * using internal VM constructs such as ResourceArea / Handle / Arena.</span>
<span class="line-added">+  * The reason being that the thread context is unknown.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * A single static buffer of size JVM_MAXPATHLEN is used for building paths.</span>
<span class="line-added">+  * os::malloc / os::free are used in a few places.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ </span>
<span class="line-added">+ static char _path_buffer[JVM_MAXPATHLEN] = { 0 };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool is_path_empty() {</span>
<span class="line-added">+   return *_path_buffer == &#39;\0&#39;;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // returns with an appended file separator (if successful)</span>
<span class="line-added">+ static size_t get_current_directory() {</span>
<span class="line-added">+   if (os::get_current_directory(_path_buffer, sizeof(_path_buffer)) == NULL) {</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   const size_t cwd_len = strlen(_path_buffer);</span>
<span class="line-added">+   const int result = jio_snprintf(_path_buffer + cwd_len,</span>
<span class="line-added">+                                   sizeof(_path_buffer),</span>
<span class="line-added">+                                   &quot;%s&quot;,</span>
<span class="line-added">+                                   os::file_separator());</span>
<span class="line-added">+   return (result == -1) ? 0 : strlen(_path_buffer);</span>
<span class="line-added">+ }</span>
  
  static fio_fd open_exclusivly(const char* path) {
<span class="line-added">+   assert((path != NULL) &amp;&amp; (*path != &#39;\0&#39;), &quot;invariant&quot;);</span>
    return os::open(path, O_CREAT | O_RDWR, S_IREAD | S_IWRITE);
  }
  
<span class="line-added">+ static bool is_emergency_dump_file_open() {</span>
<span class="line-added">+   return emergency_fd != invalid_fd;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool open_emergency_dump_fd(const char* path) {</span>
<span class="line-added">+   if (path == NULL) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(emergency_fd == invalid_fd, &quot;invariant&quot;);</span>
<span class="line-added">+   emergency_fd = open_exclusivly(path);</span>
<span class="line-added">+   return emergency_fd != invalid_fd;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void close_emergency_dump_file() {</span>
<span class="line-added">+   if (is_emergency_dump_file_open()) {</span>
<span class="line-added">+     os::close(emergency_fd);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static const char* create_emergency_dump_path() {</span>
<span class="line-added">+   assert(is_path_empty(), &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const size_t path_len = get_current_directory();</span>
<span class="line-added">+   if (path_len == 0) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   const char* filename_fmt = NULL;</span>
<span class="line-added">+   // fetch specific error cause</span>
<span class="line-added">+   switch (JfrJavaSupport::cause()) {</span>
<span class="line-added">+     case JfrJavaSupport::OUT_OF_MEMORY:</span>
<span class="line-added">+       filename_fmt = vm_oom_filename_fmt;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case JfrJavaSupport::STACK_OVERFLOW:</span>
<span class="line-added">+       filename_fmt = vm_soe_filename_fmt;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       filename_fmt = vm_error_filename_fmt;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   const bool result = Arguments::copy_expand_pid(filename_fmt, strlen(filename_fmt), _path_buffer + path_len, JVM_MAXPATHLEN - path_len);</span>
<span class="line-added">+   return result ? _path_buffer : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool open_emergency_dump_file() {</span>
<span class="line-added">+   if (is_emergency_dump_file_open()) {</span>
<span class="line-added">+     // opened already</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return open_emergency_dump_fd(create_emergency_dump_path());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void report(outputStream* st, bool emergency_file_opened, const char* repository_path) {</span>
<span class="line-added">+   assert(st != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (emergency_file_opened) {</span>
<span class="line-added">+     st-&gt;print_raw(&quot;# JFR recording file will be written. Location: &quot;);</span>
<span class="line-added">+     st-&gt;print_raw_cr(_path_buffer);</span>
<span class="line-added">+     st-&gt;print_raw_cr(&quot;#&quot;);</span>
<span class="line-added">+   } else if (repository_path != NULL) {</span>
<span class="line-added">+     st-&gt;print_raw(&quot;# The JFR repository may contain useful JFR files. Location: &quot;);</span>
<span class="line-added">+     st-&gt;print_raw_cr(repository_path);</span>
<span class="line-added">+     st-&gt;print_raw_cr(&quot;#&quot;);</span>
<span class="line-added">+   } else if (!is_path_empty()) {</span>
<span class="line-added">+     st-&gt;print_raw(&quot;# Unable to create a JFR recording file at location: &quot;);</span>
<span class="line-added">+     st-&gt;print_raw_cr(_path_buffer);</span>
<span class="line-added">+     st-&gt;print_raw_cr(&quot;#&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrEmergencyDump::on_vm_error_report(outputStream* st, const char* repository_path) {</span>
<span class="line-added">+   assert(st != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   Thread* thread = Thread::current_or_null_safe();</span>
<span class="line-added">+   if (thread != NULL) {</span>
<span class="line-added">+     report(st, open_emergency_dump_file(), repository_path);</span>
<span class="line-added">+   } else if (repository_path != NULL) {</span>
<span class="line-added">+     // a non-attached thread will not be able to write anything later</span>
<span class="line-added">+     report(st, false, repository_path);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static int file_sort(const char** const file1, const char** file2) {
    assert(NULL != *file1 &amp;&amp; NULL != *file2, &quot;invariant&quot;);
    int cmp = strncmp(*file1, *file2, iso8601_len);
    if (0 == cmp) {
      const char* const dot1 = strchr(*file1, &#39;.&#39;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,229 ***</span>
    return size;
  }
  
  class RepositoryIterator : public StackObj {
   private:
<span class="line-modified">!   const char* const _repo;</span>
<span class="line-modified">!   const size_t _repository_len;</span>
<span class="line-removed">-   GrowableArray&lt;const char*&gt;* _files;</span>
<span class="line-removed">-   const char* const fully_qualified(const char* entry) const;</span>
    mutable int _iterator;
<span class="line-modified">! </span>
   public:
<span class="line-modified">!   RepositoryIterator(const char* repository, size_t repository_len);</span>
<span class="line-modified">!   ~RepositoryIterator() {}</span>
<span class="line-removed">-   const char* const filter(const char* entry) const;</span>
    bool has_next() const;
<span class="line-modified">!   const char* const next() const;</span>
  };
  
<span class="line-modified">! const char* const RepositoryIterator::fully_qualified(const char* entry) const {</span>
<span class="line-modified">!   assert(NULL != entry, &quot;invariant&quot;);</span>
<span class="line-modified">!   char* file_path_entry = NULL;</span>
<span class="line-modified">!   // only use files that have content, not placeholders</span>
<span class="line-modified">!   const char* const file_separator = os::file_separator();</span>
<span class="line-modified">!   if (NULL != file_separator) {</span>
<span class="line-modified">!     const size_t entry_len = strlen(entry);</span>
<span class="line-modified">!     const size_t file_separator_length = strlen(file_separator);</span>
<span class="line-modified">!     const size_t file_path_entry_length = _repository_len + file_separator_length + entry_len;</span>
<span class="line-modified">!     file_path_entry = NEW_RESOURCE_ARRAY_RETURN_NULL(char, file_path_entry_length + 1);</span>
<span class="line-modified">!     if (NULL == file_path_entry) {</span>
<span class="line-removed">-       return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     int position = 0;</span>
<span class="line-removed">-     position += jio_snprintf(&amp;file_path_entry[position], _repository_len + 1, &quot;%s&quot;, _repo);</span>
<span class="line-removed">-     position += jio_snprintf(&amp;file_path_entry[position], file_separator_length + 1, &quot;%s&quot;, os::file_separator());</span>
<span class="line-removed">-     position += jio_snprintf(&amp;file_path_entry[position], entry_len + 1, &quot;%s&quot;, entry);</span>
<span class="line-removed">-     file_path_entry[position] = &#39;\0&#39;;</span>
<span class="line-removed">-     assert((size_t)position == file_path_entry_length, &quot;invariant&quot;);</span>
<span class="line-removed">-     assert(strlen(file_path_entry) == (size_t)position, &quot;invariant&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return file_path_entry;</span>
  }
  
<span class="line-modified">! const char* const RepositoryIterator::filter(const char* entry) const {</span>
<span class="line-modified">!   if (entry == NULL) {</span>
      return NULL;
    }
<span class="line-modified">!   const size_t entry_len = strlen(entry);</span>
<span class="line-modified">!   if (entry_len &lt;= 2) {</span>
<span class="line-modified">!     // for &quot;.&quot; and &quot;..&quot;</span>
      return NULL;
    }
<span class="line-modified">!   char* entry_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, entry_len + 1);</span>
<span class="line-modified">!   if (entry_name == NULL) {</span>
      return NULL;
    }
<span class="line-modified">!   strncpy(entry_name, entry, entry_len + 1);</span>
<span class="line-modified">!   const char* const fully_qualified_path_entry = fully_qualified(entry_name);</span>
<span class="line-removed">-   if (NULL == fully_qualified_path_entry) {</span>
      return NULL;
    }
<span class="line-modified">!   const fio_fd entry_fd = open_exclusivly(fully_qualified_path_entry);</span>
<span class="line-modified">!   if (invalid_fd == entry_fd) {</span>
      return NULL;
    }
<span class="line-modified">!   const int64_t entry_size = file_size(entry_fd);</span>
<span class="line-modified">!   os::close(entry_fd);</span>
<span class="line-modified">!   if (0 == entry_size) {</span>
      return NULL;
    }
<span class="line-modified">!   return entry_name;</span>
  }
  
<span class="line-modified">! RepositoryIterator::RepositoryIterator(const char* repository, size_t repository_len) :</span>
<span class="line-modified">!   _repo(repository),</span>
<span class="line-modified">!   _repository_len(repository_len),</span>
<span class="line-removed">-   _files(NULL),</span>
    _iterator(0) {
<span class="line-modified">!   if (NULL != _repo) {</span>
<span class="line-removed">-     assert(strlen(_repo) == _repository_len, &quot;invariant&quot;);</span>
<span class="line-removed">-     _files = new GrowableArray&lt;const char*&gt;(10);</span>
<span class="line-removed">-     DIR* dirp = os::opendir(_repo);</span>
      if (dirp == NULL) {
<span class="line-modified">!       log_error(jfr, system)(&quot;Unable to open repository %s&quot;, _repo);</span>
        return;
      }
      struct dirent* dentry;
      while ((dentry = os::readdir(dirp)) != NULL) {
<span class="line-modified">!       const char* const entry_path = filter(dentry-&gt;d_name);</span>
<span class="line-modified">!       if (NULL != entry_path) {</span>
<span class="line-modified">!         _files-&gt;append(entry_path);</span>
        }
      }
      os::closedir(dirp);
<span class="line-modified">!     if (_files-&gt;length() &gt; 1) {</span>
<span class="line-modified">!       _files-&gt;sort(file_sort);</span>
      }
    }
  }
  
  bool RepositoryIterator::has_next() const {
<span class="line-modified">!   return (_files != NULL &amp;&amp; _iterator &lt; _files-&gt;length());</span>
  }
  
<span class="line-modified">! const char* const RepositoryIterator::next() const {</span>
<span class="line-modified">!   return _iterator &gt;= _files-&gt;length() ? NULL : fully_qualified(_files-&gt;at(_iterator++));</span>
  }
  
<span class="line-modified">! static void write_emergency_file(fio_fd emergency_fd, const RepositoryIterator&amp; iterator) {</span>
<span class="line-modified">!   assert(emergency_fd != invalid_fd, &quot;invariant&quot;);</span>
<span class="line-removed">-   const size_t size_of_file_copy_block = 1 * M; // 1 mb</span>
<span class="line-removed">-   jbyte* const file_copy_block = NEW_RESOURCE_ARRAY_RETURN_NULL(jbyte, size_of_file_copy_block);</span>
<span class="line-removed">-   if (file_copy_block == NULL) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
    while (iterator.has_next()) {
      fio_fd current_fd = invalid_fd;
      const char* const fqn = iterator.next();
<span class="line-modified">!     if (fqn != NULL) {</span>
<span class="line-modified">!       current_fd = open_exclusivly(fqn);</span>
<span class="line-modified">!       if (current_fd != invalid_fd) {</span>
<span class="line-modified">!         const int64_t current_filesize = file_size(current_fd);</span>
<span class="line-modified">!         assert(current_filesize &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">!         int64_t bytes_read = 0;</span>
<span class="line-modified">!         int64_t bytes_written = 0;</span>
<span class="line-modified">!         while (bytes_read &lt; current_filesize) {</span>
<span class="line-modified">!           const ssize_t read_result = os::read_at(current_fd, file_copy_block, size_of_file_copy_block, bytes_read);</span>
<span class="line-modified">!           if (-1 == read_result) {</span>
<span class="line-modified">!             log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
                &quot;Unable to recover JFR data&quot;);
<span class="line-modified">!             break;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           bytes_read += (int64_t)read_result;</span>
<span class="line-removed">-           assert(bytes_read - bytes_written &lt;= (int64_t)size_of_file_copy_block, &quot;invariant&quot;);</span>
<span class="line-removed">-           bytes_written += (int64_t)os::write(emergency_fd, file_copy_block, bytes_read - bytes_written);</span>
<span class="line-removed">-           assert(bytes_read == bytes_written, &quot;invariant&quot;);</span>
          }
<span class="line-modified">!         os::close(current_fd);</span>
        }
      }
    }
  }
  
<span class="line-modified">! static const char* create_emergency_dump_path() {</span>
<span class="line-modified">!   char* buffer = NEW_RESOURCE_ARRAY_RETURN_NULL(char, JVM_MAXPATHLEN);</span>
<span class="line-modified">!   if (NULL == buffer) {</span>
<span class="line-modified">!     return NULL;</span>
    }
<span class="line-modified">!   const char* const cwd = os::get_current_directory(buffer, JVM_MAXPATHLEN);</span>
<span class="line-modified">!   if (NULL == cwd) {</span>
<span class="line-modified">!     return NULL;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   size_t pos = strlen(cwd);</span>
<span class="line-modified">!   const int fsep_len = jio_snprintf(&amp;buffer[pos], JVM_MAXPATHLEN - pos, &quot;%s&quot;, os::file_separator());</span>
<span class="line-modified">!   const char* filename_fmt = NULL;</span>
<span class="line-modified">!   // fetch specific error cause</span>
<span class="line-modified">!   switch (JfrJavaSupport::cause()) {</span>
<span class="line-modified">!     case JfrJavaSupport::OUT_OF_MEMORY:</span>
<span class="line-removed">-       filename_fmt = vm_oom_filename_fmt;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case JfrJavaSupport::STACK_OVERFLOW:</span>
<span class="line-removed">-       filename_fmt = vm_soe_filename_fmt;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       filename_fmt = vm_error_filename_fmt;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   char* emergency_dump_path = NULL;</span>
<span class="line-removed">-   pos += fsep_len;</span>
<span class="line-removed">-   if (Arguments::copy_expand_pid(filename_fmt, strlen(filename_fmt), &amp;buffer[pos], JVM_MAXPATHLEN - pos)) {</span>
<span class="line-removed">-     const size_t emergency_filename_length = strlen(buffer);</span>
<span class="line-removed">-     emergency_dump_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, emergency_filename_length + 1);</span>
<span class="line-removed">-     if (NULL == emergency_dump_path) {</span>
<span class="line-removed">-       return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     strncpy(emergency_dump_path, buffer, emergency_filename_length + 1);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (emergency_dump_path != NULL) {</span>
<span class="line-removed">-     log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
<span class="line-removed">-       &quot;Attempting to recover JFR data, emergency jfr file: %s&quot;, emergency_dump_path);</span>
    }
<span class="line-removed">-   return emergency_dump_path;</span>
  }
  
<span class="line-removed">- // Caller needs ResourceMark</span>
  static const char* create_emergency_chunk_path(const char* repository_path) {
<span class="line-removed">-   assert(repository_path != NULL, &quot;invariant&quot;);</span>
    const size_t repository_path_len = strlen(repository_path);
<span class="line-removed">-   // date time</span>
    char date_time_buffer[32] = { 0 };
    date_time(date_time_buffer, sizeof(date_time_buffer));
<span class="line-removed">-   size_t date_time_len = strlen(date_time_buffer);</span>
<span class="line-removed">-   size_t chunkname_max_len = repository_path_len          // repository_base_path</span>
<span class="line-removed">-                              + 1                          // &quot;/&quot;</span>
<span class="line-removed">-                              + date_time_len              // date_time</span>
<span class="line-removed">-                              + strlen(chunk_file_jfr_ext) // .jfr</span>
<span class="line-removed">-                              + 1;</span>
<span class="line-removed">-   char* chunk_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, chunkname_max_len);</span>
<span class="line-removed">-   if (chunk_path == NULL) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
    // append the individual substrings
<span class="line-modified">!   jio_snprintf(chunk_path, chunkname_max_len, &quot;%s%s%s%s&quot;, repository_path, os::file_separator(), date_time_buffer, chunk_file_jfr_ext);</span>
<span class="line-modified">!   return chunk_path;</span>
  }
  
<span class="line-modified">! static fio_fd emergency_dump_file_descriptor() {</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   const char* const emergency_dump_path = create_emergency_dump_path();</span>
<span class="line-modified">!   return emergency_dump_path != NULL ? open_exclusivly(emergency_dump_path) : invalid_fd;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! const char* JfrEmergencyDump::build_dump_path(const char* repository_path) {</span>
<span class="line-modified">!   return repository_path == NULL ? create_emergency_dump_path() : create_emergency_chunk_path(repository_path);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-removed">- void JfrEmergencyDump::on_vm_error(const char* repository_path) {</span>
<span class="line-removed">-   assert(repository_path != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   const fio_fd emergency_fd = emergency_dump_file_descriptor();</span>
<span class="line-removed">-   if (emergency_fd != invalid_fd) {</span>
<span class="line-removed">-     RepositoryIterator iterator(repository_path, strlen(repository_path));</span>
<span class="line-removed">-     write_emergency_file(emergency_fd, iterator);</span>
<span class="line-removed">-     os::close(emergency_fd);</span>
    }
  }
  
  /*
  * We are just about to exit the VM, so we will be very aggressive
  * at this point in order to increase overall success of dumping jfr data.
<span class="line-new-header">--- 216,200 ---</span>
    return size;
  }
  
  class RepositoryIterator : public StackObj {
   private:
<span class="line-modified">!   GrowableArray&lt;const char*&gt;* _file_names;</span>
<span class="line-modified">!   int _path_buffer_file_name_offset;</span>
    mutable int _iterator;
<span class="line-modified">!   const char* fully_qualified(const char* file_name) const;</span>
<span class="line-added">+   const char* filter(const char* file_name) const;</span>
   public:
<span class="line-modified">!   RepositoryIterator(const char* repository_path);</span>
<span class="line-modified">!   ~RepositoryIterator();</span>
    bool has_next() const;
<span class="line-modified">!   const char* next() const;</span>
  };
  
<span class="line-modified">! // append the file_name at the _path_buffer_file_name_offset position</span>
<span class="line-modified">! const char* RepositoryIterator::fully_qualified(const char* file_name) const {</span>
<span class="line-modified">!   assert(NULL != file_name, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!is_path_empty(), &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(_path_buffer_file_name_offset != 0, &quot;invariant&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   const int result = jio_snprintf(_path_buffer + _path_buffer_file_name_offset,</span>
<span class="line-modified">!                                   sizeof(_path_buffer) - _path_buffer_file_name_offset,</span>
<span class="line-modified">!                                   &quot;%s&quot;,</span>
<span class="line-modified">!                                   file_name);</span>
<span class="line-modified">!   return result != -1 ? _path_buffer : NULL;</span>
  }
  
<span class="line-modified">! // caller responsible for deallocation</span>
<span class="line-modified">! const char* RepositoryIterator::filter(const char* file_name) const {</span>
<span class="line-added">+   if (file_name == NULL) {</span>
      return NULL;
    }
<span class="line-modified">!   const size_t len = strlen(file_name);</span>
<span class="line-modified">!   if ((len &lt; chunk_file_extension_length) ||</span>
<span class="line-modified">!       (strncmp(&amp;file_name[len - chunk_file_extension_length],</span>
<span class="line-added">+                chunk_file_jfr_ext,</span>
<span class="line-added">+                chunk_file_extension_length) != 0)) {</span>
<span class="line-added">+     // not a .jfr file</span>
      return NULL;
    }
<span class="line-modified">!   const char* fqn = fully_qualified(file_name);</span>
<span class="line-modified">!   if (fqn == NULL) {</span>
      return NULL;
    }
<span class="line-modified">!   const fio_fd fd = open_exclusivly(fqn);</span>
<span class="line-modified">!   if (invalid_fd == fd) {</span>
      return NULL;
    }
<span class="line-modified">!   const int64_t size = file_size(fd);</span>
<span class="line-modified">!   os::close(fd);</span>
<span class="line-added">+   if (size &lt;= chunk_file_header_size) {</span>
      return NULL;
    }
<span class="line-modified">!   char* const file_name_copy = (char*)os::malloc(len + 1, mtTracing);</span>
<span class="line-modified">!   if (file_name_copy == NULL) {</span>
<span class="line-modified">!     log_error(jfr, system)(&quot;Unable to malloc memory during jfr emergency dump&quot;);</span>
      return NULL;
    }
<span class="line-modified">!   strncpy(file_name_copy, file_name, len + 1);</span>
<span class="line-added">+   return file_name_copy;</span>
  }
  
<span class="line-modified">! RepositoryIterator::RepositoryIterator(const char* repository_path) :</span>
<span class="line-modified">!   _file_names(NULL),</span>
<span class="line-modified">!   _path_buffer_file_name_offset(0),</span>
    _iterator(0) {
<span class="line-modified">!     DIR* dirp = os::opendir(repository_path);</span>
      if (dirp == NULL) {
<span class="line-modified">!       log_error(jfr, system)(&quot;Unable to open repository %s&quot;, repository_path);</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // store repository path in the path buffer and save that position</span>
<span class="line-added">+     _path_buffer_file_name_offset = jio_snprintf(_path_buffer,</span>
<span class="line-added">+                                                  sizeof(_path_buffer),</span>
<span class="line-added">+                                                  &quot;%s%s&quot;,</span>
<span class="line-added">+                                                  repository_path,</span>
<span class="line-added">+                                                  os::file_separator());</span>
<span class="line-added">+     if (_path_buffer_file_name_offset == -1) {</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     _file_names = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;const char*&gt;(10, true, mtTracing);</span>
<span class="line-added">+     if (_file_names == NULL) {</span>
<span class="line-added">+       log_error(jfr, system)(&quot;Unable to malloc memory during jfr emergency dump&quot;);</span>
        return;
      }
<span class="line-added">+     // iterate files in the repository and append filtered file names to the files array</span>
      struct dirent* dentry;
      while ((dentry = os::readdir(dirp)) != NULL) {
<span class="line-modified">!       const char* file_name = filter(dentry-&gt;d_name);</span>
<span class="line-modified">!       if (file_name != NULL) {</span>
<span class="line-modified">!         _file_names-&gt;append(file_name);</span>
        }
      }
      os::closedir(dirp);
<span class="line-modified">!     if (_file_names-&gt;length() &gt; 1) {</span>
<span class="line-modified">!       _file_names-&gt;sort(file_sort);</span>
      }
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RepositoryIterator::~RepositoryIterator() {</span>
<span class="line-added">+   if (_file_names != NULL) {</span>
<span class="line-added">+     for (int i = 0; i &lt; _file_names-&gt;length(); ++i) {</span>
<span class="line-added">+       os::free(const_cast&lt;char*&gt;(_file_names-&gt;at(i)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     delete _file_names;</span>
    }
  }
  
  bool RepositoryIterator::has_next() const {
<span class="line-modified">!   return _file_names != NULL &amp;&amp; _iterator &lt; _file_names-&gt;length();</span>
  }
  
<span class="line-modified">! const char* RepositoryIterator::next() const {</span>
<span class="line-modified">!   return _iterator &gt;= _file_names-&gt;length() ? NULL : fully_qualified(_file_names-&gt;at(_iterator++));</span>
  }
  
<span class="line-modified">! static void write_repository_files(const RepositoryIterator&amp; iterator, char* const copy_block, size_t block_size) {</span>
<span class="line-modified">!   assert(is_emergency_dump_file_open(), &quot;invariant&quot;);</span>
    while (iterator.has_next()) {
      fio_fd current_fd = invalid_fd;
      const char* const fqn = iterator.next();
<span class="line-modified">!     assert(fqn != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     current_fd = open_exclusivly(fqn);</span>
<span class="line-modified">!     if (current_fd != invalid_fd) {</span>
<span class="line-modified">!       const int64_t size = file_size(current_fd);</span>
<span class="line-modified">!       assert(size &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">!       int64_t bytes_read = 0;</span>
<span class="line-modified">!       int64_t bytes_written = 0;</span>
<span class="line-modified">!       while (bytes_read &lt; size) {</span>
<span class="line-modified">!         const ssize_t read_result = os::read_at(current_fd, copy_block, (int)block_size, bytes_read);</span>
<span class="line-modified">!         if (-1 == read_result) {</span>
<span class="line-modified">!           log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
                &quot;Unable to recover JFR data&quot;);
<span class="line-modified">!           break;</span>
          }
<span class="line-modified">!         bytes_read += (int64_t)read_result;</span>
<span class="line-added">+         assert(bytes_read - bytes_written &lt;= (int64_t)block_size, &quot;invariant&quot;);</span>
<span class="line-added">+         bytes_written += (int64_t)os::write(emergency_fd, copy_block, bytes_read - bytes_written);</span>
<span class="line-added">+         assert(bytes_read == bytes_written, &quot;invariant&quot;);</span>
        }
<span class="line-added">+       os::close(current_fd);</span>
      }
    }
  }
  
<span class="line-modified">! static void write_emergency_dump_file(const RepositoryIterator&amp; iterator) {</span>
<span class="line-modified">!   static const size_t block_size = 1 * M; // 1 mb</span>
<span class="line-modified">!   char* const copy_block = (char*)os::malloc(block_size, mtTracing);</span>
<span class="line-modified">!   if (copy_block == NULL) {</span>
<span class="line-added">+     log_error(jfr, system)(&quot;Unable to malloc memory during jfr emergency dump&quot;);</span>
<span class="line-added">+     log_error(jfr, system)(&quot;Unable to write jfr emergency dump file&quot;);</span>
    }
<span class="line-modified">!   write_repository_files(iterator, copy_block, block_size);</span>
<span class="line-modified">!   os::free(copy_block);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void JfrEmergencyDump::on_vm_error(const char* repository_path) {</span>
<span class="line-modified">!   assert(repository_path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (open_emergency_dump_file()) {</span>
<span class="line-modified">!     RepositoryIterator iterator(repository_path);</span>
<span class="line-modified">!     write_emergency_dump_file(iterator);</span>
<span class="line-modified">!     close_emergency_dump_file();</span>
    }
  }
  
  static const char* create_emergency_chunk_path(const char* repository_path) {
    const size_t repository_path_len = strlen(repository_path);
    char date_time_buffer[32] = { 0 };
    date_time(date_time_buffer, sizeof(date_time_buffer));
    // append the individual substrings
<span class="line-modified">!   const int result = jio_snprintf(_path_buffer,</span>
<span class="line-modified">!                                   JVM_MAXPATHLEN,</span>
<span class="line-added">+                                   &quot;%s%s%s%s&quot;,</span>
<span class="line-added">+                                   repository_path,</span>
<span class="line-added">+                                   os::file_separator(),</span>
<span class="line-added">+                                   date_time_buffer,</span>
<span class="line-added">+                                   chunk_file_jfr_ext);</span>
<span class="line-added">+   return result == -1 ? NULL : _path_buffer;</span>
  }
  
<span class="line-modified">! const char* JfrEmergencyDump::chunk_path(const char* repository_path) {</span>
<span class="line-modified">!   if (repository_path == NULL) {</span>
<span class="line-modified">!     if (!open_emergency_dump_file()) {</span>
<span class="line-modified">!       return NULL;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     // We can directly use the emergency dump file name as the chunk.</span>
<span class="line-modified">!     // The chunk writer will open its own fd so we close this descriptor.</span>
<span class="line-modified">!     close_emergency_dump_file();</span>
<span class="line-modified">!     assert(!is_path_empty(), &quot;invariant&quot;);</span>
<span class="line-modified">!     return _path_buffer;</span>
    }
<span class="line-added">+   return create_emergency_chunk_path(repository_path);</span>
  }
  
  /*
  * We are just about to exit the VM, so we will be very aggressive
  * at this point in order to increase overall success of dumping jfr data.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 441,34 ***</span>
      }
    }
  
  };
  
  void JfrEmergencyDump::on_vm_shutdown(bool exception_handler) {
    if (!guard_reentrancy()) {
      return;
    }
<span class="line-removed">- </span>
    Thread* thread = Thread::current_or_null_safe();
    if (thread == NULL) {
      return;
    }
    // Ensure a JavaThread is _thread_in_vm when we make this call
    JavaThreadInVM jtivm(thread);
    if (!prepare_for_emergency_dump(thread)) {
      return;
    }
<span class="line-modified">! </span>
<span class="line-removed">-   EventDumpReason event;</span>
<span class="line-removed">-   if (event.should_commit()) {</span>
<span class="line-removed">-     event.set_reason(exception_handler ? &quot;Crash&quot; : &quot;Out of Memory&quot;);</span>
<span class="line-removed">-     event.set_recordingId(-1);</span>
<span class="line-removed">-     event.commit();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (!exception_handler) {</span>
<span class="line-removed">-     // OOM</span>
<span class="line-removed">-     LeakProfiler::emit_events(max_jlong, false);</span>
<span class="line-removed">-   }</span>
    const int messages = MSGBIT(MSG_VM_ERROR);
    JfrRecorderService service;
    service.rotate(messages);
  }
<span class="line-new-header">--- 521,38 ---</span>
      }
    }
  
  };
  
<span class="line-added">+ static void post_events(bool exception_handler) {</span>
<span class="line-added">+   if (exception_handler) {</span>
<span class="line-added">+     EventShutdown e;</span>
<span class="line-added">+     e.set_reason(&quot;VM Error&quot;);</span>
<span class="line-added">+     e.commit();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // OOM</span>
<span class="line-added">+     LeakProfiler::emit_events(max_jlong, false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   EventDumpReason event;</span>
<span class="line-added">+   event.set_reason(exception_handler ? &quot;Crash&quot; : &quot;Out of Memory&quot;);</span>
<span class="line-added">+   event.set_recordingId(-1);</span>
<span class="line-added">+   event.commit();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JfrEmergencyDump::on_vm_shutdown(bool exception_handler) {
    if (!guard_reentrancy()) {
      return;
    }
    Thread* thread = Thread::current_or_null_safe();
    if (thread == NULL) {
      return;
    }
    // Ensure a JavaThread is _thread_in_vm when we make this call
    JavaThreadInVM jtivm(thread);
    if (!prepare_for_emergency_dump(thread)) {
      return;
    }
<span class="line-modified">!   post_events(exception_handler);</span>
    const int messages = MSGBIT(MSG_VM_ERROR);
    JfrRecorderService service;
    service.rotate(messages);
  }
</pre>
<center><a href="../../periodic/jfrPeriodic.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrEmergencyDump.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
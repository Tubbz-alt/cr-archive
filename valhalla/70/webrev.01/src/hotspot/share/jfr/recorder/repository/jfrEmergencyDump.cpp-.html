<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 28 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 29 #include &quot;jfr/recorder/repository/jfrEmergencyDump.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 32 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;runtime/atomic.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/globals.hpp&quot;
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 #include &quot;runtime/thread.inline.hpp&quot;
 41 #include &quot;utilities/growableArray.hpp&quot;
 42 
 43 static const char vm_error_filename_fmt[] = &quot;hs_err_pid%p.jfr&quot;;
 44 static const char vm_oom_filename_fmt[] = &quot;hs_oom_pid%p.jfr&quot;;
 45 static const char vm_soe_filename_fmt[] = &quot;hs_soe_pid%p.jfr&quot;;
 46 static const char chunk_file_jfr_ext[] = &quot;.jfr&quot;;
 47 static const size_t iso8601_len = 19; // &quot;YYYY-MM-DDTHH:MM:SS&quot;
 48 
 49 static fio_fd open_exclusivly(const char* path) {
 50   return os::open(path, O_CREAT | O_RDWR, S_IREAD | S_IWRITE);
 51 }
 52 
 53 static int file_sort(const char** const file1, const char** file2) {
 54   assert(NULL != *file1 &amp;&amp; NULL != *file2, &quot;invariant&quot;);
 55   int cmp = strncmp(*file1, *file2, iso8601_len);
 56   if (0 == cmp) {
 57     const char* const dot1 = strchr(*file1, &#39;.&#39;);
 58     assert(NULL != dot1, &quot;invariant&quot;);
 59     const char* const dot2 = strchr(*file2, &#39;.&#39;);
 60     assert(NULL != dot2, &quot;invariant&quot;);
 61     ptrdiff_t file1_len = dot1 - *file1;
 62     ptrdiff_t file2_len = dot2 - *file2;
 63     if (file1_len &lt; file2_len) {
 64       return -1;
 65     }
 66     if (file1_len &gt; file2_len) {
 67       return 1;
 68     }
 69     assert(file1_len == file2_len, &quot;invariant&quot;);
 70     cmp = strncmp(*file1, *file2, file1_len);
 71   }
 72   assert(cmp != 0, &quot;invariant&quot;);
 73   return cmp;
 74 }
 75 
 76 static void iso8601_to_date_time(char* iso8601_str) {
 77   assert(iso8601_str != NULL, &quot;invariant&quot;);
 78   assert(strlen(iso8601_str) == iso8601_len, &quot;invariant&quot;);
 79   // &quot;YYYY-MM-DDTHH:MM:SS&quot;
 80   for (size_t i = 0; i &lt; iso8601_len; ++i) {
 81     switch (iso8601_str[i]) {
 82     case &#39;T&#39;:
 83     case &#39;-&#39;:
 84     case &#39;:&#39;:
 85       iso8601_str[i] = &#39;_&#39;;
 86       break;
 87     }
 88   }
 89   // &quot;YYYY_MM_DD_HH_MM_SS&quot;
 90 }
 91 
 92 static void date_time(char* buffer, size_t buffer_len) {
 93   assert(buffer != NULL, &quot;invariant&quot;);
 94   assert(buffer_len &gt;= iso8601_len, &quot;buffer too small&quot;);
 95   os::iso8601_time(buffer, buffer_len);
 96   assert(strlen(buffer) &gt;= iso8601_len + 1, &quot;invariant&quot;);
 97   // &quot;YYYY-MM-DDTHH:MM:SS&quot;
 98   buffer[iso8601_len] = &#39;\0&#39;;
 99   iso8601_to_date_time(buffer);
100 }
101 
102 static int64_t file_size(fio_fd fd) {
103   assert(fd != invalid_fd, &quot;invariant&quot;);
104   const int64_t current_offset = os::current_file_offset(fd);
105   const int64_t size = os::lseek(fd, 0, SEEK_END);
106   os::seek_to_file_offset(fd, current_offset);
107   return size;
108 }
109 
110 class RepositoryIterator : public StackObj {
111  private:
112   const char* const _repo;
113   const size_t _repository_len;
114   GrowableArray&lt;const char*&gt;* _files;
115   const char* const fully_qualified(const char* entry) const;
116   mutable int _iterator;
117 
118  public:
119   RepositoryIterator(const char* repository, size_t repository_len);
120   ~RepositoryIterator() {}
121   const char* const filter(const char* entry) const;
122   bool has_next() const;
123   const char* const next() const;
124 };
125 
126 const char* const RepositoryIterator::fully_qualified(const char* entry) const {
127   assert(NULL != entry, &quot;invariant&quot;);
128   char* file_path_entry = NULL;
129   // only use files that have content, not placeholders
130   const char* const file_separator = os::file_separator();
131   if (NULL != file_separator) {
132     const size_t entry_len = strlen(entry);
133     const size_t file_separator_length = strlen(file_separator);
134     const size_t file_path_entry_length = _repository_len + file_separator_length + entry_len;
135     file_path_entry = NEW_RESOURCE_ARRAY_RETURN_NULL(char, file_path_entry_length + 1);
136     if (NULL == file_path_entry) {
137       return NULL;
138     }
139     int position = 0;
140     position += jio_snprintf(&amp;file_path_entry[position], _repository_len + 1, &quot;%s&quot;, _repo);
141     position += jio_snprintf(&amp;file_path_entry[position], file_separator_length + 1, &quot;%s&quot;, os::file_separator());
142     position += jio_snprintf(&amp;file_path_entry[position], entry_len + 1, &quot;%s&quot;, entry);
143     file_path_entry[position] = &#39;\0&#39;;
144     assert((size_t)position == file_path_entry_length, &quot;invariant&quot;);
145     assert(strlen(file_path_entry) == (size_t)position, &quot;invariant&quot;);
146   }
147   return file_path_entry;
148 }
149 
150 const char* const RepositoryIterator::filter(const char* entry) const {
151   if (entry == NULL) {
152     return NULL;
153   }
154   const size_t entry_len = strlen(entry);
155   if (entry_len &lt;= 2) {
156     // for &quot;.&quot; and &quot;..&quot;
157     return NULL;
158   }
159   char* entry_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, entry_len + 1);
160   if (entry_name == NULL) {
161     return NULL;
162   }
163   strncpy(entry_name, entry, entry_len + 1);
164   const char* const fully_qualified_path_entry = fully_qualified(entry_name);
165   if (NULL == fully_qualified_path_entry) {
166     return NULL;
167   }
168   const fio_fd entry_fd = open_exclusivly(fully_qualified_path_entry);
169   if (invalid_fd == entry_fd) {
170     return NULL;
171   }
172   const int64_t entry_size = file_size(entry_fd);
173   os::close(entry_fd);
174   if (0 == entry_size) {
175     return NULL;
176   }
177   return entry_name;
178 }
179 
180 RepositoryIterator::RepositoryIterator(const char* repository, size_t repository_len) :
181   _repo(repository),
182   _repository_len(repository_len),
183   _files(NULL),
184   _iterator(0) {
185   if (NULL != _repo) {
186     assert(strlen(_repo) == _repository_len, &quot;invariant&quot;);
187     _files = new GrowableArray&lt;const char*&gt;(10);
188     DIR* dirp = os::opendir(_repo);
189     if (dirp == NULL) {
190       log_error(jfr, system)(&quot;Unable to open repository %s&quot;, _repo);
191       return;
192     }
193     struct dirent* dentry;
194     while ((dentry = os::readdir(dirp)) != NULL) {
195       const char* const entry_path = filter(dentry-&gt;d_name);
196       if (NULL != entry_path) {
197         _files-&gt;append(entry_path);
198       }
199     }
200     os::closedir(dirp);
201     if (_files-&gt;length() &gt; 1) {
202       _files-&gt;sort(file_sort);
203     }
204   }
205 }
206 
207 bool RepositoryIterator::has_next() const {
208   return (_files != NULL &amp;&amp; _iterator &lt; _files-&gt;length());
209 }
210 
211 const char* const RepositoryIterator::next() const {
212   return _iterator &gt;= _files-&gt;length() ? NULL : fully_qualified(_files-&gt;at(_iterator++));
213 }
214 
215 static void write_emergency_file(fio_fd emergency_fd, const RepositoryIterator&amp; iterator) {
216   assert(emergency_fd != invalid_fd, &quot;invariant&quot;);
217   const size_t size_of_file_copy_block = 1 * M; // 1 mb
218   jbyte* const file_copy_block = NEW_RESOURCE_ARRAY_RETURN_NULL(jbyte, size_of_file_copy_block);
219   if (file_copy_block == NULL) {
220     return;
221   }
222   while (iterator.has_next()) {
223     fio_fd current_fd = invalid_fd;
224     const char* const fqn = iterator.next();
225     if (fqn != NULL) {
226       current_fd = open_exclusivly(fqn);
227       if (current_fd != invalid_fd) {
228         const int64_t current_filesize = file_size(current_fd);
229         assert(current_filesize &gt; 0, &quot;invariant&quot;);
230         int64_t bytes_read = 0;
231         int64_t bytes_written = 0;
232         while (bytes_read &lt; current_filesize) {
233           const ssize_t read_result = os::read_at(current_fd, file_copy_block, size_of_file_copy_block, bytes_read);
234           if (-1 == read_result) {
235             log_info(jfr)( // For user, should not be &quot;jfr, system&quot;
236               &quot;Unable to recover JFR data&quot;);
237             break;
238           }
239           bytes_read += (int64_t)read_result;
240           assert(bytes_read - bytes_written &lt;= (int64_t)size_of_file_copy_block, &quot;invariant&quot;);
241           bytes_written += (int64_t)os::write(emergency_fd, file_copy_block, bytes_read - bytes_written);
242           assert(bytes_read == bytes_written, &quot;invariant&quot;);
243         }
244         os::close(current_fd);
245       }
246     }
247   }
248 }
249 
250 static const char* create_emergency_dump_path() {
251   char* buffer = NEW_RESOURCE_ARRAY_RETURN_NULL(char, JVM_MAXPATHLEN);
252   if (NULL == buffer) {
253     return NULL;
254   }
255   const char* const cwd = os::get_current_directory(buffer, JVM_MAXPATHLEN);
256   if (NULL == cwd) {
257     return NULL;
258   }
259   size_t pos = strlen(cwd);
260   const int fsep_len = jio_snprintf(&amp;buffer[pos], JVM_MAXPATHLEN - pos, &quot;%s&quot;, os::file_separator());
261   const char* filename_fmt = NULL;
262   // fetch specific error cause
263   switch (JfrJavaSupport::cause()) {
264     case JfrJavaSupport::OUT_OF_MEMORY:
265       filename_fmt = vm_oom_filename_fmt;
266       break;
267     case JfrJavaSupport::STACK_OVERFLOW:
268       filename_fmt = vm_soe_filename_fmt;
269       break;
270     default:
271       filename_fmt = vm_error_filename_fmt;
272   }
273   char* emergency_dump_path = NULL;
274   pos += fsep_len;
275   if (Arguments::copy_expand_pid(filename_fmt, strlen(filename_fmt), &amp;buffer[pos], JVM_MAXPATHLEN - pos)) {
276     const size_t emergency_filename_length = strlen(buffer);
277     emergency_dump_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, emergency_filename_length + 1);
278     if (NULL == emergency_dump_path) {
279       return NULL;
280     }
281     strncpy(emergency_dump_path, buffer, emergency_filename_length + 1);
282   }
283   if (emergency_dump_path != NULL) {
284     log_info(jfr)( // For user, should not be &quot;jfr, system&quot;
285       &quot;Attempting to recover JFR data, emergency jfr file: %s&quot;, emergency_dump_path);
286   }
287   return emergency_dump_path;
288 }
289 
290 // Caller needs ResourceMark
291 static const char* create_emergency_chunk_path(const char* repository_path) {
292   assert(repository_path != NULL, &quot;invariant&quot;);
293   const size_t repository_path_len = strlen(repository_path);
294   // date time
295   char date_time_buffer[32] = { 0 };
296   date_time(date_time_buffer, sizeof(date_time_buffer));
297   size_t date_time_len = strlen(date_time_buffer);
298   size_t chunkname_max_len = repository_path_len          // repository_base_path
299                              + 1                          // &quot;/&quot;
300                              + date_time_len              // date_time
301                              + strlen(chunk_file_jfr_ext) // .jfr
302                              + 1;
303   char* chunk_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, chunkname_max_len);
304   if (chunk_path == NULL) {
305     return NULL;
306   }
307   // append the individual substrings
308   jio_snprintf(chunk_path, chunkname_max_len, &quot;%s%s%s%s&quot;, repository_path, os::file_separator(), date_time_buffer, chunk_file_jfr_ext);
309   return chunk_path;
310 }
311 
312 static fio_fd emergency_dump_file_descriptor() {
313   ResourceMark rm;
314   const char* const emergency_dump_path = create_emergency_dump_path();
315   return emergency_dump_path != NULL ? open_exclusivly(emergency_dump_path) : invalid_fd;
316 }
317 
318 const char* JfrEmergencyDump::build_dump_path(const char* repository_path) {
319   return repository_path == NULL ? create_emergency_dump_path() : create_emergency_chunk_path(repository_path);
320 }
321 
322 void JfrEmergencyDump::on_vm_error(const char* repository_path) {
323   assert(repository_path != NULL, &quot;invariant&quot;);
324   ResourceMark rm;
325   const fio_fd emergency_fd = emergency_dump_file_descriptor();
326   if (emergency_fd != invalid_fd) {
327     RepositoryIterator iterator(repository_path, strlen(repository_path));
328     write_emergency_file(emergency_fd, iterator);
329     os::close(emergency_fd);
330   }
331 }
332 
333 /*
334 * We are just about to exit the VM, so we will be very aggressive
335 * at this point in order to increase overall success of dumping jfr data.
336 *
337 * If we end up deadlocking in the attempt of dumping out jfr data,
338 * we rely on the WatcherThread task &quot;is_error_reported()&quot;,
339 * to exit the VM after a hard-coded timeout (disallow WatcherThread to emergency dump).
340 * This &quot;safety net&quot; somewhat explains the aggressiveness in this attempt.
341 *
342 */
343 static bool prepare_for_emergency_dump(Thread* thread) {
344   assert(thread != NULL, &quot;invariant&quot;);
345 
346   if (thread-&gt;is_Watcher_thread()) {
347     // need WatcherThread as a safeguard against potential deadlocks
348     return false;
349   }
350   if (JfrStream_lock-&gt;owned_by_self()) {
351     // crashed during jfr rotation, disallow recursion
352     return false;
353   }
354 
355 #ifdef ASSERT
356   Mutex* owned_lock = thread-&gt;owned_locks();
357   while (owned_lock != NULL) {
358     Mutex* next = owned_lock-&gt;next();
359     owned_lock-&gt;unlock();
360     owned_lock = next;
361   }
362 #endif // ASSERT
363 
364   if (Threads_lock-&gt;owned_by_self()) {
365     Threads_lock-&gt;unlock();
366   }
367 
368   if (Module_lock-&gt;owned_by_self()) {
369     Module_lock-&gt;unlock();
370   }
371 
372   if (ClassLoaderDataGraph_lock-&gt;owned_by_self()) {
373     ClassLoaderDataGraph_lock-&gt;unlock();
374   }
375 
376   if (Heap_lock-&gt;owned_by_self()) {
377     Heap_lock-&gt;unlock();
378   }
379 
380   if (VMOperationQueue_lock-&gt;owned_by_self()) {
381     VMOperationQueue_lock-&gt;unlock();
382   }
383 
384   if (VMOperationRequest_lock-&gt;owned_by_self()) {
385     VMOperationRequest_lock-&gt;unlock();
386   }
387 
388   if (Service_lock-&gt;owned_by_self()) {
389     Service_lock-&gt;unlock();
390   }
391 
392   if (UseNotificationThread &amp;&amp; Notification_lock-&gt;owned_by_self()) {
393     Notification_lock-&gt;unlock();
394   }
395 
396   if (CodeCache_lock-&gt;owned_by_self()) {
397     CodeCache_lock-&gt;unlock();
398   }
399 
400   if (PeriodicTask_lock-&gt;owned_by_self()) {
401     PeriodicTask_lock-&gt;unlock();
402   }
403 
404   if (JfrMsg_lock-&gt;owned_by_self()) {
405     JfrMsg_lock-&gt;unlock();
406   }
407 
408   if (JfrBuffer_lock-&gt;owned_by_self()) {
409     JfrBuffer_lock-&gt;unlock();
410   }
411 
412   if (JfrStacktrace_lock-&gt;owned_by_self()) {
413     JfrStacktrace_lock-&gt;unlock();
414   }
415   return true;
416 }
417 
418 static volatile int jfr_shutdown_lock = 0;
419 
420 static bool guard_reentrancy() {
421   return Atomic::cmpxchg(&amp;jfr_shutdown_lock, 0, 1) == 0;
422 }
423 
424 class JavaThreadInVM : public StackObj {
425  private:
426   JavaThread* const _jt;
427   JavaThreadState _original_state;
428  public:
429 
430   JavaThreadInVM(Thread* t) : _jt(t-&gt;is_Java_thread() ? (JavaThread*)t : NULL),
431                               _original_state(_thread_max_state) {
432     if ((_jt != NULL) &amp;&amp; (_jt-&gt;thread_state() != _thread_in_vm)) {
433       _original_state = _jt-&gt;thread_state();
434       _jt-&gt;set_thread_state(_thread_in_vm);
435     }
436   }
437 
438   ~JavaThreadInVM() {
439     if (_original_state != _thread_max_state) {
440       _jt-&gt;set_thread_state(_original_state);
441     }
442   }
443 
444 };
445 
446 void JfrEmergencyDump::on_vm_shutdown(bool exception_handler) {
447   if (!guard_reentrancy()) {
448     return;
449   }
450 
451   Thread* thread = Thread::current_or_null_safe();
452   if (thread == NULL) {
453     return;
454   }
455   // Ensure a JavaThread is _thread_in_vm when we make this call
456   JavaThreadInVM jtivm(thread);
457   if (!prepare_for_emergency_dump(thread)) {
458     return;
459   }
460 
461   EventDumpReason event;
462   if (event.should_commit()) {
463     event.set_reason(exception_handler ? &quot;Crash&quot; : &quot;Out of Memory&quot;);
464     event.set_recordingId(-1);
465     event.commit();
466   }
467   if (!exception_handler) {
468     // OOM
469     LeakProfiler::emit_events(max_jlong, false);
470   }
471   const int messages = MSGBIT(MSG_VM_ERROR);
472   JfrRecorderService service;
473   service.rotate(messages);
474 }
    </pre>
  </body>
</html>
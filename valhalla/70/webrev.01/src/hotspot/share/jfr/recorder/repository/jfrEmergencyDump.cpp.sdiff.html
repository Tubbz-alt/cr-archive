<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../periodic/jfrPeriodic.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrEmergencyDump.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 28 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 29 #include &quot;jfr/recorder/repository/jfrEmergencyDump.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 32 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
<span class="line-removed"> 34 #include &quot;memory/resourceArea.hpp&quot;</span>
 35 #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed"> 36 #include &quot;runtime/handles.inline.hpp&quot;</span>
 37 #include &quot;runtime/globals.hpp&quot;
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 #include &quot;runtime/thread.inline.hpp&quot;
 41 #include &quot;utilities/growableArray.hpp&quot;

 42 
 43 static const char vm_error_filename_fmt[] = &quot;hs_err_pid%p.jfr&quot;;
 44 static const char vm_oom_filename_fmt[] = &quot;hs_oom_pid%p.jfr&quot;;
 45 static const char vm_soe_filename_fmt[] = &quot;hs_soe_pid%p.jfr&quot;;
 46 static const char chunk_file_jfr_ext[] = &quot;.jfr&quot;;
 47 static const size_t iso8601_len = 19; // &quot;YYYY-MM-DDTHH:MM:SS&quot;































 48 
 49 static fio_fd open_exclusivly(const char* path) {

 50   return os::open(path, O_CREAT | O_RDWR, S_IREAD | S_IWRITE);
 51 }
 52 














































































 53 static int file_sort(const char** const file1, const char** file2) {
 54   assert(NULL != *file1 &amp;&amp; NULL != *file2, &quot;invariant&quot;);
 55   int cmp = strncmp(*file1, *file2, iso8601_len);
 56   if (0 == cmp) {
 57     const char* const dot1 = strchr(*file1, &#39;.&#39;);
 58     assert(NULL != dot1, &quot;invariant&quot;);
 59     const char* const dot2 = strchr(*file2, &#39;.&#39;);
 60     assert(NULL != dot2, &quot;invariant&quot;);
 61     ptrdiff_t file1_len = dot1 - *file1;
 62     ptrdiff_t file2_len = dot2 - *file2;
 63     if (file1_len &lt; file2_len) {
 64       return -1;
 65     }
 66     if (file1_len &gt; file2_len) {
 67       return 1;
 68     }
 69     assert(file1_len == file2_len, &quot;invariant&quot;);
 70     cmp = strncmp(*file1, *file2, file1_len);
 71   }
 72   assert(cmp != 0, &quot;invariant&quot;);
</pre>
<hr />
<pre>
 92 static void date_time(char* buffer, size_t buffer_len) {
 93   assert(buffer != NULL, &quot;invariant&quot;);
 94   assert(buffer_len &gt;= iso8601_len, &quot;buffer too small&quot;);
 95   os::iso8601_time(buffer, buffer_len);
 96   assert(strlen(buffer) &gt;= iso8601_len + 1, &quot;invariant&quot;);
 97   // &quot;YYYY-MM-DDTHH:MM:SS&quot;
 98   buffer[iso8601_len] = &#39;\0&#39;;
 99   iso8601_to_date_time(buffer);
100 }
101 
102 static int64_t file_size(fio_fd fd) {
103   assert(fd != invalid_fd, &quot;invariant&quot;);
104   const int64_t current_offset = os::current_file_offset(fd);
105   const int64_t size = os::lseek(fd, 0, SEEK_END);
106   os::seek_to_file_offset(fd, current_offset);
107   return size;
108 }
109 
110 class RepositoryIterator : public StackObj {
111  private:
<span class="line-modified">112   const char* const _repo;</span>
<span class="line-modified">113   const size_t _repository_len;</span>
<span class="line-removed">114   GrowableArray&lt;const char*&gt;* _files;</span>
<span class="line-removed">115   const char* const fully_qualified(const char* entry) const;</span>
116   mutable int _iterator;
<span class="line-modified">117 </span>

118  public:
<span class="line-modified">119   RepositoryIterator(const char* repository, size_t repository_len);</span>
<span class="line-modified">120   ~RepositoryIterator() {}</span>
<span class="line-removed">121   const char* const filter(const char* entry) const;</span>
122   bool has_next() const;
<span class="line-modified">123   const char* const next() const;</span>
124 };
125 
<span class="line-modified">126 const char* const RepositoryIterator::fully_qualified(const char* entry) const {</span>
<span class="line-modified">127   assert(NULL != entry, &quot;invariant&quot;);</span>
<span class="line-modified">128   char* file_path_entry = NULL;</span>
<span class="line-modified">129   // only use files that have content, not placeholders</span>
<span class="line-modified">130   const char* const file_separator = os::file_separator();</span>
<span class="line-modified">131   if (NULL != file_separator) {</span>
<span class="line-modified">132     const size_t entry_len = strlen(entry);</span>
<span class="line-modified">133     const size_t file_separator_length = strlen(file_separator);</span>
<span class="line-modified">134     const size_t file_path_entry_length = _repository_len + file_separator_length + entry_len;</span>
<span class="line-modified">135     file_path_entry = NEW_RESOURCE_ARRAY_RETURN_NULL(char, file_path_entry_length + 1);</span>
<span class="line-modified">136     if (NULL == file_path_entry) {</span>
<span class="line-removed">137       return NULL;</span>
<span class="line-removed">138     }</span>
<span class="line-removed">139     int position = 0;</span>
<span class="line-removed">140     position += jio_snprintf(&amp;file_path_entry[position], _repository_len + 1, &quot;%s&quot;, _repo);</span>
<span class="line-removed">141     position += jio_snprintf(&amp;file_path_entry[position], file_separator_length + 1, &quot;%s&quot;, os::file_separator());</span>
<span class="line-removed">142     position += jio_snprintf(&amp;file_path_entry[position], entry_len + 1, &quot;%s&quot;, entry);</span>
<span class="line-removed">143     file_path_entry[position] = &#39;\0&#39;;</span>
<span class="line-removed">144     assert((size_t)position == file_path_entry_length, &quot;invariant&quot;);</span>
<span class="line-removed">145     assert(strlen(file_path_entry) == (size_t)position, &quot;invariant&quot;);</span>
<span class="line-removed">146   }</span>
<span class="line-removed">147   return file_path_entry;</span>
148 }
149 
<span class="line-modified">150 const char* const RepositoryIterator::filter(const char* entry) const {</span>
<span class="line-modified">151   if (entry == NULL) {</span>

152     return NULL;
153   }
<span class="line-modified">154   const size_t entry_len = strlen(entry);</span>
<span class="line-modified">155   if (entry_len &lt;= 2) {</span>
<span class="line-modified">156     // for &quot;.&quot; and &quot;..&quot;</span>



157     return NULL;
158   }
<span class="line-modified">159   char* entry_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, entry_len + 1);</span>
<span class="line-modified">160   if (entry_name == NULL) {</span>
161     return NULL;
162   }
<span class="line-modified">163   strncpy(entry_name, entry, entry_len + 1);</span>
<span class="line-modified">164   const char* const fully_qualified_path_entry = fully_qualified(entry_name);</span>
<span class="line-removed">165   if (NULL == fully_qualified_path_entry) {</span>
166     return NULL;
167   }
<span class="line-modified">168   const fio_fd entry_fd = open_exclusivly(fully_qualified_path_entry);</span>
<span class="line-modified">169   if (invalid_fd == entry_fd) {</span>

170     return NULL;
171   }
<span class="line-modified">172   const int64_t entry_size = file_size(entry_fd);</span>
<span class="line-modified">173   os::close(entry_fd);</span>
<span class="line-modified">174   if (0 == entry_size) {</span>
175     return NULL;
176   }
<span class="line-modified">177   return entry_name;</span>

178 }
179 
<span class="line-modified">180 RepositoryIterator::RepositoryIterator(const char* repository, size_t repository_len) :</span>
<span class="line-modified">181   _repo(repository),</span>
<span class="line-modified">182   _repository_len(repository_len),</span>
<span class="line-removed">183   _files(NULL),</span>
184   _iterator(0) {
<span class="line-modified">185   if (NULL != _repo) {</span>
<span class="line-removed">186     assert(strlen(_repo) == _repository_len, &quot;invariant&quot;);</span>
<span class="line-removed">187     _files = new GrowableArray&lt;const char*&gt;(10);</span>
<span class="line-removed">188     DIR* dirp = os::opendir(_repo);</span>
189     if (dirp == NULL) {
<span class="line-modified">190       log_error(jfr, system)(&quot;Unable to open repository %s&quot;, _repo);</span>














191       return;
192     }

193     struct dirent* dentry;
194     while ((dentry = os::readdir(dirp)) != NULL) {
<span class="line-modified">195       const char* const entry_path = filter(dentry-&gt;d_name);</span>
<span class="line-modified">196       if (NULL != entry_path) {</span>
<span class="line-modified">197         _files-&gt;append(entry_path);</span>
198       }
199     }
200     os::closedir(dirp);
<span class="line-modified">201     if (_files-&gt;length() &gt; 1) {</span>
<span class="line-modified">202       _files-&gt;sort(file_sort);</span>
203     }








204   }
205 }
206 
207 bool RepositoryIterator::has_next() const {
<span class="line-modified">208   return (_files != NULL &amp;&amp; _iterator &lt; _files-&gt;length());</span>
209 }
210 
<span class="line-modified">211 const char* const RepositoryIterator::next() const {</span>
<span class="line-modified">212   return _iterator &gt;= _files-&gt;length() ? NULL : fully_qualified(_files-&gt;at(_iterator++));</span>
213 }
214 
<span class="line-modified">215 static void write_emergency_file(fio_fd emergency_fd, const RepositoryIterator&amp; iterator) {</span>
<span class="line-modified">216   assert(emergency_fd != invalid_fd, &quot;invariant&quot;);</span>
<span class="line-removed">217   const size_t size_of_file_copy_block = 1 * M; // 1 mb</span>
<span class="line-removed">218   jbyte* const file_copy_block = NEW_RESOURCE_ARRAY_RETURN_NULL(jbyte, size_of_file_copy_block);</span>
<span class="line-removed">219   if (file_copy_block == NULL) {</span>
<span class="line-removed">220     return;</span>
<span class="line-removed">221   }</span>
222   while (iterator.has_next()) {
223     fio_fd current_fd = invalid_fd;
224     const char* const fqn = iterator.next();
<span class="line-modified">225     if (fqn != NULL) {</span>
<span class="line-modified">226       current_fd = open_exclusivly(fqn);</span>
<span class="line-modified">227       if (current_fd != invalid_fd) {</span>
<span class="line-modified">228         const int64_t current_filesize = file_size(current_fd);</span>
<span class="line-modified">229         assert(current_filesize &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">230         int64_t bytes_read = 0;</span>
<span class="line-modified">231         int64_t bytes_written = 0;</span>
<span class="line-modified">232         while (bytes_read &lt; current_filesize) {</span>
<span class="line-modified">233           const ssize_t read_result = os::read_at(current_fd, file_copy_block, size_of_file_copy_block, bytes_read);</span>
<span class="line-modified">234           if (-1 == read_result) {</span>
<span class="line-modified">235             log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
236               &quot;Unable to recover JFR data&quot;);
<span class="line-modified">237             break;</span>
<span class="line-removed">238           }</span>
<span class="line-removed">239           bytes_read += (int64_t)read_result;</span>
<span class="line-removed">240           assert(bytes_read - bytes_written &lt;= (int64_t)size_of_file_copy_block, &quot;invariant&quot;);</span>
<span class="line-removed">241           bytes_written += (int64_t)os::write(emergency_fd, file_copy_block, bytes_read - bytes_written);</span>
<span class="line-removed">242           assert(bytes_read == bytes_written, &quot;invariant&quot;);</span>
243         }
<span class="line-modified">244         os::close(current_fd);</span>



245       }

246     }
247   }
248 }
249 
<span class="line-modified">250 static const char* create_emergency_dump_path() {</span>
<span class="line-modified">251   char* buffer = NEW_RESOURCE_ARRAY_RETURN_NULL(char, JVM_MAXPATHLEN);</span>
<span class="line-modified">252   if (NULL == buffer) {</span>
<span class="line-modified">253     return NULL;</span>


254   }
<span class="line-modified">255   const char* const cwd = os::get_current_directory(buffer, JVM_MAXPATHLEN);</span>
<span class="line-modified">256   if (NULL == cwd) {</span>
<span class="line-modified">257     return NULL;</span>
<span class="line-modified">258   }</span>
<span class="line-modified">259   size_t pos = strlen(cwd);</span>
<span class="line-modified">260   const int fsep_len = jio_snprintf(&amp;buffer[pos], JVM_MAXPATHLEN - pos, &quot;%s&quot;, os::file_separator());</span>
<span class="line-modified">261   const char* filename_fmt = NULL;</span>
<span class="line-modified">262   // fetch specific error cause</span>
<span class="line-modified">263   switch (JfrJavaSupport::cause()) {</span>
<span class="line-modified">264     case JfrJavaSupport::OUT_OF_MEMORY:</span>
<span class="line-removed">265       filename_fmt = vm_oom_filename_fmt;</span>
<span class="line-removed">266       break;</span>
<span class="line-removed">267     case JfrJavaSupport::STACK_OVERFLOW:</span>
<span class="line-removed">268       filename_fmt = vm_soe_filename_fmt;</span>
<span class="line-removed">269       break;</span>
<span class="line-removed">270     default:</span>
<span class="line-removed">271       filename_fmt = vm_error_filename_fmt;</span>
<span class="line-removed">272   }</span>
<span class="line-removed">273   char* emergency_dump_path = NULL;</span>
<span class="line-removed">274   pos += fsep_len;</span>
<span class="line-removed">275   if (Arguments::copy_expand_pid(filename_fmt, strlen(filename_fmt), &amp;buffer[pos], JVM_MAXPATHLEN - pos)) {</span>
<span class="line-removed">276     const size_t emergency_filename_length = strlen(buffer);</span>
<span class="line-removed">277     emergency_dump_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, emergency_filename_length + 1);</span>
<span class="line-removed">278     if (NULL == emergency_dump_path) {</span>
<span class="line-removed">279       return NULL;</span>
<span class="line-removed">280     }</span>
<span class="line-removed">281     strncpy(emergency_dump_path, buffer, emergency_filename_length + 1);</span>
<span class="line-removed">282   }</span>
<span class="line-removed">283   if (emergency_dump_path != NULL) {</span>
<span class="line-removed">284     log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
<span class="line-removed">285       &quot;Attempting to recover JFR data, emergency jfr file: %s&quot;, emergency_dump_path);</span>
286   }
<span class="line-removed">287   return emergency_dump_path;</span>
288 }
289 
<span class="line-removed">290 // Caller needs ResourceMark</span>
291 static const char* create_emergency_chunk_path(const char* repository_path) {
<span class="line-removed">292   assert(repository_path != NULL, &quot;invariant&quot;);</span>
293   const size_t repository_path_len = strlen(repository_path);
<span class="line-removed">294   // date time</span>
295   char date_time_buffer[32] = { 0 };
296   date_time(date_time_buffer, sizeof(date_time_buffer));
<span class="line-removed">297   size_t date_time_len = strlen(date_time_buffer);</span>
<span class="line-removed">298   size_t chunkname_max_len = repository_path_len          // repository_base_path</span>
<span class="line-removed">299                              + 1                          // &quot;/&quot;</span>
<span class="line-removed">300                              + date_time_len              // date_time</span>
<span class="line-removed">301                              + strlen(chunk_file_jfr_ext) // .jfr</span>
<span class="line-removed">302                              + 1;</span>
<span class="line-removed">303   char* chunk_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, chunkname_max_len);</span>
<span class="line-removed">304   if (chunk_path == NULL) {</span>
<span class="line-removed">305     return NULL;</span>
<span class="line-removed">306   }</span>
307   // append the individual substrings
<span class="line-modified">308   jio_snprintf(chunk_path, chunkname_max_len, &quot;%s%s%s%s&quot;, repository_path, os::file_separator(), date_time_buffer, chunk_file_jfr_ext);</span>
<span class="line-modified">309   return chunk_path;</span>






310 }
311 
<span class="line-modified">312 static fio_fd emergency_dump_file_descriptor() {</span>
<span class="line-modified">313   ResourceMark rm;</span>
<span class="line-modified">314   const char* const emergency_dump_path = create_emergency_dump_path();</span>
<span class="line-modified">315   return emergency_dump_path != NULL ? open_exclusivly(emergency_dump_path) : invalid_fd;</span>
<span class="line-modified">316 }</span>
<span class="line-modified">317 </span>
<span class="line-modified">318 const char* JfrEmergencyDump::build_dump_path(const char* repository_path) {</span>
<span class="line-modified">319   return repository_path == NULL ? create_emergency_dump_path() : create_emergency_chunk_path(repository_path);</span>
<span class="line-modified">320 }</span>
<span class="line-modified">321 </span>
<span class="line-removed">322 void JfrEmergencyDump::on_vm_error(const char* repository_path) {</span>
<span class="line-removed">323   assert(repository_path != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">324   ResourceMark rm;</span>
<span class="line-removed">325   const fio_fd emergency_fd = emergency_dump_file_descriptor();</span>
<span class="line-removed">326   if (emergency_fd != invalid_fd) {</span>
<span class="line-removed">327     RepositoryIterator iterator(repository_path, strlen(repository_path));</span>
<span class="line-removed">328     write_emergency_file(emergency_fd, iterator);</span>
<span class="line-removed">329     os::close(emergency_fd);</span>
330   }

331 }
332 
333 /*
334 * We are just about to exit the VM, so we will be very aggressive
335 * at this point in order to increase overall success of dumping jfr data.
336 *
337 * If we end up deadlocking in the attempt of dumping out jfr data,
338 * we rely on the WatcherThread task &quot;is_error_reported()&quot;,
339 * to exit the VM after a hard-coded timeout (disallow WatcherThread to emergency dump).
340 * This &quot;safety net&quot; somewhat explains the aggressiveness in this attempt.
341 *
342 */
343 static bool prepare_for_emergency_dump(Thread* thread) {
344   assert(thread != NULL, &quot;invariant&quot;);
345 
346   if (thread-&gt;is_Watcher_thread()) {
347     // need WatcherThread as a safeguard against potential deadlocks
348     return false;
349   }
350   if (JfrStream_lock-&gt;owned_by_self()) {
</pre>
<hr />
<pre>
426   JavaThread* const _jt;
427   JavaThreadState _original_state;
428  public:
429 
430   JavaThreadInVM(Thread* t) : _jt(t-&gt;is_Java_thread() ? (JavaThread*)t : NULL),
431                               _original_state(_thread_max_state) {
432     if ((_jt != NULL) &amp;&amp; (_jt-&gt;thread_state() != _thread_in_vm)) {
433       _original_state = _jt-&gt;thread_state();
434       _jt-&gt;set_thread_state(_thread_in_vm);
435     }
436   }
437 
438   ~JavaThreadInVM() {
439     if (_original_state != _thread_max_state) {
440       _jt-&gt;set_thread_state(_original_state);
441     }
442   }
443 
444 };
445 















446 void JfrEmergencyDump::on_vm_shutdown(bool exception_handler) {
447   if (!guard_reentrancy()) {
448     return;
449   }
<span class="line-removed">450 </span>
451   Thread* thread = Thread::current_or_null_safe();
452   if (thread == NULL) {
453     return;
454   }
455   // Ensure a JavaThread is _thread_in_vm when we make this call
456   JavaThreadInVM jtivm(thread);
457   if (!prepare_for_emergency_dump(thread)) {
458     return;
459   }
<span class="line-modified">460 </span>
<span class="line-removed">461   EventDumpReason event;</span>
<span class="line-removed">462   if (event.should_commit()) {</span>
<span class="line-removed">463     event.set_reason(exception_handler ? &quot;Crash&quot; : &quot;Out of Memory&quot;);</span>
<span class="line-removed">464     event.set_recordingId(-1);</span>
<span class="line-removed">465     event.commit();</span>
<span class="line-removed">466   }</span>
<span class="line-removed">467   if (!exception_handler) {</span>
<span class="line-removed">468     // OOM</span>
<span class="line-removed">469     LeakProfiler::emit_events(max_jlong, false);</span>
<span class="line-removed">470   }</span>
471   const int messages = MSGBIT(MSG_VM_ERROR);
472   JfrRecorderService service;
473   service.rotate(messages);
474 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 28 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 29 #include &quot;jfr/recorder/repository/jfrEmergencyDump.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 32 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;

 34 #include &quot;runtime/atomic.hpp&quot;

 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/mutexLocker.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/thread.inline.hpp&quot;
 39 #include &quot;utilities/growableArray.hpp&quot;
<span class="line-added"> 40 #include &quot;utilities/ostream.hpp&quot;</span>
 41 
 42 static const char vm_error_filename_fmt[] = &quot;hs_err_pid%p.jfr&quot;;
 43 static const char vm_oom_filename_fmt[] = &quot;hs_oom_pid%p.jfr&quot;;
 44 static const char vm_soe_filename_fmt[] = &quot;hs_soe_pid%p.jfr&quot;;
 45 static const char chunk_file_jfr_ext[] = &quot;.jfr&quot;;
 46 static const size_t iso8601_len = 19; // &quot;YYYY-MM-DDTHH:MM:SS&quot;
<span class="line-added"> 47 static fio_fd emergency_fd = invalid_fd;</span>
<span class="line-added"> 48 static const int64_t chunk_file_header_size = 68;</span>
<span class="line-added"> 49 static const size_t chunk_file_extension_length = sizeof chunk_file_jfr_ext - 1;</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 /*</span>
<span class="line-added"> 52  * The emergency dump logic is restrictive when it comes to</span>
<span class="line-added"> 53  * using internal VM constructs such as ResourceArea / Handle / Arena.</span>
<span class="line-added"> 54  * The reason being that the thread context is unknown.</span>
<span class="line-added"> 55  *</span>
<span class="line-added"> 56  * A single static buffer of size JVM_MAXPATHLEN is used for building paths.</span>
<span class="line-added"> 57  * os::malloc / os::free are used in a few places.</span>
<span class="line-added"> 58  */</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60 static char _path_buffer[JVM_MAXPATHLEN] = { 0 };</span>
<span class="line-added"> 61 </span>
<span class="line-added"> 62 static bool is_path_empty() {</span>
<span class="line-added"> 63   return *_path_buffer == &#39;\0&#39;;</span>
<span class="line-added"> 64 }</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66 // returns with an appended file separator (if successful)</span>
<span class="line-added"> 67 static size_t get_current_directory() {</span>
<span class="line-added"> 68   if (os::get_current_directory(_path_buffer, sizeof(_path_buffer)) == NULL) {</span>
<span class="line-added"> 69     return 0;</span>
<span class="line-added"> 70   }</span>
<span class="line-added"> 71   const size_t cwd_len = strlen(_path_buffer);</span>
<span class="line-added"> 72   const int result = jio_snprintf(_path_buffer + cwd_len,</span>
<span class="line-added"> 73                                   sizeof(_path_buffer),</span>
<span class="line-added"> 74                                   &quot;%s&quot;,</span>
<span class="line-added"> 75                                   os::file_separator());</span>
<span class="line-added"> 76   return (result == -1) ? 0 : strlen(_path_buffer);</span>
<span class="line-added"> 77 }</span>
 78 
 79 static fio_fd open_exclusivly(const char* path) {
<span class="line-added"> 80   assert((path != NULL) &amp;&amp; (*path != &#39;\0&#39;), &quot;invariant&quot;);</span>
 81   return os::open(path, O_CREAT | O_RDWR, S_IREAD | S_IWRITE);
 82 }
 83 
<span class="line-added"> 84 static bool is_emergency_dump_file_open() {</span>
<span class="line-added"> 85   return emergency_fd != invalid_fd;</span>
<span class="line-added"> 86 }</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88 static bool open_emergency_dump_fd(const char* path) {</span>
<span class="line-added"> 89   if (path == NULL) {</span>
<span class="line-added"> 90     return false;</span>
<span class="line-added"> 91   }</span>
<span class="line-added"> 92   assert(emergency_fd == invalid_fd, &quot;invariant&quot;);</span>
<span class="line-added"> 93   emergency_fd = open_exclusivly(path);</span>
<span class="line-added"> 94   return emergency_fd != invalid_fd;</span>
<span class="line-added"> 95 }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 static void close_emergency_dump_file() {</span>
<span class="line-added"> 98   if (is_emergency_dump_file_open()) {</span>
<span class="line-added"> 99     os::close(emergency_fd);</span>
<span class="line-added">100   }</span>
<span class="line-added">101 }</span>
<span class="line-added">102 </span>
<span class="line-added">103 static const char* create_emergency_dump_path() {</span>
<span class="line-added">104   assert(is_path_empty(), &quot;invariant&quot;);</span>
<span class="line-added">105 </span>
<span class="line-added">106   const size_t path_len = get_current_directory();</span>
<span class="line-added">107   if (path_len == 0) {</span>
<span class="line-added">108     return NULL;</span>
<span class="line-added">109   }</span>
<span class="line-added">110   const char* filename_fmt = NULL;</span>
<span class="line-added">111   // fetch specific error cause</span>
<span class="line-added">112   switch (JfrJavaSupport::cause()) {</span>
<span class="line-added">113     case JfrJavaSupport::OUT_OF_MEMORY:</span>
<span class="line-added">114       filename_fmt = vm_oom_filename_fmt;</span>
<span class="line-added">115       break;</span>
<span class="line-added">116     case JfrJavaSupport::STACK_OVERFLOW:</span>
<span class="line-added">117       filename_fmt = vm_soe_filename_fmt;</span>
<span class="line-added">118       break;</span>
<span class="line-added">119     default:</span>
<span class="line-added">120       filename_fmt = vm_error_filename_fmt;</span>
<span class="line-added">121   }</span>
<span class="line-added">122   const bool result = Arguments::copy_expand_pid(filename_fmt, strlen(filename_fmt), _path_buffer + path_len, JVM_MAXPATHLEN - path_len);</span>
<span class="line-added">123   return result ? _path_buffer : NULL;</span>
<span class="line-added">124 }</span>
<span class="line-added">125 </span>
<span class="line-added">126 static bool open_emergency_dump_file() {</span>
<span class="line-added">127   if (is_emergency_dump_file_open()) {</span>
<span class="line-added">128     // opened already</span>
<span class="line-added">129     return true;</span>
<span class="line-added">130   }</span>
<span class="line-added">131   return open_emergency_dump_fd(create_emergency_dump_path());</span>
<span class="line-added">132 }</span>
<span class="line-added">133 </span>
<span class="line-added">134 static void report(outputStream* st, bool emergency_file_opened, const char* repository_path) {</span>
<span class="line-added">135   assert(st != NULL, &quot;invariant&quot;);</span>
<span class="line-added">136   if (emergency_file_opened) {</span>
<span class="line-added">137     st-&gt;print_raw(&quot;# JFR recording file will be written. Location: &quot;);</span>
<span class="line-added">138     st-&gt;print_raw_cr(_path_buffer);</span>
<span class="line-added">139     st-&gt;print_raw_cr(&quot;#&quot;);</span>
<span class="line-added">140   } else if (repository_path != NULL) {</span>
<span class="line-added">141     st-&gt;print_raw(&quot;# The JFR repository may contain useful JFR files. Location: &quot;);</span>
<span class="line-added">142     st-&gt;print_raw_cr(repository_path);</span>
<span class="line-added">143     st-&gt;print_raw_cr(&quot;#&quot;);</span>
<span class="line-added">144   } else if (!is_path_empty()) {</span>
<span class="line-added">145     st-&gt;print_raw(&quot;# Unable to create a JFR recording file at location: &quot;);</span>
<span class="line-added">146     st-&gt;print_raw_cr(_path_buffer);</span>
<span class="line-added">147     st-&gt;print_raw_cr(&quot;#&quot;);</span>
<span class="line-added">148   }</span>
<span class="line-added">149 }</span>
<span class="line-added">150 </span>
<span class="line-added">151 void JfrEmergencyDump::on_vm_error_report(outputStream* st, const char* repository_path) {</span>
<span class="line-added">152   assert(st != NULL, &quot;invariant&quot;);</span>
<span class="line-added">153   Thread* thread = Thread::current_or_null_safe();</span>
<span class="line-added">154   if (thread != NULL) {</span>
<span class="line-added">155     report(st, open_emergency_dump_file(), repository_path);</span>
<span class="line-added">156   } else if (repository_path != NULL) {</span>
<span class="line-added">157     // a non-attached thread will not be able to write anything later</span>
<span class="line-added">158     report(st, false, repository_path);</span>
<span class="line-added">159   }</span>
<span class="line-added">160 }</span>
<span class="line-added">161 </span>
162 static int file_sort(const char** const file1, const char** file2) {
163   assert(NULL != *file1 &amp;&amp; NULL != *file2, &quot;invariant&quot;);
164   int cmp = strncmp(*file1, *file2, iso8601_len);
165   if (0 == cmp) {
166     const char* const dot1 = strchr(*file1, &#39;.&#39;);
167     assert(NULL != dot1, &quot;invariant&quot;);
168     const char* const dot2 = strchr(*file2, &#39;.&#39;);
169     assert(NULL != dot2, &quot;invariant&quot;);
170     ptrdiff_t file1_len = dot1 - *file1;
171     ptrdiff_t file2_len = dot2 - *file2;
172     if (file1_len &lt; file2_len) {
173       return -1;
174     }
175     if (file1_len &gt; file2_len) {
176       return 1;
177     }
178     assert(file1_len == file2_len, &quot;invariant&quot;);
179     cmp = strncmp(*file1, *file2, file1_len);
180   }
181   assert(cmp != 0, &quot;invariant&quot;);
</pre>
<hr />
<pre>
201 static void date_time(char* buffer, size_t buffer_len) {
202   assert(buffer != NULL, &quot;invariant&quot;);
203   assert(buffer_len &gt;= iso8601_len, &quot;buffer too small&quot;);
204   os::iso8601_time(buffer, buffer_len);
205   assert(strlen(buffer) &gt;= iso8601_len + 1, &quot;invariant&quot;);
206   // &quot;YYYY-MM-DDTHH:MM:SS&quot;
207   buffer[iso8601_len] = &#39;\0&#39;;
208   iso8601_to_date_time(buffer);
209 }
210 
211 static int64_t file_size(fio_fd fd) {
212   assert(fd != invalid_fd, &quot;invariant&quot;);
213   const int64_t current_offset = os::current_file_offset(fd);
214   const int64_t size = os::lseek(fd, 0, SEEK_END);
215   os::seek_to_file_offset(fd, current_offset);
216   return size;
217 }
218 
219 class RepositoryIterator : public StackObj {
220  private:
<span class="line-modified">221   GrowableArray&lt;const char*&gt;* _file_names;</span>
<span class="line-modified">222   int _path_buffer_file_name_offset;</span>


223   mutable int _iterator;
<span class="line-modified">224   const char* fully_qualified(const char* file_name) const;</span>
<span class="line-added">225   const char* filter(const char* file_name) const;</span>
226  public:
<span class="line-modified">227   RepositoryIterator(const char* repository_path);</span>
<span class="line-modified">228   ~RepositoryIterator();</span>

229   bool has_next() const;
<span class="line-modified">230   const char* next() const;</span>
231 };
232 
<span class="line-modified">233 // append the file_name at the _path_buffer_file_name_offset position</span>
<span class="line-modified">234 const char* RepositoryIterator::fully_qualified(const char* file_name) const {</span>
<span class="line-modified">235   assert(NULL != file_name, &quot;invariant&quot;);</span>
<span class="line-modified">236   assert(!is_path_empty(), &quot;invariant&quot;);</span>
<span class="line-modified">237   assert(_path_buffer_file_name_offset != 0, &quot;invariant&quot;);</span>
<span class="line-modified">238 </span>
<span class="line-modified">239   const int result = jio_snprintf(_path_buffer + _path_buffer_file_name_offset,</span>
<span class="line-modified">240                                   sizeof(_path_buffer) - _path_buffer_file_name_offset,</span>
<span class="line-modified">241                                   &quot;%s&quot;,</span>
<span class="line-modified">242                                   file_name);</span>
<span class="line-modified">243   return result != -1 ? _path_buffer : NULL;</span>











244 }
245 
<span class="line-modified">246 // caller responsible for deallocation</span>
<span class="line-modified">247 const char* RepositoryIterator::filter(const char* file_name) const {</span>
<span class="line-added">248   if (file_name == NULL) {</span>
249     return NULL;
250   }
<span class="line-modified">251   const size_t len = strlen(file_name);</span>
<span class="line-modified">252   if ((len &lt; chunk_file_extension_length) ||</span>
<span class="line-modified">253       (strncmp(&amp;file_name[len - chunk_file_extension_length],</span>
<span class="line-added">254                chunk_file_jfr_ext,</span>
<span class="line-added">255                chunk_file_extension_length) != 0)) {</span>
<span class="line-added">256     // not a .jfr file</span>
257     return NULL;
258   }
<span class="line-modified">259   const char* fqn = fully_qualified(file_name);</span>
<span class="line-modified">260   if (fqn == NULL) {</span>
261     return NULL;
262   }
<span class="line-modified">263   const fio_fd fd = open_exclusivly(fqn);</span>
<span class="line-modified">264   if (invalid_fd == fd) {</span>

265     return NULL;
266   }
<span class="line-modified">267   const int64_t size = file_size(fd);</span>
<span class="line-modified">268   os::close(fd);</span>
<span class="line-added">269   if (size &lt;= chunk_file_header_size) {</span>
270     return NULL;
271   }
<span class="line-modified">272   char* const file_name_copy = (char*)os::malloc(len + 1, mtTracing);</span>
<span class="line-modified">273   if (file_name_copy == NULL) {</span>
<span class="line-modified">274     log_error(jfr, system)(&quot;Unable to malloc memory during jfr emergency dump&quot;);</span>
275     return NULL;
276   }
<span class="line-modified">277   strncpy(file_name_copy, file_name, len + 1);</span>
<span class="line-added">278   return file_name_copy;</span>
279 }
280 
<span class="line-modified">281 RepositoryIterator::RepositoryIterator(const char* repository_path) :</span>
<span class="line-modified">282   _file_names(NULL),</span>
<span class="line-modified">283   _path_buffer_file_name_offset(0),</span>

284   _iterator(0) {
<span class="line-modified">285     DIR* dirp = os::opendir(repository_path);</span>



286     if (dirp == NULL) {
<span class="line-modified">287       log_error(jfr, system)(&quot;Unable to open repository %s&quot;, repository_path);</span>
<span class="line-added">288       return;</span>
<span class="line-added">289     }</span>
<span class="line-added">290     // store repository path in the path buffer and save that position</span>
<span class="line-added">291     _path_buffer_file_name_offset = jio_snprintf(_path_buffer,</span>
<span class="line-added">292                                                  sizeof(_path_buffer),</span>
<span class="line-added">293                                                  &quot;%s%s&quot;,</span>
<span class="line-added">294                                                  repository_path,</span>
<span class="line-added">295                                                  os::file_separator());</span>
<span class="line-added">296     if (_path_buffer_file_name_offset == -1) {</span>
<span class="line-added">297       return;</span>
<span class="line-added">298     }</span>
<span class="line-added">299     _file_names = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;const char*&gt;(10, true, mtTracing);</span>
<span class="line-added">300     if (_file_names == NULL) {</span>
<span class="line-added">301       log_error(jfr, system)(&quot;Unable to malloc memory during jfr emergency dump&quot;);</span>
302       return;
303     }
<span class="line-added">304     // iterate files in the repository and append filtered file names to the files array</span>
305     struct dirent* dentry;
306     while ((dentry = os::readdir(dirp)) != NULL) {
<span class="line-modified">307       const char* file_name = filter(dentry-&gt;d_name);</span>
<span class="line-modified">308       if (file_name != NULL) {</span>
<span class="line-modified">309         _file_names-&gt;append(file_name);</span>
310       }
311     }
312     os::closedir(dirp);
<span class="line-modified">313     if (_file_names-&gt;length() &gt; 1) {</span>
<span class="line-modified">314       _file_names-&gt;sort(file_sort);</span>
315     }
<span class="line-added">316 }</span>
<span class="line-added">317 </span>
<span class="line-added">318 RepositoryIterator::~RepositoryIterator() {</span>
<span class="line-added">319   if (_file_names != NULL) {</span>
<span class="line-added">320     for (int i = 0; i &lt; _file_names-&gt;length(); ++i) {</span>
<span class="line-added">321       os::free(const_cast&lt;char*&gt;(_file_names-&gt;at(i)));</span>
<span class="line-added">322     }</span>
<span class="line-added">323     delete _file_names;</span>
324   }
325 }
326 
327 bool RepositoryIterator::has_next() const {
<span class="line-modified">328   return _file_names != NULL &amp;&amp; _iterator &lt; _file_names-&gt;length();</span>
329 }
330 
<span class="line-modified">331 const char* RepositoryIterator::next() const {</span>
<span class="line-modified">332   return _iterator &gt;= _file_names-&gt;length() ? NULL : fully_qualified(_file_names-&gt;at(_iterator++));</span>
333 }
334 
<span class="line-modified">335 static void write_repository_files(const RepositoryIterator&amp; iterator, char* const copy_block, size_t block_size) {</span>
<span class="line-modified">336   assert(is_emergency_dump_file_open(), &quot;invariant&quot;);</span>





337   while (iterator.has_next()) {
338     fio_fd current_fd = invalid_fd;
339     const char* const fqn = iterator.next();
<span class="line-modified">340     assert(fqn != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">341     current_fd = open_exclusivly(fqn);</span>
<span class="line-modified">342     if (current_fd != invalid_fd) {</span>
<span class="line-modified">343       const int64_t size = file_size(current_fd);</span>
<span class="line-modified">344       assert(size &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">345       int64_t bytes_read = 0;</span>
<span class="line-modified">346       int64_t bytes_written = 0;</span>
<span class="line-modified">347       while (bytes_read &lt; size) {</span>
<span class="line-modified">348         const ssize_t read_result = os::read_at(current_fd, copy_block, (int)block_size, bytes_read);</span>
<span class="line-modified">349         if (-1 == read_result) {</span>
<span class="line-modified">350           log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
351               &quot;Unable to recover JFR data&quot;);
<span class="line-modified">352           break;</span>





353         }
<span class="line-modified">354         bytes_read += (int64_t)read_result;</span>
<span class="line-added">355         assert(bytes_read - bytes_written &lt;= (int64_t)block_size, &quot;invariant&quot;);</span>
<span class="line-added">356         bytes_written += (int64_t)os::write(emergency_fd, copy_block, bytes_read - bytes_written);</span>
<span class="line-added">357         assert(bytes_read == bytes_written, &quot;invariant&quot;);</span>
358       }
<span class="line-added">359       os::close(current_fd);</span>
360     }
361   }
362 }
363 
<span class="line-modified">364 static void write_emergency_dump_file(const RepositoryIterator&amp; iterator) {</span>
<span class="line-modified">365   static const size_t block_size = 1 * M; // 1 mb</span>
<span class="line-modified">366   char* const copy_block = (char*)os::malloc(block_size, mtTracing);</span>
<span class="line-modified">367   if (copy_block == NULL) {</span>
<span class="line-added">368     log_error(jfr, system)(&quot;Unable to malloc memory during jfr emergency dump&quot;);</span>
<span class="line-added">369     log_error(jfr, system)(&quot;Unable to write jfr emergency dump file&quot;);</span>
370   }
<span class="line-modified">371   write_repository_files(iterator, copy_block, block_size);</span>
<span class="line-modified">372   os::free(copy_block);</span>
<span class="line-modified">373 }</span>
<span class="line-modified">374 </span>
<span class="line-modified">375 void JfrEmergencyDump::on_vm_error(const char* repository_path) {</span>
<span class="line-modified">376   assert(repository_path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">377   if (open_emergency_dump_file()) {</span>
<span class="line-modified">378     RepositoryIterator iterator(repository_path);</span>
<span class="line-modified">379     write_emergency_dump_file(iterator);</span>
<span class="line-modified">380     close_emergency_dump_file();</span>





















381   }

382 }
383 

384 static const char* create_emergency_chunk_path(const char* repository_path) {

385   const size_t repository_path_len = strlen(repository_path);

386   char date_time_buffer[32] = { 0 };
387   date_time(date_time_buffer, sizeof(date_time_buffer));










388   // append the individual substrings
<span class="line-modified">389   const int result = jio_snprintf(_path_buffer,</span>
<span class="line-modified">390                                   JVM_MAXPATHLEN,</span>
<span class="line-added">391                                   &quot;%s%s%s%s&quot;,</span>
<span class="line-added">392                                   repository_path,</span>
<span class="line-added">393                                   os::file_separator(),</span>
<span class="line-added">394                                   date_time_buffer,</span>
<span class="line-added">395                                   chunk_file_jfr_ext);</span>
<span class="line-added">396   return result == -1 ? NULL : _path_buffer;</span>
397 }
398 
<span class="line-modified">399 const char* JfrEmergencyDump::chunk_path(const char* repository_path) {</span>
<span class="line-modified">400   if (repository_path == NULL) {</span>
<span class="line-modified">401     if (!open_emergency_dump_file()) {</span>
<span class="line-modified">402       return NULL;</span>
<span class="line-modified">403     }</span>
<span class="line-modified">404     // We can directly use the emergency dump file name as the chunk.</span>
<span class="line-modified">405     // The chunk writer will open its own fd so we close this descriptor.</span>
<span class="line-modified">406     close_emergency_dump_file();</span>
<span class="line-modified">407     assert(!is_path_empty(), &quot;invariant&quot;);</span>
<span class="line-modified">408     return _path_buffer;</span>








409   }
<span class="line-added">410   return create_emergency_chunk_path(repository_path);</span>
411 }
412 
413 /*
414 * We are just about to exit the VM, so we will be very aggressive
415 * at this point in order to increase overall success of dumping jfr data.
416 *
417 * If we end up deadlocking in the attempt of dumping out jfr data,
418 * we rely on the WatcherThread task &quot;is_error_reported()&quot;,
419 * to exit the VM after a hard-coded timeout (disallow WatcherThread to emergency dump).
420 * This &quot;safety net&quot; somewhat explains the aggressiveness in this attempt.
421 *
422 */
423 static bool prepare_for_emergency_dump(Thread* thread) {
424   assert(thread != NULL, &quot;invariant&quot;);
425 
426   if (thread-&gt;is_Watcher_thread()) {
427     // need WatcherThread as a safeguard against potential deadlocks
428     return false;
429   }
430   if (JfrStream_lock-&gt;owned_by_self()) {
</pre>
<hr />
<pre>
506   JavaThread* const _jt;
507   JavaThreadState _original_state;
508  public:
509 
510   JavaThreadInVM(Thread* t) : _jt(t-&gt;is_Java_thread() ? (JavaThread*)t : NULL),
511                               _original_state(_thread_max_state) {
512     if ((_jt != NULL) &amp;&amp; (_jt-&gt;thread_state() != _thread_in_vm)) {
513       _original_state = _jt-&gt;thread_state();
514       _jt-&gt;set_thread_state(_thread_in_vm);
515     }
516   }
517 
518   ~JavaThreadInVM() {
519     if (_original_state != _thread_max_state) {
520       _jt-&gt;set_thread_state(_original_state);
521     }
522   }
523 
524 };
525 
<span class="line-added">526 static void post_events(bool exception_handler) {</span>
<span class="line-added">527   if (exception_handler) {</span>
<span class="line-added">528     EventShutdown e;</span>
<span class="line-added">529     e.set_reason(&quot;VM Error&quot;);</span>
<span class="line-added">530     e.commit();</span>
<span class="line-added">531   } else {</span>
<span class="line-added">532     // OOM</span>
<span class="line-added">533     LeakProfiler::emit_events(max_jlong, false);</span>
<span class="line-added">534   }</span>
<span class="line-added">535   EventDumpReason event;</span>
<span class="line-added">536   event.set_reason(exception_handler ? &quot;Crash&quot; : &quot;Out of Memory&quot;);</span>
<span class="line-added">537   event.set_recordingId(-1);</span>
<span class="line-added">538   event.commit();</span>
<span class="line-added">539 }</span>
<span class="line-added">540 </span>
541 void JfrEmergencyDump::on_vm_shutdown(bool exception_handler) {
542   if (!guard_reentrancy()) {
543     return;
544   }

545   Thread* thread = Thread::current_or_null_safe();
546   if (thread == NULL) {
547     return;
548   }
549   // Ensure a JavaThread is _thread_in_vm when we make this call
550   JavaThreadInVM jtivm(thread);
551   if (!prepare_for_emergency_dump(thread)) {
552     return;
553   }
<span class="line-modified">554   post_events(exception_handler);</span>










555   const int messages = MSGBIT(MSG_VM_ERROR);
556   JfrRecorderService service;
557   service.rotate(messages);
558 }
</pre>
</td>
</tr>
</table>
<center><a href="../../periodic/jfrPeriodic.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrEmergencyDump.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
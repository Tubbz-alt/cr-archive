<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/solaris/os_solaris.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../posix/os_posix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows/os_perf_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/solaris/os_solaris.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 #include &lt;dlfcn.h&gt;
 33 #include &lt;sys/socket.h&gt;
 34 #include &lt;poll.h&gt;
 35 #include &lt;sys/filio.h&gt;
 36 #include &lt;unistd.h&gt;
 37 #include &lt;netdb.h&gt;
 38 #include &lt;setjmp.h&gt;
 39 
 40 inline bool os::uses_stack_guard_pages() {
 41   return true;
 42 }
 43 
 44 inline bool os::must_commit_stack_guard_pages() {
 45   assert(uses_stack_guard_pages(), &quot;sanity check&quot;);
 46   int r = thr_main() ;
 47   guarantee (r == 0 || r == 1, &quot;CR6501650 or CR6493689&quot;) ;
 48   return r;
 49 }
 50 
 51 
<span class="line-removed"> 52 // On Solaris, reservations are made on a page by page basis, nothing to do.</span>
<span class="line-removed"> 53 inline void os::pd_split_reserved_memory(char *base, size_t size,</span>
<span class="line-removed"> 54                                       size_t split, bool realloc) {</span>
<span class="line-removed"> 55 }</span>
<span class="line-removed"> 56 </span>
<span class="line-removed"> 57 </span>
 58 // Bang the shadow pages if they need to be touched to be mapped.
 59 inline void os::map_stack_shadow_pages(address sp) {
 60 }
 61 
 62 inline void os::dll_unload(void *lib) { ::dlclose(lib); }
 63 
 64 //////////////////////////////////////////////////////////////////////////////
 65 ////////////////////////////////////////////////////////////////////////////////
 66 
 67 // macros for restartable system calls
 68 
 69 #define RESTARTABLE(_cmd, _result) do { \
 70   do { \
 71     _result = _cmd; \
 72   } while((_result == OS_ERR) &amp;&amp; (errno == EINTR)); \
 73 } while(false)
 74 
 75 #define RESTARTABLE_RETURN_INT(_cmd) do { \
 76   int _result; \
 77   RESTARTABLE(_cmd, _result); \
</pre>
</td>
<td>
<hr />
<pre>
 32 #include &lt;dlfcn.h&gt;
 33 #include &lt;sys/socket.h&gt;
 34 #include &lt;poll.h&gt;
 35 #include &lt;sys/filio.h&gt;
 36 #include &lt;unistd.h&gt;
 37 #include &lt;netdb.h&gt;
 38 #include &lt;setjmp.h&gt;
 39 
 40 inline bool os::uses_stack_guard_pages() {
 41   return true;
 42 }
 43 
 44 inline bool os::must_commit_stack_guard_pages() {
 45   assert(uses_stack_guard_pages(), &quot;sanity check&quot;);
 46   int r = thr_main() ;
 47   guarantee (r == 0 || r == 1, &quot;CR6501650 or CR6493689&quot;) ;
 48   return r;
 49 }
 50 
 51 






 52 // Bang the shadow pages if they need to be touched to be mapped.
 53 inline void os::map_stack_shadow_pages(address sp) {
 54 }
 55 
 56 inline void os::dll_unload(void *lib) { ::dlclose(lib); }
 57 
 58 //////////////////////////////////////////////////////////////////////////////
 59 ////////////////////////////////////////////////////////////////////////////////
 60 
 61 // macros for restartable system calls
 62 
 63 #define RESTARTABLE(_cmd, _result) do { \
 64   do { \
 65     _result = _cmd; \
 66   } while((_result == OS_ERR) &amp;&amp; (errno == EINTR)); \
 67 } while(false)
 68 
 69 #define RESTARTABLE_RETURN_INT(_cmd) do { \
 70   int _result; \
 71   RESTARTABLE(_cmd, _result); \
</pre>
</td>
</tr>
</table>
<center><a href="../posix/os_posix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows/os_perf_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
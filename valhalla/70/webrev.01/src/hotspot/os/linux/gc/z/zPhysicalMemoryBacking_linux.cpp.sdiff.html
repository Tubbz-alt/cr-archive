<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../attachListener_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="zPhysicalMemoryBacking_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/gc/z/zPhysicalMemoryBacking_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zArray.inline.hpp&quot;
 26 #include &quot;gc/z/zErrno.hpp&quot;
 27 #include &quot;gc/z/zGlobals.hpp&quot;
 28 #include &quot;gc/z/zLargePages.inline.hpp&quot;
 29 #include &quot;gc/z/zMountPoint_linux.hpp&quot;
 30 #include &quot;gc/z/zNUMA.inline.hpp&quot;
 31 #include &quot;gc/z/zPhysicalMemoryBacking_linux.hpp&quot;
 32 #include &quot;gc/z/zSyscall_linux.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;runtime/init.hpp&quot;
 35 #include &quot;runtime/os.hpp&quot;

 36 #include &quot;utilities/align.hpp&quot;
 37 #include &quot;utilities/debug.hpp&quot;
 38 #include &quot;utilities/growableArray.hpp&quot;
 39 
 40 #include &lt;fcntl.h&gt;
 41 #include &lt;stdio.h&gt;
 42 #include &lt;sys/mman.h&gt;
 43 #include &lt;sys/stat.h&gt;
 44 #include &lt;sys/statfs.h&gt;
 45 #include &lt;sys/types.h&gt;
 46 #include &lt;unistd.h&gt;
 47 
 48 //
 49 // Support for building on older Linux systems
 50 //
 51 
 52 // memfd_create(2) flags
 53 #ifndef MFD_CLOEXEC
 54 #define MFD_CLOEXEC                      0x0001U
 55 #endif
</pre>
<hr />
<pre>
373 }
374 
375 bool ZPhysicalMemoryBacking::tmpfs_supports_transparent_huge_pages() const {
376   // If the shmem_enabled file exists and is readable then we
377   // know the kernel supports transparent huge pages for tmpfs.
378   return access(ZFILENAME_SHMEM_ENABLED, R_OK) == 0;
379 }
380 
381 ZErrno ZPhysicalMemoryBacking::fallocate_compat_ftruncate(size_t size) const {
382   while (ftruncate(_fd, size) == -1) {
383     if (errno != EINTR) {
384       // Failed
385       return errno;
386     }
387   }
388 
389   // Success
390   return 0;
391 }
392 
<span class="line-modified">393 ZErrno ZPhysicalMemoryBacking::fallocate_compat_mmap(size_t offset, size_t length, bool touch) const {</span>
394   // On hugetlbfs, mapping a file segment will fail immediately, without
395   // the need to touch the mapped pages first, if there aren&#39;t enough huge
396   // pages available to back the mapping.
397   void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);
398   if (addr == MAP_FAILED) {
399     // Failed
400     return errno;
401   }
402 
403   // Once mapped, the huge pages are only reserved. We need to touch them
404   // to associate them with the file segment. Note that we can not punch
405   // hole in file segments which only have reserved pages.
406   if (touch) {
407     char* const start = (char*)addr;
408     char* const end = start + length;
409     os::pretouch_memory(start, end, _block_size);
410   }
411 
412   // Unmap again. From now on, the huge pages that were mapped are allocated
<span class="line-modified">413   // to this file. There&#39;s no risk in getting SIGBUS when touching them.</span>

414   if (munmap(addr, length) == -1) {
415     // Failed
416     return errno;
417   }
418 
419   // Success
420   return 0;
421 }
422 















































423 ZErrno ZPhysicalMemoryBacking::fallocate_compat_pwrite(size_t offset, size_t length) const {
424   uint8_t data = 0;
425 
426   // Allocate backing memory by writing to each block
427   for (size_t pos = offset; pos &lt; offset + length; pos += _block_size) {
428     if (pwrite(_fd, &amp;data, sizeof(data), pos) == -1) {
429       // Failed
430       return errno;
431     }
432   }
433 
434   // Success
435   return 0;
436 }
437 
438 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole_compat(size_t offset, size_t length) {
439   // fallocate(2) is only supported by tmpfs since Linux 3.5, and by hugetlbfs
440   // since Linux 4.3. When fallocate(2) is not supported we emulate it using
<span class="line-modified">441   // ftruncate/pwrite (for tmpfs) or ftruncate/mmap/munmap (for hugetlbfs).</span>

442 
443   const size_t end = offset + length;
444   if (end &gt; _size) {
445     // Increase file size
446     const ZErrno err = fallocate_compat_ftruncate(end);
447     if (err) {
448       // Failed
449       return err;
450     }
451   }
452 
453   // Allocate backing memory
<span class="line-modified">454   const ZErrno err = is_hugetlbfs() ? fallocate_compat_mmap(offset, length, false /* touch */)</span>
<span class="line-modified">455                                     : fallocate_compat_pwrite(offset, length);</span>




456   if (err) {
457     if (end &gt; _size) {
458       // Restore file size
459       fallocate_compat_ftruncate(_size);
460     }
461 
462     // Failed
463     return err;
464   }
465 
466   if (end &gt; _size) {
467     // Record new file size
468     _size = end;
469   }
470 
471   // Success
472   return 0;
473 }
474 
475 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole_syscall(size_t offset, size_t length) {
</pre>
<hr />
<pre>
478   if (res == -1) {
479     // Failed
480     return errno;
481   }
482 
483   const size_t end = offset + length;
484   if (end &gt; _size) {
485     // Record new file size
486     _size = end;
487   }
488 
489   // Success
490   return 0;
491 }
492 
493 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole(size_t offset, size_t length) {
494   // Using compat mode is more efficient when allocating space on hugetlbfs.
495   // Note that allocating huge pages this way will only reserve them, and not
496   // associate them with segments of the file. We must guarantee that we at
497   // some point touch these segments, otherwise we can not punch hole in them.
<span class="line-modified">498   if (z_fallocate_supported &amp;&amp; !is_hugetlbfs()) {</span>


499      const ZErrno err = fallocate_fill_hole_syscall(offset, length);
500      if (!err) {
501        // Success
502        return 0;
503      }
504 
505      if (err != ENOSYS &amp;&amp; err != EOPNOTSUPP) {
506        // Failed
507        return err;
508      }
509 
510      // Not supported
511      log_debug(gc)(&quot;Falling back to fallocate() compatibility mode&quot;);
512      z_fallocate_supported = false;
513   }
514 
515   return fallocate_fill_hole_compat(offset, length);
516 }
517 
518 ZErrno ZPhysicalMemoryBacking::fallocate_punch_hole(size_t offset, size_t length) {
<span class="line-modified">519   if (is_hugetlbfs()) {</span>
520     // We can only punch hole in pages that have been touched. Non-touched
521     // pages are only reserved, and not associated with any specific file
522     // segment. We don&#39;t know which pages have been previously touched, so
523     // we always touch them here to guarantee that we can punch hole.
<span class="line-modified">524     const ZErrno err = fallocate_compat_mmap(offset, length, true /* touch */);</span>
525     if (err) {
526       // Failed
527       return err;
528     }
529   }
530 
531   const int mode = FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE;
532   if (ZSyscall::fallocate(_fd, mode, offset, length) == -1) {
533     // Failed
534     return errno;
535   }
536 
537   // Success
538   return 0;
539 }
540 
541 ZErrno ZPhysicalMemoryBacking::split_and_fallocate(bool punch_hole, size_t offset, size_t length) {
542   // Try first half
543   const size_t offset0 = offset;
544   const size_t length0 = align_up(length / 2, _block_size);
</pre>
<hr />
<pre>
565 
566   const ZErrno err = punch_hole ? fallocate_punch_hole(offset, length) : fallocate_fill_hole(offset, length);
567   if (err == EINTR &amp;&amp; length &gt; _block_size) {
568     // Calling fallocate(2) with a large length can take a long time to
569     // complete. When running profilers, such as VTune, this syscall will
570     // be constantly interrupted by signals. Expanding the file in smaller
571     // steps avoids this problem.
572     return split_and_fallocate(punch_hole, offset, length);
573   }
574 
575   return err;
576 }
577 
578 bool ZPhysicalMemoryBacking::commit_inner(size_t offset, size_t length) {
579   log_trace(gc, heap)(&quot;Committing memory: &quot; SIZE_FORMAT &quot;M-&quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;M)&quot;,
580                       offset / M, (offset + length) / M, length / M);
581 
582 retry:
583   const ZErrno err = fallocate(false /* punch_hole */, offset, length);
584   if (err) {
<span class="line-modified">585     if (err == ENOSPC &amp;&amp; !is_init_completed() &amp;&amp; is_hugetlbfs() &amp;&amp; z_fallocate_hugetlbfs_attempts-- &gt; 0) {</span>
586       // If we fail to allocate during initialization, due to lack of space on
587       // the hugetlbfs filesystem, then we wait and retry a few times before
588       // giving up. Otherwise there is a risk that running JVMs back-to-back
589       // will fail, since there is a delay between process termination and the
590       // huge pages owned by that process being returned to the huge page pool
591       // and made available for new allocations.
592       log_debug(gc, init)(&quot;Failed to commit memory (%s), retrying&quot;, err.to_string());
593 
594       // Wait and retry in one second, in the hope that huge pages will be
595       // available by then.
596       sleep(1);
597       goto retry;
598     }
599 
600     // Failed
601     log_error(gc)(&quot;Failed to commit memory (%s)&quot;, err.to_string());
602     return false;
603   }
604 
605   // Success
</pre>
</td>
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zArray.inline.hpp&quot;
 26 #include &quot;gc/z/zErrno.hpp&quot;
 27 #include &quot;gc/z/zGlobals.hpp&quot;
 28 #include &quot;gc/z/zLargePages.inline.hpp&quot;
 29 #include &quot;gc/z/zMountPoint_linux.hpp&quot;
 30 #include &quot;gc/z/zNUMA.inline.hpp&quot;
 31 #include &quot;gc/z/zPhysicalMemoryBacking_linux.hpp&quot;
 32 #include &quot;gc/z/zSyscall_linux.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;runtime/init.hpp&quot;
 35 #include &quot;runtime/os.hpp&quot;
<span class="line-added"> 36 #include &quot;runtime/stubRoutines.hpp&quot;</span>
 37 #include &quot;utilities/align.hpp&quot;
 38 #include &quot;utilities/debug.hpp&quot;
 39 #include &quot;utilities/growableArray.hpp&quot;
 40 
 41 #include &lt;fcntl.h&gt;
 42 #include &lt;stdio.h&gt;
 43 #include &lt;sys/mman.h&gt;
 44 #include &lt;sys/stat.h&gt;
 45 #include &lt;sys/statfs.h&gt;
 46 #include &lt;sys/types.h&gt;
 47 #include &lt;unistd.h&gt;
 48 
 49 //
 50 // Support for building on older Linux systems
 51 //
 52 
 53 // memfd_create(2) flags
 54 #ifndef MFD_CLOEXEC
 55 #define MFD_CLOEXEC                      0x0001U
 56 #endif
</pre>
<hr />
<pre>
374 }
375 
376 bool ZPhysicalMemoryBacking::tmpfs_supports_transparent_huge_pages() const {
377   // If the shmem_enabled file exists and is readable then we
378   // know the kernel supports transparent huge pages for tmpfs.
379   return access(ZFILENAME_SHMEM_ENABLED, R_OK) == 0;
380 }
381 
382 ZErrno ZPhysicalMemoryBacking::fallocate_compat_ftruncate(size_t size) const {
383   while (ftruncate(_fd, size) == -1) {
384     if (errno != EINTR) {
385       // Failed
386       return errno;
387     }
388   }
389 
390   // Success
391   return 0;
392 }
393 
<span class="line-modified">394 ZErrno ZPhysicalMemoryBacking::fallocate_compat_mmap_hugetlbfs(size_t offset, size_t length, bool touch) const {</span>
395   // On hugetlbfs, mapping a file segment will fail immediately, without
396   // the need to touch the mapped pages first, if there aren&#39;t enough huge
397   // pages available to back the mapping.
398   void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);
399   if (addr == MAP_FAILED) {
400     // Failed
401     return errno;
402   }
403 
404   // Once mapped, the huge pages are only reserved. We need to touch them
405   // to associate them with the file segment. Note that we can not punch
406   // hole in file segments which only have reserved pages.
407   if (touch) {
408     char* const start = (char*)addr;
409     char* const end = start + length;
410     os::pretouch_memory(start, end, _block_size);
411   }
412 
413   // Unmap again. From now on, the huge pages that were mapped are allocated
<span class="line-modified">414   // to this file. There&#39;s no risk of getting a SIGBUS when mapping and</span>
<span class="line-added">415   // touching these pages again.</span>
416   if (munmap(addr, length) == -1) {
417     // Failed
418     return errno;
419   }
420 
421   // Success
422   return 0;
423 }
424 
<span class="line-added">425 static bool safe_touch_mapping(void* addr, size_t length, size_t page_size) {</span>
<span class="line-added">426   char* const start = (char*)addr;</span>
<span class="line-added">427   char* const end = start + length;</span>
<span class="line-added">428 </span>
<span class="line-added">429   // Touching a mapping that can&#39;t be backed by memory will generate a</span>
<span class="line-added">430   // SIGBUS. By using SafeFetch32 any SIGBUS will be safely caught and</span>
<span class="line-added">431   // handled. On tmpfs, doing a fetch (rather than a store) is enough</span>
<span class="line-added">432   // to cause backing pages to be allocated (there&#39;s no zero-page to</span>
<span class="line-added">433   // worry about).</span>
<span class="line-added">434   for (char *p = start; p &lt; end; p += page_size) {</span>
<span class="line-added">435     if (SafeFetch32((int*)p, -1) == -1) {</span>
<span class="line-added">436       // Failed</span>
<span class="line-added">437       return false;</span>
<span class="line-added">438     }</span>
<span class="line-added">439   }</span>
<span class="line-added">440 </span>
<span class="line-added">441   // Success</span>
<span class="line-added">442   return true;</span>
<span class="line-added">443 }</span>
<span class="line-added">444 </span>
<span class="line-added">445 ZErrno ZPhysicalMemoryBacking::fallocate_compat_mmap_tmpfs(size_t offset, size_t length) const {</span>
<span class="line-added">446   // On tmpfs, we need to touch the mapped pages to figure out</span>
<span class="line-added">447   // if there are enough pages available to back the mapping.</span>
<span class="line-added">448   void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);</span>
<span class="line-added">449   if (addr == MAP_FAILED) {</span>
<span class="line-added">450     // Failed</span>
<span class="line-added">451     return errno;</span>
<span class="line-added">452   }</span>
<span class="line-added">453 </span>
<span class="line-added">454   // Advise mapping to use transparent huge pages</span>
<span class="line-added">455   os::realign_memory((char*)addr, length, os::large_page_size());</span>
<span class="line-added">456 </span>
<span class="line-added">457   // Touch the mapping (safely) to make sure it&#39;s backed by memory</span>
<span class="line-added">458   const bool backed = safe_touch_mapping(addr, length, _block_size);</span>
<span class="line-added">459 </span>
<span class="line-added">460   // Unmap again. If successfully touched, the backing memory will</span>
<span class="line-added">461   // be allocated to this file. There&#39;s no risk of getting a SIGBUS</span>
<span class="line-added">462   // when mapping and touching these pages again.</span>
<span class="line-added">463   if (munmap(addr, length) == -1) {</span>
<span class="line-added">464     // Failed</span>
<span class="line-added">465     return errno;</span>
<span class="line-added">466   }</span>
<span class="line-added">467 </span>
<span class="line-added">468   // Success</span>
<span class="line-added">469   return backed ? 0 : ENOMEM;</span>
<span class="line-added">470 }</span>
<span class="line-added">471 </span>
472 ZErrno ZPhysicalMemoryBacking::fallocate_compat_pwrite(size_t offset, size_t length) const {
473   uint8_t data = 0;
474 
475   // Allocate backing memory by writing to each block
476   for (size_t pos = offset; pos &lt; offset + length; pos += _block_size) {
477     if (pwrite(_fd, &amp;data, sizeof(data), pos) == -1) {
478       // Failed
479       return errno;
480     }
481   }
482 
483   // Success
484   return 0;
485 }
486 
487 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole_compat(size_t offset, size_t length) {
488   // fallocate(2) is only supported by tmpfs since Linux 3.5, and by hugetlbfs
489   // since Linux 4.3. When fallocate(2) is not supported we emulate it using
<span class="line-modified">490   // mmap/munmap (for hugetlbfs and tmpfs with transparent huge pages) or pwrite</span>
<span class="line-added">491   // (for tmpfs without transparent huge pages and other filesystem types).</span>
492 
493   const size_t end = offset + length;
494   if (end &gt; _size) {
495     // Increase file size
496     const ZErrno err = fallocate_compat_ftruncate(end);
497     if (err) {
498       // Failed
499       return err;
500     }
501   }
502 
503   // Allocate backing memory
<span class="line-modified">504   const ZErrno err = ZLargePages::is_explicit()</span>
<span class="line-modified">505                      ? fallocate_compat_mmap_hugetlbfs(offset, length, false /* touch */)</span>
<span class="line-added">506                      : (ZLargePages::is_transparent()</span>
<span class="line-added">507                         ? fallocate_compat_mmap_tmpfs(offset, length)</span>
<span class="line-added">508                         : fallocate_compat_pwrite(offset, length));</span>
<span class="line-added">509 </span>
510   if (err) {
511     if (end &gt; _size) {
512       // Restore file size
513       fallocate_compat_ftruncate(_size);
514     }
515 
516     // Failed
517     return err;
518   }
519 
520   if (end &gt; _size) {
521     // Record new file size
522     _size = end;
523   }
524 
525   // Success
526   return 0;
527 }
528 
529 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole_syscall(size_t offset, size_t length) {
</pre>
<hr />
<pre>
532   if (res == -1) {
533     // Failed
534     return errno;
535   }
536 
537   const size_t end = offset + length;
538   if (end &gt; _size) {
539     // Record new file size
540     _size = end;
541   }
542 
543   // Success
544   return 0;
545 }
546 
547 ZErrno ZPhysicalMemoryBacking::fallocate_fill_hole(size_t offset, size_t length) {
548   // Using compat mode is more efficient when allocating space on hugetlbfs.
549   // Note that allocating huge pages this way will only reserve them, and not
550   // associate them with segments of the file. We must guarantee that we at
551   // some point touch these segments, otherwise we can not punch hole in them.
<span class="line-modified">552   // Also note that we need to use compat mode when using transparent huge pages,</span>
<span class="line-added">553   // since we need to use madvise(2) on the mapping before the page is allocated.</span>
<span class="line-added">554   if (z_fallocate_supported &amp;&amp; !ZLargePages::is_enabled()) {</span>
555      const ZErrno err = fallocate_fill_hole_syscall(offset, length);
556      if (!err) {
557        // Success
558        return 0;
559      }
560 
561      if (err != ENOSYS &amp;&amp; err != EOPNOTSUPP) {
562        // Failed
563        return err;
564      }
565 
566      // Not supported
567      log_debug(gc)(&quot;Falling back to fallocate() compatibility mode&quot;);
568      z_fallocate_supported = false;
569   }
570 
571   return fallocate_fill_hole_compat(offset, length);
572 }
573 
574 ZErrno ZPhysicalMemoryBacking::fallocate_punch_hole(size_t offset, size_t length) {
<span class="line-modified">575   if (ZLargePages::is_explicit()) {</span>
576     // We can only punch hole in pages that have been touched. Non-touched
577     // pages are only reserved, and not associated with any specific file
578     // segment. We don&#39;t know which pages have been previously touched, so
579     // we always touch them here to guarantee that we can punch hole.
<span class="line-modified">580     const ZErrno err = fallocate_compat_mmap_hugetlbfs(offset, length, true /* touch */);</span>
581     if (err) {
582       // Failed
583       return err;
584     }
585   }
586 
587   const int mode = FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE;
588   if (ZSyscall::fallocate(_fd, mode, offset, length) == -1) {
589     // Failed
590     return errno;
591   }
592 
593   // Success
594   return 0;
595 }
596 
597 ZErrno ZPhysicalMemoryBacking::split_and_fallocate(bool punch_hole, size_t offset, size_t length) {
598   // Try first half
599   const size_t offset0 = offset;
600   const size_t length0 = align_up(length / 2, _block_size);
</pre>
<hr />
<pre>
621 
622   const ZErrno err = punch_hole ? fallocate_punch_hole(offset, length) : fallocate_fill_hole(offset, length);
623   if (err == EINTR &amp;&amp; length &gt; _block_size) {
624     // Calling fallocate(2) with a large length can take a long time to
625     // complete. When running profilers, such as VTune, this syscall will
626     // be constantly interrupted by signals. Expanding the file in smaller
627     // steps avoids this problem.
628     return split_and_fallocate(punch_hole, offset, length);
629   }
630 
631   return err;
632 }
633 
634 bool ZPhysicalMemoryBacking::commit_inner(size_t offset, size_t length) {
635   log_trace(gc, heap)(&quot;Committing memory: &quot; SIZE_FORMAT &quot;M-&quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;M)&quot;,
636                       offset / M, (offset + length) / M, length / M);
637 
638 retry:
639   const ZErrno err = fallocate(false /* punch_hole */, offset, length);
640   if (err) {
<span class="line-modified">641     if (err == ENOSPC &amp;&amp; !is_init_completed() &amp;&amp; ZLargePages::is_explicit() &amp;&amp; z_fallocate_hugetlbfs_attempts-- &gt; 0) {</span>
642       // If we fail to allocate during initialization, due to lack of space on
643       // the hugetlbfs filesystem, then we wait and retry a few times before
644       // giving up. Otherwise there is a risk that running JVMs back-to-back
645       // will fail, since there is a delay between process termination and the
646       // huge pages owned by that process being returned to the huge page pool
647       // and made available for new allocations.
648       log_debug(gc, init)(&quot;Failed to commit memory (%s), retrying&quot;, err.to_string());
649 
650       // Wait and retry in one second, in the hope that huge pages will be
651       // available by then.
652       sleep(1);
653       goto retry;
654     }
655 
656     // Failed
657     log_error(gc)(&quot;Failed to commit memory (%s)&quot;, err.to_string());
658     return false;
659   }
660 
661   // Success
</pre>
</td>
</tr>
</table>
<center><a href="../../attachListener_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="zPhysicalMemoryBacking_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39   static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),
 40                                         // __sigaction(), signal() is loaded
 41   static struct sigaction *(*get_signal_action)(int);
 42 
 43   static void check_signal_handler(int sig);
 44 
 45   static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);
 46   static int (*_pthread_setname_np)(pthread_t, const char*);
 47 
 48   static address   _initial_thread_stack_bottom;
 49   static uintptr_t _initial_thread_stack_size;
 50 
 51   static const char *_glibc_version;
 52   static const char *_libpthread_version;
 53 
 54   static bool _supports_fast_thread_cpu_time;
 55 
 56   static GrowableArray&lt;int&gt;* _cpu_to_node;
 57   static GrowableArray&lt;int&gt;* _nindex_to_node;
 58 


 59  protected:
 60 
 61   static julong _physical_memory;
 62   static pthread_t _main_thread;
 63   static int _page_size;
 64 
 65   static julong available_memory();
 66   static julong physical_memory() { return _physical_memory; }
 67   static void set_physical_memory(julong phys_mem) { _physical_memory = phys_mem; }
 68   static int active_processor_count();
 69 
 70   static void initialize_system_info();
 71 
 72   static int commit_memory_impl(char* addr, size_t bytes, bool exec);
 73   static int commit_memory_impl(char* addr, size_t bytes,
 74                                 size_t alignment_hint, bool exec);
 75 
 76   static void set_glibc_version(const char *s)      { _glibc_version = s; }
 77   static void set_libpthread_version(const char *s) { _libpthread_version = s; }
 78 
 79   static void rebuild_cpu_to_node_map();
 80   static void rebuild_nindex_to_node_map();
 81   static GrowableArray&lt;int&gt;* cpu_to_node()    { return _cpu_to_node; }
 82   static GrowableArray&lt;int&gt;* nindex_to_node()  { return _nindex_to_node; }
 83 
<span class="line-modified"> 84   static size_t find_large_page_size();</span>


 85   static size_t setup_large_page_size();
 86 
 87   static bool setup_large_page_type(size_t page_size);
 88   static bool transparent_huge_pages_sanity_check(bool warn, size_t pages_size);
 89   static bool hugetlbfs_sanity_check(bool warn, size_t page_size);
 90 
 91   static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec);
 92   static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec);
 93   static char* reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec);
 94   static char* reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec);
 95 
 96   static bool release_memory_special_impl(char* base, size_t bytes);
 97   static bool release_memory_special_shm(char* base, size_t bytes);
 98   static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);
 99 
100   static void print_full_memory_info(outputStream* st);
101   static void print_container_info(outputStream* st);
102   static void print_steal_info(outputStream* st);
103   static void print_distro_info(outputStream* st);
104   static void print_libversion_info(outputStream* st);
</pre>
</td>
<td>
<hr />
<pre>
 39   static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),
 40                                         // __sigaction(), signal() is loaded
 41   static struct sigaction *(*get_signal_action)(int);
 42 
 43   static void check_signal_handler(int sig);
 44 
 45   static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);
 46   static int (*_pthread_setname_np)(pthread_t, const char*);
 47 
 48   static address   _initial_thread_stack_bottom;
 49   static uintptr_t _initial_thread_stack_size;
 50 
 51   static const char *_glibc_version;
 52   static const char *_libpthread_version;
 53 
 54   static bool _supports_fast_thread_cpu_time;
 55 
 56   static GrowableArray&lt;int&gt;* _cpu_to_node;
 57   static GrowableArray&lt;int&gt;* _nindex_to_node;
 58 
<span class="line-added"> 59   static size_t _default_large_page_size;</span>
<span class="line-added"> 60 </span>
 61  protected:
 62 
 63   static julong _physical_memory;
 64   static pthread_t _main_thread;
 65   static int _page_size;
 66 
 67   static julong available_memory();
 68   static julong physical_memory() { return _physical_memory; }
 69   static void set_physical_memory(julong phys_mem) { _physical_memory = phys_mem; }
 70   static int active_processor_count();
 71 
 72   static void initialize_system_info();
 73 
 74   static int commit_memory_impl(char* addr, size_t bytes, bool exec);
 75   static int commit_memory_impl(char* addr, size_t bytes,
 76                                 size_t alignment_hint, bool exec);
 77 
 78   static void set_glibc_version(const char *s)      { _glibc_version = s; }
 79   static void set_libpthread_version(const char *s) { _libpthread_version = s; }
 80 
 81   static void rebuild_cpu_to_node_map();
 82   static void rebuild_nindex_to_node_map();
 83   static GrowableArray&lt;int&gt;* cpu_to_node()    { return _cpu_to_node; }
 84   static GrowableArray&lt;int&gt;* nindex_to_node()  { return _nindex_to_node; }
 85 
<span class="line-modified"> 86   static size_t default_large_page_size();</span>
<span class="line-added"> 87   static size_t find_default_large_page_size();</span>
<span class="line-added"> 88   static size_t find_large_page_size(size_t page_size);</span>
 89   static size_t setup_large_page_size();
 90 
 91   static bool setup_large_page_type(size_t page_size);
 92   static bool transparent_huge_pages_sanity_check(bool warn, size_t pages_size);
 93   static bool hugetlbfs_sanity_check(bool warn, size_t page_size);
 94 
 95   static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec);
 96   static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec);
 97   static char* reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec);
 98   static char* reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec);
 99 
100   static bool release_memory_special_impl(char* base, size_t bytes);
101   static bool release_memory_special_shm(char* base, size_t bytes);
102   static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);
103 
104   static void print_full_memory_info(outputStream* st);
105   static void print_container_info(outputStream* st);
106   static void print_steal_info(outputStream* st);
107   static void print_distro_info(outputStream* st);
108   static void print_libversion_info(outputStream* st);
</pre>
</td>
</tr>
</table>
<center><a href="os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
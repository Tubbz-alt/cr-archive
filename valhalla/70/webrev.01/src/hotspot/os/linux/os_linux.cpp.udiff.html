<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gc/z/zPhysicalMemoryBacking_linux.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -152,10 +152,11 @@</span>
  pthread_t os::Linux::_main_thread;
  int os::Linux::_page_size = -1;
  bool os::Linux::_supports_fast_thread_cpu_time = false;
  const char * os::Linux::_glibc_version = NULL;
  const char * os::Linux::_libpthread_version = NULL;
<span class="udiff-line-added">+ size_t os::Linux::_default_large_page_size = 0;</span>
  
  static jlong initial_time_count=0;
  
  static int clock_tics_per_sec = 100;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2974,10 +2975,19 @@</span>
  // Define MAP_HUGETLB here so we can build HotSpot on old systems.
  #ifndef MAP_HUGETLB
    #define MAP_HUGETLB 0x40000
  #endif
  
<span class="udiff-line-added">+ // If mmap flags are set with MAP_HUGETLB and the system supports multiple</span>
<span class="udiff-line-added">+ // huge page sizes, flag bits [26:31] can be used to encode the log2 of the</span>
<span class="udiff-line-added">+ // desired huge page size. Otherwise, the system&#39;s default huge page size will be used.</span>
<span class="udiff-line-added">+ // See mmap(2) man page for more info (since Linux 3.8).</span>
<span class="udiff-line-added">+ // https://lwn.net/Articles/533499/</span>
<span class="udiff-line-added">+ #ifndef MAP_HUGE_SHIFT</span>
<span class="udiff-line-added">+   #define MAP_HUGE_SHIFT 26</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  // Define MADV_HUGEPAGE here so we can build HotSpot on old systems.
  #ifndef MADV_HUGEPAGE
    #define MADV_HUGEPAGE 14
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3756,11 +3766,14 @@</span>
  
  // Large page support
  
  static size_t _large_page_size = 0;
  
<span class="udiff-line-modified-removed">- size_t os::Linux::find_large_page_size() {</span>
<span class="udiff-line-modified-added">+ size_t os::Linux::find_default_large_page_size() {</span>
<span class="udiff-line-added">+   if (_default_large_page_size != 0) {</span>
<span class="udiff-line-added">+     return _default_large_page_size;</span>
<span class="udiff-line-added">+   }</span>
    size_t large_page_size = 0;
  
    // large_page_size on Linux is used to round up heap size. x86 uses either
    // 2M or 4M page, depending on whether PAE (Physical Address Extensions)
    // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3804,32 +3817,71 @@</span>
          }
        }
      }
      fclose(fp);
    }
<span class="udiff-line-added">+   return large_page_size;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) &amp;&amp; LargePageSizeInBytes != large_page_size) {</span>
<span class="udiff-line-modified-removed">-     warning(&quot;Setting LargePageSizeInBytes has no effect on this OS. Large page size is &quot;</span>
<span class="udiff-line-modified-removed">-             SIZE_FORMAT &quot;%s.&quot;, byte_size_in_proper_unit(large_page_size),</span>
<span class="udiff-line-removed">-             proper_unit_for_byte_size(large_page_size));</span>
<span class="udiff-line-modified-added">+ size_t os::Linux::find_large_page_size(size_t large_page_size) {</span>
<span class="udiff-line-modified-added">+   if (_default_large_page_size == 0) {</span>
<span class="udiff-line-modified-added">+     _default_large_page_size = Linux::find_default_large_page_size();</span>
    }
<span class="udiff-line-added">+   // We need to scan /sys/kernel/mm/hugepages</span>
<span class="udiff-line-added">+   // to discover the available page sizes</span>
<span class="udiff-line-added">+   const char* sys_hugepages = &quot;/sys/kernel/mm/hugepages&quot;;</span>
  
<span class="udiff-line-modified-removed">-   return large_page_size;</span>
<span class="udiff-line-modified-added">+   DIR *dir = opendir(sys_hugepages);</span>
<span class="udiff-line-added">+   if (dir == NULL) {</span>
<span class="udiff-line-added">+     return _default_large_page_size;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   struct dirent *entry;</span>
<span class="udiff-line-added">+   size_t page_size;</span>
<span class="udiff-line-added">+   while ((entry = readdir(dir)) != NULL) {</span>
<span class="udiff-line-added">+     if (entry-&gt;d_type == DT_DIR &amp;&amp;</span>
<span class="udiff-line-added">+         sscanf(entry-&gt;d_name, &quot;hugepages-%zukB&quot;, &amp;page_size) == 1) {</span>
<span class="udiff-line-added">+       // The kernel is using kB, hotspot uses bytes</span>
<span class="udiff-line-added">+       if (large_page_size == page_size * K) {</span>
<span class="udiff-line-added">+         closedir(dir);</span>
<span class="udiff-line-added">+         return large_page_size;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   closedir(dir);</span>
<span class="udiff-line-added">+   return _default_large_page_size;</span>
  }
  
  size_t os::Linux::setup_large_page_size() {
<span class="udiff-line-modified-removed">-   _large_page_size = Linux::find_large_page_size();</span>
<span class="udiff-line-modified-added">+   _default_large_page_size = Linux::find_default_large_page_size();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) &amp;&amp; LargePageSizeInBytes != _default_large_page_size ) {</span>
<span class="udiff-line-added">+     _large_page_size = find_large_page_size(LargePageSizeInBytes);</span>
<span class="udiff-line-added">+     if (_large_page_size == _default_large_page_size) {</span>
<span class="udiff-line-added">+       warning(&quot;Setting LargePageSizeInBytes=&quot; SIZE_FORMAT &quot; has no effect on this OS. Using the default large page size &quot;</span>
<span class="udiff-line-added">+               SIZE_FORMAT &quot;%s.&quot;,</span>
<span class="udiff-line-added">+               LargePageSizeInBytes,</span>
<span class="udiff-line-added">+               byte_size_in_proper_unit(_large_page_size), proper_unit_for_byte_size(_large_page_size));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     _large_page_size = _default_large_page_size;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    const size_t default_page_size = (size_t)Linux::page_size();
    if (_large_page_size &gt; default_page_size) {
      _page_sizes[0] = _large_page_size;
      _page_sizes[1] = default_page_size;
      _page_sizes[2] = 0;
    }
  
    return _large_page_size;
  }
  
<span class="udiff-line-added">+ size_t os::Linux::default_large_page_size() {</span>
<span class="udiff-line-added">+   return _default_large_page_size;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool os::Linux::setup_large_page_type(size_t page_size) {
    if (FLAG_IS_DEFAULT(UseHugeTLBFS) &amp;&amp;
        FLAG_IS_DEFAULT(UseSHM) &amp;&amp;
        FLAG_IS_DEFAULT(UseTransparentHugePages)) {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4054,13 +4106,16 @@</span>
    assert(UseLargePages &amp;&amp; UseHugeTLBFS, &quot;only for Huge TLBFS large pages&quot;);
    assert(is_aligned(bytes, os::large_page_size()), &quot;Unaligned size&quot;);
    assert(is_aligned(req_addr, os::large_page_size()), &quot;Unaligned address&quot;);
  
    int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
<span class="udiff-line-modified-removed">-   char* addr = (char*)::mmap(req_addr, bytes, prot,</span>
<span class="udiff-line-modified-removed">-                              MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB,</span>
<span class="udiff-line-modified-removed">-                              -1, 0);</span>
<span class="udiff-line-modified-added">+   int flags = MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (os::large_page_size() != default_large_page_size()) {</span>
<span class="udiff-line-added">+     flags |= (exact_log2(os::large_page_size()) &lt;&lt; MAP_HUGE_SHIFT);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   char* addr = (char*)::mmap(req_addr, bytes, prot, flags, -1, 0);</span>
  
    if (addr == MAP_FAILED) {
      warn_on_large_pages_failure(req_addr, bytes, errno);
      return NULL;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4112,28 +4167,30 @@</span>
      ::munmap(start, end - start);
      return NULL;
    }
  
    int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+   int flags = MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED;</span>
    void* result;
  
    // Commit small-paged leading area.
    if (start != lp_start) {
<span class="udiff-line-modified-removed">-     result = ::mmap(start, lp_start - start, prot,</span>
<span class="udiff-line-removed">-                     MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,</span>
<span class="udiff-line-removed">-                     -1, 0);</span>
<span class="udiff-line-modified-added">+     result = ::mmap(start, lp_start - start, prot, flags, -1, 0);</span>
      if (result == MAP_FAILED) {
        ::munmap(lp_start, end - lp_start);
        return NULL;
      }
    }
  
    // Commit large-paged area.
<span class="udiff-line-modified-removed">-   result = ::mmap(lp_start, lp_bytes, prot,</span>
<span class="udiff-line-modified-removed">-                   MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_HUGETLB,</span>
<span class="udiff-line-modified-removed">-                   -1, 0);</span>
<span class="udiff-line-modified-added">+   flags |= MAP_HUGETLB;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (os::large_page_size() != default_large_page_size()) {</span>
<span class="udiff-line-added">+     flags |= (exact_log2(os::large_page_size()) &lt;&lt; MAP_HUGE_SHIFT);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   result = ::mmap(lp_start, lp_bytes, prot, flags, -1, 0);</span>
    if (result == MAP_FAILED) {
      warn_on_large_pages_failure(lp_start, lp_bytes, errno);
      // If the mmap above fails, the large pages region will be unmapped and we
      // have regions before and after with small pages. Release these regions.
      //
</pre>
<center><a href="gc/z/zPhysicalMemoryBacking_linux.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
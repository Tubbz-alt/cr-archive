<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/posix/os_posix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../linux/os_linux.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/os_solaris.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/posix/os_posix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 345   size_t end_offset = (extra_base + extra_size) - (aligned_base + size);
 346 
 347   if (begin_offset &gt; 0) {
 348       os::release_memory(extra_base, begin_offset);
 349   }
 350 
 351   if (end_offset &gt; 0) {
 352       os::release_memory(extra_base + begin_offset + size, end_offset);
 353   }
 354 
 355   if (file_desc != -1) {
 356     // After we have an aligned address, we can replace anonymous mapping with file mapping
 357     if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == NULL) {
 358       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
 359     }
 360     MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);
 361   }
 362   return aligned_base;
 363 }
 364 










 365 int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {
 366   // All supported POSIX platforms provide C99 semantics.
 367   int result = ::vsnprintf(buf, len, fmt, args);
 368   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
 369   // whether the buffer is NUL terminated, so ensure it is.
 370   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
 371     buf[len - 1] = &#39;\0&#39;;
 372   }
 373   return result;
 374 }
 375 
 376 int os::get_fileno(FILE* fp) {
 377   return NOT_AIX(::)fileno(fp);
 378 }
 379 
 380 struct tm* os::gmtime_pd(const time_t* clock, struct tm*  res) {
 381   return gmtime_r(clock, res);
 382 }
 383 
 384 void os::Posix::print_load_average(outputStream* st) {
</pre>
</td>
<td>
<hr />
<pre>
 345   size_t end_offset = (extra_base + extra_size) - (aligned_base + size);
 346 
 347   if (begin_offset &gt; 0) {
 348       os::release_memory(extra_base, begin_offset);
 349   }
 350 
 351   if (end_offset &gt; 0) {
 352       os::release_memory(extra_base + begin_offset + size, end_offset);
 353   }
 354 
 355   if (file_desc != -1) {
 356     // After we have an aligned address, we can replace anonymous mapping with file mapping
 357     if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == NULL) {
 358       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
 359     }
 360     MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);
 361   }
 362   return aligned_base;
 363 }
 364 
<span class="line-added"> 365 // On Posix platforms, reservations are done using mmap which can be released in parts. So splitting is a no-op.</span>
<span class="line-added"> 366 void os::split_reserved_memory(char *base, size_t size, size_t split) {</span>
<span class="line-added"> 367   char* const split_address = base + split;</span>
<span class="line-added"> 368   assert(size &gt; 0, &quot;Sanity&quot;);</span>
<span class="line-added"> 369   assert(size &gt; split, &quot;Sanity&quot;);</span>
<span class="line-added"> 370   assert(split &gt; 0, &quot;Sanity&quot;);</span>
<span class="line-added"> 371   assert(is_aligned(base, os::vm_allocation_granularity()), &quot;Sanity&quot;);</span>
<span class="line-added"> 372   assert(is_aligned(split_address, os::vm_allocation_granularity()), &quot;Sanity&quot;);</span>
<span class="line-added"> 373 }</span>
<span class="line-added"> 374 </span>
 375 int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {
 376   // All supported POSIX platforms provide C99 semantics.
 377   int result = ::vsnprintf(buf, len, fmt, args);
 378   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
 379   // whether the buffer is NUL terminated, so ensure it is.
 380   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
 381     buf[len - 1] = &#39;\0&#39;;
 382   }
 383   return result;
 384 }
 385 
 386 int os::get_fileno(FILE* fp) {
 387   return NOT_AIX(::)fileno(fp);
 388 }
 389 
 390 struct tm* os::gmtime_pd(const time_t* clock, struct tm*  res) {
 391   return gmtime_r(clock, res);
 392 }
 393 
 394 void os::Posix::print_load_average(outputStream* st) {
</pre>
</td>
</tr>
</table>
<center><a href="../linux/os_linux.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/os_solaris.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/windows/os_perf_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../solaris/os_solaris.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/os_perf_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;pdh_interface.hpp&quot;
  #include &quot;runtime/os_perf.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
<span class="line-added">+ #include &quot;runtime/semaphore.inline.hpp&quot;</span>
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include CPU_HEADER(vm_version_ext)
  #include &lt;math.h&gt;
  #include &lt;psapi.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,22 ***</span>
   * We import a selected few api entry points from PDH, see pdh_interface.hpp.
   *
   * The code located in this file is to a large extent an abstraction over much of the
   * plumbing needed to start consuming an object and/or counter of choice.
   *
<span class="line-modified">!  */</span>
<span class="line-removed">- </span>
<span class="line-removed">-  /*</span>
   * How to use:
<span class="line-modified">!  * 1. Create query</span>
   * 2. Add counters to the query
   * 3. Collect the performance data using the query
<span class="line-modified">!  * 4. Display the performance data using the counters associated with the query</span>
   * 5. Destroy query (counter destruction implied)
<span class="line-modified">!  */</span>
<span class="line-modified">! </span>
<span class="line-removed">- /*</span>
   * Every PDH artifact, like processor, process, thread, memory, and so forth are
   * identified with an index that is always the same irrespective
   * of the localized version of the operating system or service pack installed.
   * INFO: Using PDH APIs Correctly in a Localized Language (Q287159)
   *   http://support.microsoft.com/default.aspx?scid=kb;EN-US;q287159
<span class="line-new-header">--- 44,19 ---</span>
   * We import a selected few api entry points from PDH, see pdh_interface.hpp.
   *
   * The code located in this file is to a large extent an abstraction over much of the
   * plumbing needed to start consuming an object and/or counter of choice.
   *
<span class="line-modified">!  *</span>
   * How to use:
<span class="line-modified">!  * 1. Create a query</span>
   * 2. Add counters to the query
   * 3. Collect the performance data using the query
<span class="line-modified">!  * 4. Read the performance data from counters associated with the query</span>
   * 5. Destroy query (counter destruction implied)
<span class="line-modified">!  *</span>
<span class="line-modified">!  *</span>
   * Every PDH artifact, like processor, process, thread, memory, and so forth are
   * identified with an index that is always the same irrespective
   * of the localized version of the operating system or service pack installed.
   * INFO: Using PDH APIs Correctly in a Localized Language (Q287159)
   *   http://support.microsoft.com/default.aspx?scid=kb;EN-US;q287159
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,31 ***</span>
  static const DWORD PDH_PROCESS_IDX = 230;
  static const DWORD PDH_ID_PROCESS_IDX = 784;
  static const DWORD PDH_CONTEXT_SWITCH_RATE_IDX = 146;
  static const DWORD PDH_SYSTEM_IDX = 2;
  
<span class="line-modified">! /* useful pdh fmt&#39;s */</span>
  static const char* const OBJECT_COUNTER_FMT = &quot;\\%s\\%s&quot;;
  static const size_t OBJECT_COUNTER_FMT_LEN = 2;
  static const char* const OBJECT_WITH_INSTANCES_COUNTER_FMT = &quot;\\%s(%s)\\%s&quot;;
  static const size_t OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN = 4;
<span class="line-modified">! static const char* const PROCESS_OBJECT_INSTANCE_COUNTER_FMT = &quot;\\%s(%s#%s)\\%s&quot;;</span>
<span class="line-modified">! static const size_t PROCESS_OBJECT_INSTANCE_COUNTER_FMT_LEN = 5;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static const char* process_image_name = NULL; // for example, &quot;java&quot; but could have another image name</span>
<span class="line-removed">- static char* pdh_IDProcess_counter_fmt = NULL;   // &quot;\Process(java#%d)\ID Process&quot; */</span>
  
<span class="line-modified">! // Need to limit how often we update a query to minimize the heisenberg effect.</span>
<span class="line-modified">! // (PDH behaves erratically if the counters are queried too often, especially counters that</span>
<span class="line-modified">! // store and use values from two consecutive updates, like cpu load.)</span>
<span class="line-modified">! static const int min_update_interval_millis = 500;</span>
  
  /*
  * Structs for PDH queries.
  */
  typedef struct {
<span class="line-modified">!   HQUERY query;</span>
    s8     lastUpdate; // Last time query was updated.
  } UpdateQueryS, *UpdateQueryP;
  
  
  typedef struct {
<span class="line-new-header">--- 72,30 ---</span>
  static const DWORD PDH_PROCESS_IDX = 230;
  static const DWORD PDH_ID_PROCESS_IDX = 784;
  static const DWORD PDH_CONTEXT_SWITCH_RATE_IDX = 146;
  static const DWORD PDH_SYSTEM_IDX = 2;
  
<span class="line-modified">! /* useful pdh fmt&#39;s for the general form: \object(instance#index)\counter */</span>
  static const char* const OBJECT_COUNTER_FMT = &quot;\\%s\\%s&quot;;
  static const size_t OBJECT_COUNTER_FMT_LEN = 2;
  static const char* const OBJECT_WITH_INSTANCES_COUNTER_FMT = &quot;\\%s(%s)\\%s&quot;;
  static const size_t OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN = 4;
<span class="line-modified">! static const char* const PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT = &quot;\\%s(%s#%s)\\%s&quot;;</span>
<span class="line-modified">! static const size_t PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN = 5;</span>
<span class="line-modified">! static const char* const PROCESS_OBJECT_WITH_INSTANCES_WILDCARD_FMT = &quot;\\%s(%s*)\\%s&quot;;</span>
<span class="line-modified">! static const size_t PROCESS_OBJECT_WITH_INSTANCES_WILDCARD_FMT_LEN = 5;</span>
  
<span class="line-modified">! /* pdh string constants built up from fmts on initialization */</span>
<span class="line-modified">! static const char* process_image_name = NULL; // e.g. &quot;java&quot; but could have another image name</span>
<span class="line-modified">! static char* pdh_process_instance_IDProcess_counter_fmt = NULL; // &quot;\Process(java#%d)\ID Process&quot; */</span>
<span class="line-modified">! static char* pdh_process_instance_wildcard_IDProcess_counter = NULL; // &quot;\Process(java*)\ID Process&quot; */</span>
  
  /*
  * Structs for PDH queries.
  */
  typedef struct {
<span class="line-modified">!   HQUERY pdh_query_handle;</span>
    s8     lastUpdate; // Last time query was updated.
  } UpdateQueryS, *UpdateQueryP;
  
  
  typedef struct {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,81 ***</span>
    bool               initialized;
  } MultiCounterQuerySetS, *MultiCounterQuerySetP;
  
  typedef struct {
    MultiCounterQuerySetS set;
<span class="line-modified">!   int                   process_index;</span>
  } ProcessQueryS, *ProcessQueryP;
  
<span class="line-modified">! static void pdh_cleanup(HQUERY* const query, HCOUNTER* const counter) {</span>
    if (counter != NULL &amp;&amp; *counter != NULL) {
      PdhDll::PdhRemoveCounter(*counter);
      *counter = NULL;
    }
<span class="line-modified">!   if (query != NULL &amp;&amp; *query != NULL) {</span>
<span class="line-modified">!     PdhDll::PdhCloseQuery(*query);</span>
<span class="line-modified">!     *query = NULL;</span>
    }
  }
  
  static CounterQueryP create_counter_query() {
    CounterQueryP const query = NEW_C_HEAP_OBJ(CounterQueryS, mtInternal);
    memset(query, 0, sizeof(CounterQueryS));
    return query;
  }
  
<span class="line-removed">- static void destroy_counter_query(CounterQueryP query) {</span>
<span class="line-removed">-   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   pdh_cleanup(&amp;query-&gt;query.query, &amp;query-&gt;counter);</span>
<span class="line-removed">-   FREE_C_HEAP_OBJ(query);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static MultiCounterQueryP create_multi_counter_query() {
    MultiCounterQueryP const query = NEW_C_HEAP_ARRAY(MultiCounterQueryS, 1, mtInternal);
    memset(query, 0, sizeof(MultiCounterQueryS));
    return query;
  }
  
<span class="line-modified">! static void destroy_counter_query(MultiCounterQueryP counter_query) {</span>
<span class="line-modified">!   if (counter_query != NULL) {</span>
<span class="line-modified">!     for (int i = 0; i &lt; counter_query-&gt;noOfCounters; ++i) {</span>
<span class="line-modified">!       pdh_cleanup(NULL, &amp;counter_query-&gt;counters[i]);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(char, counter_query-&gt;counters);</span>
<span class="line-removed">-     pdh_cleanup(&amp;counter_query-&gt;query.query, NULL);</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(MultiCounterQueryS, counter_query);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! static void destroy_multi_counter_query(MultiCounterQuerySetP counter_query_set) {</span>
<span class="line-modified">!   for (int i = 0; i &lt; counter_query_set-&gt;size; i++) {</span>
<span class="line-modified">!     for (int j = 0; j &lt; counter_query_set-&gt;queries[i].noOfCounters; ++j) {</span>
<span class="line-modified">!       pdh_cleanup(NULL, &amp;counter_query_set-&gt;queries[i].counters[j]);</span>
      }
<span class="line-modified">!     FREE_C_HEAP_ARRAY(char, counter_query_set-&gt;queries[i].counters);</span>
<span class="line-modified">!     pdh_cleanup(&amp;counter_query_set-&gt;queries[i].query.query, NULL);</span>
    }
<span class="line-removed">-   FREE_C_HEAP_ARRAY(MultiCounterQueryS, counter_query_set-&gt;queries);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void destroy_counter_query(MultiCounterQuerySetP counter_query_set) {</span>
<span class="line-removed">-   destroy_multi_counter_query(counter_query_set);</span>
<span class="line-removed">-   FREE_C_HEAP_ARRAY(MultiCounterQuerySetS, counter_query_set);</span>
  }
  
<span class="line-modified">! static void destroy_counter_query(ProcessQueryP process_query) {</span>
<span class="line-modified">!   destroy_multi_counter_query(&amp;process_query-&gt;set);</span>
<span class="line-modified">!   FREE_C_HEAP_OBJ(process_query);</span>
  }
  
<span class="line-modified">! static int open_query(HQUERY* query) {</span>
<span class="line-modified">!   return PdhDll::PdhOpenQuery(NULL, 0, query);</span>
  }
  
<span class="line-modified">! template &lt;typename QueryP&gt;</span>
<span class="line-modified">! static int open_query(QueryP query) {</span>
<span class="line-modified">!   return open_query(&amp;query-&gt;query);</span>
  }
  
  static void allocate_counters(MultiCounterQueryP query, size_t nofCounters) {
    assert(query != NULL, &quot;invariant&quot;);
    assert(!query-&gt;initialized, &quot;invariant&quot;);
<span class="line-new-header">--- 117,93 ---</span>
    bool               initialized;
  } MultiCounterQuerySetS, *MultiCounterQuerySetP;
  
  typedef struct {
    MultiCounterQuerySetS set;
<span class="line-modified">!   int                   process_idx;</span>
  } ProcessQueryS, *ProcessQueryP;
  
<span class="line-modified">! static int open_query(HQUERY* pdh_query_handle) {</span>
<span class="line-added">+   return PdhDll::PdhOpenQuery(NULL, 0, pdh_query_handle) != ERROR_SUCCESS ? OS_ERR : OS_OK;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int open_query(UpdateQueryP query) {</span>
<span class="line-added">+   return open_query(&amp;query-&gt;pdh_query_handle);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename QueryP&gt;</span>
<span class="line-added">+ static int open_query(QueryP query) {</span>
<span class="line-added">+   return open_query(&amp;query-&gt;query);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void close_query(HQUERY* const pdh_query_handle, HCOUNTER* const counter) {</span>
    if (counter != NULL &amp;&amp; *counter != NULL) {
      PdhDll::PdhRemoveCounter(*counter);
      *counter = NULL;
    }
<span class="line-modified">!   if (pdh_query_handle != NULL &amp;&amp; *pdh_query_handle != NULL) {</span>
<span class="line-modified">!     PdhDll::PdhCloseQuery(*pdh_query_handle);</span>
<span class="line-modified">!     *pdh_query_handle = NULL;</span>
    }
  }
  
<span class="line-added">+ static void close_query(MultiCounterQueryP query) {</span>
<span class="line-added">+   for (int i = 0; i &lt; query-&gt;noOfCounters; ++i) {</span>
<span class="line-added">+     close_query(NULL, &amp;query-&gt;counters[i]);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   close_query(&amp;query-&gt;query.pdh_query_handle, NULL);</span>
<span class="line-added">+   query-&gt;initialized = false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static CounterQueryP create_counter_query() {
    CounterQueryP const query = NEW_C_HEAP_OBJ(CounterQueryS, mtInternal);
    memset(query, 0, sizeof(CounterQueryS));
    return query;
  }
  
  static MultiCounterQueryP create_multi_counter_query() {
    MultiCounterQueryP const query = NEW_C_HEAP_ARRAY(MultiCounterQueryS, 1, mtInternal);
    memset(query, 0, sizeof(MultiCounterQueryS));
    return query;
  }
  
<span class="line-modified">! static void destroy(CounterQueryP query) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   close_query(&amp;query-&gt;query.pdh_query_handle, &amp;query-&gt;counter);</span>
<span class="line-modified">!   FREE_C_HEAP_OBJ(query);</span>
  }
  
<span class="line-modified">! static void destroy(MultiCounterQueryP query) {</span>
<span class="line-modified">!   if (query != NULL) {</span>
<span class="line-modified">!     for (int i = 0; i &lt; query-&gt;noOfCounters; ++i) {</span>
<span class="line-modified">!       close_query(NULL, &amp;query-&gt;counters[i]);</span>
      }
<span class="line-modified">!     FREE_C_HEAP_ARRAY(char, query-&gt;counters);</span>
<span class="line-modified">!     close_query(&amp;query-&gt;query.pdh_query_handle, NULL);</span>
<span class="line-added">+     FREE_C_HEAP_ARRAY(MultiCounterQueryS, query);</span>
    }
  }
  
<span class="line-modified">! static void destroy_query_set(MultiCounterQuerySetP query_set) {</span>
<span class="line-modified">!   for (int i = 0; i &lt; query_set-&gt;size; i++) {</span>
<span class="line-modified">!     for (int j = 0; j &lt; query_set-&gt;queries[i].noOfCounters; ++j) {</span>
<span class="line-added">+       close_query(NULL, &amp;query_set-&gt;queries[i].counters[j]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     FREE_C_HEAP_ARRAY(char, query_set-&gt;queries[i].counters);</span>
<span class="line-added">+     close_query(&amp;query_set-&gt;queries[i].query.pdh_query_handle, NULL);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   FREE_C_HEAP_ARRAY(MultiCounterQueryS, query_set-&gt;queries);</span>
  }
  
<span class="line-modified">! static void destroy(MultiCounterQuerySetP query) {</span>
<span class="line-modified">!   destroy_query_set(query);</span>
<span class="line-added">+   FREE_C_HEAP_ARRAY(MultiCounterQuerySetS, query);</span>
  }
  
<span class="line-modified">! static void destroy(ProcessQueryP query) {</span>
<span class="line-modified">!   destroy_query_set(&amp;query-&gt;set);</span>
<span class="line-modified">!   FREE_C_HEAP_OBJ(query);</span>
  }
  
  static void allocate_counters(MultiCounterQueryP query, size_t nofCounters) {
    assert(query != NULL, &quot;invariant&quot;);
    assert(!query-&gt;initialized, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,40 ***</span>
    query-&gt;counters = NEW_C_HEAP_ARRAY(HCOUNTER, nofCounters, mtInternal);
    memset(query-&gt;counters, 0, nofCounters * sizeof(HCOUNTER));
    query-&gt;noOfCounters = (int)nofCounters;
  }
  
<span class="line-modified">! static void allocate_counters(MultiCounterQuerySetP query_set, size_t nofCounters) {</span>
<span class="line-modified">!   assert(query_set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!query_set-&gt;initialized, &quot;invariant&quot;);</span>
<span class="line-modified">!   for (int i = 0; i &lt; query_set-&gt;size; ++i) {</span>
<span class="line-modified">!     allocate_counters(&amp;query_set-&gt;queries[i], nofCounters);</span>
    }
  }
  
<span class="line-modified">! static void allocate_counters(ProcessQueryP process_query, size_t nofCounters) {</span>
<span class="line-modified">!   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   allocate_counters(&amp;process_query-&gt;set, nofCounters);</span>
  }
  
  static void deallocate_counters(MultiCounterQueryP query) {
    FREE_C_HEAP_ARRAY(char, query-&gt;counters);
    query-&gt;counters = NULL;
    query-&gt;noOfCounters = 0;
  }
  
<span class="line-modified">! static OSReturn add_counter(UpdateQueryP query, HCOUNTER* counter, const char* path, bool first_sample_on_init) {</span>
    assert(query != NULL, &quot;invariant&quot;);
    assert(counter != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (query-&gt;query == NULL) {</span>
<span class="line-modified">!     if (open_query(query) != ERROR_SUCCESS) {</span>
        return OS_ERR;
      }
    }
<span class="line-modified">!   assert(query-&gt;query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   PDH_STATUS status = PdhDll::PdhAddCounter(query-&gt;query, path, 0, counter);</span>
    if (PDH_CSTATUS_NO_OBJECT == status || PDH_CSTATUS_NO_COUNTER == status) {
      return OS_ERR;
    }
    /*
    * According to the MSDN documentation, rate counters must be read twice:
<span class="line-new-header">--- 212,40 ---</span>
    query-&gt;counters = NEW_C_HEAP_ARRAY(HCOUNTER, nofCounters, mtInternal);
    memset(query-&gt;counters, 0, nofCounters * sizeof(HCOUNTER));
    query-&gt;noOfCounters = (int)nofCounters;
  }
  
<span class="line-modified">! static void allocate_counters(MultiCounterQuerySetP query, size_t nofCounters) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!query-&gt;initialized, &quot;invariant&quot;);</span>
<span class="line-modified">!   for (int i = 0; i &lt; query-&gt;size; ++i) {</span>
<span class="line-modified">!     allocate_counters(&amp;query-&gt;queries[i], nofCounters);</span>
    }
  }
  
<span class="line-modified">! static void allocate_counters(ProcessQueryP query, size_t nofCounters) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   allocate_counters(&amp;query-&gt;set, nofCounters);</span>
  }
  
  static void deallocate_counters(MultiCounterQueryP query) {
    FREE_C_HEAP_ARRAY(char, query-&gt;counters);
    query-&gt;counters = NULL;
    query-&gt;noOfCounters = 0;
  }
  
<span class="line-modified">! static OSReturn add_counter(UpdateQueryP query, HCOUNTER* counter, const char* counter_path, bool first_sample_on_init) {</span>
    assert(query != NULL, &quot;invariant&quot;);
    assert(counter != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(counter_path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (query-&gt;pdh_query_handle == NULL) {</span>
<span class="line-modified">!     if (open_query(query) != OS_OK) {</span>
        return OS_ERR;
      }
    }
<span class="line-modified">!   assert(query-&gt;pdh_query_handle != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   PDH_STATUS status = PdhDll::PdhAddCounter(query-&gt;pdh_query_handle, counter_path, 0, counter);</span>
    if (PDH_CSTATUS_NO_OBJECT == status || PDH_CSTATUS_NO_COUNTER == status) {
      return OS_ERR;
    }
    /*
    * According to the MSDN documentation, rate counters must be read twice:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,216 ***</span>
    *  implement the waiting period between the two calls to PdhCollectQueryData.&quot;
    *
    *  Take the first sample here already to allow for the next &quot;real&quot; sample
    *  to succeed.
    */
<span class="line-modified">!   if (first_sample_on_init) {</span>
<span class="line-modified">!     PdhDll::PdhCollectQueryData(query-&gt;query);</span>
    }
    return OS_OK;
  }
  
  template &lt;typename QueryP&gt;
<span class="line-modified">! static OSReturn add_counter(QueryP counter_query, HCOUNTER* counter, const char* path, bool first_sample_on_init) {</span>
<span class="line-modified">!   assert(counter_query != NULL, &quot;invariant&quot;);</span>
    assert(counter != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return add_counter(&amp;counter_query-&gt;query, counter, path, first_sample_on_init);</span>
  }
  
<span class="line-modified">! static OSReturn add_counter(CounterQueryP counter_query, const char* path, bool first_sample_on_init) {</span>
<span class="line-modified">!   if (add_counter(counter_query, &amp;counter_query-&gt;counter, path, first_sample_on_init) != OS_OK) {</span>
<span class="line-modified">!     // performance counter might be disabled in the registry</span>
<span class="line-removed">-     return OS_ERR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   counter_query-&gt;initialized = true;</span>
<span class="line-removed">-   return OS_OK;</span>
  }
  
<span class="line-modified">! static OSReturn add_process_counter(MultiCounterQueryP query, int slot_index, const char* path, bool first_sample_on_init) {</span>
    assert(query != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(slot_index &lt; query-&gt;noOfCounters, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(query-&gt;counters[slot_index] == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   const OSReturn ret = add_counter(query, &amp;query-&gt;counters[slot_index], path, first_sample_on_init);</span>
<span class="line-removed">-   if (OS_OK == ret) {</span>
<span class="line-removed">-     if (slot_index + 1 == query-&gt;noOfCounters) {</span>
<span class="line-removed">-       query-&gt;initialized = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return ret;</span>
  }
  
<span class="line-modified">! static int collect_query_data(UpdateQueryP update_query) {</span>
<span class="line-modified">!   assert(update_query != NULL, &quot;invariant&quot;);</span>
    const s8 now = os::javaTimeNanos();
<span class="line-modified">!   if (nanos_to_millis(now - update_query-&gt;lastUpdate) &gt; min_update_interval_millis) {</span>
<span class="line-modified">!     if (PdhDll::PdhCollectQueryData(update_query-&gt;query) != ERROR_SUCCESS) {</span>
        return OS_ERR;
      }
<span class="line-modified">!     update_query-&gt;lastUpdate = now;</span>
    }
    return OS_OK;
  }
  
<span class="line-modified">! template &lt;typename Query&gt;</span>
<span class="line-modified">! static int collect_query_data(Query* counter_query) {</span>
<span class="line-modified">!   assert(counter_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return collect_query_data(&amp;counter_query-&gt;query);</span>
  }
  
  static int formatted_counter_value(HCOUNTER counter, DWORD format, PDH_FMT_COUNTERVALUE* const value) {
    assert(value != NULL, &quot;invariant&quot;);
<span class="line-modified">!   if (PdhDll::PdhGetFormattedCounterValue(counter, format, NULL, value) != ERROR_SUCCESS) {</span>
      return OS_ERR;
    }
<span class="line-modified">!   return OS_OK;</span>
  }
  
  /*
<span class="line-modified">! * Working against the Process object and it&#39;s related counters is inherently problematic</span>
<span class="line-modified">! * when using the PDH API:</span>
  *
<span class="line-modified">! * Using PDH, a process is not primarily identified by the process id,</span>
<span class="line-modified">! * but with a sequential number, for example \Process(java#0), \Process(java#1), ...</span>
<span class="line-modified">! * The really bad part is that this list is reset as soon as a process exits:</span>
<span class="line-modified">! * If \Process(java#1) exits, \Process(java#3) now becomes \Process(java#2) etc.</span>
  *
<span class="line-modified">! * The PDH api requires a process identifier to be submitted when registering</span>
<span class="line-modified">! * a query, but as soon as the list resets, the query is invalidated (since the name changed).</span>
  *
  * Solution:
<span class="line-modified">! * The #number identifier for a Process query can only decrease after process creation.</span>
  *
  * We therefore create an array of counter queries for all process object instances
  * up to and including ourselves:
  *
<span class="line-modified">! * Ex. we come in as third process instance (java#2), we then create and register</span>
  * queries for the following Process object instances:
  * java#0, java#1, java#2
  *
<span class="line-modified">! * current_query_index_for_process() keeps track of the current &quot;correct&quot; query</span>
<span class="line-modified">! * (in order to keep this index valid when the list resets from underneath,</span>
<span class="line-modified">! * ensure to call current_query_index_for_process() before every query involving</span>
<span class="line-modified">! * Process object instance data).</span>
  *
<span class="line-modified">! * if unable to query, returns OS_ERR(-1)</span>
  */
<span class="line-modified">! static int current_query_index_for_process() {</span>
    assert(process_image_name != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(pdh_IDProcess_counter_fmt != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   HQUERY tmpQuery = NULL;</span>
<span class="line-modified">!   if (open_query(&amp;tmpQuery) != ERROR_SUCCESS) {</span>
      return OS_ERR;
    }
<span class="line-modified">!   char counter[512];</span>
<span class="line-modified">!   HCOUNTER handle_counter = NULL;</span>
<span class="line-modified">!   // iterate over all instance indexes and try to find our own pid</span>
<span class="line-modified">!   for (int index = 0; index &lt; max_intx; index++) {</span>
<span class="line-modified">!     jio_snprintf(counter, sizeof(counter) - 1, pdh_IDProcess_counter_fmt, index);</span>
<span class="line-modified">!     assert(strlen(counter) &lt; sizeof(counter), &quot;invariant&quot;);</span>
<span class="line-modified">!     if (PdhDll::PdhAddCounter(tmpQuery, counter, 0, &amp;handle_counter) != ERROR_SUCCESS) {</span>
<span class="line-modified">!       pdh_cleanup(&amp;tmpQuery, &amp;handle_counter);</span>
<span class="line-modified">!       return OS_ERR;</span>
      }
<span class="line-modified">!     const PDH_STATUS res = PdhDll::PdhCollectQueryData(tmpQuery);</span>
<span class="line-modified">!     if (res == PDH_INVALID_HANDLE || res == PDH_NO_DATA) {</span>
<span class="line-removed">-       pdh_cleanup(&amp;tmpQuery, &amp;handle_counter);</span>
        return OS_ERR;
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       PDH_FMT_COUNTERVALUE counter_value;</span>
<span class="line-modified">!       formatted_counter_value(handle_counter, PDH_FMT_LONG, &amp;counter_value);</span>
<span class="line-modified">!       pdh_cleanup(NULL, &amp;handle_counter);</span>
<span class="line-removed">-       if ((LONG)os::current_process_id() == counter_value.longValue) {</span>
<span class="line-removed">-         pdh_cleanup(&amp;tmpQuery, NULL);</span>
<span class="line-removed">-         return index;</span>
<span class="line-removed">-       }</span>
      }
    }
<span class="line-modified">!   pdh_cleanup(&amp;tmpQuery, NULL);</span>
<span class="line-modified">!   return OS_ERR;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static ProcessQueryP create_process_query() {</span>
<span class="line-removed">-   const int current_process_idx = current_query_index_for_process();</span>
<span class="line-removed">-   if (OS_ERR == current_process_idx) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   ProcessQueryP const process_query = NEW_C_HEAP_OBJ(ProcessQueryS, mtInternal);</span>
<span class="line-removed">-   memset(process_query, 0, sizeof(ProcessQueryS));</span>
<span class="line-removed">-   process_query-&gt;set.queries = NEW_C_HEAP_ARRAY(MultiCounterQueryS, current_process_idx + 1, mtInternal);</span>
<span class="line-removed">-   memset(process_query-&gt;set.queries, 0, sizeof(MultiCounterQueryS) * (current_process_idx + 1));</span>
<span class="line-removed">-   process_query-&gt;process_index = current_process_idx;</span>
<span class="line-removed">-   process_query-&gt;set.size = current_process_idx + 1;</span>
<span class="line-removed">-   assert(process_query-&gt;set.size &gt; process_query-&gt;process_index, &quot;invariant&quot;);</span>
<span class="line-removed">-   return process_query;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static MultiCounterQueryP current_process_counter_query(ProcessQueryP process_query) {</span>
<span class="line-removed">-   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(process_query-&gt;process_index &lt; process_query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-removed">-   return &amp;process_query-&gt;set.queries[process_query-&gt;process_index];</span>
  }
  
<span class="line-modified">! static void clear_multi_counter(MultiCounterQueryP query) {</span>
<span class="line-modified">!   for (int i = 0; i &lt; query-&gt;noOfCounters; ++i) {</span>
<span class="line-modified">!     pdh_cleanup(NULL, &amp;query-&gt;counters[i]);</span>
    }
<span class="line-modified">!   pdh_cleanup(&amp;query-&gt;query.query, NULL);</span>
<span class="line-modified">!   query-&gt;initialized = false;</span>
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static int ensure_valid_process_query_index(ProcessQueryP process_query) {</span>
<span class="line-removed">-   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   const int previous_process_idx = process_query-&gt;process_index;</span>
<span class="line-removed">-   if (previous_process_idx == 0) {</span>
<span class="line-removed">-     return previous_process_idx;</span>
    }
<span class="line-modified">!   const int current_process_idx = current_query_index_for_process();</span>
<span class="line-modified">!   if (current_process_idx == previous_process_idx || OS_ERR == current_process_idx ||</span>
<span class="line-removed">-     current_process_idx &gt;= process_query-&gt;set.size) {</span>
<span class="line-removed">-     return previous_process_idx;</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   assert(current_process_idx &gt;= 0 &amp;&amp; current_process_idx &lt; process_query-&gt;set.size, &quot;out of bounds!&quot;);</span>
<span class="line-modified">!   while (current_process_idx &lt; process_query-&gt;set.size - 1) {</span>
<span class="line-modified">!     const int new_size = --process_query-&gt;set.size;</span>
<span class="line-removed">-     clear_multi_counter(&amp;process_query-&gt;set.queries[new_size]);</span>
    }
<span class="line-modified">!   assert(current_process_idx &lt; process_query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-modified">!   process_query-&gt;process_index = current_process_idx;</span>
<span class="line-modified">!   return current_process_idx;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static MultiCounterQueryP current_process_query(ProcessQueryP process_query) {</span>
<span class="line-removed">-   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   const int current_process_idx = ensure_valid_process_query_index(process_query);</span>
<span class="line-removed">-   assert(current_process_idx == process_query-&gt;process_index, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(current_process_idx &lt; process_query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-removed">-   return &amp;process_query-&gt;set.queries[current_process_idx];</span>
  }
  
<span class="line-modified">! static int collect_process_query_data(ProcessQueryP process_query) {</span>
<span class="line-modified">!   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return collect_query_data(current_process_query(process_query));</span>
  }
  
<span class="line-modified">! static int query_process_counter(ProcessQueryP process_query, int slot_index, DWORD format, PDH_FMT_COUNTERVALUE* const value) {</span>
<span class="line-modified">!   MultiCounterQueryP const current_query = current_process_counter_query(process_query);</span>
<span class="line-modified">!   assert(current_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(slot_index &lt; current_query-&gt;noOfCounters, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(current_query-&gt;counters[slot_index] != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   return formatted_counter_value(current_query-&gt;counters[slot_index], format, value);</span>
  }
  
  /*
<span class="line-modified">!  * Construct a fully qualified PDH path</span>
   *
<span class="line-modified">!  * @param objectName   a PDH Object string representation(required)</span>
<span class="line-modified">!  * @param counterName  a PDH Counter string representation(required)</span>
<span class="line-modified">!  * @param imageName    a process image name string, ex. &quot;java&quot; (opt)</span>
<span class="line-modified">!  * @param instance     an instance string, ex. &quot;0&quot;, &quot;1&quot;, ... (opt)</span>
<span class="line-modified">!  * @return             the fully qualified PDH path.</span>
   *
   * Caller will need a ResourceMark.
   *
   * (PdhMakeCounterPath() seems buggy on concatenating instances, hence this function instead)
   */
<span class="line-new-header">--- 256,280 ---</span>
    *  implement the waiting period between the two calls to PdhCollectQueryData.&quot;
    *
    *  Take the first sample here already to allow for the next &quot;real&quot; sample
    *  to succeed.
    */
<span class="line-modified">!   if (first_sample_on_init &amp;&amp; PdhDll::PdhCollectQueryData(query-&gt;pdh_query_handle) != ERROR_SUCCESS) {</span>
<span class="line-modified">!     return OS_ERR;</span>
    }
    return OS_OK;
  }
  
  template &lt;typename QueryP&gt;
<span class="line-modified">! static OSReturn add_counter(QueryP query, HCOUNTER* counter, const char* counter_path, bool first_sample_on_init) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
    assert(counter != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(counter_path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return add_counter(&amp;query-&gt;query, counter, counter_path, first_sample_on_init);</span>
  }
  
<span class="line-modified">! // if add_counter fails with OS_ERR, the performance counter might be disabled in the registry</span>
<span class="line-modified">! static OSReturn add_counter(CounterQueryP query, const char* counter_path, bool first_sample_on_init = true) {</span>
<span class="line-modified">!   return add_counter(query, &amp;query-&gt;counter, counter_path, first_sample_on_init);</span>
  }
  
<span class="line-modified">! static OSReturn add_counter(MultiCounterQueryP query, int counter_idx, const char* counter_path, bool first_sample_on_init) {</span>
    assert(query != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(counter_idx &lt; query-&gt;noOfCounters, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(query-&gt;counters[counter_idx] == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return add_counter(query, &amp;query-&gt;counters[counter_idx], counter_path, first_sample_on_init);</span>
  }
  
<span class="line-modified">! // Need to limit how often we update a query to minimize the heisenberg effect.</span>
<span class="line-modified">! // (PDH behaves erratically if the counters are queried too often, especially counters that</span>
<span class="line-added">+ // store and use values from two consecutive updates, like cpu load.)</span>
<span class="line-added">+ static const int min_update_interval_millis = 500;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int collect(UpdateQueryP query) {</span>
<span class="line-added">+   assert(query != NULL, &quot;invariant&quot;);</span>
    const s8 now = os::javaTimeNanos();
<span class="line-modified">!   if (nanos_to_millis(now - query-&gt;lastUpdate) &gt; min_update_interval_millis) {</span>
<span class="line-modified">!     if (PdhDll::PdhCollectQueryData(query-&gt;pdh_query_handle) != ERROR_SUCCESS) {</span>
        return OS_ERR;
      }
<span class="line-modified">!     query-&gt;lastUpdate = now;</span>
    }
    return OS_OK;
  }
  
<span class="line-modified">! template &lt;typename QueryP&gt;</span>
<span class="line-modified">! static int collect(QueryP query) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return collect(&amp;query-&gt;query);</span>
  }
  
  static int formatted_counter_value(HCOUNTER counter, DWORD format, PDH_FMT_COUNTERVALUE* const value) {
    assert(value != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return PdhDll::PdhGetFormattedCounterValue(counter, format, NULL, value) != ERROR_SUCCESS ? OS_ERR : OS_OK;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int read_counter(CounterQueryP query, DWORD format, PDH_FMT_COUNTERVALUE* const value) {</span>
<span class="line-added">+   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return formatted_counter_value(query-&gt;counter, format, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int read_counter(MultiCounterQueryP query, int counter_idx, DWORD format, PDH_FMT_COUNTERVALUE* const value) {</span>
<span class="line-added">+   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(counter_idx &lt; query-&gt;noOfCounters, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(query-&gt;counters[counter_idx] != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return formatted_counter_value(query-&gt;counters[counter_idx], format, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int read_counter(ProcessQueryP query, int counter_idx, DWORD format, PDH_FMT_COUNTERVALUE* const value) {</span>
<span class="line-added">+   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   MultiCounterQueryP const current_query = &amp;query-&gt;set.queries[query-&gt;process_idx];</span>
<span class="line-added">+   assert(current_query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return read_counter(current_query, counter_idx, format, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+ * The routine expands a process object path including a wildcard to fetch the list of process instances</span>
<span class="line-added">+ * having the same name, i.e. &quot;java&quot; or rather the value of process_image_name.</span>
<span class="line-added">+ * A tally of this list is returned to the caller.</span>
<span class="line-added">+ */</span>
<span class="line-added">+ static int number_of_live_process_instances() {</span>
<span class="line-added">+   char* buffer = NULL;</span>
<span class="line-added">+   DWORD size = 0;</span>
<span class="line-added">+   // determine size</span>
<span class="line-added">+   PDH_STATUS status = PdhDll::PdhExpandWildCardPath(NULL,</span>
<span class="line-added">+                                                     pdh_process_instance_wildcard_IDProcess_counter,</span>
<span class="line-added">+                                                     buffer,</span>
<span class="line-added">+                                                     &amp;size,</span>
<span class="line-added">+                                                     PDH_NOEXPANDCOUNTERS);</span>
<span class="line-added">+   while (status == PDH_MORE_DATA) {</span>
<span class="line-added">+     buffer = NEW_RESOURCE_ARRAY(char, size);</span>
<span class="line-added">+     status = PdhDll::PdhExpandWildCardPath(NULL,</span>
<span class="line-added">+                                            pdh_process_instance_wildcard_IDProcess_counter,</span>
<span class="line-added">+                                            buffer,</span>
<span class="line-added">+                                            &amp;size,</span>
<span class="line-added">+                                            PDH_NOEXPANDCOUNTERS);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (status != ERROR_SUCCESS) {</span>
      return OS_ERR;
    }
<span class="line-modified">!   // count the number of live process instances</span>
<span class="line-added">+   int instances = 0;</span>
<span class="line-added">+   const char* const end = buffer + size;</span>
<span class="line-added">+   for (char* next = buffer; next != end &amp;&amp; (*next != &#39;\0&#39;); next = &amp;next[strlen(next) + 1], ++instances);</span>
<span class="line-added">+   assert(instances &gt; 0, &quot;invariant&quot;);</span>
<span class="line-added">+   return instances;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static PDH_STATUS pdh_process_idx_to_pid(HQUERY&amp; pdh_query_handle, int idx, LONG* pid) {</span>
<span class="line-added">+   assert(pid != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   char counter_path[PDH_MAX_COUNTER_PATH];</span>
<span class="line-added">+   jio_snprintf(counter_path, sizeof(counter_path) - 1, pdh_process_instance_IDProcess_counter_fmt, idx);</span>
<span class="line-added">+   assert(strlen(counter_path) &lt; sizeof(counter_path), &quot;invariant&quot;);</span>
<span class="line-added">+   HCOUNTER counter = NULL;</span>
<span class="line-added">+   PDH_STATUS status = PdhDll::PdhAddCounter(pdh_query_handle, counter_path, 0, &amp;counter);</span>
<span class="line-added">+   if (status != ERROR_SUCCESS) {</span>
<span class="line-added">+     close_query(&amp;pdh_query_handle, &amp;counter);</span>
<span class="line-added">+     return status;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   status = PdhDll::PdhCollectQueryData(pdh_query_handle);</span>
<span class="line-added">+   if (status != ERROR_SUCCESS) {</span>
<span class="line-added">+     close_query(NULL, &amp;counter);</span>
<span class="line-added">+     return PDH_NO_DATA;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   PDH_FMT_COUNTERVALUE counter_value;</span>
<span class="line-added">+   status = formatted_counter_value(counter, PDH_FMT_LONG, &amp;counter_value);</span>
<span class="line-added">+   if (status != OS_OK) {</span>
<span class="line-added">+     close_query(&amp;pdh_query_handle, &amp;counter);</span>
<span class="line-added">+     return status;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   *pid = counter_value.longValue;</span>
<span class="line-added">+   close_query(NULL, &amp;counter);</span>
<span class="line-added">+   return ERROR_SUCCESS;</span>
  }
  
<span class="line-added">+ </span>
  /*
<span class="line-modified">!  * Max process query index is derived from the total number of live process instances, seen</span>
<span class="line-modified">!  * as a snap-shot at the point of initialization, i.e. processes having the same name, e.g. &quot;java&quot;.</span>
<span class="line-added">+  * The total number of live processes includes this process and this number - 1 is the maximum index</span>
<span class="line-added">+  * to be used in a process query.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int max_process_query_idx = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+ * Working with the Process object and its related counters is inherently</span>
<span class="line-added">+ * problematic when using the PDH API:</span>
<span class="line-added">+ *</span>
<span class="line-added">+ * A process is not primarily identified by the process id, but by an opaque</span>
<span class="line-added">+ * index into a list maintained by the kernel. To distinguish which</span>
<span class="line-added">+ * process instance is the intended target for a query, the PDH Process API demands,</span>
<span class="line-added">+ * at time of registration, a string describing the target process name concatenated</span>
<span class="line-added">+ * with the value for this index. For example:</span>
<span class="line-added">+ * &quot;\Process(java#0)&quot;, &quot;\Process(java#1)&quot;, ...</span>
  *
<span class="line-modified">! * The bad part is that this list is constantly in-flux as</span>
<span class="line-modified">! * processes are exiting. One consequence is that processes with indexes</span>
<span class="line-modified">! * greater than the one that just terminated is now shifted down by one.</span>
<span class="line-modified">! * For example:</span>
<span class="line-added">+ * if \Process(java#1) exits, \Process(java#2) now becomes \Process(java#1),</span>
<span class="line-added">+ *    \Process(java#2) becomes \Process(java#1) ...</span>
  *
<span class="line-modified">! * To make matters even more exciting, an already registered query is not invalidated</span>
<span class="line-modified">! * when the process list changes. Instead, the query will continue to work just as before,</span>
<span class="line-added">+ * or at least, so it seems.</span>
<span class="line-added">+ * Only, now, the query will read performance data from another process instance!</span>
<span class="line-added">+ * That&#39;s right, the performance data is now read from the process that was shifted</span>
<span class="line-added">+ * down by the kernel to occupy the index slot associated with our original registration.</span>
  *
  * Solution:
<span class="line-modified">! * The #index identifier for a Process query can only decrease after process creation.</span>
  *
  * We therefore create an array of counter queries for all process object instances
  * up to and including ourselves:
  *
<span class="line-modified">! * E.g. we come in as the third process instance (java#2), we then create and register</span>
  * queries for the following Process object instances:
  * java#0, java#1, java#2
  *
<span class="line-modified">! * current_process_query_index() finds the &quot;correct&quot; pdh process query index by inspecting</span>
<span class="line-modified">! * the pdh process list, at a particular instant, i.e. just before we issue the real process query.</span>
<span class="line-modified">! * Of course, this is an inherently racy situation because the pdh process list can change at any time.</span>
<span class="line-modified">! * We use current_process_query_index() to help keep the number of data errors low,</span>
<span class="line-added">+ * where a data error is defined to be the result of using a stale index to query the wrong process.</span>
  *
<span class="line-modified">! * Ensure to call ensure_current_process_query_index() before every query involving Process object instance data.</span>
<span class="line-added">+ *</span>
<span class="line-added">+ * returns OS_ERR(-1) if anything goes wrong in the discovery process.</span>
  */
<span class="line-modified">! </span>
<span class="line-added">+ static int current_process_query_index(int previous_query_idx = 0) {</span>
<span class="line-added">+   assert(max_process_query_idx &gt;= 0, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(max_process_query_idx &gt;= previous_query_idx, &quot;invariant&quot;);</span>
    assert(process_image_name != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(pdh_process_instance_IDProcess_counter_fmt != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   int result = OS_ERR;</span>
<span class="line-modified">!   HQUERY tmp_pdh_query_handle = NULL;</span>
<span class="line-added">+   if (open_query(&amp;tmp_pdh_query_handle) != OS_OK) {</span>
      return OS_ERR;
    }
<span class="line-modified">!   // We need to find the correct pdh process index corresponding to our process identifier (pid).</span>
<span class="line-modified">!   // Begin from the index that was valid at the time of the last query. If that index is no longer valid,</span>
<span class="line-modified">!   // it means the pdh process list has changed, i.e. because other processes with the same name as us have terminated.</span>
<span class="line-modified">!   // Seek downwards to find the updated, now downshifted, list index corresponding to our pid.</span>
<span class="line-modified">!   static const LONG current_pid = (LONG)os::current_process_id();</span>
<span class="line-modified">!   const int start_idx = previous_query_idx != 0 ? previous_query_idx : max_process_query_idx;</span>
<span class="line-modified">!   for (int idx = start_idx; idx &gt;= 0; --idx) {</span>
<span class="line-modified">!     LONG pid;</span>
<span class="line-modified">!     const PDH_STATUS status = pdh_process_idx_to_pid(tmp_pdh_query_handle, idx, &amp;pid);</span>
<span class="line-added">+     if (status == PDH_NO_DATA) {</span>
<span class="line-added">+       // pdh process list has changed</span>
<span class="line-added">+       continue;</span>
      }
<span class="line-modified">!     if (status != ERROR_SUCCESS) {</span>
<span class="line-modified">!       // something went wrong, tmp_pdh_query_handle is already closed.</span>
        return OS_ERR;
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (current_pid == pid) {</span>
<span class="line-modified">!       result = idx;</span>
<span class="line-modified">!       break;</span>
      }
    }
<span class="line-modified">!   close_query(&amp;tmp_pdh_query_handle, NULL);</span>
<span class="line-modified">!   return result;</span>
  }
  
<span class="line-modified">! static int ensure_current_process_query_index(ProcessQueryP query) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   const int previous_query_idx = query-&gt;process_idx;</span>
<span class="line-added">+   if (previous_query_idx == 0) {</span>
<span class="line-added">+     return previous_query_idx;</span>
    }
<span class="line-modified">!   const int current_query_idx = current_process_query_index(previous_query_idx);</span>
<span class="line-modified">!   if (current_query_idx == OS_ERR || current_query_idx &gt;= query-&gt;set.size) {</span>
<span class="line-modified">!     return OS_ERR;</span>
    }
<span class="line-modified">!   if (current_query_idx == previous_query_idx) {</span>
<span class="line-modified">!     return previous_query_idx;</span>
    }
<span class="line-modified">!   assert(current_query_idx &gt;= 0 &amp;&amp; current_query_idx &lt; query-&gt;set.size, &quot;out of bounds!&quot;);</span>
<span class="line-modified">!   while (current_query_idx &lt; query-&gt;set.size - 1) {</span>
<span class="line-modified">!     const int new_size = --query-&gt;set.size;</span>
<span class="line-modified">!     close_query(&amp;query-&gt;set.queries[new_size]);</span>
    }
<span class="line-modified">!   assert(current_query_idx &lt; query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-modified">!   query-&gt;process_idx = current_query_idx;</span>
<span class="line-modified">!   return OS_OK;</span>
  }
  
<span class="line-modified">! static MultiCounterQueryP current_process_query(ProcessQueryP query) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (ensure_current_process_query_index(query) == OS_ERR) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(query-&gt;process_idx &lt; query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-added">+   return &amp;query-&gt;set.queries[query-&gt;process_idx];</span>
  }
  
<span class="line-modified">! static int collect(ProcessQueryP query) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   MultiCounterQueryP current_query = current_process_query(query);</span>
<span class="line-modified">!   return current_query != NULL ? collect(current_query) : OS_ERR;</span>
  }
  
  /*
<span class="line-modified">!  * Construct a fully qualified PDH counter path.</span>
   *
<span class="line-modified">!  * @param object_name   a PDH Object string representation(required)</span>
<span class="line-modified">!  * @param counter_name  a PDH Counter string representation(required)</span>
<span class="line-modified">!  * @param image_name    a process image name string, ex. &quot;java&quot; (opt)</span>
<span class="line-modified">!  * @param instance      an instance string, ex. &quot;0&quot;, &quot;1&quot;, ... (opt)</span>
<span class="line-modified">!  * @return              the fully qualified PDH counter path.</span>
   *
   * Caller will need a ResourceMark.
   *
   * (PdhMakeCounterPath() seems buggy on concatenating instances, hence this function instead)
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,40 ***</span>
                                                       const char* counter_name,
                                                       const char* image_name = NULL,
                                                       const char* instance = NULL) {
    assert(object_name != NULL, &quot;invariant&quot;);
    assert(counter_name != NULL, &quot;invariant&quot;);
<span class="line-modified">!   size_t full_counter_path_len = strlen(object_name) + strlen(counter_name);</span>
  
<span class="line-modified">!   char* full_counter_path;</span>
    size_t jio_snprintf_result = 0;
    if (image_name) {
      /*
      * For paths using the &quot;Process&quot; Object.
      *
      * Examples:
      * form:   &quot;\object_name(image_name#instance)\counter_name&quot;
      * actual: &quot;\Process(java#2)\ID Process&quot;
      */
<span class="line-modified">!     full_counter_path_len += PROCESS_OBJECT_INSTANCE_COUNTER_FMT_LEN;</span>
<span class="line-modified">!     full_counter_path_len += strlen(image_name);</span>
      /*
      * image_name must be passed together with an associated
      * instance &quot;number&quot; (&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, ...).
      * This is required in order to create valid &quot;Process&quot; Object paths.
      *
      * Examples: &quot;\Process(java#0)&quot;, \Process(java#1&quot;), ...
      */
      assert(instance != NULL, &quot;invariant&quot;);
<span class="line-modified">!     full_counter_path_len += strlen(instance);</span>
<span class="line-modified">!     full_counter_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, full_counter_path_len + 1);</span>
<span class="line-modified">!     if (full_counter_path == NULL) {</span>
<span class="line-modified">!       return NULL;</span>
<span class="line-modified">!     }</span>
<span class="line-removed">-     jio_snprintf_result = jio_snprintf(full_counter_path,</span>
<span class="line-removed">-                                        full_counter_path_len + 1,</span>
<span class="line-removed">-                                        PROCESS_OBJECT_INSTANCE_COUNTER_FMT,</span>
                                         object_name,
                                         image_name,
                                         instance,
                                         counter_name);
    } else {
<span class="line-new-header">--- 537,37 ---</span>
                                                       const char* counter_name,
                                                       const char* image_name = NULL,
                                                       const char* instance = NULL) {
    assert(object_name != NULL, &quot;invariant&quot;);
    assert(counter_name != NULL, &quot;invariant&quot;);
<span class="line-modified">!   size_t counter_path_len = strlen(object_name) + strlen(counter_name);</span>
  
<span class="line-modified">!   char* counter_path;</span>
    size_t jio_snprintf_result = 0;
    if (image_name) {
      /*
      * For paths using the &quot;Process&quot; Object.
      *
      * Examples:
      * form:   &quot;\object_name(image_name#instance)\counter_name&quot;
      * actual: &quot;\Process(java#2)\ID Process&quot;
      */
<span class="line-modified">!     counter_path_len += PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN;</span>
<span class="line-modified">!     counter_path_len += strlen(image_name);</span>
      /*
      * image_name must be passed together with an associated
      * instance &quot;number&quot; (&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, ...).
      * This is required in order to create valid &quot;Process&quot; Object paths.
      *
      * Examples: &quot;\Process(java#0)&quot;, \Process(java#1&quot;), ...
      */
      assert(instance != NULL, &quot;invariant&quot;);
<span class="line-modified">!     counter_path_len += strlen(instance);</span>
<span class="line-modified">!     counter_path = NEW_RESOURCE_ARRAY(char, counter_path_len + 1);</span>
<span class="line-modified">!     jio_snprintf_result = jio_snprintf(counter_path,</span>
<span class="line-modified">!                                        counter_path_len + 1,</span>
<span class="line-modified">!                                        PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT,</span>
                                         object_name,
                                         image_name,
                                         instance,
                                         counter_name);
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,43 ***</span>
        *
        * Examples:
        * form:   &quot;\object_name(instance)\counter_name&quot;
        * actual: &quot;\Processor(0)\% Privileged Time&quot;
        */
<span class="line-modified">!       full_counter_path_len += strlen(instance);</span>
<span class="line-modified">!       full_counter_path_len += OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN;</span>
      } else {
        /*
        * For &quot;normal&quot; paths.
        *
        * Examples:
        * form:   &quot;\object_name\counter_name&quot;
        * actual: &quot;\Memory\Available Mbytes&quot;
        */
<span class="line-modified">!       full_counter_path_len += OBJECT_COUNTER_FMT_LEN;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     full_counter_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, full_counter_path_len + 1);</span>
<span class="line-removed">-     if (full_counter_path == NULL) {</span>
<span class="line-removed">-       return NULL;</span>
      }
      if (instance) {
<span class="line-modified">!       jio_snprintf_result = jio_snprintf(full_counter_path,</span>
<span class="line-modified">!                                          full_counter_path_len + 1,</span>
                                           OBJECT_WITH_INSTANCES_COUNTER_FMT,
                                           object_name,
                                           instance,
                                           counter_name);
      } else {
<span class="line-modified">!       jio_snprintf_result = jio_snprintf(full_counter_path,</span>
<span class="line-modified">!                                          full_counter_path_len + 1,</span>
                                           OBJECT_COUNTER_FMT,
                                           object_name,
                                           counter_name);
      }
    }
<span class="line-modified">!   assert(full_counter_path_len == jio_snprintf_result, &quot;invariant&quot;);</span>
<span class="line-modified">!   return full_counter_path;</span>
  }
  
  static void log_invalid_pdh_index(DWORD index) {
    log_warning(os)(&quot;Unable to resolve PDH index: (%ld)&quot;, index);
    log_warning(os)(&quot;Please check the registry if this performance object/counter is disabled&quot;);
<span class="line-new-header">--- 577,40 ---</span>
        *
        * Examples:
        * form:   &quot;\object_name(instance)\counter_name&quot;
        * actual: &quot;\Processor(0)\% Privileged Time&quot;
        */
<span class="line-modified">!       counter_path_len += strlen(instance);</span>
<span class="line-modified">!       counter_path_len += OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN;</span>
      } else {
        /*
        * For &quot;normal&quot; paths.
        *
        * Examples:
        * form:   &quot;\object_name\counter_name&quot;
        * actual: &quot;\Memory\Available Mbytes&quot;
        */
<span class="line-modified">!       counter_path_len += OBJECT_COUNTER_FMT_LEN;</span>
      }
<span class="line-added">+     counter_path = NEW_RESOURCE_ARRAY(char, counter_path_len + 1);</span>
      if (instance) {
<span class="line-modified">!       jio_snprintf_result = jio_snprintf(counter_path,</span>
<span class="line-modified">!                                          counter_path_len + 1,</span>
                                           OBJECT_WITH_INSTANCES_COUNTER_FMT,
                                           object_name,
                                           instance,
                                           counter_name);
      } else {
<span class="line-modified">!       jio_snprintf_result = jio_snprintf(counter_path,</span>
<span class="line-modified">!                                          counter_path_len + 1,</span>
                                           OBJECT_COUNTER_FMT,
                                           object_name,
                                           counter_name);
      }
    }
<span class="line-modified">!   assert(counter_path_len == jio_snprintf_result, &quot;invariant&quot;);</span>
<span class="line-modified">!   return counter_path;</span>
  }
  
  static void log_invalid_pdh_index(DWORD index) {
    log_warning(os)(&quot;Unable to resolve PDH index: (%ld)&quot;, index);
    log_warning(os)(&quot;Please check the registry if this performance object/counter is disabled&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,11 ***</span>
   * Maps an index to a resource area allocated string for the localized PDH artifact.
   *
   * Caller will need a ResourceMark.
   *
   * @param index    the counter index as specified in the registry
<span class="line-modified">!  * @param ppBuffer pointer to a char*</span>
   * @return         OS_OK if successful, OS_ERR on failure.
   */
  static OSReturn lookup_name_by_index(DWORD index, char** p_string) {
    assert(p_string != NULL, &quot;invariant&quot;);
    if (!is_valid_pdh_index(index)) {
<span class="line-new-header">--- 629,11 ---</span>
   * Maps an index to a resource area allocated string for the localized PDH artifact.
   *
   * Caller will need a ResourceMark.
   *
   * @param index    the counter index as specified in the registry
<span class="line-modified">!  * @param p_string pointer to a char*</span>
   * @return         OS_OK if successful, OS_ERR on failure.
   */
  static OSReturn lookup_name_by_index(DWORD index, char** p_string) {
    assert(p_string != NULL, &quot;invariant&quot;);
    if (!is_valid_pdh_index(index)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,14 ***</span>
    }
    // determine size needed
    DWORD size = 0;
    PDH_STATUS status = PdhDll::PdhLookupPerfNameByIndex(NULL, index, NULL, &amp;size);
    assert(status == PDH_MORE_DATA, &quot;invariant&quot;);
<span class="line-modified">!   *p_string = NEW_RESOURCE_ARRAY_RETURN_NULL(char, size);</span>
<span class="line-removed">-   if (*p_string== NULL) {</span>
<span class="line-removed">-     return OS_ERR;</span>
<span class="line-removed">-   }</span>
    if (PdhDll::PdhLookupPerfNameByIndex(NULL, index, *p_string, &amp;size) != ERROR_SUCCESS) {
      return OS_ERR;
    }
    if (0 == size || *p_string == NULL) {
      return OS_ERR;
<span class="line-new-header">--- 641,11 ---</span>
    }
    // determine size needed
    DWORD size = 0;
    PDH_STATUS status = PdhDll::PdhLookupPerfNameByIndex(NULL, index, NULL, &amp;size);
    assert(status == PDH_MORE_DATA, &quot;invariant&quot;);
<span class="line-modified">!   *p_string = NEW_RESOURCE_ARRAY(char, size);</span>
    if (PdhDll::PdhLookupPerfNameByIndex(NULL, index, *p_string, &amp;size) != ERROR_SUCCESS) {
      return OS_ERR;
    }
    if (0 == size || *p_string == NULL) {
      return OS_ERR;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 592,30 ***</span>
  }
  
  static const char* copy_string_to_c_heap(const char* string) {
    assert(string != NULL, &quot;invariant&quot;);
    const size_t len = strlen(string);
<span class="line-modified">!   char* const cheap_allocated_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len + 1, mtInternal);</span>
<span class="line-removed">-   if (NULL == cheap_allocated_string) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
    strncpy(cheap_allocated_string, string, len + 1);
    return cheap_allocated_string;
  }
  
  /*
<span class="line-modified">! * Maps an index to a resource area allocated string for the localized PDH artifact.</span>
  *
  * Caller will need a ResourceMark.
  *
<span class="line-modified">! * @param index    the counter index as specified in the registry</span>
<span class="line-modified">! * @return         localized pdh artifact string if successful, NULL on failure.</span>
  */
<span class="line-modified">! static const char* pdh_localized_artifact(DWORD pdh_artifact_index) {</span>
    char* pdh_localized_artifact_string = NULL;
<span class="line-modified">!   // get localized name from pdh artifact index</span>
<span class="line-modified">!   if (lookup_name_by_index(pdh_artifact_index, &amp;pdh_localized_artifact_string) != OS_OK) {</span>
      return NULL;
    }
    return pdh_localized_artifact_string;
  }
  
<span class="line-new-header">--- 656,27 ---</span>
  }
  
  static const char* copy_string_to_c_heap(const char* string) {
    assert(string != NULL, &quot;invariant&quot;);
    const size_t len = strlen(string);
<span class="line-modified">!   char* const cheap_allocated_string = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
    strncpy(cheap_allocated_string, string, len + 1);
    return cheap_allocated_string;
  }
  
  /*
<span class="line-modified">! * Maps a pdh artifact index to a resource area allocated string representing a localized name.</span>
  *
  * Caller will need a ResourceMark.
  *
<span class="line-modified">! * @param pdh_artifact_idx   the counter index as specified in the registry</span>
<span class="line-modified">! * @return                   localized pdh artifact string if successful, NULL on failure.</span>
  */
<span class="line-modified">! static const char* pdh_localized_artifact(DWORD pdh_artifact_idx) {</span>
    char* pdh_localized_artifact_string = NULL;
<span class="line-modified">!   // get localized name for the pdh artifact idx</span>
<span class="line-modified">!   if (lookup_name_by_index(pdh_artifact_idx, &amp;pdh_localized_artifact_string) != OS_OK) {</span>
      return NULL;
    }
    return pdh_localized_artifact_string;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,17 ***</span>
   * Ex. &quot;Process(java#0)\Virtual Bytes&quot; - where &quot;java&quot; is the PDH process
   * image description.
   *
   * Caller needs ResourceMark.
   *
<span class="line-modified">!  * @return the process image description. NULL if the call failed.</span>
  */
  static const char* pdh_process_image_name() {
<span class="line-modified">!   char* module_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, MAX_PATH);</span>
<span class="line-removed">-   if (NULL == module_name) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
    // Find our module name and use it to extract the image name used by PDH
    DWORD getmfn_return = GetModuleFileName(NULL, module_name, MAX_PATH);
    if (getmfn_return &gt;= MAX_PATH || 0 == getmfn_return) {
      return NULL;
    }
<span class="line-new-header">--- 687,14 ---</span>
   * Ex. &quot;Process(java#0)\Virtual Bytes&quot; - where &quot;java&quot; is the PDH process
   * image description.
   *
   * Caller needs ResourceMark.
   *
<span class="line-modified">!  * @return the process image string description, NULL if the call failed.</span>
  */
  static const char* pdh_process_image_name() {
<span class="line-modified">!   char* module_name = NEW_RESOURCE_ARRAY(char, MAX_PATH);</span>
    // Find our module name and use it to extract the image name used by PDH
    DWORD getmfn_return = GetModuleFileName(NULL, module_name, MAX_PATH);
    if (getmfn_return &gt;= MAX_PATH || 0 == getmfn_return) {
      return NULL;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 651,15 ***</span>
  }
  
  static void deallocate_pdh_constants() {
    FREE_C_HEAP_ARRAY(char, process_image_name);
    process_image_name = NULL;
<span class="line-modified">!   FREE_C_HEAP_ARRAY(char, pdh_IDProcess_counter_fmt);</span>
<span class="line-modified">!   pdh_IDProcess_counter_fmt = NULL;</span>
  }
  
<span class="line-modified">! static int allocate_pdh_constants() {</span>
    assert(process_image_name == NULL, &quot;invariant&quot;);
    const char* pdh_image_name = pdh_process_image_name();
    if (pdh_image_name == NULL) {
      return OS_ERR;
    }
<span class="line-new-header">--- 709,17 ---</span>
  }
  
  static void deallocate_pdh_constants() {
    FREE_C_HEAP_ARRAY(char, process_image_name);
    process_image_name = NULL;
<span class="line-modified">!   FREE_C_HEAP_ARRAY(char, pdh_process_instance_IDProcess_counter_fmt);</span>
<span class="line-modified">!   pdh_process_instance_IDProcess_counter_fmt = NULL;</span>
<span class="line-added">+   FREE_C_HEAP_ARRAY(char, pdh_process_instance_wildcard_IDProcess_counter);</span>
<span class="line-added">+   pdh_process_instance_wildcard_IDProcess_counter = NULL;</span>
  }
  
<span class="line-modified">! static OSReturn allocate_pdh_constants() {</span>
    assert(process_image_name == NULL, &quot;invariant&quot;);
    const char* pdh_image_name = pdh_process_image_name();
    if (pdh_image_name == NULL) {
      return OS_ERR;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 673,33 ***</span>
    const char* pdh_localized_IDProcess_counter = pdh_localized_artifact(PDH_ID_PROCESS_IDX);
    if (pdh_localized_IDProcess_counter == NULL) {
      return OS_ERR;
    }
  
<span class="line-modified">!   size_t pdh_IDProcess_counter_fmt_len = strlen(process_image_name);</span>
<span class="line-modified">!   pdh_IDProcess_counter_fmt_len += strlen(pdh_localized_process_object);</span>
<span class="line-modified">!   pdh_IDProcess_counter_fmt_len += strlen(pdh_localized_IDProcess_counter);</span>
<span class="line-removed">-   pdh_IDProcess_counter_fmt_len += PROCESS_OBJECT_INSTANCE_COUNTER_FMT_LEN;</span>
<span class="line-removed">-   pdh_IDProcess_counter_fmt_len += 2; // &quot;%d&quot;</span>
  
<span class="line-modified">!   assert(pdh_IDProcess_counter_fmt == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   pdh_IDProcess_counter_fmt = NEW_C_HEAP_ARRAY_RETURN_NULL(char, pdh_IDProcess_counter_fmt_len + 1, mtInternal);</span>
<span class="line-modified">!   if (pdh_IDProcess_counter_fmt == NULL) {</span>
<span class="line-modified">!     return OS_ERR;</span>
<span class="line-modified">!   }</span>
  
    /* &quot;\Process(java#%d)\ID Process&quot; */
<span class="line-modified">!   const size_t len = jio_snprintf(pdh_IDProcess_counter_fmt,</span>
<span class="line-modified">!                                   pdh_IDProcess_counter_fmt_len + 1,</span>
<span class="line-modified">!                                   PROCESS_OBJECT_INSTANCE_COUNTER_FMT,</span>
<span class="line-modified">!                                   pdh_localized_process_object,</span>
<span class="line-modified">!                                   process_image_name,</span>
<span class="line-modified">!                                   &quot;%d&quot;,</span>
<span class="line-modified">!                                   pdh_localized_IDProcess_counter);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert(pdh_IDProcess_counter_fmt != NULL, &quot;invariant&quot;);</span>
    assert(len == pdh_IDProcess_counter_fmt_len, &quot;invariant&quot;);
    return OS_OK;
  }
  
  /*
   * Enuerate the Processor PDH object and returns a buffer containing the enumerated instances.
<span class="line-new-header">--- 733,50 ---</span>
    const char* pdh_localized_IDProcess_counter = pdh_localized_artifact(PDH_ID_PROCESS_IDX);
    if (pdh_localized_IDProcess_counter == NULL) {
      return OS_ERR;
    }
  
<span class="line-modified">!   const size_t id_process_base_length = strlen(process_image_name) +</span>
<span class="line-modified">!                                         strlen(pdh_localized_process_object) +</span>
<span class="line-modified">!                                         strlen(pdh_localized_IDProcess_counter);</span>
  
<span class="line-modified">!   const size_t pdh_IDProcess_counter_fmt_len = id_process_base_length +</span>
<span class="line-modified">!                                                PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN +</span>
<span class="line-modified">!                                                2; // &quot;%d&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert(pdh_process_instance_IDProcess_counter_fmt == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   pdh_process_instance_IDProcess_counter_fmt = NEW_C_HEAP_ARRAY(char, pdh_IDProcess_counter_fmt_len + 1, mtInternal);</span>
  
    /* &quot;\Process(java#%d)\ID Process&quot; */
<span class="line-modified">!   size_t len = jio_snprintf(pdh_process_instance_IDProcess_counter_fmt,</span>
<span class="line-modified">!                             pdh_IDProcess_counter_fmt_len + 1,</span>
<span class="line-modified">!                             PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT,</span>
<span class="line-modified">!                             pdh_localized_process_object,</span>
<span class="line-modified">!                             process_image_name,</span>
<span class="line-modified">!                             &quot;%d&quot;,</span>
<span class="line-modified">!                             pdh_localized_IDProcess_counter);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert(pdh_process_instance_IDProcess_counter_fmt != NULL, &quot;invariant&quot;);</span>
    assert(len == pdh_IDProcess_counter_fmt_len, &quot;invariant&quot;);
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   const size_t pdh_IDProcess_wildcard_fmt_len = id_process_base_length +</span>
<span class="line-added">+                                                 PROCESS_OBJECT_WITH_INSTANCES_WILDCARD_FMT_LEN;</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(pdh_process_instance_wildcard_IDProcess_counter == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   pdh_process_instance_wildcard_IDProcess_counter = NEW_C_HEAP_ARRAY(char, pdh_IDProcess_wildcard_fmt_len + 1, mtInternal);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* &quot;\Process(java*)\ID Process&quot; */</span>
<span class="line-added">+   len = jio_snprintf(pdh_process_instance_wildcard_IDProcess_counter,</span>
<span class="line-added">+                      pdh_IDProcess_wildcard_fmt_len + 1,</span>
<span class="line-added">+                      PROCESS_OBJECT_WITH_INSTANCES_WILDCARD_FMT,</span>
<span class="line-added">+                      pdh_localized_process_object,</span>
<span class="line-added">+                      process_image_name,</span>
<span class="line-added">+                      pdh_localized_IDProcess_counter);</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(pdh_process_instance_wildcard_IDProcess_counter != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(len == pdh_IDProcess_wildcard_fmt_len, &quot;invariant&quot;);</span>
    return OS_OK;
  }
  
  /*
   * Enuerate the Processor PDH object and returns a buffer containing the enumerated instances.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,28 ***</span>
                                                    PERF_DETAIL_WIZARD, // counter detail level
                                                    0);
    if (PdhDll::PdhStatusFail((pdhStat))) {
      return NULL;
    }
<span class="line-modified">!   char* const instances = NEW_RESOURCE_ARRAY_RETURN_NULL(char, i_size);</span>
<span class="line-removed">-   if (instances == NULL) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
    c_size = 0;
    pdhStat = PdhDll::PdhEnumObjectItems(NULL, // reserved
                                         NULL, // local machine
                                         processor, // object to enumerate
                                         NULL,
                                         &amp;c_size,
                                         instances, // now instance buffer is allocated to be filled in
                                         &amp;i_size, // and the required size is known
                                         PERF_DETAIL_WIZARD, // counter detail level
                                         0);
<span class="line-modified">!   if (PdhDll::PdhStatusFail((pdhStat))) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return instances;</span>
  }
  
  static int count_logical_cpus(const char* instances) {
    assert(instances != NULL, &quot;invariant&quot;);
    // count logical instances.
<span class="line-new-header">--- 802,22 ---</span>
                                                    PERF_DETAIL_WIZARD, // counter detail level
                                                    0);
    if (PdhDll::PdhStatusFail((pdhStat))) {
      return NULL;
    }
<span class="line-modified">!   char* const instances = NEW_RESOURCE_ARRAY(char, i_size);</span>
    c_size = 0;
    pdhStat = PdhDll::PdhEnumObjectItems(NULL, // reserved
                                         NULL, // local machine
                                         processor, // object to enumerate
                                         NULL,
                                         &amp;c_size,
                                         instances, // now instance buffer is allocated to be filled in
                                         &amp;i_size, // and the required size is known
                                         PERF_DETAIL_WIZARD, // counter detail level
                                         0);
<span class="line-modified">!   return PdhDll::PdhStatusFail(pdhStat) ? NULL : instances;</span>
  }
  
  static int count_logical_cpus(const char* instances) {
    assert(instances != NULL, &quot;invariant&quot;);
    // count logical instances.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 769,154 ***</span>
    }
    return numberOfCPUS;
  }
  
  static double cpu_factor() {
<span class="line-modified">!   static DWORD  numCpus = 0;</span>
    static double cpuFactor = .0;
    if (numCpus == 0) {
      numCpus = number_of_logical_cpus();
      assert(os::processor_count() &lt;= (int)numCpus, &quot;invariant&quot;);
      cpuFactor = numCpus * 100;
    }
    return cpuFactor;
  }
  
<span class="line-modified">! static void log_error_message_on_no_PDH_artifact(const char* full_counter_name) {</span>
<span class="line-modified">!   log_warning(os)(&quot;Unable to register PDH query for \&quot;%s\&quot;&quot;, full_counter_name);</span>
    log_warning(os)(&quot;Please check the registry if this performance object/counter is disabled&quot;);
  }
  
<span class="line-modified">! static int initialize_cpu_query_counters(MultiCounterQueryP cpu_query, DWORD pdh_counter_idx) {</span>
<span class="line-modified">!   assert(cpu_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(cpu_query-&gt;counters != NULL, &quot;invariant&quot;);</span>
    char* processor; //&#39;Processor&#39; == PDH_PROCESSOR_IDX
    if (lookup_name_by_index(PDH_PROCESSOR_IDX, &amp;processor) != OS_OK) {
      return OS_ERR;
    }
    char* counter_name = NULL;
    if (lookup_name_by_index(pdh_counter_idx, &amp;counter_name) != OS_OK) {
      return OS_ERR;
    }
<span class="line-modified">!   if (cpu_query-&gt;query.query == NULL) {</span>
<span class="line-modified">!     if (open_query(cpu_query)) {</span>
        return OS_ERR;
      }
    }
<span class="line-modified">!   assert(cpu_query-&gt;query.query != NULL, &quot;invariant&quot;);</span>
    size_t counter_len = strlen(processor);
    counter_len += strlen(counter_name);
    counter_len += OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN; // &quot;\\%s(%s)\\%s&quot;
<span class="line-removed">- </span>
<span class="line-removed">-   DWORD index;</span>
<span class="line-removed">-   char* tmp;</span>
    const char* instances = enumerate_cpu_instances();
<span class="line-modified">!   for (index = 0, tmp = const_cast&lt;char*&gt;(instances); *tmp != &#39;\0&#39;; tmp = &amp;tmp[strlen(tmp) + 1], index++) {</span>
      const size_t tmp_len = strlen(tmp);
<span class="line-modified">!     char* counter_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, counter_len + tmp_len + 1);</span>
<span class="line-removed">-     if (counter_path == NULL) {</span>
<span class="line-removed">-       return OS_ERR;</span>
<span class="line-removed">-     }</span>
      const size_t jio_snprintf_result = jio_snprintf(counter_path,
                                                      counter_len + tmp_len + 1,
                                                      OBJECT_WITH_INSTANCES_COUNTER_FMT,
                                                      processor,
                                                      tmp, // instance &quot;0&quot;, &quot;1&quot;, ..&quot;_Total&quot;
                                                      counter_name);
      assert(counter_len + tmp_len == jio_snprintf_result, &quot;invariant&quot;);
<span class="line-modified">!     if (add_counter(cpu_query, &amp;cpu_query-&gt;counters[index], counter_path, false) != OS_OK) {</span>
        // performance counter is disabled in registry and not accessible via PerfLib
        log_error_message_on_no_PDH_artifact(counter_path);
        // return OS_OK to have the system continue to run without the missing counter
        return OS_OK;
      }
    }
<span class="line-removed">-   cpu_query-&gt;initialized = true;</span>
    // Query once to initialize the counters which require at least two samples
    // (like the % CPU usage) to calculate correctly.
<span class="line-modified">!   collect_query_data(cpu_query);</span>
<span class="line-removed">-   return OS_OK;</span>
  }
  
<span class="line-modified">! static int initialize_cpu_query(MultiCounterQueryP cpu_query, DWORD pdh_counter_idx) {</span>
<span class="line-modified">!   assert(cpu_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!cpu_query-&gt;initialized, &quot;invariant&quot;);</span>
    const int logical_cpu_count = number_of_logical_cpus();
    assert(logical_cpu_count &gt;= os::processor_count(), &quot;invariant&quot;);
    // we also add another counter for instance &quot;_Total&quot;
<span class="line-modified">!   allocate_counters(cpu_query, logical_cpu_count + 1);</span>
<span class="line-modified">!   assert(cpu_query-&gt;noOfCounters == logical_cpu_count + 1, &quot;invariant&quot;);</span>
<span class="line-modified">!   return initialize_cpu_query_counters(cpu_query, pdh_counter_idx);</span>
  }
  
<span class="line-modified">! static int initialize_process_counter(ProcessQueryP process_query, int slot_index, DWORD pdh_counter_index) {</span>
    char* localized_process_object;
    if (lookup_name_by_index(PDH_PROCESS_IDX, &amp;localized_process_object) != OS_OK) {
      return OS_ERR;
    }
    assert(localized_process_object != NULL, &quot;invariant&quot;);
    char* localized_counter_name;
<span class="line-modified">!   if (lookup_name_by_index(pdh_counter_index, &amp;localized_counter_name) != OS_OK) {</span>
      return OS_ERR;
    }
    assert(localized_counter_name != NULL, &quot;invariant&quot;);
    for (int i = 0; i &lt; process_query-&gt;set.size; ++i) {
      char instanceIndexBuffer[32];
      const char* counter_path = make_fully_qualified_counter_path(localized_process_object,
                                                                   localized_counter_name,
                                                                   process_image_name,
                                                                   itoa(i, instanceIndexBuffer, 10));
<span class="line-modified">!     if (counter_path == NULL) {</span>
<span class="line-removed">-       return OS_ERR;</span>
<span class="line-removed">-     }</span>
      MultiCounterQueryP const query = &amp;process_query-&gt;set.queries[i];
<span class="line-modified">!     if (add_process_counter(query, slot_index, counter_path, true)) {</span>
        return OS_ERR;
      }
    }
    return OS_OK;
  }
  
<span class="line-modified">! static CounterQueryP create_counter_query(DWORD pdh_object_idx, DWORD pdh_counter_idx) {</span>
<span class="line-modified">!   if (!((is_valid_pdh_index(pdh_object_idx) &amp;&amp; is_valid_pdh_index(pdh_counter_idx)))) {</span>
<span class="line-modified">!     return NULL;</span>
    }
<span class="line-modified">!   CounterQueryP const query = create_counter_query();</span>
<span class="line-modified">!   const char* object = pdh_localized_artifact(pdh_object_idx);</span>
<span class="line-modified">!   assert(object != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   const char* counter = pdh_localized_artifact(pdh_counter_idx);</span>
<span class="line-modified">!   assert(counter != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   const char* full_counter_path = make_fully_qualified_counter_path(object, counter);</span>
<span class="line-removed">-   assert(full_counter_path != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   add_counter(query, full_counter_path, true);</span>
<span class="line-removed">-   return query;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void deallocate() {</span>
<span class="line-removed">-   deallocate_pdh_constants();</span>
<span class="line-removed">-   PdhDll::PdhDetach();</span>
  }
  
<span class="line-modified">! static LONG critical_section = 0;</span>
<span class="line-removed">- static LONG reference_count = 0;</span>
  static bool pdh_initialized = false;
  
  static void on_initialization_failure() {
<span class="line-modified">!   // still holder of critical section</span>
<span class="line-modified">!   deallocate();</span>
<span class="line-modified">!   InterlockedExchangeAdd(&amp;reference_count, -1);</span>
  }
  
  static OSReturn initialize() {
    ResourceMark rm;
    if (!PdhDll::PdhAttach()) {
      return OS_ERR;
    }
    if (allocate_pdh_constants() != OS_OK) {
      on_initialization_failure();
      return OS_ERR;
    }
    return OS_OK;
  }
  
  /*
  * Helper to initialize the PDH library, function pointers, constants and counters.
<span class="line-new-header">--- 840,210 ---</span>
    }
    return numberOfCPUS;
  }
  
  static double cpu_factor() {
<span class="line-modified">!   static DWORD numCpus = 0;</span>
    static double cpuFactor = .0;
    if (numCpus == 0) {
      numCpus = number_of_logical_cpus();
      assert(os::processor_count() &lt;= (int)numCpus, &quot;invariant&quot;);
      cpuFactor = numCpus * 100;
    }
    return cpuFactor;
  }
  
<span class="line-modified">! static void log_error_message_on_no_PDH_artifact(const char* counter_path) {</span>
<span class="line-modified">!   log_warning(os)(&quot;Unable to register PDH query for \&quot;%s\&quot;&quot;, counter_path);</span>
    log_warning(os)(&quot;Please check the registry if this performance object/counter is disabled&quot;);
  }
  
<span class="line-modified">! static int initialize_cpu_query_counters(MultiCounterQueryP query, DWORD pdh_counter_idx) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(query-&gt;counters != NULL, &quot;invariant&quot;);</span>
    char* processor; //&#39;Processor&#39; == PDH_PROCESSOR_IDX
    if (lookup_name_by_index(PDH_PROCESSOR_IDX, &amp;processor) != OS_OK) {
      return OS_ERR;
    }
    char* counter_name = NULL;
    if (lookup_name_by_index(pdh_counter_idx, &amp;counter_name) != OS_OK) {
      return OS_ERR;
    }
<span class="line-modified">!   if (query-&gt;query.pdh_query_handle == NULL) {</span>
<span class="line-modified">!     if (open_query(query) != OS_OK) {</span>
        return OS_ERR;
      }
    }
<span class="line-modified">!   assert(query-&gt;query.pdh_query_handle != NULL, &quot;invariant&quot;);</span>
    size_t counter_len = strlen(processor);
    counter_len += strlen(counter_name);
    counter_len += OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN; // &quot;\\%s(%s)\\%s&quot;
    const char* instances = enumerate_cpu_instances();
<span class="line-modified">!   DWORD index = 0;</span>
<span class="line-added">+   for (char* tmp = const_cast&lt;char*&gt;(instances); *tmp != &#39;\0&#39;; tmp = &amp;tmp[strlen(tmp) + 1], index++) {</span>
      const size_t tmp_len = strlen(tmp);
<span class="line-modified">!     char* counter_path = NEW_RESOURCE_ARRAY(char, counter_len + tmp_len + 1);</span>
      const size_t jio_snprintf_result = jio_snprintf(counter_path,
                                                      counter_len + tmp_len + 1,
                                                      OBJECT_WITH_INSTANCES_COUNTER_FMT,
                                                      processor,
                                                      tmp, // instance &quot;0&quot;, &quot;1&quot;, ..&quot;_Total&quot;
                                                      counter_name);
      assert(counter_len + tmp_len == jio_snprintf_result, &quot;invariant&quot;);
<span class="line-modified">!     if (add_counter(query, &amp;query-&gt;counters[index], counter_path, false) != OS_OK) {</span>
        // performance counter is disabled in registry and not accessible via PerfLib
        log_error_message_on_no_PDH_artifact(counter_path);
        // return OS_OK to have the system continue to run without the missing counter
        return OS_OK;
      }
    }
    // Query once to initialize the counters which require at least two samples
    // (like the % CPU usage) to calculate correctly.
<span class="line-modified">!   return PdhDll::PdhCollectQueryData(query-&gt;query.pdh_query_handle) != ERROR_SUCCESS ? OS_ERR : OS_OK;</span>
  }
  
<span class="line-modified">! static int initialize_cpu_query(MultiCounterQueryP query) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!query-&gt;initialized, &quot;invariant&quot;);</span>
    const int logical_cpu_count = number_of_logical_cpus();
    assert(logical_cpu_count &gt;= os::processor_count(), &quot;invariant&quot;);
    // we also add another counter for instance &quot;_Total&quot;
<span class="line-modified">!   allocate_counters(query, logical_cpu_count + 1);</span>
<span class="line-modified">!   assert(query-&gt;noOfCounters == logical_cpu_count + 1, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (initialize_cpu_query_counters(query, PDH_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-added">+     return OS_ERR;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   query-&gt;initialized = true;</span>
<span class="line-added">+   return OS_OK;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int initialize_query(CounterQueryP query, DWORD pdh_object_idx, DWORD pdh_counter_idx) {</span>
<span class="line-added">+   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(!query-&gt;initialized, &quot;invariant&quot;);</span>
<span class="line-added">+   if (!((is_valid_pdh_index(pdh_object_idx) &amp;&amp; is_valid_pdh_index(pdh_counter_idx)))) {</span>
<span class="line-added">+     return OS_ERR;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   const char* object = pdh_localized_artifact(pdh_object_idx);</span>
<span class="line-added">+   assert(object != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   const char* counter = pdh_localized_artifact(pdh_counter_idx);</span>
<span class="line-added">+   assert(counter != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   const char* counter_path = make_fully_qualified_counter_path(object, counter);</span>
<span class="line-added">+   assert(counter_path != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (add_counter(query, counter_path, true) != OS_OK) {</span>
<span class="line-added">+     return OS_ERR;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   query-&gt;initialized = true;</span>
<span class="line-added">+   return OS_OK;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int initialize_context_switches_query(CounterQueryP query) {</span>
<span class="line-added">+   return initialize_query(query, PDH_SYSTEM_IDX, PDH_CONTEXT_SWITCH_RATE_IDX);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static ProcessQueryP create_process_query() {</span>
<span class="line-added">+   const int current_process_query_idx = current_process_query_index();</span>
<span class="line-added">+   if (current_process_query_idx == OS_ERR) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ProcessQueryP const query = NEW_C_HEAP_OBJ(ProcessQueryS, mtInternal);</span>
<span class="line-added">+   memset(query, 0, sizeof(ProcessQueryS));</span>
<span class="line-added">+   query-&gt;process_idx = current_process_query_idx;</span>
<span class="line-added">+   const int size = current_process_query_idx + 1;</span>
<span class="line-added">+   query-&gt;set.queries = NEW_C_HEAP_ARRAY(MultiCounterQueryS, size, mtInternal);</span>
<span class="line-added">+   memset(query-&gt;set.queries, 0, sizeof(MultiCounterQueryS) * size);</span>
<span class="line-added">+   query-&gt;set.size = size;</span>
<span class="line-added">+   return query;</span>
  }
  
<span class="line-modified">! static int initialize_process_counter(ProcessQueryP process_query, int counter_idx, DWORD pdh_counter_idx) {</span>
    char* localized_process_object;
    if (lookup_name_by_index(PDH_PROCESS_IDX, &amp;localized_process_object) != OS_OK) {
      return OS_ERR;
    }
    assert(localized_process_object != NULL, &quot;invariant&quot;);
    char* localized_counter_name;
<span class="line-modified">!   if (lookup_name_by_index(pdh_counter_idx, &amp;localized_counter_name) != OS_OK) {</span>
      return OS_ERR;
    }
    assert(localized_counter_name != NULL, &quot;invariant&quot;);
    for (int i = 0; i &lt; process_query-&gt;set.size; ++i) {
      char instanceIndexBuffer[32];
      const char* counter_path = make_fully_qualified_counter_path(localized_process_object,
                                                                   localized_counter_name,
                                                                   process_image_name,
                                                                   itoa(i, instanceIndexBuffer, 10));
<span class="line-modified">!     assert(counter_path != NULL, &quot;invariant&quot;);</span>
      MultiCounterQueryP const query = &amp;process_query-&gt;set.queries[i];
<span class="line-modified">!     if (add_counter(query, counter_idx, counter_path, true) != OS_OK) {</span>
        return OS_ERR;
      }
<span class="line-added">+     if (counter_idx + 1 == query-&gt;noOfCounters) {</span>
<span class="line-added">+       // last counter in query implies query initialized</span>
<span class="line-added">+       query-&gt;initialized = true;</span>
<span class="line-added">+     }</span>
    }
    return OS_OK;
  }
  
<span class="line-modified">! static int initialize_process_query(ProcessQueryP query) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!query-&gt;set.initialized, &quot;invariant&quot;);</span>
<span class="line-added">+   allocate_counters(query, 2);</span>
<span class="line-added">+   if (initialize_process_counter(query, 0, PDH_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-added">+     return OS_ERR;</span>
    }
<span class="line-modified">!   if (initialize_process_counter(query, 1, PDH_PRIV_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-modified">!     return OS_ERR;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   query-&gt;set.initialized = true;</span>
<span class="line-modified">!   return OS_OK;</span>
  }
  
<span class="line-modified">! static int reference_count = 0;</span>
  static bool pdh_initialized = false;
  
<span class="line-added">+ class PdhMutex : public StackObj {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   static Semaphore _semaphore;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   PdhMutex() {</span>
<span class="line-added">+     _semaphore.wait();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ~PdhMutex() {</span>
<span class="line-added">+     _semaphore.signal();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ Semaphore PdhMutex::_semaphore(1);</span>
<span class="line-added">+ </span>
  static void on_initialization_failure() {
<span class="line-modified">!   // still holder of mutex</span>
<span class="line-modified">!   assert(max_process_query_idx == 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   deallocate_pdh_constants();</span>
<span class="line-added">+   --reference_count;</span>
<span class="line-added">+   PdhDll::PdhDetach();</span>
  }
  
  static OSReturn initialize() {
<span class="line-added">+   // still holder of mutex</span>
    ResourceMark rm;
    if (!PdhDll::PdhAttach()) {
      return OS_ERR;
    }
    if (allocate_pdh_constants() != OS_OK) {
      on_initialization_failure();
      return OS_ERR;
    }
<span class="line-added">+   // Take a snapshot of the current number of live processes (including ourselves)</span>
<span class="line-added">+   // with the same name, e.g. &quot;java&quot;, in order to derive a value for max_process_query_idx.</span>
<span class="line-added">+   const int process_instance_count = number_of_live_process_instances();</span>
<span class="line-added">+   if (process_instance_count == OS_ERR) {</span>
<span class="line-added">+     on_initialization_failure();</span>
<span class="line-added">+     return OS_ERR;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(process_instance_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-added">+   max_process_query_idx = process_instance_count - 1;</span>
    return OS_OK;
  }
  
  /*
  * Helper to initialize the PDH library, function pointers, constants and counters.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 926,32 ***</span>
  *   pdh_acquire();
  *   pdh_release();
  *
  * @return  OS_OK if successful, OS_ERR on failure.
  */
<span class="line-modified">! static bool pdh_acquire() {</span>
<span class="line-modified">!   while (InterlockedCompareExchange(&amp;critical_section, 1, 0) == 1);</span>
<span class="line-modified">!   InterlockedExchangeAdd(&amp;reference_count, 1);</span>
    if (pdh_initialized) {
<span class="line-modified">!     return true;</span>
    }
<span class="line-modified">!   const OSReturn ret = initialize();</span>
<span class="line-modified">!   if (OS_OK == ret) {</span>
<span class="line-modified">!     pdh_initialized = true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   while (InterlockedCompareExchange(&amp;critical_section, 0, 1) == 0);</span>
<span class="line-removed">-   return ret == OS_OK;</span>
  }
  
  static void pdh_release() {
<span class="line-modified">!   while (InterlockedCompareExchange(&amp;critical_section, 1, 0) == 1);</span>
<span class="line-modified">!   const LONG prev_ref_count = InterlockedExchangeAdd(&amp;reference_count, -1);</span>
<span class="line-modified">!   if (1 == prev_ref_count) {</span>
<span class="line-modified">!     deallocate();</span>
      pdh_initialized = false;
    }
<span class="line-removed">-   while (InterlockedCompareExchange(&amp;critical_section, 0, 1) == 0);</span>
  }
  
  class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
    friend class CPUPerformanceInterface;
   private:
<span class="line-new-header">--- 1053,28 ---</span>
  *   pdh_acquire();
  *   pdh_release();
  *
  * @return  OS_OK if successful, OS_ERR on failure.
  */
<span class="line-modified">! static OSReturn pdh_acquire() {</span>
<span class="line-modified">!   PdhMutex mutex;</span>
<span class="line-modified">!   reference_count++;</span>
    if (pdh_initialized) {
<span class="line-modified">!     return OS_OK;</span>
    }
<span class="line-modified">!   const OSReturn status = initialize();</span>
<span class="line-modified">!   pdh_initialized = status == OS_OK;</span>
<span class="line-modified">!   return status;</span>
  }
  
  static void pdh_release() {
<span class="line-modified">!   PdhMutex mutex;</span>
<span class="line-modified">!   if (1 == reference_count--) {</span>
<span class="line-modified">!     deallocate_pdh_constants();</span>
<span class="line-modified">!     PdhDll::PdhDetach();</span>
      pdh_initialized = false;
    }
  }
  
  class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
    friend class CPUPerformanceInterface;
   private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 960,92 ***</span>
    MultiCounterQueryP _machine_cpu_load;
  
    int cpu_load(int which_logical_cpu, double* cpu_load);
    int context_switch_rate(double* rate);
    int cpu_load_total_process(double* cpu_load);
<span class="line-modified">!   int cpu_loads_process(double* jvm_user_load, double* jvm_kernel_load, double* psystemTotalLoad);</span>
    CPUPerformance();
    ~CPUPerformance();
    bool initialize();
  };
  
<span class="line-removed">- class SystemProcessInterface::SystemProcesses : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-removed">-   friend class SystemProcessInterface;</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   class ProcessIterator : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-removed">-     friend class SystemProcessInterface::SystemProcesses;</span>
<span class="line-removed">-    private:</span>
<span class="line-removed">-     HANDLE         _hProcessSnap;</span>
<span class="line-removed">-     PROCESSENTRY32 _pe32;</span>
<span class="line-removed">-     BOOL           _valid;</span>
<span class="line-removed">-     char           _exePath[MAX_PATH];</span>
<span class="line-removed">-     ProcessIterator();</span>
<span class="line-removed">-     ~ProcessIterator();</span>
<span class="line-removed">-     bool initialize();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int current(SystemProcess* const process_info);</span>
<span class="line-removed">-     int next_process();</span>
<span class="line-removed">-     bool is_valid() const { return _valid != FALSE; }</span>
<span class="line-removed">-     char* allocate_string(const char* str) const;</span>
<span class="line-removed">-     int snapshot();</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ProcessIterator* _iterator;</span>
<span class="line-removed">-   SystemProcesses();</span>
<span class="line-removed">-   ~SystemProcesses();</span>
<span class="line-removed">-   bool initialize();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // information about system processes</span>
<span class="line-removed">-   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  CPUPerformanceInterface::CPUPerformance::CPUPerformance() : _context_switches(NULL), _process_cpu_load(NULL), _machine_cpu_load(NULL) {}
  
  bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified">!   if (!pdh_acquire()) {</span>
<span class="line-modified">!     return true;</span>
    }
<span class="line-modified">!   _context_switches = create_counter_query(PDH_SYSTEM_IDX, PDH_CONTEXT_SWITCH_RATE_IDX);</span>
    _process_cpu_load = create_process_query();
    if (_process_cpu_load == NULL) {
<span class="line-modified">!     return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   allocate_counters(_process_cpu_load, 2);</span>
<span class="line-removed">-   if (initialize_process_counter(_process_cpu_load, 0, PDH_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-removed">-     return true;</span>
    }
<span class="line-modified">!   if (initialize_process_counter(_process_cpu_load, 1, PDH_PRIV_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-modified">!     return true;</span>
    }
<span class="line-modified">!   _process_cpu_load-&gt;set.initialized = true;</span>
    _machine_cpu_load = create_multi_counter_query();
<span class="line-modified">!   if (_machine_cpu_load == NULL) {</span>
<span class="line-modified">!     return true;</span>
    }
<span class="line-modified">!   initialize_cpu_query(_machine_cpu_load, PDH_PROCESSOR_TIME_IDX);</span>
    return true;
  }
  
  CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
    if (_context_switches != NULL) {
<span class="line-modified">!     destroy_counter_query(_context_switches);</span>
      _context_switches = NULL;
    }
    if (_process_cpu_load != NULL) {
<span class="line-modified">!     destroy_counter_query(_process_cpu_load);</span>
      _process_cpu_load = NULL;
    }
    if (_machine_cpu_load != NULL) {
<span class="line-modified">!     destroy_counter_query(_machine_cpu_load);</span>
      _machine_cpu_load = NULL;
    }
    pdh_release();
  }
  
<span class="line-modified">! CPUPerformanceInterface::CPUPerformanceInterface() {</span>
<span class="line-removed">-   _impl = NULL;</span>
<span class="line-removed">- }</span>
  
  bool CPUPerformanceInterface::initialize() {
    _impl = new CPUPerformanceInterface::CPUPerformance();
    return _impl-&gt;initialize();
  }
<span class="line-new-header">--- 1083,62 ---</span>
    MultiCounterQueryP _machine_cpu_load;
  
    int cpu_load(int which_logical_cpu, double* cpu_load);
    int context_switch_rate(double* rate);
    int cpu_load_total_process(double* cpu_load);
<span class="line-modified">!   int cpu_loads_process(double* jvm_user_load, double* jvm_kernel_load, double* system_total_load);</span>
    CPUPerformance();
    ~CPUPerformance();
    bool initialize();
  };
  
  CPUPerformanceInterface::CPUPerformance::CPUPerformance() : _context_switches(NULL), _process_cpu_load(NULL), _machine_cpu_load(NULL) {}
  
  bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified">!   if (pdh_acquire() != OS_OK) {</span>
<span class="line-modified">!     return false;</span>
    }
<span class="line-modified">!   _context_switches = create_counter_query();</span>
<span class="line-added">+   assert(_context_switches != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (initialize_context_switches_query(_context_switches) != OS_OK) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(_context_switches-&gt;initialized, &quot;invariant&quot;);</span>
    _process_cpu_load = create_process_query();
    if (_process_cpu_load == NULL) {
<span class="line-modified">!     return false;</span>
    }
<span class="line-modified">!   if (initialize_process_query(_process_cpu_load) != OS_OK) {</span>
<span class="line-modified">!     return false;</span>
    }
<span class="line-modified">!   assert(_process_cpu_load-&gt;set.initialized, &quot;invariant&quot;);</span>
    _machine_cpu_load = create_multi_counter_query();
<span class="line-modified">!   assert(_machine_cpu_load != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (initialize_cpu_query(_machine_cpu_load) != OS_OK) {</span>
<span class="line-added">+     return false;</span>
    }
<span class="line-modified">!   assert(_machine_cpu_load-&gt;initialized, &quot;invariant&quot;);</span>
    return true;
  }
  
  CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
    if (_context_switches != NULL) {
<span class="line-modified">!     destroy(_context_switches);</span>
      _context_switches = NULL;
    }
    if (_process_cpu_load != NULL) {
<span class="line-modified">!     destroy(_process_cpu_load);</span>
      _process_cpu_load = NULL;
    }
    if (_machine_cpu_load != NULL) {
<span class="line-modified">!     destroy(_machine_cpu_load);</span>
      _machine_cpu_load = NULL;
    }
    pdh_release();
  }
  
<span class="line-modified">! CPUPerformanceInterface::CPUPerformanceInterface() : _impl(NULL) {}</span>
  
  bool CPUPerformanceInterface::initialize() {
    _impl = new CPUPerformanceInterface::CPUPerformance();
    return _impl-&gt;initialize();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1066,129 ***</span>
  
  int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
    return _impl-&gt;cpu_load_total_process(cpu_load);
  }
  
<span class="line-modified">! int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad,</span>
<span class="line-modified">!                                                double* pjvmKernelLoad,</span>
<span class="line-modified">!                                                double* psystemTotalLoad) const {</span>
<span class="line-modified">!   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);</span>
  }
  
  int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
    *cpu_load = .0;
    if (_machine_cpu_load == NULL || !_machine_cpu_load-&gt;initialized) {
      return OS_ERR;
    }
<span class="line-removed">-   assert(_machine_cpu_load != NULL, &quot;invariant&quot;);</span>
    assert(which_logical_cpu &lt; _machine_cpu_load-&gt;noOfCounters, &quot;invariant&quot;);
<span class="line-modified">! </span>
<span class="line-removed">-   if (collect_query_data(_machine_cpu_load)) {</span>
      return OS_ERR;
    }
    // -1 is total (all cpus)
    const int counter_idx = -1 == which_logical_cpu ? _machine_cpu_load-&gt;noOfCounters - 1 : which_logical_cpu;
    PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">!   formatted_counter_value(_machine_cpu_load-&gt;counters[counter_idx], PDH_FMT_DOUBLE, &amp;counter_value);</span>
    *cpu_load = counter_value.doubleValue / 100;
    return OS_OK;
  }
  
  int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {
    *cpu_load = .0;
    if (_process_cpu_load == NULL || !_process_cpu_load-&gt;set.initialized) {
      return OS_ERR;
    }
<span class="line-modified">!   assert(_process_cpu_load != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   if (collect_process_query_data(_process_cpu_load)) {</span>
      return OS_ERR;
    }
    PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">!   if (query_process_counter(_process_cpu_load, 0, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
    double process_load = counter_value.doubleValue / cpu_factor();
    process_load = MIN2&lt;double&gt;(1, process_load);
    process_load = MAX2&lt;double&gt;(0, process_load);
    *cpu_load = process_load;
    return OS_OK;
  }
  
<span class="line-modified">! int CPUPerformanceInterface::CPUPerformance::cpu_loads_process(double* pjvmUserLoad,</span>
<span class="line-modified">!                                                                double* pjvmKernelLoad,</span>
<span class="line-modified">!                                                                double* psystemTotalLoad) {</span>
<span class="line-modified">!   assert(pjvmUserLoad != NULL, &quot;pjvmUserLoad is NULL!&quot;);</span>
<span class="line-modified">!   assert(pjvmKernelLoad != NULL, &quot;pjvmKernelLoad is NULL!&quot;);</span>
<span class="line-modified">!   assert(psystemTotalLoad != NULL, &quot;psystemTotalLoad is NULL!&quot;);</span>
<span class="line-modified">!   *pjvmUserLoad = .0;</span>
<span class="line-modified">!   *pjvmKernelLoad = .0;</span>
<span class="line-modified">!   *psystemTotalLoad = .0;</span>
  
    if (_process_cpu_load == NULL || !_process_cpu_load-&gt;set.initialized) {
      return OS_ERR;
    }
<span class="line-modified">!   assert(_process_cpu_load != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   if (collect_process_query_data(_process_cpu_load)) {</span>
      return OS_ERR;
    }
    double process_load = .0;
    PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">!   // Read  PDH_PROCESSOR_TIME_IDX</span>
<span class="line-modified">!   if (query_process_counter(_process_cpu_load, 0, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
    process_load = counter_value.doubleValue / cpu_factor();
    process_load = MIN2&lt;double&gt;(1, process_load);
    process_load = MAX2&lt;double&gt;(0, process_load);
<span class="line-modified">!   // Read PDH_PRIV_PROCESSOR_TIME_IDX</span>
<span class="line-modified">!   if (query_process_counter(_process_cpu_load, 1, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
<span class="line-modified">!   double kernel_load = counter_value.doubleValue / cpu_factor();</span>
<span class="line-modified">!   kernel_load = MIN2&lt;double&gt;(1, kernel_load);</span>
<span class="line-modified">!   kernel_load = MAX2&lt;double&gt;(0, kernel_load);</span>
<span class="line-modified">!   *pjvmKernelLoad = kernel_load;</span>
  
<span class="line-modified">!   double user_load = process_load - kernel_load;</span>
    user_load = MIN2&lt;double&gt;(1, user_load);
    user_load = MAX2&lt;double&gt;(0, user_load);
<span class="line-modified">!   *pjvmUserLoad = user_load;</span>
<span class="line-modified">! </span>
<span class="line-removed">-   if (collect_query_data(_machine_cpu_load)) {</span>
      return OS_ERR;
    }
<span class="line-modified">!   if (formatted_counter_value(_machine_cpu_load-&gt;counters[_machine_cpu_load-&gt;noOfCounters - 1], PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
    double machine_load = counter_value.doubleValue / 100;
    assert(machine_load &gt;= 0, &quot;machine_load is negative!&quot;);
    // clamp at user+system and 1.0
<span class="line-modified">!   if (*pjvmKernelLoad + *pjvmUserLoad &gt; machine_load) {</span>
<span class="line-modified">!     machine_load = MIN2(*pjvmKernelLoad + *pjvmUserLoad, 1.0);</span>
    }
<span class="line-modified">!   *psystemTotalLoad = machine_load;</span>
    return OS_OK;
  }
  
  int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
    assert(rate != NULL, &quot;invariant&quot;);
    *rate = .0;
    if (_context_switches == NULL || !_context_switches-&gt;initialized) {
      return OS_ERR;
    }
<span class="line-modified">!   assert(_context_switches != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   if (collect_query_data(_context_switches) != OS_OK) {</span>
      return OS_ERR;
    }
    PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">!   if (formatted_counter_value(_context_switches-&gt;counter, PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
    *rate = counter_value.doubleValue;
    return OS_OK;
  }
  
  SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {
    _hProcessSnap = INVALID_HANDLE_VALUE;
    _valid = FALSE;
    _pe32.dwSize = sizeof(PROCESSENTRY32);
  }
<span class="line-new-header">--- 1159,156 ---</span>
  
  int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
    return _impl-&gt;cpu_load_total_process(cpu_load);
  }
  
<span class="line-modified">! int CPUPerformanceInterface::cpu_loads_process(double* jvm_user_load,</span>
<span class="line-modified">!                                                double* jvm_kernel_load,</span>
<span class="line-modified">!                                                double* system_total_load) const {</span>
<span class="line-modified">!   return _impl-&gt;cpu_loads_process(jvm_user_load, jvm_kernel_load, system_total_load);</span>
  }
  
  int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
    *cpu_load = .0;
    if (_machine_cpu_load == NULL || !_machine_cpu_load-&gt;initialized) {
      return OS_ERR;
    }
    assert(which_logical_cpu &lt; _machine_cpu_load-&gt;noOfCounters, &quot;invariant&quot;);
<span class="line-modified">!   if (collect(_machine_cpu_load) != OS_OK) {</span>
      return OS_ERR;
    }
    // -1 is total (all cpus)
    const int counter_idx = -1 == which_logical_cpu ? _machine_cpu_load-&gt;noOfCounters - 1 : which_logical_cpu;
    PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">!   if (read_counter(_machine_cpu_load, counter_idx, PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
<span class="line-added">+     return OS_ERR;</span>
<span class="line-added">+   }</span>
    *cpu_load = counter_value.doubleValue / 100;
    return OS_OK;
  }
  
  int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {
    *cpu_load = .0;
    if (_process_cpu_load == NULL || !_process_cpu_load-&gt;set.initialized) {
      return OS_ERR;
    }
<span class="line-modified">!   if (collect(_process_cpu_load) != OS_OK) {</span>
      return OS_ERR;
    }
    PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">!   if (read_counter(_process_cpu_load, 0, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
    double process_load = counter_value.doubleValue / cpu_factor();
    process_load = MIN2&lt;double&gt;(1, process_load);
    process_load = MAX2&lt;double&gt;(0, process_load);
    *cpu_load = process_load;
    return OS_OK;
  }
  
<span class="line-modified">! int CPUPerformanceInterface::CPUPerformance::cpu_loads_process(double* jvm_user_load,</span>
<span class="line-modified">!                                                                double* jvm_kernel_load,</span>
<span class="line-modified">!                                                                double* system_total_load) {</span>
<span class="line-modified">!   assert(jvm_user_load != NULL, &quot;jvm_user_load is NULL!&quot;);</span>
<span class="line-modified">!   assert(jvm_kernel_load != NULL, &quot;jvm_kernel_load is NULL!&quot;);</span>
<span class="line-modified">!   assert(system_total_load != NULL, &quot;system_total_load is NULL!&quot;);</span>
<span class="line-modified">!   *jvm_user_load = .0;</span>
<span class="line-modified">!   *jvm_kernel_load = .0;</span>
<span class="line-modified">!   *system_total_load = .0;</span>
  
    if (_process_cpu_load == NULL || !_process_cpu_load-&gt;set.initialized) {
      return OS_ERR;
    }
<span class="line-modified">!   if (collect(_process_cpu_load) != OS_OK) {</span>
      return OS_ERR;
    }
    double process_load = .0;
    PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">!   // Read PDH_PROCESSOR_TIME_IDX as counter_idx == 0</span>
<span class="line-modified">!   if (read_counter(_process_cpu_load, 0, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
    process_load = counter_value.doubleValue / cpu_factor();
    process_load = MIN2&lt;double&gt;(1, process_load);
    process_load = MAX2&lt;double&gt;(0, process_load);
<span class="line-modified">!   // Read PDH_PRIV_PROCESSOR_TIME_IDX as counter_idx == 1</span>
<span class="line-modified">!   if (read_counter(_process_cpu_load, 1, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
<span class="line-modified">!   double process_kernel_load = counter_value.doubleValue / cpu_factor();</span>
<span class="line-modified">!   process_kernel_load = MIN2&lt;double&gt;(1, process_kernel_load);</span>
<span class="line-modified">!   process_kernel_load = MAX2&lt;double&gt;(0, process_kernel_load);</span>
<span class="line-modified">!   *jvm_kernel_load = process_kernel_load;</span>
  
<span class="line-modified">!   double user_load = process_load - process_kernel_load;</span>
    user_load = MIN2&lt;double&gt;(1, user_load);
    user_load = MAX2&lt;double&gt;(0, user_load);
<span class="line-modified">!   *jvm_user_load = user_load;</span>
<span class="line-modified">!   if (collect(_machine_cpu_load) != OS_OK) {</span>
      return OS_ERR;
    }
<span class="line-modified">!   // Read PDH_PROCESSOR_IDX as counter_idx == _machine_cpu_load-&gt;noOfCounters - 1</span>
<span class="line-added">+   if (read_counter(_machine_cpu_load, _machine_cpu_load-&gt;noOfCounters - 1, PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
    double machine_load = counter_value.doubleValue / 100;
    assert(machine_load &gt;= 0, &quot;machine_load is negative!&quot;);
    // clamp at user+system and 1.0
<span class="line-modified">!   if (*jvm_kernel_load + *jvm_user_load &gt; machine_load) {</span>
<span class="line-modified">!     machine_load = MIN2(*jvm_kernel_load + *jvm_user_load, 1.0);</span>
    }
<span class="line-modified">!   *system_total_load = machine_load;</span>
    return OS_OK;
  }
  
  int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
    assert(rate != NULL, &quot;invariant&quot;);
    *rate = .0;
    if (_context_switches == NULL || !_context_switches-&gt;initialized) {
      return OS_ERR;
    }
<span class="line-modified">!   if (collect(_context_switches) != OS_OK) {</span>
      return OS_ERR;
    }
    PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">!   if (read_counter(_context_switches, PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
      return OS_ERR;
    }
    *rate = counter_value.doubleValue;
    return OS_OK;
  }
  
<span class="line-added">+ class SystemProcessInterface::SystemProcesses : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-added">+   friend class SystemProcessInterface;</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   class ProcessIterator : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-added">+     friend class SystemProcessInterface::SystemProcesses;</span>
<span class="line-added">+    private:</span>
<span class="line-added">+     HANDLE         _hProcessSnap;</span>
<span class="line-added">+     PROCESSENTRY32 _pe32;</span>
<span class="line-added">+     BOOL           _valid;</span>
<span class="line-added">+     char           _exePath[MAX_PATH];</span>
<span class="line-added">+     ProcessIterator();</span>
<span class="line-added">+     ~ProcessIterator();</span>
<span class="line-added">+     bool initialize();</span>
<span class="line-added">+ </span>
<span class="line-added">+     int current(SystemProcess* const process_info);</span>
<span class="line-added">+     int next_process();</span>
<span class="line-added">+     bool is_valid() const { return _valid != FALSE; }</span>
<span class="line-added">+     char* allocate_string(const char* str) const;</span>
<span class="line-added">+     int snapshot();</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   ProcessIterator* _iterator;</span>
<span class="line-added">+   SystemProcesses();</span>
<span class="line-added">+   ~SystemProcesses();</span>
<span class="line-added">+   bool initialize();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // information about system processes</span>
<span class="line-added">+   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {
    _hProcessSnap = INVALID_HANDLE_VALUE;
    _valid = FALSE;
    _pe32.dwSize = sizeof(PROCESSENTRY32);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1234,34 ***</span>
    process_info-&gt;set_path(allocate_string(exePath));
    return OS_OK;
  }
  
  char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
<span class="line-modified">!   if (str != NULL) {</span>
<span class="line-removed">-     return os::strdup_check_oom(str, mtInternal);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return NULL;</span>
  }
  
  int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
    _valid = Process32Next(_hProcessSnap, &amp;_pe32);
    return OS_OK;
  }
  
<span class="line-modified">! SystemProcessInterface::SystemProcesses::SystemProcesses() {</span>
<span class="line-removed">-   _iterator = NULL;</span>
<span class="line-removed">- }</span>
  
  bool SystemProcessInterface::SystemProcesses::initialize() {
    _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
    return _iterator-&gt;initialize();
  }
  
  SystemProcessInterface::SystemProcesses::~SystemProcesses() {
    if (_iterator != NULL) {
      delete _iterator;
<span class="line-removed">-     _iterator = NULL;</span>
    }
  }
  
  int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes,
                                                                int* no_of_sys_processes) const {
<span class="line-new-header">--- 1354,28 ---</span>
    process_info-&gt;set_path(allocate_string(exePath));
    return OS_OK;
  }
  
  char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
<span class="line-modified">!   return str != NULL ? os::strdup_check_oom(str, mtInternal) : NULL;</span>
  }
  
  int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
    _valid = Process32Next(_hProcessSnap, &amp;_pe32);
    return OS_OK;
  }
  
<span class="line-modified">! SystemProcessInterface::SystemProcesses::SystemProcesses() : _iterator(NULL) {}</span>
  
  bool SystemProcessInterface::SystemProcesses::initialize() {
    _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
    return _iterator-&gt;initialize();
  }
  
  SystemProcessInterface::SystemProcesses::~SystemProcesses() {
    if (_iterator != NULL) {
      delete _iterator;
    }
  }
  
  int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes,
                                                                int* no_of_sys_processes) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1300,13 ***</span>
  int SystemProcessInterface::system_processes(SystemProcess** system_procs,
                                               int* no_of_sys_processes) const {
    return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
  }
  
<span class="line-modified">! SystemProcessInterface::SystemProcessInterface() {</span>
<span class="line-removed">-   _impl = NULL;</span>
<span class="line-removed">- }</span>
  
  bool SystemProcessInterface::initialize() {
    _impl = new SystemProcessInterface::SystemProcesses();
    return _impl-&gt;initialize();
  }
<span class="line-new-header">--- 1414,11 ---</span>
  int SystemProcessInterface::system_processes(SystemProcess** system_procs,
                                               int* no_of_sys_processes) const {
    return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
  }
  
<span class="line-modified">! SystemProcessInterface::SystemProcessInterface() : _impl(NULL) {}</span>
  
  bool SystemProcessInterface::initialize() {
    _impl = new SystemProcessInterface::SystemProcesses();
    return _impl-&gt;initialize();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1315,13 ***</span>
    if (_impl != NULL) {
      delete _impl;
    }
  }
  
<span class="line-modified">! CPUInformationInterface::CPUInformationInterface() {</span>
<span class="line-removed">-   _cpu_info = NULL;</span>
<span class="line-removed">- }</span>
  
  bool CPUInformationInterface::initialize() {
    _cpu_info = new CPUInformation();
    _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
    _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
<span class="line-new-header">--- 1427,11 ---</span>
    if (_impl != NULL) {
      delete _impl;
    }
  }
  
<span class="line-modified">! CPUInformationInterface::CPUInformationInterface() : _cpu_info(NULL) {}</span>
  
  bool CPUInformationInterface::initialize() {
    _cpu_info = new CPUInformation();
    _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
    _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1336,11 ***</span>
      FREE_C_HEAP_ARRAY(char, _cpu_info-&gt;cpu_name());
      _cpu_info-&gt;set_cpu_name(NULL);
      FREE_C_HEAP_ARRAY(char, _cpu_info-&gt;cpu_description());
      _cpu_info-&gt;set_cpu_description(NULL);
      delete _cpu_info;
<span class="line-removed">-     _cpu_info = NULL;</span>
    }
  }
  
  int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
    if (NULL == _cpu_info) {
<span class="line-new-header">--- 1446,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1360,13 ***</span>
    bool initialize();
    ~NetworkPerformance();
    int network_utilization(NetworkInterface** network_interfaces) const;
  };
  
<span class="line-modified">! NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance()</span>
<span class="line-removed">- : _iphlp_attached(false) {</span>
<span class="line-removed">- }</span>
  
  bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
    _iphlp_attached = IphlpDll::IphlpAttach();
    return _iphlp_attached;
  }
<span class="line-new-header">--- 1469,11 ---</span>
    bool initialize();
    ~NetworkPerformance();
    int network_utilization(NetworkInterface** network_interfaces) const;
  };
  
<span class="line-modified">! NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() : _iphlp_attached(false) {}</span>
  
  bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
    _iphlp_attached = IphlpDll::IphlpAttach();
    return _iphlp_attached;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1403,13 ***</span>
    *network_interfaces = ret;
  
    return OS_OK;
  }
  
<span class="line-modified">! NetworkPerformanceInterface::NetworkPerformanceInterface() {</span>
<span class="line-removed">-   _impl = NULL;</span>
<span class="line-removed">- }</span>
  
  NetworkPerformanceInterface::~NetworkPerformanceInterface() {
    if (_impl != NULL) {
      delete _impl;
    }
<span class="line-new-header">--- 1510,11 ---</span>
    *network_interfaces = ret;
  
    return OS_OK;
  }
  
<span class="line-modified">! NetworkPerformanceInterface::NetworkPerformanceInterface() : _impl(NULL) {}</span>
  
  NetworkPerformanceInterface::~NetworkPerformanceInterface() {
    if (_impl != NULL) {
      delete _impl;
    }
</pre>
<center><a href="../solaris/os_solaris.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
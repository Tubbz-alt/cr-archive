<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/windows/os_perf_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../solaris/os_solaris.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/os_perf_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;iphlp_interface.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;pdh_interface.hpp&quot;
  31 #include &quot;runtime/os_perf.hpp&quot;
  32 #include &quot;runtime/os.hpp&quot;

  33 #include &quot;utilities/globalDefinitions.hpp&quot;
  34 #include &quot;utilities/macros.hpp&quot;
  35 #include CPU_HEADER(vm_version_ext)
  36 #include &lt;math.h&gt;
  37 #include &lt;psapi.h&gt;
  38 #include &lt;TlHelp32.h&gt;
  39 
  40 /*
  41  * Windows provides a vast plethora of performance objects and counters,
  42  * consumption of which is assisted using the Performance Data Helper (PDH) interface.
  43  * We import a selected few api entry points from PDH, see pdh_interface.hpp.
  44  *
  45  * The code located in this file is to a large extent an abstraction over much of the
  46  * plumbing needed to start consuming an object and/or counter of choice.
  47  *
<span class="line-modified">  48  */</span>
<span class="line-removed">  49 </span>
<span class="line-removed">  50  /*</span>
  51  * How to use:
<span class="line-modified">  52  * 1. Create query</span>
  53  * 2. Add counters to the query
  54  * 3. Collect the performance data using the query
<span class="line-modified">  55  * 4. Display the performance data using the counters associated with the query</span>
  56  * 5. Destroy query (counter destruction implied)
<span class="line-modified">  57  */</span>
<span class="line-modified">  58 </span>
<span class="line-removed">  59 /*</span>
  60  * Every PDH artifact, like processor, process, thread, memory, and so forth are
  61  * identified with an index that is always the same irrespective
  62  * of the localized version of the operating system or service pack installed.
  63  * INFO: Using PDH APIs Correctly in a Localized Language (Q287159)
  64  *   http://support.microsoft.com/default.aspx?scid=kb;EN-US;q287159
  65  *
  66  * To find the correct index for an object or counter, inspect the registry key / value:
  67  * [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib\009\Counter]
  68  *
  69  * some common PDH indexes
  70  */
  71 static const DWORD PDH_PROCESSOR_IDX = 238;
  72 static const DWORD PDH_PROCESSOR_TIME_IDX = 6;
  73 static const DWORD PDH_PRIV_PROCESSOR_TIME_IDX = 144;
  74 static const DWORD PDH_PROCESS_IDX = 230;
  75 static const DWORD PDH_ID_PROCESS_IDX = 784;
  76 static const DWORD PDH_CONTEXT_SWITCH_RATE_IDX = 146;
  77 static const DWORD PDH_SYSTEM_IDX = 2;
  78 
<span class="line-modified">  79 /* useful pdh fmt&#39;s */</span>
  80 static const char* const OBJECT_COUNTER_FMT = &quot;\\%s\\%s&quot;;
  81 static const size_t OBJECT_COUNTER_FMT_LEN = 2;
  82 static const char* const OBJECT_WITH_INSTANCES_COUNTER_FMT = &quot;\\%s(%s)\\%s&quot;;
  83 static const size_t OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN = 4;
<span class="line-modified">  84 static const char* const PROCESS_OBJECT_INSTANCE_COUNTER_FMT = &quot;\\%s(%s#%s)\\%s&quot;;</span>
<span class="line-modified">  85 static const size_t PROCESS_OBJECT_INSTANCE_COUNTER_FMT_LEN = 5;</span>
<span class="line-modified">  86 </span>
<span class="line-modified">  87 static const char* process_image_name = NULL; // for example, &quot;java&quot; but could have another image name</span>
<span class="line-removed">  88 static char* pdh_IDProcess_counter_fmt = NULL;   // &quot;\Process(java#%d)\ID Process&quot; */</span>
  89 
<span class="line-modified">  90 // Need to limit how often we update a query to minimize the heisenberg effect.</span>
<span class="line-modified">  91 // (PDH behaves erratically if the counters are queried too often, especially counters that</span>
<span class="line-modified">  92 // store and use values from two consecutive updates, like cpu load.)</span>
<span class="line-modified">  93 static const int min_update_interval_millis = 500;</span>
  94 
  95 /*
  96 * Structs for PDH queries.
  97 */
  98 typedef struct {
<span class="line-modified">  99   HQUERY query;</span>
 100   s8     lastUpdate; // Last time query was updated.
 101 } UpdateQueryS, *UpdateQueryP;
 102 
 103 
 104 typedef struct {
 105   UpdateQueryS query;
 106   HCOUNTER     counter;
 107   bool         initialized;
 108 } CounterQueryS, *CounterQueryP;
 109 
 110 typedef struct {
 111   UpdateQueryS query;
 112   HCOUNTER*    counters;
 113   int          noOfCounters;
 114   bool         initialized;
 115 } MultiCounterQueryS, *MultiCounterQueryP;
 116 
 117 typedef struct {
 118   MultiCounterQueryP queries;
 119   int                size;
 120   bool               initialized;
 121 } MultiCounterQuerySetS, *MultiCounterQuerySetP;
 122 
 123 typedef struct {
 124   MultiCounterQuerySetS set;
<span class="line-modified"> 125   int                   process_index;</span>
 126 } ProcessQueryS, *ProcessQueryP;
 127 
<span class="line-modified"> 128 static void pdh_cleanup(HQUERY* const query, HCOUNTER* const counter) {</span>













 129   if (counter != NULL &amp;&amp; *counter != NULL) {
 130     PdhDll::PdhRemoveCounter(*counter);
 131     *counter = NULL;
 132   }
<span class="line-modified"> 133   if (query != NULL &amp;&amp; *query != NULL) {</span>
<span class="line-modified"> 134     PdhDll::PdhCloseQuery(*query);</span>
<span class="line-modified"> 135     *query = NULL;</span>
 136   }
 137 }
 138 








 139 static CounterQueryP create_counter_query() {
 140   CounterQueryP const query = NEW_C_HEAP_OBJ(CounterQueryS, mtInternal);
 141   memset(query, 0, sizeof(CounterQueryS));
 142   return query;
 143 }
 144 
<span class="line-removed"> 145 static void destroy_counter_query(CounterQueryP query) {</span>
<span class="line-removed"> 146   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 147   pdh_cleanup(&amp;query-&gt;query.query, &amp;query-&gt;counter);</span>
<span class="line-removed"> 148   FREE_C_HEAP_OBJ(query);</span>
<span class="line-removed"> 149 }</span>
<span class="line-removed"> 150 </span>
 151 static MultiCounterQueryP create_multi_counter_query() {
 152   MultiCounterQueryP const query = NEW_C_HEAP_ARRAY(MultiCounterQueryS, 1, mtInternal);
 153   memset(query, 0, sizeof(MultiCounterQueryS));
 154   return query;
 155 }
 156 
<span class="line-modified"> 157 static void destroy_counter_query(MultiCounterQueryP counter_query) {</span>
<span class="line-modified"> 158   if (counter_query != NULL) {</span>
<span class="line-modified"> 159     for (int i = 0; i &lt; counter_query-&gt;noOfCounters; ++i) {</span>
<span class="line-modified"> 160       pdh_cleanup(NULL, &amp;counter_query-&gt;counters[i]);</span>
<span class="line-removed"> 161     }</span>
<span class="line-removed"> 162     FREE_C_HEAP_ARRAY(char, counter_query-&gt;counters);</span>
<span class="line-removed"> 163     pdh_cleanup(&amp;counter_query-&gt;query.query, NULL);</span>
<span class="line-removed"> 164     FREE_C_HEAP_ARRAY(MultiCounterQueryS, counter_query);</span>
<span class="line-removed"> 165   }</span>
 166 }
 167 
<span class="line-modified"> 168 static void destroy_multi_counter_query(MultiCounterQuerySetP counter_query_set) {</span>
<span class="line-modified"> 169   for (int i = 0; i &lt; counter_query_set-&gt;size; i++) {</span>
<span class="line-modified"> 170     for (int j = 0; j &lt; counter_query_set-&gt;queries[i].noOfCounters; ++j) {</span>
<span class="line-modified"> 171       pdh_cleanup(NULL, &amp;counter_query_set-&gt;queries[i].counters[j]);</span>
 172     }
<span class="line-modified"> 173     FREE_C_HEAP_ARRAY(char, counter_query_set-&gt;queries[i].counters);</span>
<span class="line-modified"> 174     pdh_cleanup(&amp;counter_query_set-&gt;queries[i].query.query, NULL);</span>

 175   }
<span class="line-removed"> 176   FREE_C_HEAP_ARRAY(MultiCounterQueryS, counter_query_set-&gt;queries);</span>
<span class="line-removed"> 177 }</span>
<span class="line-removed"> 178 </span>
<span class="line-removed"> 179 static void destroy_counter_query(MultiCounterQuerySetP counter_query_set) {</span>
<span class="line-removed"> 180   destroy_multi_counter_query(counter_query_set);</span>
<span class="line-removed"> 181   FREE_C_HEAP_ARRAY(MultiCounterQuerySetS, counter_query_set);</span>
 182 }
 183 
<span class="line-modified"> 184 static void destroy_counter_query(ProcessQueryP process_query) {</span>
<span class="line-modified"> 185   destroy_multi_counter_query(&amp;process_query-&gt;set);</span>
<span class="line-modified"> 186   FREE_C_HEAP_OBJ(process_query);</span>






 187 }
 188 
<span class="line-modified"> 189 static int open_query(HQUERY* query) {</span>
<span class="line-modified"> 190   return PdhDll::PdhOpenQuery(NULL, 0, query);</span>

 191 }
 192 
<span class="line-modified"> 193 template &lt;typename QueryP&gt;</span>
<span class="line-modified"> 194 static int open_query(QueryP query) {</span>
<span class="line-modified"> 195   return open_query(&amp;query-&gt;query);</span>
 196 }
 197 
 198 static void allocate_counters(MultiCounterQueryP query, size_t nofCounters) {
 199   assert(query != NULL, &quot;invariant&quot;);
 200   assert(!query-&gt;initialized, &quot;invariant&quot;);
 201   assert(0 == query-&gt;noOfCounters, &quot;invariant&quot;);
 202   assert(query-&gt;counters == NULL, &quot;invariant&quot;);
 203   query-&gt;counters = NEW_C_HEAP_ARRAY(HCOUNTER, nofCounters, mtInternal);
 204   memset(query-&gt;counters, 0, nofCounters * sizeof(HCOUNTER));
 205   query-&gt;noOfCounters = (int)nofCounters;
 206 }
 207 
<span class="line-modified"> 208 static void allocate_counters(MultiCounterQuerySetP query_set, size_t nofCounters) {</span>
<span class="line-modified"> 209   assert(query_set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 210   assert(!query_set-&gt;initialized, &quot;invariant&quot;);</span>
<span class="line-modified"> 211   for (int i = 0; i &lt; query_set-&gt;size; ++i) {</span>
<span class="line-modified"> 212     allocate_counters(&amp;query_set-&gt;queries[i], nofCounters);</span>
 213   }
 214 }
 215 
<span class="line-modified"> 216 static void allocate_counters(ProcessQueryP process_query, size_t nofCounters) {</span>
<span class="line-modified"> 217   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 218   allocate_counters(&amp;process_query-&gt;set, nofCounters);</span>
 219 }
 220 
 221 static void deallocate_counters(MultiCounterQueryP query) {
 222   FREE_C_HEAP_ARRAY(char, query-&gt;counters);
 223   query-&gt;counters = NULL;
 224   query-&gt;noOfCounters = 0;
 225 }
 226 
<span class="line-modified"> 227 static OSReturn add_counter(UpdateQueryP query, HCOUNTER* counter, const char* path, bool first_sample_on_init) {</span>
 228   assert(query != NULL, &quot;invariant&quot;);
 229   assert(counter != NULL, &quot;invariant&quot;);
<span class="line-modified"> 230   assert(path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 231   if (query-&gt;query == NULL) {</span>
<span class="line-modified"> 232     if (open_query(query) != ERROR_SUCCESS) {</span>
 233       return OS_ERR;
 234     }
 235   }
<span class="line-modified"> 236   assert(query-&gt;query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 237   PDH_STATUS status = PdhDll::PdhAddCounter(query-&gt;query, path, 0, counter);</span>
 238   if (PDH_CSTATUS_NO_OBJECT == status || PDH_CSTATUS_NO_COUNTER == status) {
 239     return OS_ERR;
 240   }
 241   /*
 242   * According to the MSDN documentation, rate counters must be read twice:
 243   *
 244   * &quot;Obtaining the value of rate counters such as Page faults/sec requires that
 245   *  PdhCollectQueryData be called twice, with a specific time interval between
 246   *  the two calls, before calling PdhGetFormattedCounterValue. Call Sleep to
 247   *  implement the waiting period between the two calls to PdhCollectQueryData.&quot;
 248   *
 249   *  Take the first sample here already to allow for the next &quot;real&quot; sample
 250   *  to succeed.
 251   */
<span class="line-modified"> 252   if (first_sample_on_init) {</span>
<span class="line-modified"> 253     PdhDll::PdhCollectQueryData(query-&gt;query);</span>
 254   }
 255   return OS_OK;
 256 }
 257 
 258 template &lt;typename QueryP&gt;
<span class="line-modified"> 259 static OSReturn add_counter(QueryP counter_query, HCOUNTER* counter, const char* path, bool first_sample_on_init) {</span>
<span class="line-modified"> 260   assert(counter_query != NULL, &quot;invariant&quot;);</span>
 261   assert(counter != NULL, &quot;invariant&quot;);
<span class="line-modified"> 262   assert(path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 263   return add_counter(&amp;counter_query-&gt;query, counter, path, first_sample_on_init);</span>
 264 }
 265 
<span class="line-modified"> 266 static OSReturn add_counter(CounterQueryP counter_query, const char* path, bool first_sample_on_init) {</span>
<span class="line-modified"> 267   if (add_counter(counter_query, &amp;counter_query-&gt;counter, path, first_sample_on_init) != OS_OK) {</span>
<span class="line-modified"> 268     // performance counter might be disabled in the registry</span>
<span class="line-removed"> 269     return OS_ERR;</span>
<span class="line-removed"> 270   }</span>
<span class="line-removed"> 271   counter_query-&gt;initialized = true;</span>
<span class="line-removed"> 272   return OS_OK;</span>
 273 }
 274 
<span class="line-modified"> 275 static OSReturn add_process_counter(MultiCounterQueryP query, int slot_index, const char* path, bool first_sample_on_init) {</span>
 276   assert(query != NULL, &quot;invariant&quot;);
<span class="line-modified"> 277   assert(slot_index &lt; query-&gt;noOfCounters, &quot;invariant&quot;);</span>
<span class="line-modified"> 278   assert(query-&gt;counters[slot_index] == NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 279   const OSReturn ret = add_counter(query, &amp;query-&gt;counters[slot_index], path, first_sample_on_init);</span>
<span class="line-removed"> 280   if (OS_OK == ret) {</span>
<span class="line-removed"> 281     if (slot_index + 1 == query-&gt;noOfCounters) {</span>
<span class="line-removed"> 282       query-&gt;initialized = true;</span>
<span class="line-removed"> 283     }</span>
<span class="line-removed"> 284   }</span>
<span class="line-removed"> 285   return ret;</span>
 286 }
 287 
<span class="line-modified"> 288 static int collect_query_data(UpdateQueryP update_query) {</span>
<span class="line-modified"> 289   assert(update_query != NULL, &quot;invariant&quot;);</span>





 290   const s8 now = os::javaTimeNanos();
<span class="line-modified"> 291   if (nanos_to_millis(now - update_query-&gt;lastUpdate) &gt; min_update_interval_millis) {</span>
<span class="line-modified"> 292     if (PdhDll::PdhCollectQueryData(update_query-&gt;query) != ERROR_SUCCESS) {</span>
 293       return OS_ERR;
 294     }
<span class="line-modified"> 295     update_query-&gt;lastUpdate = now;</span>
 296   }
 297   return OS_OK;
 298 }
 299 
<span class="line-modified"> 300 template &lt;typename Query&gt;</span>
<span class="line-modified"> 301 static int collect_query_data(Query* counter_query) {</span>
<span class="line-modified"> 302   assert(counter_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 303   return collect_query_data(&amp;counter_query-&gt;query);</span>
 304 }
 305 
 306 static int formatted_counter_value(HCOUNTER counter, DWORD format, PDH_FMT_COUNTERVALUE* const value) {
 307   assert(value != NULL, &quot;invariant&quot;);
<span class="line-modified"> 308   if (PdhDll::PdhGetFormattedCounterValue(counter, format, NULL, value) != ERROR_SUCCESS) {</span>












































 309     return OS_ERR;
 310   }
<span class="line-modified"> 311   return OS_OK;</span>
































 312 }
 313 

 314 /*
<span class="line-modified"> 315 * Working against the Process object and it&#39;s related counters is inherently problematic</span>
<span class="line-modified"> 316 * when using the PDH API:</span>















 317 *
<span class="line-modified"> 318 * Using PDH, a process is not primarily identified by the process id,</span>
<span class="line-modified"> 319 * but with a sequential number, for example \Process(java#0), \Process(java#1), ...</span>
<span class="line-modified"> 320 * The really bad part is that this list is reset as soon as a process exits:</span>
<span class="line-modified"> 321 * If \Process(java#1) exits, \Process(java#3) now becomes \Process(java#2) etc.</span>


 322 *
<span class="line-modified"> 323 * The PDH api requires a process identifier to be submitted when registering</span>
<span class="line-modified"> 324 * a query, but as soon as the list resets, the query is invalidated (since the name changed).</span>




 325 *
 326 * Solution:
<span class="line-modified"> 327 * The #number identifier for a Process query can only decrease after process creation.</span>
 328 *
 329 * We therefore create an array of counter queries for all process object instances
 330 * up to and including ourselves:
 331 *
<span class="line-modified"> 332 * Ex. we come in as third process instance (java#2), we then create and register</span>
 333 * queries for the following Process object instances:
 334 * java#0, java#1, java#2
 335 *
<span class="line-modified"> 336 * current_query_index_for_process() keeps track of the current &quot;correct&quot; query</span>
<span class="line-modified"> 337 * (in order to keep this index valid when the list resets from underneath,</span>
<span class="line-modified"> 338 * ensure to call current_query_index_for_process() before every query involving</span>
<span class="line-modified"> 339 * Process object instance data).</span>

 340 *
<span class="line-modified"> 341 * if unable to query, returns OS_ERR(-1)</span>


 342 */
<span class="line-modified"> 343 static int current_query_index_for_process() {</span>



 344   assert(process_image_name != NULL, &quot;invariant&quot;);
<span class="line-modified"> 345   assert(pdh_IDProcess_counter_fmt != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 346   HQUERY tmpQuery = NULL;</span>
<span class="line-modified"> 347   if (open_query(&amp;tmpQuery) != ERROR_SUCCESS) {</span>

 348     return OS_ERR;
 349   }
<span class="line-modified"> 350   char counter[512];</span>
<span class="line-modified"> 351   HCOUNTER handle_counter = NULL;</span>
<span class="line-modified"> 352   // iterate over all instance indexes and try to find our own pid</span>
<span class="line-modified"> 353   for (int index = 0; index &lt; max_intx; index++) {</span>
<span class="line-modified"> 354     jio_snprintf(counter, sizeof(counter) - 1, pdh_IDProcess_counter_fmt, index);</span>
<span class="line-modified"> 355     assert(strlen(counter) &lt; sizeof(counter), &quot;invariant&quot;);</span>
<span class="line-modified"> 356     if (PdhDll::PdhAddCounter(tmpQuery, counter, 0, &amp;handle_counter) != ERROR_SUCCESS) {</span>
<span class="line-modified"> 357       pdh_cleanup(&amp;tmpQuery, &amp;handle_counter);</span>
<span class="line-modified"> 358       return OS_ERR;</span>



 359     }
<span class="line-modified"> 360     const PDH_STATUS res = PdhDll::PdhCollectQueryData(tmpQuery);</span>
<span class="line-modified"> 361     if (res == PDH_INVALID_HANDLE || res == PDH_NO_DATA) {</span>
<span class="line-removed"> 362       pdh_cleanup(&amp;tmpQuery, &amp;handle_counter);</span>
 363       return OS_ERR;
<span class="line-modified"> 364     } else {</span>
<span class="line-modified"> 365       PDH_FMT_COUNTERVALUE counter_value;</span>
<span class="line-modified"> 366       formatted_counter_value(handle_counter, PDH_FMT_LONG, &amp;counter_value);</span>
<span class="line-modified"> 367       pdh_cleanup(NULL, &amp;handle_counter);</span>
<span class="line-removed"> 368       if ((LONG)os::current_process_id() == counter_value.longValue) {</span>
<span class="line-removed"> 369         pdh_cleanup(&amp;tmpQuery, NULL);</span>
<span class="line-removed"> 370         return index;</span>
<span class="line-removed"> 371       }</span>
 372     }
 373   }
<span class="line-modified"> 374   pdh_cleanup(&amp;tmpQuery, NULL);</span>
<span class="line-modified"> 375   return OS_ERR;</span>
<span class="line-removed"> 376 }</span>
<span class="line-removed"> 377 </span>
<span class="line-removed"> 378 static ProcessQueryP create_process_query() {</span>
<span class="line-removed"> 379   const int current_process_idx = current_query_index_for_process();</span>
<span class="line-removed"> 380   if (OS_ERR == current_process_idx) {</span>
<span class="line-removed"> 381     return NULL;</span>
<span class="line-removed"> 382   }</span>
<span class="line-removed"> 383   ProcessQueryP const process_query = NEW_C_HEAP_OBJ(ProcessQueryS, mtInternal);</span>
<span class="line-removed"> 384   memset(process_query, 0, sizeof(ProcessQueryS));</span>
<span class="line-removed"> 385   process_query-&gt;set.queries = NEW_C_HEAP_ARRAY(MultiCounterQueryS, current_process_idx + 1, mtInternal);</span>
<span class="line-removed"> 386   memset(process_query-&gt;set.queries, 0, sizeof(MultiCounterQueryS) * (current_process_idx + 1));</span>
<span class="line-removed"> 387   process_query-&gt;process_index = current_process_idx;</span>
<span class="line-removed"> 388   process_query-&gt;set.size = current_process_idx + 1;</span>
<span class="line-removed"> 389   assert(process_query-&gt;set.size &gt; process_query-&gt;process_index, &quot;invariant&quot;);</span>
<span class="line-removed"> 390   return process_query;</span>
<span class="line-removed"> 391 }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393 static MultiCounterQueryP current_process_counter_query(ProcessQueryP process_query) {</span>
<span class="line-removed"> 394   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 395   assert(process_query-&gt;process_index &lt; process_query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-removed"> 396   return &amp;process_query-&gt;set.queries[process_query-&gt;process_index];</span>
 397 }
 398 
<span class="line-modified"> 399 static void clear_multi_counter(MultiCounterQueryP query) {</span>
<span class="line-modified"> 400   for (int i = 0; i &lt; query-&gt;noOfCounters; ++i) {</span>
<span class="line-modified"> 401     pdh_cleanup(NULL, &amp;query-&gt;counters[i]);</span>


 402   }
<span class="line-modified"> 403   pdh_cleanup(&amp;query-&gt;query.query, NULL);</span>
<span class="line-modified"> 404   query-&gt;initialized = false;</span>
<span class="line-modified"> 405 }</span>
<span class="line-removed"> 406 </span>
<span class="line-removed"> 407 static int ensure_valid_process_query_index(ProcessQueryP process_query) {</span>
<span class="line-removed"> 408   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 409   const int previous_process_idx = process_query-&gt;process_index;</span>
<span class="line-removed"> 410   if (previous_process_idx == 0) {</span>
<span class="line-removed"> 411     return previous_process_idx;</span>
 412   }
<span class="line-modified"> 413   const int current_process_idx = current_query_index_for_process();</span>
<span class="line-modified"> 414   if (current_process_idx == previous_process_idx || OS_ERR == current_process_idx ||</span>
<span class="line-removed"> 415     current_process_idx &gt;= process_query-&gt;set.size) {</span>
<span class="line-removed"> 416     return previous_process_idx;</span>
 417   }
<span class="line-modified"> 418 </span>
<span class="line-modified"> 419   assert(current_process_idx &gt;= 0 &amp;&amp; current_process_idx &lt; process_query-&gt;set.size, &quot;out of bounds!&quot;);</span>
<span class="line-modified"> 420   while (current_process_idx &lt; process_query-&gt;set.size - 1) {</span>
<span class="line-modified"> 421     const int new_size = --process_query-&gt;set.size;</span>
<span class="line-removed"> 422     clear_multi_counter(&amp;process_query-&gt;set.queries[new_size]);</span>
 423   }
<span class="line-modified"> 424   assert(current_process_idx &lt; process_query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-modified"> 425   process_query-&gt;process_index = current_process_idx;</span>
<span class="line-modified"> 426   return current_process_idx;</span>
<span class="line-removed"> 427 }</span>
<span class="line-removed"> 428 </span>
<span class="line-removed"> 429 static MultiCounterQueryP current_process_query(ProcessQueryP process_query) {</span>
<span class="line-removed"> 430   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 431   const int current_process_idx = ensure_valid_process_query_index(process_query);</span>
<span class="line-removed"> 432   assert(current_process_idx == process_query-&gt;process_index, &quot;invariant&quot;);</span>
<span class="line-removed"> 433   assert(current_process_idx &lt; process_query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-removed"> 434   return &amp;process_query-&gt;set.queries[current_process_idx];</span>
 435 }
 436 
<span class="line-modified"> 437 static int collect_process_query_data(ProcessQueryP process_query) {</span>
<span class="line-modified"> 438   assert(process_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 439   return collect_query_data(current_process_query(process_query));</span>




 440 }
 441 
<span class="line-modified"> 442 static int query_process_counter(ProcessQueryP process_query, int slot_index, DWORD format, PDH_FMT_COUNTERVALUE* const value) {</span>
<span class="line-modified"> 443   MultiCounterQueryP const current_query = current_process_counter_query(process_query);</span>
<span class="line-modified"> 444   assert(current_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 445   assert(slot_index &lt; current_query-&gt;noOfCounters, &quot;invariant&quot;);</span>
<span class="line-removed"> 446   assert(current_query-&gt;counters[slot_index] != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 447   return formatted_counter_value(current_query-&gt;counters[slot_index], format, value);</span>
 448 }
 449 
 450 /*
<span class="line-modified"> 451  * Construct a fully qualified PDH path</span>
 452  *
<span class="line-modified"> 453  * @param objectName   a PDH Object string representation(required)</span>
<span class="line-modified"> 454  * @param counterName  a PDH Counter string representation(required)</span>
<span class="line-modified"> 455  * @param imageName    a process image name string, ex. &quot;java&quot; (opt)</span>
<span class="line-modified"> 456  * @param instance     an instance string, ex. &quot;0&quot;, &quot;1&quot;, ... (opt)</span>
<span class="line-modified"> 457  * @return             the fully qualified PDH path.</span>
 458  *
 459  * Caller will need a ResourceMark.
 460  *
 461  * (PdhMakeCounterPath() seems buggy on concatenating instances, hence this function instead)
 462  */
 463 static const char* make_fully_qualified_counter_path(const char* object_name,
 464                                                      const char* counter_name,
 465                                                      const char* image_name = NULL,
 466                                                      const char* instance = NULL) {
 467   assert(object_name != NULL, &quot;invariant&quot;);
 468   assert(counter_name != NULL, &quot;invariant&quot;);
<span class="line-modified"> 469   size_t full_counter_path_len = strlen(object_name) + strlen(counter_name);</span>
 470 
<span class="line-modified"> 471   char* full_counter_path;</span>
 472   size_t jio_snprintf_result = 0;
 473   if (image_name) {
 474     /*
 475     * For paths using the &quot;Process&quot; Object.
 476     *
 477     * Examples:
 478     * form:   &quot;\object_name(image_name#instance)\counter_name&quot;
 479     * actual: &quot;\Process(java#2)\ID Process&quot;
 480     */
<span class="line-modified"> 481     full_counter_path_len += PROCESS_OBJECT_INSTANCE_COUNTER_FMT_LEN;</span>
<span class="line-modified"> 482     full_counter_path_len += strlen(image_name);</span>
 483     /*
 484     * image_name must be passed together with an associated
 485     * instance &quot;number&quot; (&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, ...).
 486     * This is required in order to create valid &quot;Process&quot; Object paths.
 487     *
 488     * Examples: &quot;\Process(java#0)&quot;, \Process(java#1&quot;), ...
 489     */
 490     assert(instance != NULL, &quot;invariant&quot;);
<span class="line-modified"> 491     full_counter_path_len += strlen(instance);</span>
<span class="line-modified"> 492     full_counter_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, full_counter_path_len + 1);</span>
<span class="line-modified"> 493     if (full_counter_path == NULL) {</span>
<span class="line-modified"> 494       return NULL;</span>
<span class="line-modified"> 495     }</span>
<span class="line-removed"> 496     jio_snprintf_result = jio_snprintf(full_counter_path,</span>
<span class="line-removed"> 497                                        full_counter_path_len + 1,</span>
<span class="line-removed"> 498                                        PROCESS_OBJECT_INSTANCE_COUNTER_FMT,</span>
 499                                        object_name,
 500                                        image_name,
 501                                        instance,
 502                                        counter_name);
 503   } else {
 504     if (instance) {
 505       /*
 506       * For paths where the Object has multiple instances.
 507       *
 508       * Examples:
 509       * form:   &quot;\object_name(instance)\counter_name&quot;
 510       * actual: &quot;\Processor(0)\% Privileged Time&quot;
 511       */
<span class="line-modified"> 512       full_counter_path_len += strlen(instance);</span>
<span class="line-modified"> 513       full_counter_path_len += OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN;</span>
 514     } else {
 515       /*
 516       * For &quot;normal&quot; paths.
 517       *
 518       * Examples:
 519       * form:   &quot;\object_name\counter_name&quot;
 520       * actual: &quot;\Memory\Available Mbytes&quot;
 521       */
<span class="line-modified"> 522       full_counter_path_len += OBJECT_COUNTER_FMT_LEN;</span>
<span class="line-removed"> 523     }</span>
<span class="line-removed"> 524     full_counter_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, full_counter_path_len + 1);</span>
<span class="line-removed"> 525     if (full_counter_path == NULL) {</span>
<span class="line-removed"> 526       return NULL;</span>
 527     }

 528     if (instance) {
<span class="line-modified"> 529       jio_snprintf_result = jio_snprintf(full_counter_path,</span>
<span class="line-modified"> 530                                          full_counter_path_len + 1,</span>
 531                                          OBJECT_WITH_INSTANCES_COUNTER_FMT,
 532                                          object_name,
 533                                          instance,
 534                                          counter_name);
 535     } else {
<span class="line-modified"> 536       jio_snprintf_result = jio_snprintf(full_counter_path,</span>
<span class="line-modified"> 537                                          full_counter_path_len + 1,</span>
 538                                          OBJECT_COUNTER_FMT,
 539                                          object_name,
 540                                          counter_name);
 541     }
 542   }
<span class="line-modified"> 543   assert(full_counter_path_len == jio_snprintf_result, &quot;invariant&quot;);</span>
<span class="line-modified"> 544   return full_counter_path;</span>
 545 }
 546 
 547 static void log_invalid_pdh_index(DWORD index) {
 548   log_warning(os)(&quot;Unable to resolve PDH index: (%ld)&quot;, index);
 549   log_warning(os)(&quot;Please check the registry if this performance object/counter is disabled&quot;);
 550 }
 551 
 552 static bool is_valid_pdh_index(DWORD index) {
 553   DWORD dummy = 0;
 554   if (PdhDll::PdhLookupPerfNameByIndex(NULL, index, NULL, &amp;dummy) != PDH_MORE_DATA) {
 555     log_invalid_pdh_index(index);
 556     return false;
 557   }
 558   return true;
 559 }
 560 
 561 /*
 562  * Maps an index to a resource area allocated string for the localized PDH artifact.
 563  *
 564  * Caller will need a ResourceMark.
 565  *
 566  * @param index    the counter index as specified in the registry
<span class="line-modified"> 567  * @param ppBuffer pointer to a char*</span>
 568  * @return         OS_OK if successful, OS_ERR on failure.
 569  */
 570 static OSReturn lookup_name_by_index(DWORD index, char** p_string) {
 571   assert(p_string != NULL, &quot;invariant&quot;);
 572   if (!is_valid_pdh_index(index)) {
 573     return OS_ERR;
 574   }
 575   // determine size needed
 576   DWORD size = 0;
 577   PDH_STATUS status = PdhDll::PdhLookupPerfNameByIndex(NULL, index, NULL, &amp;size);
 578   assert(status == PDH_MORE_DATA, &quot;invariant&quot;);
<span class="line-modified"> 579   *p_string = NEW_RESOURCE_ARRAY_RETURN_NULL(char, size);</span>
<span class="line-removed"> 580   if (*p_string== NULL) {</span>
<span class="line-removed"> 581     return OS_ERR;</span>
<span class="line-removed"> 582   }</span>
 583   if (PdhDll::PdhLookupPerfNameByIndex(NULL, index, *p_string, &amp;size) != ERROR_SUCCESS) {
 584     return OS_ERR;
 585   }
 586   if (0 == size || *p_string == NULL) {
 587     return OS_ERR;
 588   }
 589   // windows vista does not null-terminate the string (although the docs says it will)
 590   (*p_string)[size - 1] = &#39;\0&#39;;
 591   return OS_OK;
 592 }
 593 
 594 static const char* copy_string_to_c_heap(const char* string) {
 595   assert(string != NULL, &quot;invariant&quot;);
 596   const size_t len = strlen(string);
<span class="line-modified"> 597   char* const cheap_allocated_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len + 1, mtInternal);</span>
<span class="line-removed"> 598   if (NULL == cheap_allocated_string) {</span>
<span class="line-removed"> 599     return NULL;</span>
<span class="line-removed"> 600   }</span>
 601   strncpy(cheap_allocated_string, string, len + 1);
 602   return cheap_allocated_string;
 603 }
 604 
 605 /*
<span class="line-modified"> 606 * Maps an index to a resource area allocated string for the localized PDH artifact.</span>
 607 *
 608 * Caller will need a ResourceMark.
 609 *
<span class="line-modified"> 610 * @param index    the counter index as specified in the registry</span>
<span class="line-modified"> 611 * @return         localized pdh artifact string if successful, NULL on failure.</span>
 612 */
<span class="line-modified"> 613 static const char* pdh_localized_artifact(DWORD pdh_artifact_index) {</span>
 614   char* pdh_localized_artifact_string = NULL;
<span class="line-modified"> 615   // get localized name from pdh artifact index</span>
<span class="line-modified"> 616   if (lookup_name_by_index(pdh_artifact_index, &amp;pdh_localized_artifact_string) != OS_OK) {</span>
 617     return NULL;
 618   }
 619   return pdh_localized_artifact_string;
 620 }
 621 
 622 /*
 623  * Returns the PDH string identifying the current process image name.
 624  * Use this prefix when getting counters from the PDH process object
 625  * representing your process.
 626  * Ex. &quot;Process(java#0)\Virtual Bytes&quot; - where &quot;java&quot; is the PDH process
 627  * image description.
 628  *
 629  * Caller needs ResourceMark.
 630  *
<span class="line-modified"> 631  * @return the process image description. NULL if the call failed.</span>
 632 */
 633 static const char* pdh_process_image_name() {
<span class="line-modified"> 634   char* module_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, MAX_PATH);</span>
<span class="line-removed"> 635   if (NULL == module_name) {</span>
<span class="line-removed"> 636     return NULL;</span>
<span class="line-removed"> 637   }</span>
 638   // Find our module name and use it to extract the image name used by PDH
 639   DWORD getmfn_return = GetModuleFileName(NULL, module_name, MAX_PATH);
 640   if (getmfn_return &gt;= MAX_PATH || 0 == getmfn_return) {
 641     return NULL;
 642   }
 643   if (os::get_last_error() == ERROR_INSUFFICIENT_BUFFER) {
 644     return NULL;
 645   }
 646   char* process_image_name = strrchr(module_name, &#39;\\&#39;); //drop path
 647   process_image_name++;                                  //skip slash
 648   char* dot_pos = strrchr(process_image_name, &#39;.&#39;);      //drop .exe
 649   dot_pos[0] = &#39;\0&#39;;
 650   return process_image_name;
 651 }
 652 
 653 static void deallocate_pdh_constants() {
 654   FREE_C_HEAP_ARRAY(char, process_image_name);
 655   process_image_name = NULL;
<span class="line-modified"> 656   FREE_C_HEAP_ARRAY(char, pdh_IDProcess_counter_fmt);</span>
<span class="line-modified"> 657   pdh_IDProcess_counter_fmt = NULL;</span>


 658 }
 659 
<span class="line-modified"> 660 static int allocate_pdh_constants() {</span>
 661   assert(process_image_name == NULL, &quot;invariant&quot;);
 662   const char* pdh_image_name = pdh_process_image_name();
 663   if (pdh_image_name == NULL) {
 664     return OS_ERR;
 665   }
 666   process_image_name = copy_string_to_c_heap(pdh_image_name);
 667 
 668   const char* pdh_localized_process_object = pdh_localized_artifact(PDH_PROCESS_IDX);
 669   if (pdh_localized_process_object == NULL) {
 670     return OS_ERR;
 671   }
 672 
 673   const char* pdh_localized_IDProcess_counter = pdh_localized_artifact(PDH_ID_PROCESS_IDX);
 674   if (pdh_localized_IDProcess_counter == NULL) {
 675     return OS_ERR;
 676   }
 677 
<span class="line-modified"> 678   size_t pdh_IDProcess_counter_fmt_len = strlen(process_image_name);</span>
<span class="line-modified"> 679   pdh_IDProcess_counter_fmt_len += strlen(pdh_localized_process_object);</span>
<span class="line-modified"> 680   pdh_IDProcess_counter_fmt_len += strlen(pdh_localized_IDProcess_counter);</span>
<span class="line-removed"> 681   pdh_IDProcess_counter_fmt_len += PROCESS_OBJECT_INSTANCE_COUNTER_FMT_LEN;</span>
<span class="line-removed"> 682   pdh_IDProcess_counter_fmt_len += 2; // &quot;%d&quot;</span>
 683 
<span class="line-modified"> 684   assert(pdh_IDProcess_counter_fmt == NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 685   pdh_IDProcess_counter_fmt = NEW_C_HEAP_ARRAY_RETURN_NULL(char, pdh_IDProcess_counter_fmt_len + 1, mtInternal);</span>
<span class="line-modified"> 686   if (pdh_IDProcess_counter_fmt == NULL) {</span>
<span class="line-modified"> 687     return OS_ERR;</span>
<span class="line-modified"> 688   }</span>

 689 
 690   /* &quot;\Process(java#%d)\ID Process&quot; */
<span class="line-modified"> 691   const size_t len = jio_snprintf(pdh_IDProcess_counter_fmt,</span>
<span class="line-modified"> 692                                   pdh_IDProcess_counter_fmt_len + 1,</span>
<span class="line-modified"> 693                                   PROCESS_OBJECT_INSTANCE_COUNTER_FMT,</span>
<span class="line-modified"> 694                                   pdh_localized_process_object,</span>
<span class="line-modified"> 695                                   process_image_name,</span>
<span class="line-modified"> 696                                   &quot;%d&quot;,</span>
<span class="line-modified"> 697                                   pdh_localized_IDProcess_counter);</span>
<span class="line-modified"> 698 </span>
<span class="line-modified"> 699   assert(pdh_IDProcess_counter_fmt != NULL, &quot;invariant&quot;);</span>
 700   assert(len == pdh_IDProcess_counter_fmt_len, &quot;invariant&quot;);


















 701   return OS_OK;
 702 }
 703 
 704 /*
 705  * Enuerate the Processor PDH object and returns a buffer containing the enumerated instances.
 706  * Caller needs ResourceMark;
 707  *
 708  * @return  buffer if successful, NULL on failure.
 709 */
 710 static const char* enumerate_cpu_instances() {
 711   char* processor; //&#39;Processor&#39; == PDH_PROCESSOR_IDX
 712   if (lookup_name_by_index(PDH_PROCESSOR_IDX, &amp;processor) != OS_OK) {
 713     return NULL;
 714   }
 715   DWORD c_size = 0;
 716   DWORD i_size = 0;
 717   // enumerate all processors.
 718   PDH_STATUS pdhStat = PdhDll::PdhEnumObjectItems(NULL, // reserved
 719                                                   NULL, // local machine
 720                                                   processor, // object to enumerate
 721                                                   NULL,
 722                                                   &amp;c_size,
 723                                                   NULL, // instance buffer is NULL and
 724                                                   &amp;i_size,  // pass 0 length in order to get the required size
 725                                                   PERF_DETAIL_WIZARD, // counter detail level
 726                                                   0);
 727   if (PdhDll::PdhStatusFail((pdhStat))) {
 728     return NULL;
 729   }
<span class="line-modified"> 730   char* const instances = NEW_RESOURCE_ARRAY_RETURN_NULL(char, i_size);</span>
<span class="line-removed"> 731   if (instances == NULL) {</span>
<span class="line-removed"> 732     return NULL;</span>
<span class="line-removed"> 733   }</span>
 734   c_size = 0;
 735   pdhStat = PdhDll::PdhEnumObjectItems(NULL, // reserved
 736                                        NULL, // local machine
 737                                        processor, // object to enumerate
 738                                        NULL,
 739                                        &amp;c_size,
 740                                        instances, // now instance buffer is allocated to be filled in
 741                                        &amp;i_size, // and the required size is known
 742                                        PERF_DETAIL_WIZARD, // counter detail level
 743                                        0);
<span class="line-modified"> 744   if (PdhDll::PdhStatusFail((pdhStat))) {</span>
<span class="line-removed"> 745     return NULL;</span>
<span class="line-removed"> 746   }</span>
<span class="line-removed"> 747   return instances;</span>
 748 }
 749 
 750 static int count_logical_cpus(const char* instances) {
 751   assert(instances != NULL, &quot;invariant&quot;);
 752   // count logical instances.
 753   DWORD count;
 754   char* tmp;
 755   for (count = 0, tmp = const_cast&lt;char*&gt;(instances); *tmp != &#39;\0&#39;; tmp = &amp;tmp[strlen(tmp) + 1], count++);
 756   // PDH reports an instance for each logical processor plus an instance for the total (_Total)
 757   assert(count == os::processor_count() + 1, &quot;invalid enumeration!&quot;);
 758   return count - 1;
 759 }
 760 
 761 static int number_of_logical_cpus() {
 762   static int numberOfCPUS = 0;
 763   if (numberOfCPUS == 0) {
 764     const char* instances = enumerate_cpu_instances();
 765     if (instances == NULL) {
 766       return OS_ERR;
 767     }
 768     numberOfCPUS = count_logical_cpus(instances);
 769   }
 770   return numberOfCPUS;
 771 }
 772 
 773 static double cpu_factor() {
<span class="line-modified"> 774   static DWORD  numCpus = 0;</span>
 775   static double cpuFactor = .0;
 776   if (numCpus == 0) {
 777     numCpus = number_of_logical_cpus();
 778     assert(os::processor_count() &lt;= (int)numCpus, &quot;invariant&quot;);
 779     cpuFactor = numCpus * 100;
 780   }
 781   return cpuFactor;
 782 }
 783 
<span class="line-modified"> 784 static void log_error_message_on_no_PDH_artifact(const char* full_counter_name) {</span>
<span class="line-modified"> 785   log_warning(os)(&quot;Unable to register PDH query for \&quot;%s\&quot;&quot;, full_counter_name);</span>
 786   log_warning(os)(&quot;Please check the registry if this performance object/counter is disabled&quot;);
 787 }
 788 
<span class="line-modified"> 789 static int initialize_cpu_query_counters(MultiCounterQueryP cpu_query, DWORD pdh_counter_idx) {</span>
<span class="line-modified"> 790   assert(cpu_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 791   assert(cpu_query-&gt;counters != NULL, &quot;invariant&quot;);</span>
 792   char* processor; //&#39;Processor&#39; == PDH_PROCESSOR_IDX
 793   if (lookup_name_by_index(PDH_PROCESSOR_IDX, &amp;processor) != OS_OK) {
 794     return OS_ERR;
 795   }
 796   char* counter_name = NULL;
 797   if (lookup_name_by_index(pdh_counter_idx, &amp;counter_name) != OS_OK) {
 798     return OS_ERR;
 799   }
<span class="line-modified"> 800   if (cpu_query-&gt;query.query == NULL) {</span>
<span class="line-modified"> 801     if (open_query(cpu_query)) {</span>
 802       return OS_ERR;
 803     }
 804   }
<span class="line-modified"> 805   assert(cpu_query-&gt;query.query != NULL, &quot;invariant&quot;);</span>
 806   size_t counter_len = strlen(processor);
 807   counter_len += strlen(counter_name);
 808   counter_len += OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN; // &quot;\\%s(%s)\\%s&quot;
<span class="line-removed"> 809 </span>
<span class="line-removed"> 810   DWORD index;</span>
<span class="line-removed"> 811   char* tmp;</span>
 812   const char* instances = enumerate_cpu_instances();
<span class="line-modified"> 813   for (index = 0, tmp = const_cast&lt;char*&gt;(instances); *tmp != &#39;\0&#39;; tmp = &amp;tmp[strlen(tmp) + 1], index++) {</span>

 814     const size_t tmp_len = strlen(tmp);
<span class="line-modified"> 815     char* counter_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, counter_len + tmp_len + 1);</span>
<span class="line-removed"> 816     if (counter_path == NULL) {</span>
<span class="line-removed"> 817       return OS_ERR;</span>
<span class="line-removed"> 818     }</span>
 819     const size_t jio_snprintf_result = jio_snprintf(counter_path,
 820                                                     counter_len + tmp_len + 1,
 821                                                     OBJECT_WITH_INSTANCES_COUNTER_FMT,
 822                                                     processor,
 823                                                     tmp, // instance &quot;0&quot;, &quot;1&quot;, ..&quot;_Total&quot;
 824                                                     counter_name);
 825     assert(counter_len + tmp_len == jio_snprintf_result, &quot;invariant&quot;);
<span class="line-modified"> 826     if (add_counter(cpu_query, &amp;cpu_query-&gt;counters[index], counter_path, false) != OS_OK) {</span>
 827       // performance counter is disabled in registry and not accessible via PerfLib
 828       log_error_message_on_no_PDH_artifact(counter_path);
 829       // return OS_OK to have the system continue to run without the missing counter
 830       return OS_OK;
 831     }
 832   }
<span class="line-removed"> 833   cpu_query-&gt;initialized = true;</span>
 834   // Query once to initialize the counters which require at least two samples
 835   // (like the % CPU usage) to calculate correctly.
<span class="line-modified"> 836   collect_query_data(cpu_query);</span>
<span class="line-removed"> 837   return OS_OK;</span>
 838 }
 839 
<span class="line-modified"> 840 static int initialize_cpu_query(MultiCounterQueryP cpu_query, DWORD pdh_counter_idx) {</span>
<span class="line-modified"> 841   assert(cpu_query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 842   assert(!cpu_query-&gt;initialized, &quot;invariant&quot;);</span>
 843   const int logical_cpu_count = number_of_logical_cpus();
 844   assert(logical_cpu_count &gt;= os::processor_count(), &quot;invariant&quot;);
 845   // we also add another counter for instance &quot;_Total&quot;
<span class="line-modified"> 846   allocate_counters(cpu_query, logical_cpu_count + 1);</span>
<span class="line-modified"> 847   assert(cpu_query-&gt;noOfCounters == logical_cpu_count + 1, &quot;invariant&quot;);</span>
<span class="line-modified"> 848   return initialize_cpu_query_counters(cpu_query, pdh_counter_idx);</span>










































 849 }
 850 
<span class="line-modified"> 851 static int initialize_process_counter(ProcessQueryP process_query, int slot_index, DWORD pdh_counter_index) {</span>
 852   char* localized_process_object;
 853   if (lookup_name_by_index(PDH_PROCESS_IDX, &amp;localized_process_object) != OS_OK) {
 854     return OS_ERR;
 855   }
 856   assert(localized_process_object != NULL, &quot;invariant&quot;);
 857   char* localized_counter_name;
<span class="line-modified"> 858   if (lookup_name_by_index(pdh_counter_index, &amp;localized_counter_name) != OS_OK) {</span>
 859     return OS_ERR;
 860   }
 861   assert(localized_counter_name != NULL, &quot;invariant&quot;);
 862   for (int i = 0; i &lt; process_query-&gt;set.size; ++i) {
 863     char instanceIndexBuffer[32];
 864     const char* counter_path = make_fully_qualified_counter_path(localized_process_object,
 865                                                                  localized_counter_name,
 866                                                                  process_image_name,
 867                                                                  itoa(i, instanceIndexBuffer, 10));
<span class="line-modified"> 868     if (counter_path == NULL) {</span>
<span class="line-removed"> 869       return OS_ERR;</span>
<span class="line-removed"> 870     }</span>
 871     MultiCounterQueryP const query = &amp;process_query-&gt;set.queries[i];
<span class="line-modified"> 872     if (add_process_counter(query, slot_index, counter_path, true)) {</span>
 873       return OS_ERR;
 874     }




 875   }
 876   return OS_OK;
 877 }
 878 
<span class="line-modified"> 879 static CounterQueryP create_counter_query(DWORD pdh_object_idx, DWORD pdh_counter_idx) {</span>
<span class="line-modified"> 880   if (!((is_valid_pdh_index(pdh_object_idx) &amp;&amp; is_valid_pdh_index(pdh_counter_idx)))) {</span>
<span class="line-modified"> 881     return NULL;</span>



 882   }
<span class="line-modified"> 883   CounterQueryP const query = create_counter_query();</span>
<span class="line-modified"> 884   const char* object = pdh_localized_artifact(pdh_object_idx);</span>
<span class="line-modified"> 885   assert(object != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 886   const char* counter = pdh_localized_artifact(pdh_counter_idx);</span>
<span class="line-modified"> 887   assert(counter != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 888   const char* full_counter_path = make_fully_qualified_counter_path(object, counter);</span>
<span class="line-removed"> 889   assert(full_counter_path != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 890   add_counter(query, full_counter_path, true);</span>
<span class="line-removed"> 891   return query;</span>
<span class="line-removed"> 892 }</span>
<span class="line-removed"> 893 </span>
<span class="line-removed"> 894 static void deallocate() {</span>
<span class="line-removed"> 895   deallocate_pdh_constants();</span>
<span class="line-removed"> 896   PdhDll::PdhDetach();</span>
 897 }
 898 
<span class="line-modified"> 899 static LONG critical_section = 0;</span>
<span class="line-removed"> 900 static LONG reference_count = 0;</span>
 901 static bool pdh_initialized = false;
 902 














 903 static void on_initialization_failure() {
<span class="line-modified"> 904   // still holder of critical section</span>
<span class="line-modified"> 905   deallocate();</span>
<span class="line-modified"> 906   InterlockedExchangeAdd(&amp;reference_count, -1);</span>


 907 }
 908 
 909 static OSReturn initialize() {

 910   ResourceMark rm;
 911   if (!PdhDll::PdhAttach()) {
 912     return OS_ERR;
 913   }
 914   if (allocate_pdh_constants() != OS_OK) {
 915     on_initialization_failure();
 916     return OS_ERR;
 917   }









 918   return OS_OK;
 919 }
 920 
 921 /*
 922 * Helper to initialize the PDH library, function pointers, constants and counters.
 923 *
 924 * Reference counting allows for unloading of pdh.dll granted all sessions use the pair:
 925 *
 926 *   pdh_acquire();
 927 *   pdh_release();
 928 *
 929 * @return  OS_OK if successful, OS_ERR on failure.
 930 */
<span class="line-modified"> 931 static bool pdh_acquire() {</span>
<span class="line-modified"> 932   while (InterlockedCompareExchange(&amp;critical_section, 1, 0) == 1);</span>
<span class="line-modified"> 933   InterlockedExchangeAdd(&amp;reference_count, 1);</span>
 934   if (pdh_initialized) {
<span class="line-modified"> 935     return true;</span>
 936   }
<span class="line-modified"> 937   const OSReturn ret = initialize();</span>
<span class="line-modified"> 938   if (OS_OK == ret) {</span>
<span class="line-modified"> 939     pdh_initialized = true;</span>
<span class="line-removed"> 940   }</span>
<span class="line-removed"> 941   while (InterlockedCompareExchange(&amp;critical_section, 0, 1) == 0);</span>
<span class="line-removed"> 942   return ret == OS_OK;</span>
 943 }
 944 
 945 static void pdh_release() {
<span class="line-modified"> 946   while (InterlockedCompareExchange(&amp;critical_section, 1, 0) == 1);</span>
<span class="line-modified"> 947   const LONG prev_ref_count = InterlockedExchangeAdd(&amp;reference_count, -1);</span>
<span class="line-modified"> 948   if (1 == prev_ref_count) {</span>
<span class="line-modified"> 949     deallocate();</span>
 950     pdh_initialized = false;
 951   }
<span class="line-removed"> 952   while (InterlockedCompareExchange(&amp;critical_section, 0, 1) == 0);</span>
 953 }
 954 
 955 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
 956   friend class CPUPerformanceInterface;
 957  private:
 958   CounterQueryP _context_switches;
 959   ProcessQueryP _process_cpu_load;
 960   MultiCounterQueryP _machine_cpu_load;
 961 
 962   int cpu_load(int which_logical_cpu, double* cpu_load);
 963   int context_switch_rate(double* rate);
 964   int cpu_load_total_process(double* cpu_load);
<span class="line-modified"> 965   int cpu_loads_process(double* jvm_user_load, double* jvm_kernel_load, double* psystemTotalLoad);</span>
 966   CPUPerformance();
 967   ~CPUPerformance();
 968   bool initialize();
 969 };
 970 
<span class="line-removed"> 971 class SystemProcessInterface::SystemProcesses : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-removed"> 972   friend class SystemProcessInterface;</span>
<span class="line-removed"> 973  private:</span>
<span class="line-removed"> 974   class ProcessIterator : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-removed"> 975     friend class SystemProcessInterface::SystemProcesses;</span>
<span class="line-removed"> 976    private:</span>
<span class="line-removed"> 977     HANDLE         _hProcessSnap;</span>
<span class="line-removed"> 978     PROCESSENTRY32 _pe32;</span>
<span class="line-removed"> 979     BOOL           _valid;</span>
<span class="line-removed"> 980     char           _exePath[MAX_PATH];</span>
<span class="line-removed"> 981     ProcessIterator();</span>
<span class="line-removed"> 982     ~ProcessIterator();</span>
<span class="line-removed"> 983     bool initialize();</span>
<span class="line-removed"> 984 </span>
<span class="line-removed"> 985     int current(SystemProcess* const process_info);</span>
<span class="line-removed"> 986     int next_process();</span>
<span class="line-removed"> 987     bool is_valid() const { return _valid != FALSE; }</span>
<span class="line-removed"> 988     char* allocate_string(const char* str) const;</span>
<span class="line-removed"> 989     int snapshot();</span>
<span class="line-removed"> 990   };</span>
<span class="line-removed"> 991 </span>
<span class="line-removed"> 992   ProcessIterator* _iterator;</span>
<span class="line-removed"> 993   SystemProcesses();</span>
<span class="line-removed"> 994   ~SystemProcesses();</span>
<span class="line-removed"> 995   bool initialize();</span>
<span class="line-removed"> 996 </span>
<span class="line-removed"> 997   // information about system processes</span>
<span class="line-removed"> 998   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;</span>
<span class="line-removed"> 999 };</span>
<span class="line-removed">1000 </span>
1001 CPUPerformanceInterface::CPUPerformance::CPUPerformance() : _context_switches(NULL), _process_cpu_load(NULL), _machine_cpu_load(NULL) {}
1002 
1003 bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified">1004   if (!pdh_acquire()) {</span>
<span class="line-modified">1005     return true;</span>
1006   }
<span class="line-modified">1007   _context_switches = create_counter_query(PDH_SYSTEM_IDX, PDH_CONTEXT_SWITCH_RATE_IDX);</span>





1008   _process_cpu_load = create_process_query();
1009   if (_process_cpu_load == NULL) {
<span class="line-modified">1010     return true;</span>
<span class="line-removed">1011   }</span>
<span class="line-removed">1012   allocate_counters(_process_cpu_load, 2);</span>
<span class="line-removed">1013   if (initialize_process_counter(_process_cpu_load, 0, PDH_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-removed">1014     return true;</span>
1015   }
<span class="line-modified">1016   if (initialize_process_counter(_process_cpu_load, 1, PDH_PRIV_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-modified">1017     return true;</span>
1018   }
<span class="line-modified">1019   _process_cpu_load-&gt;set.initialized = true;</span>
1020   _machine_cpu_load = create_multi_counter_query();
<span class="line-modified">1021   if (_machine_cpu_load == NULL) {</span>
<span class="line-modified">1022     return true;</span>

1023   }
<span class="line-modified">1024   initialize_cpu_query(_machine_cpu_load, PDH_PROCESSOR_TIME_IDX);</span>
1025   return true;
1026 }
1027 
1028 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
1029   if (_context_switches != NULL) {
<span class="line-modified">1030     destroy_counter_query(_context_switches);</span>
1031     _context_switches = NULL;
1032   }
1033   if (_process_cpu_load != NULL) {
<span class="line-modified">1034     destroy_counter_query(_process_cpu_load);</span>
1035     _process_cpu_load = NULL;
1036   }
1037   if (_machine_cpu_load != NULL) {
<span class="line-modified">1038     destroy_counter_query(_machine_cpu_load);</span>
1039     _machine_cpu_load = NULL;
1040   }
1041   pdh_release();
1042 }
1043 
<span class="line-modified">1044 CPUPerformanceInterface::CPUPerformanceInterface() {</span>
<span class="line-removed">1045   _impl = NULL;</span>
<span class="line-removed">1046 }</span>
1047 
1048 bool CPUPerformanceInterface::initialize() {
1049   _impl = new CPUPerformanceInterface::CPUPerformance();
1050   return _impl-&gt;initialize();
1051 }
1052 
1053 CPUPerformanceInterface::~CPUPerformanceInterface() {
1054   if (_impl != NULL) {
1055     delete _impl;
1056   }
1057 }
1058 
1059 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
1060   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
1061 }
1062 
1063 int CPUPerformanceInterface::context_switch_rate(double* rate) const {
1064   return _impl-&gt;context_switch_rate(rate);
1065 }
1066 
1067 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
1068   return _impl-&gt;cpu_load_total_process(cpu_load);
1069 }
1070 
<span class="line-modified">1071 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad,</span>
<span class="line-modified">1072                                                double* pjvmKernelLoad,</span>
<span class="line-modified">1073                                                double* psystemTotalLoad) const {</span>
<span class="line-modified">1074   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);</span>
1075 }
1076 
1077 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
1078   *cpu_load = .0;
1079   if (_machine_cpu_load == NULL || !_machine_cpu_load-&gt;initialized) {
1080     return OS_ERR;
1081   }
<span class="line-removed">1082   assert(_machine_cpu_load != NULL, &quot;invariant&quot;);</span>
1083   assert(which_logical_cpu &lt; _machine_cpu_load-&gt;noOfCounters, &quot;invariant&quot;);
<span class="line-modified">1084 </span>
<span class="line-removed">1085   if (collect_query_data(_machine_cpu_load)) {</span>
1086     return OS_ERR;
1087   }
1088   // -1 is total (all cpus)
1089   const int counter_idx = -1 == which_logical_cpu ? _machine_cpu_load-&gt;noOfCounters - 1 : which_logical_cpu;
1090   PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">1091   formatted_counter_value(_machine_cpu_load-&gt;counters[counter_idx], PDH_FMT_DOUBLE, &amp;counter_value);</span>


1092   *cpu_load = counter_value.doubleValue / 100;
1093   return OS_OK;
1094 }
1095 
1096 int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {
1097   *cpu_load = .0;
1098   if (_process_cpu_load == NULL || !_process_cpu_load-&gt;set.initialized) {
1099     return OS_ERR;
1100   }
<span class="line-modified">1101   assert(_process_cpu_load != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1102   if (collect_process_query_data(_process_cpu_load)) {</span>
1103     return OS_ERR;
1104   }
1105   PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">1106   if (query_process_counter(_process_cpu_load, 0, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
1107     return OS_ERR;
1108   }
1109   double process_load = counter_value.doubleValue / cpu_factor();
1110   process_load = MIN2&lt;double&gt;(1, process_load);
1111   process_load = MAX2&lt;double&gt;(0, process_load);
1112   *cpu_load = process_load;
1113   return OS_OK;
1114 }
1115 
<span class="line-modified">1116 int CPUPerformanceInterface::CPUPerformance::cpu_loads_process(double* pjvmUserLoad,</span>
<span class="line-modified">1117                                                                double* pjvmKernelLoad,</span>
<span class="line-modified">1118                                                                double* psystemTotalLoad) {</span>
<span class="line-modified">1119   assert(pjvmUserLoad != NULL, &quot;pjvmUserLoad is NULL!&quot;);</span>
<span class="line-modified">1120   assert(pjvmKernelLoad != NULL, &quot;pjvmKernelLoad is NULL!&quot;);</span>
<span class="line-modified">1121   assert(psystemTotalLoad != NULL, &quot;psystemTotalLoad is NULL!&quot;);</span>
<span class="line-modified">1122   *pjvmUserLoad = .0;</span>
<span class="line-modified">1123   *pjvmKernelLoad = .0;</span>
<span class="line-modified">1124   *psystemTotalLoad = .0;</span>
1125 
1126   if (_process_cpu_load == NULL || !_process_cpu_load-&gt;set.initialized) {
1127     return OS_ERR;
1128   }
<span class="line-modified">1129   assert(_process_cpu_load != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1130   if (collect_process_query_data(_process_cpu_load)) {</span>
1131     return OS_ERR;
1132   }
1133   double process_load = .0;
1134   PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">1135   // Read  PDH_PROCESSOR_TIME_IDX</span>
<span class="line-modified">1136   if (query_process_counter(_process_cpu_load, 0, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
1137     return OS_ERR;
1138   }
1139   process_load = counter_value.doubleValue / cpu_factor();
1140   process_load = MIN2&lt;double&gt;(1, process_load);
1141   process_load = MAX2&lt;double&gt;(0, process_load);
<span class="line-modified">1142   // Read PDH_PRIV_PROCESSOR_TIME_IDX</span>
<span class="line-modified">1143   if (query_process_counter(_process_cpu_load, 1, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
1144     return OS_ERR;
1145   }
<span class="line-modified">1146   double kernel_load = counter_value.doubleValue / cpu_factor();</span>
<span class="line-modified">1147   kernel_load = MIN2&lt;double&gt;(1, kernel_load);</span>
<span class="line-modified">1148   kernel_load = MAX2&lt;double&gt;(0, kernel_load);</span>
<span class="line-modified">1149   *pjvmKernelLoad = kernel_load;</span>
1150 
<span class="line-modified">1151   double user_load = process_load - kernel_load;</span>
1152   user_load = MIN2&lt;double&gt;(1, user_load);
1153   user_load = MAX2&lt;double&gt;(0, user_load);
<span class="line-modified">1154   *pjvmUserLoad = user_load;</span>
<span class="line-modified">1155 </span>
<span class="line-removed">1156   if (collect_query_data(_machine_cpu_load)) {</span>
1157     return OS_ERR;
1158   }
<span class="line-modified">1159   if (formatted_counter_value(_machine_cpu_load-&gt;counters[_machine_cpu_load-&gt;noOfCounters - 1], PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>

1160     return OS_ERR;
1161   }
1162   double machine_load = counter_value.doubleValue / 100;
1163   assert(machine_load &gt;= 0, &quot;machine_load is negative!&quot;);
1164   // clamp at user+system and 1.0
<span class="line-modified">1165   if (*pjvmKernelLoad + *pjvmUserLoad &gt; machine_load) {</span>
<span class="line-modified">1166     machine_load = MIN2(*pjvmKernelLoad + *pjvmUserLoad, 1.0);</span>
1167   }
<span class="line-modified">1168   *psystemTotalLoad = machine_load;</span>
1169   return OS_OK;
1170 }
1171 
1172 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
1173   assert(rate != NULL, &quot;invariant&quot;);
1174   *rate = .0;
1175   if (_context_switches == NULL || !_context_switches-&gt;initialized) {
1176     return OS_ERR;
1177   }
<span class="line-modified">1178   assert(_context_switches != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1179   if (collect_query_data(_context_switches) != OS_OK) {</span>
1180     return OS_ERR;
1181   }
1182   PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">1183   if (formatted_counter_value(_context_switches-&gt;counter, PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
1184     return OS_ERR;
1185   }
1186   *rate = counter_value.doubleValue;
1187   return OS_OK;
1188 }
1189 






























1190 SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {
1191   _hProcessSnap = INVALID_HANDLE_VALUE;
1192   _valid = FALSE;
1193   _pe32.dwSize = sizeof(PROCESSENTRY32);
1194 }
1195 
1196 bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {
1197   return true;
1198 }
1199 
1200 int SystemProcessInterface::SystemProcesses::ProcessIterator::snapshot() {
1201   // take snapshot of all process in the system
1202   _hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
1203   if (_hProcessSnap == INVALID_HANDLE_VALUE) {
1204     return OS_ERR;
1205   }
1206   // step to first process
1207   _valid = Process32First(_hProcessSnap, &amp;_pe32);
1208   return is_valid() ? OS_OK : OS_ERR;
1209 }
</pre>
<hr />
<pre>
1219   assert(process_info != NULL, &quot;process_info is NULL!&quot;);
1220   char* exePath = NULL;
1221   HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, _pe32.th32ProcessID);
1222   if (hProcess != NULL) {
1223     HMODULE hMod;
1224     DWORD cbNeeded;
1225     if (EnumProcessModules(hProcess, &amp;hMod, sizeof(hMod), &amp;cbNeeded) != 0) {
1226       if (GetModuleFileNameExA(hProcess, hMod, _exePath, sizeof(_exePath)) != 0) {
1227         exePath = _exePath;
1228       }
1229     }
1230     CloseHandle (hProcess);
1231   }
1232   process_info-&gt;set_pid((int)_pe32.th32ProcessID);
1233   process_info-&gt;set_name(allocate_string(_pe32.szExeFile));
1234   process_info-&gt;set_path(allocate_string(exePath));
1235   return OS_OK;
1236 }
1237 
1238 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
<span class="line-modified">1239   if (str != NULL) {</span>
<span class="line-removed">1240     return os::strdup_check_oom(str, mtInternal);</span>
<span class="line-removed">1241   }</span>
<span class="line-removed">1242   return NULL;</span>
1243 }
1244 
1245 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
1246   _valid = Process32Next(_hProcessSnap, &amp;_pe32);
1247   return OS_OK;
1248 }
1249 
<span class="line-modified">1250 SystemProcessInterface::SystemProcesses::SystemProcesses() {</span>
<span class="line-removed">1251   _iterator = NULL;</span>
<span class="line-removed">1252 }</span>
1253 
1254 bool SystemProcessInterface::SystemProcesses::initialize() {
1255   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
1256   return _iterator-&gt;initialize();
1257 }
1258 
1259 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
1260   if (_iterator != NULL) {
1261     delete _iterator;
<span class="line-removed">1262     _iterator = NULL;</span>
1263   }
1264 }
1265 
1266 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes,
1267                                                               int* no_of_sys_processes) const {
1268   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
1269   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
1270   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
1271 
1272   // initialize pointers
1273   *no_of_sys_processes = 0;
1274   *system_processes = NULL;
1275 
1276   // take process snapshot
1277   if (_iterator-&gt;snapshot() != OS_OK) {
1278     return OS_ERR;
1279   }
1280 
1281   while (_iterator-&gt;is_valid()) {
1282     SystemProcess* tmp = new SystemProcess();
</pre>
<hr />
<pre>
1285     //if already existing head
1286     if (*system_processes != NULL) {
1287       //move &quot;first to second&quot;
1288       tmp-&gt;set_next(*system_processes);
1289     }
1290     // new head
1291     *system_processes = tmp;
1292     // increment
1293     (*no_of_sys_processes)++;
1294     // step forward
1295     _iterator-&gt;next_process();
1296   }
1297   return OS_OK;
1298 }
1299 
1300 int SystemProcessInterface::system_processes(SystemProcess** system_procs,
1301                                              int* no_of_sys_processes) const {
1302   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
1303 }
1304 
<span class="line-modified">1305 SystemProcessInterface::SystemProcessInterface() {</span>
<span class="line-removed">1306   _impl = NULL;</span>
<span class="line-removed">1307 }</span>
1308 
1309 bool SystemProcessInterface::initialize() {
1310   _impl = new SystemProcessInterface::SystemProcesses();
1311   return _impl-&gt;initialize();
1312 }
1313 
1314 SystemProcessInterface::~SystemProcessInterface() {
1315   if (_impl != NULL) {
1316     delete _impl;
1317   }
1318 }
1319 
<span class="line-modified">1320 CPUInformationInterface::CPUInformationInterface() {</span>
<span class="line-removed">1321   _cpu_info = NULL;</span>
<span class="line-removed">1322 }</span>
1323 
1324 bool CPUInformationInterface::initialize() {
1325   _cpu_info = new CPUInformation();
1326   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
1327   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
1328   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
1329   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
1330   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
1331   return true;
1332 }
1333 
1334 CPUInformationInterface::~CPUInformationInterface() {
1335   if (_cpu_info != NULL) {
1336     FREE_C_HEAP_ARRAY(char, _cpu_info-&gt;cpu_name());
1337     _cpu_info-&gt;set_cpu_name(NULL);
1338     FREE_C_HEAP_ARRAY(char, _cpu_info-&gt;cpu_description());
1339     _cpu_info-&gt;set_cpu_description(NULL);
1340     delete _cpu_info;
<span class="line-removed">1341     _cpu_info = NULL;</span>
1342   }
1343 }
1344 
1345 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
1346   if (NULL == _cpu_info) {
1347     return OS_ERR;
1348   }
1349   cpu_info = *_cpu_info; // shallow copy assignment
1350   return OS_OK;
1351 }
1352 
1353 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
1354   friend class NetworkPerformanceInterface;
1355  private:
1356   bool _iphlp_attached;
1357 
1358   NetworkPerformance();
1359   NONCOPYABLE(NetworkPerformance);
1360   bool initialize();
1361   ~NetworkPerformance();
1362   int network_utilization(NetworkInterface** network_interfaces) const;
1363 };
1364 
<span class="line-modified">1365 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance()</span>
<span class="line-removed">1366 : _iphlp_attached(false) {</span>
<span class="line-removed">1367 }</span>
1368 
1369 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
1370   _iphlp_attached = IphlpDll::IphlpAttach();
1371   return _iphlp_attached;
1372 }
1373 
1374 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
1375   if (_iphlp_attached) {
1376     IphlpDll::IphlpDetach();
1377   }
1378 }
1379 
1380 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const {
1381   MIB_IF_TABLE2* table;
1382 
1383   if (IphlpDll::GetIfTable2(&amp;table) != NO_ERROR) {
1384     return OS_ERR;
1385   }
1386 
1387   NetworkInterface* ret = NULL;
1388   for (ULONG i = 0; i &lt; table-&gt;NumEntries; ++i) {
1389     if (table-&gt;Table[i].InterfaceAndOperStatusFlags.FilterInterface) {
1390       continue;
1391     }
1392 
1393     char buf[256];
1394     if (WideCharToMultiByte(CP_UTF8, 0, table-&gt;Table[i].Description, -1, buf, sizeof(buf), NULL, NULL) == 0) {
1395       continue;
1396     }
1397 
1398     NetworkInterface* cur = new NetworkInterface(buf, table-&gt;Table[i].InOctets, table-&gt;Table[i].OutOctets, ret);
1399     ret = cur;
1400   }
1401 
1402   IphlpDll::FreeMibTable(table);
1403   *network_interfaces = ret;
1404 
1405   return OS_OK;
1406 }
1407 
<span class="line-modified">1408 NetworkPerformanceInterface::NetworkPerformanceInterface() {</span>
<span class="line-removed">1409   _impl = NULL;</span>
<span class="line-removed">1410 }</span>
1411 
1412 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1413   if (_impl != NULL) {
1414     delete _impl;
1415   }
1416 }
1417 
1418 bool NetworkPerformanceInterface::initialize() {
1419   _impl = new NetworkPerformanceInterface::NetworkPerformance();
1420   return _impl-&gt;initialize();
1421 }
1422 
1423 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1424   return _impl-&gt;network_utilization(network_interfaces);
1425 }
</pre>
</td>
<td>
<hr />
<pre>
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;iphlp_interface.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;pdh_interface.hpp&quot;
  31 #include &quot;runtime/os_perf.hpp&quot;
  32 #include &quot;runtime/os.hpp&quot;
<span class="line-added">  33 #include &quot;runtime/semaphore.inline.hpp&quot;</span>
  34 #include &quot;utilities/globalDefinitions.hpp&quot;
  35 #include &quot;utilities/macros.hpp&quot;
  36 #include CPU_HEADER(vm_version_ext)
  37 #include &lt;math.h&gt;
  38 #include &lt;psapi.h&gt;
  39 #include &lt;TlHelp32.h&gt;
  40 
  41 /*
  42  * Windows provides a vast plethora of performance objects and counters,
  43  * consumption of which is assisted using the Performance Data Helper (PDH) interface.
  44  * We import a selected few api entry points from PDH, see pdh_interface.hpp.
  45  *
  46  * The code located in this file is to a large extent an abstraction over much of the
  47  * plumbing needed to start consuming an object and/or counter of choice.
  48  *
<span class="line-modified">  49  *</span>


  50  * How to use:
<span class="line-modified">  51  * 1. Create a query</span>
  52  * 2. Add counters to the query
  53  * 3. Collect the performance data using the query
<span class="line-modified">  54  * 4. Read the performance data from counters associated with the query</span>
  55  * 5. Destroy query (counter destruction implied)
<span class="line-modified">  56  *</span>
<span class="line-modified">  57  *</span>

  58  * Every PDH artifact, like processor, process, thread, memory, and so forth are
  59  * identified with an index that is always the same irrespective
  60  * of the localized version of the operating system or service pack installed.
  61  * INFO: Using PDH APIs Correctly in a Localized Language (Q287159)
  62  *   http://support.microsoft.com/default.aspx?scid=kb;EN-US;q287159
  63  *
  64  * To find the correct index for an object or counter, inspect the registry key / value:
  65  * [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib\009\Counter]
  66  *
  67  * some common PDH indexes
  68  */
  69 static const DWORD PDH_PROCESSOR_IDX = 238;
  70 static const DWORD PDH_PROCESSOR_TIME_IDX = 6;
  71 static const DWORD PDH_PRIV_PROCESSOR_TIME_IDX = 144;
  72 static const DWORD PDH_PROCESS_IDX = 230;
  73 static const DWORD PDH_ID_PROCESS_IDX = 784;
  74 static const DWORD PDH_CONTEXT_SWITCH_RATE_IDX = 146;
  75 static const DWORD PDH_SYSTEM_IDX = 2;
  76 
<span class="line-modified">  77 /* useful pdh fmt&#39;s for the general form: \object(instance#index)\counter */</span>
  78 static const char* const OBJECT_COUNTER_FMT = &quot;\\%s\\%s&quot;;
  79 static const size_t OBJECT_COUNTER_FMT_LEN = 2;
  80 static const char* const OBJECT_WITH_INSTANCES_COUNTER_FMT = &quot;\\%s(%s)\\%s&quot;;
  81 static const size_t OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN = 4;
<span class="line-modified">  82 static const char* const PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT = &quot;\\%s(%s#%s)\\%s&quot;;</span>
<span class="line-modified">  83 static const size_t PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN = 5;</span>
<span class="line-modified">  84 static const char* const PROCESS_OBJECT_WITH_INSTANCES_WILDCARD_FMT = &quot;\\%s(%s*)\\%s&quot;;</span>
<span class="line-modified">  85 static const size_t PROCESS_OBJECT_WITH_INSTANCES_WILDCARD_FMT_LEN = 5;</span>

  86 
<span class="line-modified">  87 /* pdh string constants built up from fmts on initialization */</span>
<span class="line-modified">  88 static const char* process_image_name = NULL; // e.g. &quot;java&quot; but could have another image name</span>
<span class="line-modified">  89 static char* pdh_process_instance_IDProcess_counter_fmt = NULL; // &quot;\Process(java#%d)\ID Process&quot; */</span>
<span class="line-modified">  90 static char* pdh_process_instance_wildcard_IDProcess_counter = NULL; // &quot;\Process(java*)\ID Process&quot; */</span>
  91 
  92 /*
  93 * Structs for PDH queries.
  94 */
  95 typedef struct {
<span class="line-modified">  96   HQUERY pdh_query_handle;</span>
  97   s8     lastUpdate; // Last time query was updated.
  98 } UpdateQueryS, *UpdateQueryP;
  99 
 100 
 101 typedef struct {
 102   UpdateQueryS query;
 103   HCOUNTER     counter;
 104   bool         initialized;
 105 } CounterQueryS, *CounterQueryP;
 106 
 107 typedef struct {
 108   UpdateQueryS query;
 109   HCOUNTER*    counters;
 110   int          noOfCounters;
 111   bool         initialized;
 112 } MultiCounterQueryS, *MultiCounterQueryP;
 113 
 114 typedef struct {
 115   MultiCounterQueryP queries;
 116   int                size;
 117   bool               initialized;
 118 } MultiCounterQuerySetS, *MultiCounterQuerySetP;
 119 
 120 typedef struct {
 121   MultiCounterQuerySetS set;
<span class="line-modified"> 122   int                   process_idx;</span>
 123 } ProcessQueryS, *ProcessQueryP;
 124 
<span class="line-modified"> 125 static int open_query(HQUERY* pdh_query_handle) {</span>
<span class="line-added"> 126   return PdhDll::PdhOpenQuery(NULL, 0, pdh_query_handle) != ERROR_SUCCESS ? OS_ERR : OS_OK;</span>
<span class="line-added"> 127 }</span>
<span class="line-added"> 128 </span>
<span class="line-added"> 129 static int open_query(UpdateQueryP query) {</span>
<span class="line-added"> 130   return open_query(&amp;query-&gt;pdh_query_handle);</span>
<span class="line-added"> 131 }</span>
<span class="line-added"> 132 </span>
<span class="line-added"> 133 template &lt;typename QueryP&gt;</span>
<span class="line-added"> 134 static int open_query(QueryP query) {</span>
<span class="line-added"> 135   return open_query(&amp;query-&gt;query);</span>
<span class="line-added"> 136 }</span>
<span class="line-added"> 137 </span>
<span class="line-added"> 138 static void close_query(HQUERY* const pdh_query_handle, HCOUNTER* const counter) {</span>
 139   if (counter != NULL &amp;&amp; *counter != NULL) {
 140     PdhDll::PdhRemoveCounter(*counter);
 141     *counter = NULL;
 142   }
<span class="line-modified"> 143   if (pdh_query_handle != NULL &amp;&amp; *pdh_query_handle != NULL) {</span>
<span class="line-modified"> 144     PdhDll::PdhCloseQuery(*pdh_query_handle);</span>
<span class="line-modified"> 145     *pdh_query_handle = NULL;</span>
 146   }
 147 }
 148 
<span class="line-added"> 149 static void close_query(MultiCounterQueryP query) {</span>
<span class="line-added"> 150   for (int i = 0; i &lt; query-&gt;noOfCounters; ++i) {</span>
<span class="line-added"> 151     close_query(NULL, &amp;query-&gt;counters[i]);</span>
<span class="line-added"> 152   }</span>
<span class="line-added"> 153   close_query(&amp;query-&gt;query.pdh_query_handle, NULL);</span>
<span class="line-added"> 154   query-&gt;initialized = false;</span>
<span class="line-added"> 155 }</span>
<span class="line-added"> 156 </span>
 157 static CounterQueryP create_counter_query() {
 158   CounterQueryP const query = NEW_C_HEAP_OBJ(CounterQueryS, mtInternal);
 159   memset(query, 0, sizeof(CounterQueryS));
 160   return query;
 161 }
 162 






 163 static MultiCounterQueryP create_multi_counter_query() {
 164   MultiCounterQueryP const query = NEW_C_HEAP_ARRAY(MultiCounterQueryS, 1, mtInternal);
 165   memset(query, 0, sizeof(MultiCounterQueryS));
 166   return query;
 167 }
 168 
<span class="line-modified"> 169 static void destroy(CounterQueryP query) {</span>
<span class="line-modified"> 170   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 171   close_query(&amp;query-&gt;query.pdh_query_handle, &amp;query-&gt;counter);</span>
<span class="line-modified"> 172   FREE_C_HEAP_OBJ(query);</span>





 173 }
 174 
<span class="line-modified"> 175 static void destroy(MultiCounterQueryP query) {</span>
<span class="line-modified"> 176   if (query != NULL) {</span>
<span class="line-modified"> 177     for (int i = 0; i &lt; query-&gt;noOfCounters; ++i) {</span>
<span class="line-modified"> 178       close_query(NULL, &amp;query-&gt;counters[i]);</span>
 179     }
<span class="line-modified"> 180     FREE_C_HEAP_ARRAY(char, query-&gt;counters);</span>
<span class="line-modified"> 181     close_query(&amp;query-&gt;query.pdh_query_handle, NULL);</span>
<span class="line-added"> 182     FREE_C_HEAP_ARRAY(MultiCounterQueryS, query);</span>
 183   }






 184 }
 185 
<span class="line-modified"> 186 static void destroy_query_set(MultiCounterQuerySetP query_set) {</span>
<span class="line-modified"> 187   for (int i = 0; i &lt; query_set-&gt;size; i++) {</span>
<span class="line-modified"> 188     for (int j = 0; j &lt; query_set-&gt;queries[i].noOfCounters; ++j) {</span>
<span class="line-added"> 189       close_query(NULL, &amp;query_set-&gt;queries[i].counters[j]);</span>
<span class="line-added"> 190     }</span>
<span class="line-added"> 191     FREE_C_HEAP_ARRAY(char, query_set-&gt;queries[i].counters);</span>
<span class="line-added"> 192     close_query(&amp;query_set-&gt;queries[i].query.pdh_query_handle, NULL);</span>
<span class="line-added"> 193   }</span>
<span class="line-added"> 194   FREE_C_HEAP_ARRAY(MultiCounterQueryS, query_set-&gt;queries);</span>
 195 }
 196 
<span class="line-modified"> 197 static void destroy(MultiCounterQuerySetP query) {</span>
<span class="line-modified"> 198   destroy_query_set(query);</span>
<span class="line-added"> 199   FREE_C_HEAP_ARRAY(MultiCounterQuerySetS, query);</span>
 200 }
 201 
<span class="line-modified"> 202 static void destroy(ProcessQueryP query) {</span>
<span class="line-modified"> 203   destroy_query_set(&amp;query-&gt;set);</span>
<span class="line-modified"> 204   FREE_C_HEAP_OBJ(query);</span>
 205 }
 206 
 207 static void allocate_counters(MultiCounterQueryP query, size_t nofCounters) {
 208   assert(query != NULL, &quot;invariant&quot;);
 209   assert(!query-&gt;initialized, &quot;invariant&quot;);
 210   assert(0 == query-&gt;noOfCounters, &quot;invariant&quot;);
 211   assert(query-&gt;counters == NULL, &quot;invariant&quot;);
 212   query-&gt;counters = NEW_C_HEAP_ARRAY(HCOUNTER, nofCounters, mtInternal);
 213   memset(query-&gt;counters, 0, nofCounters * sizeof(HCOUNTER));
 214   query-&gt;noOfCounters = (int)nofCounters;
 215 }
 216 
<span class="line-modified"> 217 static void allocate_counters(MultiCounterQuerySetP query, size_t nofCounters) {</span>
<span class="line-modified"> 218   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 219   assert(!query-&gt;initialized, &quot;invariant&quot;);</span>
<span class="line-modified"> 220   for (int i = 0; i &lt; query-&gt;size; ++i) {</span>
<span class="line-modified"> 221     allocate_counters(&amp;query-&gt;queries[i], nofCounters);</span>
 222   }
 223 }
 224 
<span class="line-modified"> 225 static void allocate_counters(ProcessQueryP query, size_t nofCounters) {</span>
<span class="line-modified"> 226   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 227   allocate_counters(&amp;query-&gt;set, nofCounters);</span>
 228 }
 229 
 230 static void deallocate_counters(MultiCounterQueryP query) {
 231   FREE_C_HEAP_ARRAY(char, query-&gt;counters);
 232   query-&gt;counters = NULL;
 233   query-&gt;noOfCounters = 0;
 234 }
 235 
<span class="line-modified"> 236 static OSReturn add_counter(UpdateQueryP query, HCOUNTER* counter, const char* counter_path, bool first_sample_on_init) {</span>
 237   assert(query != NULL, &quot;invariant&quot;);
 238   assert(counter != NULL, &quot;invariant&quot;);
<span class="line-modified"> 239   assert(counter_path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 240   if (query-&gt;pdh_query_handle == NULL) {</span>
<span class="line-modified"> 241     if (open_query(query) != OS_OK) {</span>
 242       return OS_ERR;
 243     }
 244   }
<span class="line-modified"> 245   assert(query-&gt;pdh_query_handle != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 246   PDH_STATUS status = PdhDll::PdhAddCounter(query-&gt;pdh_query_handle, counter_path, 0, counter);</span>
 247   if (PDH_CSTATUS_NO_OBJECT == status || PDH_CSTATUS_NO_COUNTER == status) {
 248     return OS_ERR;
 249   }
 250   /*
 251   * According to the MSDN documentation, rate counters must be read twice:
 252   *
 253   * &quot;Obtaining the value of rate counters such as Page faults/sec requires that
 254   *  PdhCollectQueryData be called twice, with a specific time interval between
 255   *  the two calls, before calling PdhGetFormattedCounterValue. Call Sleep to
 256   *  implement the waiting period between the two calls to PdhCollectQueryData.&quot;
 257   *
 258   *  Take the first sample here already to allow for the next &quot;real&quot; sample
 259   *  to succeed.
 260   */
<span class="line-modified"> 261   if (first_sample_on_init &amp;&amp; PdhDll::PdhCollectQueryData(query-&gt;pdh_query_handle) != ERROR_SUCCESS) {</span>
<span class="line-modified"> 262     return OS_ERR;</span>
 263   }
 264   return OS_OK;
 265 }
 266 
 267 template &lt;typename QueryP&gt;
<span class="line-modified"> 268 static OSReturn add_counter(QueryP query, HCOUNTER* counter, const char* counter_path, bool first_sample_on_init) {</span>
<span class="line-modified"> 269   assert(query != NULL, &quot;invariant&quot;);</span>
 270   assert(counter != NULL, &quot;invariant&quot;);
<span class="line-modified"> 271   assert(counter_path != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 272   return add_counter(&amp;query-&gt;query, counter, counter_path, first_sample_on_init);</span>
 273 }
 274 
<span class="line-modified"> 275 // if add_counter fails with OS_ERR, the performance counter might be disabled in the registry</span>
<span class="line-modified"> 276 static OSReturn add_counter(CounterQueryP query, const char* counter_path, bool first_sample_on_init = true) {</span>
<span class="line-modified"> 277   return add_counter(query, &amp;query-&gt;counter, counter_path, first_sample_on_init);</span>




 278 }
 279 
<span class="line-modified"> 280 static OSReturn add_counter(MultiCounterQueryP query, int counter_idx, const char* counter_path, bool first_sample_on_init) {</span>
 281   assert(query != NULL, &quot;invariant&quot;);
<span class="line-modified"> 282   assert(counter_idx &lt; query-&gt;noOfCounters, &quot;invariant&quot;);</span>
<span class="line-modified"> 283   assert(query-&gt;counters[counter_idx] == NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 284   return add_counter(query, &amp;query-&gt;counters[counter_idx], counter_path, first_sample_on_init);</span>






 285 }
 286 
<span class="line-modified"> 287 // Need to limit how often we update a query to minimize the heisenberg effect.</span>
<span class="line-modified"> 288 // (PDH behaves erratically if the counters are queried too often, especially counters that</span>
<span class="line-added"> 289 // store and use values from two consecutive updates, like cpu load.)</span>
<span class="line-added"> 290 static const int min_update_interval_millis = 500;</span>
<span class="line-added"> 291 </span>
<span class="line-added"> 292 static int collect(UpdateQueryP query) {</span>
<span class="line-added"> 293   assert(query != NULL, &quot;invariant&quot;);</span>
 294   const s8 now = os::javaTimeNanos();
<span class="line-modified"> 295   if (nanos_to_millis(now - query-&gt;lastUpdate) &gt; min_update_interval_millis) {</span>
<span class="line-modified"> 296     if (PdhDll::PdhCollectQueryData(query-&gt;pdh_query_handle) != ERROR_SUCCESS) {</span>
 297       return OS_ERR;
 298     }
<span class="line-modified"> 299     query-&gt;lastUpdate = now;</span>
 300   }
 301   return OS_OK;
 302 }
 303 
<span class="line-modified"> 304 template &lt;typename QueryP&gt;</span>
<span class="line-modified"> 305 static int collect(QueryP query) {</span>
<span class="line-modified"> 306   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 307   return collect(&amp;query-&gt;query);</span>
 308 }
 309 
 310 static int formatted_counter_value(HCOUNTER counter, DWORD format, PDH_FMT_COUNTERVALUE* const value) {
 311   assert(value != NULL, &quot;invariant&quot;);
<span class="line-modified"> 312   return PdhDll::PdhGetFormattedCounterValue(counter, format, NULL, value) != ERROR_SUCCESS ? OS_ERR : OS_OK;</span>
<span class="line-added"> 313 }</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315 static int read_counter(CounterQueryP query, DWORD format, PDH_FMT_COUNTERVALUE* const value) {</span>
<span class="line-added"> 316   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 317   return formatted_counter_value(query-&gt;counter, format, value);</span>
<span class="line-added"> 318 }</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320 static int read_counter(MultiCounterQueryP query, int counter_idx, DWORD format, PDH_FMT_COUNTERVALUE* const value) {</span>
<span class="line-added"> 321   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 322   assert(counter_idx &lt; query-&gt;noOfCounters, &quot;invariant&quot;);</span>
<span class="line-added"> 323   assert(query-&gt;counters[counter_idx] != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 324   return formatted_counter_value(query-&gt;counters[counter_idx], format, value);</span>
<span class="line-added"> 325 }</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327 static int read_counter(ProcessQueryP query, int counter_idx, DWORD format, PDH_FMT_COUNTERVALUE* const value) {</span>
<span class="line-added"> 328   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 329   MultiCounterQueryP const current_query = &amp;query-&gt;set.queries[query-&gt;process_idx];</span>
<span class="line-added"> 330   assert(current_query != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 331   return read_counter(current_query, counter_idx, format, value);</span>
<span class="line-added"> 332 }</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334 /*</span>
<span class="line-added"> 335 * The routine expands a process object path including a wildcard to fetch the list of process instances</span>
<span class="line-added"> 336 * having the same name, i.e. &quot;java&quot; or rather the value of process_image_name.</span>
<span class="line-added"> 337 * A tally of this list is returned to the caller.</span>
<span class="line-added"> 338 */</span>
<span class="line-added"> 339 static int number_of_live_process_instances() {</span>
<span class="line-added"> 340   char* buffer = NULL;</span>
<span class="line-added"> 341   DWORD size = 0;</span>
<span class="line-added"> 342   // determine size</span>
<span class="line-added"> 343   PDH_STATUS status = PdhDll::PdhExpandWildCardPath(NULL,</span>
<span class="line-added"> 344                                                     pdh_process_instance_wildcard_IDProcess_counter,</span>
<span class="line-added"> 345                                                     buffer,</span>
<span class="line-added"> 346                                                     &amp;size,</span>
<span class="line-added"> 347                                                     PDH_NOEXPANDCOUNTERS);</span>
<span class="line-added"> 348   while (status == PDH_MORE_DATA) {</span>
<span class="line-added"> 349     buffer = NEW_RESOURCE_ARRAY(char, size);</span>
<span class="line-added"> 350     status = PdhDll::PdhExpandWildCardPath(NULL,</span>
<span class="line-added"> 351                                            pdh_process_instance_wildcard_IDProcess_counter,</span>
<span class="line-added"> 352                                            buffer,</span>
<span class="line-added"> 353                                            &amp;size,</span>
<span class="line-added"> 354                                            PDH_NOEXPANDCOUNTERS);</span>
<span class="line-added"> 355   }</span>
<span class="line-added"> 356   if (status != ERROR_SUCCESS) {</span>
 357     return OS_ERR;
 358   }
<span class="line-modified"> 359   // count the number of live process instances</span>
<span class="line-added"> 360   int instances = 0;</span>
<span class="line-added"> 361   const char* const end = buffer + size;</span>
<span class="line-added"> 362   for (char* next = buffer; next != end &amp;&amp; (*next != &#39;\0&#39;); next = &amp;next[strlen(next) + 1], ++instances);</span>
<span class="line-added"> 363   assert(instances &gt; 0, &quot;invariant&quot;);</span>
<span class="line-added"> 364   return instances;</span>
<span class="line-added"> 365 }</span>
<span class="line-added"> 366 </span>
<span class="line-added"> 367 static PDH_STATUS pdh_process_idx_to_pid(HQUERY&amp; pdh_query_handle, int idx, LONG* pid) {</span>
<span class="line-added"> 368   assert(pid != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 369   char counter_path[PDH_MAX_COUNTER_PATH];</span>
<span class="line-added"> 370   jio_snprintf(counter_path, sizeof(counter_path) - 1, pdh_process_instance_IDProcess_counter_fmt, idx);</span>
<span class="line-added"> 371   assert(strlen(counter_path) &lt; sizeof(counter_path), &quot;invariant&quot;);</span>
<span class="line-added"> 372   HCOUNTER counter = NULL;</span>
<span class="line-added"> 373   PDH_STATUS status = PdhDll::PdhAddCounter(pdh_query_handle, counter_path, 0, &amp;counter);</span>
<span class="line-added"> 374   if (status != ERROR_SUCCESS) {</span>
<span class="line-added"> 375     close_query(&amp;pdh_query_handle, &amp;counter);</span>
<span class="line-added"> 376     return status;</span>
<span class="line-added"> 377   }</span>
<span class="line-added"> 378   status = PdhDll::PdhCollectQueryData(pdh_query_handle);</span>
<span class="line-added"> 379   if (status != ERROR_SUCCESS) {</span>
<span class="line-added"> 380     close_query(NULL, &amp;counter);</span>
<span class="line-added"> 381     return PDH_NO_DATA;</span>
<span class="line-added"> 382   }</span>
<span class="line-added"> 383   PDH_FMT_COUNTERVALUE counter_value;</span>
<span class="line-added"> 384   status = formatted_counter_value(counter, PDH_FMT_LONG, &amp;counter_value);</span>
<span class="line-added"> 385   if (status != OS_OK) {</span>
<span class="line-added"> 386     close_query(&amp;pdh_query_handle, &amp;counter);</span>
<span class="line-added"> 387     return status;</span>
<span class="line-added"> 388   }</span>
<span class="line-added"> 389   *pid = counter_value.longValue;</span>
<span class="line-added"> 390   close_query(NULL, &amp;counter);</span>
<span class="line-added"> 391   return ERROR_SUCCESS;</span>
 392 }
 393 
<span class="line-added"> 394 </span>
 395 /*
<span class="line-modified"> 396  * Max process query index is derived from the total number of live process instances, seen</span>
<span class="line-modified"> 397  * as a snap-shot at the point of initialization, i.e. processes having the same name, e.g. &quot;java&quot;.</span>
<span class="line-added"> 398  * The total number of live processes includes this process and this number - 1 is the maximum index</span>
<span class="line-added"> 399  * to be used in a process query.</span>
<span class="line-added"> 400  */</span>
<span class="line-added"> 401 static int max_process_query_idx = 0;</span>
<span class="line-added"> 402 </span>
<span class="line-added"> 403 /*</span>
<span class="line-added"> 404 * Working with the Process object and its related counters is inherently</span>
<span class="line-added"> 405 * problematic when using the PDH API:</span>
<span class="line-added"> 406 *</span>
<span class="line-added"> 407 * A process is not primarily identified by the process id, but by an opaque</span>
<span class="line-added"> 408 * index into a list maintained by the kernel. To distinguish which</span>
<span class="line-added"> 409 * process instance is the intended target for a query, the PDH Process API demands,</span>
<span class="line-added"> 410 * at time of registration, a string describing the target process name concatenated</span>
<span class="line-added"> 411 * with the value for this index. For example:</span>
<span class="line-added"> 412 * &quot;\Process(java#0)&quot;, &quot;\Process(java#1)&quot;, ...</span>
 413 *
<span class="line-modified"> 414 * The bad part is that this list is constantly in-flux as</span>
<span class="line-modified"> 415 * processes are exiting. One consequence is that processes with indexes</span>
<span class="line-modified"> 416 * greater than the one that just terminated is now shifted down by one.</span>
<span class="line-modified"> 417 * For example:</span>
<span class="line-added"> 418 * if \Process(java#1) exits, \Process(java#2) now becomes \Process(java#1),</span>
<span class="line-added"> 419 *    \Process(java#2) becomes \Process(java#1) ...</span>
 420 *
<span class="line-modified"> 421 * To make matters even more exciting, an already registered query is not invalidated</span>
<span class="line-modified"> 422 * when the process list changes. Instead, the query will continue to work just as before,</span>
<span class="line-added"> 423 * or at least, so it seems.</span>
<span class="line-added"> 424 * Only, now, the query will read performance data from another process instance!</span>
<span class="line-added"> 425 * That&#39;s right, the performance data is now read from the process that was shifted</span>
<span class="line-added"> 426 * down by the kernel to occupy the index slot associated with our original registration.</span>
 427 *
 428 * Solution:
<span class="line-modified"> 429 * The #index identifier for a Process query can only decrease after process creation.</span>
 430 *
 431 * We therefore create an array of counter queries for all process object instances
 432 * up to and including ourselves:
 433 *
<span class="line-modified"> 434 * E.g. we come in as the third process instance (java#2), we then create and register</span>
 435 * queries for the following Process object instances:
 436 * java#0, java#1, java#2
 437 *
<span class="line-modified"> 438 * current_process_query_index() finds the &quot;correct&quot; pdh process query index by inspecting</span>
<span class="line-modified"> 439 * the pdh process list, at a particular instant, i.e. just before we issue the real process query.</span>
<span class="line-modified"> 440 * Of course, this is an inherently racy situation because the pdh process list can change at any time.</span>
<span class="line-modified"> 441 * We use current_process_query_index() to help keep the number of data errors low,</span>
<span class="line-added"> 442 * where a data error is defined to be the result of using a stale index to query the wrong process.</span>
 443 *
<span class="line-modified"> 444 * Ensure to call ensure_current_process_query_index() before every query involving Process object instance data.</span>
<span class="line-added"> 445 *</span>
<span class="line-added"> 446 * returns OS_ERR(-1) if anything goes wrong in the discovery process.</span>
 447 */
<span class="line-modified"> 448 </span>
<span class="line-added"> 449 static int current_process_query_index(int previous_query_idx = 0) {</span>
<span class="line-added"> 450   assert(max_process_query_idx &gt;= 0, &quot;invariant&quot;);</span>
<span class="line-added"> 451   assert(max_process_query_idx &gt;= previous_query_idx, &quot;invariant&quot;);</span>
 452   assert(process_image_name != NULL, &quot;invariant&quot;);
<span class="line-modified"> 453   assert(pdh_process_instance_IDProcess_counter_fmt != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 454   int result = OS_ERR;</span>
<span class="line-modified"> 455   HQUERY tmp_pdh_query_handle = NULL;</span>
<span class="line-added"> 456   if (open_query(&amp;tmp_pdh_query_handle) != OS_OK) {</span>
 457     return OS_ERR;
 458   }
<span class="line-modified"> 459   // We need to find the correct pdh process index corresponding to our process identifier (pid).</span>
<span class="line-modified"> 460   // Begin from the index that was valid at the time of the last query. If that index is no longer valid,</span>
<span class="line-modified"> 461   // it means the pdh process list has changed, i.e. because other processes with the same name as us have terminated.</span>
<span class="line-modified"> 462   // Seek downwards to find the updated, now downshifted, list index corresponding to our pid.</span>
<span class="line-modified"> 463   static const LONG current_pid = (LONG)os::current_process_id();</span>
<span class="line-modified"> 464   const int start_idx = previous_query_idx != 0 ? previous_query_idx : max_process_query_idx;</span>
<span class="line-modified"> 465   for (int idx = start_idx; idx &gt;= 0; --idx) {</span>
<span class="line-modified"> 466     LONG pid;</span>
<span class="line-modified"> 467     const PDH_STATUS status = pdh_process_idx_to_pid(tmp_pdh_query_handle, idx, &amp;pid);</span>
<span class="line-added"> 468     if (status == PDH_NO_DATA) {</span>
<span class="line-added"> 469       // pdh process list has changed</span>
<span class="line-added"> 470       continue;</span>
 471     }
<span class="line-modified"> 472     if (status != ERROR_SUCCESS) {</span>
<span class="line-modified"> 473       // something went wrong, tmp_pdh_query_handle is already closed.</span>

 474       return OS_ERR;
<span class="line-modified"> 475     }</span>
<span class="line-modified"> 476     if (current_pid == pid) {</span>
<span class="line-modified"> 477       result = idx;</span>
<span class="line-modified"> 478       break;</span>




 479     }
 480   }
<span class="line-modified"> 481   close_query(&amp;tmp_pdh_query_handle, NULL);</span>
<span class="line-modified"> 482   return result;</span>





















 483 }
 484 
<span class="line-modified"> 485 static int ensure_current_process_query_index(ProcessQueryP query) {</span>
<span class="line-modified"> 486   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 487   const int previous_query_idx = query-&gt;process_idx;</span>
<span class="line-added"> 488   if (previous_query_idx == 0) {</span>
<span class="line-added"> 489     return previous_query_idx;</span>
 490   }
<span class="line-modified"> 491   const int current_query_idx = current_process_query_index(previous_query_idx);</span>
<span class="line-modified"> 492   if (current_query_idx == OS_ERR || current_query_idx &gt;= query-&gt;set.size) {</span>
<span class="line-modified"> 493     return OS_ERR;</span>






 494   }
<span class="line-modified"> 495   if (current_query_idx == previous_query_idx) {</span>
<span class="line-modified"> 496     return previous_query_idx;</span>


 497   }
<span class="line-modified"> 498   assert(current_query_idx &gt;= 0 &amp;&amp; current_query_idx &lt; query-&gt;set.size, &quot;out of bounds!&quot;);</span>
<span class="line-modified"> 499   while (current_query_idx &lt; query-&gt;set.size - 1) {</span>
<span class="line-modified"> 500     const int new_size = --query-&gt;set.size;</span>
<span class="line-modified"> 501     close_query(&amp;query-&gt;set.queries[new_size]);</span>

 502   }
<span class="line-modified"> 503   assert(current_query_idx &lt; query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-modified"> 504   query-&gt;process_idx = current_query_idx;</span>
<span class="line-modified"> 505   return OS_OK;</span>








 506 }
 507 
<span class="line-modified"> 508 static MultiCounterQueryP current_process_query(ProcessQueryP query) {</span>
<span class="line-modified"> 509   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 510   if (ensure_current_process_query_index(query) == OS_ERR) {</span>
<span class="line-added"> 511     return NULL;</span>
<span class="line-added"> 512   }</span>
<span class="line-added"> 513   assert(query-&gt;process_idx &lt; query-&gt;set.size, &quot;invariant&quot;);</span>
<span class="line-added"> 514   return &amp;query-&gt;set.queries[query-&gt;process_idx];</span>
 515 }
 516 
<span class="line-modified"> 517 static int collect(ProcessQueryP query) {</span>
<span class="line-modified"> 518   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 519   MultiCounterQueryP current_query = current_process_query(query);</span>
<span class="line-modified"> 520   return current_query != NULL ? collect(current_query) : OS_ERR;</span>


 521 }
 522 
 523 /*
<span class="line-modified"> 524  * Construct a fully qualified PDH counter path.</span>
 525  *
<span class="line-modified"> 526  * @param object_name   a PDH Object string representation(required)</span>
<span class="line-modified"> 527  * @param counter_name  a PDH Counter string representation(required)</span>
<span class="line-modified"> 528  * @param image_name    a process image name string, ex. &quot;java&quot; (opt)</span>
<span class="line-modified"> 529  * @param instance      an instance string, ex. &quot;0&quot;, &quot;1&quot;, ... (opt)</span>
<span class="line-modified"> 530  * @return              the fully qualified PDH counter path.</span>
 531  *
 532  * Caller will need a ResourceMark.
 533  *
 534  * (PdhMakeCounterPath() seems buggy on concatenating instances, hence this function instead)
 535  */
 536 static const char* make_fully_qualified_counter_path(const char* object_name,
 537                                                      const char* counter_name,
 538                                                      const char* image_name = NULL,
 539                                                      const char* instance = NULL) {
 540   assert(object_name != NULL, &quot;invariant&quot;);
 541   assert(counter_name != NULL, &quot;invariant&quot;);
<span class="line-modified"> 542   size_t counter_path_len = strlen(object_name) + strlen(counter_name);</span>
 543 
<span class="line-modified"> 544   char* counter_path;</span>
 545   size_t jio_snprintf_result = 0;
 546   if (image_name) {
 547     /*
 548     * For paths using the &quot;Process&quot; Object.
 549     *
 550     * Examples:
 551     * form:   &quot;\object_name(image_name#instance)\counter_name&quot;
 552     * actual: &quot;\Process(java#2)\ID Process&quot;
 553     */
<span class="line-modified"> 554     counter_path_len += PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN;</span>
<span class="line-modified"> 555     counter_path_len += strlen(image_name);</span>
 556     /*
 557     * image_name must be passed together with an associated
 558     * instance &quot;number&quot; (&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, ...).
 559     * This is required in order to create valid &quot;Process&quot; Object paths.
 560     *
 561     * Examples: &quot;\Process(java#0)&quot;, \Process(java#1&quot;), ...
 562     */
 563     assert(instance != NULL, &quot;invariant&quot;);
<span class="line-modified"> 564     counter_path_len += strlen(instance);</span>
<span class="line-modified"> 565     counter_path = NEW_RESOURCE_ARRAY(char, counter_path_len + 1);</span>
<span class="line-modified"> 566     jio_snprintf_result = jio_snprintf(counter_path,</span>
<span class="line-modified"> 567                                        counter_path_len + 1,</span>
<span class="line-modified"> 568                                        PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT,</span>



 569                                        object_name,
 570                                        image_name,
 571                                        instance,
 572                                        counter_name);
 573   } else {
 574     if (instance) {
 575       /*
 576       * For paths where the Object has multiple instances.
 577       *
 578       * Examples:
 579       * form:   &quot;\object_name(instance)\counter_name&quot;
 580       * actual: &quot;\Processor(0)\% Privileged Time&quot;
 581       */
<span class="line-modified"> 582       counter_path_len += strlen(instance);</span>
<span class="line-modified"> 583       counter_path_len += OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN;</span>
 584     } else {
 585       /*
 586       * For &quot;normal&quot; paths.
 587       *
 588       * Examples:
 589       * form:   &quot;\object_name\counter_name&quot;
 590       * actual: &quot;\Memory\Available Mbytes&quot;
 591       */
<span class="line-modified"> 592       counter_path_len += OBJECT_COUNTER_FMT_LEN;</span>




 593     }
<span class="line-added"> 594     counter_path = NEW_RESOURCE_ARRAY(char, counter_path_len + 1);</span>
 595     if (instance) {
<span class="line-modified"> 596       jio_snprintf_result = jio_snprintf(counter_path,</span>
<span class="line-modified"> 597                                          counter_path_len + 1,</span>
 598                                          OBJECT_WITH_INSTANCES_COUNTER_FMT,
 599                                          object_name,
 600                                          instance,
 601                                          counter_name);
 602     } else {
<span class="line-modified"> 603       jio_snprintf_result = jio_snprintf(counter_path,</span>
<span class="line-modified"> 604                                          counter_path_len + 1,</span>
 605                                          OBJECT_COUNTER_FMT,
 606                                          object_name,
 607                                          counter_name);
 608     }
 609   }
<span class="line-modified"> 610   assert(counter_path_len == jio_snprintf_result, &quot;invariant&quot;);</span>
<span class="line-modified"> 611   return counter_path;</span>
 612 }
 613 
 614 static void log_invalid_pdh_index(DWORD index) {
 615   log_warning(os)(&quot;Unable to resolve PDH index: (%ld)&quot;, index);
 616   log_warning(os)(&quot;Please check the registry if this performance object/counter is disabled&quot;);
 617 }
 618 
 619 static bool is_valid_pdh_index(DWORD index) {
 620   DWORD dummy = 0;
 621   if (PdhDll::PdhLookupPerfNameByIndex(NULL, index, NULL, &amp;dummy) != PDH_MORE_DATA) {
 622     log_invalid_pdh_index(index);
 623     return false;
 624   }
 625   return true;
 626 }
 627 
 628 /*
 629  * Maps an index to a resource area allocated string for the localized PDH artifact.
 630  *
 631  * Caller will need a ResourceMark.
 632  *
 633  * @param index    the counter index as specified in the registry
<span class="line-modified"> 634  * @param p_string pointer to a char*</span>
 635  * @return         OS_OK if successful, OS_ERR on failure.
 636  */
 637 static OSReturn lookup_name_by_index(DWORD index, char** p_string) {
 638   assert(p_string != NULL, &quot;invariant&quot;);
 639   if (!is_valid_pdh_index(index)) {
 640     return OS_ERR;
 641   }
 642   // determine size needed
 643   DWORD size = 0;
 644   PDH_STATUS status = PdhDll::PdhLookupPerfNameByIndex(NULL, index, NULL, &amp;size);
 645   assert(status == PDH_MORE_DATA, &quot;invariant&quot;);
<span class="line-modified"> 646   *p_string = NEW_RESOURCE_ARRAY(char, size);</span>



 647   if (PdhDll::PdhLookupPerfNameByIndex(NULL, index, *p_string, &amp;size) != ERROR_SUCCESS) {
 648     return OS_ERR;
 649   }
 650   if (0 == size || *p_string == NULL) {
 651     return OS_ERR;
 652   }
 653   // windows vista does not null-terminate the string (although the docs says it will)
 654   (*p_string)[size - 1] = &#39;\0&#39;;
 655   return OS_OK;
 656 }
 657 
 658 static const char* copy_string_to_c_heap(const char* string) {
 659   assert(string != NULL, &quot;invariant&quot;);
 660   const size_t len = strlen(string);
<span class="line-modified"> 661   char* const cheap_allocated_string = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>



 662   strncpy(cheap_allocated_string, string, len + 1);
 663   return cheap_allocated_string;
 664 }
 665 
 666 /*
<span class="line-modified"> 667 * Maps a pdh artifact index to a resource area allocated string representing a localized name.</span>
 668 *
 669 * Caller will need a ResourceMark.
 670 *
<span class="line-modified"> 671 * @param pdh_artifact_idx   the counter index as specified in the registry</span>
<span class="line-modified"> 672 * @return                   localized pdh artifact string if successful, NULL on failure.</span>
 673 */
<span class="line-modified"> 674 static const char* pdh_localized_artifact(DWORD pdh_artifact_idx) {</span>
 675   char* pdh_localized_artifact_string = NULL;
<span class="line-modified"> 676   // get localized name for the pdh artifact idx</span>
<span class="line-modified"> 677   if (lookup_name_by_index(pdh_artifact_idx, &amp;pdh_localized_artifact_string) != OS_OK) {</span>
 678     return NULL;
 679   }
 680   return pdh_localized_artifact_string;
 681 }
 682 
 683 /*
 684  * Returns the PDH string identifying the current process image name.
 685  * Use this prefix when getting counters from the PDH process object
 686  * representing your process.
 687  * Ex. &quot;Process(java#0)\Virtual Bytes&quot; - where &quot;java&quot; is the PDH process
 688  * image description.
 689  *
 690  * Caller needs ResourceMark.
 691  *
<span class="line-modified"> 692  * @return the process image string description, NULL if the call failed.</span>
 693 */
 694 static const char* pdh_process_image_name() {
<span class="line-modified"> 695   char* module_name = NEW_RESOURCE_ARRAY(char, MAX_PATH);</span>



 696   // Find our module name and use it to extract the image name used by PDH
 697   DWORD getmfn_return = GetModuleFileName(NULL, module_name, MAX_PATH);
 698   if (getmfn_return &gt;= MAX_PATH || 0 == getmfn_return) {
 699     return NULL;
 700   }
 701   if (os::get_last_error() == ERROR_INSUFFICIENT_BUFFER) {
 702     return NULL;
 703   }
 704   char* process_image_name = strrchr(module_name, &#39;\\&#39;); //drop path
 705   process_image_name++;                                  //skip slash
 706   char* dot_pos = strrchr(process_image_name, &#39;.&#39;);      //drop .exe
 707   dot_pos[0] = &#39;\0&#39;;
 708   return process_image_name;
 709 }
 710 
 711 static void deallocate_pdh_constants() {
 712   FREE_C_HEAP_ARRAY(char, process_image_name);
 713   process_image_name = NULL;
<span class="line-modified"> 714   FREE_C_HEAP_ARRAY(char, pdh_process_instance_IDProcess_counter_fmt);</span>
<span class="line-modified"> 715   pdh_process_instance_IDProcess_counter_fmt = NULL;</span>
<span class="line-added"> 716   FREE_C_HEAP_ARRAY(char, pdh_process_instance_wildcard_IDProcess_counter);</span>
<span class="line-added"> 717   pdh_process_instance_wildcard_IDProcess_counter = NULL;</span>
 718 }
 719 
<span class="line-modified"> 720 static OSReturn allocate_pdh_constants() {</span>
 721   assert(process_image_name == NULL, &quot;invariant&quot;);
 722   const char* pdh_image_name = pdh_process_image_name();
 723   if (pdh_image_name == NULL) {
 724     return OS_ERR;
 725   }
 726   process_image_name = copy_string_to_c_heap(pdh_image_name);
 727 
 728   const char* pdh_localized_process_object = pdh_localized_artifact(PDH_PROCESS_IDX);
 729   if (pdh_localized_process_object == NULL) {
 730     return OS_ERR;
 731   }
 732 
 733   const char* pdh_localized_IDProcess_counter = pdh_localized_artifact(PDH_ID_PROCESS_IDX);
 734   if (pdh_localized_IDProcess_counter == NULL) {
 735     return OS_ERR;
 736   }
 737 
<span class="line-modified"> 738   const size_t id_process_base_length = strlen(process_image_name) +</span>
<span class="line-modified"> 739                                         strlen(pdh_localized_process_object) +</span>
<span class="line-modified"> 740                                         strlen(pdh_localized_IDProcess_counter);</span>


 741 
<span class="line-modified"> 742   const size_t pdh_IDProcess_counter_fmt_len = id_process_base_length +</span>
<span class="line-modified"> 743                                                PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN +</span>
<span class="line-modified"> 744                                                2; // &quot;%d&quot;</span>
<span class="line-modified"> 745 </span>
<span class="line-modified"> 746   assert(pdh_process_instance_IDProcess_counter_fmt == NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 747   pdh_process_instance_IDProcess_counter_fmt = NEW_C_HEAP_ARRAY(char, pdh_IDProcess_counter_fmt_len + 1, mtInternal);</span>
 748 
 749   /* &quot;\Process(java#%d)\ID Process&quot; */
<span class="line-modified"> 750   size_t len = jio_snprintf(pdh_process_instance_IDProcess_counter_fmt,</span>
<span class="line-modified"> 751                             pdh_IDProcess_counter_fmt_len + 1,</span>
<span class="line-modified"> 752                             PROCESS_OBJECT_WITH_INSTANCES_COUNTER_FMT,</span>
<span class="line-modified"> 753                             pdh_localized_process_object,</span>
<span class="line-modified"> 754                             process_image_name,</span>
<span class="line-modified"> 755                             &quot;%d&quot;,</span>
<span class="line-modified"> 756                             pdh_localized_IDProcess_counter);</span>
<span class="line-modified"> 757 </span>
<span class="line-modified"> 758   assert(pdh_process_instance_IDProcess_counter_fmt != NULL, &quot;invariant&quot;);</span>
 759   assert(len == pdh_IDProcess_counter_fmt_len, &quot;invariant&quot;);
<span class="line-added"> 760 </span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762   const size_t pdh_IDProcess_wildcard_fmt_len = id_process_base_length +</span>
<span class="line-added"> 763                                                 PROCESS_OBJECT_WITH_INSTANCES_WILDCARD_FMT_LEN;</span>
<span class="line-added"> 764 </span>
<span class="line-added"> 765   assert(pdh_process_instance_wildcard_IDProcess_counter == NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 766   pdh_process_instance_wildcard_IDProcess_counter = NEW_C_HEAP_ARRAY(char, pdh_IDProcess_wildcard_fmt_len + 1, mtInternal);</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768   /* &quot;\Process(java*)\ID Process&quot; */</span>
<span class="line-added"> 769   len = jio_snprintf(pdh_process_instance_wildcard_IDProcess_counter,</span>
<span class="line-added"> 770                      pdh_IDProcess_wildcard_fmt_len + 1,</span>
<span class="line-added"> 771                      PROCESS_OBJECT_WITH_INSTANCES_WILDCARD_FMT,</span>
<span class="line-added"> 772                      pdh_localized_process_object,</span>
<span class="line-added"> 773                      process_image_name,</span>
<span class="line-added"> 774                      pdh_localized_IDProcess_counter);</span>
<span class="line-added"> 775 </span>
<span class="line-added"> 776   assert(pdh_process_instance_wildcard_IDProcess_counter != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 777   assert(len == pdh_IDProcess_wildcard_fmt_len, &quot;invariant&quot;);</span>
 778   return OS_OK;
 779 }
 780 
 781 /*
 782  * Enuerate the Processor PDH object and returns a buffer containing the enumerated instances.
 783  * Caller needs ResourceMark;
 784  *
 785  * @return  buffer if successful, NULL on failure.
 786 */
 787 static const char* enumerate_cpu_instances() {
 788   char* processor; //&#39;Processor&#39; == PDH_PROCESSOR_IDX
 789   if (lookup_name_by_index(PDH_PROCESSOR_IDX, &amp;processor) != OS_OK) {
 790     return NULL;
 791   }
 792   DWORD c_size = 0;
 793   DWORD i_size = 0;
 794   // enumerate all processors.
 795   PDH_STATUS pdhStat = PdhDll::PdhEnumObjectItems(NULL, // reserved
 796                                                   NULL, // local machine
 797                                                   processor, // object to enumerate
 798                                                   NULL,
 799                                                   &amp;c_size,
 800                                                   NULL, // instance buffer is NULL and
 801                                                   &amp;i_size,  // pass 0 length in order to get the required size
 802                                                   PERF_DETAIL_WIZARD, // counter detail level
 803                                                   0);
 804   if (PdhDll::PdhStatusFail((pdhStat))) {
 805     return NULL;
 806   }
<span class="line-modified"> 807   char* const instances = NEW_RESOURCE_ARRAY(char, i_size);</span>



 808   c_size = 0;
 809   pdhStat = PdhDll::PdhEnumObjectItems(NULL, // reserved
 810                                        NULL, // local machine
 811                                        processor, // object to enumerate
 812                                        NULL,
 813                                        &amp;c_size,
 814                                        instances, // now instance buffer is allocated to be filled in
 815                                        &amp;i_size, // and the required size is known
 816                                        PERF_DETAIL_WIZARD, // counter detail level
 817                                        0);
<span class="line-modified"> 818   return PdhDll::PdhStatusFail(pdhStat) ? NULL : instances;</span>



 819 }
 820 
 821 static int count_logical_cpus(const char* instances) {
 822   assert(instances != NULL, &quot;invariant&quot;);
 823   // count logical instances.
 824   DWORD count;
 825   char* tmp;
 826   for (count = 0, tmp = const_cast&lt;char*&gt;(instances); *tmp != &#39;\0&#39;; tmp = &amp;tmp[strlen(tmp) + 1], count++);
 827   // PDH reports an instance for each logical processor plus an instance for the total (_Total)
 828   assert(count == os::processor_count() + 1, &quot;invalid enumeration!&quot;);
 829   return count - 1;
 830 }
 831 
 832 static int number_of_logical_cpus() {
 833   static int numberOfCPUS = 0;
 834   if (numberOfCPUS == 0) {
 835     const char* instances = enumerate_cpu_instances();
 836     if (instances == NULL) {
 837       return OS_ERR;
 838     }
 839     numberOfCPUS = count_logical_cpus(instances);
 840   }
 841   return numberOfCPUS;
 842 }
 843 
 844 static double cpu_factor() {
<span class="line-modified"> 845   static DWORD numCpus = 0;</span>
 846   static double cpuFactor = .0;
 847   if (numCpus == 0) {
 848     numCpus = number_of_logical_cpus();
 849     assert(os::processor_count() &lt;= (int)numCpus, &quot;invariant&quot;);
 850     cpuFactor = numCpus * 100;
 851   }
 852   return cpuFactor;
 853 }
 854 
<span class="line-modified"> 855 static void log_error_message_on_no_PDH_artifact(const char* counter_path) {</span>
<span class="line-modified"> 856   log_warning(os)(&quot;Unable to register PDH query for \&quot;%s\&quot;&quot;, counter_path);</span>
 857   log_warning(os)(&quot;Please check the registry if this performance object/counter is disabled&quot;);
 858 }
 859 
<span class="line-modified"> 860 static int initialize_cpu_query_counters(MultiCounterQueryP query, DWORD pdh_counter_idx) {</span>
<span class="line-modified"> 861   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 862   assert(query-&gt;counters != NULL, &quot;invariant&quot;);</span>
 863   char* processor; //&#39;Processor&#39; == PDH_PROCESSOR_IDX
 864   if (lookup_name_by_index(PDH_PROCESSOR_IDX, &amp;processor) != OS_OK) {
 865     return OS_ERR;
 866   }
 867   char* counter_name = NULL;
 868   if (lookup_name_by_index(pdh_counter_idx, &amp;counter_name) != OS_OK) {
 869     return OS_ERR;
 870   }
<span class="line-modified"> 871   if (query-&gt;query.pdh_query_handle == NULL) {</span>
<span class="line-modified"> 872     if (open_query(query) != OS_OK) {</span>
 873       return OS_ERR;
 874     }
 875   }
<span class="line-modified"> 876   assert(query-&gt;query.pdh_query_handle != NULL, &quot;invariant&quot;);</span>
 877   size_t counter_len = strlen(processor);
 878   counter_len += strlen(counter_name);
 879   counter_len += OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN; // &quot;\\%s(%s)\\%s&quot;



 880   const char* instances = enumerate_cpu_instances();
<span class="line-modified"> 881   DWORD index = 0;</span>
<span class="line-added"> 882   for (char* tmp = const_cast&lt;char*&gt;(instances); *tmp != &#39;\0&#39;; tmp = &amp;tmp[strlen(tmp) + 1], index++) {</span>
 883     const size_t tmp_len = strlen(tmp);
<span class="line-modified"> 884     char* counter_path = NEW_RESOURCE_ARRAY(char, counter_len + tmp_len + 1);</span>



 885     const size_t jio_snprintf_result = jio_snprintf(counter_path,
 886                                                     counter_len + tmp_len + 1,
 887                                                     OBJECT_WITH_INSTANCES_COUNTER_FMT,
 888                                                     processor,
 889                                                     tmp, // instance &quot;0&quot;, &quot;1&quot;, ..&quot;_Total&quot;
 890                                                     counter_name);
 891     assert(counter_len + tmp_len == jio_snprintf_result, &quot;invariant&quot;);
<span class="line-modified"> 892     if (add_counter(query, &amp;query-&gt;counters[index], counter_path, false) != OS_OK) {</span>
 893       // performance counter is disabled in registry and not accessible via PerfLib
 894       log_error_message_on_no_PDH_artifact(counter_path);
 895       // return OS_OK to have the system continue to run without the missing counter
 896       return OS_OK;
 897     }
 898   }

 899   // Query once to initialize the counters which require at least two samples
 900   // (like the % CPU usage) to calculate correctly.
<span class="line-modified"> 901   return PdhDll::PdhCollectQueryData(query-&gt;query.pdh_query_handle) != ERROR_SUCCESS ? OS_ERR : OS_OK;</span>

 902 }
 903 
<span class="line-modified"> 904 static int initialize_cpu_query(MultiCounterQueryP query) {</span>
<span class="line-modified"> 905   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 906   assert(!query-&gt;initialized, &quot;invariant&quot;);</span>
 907   const int logical_cpu_count = number_of_logical_cpus();
 908   assert(logical_cpu_count &gt;= os::processor_count(), &quot;invariant&quot;);
 909   // we also add another counter for instance &quot;_Total&quot;
<span class="line-modified"> 910   allocate_counters(query, logical_cpu_count + 1);</span>
<span class="line-modified"> 911   assert(query-&gt;noOfCounters == logical_cpu_count + 1, &quot;invariant&quot;);</span>
<span class="line-modified"> 912   if (initialize_cpu_query_counters(query, PDH_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-added"> 913     return OS_ERR;</span>
<span class="line-added"> 914   }</span>
<span class="line-added"> 915   query-&gt;initialized = true;</span>
<span class="line-added"> 916   return OS_OK;</span>
<span class="line-added"> 917 }</span>
<span class="line-added"> 918 </span>
<span class="line-added"> 919 static int initialize_query(CounterQueryP query, DWORD pdh_object_idx, DWORD pdh_counter_idx) {</span>
<span class="line-added"> 920   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 921   assert(!query-&gt;initialized, &quot;invariant&quot;);</span>
<span class="line-added"> 922   if (!((is_valid_pdh_index(pdh_object_idx) &amp;&amp; is_valid_pdh_index(pdh_counter_idx)))) {</span>
<span class="line-added"> 923     return OS_ERR;</span>
<span class="line-added"> 924   }</span>
<span class="line-added"> 925   const char* object = pdh_localized_artifact(pdh_object_idx);</span>
<span class="line-added"> 926   assert(object != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 927   const char* counter = pdh_localized_artifact(pdh_counter_idx);</span>
<span class="line-added"> 928   assert(counter != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 929   const char* counter_path = make_fully_qualified_counter_path(object, counter);</span>
<span class="line-added"> 930   assert(counter_path != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 931   if (add_counter(query, counter_path, true) != OS_OK) {</span>
<span class="line-added"> 932     return OS_ERR;</span>
<span class="line-added"> 933   }</span>
<span class="line-added"> 934   query-&gt;initialized = true;</span>
<span class="line-added"> 935   return OS_OK;</span>
<span class="line-added"> 936 }</span>
<span class="line-added"> 937 </span>
<span class="line-added"> 938 static int initialize_context_switches_query(CounterQueryP query) {</span>
<span class="line-added"> 939   return initialize_query(query, PDH_SYSTEM_IDX, PDH_CONTEXT_SWITCH_RATE_IDX);</span>
<span class="line-added"> 940 }</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942 static ProcessQueryP create_process_query() {</span>
<span class="line-added"> 943   const int current_process_query_idx = current_process_query_index();</span>
<span class="line-added"> 944   if (current_process_query_idx == OS_ERR) {</span>
<span class="line-added"> 945     return NULL;</span>
<span class="line-added"> 946   }</span>
<span class="line-added"> 947   ProcessQueryP const query = NEW_C_HEAP_OBJ(ProcessQueryS, mtInternal);</span>
<span class="line-added"> 948   memset(query, 0, sizeof(ProcessQueryS));</span>
<span class="line-added"> 949   query-&gt;process_idx = current_process_query_idx;</span>
<span class="line-added"> 950   const int size = current_process_query_idx + 1;</span>
<span class="line-added"> 951   query-&gt;set.queries = NEW_C_HEAP_ARRAY(MultiCounterQueryS, size, mtInternal);</span>
<span class="line-added"> 952   memset(query-&gt;set.queries, 0, sizeof(MultiCounterQueryS) * size);</span>
<span class="line-added"> 953   query-&gt;set.size = size;</span>
<span class="line-added"> 954   return query;</span>
 955 }
 956 
<span class="line-modified"> 957 static int initialize_process_counter(ProcessQueryP process_query, int counter_idx, DWORD pdh_counter_idx) {</span>
 958   char* localized_process_object;
 959   if (lookup_name_by_index(PDH_PROCESS_IDX, &amp;localized_process_object) != OS_OK) {
 960     return OS_ERR;
 961   }
 962   assert(localized_process_object != NULL, &quot;invariant&quot;);
 963   char* localized_counter_name;
<span class="line-modified"> 964   if (lookup_name_by_index(pdh_counter_idx, &amp;localized_counter_name) != OS_OK) {</span>
 965     return OS_ERR;
 966   }
 967   assert(localized_counter_name != NULL, &quot;invariant&quot;);
 968   for (int i = 0; i &lt; process_query-&gt;set.size; ++i) {
 969     char instanceIndexBuffer[32];
 970     const char* counter_path = make_fully_qualified_counter_path(localized_process_object,
 971                                                                  localized_counter_name,
 972                                                                  process_image_name,
 973                                                                  itoa(i, instanceIndexBuffer, 10));
<span class="line-modified"> 974     assert(counter_path != NULL, &quot;invariant&quot;);</span>


 975     MultiCounterQueryP const query = &amp;process_query-&gt;set.queries[i];
<span class="line-modified"> 976     if (add_counter(query, counter_idx, counter_path, true) != OS_OK) {</span>
 977       return OS_ERR;
 978     }
<span class="line-added"> 979     if (counter_idx + 1 == query-&gt;noOfCounters) {</span>
<span class="line-added"> 980       // last counter in query implies query initialized</span>
<span class="line-added"> 981       query-&gt;initialized = true;</span>
<span class="line-added"> 982     }</span>
 983   }
 984   return OS_OK;
 985 }
 986 
<span class="line-modified"> 987 static int initialize_process_query(ProcessQueryP query) {</span>
<span class="line-modified"> 988   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 989   assert(!query-&gt;set.initialized, &quot;invariant&quot;);</span>
<span class="line-added"> 990   allocate_counters(query, 2);</span>
<span class="line-added"> 991   if (initialize_process_counter(query, 0, PDH_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-added"> 992     return OS_ERR;</span>
 993   }
<span class="line-modified"> 994   if (initialize_process_counter(query, 1, PDH_PRIV_PROCESSOR_TIME_IDX) != OS_OK) {</span>
<span class="line-modified"> 995     return OS_ERR;</span>
<span class="line-modified"> 996   }</span>
<span class="line-modified"> 997   query-&gt;set.initialized = true;</span>
<span class="line-modified"> 998   return OS_OK;</span>









 999 }
1000 
<span class="line-modified">1001 static int reference_count = 0;</span>

1002 static bool pdh_initialized = false;
1003 
<span class="line-added">1004 class PdhMutex : public StackObj {</span>
<span class="line-added">1005  private:</span>
<span class="line-added">1006   static Semaphore _semaphore;</span>
<span class="line-added">1007  public:</span>
<span class="line-added">1008   PdhMutex() {</span>
<span class="line-added">1009     _semaphore.wait();</span>
<span class="line-added">1010   }</span>
<span class="line-added">1011   ~PdhMutex() {</span>
<span class="line-added">1012     _semaphore.signal();</span>
<span class="line-added">1013   }</span>
<span class="line-added">1014 };</span>
<span class="line-added">1015 </span>
<span class="line-added">1016 Semaphore PdhMutex::_semaphore(1);</span>
<span class="line-added">1017 </span>
1018 static void on_initialization_failure() {
<span class="line-modified">1019   // still holder of mutex</span>
<span class="line-modified">1020   assert(max_process_query_idx == 0, &quot;invariant&quot;);</span>
<span class="line-modified">1021   deallocate_pdh_constants();</span>
<span class="line-added">1022   --reference_count;</span>
<span class="line-added">1023   PdhDll::PdhDetach();</span>
1024 }
1025 
1026 static OSReturn initialize() {
<span class="line-added">1027   // still holder of mutex</span>
1028   ResourceMark rm;
1029   if (!PdhDll::PdhAttach()) {
1030     return OS_ERR;
1031   }
1032   if (allocate_pdh_constants() != OS_OK) {
1033     on_initialization_failure();
1034     return OS_ERR;
1035   }
<span class="line-added">1036   // Take a snapshot of the current number of live processes (including ourselves)</span>
<span class="line-added">1037   // with the same name, e.g. &quot;java&quot;, in order to derive a value for max_process_query_idx.</span>
<span class="line-added">1038   const int process_instance_count = number_of_live_process_instances();</span>
<span class="line-added">1039   if (process_instance_count == OS_ERR) {</span>
<span class="line-added">1040     on_initialization_failure();</span>
<span class="line-added">1041     return OS_ERR;</span>
<span class="line-added">1042   }</span>
<span class="line-added">1043   assert(process_instance_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-added">1044   max_process_query_idx = process_instance_count - 1;</span>
1045   return OS_OK;
1046 }
1047 
1048 /*
1049 * Helper to initialize the PDH library, function pointers, constants and counters.
1050 *
1051 * Reference counting allows for unloading of pdh.dll granted all sessions use the pair:
1052 *
1053 *   pdh_acquire();
1054 *   pdh_release();
1055 *
1056 * @return  OS_OK if successful, OS_ERR on failure.
1057 */
<span class="line-modified">1058 static OSReturn pdh_acquire() {</span>
<span class="line-modified">1059   PdhMutex mutex;</span>
<span class="line-modified">1060   reference_count++;</span>
1061   if (pdh_initialized) {
<span class="line-modified">1062     return OS_OK;</span>
1063   }
<span class="line-modified">1064   const OSReturn status = initialize();</span>
<span class="line-modified">1065   pdh_initialized = status == OS_OK;</span>
<span class="line-modified">1066   return status;</span>



1067 }
1068 
1069 static void pdh_release() {
<span class="line-modified">1070   PdhMutex mutex;</span>
<span class="line-modified">1071   if (1 == reference_count--) {</span>
<span class="line-modified">1072     deallocate_pdh_constants();</span>
<span class="line-modified">1073     PdhDll::PdhDetach();</span>
1074     pdh_initialized = false;
1075   }

1076 }
1077 
1078 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
1079   friend class CPUPerformanceInterface;
1080  private:
1081   CounterQueryP _context_switches;
1082   ProcessQueryP _process_cpu_load;
1083   MultiCounterQueryP _machine_cpu_load;
1084 
1085   int cpu_load(int which_logical_cpu, double* cpu_load);
1086   int context_switch_rate(double* rate);
1087   int cpu_load_total_process(double* cpu_load);
<span class="line-modified">1088   int cpu_loads_process(double* jvm_user_load, double* jvm_kernel_load, double* system_total_load);</span>
1089   CPUPerformance();
1090   ~CPUPerformance();
1091   bool initialize();
1092 };
1093 






























1094 CPUPerformanceInterface::CPUPerformance::CPUPerformance() : _context_switches(NULL), _process_cpu_load(NULL), _machine_cpu_load(NULL) {}
1095 
1096 bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified">1097   if (pdh_acquire() != OS_OK) {</span>
<span class="line-modified">1098     return false;</span>
1099   }
<span class="line-modified">1100   _context_switches = create_counter_query();</span>
<span class="line-added">1101   assert(_context_switches != NULL, &quot;invariant&quot;);</span>
<span class="line-added">1102   if (initialize_context_switches_query(_context_switches) != OS_OK) {</span>
<span class="line-added">1103     return false;</span>
<span class="line-added">1104   }</span>
<span class="line-added">1105   assert(_context_switches-&gt;initialized, &quot;invariant&quot;);</span>
1106   _process_cpu_load = create_process_query();
1107   if (_process_cpu_load == NULL) {
<span class="line-modified">1108     return false;</span>




1109   }
<span class="line-modified">1110   if (initialize_process_query(_process_cpu_load) != OS_OK) {</span>
<span class="line-modified">1111     return false;</span>
1112   }
<span class="line-modified">1113   assert(_process_cpu_load-&gt;set.initialized, &quot;invariant&quot;);</span>
1114   _machine_cpu_load = create_multi_counter_query();
<span class="line-modified">1115   assert(_machine_cpu_load != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1116   if (initialize_cpu_query(_machine_cpu_load) != OS_OK) {</span>
<span class="line-added">1117     return false;</span>
1118   }
<span class="line-modified">1119   assert(_machine_cpu_load-&gt;initialized, &quot;invariant&quot;);</span>
1120   return true;
1121 }
1122 
1123 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
1124   if (_context_switches != NULL) {
<span class="line-modified">1125     destroy(_context_switches);</span>
1126     _context_switches = NULL;
1127   }
1128   if (_process_cpu_load != NULL) {
<span class="line-modified">1129     destroy(_process_cpu_load);</span>
1130     _process_cpu_load = NULL;
1131   }
1132   if (_machine_cpu_load != NULL) {
<span class="line-modified">1133     destroy(_machine_cpu_load);</span>
1134     _machine_cpu_load = NULL;
1135   }
1136   pdh_release();
1137 }
1138 
<span class="line-modified">1139 CPUPerformanceInterface::CPUPerformanceInterface() : _impl(NULL) {}</span>


1140 
1141 bool CPUPerformanceInterface::initialize() {
1142   _impl = new CPUPerformanceInterface::CPUPerformance();
1143   return _impl-&gt;initialize();
1144 }
1145 
1146 CPUPerformanceInterface::~CPUPerformanceInterface() {
1147   if (_impl != NULL) {
1148     delete _impl;
1149   }
1150 }
1151 
1152 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
1153   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
1154 }
1155 
1156 int CPUPerformanceInterface::context_switch_rate(double* rate) const {
1157   return _impl-&gt;context_switch_rate(rate);
1158 }
1159 
1160 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
1161   return _impl-&gt;cpu_load_total_process(cpu_load);
1162 }
1163 
<span class="line-modified">1164 int CPUPerformanceInterface::cpu_loads_process(double* jvm_user_load,</span>
<span class="line-modified">1165                                                double* jvm_kernel_load,</span>
<span class="line-modified">1166                                                double* system_total_load) const {</span>
<span class="line-modified">1167   return _impl-&gt;cpu_loads_process(jvm_user_load, jvm_kernel_load, system_total_load);</span>
1168 }
1169 
1170 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
1171   *cpu_load = .0;
1172   if (_machine_cpu_load == NULL || !_machine_cpu_load-&gt;initialized) {
1173     return OS_ERR;
1174   }

1175   assert(which_logical_cpu &lt; _machine_cpu_load-&gt;noOfCounters, &quot;invariant&quot;);
<span class="line-modified">1176   if (collect(_machine_cpu_load) != OS_OK) {</span>

1177     return OS_ERR;
1178   }
1179   // -1 is total (all cpus)
1180   const int counter_idx = -1 == which_logical_cpu ? _machine_cpu_load-&gt;noOfCounters - 1 : which_logical_cpu;
1181   PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">1182   if (read_counter(_machine_cpu_load, counter_idx, PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
<span class="line-added">1183     return OS_ERR;</span>
<span class="line-added">1184   }</span>
1185   *cpu_load = counter_value.doubleValue / 100;
1186   return OS_OK;
1187 }
1188 
1189 int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {
1190   *cpu_load = .0;
1191   if (_process_cpu_load == NULL || !_process_cpu_load-&gt;set.initialized) {
1192     return OS_ERR;
1193   }
<span class="line-modified">1194   if (collect(_process_cpu_load) != OS_OK) {</span>

1195     return OS_ERR;
1196   }
1197   PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">1198   if (read_counter(_process_cpu_load, 0, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
1199     return OS_ERR;
1200   }
1201   double process_load = counter_value.doubleValue / cpu_factor();
1202   process_load = MIN2&lt;double&gt;(1, process_load);
1203   process_load = MAX2&lt;double&gt;(0, process_load);
1204   *cpu_load = process_load;
1205   return OS_OK;
1206 }
1207 
<span class="line-modified">1208 int CPUPerformanceInterface::CPUPerformance::cpu_loads_process(double* jvm_user_load,</span>
<span class="line-modified">1209                                                                double* jvm_kernel_load,</span>
<span class="line-modified">1210                                                                double* system_total_load) {</span>
<span class="line-modified">1211   assert(jvm_user_load != NULL, &quot;jvm_user_load is NULL!&quot;);</span>
<span class="line-modified">1212   assert(jvm_kernel_load != NULL, &quot;jvm_kernel_load is NULL!&quot;);</span>
<span class="line-modified">1213   assert(system_total_load != NULL, &quot;system_total_load is NULL!&quot;);</span>
<span class="line-modified">1214   *jvm_user_load = .0;</span>
<span class="line-modified">1215   *jvm_kernel_load = .0;</span>
<span class="line-modified">1216   *system_total_load = .0;</span>
1217 
1218   if (_process_cpu_load == NULL || !_process_cpu_load-&gt;set.initialized) {
1219     return OS_ERR;
1220   }
<span class="line-modified">1221   if (collect(_process_cpu_load) != OS_OK) {</span>

1222     return OS_ERR;
1223   }
1224   double process_load = .0;
1225   PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">1226   // Read PDH_PROCESSOR_TIME_IDX as counter_idx == 0</span>
<span class="line-modified">1227   if (read_counter(_process_cpu_load, 0, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
1228     return OS_ERR;
1229   }
1230   process_load = counter_value.doubleValue / cpu_factor();
1231   process_load = MIN2&lt;double&gt;(1, process_load);
1232   process_load = MAX2&lt;double&gt;(0, process_load);
<span class="line-modified">1233   // Read PDH_PRIV_PROCESSOR_TIME_IDX as counter_idx == 1</span>
<span class="line-modified">1234   if (read_counter(_process_cpu_load, 1, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &amp;counter_value) != OS_OK) {</span>
1235     return OS_ERR;
1236   }
<span class="line-modified">1237   double process_kernel_load = counter_value.doubleValue / cpu_factor();</span>
<span class="line-modified">1238   process_kernel_load = MIN2&lt;double&gt;(1, process_kernel_load);</span>
<span class="line-modified">1239   process_kernel_load = MAX2&lt;double&gt;(0, process_kernel_load);</span>
<span class="line-modified">1240   *jvm_kernel_load = process_kernel_load;</span>
1241 
<span class="line-modified">1242   double user_load = process_load - process_kernel_load;</span>
1243   user_load = MIN2&lt;double&gt;(1, user_load);
1244   user_load = MAX2&lt;double&gt;(0, user_load);
<span class="line-modified">1245   *jvm_user_load = user_load;</span>
<span class="line-modified">1246   if (collect(_machine_cpu_load) != OS_OK) {</span>

1247     return OS_ERR;
1248   }
<span class="line-modified">1249   // Read PDH_PROCESSOR_IDX as counter_idx == _machine_cpu_load-&gt;noOfCounters - 1</span>
<span class="line-added">1250   if (read_counter(_machine_cpu_load, _machine_cpu_load-&gt;noOfCounters - 1, PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
1251     return OS_ERR;
1252   }
1253   double machine_load = counter_value.doubleValue / 100;
1254   assert(machine_load &gt;= 0, &quot;machine_load is negative!&quot;);
1255   // clamp at user+system and 1.0
<span class="line-modified">1256   if (*jvm_kernel_load + *jvm_user_load &gt; machine_load) {</span>
<span class="line-modified">1257     machine_load = MIN2(*jvm_kernel_load + *jvm_user_load, 1.0);</span>
1258   }
<span class="line-modified">1259   *system_total_load = machine_load;</span>
1260   return OS_OK;
1261 }
1262 
1263 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
1264   assert(rate != NULL, &quot;invariant&quot;);
1265   *rate = .0;
1266   if (_context_switches == NULL || !_context_switches-&gt;initialized) {
1267     return OS_ERR;
1268   }
<span class="line-modified">1269   if (collect(_context_switches) != OS_OK) {</span>

1270     return OS_ERR;
1271   }
1272   PDH_FMT_COUNTERVALUE counter_value;
<span class="line-modified">1273   if (read_counter(_context_switches, PDH_FMT_DOUBLE, &amp;counter_value) != OS_OK) {</span>
1274     return OS_ERR;
1275   }
1276   *rate = counter_value.doubleValue;
1277   return OS_OK;
1278 }
1279 
<span class="line-added">1280 class SystemProcessInterface::SystemProcesses : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-added">1281   friend class SystemProcessInterface;</span>
<span class="line-added">1282  private:</span>
<span class="line-added">1283   class ProcessIterator : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-added">1284     friend class SystemProcessInterface::SystemProcesses;</span>
<span class="line-added">1285    private:</span>
<span class="line-added">1286     HANDLE         _hProcessSnap;</span>
<span class="line-added">1287     PROCESSENTRY32 _pe32;</span>
<span class="line-added">1288     BOOL           _valid;</span>
<span class="line-added">1289     char           _exePath[MAX_PATH];</span>
<span class="line-added">1290     ProcessIterator();</span>
<span class="line-added">1291     ~ProcessIterator();</span>
<span class="line-added">1292     bool initialize();</span>
<span class="line-added">1293 </span>
<span class="line-added">1294     int current(SystemProcess* const process_info);</span>
<span class="line-added">1295     int next_process();</span>
<span class="line-added">1296     bool is_valid() const { return _valid != FALSE; }</span>
<span class="line-added">1297     char* allocate_string(const char* str) const;</span>
<span class="line-added">1298     int snapshot();</span>
<span class="line-added">1299   };</span>
<span class="line-added">1300 </span>
<span class="line-added">1301   ProcessIterator* _iterator;</span>
<span class="line-added">1302   SystemProcesses();</span>
<span class="line-added">1303   ~SystemProcesses();</span>
<span class="line-added">1304   bool initialize();</span>
<span class="line-added">1305 </span>
<span class="line-added">1306   // information about system processes</span>
<span class="line-added">1307   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;</span>
<span class="line-added">1308 };</span>
<span class="line-added">1309 </span>
1310 SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {
1311   _hProcessSnap = INVALID_HANDLE_VALUE;
1312   _valid = FALSE;
1313   _pe32.dwSize = sizeof(PROCESSENTRY32);
1314 }
1315 
1316 bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {
1317   return true;
1318 }
1319 
1320 int SystemProcessInterface::SystemProcesses::ProcessIterator::snapshot() {
1321   // take snapshot of all process in the system
1322   _hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
1323   if (_hProcessSnap == INVALID_HANDLE_VALUE) {
1324     return OS_ERR;
1325   }
1326   // step to first process
1327   _valid = Process32First(_hProcessSnap, &amp;_pe32);
1328   return is_valid() ? OS_OK : OS_ERR;
1329 }
</pre>
<hr />
<pre>
1339   assert(process_info != NULL, &quot;process_info is NULL!&quot;);
1340   char* exePath = NULL;
1341   HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, _pe32.th32ProcessID);
1342   if (hProcess != NULL) {
1343     HMODULE hMod;
1344     DWORD cbNeeded;
1345     if (EnumProcessModules(hProcess, &amp;hMod, sizeof(hMod), &amp;cbNeeded) != 0) {
1346       if (GetModuleFileNameExA(hProcess, hMod, _exePath, sizeof(_exePath)) != 0) {
1347         exePath = _exePath;
1348       }
1349     }
1350     CloseHandle (hProcess);
1351   }
1352   process_info-&gt;set_pid((int)_pe32.th32ProcessID);
1353   process_info-&gt;set_name(allocate_string(_pe32.szExeFile));
1354   process_info-&gt;set_path(allocate_string(exePath));
1355   return OS_OK;
1356 }
1357 
1358 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
<span class="line-modified">1359   return str != NULL ? os::strdup_check_oom(str, mtInternal) : NULL;</span>



1360 }
1361 
1362 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
1363   _valid = Process32Next(_hProcessSnap, &amp;_pe32);
1364   return OS_OK;
1365 }
1366 
<span class="line-modified">1367 SystemProcessInterface::SystemProcesses::SystemProcesses() : _iterator(NULL) {}</span>


1368 
1369 bool SystemProcessInterface::SystemProcesses::initialize() {
1370   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
1371   return _iterator-&gt;initialize();
1372 }
1373 
1374 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
1375   if (_iterator != NULL) {
1376     delete _iterator;

1377   }
1378 }
1379 
1380 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes,
1381                                                               int* no_of_sys_processes) const {
1382   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
1383   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
1384   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
1385 
1386   // initialize pointers
1387   *no_of_sys_processes = 0;
1388   *system_processes = NULL;
1389 
1390   // take process snapshot
1391   if (_iterator-&gt;snapshot() != OS_OK) {
1392     return OS_ERR;
1393   }
1394 
1395   while (_iterator-&gt;is_valid()) {
1396     SystemProcess* tmp = new SystemProcess();
</pre>
<hr />
<pre>
1399     //if already existing head
1400     if (*system_processes != NULL) {
1401       //move &quot;first to second&quot;
1402       tmp-&gt;set_next(*system_processes);
1403     }
1404     // new head
1405     *system_processes = tmp;
1406     // increment
1407     (*no_of_sys_processes)++;
1408     // step forward
1409     _iterator-&gt;next_process();
1410   }
1411   return OS_OK;
1412 }
1413 
1414 int SystemProcessInterface::system_processes(SystemProcess** system_procs,
1415                                              int* no_of_sys_processes) const {
1416   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
1417 }
1418 
<span class="line-modified">1419 SystemProcessInterface::SystemProcessInterface() : _impl(NULL) {}</span>


1420 
1421 bool SystemProcessInterface::initialize() {
1422   _impl = new SystemProcessInterface::SystemProcesses();
1423   return _impl-&gt;initialize();
1424 }
1425 
1426 SystemProcessInterface::~SystemProcessInterface() {
1427   if (_impl != NULL) {
1428     delete _impl;
1429   }
1430 }
1431 
<span class="line-modified">1432 CPUInformationInterface::CPUInformationInterface() : _cpu_info(NULL) {}</span>


1433 
1434 bool CPUInformationInterface::initialize() {
1435   _cpu_info = new CPUInformation();
1436   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
1437   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
1438   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
1439   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
1440   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
1441   return true;
1442 }
1443 
1444 CPUInformationInterface::~CPUInformationInterface() {
1445   if (_cpu_info != NULL) {
1446     FREE_C_HEAP_ARRAY(char, _cpu_info-&gt;cpu_name());
1447     _cpu_info-&gt;set_cpu_name(NULL);
1448     FREE_C_HEAP_ARRAY(char, _cpu_info-&gt;cpu_description());
1449     _cpu_info-&gt;set_cpu_description(NULL);
1450     delete _cpu_info;

1451   }
1452 }
1453 
1454 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
1455   if (NULL == _cpu_info) {
1456     return OS_ERR;
1457   }
1458   cpu_info = *_cpu_info; // shallow copy assignment
1459   return OS_OK;
1460 }
1461 
1462 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
1463   friend class NetworkPerformanceInterface;
1464  private:
1465   bool _iphlp_attached;
1466 
1467   NetworkPerformance();
1468   NONCOPYABLE(NetworkPerformance);
1469   bool initialize();
1470   ~NetworkPerformance();
1471   int network_utilization(NetworkInterface** network_interfaces) const;
1472 };
1473 
<span class="line-modified">1474 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() : _iphlp_attached(false) {}</span>


1475 
1476 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
1477   _iphlp_attached = IphlpDll::IphlpAttach();
1478   return _iphlp_attached;
1479 }
1480 
1481 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
1482   if (_iphlp_attached) {
1483     IphlpDll::IphlpDetach();
1484   }
1485 }
1486 
1487 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const {
1488   MIB_IF_TABLE2* table;
1489 
1490   if (IphlpDll::GetIfTable2(&amp;table) != NO_ERROR) {
1491     return OS_ERR;
1492   }
1493 
1494   NetworkInterface* ret = NULL;
1495   for (ULONG i = 0; i &lt; table-&gt;NumEntries; ++i) {
1496     if (table-&gt;Table[i].InterfaceAndOperStatusFlags.FilterInterface) {
1497       continue;
1498     }
1499 
1500     char buf[256];
1501     if (WideCharToMultiByte(CP_UTF8, 0, table-&gt;Table[i].Description, -1, buf, sizeof(buf), NULL, NULL) == 0) {
1502       continue;
1503     }
1504 
1505     NetworkInterface* cur = new NetworkInterface(buf, table-&gt;Table[i].InOctets, table-&gt;Table[i].OutOctets, ret);
1506     ret = cur;
1507   }
1508 
1509   IphlpDll::FreeMibTable(table);
1510   *network_interfaces = ret;
1511 
1512   return OS_OK;
1513 }
1514 
<span class="line-modified">1515 NetworkPerformanceInterface::NetworkPerformanceInterface() : _impl(NULL) {}</span>


1516 
1517 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1518   if (_impl != NULL) {
1519     delete _impl;
1520   }
1521 }
1522 
1523 bool NetworkPerformanceInterface::initialize() {
1524   _impl = new NetworkPerformanceInterface::NetworkPerformance();
1525   return _impl-&gt;initialize();
1526 }
1527 
1528 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1529   return _impl-&gt;network_utilization(network_interfaces);
1530 }
</pre>
</td>
</tr>
</table>
<center><a href="../solaris/os_solaris.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/windows/pdh_interface.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;pdh_interface.hpp&quot;
 27 #include &quot;runtime/os.hpp&quot;
 28 #include &quot;utilities/macros.hpp&quot;
 29 
 30 // PDH API
 31 typedef PDH_STATUS (WINAPI *PdhAddCounter_Fn)(HQUERY, LPCSTR, DWORD, HCOUNTER*);
 32 typedef PDH_STATUS (WINAPI *PdhOpenQuery_Fn)(LPCWSTR, DWORD, HQUERY*);
 33 typedef DWORD      (WINAPI *PdhCloseQuery_Fn)(HQUERY);
 34 typedef PDH_STATUS (WINAPI *PdhCollectQueryData_Fn)(HQUERY);
 35 typedef DWORD      (WINAPI *PdhGetFormattedCounterValue_Fn)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE);
 36 typedef PDH_STATUS (WINAPI *PdhEnumObjectItems_Fn)(LPCTSTR, LPCTSTR, LPCTSTR, LPTSTR, LPDWORD, LPTSTR, LPDWORD, DWORD, DWORD);
 37 typedef PDH_STATUS (WINAPI *PdhRemoveCounter_Fn)(HCOUNTER);
 38 typedef PDH_STATUS (WINAPI *PdhLookupPerfNameByIndex_Fn)(LPCSTR, DWORD, LPSTR, LPDWORD);
 39 typedef PDH_STATUS (WINAPI *PdhMakeCounterPath_Fn)(PDH_COUNTER_PATH_ELEMENTS*, LPTSTR, LPDWORD, DWORD);
<a name="2" id="anc2"></a><span class="line-added"> 40 typedef PDH_STATUS (WINAPI *PdhExpandWildCardPath_Fn)(LPCSTR, LPCSTR, PZZSTR, LPDWORD, DWORD);</span>
 41 
 42 PdhAddCounter_Fn PdhDll::_PdhAddCounter = NULL;
 43 PdhOpenQuery_Fn  PdhDll::_PdhOpenQuery = NULL;
 44 PdhCloseQuery_Fn PdhDll::_PdhCloseQuery = NULL;
 45 PdhCollectQueryData_Fn PdhDll::_PdhCollectQueryData = NULL;
 46 PdhGetFormattedCounterValue_Fn PdhDll::_PdhGetFormattedCounterValue = NULL;
 47 PdhEnumObjectItems_Fn PdhDll::_PdhEnumObjectItems = NULL;
 48 PdhRemoveCounter_Fn PdhDll::_PdhRemoveCounter = NULL;
 49 PdhLookupPerfNameByIndex_Fn PdhDll::_PdhLookupPerfNameByIndex = NULL;
 50 PdhMakeCounterPath_Fn PdhDll::_PdhMakeCounterPath = NULL;
<a name="3" id="anc3"></a><span class="line-added"> 51 PdhExpandWildCardPath_Fn PdhDll::_PdhExpandWildCardPath = NULL;</span>
 52 
 53 LONG PdhDll::_critical_section = 0;
 54 LONG PdhDll::_initialized = 0;
 55 LONG PdhDll::_pdh_reference_count = 0;
 56 HMODULE PdhDll::_hModule = NULL;
 57 
 58 void PdhDll::initialize(void) {
 59   _hModule = os::win32::load_Windows_dll(&quot;pdh.dll&quot;, NULL, 0);
 60   if (NULL == _hModule) {
 61     return;
 62   }
 63   // The &#39;A&#39; at the end means the ANSI (not the UNICODE) vesions of the methods
 64   _PdhAddCounter               = (PdhAddCounter_Fn)::GetProcAddress(_hModule, &quot;PdhAddCounterA&quot;);
 65   _PdhOpenQuery                = (PdhOpenQuery_Fn)::GetProcAddress(_hModule, &quot;PdhOpenQueryA&quot;);
 66   _PdhCloseQuery               = (PdhCloseQuery_Fn)::GetProcAddress(_hModule, &quot;PdhCloseQuery&quot;);
 67   _PdhCollectQueryData         = (PdhCollectQueryData_Fn)::GetProcAddress(_hModule, &quot;PdhCollectQueryData&quot;);
 68   _PdhGetFormattedCounterValue = (PdhGetFormattedCounterValue_Fn)::GetProcAddress(_hModule, &quot;PdhGetFormattedCounterValue&quot;);
 69   _PdhEnumObjectItems          = (PdhEnumObjectItems_Fn)::GetProcAddress(_hModule, &quot;PdhEnumObjectItemsA&quot;);
 70   _PdhRemoveCounter            = (PdhRemoveCounter_Fn)::GetProcAddress(_hModule, &quot;PdhRemoveCounter&quot;);
 71   _PdhLookupPerfNameByIndex    = (PdhLookupPerfNameByIndex_Fn)::GetProcAddress(_hModule, &quot;PdhLookupPerfNameByIndexA&quot;);
 72   _PdhMakeCounterPath          = (PdhMakeCounterPath_Fn)::GetProcAddress(_hModule, &quot;PdhMakeCounterPathA&quot;);
<a name="4" id="anc4"></a><span class="line-added"> 73   _PdhExpandWildCardPath       = (PdhExpandWildCardPath_Fn)::GetProcAddress(_hModule, &quot;PdhExpandWildCardPathA&quot;);</span>
 74   InterlockedExchange(&amp;_initialized, 1);
 75 }
 76 
 77 bool PdhDll::PdhDetach(void) {
 78   LONG prev_ref_count = InterlockedExchangeAdd(&amp;_pdh_reference_count, -1);
 79   BOOL ret = false;
 80   if (1 == prev_ref_count) {
 81     if (_initialized &amp;&amp; _hModule != NULL) {
 82       ret = FreeLibrary(_hModule);
 83       if (ret) {
 84         _hModule = NULL;
 85         _PdhAddCounter = NULL;
 86         _PdhOpenQuery = NULL;
 87         _PdhCloseQuery = NULL;
 88         _PdhCollectQueryData = NULL;
 89         _PdhGetFormattedCounterValue = NULL;
 90         _PdhEnumObjectItems = NULL;
 91         _PdhRemoveCounter = NULL;
 92         _PdhLookupPerfNameByIndex = NULL;
 93         _PdhMakeCounterPath = NULL;
<a name="5" id="anc5"></a><span class="line-added"> 94         _PdhExpandWildCardPath = NULL;</span>
 95         InterlockedExchange(&amp;_initialized, 0);
 96       }
 97     }
 98   }
 99   return ret != 0;
100 }
101 
102 bool PdhDll::PdhAttach(void) {
103   InterlockedExchangeAdd(&amp;_pdh_reference_count, 1);
104   if (1 == _initialized) {
105     return true;
106   }
107   while (InterlockedCompareExchange(&amp;_critical_section, 1, 0) == 1);
108   if (0 == _initialized) {
109     initialize();
110   }
111   while (InterlockedCompareExchange(&amp;_critical_section, 0, 1) == 0);
112   return (_PdhAddCounter != NULL &amp;&amp; _PdhOpenQuery != NULL
113          &amp;&amp; _PdhCloseQuery != NULL &amp;&amp; PdhCollectQueryData != NULL
114          &amp;&amp; _PdhGetFormattedCounterValue != NULL &amp;&amp; _PdhEnumObjectItems != NULL
115          &amp;&amp; _PdhRemoveCounter != NULL &amp;&amp; PdhLookupPerfNameByIndex != NULL
<a name="6" id="anc6"></a><span class="line-modified">116          &amp;&amp; _PdhMakeCounterPath != NULL &amp;&amp; _PdhExpandWildCardPath != NULL);</span>
117 }
118 
119 PDH_STATUS PdhDll::PdhAddCounter(HQUERY hQuery, LPCSTR szFullCounterPath, DWORD dwUserData, HCOUNTER* phCounter) {
120   assert(_initialized &amp;&amp; _PdhAddCounter != NULL, &quot;PdhAvailable() not yet called&quot;);
121   return _PdhAddCounter(hQuery, szFullCounterPath, dwUserData, phCounter);
122 }
123 
124 PDH_STATUS PdhDll::PdhOpenQuery(LPCWSTR szDataSource, DWORD dwUserData, HQUERY* phQuery) {
125   assert(_initialized &amp;&amp; _PdhOpenQuery != NULL, &quot;PdhAvailable() not yet called&quot;);
126   return _PdhOpenQuery(szDataSource, dwUserData, phQuery);
127 }
128 
129 DWORD PdhDll::PdhCloseQuery(HQUERY hQuery) {
130   assert(_initialized &amp;&amp; _PdhCloseQuery != NULL, &quot;PdhAvailable() not yet called&quot;);
131   return _PdhCloseQuery(hQuery);
132 }
133 
134 PDH_STATUS PdhDll::PdhCollectQueryData(HQUERY hQuery) {
135   assert(_initialized &amp;&amp; _PdhCollectQueryData != NULL, &quot;PdhAvailable() not yet called&quot;);
136   return _PdhCollectQueryData(hQuery);
137 }
138 
139 DWORD PdhDll::PdhGetFormattedCounterValue(HCOUNTER hCounter, DWORD dwFormat, LPDWORD lpdwType, PPDH_FMT_COUNTERVALUE pValue) {
140   assert(_initialized &amp;&amp; _PdhGetFormattedCounterValue != NULL, &quot;PdhAvailable() not yet called&quot;);
141   return _PdhGetFormattedCounterValue(hCounter, dwFormat, lpdwType, pValue);
142 }
143 
144 PDH_STATUS PdhDll::PdhEnumObjectItems(LPCTSTR szDataSource, LPCTSTR szMachineName, LPCTSTR szObjectName,
145     LPTSTR mszCounterList, LPDWORD pcchCounterListLength, LPTSTR mszInstanceList,
146     LPDWORD pcchInstanceListLength, DWORD dwDetailLevel, DWORD dwFlags) {
147   assert(_initialized &amp;&amp; _PdhEnumObjectItems != NULL, &quot;PdhAvailable() not yet called&quot;);
148   return _PdhEnumObjectItems(szDataSource, szMachineName, szObjectName, mszCounterList, pcchCounterListLength,
149     mszInstanceList, pcchInstanceListLength, dwDetailLevel, dwFlags);
150 }
151 
152 PDH_STATUS PdhDll::PdhRemoveCounter(HCOUNTER hCounter) {
153   assert(_initialized &amp;&amp; _PdhRemoveCounter != NULL, &quot;PdhAvailable() not yet called&quot;);
154   return _PdhRemoveCounter(hCounter);
155 }
156 
157 PDH_STATUS PdhDll::PdhLookupPerfNameByIndex(LPCSTR szMachineName, DWORD dwNameIndex, LPSTR szNameBuffer, LPDWORD pcchNameBufferSize) {
158   assert(_initialized &amp;&amp; _PdhLookupPerfNameByIndex != NULL, &quot;PdhAvailable() not yet called&quot;);
159   return _PdhLookupPerfNameByIndex(szMachineName, dwNameIndex, szNameBuffer, pcchNameBufferSize);
160 }
161 
162 PDH_STATUS PdhDll::PdhMakeCounterPath(PDH_COUNTER_PATH_ELEMENTS* pCounterPathElements, LPTSTR szFullPathBuffer, LPDWORD pcchBufferSize, DWORD dwFlags) {
163   assert(_initialized &amp;&amp; _PdhMakeCounterPath != NULL, &quot;PdhAvailable() not yet called&quot;);
164   return _PdhMakeCounterPath(pCounterPathElements, szFullPathBuffer, pcchBufferSize, dwFlags);
165 }
166 
<a name="7" id="anc7"></a><span class="line-added">167 PDH_STATUS PdhDll::PdhExpandWildCardPath(LPCSTR szDataSource, LPCSTR szWildCardPath, PZZSTR mszExpandedPathList, LPDWORD pcchPathListLength, DWORD dwFlags) {</span>
<span class="line-added">168   assert(_initialized &amp;&amp; PdhExpandWildCardPath != NULL, &quot;PdhAvailable() not yet called&quot;);</span>
<span class="line-added">169   return _PdhExpandWildCardPath(szDataSource, szWildCardPath, mszExpandedPathList, pcchPathListLength, dwFlags);</span>
<span class="line-added">170 }</span>
<span class="line-added">171 </span>
172 bool PdhDll::PdhStatusFail(PDH_STATUS pdhStat) {
173   return pdhStat != ERROR_SUCCESS &amp;&amp; pdhStat != PDH_MORE_DATA;
174 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/stubGenerator_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_globals_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ppc/c1_globals_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/stubGenerator_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3011     //       the disadvantage of having a much more complicated generator structure. See also comment in stubRoutines.hpp.
3012     StubRoutines::_forward_exception_entry      = generate_forward_exception();
3013 
3014     StubRoutines::_call_stub_entry              =
3015       generate_call_stub(StubRoutines::_call_stub_return_address);
3016     // is referenced by megamorphic call
3017     StubRoutines::_catch_exception_entry        = generate_catch_exception();
3018 
3019     // stub for throwing stack overflow error used both by interpreter and compiler
3020     StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(&quot;StackOverflowError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));
3021 
3022     // integer division used both by interpreter and compiler
3023     StubRoutines::Arm::_idiv_irem_entry = generate_idiv_irem();
3024 
3025     StubRoutines::_atomic_add_entry = generate_atomic_add();
3026     StubRoutines::_atomic_xchg_entry = generate_atomic_xchg();
3027     StubRoutines::_atomic_cmpxchg_entry = generate_atomic_cmpxchg();
3028     StubRoutines::_atomic_cmpxchg_long_entry = generate_atomic_cmpxchg_long();
3029     StubRoutines::_atomic_load_long_entry = generate_atomic_load_long();
3030     StubRoutines::_atomic_store_long_entry = generate_atomic_store_long();









3031   }
3032 
3033   void generate_all() {
3034     // Generates all stubs and initializes the entry points
3035 
3036 #ifdef COMPILER2
3037     // Generate partial_subtype_check first here since its code depends on
3038     // UseZeroBaseCompressedOops which is defined after heap initialization.
3039     StubRoutines::Arm::_partial_subtype_check                = generate_partial_subtype_check();
3040 #endif
3041     // These entry points require SharedInfo::stack0 to be set up in non-core builds
3042     // and need to be relocatable, so they each fabricate a RuntimeStub internally.
3043     StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(&quot;AbstractMethodError throw_exception&quot;,          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));
3044     StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(&quot;IncompatibleClassChangeError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));
3045     StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));
3046 
3047     //------------------------------------------------------------------------------------------------------------------------
3048     // entry points that are platform specific
3049 
3050     // support for verify_oop (must happen after universe_init)
3051     StubRoutines::_verify_oop_subroutine_entry     = generate_verify_oop();
3052 
3053     // arraycopy stubs used by compilers
3054     generate_arraycopy_stubs();
3055 
<span class="line-removed">3056     // Safefetch stubs.</span>
<span class="line-removed">3057     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int), &amp;StubRoutines::_safefetch32_entry,</span>
<span class="line-removed">3058                                                    &amp;StubRoutines::_safefetch32_fault_pc,</span>
<span class="line-removed">3059                                                    &amp;StubRoutines::_safefetch32_continuation_pc);</span>
<span class="line-removed">3060     assert (sizeof(int) == wordSize, &quot;32-bit architecture&quot;);</span>
<span class="line-removed">3061     StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;</span>
<span class="line-removed">3062     StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;</span>
<span class="line-removed">3063     StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;</span>
<span class="line-removed">3064 </span>
3065 #ifdef COMPILE_CRYPTO
3066     // generate AES intrinsics code
3067     if (UseAESIntrinsics) {
3068       aes_init();
3069       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3070       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3071       StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
3072       StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();
3073     }
3074 #endif // COMPILE_CRYPTO
3075   }
3076 
3077 
3078  public:
3079   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3080     if (all) {
3081       generate_all();
3082     } else {
3083       generate_initial();
3084     }
</pre>
</td>
<td>
<hr />
<pre>
3011     //       the disadvantage of having a much more complicated generator structure. See also comment in stubRoutines.hpp.
3012     StubRoutines::_forward_exception_entry      = generate_forward_exception();
3013 
3014     StubRoutines::_call_stub_entry              =
3015       generate_call_stub(StubRoutines::_call_stub_return_address);
3016     // is referenced by megamorphic call
3017     StubRoutines::_catch_exception_entry        = generate_catch_exception();
3018 
3019     // stub for throwing stack overflow error used both by interpreter and compiler
3020     StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(&quot;StackOverflowError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));
3021 
3022     // integer division used both by interpreter and compiler
3023     StubRoutines::Arm::_idiv_irem_entry = generate_idiv_irem();
3024 
3025     StubRoutines::_atomic_add_entry = generate_atomic_add();
3026     StubRoutines::_atomic_xchg_entry = generate_atomic_xchg();
3027     StubRoutines::_atomic_cmpxchg_entry = generate_atomic_cmpxchg();
3028     StubRoutines::_atomic_cmpxchg_long_entry = generate_atomic_cmpxchg_long();
3029     StubRoutines::_atomic_load_long_entry = generate_atomic_load_long();
3030     StubRoutines::_atomic_store_long_entry = generate_atomic_store_long();
<span class="line-added">3031 </span>
<span class="line-added">3032     // Safefetch stubs.</span>
<span class="line-added">3033     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int), &amp;StubRoutines::_safefetch32_entry,</span>
<span class="line-added">3034                                                    &amp;StubRoutines::_safefetch32_fault_pc,</span>
<span class="line-added">3035                                                    &amp;StubRoutines::_safefetch32_continuation_pc);</span>
<span class="line-added">3036     assert (sizeof(int) == wordSize, &quot;32-bit architecture&quot;);</span>
<span class="line-added">3037     StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;</span>
<span class="line-added">3038     StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;</span>
<span class="line-added">3039     StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;</span>
3040   }
3041 
3042   void generate_all() {
3043     // Generates all stubs and initializes the entry points
3044 
3045 #ifdef COMPILER2
3046     // Generate partial_subtype_check first here since its code depends on
3047     // UseZeroBaseCompressedOops which is defined after heap initialization.
3048     StubRoutines::Arm::_partial_subtype_check                = generate_partial_subtype_check();
3049 #endif
3050     // These entry points require SharedInfo::stack0 to be set up in non-core builds
3051     // and need to be relocatable, so they each fabricate a RuntimeStub internally.
3052     StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(&quot;AbstractMethodError throw_exception&quot;,          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));
3053     StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(&quot;IncompatibleClassChangeError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));
3054     StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));
3055 
3056     //------------------------------------------------------------------------------------------------------------------------
3057     // entry points that are platform specific
3058 
3059     // support for verify_oop (must happen after universe_init)
3060     StubRoutines::_verify_oop_subroutine_entry     = generate_verify_oop();
3061 
3062     // arraycopy stubs used by compilers
3063     generate_arraycopy_stubs();
3064 









3065 #ifdef COMPILE_CRYPTO
3066     // generate AES intrinsics code
3067     if (UseAESIntrinsics) {
3068       aes_init();
3069       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3070       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3071       StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
3072       StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();
3073     }
3074 #endif // COMPILE_CRYPTO
3075   }
3076 
3077 
3078  public:
3079   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3080     if (all) {
3081       generate_all();
3082     } else {
3083       generate_initial();
3084     }
</pre>
</td>
</tr>
</table>
<center><a href="c1_globals_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ppc/c1_globals_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/cpu/ppc/ppc.ad b/src/hotspot/cpu/ppc/ppc.ad
--- a/src/hotspot/cpu/ppc/ppc.ad
+++ b/src/hotspot/cpu/ppc/ppc.ad
@@ -13828,57 +13828,114 @@
 %}
 
 // Load Integer reversed byte order
 instruct loadI_reversed(iRegIdst dst, indirect mem) %{
   match(Set dst (ReverseBytesI (LoadI mem)));
+  predicate(n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1)));
   ins_cost(MEMORY_REF_COST);
 
   size(4);
   ins_encode %{
     __ lwbrx($dst$$Register, $mem$$Register);
   %}
   ins_pipe(pipe_class_default);
 %}
 
+instruct loadI_reversed_acquire(iRegIdst dst, indirect mem) %{
+  match(Set dst (ReverseBytesI (LoadI mem)));
+  ins_cost(2 * MEMORY_REF_COST);
+
+  size(12);
+  ins_encode %{
+    __ lwbrx($dst$$Register, $mem$$Register);
+    __ twi_0($dst$$Register);
+    __ isync();
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
 // Load Long - aligned and reversed
 instruct loadL_reversed(iRegLdst dst, indirect mem) %{
   match(Set dst (ReverseBytesL (LoadL mem)));
-  predicate(VM_Version::has_ldbrx());
+  predicate(VM_Version::has_ldbrx() && (n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));
   ins_cost(MEMORY_REF_COST);
 
   size(4);
   ins_encode %{
     __ ldbrx($dst$$Register, $mem$$Register);
   %}
   ins_pipe(pipe_class_default);
 %}
 
+instruct loadL_reversed_acquire(iRegLdst dst, indirect mem) %{
+  match(Set dst (ReverseBytesL (LoadL mem)));
+  predicate(VM_Version::has_ldbrx());
+  ins_cost(2 * MEMORY_REF_COST);
+
+  size(12);
+  ins_encode %{
+    __ ldbrx($dst$$Register, $mem$$Register);
+    __ twi_0($dst$$Register);
+    __ isync();
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
 // Load unsigned short / char reversed byte order
 instruct loadUS_reversed(iRegIdst dst, indirect mem) %{
   match(Set dst (ReverseBytesUS (LoadUS mem)));
+  predicate(n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1)));
   ins_cost(MEMORY_REF_COST);
 
   size(4);
   ins_encode %{
     __ lhbrx($dst$$Register, $mem$$Register);
   %}
   ins_pipe(pipe_class_default);
 %}
 
+instruct loadUS_reversed_acquire(iRegIdst dst, indirect mem) %{
+  match(Set dst (ReverseBytesUS (LoadUS mem)));
+  ins_cost(2 * MEMORY_REF_COST);
+
+  size(12);
+  ins_encode %{
+    __ lhbrx($dst$$Register, $mem$$Register);
+    __ twi_0($dst$$Register);
+    __ isync();
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
 // Load short reversed byte order
 instruct loadS_reversed(iRegIdst dst, indirect mem) %{
   match(Set dst (ReverseBytesS (LoadS mem)));
+  predicate(n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1)));
   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 
   size(8);
   ins_encode %{
     __ lhbrx($dst$$Register, $mem$$Register);
     __ extsh($dst$$Register, $dst$$Register);
   %}
   ins_pipe(pipe_class_default);
 %}
 
+instruct loadS_reversed_acquire(iRegIdst dst, indirect mem) %{
+  match(Set dst (ReverseBytesS (LoadS mem)));
+  ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
+
+  size(16);
+  ins_encode %{
+    __ lhbrx($dst$$Register, $mem$$Register);
+    __ twi_0($dst$$Register);
+    __ extsh($dst$$Register, $dst$$Register);
+    __ isync();
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
 // Store Integer reversed byte order
 instruct storeI_reversed(iRegIsrc src, indirect mem) %{
   match(Set mem (StoreI mem (ReverseBytesI src)));
   ins_cost(MEMORY_REF_COST);
 

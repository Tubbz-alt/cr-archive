<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/stubGenerator_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_x86_32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/globalDefinitions_zero.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/stubGenerator_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
6555       }
6556       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog)) {
6557         StubRoutines::_dlog = generate_libmLog();
6558       }
6559       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog10)) {
6560         StubRoutines::_dlog10 = generate_libmLog10();
6561       }
6562       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dpow)) {
6563         StubRoutines::_dpow = generate_libmPow();
6564       }
6565       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin)) {
6566         StubRoutines::_dsin = generate_libmSin();
6567       }
6568       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos)) {
6569         StubRoutines::_dcos = generate_libmCos();
6570       }
6571       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {
6572         StubRoutines::_dtan = generate_libmTan();
6573       }
6574     }








6575   }
6576 
6577   void generate_all() {
6578     // Generates all stubs and initializes the entry points
6579 
6580     // These entry points require SharedInfo::stack0 to be set up in
6581     // non-core builds and need to be relocatable, so they each
6582     // fabricate a RuntimeStub internally.
6583     StubRoutines::_throw_AbstractMethodError_entry =
6584       generate_throw_exception(&quot;AbstractMethodError throw_exception&quot;,
6585                                CAST_FROM_FN_PTR(address,
6586                                                 SharedRuntime::
6587                                                 throw_AbstractMethodError));
6588 
6589     StubRoutines::_throw_IncompatibleClassChangeError_entry =
6590       generate_throw_exception(&quot;IncompatibleClassChangeError throw_exception&quot;,
6591                                CAST_FROM_FN_PTR(address,
6592                                                 SharedRuntime::
6593                                                 throw_IncompatibleClassChangeError));
6594 
</pre>
<hr />
<pre>
6674       if (VM_Version::supports_avx()) {
6675         StubRoutines::x86::_ghash_shuffmask_addr = ghash_shufflemask_addr();
6676         StubRoutines::x86::_ghash_poly_addr = ghash_polynomial_addr();
6677         StubRoutines::_ghash_processBlocks = generate_avx_ghash_processBlocks();
6678       } else {
6679         StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();
6680       }
6681     }
6682 
6683     if (UseBASE64Intrinsics) {
6684       StubRoutines::x86::_and_mask = base64_and_mask_addr();
6685       StubRoutines::x86::_bswap_mask = base64_bswap_mask_addr();
6686       StubRoutines::x86::_base64_charset = base64_charset_addr();
6687       StubRoutines::x86::_url_charset = base64url_charset_addr();
6688       StubRoutines::x86::_gather_mask = base64_gather_mask_addr();
6689       StubRoutines::x86::_left_shift_mask = base64_left_shift_mask_addr();
6690       StubRoutines::x86::_right_shift_mask = base64_right_shift_mask_addr();
6691       StubRoutines::_base64_encodeBlock = generate_base64_encodeBlock();
6692     }
6693 
<span class="line-removed">6694     // Safefetch stubs.</span>
<span class="line-removed">6695     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int),     &amp;StubRoutines::_safefetch32_entry,</span>
<span class="line-removed">6696                                                        &amp;StubRoutines::_safefetch32_fault_pc,</span>
<span class="line-removed">6697                                                        &amp;StubRoutines::_safefetch32_continuation_pc);</span>
<span class="line-removed">6698     generate_safefetch(&quot;SafeFetchN&quot;, sizeof(intptr_t), &amp;StubRoutines::_safefetchN_entry,</span>
<span class="line-removed">6699                                                        &amp;StubRoutines::_safefetchN_fault_pc,</span>
<span class="line-removed">6700                                                        &amp;StubRoutines::_safefetchN_continuation_pc);</span>
<span class="line-removed">6701 </span>
6702     BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();
6703     if (bs_nm != NULL) {
6704       StubRoutines::x86::_method_entry_barrier = generate_method_entry_barrier();
6705     }
6706 #ifdef COMPILER2
6707     if (UseMultiplyToLenIntrinsic) {
6708       StubRoutines::_multiplyToLen = generate_multiplyToLen();
6709     }
6710     if (UseSquareToLenIntrinsic) {
6711       StubRoutines::_squareToLen = generate_squareToLen();
6712     }
6713     if (UseMulAddIntrinsic) {
6714       StubRoutines::_mulAdd = generate_mulAdd();
6715     }
6716     if (VM_Version::supports_avx512_vbmi2()) {
6717       StubRoutines::_bigIntegerRightShiftWorker = generate_bigIntegerRightShift();
6718       StubRoutines::_bigIntegerLeftShiftWorker = generate_bigIntegerLeftShift();
6719     }
6720 #ifndef _WINDOWS
6721     if (UseMontgomeryMultiplyIntrinsic) {
</pre>
</td>
<td>
<hr />
<pre>
6555       }
6556       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog)) {
6557         StubRoutines::_dlog = generate_libmLog();
6558       }
6559       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog10)) {
6560         StubRoutines::_dlog10 = generate_libmLog10();
6561       }
6562       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dpow)) {
6563         StubRoutines::_dpow = generate_libmPow();
6564       }
6565       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin)) {
6566         StubRoutines::_dsin = generate_libmSin();
6567       }
6568       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos)) {
6569         StubRoutines::_dcos = generate_libmCos();
6570       }
6571       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {
6572         StubRoutines::_dtan = generate_libmTan();
6573       }
6574     }
<span class="line-added">6575 </span>
<span class="line-added">6576     // Safefetch stubs.</span>
<span class="line-added">6577     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int),     &amp;StubRoutines::_safefetch32_entry,</span>
<span class="line-added">6578                                                        &amp;StubRoutines::_safefetch32_fault_pc,</span>
<span class="line-added">6579                                                        &amp;StubRoutines::_safefetch32_continuation_pc);</span>
<span class="line-added">6580     generate_safefetch(&quot;SafeFetchN&quot;, sizeof(intptr_t), &amp;StubRoutines::_safefetchN_entry,</span>
<span class="line-added">6581                                                        &amp;StubRoutines::_safefetchN_fault_pc,</span>
<span class="line-added">6582                                                        &amp;StubRoutines::_safefetchN_continuation_pc);</span>
6583   }
6584 
6585   void generate_all() {
6586     // Generates all stubs and initializes the entry points
6587 
6588     // These entry points require SharedInfo::stack0 to be set up in
6589     // non-core builds and need to be relocatable, so they each
6590     // fabricate a RuntimeStub internally.
6591     StubRoutines::_throw_AbstractMethodError_entry =
6592       generate_throw_exception(&quot;AbstractMethodError throw_exception&quot;,
6593                                CAST_FROM_FN_PTR(address,
6594                                                 SharedRuntime::
6595                                                 throw_AbstractMethodError));
6596 
6597     StubRoutines::_throw_IncompatibleClassChangeError_entry =
6598       generate_throw_exception(&quot;IncompatibleClassChangeError throw_exception&quot;,
6599                                CAST_FROM_FN_PTR(address,
6600                                                 SharedRuntime::
6601                                                 throw_IncompatibleClassChangeError));
6602 
</pre>
<hr />
<pre>
6682       if (VM_Version::supports_avx()) {
6683         StubRoutines::x86::_ghash_shuffmask_addr = ghash_shufflemask_addr();
6684         StubRoutines::x86::_ghash_poly_addr = ghash_polynomial_addr();
6685         StubRoutines::_ghash_processBlocks = generate_avx_ghash_processBlocks();
6686       } else {
6687         StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();
6688       }
6689     }
6690 
6691     if (UseBASE64Intrinsics) {
6692       StubRoutines::x86::_and_mask = base64_and_mask_addr();
6693       StubRoutines::x86::_bswap_mask = base64_bswap_mask_addr();
6694       StubRoutines::x86::_base64_charset = base64_charset_addr();
6695       StubRoutines::x86::_url_charset = base64url_charset_addr();
6696       StubRoutines::x86::_gather_mask = base64_gather_mask_addr();
6697       StubRoutines::x86::_left_shift_mask = base64_left_shift_mask_addr();
6698       StubRoutines::x86::_right_shift_mask = base64_right_shift_mask_addr();
6699       StubRoutines::_base64_encodeBlock = generate_base64_encodeBlock();
6700     }
6701 








6702     BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();
6703     if (bs_nm != NULL) {
6704       StubRoutines::x86::_method_entry_barrier = generate_method_entry_barrier();
6705     }
6706 #ifdef COMPILER2
6707     if (UseMultiplyToLenIntrinsic) {
6708       StubRoutines::_multiplyToLen = generate_multiplyToLen();
6709     }
6710     if (UseSquareToLenIntrinsic) {
6711       StubRoutines::_squareToLen = generate_squareToLen();
6712     }
6713     if (UseMulAddIntrinsic) {
6714       StubRoutines::_mulAdd = generate_mulAdd();
6715     }
6716     if (VM_Version::supports_avx512_vbmi2()) {
6717       StubRoutines::_bigIntegerRightShiftWorker = generate_bigIntegerRightShift();
6718       StubRoutines::_bigIntegerLeftShiftWorker = generate_bigIntegerLeftShift();
6719     }
6720 #ifndef _WINDOWS
6721     if (UseMontgomeryMultiplyIntrinsic) {
</pre>
</td>
</tr>
</table>
<center><a href="stubGenerator_x86_32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/globalDefinitions_zero.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
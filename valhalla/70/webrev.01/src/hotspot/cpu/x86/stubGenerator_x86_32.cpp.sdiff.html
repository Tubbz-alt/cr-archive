<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/stubGenerator_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/stubGenerator_x86_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3853       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin) ||
3854         vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos) ||
3855         vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {
3856         StubRoutines::_dlibm_reduce_pi04l = generate_libm_reduce_pi04l();
3857       }
3858       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin) ||
3859         vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos)) {
3860         StubRoutines::_dlibm_sin_cos_huge = generate_libm_sin_cos_huge();
3861       }
3862       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin)) {
3863         StubRoutines::_dsin = generate_libmSin();
3864       }
3865       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos)) {
3866         StubRoutines::_dcos = generate_libmCos();
3867       }
3868       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {
3869         StubRoutines::_dlibm_tan_cot_huge = generate_libm_tan_cot_huge();
3870         StubRoutines::_dtan = generate_libmTan();
3871       }
3872     }








3873   }
3874 
3875   void generate_all() {
3876     // Generates all stubs and initializes the entry points
3877 
3878     // These entry points require SharedInfo::stack0 to be set up in non-core builds
3879     // and need to be relocatable, so they each fabricate a RuntimeStub internally.
3880     StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(&quot;AbstractMethodError throw_exception&quot;,          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));
3881     StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(&quot;IncompatibleClassChangeError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));
3882     StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));
3883 
3884     //------------------------------------------------------------------------------------------------------------------------
3885     // entry points that are platform specific
3886 
3887     StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(&quot;vector_float_sign_mask&quot;, 0x7FFFFFFF);
3888     StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(&quot;vector_float_sign_flip&quot;, 0x80000000);
3889     StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask_long_double(&quot;vector_double_sign_mask&quot;, 0x7FFFFFFF, 0xFFFFFFFF);
3890     StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask_long_double(&quot;vector_double_sign_flip&quot;, 0x80000000, 0x00000000);
3891     StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(&quot;vector_short_to_byte_mask&quot;, 0x00ff00ff);
3892     StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask(&quot;vector_byte_perm_mask&quot;);
</pre>
<hr />
<pre>
3916     if (UseSHA1Intrinsics) {
3917       StubRoutines::x86::_upper_word_mask_addr = generate_upper_word_mask();
3918       StubRoutines::x86::_shuffle_byte_flip_mask_addr = generate_shuffle_byte_flip_mask();
3919       StubRoutines::_sha1_implCompress = generate_sha1_implCompress(false, &quot;sha1_implCompress&quot;);
3920       StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(true, &quot;sha1_implCompressMB&quot;);
3921     }
3922     if (UseSHA256Intrinsics) {
3923       StubRoutines::x86::_k256_adr = (address)StubRoutines::x86::_k256;
3924       StubRoutines::x86::_pshuffle_byte_flip_mask_addr = generate_pshuffle_byte_flip_mask();
3925       StubRoutines::_sha256_implCompress = generate_sha256_implCompress(false, &quot;sha256_implCompress&quot;);
3926       StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true, &quot;sha256_implCompressMB&quot;);
3927     }
3928 
3929     // Generate GHASH intrinsics code
3930     if (UseGHASHIntrinsics) {
3931       StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();
3932       StubRoutines::x86::_ghash_byte_swap_mask_addr = generate_ghash_byte_swap_mask();
3933       StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();
3934     }
3935 
<span class="line-removed">3936     // Safefetch stubs.</span>
<span class="line-removed">3937     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int), &amp;StubRoutines::_safefetch32_entry,</span>
<span class="line-removed">3938                                                    &amp;StubRoutines::_safefetch32_fault_pc,</span>
<span class="line-removed">3939                                                    &amp;StubRoutines::_safefetch32_continuation_pc);</span>
<span class="line-removed">3940     StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;</span>
<span class="line-removed">3941     StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;</span>
<span class="line-removed">3942     StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;</span>
<span class="line-removed">3943 </span>
3944     BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();
3945     if (bs_nm != NULL) {
3946       StubRoutines::x86::_method_entry_barrier = generate_method_entry_barrier();
3947     }
3948   }
3949 
3950 
3951  public:
3952   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3953     if (all) {
3954       generate_all();
3955     } else {
3956       generate_initial();
3957     }
3958   }
3959 }; // end class declaration
3960 
3961 #define UCM_TABLE_MAX_ENTRIES 8
3962 void StubGenerator_generate(CodeBuffer* code, bool all) {
3963   if (UnsafeCopyMemory::_table == NULL) {
</pre>
</td>
<td>
<hr />
<pre>
3853       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin) ||
3854         vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos) ||
3855         vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {
3856         StubRoutines::_dlibm_reduce_pi04l = generate_libm_reduce_pi04l();
3857       }
3858       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin) ||
3859         vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos)) {
3860         StubRoutines::_dlibm_sin_cos_huge = generate_libm_sin_cos_huge();
3861       }
3862       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin)) {
3863         StubRoutines::_dsin = generate_libmSin();
3864       }
3865       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos)) {
3866         StubRoutines::_dcos = generate_libmCos();
3867       }
3868       if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {
3869         StubRoutines::_dlibm_tan_cot_huge = generate_libm_tan_cot_huge();
3870         StubRoutines::_dtan = generate_libmTan();
3871       }
3872     }
<span class="line-added">3873 </span>
<span class="line-added">3874     // Safefetch stubs.</span>
<span class="line-added">3875     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int), &amp;StubRoutines::_safefetch32_entry,</span>
<span class="line-added">3876                                                    &amp;StubRoutines::_safefetch32_fault_pc,</span>
<span class="line-added">3877                                                    &amp;StubRoutines::_safefetch32_continuation_pc);</span>
<span class="line-added">3878     StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;</span>
<span class="line-added">3879     StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;</span>
<span class="line-added">3880     StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;</span>
3881   }
3882 
3883   void generate_all() {
3884     // Generates all stubs and initializes the entry points
3885 
3886     // These entry points require SharedInfo::stack0 to be set up in non-core builds
3887     // and need to be relocatable, so they each fabricate a RuntimeStub internally.
3888     StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(&quot;AbstractMethodError throw_exception&quot;,          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));
3889     StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(&quot;IncompatibleClassChangeError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));
3890     StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));
3891 
3892     //------------------------------------------------------------------------------------------------------------------------
3893     // entry points that are platform specific
3894 
3895     StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(&quot;vector_float_sign_mask&quot;, 0x7FFFFFFF);
3896     StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(&quot;vector_float_sign_flip&quot;, 0x80000000);
3897     StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask_long_double(&quot;vector_double_sign_mask&quot;, 0x7FFFFFFF, 0xFFFFFFFF);
3898     StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask_long_double(&quot;vector_double_sign_flip&quot;, 0x80000000, 0x00000000);
3899     StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(&quot;vector_short_to_byte_mask&quot;, 0x00ff00ff);
3900     StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask(&quot;vector_byte_perm_mask&quot;);
</pre>
<hr />
<pre>
3924     if (UseSHA1Intrinsics) {
3925       StubRoutines::x86::_upper_word_mask_addr = generate_upper_word_mask();
3926       StubRoutines::x86::_shuffle_byte_flip_mask_addr = generate_shuffle_byte_flip_mask();
3927       StubRoutines::_sha1_implCompress = generate_sha1_implCompress(false, &quot;sha1_implCompress&quot;);
3928       StubRoutines::_sha1_implCompressMB = generate_sha1_implCompress(true, &quot;sha1_implCompressMB&quot;);
3929     }
3930     if (UseSHA256Intrinsics) {
3931       StubRoutines::x86::_k256_adr = (address)StubRoutines::x86::_k256;
3932       StubRoutines::x86::_pshuffle_byte_flip_mask_addr = generate_pshuffle_byte_flip_mask();
3933       StubRoutines::_sha256_implCompress = generate_sha256_implCompress(false, &quot;sha256_implCompress&quot;);
3934       StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true, &quot;sha256_implCompressMB&quot;);
3935     }
3936 
3937     // Generate GHASH intrinsics code
3938     if (UseGHASHIntrinsics) {
3939       StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();
3940       StubRoutines::x86::_ghash_byte_swap_mask_addr = generate_ghash_byte_swap_mask();
3941       StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();
3942     }
3943 








3944     BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();
3945     if (bs_nm != NULL) {
3946       StubRoutines::x86::_method_entry_barrier = generate_method_entry_barrier();
3947     }
3948   }
3949 
3950 
3951  public:
3952   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3953     if (all) {
3954       generate_all();
3955     } else {
3956       generate_initial();
3957     }
3958   }
3959 }; // end class declaration
3960 
3961 #define UCM_TABLE_MAX_ENTRIES 8
3962 void StubGenerator_generate(CodeBuffer* code, bool all) {
3963   if (UnsafeCopyMemory::_table == NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
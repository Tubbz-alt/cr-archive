diff a/src/java.base/share/classes/java/net/DatagramSocket.java b/src/java.base/share/classes/java/net/DatagramSocket.java
--- a/src/java.base/share/classes/java/net/DatagramSocket.java
+++ b/src/java.base/share/classes/java/net/DatagramSocket.java
@@ -27,14 +27,14 @@
 
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.nio.channels.DatagramChannel;
 import java.security.AccessController;
-import java.security.PrivilegedExceptionAction;
-import java.util.Objects;
+import java.security.PrivilegedAction;
 import java.util.Set;
-import java.util.Collections;
+import sun.net.NetProperties;
+import sun.nio.ch.DefaultSelectorProvider;
 
 /**
  * This class represents a socket for sending and receiving datagram packets.
  *
  * <p>A datagram socket is the sending or receiving point for a packet
@@ -111,122 +111,32 @@
  * @see     java.net.DatagramPacket
  * @see     java.nio.channels.DatagramChannel
  * @since 1.0
  */
 public class DatagramSocket implements java.io.Closeable {
-    /**
-     * Various states of this socket.
-     */
-    private boolean bound = false;
-    private boolean closed = false;
-    private volatile boolean created;
-    private final Object closeLock = new Object();
 
-    /*
-     * The implementation of this DatagramSocket.
-     */
-    private final DatagramSocketImpl impl;
+    // An instance of DatagramSocketAdaptor, NetMulticastSocket, or null
+    private final DatagramSocket delegate;
 
-    /**
-     * Are we using an older DatagramSocketImpl?
-     */
-    final boolean oldImpl;
-
-    /**
-     * Set when a socket is ST_CONNECTED until we are certain
-     * that any packets which might have been received prior
-     * to calling connect() but not read by the application
-     * have been read. During this time we check the source
-     * address of all packets received to be sure they are from
-     * the connected destination. Other packets are read but
-     * silently dropped.
-     */
-    private boolean explicitFilter = false;
-    private int bytesLeftToFilter;
-    /*
-     * Connection state:
-     * ST_NOT_CONNECTED = socket not connected
-     * ST_CONNECTED = socket connected
-     * ST_CONNECTED_NO_IMPL = socket connected but not at impl level
-     */
-    static final int ST_NOT_CONNECTED = 0;
-    static final int ST_CONNECTED = 1;
-    static final int ST_CONNECTED_NO_IMPL = 2;
-
-    int connectState = ST_NOT_CONNECTED;
-
-    /*
-     * Connected address & port
-     */
-    InetAddress connectedAddress = null;
-    int connectedPort = -1;
+    DatagramSocket delegate() {
+        if (delegate == null) {
+            throw new InternalError("Should not get here");
+        }
+        return delegate;
+    }
 
     /**
-     * Connects this socket to a remote socket address (IP address + port number).
-     * Binds socket if not already bound.
-     *
-     * @param   address The remote address.
-     * @param   port    The remote port
-     * @throws  SocketException if binding the socket fails.
+     * All constructors eventually call this one.
+     * @param delegate The wrapped DatagramSocket implementation, or null.
      */
-    private synchronized void connectInternal(InetAddress address, int port) throws SocketException {
-        if (port < 0 || port > 0xFFFF) {
-            throw new IllegalArgumentException("connect: " + port);
-        }
-        if (address == null) {
-            throw new IllegalArgumentException("connect: null address");
-        }
-        checkAddress (address, "connect");
-        if (isClosed())
-            return;
-        SecurityManager security = System.getSecurityManager();
-        if (security != null) {
-            if (address.isMulticastAddress()) {
-                security.checkMulticast(address);
-            } else {
-                security.checkConnect(address.getHostAddress(), port);
-                security.checkAccept(address.getHostAddress(), port);
-            }
-        }
-
-        if (port == 0) {
-            throw new SocketException("Can't connect to port 0");
-        }
-        if (!isBound())
-          bind(new InetSocketAddress(0));
-
-        // old impls do not support connect/disconnect
-        if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &&
-             ((AbstractPlainDatagramSocketImpl)impl).nativeConnectDisabled())) {
-            connectState = ST_CONNECTED_NO_IMPL;
-        } else {
-            try {
-                getImpl().connect(address, port);
-
-                // socket is now connected by the impl
-                connectState = ST_CONNECTED;
-                // Do we need to filter some packets?
-                int avail = getImpl().dataAvailable();
-                if (avail == -1) {
-                    throw new SocketException();
-                }
-                explicitFilter = avail > 0;
-                if (explicitFilter) {
-                    bytesLeftToFilter = getReceiveBufferSize();
-                }
-            } catch (SocketException se) {
-
-                // connection will be emulated by DatagramSocket
-                connectState = ST_CONNECTED_NO_IMPL;
-            }
-        }
-
-        connectedAddress = address;
-        connectedPort = port;
+    DatagramSocket(DatagramSocket delegate) {
+        assert delegate == null
+                || delegate instanceof NetMulticastSocket
+                || delegate instanceof sun.nio.ch.DatagramSocketAdaptor;
+        this.delegate = delegate;
     }
 
-
     /**
      * Constructs a datagram socket and binds it to any available port
      * on the local host machine.  The socket will be bound to the
      * {@link InetAddress#isAnyLocalAddress wildcard} address,
      * an IP address chosen by the kernel.
@@ -254,14 +164,11 @@
      * @param impl an instance of a <B>DatagramSocketImpl</B>
      *        the subclass wishes to use on the DatagramSocket.
      * @since   1.4
      */
     protected DatagramSocket(DatagramSocketImpl impl) {
-        if (impl == null)
-            throw new NullPointerException();
-        this.impl = impl;
-        this.oldImpl = checkOldImpl(impl);
+        this(new NetMulticastSocket(impl));
     }
 
     /**
      * Creates a datagram socket, bound to the specified local
      * socket address.
@@ -284,32 +191,11 @@
      *
      * @see SecurityManager#checkListen
      * @since   1.4
      */
     public DatagramSocket(SocketAddress bindaddr) throws SocketException {
-        // Special case initialization for the DatagramChannel socket adaptor.
-        if (this instanceof sun.nio.ch.DatagramSocketAdaptor) {
-            this.impl = null;  // no DatagramSocketImpl
-            this.oldImpl = false;
-            return;
-        }
-
-        // create a datagram socket.
-        boolean multicast = (this instanceof MulticastSocket);
-        this.impl = createImpl(multicast);
-        // creates the udp socket
-        impl.create();
-        created = true;
-        this.oldImpl = checkOldImpl(impl);
-        if (bindaddr != null) {
-            try {
-                bind(bindaddr);
-            } finally {
-                if (!isBound())
-                    close();
-            }
-        }
+        this(createDelegate(bindaddr, DatagramSocket.class));
     }
 
     /**
      * Constructs a datagram socket and binds it to the specified port
      * on the local host machine.  The socket will be bound to the
@@ -360,71 +246,10 @@
      */
     public DatagramSocket(int port, InetAddress laddr) throws SocketException {
         this(new InetSocketAddress(laddr, port));
     }
 
-    /**
-     * Return true if the given DatagramSocketImpl is an "old" impl. An old impl
-     * is one that doesn't implement the abstract methods added in Java SE 1.4.
-     */
-    private static boolean checkOldImpl(DatagramSocketImpl impl) {
-        // DatagramSocketImpl.peekData() is a protected method, therefore we need to use
-        // getDeclaredMethod, therefore we need permission to access the member
-        try {
-            AccessController.doPrivileged(
-                new PrivilegedExceptionAction<>() {
-                    public Void run() throws NoSuchMethodException {
-                        Class<?>[] cl = new Class<?>[1];
-                        cl[0] = DatagramPacket.class;
-                        impl.getClass().getDeclaredMethod("peekData", cl);
-                        return null;
-                    }
-                });
-            return false;
-        } catch (java.security.PrivilegedActionException e) {
-            return true;
-        }
-    }
-
-    static Class<?> implClass = null;
-
-    /**
-     * Creates a DatagramSocketImpl.
-     * @param multicast true if the DatagramSocketImpl is for a MulticastSocket
-     */
-    private static DatagramSocketImpl createImpl(boolean multicast) throws SocketException {
-        DatagramSocketImpl impl;
-        DatagramSocketImplFactory factory = DatagramSocket.factory;
-        if (factory != null) {
-            impl = factory.createDatagramSocketImpl();
-        } else {
-            impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);
-        }
-        return impl;
-    }
-
-    /**
-     * Return the {@code DatagramSocketImpl} attached to this socket,
-     * creating the socket if not already created.
-     *
-     * @return  the {@code DatagramSocketImpl} attached to that
-     *          DatagramSocket
-     * @throws SocketException if creating the socket fails
-     * @since 1.4
-     */
-    final DatagramSocketImpl getImpl() throws SocketException {
-        if (!created) {
-            synchronized (this) {
-                if (!created)  {
-                    impl.create();
-                    created = true;
-                }
-            }
-        }
-        return impl;
-    }
-
     /**
      * Binds this DatagramSocket to a specific address and port.
      * <p>
      * If the address is {@code null}, then the system will pick up
      * an ephemeral port and a valid local address to bind the socket.
@@ -436,45 +261,12 @@
      *             {@code checkListen} method doesn't allow the operation.
      * @throws IllegalArgumentException if addr is a SocketAddress subclass
      *         not supported by this socket.
      * @since 1.4
      */
-    public synchronized void bind(SocketAddress addr) throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        if (isBound())
-            throw new SocketException("already bound");
-        if (addr == null)
-            addr = new InetSocketAddress(0);
-        if (!(addr instanceof InetSocketAddress))
-            throw new IllegalArgumentException("Unsupported address type!");
-        InetSocketAddress epoint = (InetSocketAddress) addr;
-        if (epoint.isUnresolved())
-            throw new SocketException("Unresolved address");
-        InetAddress iaddr = epoint.getAddress();
-        int port = epoint.getPort();
-        checkAddress(iaddr, "bind");
-        SecurityManager sec = System.getSecurityManager();
-        if (sec != null) {
-            sec.checkListen(port);
-        }
-        try {
-            getImpl().bind(port, iaddr);
-        } catch (SocketException e) {
-            getImpl().close();
-            throw e;
-        }
-        bound = true;
-    }
-
-    void checkAddress (InetAddress addr, String op) {
-        if (addr == null) {
-            return;
-        }
-        if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {
-            throw new IllegalArgumentException(op + ": invalid address type");
-        }
+    public void bind(SocketAddress addr) throws SocketException {
+        delegate().bind(addr);
     }
 
     /**
      * Connects the socket to a remote address for this socket. When a
      * socket is connected to a remote address, packets may only be
@@ -532,15 +324,11 @@
      * @see #disconnect
      *
      * @since 1.2
      */
     public void connect(InetAddress address, int port) {
-        try {
-            connectInternal(address, port);
-        } catch (SocketException se) {
-            throw new UncheckedIOException("connect failed", se);
-        }
+        delegate().connect(address, port);
     }
 
     /**
      * Connects this socket to a remote socket address (IP address + port number).
      *
@@ -564,18 +352,11 @@
      *         not permit access to the given remote address
      *
      * @since 1.4
      */
     public void connect(SocketAddress addr) throws SocketException {
-        if (addr == null)
-            throw new IllegalArgumentException("Address can't be null");
-        if (!(addr instanceof InetSocketAddress))
-            throw new IllegalArgumentException("Unsupported address type");
-        InetSocketAddress epoint = (InetSocketAddress) addr;
-        if (epoint.isUnresolved())
-            throw new SocketException("Unresolved address");
-        connectInternal(epoint.getAddress(), epoint.getPort());
+        delegate().connect(addr);
     }
 
     /**
      * Disconnects the socket. If the socket is closed or not connected,
      * then this method has no effect.
@@ -592,21 +373,11 @@
      * @see #connect
      *
      * @since 1.2
      */
     public void disconnect() {
-        synchronized (this) {
-            if (isClosed())
-                return;
-            if (connectState == ST_CONNECTED) {
-                impl.disconnect ();
-            }
-            connectedAddress = null;
-            connectedPort = -1;
-            connectState = ST_NOT_CONNECTED;
-            explicitFilter = false;
-        }
+        delegate().disconnect();
     }
 
     /**
      * Returns the binding state of the socket.
      * <p>
@@ -616,11 +387,11 @@
      *
      * @return true if the socket successfully bound to an address
      * @since 1.4
      */
     public boolean isBound() {
-        return bound;
+        return delegate().isBound();
     }
 
     /**
      * Returns the connection state of the socket.
      * <p>
@@ -630,11 +401,11 @@
      *
      * @return true if the socket successfully connected to a server
      * @since 1.4
      */
     public boolean isConnected() {
-        return connectState != ST_NOT_CONNECTED;
+        return delegate().isConnected();
     }
 
     /**
      * Returns the address to which this socket is connected. Returns
      * {@code null} if the socket is not connected.
@@ -645,11 +416,11 @@
      *
      * @return the address to which this socket is connected.
      * @since 1.2
      */
     public InetAddress getInetAddress() {
-        return connectedAddress;
+        return delegate().getInetAddress();
     }
 
     /**
      * Returns the port number to which this socket is connected.
      * Returns {@code -1} if the socket is not connected.
@@ -660,11 +431,11 @@
      *
      * @return the port number to which this socket is connected.
      * @since 1.2
      */
     public int getPort() {
-        return connectedPort;
+        return delegate().getPort();
     }
 
     /**
      * Returns the address of the endpoint this socket is connected to, or
      * {@code null} if it is unconnected.
@@ -680,13 +451,11 @@
      * @see #getPort()
      * @see #connect(SocketAddress)
      * @since 1.4
      */
     public SocketAddress getRemoteSocketAddress() {
-        if (!isConnected())
-            return null;
-        return new InetSocketAddress(getInetAddress(), getPort());
+        return delegate().getRemoteSocketAddress();
     }
 
     /**
      * Returns the address of the endpoint this socket is bound to.
      *
@@ -696,15 +465,11 @@
      * @see #getLocalPort()
      * @see #bind(SocketAddress)
      * @since 1.4
      */
     public SocketAddress getLocalSocketAddress() {
-        if (isClosed())
-            return null;
-        if (!isBound())
-            return null;
-        return new InetSocketAddress(getLocalAddress(), getLocalPort());
+        return delegate().getLocalSocketAddress();
     }
 
     /**
      * Sends a datagram packet from this socket. The
      * {@code DatagramPacket} includes information indicating the
@@ -746,58 +511,11 @@
      * @see        SecurityManager#checkConnect
      * @revised 1.4
      * @spec JSR-51
      */
     public void send(DatagramPacket p) throws IOException  {
-        synchronized (p) {
-            if (isClosed())
-                throw new SocketException("Socket is closed");
-            InetAddress packetAddress = p.getAddress();
-            int packetPort = p.getPort();
-            checkAddress (packetAddress, "send");
-            if (connectState == ST_NOT_CONNECTED) {
-                if (packetAddress == null) {
-                    throw new IllegalArgumentException("Address not set");
-                }
-                if (packetPort < 0 || packetPort > 0xFFFF)
-                    throw new IllegalArgumentException("port out of range:" + packetPort);
-                // check the address is ok with the security manager on every send.
-                SecurityManager security = System.getSecurityManager();
-
-                // The reason you want to synchronize on datagram packet
-                // is because you don't want an applet to change the address
-                // while you are trying to send the packet for example
-                // after the security check but before the send.
-                if (security != null) {
-                    if (packetAddress.isMulticastAddress()) {
-                        security.checkMulticast(packetAddress);
-                    } else {
-                        security.checkConnect(packetAddress.getHostAddress(),
-                                packetPort);
-                    }
-                }
-                if (packetPort == 0) {
-                    throw new SocketException("Can't send to port 0");
-                }
-            } else {
-                // we're connected
-                if (packetAddress == null) {
-                    p.setAddress(connectedAddress);
-                    p.setPort(connectedPort);
-                } else if ((!packetAddress.equals(connectedAddress)) ||
-                        packetPort != connectedPort) {
-                    throw new IllegalArgumentException("connected address " +
-                                                       "and packet address" +
-                                                       " differ");
-                }
-            }
-            // Check whether the socket is bound
-            if (!isBound())
-                bind(new InetSocketAddress(0));
-            // call the  method to send
-            getImpl().send(p);
-        }
+        delegate().send(p);
     }
 
     /**
      * Receives a datagram packet from this socket. When this method
      * returns, the {@code DatagramPacket}'s buffer is filled with
@@ -829,109 +547,12 @@
      * @see        java.net.DatagramPacket
      * @see        java.net.DatagramSocket
      * @revised 1.4
      * @spec JSR-51
      */
-    public synchronized void receive(DatagramPacket p) throws IOException {
-        synchronized (p) {
-            if (!isBound())
-                bind(new InetSocketAddress(0));
-            if (connectState == ST_NOT_CONNECTED) {
-                // check the address is ok with the security manager before every recv.
-                SecurityManager security = System.getSecurityManager();
-                if (security != null) {
-                    while(true) {
-                        String peekAd = null;
-                        int peekPort = 0;
-                        // peek at the packet to see who it is from.
-                        if (!oldImpl) {
-                            // We can use the new peekData() API
-                            DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
-                            peekPort = getImpl().peekData(peekPacket);
-                            peekAd = peekPacket.getAddress().getHostAddress();
-                        } else {
-                            InetAddress adr = new InetAddress();
-                            peekPort = getImpl().peek(adr);
-                            peekAd = adr.getHostAddress();
-                        }
-                        try {
-                            security.checkAccept(peekAd, peekPort);
-                            // security check succeeded - so now break
-                            // and recv the packet.
-                            break;
-                        } catch (SecurityException se) {
-                            // Throw away the offending packet by consuming
-                            // it in a tmp buffer.
-                            DatagramPacket tmp = new DatagramPacket(new byte[1], 1);
-                            getImpl().receive(tmp);
-
-                            // silently discard the offending packet
-                            // and continue: unknown/malicious
-                            // entities on nets should not make
-                            // runtime throw security exception and
-                            // disrupt the applet by sending random
-                            // datagram packets.
-                            continue;
-                        }
-                    } // end of while
-                }
-            }
-            DatagramPacket tmp = null;
-            if ((connectState == ST_CONNECTED_NO_IMPL) || explicitFilter) {
-                // We have to do the filtering the old fashioned way since
-                // the native impl doesn't support connect or the connect
-                // via the impl failed, or .. "explicitFilter" may be set when
-                // a socket is connected via the impl, for a period of time
-                // when packets from other sources might be queued on socket.
-                boolean stop = false;
-                while (!stop) {
-                    InetAddress peekAddress = null;
-                    int peekPort = -1;
-                    // peek at the packet to see who it is from.
-                    if (!oldImpl) {
-                        // We can use the new peekData() API
-                        DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
-                        peekPort = getImpl().peekData(peekPacket);
-                        peekAddress = peekPacket.getAddress();
-                    } else {
-                        // this api only works for IPv4
-                        peekAddress = new InetAddress();
-                        peekPort = getImpl().peek(peekAddress);
-                    }
-                    if ((!connectedAddress.equals(peekAddress)) ||
-                        (connectedPort != peekPort)) {
-                        // throw the packet away and silently continue
-                        tmp = new DatagramPacket(
-                                                new byte[1024], 1024);
-                        getImpl().receive(tmp);
-                        if (explicitFilter) {
-                            if (checkFiltering(tmp)) {
-                                stop = true;
-                            }
-                        }
-                    } else {
-                        stop = true;
-                    }
-                }
-            }
-            // If the security check succeeds, or the datagram is
-            // connected then receive the packet
-            getImpl().receive(p);
-            if (explicitFilter && tmp == null) {
-                // packet was not filtered, account for it here
-                checkFiltering(p);
-            }
-        }
-    }
-
-    private boolean checkFiltering(DatagramPacket p) throws SocketException {
-        bytesLeftToFilter -= p.getLength();
-        if (bytesLeftToFilter <= 0 || getImpl().dataAvailable() <= 0) {
-            explicitFilter = false;
-            return true;
-        }
-        return false;
+    public void receive(DatagramPacket p) throws IOException {
+        delegate().receive(p);
     }
 
     /**
      * Gets the local address to which the socket is bound.
      *
@@ -949,26 +570,11 @@
      *          the security manager {@code checkConnect}
      *          method does not allow the operation
      * @since   1.1
      */
     public InetAddress getLocalAddress() {
-        if (isClosed())
-            return null;
-        InetAddress in;
-        try {
-            in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);
-            if (in.isAnyLocalAddress()) {
-                in = InetAddress.anyLocalAddress();
-            }
-            SecurityManager s = System.getSecurityManager();
-            if (s != null) {
-                s.checkConnect(in.getHostAddress(), -1);
-            }
-        } catch (Exception e) {
-            in = InetAddress.anyLocalAddress(); // "0.0.0.0"
-        }
-        return in;
+        return delegate().getLocalAddress();
     }
 
     /**
      * Returns the port number on the local host to which this socket
      * is bound.
@@ -976,17 +582,11 @@
      * @return  the port number on the local host to which this socket is bound,
      *          {@code -1} if the socket is closed, or
      *          {@code 0} if it is not bound yet.
      */
     public int getLocalPort() {
-        if (isClosed())
-            return -1;
-        try {
-            return getImpl().getLocalPort();
-        } catch (Exception e) {
-            return 0;
-        }
+        return delegate().getLocalPort();
     }
 
     /**
      * Enable/disable SO_TIMEOUT with the specified timeout, in
      * milliseconds. With this option set to a positive timeout value,
@@ -1002,16 +602,12 @@
      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
      * @throws IllegalArgumentException if {@code timeout} is negative
      * @since   1.1
      * @see #getSoTimeout()
      */
-    public synchronized void setSoTimeout(int timeout) throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        if (timeout < 0)
-            throw new IllegalArgumentException("timeout < 0");
-        getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
+    public void setSoTimeout(int timeout) throws SocketException {
+        delegate().setSoTimeout(timeout);
     }
 
     /**
      * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
      * option is disabled (i.e., timeout of infinity).
@@ -1019,22 +615,12 @@
      * @return the setting for SO_TIMEOUT
      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
      * @since   1.1
      * @see #setSoTimeout(int)
      */
-    public synchronized int getSoTimeout() throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        if (getImpl() == null)
-            return 0;
-        Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
-        /* extra type safety */
-        if (o instanceof Integer) {
-            return ((Integer) o).intValue();
-        } else {
-            return 0;
-        }
+    public int getSoTimeout() throws SocketException {
+        return delegate().getSoTimeout();
     }
 
     /**
      * Sets the SO_SNDBUF option to the specified value for this
      * {@code DatagramSocket}. The SO_SNDBUF option is used by the
@@ -1063,17 +649,12 @@
      * @throws    IllegalArgumentException if the value is 0 or is
      * negative.
      * @see #getSendBufferSize()
      * @since 1.2
      */
-    public synchronized void setSendBufferSize(int size) throws SocketException {
-        if (!(size > 0)) {
-            throw new IllegalArgumentException("negative send size");
-        }
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        getImpl().setOption(SocketOptions.SO_SNDBUF, size);
+    public void setSendBufferSize(int size) throws SocketException {
+        delegate().setSendBufferSize(size);
     }
 
     /**
      * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
      * buffer size used by the platform for output on this {@code DatagramSocket}.
@@ -1082,19 +663,12 @@
      * @throws    SocketException if there is an error in
      * the underlying protocol, such as an UDP error.
      * @see #setSendBufferSize
      * @since 1.2
      */
-    public synchronized int getSendBufferSize() throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        int result = 0;
-        Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);
-        if (o instanceof Integer) {
-            result = ((Integer)o).intValue();
-        }
-        return result;
+    public int getSendBufferSize() throws SocketException {
+        return delegate().getSendBufferSize();
     }
 
     /**
      * Sets the SO_RCVBUF option to the specified value for this
      * {@code DatagramSocket}. The SO_RCVBUF option is used by
@@ -1122,17 +696,12 @@
      * @throws    IllegalArgumentException if the value is 0 or is
      * negative.
      * @see #getReceiveBufferSize()
      * @since 1.2
      */
-    public synchronized void setReceiveBufferSize(int size) throws SocketException {
-        if (size <= 0) {
-            throw new IllegalArgumentException("invalid receive size");
-        }
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        getImpl().setOption(SocketOptions.SO_RCVBUF, size);
+    public void setReceiveBufferSize(int size) throws SocketException {
+        delegate().setReceiveBufferSize(size);
     }
 
     /**
      * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
      * buffer size used by the platform for input on this {@code DatagramSocket}.
@@ -1140,19 +709,12 @@
      * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
      * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.
      * @see #setReceiveBufferSize(int)
      * @since 1.2
      */
-    public synchronized int getReceiveBufferSize() throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        int result = 0;
-        Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
-        if (o instanceof Integer) {
-            result = ((Integer)o).intValue();
-        }
-        return result;
+    public int getReceiveBufferSize() throws SocketException {
+        return delegate().getReceiveBufferSize();
     }
 
     /**
      * Enable/disable the SO_REUSEADDR socket option.
      * <p>
@@ -1185,18 +747,12 @@
      * @see #getReuseAddress()
      * @see #bind(SocketAddress)
      * @see #isBound()
      * @see #isClosed()
      */
-    public synchronized void setReuseAddress(boolean on) throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        // Integer instead of Boolean for compatibility with older DatagramSocketImpl
-        if (oldImpl)
-            getImpl().setOption(SocketOptions.SO_REUSEADDR, on?-1:0);
-        else
-            getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
+    public void setReuseAddress(boolean on) throws SocketException {
+        delegate().setReuseAddress(on);
     }
 
     /**
      * Tests if SO_REUSEADDR is enabled.
      *
@@ -1204,15 +760,12 @@
      * @throws    SocketException if there is an error
      * in the underlying protocol, such as an UDP error.
      * @since   1.4
      * @see #setReuseAddress(boolean)
      */
-    public synchronized boolean getReuseAddress() throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        Object o = getImpl().getOption(SocketOptions.SO_REUSEADDR);
-        return ((Boolean)o).booleanValue();
+    public boolean getReuseAddress() throws SocketException {
+        return delegate().getReuseAddress();
     }
 
     /**
      * Enable/disable SO_BROADCAST.
      *
@@ -1228,28 +781,24 @@
      *          error.
      *
      * @since 1.4
      * @see #getBroadcast()
      */
-    public synchronized void setBroadcast(boolean on) throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        getImpl().setOption(SocketOptions.SO_BROADCAST, Boolean.valueOf(on));
+    public void setBroadcast(boolean on) throws SocketException {
+        delegate().setBroadcast(on);
     }
 
     /**
      * Tests if SO_BROADCAST is enabled.
      * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
      * @throws    SocketException if there is an error
      * in the underlying protocol, such as an UDP error.
      * @since 1.4
      * @see #setBroadcast(boolean)
      */
-    public synchronized boolean getBroadcast() throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        return ((Boolean)(getImpl().getOption(SocketOptions.SO_BROADCAST))).booleanValue();
+    public boolean getBroadcast() throws SocketException {
+        return delegate().getBroadcast();
     }
 
     /**
      * Sets traffic class or type-of-service octet in the IP
      * datagram header for datagrams sent from this DatagramSocket.
@@ -1285,24 +834,12 @@
      * @throws SocketException if there is an error setting the
      * traffic class or type-of-service
      * @since 1.4
      * @see #getTrafficClass
      */
-    public synchronized void setTrafficClass(int tc) throws SocketException {
-        if (tc < 0 || tc > 255)
-            throw new IllegalArgumentException("tc is not in range 0 -- 255");
-
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        try {
-            getImpl().setOption(SocketOptions.IP_TOS, tc);
-        } catch (SocketException se) {
-            // not supported if socket already connected
-            // Solaris returns error in such cases
-            if(!isConnected())
-                throw se;
-        }
+    public void setTrafficClass(int tc) throws SocketException {
+        delegate().setTrafficClass(tc);
     }
 
     /**
      * Gets traffic class or type-of-service in the IP datagram
      * header for packets sent from this DatagramSocket.
@@ -1317,14 +854,12 @@
      * @throws SocketException if there is an error obtaining the
      * traffic class or type-of-service value.
      * @since 1.4
      * @see #setTrafficClass(int)
      */
-    public synchronized int getTrafficClass() throws SocketException {
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        return ((Integer)(getImpl().getOption(SocketOptions.IP_TOS))).intValue();
+    public int getTrafficClass() throws SocketException {
+        return delegate().getTrafficClass();
     }
 
     /**
      * Closes this datagram socket.
      * <p>
@@ -1336,28 +871,21 @@
      *
      * @revised 1.4
      * @spec JSR-51
      */
     public void close() {
-        synchronized(closeLock) {
-            if (isClosed())
-                return;
-            impl.close();
-            closed = true;
-        }
+        delegate().close();
     }
 
     /**
      * Returns whether the socket is closed or not.
      *
      * @return true if the socket has been closed
      * @since 1.4
      */
     public boolean isClosed() {
-        synchronized(closeLock) {
-            return closed;
-        }
+        return delegate().isClosed();
     }
 
     /**
      * Returns the unique {@link java.nio.channels.DatagramChannel} object
      * associated with this datagram socket, if any.
@@ -1407,11 +935,11 @@
      * @see       SecurityManager#checkSetFactory
      * @since 1.3
      */
     public static synchronized void
     setDatagramSocketImplFactory(DatagramSocketImplFactory fac)
-       throws IOException
+            throws IOException
     {
         if (factory != null) {
             throw new SocketException("factory already defined");
         }
         SecurityManager security = System.getSecurityManager();
@@ -1450,14 +978,11 @@
      * @since 9
      */
     public <T> DatagramSocket setOption(SocketOption<T> name, T value)
         throws IOException
     {
-        Objects.requireNonNull(name);
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        getImpl().setOption(name, value);
+        delegate().setOption(name, value);
         return this;
     }
 
     /**
      * Returns the value of a socket option.
@@ -1481,19 +1006,13 @@
      *         do not require any security permission.
      *
      * @since 9
      */
     public <T> T getOption(SocketOption<T> name) throws IOException {
-        Objects.requireNonNull(name);
-        if (isClosed())
-            throw new SocketException("Socket is closed");
-        return getImpl().getOption(name);
+        return delegate().getOption(name);
     }
 
-    private volatile Set<SocketOption<?>> options;
-    private final Object optionsLock = new Object();
-
     /**
      * Returns a set of the socket options supported by this socket.
      *
      * This method will continue to return the set of options even after
      * the socket has been closed.
@@ -1502,24 +1021,119 @@
      *        may be empty if the socket's DatagramSocketImpl cannot be created.
      *
      * @since 9
      */
     public Set<SocketOption<?>> supportedOptions() {
-        Set<SocketOption<?>> options = this.options;
-        if (options != null)
-            return options;
+        return delegate().supportedOptions();
+    }
 
-        synchronized (optionsLock) {
-            options = this.options;
-            if (options != null)
-                return options;
+    // Temporary solution until JDK-8237352 is addressed
+    private static final SocketAddress NO_DELEGATE = new SocketAddress() {};
+    private static final boolean USE_PLAINDATAGRAMSOCKET = usePlainDatagramSocketImpl();
 
+    private static boolean usePlainDatagramSocketImpl() {
+        PrivilegedAction<String> pa = () -> NetProperties.get("jdk.net.usePlainDatagramSocketImpl");
+        String s = AccessController.doPrivileged(pa);
+        return (s != null) && (s.isEmpty() || s.equalsIgnoreCase("true"));
+    }
+
+    /**
+     * Best effort to convert an {@link IOException}
+     * into a {@link SocketException}.
+     *
+     * @param e an instance of {@link IOException}
+     * @return an instance of {@link SocketException}
+     */
+    private static SocketException toSocketException(IOException e) {
+        if (e instanceof SocketException)
+            return (SocketException) e;
+        Throwable cause = e.getCause();
+        if (cause instanceof SocketException)
+            return (SocketException) cause;
+        SocketException se = new SocketException(e.getMessage());
+        se.initCause(e);
+        return se;
+    }
+
+    /**
+     * Creates a delegate for the specific requested {@code type}. This method should
+     * only be called by {@code DatagramSocket} and {@code MulticastSocket}
+     * public constructors.
+     *
+     * @param bindaddr An address to bind to, or {@code null} if creating an unbound
+     *                 socket.
+     * @param type     This is either {@code MulticastSocket.class}, if the delegate needs
+     *                 to support joining multicast groups, or {@code DatagramSocket.class},
+     *                 if it doesn't. Typically, this will be {@code DatagramSocket.class}
+     *                 when creating a delegate for {@code DatagramSocket}, and
+     *                 {@code MulticastSocket.class} when creating a delegate for
+     *                 {@code MulticastSocket}.
+     * @param <T>      The target type for which the delegate is created.
+     *                 This is either {@code java.net.DatagramSocket} or
+     *                 {@code java.net.MulticastSocket}.
+     * @return {@code null} if {@code bindaddr == NO_DELEGATE}, otherwise returns a
+     * delegate for the requested {@code type}.
+     * @throws SocketException if an exception occurs while creating or binding the
+     *                         the delegate.
+     */
+    static <T extends DatagramSocket> T createDelegate(SocketAddress bindaddr, Class<T> type)
+            throws SocketException {
+
+        // Temporary solution until JDK-8237352 is addressed
+        if (bindaddr == NO_DELEGATE) return null;
+
+        assert type == DatagramSocket.class || type == MulticastSocket.class;
+        boolean multicast = (type == MulticastSocket.class);
+        DatagramSocket delegate = null;
+        boolean initialized = false;
+        try {
+            DatagramSocketImplFactory factory = DatagramSocket.factory;
+            if (USE_PLAINDATAGRAMSOCKET || factory != null) {
+                // create legacy DatagramSocket delegate
+                DatagramSocketImpl impl;
+                if (factory != null) {
+                    impl = factory.createDatagramSocketImpl();
+                } else {
+                    impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);
+                }
+                delegate = new NetMulticastSocket(impl);
+                ((NetMulticastSocket) delegate).getImpl(); // ensure impl.create() is called.
+            } else {
+                // create NIO adaptor
+                delegate = DefaultSelectorProvider.get()
+                        .openUninterruptibleDatagramChannel()
+                        .socket();
+            }
+
+            if (multicast) {
+                // set reuseaddress if multicasting
+                // (must be set before binding)
+                delegate.setReuseAddress(true);
+            }
+
+            if (bindaddr != null) {
+                // bind if needed
+                delegate.bind(bindaddr);
+            }
+
+            // enable broadcast if possible
             try {
-                DatagramSocketImpl impl = getImpl();
-                options = Collections.unmodifiableSet(impl.supportedOptions());
-            } catch (IOException e) {
-                options = Collections.emptySet();
+                delegate.setBroadcast(true);
+            } catch (IOException ioe) {
+            }
+
+            initialized = true;
+        } catch (IOException ioe) {
+            throw toSocketException(ioe);
+        } finally {
+            // make sure the delegate is closed if anything
+            // went wrong
+            if (!initialized && delegate != null) {
+                delegate.close();
             }
-            return this.options = options;
         }
+        @SuppressWarnings("unchecked")
+        T result = (T) delegate;
+        return result;
     }
+
 }

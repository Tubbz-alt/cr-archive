<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/net/MulticastSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
 29 import java.nio.channels.DatagramChannel;
 30 import java.nio.channels.MulticastChannel;
 31 
 32 /**
 33  * The multicast datagram socket class is useful for sending
 34  * and receiving IP multicast packets. A MulticastSocket is
 35  * a (UDP) DatagramSocket, with additional capabilities for
 36  * joining &quot;groups&quot; of other multicast hosts on the internet.
 37  * &lt;P&gt;
 38  * A multicast group is specified by a class D IP address
 39  * and by a standard UDP port number. Class D IP addresses
 40  * are in the range {@code 224.0.0.0} to {@code 239.255.255.255},
 41  * inclusive. The address 224.0.0.0 is reserved and should not be used.
 42  * &lt;P&gt;
 43  * One would join a multicast group by first creating a MulticastSocket
 44  * with the desired port, then invoking the
 45  * &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
 46  * method:
 47  * &lt;PRE&gt;
 48  * // join a Multicast group and send the group salutations
 49  * ...
 50  * String msg = &quot;Hello&quot;;
 51  * InetAddress mcastaddr = InetAddress.getByName(&quot;228.5.6.7&quot;);
 52  * InetSocketAddress group = new InetSocketAddress(mcastaddr, port);
 53  * NetworkInterface netIf = NetworkInterface.getByName(&quot;bge0&quot;);
 54  * MulticastSocket s = new MulticastSocket(6789);
 55  *
 56  * s.joinGroup(group, netIf);
 57  * byte[] msgBytes = msg.getBytes(StandardCharsets.UTF_8);
 58  * DatagramPacket hi = new DatagramPacket(msgBytes, msgBytes.length,
 59  *                                        group, 6789);
 60  * s.send(hi);
 61  * // get their responses!
 62  * byte[] buf = new byte[1000];
 63  * DatagramPacket recv = new DatagramPacket(buf, buf.length);
 64  * s.receive(recv);
 65  * ...
 66  * // OK, I&#39;m done talking - leave the group...
 67  * s.leaveGroup(group, netIf);
 68  * &lt;/PRE&gt;
 69  *
 70  * When one sends a message to a multicast group, &lt;B&gt;all&lt;/B&gt; subscribing
 71  * recipients to that host and port receive the message (within the
 72  * time-to-live range of the packet, see below). The socket needn&#39;t
 73  * be a member of the multicast group to send messages to it.
 74  * &lt;P&gt;
 75  * When a socket subscribes to a multicast group/port, it receives
 76  * datagrams sent by other hosts to the group/port, as do all other
 77  * members of the group and port.  A socket relinquishes membership
 78  * in a group by the leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
 79  * method.
 80  * &lt;B&gt;Multiple MulticastSockets&lt;/B&gt; may subscribe to a multicast group
 81  * and port concurrently, and they will all receive group datagrams.
 82  *
 83  * &lt;p&gt; The {@code DatagramSocket} and {@code MulticastSocket}
 84  * classes define convenience methods to set and get several
 85  * socket options. Like {@code DatagramSocket} this class also
 86  * supports the {@link #setOption(SocketOption, Object) setOption}
 87  * and {@link #getOption(SocketOption) getOption} methods to set
 88  * and query socket options.
 89  * In addition to the socket options supported by
 90  * &lt;a href=&quot;DatagramSocket.html#SocketOptions&quot;&gt;{@code DatagramSocket}&lt;/a&gt;, a
 91  * {@code MulticastSocket} supports the following socket options:
 92  * &lt;blockquote&gt;
 93  * &lt;a id=&quot;MulticastOptions&quot;&gt;&lt;/a&gt;
 94  * &lt;table class=&quot;striped&quot;&gt;
 95  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;
 96  * &lt;thead&gt;
 97  *   &lt;tr&gt;
 98  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;
 99  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
100  *   &lt;/tr&gt;
101  * &lt;/thead&gt;
102  * &lt;tbody&gt;
103  *   &lt;tr&gt;
104  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_IF IP_MULTICAST_IF} &lt;/th&gt;
105  *     &lt;td&gt; The network interface for Internet Protocol (IP) multicast datagrams &lt;/td&gt;
106  *   &lt;/tr&gt;
107  *   &lt;tr&gt;
108  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_TTL
109  *       IP_MULTICAST_TTL} &lt;/th&gt;
110  *     &lt;td&gt; The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast
111  *       datagrams &lt;/td&gt;
112  *   &lt;/tr&gt;
113  *   &lt;tr&gt;
114  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP
115  *       IP_MULTICAST_LOOP} &lt;/th&gt;
116  *     &lt;td&gt; Loopback for Internet Protocol (IP) multicast datagrams &lt;/td&gt;
117  *   &lt;/tr&gt;
118  * &lt;/tbody&gt;
119  * &lt;/table&gt;
120  * &lt;/blockquote&gt;
121  * Additional (implementation specific) options may also be supported.
122  *
123  * @apiNote {@link DatagramChannel} implements the {@link MulticastChannel} interface
124  *          and provides an alternative API for sending and receiving multicast datagrams.
125  *          The {@link MulticastChannel} API supports both {@linkplain
126  *          MulticastChannel#join(InetAddress, NetworkInterface) any-source} and
127  *          {@linkplain MulticastChannel#join(InetAddress, NetworkInterface, InetAddress)
128  *          source-specific} multicast.
129  *
130  * @author Pavani Diwanji
131  * @since 1.1
132  */
133 public class MulticastSocket extends DatagramSocket {
134 
135     @Override
136     final MulticastSocket delegate() {
137         return (MulticastSocket) super.delegate();
138     }
139 
140     /**
141      * Create a MulticastSocket that delegates to the given delegate if not null.
142      * @param delegate the delegate, can be null.
143      */
144     MulticastSocket(MulticastSocket delegate)  {
145         super(delegate);
146     }
147 
148 
149     /**
150      * Create a multicast socket.
151      *
152      * &lt;p&gt;
153      * If there is a security manager, its {@code checkListen} method is first
154      * called with 0 as its argument to ensure the operation is allowed. This
155      * could result in a SecurityException.
156      * &lt;p&gt;
157      * When the socket is created the
158      * {@link DatagramSocket#setReuseAddress(boolean)} method is called to
159      * enable the SO_REUSEADDR socket option.
160      *
161      * @throws    IOException if an I/O exception occurs while creating the
162      * MulticastSocket
163      * @throws    SecurityException if a security manager exists and its
164      * {@code checkListen} method doesn&#39;t allow the operation.
165      * @see SecurityManager#checkListen
166      * @see java.net.DatagramSocket#setReuseAddress(boolean)
167      * @see java.net.DatagramSocketImpl#setOption(SocketOption, Object)
168      */
169     public MulticastSocket() throws IOException {
170         this(new InetSocketAddress(0));
171     }
172 
173     /**
174      * Create a multicast socket and bind it to a specific port.
175      *
176      * &lt;p&gt;If there is a security manager,
177      * its {@code checkListen} method is first called
178      * with the {@code port} argument
179      * as its argument to ensure the operation is allowed.
180      * This could result in a SecurityException.
181      * &lt;p&gt;
182      * When the socket is created the
183      * {@link DatagramSocket#setReuseAddress(boolean)} method is
184      * called to enable the SO_REUSEADDR socket option.
185      *
186      * @param     port port to use
187      * @throws    IOException if an I/O exception occurs
188      *            while creating the MulticastSocket
189      * @throws    SecurityException  if a security manager exists and its
190      *            {@code checkListen} method doesn&#39;t allow the operation.
191      * @see       SecurityManager#checkListen
192      * @see       java.net.DatagramSocket#setReuseAddress(boolean)
193      */
194     public MulticastSocket(int port) throws IOException {
195         this(new InetSocketAddress(port));
196     }
197 
198     /**
199      * Create a MulticastSocket bound to the specified socket address.
200      * &lt;p&gt;
201      * Or, if the address is {@code null}, create an unbound socket.
202      *
203      * &lt;p&gt;If there is a security manager,
204      * its {@code checkListen} method is first called
205      * with the SocketAddress port as its argument to ensure the operation is allowed.
206      * This could result in a SecurityException.
207      * &lt;p&gt;
208      * When the socket is created the
209      * {@link DatagramSocket#setReuseAddress(boolean)} method is
210      * called to enable the SO_REUSEADDR socket option.
211      *
212      * @param    bindaddr Socket address to bind to, or {@code null} for
213      *           an unbound socket.
214      * @throws   IOException if an I/O exception occurs
215      *           while creating the MulticastSocket
216      * @throws   SecurityException  if a security manager exists and its
217      *           {@code checkListen} method doesn&#39;t allow the operation.
218      * @see      SecurityManager#checkListen
219      * @see      java.net.DatagramSocket#setReuseAddress(boolean)
220      *
221      * @since 1.4
222      */
223     public MulticastSocket(SocketAddress bindaddr) throws IOException {
224         this(createDelegate(bindaddr, MulticastSocket.class));
225     }
226 
227     /**
228      * Set the default time-to-live for multicast packets sent out
229      * on this {@code MulticastSocket} in order to control the
230      * scope of the multicasts.
231      *
232      * &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
233      * in the range {@code 0 &lt;= ttl &lt;= 0xFF }.
234      *
235      * @param      ttl the time-to-live
236      * @throws     IOException if an I/O exception occurs
237      *             while setting the default time-to-live value
238      * @deprecated use the setTimeToLive method instead, which uses
239      *             &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.
240      * @see #getTTL()
241      */
242     @Deprecated
243     public void setTTL(byte ttl) throws IOException {
244         delegate().setTTL(ttl);
245     }
246 
247     /**
248      * Set the default time-to-live for multicast packets sent out
249      * on this {@code MulticastSocket} in order to control the
250      * scope of the multicasts.
251      *
252      * &lt;P&gt; The ttl &lt;B&gt;must&lt;/B&gt; be in the range {@code  0 &lt;= ttl &lt;=
253      * 255} or an {@code IllegalArgumentException} will be thrown.
254      * Multicast packets sent with a TTL of {@code 0} are not transmitted
255      * on the network but may be delivered locally.
256      *
257      * @param  ttl
258      *         the time-to-live
259      *
260      * @throws  IOException
261      *          if an I/O exception occurs while setting the
262      *          default time-to-live value
263      *
264      * @see #getTimeToLive()
265      * @since 1.2
266      */
267     public void setTimeToLive(int ttl) throws IOException {
268         delegate().setTimeToLive(ttl);
269     }
270 
271     /**
272      * Get the default time-to-live for multicast packets sent out on
273      * the socket.
274      *
275      * @throws    IOException if an I/O exception occurs
276      * while getting the default time-to-live value
277      * @return the default time-to-live value
278      * @deprecated use the getTimeToLive method instead, which returns
279      * an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.
280      * @see #setTTL(byte)
281      */
282     @Deprecated
283     public byte getTTL() throws IOException {
284         return delegate().getTTL();
285     }
286 
287     /**
288      * Get the default time-to-live for multicast packets sent out on
289      * the socket.
290      * @throws    IOException if an I/O exception occurs while
291      * getting the default time-to-live value
292      * @return the default time-to-live value
293      * @see #setTimeToLive(int)
294      * @since 1.2
295      */
296     public int getTimeToLive() throws IOException {
297         return delegate().getTimeToLive();
298     }
299 
300     /**
301      * Joins a multicast group. Its behavior may be affected by
302      * {@code setInterface} or {@code setNetworkInterface}.
303      *
304      * &lt;p&gt;If there is a security manager, this method first
305      * calls its {@code checkMulticast} method with the
306      * {@code mcastaddr} argument as its argument.
307      *
308      * @param      mcastaddr is the multicast address to join
309      * @throws     IOException if there is an error joining,
310      *             or when the address is not a multicast address,
311      *             or the platform does not support multicasting
312      * @throws     SecurityException if a security manager exists and its
313      *             {@code checkMulticast} method doesn&#39;t allow the join.
314      * @deprecated This method does not accept the network interface on
315      *             which to join the multicast group. Use
316      *             {@link #joinGroup(SocketAddress, NetworkInterface)} instead.
317      * @see        SecurityManager#checkMulticast(InetAddress)
318      */
319     @Deprecated(since=&quot;14&quot;)
320     public void joinGroup(InetAddress mcastaddr) throws IOException {
321         delegate().joinGroup(mcastaddr);
322     }
323 
324     /**
325      * Leave a multicast group. Its behavior may be affected by
326      * {@code setInterface} or {@code setNetworkInterface}.
327      *
328      * &lt;p&gt;If there is a security manager, this method first
329      * calls its {@code checkMulticast} method with the
330      * {@code mcastaddr} argument as its argument.
331      *
332      * @param      mcastaddr is the multicast address to leave
333      * @throws     IOException if there is an error leaving
334      *             or when the address is not a multicast address.
335      * @throws     SecurityException if a security manager exists and its
336      *             {@code checkMulticast} method doesn&#39;t allow the operation.
337      * @deprecated This method does not accept the network interface on which
338      *             to leave the multicast group. Use
339      *             {@link #leaveGroup(SocketAddress, NetworkInterface)} instead.
340      * @see        SecurityManager#checkMulticast(InetAddress)
341      */
342     @Deprecated(since=&quot;14&quot;)
343     public void leaveGroup(InetAddress mcastaddr) throws IOException {
344         delegate().leaveGroup(mcastaddr);
345     }
346 
347     /**
348      * Joins the specified multicast group at the specified interface.
349      *
350      * &lt;p&gt;If there is a security manager, this method first
351      * calls its {@code checkMulticast} method
352      * with the {@code mcastaddr} argument
353      * as its argument.
354      *
355      * @param  mcastaddr is the multicast address to join
356      * @param  netIf specifies the local interface to receive multicast
357      *         datagram packets, or {@code null} to defer to the interface set by
358      *         {@link MulticastSocket#setInterface(InetAddress)} or
359      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.
360      *         If {@code null}, and no interface has been set, the behaviour is
361      *         unspecified: any interface may be selected or the operation may fail
362      *         with a {@code SocketException}.
363      * @throws IOException if there is an error joining, or when the address
364      *         is not a multicast address, or the platform does not support
365      *         multicasting
366      * @throws SecurityException if a security manager exists and its
367      *         {@code checkMulticast} method doesn&#39;t allow the join.
368      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a
369      *         SocketAddress subclass not supported by this socket
370      * @see    SecurityManager#checkMulticast(InetAddress)
371      * @see    DatagramChannel#join(InetAddress, NetworkInterface)
372      * @since  1.4
373      */
374     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
375         throws IOException {
376         delegate().joinGroup(mcastaddr, netIf);
377     }
378 
379     /**
380      * Leave a multicast group on a specified local interface.
381      *
382      * &lt;p&gt;If there is a security manager, this method first
383      * calls its {@code checkMulticast} method with the
384      * {@code mcastaddr} argument as its argument.
385      *
386      * @param  mcastaddr is the multicast address to leave
387      * @param  netIf specifies the local interface or {@code null} to defer
388      *         to the interface set by
389      *         {@link MulticastSocket#setInterface(InetAddress)} or
390      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.
391      *         If {@code null}, and no interface has been set, the behaviour
392      *         is unspecified: any interface may be selected or the operation
393      *         may fail with a {@code SocketException}.
394      * @throws IOException if there is an error leaving or when the address
395      *         is not a multicast address.
396      * @throws SecurityException if a security manager exists and its
397      *         {@code checkMulticast} method doesn&#39;t allow the operation.
398      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a
399      *         SocketAddress subclass not supported by this socket.
400      * @see    SecurityManager#checkMulticast(InetAddress)
401      * @since  1.4
402      */
403     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
404         throws IOException {
405         delegate().leaveGroup(mcastaddr, netIf);
406      }
407 
408     /**
409      * Set the multicast network interface used by methods
410      * whose behavior would be affected by the value of the
411      * network interface. Useful for multihomed hosts.
412      *
413      * @param      inf the InetAddress
414      * @throws     SocketException if there is an error in
415      *             the underlying protocol, such as a TCP error.
416      * @deprecated The InetAddress may not uniquely identify
417      *             the network interface. Use
418      *             {@link #setNetworkInterface(NetworkInterface)} instead.
419      * @see        #getInterface()
420      */
421     @Deprecated(since=&quot;14&quot;)
422     public void setInterface(InetAddress inf) throws SocketException {
423         delegate().setInterface(inf);
424     }
425 
426     /**
427      * Retrieve the address of the network interface used for
428      * multicast packets.
429      *
430      * @return     An {@code InetAddress} representing the address
431      *             of the network interface used for multicast packets,
432      *             or if no interface has been set, an {@code InetAddress}
433      *             representing any local address.
434      * @throws     SocketException if there is an error in the
435      *             underlying protocol, such as a TCP error.
436      * @deprecated The network interface may not be uniquely identified by
437      *             the InetAddress returned.
438      *             Use {@link #getNetworkInterface()} instead.
439      * @see        #setInterface(java.net.InetAddress)
440      */
441     @Deprecated(since=&quot;14&quot;)
442     public InetAddress getInterface() throws SocketException {
443         return delegate().getInterface();
444     }
445 
446     /**
447      * Specify the network interface for outgoing multicast datagrams
448      * sent on this socket.
449      *
450      * @param netIf the interface
451      * @throws    SocketException if there is an error in
452      * the underlying protocol, such as a TCP error.
453      * @see #getNetworkInterface()
454      * @since 1.4
455      */
456     public void setNetworkInterface(NetworkInterface netIf)
457         throws SocketException {
458         delegate().setNetworkInterface(netIf);
459     }
460 
461     /**
462      * Get the multicast network interface set.
463      *
464      * @throws SocketException if there is an error in
465      *         the underlying protocol, such as a TCP error.
466      * @return The multicast {@code NetworkInterface} currently set. A placeholder
467      *         NetworkInterface is returned when there is no interface set; it has
468      *         a single InetAddress to represent any local address.
469      * @see    #setNetworkInterface(NetworkInterface)
470      * @since  1.4
471      */
472     public NetworkInterface getNetworkInterface() throws SocketException {
473         return delegate().getNetworkInterface();
474     }
475 
476     /**
477      * Disable/Enable local loopback of multicast datagrams.
478      * The option is used by the platform&#39;s networking code as a hint
479      * for setting whether multicast data will be looped back to
480      * the local socket.
481      *
482      * &lt;p&gt;Because this option is a hint, applications that want to
483      * verify what loopback mode is set to should call
484      * {@link #getLoopbackMode()}
485      * @param      disable {@code true} to disable the LoopbackMode
486      * @throws     SocketException if an error occurs while setting the value
487      * @since      1.4
488      * @deprecated Use {@link #setOption(SocketOption, Object)} with
489      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
490      *             instead. The loopback mode is enabled by default,
491      *             {@code MulticastSocket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, false)}
492      *             disables it.
493      * @see        #getLoopbackMode
494      */
495     @Deprecated(since=&quot;14&quot;)
496     public void setLoopbackMode(boolean disable) throws SocketException {
497         delegate().setLoopbackMode(disable);
498     }
499 
500     /**
501      * Get the setting for local loopback of multicast datagrams.
502      *
503      * @throws     SocketException if an error occurs while getting the value
504      * @return     true if the LoopbackMode has been disabled
505      * @since      1.4
506      * @deprecated Use {@link #getOption(SocketOption)} with
507      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
508      *             instead.
509      * @see        #setLoopbackMode
510      */
511     @Deprecated(since=&quot;14&quot;)
512     public boolean getLoopbackMode() throws SocketException {
513         return delegate().getLoopbackMode();
514     }
515 
516     /**
517      * Sends a datagram packet to the destination, with a TTL (time-to-live)
518      * other than the default for the socket.  This method
519      * need only be used in instances where a particular TTL is desired;
520      * otherwise it is preferable to set a TTL once on the socket, and
521      * use that default TTL for all packets.  This method does &lt;B&gt;not
522      * &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
523      * affected by {@code setInterface}.
524      *
525      * &lt;p&gt;If there is a security manager, this method first performs some
526      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
527      * is true, this method calls the
528      * security manager&#39;s {@code checkMulticast} method
529      * with {@code p.getAddress()} and {@code ttl} as its arguments.
530      * If the evaluation of that expression is false,
531      * this method instead calls the security manager&#39;s
532      * {@code checkConnect} method with arguments
533      * {@code p.getAddress().getHostAddress()} and
534      * {@code p.getPort()}. Each call to a security manager method
535      * could result in a SecurityException if the operation is not allowed.
536      *
537      * @param p is the packet to be sent. The packet should contain
538      * the destination multicast ip address and the data to be sent.
539      * One does not need to be the member of the group to send
540      * packets to a destination multicast address.
541      * @param ttl optional time to live for multicast packet.
542      * default ttl is 1.
543      *
544      * @throws     IOException is raised if an error occurs i.e
545      *             error while setting ttl.
546      * @throws     SecurityException  if a security manager exists and its
547      *             {@code checkMulticast} or {@code checkConnect}
548      *             method doesn&#39;t allow the send.
549      * @throws     PortUnreachableException may be thrown if the socket is connected
550      *             to a currently unreachable destination. Note, there is no
551      *             guarantee that the exception will be thrown.
552      * @throws     IllegalArgumentException if the socket is connected,
553      *             and connected address and packet address differ, or
554      *             if the socket is not connected and the packet address
555      *             is not set or if its port is out of range.
556      *
557      *
558      * @deprecated Use the following code or its equivalent instead:
559      *  ......
560      *  int ttl = mcastSocket.getTimeToLive();
561      *  mcastSocket.setTimeToLive(newttl);
562      *  mcastSocket.send(p);
563      *  mcastSocket.setTimeToLive(ttl);
564      *  ......
565      *
566      * @see DatagramSocket#send
567      * @see DatagramSocket#receive
568      * @see SecurityManager#checkMulticast(java.net.InetAddress, byte)
569      * @see SecurityManager#checkConnect
570      */
571     @Deprecated
572     public void send(DatagramPacket p, byte ttl)
573         throws IOException {
574         delegate().send(p, ttl);
575     }
576 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../net/DatagramSocket.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;

  30 import jdk.internal.misc.VM;
  31 import jdk.internal.org.objectweb.asm.ClassWriter;
  32 import jdk.internal.org.objectweb.asm.Label;
  33 import jdk.internal.org.objectweb.asm.MethodVisitor;
  34 import jdk.internal.org.objectweb.asm.Opcodes;

  35 import sun.invoke.util.Wrapper;
  36 
  37 import java.lang.invoke.MethodHandles.Lookup;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.List;
  41 import java.util.Objects;
  42 import java.util.concurrent.ConcurrentHashMap;
  43 import java.util.concurrent.ConcurrentMap;
  44 import java.util.function.Function;
  45 
  46 import static java.lang.invoke.MethodHandles.lookup;
  47 import static java.lang.invoke.MethodType.methodType;
  48 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;
  49 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  50 
  51 /**
  52  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  53  * can be used to efficiently concatenate a known number of arguments of known
  54  * types, possibly after type adaptation and partial evaluation of arguments.
</pre>
<hr />
<pre>
 112      */
 113     private static final char TAG_ARG = &#39;\u0001&#39;;
 114 
 115     /**
 116      * Tag used to demarcate a constant.
 117      */
 118     private static final char TAG_CONST = &#39;\u0002&#39;;
 119 
 120     /**
 121      * Maximum number of argument slots in String Concat call.
 122      *
 123      * While the maximum number of argument slots that indy call can handle is 253,
 124      * we do not use all those slots, to let the strategies with MethodHandle
 125      * combinators to use some arguments.
 126      */
 127     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 128 
 129     /**
 130      * Concatenation strategy to use. See {@link Strategy} for possible options.
 131      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.


 132      */
<span class="line-modified"> 133     private static Strategy STRATEGY;</span>
<span class="line-removed"> 134 </span>
<span class="line-removed"> 135     /**</span>
<span class="line-removed"> 136      * Default strategy to use for concatenation.</span>
<span class="line-removed"> 137      */</span>
<span class="line-removed"> 138     private static final Strategy DEFAULT_STRATEGY = Strategy.MH_INLINE_SIZED_EXACT;</span>
 139 
 140     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 141 
 142     private enum Strategy {
 143         /**
 144          * Bytecode generator, calling into {@link java.lang.StringBuilder}.
 145          */
 146         BC_SB,
 147 
 148         /**
 149          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 150          * but trying to estimate the required storage.
 151          */
 152         BC_SB_SIZED,
 153 
 154         /**
 155          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 156          * but computing the required storage exactly.
 157          */
 158         BC_SB_SIZED_EXACT,
</pre>
<hr />
<pre>
 165 
 166         /**
 167          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 168          * This strategy also estimate the required storage exactly.
 169          */
 170         MH_SB_SIZED_EXACT,
 171 
 172         /**
 173          * MethodHandle-based generator, that constructs its own byte[] array from
 174          * the arguments. It computes the required storage exactly.
 175          */
 176         MH_INLINE_SIZED_EXACT
 177     }
 178 
 179     /**
 180      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 181      * checks, etc.
 182      */
 183     private static final boolean DEBUG;
 184 
<span class="line-removed"> 185     /**</span>
<span class="line-removed"> 186      * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-removed"> 187      * code, at the expense of contaminating the profiles.</span>
<span class="line-removed"> 188      */</span>
<span class="line-removed"> 189     private static final boolean CACHE_ENABLE;</span>
<span class="line-removed"> 190 </span>
<span class="line-removed"> 191     private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-removed"> 192 </span>
<span class="line-removed"> 193     /**</span>
<span class="line-removed"> 194      * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-removed"> 195      */</span>
<span class="line-removed"> 196     private static final ProxyClassesDumper DUMPER;</span>
<span class="line-removed"> 197 </span>
 198     static {
<span class="line-removed"> 199         // In case we need to double-back onto the StringConcatFactory during this</span>
<span class="line-removed"> 200         // static initialization, make sure we have the reasonable defaults to complete</span>
<span class="line-removed"> 201         // the static initialization properly. After that, actual users would use</span>
<span class="line-removed"> 202         // the proper values we have read from the properties.</span>
<span class="line-removed"> 203         STRATEGY = DEFAULT_STRATEGY;</span>
<span class="line-removed"> 204         // CACHE_ENABLE = false; // implied</span>
<span class="line-removed"> 205         // CACHE = null;         // implied</span>
<span class="line-removed"> 206         // DEBUG = false;        // implied</span>
<span class="line-removed"> 207         // DUMPER = null;        // implied</span>
<span class="line-removed"> 208 </span>
 209         final String strategy =
 210                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
<span class="line-modified"> 211         CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-modified"> 212                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>





 213         DEBUG = Boolean.parseBoolean(
 214                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));
<span class="line-removed"> 215         final String dumpPath =</span>
<span class="line-removed"> 216                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218         STRATEGY = (strategy == null) ? DEFAULT_STRATEGY : Strategy.valueOf(strategy);</span>
<span class="line-removed"> 219         CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-removed"> 220         DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
 221     }
 222 
 223     /**
 224      * Cache key is a composite of:
 225      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 226      *   - method type, describing the dynamic arguments for concatenation
 227      *   - concat recipe, describing the constants and concat shape
 228      */
 229     private static final class Key {
 230         final String className;
 231         final MethodType mt;
 232         final Recipe recipe;
 233 
 234         public Key(String className, MethodType mt, Recipe recipe) {
 235             this.className = className;
 236             this.mt = mt;
 237             this.recipe = recipe;
 238         }
 239 
 240         @Override
</pre>
<hr />
<pre>
 243             if (o == null || getClass() != o.getClass()) return false;
 244 
 245             Key key = (Key) o;
 246 
 247             if (!className.equals(key.className)) return false;
 248             if (!mt.equals(key.mt)) return false;
 249             if (!recipe.equals(key.recipe)) return false;
 250             return true;
 251         }
 252 
 253         @Override
 254         public int hashCode() {
 255             int result = className.hashCode();
 256             result = 31 * result + mt.hashCode();
 257             result = 31 * result + recipe.hashCode();
 258             return result;
 259         }
 260     }
 261 
 262     /**
<span class="line-modified"> 263      * Parses the recipe string, and produces the traversable collection of</span>
 264      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 265      * strategies. Notably, this class parses out the constants from the recipe
 266      * and from other static arguments.
 267      */
 268     private static final class Recipe {
 269         private final List&lt;RecipeElement&gt; elements;
 270 
 271         public Recipe(String src, Object[] constants) {
 272             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 273 
 274             int constC = 0;
 275             int argC = 0;
 276 
 277             StringBuilder acc = new StringBuilder();
 278 
 279             for (int i = 0; i &lt; src.length(); i++) {
 280                 char c = src.charAt(i);
 281 
 282                 if (c == TAG_CONST || c == TAG_ARG) {
 283                     // Detected a special tag, flush all accumulated characters
</pre>
<hr />
<pre>
 651                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 652                             cCount +
 653                             &quot; constants, but only &quot; +
 654                             constants.length +
 655                             &quot; are passed&quot;);
 656         }
 657 
 658         if (!concatType.returnType().isAssignableFrom(String.class)) {
 659             throw new StringConcatException(
 660                     &quot;The return type should be compatible with String, but it is &quot; +
 661                             concatType.returnType());
 662         }
 663 
 664         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 665             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 666                     concatType.parameterSlotCount() +
 667                     &quot;, can only accept &quot; +
 668                     MAX_INDY_CONCAT_ARG_SLOTS);
 669         }
 670 
<span class="line-removed"> 671         String className = getClassName(lookup.lookupClass());</span>
 672         MethodType mt = adaptType(concatType);
 673         Recipe rec = new Recipe(recipe, constants);
<span class="line-modified"> 674 </span>
<span class="line-removed"> 675         MethodHandle mh;</span>
<span class="line-removed"> 676         if (CACHE_ENABLE) {</span>
<span class="line-removed"> 677             Key key = new Key(className, mt, rec);</span>
<span class="line-removed"> 678             mh = CACHE.get(key);</span>
<span class="line-removed"> 679             if (mh == null) {</span>
<span class="line-removed"> 680                 mh = generate(lookup, className, mt, rec);</span>
<span class="line-removed"> 681                 CACHE.put(key, mh);</span>
<span class="line-removed"> 682             }</span>
<span class="line-removed"> 683         } else {</span>
<span class="line-removed"> 684             mh = generate(lookup, className, mt, rec);</span>
<span class="line-removed"> 685         }</span>
 686         return new ConstantCallSite(mh.asType(concatType));
 687     }
 688 
 689     /**
 690      * Adapt method type to an API we are going to use.
 691      *
 692      * This strips the concrete classes from the signatures, thus preventing
 693      * class leakage when we cache the concatenation stubs.
 694      *
 695      * @param args actual argument types
 696      * @return argument types the strategy is going to use
 697      */
 698     private static MethodType adaptType(MethodType args) {
 699         Class&lt;?&gt;[] ptypes = null;
 700         for (int i = 0; i &lt; args.parameterCount(); i++) {
 701             Class&lt;?&gt; ptype = args.parameterType(i);
 702             if (!ptype.isPrimitive() &amp;&amp;
 703                     ptype != String.class &amp;&amp;
 704                     ptype != Object.class) { // truncate to Object
 705                 if (ptypes == null) {
 706                     ptypes = args.parameterArray();
 707                 }
 708                 ptypes[i] = Object.class;
 709             }
 710             // else other primitives or String or Object (unchanged)
 711         }
 712         return (ptypes != null)
 713                 ? MethodType.methodType(args.returnType(), ptypes)
 714                 : args;
 715     }
 716 
<span class="line-modified"> 717     private static String getClassName(Class&lt;?&gt; hostClass) throws StringConcatException {</span>
<span class="line-removed"> 718         /*</span>
<span class="line-removed"> 719           The generated class is in the same package as the host class as</span>
<span class="line-removed"> 720           it&#39;s the implementation of the string concatenation for the host class.</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722           When cache is enabled, we want to cache as much as we can.</span>
<span class="line-removed"> 723          */</span>
<span class="line-removed"> 724 </span>
<span class="line-removed"> 725         switch (STRATEGY) {</span>
<span class="line-removed"> 726             case BC_SB:</span>
<span class="line-removed"> 727             case BC_SB_SIZED:</span>
<span class="line-removed"> 728             case BC_SB_SIZED_EXACT: {</span>
<span class="line-removed"> 729                 if (CACHE_ENABLE) {</span>
<span class="line-removed"> 730                     String pkgName = hostClass.getPackageName();</span>
<span class="line-removed"> 731                     return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-removed"> 732                 } else {</span>
<span class="line-removed"> 733                     String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-removed"> 734                                                        : hostClass.getName();</span>
<span class="line-removed"> 735                     return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-removed"> 736                 }</span>
<span class="line-removed"> 737             }</span>
<span class="line-removed"> 738             case MH_SB_SIZED:</span>
<span class="line-removed"> 739             case MH_SB_SIZED_EXACT:</span>
<span class="line-removed"> 740             case MH_INLINE_SIZED_EXACT:</span>
<span class="line-removed"> 741                 // MethodHandle strategies do not need a class name.</span>
<span class="line-removed"> 742                 return &quot;&quot;;</span>
<span class="line-removed"> 743             default:</span>
<span class="line-removed"> 744                 throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);</span>
<span class="line-removed"> 745         }</span>
<span class="line-removed"> 746     }</span>
<span class="line-removed"> 747 </span>
<span class="line-removed"> 748     private static MethodHandle generate(Lookup lookup, String className, MethodType mt, Recipe recipe) throws StringConcatException {</span>
 749         try {



 750             switch (STRATEGY) {
 751                 case BC_SB:
<span class="line-modified"> 752                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.DEFAULT);</span>
 753                 case BC_SB_SIZED:
<span class="line-modified"> 754                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED);</span>
 755                 case BC_SB_SIZED_EXACT:
<span class="line-modified"> 756                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED_EXACT);</span>
 757                 case MH_SB_SIZED:
 758                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
 759                 case MH_SB_SIZED_EXACT:
 760                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
 761                 case MH_INLINE_SIZED_EXACT:
 762                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);
 763                 default:
 764                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);
 765             }
 766         } catch (Error | StringConcatException e) {
 767             // Pass through any error or existing StringConcatException
 768             throw e;
 769         } catch (Throwable t) {
 770             throw new StringConcatException(&quot;Generator failed&quot;, t);
 771         }
 772     }
 773 
 774     private enum Mode {
 775         DEFAULT(false, false),
 776         SIZED(true, false),
</pre>
<hr />
<pre>
 819      * it only guesses the space required for known types (e.g. primitives and
 820      * Strings), but does not otherwise convert arguments. Therefore, the
 821      * capacity estimate may be wrong, and StringBuilder may have to
 822      * transparently resize or trim when doing the actual concatenation. While
 823      * this does not constitute a correctness issue (in the end, that what BC_SB
 824      * has to do anyway), this does pose a potential performance problem.
 825      *
 826      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but
 827      * sized exactly&quot;.&lt;/b&gt;
 828      *
 829      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first
 830      * converting all arguments to String in order to get the exact capacity
 831      * StringBuilder should have. The conversion is done via the public
 832      * String.valueOf and/or Object.toString methods, and does not touch any
 833      * private String API.
 834      */
 835     private static final class BytecodeStringBuilderStrategy {
 836         static final int CLASSFILE_VERSION = 52;
 837         static final String METHOD_NAME = &quot;concat&quot;;
 838 
























 839         private BytecodeStringBuilderStrategy() {
 840             // no instantiation
 841         }
 842 
<span class="line-modified"> 843         private static MethodHandle generate(Lookup lookup, String className, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>










 844             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 845 
 846             cw.visit(CLASSFILE_VERSION,
 847                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
 848                     className,
 849                     null,
 850                     &quot;java/lang/Object&quot;,
 851                     null
 852             );
 853 
 854             MethodVisitor mv = cw.visitMethod(
 855                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,
 856                     METHOD_NAME,
 857                     args.toMethodDescriptorString(),
 858                     null,
 859                     null);
 860 
 861             // use of @ForceInline no longer has any effect
 862             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);
 863             mv.visitCode();
</pre>
<hr />
<pre>
1113             }
1114 
1115             mv.visitMethodInsn(
1116                     INVOKEVIRTUAL,
1117                     &quot;java/lang/StringBuilder&quot;,
1118                     &quot;toString&quot;,
1119                     &quot;()Ljava/lang/String;&quot;,
1120                     false
1121             );
1122 
1123             mv.visitInsn(ARETURN);
1124 
1125             mv.visitMaxs(-1, -1);
1126             mv.visitEnd();
1127             cw.visitEnd();
1128 
1129             byte[] classBytes = cw.toByteArray();
1130             try {
1131                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
1132                 dumpIfEnabled(className, classBytes);
<span class="line-modified">1133                 return lookup.findStatic(innerClass, METHOD_NAME, args);</span>




1134             } catch (Exception e) {
1135                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
1136                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
1137             }
1138         }
1139 


















1140         private static void dumpIfEnabled(String name, byte[] bytes) {
1141             if (DUMPER != null) {
1142                 DUMPER.dumpClass(name, bytes);
1143             }
1144         }
1145 
1146         private static String getSBAppendDesc(Class&lt;?&gt; cl) {
1147             if (cl.isPrimitive()) {
1148                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1149                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;
1150                 } else if (cl == Boolean.TYPE) {
1151                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;
1152                 } else if (cl == Character.TYPE) {
1153                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;
1154                 } else if (cl == Double.TYPE) {
1155                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;
1156                 } else if (cl == Float.TYPE) {
1157                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;
1158                 } else if (cl == Long.TYPE) {
1159                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;
</pre>
<hr />
<pre>
1498      * particular implementation details for String, this opens the door for
1499      * building a very optimal concatenation sequence. This is the only strategy
1500      * that requires porting if there are private JDK changes occur.
1501      */
1502     private static final class MethodHandleInlineCopyStrategy {
1503         private MethodHandleInlineCopyStrategy() {
1504             // no instantiation
1505         }
1506 
1507         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {
1508 
1509             // Fast-path two-argument Object + Object concatenations
1510             if (recipe.getElements().size() == 2) {
1511                 // Two object arguments
1512                 if (mt.parameterCount() == 2 &amp;&amp;
1513                     !mt.parameterType(0).isPrimitive() &amp;&amp;
1514                     !mt.parameterType(1).isPrimitive() &amp;&amp;
1515                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;
1516                     recipe.getElements().get(1).getTag() == TAG_ARG) {
1517 
<span class="line-modified">1518                     return SIMPLE;</span>
1519 
1520                 } else if (mt.parameterCount() == 1 &amp;&amp;
1521                            !mt.parameterType(0).isPrimitive()) {
1522                     // One Object argument, one constant
<span class="line-modified">1523                     MethodHandle mh = SIMPLE;</span>
1524 
1525                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;
1526                         recipe.getElements().get(1).getTag() == TAG_ARG) {
1527                         // First recipe element is a constant
1528                         return MethodHandles.insertArguments(mh, 0,
1529                                 recipe.getElements().get(0).getValue());
1530 
1531                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;
1532                                recipe.getElements().get(0).getTag() == TAG_ARG) {
1533                         // Second recipe element is a constant
1534                         return MethodHandles.insertArguments(mh, 1,
1535                                 recipe.getElements().get(1).getValue());
1536 
1537                     }
1538                 }
1539                 // else... fall-through to slow-path
1540             }
1541 
1542             // Create filters and obtain filtered parameter types. Filters would be used in the beginning
1543             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
</pre>
<hr />
<pre>
1545             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1546             MethodHandle[] filters = null;
1547             for (int i = 0; i &lt; ptypes.length; i++) {
1548                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);
1549                 if (filter != null) {
1550                     if (filters == null) {
1551                         filters = new MethodHandle[ptypes.length];
1552                     }
1553                     filters[i] = filter;
1554                     ptypes[i] = filter.type().returnType();
1555                 }
1556             }
1557 
1558             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
1559             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
1560             // assembled bottom-up, which makes the code arguably hard to read.
1561 
1562             // Drop all remaining parameter types, leave only helper arguments:
1563             MethodHandle mh;
1564 
<span class="line-modified">1565             mh = MethodHandles.dropArguments(NEW_STRING, 2, ptypes);</span>
1566 
1567             long initialLengthCoder = INITIAL_CODER;
1568 
1569             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
1570             // known from the combinators below. We are assembling the string backwards, so the index coded
1571             // into indexCoder is the *ending* index.
1572 
1573             // We need one prepender per argument, but also need to fold in constants. We do so by greedily
1574             // create prependers that fold in surrounding constants into the argument prepender. This reduces
1575             // the number of unique MH combinator tree shapes we&#39;ll create in an application.
1576             String prefixConstant = null, suffixConstant = null;
1577             int pos = -1;
1578             for (RecipeElement el : recipe.getElements()) {
1579                 // Do the prepend, and put &quot;new&quot; index at index 1
1580                 switch (el.getTag()) {
1581                     case TAG_CONST: {
1582                         String constantValue = el.getValue();
1583 
1584                         // Eagerly update the initialLengthCoder value
1585                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);
</pre>
<hr />
<pre>
1616 
1617             // Insert any trailing args, constants
1618             if (pos &gt;= 0) {
1619                 mh = MethodHandles.filterArgumentsWithCombiner(
1620                     mh, 1,
1621                     prepender(prefixConstant, ptypes[pos], suffixConstant),
1622                     1, 0, // indexCoder, storage
1623                     2 + pos  // selected argument
1624                 );
1625             } else if (prefixConstant != null) {
1626                 assert (suffixConstant == null);
1627                 // Sole prefixConstant can only happen if there were no non-constant arguments
1628                 mh = MethodHandles.filterArgumentsWithCombiner(
1629                     mh, 1,
1630                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
1631                     1, 0 // indexCoder, storage
1632                 );
1633             }
1634 
1635             // Fold in byte[] instantiation at argument 0
<span class="line-modified">1636             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, NEW_ARRAY,</span>
1637                     1 // index
1638             );
1639 
1640             // Start combining length and coder mixers.
1641             //
1642             // Length is easy: constant lengths can be computed on the spot, and all non-constant
1643             // shapes have been either converted to Strings, or explicit methods for getting the
1644             // string length out of primitives are provided.
1645             //
1646             // Coders are more interesting. Only Object, String and char arguments (and constants)
1647             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
1648             // and deduce the coder from there. Arguments would be either converted to Strings
1649             // during the initial filtering, or handled by specializations in MIXERS.
1650             //
1651             // The method handle shape before all mixers are combined in is:
1652             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
1653             //
1654             // We will bind the initialLengthCoder value to the last mixer (the one that will be
1655             // executed first), then fold that in. This leaves the shape after all mixers are
1656             // combined in as:
</pre>
<hr />
<pre>
1690                         1 + ac // selected argument
1691                 );
1692             } else {
1693                 // No mixer (constants only concat), insert initialLengthCoder directly
1694                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
1695             }
1696 
1697             // The method handle shape here is (&lt;args&gt;).
1698 
1699             // Apply filters, converting the arguments:
1700             if (filters != null) {
1701                 mh = MethodHandles.filterArguments(mh, 0, filters);
1702             }
1703 
1704             return mh;
1705         }
1706 
1707         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
1708             return MethodHandles.insertArguments(
1709                     MethodHandles.insertArguments(
<span class="line-modified">1710                         PREPENDERS.computeIfAbsent(cl, PREPEND),2, prefix), 3, suffix);</span>
1711         }
1712 
1713         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1714             return MIXERS.computeIfAbsent(cl, MIX);
1715         }
1716 
1717         // This one is deliberately non-lambdified to optimize startup time:
1718         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
1719             @Override
1720             public MethodHandle apply(Class&lt;?&gt; c) {
1721                 return JLA.stringConcatHelper(&quot;prepend&quot;,
1722                             methodType(long.class, long.class, byte[].class,
1723                                        String.class, Wrapper.asPrimitiveType(c), String.class));
1724             }
1725         };
1726 
1727         // This one is deliberately non-lambdified to optimize startup time:
1728         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
1729             @Override
1730             public MethodHandle apply(Class&lt;?&gt; c) {
1731                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));
1732             }
1733         };
1734 
<span class="line-modified">1735         private static final MethodHandle SIMPLE;</span>
<span class="line-modified">1736         private static final MethodHandle NEW_STRING;</span>
<span class="line-modified">1737         private static final MethodHandle NEW_ARRAY;</span>
























1738         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1739         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1740         private static final long INITIAL_CODER;
1741 
1742         static {
<span class="line-modified">1743             try {</span>
<span class="line-removed">1744                 MethodHandle initCoder = JLA.stringConcatHelper(&quot;initialCoder&quot;, methodType(long.class));</span>
<span class="line-removed">1745                 INITIAL_CODER = (long) initCoder.invoke();</span>
<span class="line-removed">1746             } catch (Throwable e) {</span>
<span class="line-removed">1747                 throw new AssertionError(e);</span>
<span class="line-removed">1748             }</span>
<span class="line-removed">1749 </span>
1750             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1751             MIXERS = new ConcurrentHashMap&lt;&gt;();
<span class="line-removed">1752 </span>
<span class="line-removed">1753             SIMPLE     = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
<span class="line-removed">1754             NEW_STRING = JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));</span>
<span class="line-removed">1755             NEW_ARRAY  = JLA.stringConcatHelper( &quot;newArray&quot;, methodType(byte[].class, long.class));</span>
1756         }
1757     }
1758 
1759     /**
1760      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1761      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1762      */
1763     private static final class Stringifiers {
1764         private Stringifiers() {
1765             // no instantiation
1766         }
1767 
1768         private static final MethodHandle OBJECT_INSTANCE =
1769                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));
1770 
1771         private static class FloatStringifiers {
1772             private static final MethodHandle FLOAT_INSTANCE =
1773                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1774 
1775             private static final MethodHandle DOUBLE_INSTANCE =
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
<span class="line-added">  30 import jdk.internal.misc.Unsafe;</span>
  31 import jdk.internal.misc.VM;
  32 import jdk.internal.org.objectweb.asm.ClassWriter;
  33 import jdk.internal.org.objectweb.asm.Label;
  34 import jdk.internal.org.objectweb.asm.MethodVisitor;
  35 import jdk.internal.org.objectweb.asm.Opcodes;
<span class="line-added">  36 import jdk.internal.vm.annotation.Stable;</span>
  37 import sun.invoke.util.Wrapper;
  38 
  39 import java.lang.invoke.MethodHandles.Lookup;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.List;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 import java.util.function.Function;
  47 
  48 import static java.lang.invoke.MethodHandles.lookup;
  49 import static java.lang.invoke.MethodType.methodType;
  50 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;
  51 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  52 
  53 /**
  54  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  55  * can be used to efficiently concatenate a known number of arguments of known
  56  * types, possibly after type adaptation and partial evaluation of arguments.
</pre>
<hr />
<pre>
 114      */
 115     private static final char TAG_ARG = &#39;\u0001&#39;;
 116 
 117     /**
 118      * Tag used to demarcate a constant.
 119      */
 120     private static final char TAG_CONST = &#39;\u0002&#39;;
 121 
 122     /**
 123      * Maximum number of argument slots in String Concat call.
 124      *
 125      * While the maximum number of argument slots that indy call can handle is 253,
 126      * we do not use all those slots, to let the strategies with MethodHandle
 127      * combinators to use some arguments.
 128      */
 129     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 130 
 131     /**
 132      * Concatenation strategy to use. See {@link Strategy} for possible options.
 133      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.
<span class="line-added"> 134      *</span>
<span class="line-added"> 135      * Defaults to MH_INLINE_SIZED_EXACT if not set.</span>
 136      */
<span class="line-modified"> 137     private static final Strategy STRATEGY;</span>





 138 
 139     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 140 
 141     private enum Strategy {
 142         /**
 143          * Bytecode generator, calling into {@link java.lang.StringBuilder}.
 144          */
 145         BC_SB,
 146 
 147         /**
 148          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 149          * but trying to estimate the required storage.
 150          */
 151         BC_SB_SIZED,
 152 
 153         /**
 154          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 155          * but computing the required storage exactly.
 156          */
 157         BC_SB_SIZED_EXACT,
</pre>
<hr />
<pre>
 164 
 165         /**
 166          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 167          * This strategy also estimate the required storage exactly.
 168          */
 169         MH_SB_SIZED_EXACT,
 170 
 171         /**
 172          * MethodHandle-based generator, that constructs its own byte[] array from
 173          * the arguments. It computes the required storage exactly.
 174          */
 175         MH_INLINE_SIZED_EXACT
 176     }
 177 
 178     /**
 179      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 180      * checks, etc.
 181      */
 182     private static final boolean DEBUG;
 183 













 184     static {










 185         final String strategy =
 186                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
<span class="line-modified"> 187         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);</span>
<span class="line-modified"> 188 </span>
<span class="line-added"> 189         if (STRATEGY == null || STRATEGY == Strategy.MH_INLINE_SIZED_EXACT) {</span>
<span class="line-added"> 190             // Force initialization of default strategy:</span>
<span class="line-added"> 191             Unsafe.getUnsafe().ensureClassInitialized(MethodHandleInlineCopyStrategy.class);</span>
<span class="line-added"> 192         }</span>
<span class="line-added"> 193 </span>
 194         DEBUG = Boolean.parseBoolean(
 195                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));






 196     }
 197 
 198     /**
 199      * Cache key is a composite of:
 200      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 201      *   - method type, describing the dynamic arguments for concatenation
 202      *   - concat recipe, describing the constants and concat shape
 203      */
 204     private static final class Key {
 205         final String className;
 206         final MethodType mt;
 207         final Recipe recipe;
 208 
 209         public Key(String className, MethodType mt, Recipe recipe) {
 210             this.className = className;
 211             this.mt = mt;
 212             this.recipe = recipe;
 213         }
 214 
 215         @Override
</pre>
<hr />
<pre>
 218             if (o == null || getClass() != o.getClass()) return false;
 219 
 220             Key key = (Key) o;
 221 
 222             if (!className.equals(key.className)) return false;
 223             if (!mt.equals(key.mt)) return false;
 224             if (!recipe.equals(key.recipe)) return false;
 225             return true;
 226         }
 227 
 228         @Override
 229         public int hashCode() {
 230             int result = className.hashCode();
 231             result = 31 * result + mt.hashCode();
 232             result = 31 * result + recipe.hashCode();
 233             return result;
 234         }
 235     }
 236 
 237     /**
<span class="line-modified"> 238      * Parses the recipe string, and produces a traversable collection of</span>
 239      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 240      * strategies. Notably, this class parses out the constants from the recipe
 241      * and from other static arguments.
 242      */
 243     private static final class Recipe {
 244         private final List&lt;RecipeElement&gt; elements;
 245 
 246         public Recipe(String src, Object[] constants) {
 247             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 248 
 249             int constC = 0;
 250             int argC = 0;
 251 
 252             StringBuilder acc = new StringBuilder();
 253 
 254             for (int i = 0; i &lt; src.length(); i++) {
 255                 char c = src.charAt(i);
 256 
 257                 if (c == TAG_CONST || c == TAG_ARG) {
 258                     // Detected a special tag, flush all accumulated characters
</pre>
<hr />
<pre>
 626                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 627                             cCount +
 628                             &quot; constants, but only &quot; +
 629                             constants.length +
 630                             &quot; are passed&quot;);
 631         }
 632 
 633         if (!concatType.returnType().isAssignableFrom(String.class)) {
 634             throw new StringConcatException(
 635                     &quot;The return type should be compatible with String, but it is &quot; +
 636                             concatType.returnType());
 637         }
 638 
 639         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 640             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 641                     concatType.parameterSlotCount() +
 642                     &quot;, can only accept &quot; +
 643                     MAX_INDY_CONCAT_ARG_SLOTS);
 644         }
 645 

 646         MethodType mt = adaptType(concatType);
 647         Recipe rec = new Recipe(recipe, constants);
<span class="line-modified"> 648         MethodHandle mh = generate(lookup, mt, rec);</span>











 649         return new ConstantCallSite(mh.asType(concatType));
 650     }
 651 
 652     /**
 653      * Adapt method type to an API we are going to use.
 654      *
 655      * This strips the concrete classes from the signatures, thus preventing
 656      * class leakage when we cache the concatenation stubs.
 657      *
 658      * @param args actual argument types
 659      * @return argument types the strategy is going to use
 660      */
 661     private static MethodType adaptType(MethodType args) {
 662         Class&lt;?&gt;[] ptypes = null;
 663         for (int i = 0; i &lt; args.parameterCount(); i++) {
 664             Class&lt;?&gt; ptype = args.parameterType(i);
 665             if (!ptype.isPrimitive() &amp;&amp;
 666                     ptype != String.class &amp;&amp;
 667                     ptype != Object.class) { // truncate to Object
 668                 if (ptypes == null) {
 669                     ptypes = args.parameterArray();
 670                 }
 671                 ptypes[i] = Object.class;
 672             }
 673             // else other primitives or String or Object (unchanged)
 674         }
 675         return (ptypes != null)
 676                 ? MethodType.methodType(args.returnType(), ptypes)
 677                 : args;
 678     }
 679 
<span class="line-modified"> 680     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {</span>































 681         try {
<span class="line-added"> 682             if (STRATEGY == null) {</span>
<span class="line-added"> 683                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-added"> 684             }</span>
 685             switch (STRATEGY) {
 686                 case BC_SB:
<span class="line-modified"> 687                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);</span>
 688                 case BC_SB_SIZED:
<span class="line-modified"> 689                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);</span>
 690                 case BC_SB_SIZED_EXACT:
<span class="line-modified"> 691                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);</span>
 692                 case MH_SB_SIZED:
 693                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
 694                 case MH_SB_SIZED_EXACT:
 695                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
 696                 case MH_INLINE_SIZED_EXACT:
 697                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);
 698                 default:
 699                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);
 700             }
 701         } catch (Error | StringConcatException e) {
 702             // Pass through any error or existing StringConcatException
 703             throw e;
 704         } catch (Throwable t) {
 705             throw new StringConcatException(&quot;Generator failed&quot;, t);
 706         }
 707     }
 708 
 709     private enum Mode {
 710         DEFAULT(false, false),
 711         SIZED(true, false),
</pre>
<hr />
<pre>
 754      * it only guesses the space required for known types (e.g. primitives and
 755      * Strings), but does not otherwise convert arguments. Therefore, the
 756      * capacity estimate may be wrong, and StringBuilder may have to
 757      * transparently resize or trim when doing the actual concatenation. While
 758      * this does not constitute a correctness issue (in the end, that what BC_SB
 759      * has to do anyway), this does pose a potential performance problem.
 760      *
 761      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but
 762      * sized exactly&quot;.&lt;/b&gt;
 763      *
 764      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first
 765      * converting all arguments to String in order to get the exact capacity
 766      * StringBuilder should have. The conversion is done via the public
 767      * String.valueOf and/or Object.toString methods, and does not touch any
 768      * private String API.
 769      */
 770     private static final class BytecodeStringBuilderStrategy {
 771         static final int CLASSFILE_VERSION = 52;
 772         static final String METHOD_NAME = &quot;concat&quot;;
 773 
<span class="line-added"> 774         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-added"> 775 </span>
<span class="line-added"> 776         /**</span>
<span class="line-added"> 777          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-added"> 778          * code, at the expense of contaminating the profiles.</span>
<span class="line-added"> 779          */</span>
<span class="line-added"> 780         private static final boolean CACHE_ENABLE;</span>
<span class="line-added"> 781 </span>
<span class="line-added"> 782         /**</span>
<span class="line-added"> 783          * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-added"> 784          */</span>
<span class="line-added"> 785         private static final ProxyClassesDumper DUMPER;</span>
<span class="line-added"> 786 </span>
<span class="line-added"> 787         static {</span>
<span class="line-added"> 788             CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-added"> 789                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="line-added"> 790             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-added"> 791 </span>
<span class="line-added"> 792             final String dumpPath =</span>
<span class="line-added"> 793                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-added"> 794 </span>
<span class="line-added"> 795             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="line-added"> 796         }</span>
<span class="line-added"> 797 </span>
 798         private BytecodeStringBuilderStrategy() {
 799             // no instantiation
 800         }
 801 
<span class="line-modified"> 802         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-added"> 803             String className = getClassName(lookup.lookupClass());</span>
<span class="line-added"> 804             Key key = null;</span>
<span class="line-added"> 805             if (CACHE_ENABLE) {</span>
<span class="line-added"> 806                 key = new Key(className, args, recipe);</span>
<span class="line-added"> 807                 MethodHandle mh = CACHE.get(key);</span>
<span class="line-added"> 808                 if (mh != null) {</span>
<span class="line-added"> 809                     return mh;</span>
<span class="line-added"> 810                 }</span>
<span class="line-added"> 811             }</span>
<span class="line-added"> 812 </span>
 813             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 814 
 815             cw.visit(CLASSFILE_VERSION,
 816                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
 817                     className,
 818                     null,
 819                     &quot;java/lang/Object&quot;,
 820                     null
 821             );
 822 
 823             MethodVisitor mv = cw.visitMethod(
 824                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,
 825                     METHOD_NAME,
 826                     args.toMethodDescriptorString(),
 827                     null,
 828                     null);
 829 
 830             // use of @ForceInline no longer has any effect
 831             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);
 832             mv.visitCode();
</pre>
<hr />
<pre>
1082             }
1083 
1084             mv.visitMethodInsn(
1085                     INVOKEVIRTUAL,
1086                     &quot;java/lang/StringBuilder&quot;,
1087                     &quot;toString&quot;,
1088                     &quot;()Ljava/lang/String;&quot;,
1089                     false
1090             );
1091 
1092             mv.visitInsn(ARETURN);
1093 
1094             mv.visitMaxs(-1, -1);
1095             mv.visitEnd();
1096             cw.visitEnd();
1097 
1098             byte[] classBytes = cw.toByteArray();
1099             try {
1100                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
1101                 dumpIfEnabled(className, classBytes);
<span class="line-modified">1102                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);</span>
<span class="line-added">1103                 if (CACHE_ENABLE) {</span>
<span class="line-added">1104                     CACHE.put(key, mh);</span>
<span class="line-added">1105                 }</span>
<span class="line-added">1106                 return mh;</span>
1107             } catch (Exception e) {
1108                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
1109                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
1110             }
1111         }
1112 
<span class="line-added">1113         /**</span>
<span class="line-added">1114          * The generated class is in the same package as the host class as</span>
<span class="line-added">1115          * it&#39;s the implementation of the string concatenation for the host</span>
<span class="line-added">1116          * class.</span>
<span class="line-added">1117          *</span>
<span class="line-added">1118          * When cache is enabled, we want to cache as much as we can.</span>
<span class="line-added">1119          */</span>
<span class="line-added">1120         private static String getClassName(Class&lt;?&gt; hostClass) {</span>
<span class="line-added">1121             if (CACHE_ENABLE) {</span>
<span class="line-added">1122                 String pkgName = hostClass.getPackageName();</span>
<span class="line-added">1123                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-added">1124             } else {</span>
<span class="line-added">1125                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-added">1126                         : hostClass.getName();</span>
<span class="line-added">1127                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-added">1128             }</span>
<span class="line-added">1129         }</span>
<span class="line-added">1130 </span>
1131         private static void dumpIfEnabled(String name, byte[] bytes) {
1132             if (DUMPER != null) {
1133                 DUMPER.dumpClass(name, bytes);
1134             }
1135         }
1136 
1137         private static String getSBAppendDesc(Class&lt;?&gt; cl) {
1138             if (cl.isPrimitive()) {
1139                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1140                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;
1141                 } else if (cl == Boolean.TYPE) {
1142                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;
1143                 } else if (cl == Character.TYPE) {
1144                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;
1145                 } else if (cl == Double.TYPE) {
1146                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;
1147                 } else if (cl == Float.TYPE) {
1148                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;
1149                 } else if (cl == Long.TYPE) {
1150                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;
</pre>
<hr />
<pre>
1489      * particular implementation details for String, this opens the door for
1490      * building a very optimal concatenation sequence. This is the only strategy
1491      * that requires porting if there are private JDK changes occur.
1492      */
1493     private static final class MethodHandleInlineCopyStrategy {
1494         private MethodHandleInlineCopyStrategy() {
1495             // no instantiation
1496         }
1497 
1498         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {
1499 
1500             // Fast-path two-argument Object + Object concatenations
1501             if (recipe.getElements().size() == 2) {
1502                 // Two object arguments
1503                 if (mt.parameterCount() == 2 &amp;&amp;
1504                     !mt.parameterType(0).isPrimitive() &amp;&amp;
1505                     !mt.parameterType(1).isPrimitive() &amp;&amp;
1506                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;
1507                     recipe.getElements().get(1).getTag() == TAG_ARG) {
1508 
<span class="line-modified">1509                     return simpleConcat();</span>
1510 
1511                 } else if (mt.parameterCount() == 1 &amp;&amp;
1512                            !mt.parameterType(0).isPrimitive()) {
1513                     // One Object argument, one constant
<span class="line-modified">1514                     MethodHandle mh = simpleConcat();</span>
1515 
1516                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;
1517                         recipe.getElements().get(1).getTag() == TAG_ARG) {
1518                         // First recipe element is a constant
1519                         return MethodHandles.insertArguments(mh, 0,
1520                                 recipe.getElements().get(0).getValue());
1521 
1522                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;
1523                                recipe.getElements().get(0).getTag() == TAG_ARG) {
1524                         // Second recipe element is a constant
1525                         return MethodHandles.insertArguments(mh, 1,
1526                                 recipe.getElements().get(1).getValue());
1527 
1528                     }
1529                 }
1530                 // else... fall-through to slow-path
1531             }
1532 
1533             // Create filters and obtain filtered parameter types. Filters would be used in the beginning
1534             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
</pre>
<hr />
<pre>
1536             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1537             MethodHandle[] filters = null;
1538             for (int i = 0; i &lt; ptypes.length; i++) {
1539                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);
1540                 if (filter != null) {
1541                     if (filters == null) {
1542                         filters = new MethodHandle[ptypes.length];
1543                     }
1544                     filters[i] = filter;
1545                     ptypes[i] = filter.type().returnType();
1546                 }
1547             }
1548 
1549             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
1550             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
1551             // assembled bottom-up, which makes the code arguably hard to read.
1552 
1553             // Drop all remaining parameter types, leave only helper arguments:
1554             MethodHandle mh;
1555 
<span class="line-modified">1556             mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
1557 
1558             long initialLengthCoder = INITIAL_CODER;
1559 
1560             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
1561             // known from the combinators below. We are assembling the string backwards, so the index coded
1562             // into indexCoder is the *ending* index.
1563 
1564             // We need one prepender per argument, but also need to fold in constants. We do so by greedily
1565             // create prependers that fold in surrounding constants into the argument prepender. This reduces
1566             // the number of unique MH combinator tree shapes we&#39;ll create in an application.
1567             String prefixConstant = null, suffixConstant = null;
1568             int pos = -1;
1569             for (RecipeElement el : recipe.getElements()) {
1570                 // Do the prepend, and put &quot;new&quot; index at index 1
1571                 switch (el.getTag()) {
1572                     case TAG_CONST: {
1573                         String constantValue = el.getValue();
1574 
1575                         // Eagerly update the initialLengthCoder value
1576                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);
</pre>
<hr />
<pre>
1607 
1608             // Insert any trailing args, constants
1609             if (pos &gt;= 0) {
1610                 mh = MethodHandles.filterArgumentsWithCombiner(
1611                     mh, 1,
1612                     prepender(prefixConstant, ptypes[pos], suffixConstant),
1613                     1, 0, // indexCoder, storage
1614                     2 + pos  // selected argument
1615                 );
1616             } else if (prefixConstant != null) {
1617                 assert (suffixConstant == null);
1618                 // Sole prefixConstant can only happen if there were no non-constant arguments
1619                 mh = MethodHandles.filterArgumentsWithCombiner(
1620                     mh, 1,
1621                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
1622                     1, 0 // indexCoder, storage
1623                 );
1624             }
1625 
1626             // Fold in byte[] instantiation at argument 0
<span class="line-modified">1627             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),</span>
1628                     1 // index
1629             );
1630 
1631             // Start combining length and coder mixers.
1632             //
1633             // Length is easy: constant lengths can be computed on the spot, and all non-constant
1634             // shapes have been either converted to Strings, or explicit methods for getting the
1635             // string length out of primitives are provided.
1636             //
1637             // Coders are more interesting. Only Object, String and char arguments (and constants)
1638             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
1639             // and deduce the coder from there. Arguments would be either converted to Strings
1640             // during the initial filtering, or handled by specializations in MIXERS.
1641             //
1642             // The method handle shape before all mixers are combined in is:
1643             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
1644             //
1645             // We will bind the initialLengthCoder value to the last mixer (the one that will be
1646             // executed first), then fold that in. This leaves the shape after all mixers are
1647             // combined in as:
</pre>
<hr />
<pre>
1681                         1 + ac // selected argument
1682                 );
1683             } else {
1684                 // No mixer (constants only concat), insert initialLengthCoder directly
1685                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
1686             }
1687 
1688             // The method handle shape here is (&lt;args&gt;).
1689 
1690             // Apply filters, converting the arguments:
1691             if (filters != null) {
1692                 mh = MethodHandles.filterArguments(mh, 0, filters);
1693             }
1694 
1695             return mh;
1696         }
1697 
1698         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
1699             return MethodHandles.insertArguments(
1700                     MethodHandles.insertArguments(
<span class="line-modified">1701                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);</span>
1702         }
1703 
1704         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1705             return MIXERS.computeIfAbsent(cl, MIX);
1706         }
1707 
1708         // This one is deliberately non-lambdified to optimize startup time:
1709         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
1710             @Override
1711             public MethodHandle apply(Class&lt;?&gt; c) {
1712                 return JLA.stringConcatHelper(&quot;prepend&quot;,
1713                             methodType(long.class, long.class, byte[].class,
1714                                        String.class, Wrapper.asPrimitiveType(c), String.class));
1715             }
1716         };
1717 
1718         // This one is deliberately non-lambdified to optimize startup time:
1719         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
1720             @Override
1721             public MethodHandle apply(Class&lt;?&gt; c) {
1722                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));
1723             }
1724         };
1725 
<span class="line-modified">1726         private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="line-modified">1727         private static MethodHandle simpleConcat() {</span>
<span class="line-modified">1728             if (SIMPLE_CONCAT == null) {</span>
<span class="line-added">1729                 SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
<span class="line-added">1730             }</span>
<span class="line-added">1731             return SIMPLE_CONCAT;</span>
<span class="line-added">1732         }</span>
<span class="line-added">1733 </span>
<span class="line-added">1734         private @Stable static MethodHandle NEW_STRING;</span>
<span class="line-added">1735         private static MethodHandle newString() {</span>
<span class="line-added">1736             MethodHandle mh = NEW_STRING;</span>
<span class="line-added">1737             if (mh == null) {</span>
<span class="line-added">1738                 NEW_STRING = mh =</span>
<span class="line-added">1739                     JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));</span>
<span class="line-added">1740             }</span>
<span class="line-added">1741             return mh;</span>
<span class="line-added">1742         }</span>
<span class="line-added">1743         private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="line-added">1744         private static MethodHandle newArray() {</span>
<span class="line-added">1745             MethodHandle mh = NEW_ARRAY;</span>
<span class="line-added">1746             if (mh == null) {</span>
<span class="line-added">1747                 NEW_ARRAY = mh =</span>
<span class="line-added">1748                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));</span>
<span class="line-added">1749             }</span>
<span class="line-added">1750             return mh;</span>
<span class="line-added">1751         }</span>
<span class="line-added">1752 </span>
1753         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1754         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1755         private static final long INITIAL_CODER;
1756 
1757         static {
<span class="line-modified">1758             INITIAL_CODER = JLA.stringConcatInitialCoder();</span>






1759             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1760             MIXERS = new ConcurrentHashMap&lt;&gt;();




1761         }
1762     }
1763 
1764     /**
1765      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1766      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1767      */
1768     private static final class Stringifiers {
1769         private Stringifiers() {
1770             // no instantiation
1771         }
1772 
1773         private static final MethodHandle OBJECT_INSTANCE =
1774                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));
1775 
1776         private static class FloatStringifiers {
1777             private static final MethodHandle FLOAT_INSTANCE =
1778                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1779 
1780             private static final MethodHandle DOUBLE_INSTANCE =
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../net/DatagramSocket.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
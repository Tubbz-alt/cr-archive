<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.misc.Unsafe;
  31 import jdk.internal.misc.VM;
  32 import jdk.internal.org.objectweb.asm.ClassWriter;
  33 import jdk.internal.org.objectweb.asm.Label;
  34 import jdk.internal.org.objectweb.asm.MethodVisitor;
  35 import jdk.internal.org.objectweb.asm.Opcodes;
  36 import jdk.internal.vm.annotation.Stable;
  37 import sun.invoke.util.Wrapper;
  38 
  39 import java.lang.invoke.MethodHandles.Lookup;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.List;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 import java.util.function.Function;
  47 
  48 import static java.lang.invoke.MethodHandles.lookup;
  49 import static java.lang.invoke.MethodType.methodType;
  50 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;
  51 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  52 
  53 /**
  54  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  55  * can be used to efficiently concatenate a known number of arguments of known
  56  * types, possibly after type adaptation and partial evaluation of arguments.
  57  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
  58  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
  59  * feature of the Java Programming Language.
  60  *
  61  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
  62  * MethodHandle} proceeds in order through two phases:
  63  *
  64  * &lt;ol&gt;
  65  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
  66  * They take as arguments a method type describing the concatenated arguments
  67  * count and types, and optionally the String &lt;em&gt;recipe&lt;/em&gt;, plus the
  68  * constants that participate in the String concatenation. The details on
  69  * accepted recipe shapes are described further below. Linkage may involve
  70  * dynamically loading a new class that implements the expected concatenation
  71  * behavior. The {@code CallSite} holds the {@code MethodHandle} pointing to the
  72  * exact concatenation method. The concatenation methods may be shared among
  73  * different {@code CallSite}s, e.g. if linkage methods produce them as pure
  74  * functions.&lt;/li&gt;
  75  *
  76  * &lt;li&gt;&lt;em&gt;Invocation&lt;/em&gt; occurs when a generated concatenation method is
  77  * invoked with the exact dynamic arguments. This may occur many times for a
  78  * single concatenation method. The method referenced by the behavior {@code
  79  * MethodHandle} is invoked with the static arguments and any additional dynamic
  80  * arguments provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.&lt;/li&gt;
  81  * &lt;/ol&gt;
  82  *
  83  * &lt;p&gt; This class provides two forms of linkage methods: a simple version
  84  * ({@link #makeConcat(java.lang.invoke.MethodHandles.Lookup, String,
  85  * MethodType)}) using only the dynamic arguments, and an advanced version
  86  * ({@link #makeConcatWithConstants(java.lang.invoke.MethodHandles.Lookup,
  87  * String, MethodType, String, Object...)} using the advanced forms of capturing
  88  * the constant arguments. The advanced strategy can produce marginally better
  89  * invocation bytecode, at the expense of exploding the number of shapes of
  90  * string concatenation methods present at runtime, because those shapes would
  91  * include constant static arguments as well.
  92  *
  93  * @author Aleksey Shipilev
  94  * @author Remi Forax
  95  * @author Peter Levart
  96  *
  97  * @apiNote
  98  * &lt;p&gt;There is a JVM limit (classfile structural constraint): no method
  99  * can call with more than 255 slots. This limits the number of static and
 100  * dynamic arguments one can pass to bootstrap method. Since there are potential
 101  * concatenation strategies that use {@code MethodHandle} combinators, we need
 102  * to reserve a few empty slots on the parameter lists to capture the
 103  * temporal results. This is why bootstrap methods in this factory do not accept
 104  * more than 200 argument slots. Users requiring more than 200 argument slots in
 105  * concatenation are expected to split the large concatenation in smaller
 106  * expressions.
 107  *
 108  * @since 9
 109  */
 110 public final class StringConcatFactory {
 111 
 112     /**
 113      * Tag used to demarcate an ordinary argument.
 114      */
 115     private static final char TAG_ARG = &#39;\u0001&#39;;
 116 
 117     /**
 118      * Tag used to demarcate a constant.
 119      */
 120     private static final char TAG_CONST = &#39;\u0002&#39;;
 121 
 122     /**
 123      * Maximum number of argument slots in String Concat call.
 124      *
 125      * While the maximum number of argument slots that indy call can handle is 253,
 126      * we do not use all those slots, to let the strategies with MethodHandle
 127      * combinators to use some arguments.
 128      */
 129     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 130 
 131     /**
 132      * Concatenation strategy to use. See {@link Strategy} for possible options.
 133      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.
 134      *
 135      * Defaults to MH_INLINE_SIZED_EXACT if not set.
 136      */
 137     private static final Strategy STRATEGY;
 138 
 139     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 140 
 141     private enum Strategy {
 142         /**
 143          * Bytecode generator, calling into {@link java.lang.StringBuilder}.
 144          */
 145         BC_SB,
 146 
 147         /**
 148          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 149          * but trying to estimate the required storage.
 150          */
 151         BC_SB_SIZED,
 152 
 153         /**
 154          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 155          * but computing the required storage exactly.
 156          */
 157         BC_SB_SIZED_EXACT,
 158 
 159         /**
 160          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 161          * This strategy also tries to estimate the required storage.
 162          */
 163         MH_SB_SIZED,
 164 
 165         /**
 166          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 167          * This strategy also estimate the required storage exactly.
 168          */
 169         MH_SB_SIZED_EXACT,
 170 
 171         /**
 172          * MethodHandle-based generator, that constructs its own byte[] array from
 173          * the arguments. It computes the required storage exactly.
 174          */
 175         MH_INLINE_SIZED_EXACT
 176     }
 177 
 178     /**
 179      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 180      * checks, etc.
 181      */
 182     private static final boolean DEBUG;
 183 
 184     static {
 185         final String strategy =
 186                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
 187         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);
 188 
 189         if (STRATEGY == null || STRATEGY == Strategy.MH_INLINE_SIZED_EXACT) {
 190             // Force initialization of default strategy:
 191             Unsafe.getUnsafe().ensureClassInitialized(MethodHandleInlineCopyStrategy.class);
 192         }
 193 
 194         DEBUG = Boolean.parseBoolean(
 195                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));
 196     }
 197 
 198     /**
 199      * Cache key is a composite of:
 200      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 201      *   - method type, describing the dynamic arguments for concatenation
 202      *   - concat recipe, describing the constants and concat shape
 203      */
 204     private static final class Key {
 205         final String className;
 206         final MethodType mt;
 207         final Recipe recipe;
 208 
 209         public Key(String className, MethodType mt, Recipe recipe) {
 210             this.className = className;
 211             this.mt = mt;
 212             this.recipe = recipe;
 213         }
 214 
 215         @Override
 216         public boolean equals(Object o) {
 217             if (this == o) return true;
 218             if (o == null || getClass() != o.getClass()) return false;
 219 
 220             Key key = (Key) o;
 221 
 222             if (!className.equals(key.className)) return false;
 223             if (!mt.equals(key.mt)) return false;
 224             if (!recipe.equals(key.recipe)) return false;
 225             return true;
 226         }
 227 
 228         @Override
 229         public int hashCode() {
 230             int result = className.hashCode();
 231             result = 31 * result + mt.hashCode();
 232             result = 31 * result + recipe.hashCode();
 233             return result;
 234         }
 235     }
 236 
 237     /**
 238      * Parses the recipe string, and produces a traversable collection of
 239      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 240      * strategies. Notably, this class parses out the constants from the recipe
 241      * and from other static arguments.
 242      */
 243     private static final class Recipe {
 244         private final List&lt;RecipeElement&gt; elements;
 245 
 246         public Recipe(String src, Object[] constants) {
 247             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 248 
 249             int constC = 0;
 250             int argC = 0;
 251 
 252             StringBuilder acc = new StringBuilder();
 253 
 254             for (int i = 0; i &lt; src.length(); i++) {
 255                 char c = src.charAt(i);
 256 
 257                 if (c == TAG_CONST || c == TAG_ARG) {
 258                     // Detected a special tag, flush all accumulated characters
 259                     // as a constant first:
 260                     if (acc.length() &gt; 0) {
 261                         el.add(new RecipeElement(acc.toString()));
 262                         acc.setLength(0);
 263                     }
 264                     if (c == TAG_CONST) {
 265                         Object cnst = constants[constC++];
 266                         el.add(new RecipeElement(cnst));
 267                     } else if (c == TAG_ARG) {
 268                         el.add(new RecipeElement(argC++));
 269                     }
 270                 } else {
 271                     // Not a special character, this is a constant embedded into
 272                     // the recipe itself.
 273                     acc.append(c);
 274                 }
 275             }
 276 
 277             // Flush the remaining characters as constant:
 278             if (acc.length() &gt; 0) {
 279                 el.add(new RecipeElement(acc.toString()));
 280             }
 281 
 282             elements = el;
 283         }
 284 
 285         public List&lt;RecipeElement&gt; getElements() {
 286             return elements;
 287         }
 288 
 289         @Override
 290         public boolean equals(Object o) {
 291             if (this == o) return true;
 292             if (o == null || getClass() != o.getClass()) return false;
 293 
 294             Recipe recipe = (Recipe) o;
 295             return elements.equals(recipe.elements);
 296         }
 297 
 298         @Override
 299         public String toString() {
 300             return &quot;Recipe{&quot; +
 301                     &quot;elements=&quot; + elements +
 302                     &#39;}&#39;;
 303         }
 304 
 305         @Override
 306         public int hashCode() {
 307             return elements.hashCode();
 308         }
 309     }
 310 
 311     private static final class RecipeElement {
 312         private final String value;
 313         private final int argPos;
 314         private final char tag;
 315 
 316         public RecipeElement(Object cnst) {
 317             this.value = String.valueOf(Objects.requireNonNull(cnst));
 318             this.argPos = -1;
 319             this.tag = TAG_CONST;
 320         }
 321 
 322         public RecipeElement(int arg) {
 323             this.value = null;
 324             this.argPos = arg;
 325             this.tag = TAG_ARG;
 326         }
 327 
 328         public String getValue() {
 329             assert (tag == TAG_CONST);
 330             return value;
 331         }
 332 
 333         public int getArgPos() {
 334             assert (tag == TAG_ARG);
 335             return argPos;
 336         }
 337 
 338         public char getTag() {
 339             return tag;
 340         }
 341 
 342         @Override
 343         public boolean equals(Object o) {
 344             if (this == o) return true;
 345             if (o == null || getClass() != o.getClass()) return false;
 346 
 347             RecipeElement that = (RecipeElement) o;
 348 
 349             if (this.tag != that.tag) return false;
 350             if (this.tag == TAG_CONST &amp;&amp; (!value.equals(that.value))) return false;
 351             if (this.tag == TAG_ARG &amp;&amp; (argPos != that.argPos)) return false;
 352             return true;
 353         }
 354 
 355         @Override
 356         public String toString() {
 357             return &quot;RecipeElement{&quot; +
 358                     &quot;value=&#39;&quot; + value + &#39;\&#39;&#39; +
 359                     &quot;, argPos=&quot; + argPos +
 360                     &quot;, tag=&quot; + tag +
 361                     &#39;}&#39;;
 362         }
 363 
 364         @Override
 365         public int hashCode() {
 366             return (int)tag;
 367         }
 368     }
 369 
 370     // StringConcatFactory bootstrap methods are startup sensitive, and may be
 371     // special cased in java.lang.invokeBootstrapMethodInvoker to ensure
 372     // methods are invoked with exact type information to avoid generating
 373     // code for runtime checks. Take care any changes or additions here are
 374     // reflected there as appropriate.
 375 
 376     /**
 377      * Facilitates the creation of optimized String concatenation methods, that
 378      * can be used to efficiently concatenate a known number of arguments of
 379      * known types, possibly after type adaptation and partial evaluation of
 380      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 381      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 382      * feature of the Java Programming Language.
 383      *
 384      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 385      * invoked, it returns the result of String concatenation, taking all
 386      * function arguments passed to the linkage method as inputs for
 387      * concatenation. The target signature is given by {@code concatType}.
 388      * For a target accepting:
 389      * &lt;ul&gt;
 390      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 391      *     &lt;li&gt;one input, concatenation results in the single
 392      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
 393      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
 394      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
 395      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
 396      *     and combined from left to right.&lt;/li&gt;
 397      * &lt;/ul&gt;
 398      *
 399      * &lt;p&gt;Assume the linkage arguments are as follows:
 400      *
 401      * &lt;ul&gt;
 402      *     &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 403      * &lt;/ul&gt;
 404      *
 405      * &lt;p&gt;Then the following linkage invariants must hold:
 406      *
 407      * &lt;ul&gt;
 408      *     &lt;li&gt;The number of parameter slots in {@code concatType} is
 409      *         less than or equal to 200&lt;/li&gt;
 410      *     &lt;li&gt;The return type in {@code concatType} is assignable from {@link java.lang.String}&lt;/li&gt;
 411      * &lt;/ul&gt;
 412      *
 413      * @param lookup   Represents a lookup context with the accessibility
 414      *                 privileges of the caller. Specifically, the lookup
 415      *                 context must have
 416      *                 {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
 417      *                 full privilege access}.
 418      *                 When used with {@code invokedynamic}, this is stacked
 419      *                 automatically by the VM.
 420      * @param name     The name of the method to implement. This name is
 421      *                 arbitrary, and has no meaning for this linkage method.
 422      *                 When used with {@code invokedynamic}, this is provided by
 423      *                 the {@code NameAndType} of the {@code InvokeDynamic}
 424      *                 structure and is stacked automatically by the VM.
 425      * @param concatType The expected signature of the {@code CallSite}.  The
 426      *                   parameter types represent the types of concatenation
 427      *                   arguments; the return type is always assignable from {@link
 428      *                   java.lang.String}.  When used with {@code invokedynamic},
 429      *                   this is provided by the {@code NameAndType} of the {@code
 430      *                   InvokeDynamic} structure and is stacked automatically by
 431      *                   the VM.
 432      * @return a CallSite whose target can be used to perform String
 433      * concatenation, with dynamic concatenation arguments described by the given
 434      * {@code concatType}.
 435      * @throws StringConcatException If any of the linkage invariants described
 436      *                               here are violated, or the lookup context
 437      *                               does not have private access privileges.
 438      * @throws NullPointerException If any of the incoming arguments is null.
 439      *                              This will never happen when a bootstrap method
 440      *                              is called with invokedynamic.
 441      *
 442      * @jls  5.1.11 String Conversion
 443      * @jls 15.18.1 String Concatenation Operator +
 444      */
 445     public static CallSite makeConcat(MethodHandles.Lookup lookup,
 446                                       String name,
 447                                       MethodType concatType) throws StringConcatException {
 448         if (DEBUG) {
 449             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType);
 450         }
 451 
 452         return doStringConcat(lookup, name, concatType, true, null);
 453     }
 454 
 455     /**
 456      * Facilitates the creation of optimized String concatenation methods, that
 457      * can be used to efficiently concatenate a known number of arguments of
 458      * known types, possibly after type adaptation and partial evaluation of
 459      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 460      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 461      * feature of the Java Programming Language.
 462      *
 463      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 464      * invoked, it returns the result of String concatenation, taking all
 465      * function arguments and constants passed to the linkage method as inputs for
 466      * concatenation. The target signature is given by {@code concatType}, and
 467      * does not include constants.
 468      * For a target accepting:
 469      * &lt;ul&gt;
 470      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 471      *     &lt;li&gt;one input, concatenation results in the single
 472      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
 473      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
 474      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
 475      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
 476      *     and combined from left to right.&lt;/li&gt;
 477      * &lt;/ul&gt;
 478      *
 479      * &lt;p&gt;The concatenation &lt;em&gt;recipe&lt;/em&gt; is a String description for the way to
 480      * construct a concatenated String from the arguments and constants. The
 481      * recipe is processed from left to right, and each character represents an
 482      * input to concatenation. Recipe characters mean:
 483      *
 484      * &lt;ul&gt;
 485      *
 486      *   &lt;li&gt;&lt;em&gt;\1 (Unicode point 0001)&lt;/em&gt;: an ordinary argument. This
 487      *   input is passed through dynamic argument, and is provided during the
 488      *   concatenation method invocation. This input can be null.&lt;/li&gt;
 489      *
 490      *   &lt;li&gt;&lt;em&gt;\2 (Unicode point 0002):&lt;/em&gt; a constant. This input passed
 491      *   through static bootstrap argument. This constant can be any value
 492      *   representable in constant pool. If necessary, the factory would call
 493      *   {@code toString} to perform a one-time String conversion.&lt;/li&gt;
 494      *
 495      *   &lt;li&gt;&lt;em&gt;Any other char value:&lt;/em&gt; a single character constant.&lt;/li&gt;
 496      * &lt;/ul&gt;
 497      *
 498      * &lt;p&gt;Assume the linkage arguments are as follows:
 499      *
 500      * &lt;ul&gt;
 501      *   &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 502      *   &lt;li&gt;{@code recipe}, describing the String recipe&lt;/li&gt;
 503      *   &lt;li&gt;{@code constants}, the vararg array of constants&lt;/li&gt;
 504      * &lt;/ul&gt;
 505      *
 506      * &lt;p&gt;Then the following linkage invariants must hold:
 507      *
 508      * &lt;ul&gt;
 509      *   &lt;li&gt;The number of parameter slots in {@code concatType} is less than
 510      *       or equal to 200&lt;/li&gt;
 511      *
 512      *   &lt;li&gt;The parameter count in {@code concatType} is equal to number of \1 tags
 513      *   in {@code recipe}&lt;/li&gt;
 514      *
 515      *   &lt;li&gt;The return type in {@code concatType} is assignable
 516      *   from {@link java.lang.String}, and matches the return type of the
 517      *   returned {@link MethodHandle}&lt;/li&gt;
 518      *
 519      *   &lt;li&gt;The number of elements in {@code constants} is equal to number of \2
 520      *   tags in {@code recipe}&lt;/li&gt;
 521      * &lt;/ul&gt;
 522      *
 523      * @param lookup    Represents a lookup context with the accessibility
 524      *                  privileges of the caller. Specifically, the lookup
 525      *                  context must have
 526      *                  {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
 527      *                  full privilege access}.
 528      *                  When used with {@code invokedynamic}, this is stacked
 529      *                  automatically by the VM.
 530      * @param name      The name of the method to implement. This name is
 531      *                  arbitrary, and has no meaning for this linkage method.
 532      *                  When used with {@code invokedynamic}, this is provided
 533      *                  by the {@code NameAndType} of the {@code InvokeDynamic}
 534      *                  structure and is stacked automatically by the VM.
 535      * @param concatType The expected signature of the {@code CallSite}.  The
 536      *                  parameter types represent the types of dynamic concatenation
 537      *                  arguments; the return type is always assignable from {@link
 538      *                  java.lang.String}.  When used with {@code
 539      *                  invokedynamic}, this is provided by the {@code
 540      *                  NameAndType} of the {@code InvokeDynamic} structure and
 541      *                  is stacked automatically by the VM.
 542      * @param recipe    Concatenation recipe, described above.
 543      * @param constants A vararg parameter representing the constants passed to
 544      *                  the linkage method.
 545      * @return a CallSite whose target can be used to perform String
 546      * concatenation, with dynamic concatenation arguments described by the given
 547      * {@code concatType}.
 548      * @throws StringConcatException If any of the linkage invariants described
 549      *                               here are violated, or the lookup context
 550      *                               does not have private access privileges.
 551      * @throws NullPointerException If any of the incoming arguments is null, or
 552      *                              any constant in {@code recipe} is null.
 553      *                              This will never happen when a bootstrap method
 554      *                              is called with invokedynamic.
 555      * @apiNote Code generators have three distinct ways to process a constant
 556      * string operand S in a string concatenation expression.  First, S can be
 557      * materialized as a reference (using ldc) and passed as an ordinary argument
 558      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
 559      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
 560      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
 561      * itself, causing its characters to be inserted into the result.
 562      *
 563      * @jls  5.1.11 String Conversion
 564      * @jls 15.18.1 String Concatenation Operator +
 565      */
 566     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
 567                                                    String name,
 568                                                    MethodType concatType,
 569                                                    String recipe,
 570                                                    Object... constants) throws StringConcatException {
 571         if (DEBUG) {
 572             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType + &quot;, {&quot; + recipe + &quot;}, &quot; + Arrays.toString(constants));
 573         }
 574 
 575         return doStringConcat(lookup, name, concatType, false, recipe, constants);
 576     }
 577 
 578     private static CallSite doStringConcat(MethodHandles.Lookup lookup,
 579                                            String name,
 580                                            MethodType concatType,
 581                                            boolean generateRecipe,
 582                                            String recipe,
 583                                            Object... constants) throws StringConcatException {
 584         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
 585         Objects.requireNonNull(name, &quot;Name is null&quot;);
 586         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
 587         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
 588 
 589         for (Object o : constants) {
 590             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);
 591         }
 592 
 593         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
 594             throw new StringConcatException(&quot;Invalid caller: &quot; +
 595                     lookup.lookupClass().getName());
 596         }
 597 
 598         int cCount = 0;
 599         int oCount = 0;
 600         if (generateRecipe) {
 601             // Mock the recipe to reuse the concat generator code
 602             char[] value = new char[concatType.parameterCount()];
 603             Arrays.fill(value, TAG_ARG);
 604             recipe = new String(value);
 605             oCount = concatType.parameterCount();
 606         } else {
 607             Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);
 608 
 609             for (int i = 0; i &lt; recipe.length(); i++) {
 610                 char c = recipe.charAt(i);
 611                 if (c == TAG_CONST) cCount++;
 612                 if (c == TAG_ARG)   oCount++;
 613             }
 614         }
 615 
 616         if (oCount != concatType.parameterCount()) {
 617             throw new StringConcatException(
 618                     &quot;Mismatched number of concat arguments: recipe wants &quot; +
 619                             oCount +
 620                             &quot; arguments, but signature provides &quot; +
 621                             concatType.parameterCount());
 622         }
 623 
 624         if (cCount != constants.length) {
 625             throw new StringConcatException(
 626                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 627                             cCount +
 628                             &quot; constants, but only &quot; +
 629                             constants.length +
 630                             &quot; are passed&quot;);
 631         }
 632 
 633         if (!concatType.returnType().isAssignableFrom(String.class)) {
 634             throw new StringConcatException(
 635                     &quot;The return type should be compatible with String, but it is &quot; +
 636                             concatType.returnType());
 637         }
 638 
 639         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 640             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 641                     concatType.parameterSlotCount() +
 642                     &quot;, can only accept &quot; +
 643                     MAX_INDY_CONCAT_ARG_SLOTS);
 644         }
 645 
 646         MethodType mt = adaptType(concatType);
 647         Recipe rec = new Recipe(recipe, constants);
 648         MethodHandle mh = generate(lookup, mt, rec);
 649         return new ConstantCallSite(mh.asType(concatType));
 650     }
 651 
 652     /**
 653      * Adapt method type to an API we are going to use.
 654      *
 655      * This strips the concrete classes from the signatures, thus preventing
 656      * class leakage when we cache the concatenation stubs.
 657      *
 658      * @param args actual argument types
 659      * @return argument types the strategy is going to use
 660      */
 661     private static MethodType adaptType(MethodType args) {
 662         Class&lt;?&gt;[] ptypes = null;
 663         for (int i = 0; i &lt; args.parameterCount(); i++) {
 664             Class&lt;?&gt; ptype = args.parameterType(i);
 665             if (!ptype.isPrimitive() &amp;&amp;
 666                     ptype != String.class &amp;&amp;
 667                     ptype != Object.class) { // truncate to Object
 668                 if (ptypes == null) {
 669                     ptypes = args.parameterArray();
 670                 }
 671                 ptypes[i] = Object.class;
 672             }
 673             // else other primitives or String or Object (unchanged)
 674         }
 675         return (ptypes != null)
 676                 ? MethodType.methodType(args.returnType(), ptypes)
 677                 : args;
 678     }
 679 
 680     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
 681         try {
 682             if (STRATEGY == null) {
 683                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);
 684             }
 685             switch (STRATEGY) {
 686                 case BC_SB:
 687                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);
 688                 case BC_SB_SIZED:
 689                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);
 690                 case BC_SB_SIZED_EXACT:
 691                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);
 692                 case MH_SB_SIZED:
 693                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
 694                 case MH_SB_SIZED_EXACT:
 695                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
 696                 case MH_INLINE_SIZED_EXACT:
 697                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);
 698                 default:
 699                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);
 700             }
 701         } catch (Error | StringConcatException e) {
 702             // Pass through any error or existing StringConcatException
 703             throw e;
 704         } catch (Throwable t) {
 705             throw new StringConcatException(&quot;Generator failed&quot;, t);
 706         }
 707     }
 708 
 709     private enum Mode {
 710         DEFAULT(false, false),
 711         SIZED(true, false),
 712         SIZED_EXACT(true, true);
 713 
 714         private final boolean sized;
 715         private final boolean exact;
 716 
 717         Mode(boolean sized, boolean exact) {
 718             this.sized = sized;
 719             this.exact = exact;
 720         }
 721 
 722         boolean isSized() {
 723             return sized;
 724         }
 725 
 726         boolean isExact() {
 727             return exact;
 728         }
 729     }
 730 
 731     /**
 732      * Bytecode StringBuilder strategy.
 733      *
 734      * &lt;p&gt;This strategy operates in three modes, gated by {@link Mode}.
 735      *
 736      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB}: &quot;bytecode StringBuilder&quot;.&lt;/b&gt;
 737      *
 738      * &lt;p&gt;This strategy spins up the bytecode that has the same StringBuilder
 739      * chain javac would otherwise emit. This strategy uses only the public API,
 740      * and comes as the baseline for the current JDK behavior. On other words,
 741      * this strategy moves the javac generated bytecode to runtime. The
 742      * generated bytecode is loaded via Lookup::defineClass, but with
 743      * the caller class coming from the BSM -- in other words, the protection
 744      * guarantees are inherited from the method where invokedynamic was
 745      * originally called. This means, among other things, that the bytecode is
 746      * verified for all non-JDK uses.
 747      *
 748      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED}: &quot;bytecode StringBuilder, but
 749      * sized&quot;.&lt;/b&gt;
 750      *
 751      * &lt;p&gt;This strategy acts similarly to {@link Strategy#BC_SB}, but it also
 752      * tries to guess the capacity required for StringBuilder to accept all
 753      * arguments without resizing. This strategy only makes an educated guess:
 754      * it only guesses the space required for known types (e.g. primitives and
 755      * Strings), but does not otherwise convert arguments. Therefore, the
 756      * capacity estimate may be wrong, and StringBuilder may have to
 757      * transparently resize or trim when doing the actual concatenation. While
 758      * this does not constitute a correctness issue (in the end, that what BC_SB
 759      * has to do anyway), this does pose a potential performance problem.
 760      *
 761      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but
 762      * sized exactly&quot;.&lt;/b&gt;
 763      *
 764      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first
 765      * converting all arguments to String in order to get the exact capacity
 766      * StringBuilder should have. The conversion is done via the public
 767      * String.valueOf and/or Object.toString methods, and does not touch any
 768      * private String API.
 769      */
 770     private static final class BytecodeStringBuilderStrategy {
 771         static final int CLASSFILE_VERSION = 52;
 772         static final String METHOD_NAME = &quot;concat&quot;;
 773 
 774         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;
 775 
 776         /**
 777          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated
 778          * code, at the expense of contaminating the profiles.
 779          */
 780         private static final boolean CACHE_ENABLE;
 781 
 782         /**
 783          * Dump generated classes to disk, for debugging purposes.
 784          */
 785         private static final ProxyClassesDumper DUMPER;
 786 
 787         static {
 788             CACHE_ENABLE = Boolean.parseBoolean(
 789                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));
 790             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;
 791 
 792             final String dumpPath =
 793                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);
 794 
 795             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);
 796         }
 797 
 798         private BytecodeStringBuilderStrategy() {
 799             // no instantiation
 800         }
 801 
 802         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {
 803             String className = getClassName(lookup.lookupClass());
 804             Key key = null;
 805             if (CACHE_ENABLE) {
 806                 key = new Key(className, args, recipe);
 807                 MethodHandle mh = CACHE.get(key);
 808                 if (mh != null) {
 809                     return mh;
 810                 }
 811             }
 812 
 813             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 814 
 815             cw.visit(CLASSFILE_VERSION,
 816                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
 817                     className,
 818                     null,
 819                     &quot;java/lang/Object&quot;,
 820                     null
 821             );
 822 
 823             MethodVisitor mv = cw.visitMethod(
 824                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,
 825                     METHOD_NAME,
 826                     args.toMethodDescriptorString(),
 827                     null,
 828                     null);
 829 
 830             // use of @ForceInline no longer has any effect
 831             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);
 832             mv.visitCode();
 833 
 834             Class&lt;?&gt;[] arr = args.parameterArray();
 835             boolean[] guaranteedNonNull = new boolean[arr.length];
 836 
 837             if (mode.isExact()) {
 838                 /*
 839                     In exact mode, we need to convert all arguments to their String representations,
 840                     as this allows to compute their String sizes exactly. We cannot use private
 841                     methods for primitives in here, therefore we need to convert those as well.
 842 
 843                     We also record what arguments are guaranteed to be non-null as the result
 844                     of the conversion. String.valueOf does the null checks for us. The only
 845                     corner case to take care of is String.valueOf(Object) returning null itself.
 846 
 847                     Also, if any conversion happened, then the slot indices in the incoming
 848                     arguments are not equal to the final local maps. The only case this may break
 849                     is when converting 2-slot long/double argument to 1-slot String. Therefore,
 850                     we get away with tracking modified offset, since no conversion can overwrite
 851                     the upcoming the argument.
 852                  */
 853 
 854                 int off = 0;
 855                 int modOff = 0;
 856                 for (int c = 0; c &lt; arr.length; c++) {
 857                     Class&lt;?&gt; cl = arr[c];
 858                     if (cl == String.class) {
 859                         if (off != modOff) {
 860                             mv.visitIntInsn(getLoadOpcode(cl), off);
 861                             mv.visitIntInsn(ASTORE, modOff);
 862                         }
 863                     } else {
 864                         mv.visitIntInsn(getLoadOpcode(cl), off);
 865                         mv.visitMethodInsn(
 866                                 INVOKESTATIC,
 867                                 &quot;java/lang/String&quot;,
 868                                 &quot;valueOf&quot;,
 869                                 getStringValueOfDesc(cl),
 870                                 false
 871                         );
 872                         mv.visitIntInsn(ASTORE, modOff);
 873                         arr[c] = String.class;
 874                         guaranteedNonNull[c] = cl.isPrimitive();
 875                     }
 876                     off += getParameterSize(cl);
 877                     modOff += getParameterSize(String.class);
 878                 }
 879             }
 880 
 881             if (mode.isSized()) {
 882                 /*
 883                     When operating in sized mode (this includes exact mode), it makes sense to make
 884                     StringBuilder append chains look familiar to OptimizeStringConcat. For that, we
 885                     need to do null-checks early, not make the append chain shape simpler.
 886                  */
 887 
 888                 int off = 0;
 889                 for (RecipeElement el : recipe.getElements()) {
 890                     switch (el.getTag()) {
 891                         case TAG_CONST:
 892                             // Guaranteed non-null, no null check required.
 893                             break;
 894                         case TAG_ARG:
 895                             // Null-checks are needed only for String arguments, and when a previous stage
 896                             // did not do implicit null-checks. If a String is null, we eagerly replace it
 897                             // with &quot;null&quot; constant. Note, we omit Objects here, because we don&#39;t call
 898                             // .length() on them down below.
 899                             int ac = el.getArgPos();
 900                             Class&lt;?&gt; cl = arr[ac];
 901                             if (cl == String.class &amp;&amp; !guaranteedNonNull[ac]) {
 902                                 Label l0 = new Label();
 903                                 mv.visitIntInsn(ALOAD, off);
 904                                 mv.visitJumpInsn(IFNONNULL, l0);
 905                                 mv.visitLdcInsn(&quot;null&quot;);
 906                                 mv.visitIntInsn(ASTORE, off);
 907                                 mv.visitLabel(l0);
 908                             }
 909                             off += getParameterSize(cl);
 910                             break;
 911                         default:
 912                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
 913                     }
 914                 }
 915             }
 916 
 917             // Prepare StringBuilder instance
 918             mv.visitTypeInsn(NEW, &quot;java/lang/StringBuilder&quot;);
 919             mv.visitInsn(DUP);
 920 
 921             if (mode.isSized()) {
 922                 /*
 923                     Sized mode requires us to walk through the arguments, and estimate the final length.
 924                     In exact mode, this will operate on Strings only. This code would accumulate the
 925                     final length on stack.
 926                  */
 927                 int len = 0;
 928                 int off = 0;
 929 
 930                 mv.visitInsn(ICONST_0);
 931 
 932                 for (RecipeElement el : recipe.getElements()) {
 933                     switch (el.getTag()) {
 934                         case TAG_CONST:
 935                             len += el.getValue().length();
 936                             break;
 937                         case TAG_ARG:
 938                             /*
 939                                 If an argument is String, then we can call .length() on it. Sized/Exact modes have
 940                                 converted arguments for us. If an argument is primitive, we can provide a guess
 941                                 for its String representation size.
 942                             */
 943                             Class&lt;?&gt; cl = arr[el.getArgPos()];
 944                             if (cl == String.class) {
 945                                 mv.visitIntInsn(ALOAD, off);
 946                                 mv.visitMethodInsn(
 947                                         INVOKEVIRTUAL,
 948                                         &quot;java/lang/String&quot;,
 949                                         &quot;length&quot;,
 950                                         &quot;()I&quot;,
 951                                         false
 952                                 );
 953                                 mv.visitInsn(IADD);
 954                             } else if (cl.isPrimitive()) {
 955                                 len += estimateSize(cl);
 956                             }
 957                             off += getParameterSize(cl);
 958                             break;
 959                         default:
 960                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
 961                     }
 962                 }
 963 
 964                 // Constants have non-zero length, mix in
 965                 if (len &gt; 0) {
 966                     iconst(mv, len);
 967                     mv.visitInsn(IADD);
 968                 }
 969 
 970                 mv.visitMethodInsn(
 971                         INVOKESPECIAL,
 972                         &quot;java/lang/StringBuilder&quot;,
 973                         &quot;&lt;init&gt;&quot;,
 974                         &quot;(I)V&quot;,
 975                         false
 976                 );
 977             } else {
 978                 mv.visitMethodInsn(
 979                         INVOKESPECIAL,
 980                         &quot;java/lang/StringBuilder&quot;,
 981                         &quot;&lt;init&gt;&quot;,
 982                         &quot;()V&quot;,
 983                         false
 984                 );
 985             }
 986 
 987             // At this point, we have a blank StringBuilder on stack, fill it in with .append calls.
 988             {
 989                 int off = 0;
 990                 for (RecipeElement el : recipe.getElements()) {
 991                     String desc;
 992                     switch (el.getTag()) {
 993                         case TAG_CONST:
 994                             mv.visitLdcInsn(el.getValue());
 995                             desc = getSBAppendDesc(String.class);
 996                             break;
 997                         case TAG_ARG:
 998                             Class&lt;?&gt; cl = arr[el.getArgPos()];
 999                             mv.visitVarInsn(getLoadOpcode(cl), off);
1000                             off += getParameterSize(cl);
1001                             desc = getSBAppendDesc(cl);
1002                             break;
1003                         default:
1004                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1005                     }
1006 
1007                     mv.visitMethodInsn(
1008                             INVOKEVIRTUAL,
1009                             &quot;java/lang/StringBuilder&quot;,
1010                             &quot;append&quot;,
1011                             desc,
1012                             false
1013                     );
1014                 }
1015             }
1016 
1017             if (DEBUG &amp;&amp; mode.isExact()) {
1018                 /*
1019                     Exactness checks compare the final StringBuilder.capacity() with a resulting
1020                     String.length(). If these values disagree, that means StringBuilder had to perform
1021                     storage trimming, which defeats the purpose of exact strategies.
1022                  */
1023 
1024                 /*
1025                    The logic for this check is as follows:
1026 
1027                      Stack before:     Op:
1028                       (SB)              dup, dup
1029                       (SB, SB, SB)      capacity()
1030                       (int, SB, SB)     swap
1031                       (SB, int, SB)     toString()
1032                       (S, int, SB)      length()
1033                       (int, int, SB)    if_icmpeq
1034                       (SB)              &lt;end&gt;
1035 
1036                    Note that it leaves the same StringBuilder on exit, like the one on enter.
1037                  */
1038 
1039                 mv.visitInsn(DUP);
1040                 mv.visitInsn(DUP);
1041 
1042                 mv.visitMethodInsn(
1043                         INVOKEVIRTUAL,
1044                         &quot;java/lang/StringBuilder&quot;,
1045                         &quot;capacity&quot;,
1046                         &quot;()I&quot;,
1047                         false
1048                 );
1049 
1050                 mv.visitInsn(SWAP);
1051 
1052                 mv.visitMethodInsn(
1053                         INVOKEVIRTUAL,
1054                         &quot;java/lang/StringBuilder&quot;,
1055                         &quot;toString&quot;,
1056                         &quot;()Ljava/lang/String;&quot;,
1057                         false
1058                 );
1059 
1060                 mv.visitMethodInsn(
1061                         INVOKEVIRTUAL,
1062                         &quot;java/lang/String&quot;,
1063                         &quot;length&quot;,
1064                         &quot;()I&quot;,
1065                         false
1066                 );
1067 
1068                 Label l0 = new Label();
1069                 mv.visitJumpInsn(IF_ICMPEQ, l0);
1070 
1071                 mv.visitTypeInsn(NEW, &quot;java/lang/AssertionError&quot;);
1072                 mv.visitInsn(DUP);
1073                 mv.visitLdcInsn(&quot;Failed exactness check&quot;);
1074                 mv.visitMethodInsn(INVOKESPECIAL,
1075                         &quot;java/lang/AssertionError&quot;,
1076                         &quot;&lt;init&gt;&quot;,
1077                         &quot;(Ljava/lang/Object;)V&quot;,
1078                         false);
1079                 mv.visitInsn(ATHROW);
1080 
1081                 mv.visitLabel(l0);
1082             }
1083 
1084             mv.visitMethodInsn(
1085                     INVOKEVIRTUAL,
1086                     &quot;java/lang/StringBuilder&quot;,
1087                     &quot;toString&quot;,
1088                     &quot;()Ljava/lang/String;&quot;,
1089                     false
1090             );
1091 
1092             mv.visitInsn(ARETURN);
1093 
1094             mv.visitMaxs(-1, -1);
1095             mv.visitEnd();
1096             cw.visitEnd();
1097 
1098             byte[] classBytes = cw.toByteArray();
1099             try {
1100                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
1101                 dumpIfEnabled(className, classBytes);
1102                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);
1103                 if (CACHE_ENABLE) {
1104                     CACHE.put(key, mh);
1105                 }
1106                 return mh;
1107             } catch (Exception e) {
1108                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
1109                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
1110             }
1111         }
1112 
1113         /**
1114          * The generated class is in the same package as the host class as
1115          * it&#39;s the implementation of the string concatenation for the host
1116          * class.
1117          *
1118          * When cache is enabled, we want to cache as much as we can.
1119          */
1120         private static String getClassName(Class&lt;?&gt; hostClass) {
1121             if (CACHE_ENABLE) {
1122                 String pkgName = hostClass.getPackageName();
1123                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;
1124             } else {
1125                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)
1126                         : hostClass.getName();
1127                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;
1128             }
1129         }
1130 
1131         private static void dumpIfEnabled(String name, byte[] bytes) {
1132             if (DUMPER != null) {
1133                 DUMPER.dumpClass(name, bytes);
1134             }
1135         }
1136 
1137         private static String getSBAppendDesc(Class&lt;?&gt; cl) {
1138             if (cl.isPrimitive()) {
1139                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1140                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;
1141                 } else if (cl == Boolean.TYPE) {
1142                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;
1143                 } else if (cl == Character.TYPE) {
1144                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;
1145                 } else if (cl == Double.TYPE) {
1146                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;
1147                 } else if (cl == Float.TYPE) {
1148                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;
1149                 } else if (cl == Long.TYPE) {
1150                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;
1151                 } else {
1152                     throw new IllegalStateException(&quot;Unhandled primitive StringBuilder.append: &quot; + cl);
1153                 }
1154             } else if (cl == String.class) {
1155                 return &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;
1156             } else {
1157                 return &quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;;
1158             }
1159         }
1160 
1161         private static String getStringValueOfDesc(Class&lt;?&gt; cl) {
1162             if (cl.isPrimitive()) {
1163                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1164                     return &quot;(I)Ljava/lang/String;&quot;;
1165                 } else if (cl == Boolean.TYPE) {
1166                     return &quot;(Z)Ljava/lang/String;&quot;;
1167                 } else if (cl == Character.TYPE) {
1168                     return &quot;(C)Ljava/lang/String;&quot;;
1169                 } else if (cl == Double.TYPE) {
1170                     return &quot;(D)Ljava/lang/String;&quot;;
1171                 } else if (cl == Float.TYPE) {
1172                     return &quot;(F)Ljava/lang/String;&quot;;
1173                 } else if (cl == Long.TYPE) {
1174                     return &quot;(J)Ljava/lang/String;&quot;;
1175                 } else {
1176                     throw new IllegalStateException(&quot;Unhandled String.valueOf: &quot; + cl);
1177                 }
1178             } else if (cl == String.class) {
1179                 return &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;;
1180             } else {
1181                 return &quot;(Ljava/lang/Object;)Ljava/lang/String;&quot;;
1182             }
1183         }
1184 
1185         /**
1186          * The following method is copied from
1187          * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small
1188          * and fast Java bytecode manipulation framework.
1189          * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.
1190          */
1191         private static void iconst(MethodVisitor mv, final int cst) {
1192             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
1193                 mv.visitInsn(Opcodes.ICONST_0 + cst);
1194             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
1195                 mv.visitIntInsn(Opcodes.BIPUSH, cst);
1196             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
1197                 mv.visitIntInsn(Opcodes.SIPUSH, cst);
1198             } else {
1199                 mv.visitLdcInsn(cst);
1200             }
1201         }
1202 
1203         private static int getLoadOpcode(Class&lt;?&gt; c) {
1204             if (c == Void.TYPE) {
1205                 throw new InternalError(&quot;Unexpected void type of load opcode&quot;);
1206             }
1207             return ILOAD + getOpcodeOffset(c);
1208         }
1209 
1210         private static int getOpcodeOffset(Class&lt;?&gt; c) {
1211             if (c.isPrimitive()) {
1212                 if (c == Long.TYPE) {
1213                     return 1;
1214                 } else if (c == Float.TYPE) {
1215                     return 2;
1216                 } else if (c == Double.TYPE) {
1217                     return 3;
1218                 }
1219                 return 0;
1220             } else {
1221                 return 4;
1222             }
1223         }
1224 
1225         private static int getParameterSize(Class&lt;?&gt; c) {
1226             if (c == Void.TYPE) {
1227                 return 0;
1228             } else if (c == Long.TYPE || c == Double.TYPE) {
1229                 return 2;
1230             }
1231             return 1;
1232         }
1233     }
1234 
1235     /**
1236      * MethodHandle StringBuilder strategy.
1237      *
1238      * &lt;p&gt;This strategy operates in two modes, gated by {@link Mode}.
1239      *
1240      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED}: &quot;MethodHandles StringBuilder,
1241      * sized&quot;.&lt;/b&gt;
1242      *
1243      * &lt;p&gt;This strategy avoids spinning up the bytecode by building the
1244      * computation on MethodHandle combinators. The computation is built with
1245      * public MethodHandle APIs, resolved from a public Lookup sequence, and
1246      * ends up calling the public StringBuilder API. Therefore, this strategy
1247      * does not use any private API at all since everything is handled under
1248      * cover by java.lang.invoke APIs.
1249      *
1250      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED_EXACT}: &quot;MethodHandles StringBuilder,
1251      * sized exactly&quot;.&lt;/b&gt;
1252      *
1253      * &lt;p&gt;This strategy improves on @link Strategy#MH_SB_SIZED}, by first
1254      * converting all arguments to String in order to get the exact capacity
1255      * StringBuilder should have. The conversion is done via the public
1256      * String.valueOf and/or Object.toString methods, and does not touch any
1257      * private String API.
1258      */
1259     private static final class MethodHandleStringBuilderStrategy {
1260         private MethodHandleStringBuilderStrategy() {
1261             // no instantiation
1262         }
1263 
1264         private static MethodHandle generate(MethodType mt, Recipe recipe, Mode mode) throws Exception {
1265             int pc = mt.parameterCount();
1266 
1267             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1268             MethodHandle[] filters = new MethodHandle[ptypes.length];
1269             for (int i = 0; i &lt; ptypes.length; i++) {
1270                 MethodHandle filter;
1271                 switch (mode) {
1272                     case SIZED:
1273                         // In sized mode, we convert all references and floats/doubles
1274                         // to String: there is no specialization for different
1275                         // classes in StringBuilder API, and it will convert to
1276                         // String internally anyhow.
1277                         filter = Stringifiers.forMost(ptypes[i]);
1278                         break;
1279                     case SIZED_EXACT:
1280                         // In exact mode, we convert everything to String:
1281                         // this helps to compute the storage exactly.
1282                         filter = Stringifiers.forAny(ptypes[i]);
1283                         break;
1284                     default:
1285                         throw new StringConcatException(&quot;Not supported&quot;);
1286                 }
1287                 if (filter != null) {
1288                     filters[i] = filter;
1289                     ptypes[i] = filter.type().returnType();
1290                 }
1291             }
1292 
1293             MethodHandle[] lengthers = new MethodHandle[pc];
1294 
1295             // Figure out lengths: constants&#39; lengths can be deduced on the spot.
1296             // All reference arguments were filtered to String in the combinators below, so we can
1297             // call the usual String.length(). Primitive values string sizes can be estimated.
1298             int initial = 0;
1299             for (RecipeElement el : recipe.getElements()) {
1300                 switch (el.getTag()) {
1301                     case TAG_CONST:
1302                         initial += el.getValue().length();
1303                         break;
1304                     case TAG_ARG:
1305                         final int i = el.getArgPos();
1306                         Class&lt;?&gt; type = ptypes[i];
1307                         if (type.isPrimitive()) {
1308                             MethodHandle est = MethodHandles.constant(int.class, estimateSize(type));
1309                             est = MethodHandles.dropArguments(est, 0, type);
1310                             lengthers[i] = est;
1311                         } else {
1312                             lengthers[i] = STRING_LENGTH;
1313                         }
1314                         break;
1315                     default:
1316                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1317                 }
1318             }
1319 
1320             // Create (StringBuilder, &lt;args&gt;) shape for appending:
1321             MethodHandle builder = MethodHandles.dropArguments(MethodHandles.identity(StringBuilder.class), 1, ptypes);
1322 
1323             // Compose append calls. This is done in reverse because the application order is
1324             // reverse as well.
1325             List&lt;RecipeElement&gt; elements = recipe.getElements();
1326             for (int i = elements.size() - 1; i &gt;= 0; i--) {
1327                 RecipeElement el = elements.get(i);
1328                 MethodHandle appender;
1329                 switch (el.getTag()) {
1330                     case TAG_CONST:
1331                         MethodHandle mh = appender(adaptToStringBuilder(String.class));
1332                         appender = MethodHandles.insertArguments(mh, 1, el.getValue());
1333                         break;
1334                     case TAG_ARG:
1335                         int ac = el.getArgPos();
1336                         appender = appender(ptypes[ac]);
1337 
1338                         // Insert dummy arguments to match the prefix in the signature.
1339                         // The actual appender argument will be the ac-ith argument.
1340                         if (ac != 0) {
1341                             appender = MethodHandles.dropArguments(appender, 1, Arrays.copyOf(ptypes, ac));
1342                         }
1343                         break;
1344                     default:
1345                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1346                 }
1347                 builder = MethodHandles.foldArguments(builder, appender);
1348             }
1349 
1350             // Build the sub-tree that adds the sizes and produces a StringBuilder:
1351 
1352             // a) Start with the reducer that accepts all arguments, plus one
1353             //    slot for the initial value. Inject the initial value right away.
1354             //    This produces (&lt;ints&gt;)int shape:
1355             MethodHandle sum = getReducerFor(pc + 1);
1356             MethodHandle adder = MethodHandles.insertArguments(sum, 0, initial);
1357 
1358             // b) Apply lengthers to transform arguments to lengths, producing (&lt;args&gt;)int
1359             adder = MethodHandles.filterArguments(adder, 0, lengthers);
1360 
1361             // c) Instantiate StringBuilder (&lt;args&gt;)int -&gt; (&lt;args&gt;)StringBuilder
1362             MethodHandle newBuilder = MethodHandles.filterReturnValue(adder, NEW_STRING_BUILDER);
1363 
1364             // d) Fold in StringBuilder constructor, this produces (&lt;args&gt;)StringBuilder
1365             MethodHandle mh = MethodHandles.foldArguments(builder, newBuilder);
1366 
1367             // Convert non-primitive arguments to Strings
1368             mh = MethodHandles.filterArguments(mh, 0, filters);
1369 
1370             // Convert (&lt;args&gt;)StringBuilder to (&lt;args&gt;)String
1371             if (DEBUG &amp;&amp; mode.isExact()) {
1372                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING_CHECKED);
1373             } else {
1374                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING);
1375             }
1376 
1377             return mh;
1378         }
1379 
1380         private static MethodHandle getReducerFor(int cnt) {
1381             return SUMMERS.computeIfAbsent(cnt, SUMMER);
1382         }
1383 
1384         private static MethodHandle appender(Class&lt;?&gt; appendType) {
1385             MethodHandle appender = lookupVirtual(MethodHandles.publicLookup(), StringBuilder.class, &quot;append&quot;,
1386                     StringBuilder.class, adaptToStringBuilder(appendType));
1387 
1388             // appenders should return void, this would not modify the target signature during folding
1389             MethodType nt = MethodType.methodType(void.class, StringBuilder.class, appendType);
1390             return appender.asType(nt);
1391         }
1392 
1393         private static String toStringChecked(StringBuilder sb) {
1394             String s = sb.toString();
1395             if (s.length() != sb.capacity()) {
1396                 throw new AssertionError(&quot;Exactness check failed: result length = &quot; + s.length() + &quot;, buffer capacity = &quot; + sb.capacity());
1397             }
1398             return s;
1399         }
1400 
1401         private static int sum(int v1, int v2) {
1402             return v1 + v2;
1403         }
1404 
1405         private static int sum(int v1, int v2, int v3) {
1406             return v1 + v2 + v3;
1407         }
1408 
1409         private static int sum(int v1, int v2, int v3, int v4) {
1410             return v1 + v2 + v3 + v4;
1411         }
1412 
1413         private static int sum(int v1, int v2, int v3, int v4, int v5) {
1414             return v1 + v2 + v3 + v4 + v5;
1415         }
1416 
1417         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6) {
1418             return v1 + v2 + v3 + v4 + v5 + v6;
1419         }
1420 
1421         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7) {
1422             return v1 + v2 + v3 + v4 + v5 + v6 + v7;
1423         }
1424 
1425         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {
1426             return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;
1427         }
1428 
1429         private static int sum(int initial, int[] vs) {
1430             int sum = initial;
1431             for (int v : vs) {
1432                 sum += v;
1433             }
1434             return sum;
1435         }
1436 
1437         private static final Lookup MHSBS_LOOKUP = lookup();
1438 
1439         private static final ConcurrentMap&lt;Integer, MethodHandle&gt; SUMMERS;
1440 
1441         // This one is deliberately non-lambdified to optimize startup time:
1442         private static final Function&lt;Integer, MethodHandle&gt; SUMMER = new Function&lt;Integer, MethodHandle&gt;() {
1443             @Override
1444             public MethodHandle apply(Integer cnt) {
1445                 if (cnt == 1) {
1446                     return MethodHandles.identity(int.class);
1447                 } else if (cnt &lt;= 8) {
1448                     // Variable-arity collectors are not as efficient as small-count methods,
1449                     // unroll some initial sizes.
1450                     Class&lt;?&gt;[] cls = new Class&lt;?&gt;[cnt];
1451                     Arrays.fill(cls, int.class);
1452                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, cls);
1453                 } else {
1454                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, int.class, int[].class)
1455                             .asCollector(int[].class, cnt - 1);
1456                 }
1457             }
1458         };
1459 
1460         private static final MethodHandle NEW_STRING_BUILDER, STRING_LENGTH, BUILDER_TO_STRING, BUILDER_TO_STRING_CHECKED;
1461 
1462         static {
1463             SUMMERS = new ConcurrentHashMap&lt;&gt;();
1464             Lookup publicLookup = MethodHandles.publicLookup();
1465             NEW_STRING_BUILDER = lookupConstructor(publicLookup, StringBuilder.class, int.class);
1466             STRING_LENGTH = lookupVirtual(publicLookup, String.class, &quot;length&quot;, int.class);
1467             BUILDER_TO_STRING = lookupVirtual(publicLookup, StringBuilder.class, &quot;toString&quot;, String.class);
1468             if (DEBUG) {
1469                 BUILDER_TO_STRING_CHECKED = lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class,
1470                         &quot;toStringChecked&quot;, String.class, StringBuilder.class);
1471             } else {
1472                 BUILDER_TO_STRING_CHECKED = null;
1473             }
1474         }
1475 
1476     }
1477 
1478 
1479     /**
1480      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_INLINE_SIZED_EXACT}: &quot;MethodHandles inline,
1481      * sized exactly&quot;.&lt;/b&gt;
1482      *
1483      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
1484      * byte[] array on its own and passes that byte[] array to String
1485      * constructor. This strategy requires access to some private APIs in JDK,
1486      * most notably, the read-only Integer/Long.stringSize methods that measure
1487      * the character length of the integers, and the private String constructor
1488      * that accepts byte[] arrays without copying. While this strategy assumes a
1489      * particular implementation details for String, this opens the door for
1490      * building a very optimal concatenation sequence. This is the only strategy
1491      * that requires porting if there are private JDK changes occur.
1492      */
1493     private static final class MethodHandleInlineCopyStrategy {
1494         private MethodHandleInlineCopyStrategy() {
1495             // no instantiation
1496         }
1497 
1498         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {
1499 
1500             // Fast-path two-argument Object + Object concatenations
1501             if (recipe.getElements().size() == 2) {
1502                 // Two object arguments
1503                 if (mt.parameterCount() == 2 &amp;&amp;
1504                     !mt.parameterType(0).isPrimitive() &amp;&amp;
1505                     !mt.parameterType(1).isPrimitive() &amp;&amp;
1506                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;
1507                     recipe.getElements().get(1).getTag() == TAG_ARG) {
1508 
1509                     return simpleConcat();
1510 
1511                 } else if (mt.parameterCount() == 1 &amp;&amp;
1512                            !mt.parameterType(0).isPrimitive()) {
1513                     // One Object argument, one constant
1514                     MethodHandle mh = simpleConcat();
1515 
1516                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;
1517                         recipe.getElements().get(1).getTag() == TAG_ARG) {
1518                         // First recipe element is a constant
1519                         return MethodHandles.insertArguments(mh, 0,
1520                                 recipe.getElements().get(0).getValue());
1521 
1522                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;
1523                                recipe.getElements().get(0).getTag() == TAG_ARG) {
1524                         // Second recipe element is a constant
1525                         return MethodHandles.insertArguments(mh, 1,
1526                                 recipe.getElements().get(1).getValue());
1527 
1528                     }
1529                 }
1530                 // else... fall-through to slow-path
1531             }
1532 
1533             // Create filters and obtain filtered parameter types. Filters would be used in the beginning
1534             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
1535             // The filtered argument type list is used all over in the combinators below.
1536             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1537             MethodHandle[] filters = null;
1538             for (int i = 0; i &lt; ptypes.length; i++) {
1539                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);
1540                 if (filter != null) {
1541                     if (filters == null) {
1542                         filters = new MethodHandle[ptypes.length];
1543                     }
1544                     filters[i] = filter;
1545                     ptypes[i] = filter.type().returnType();
1546                 }
1547             }
1548 
1549             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
1550             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
1551             // assembled bottom-up, which makes the code arguably hard to read.
1552 
1553             // Drop all remaining parameter types, leave only helper arguments:
1554             MethodHandle mh;
1555 
1556             mh = MethodHandles.dropArguments(newString(), 2, ptypes);
1557 
1558             long initialLengthCoder = INITIAL_CODER;
1559 
1560             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
1561             // known from the combinators below. We are assembling the string backwards, so the index coded
1562             // into indexCoder is the *ending* index.
1563 
1564             // We need one prepender per argument, but also need to fold in constants. We do so by greedily
1565             // create prependers that fold in surrounding constants into the argument prepender. This reduces
1566             // the number of unique MH combinator tree shapes we&#39;ll create in an application.
1567             String prefixConstant = null, suffixConstant = null;
1568             int pos = -1;
1569             for (RecipeElement el : recipe.getElements()) {
1570                 // Do the prepend, and put &quot;new&quot; index at index 1
1571                 switch (el.getTag()) {
1572                     case TAG_CONST: {
1573                         String constantValue = el.getValue();
1574 
1575                         // Eagerly update the initialLengthCoder value
1576                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);
1577 
1578                         if (pos &lt; 0) {
1579                             // Collecting into prefixConstant
1580                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;
1581                         } else {
1582                             // Collecting into suffixConstant
1583                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;
1584                         }
1585                         break;
1586                     }
1587                     case TAG_ARG: {
1588 
1589                         if (pos &gt;= 0) {
1590                             // Flush the previous non-constant arg with any prefix/suffix constant
1591                             mh = MethodHandles.filterArgumentsWithCombiner(
1592                                 mh, 1,
1593                                 prepender(prefixConstant, ptypes[pos], suffixConstant),
1594                                 1, 0, // indexCoder, storage
1595                                 2 + pos  // selected argument
1596                             );
1597                             prefixConstant = suffixConstant = null;
1598                         }
1599                         // Mark the pos of next non-constant arg
1600                         pos = el.getArgPos();
1601                         break;
1602                     }
1603                     default:
1604                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1605                 }
1606             }
1607 
1608             // Insert any trailing args, constants
1609             if (pos &gt;= 0) {
1610                 mh = MethodHandles.filterArgumentsWithCombiner(
1611                     mh, 1,
1612                     prepender(prefixConstant, ptypes[pos], suffixConstant),
1613                     1, 0, // indexCoder, storage
1614                     2 + pos  // selected argument
1615                 );
1616             } else if (prefixConstant != null) {
1617                 assert (suffixConstant == null);
1618                 // Sole prefixConstant can only happen if there were no non-constant arguments
1619                 mh = MethodHandles.filterArgumentsWithCombiner(
1620                     mh, 1,
1621                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
1622                     1, 0 // indexCoder, storage
1623                 );
1624             }
1625 
1626             // Fold in byte[] instantiation at argument 0
1627             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),
1628                     1 // index
1629             );
1630 
1631             // Start combining length and coder mixers.
1632             //
1633             // Length is easy: constant lengths can be computed on the spot, and all non-constant
1634             // shapes have been either converted to Strings, or explicit methods for getting the
1635             // string length out of primitives are provided.
1636             //
1637             // Coders are more interesting. Only Object, String and char arguments (and constants)
1638             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
1639             // and deduce the coder from there. Arguments would be either converted to Strings
1640             // during the initial filtering, or handled by specializations in MIXERS.
1641             //
1642             // The method handle shape before all mixers are combined in is:
1643             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
1644             //
1645             // We will bind the initialLengthCoder value to the last mixer (the one that will be
1646             // executed first), then fold that in. This leaves the shape after all mixers are
1647             // combined in as:
1648             //   (&lt;args&gt;)String = (&lt;args&gt;)
1649 
1650             int ac = -1;
1651             MethodHandle mix = null;
1652             for (RecipeElement el : recipe.getElements()) {
1653                 switch (el.getTag()) {
1654                     case TAG_CONST:
1655                         // Constants already handled in the code above
1656                         break;
1657                     case TAG_ARG:
1658                         if (ac &gt;= 0) {
1659                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.
1660                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,
1661                                     0, // old-index
1662                                     1 + ac // selected argument
1663                             );
1664                         }
1665 
1666                         ac = el.getArgPos();
1667                         Class&lt;?&gt; argClass = ptypes[ac];
1668                         mix = mixer(argClass);
1669 
1670                         break;
1671                     default:
1672                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1673                 }
1674             }
1675 
1676             // Insert the initialLengthCoder value into the final mixer, then
1677             // fold that into the base method handle
1678             if (ac &gt;= 0) {
1679                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);
1680                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,
1681                         1 + ac // selected argument
1682                 );
1683             } else {
1684                 // No mixer (constants only concat), insert initialLengthCoder directly
1685                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
1686             }
1687 
1688             // The method handle shape here is (&lt;args&gt;).
1689 
1690             // Apply filters, converting the arguments:
1691             if (filters != null) {
1692                 mh = MethodHandles.filterArguments(mh, 0, filters);
1693             }
1694 
1695             return mh;
1696         }
1697 
1698         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
1699             return MethodHandles.insertArguments(
1700                     MethodHandles.insertArguments(
1701                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);
1702         }
1703 
1704         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1705             return MIXERS.computeIfAbsent(cl, MIX);
1706         }
1707 
1708         // This one is deliberately non-lambdified to optimize startup time:
1709         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
1710             @Override
1711             public MethodHandle apply(Class&lt;?&gt; c) {
1712                 return JLA.stringConcatHelper(&quot;prepend&quot;,
1713                             methodType(long.class, long.class, byte[].class,
1714                                        String.class, Wrapper.asPrimitiveType(c), String.class));
1715             }
1716         };
1717 
1718         // This one is deliberately non-lambdified to optimize startup time:
1719         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
1720             @Override
1721             public MethodHandle apply(Class&lt;?&gt; c) {
1722                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));
1723             }
1724         };
1725 
1726         private @Stable static MethodHandle SIMPLE_CONCAT;
1727         private static MethodHandle simpleConcat() {
1728             if (SIMPLE_CONCAT == null) {
1729                 SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));
1730             }
1731             return SIMPLE_CONCAT;
1732         }
1733 
1734         private @Stable static MethodHandle NEW_STRING;
1735         private static MethodHandle newString() {
1736             MethodHandle mh = NEW_STRING;
1737             if (mh == null) {
1738                 NEW_STRING = mh =
1739                     JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
1740             }
1741             return mh;
1742         }
1743         private @Stable static MethodHandle NEW_ARRAY;
1744         private static MethodHandle newArray() {
1745             MethodHandle mh = NEW_ARRAY;
1746             if (mh == null) {
1747                 NEW_ARRAY = mh =
1748                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));
1749             }
1750             return mh;
1751         }
1752 
1753         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1754         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1755         private static final long INITIAL_CODER;
1756 
1757         static {
1758             INITIAL_CODER = JLA.stringConcatInitialCoder();
1759             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1760             MIXERS = new ConcurrentHashMap&lt;&gt;();
1761         }
1762     }
1763 
1764     /**
1765      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1766      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1767      */
1768     private static final class Stringifiers {
1769         private Stringifiers() {
1770             // no instantiation
1771         }
1772 
1773         private static final MethodHandle OBJECT_INSTANCE =
1774                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));
1775 
1776         private static class FloatStringifiers {
1777             private static final MethodHandle FLOAT_INSTANCE =
1778                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1779 
1780             private static final MethodHandle DOUBLE_INSTANCE =
1781                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);
1782         }
1783 
1784         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {
1785 
1786             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();
1787 
1788             @Override
1789             protected MethodHandle computeValue(Class&lt;?&gt; cl) {
1790                 if (cl == byte.class || cl == short.class || cl == int.class) {
1791                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);
1792                 } else if (cl == boolean.class) {
1793                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);
1794                 } else if (cl == char.class) {
1795                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, char.class);
1796                 } else if (cl == long.class) {
1797                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, long.class);
1798                 } else {
1799                     MethodHandle mh = forMost(cl);
1800                     if (mh != null) {
1801                         return mh;
1802                     } else {
1803                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);
1804                     }
1805                 }
1806             }
1807         }
1808 
1809         /**
1810          * Returns a stringifier for references and floats/doubles only.
1811          * Always returns null for other primitives.
1812          *
1813          * @param t class to stringify
1814          * @return stringifier; null, if not available
1815          */
1816         static MethodHandle forMost(Class&lt;?&gt; t) {
1817             if (!t.isPrimitive()) {
1818                 return OBJECT_INSTANCE;
1819             } else if (t == float.class) {
1820                 return FloatStringifiers.FLOAT_INSTANCE;
1821             } else if (t == double.class) {
1822                 return FloatStringifiers.DOUBLE_INSTANCE;
1823             }
1824             return null;
1825         }
1826 
1827         /**
1828          * Returns a stringifier for any type. Never returns null.
1829          *
1830          * @param t class to stringify
1831          * @return stringifier
1832          */
1833         static MethodHandle forAny(Class&lt;?&gt; t) {
1834             return StringifierAny.INSTANCE.get(t);
1835         }
1836     }
1837 
1838     /* ------------------------------- Common utilities ------------------------------------ */
1839 
1840     static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1841         try {
1842             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));
1843         } catch (NoSuchMethodException | IllegalAccessException e) {
1844             throw new AssertionError(e);
1845         }
1846     }
1847 
1848     static MethodHandle lookupVirtual(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1849         try {
1850             return lookup.findVirtual(refc, name, MethodType.methodType(rtype, ptypes));
1851         } catch (NoSuchMethodException | IllegalAccessException e) {
1852             throw new AssertionError(e);
1853         }
1854     }
1855 
1856     static MethodHandle lookupConstructor(Lookup lookup, Class&lt;?&gt; refc, Class&lt;?&gt; ptypes) {
1857         try {
1858             return lookup.findConstructor(refc, MethodType.methodType(void.class, ptypes));
1859         } catch (NoSuchMethodException | IllegalAccessException e) {
1860             throw new AssertionError(e);
1861         }
1862     }
1863 
1864     static int estimateSize(Class&lt;?&gt; cl) {
1865         if (cl == Integer.TYPE) {
1866             return 11; // &quot;-2147483648&quot;
1867         } else if (cl == Boolean.TYPE) {
1868             return 5; // &quot;false&quot;
1869         } else if (cl == Byte.TYPE) {
1870             return 4; // &quot;-128&quot;
1871         } else if (cl == Character.TYPE) {
1872             return 1; // duh
1873         } else if (cl == Short.TYPE) {
1874             return 6; // &quot;-32768&quot;
1875         } else if (cl == Double.TYPE) {
1876             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer
1877         } else if (cl == Float.TYPE) {
1878             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer
1879         } else if (cl == Long.TYPE)  {
1880             return 20; // &quot;-9223372036854775808&quot;
1881         } else {
1882             throw new IllegalArgumentException(&quot;Cannot estimate the size for &quot; + cl);
1883         }
1884     }
1885 
1886     static Class&lt;?&gt; adaptToStringBuilder(Class&lt;?&gt; c) {
1887         if (c.isPrimitive()) {
1888             if (c == Byte.TYPE || c == Short.TYPE) {
1889                 return int.class;
1890             }
1891         } else {
1892             if (c != String.class) {
1893                 return Object.class;
1894             }
1895         }
1896         return c;
1897     }
1898 
1899     private StringConcatFactory() {
1900         // no instantiation
1901     }
1902 
1903 }
    </pre>
  </body>
</html>
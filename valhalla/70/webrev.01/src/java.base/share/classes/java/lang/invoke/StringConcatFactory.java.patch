diff a/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java b/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java
--- a/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java
+++ b/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java
@@ -25,15 +25,17 @@
 
 package java.lang.invoke;
 
 import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.misc.Unsafe;
 import jdk.internal.misc.VM;
 import jdk.internal.org.objectweb.asm.ClassWriter;
 import jdk.internal.org.objectweb.asm.Label;
 import jdk.internal.org.objectweb.asm.MethodVisitor;
 import jdk.internal.org.objectweb.asm.Opcodes;
+import jdk.internal.vm.annotation.Stable;
 import sun.invoke.util.Wrapper;
 
 import java.lang.invoke.MethodHandles.Lookup;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -127,17 +129,14 @@
     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 
     /**
      * Concatenation strategy to use. See {@link Strategy} for possible options.
      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.
+     *
+     * Defaults to MH_INLINE_SIZED_EXACT if not set.
      */
-    private static Strategy STRATEGY;
-
-    /**
-     * Default strategy to use for concatenation.
-     */
-    private static final Strategy DEFAULT_STRATEGY = Strategy.MH_INLINE_SIZED_EXACT;
+    private static final Strategy STRATEGY;
 
     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 
     private enum Strategy {
         /**
@@ -180,46 +179,22 @@
      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
      * checks, etc.
      */
     private static final boolean DEBUG;
 
-    /**
-     * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated
-     * code, at the expense of contaminating the profiles.
-     */
-    private static final boolean CACHE_ENABLE;
-
-    private static final ConcurrentMap<Key, MethodHandle> CACHE;
-
-    /**
-     * Dump generated classes to disk, for debugging purposes.
-     */
-    private static final ProxyClassesDumper DUMPER;
-
     static {
-        // In case we need to double-back onto the StringConcatFactory during this
-        // static initialization, make sure we have the reasonable defaults to complete
-        // the static initialization properly. After that, actual users would use
-        // the proper values we have read from the properties.
-        STRATEGY = DEFAULT_STRATEGY;
-        // CACHE_ENABLE = false; // implied
-        // CACHE = null;         // implied
-        // DEBUG = false;        // implied
-        // DUMPER = null;        // implied
-
         final String strategy =
                 VM.getSavedProperty("java.lang.invoke.stringConcat");
-        CACHE_ENABLE = Boolean.parseBoolean(
-                VM.getSavedProperty("java.lang.invoke.stringConcat.cache"));
+        STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);
+
+        if (STRATEGY == null || STRATEGY == Strategy.MH_INLINE_SIZED_EXACT) {
+            // Force initialization of default strategy:
+            Unsafe.getUnsafe().ensureClassInitialized(MethodHandleInlineCopyStrategy.class);
+        }
+
         DEBUG = Boolean.parseBoolean(
                 VM.getSavedProperty("java.lang.invoke.stringConcat.debug"));
-        final String dumpPath =
-                VM.getSavedProperty("java.lang.invoke.stringConcat.dumpClasses");
-
-        STRATEGY = (strategy == null) ? DEFAULT_STRATEGY : Strategy.valueOf(strategy);
-        CACHE = CACHE_ENABLE ? new ConcurrentHashMap<>() : null;
-        DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);
     }
 
     /**
      * Cache key is a composite of:
      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
@@ -258,11 +233,11 @@
             return result;
         }
     }
 
     /**
-     * Parses the recipe string, and produces the traversable collection of
+     * Parses the recipe string, and produces a traversable collection of
      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
      * strategies. Notably, this class parses out the constants from the recipe
      * and from other static arguments.
      */
     private static final class Recipe {
@@ -666,25 +641,13 @@
                     concatType.parameterSlotCount() +
                     ", can only accept " +
                     MAX_INDY_CONCAT_ARG_SLOTS);
         }
 
-        String className = getClassName(lookup.lookupClass());
         MethodType mt = adaptType(concatType);
         Recipe rec = new Recipe(recipe, constants);
-
-        MethodHandle mh;
-        if (CACHE_ENABLE) {
-            Key key = new Key(className, mt, rec);
-            mh = CACHE.get(key);
-            if (mh == null) {
-                mh = generate(lookup, className, mt, rec);
-                CACHE.put(key, mh);
-            }
-        } else {
-            mh = generate(lookup, className, mt, rec);
-        }
+        MethodHandle mh = generate(lookup, mt, rec);
         return new ConstantCallSite(mh.asType(concatType));
     }
 
     /**
      * Adapt method type to an API we are going to use.
@@ -712,50 +675,22 @@
         return (ptypes != null)
                 ? MethodType.methodType(args.returnType(), ptypes)
                 : args;
     }
 
-    private static String getClassName(Class<?> hostClass) throws StringConcatException {
-        /*
-          The generated class is in the same package as the host class as
-          it's the implementation of the string concatenation for the host class.
-
-          When cache is enabled, we want to cache as much as we can.
-         */
-
-        switch (STRATEGY) {
-            case BC_SB:
-            case BC_SB_SIZED:
-            case BC_SB_SIZED_EXACT: {
-                if (CACHE_ENABLE) {
-                    String pkgName = hostClass.getPackageName();
-                    return (!pkgName.isEmpty() ? pkgName.replace('.', '/') + "/" : "") + "Stubs$$StringConcat";
-                } else {
-                    String name = hostClass.isHidden() ? hostClass.getName().replace('/', '_')
-                                                       : hostClass.getName();
-                    return name.replace('.', '/') + "$$StringConcat";
-                }
-            }
-            case MH_SB_SIZED:
-            case MH_SB_SIZED_EXACT:
-            case MH_INLINE_SIZED_EXACT:
-                // MethodHandle strategies do not need a class name.
-                return "";
-            default:
-                throw new StringConcatException("Concatenation strategy " + STRATEGY + " is not implemented");
-        }
-    }
-
-    private static MethodHandle generate(Lookup lookup, String className, MethodType mt, Recipe recipe) throws StringConcatException {
+    private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
         try {
+            if (STRATEGY == null) {
+                return MethodHandleInlineCopyStrategy.generate(mt, recipe);
+            }
             switch (STRATEGY) {
                 case BC_SB:
-                    return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.DEFAULT);
+                    return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);
                 case BC_SB_SIZED:
-                    return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED);
+                    return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);
                 case BC_SB_SIZED_EXACT:
-                    return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED_EXACT);
+                    return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);
                 case MH_SB_SIZED:
                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
                 case MH_SB_SIZED_EXACT:
                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
                 case MH_INLINE_SIZED_EXACT:
@@ -834,15 +769,49 @@
      */
     private static final class BytecodeStringBuilderStrategy {
         static final int CLASSFILE_VERSION = 52;
         static final String METHOD_NAME = "concat";
 
+        private static final ConcurrentMap<Key, MethodHandle> CACHE;
+
+        /**
+         * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated
+         * code, at the expense of contaminating the profiles.
+         */
+        private static final boolean CACHE_ENABLE;
+
+        /**
+         * Dump generated classes to disk, for debugging purposes.
+         */
+        private static final ProxyClassesDumper DUMPER;
+
+        static {
+            CACHE_ENABLE = Boolean.parseBoolean(
+                    VM.getSavedProperty("java.lang.invoke.stringConcat.cache"));
+            CACHE = CACHE_ENABLE ? new ConcurrentHashMap<>() : null;
+
+            final String dumpPath =
+                    VM.getSavedProperty("java.lang.invoke.stringConcat.dumpClasses");
+
+            DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);
+        }
+
         private BytecodeStringBuilderStrategy() {
             // no instantiation
         }
 
-        private static MethodHandle generate(Lookup lookup, String className, MethodType args, Recipe recipe, Mode mode) throws Exception {
+        private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {
+            String className = getClassName(lookup.lookupClass());
+            Key key = null;
+            if (CACHE_ENABLE) {
+                key = new Key(className, args, recipe);
+                MethodHandle mh = CACHE.get(key);
+                if (mh != null) {
+                    return mh;
+                }
+            }
+
             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 
             cw.visit(CLASSFILE_VERSION,
                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
                     className,
@@ -1128,17 +1097,39 @@
 
             byte[] classBytes = cw.toByteArray();
             try {
                 Class<?> innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
                 dumpIfEnabled(className, classBytes);
-                return lookup.findStatic(innerClass, METHOD_NAME, args);
+                MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);
+                if (CACHE_ENABLE) {
+                    CACHE.put(key, mh);
+                }
+                return mh;
             } catch (Exception e) {
                 dumpIfEnabled(className + "$$FAILED", classBytes);
                 throw new StringConcatException("Exception while spinning the class", e);
             }
         }
 
+        /**
+         * The generated class is in the same package as the host class as
+         * it's the implementation of the string concatenation for the host
+         * class.
+         *
+         * When cache is enabled, we want to cache as much as we can.
+         */
+        private static String getClassName(Class<?> hostClass) {
+            if (CACHE_ENABLE) {
+                String pkgName = hostClass.getPackageName();
+                return (!pkgName.isEmpty() ? pkgName.replace('.', '/') + "/" : "") + "Stubs$$StringConcat";
+            } else {
+                String name = hostClass.isHidden() ? hostClass.getName().replace('/', '_')
+                        : hostClass.getName();
+                return name.replace('.', '/') + "$$StringConcat";
+            }
+        }
+
         private static void dumpIfEnabled(String name, byte[] bytes) {
             if (DUMPER != null) {
                 DUMPER.dumpClass(name, bytes);
             }
         }
@@ -1513,16 +1504,16 @@
                     !mt.parameterType(0).isPrimitive() &&
                     !mt.parameterType(1).isPrimitive() &&
                     recipe.getElements().get(0).getTag() == TAG_ARG &&
                     recipe.getElements().get(1).getTag() == TAG_ARG) {
 
-                    return SIMPLE;
+                    return simpleConcat();
 
                 } else if (mt.parameterCount() == 1 &&
                            !mt.parameterType(0).isPrimitive()) {
                     // One Object argument, one constant
-                    MethodHandle mh = SIMPLE;
+                    MethodHandle mh = simpleConcat();
 
                     if (recipe.getElements().get(0).getTag() == TAG_CONST &&
                         recipe.getElements().get(1).getTag() == TAG_ARG) {
                         // First recipe element is a constant
                         return MethodHandles.insertArguments(mh, 0,
@@ -1560,11 +1551,11 @@
             // assembled bottom-up, which makes the code arguably hard to read.
 
             // Drop all remaining parameter types, leave only helper arguments:
             MethodHandle mh;
 
-            mh = MethodHandles.dropArguments(NEW_STRING, 2, ptypes);
+            mh = MethodHandles.dropArguments(newString(), 2, ptypes);
 
             long initialLengthCoder = INITIAL_CODER;
 
             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
             // known from the combinators below. We are assembling the string backwards, so the index coded
@@ -1631,11 +1622,11 @@
                     1, 0 // indexCoder, storage
                 );
             }
 
             // Fold in byte[] instantiation at argument 0
-            mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, NEW_ARRAY,
+            mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),
                     1 // index
             );
 
             // Start combining length and coder mixers.
             //
@@ -1705,11 +1696,11 @@
         }
 
         private static MethodHandle prepender(String prefix, Class<?> cl, String suffix) {
             return MethodHandles.insertArguments(
                     MethodHandles.insertArguments(
-                        PREPENDERS.computeIfAbsent(cl, PREPEND),2, prefix), 3, suffix);
+                        PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);
         }
 
         private static MethodHandle mixer(Class<?> cl) {
             return MIXERS.computeIfAbsent(cl, MIX);
         }
@@ -1730,31 +1721,45 @@
             public MethodHandle apply(Class<?> c) {
                 return JLA.stringConcatHelper("mix", methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));
             }
         };
 
-        private static final MethodHandle SIMPLE;
-        private static final MethodHandle NEW_STRING;
-        private static final MethodHandle NEW_ARRAY;
+        private @Stable static MethodHandle SIMPLE_CONCAT;
+        private static MethodHandle simpleConcat() {
+            if (SIMPLE_CONCAT == null) {
+                SIMPLE_CONCAT = JLA.stringConcatHelper("simpleConcat", methodType(String.class, Object.class, Object.class));
+            }
+            return SIMPLE_CONCAT;
+        }
+
+        private @Stable static MethodHandle NEW_STRING;
+        private static MethodHandle newString() {
+            MethodHandle mh = NEW_STRING;
+            if (mh == null) {
+                NEW_STRING = mh =
+                    JLA.stringConcatHelper("newString", methodType(String.class, byte[].class, long.class));
+            }
+            return mh;
+        }
+        private @Stable static MethodHandle NEW_ARRAY;
+        private static MethodHandle newArray() {
+            MethodHandle mh = NEW_ARRAY;
+            if (mh == null) {
+                NEW_ARRAY = mh =
+                    JLA.stringConcatHelper("newArray", methodType(byte[].class, long.class));
+            }
+            return mh;
+        }
+
         private static final ConcurrentMap<Class<?>, MethodHandle> PREPENDERS;
         private static final ConcurrentMap<Class<?>, MethodHandle> MIXERS;
         private static final long INITIAL_CODER;
 
         static {
-            try {
-                MethodHandle initCoder = JLA.stringConcatHelper("initialCoder", methodType(long.class));
-                INITIAL_CODER = (long) initCoder.invoke();
-            } catch (Throwable e) {
-                throw new AssertionError(e);
-            }
-
+            INITIAL_CODER = JLA.stringConcatInitialCoder();
             PREPENDERS = new ConcurrentHashMap<>();
             MIXERS = new ConcurrentHashMap<>();
-
-            SIMPLE     = JLA.stringConcatHelper("simpleConcat", methodType(String.class, Object.class, Object.class));
-            NEW_STRING = JLA.stringConcatHelper("newString", methodType(String.class, byte[].class, long.class));
-            NEW_ARRAY  = JLA.stringConcatHelper( "newArray", methodType(byte[].class, long.class));
         }
     }
 
     /**
      * Public gateways to public "stringify" methods. These methods have the form String apply(T obj), and normally

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/DatagramSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../lang/invoke/StringConcatFactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/DatagramSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,14 ***</span>
  
  import java.io.IOException;
  import java.io.UncheckedIOException;
  import java.nio.channels.DatagramChannel;
  import java.security.AccessController;
<span class="line-modified">! import java.security.PrivilegedExceptionAction;</span>
<span class="line-removed">- import java.util.Objects;</span>
  import java.util.Set;
<span class="line-modified">! import java.util.Collections;</span>
  
  /**
   * This class represents a socket for sending and receiving datagram packets.
   *
   * &lt;p&gt;A datagram socket is the sending or receiving point for a packet
<span class="line-new-header">--- 27,14 ---</span>
  
  import java.io.IOException;
  import java.io.UncheckedIOException;
  import java.nio.channels.DatagramChannel;
  import java.security.AccessController;
<span class="line-modified">! import java.security.PrivilegedAction;</span>
  import java.util.Set;
<span class="line-modified">! import sun.net.NetProperties;</span>
<span class="line-added">+ import sun.nio.ch.DefaultSelectorProvider;</span>
  
  /**
   * This class represents a socket for sending and receiving datagram packets.
   *
   * &lt;p&gt;A datagram socket is the sending or receiving point for a packet
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,122 ***</span>
   * @see     java.net.DatagramPacket
   * @see     java.nio.channels.DatagramChannel
   * @since 1.0
   */
  public class DatagramSocket implements java.io.Closeable {
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Various states of this socket.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private boolean bound = false;</span>
<span class="line-removed">-     private boolean closed = false;</span>
<span class="line-removed">-     private volatile boolean created;</span>
<span class="line-removed">-     private final Object closeLock = new Object();</span>
  
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * The implementation of this DatagramSocket.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private final DatagramSocketImpl impl;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Are we using an older DatagramSocketImpl?</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     final boolean oldImpl;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * Set when a socket is ST_CONNECTED until we are certain</span>
<span class="line-removed">-      * that any packets which might have been received prior</span>
<span class="line-removed">-      * to calling connect() but not read by the application</span>
<span class="line-removed">-      * have been read. During this time we check the source</span>
<span class="line-removed">-      * address of all packets received to be sure they are from</span>
<span class="line-removed">-      * the connected destination. Other packets are read but</span>
<span class="line-removed">-      * silently dropped.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private boolean explicitFilter = false;</span>
<span class="line-removed">-     private int bytesLeftToFilter;</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * Connection state:</span>
<span class="line-removed">-      * ST_NOT_CONNECTED = socket not connected</span>
<span class="line-removed">-      * ST_CONNECTED = socket connected</span>
<span class="line-removed">-      * ST_CONNECTED_NO_IMPL = socket connected but not at impl level</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     static final int ST_NOT_CONNECTED = 0;</span>
<span class="line-removed">-     static final int ST_CONNECTED = 1;</span>
<span class="line-removed">-     static final int ST_CONNECTED_NO_IMPL = 2;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int connectState = ST_NOT_CONNECTED;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * Connected address &amp; port</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     InetAddress connectedAddress = null;</span>
<span class="line-removed">-     int connectedPort = -1;</span>
  
      /**
<span class="line-modified">!      * Connects this socket to a remote socket address (IP address + port number).</span>
<span class="line-modified">!      * Binds socket if not already bound.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param   address The remote address.</span>
<span class="line-removed">-      * @param   port    The remote port</span>
<span class="line-removed">-      * @throws  SocketException if binding the socket fails.</span>
       */
<span class="line-modified">!     private synchronized void connectInternal(InetAddress address, int port) throws SocketException {</span>
<span class="line-modified">!         if (port &lt; 0 || port &gt; 0xFFFF) {</span>
<span class="line-modified">!             throw new IllegalArgumentException(&quot;connect: &quot; + port);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (address == null) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;connect: null address&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         checkAddress (address, &quot;connect&quot;);</span>
<span class="line-removed">-         if (isClosed())</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed">-         if (security != null) {</span>
<span class="line-removed">-             if (address.isMulticastAddress()) {</span>
<span class="line-removed">-                 security.checkMulticast(address);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 security.checkConnect(address.getHostAddress(), port);</span>
<span class="line-removed">-                 security.checkAccept(address.getHostAddress(), port);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (port == 0) {</span>
<span class="line-removed">-             throw new SocketException(&quot;Can&#39;t connect to port 0&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!isBound())</span>
<span class="line-removed">-           bind(new InetSocketAddress(0));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // old impls do not support connect/disconnect</span>
<span class="line-removed">-         if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &amp;&amp;</span>
<span class="line-removed">-              ((AbstractPlainDatagramSocketImpl)impl).nativeConnectDisabled())) {</span>
<span class="line-removed">-             connectState = ST_CONNECTED_NO_IMPL;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 getImpl().connect(address, port);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // socket is now connected by the impl</span>
<span class="line-removed">-                 connectState = ST_CONNECTED;</span>
<span class="line-removed">-                 // Do we need to filter some packets?</span>
<span class="line-removed">-                 int avail = getImpl().dataAvailable();</span>
<span class="line-removed">-                 if (avail == -1) {</span>
<span class="line-removed">-                     throw new SocketException();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 explicitFilter = avail &gt; 0;</span>
<span class="line-removed">-                 if (explicitFilter) {</span>
<span class="line-removed">-                     bytesLeftToFilter = getReceiveBufferSize();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } catch (SocketException se) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // connection will be emulated by DatagramSocket</span>
<span class="line-removed">-                 connectState = ST_CONNECTED_NO_IMPL;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         connectedAddress = address;</span>
<span class="line-removed">-         connectedPort = port;</span>
      }
  
<span class="line-removed">- </span>
      /**
       * Constructs a datagram socket and binds it to any available port
       * on the local host machine.  The socket will be bound to the
       * {@link InetAddress#isAnyLocalAddress wildcard} address,
       * an IP address chosen by the kernel.
<span class="line-new-header">--- 111,32 ---</span>
   * @see     java.net.DatagramPacket
   * @see     java.nio.channels.DatagramChannel
   * @since 1.0
   */
  public class DatagramSocket implements java.io.Closeable {
  
<span class="line-modified">!     // An instance of DatagramSocketAdaptor, NetMulticastSocket, or null</span>
<span class="line-modified">!     private final DatagramSocket delegate;</span>
  
<span class="line-modified">!     DatagramSocket delegate() {</span>
<span class="line-modified">!         if (delegate == null) {</span>
<span class="line-modified">!             throw new InternalError(&quot;Should not get here&quot;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return delegate;</span>
<span class="line-modified">!     }</span>
  
      /**
<span class="line-modified">!      * All constructors eventually call this one.</span>
<span class="line-modified">!      * @param delegate The wrapped DatagramSocket implementation, or null.</span>
       */
<span class="line-modified">!     DatagramSocket(DatagramSocket delegate) {</span>
<span class="line-modified">!         assert delegate == null</span>
<span class="line-modified">!                 || delegate instanceof NetMulticastSocket</span>
<span class="line-modified">!                 || delegate instanceof sun.nio.ch.DatagramSocketAdaptor;</span>
<span class="line-modified">!         this.delegate = delegate;</span>
      }
  
      /**
       * Constructs a datagram socket and binds it to any available port
       * on the local host machine.  The socket will be bound to the
       * {@link InetAddress#isAnyLocalAddress wildcard} address,
       * an IP address chosen by the kernel.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 254,14 ***</span>
       * @param impl an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
       *        the subclass wishes to use on the DatagramSocket.
       * @since   1.4
       */
      protected DatagramSocket(DatagramSocketImpl impl) {
<span class="line-modified">!         if (impl == null)</span>
<span class="line-removed">-             throw new NullPointerException();</span>
<span class="line-removed">-         this.impl = impl;</span>
<span class="line-removed">-         this.oldImpl = checkOldImpl(impl);</span>
      }
  
      /**
       * Creates a datagram socket, bound to the specified local
       * socket address.
<span class="line-new-header">--- 164,11 ---</span>
       * @param impl an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
       *        the subclass wishes to use on the DatagramSocket.
       * @since   1.4
       */
      protected DatagramSocket(DatagramSocketImpl impl) {
<span class="line-modified">!         this(new NetMulticastSocket(impl));</span>
      }
  
      /**
       * Creates a datagram socket, bound to the specified local
       * socket address.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 284,32 ***</span>
       *
       * @see SecurityManager#checkListen
       * @since   1.4
       */
      public DatagramSocket(SocketAddress bindaddr) throws SocketException {
<span class="line-modified">!         // Special case initialization for the DatagramChannel socket adaptor.</span>
<span class="line-removed">-         if (this instanceof sun.nio.ch.DatagramSocketAdaptor) {</span>
<span class="line-removed">-             this.impl = null;  // no DatagramSocketImpl</span>
<span class="line-removed">-             this.oldImpl = false;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // create a datagram socket.</span>
<span class="line-removed">-         boolean multicast = (this instanceof MulticastSocket);</span>
<span class="line-removed">-         this.impl = createImpl(multicast);</span>
<span class="line-removed">-         // creates the udp socket</span>
<span class="line-removed">-         impl.create();</span>
<span class="line-removed">-         created = true;</span>
<span class="line-removed">-         this.oldImpl = checkOldImpl(impl);</span>
<span class="line-removed">-         if (bindaddr != null) {</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 bind(bindaddr);</span>
<span class="line-removed">-             } finally {</span>
<span class="line-removed">-                 if (!isBound())</span>
<span class="line-removed">-                     close();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Constructs a datagram socket and binds it to the specified port
       * on the local host machine.  The socket will be bound to the
<span class="line-new-header">--- 191,11 ---</span>
       *
       * @see SecurityManager#checkListen
       * @since   1.4
       */
      public DatagramSocket(SocketAddress bindaddr) throws SocketException {
<span class="line-modified">!         this(createDelegate(bindaddr, DatagramSocket.class));</span>
      }
  
      /**
       * Constructs a datagram socket and binds it to the specified port
       * on the local host machine.  The socket will be bound to the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,71 ***</span>
       */
      public DatagramSocket(int port, InetAddress laddr) throws SocketException {
          this(new InetSocketAddress(laddr, port));
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Return true if the given DatagramSocketImpl is an &quot;old&quot; impl. An old impl</span>
<span class="line-removed">-      * is one that doesn&#39;t implement the abstract methods added in Java SE 1.4.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static boolean checkOldImpl(DatagramSocketImpl impl) {</span>
<span class="line-removed">-         // DatagramSocketImpl.peekData() is a protected method, therefore we need to use</span>
<span class="line-removed">-         // getDeclaredMethod, therefore we need permission to access the member</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             AccessController.doPrivileged(</span>
<span class="line-removed">-                 new PrivilegedExceptionAction&lt;&gt;() {</span>
<span class="line-removed">-                     public Void run() throws NoSuchMethodException {</span>
<span class="line-removed">-                         Class&lt;?&gt;[] cl = new Class&lt;?&gt;[1];</span>
<span class="line-removed">-                         cl[0] = DatagramPacket.class;</span>
<span class="line-removed">-                         impl.getClass().getDeclaredMethod(&quot;peekData&quot;, cl);</span>
<span class="line-removed">-                         return null;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 });</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static Class&lt;?&gt; implClass = null;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Creates a DatagramSocketImpl.</span>
<span class="line-removed">-      * @param multicast true if the DatagramSocketImpl is for a MulticastSocket</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static DatagramSocketImpl createImpl(boolean multicast) throws SocketException {</span>
<span class="line-removed">-         DatagramSocketImpl impl;</span>
<span class="line-removed">-         DatagramSocketImplFactory factory = DatagramSocket.factory;</span>
<span class="line-removed">-         if (factory != null) {</span>
<span class="line-removed">-             impl = factory.createDatagramSocketImpl();</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return impl;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Return the {@code DatagramSocketImpl} attached to this socket,</span>
<span class="line-removed">-      * creating the socket if not already created.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return  the {@code DatagramSocketImpl} attached to that</span>
<span class="line-removed">-      *          DatagramSocket</span>
<span class="line-removed">-      * @throws SocketException if creating the socket fails</span>
<span class="line-removed">-      * @since 1.4</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     final DatagramSocketImpl getImpl() throws SocketException {</span>
<span class="line-removed">-         if (!created) {</span>
<span class="line-removed">-             synchronized (this) {</span>
<span class="line-removed">-                 if (!created)  {</span>
<span class="line-removed">-                     impl.create();</span>
<span class="line-removed">-                     created = true;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return impl;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Binds this DatagramSocket to a specific address and port.
       * &lt;p&gt;
       * If the address is {@code null}, then the system will pick up
       * an ephemeral port and a valid local address to bind the socket.
<span class="line-new-header">--- 246,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,45 ***</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       * @throws IllegalArgumentException if addr is a SocketAddress subclass
       *         not supported by this socket.
       * @since 1.4
       */
<span class="line-modified">!     public synchronized void bind(SocketAddress addr) throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         if (isBound())</span>
<span class="line-removed">-             throw new SocketException(&quot;already bound&quot;);</span>
<span class="line-removed">-         if (addr == null)</span>
<span class="line-removed">-             addr = new InetSocketAddress(0);</span>
<span class="line-removed">-         if (!(addr instanceof InetSocketAddress))</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;Unsupported address type!&quot;);</span>
<span class="line-removed">-         InetSocketAddress epoint = (InetSocketAddress) addr;</span>
<span class="line-removed">-         if (epoint.isUnresolved())</span>
<span class="line-removed">-             throw new SocketException(&quot;Unresolved address&quot;);</span>
<span class="line-removed">-         InetAddress iaddr = epoint.getAddress();</span>
<span class="line-removed">-         int port = epoint.getPort();</span>
<span class="line-removed">-         checkAddress(iaddr, &quot;bind&quot;);</span>
<span class="line-removed">-         SecurityManager sec = System.getSecurityManager();</span>
<span class="line-removed">-         if (sec != null) {</span>
<span class="line-removed">-             sec.checkListen(port);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             getImpl().bind(port, iaddr);</span>
<span class="line-removed">-         } catch (SocketException e) {</span>
<span class="line-removed">-             getImpl().close();</span>
<span class="line-removed">-             throw e;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         bound = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void checkAddress (InetAddress addr, String op) {</span>
<span class="line-removed">-         if (addr == null) {</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(op + &quot;: invalid address type&quot;);</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Connects the socket to a remote address for this socket. When a
       * socket is connected to a remote address, packets may only be
<span class="line-new-header">--- 261,12 ---</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       * @throws IllegalArgumentException if addr is a SocketAddress subclass
       *         not supported by this socket.
       * @since 1.4
       */
<span class="line-modified">!     public void bind(SocketAddress addr) throws SocketException {</span>
<span class="line-modified">!         delegate().bind(addr);</span>
      }
  
      /**
       * Connects the socket to a remote address for this socket. When a
       * socket is connected to a remote address, packets may only be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 532,15 ***</span>
       * @see #disconnect
       *
       * @since 1.2
       */
      public void connect(InetAddress address, int port) {
<span class="line-modified">!         try {</span>
<span class="line-removed">-             connectInternal(address, port);</span>
<span class="line-removed">-         } catch (SocketException se) {</span>
<span class="line-removed">-             throw new UncheckedIOException(&quot;connect failed&quot;, se);</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Connects this socket to a remote socket address (IP address + port number).
       *
<span class="line-new-header">--- 324,11 ---</span>
       * @see #disconnect
       *
       * @since 1.2
       */
      public void connect(InetAddress address, int port) {
<span class="line-modified">!         delegate().connect(address, port);</span>
      }
  
      /**
       * Connects this socket to a remote socket address (IP address + port number).
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 564,18 ***</span>
       *         not permit access to the given remote address
       *
       * @since 1.4
       */
      public void connect(SocketAddress addr) throws SocketException {
<span class="line-modified">!         if (addr == null)</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);</span>
<span class="line-removed">-         if (!(addr instanceof InetSocketAddress))</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="line-removed">-         InetSocketAddress epoint = (InetSocketAddress) addr;</span>
<span class="line-removed">-         if (epoint.isUnresolved())</span>
<span class="line-removed">-             throw new SocketException(&quot;Unresolved address&quot;);</span>
<span class="line-removed">-         connectInternal(epoint.getAddress(), epoint.getPort());</span>
      }
  
      /**
       * Disconnects the socket. If the socket is closed or not connected,
       * then this method has no effect.
<span class="line-new-header">--- 352,11 ---</span>
       *         not permit access to the given remote address
       *
       * @since 1.4
       */
      public void connect(SocketAddress addr) throws SocketException {
<span class="line-modified">!         delegate().connect(addr);</span>
      }
  
      /**
       * Disconnects the socket. If the socket is closed or not connected,
       * then this method has no effect.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 592,21 ***</span>
       * @see #connect
       *
       * @since 1.2
       */
      public void disconnect() {
<span class="line-modified">!         synchronized (this) {</span>
<span class="line-removed">-             if (isClosed())</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             if (connectState == ST_CONNECTED) {</span>
<span class="line-removed">-                 impl.disconnect ();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             connectedAddress = null;</span>
<span class="line-removed">-             connectedPort = -1;</span>
<span class="line-removed">-             connectState = ST_NOT_CONNECTED;</span>
<span class="line-removed">-             explicitFilter = false;</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Returns the binding state of the socket.
       * &lt;p&gt;
<span class="line-new-header">--- 373,11 ---</span>
       * @see #connect
       *
       * @since 1.2
       */
      public void disconnect() {
<span class="line-modified">!         delegate().disconnect();</span>
      }
  
      /**
       * Returns the binding state of the socket.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 616,11 ***</span>
       *
       * @return true if the socket successfully bound to an address
       * @since 1.4
       */
      public boolean isBound() {
<span class="line-modified">!         return bound;</span>
      }
  
      /**
       * Returns the connection state of the socket.
       * &lt;p&gt;
<span class="line-new-header">--- 387,11 ---</span>
       *
       * @return true if the socket successfully bound to an address
       * @since 1.4
       */
      public boolean isBound() {
<span class="line-modified">!         return delegate().isBound();</span>
      }
  
      /**
       * Returns the connection state of the socket.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,11 ***</span>
       *
       * @return true if the socket successfully connected to a server
       * @since 1.4
       */
      public boolean isConnected() {
<span class="line-modified">!         return connectState != ST_NOT_CONNECTED;</span>
      }
  
      /**
       * Returns the address to which this socket is connected. Returns
       * {@code null} if the socket is not connected.
<span class="line-new-header">--- 401,11 ---</span>
       *
       * @return true if the socket successfully connected to a server
       * @since 1.4
       */
      public boolean isConnected() {
<span class="line-modified">!         return delegate().isConnected();</span>
      }
  
      /**
       * Returns the address to which this socket is connected. Returns
       * {@code null} if the socket is not connected.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 645,11 ***</span>
       *
       * @return the address to which this socket is connected.
       * @since 1.2
       */
      public InetAddress getInetAddress() {
<span class="line-modified">!         return connectedAddress;</span>
      }
  
      /**
       * Returns the port number to which this socket is connected.
       * Returns {@code -1} if the socket is not connected.
<span class="line-new-header">--- 416,11 ---</span>
       *
       * @return the address to which this socket is connected.
       * @since 1.2
       */
      public InetAddress getInetAddress() {
<span class="line-modified">!         return delegate().getInetAddress();</span>
      }
  
      /**
       * Returns the port number to which this socket is connected.
       * Returns {@code -1} if the socket is not connected.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 660,11 ***</span>
       *
       * @return the port number to which this socket is connected.
       * @since 1.2
       */
      public int getPort() {
<span class="line-modified">!         return connectedPort;</span>
      }
  
      /**
       * Returns the address of the endpoint this socket is connected to, or
       * {@code null} if it is unconnected.
<span class="line-new-header">--- 431,11 ---</span>
       *
       * @return the port number to which this socket is connected.
       * @since 1.2
       */
      public int getPort() {
<span class="line-modified">!         return delegate().getPort();</span>
      }
  
      /**
       * Returns the address of the endpoint this socket is connected to, or
       * {@code null} if it is unconnected.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 680,13 ***</span>
       * @see #getPort()
       * @see #connect(SocketAddress)
       * @since 1.4
       */
      public SocketAddress getRemoteSocketAddress() {
<span class="line-modified">!         if (!isConnected())</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         return new InetSocketAddress(getInetAddress(), getPort());</span>
      }
  
      /**
       * Returns the address of the endpoint this socket is bound to.
       *
<span class="line-new-header">--- 451,11 ---</span>
       * @see #getPort()
       * @see #connect(SocketAddress)
       * @since 1.4
       */
      public SocketAddress getRemoteSocketAddress() {
<span class="line-modified">!         return delegate().getRemoteSocketAddress();</span>
      }
  
      /**
       * Returns the address of the endpoint this socket is bound to.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,15 ***</span>
       * @see #getLocalPort()
       * @see #bind(SocketAddress)
       * @since 1.4
       */
      public SocketAddress getLocalSocketAddress() {
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         if (!isBound())</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         return new InetSocketAddress(getLocalAddress(), getLocalPort());</span>
      }
  
      /**
       * Sends a datagram packet from this socket. The
       * {@code DatagramPacket} includes information indicating the
<span class="line-new-header">--- 465,11 ---</span>
       * @see #getLocalPort()
       * @see #bind(SocketAddress)
       * @since 1.4
       */
      public SocketAddress getLocalSocketAddress() {
<span class="line-modified">!         return delegate().getLocalSocketAddress();</span>
      }
  
      /**
       * Sends a datagram packet from this socket. The
       * {@code DatagramPacket} includes information indicating the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,58 ***</span>
       * @see        SecurityManager#checkConnect
       * @revised 1.4
       * @spec JSR-51
       */
      public void send(DatagramPacket p) throws IOException  {
<span class="line-modified">!         synchronized (p) {</span>
<span class="line-removed">-             if (isClosed())</span>
<span class="line-removed">-                 throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-             InetAddress packetAddress = p.getAddress();</span>
<span class="line-removed">-             int packetPort = p.getPort();</span>
<span class="line-removed">-             checkAddress (packetAddress, &quot;send&quot;);</span>
<span class="line-removed">-             if (connectState == ST_NOT_CONNECTED) {</span>
<span class="line-removed">-                 if (packetAddress == null) {</span>
<span class="line-removed">-                     throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)</span>
<span class="line-removed">-                     throw new IllegalArgumentException(&quot;port out of range:&quot; + packetPort);</span>
<span class="line-removed">-                 // check the address is ok with the security manager on every send.</span>
<span class="line-removed">-                 SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // The reason you want to synchronize on datagram packet</span>
<span class="line-removed">-                 // is because you don&#39;t want an applet to change the address</span>
<span class="line-removed">-                 // while you are trying to send the packet for example</span>
<span class="line-removed">-                 // after the security check but before the send.</span>
<span class="line-removed">-                 if (security != null) {</span>
<span class="line-removed">-                     if (packetAddress.isMulticastAddress()) {</span>
<span class="line-removed">-                         security.checkMulticast(packetAddress);</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         security.checkConnect(packetAddress.getHostAddress(),</span>
<span class="line-removed">-                                 packetPort);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (packetPort == 0) {</span>
<span class="line-removed">-                     throw new SocketException(&quot;Can&#39;t send to port 0&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 // we&#39;re connected</span>
<span class="line-removed">-                 if (packetAddress == null) {</span>
<span class="line-removed">-                     p.setAddress(connectedAddress);</span>
<span class="line-removed">-                     p.setPort(connectedPort);</span>
<span class="line-removed">-                 } else if ((!packetAddress.equals(connectedAddress)) ||</span>
<span class="line-removed">-                         packetPort != connectedPort) {</span>
<span class="line-removed">-                     throw new IllegalArgumentException(&quot;connected address &quot; +</span>
<span class="line-removed">-                                                        &quot;and packet address&quot; +</span>
<span class="line-removed">-                                                        &quot; differ&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // Check whether the socket is bound</span>
<span class="line-removed">-             if (!isBound())</span>
<span class="line-removed">-                 bind(new InetSocketAddress(0));</span>
<span class="line-removed">-             // call the  method to send</span>
<span class="line-removed">-             getImpl().send(p);</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Receives a datagram packet from this socket. When this method
       * returns, the {@code DatagramPacket}&#39;s buffer is filled with
<span class="line-new-header">--- 511,11 ---</span>
       * @see        SecurityManager#checkConnect
       * @revised 1.4
       * @spec JSR-51
       */
      public void send(DatagramPacket p) throws IOException  {
<span class="line-modified">!         delegate().send(p);</span>
      }
  
      /**
       * Receives a datagram packet from this socket. When this method
       * returns, the {@code DatagramPacket}&#39;s buffer is filled with
</pre>
<hr />
<pre>
<span class="line-old-header">*** 829,109 ***</span>
       * @see        java.net.DatagramPacket
       * @see        java.net.DatagramSocket
       * @revised 1.4
       * @spec JSR-51
       */
<span class="line-modified">!     public synchronized void receive(DatagramPacket p) throws IOException {</span>
<span class="line-modified">!         synchronized (p) {</span>
<span class="line-removed">-             if (!isBound())</span>
<span class="line-removed">-                 bind(new InetSocketAddress(0));</span>
<span class="line-removed">-             if (connectState == ST_NOT_CONNECTED) {</span>
<span class="line-removed">-                 // check the address is ok with the security manager before every recv.</span>
<span class="line-removed">-                 SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed">-                 if (security != null) {</span>
<span class="line-removed">-                     while(true) {</span>
<span class="line-removed">-                         String peekAd = null;</span>
<span class="line-removed">-                         int peekPort = 0;</span>
<span class="line-removed">-                         // peek at the packet to see who it is from.</span>
<span class="line-removed">-                         if (!oldImpl) {</span>
<span class="line-removed">-                             // We can use the new peekData() API</span>
<span class="line-removed">-                             DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);</span>
<span class="line-removed">-                             peekPort = getImpl().peekData(peekPacket);</span>
<span class="line-removed">-                             peekAd = peekPacket.getAddress().getHostAddress();</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             InetAddress adr = new InetAddress();</span>
<span class="line-removed">-                             peekPort = getImpl().peek(adr);</span>
<span class="line-removed">-                             peekAd = adr.getHostAddress();</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         try {</span>
<span class="line-removed">-                             security.checkAccept(peekAd, peekPort);</span>
<span class="line-removed">-                             // security check succeeded - so now break</span>
<span class="line-removed">-                             // and recv the packet.</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         } catch (SecurityException se) {</span>
<span class="line-removed">-                             // Throw away the offending packet by consuming</span>
<span class="line-removed">-                             // it in a tmp buffer.</span>
<span class="line-removed">-                             DatagramPacket tmp = new DatagramPacket(new byte[1], 1);</span>
<span class="line-removed">-                             getImpl().receive(tmp);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                             // silently discard the offending packet</span>
<span class="line-removed">-                             // and continue: unknown/malicious</span>
<span class="line-removed">-                             // entities on nets should not make</span>
<span class="line-removed">-                             // runtime throw security exception and</span>
<span class="line-removed">-                             // disrupt the applet by sending random</span>
<span class="line-removed">-                             // datagram packets.</span>
<span class="line-removed">-                             continue;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     } // end of while</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             DatagramPacket tmp = null;</span>
<span class="line-removed">-             if ((connectState == ST_CONNECTED_NO_IMPL) || explicitFilter) {</span>
<span class="line-removed">-                 // We have to do the filtering the old fashioned way since</span>
<span class="line-removed">-                 // the native impl doesn&#39;t support connect or the connect</span>
<span class="line-removed">-                 // via the impl failed, or .. &quot;explicitFilter&quot; may be set when</span>
<span class="line-removed">-                 // a socket is connected via the impl, for a period of time</span>
<span class="line-removed">-                 // when packets from other sources might be queued on socket.</span>
<span class="line-removed">-                 boolean stop = false;</span>
<span class="line-removed">-                 while (!stop) {</span>
<span class="line-removed">-                     InetAddress peekAddress = null;</span>
<span class="line-removed">-                     int peekPort = -1;</span>
<span class="line-removed">-                     // peek at the packet to see who it is from.</span>
<span class="line-removed">-                     if (!oldImpl) {</span>
<span class="line-removed">-                         // We can use the new peekData() API</span>
<span class="line-removed">-                         DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);</span>
<span class="line-removed">-                         peekPort = getImpl().peekData(peekPacket);</span>
<span class="line-removed">-                         peekAddress = peekPacket.getAddress();</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         // this api only works for IPv4</span>
<span class="line-removed">-                         peekAddress = new InetAddress();</span>
<span class="line-removed">-                         peekPort = getImpl().peek(peekAddress);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     if ((!connectedAddress.equals(peekAddress)) ||</span>
<span class="line-removed">-                         (connectedPort != peekPort)) {</span>
<span class="line-removed">-                         // throw the packet away and silently continue</span>
<span class="line-removed">-                         tmp = new DatagramPacket(</span>
<span class="line-removed">-                                                 new byte[1024], 1024);</span>
<span class="line-removed">-                         getImpl().receive(tmp);</span>
<span class="line-removed">-                         if (explicitFilter) {</span>
<span class="line-removed">-                             if (checkFiltering(tmp)) {</span>
<span class="line-removed">-                                 stop = true;</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         stop = true;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // If the security check succeeds, or the datagram is</span>
<span class="line-removed">-             // connected then receive the packet</span>
<span class="line-removed">-             getImpl().receive(p);</span>
<span class="line-removed">-             if (explicitFilter &amp;&amp; tmp == null) {</span>
<span class="line-removed">-                 // packet was not filtered, account for it here</span>
<span class="line-removed">-                 checkFiltering(p);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private boolean checkFiltering(DatagramPacket p) throws SocketException {</span>
<span class="line-removed">-         bytesLeftToFilter -= p.getLength();</span>
<span class="line-removed">-         if (bytesLeftToFilter &lt;= 0 || getImpl().dataAvailable() &lt;= 0) {</span>
<span class="line-removed">-             explicitFilter = false;</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return false;</span>
      }
  
      /**
       * Gets the local address to which the socket is bound.
       *
<span class="line-new-header">--- 547,12 ---</span>
       * @see        java.net.DatagramPacket
       * @see        java.net.DatagramSocket
       * @revised 1.4
       * @spec JSR-51
       */
<span class="line-modified">!     public void receive(DatagramPacket p) throws IOException {</span>
<span class="line-modified">!         delegate().receive(p);</span>
      }
  
      /**
       * Gets the local address to which the socket is bound.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 949,26 ***</span>
       *          the security manager {@code checkConnect}
       *          method does not allow the operation
       * @since   1.1
       */
      public InetAddress getLocalAddress() {
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         InetAddress in;</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);</span>
<span class="line-removed">-             if (in.isAnyLocalAddress()) {</span>
<span class="line-removed">-                 in = InetAddress.anyLocalAddress();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             SecurityManager s = System.getSecurityManager();</span>
<span class="line-removed">-             if (s != null) {</span>
<span class="line-removed">-                 s.checkConnect(in.getHostAddress(), -1);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } catch (Exception e) {</span>
<span class="line-removed">-             in = InetAddress.anyLocalAddress(); // &quot;0.0.0.0&quot;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return in;</span>
      }
  
      /**
       * Returns the port number on the local host to which this socket
       * is bound.
<span class="line-new-header">--- 570,11 ---</span>
       *          the security manager {@code checkConnect}
       *          method does not allow the operation
       * @since   1.1
       */
      public InetAddress getLocalAddress() {
<span class="line-modified">!         return delegate().getLocalAddress();</span>
      }
  
      /**
       * Returns the port number on the local host to which this socket
       * is bound.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 976,17 ***</span>
       * @return  the port number on the local host to which this socket is bound,
       *          {@code -1} if the socket is closed, or
       *          {@code 0} if it is not bound yet.
       */
      public int getLocalPort() {
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             return getImpl().getLocalPort();</span>
<span class="line-removed">-         } catch (Exception e) {</span>
<span class="line-removed">-             return 0;</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Enable/disable SO_TIMEOUT with the specified timeout, in
       * milliseconds. With this option set to a positive timeout value,
<span class="line-new-header">--- 582,11 ---</span>
       * @return  the port number on the local host to which this socket is bound,
       *          {@code -1} if the socket is closed, or
       *          {@code 0} if it is not bound yet.
       */
      public int getLocalPort() {
<span class="line-modified">!         return delegate().getLocalPort();</span>
      }
  
      /**
       * Enable/disable SO_TIMEOUT with the specified timeout, in
       * milliseconds. With this option set to a positive timeout value,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1002,16 ***</span>
       * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
       * @throws IllegalArgumentException if {@code timeout} is negative
       * @since   1.1
       * @see #getSoTimeout()
       */
<span class="line-modified">!     public synchronized void setSoTimeout(int timeout) throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         if (timeout &lt; 0)</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
<span class="line-removed">-         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);</span>
      }
  
      /**
       * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
       * option is disabled (i.e., timeout of infinity).
<span class="line-new-header">--- 602,12 ---</span>
       * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
       * @throws IllegalArgumentException if {@code timeout} is negative
       * @since   1.1
       * @see #getSoTimeout()
       */
<span class="line-modified">!     public void setSoTimeout(int timeout) throws SocketException {</span>
<span class="line-modified">!         delegate().setSoTimeout(timeout);</span>
      }
  
      /**
       * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
       * option is disabled (i.e., timeout of infinity).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1019,22 ***</span>
       * @return the setting for SO_TIMEOUT
       * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
       * @since   1.1
       * @see #setSoTimeout(int)
       */
<span class="line-modified">!     public synchronized int getSoTimeout() throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         if (getImpl() == null)</span>
<span class="line-removed">-             return 0;</span>
<span class="line-removed">-         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);</span>
<span class="line-removed">-         /* extra type safety */</span>
<span class="line-removed">-         if (o instanceof Integer) {</span>
<span class="line-removed">-             return ((Integer) o).intValue();</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return 0;</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Sets the SO_SNDBUF option to the specified value for this
       * {@code DatagramSocket}. The SO_SNDBUF option is used by the
<span class="line-new-header">--- 615,12 ---</span>
       * @return the setting for SO_TIMEOUT
       * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
       * @since   1.1
       * @see #setSoTimeout(int)
       */
<span class="line-modified">!     public int getSoTimeout() throws SocketException {</span>
<span class="line-modified">!         return delegate().getSoTimeout();</span>
      }
  
      /**
       * Sets the SO_SNDBUF option to the specified value for this
       * {@code DatagramSocket}. The SO_SNDBUF option is used by the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1063,17 ***</span>
       * @throws    IllegalArgumentException if the value is 0 or is
       * negative.
       * @see #getSendBufferSize()
       * @since 1.2
       */
<span class="line-modified">!     public synchronized void setSendBufferSize(int size) throws SocketException {</span>
<span class="line-modified">!         if (!(size &gt; 0)) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;negative send size&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         getImpl().setOption(SocketOptions.SO_SNDBUF, size);</span>
      }
  
      /**
       * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
       * buffer size used by the platform for output on this {@code DatagramSocket}.
<span class="line-new-header">--- 649,12 ---</span>
       * @throws    IllegalArgumentException if the value is 0 or is
       * negative.
       * @see #getSendBufferSize()
       * @since 1.2
       */
<span class="line-modified">!     public void setSendBufferSize(int size) throws SocketException {</span>
<span class="line-modified">!         delegate().setSendBufferSize(size);</span>
      }
  
      /**
       * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
       * buffer size used by the platform for output on this {@code DatagramSocket}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1082,19 ***</span>
       * @throws    SocketException if there is an error in
       * the underlying protocol, such as an UDP error.
       * @see #setSendBufferSize
       * @since 1.2
       */
<span class="line-modified">!     public synchronized int getSendBufferSize() throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         int result = 0;</span>
<span class="line-removed">-         Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-removed">-         if (o instanceof Integer) {</span>
<span class="line-removed">-             result = ((Integer)o).intValue();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return result;</span>
      }
  
      /**
       * Sets the SO_RCVBUF option to the specified value for this
       * {@code DatagramSocket}. The SO_RCVBUF option is used by
<span class="line-new-header">--- 663,12 ---</span>
       * @throws    SocketException if there is an error in
       * the underlying protocol, such as an UDP error.
       * @see #setSendBufferSize
       * @since 1.2
       */
<span class="line-modified">!     public int getSendBufferSize() throws SocketException {</span>
<span class="line-modified">!         return delegate().getSendBufferSize();</span>
      }
  
      /**
       * Sets the SO_RCVBUF option to the specified value for this
       * {@code DatagramSocket}. The SO_RCVBUF option is used by
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1122,17 ***</span>
       * @throws    IllegalArgumentException if the value is 0 or is
       * negative.
       * @see #getReceiveBufferSize()
       * @since 1.2
       */
<span class="line-modified">!     public synchronized void setReceiveBufferSize(int size) throws SocketException {</span>
<span class="line-modified">!         if (size &lt;= 0) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;invalid receive size&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         getImpl().setOption(SocketOptions.SO_RCVBUF, size);</span>
      }
  
      /**
       * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
       * buffer size used by the platform for input on this {@code DatagramSocket}.
<span class="line-new-header">--- 696,12 ---</span>
       * @throws    IllegalArgumentException if the value is 0 or is
       * negative.
       * @see #getReceiveBufferSize()
       * @since 1.2
       */
<span class="line-modified">!     public void setReceiveBufferSize(int size) throws SocketException {</span>
<span class="line-modified">!         delegate().setReceiveBufferSize(size);</span>
      }
  
      /**
       * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
       * buffer size used by the platform for input on this {@code DatagramSocket}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1140,19 ***</span>
       * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
       * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.
       * @see #setReceiveBufferSize(int)
       * @since 1.2
       */
<span class="line-modified">!     public synchronized int getReceiveBufferSize() throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         int result = 0;</span>
<span class="line-removed">-         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-removed">-         if (o instanceof Integer) {</span>
<span class="line-removed">-             result = ((Integer)o).intValue();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return result;</span>
      }
  
      /**
       * Enable/disable the SO_REUSEADDR socket option.
       * &lt;p&gt;
<span class="line-new-header">--- 709,12 ---</span>
       * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
       * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.
       * @see #setReceiveBufferSize(int)
       * @since 1.2
       */
<span class="line-modified">!     public int getReceiveBufferSize() throws SocketException {</span>
<span class="line-modified">!         return delegate().getReceiveBufferSize();</span>
      }
  
      /**
       * Enable/disable the SO_REUSEADDR socket option.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1185,18 ***</span>
       * @see #getReuseAddress()
       * @see #bind(SocketAddress)
       * @see #isBound()
       * @see #isClosed()
       */
<span class="line-modified">!     public synchronized void setReuseAddress(boolean on) throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         // Integer instead of Boolean for compatibility with older DatagramSocketImpl</span>
<span class="line-removed">-         if (oldImpl)</span>
<span class="line-removed">-             getImpl().setOption(SocketOptions.SO_REUSEADDR, on?-1:0);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));</span>
      }
  
      /**
       * Tests if SO_REUSEADDR is enabled.
       *
<span class="line-new-header">--- 747,12 ---</span>
       * @see #getReuseAddress()
       * @see #bind(SocketAddress)
       * @see #isBound()
       * @see #isClosed()
       */
<span class="line-modified">!     public void setReuseAddress(boolean on) throws SocketException {</span>
<span class="line-modified">!         delegate().setReuseAddress(on);</span>
      }
  
      /**
       * Tests if SO_REUSEADDR is enabled.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1204,15 ***</span>
       * @throws    SocketException if there is an error
       * in the underlying protocol, such as an UDP error.
       * @since   1.4
       * @see #setReuseAddress(boolean)
       */
<span class="line-modified">!     public synchronized boolean getReuseAddress() throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         Object o = getImpl().getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-removed">-         return ((Boolean)o).booleanValue();</span>
      }
  
      /**
       * Enable/disable SO_BROADCAST.
       *
<span class="line-new-header">--- 760,12 ---</span>
       * @throws    SocketException if there is an error
       * in the underlying protocol, such as an UDP error.
       * @since   1.4
       * @see #setReuseAddress(boolean)
       */
<span class="line-modified">!     public boolean getReuseAddress() throws SocketException {</span>
<span class="line-modified">!         return delegate().getReuseAddress();</span>
      }
  
      /**
       * Enable/disable SO_BROADCAST.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1228,28 ***</span>
       *          error.
       *
       * @since 1.4
       * @see #getBroadcast()
       */
<span class="line-modified">!     public synchronized void setBroadcast(boolean on) throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         getImpl().setOption(SocketOptions.SO_BROADCAST, Boolean.valueOf(on));</span>
      }
  
      /**
       * Tests if SO_BROADCAST is enabled.
       * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
       * @throws    SocketException if there is an error
       * in the underlying protocol, such as an UDP error.
       * @since 1.4
       * @see #setBroadcast(boolean)
       */
<span class="line-modified">!     public synchronized boolean getBroadcast() throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         return ((Boolean)(getImpl().getOption(SocketOptions.SO_BROADCAST))).booleanValue();</span>
      }
  
      /**
       * Sets traffic class or type-of-service octet in the IP
       * datagram header for datagrams sent from this DatagramSocket.
<span class="line-new-header">--- 781,24 ---</span>
       *          error.
       *
       * @since 1.4
       * @see #getBroadcast()
       */
<span class="line-modified">!     public void setBroadcast(boolean on) throws SocketException {</span>
<span class="line-modified">!         delegate().setBroadcast(on);</span>
      }
  
      /**
       * Tests if SO_BROADCAST is enabled.
       * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
       * @throws    SocketException if there is an error
       * in the underlying protocol, such as an UDP error.
       * @since 1.4
       * @see #setBroadcast(boolean)
       */
<span class="line-modified">!     public boolean getBroadcast() throws SocketException {</span>
<span class="line-modified">!         return delegate().getBroadcast();</span>
      }
  
      /**
       * Sets traffic class or type-of-service octet in the IP
       * datagram header for datagrams sent from this DatagramSocket.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1285,24 ***</span>
       * @throws SocketException if there is an error setting the
       * traffic class or type-of-service
       * @since 1.4
       * @see #getTrafficClass
       */
<span class="line-modified">!     public synchronized void setTrafficClass(int tc) throws SocketException {</span>
<span class="line-modified">!         if (tc &lt; 0 || tc &gt; 255)</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;tc is not in range 0 -- 255&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             getImpl().setOption(SocketOptions.IP_TOS, tc);</span>
<span class="line-removed">-         } catch (SocketException se) {</span>
<span class="line-removed">-             // not supported if socket already connected</span>
<span class="line-removed">-             // Solaris returns error in such cases</span>
<span class="line-removed">-             if(!isConnected())</span>
<span class="line-removed">-                 throw se;</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Gets traffic class or type-of-service in the IP datagram
       * header for packets sent from this DatagramSocket.
<span class="line-new-header">--- 834,12 ---</span>
       * @throws SocketException if there is an error setting the
       * traffic class or type-of-service
       * @since 1.4
       * @see #getTrafficClass
       */
<span class="line-modified">!     public void setTrafficClass(int tc) throws SocketException {</span>
<span class="line-modified">!         delegate().setTrafficClass(tc);</span>
      }
  
      /**
       * Gets traffic class or type-of-service in the IP datagram
       * header for packets sent from this DatagramSocket.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1317,14 ***</span>
       * @throws SocketException if there is an error obtaining the
       * traffic class or type-of-service value.
       * @since 1.4
       * @see #setTrafficClass(int)
       */
<span class="line-modified">!     public synchronized int getTrafficClass() throws SocketException {</span>
<span class="line-modified">!         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         return ((Integer)(getImpl().getOption(SocketOptions.IP_TOS))).intValue();</span>
      }
  
      /**
       * Closes this datagram socket.
       * &lt;p&gt;
<span class="line-new-header">--- 854,12 ---</span>
       * @throws SocketException if there is an error obtaining the
       * traffic class or type-of-service value.
       * @since 1.4
       * @see #setTrafficClass(int)
       */
<span class="line-modified">!     public int getTrafficClass() throws SocketException {</span>
<span class="line-modified">!         return delegate().getTrafficClass();</span>
      }
  
      /**
       * Closes this datagram socket.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1336,28 ***</span>
       *
       * @revised 1.4
       * @spec JSR-51
       */
      public void close() {
<span class="line-modified">!         synchronized(closeLock) {</span>
<span class="line-removed">-             if (isClosed())</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             impl.close();</span>
<span class="line-removed">-             closed = true;</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Returns whether the socket is closed or not.
       *
       * @return true if the socket has been closed
       * @since 1.4
       */
      public boolean isClosed() {
<span class="line-modified">!         synchronized(closeLock) {</span>
<span class="line-removed">-             return closed;</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Returns the unique {@link java.nio.channels.DatagramChannel} object
       * associated with this datagram socket, if any.
<span class="line-new-header">--- 871,21 ---</span>
       *
       * @revised 1.4
       * @spec JSR-51
       */
      public void close() {
<span class="line-modified">!         delegate().close();</span>
      }
  
      /**
       * Returns whether the socket is closed or not.
       *
       * @return true if the socket has been closed
       * @since 1.4
       */
      public boolean isClosed() {
<span class="line-modified">!         return delegate().isClosed();</span>
      }
  
      /**
       * Returns the unique {@link java.nio.channels.DatagramChannel} object
       * associated with this datagram socket, if any.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1407,11 ***</span>
       * @see       SecurityManager#checkSetFactory
       * @since 1.3
       */
      public static synchronized void
      setDatagramSocketImplFactory(DatagramSocketImplFactory fac)
<span class="line-modified">!        throws IOException</span>
      {
          if (factory != null) {
              throw new SocketException(&quot;factory already defined&quot;);
          }
          SecurityManager security = System.getSecurityManager();
<span class="line-new-header">--- 935,11 ---</span>
       * @see       SecurityManager#checkSetFactory
       * @since 1.3
       */
      public static synchronized void
      setDatagramSocketImplFactory(DatagramSocketImplFactory fac)
<span class="line-modified">!             throws IOException</span>
      {
          if (factory != null) {
              throw new SocketException(&quot;factory already defined&quot;);
          }
          SecurityManager security = System.getSecurityManager();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1450,14 ***</span>
       * @since 9
       */
      public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value)
          throws IOException
      {
<span class="line-modified">!         Objects.requireNonNull(name);</span>
<span class="line-removed">-         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         getImpl().setOption(name, value);</span>
          return this;
      }
  
      /**
       * Returns the value of a socket option.
<span class="line-new-header">--- 978,11 ---</span>
       * @since 9
       */
      public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value)
          throws IOException
      {
<span class="line-modified">!         delegate().setOption(name, value);</span>
          return this;
      }
  
      /**
       * Returns the value of a socket option.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1481,19 ***</span>
       *         do not require any security permission.
       *
       * @since 9
       */
      public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-modified">!         Objects.requireNonNull(name);</span>
<span class="line-removed">-         if (isClosed())</span>
<span class="line-removed">-             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">-         return getImpl().getOption(name);</span>
      }
  
<span class="line-removed">-     private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;</span>
<span class="line-removed">-     private final Object optionsLock = new Object();</span>
<span class="line-removed">- </span>
      /**
       * Returns a set of the socket options supported by this socket.
       *
       * This method will continue to return the set of options even after
       * the socket has been closed.
<span class="line-new-header">--- 1006,13 ---</span>
       *         do not require any security permission.
       *
       * @since 9
       */
      public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-modified">!         return delegate().getOption(name);</span>
      }
  
      /**
       * Returns a set of the socket options supported by this socket.
       *
       * This method will continue to return the set of options even after
       * the socket has been closed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1502,24 ***</span>
       *        may be empty if the socket&#39;s DatagramSocketImpl cannot be created.
       *
       * @since 9
       */
      public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="line-modified">!         Set&lt;SocketOption&lt;?&gt;&gt; options = this.options;</span>
<span class="line-modified">!         if (options != null)</span>
<span class="line-removed">-             return options;</span>
  
<span class="line-modified">!         synchronized (optionsLock) {</span>
<span class="line-modified">!             options = this.options;</span>
<span class="line-modified">!             if (options != null)</span>
<span class="line-removed">-                 return options;</span>
  
              try {
<span class="line-modified">!                 DatagramSocketImpl impl = getImpl();</span>
<span class="line-modified">!                 options = Collections.unmodifiableSet(impl.supportedOptions());</span>
<span class="line-modified">!             } catch (IOException e) {</span>
<span class="line-modified">!                 options = Collections.emptySet();</span>
              }
<span class="line-removed">-             return this.options = options;</span>
          }
      }
  }
<span class="line-new-header">--- 1021,119 ---</span>
       *        may be empty if the socket&#39;s DatagramSocketImpl cannot be created.
       *
       * @since 9
       */
      public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="line-modified">!         return delegate().supportedOptions();</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     // Temporary solution until JDK-8237352 is addressed</span>
<span class="line-modified">!     private static final SocketAddress NO_DELEGATE = new SocketAddress() {};</span>
<span class="line-modified">!     private static final boolean USE_PLAINDATAGRAMSOCKET = usePlainDatagramSocketImpl();</span>
  
<span class="line-added">+     private static boolean usePlainDatagramSocketImpl() {</span>
<span class="line-added">+         PrivilegedAction&lt;String&gt; pa = () -&gt; NetProperties.get(&quot;jdk.net.usePlainDatagramSocketImpl&quot;);</span>
<span class="line-added">+         String s = AccessController.doPrivileged(pa);</span>
<span class="line-added">+         return (s != null) &amp;&amp; (s.isEmpty() || s.equalsIgnoreCase(&quot;true&quot;));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Best effort to convert an {@link IOException}</span>
<span class="line-added">+      * into a {@link SocketException}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param e an instance of {@link IOException}</span>
<span class="line-added">+      * @return an instance of {@link SocketException}</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static SocketException toSocketException(IOException e) {</span>
<span class="line-added">+         if (e instanceof SocketException)</span>
<span class="line-added">+             return (SocketException) e;</span>
<span class="line-added">+         Throwable cause = e.getCause();</span>
<span class="line-added">+         if (cause instanceof SocketException)</span>
<span class="line-added">+             return (SocketException) cause;</span>
<span class="line-added">+         SocketException se = new SocketException(e.getMessage());</span>
<span class="line-added">+         se.initCause(e);</span>
<span class="line-added">+         return se;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Creates a delegate for the specific requested {@code type}. This method should</span>
<span class="line-added">+      * only be called by {@code DatagramSocket} and {@code MulticastSocket}</span>
<span class="line-added">+      * public constructors.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param bindaddr An address to bind to, or {@code null} if creating an unbound</span>
<span class="line-added">+      *                 socket.</span>
<span class="line-added">+      * @param type     This is either {@code MulticastSocket.class}, if the delegate needs</span>
<span class="line-added">+      *                 to support joining multicast groups, or {@code DatagramSocket.class},</span>
<span class="line-added">+      *                 if it doesn&#39;t. Typically, this will be {@code DatagramSocket.class}</span>
<span class="line-added">+      *                 when creating a delegate for {@code DatagramSocket}, and</span>
<span class="line-added">+      *                 {@code MulticastSocket.class} when creating a delegate for</span>
<span class="line-added">+      *                 {@code MulticastSocket}.</span>
<span class="line-added">+      * @param &lt;T&gt;      The target type for which the delegate is created.</span>
<span class="line-added">+      *                 This is either {@code java.net.DatagramSocket} or</span>
<span class="line-added">+      *                 {@code java.net.MulticastSocket}.</span>
<span class="line-added">+      * @return {@code null} if {@code bindaddr == NO_DELEGATE}, otherwise returns a</span>
<span class="line-added">+      * delegate for the requested {@code type}.</span>
<span class="line-added">+      * @throws SocketException if an exception occurs while creating or binding the</span>
<span class="line-added">+      *                         the delegate.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static &lt;T extends DatagramSocket&gt; T createDelegate(SocketAddress bindaddr, Class&lt;T&gt; type)</span>
<span class="line-added">+             throws SocketException {</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Temporary solution until JDK-8237352 is addressed</span>
<span class="line-added">+         if (bindaddr == NO_DELEGATE) return null;</span>
<span class="line-added">+ </span>
<span class="line-added">+         assert type == DatagramSocket.class || type == MulticastSocket.class;</span>
<span class="line-added">+         boolean multicast = (type == MulticastSocket.class);</span>
<span class="line-added">+         DatagramSocket delegate = null;</span>
<span class="line-added">+         boolean initialized = false;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             DatagramSocketImplFactory factory = DatagramSocket.factory;</span>
<span class="line-added">+             if (USE_PLAINDATAGRAMSOCKET || factory != null) {</span>
<span class="line-added">+                 // create legacy DatagramSocket delegate</span>
<span class="line-added">+                 DatagramSocketImpl impl;</span>
<span class="line-added">+                 if (factory != null) {</span>
<span class="line-added">+                     impl = factory.createDatagramSocketImpl();</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 delegate = new NetMulticastSocket(impl);</span>
<span class="line-added">+                 ((NetMulticastSocket) delegate).getImpl(); // ensure impl.create() is called.</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // create NIO adaptor</span>
<span class="line-added">+                 delegate = DefaultSelectorProvider.get()</span>
<span class="line-added">+                         .openUninterruptibleDatagramChannel()</span>
<span class="line-added">+                         .socket();</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (multicast) {</span>
<span class="line-added">+                 // set reuseaddress if multicasting</span>
<span class="line-added">+                 // (must be set before binding)</span>
<span class="line-added">+                 delegate.setReuseAddress(true);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (bindaddr != null) {</span>
<span class="line-added">+                 // bind if needed</span>
<span class="line-added">+                 delegate.bind(bindaddr);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // enable broadcast if possible</span>
              try {
<span class="line-modified">!                 delegate.setBroadcast(true);</span>
<span class="line-modified">!             } catch (IOException ioe) {</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-added">+             initialized = true;</span>
<span class="line-added">+         } catch (IOException ioe) {</span>
<span class="line-added">+             throw toSocketException(ioe);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             // make sure the delegate is closed if anything</span>
<span class="line-added">+             // went wrong</span>
<span class="line-added">+             if (!initialized &amp;&amp; delegate != null) {</span>
<span class="line-added">+                 delegate.close();</span>
              }
          }
<span class="line-added">+         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">+         T result = (T) delegate;</span>
<span class="line-added">+         return result;</span>
      }
<span class="line-added">+ </span>
  }
</pre>
<center><a href="../lang/invoke/StringConcatFactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
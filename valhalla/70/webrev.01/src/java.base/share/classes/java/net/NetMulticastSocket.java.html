<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/net/NetMulticastSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.IOException;
  29 import java.io.UncheckedIOException;
  30 import java.nio.channels.DatagramChannel;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedExceptionAction;
  33 import java.util.Enumeration;
  34 import java.util.Objects;
  35 import java.util.Set;
  36 import java.util.Collections;
  37 
  38 /**
  39  * A multicast datagram socket that delegates socket operations to a
  40  * {@link DatagramSocketImpl}.
  41  *
  42  * This class overrides every public method defined by {@link DatagramSocket}
  43  * and {@link MulticastSocket}.
  44  */
  45 final class NetMulticastSocket extends MulticastSocket {
  46     /**
  47      * Various states of this socket.
  48      */
  49     private boolean bound = false;
  50     private boolean closed = false;
  51     private volatile boolean created;
  52     private final Object closeLock = new Object();
  53 
  54     /*
  55      * The implementation of this DatagramSocket.
  56      */
  57     private final DatagramSocketImpl impl;
  58 
  59     /**
  60      * Are we using an older DatagramSocketImpl?
  61      */
  62     private final boolean oldImpl;
  63 
  64     /**
  65      * Set when a socket is ST_CONNECTED until we are certain
  66      * that any packets which might have been received prior
  67      * to calling connect() but not read by the application
  68      * have been read. During this time we check the source
  69      * address of all packets received to be sure they are from
  70      * the connected destination. Other packets are read but
  71      * silently dropped.
  72      */
  73     private boolean explicitFilter = false;
  74     private int bytesLeftToFilter;
  75     /*
  76      * Connection state:
  77      * ST_NOT_CONNECTED = socket not connected
  78      * ST_CONNECTED = socket connected
  79      * ST_CONNECTED_NO_IMPL = socket connected but not at impl level
  80      */
  81     static final int ST_NOT_CONNECTED = 0;
  82     static final int ST_CONNECTED = 1;
  83     static final int ST_CONNECTED_NO_IMPL = 2;
  84 
  85     int connectState = ST_NOT_CONNECTED;
  86 
  87     /*
  88      * Connected address &amp; port
  89      */
  90     InetAddress connectedAddress = null;
  91     int connectedPort = -1;
  92 
  93     /**
  94      * This constructor is also used by {@link DatagramSocket#DatagramSocket(DatagramSocketImpl)}.
  95      * @param impl The impl used in this instance.
  96      */
  97     NetMulticastSocket(DatagramSocketImpl impl) {
  98         super((MulticastSocket) null);
  99         this.impl = Objects.requireNonNull(impl);
 100         this.oldImpl = checkOldImpl(impl);
 101     }
 102 
 103     /**
 104      * Connects this socket to a remote socket address (IP address + port number).
 105      * Binds socket if not already bound.
 106      *
 107      * @param   address The remote address.
 108      * @param   port    The remote port
 109      * @throws  SocketException if binding the socket fails.
 110      */
 111     private synchronized void connectInternal(InetAddress address, int port) throws SocketException {
 112         if (port &lt; 0 || port &gt; 0xFFFF) {
 113             throw new IllegalArgumentException(&quot;connect: &quot; + port);
 114         }
 115         if (address == null) {
 116             throw new IllegalArgumentException(&quot;connect: null address&quot;);
 117         }
 118         checkAddress(address, &quot;connect&quot;);
 119         if (isClosed())
 120             return;
 121         SecurityManager security = System.getSecurityManager();
 122         if (security != null) {
 123             if (address.isMulticastAddress()) {
 124                 security.checkMulticast(address);
 125             } else {
 126                 security.checkConnect(address.getHostAddress(), port);
 127                 security.checkAccept(address.getHostAddress(), port);
 128             }
 129         }
 130 
 131         if (port == 0) {
 132             throw new SocketException(&quot;Can&#39;t connect to port 0&quot;);
 133         }
 134         if (!isBound())
 135             bind(new InetSocketAddress(0));
 136 
 137         // old impls do not support connect/disconnect
 138         if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &amp;&amp;
 139                 ((AbstractPlainDatagramSocketImpl) impl).nativeConnectDisabled())) {
 140             connectState = ST_CONNECTED_NO_IMPL;
 141         } else {
 142             try {
 143                 getImpl().connect(address, port);
 144 
 145                 // socket is now connected by the impl
 146                 connectState = ST_CONNECTED;
 147                 // Do we need to filter some packets?
 148                 int avail = getImpl().dataAvailable();
 149                 if (avail == -1) {
 150                     throw new SocketException();
 151                 }
 152                 explicitFilter = avail &gt; 0;
 153                 if (explicitFilter) {
 154                     bytesLeftToFilter = getReceiveBufferSize();
 155                 }
 156             } catch (SocketException se) {
 157 
 158                 // connection will be emulated by DatagramSocket
 159                 connectState = ST_CONNECTED_NO_IMPL;
 160             }
 161         }
 162 
 163         connectedAddress = address;
 164         connectedPort = port;
 165     }
 166 
 167     /**
 168      * Return true if the given DatagramSocketImpl is an &quot;old&quot; impl. An old impl
 169      * is one that doesn&#39;t implement the abstract methods added in Java SE 1.4.
 170      */
 171     private static boolean checkOldImpl(DatagramSocketImpl impl) {
 172         // DatagramSocketImpl.peekData() is a protected method, therefore we need to use
 173         // getDeclaredMethod, therefore we need permission to access the member
 174         try {
 175             AccessController.doPrivileged(
 176                 new PrivilegedExceptionAction&lt;&gt;() {
 177                     public Void run() throws NoSuchMethodException {
 178                         Class&lt;?&gt;[] cl = new Class&lt;?&gt;[1];
 179                         cl[0] = DatagramPacket.class;
 180                         impl.getClass().getDeclaredMethod(&quot;peekData&quot;, cl);
 181                         return null;
 182                     }
 183                 });
 184             return false;
 185         } catch (java.security.PrivilegedActionException e) {
 186             return true;
 187         }
 188     }
 189 
 190     /**
 191      * Return the {@code DatagramSocketImpl} attached to this socket,
 192      * creating the socket if not already created.
 193      *
 194      * @return  the {@code DatagramSocketImpl} attached to that
 195      *          DatagramSocket
 196      * @throws SocketException if creating the socket fails
 197      * @since 1.4
 198      */
 199     final DatagramSocketImpl getImpl() throws SocketException {
 200         if (!created) {
 201             synchronized (this) {
 202                 if (!created)  {
 203                     impl.create();
 204                     created = true;
 205                 }
 206             }
 207         }
 208         return impl;
 209     }
 210 
 211     @Override
 212     public synchronized void bind(SocketAddress addr) throws SocketException {
 213         if (isClosed())
 214             throw new SocketException(&quot;Socket is closed&quot;);
 215         if (isBound())
 216             throw new SocketException(&quot;already bound&quot;);
 217         if (addr == null)
 218             addr = new InetSocketAddress(0);
 219         if (!(addr instanceof InetSocketAddress))
 220             throw new IllegalArgumentException(&quot;Unsupported address type!&quot;);
 221         InetSocketAddress epoint = (InetSocketAddress) addr;
 222         if (epoint.isUnresolved())
 223             throw new SocketException(&quot;Unresolved address&quot;);
 224         InetAddress iaddr = epoint.getAddress();
 225         int port = epoint.getPort();
 226         checkAddress(iaddr, &quot;bind&quot;);
 227         SecurityManager sec = System.getSecurityManager();
 228         if (sec != null) {
 229             sec.checkListen(port);
 230         }
 231         try {
 232             getImpl().bind(port, iaddr);
 233         } catch (SocketException e) {
 234             getImpl().close();
 235             throw e;
 236         }
 237         bound = true;
 238     }
 239 
 240     static void checkAddress(InetAddress addr, String op) {
 241         if (addr == null) {
 242             return;
 243         }
 244         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {
 245             throw new IllegalArgumentException(op + &quot;: invalid address type&quot;);
 246         }
 247     }
 248 
 249     @Override
 250     public void connect(InetAddress address, int port) {
 251         try {
 252             connectInternal(address, port);
 253         } catch (SocketException se) {
 254             throw new UncheckedIOException(&quot;connect failed&quot;, se);
 255         }
 256     }
 257 
 258     @Override
 259     public void connect(SocketAddress addr) throws SocketException {
 260         if (addr == null)
 261             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
 262         if (!(addr instanceof InetSocketAddress))
 263             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 264         InetSocketAddress epoint = (InetSocketAddress) addr;
 265         if (epoint.isUnresolved())
 266             throw new SocketException(&quot;Unresolved address&quot;);
 267         connectInternal(epoint.getAddress(), epoint.getPort());
 268     }
 269 
 270     @Override
 271     public void disconnect() {
 272         synchronized (this) {
 273             if (isClosed())
 274                 return;
 275             if (connectState == ST_CONNECTED) {
 276                 impl.disconnect();
 277             }
 278             connectedAddress = null;
 279             connectedPort = -1;
 280             connectState = ST_NOT_CONNECTED;
 281             explicitFilter = false;
 282         }
 283     }
 284 
 285     @Override
 286     public boolean isBound() {
 287         return bound;
 288     }
 289 
 290     @Override
 291     public boolean isConnected() {
 292         return connectState != ST_NOT_CONNECTED;
 293     }
 294 
 295     @Override
 296     public InetAddress getInetAddress() {
 297         return connectedAddress;
 298     }
 299 
 300     @Override
 301     public int getPort() {
 302         return connectedPort;
 303     }
 304 
 305     @Override
 306     public SocketAddress getRemoteSocketAddress() {
 307         if (!isConnected())
 308             return null;
 309         return new InetSocketAddress(getInetAddress(), getPort());
 310     }
 311 
 312     @Override
 313     public SocketAddress getLocalSocketAddress() {
 314         if (isClosed())
 315             return null;
 316         if (!isBound())
 317             return null;
 318         return new InetSocketAddress(getLocalAddress(), getLocalPort());
 319     }
 320 
 321     @Override
 322     public void send(DatagramPacket p) throws IOException {
 323         synchronized (p) {
 324             if (isClosed())
 325                 throw new SocketException(&quot;Socket is closed&quot;);
 326             InetAddress packetAddress = p.getAddress();
 327             int packetPort = p.getPort();
 328             checkAddress(packetAddress, &quot;send&quot;);
 329             if (connectState == ST_NOT_CONNECTED) {
 330                 if (packetAddress == null) {
 331                     throw new IllegalArgumentException(&quot;Address not set&quot;);
 332                 }
 333                 if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)
 334                     throw new IllegalArgumentException(&quot;port out of range: &quot; + packetPort);
 335                 // check the address is ok with the security manager on every send.
 336                 SecurityManager security = System.getSecurityManager();
 337 
 338                 // The reason you want to synchronize on datagram packet
 339                 // is because you don&#39;t want an applet to change the address
 340                 // while you are trying to send the packet for example
 341                 // after the security check but before the send.
 342                 if (security != null) {
 343                     if (packetAddress.isMulticastAddress()) {
 344                         security.checkMulticast(packetAddress);
 345                     } else {
 346                         security.checkConnect(packetAddress.getHostAddress(),
 347                                 packetPort);
 348                     }
 349                 }
 350                 if (packetPort == 0) {
 351                     throw new SocketException(&quot;Can&#39;t send to port 0&quot;);
 352                 }
 353             } else {
 354                 // we&#39;re connected
 355                 if (packetAddress == null) {
 356                     p.setAddress(connectedAddress);
 357                     p.setPort(connectedPort);
 358                 } else if ((!packetAddress.equals(connectedAddress)) ||
 359                         packetPort != connectedPort) {
 360                     throw new IllegalArgumentException(&quot;connected address &quot; +
 361                             &quot;and packet address&quot; +
 362                             &quot; differ&quot;);
 363                 }
 364             }
 365             // Check whether the socket is bound
 366             if (!isBound())
 367                 bind(new InetSocketAddress(0));
 368             // call the  method to send
 369             getImpl().send(p);
 370         }
 371     }
 372 
 373     @Override
 374     public synchronized void receive(DatagramPacket p) throws IOException {
 375         synchronized (p) {
 376             if (!isBound())
 377                 bind(new InetSocketAddress(0));
 378             if (connectState == ST_NOT_CONNECTED) {
 379                 // check the address is ok with the security manager before every recv.
 380                 SecurityManager security = System.getSecurityManager();
 381                 if (security != null) {
 382                     while (true) {
 383                         String peekAd = null;
 384                         int peekPort = 0;
 385                         // peek at the packet to see who it is from.
 386                         if (!oldImpl) {
 387                             // We can use the new peekData() API
 388                             DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
 389                             peekPort = getImpl().peekData(peekPacket);
 390                             peekAd = peekPacket.getAddress().getHostAddress();
 391                         } else {
 392                             InetAddress adr = new InetAddress();
 393                             peekPort = getImpl().peek(adr);
 394                             peekAd = adr.getHostAddress();
 395                         }
 396                         try {
 397                             security.checkAccept(peekAd, peekPort);
 398                             // security check succeeded - so now break
 399                             // and recv the packet.
 400                             break;
 401                         } catch (SecurityException se) {
 402                             // Throw away the offending packet by consuming
 403                             // it in a tmp buffer.
 404                             DatagramPacket tmp = new DatagramPacket(new byte[1], 1);
 405                             getImpl().receive(tmp);
 406 
 407                             // silently discard the offending packet
 408                             // and continue: unknown/malicious
 409                             // entities on nets should not make
 410                             // runtime throw security exception and
 411                             // disrupt the applet by sending random
 412                             // datagram packets.
 413                             continue;
 414                         }
 415                     } // end of while
 416                 }
 417             }
 418             DatagramPacket tmp = null;
 419             if ((connectState == ST_CONNECTED_NO_IMPL) || explicitFilter) {
 420                 // We have to do the filtering the old fashioned way since
 421                 // the native impl doesn&#39;t support connect or the connect
 422                 // via the impl failed, or .. &quot;explicitFilter&quot; may be set when
 423                 // a socket is connected via the impl, for a period of time
 424                 // when packets from other sources might be queued on socket.
 425                 boolean stop = false;
 426                 while (!stop) {
 427                     InetAddress peekAddress = null;
 428                     int peekPort = -1;
 429                     // peek at the packet to see who it is from.
 430                     if (!oldImpl) {
 431                         // We can use the new peekData() API
 432                         DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
 433                         peekPort = getImpl().peekData(peekPacket);
 434                         peekAddress = peekPacket.getAddress();
 435                     } else {
 436                         // this api only works for IPv4
 437                         peekAddress = new InetAddress();
 438                         peekPort = getImpl().peek(peekAddress);
 439                     }
 440                     if ((!connectedAddress.equals(peekAddress)) ||
 441                             (connectedPort != peekPort)) {
 442                         // throw the packet away and silently continue
 443                         tmp = new DatagramPacket(
 444                                 new byte[1024], 1024);
 445                         getImpl().receive(tmp);
 446                         if (explicitFilter) {
 447                             if (checkFiltering(tmp)) {
 448                                 stop = true;
 449                             }
 450                         }
 451                     } else {
 452                         stop = true;
 453                     }
 454                 }
 455             }
 456             // If the security check succeeds, or the datagram is
 457             // connected then receive the packet
 458             getImpl().receive(p);
 459             if (explicitFilter &amp;&amp; tmp == null) {
 460                 // packet was not filtered, account for it here
 461                 checkFiltering(p);
 462             }
 463         }
 464     }
 465 
 466     private boolean checkFiltering(DatagramPacket p) throws SocketException {
 467         bytesLeftToFilter -= p.getLength();
 468         if (bytesLeftToFilter &lt;= 0 || getImpl().dataAvailable() &lt;= 0) {
 469             explicitFilter = false;
 470             return true;
 471         }
 472         return false;
 473     }
 474 
 475     @Override
 476     public InetAddress getLocalAddress() {
 477         if (isClosed())
 478             return null;
 479         InetAddress in;
 480         try {
 481             in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);
 482             if (in.isAnyLocalAddress()) {
 483                 in = InetAddress.anyLocalAddress();
 484             }
 485             SecurityManager s = System.getSecurityManager();
 486             if (s != null) {
 487                 s.checkConnect(in.getHostAddress(), -1);
 488             }
 489         } catch (Exception e) {
 490             in = InetAddress.anyLocalAddress(); // &quot;0.0.0.0&quot;
 491         }
 492         return in;
 493     }
 494 
 495     @Override
 496     public int getLocalPort() {
 497         if (isClosed())
 498             return -1;
 499         try {
 500             return getImpl().getLocalPort();
 501         } catch (Exception e) {
 502             return 0;
 503         }
 504     }
 505 
 506     @Override
 507     public synchronized void setSoTimeout(int timeout) throws SocketException {
 508         if (isClosed())
 509             throw new SocketException(&quot;Socket is closed&quot;);
 510         if (timeout &lt; 0)
 511             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);
 512         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
 513     }
 514 
 515     @Override
 516     public synchronized int getSoTimeout() throws SocketException {
 517         if (isClosed())
 518             throw new SocketException(&quot;Socket is closed&quot;);
 519         if (getImpl() == null)
 520             return 0;
 521         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
 522         /* extra type safety */
 523         if (o instanceof Integer) {
 524             return ((Integer) o).intValue();
 525         } else {
 526             return 0;
 527         }
 528     }
 529 
 530     @Override
 531     public synchronized void setSendBufferSize(int size) throws SocketException {
 532         if (!(size &gt; 0)) {
 533             throw new IllegalArgumentException(&quot;negative send size&quot;);
 534         }
 535         if (isClosed())
 536             throw new SocketException(&quot;Socket is closed&quot;);
 537         getImpl().setOption(SocketOptions.SO_SNDBUF, size);
 538     }
 539 
 540     @Override
 541     public synchronized int getSendBufferSize() throws SocketException {
 542         if (isClosed())
 543             throw new SocketException(&quot;Socket is closed&quot;);
 544         int result = 0;
 545         Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);
 546         if (o instanceof Integer) {
 547             result = ((Integer) o).intValue();
 548         }
 549         return result;
 550     }
 551 
 552     @Override
 553     public synchronized void setReceiveBufferSize(int size) throws SocketException {
 554         if (size &lt;= 0) {
 555             throw new IllegalArgumentException(&quot;invalid receive size&quot;);
 556         }
 557         if (isClosed())
 558             throw new SocketException(&quot;Socket is closed&quot;);
 559         getImpl().setOption(SocketOptions.SO_RCVBUF, size);
 560     }
 561 
 562     @Override
 563     public synchronized int getReceiveBufferSize() throws SocketException {
 564         if (isClosed())
 565             throw new SocketException(&quot;Socket is closed&quot;);
 566         int result = 0;
 567         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
 568         if (o instanceof Integer) {
 569             result = ((Integer) o).intValue();
 570         }
 571         return result;
 572     }
 573 
 574     @Override
 575     public synchronized void setReuseAddress(boolean on) throws SocketException {
 576         if (isClosed())
 577             throw new SocketException(&quot;Socket is closed&quot;);
 578         // Integer instead of Boolean for compatibility with older DatagramSocketImpl
 579         if (oldImpl)
 580             getImpl().setOption(SocketOptions.SO_REUSEADDR, on ? -1 : 0);
 581         else
 582             getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
 583     }
 584 
 585     @Override
 586     public synchronized boolean getReuseAddress() throws SocketException {
 587         if (isClosed())
 588             throw new SocketException(&quot;Socket is closed&quot;);
 589         Object o = getImpl().getOption(SocketOptions.SO_REUSEADDR);
 590         return ((Boolean) o).booleanValue();
 591     }
 592 
 593     @Override
 594     public synchronized void setBroadcast(boolean on) throws SocketException {
 595         if (isClosed())
 596             throw new SocketException(&quot;Socket is closed&quot;);
 597         getImpl().setOption(SocketOptions.SO_BROADCAST, Boolean.valueOf(on));
 598     }
 599 
 600     @Override
 601     public synchronized boolean getBroadcast() throws SocketException {
 602         if (isClosed())
 603             throw new SocketException(&quot;Socket is closed&quot;);
 604         return ((Boolean) (getImpl().getOption(SocketOptions.SO_BROADCAST))).booleanValue();
 605     }
 606 
 607     @Override
 608     public synchronized void setTrafficClass(int tc) throws SocketException {
 609         if (tc &lt; 0 || tc &gt; 255)
 610             throw new IllegalArgumentException(&quot;tc is not in range 0 -- 255&quot;);
 611 
 612         if (isClosed())
 613             throw new SocketException(&quot;Socket is closed&quot;);
 614         try {
 615             getImpl().setOption(SocketOptions.IP_TOS, tc);
 616         } catch (SocketException se) {
 617             // not supported if socket already connected
 618             // Solaris returns error in such cases
 619             if (!isConnected())
 620                 throw se;
 621         }
 622     }
 623 
 624     @Override
 625     public synchronized int getTrafficClass() throws SocketException {
 626         if (isClosed())
 627             throw new SocketException(&quot;Socket is closed&quot;);
 628         return ((Integer) (getImpl().getOption(SocketOptions.IP_TOS))).intValue();
 629     }
 630 
 631     @Override
 632     public void close() {
 633         synchronized (closeLock) {
 634             if (isClosed())
 635                 return;
 636             impl.close();
 637             closed = true;
 638         }
 639     }
 640 
 641     @Override
 642     public boolean isClosed() {
 643         synchronized (closeLock) {
 644             return closed;
 645         }
 646     }
 647 
 648     @Override
 649     public  &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value)
 650             throws IOException
 651     {
 652         Objects.requireNonNull(name);
 653         if (isClosed())
 654             throw new SocketException(&quot;Socket is closed&quot;);
 655         getImpl().setOption(name, value);
 656         return this;
 657     }
 658 
 659     @Override
 660     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
 661         Objects.requireNonNull(name);
 662         if (isClosed())
 663             throw new SocketException(&quot;Socket is closed&quot;);
 664         return getImpl().getOption(name);
 665     }
 666 
 667     private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;
 668     private final Object optionsLock = new Object();
 669 
 670     @Override
 671     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 672         Set&lt;SocketOption&lt;?&gt;&gt; options = this.options;
 673         if (options != null)
 674             return options;
 675         synchronized (optionsLock) {
 676             options = this.options;
 677             if (options != null) {
 678                 return options;
 679             }
 680             try {
 681                 DatagramSocketImpl impl = getImpl();
 682                 options = Collections.unmodifiableSet(impl.supportedOptions());
 683             } catch (IOException e) {
 684                 options = Collections.emptySet();
 685             }
 686             return this.options = options;
 687         }
 688     }
 689 
 690     // Multicast socket support
 691 
 692     /**
 693      * Used on some platforms to record if an outgoing interface
 694      * has been set for this socket.
 695      */
 696     private boolean interfaceSet;
 697 
 698     /**
 699      * The lock on the socket&#39;s TTL. This is for set/getTTL and
 700      * send(packet,ttl).
 701      */
 702     private final Object ttlLock = new Object();
 703 
 704     /**
 705      * The lock on the socket&#39;s interface - used by setInterface
 706      * and getInterface
 707      */
 708     private final Object infLock = new Object();
 709 
 710     /**
 711      * The &quot;last&quot; interface set by setInterface on this MulticastSocket
 712      */
 713     private InetAddress infAddress = null;
 714 
 715     @Deprecated
 716     @Override
 717     public void setTTL(byte ttl) throws IOException {
 718         if (isClosed())
 719             throw new SocketException(&quot;Socket is closed&quot;);
 720         getImpl().setTTL(ttl);
 721     }
 722 
 723     @Override
 724     public void setTimeToLive(int ttl) throws IOException {
 725         if (ttl &lt; 0 || ttl &gt; 255) {
 726             throw new IllegalArgumentException(&quot;ttl out of range&quot;);
 727         }
 728         if (isClosed())
 729             throw new SocketException(&quot;Socket is closed&quot;);
 730         getImpl().setTimeToLive(ttl);
 731     }
 732 
 733     @Deprecated
 734     @Override
 735     public byte getTTL() throws IOException {
 736         if (isClosed())
 737             throw new SocketException(&quot;Socket is closed&quot;);
 738         return getImpl().getTTL();
 739     }
 740 
 741     @Override
 742     public int getTimeToLive() throws IOException {
 743         if (isClosed())
 744             throw new SocketException(&quot;Socket is closed&quot;);
 745         return getImpl().getTimeToLive();
 746     }
 747 
 748     @Override
 749     @Deprecated
 750     public void joinGroup(InetAddress mcastaddr) throws IOException {
 751         if (isClosed()) {
 752             throw new SocketException(&quot;Socket is closed&quot;);
 753         }
 754 
 755         checkAddress(mcastaddr, &quot;joinGroup&quot;);
 756         SecurityManager security = System.getSecurityManager();
 757         if (security != null) {
 758             security.checkMulticast(mcastaddr);
 759         }
 760 
 761         if (!mcastaddr.isMulticastAddress()) {
 762             throw new SocketException(&quot;Not a multicast address&quot;);
 763         }
 764 
 765         /**
 766          * required for some platforms where it&#39;s not possible to join
 767          * a group without setting the interface first.
 768          */
 769         NetworkInterface defaultInterface = NetworkInterface.getDefault();
 770 
 771         if (!interfaceSet &amp;&amp; defaultInterface != null) {
 772             setNetworkInterface(defaultInterface);
 773         }
 774 
 775         getImpl().join(mcastaddr);
 776     }
 777 
 778     @Override
 779     @Deprecated
 780     public void leaveGroup(InetAddress mcastaddr) throws IOException {
 781         if (isClosed()) {
 782             throw new SocketException(&quot;Socket is closed&quot;);
 783         }
 784 
 785         checkAddress(mcastaddr, &quot;leaveGroup&quot;);
 786         SecurityManager security = System.getSecurityManager();
 787         if (security != null) {
 788             security.checkMulticast(mcastaddr);
 789         }
 790 
 791         if (!mcastaddr.isMulticastAddress()) {
 792             throw new SocketException(&quot;Not a multicast address&quot;);
 793         }
 794 
 795         getImpl().leave(mcastaddr);
 796     }
 797 
 798     @Override
 799     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
 800             throws IOException {
 801         if (isClosed())
 802             throw new SocketException(&quot;Socket is closed&quot;);
 803 
 804         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
 805             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 806 
 807         if (oldImpl)
 808             throw new UnsupportedOperationException();
 809 
 810         checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;joinGroup&quot;);
 811         SecurityManager security = System.getSecurityManager();
 812         if (security != null) {
 813             security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());
 814         }
 815 
 816         if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {
 817             throw new SocketException(&quot;Not a multicast address&quot;);
 818         }
 819 
 820         getImpl().joinGroup(mcastaddr, netIf);
 821     }
 822 
 823     @Override
 824     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
 825             throws IOException {
 826         if (isClosed())
 827             throw new SocketException(&quot;Socket is closed&quot;);
 828 
 829         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
 830             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 831 
 832         if (oldImpl)
 833             throw new UnsupportedOperationException();
 834 
 835         checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;leaveGroup&quot;);
 836         SecurityManager security = System.getSecurityManager();
 837         if (security != null) {
 838             security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());
 839         }
 840 
 841         if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {
 842             throw new SocketException(&quot;Not a multicast address&quot;);
 843         }
 844 
 845         getImpl().leaveGroup(mcastaddr, netIf);
 846     }
 847 
 848     @Override
 849     @Deprecated
 850     public void setInterface(InetAddress inf) throws SocketException {
 851         if (isClosed()) {
 852             throw new SocketException(&quot;Socket is closed&quot;);
 853         }
 854         checkAddress(inf, &quot;setInterface&quot;);
 855         synchronized (infLock) {
 856             getImpl().setOption(SocketOptions.IP_MULTICAST_IF, inf);
 857             infAddress = inf;
 858             interfaceSet = true;
 859         }
 860     }
 861 
 862     @Override
 863     @Deprecated
 864     public InetAddress getInterface() throws SocketException {
 865         if (isClosed()) {
 866             throw new SocketException(&quot;Socket is closed&quot;);
 867         }
 868         synchronized (infLock) {
 869             InetAddress ia =
 870                     (InetAddress)getImpl().getOption(SocketOptions.IP_MULTICAST_IF);
 871 
 872             /**
 873              * No previous setInterface or interface can be
 874              * set using setNetworkInterface
 875              */
 876             if (infAddress == null) {
 877                 return ia;
 878             }
 879 
 880             /**
 881              * Same interface set with setInterface?
 882              */
 883             if (ia.equals(infAddress)) {
 884                 return ia;
 885             }
 886 
 887             /**
 888              * Different InetAddress from what we set with setInterface
 889              * so enumerate the current interface to see if the
 890              * address set by setInterface is bound to this interface.
 891              */
 892             try {
 893                 NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
 894                 Enumeration&lt;InetAddress&gt; addrs = ni.getInetAddresses();
 895                 while (addrs.hasMoreElements()) {
 896                     InetAddress addr = addrs.nextElement();
 897                     if (addr.equals(infAddress)) {
 898                         return infAddress;
 899                     }
 900                 }
 901 
 902                 /**
 903                  * No match so reset infAddress to indicate that the
 904                  * interface has changed via means
 905                  */
 906                 infAddress = null;
 907                 return ia;
 908             } catch (Exception e) {
 909                 return ia;
 910             }
 911         }
 912     }
 913 
 914     @Override
 915     public void setNetworkInterface(NetworkInterface netIf)
 916             throws SocketException {
 917 
 918         synchronized (infLock) {
 919             getImpl().setOption(SocketOptions.IP_MULTICAST_IF2, netIf);
 920             infAddress = null;
 921             interfaceSet = true;
 922         }
 923     }
 924 
 925     @Override
 926     public NetworkInterface getNetworkInterface() throws SocketException {
 927         NetworkInterface ni
 928                 = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);
 929         if (ni == null) {
 930             InetAddress[] addrs = new InetAddress[1];
 931             addrs[0] = InetAddress.anyLocalAddress();
 932             return new NetworkInterface(addrs[0].getHostName(), 0, addrs);
 933         } else {
 934             return ni;
 935         }
 936     }
 937 
 938     @Override
 939     @Deprecated
 940     public void setLoopbackMode(boolean disable) throws SocketException {
 941         getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));
 942     }
 943 
 944     @Override
 945     @Deprecated
 946     public boolean getLoopbackMode() throws SocketException {
 947         return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();
 948     }
 949 
 950     @Deprecated
 951     @Override
 952     public void send(DatagramPacket p, byte ttl)
 953             throws IOException {
 954         if (isClosed())
 955             throw new SocketException(&quot;Socket is closed&quot;);
 956         synchronized(ttlLock) {
 957             synchronized(p) {
 958                 InetAddress packetAddress = p.getAddress();
 959                 checkAddress(packetAddress, &quot;send&quot;);
 960                 if (connectState == NetMulticastSocket.ST_NOT_CONNECTED) {
 961                     if (packetAddress == null) {
 962                         throw new IllegalArgumentException(&quot;Address not set&quot;);
 963                     }
 964                     // Security manager makes sure that the multicast address
 965                     // is allowed one and that the ttl used is less
 966                     // than the allowed maxttl.
 967                     SecurityManager security = System.getSecurityManager();
 968                     if (security != null) {
 969                         if (packetAddress.isMulticastAddress()) {
 970                             security.checkMulticast(packetAddress, ttl);
 971                         } else {
 972                             security.checkConnect(packetAddress.getHostAddress(),
 973                                     p.getPort());
 974                         }
 975                     }
 976                 } else {
 977                     // we&#39;re connected
 978                     if (packetAddress == null) {
 979                         p.setAddress(connectedAddress);
 980                         p.setPort(connectedPort);
 981                     } else if ((!packetAddress.equals(connectedAddress)) ||
 982                             p.getPort() != connectedPort) {
 983                         throw new IllegalArgumentException(&quot;connected address and packet address&quot; +
 984                                 &quot; differ&quot;);
 985                     }
 986                 }
 987                 byte dttl = getTTL();
 988                 try {
 989                     if (ttl != dttl) {
 990                         // set the ttl
 991                         getImpl().setTTL(ttl);
 992                     }
 993                     if (p.getPort() == 0) {
 994                         throw new SocketException(&quot;Can&#39;t send to port 0&quot;);
 995                     }
 996                     // call the datagram method to send
 997                     getImpl().send(p);
 998                 } finally {
 999                     // set it back to default
1000                     if (ttl != dttl) {
1001                         getImpl().setTTL(dttl);
1002                     }
1003                 }
1004             } // synch p
1005         }  //synch ttl
1006     } //method
1007 }
    </pre>
  </body>
</html>
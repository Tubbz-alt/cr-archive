<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/MulticastSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../nio/channels/DatagramChannel.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/MulticastSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
 29 import java.nio.channels.DatagramChannel;
 30 import java.nio.channels.MulticastChannel;
<span class="line-removed"> 31 import java.util.Collections;</span>
<span class="line-removed"> 32 import java.util.Enumeration;</span>
<span class="line-removed"> 33 import java.util.Set;</span>
 34 
 35 /**
 36  * The multicast datagram socket class is useful for sending
 37  * and receiving IP multicast packets. A MulticastSocket is
 38  * a (UDP) DatagramSocket, with additional capabilities for
 39  * joining &quot;groups&quot; of other multicast hosts on the internet.
 40  * &lt;P&gt;
 41  * A multicast group is specified by a class D IP address
 42  * and by a standard UDP port number. Class D IP addresses
 43  * are in the range {@code 224.0.0.0} to {@code 239.255.255.255},
 44  * inclusive. The address 224.0.0.0 is reserved and should not be used.
 45  * &lt;P&gt;
 46  * One would join a multicast group by first creating a MulticastSocket
 47  * with the desired port, then invoking the
 48  * &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
 49  * method:
 50  * &lt;PRE&gt;
 51  * // join a Multicast group and send the group salutations
 52  * ...
 53  * String msg = &quot;Hello&quot;;
</pre>
<hr />
<pre>
118  *       IP_MULTICAST_LOOP} &lt;/th&gt;
119  *     &lt;td&gt; Loopback for Internet Protocol (IP) multicast datagrams &lt;/td&gt;
120  *   &lt;/tr&gt;
121  * &lt;/tbody&gt;
122  * &lt;/table&gt;
123  * &lt;/blockquote&gt;
124  * Additional (implementation specific) options may also be supported.
125  *
126  * @apiNote {@link DatagramChannel} implements the {@link MulticastChannel} interface
127  *          and provides an alternative API for sending and receiving multicast datagrams.
128  *          The {@link MulticastChannel} API supports both {@linkplain
129  *          MulticastChannel#join(InetAddress, NetworkInterface) any-source} and
130  *          {@linkplain MulticastChannel#join(InetAddress, NetworkInterface, InetAddress)
131  *          source-specific} multicast.
132  *
133  * @author Pavani Diwanji
134  * @since 1.1
135  */
136 public class MulticastSocket extends DatagramSocket {
137 





138     /**
<span class="line-modified">139      * Used on some platforms to record if an outgoing interface</span>
<span class="line-modified">140      * has been set for this socket.</span>
141      */
<span class="line-modified">142     private boolean interfaceSet;</span>



143 
144     /**
145      * Create a multicast socket.
146      *
147      * &lt;p&gt;
148      * If there is a security manager, its {@code checkListen} method is first
149      * called with 0 as its argument to ensure the operation is allowed. This
150      * could result in a SecurityException.
151      * &lt;p&gt;
152      * When the socket is created the
153      * {@link DatagramSocket#setReuseAddress(boolean)} method is called to
154      * enable the SO_REUSEADDR socket option.
155      *
156      * @throws    IOException if an I/O exception occurs while creating the
157      * MulticastSocket
158      * @throws    SecurityException if a security manager exists and its
159      * {@code checkListen} method doesn&#39;t allow the operation.
160      * @see SecurityManager#checkListen
161      * @see java.net.DatagramSocket#setReuseAddress(boolean)
162      * @see java.net.DatagramSocketImpl#setOption(SocketOption, Object)
</pre>
<hr />
<pre>
199      * its {@code checkListen} method is first called
200      * with the SocketAddress port as its argument to ensure the operation is allowed.
201      * This could result in a SecurityException.
202      * &lt;p&gt;
203      * When the socket is created the
204      * {@link DatagramSocket#setReuseAddress(boolean)} method is
205      * called to enable the SO_REUSEADDR socket option.
206      *
207      * @param    bindaddr Socket address to bind to, or {@code null} for
208      *           an unbound socket.
209      * @throws   IOException if an I/O exception occurs
210      *           while creating the MulticastSocket
211      * @throws   SecurityException  if a security manager exists and its
212      *           {@code checkListen} method doesn&#39;t allow the operation.
213      * @see      SecurityManager#checkListen
214      * @see      java.net.DatagramSocket#setReuseAddress(boolean)
215      *
216      * @since 1.4
217      */
218     public MulticastSocket(SocketAddress bindaddr) throws IOException {
<span class="line-modified">219         super((SocketAddress) null);</span>
<span class="line-removed">220 </span>
<span class="line-removed">221         // No further initialization when this is a DatagramChannel socket adaptor</span>
<span class="line-removed">222         if (this instanceof sun.nio.ch.DatagramSocketAdaptor)</span>
<span class="line-removed">223             return;</span>
<span class="line-removed">224 </span>
<span class="line-removed">225         // Enable SO_REUSEADDR before binding</span>
<span class="line-removed">226         setReuseAddress(true);</span>
<span class="line-removed">227 </span>
<span class="line-removed">228         if (bindaddr != null) {</span>
<span class="line-removed">229             try {</span>
<span class="line-removed">230                 bind(bindaddr);</span>
<span class="line-removed">231             } finally {</span>
<span class="line-removed">232                 if (!isBound()) {</span>
<span class="line-removed">233                     close();</span>
<span class="line-removed">234                 }</span>
<span class="line-removed">235             }</span>
<span class="line-removed">236         }</span>
237     }
238 
<span class="line-removed">239     /**</span>
<span class="line-removed">240      * The lock on the socket&#39;s TTL. This is for set/getTTL and</span>
<span class="line-removed">241      * send(packet,ttl).</span>
<span class="line-removed">242      */</span>
<span class="line-removed">243     private Object ttlLock = new Object();</span>
<span class="line-removed">244 </span>
<span class="line-removed">245     /**</span>
<span class="line-removed">246      * The lock on the socket&#39;s interface - used by setInterface</span>
<span class="line-removed">247      * and getInterface</span>
<span class="line-removed">248      */</span>
<span class="line-removed">249     private Object infLock = new Object();</span>
<span class="line-removed">250 </span>
<span class="line-removed">251     /**</span>
<span class="line-removed">252      * The &quot;last&quot; interface set by setInterface on this MulticastSocket</span>
<span class="line-removed">253      */</span>
<span class="line-removed">254     private InetAddress infAddress = null;</span>
<span class="line-removed">255 </span>
<span class="line-removed">256 </span>
257     /**
258      * Set the default time-to-live for multicast packets sent out
259      * on this {@code MulticastSocket} in order to control the
260      * scope of the multicasts.
261      *
262      * &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
263      * in the range {@code 0 &lt;= ttl &lt;= 0xFF }.
264      *
265      * @param      ttl the time-to-live
266      * @throws     IOException if an I/O exception occurs
267      *             while setting the default time-to-live value
268      * @deprecated use the setTimeToLive method instead, which uses
269      *             &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.
270      * @see #getTTL()
271      */
272     @Deprecated
273     public void setTTL(byte ttl) throws IOException {
<span class="line-modified">274         if (isClosed())</span>
<span class="line-removed">275             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">276         getImpl().setTTL(ttl);</span>
277     }
278 
279     /**
280      * Set the default time-to-live for multicast packets sent out
281      * on this {@code MulticastSocket} in order to control the
282      * scope of the multicasts.
283      *
284      * &lt;P&gt; The ttl &lt;B&gt;must&lt;/B&gt; be in the range {@code  0 &lt;= ttl &lt;=
285      * 255} or an {@code IllegalArgumentException} will be thrown.
286      * Multicast packets sent with a TTL of {@code 0} are not transmitted
287      * on the network but may be delivered locally.
288      *
289      * @param  ttl
290      *         the time-to-live
291      *
292      * @throws  IOException
293      *          if an I/O exception occurs while setting the
294      *          default time-to-live value
295      *
296      * @see #getTimeToLive()
297      * @since 1.2
298      */
299     public void setTimeToLive(int ttl) throws IOException {
<span class="line-modified">300         if (ttl &lt; 0 || ttl &gt; 255) {</span>
<span class="line-removed">301             throw new IllegalArgumentException(&quot;ttl out of range&quot;);</span>
<span class="line-removed">302         }</span>
<span class="line-removed">303         if (isClosed())</span>
<span class="line-removed">304             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">305         getImpl().setTimeToLive(ttl);</span>
306     }
307 
308     /**
309      * Get the default time-to-live for multicast packets sent out on
310      * the socket.
311      *
312      * @throws    IOException if an I/O exception occurs
313      * while getting the default time-to-live value
314      * @return the default time-to-live value
315      * @deprecated use the getTimeToLive method instead, which returns
316      * an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.
317      * @see #setTTL(byte)
318      */
319     @Deprecated
320     public byte getTTL() throws IOException {
<span class="line-modified">321         if (isClosed())</span>
<span class="line-removed">322             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">323         return getImpl().getTTL();</span>
324     }
325 
326     /**
327      * Get the default time-to-live for multicast packets sent out on
328      * the socket.
329      * @throws    IOException if an I/O exception occurs while
330      * getting the default time-to-live value
331      * @return the default time-to-live value
332      * @see #setTimeToLive(int)
333      * @since 1.2
334      */
335     public int getTimeToLive() throws IOException {
<span class="line-modified">336         if (isClosed())</span>
<span class="line-removed">337             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">338         return getImpl().getTimeToLive();</span>
339     }
340 
341     /**
342      * Joins a multicast group. Its behavior may be affected by
343      * {@code setInterface} or {@code setNetworkInterface}.
344      *
345      * &lt;p&gt;If there is a security manager, this method first
346      * calls its {@code checkMulticast} method with the
347      * {@code mcastaddr} argument as its argument.
348      *
349      * @param      mcastaddr is the multicast address to join
350      * @throws     IOException if there is an error joining,
351      *             or when the address is not a multicast address,
352      *             or the platform does not support multicasting
353      * @throws     SecurityException if a security manager exists and its
354      *             {@code checkMulticast} method doesn&#39;t allow the join.
355      * @deprecated This method does not accept the network interface on
356      *             which to join the multicast group. Use
357      *             {@link #joinGroup(SocketAddress, NetworkInterface)} instead.
358      * @see        SecurityManager#checkMulticast(InetAddress)
359      */
360     @Deprecated(since=&quot;14&quot;)
361     public void joinGroup(InetAddress mcastaddr) throws IOException {
<span class="line-modified">362         if (isClosed()) {</span>
<span class="line-removed">363             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">364         }</span>
<span class="line-removed">365 </span>
<span class="line-removed">366         checkAddress(mcastaddr, &quot;joinGroup&quot;);</span>
<span class="line-removed">367         SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed">368         if (security != null) {</span>
<span class="line-removed">369             security.checkMulticast(mcastaddr);</span>
<span class="line-removed">370         }</span>
<span class="line-removed">371 </span>
<span class="line-removed">372         if (!mcastaddr.isMulticastAddress()) {</span>
<span class="line-removed">373             throw new SocketException(&quot;Not a multicast address&quot;);</span>
<span class="line-removed">374         }</span>
<span class="line-removed">375 </span>
<span class="line-removed">376         /**</span>
<span class="line-removed">377          * required for some platforms where it&#39;s not possible to join</span>
<span class="line-removed">378          * a group without setting the interface first.</span>
<span class="line-removed">379          */</span>
<span class="line-removed">380         NetworkInterface defaultInterface = NetworkInterface.getDefault();</span>
<span class="line-removed">381 </span>
<span class="line-removed">382         if (!interfaceSet &amp;&amp; defaultInterface != null) {</span>
<span class="line-removed">383             setNetworkInterface(defaultInterface);</span>
<span class="line-removed">384         }</span>
<span class="line-removed">385 </span>
<span class="line-removed">386         getImpl().join(mcastaddr);</span>
387     }
388 
389     /**
390      * Leave a multicast group. Its behavior may be affected by
391      * {@code setInterface} or {@code setNetworkInterface}.
392      *
393      * &lt;p&gt;If there is a security manager, this method first
394      * calls its {@code checkMulticast} method with the
395      * {@code mcastaddr} argument as its argument.
396      *
397      * @param      mcastaddr is the multicast address to leave
398      * @throws     IOException if there is an error leaving
399      *             or when the address is not a multicast address.
400      * @throws     SecurityException if a security manager exists and its
401      *             {@code checkMulticast} method doesn&#39;t allow the operation.
402      * @deprecated This method does not accept the network interface on which
403      *             to leave the multicast group. Use
404      *             {@link #leaveGroup(SocketAddress, NetworkInterface)} instead.
405      * @see        SecurityManager#checkMulticast(InetAddress)
406      */
407     @Deprecated(since=&quot;14&quot;)
408     public void leaveGroup(InetAddress mcastaddr) throws IOException {
<span class="line-modified">409         if (isClosed()) {</span>
<span class="line-removed">410             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">411         }</span>
<span class="line-removed">412 </span>
<span class="line-removed">413         checkAddress(mcastaddr, &quot;leaveGroup&quot;);</span>
<span class="line-removed">414         SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed">415         if (security != null) {</span>
<span class="line-removed">416             security.checkMulticast(mcastaddr);</span>
<span class="line-removed">417         }</span>
<span class="line-removed">418 </span>
<span class="line-removed">419         if (!mcastaddr.isMulticastAddress()) {</span>
<span class="line-removed">420             throw new SocketException(&quot;Not a multicast address&quot;);</span>
<span class="line-removed">421         }</span>
<span class="line-removed">422 </span>
<span class="line-removed">423         getImpl().leave(mcastaddr);</span>
424     }
425 
426     /**
427      * Joins the specified multicast group at the specified interface.
428      *
429      * &lt;p&gt;If there is a security manager, this method first
430      * calls its {@code checkMulticast} method
431      * with the {@code mcastaddr} argument
432      * as its argument.
433      *
434      * @param  mcastaddr is the multicast address to join
435      * @param  netIf specifies the local interface to receive multicast
436      *         datagram packets, or {@code null} to defer to the interface set by
437      *         {@link MulticastSocket#setInterface(InetAddress)} or
438      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.
439      *         If {@code null}, and no interface has been set, the behaviour is
440      *         unspecified: any interface may be selected or the operation may fail
441      *         with a {@code SocketException}.
442      * @throws IOException if there is an error joining, or when the address
443      *         is not a multicast address, or the platform does not support
444      *         multicasting
445      * @throws SecurityException if a security manager exists and its
446      *         {@code checkMulticast} method doesn&#39;t allow the join.
447      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a
448      *         SocketAddress subclass not supported by this socket
449      * @see    SecurityManager#checkMulticast(InetAddress)
450      * @see    DatagramChannel#join(InetAddress, NetworkInterface)
451      * @since  1.4
452      */
453     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
454         throws IOException {
<span class="line-modified">455         if (isClosed())</span>
<span class="line-removed">456             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">457 </span>
<span class="line-removed">458         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="line-removed">459             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="line-removed">460 </span>
<span class="line-removed">461         if (oldImpl)</span>
<span class="line-removed">462             throw new UnsupportedOperationException();</span>
<span class="line-removed">463 </span>
<span class="line-removed">464         checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;joinGroup&quot;);</span>
<span class="line-removed">465         SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed">466         if (security != null) {</span>
<span class="line-removed">467             security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());</span>
<span class="line-removed">468         }</span>
<span class="line-removed">469 </span>
<span class="line-removed">470         if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {</span>
<span class="line-removed">471             throw new SocketException(&quot;Not a multicast address&quot;);</span>
<span class="line-removed">472         }</span>
<span class="line-removed">473 </span>
<span class="line-removed">474         getImpl().joinGroup(mcastaddr, netIf);</span>
475     }
476 
477     /**
478      * Leave a multicast group on a specified local interface.
479      *
480      * &lt;p&gt;If there is a security manager, this method first
481      * calls its {@code checkMulticast} method with the
482      * {@code mcastaddr} argument as its argument.
483      *
484      * @param  mcastaddr is the multicast address to leave
485      * @param  netIf specifies the local interface or {@code null} to defer
486      *         to the interface set by
487      *         {@link MulticastSocket#setInterface(InetAddress)} or
488      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.
489      *         If {@code null}, and no interface has been set, the behaviour
490      *         is unspecified: any interface may be selected or the operation
491      *         may fail with a {@code SocketException}.
492      * @throws IOException if there is an error leaving or when the address
493      *         is not a multicast address.
494      * @throws SecurityException if a security manager exists and its
495      *         {@code checkMulticast} method doesn&#39;t allow the operation.
496      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a
497      *         SocketAddress subclass not supported by this socket.
498      * @see    SecurityManager#checkMulticast(InetAddress)
499      * @since  1.4
500      */
501     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
502         throws IOException {
<span class="line-modified">503         if (isClosed())</span>
<span class="line-removed">504             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">505 </span>
<span class="line-removed">506         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="line-removed">507             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="line-removed">508 </span>
<span class="line-removed">509         if (oldImpl)</span>
<span class="line-removed">510             throw new UnsupportedOperationException();</span>
<span class="line-removed">511 </span>
<span class="line-removed">512         checkAddress(((InetSocketAddress)mcastaddr).getAddress(), &quot;leaveGroup&quot;);</span>
<span class="line-removed">513         SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed">514         if (security != null) {</span>
<span class="line-removed">515             security.checkMulticast(((InetSocketAddress)mcastaddr).getAddress());</span>
<span class="line-removed">516         }</span>
<span class="line-removed">517 </span>
<span class="line-removed">518         if (!((InetSocketAddress)mcastaddr).getAddress().isMulticastAddress()) {</span>
<span class="line-removed">519             throw new SocketException(&quot;Not a multicast address&quot;);</span>
<span class="line-removed">520         }</span>
<span class="line-removed">521 </span>
<span class="line-removed">522         getImpl().leaveGroup(mcastaddr, netIf);</span>
523      }
524 
525     /**
526      * Set the multicast network interface used by methods
527      * whose behavior would be affected by the value of the
528      * network interface. Useful for multihomed hosts.
529      *
530      * @param      inf the InetAddress
531      * @throws     SocketException if there is an error in
532      *             the underlying protocol, such as a TCP error.
533      * @deprecated The InetAddress may not uniquely identify
534      *             the network interface. Use
535      *             {@link #setNetworkInterface(NetworkInterface)} instead.
536      * @see        #getInterface()
537      */
538     @Deprecated(since=&quot;14&quot;)
539     public void setInterface(InetAddress inf) throws SocketException {
<span class="line-modified">540         if (isClosed()) {</span>
<span class="line-removed">541             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">542         }</span>
<span class="line-removed">543         checkAddress(inf, &quot;setInterface&quot;);</span>
<span class="line-removed">544         synchronized (infLock) {</span>
<span class="line-removed">545             getImpl().setOption(SocketOptions.IP_MULTICAST_IF, inf);</span>
<span class="line-removed">546             infAddress = inf;</span>
<span class="line-removed">547             interfaceSet = true;</span>
<span class="line-removed">548         }</span>
549     }
550 
551     /**
552      * Retrieve the address of the network interface used for
553      * multicast packets.
554      *
555      * @return     An {@code InetAddress} representing the address
556      *             of the network interface used for multicast packets,
557      *             or if no interface has been set, an {@code InetAddress}
558      *             representing any local address.
559      * @throws     SocketException if there is an error in the
560      *             underlying protocol, such as a TCP error.
561      * @deprecated The network interface may not be uniquely identified by
562      *             the InetAddress returned.
563      *             Use {@link #getNetworkInterface()} instead.
564      * @see        #setInterface(java.net.InetAddress)
565      */
566     @Deprecated(since=&quot;14&quot;)
567     public InetAddress getInterface() throws SocketException {
<span class="line-modified">568         if (isClosed()) {</span>
<span class="line-removed">569             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">570         }</span>
<span class="line-removed">571         synchronized (infLock) {</span>
<span class="line-removed">572             InetAddress ia =</span>
<span class="line-removed">573                 (InetAddress)getImpl().getOption(SocketOptions.IP_MULTICAST_IF);</span>
<span class="line-removed">574 </span>
<span class="line-removed">575             /**</span>
<span class="line-removed">576              * No previous setInterface or interface can be</span>
<span class="line-removed">577              * set using setNetworkInterface</span>
<span class="line-removed">578              */</span>
<span class="line-removed">579             if (infAddress == null) {</span>
<span class="line-removed">580                 return ia;</span>
<span class="line-removed">581             }</span>
<span class="line-removed">582 </span>
<span class="line-removed">583             /**</span>
<span class="line-removed">584              * Same interface set with setInterface?</span>
<span class="line-removed">585              */</span>
<span class="line-removed">586             if (ia.equals(infAddress)) {</span>
<span class="line-removed">587                 return ia;</span>
<span class="line-removed">588             }</span>
<span class="line-removed">589 </span>
<span class="line-removed">590             /**</span>
<span class="line-removed">591              * Different InetAddress from what we set with setInterface</span>
<span class="line-removed">592              * so enumerate the current interface to see if the</span>
<span class="line-removed">593              * address set by setInterface is bound to this interface.</span>
<span class="line-removed">594              */</span>
<span class="line-removed">595             try {</span>
<span class="line-removed">596                 NetworkInterface ni = NetworkInterface.getByInetAddress(ia);</span>
<span class="line-removed">597                 Enumeration&lt;InetAddress&gt; addrs = ni.getInetAddresses();</span>
<span class="line-removed">598                 while (addrs.hasMoreElements()) {</span>
<span class="line-removed">599                     InetAddress addr = addrs.nextElement();</span>
<span class="line-removed">600                     if (addr.equals(infAddress)) {</span>
<span class="line-removed">601                         return infAddress;</span>
<span class="line-removed">602                     }</span>
<span class="line-removed">603                 }</span>
<span class="line-removed">604 </span>
<span class="line-removed">605                 /**</span>
<span class="line-removed">606                  * No match so reset infAddress to indicate that the</span>
<span class="line-removed">607                  * interface has changed via means</span>
<span class="line-removed">608                  */</span>
<span class="line-removed">609                 infAddress = null;</span>
<span class="line-removed">610                 return ia;</span>
<span class="line-removed">611             } catch (Exception e) {</span>
<span class="line-removed">612                 return ia;</span>
<span class="line-removed">613             }</span>
<span class="line-removed">614         }</span>
615     }
616 
617     /**
618      * Specify the network interface for outgoing multicast datagrams
619      * sent on this socket.
620      *
621      * @param netIf the interface
622      * @throws    SocketException if there is an error in
623      * the underlying protocol, such as a TCP error.
624      * @see #getNetworkInterface()
625      * @since 1.4
626      */
627     public void setNetworkInterface(NetworkInterface netIf)
628         throws SocketException {
<span class="line-modified">629 </span>
<span class="line-removed">630         synchronized (infLock) {</span>
<span class="line-removed">631             getImpl().setOption(SocketOptions.IP_MULTICAST_IF2, netIf);</span>
<span class="line-removed">632             infAddress = null;</span>
<span class="line-removed">633             interfaceSet = true;</span>
<span class="line-removed">634         }</span>
635     }
636 
637     /**
638      * Get the multicast network interface set.
639      *
640      * @throws SocketException if there is an error in
641      *         the underlying protocol, such as a TCP error.
642      * @return The multicast {@code NetworkInterface} currently set. A placeholder
643      *         NetworkInterface is returned when there is no interface set; it has
644      *         a single InetAddress to represent any local address.
645      * @see    #setNetworkInterface(NetworkInterface)
646      * @since  1.4
647      */
648     public NetworkInterface getNetworkInterface() throws SocketException {
<span class="line-modified">649         NetworkInterface ni</span>
<span class="line-removed">650             = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);</span>
<span class="line-removed">651         if (ni == null) {</span>
<span class="line-removed">652             InetAddress[] addrs = new InetAddress[1];</span>
<span class="line-removed">653             addrs[0] = InetAddress.anyLocalAddress();</span>
<span class="line-removed">654             return new NetworkInterface(addrs[0].getHostName(), 0, addrs);</span>
<span class="line-removed">655         } else {</span>
<span class="line-removed">656             return ni;</span>
<span class="line-removed">657         }</span>
658     }
659 
660     /**
661      * Disable/Enable local loopback of multicast datagrams.
662      * The option is used by the platform&#39;s networking code as a hint
663      * for setting whether multicast data will be looped back to
664      * the local socket.
665      *
666      * &lt;p&gt;Because this option is a hint, applications that want to
667      * verify what loopback mode is set to should call
668      * {@link #getLoopbackMode()}
669      * @param      disable {@code true} to disable the LoopbackMode
670      * @throws     SocketException if an error occurs while setting the value
671      * @since      1.4
672      * @deprecated Use {@link #setOption(SocketOption, Object)} with
673      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
674      *             instead. The loopback mode is enabled by default,
675      *             {@code MulticastSocket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, false)}
676      *             disables it.
677      * @see        #getLoopbackMode
678      */
679     @Deprecated(since=&quot;14&quot;)
680     public void setLoopbackMode(boolean disable) throws SocketException {
<span class="line-modified">681         getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));</span>
682     }
683 
684     /**
685      * Get the setting for local loopback of multicast datagrams.
686      *
687      * @throws     SocketException if an error occurs while getting the value
688      * @return     true if the LoopbackMode has been disabled
689      * @since      1.4
690      * @deprecated Use {@link #getOption(SocketOption)} with
691      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
692      *             instead.
693      * @see        #setLoopbackMode
694      */
695     @Deprecated(since=&quot;14&quot;)
696     public boolean getLoopbackMode() throws SocketException {
<span class="line-modified">697         return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();</span>
698     }
699 
700     /**
701      * Sends a datagram packet to the destination, with a TTL (time-to-live)
702      * other than the default for the socket.  This method
703      * need only be used in instances where a particular TTL is desired;
704      * otherwise it is preferable to set a TTL once on the socket, and
705      * use that default TTL for all packets.  This method does &lt;B&gt;not
706      * &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
707      * affected by {@code setInterface}.
708      *
709      * &lt;p&gt;If there is a security manager, this method first performs some
710      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
711      * is true, this method calls the
712      * security manager&#39;s {@code checkMulticast} method
713      * with {@code p.getAddress()} and {@code ttl} as its arguments.
714      * If the evaluation of that expression is false,
715      * this method instead calls the security manager&#39;s
716      * {@code checkConnect} method with arguments
717      * {@code p.getAddress().getHostAddress()} and
</pre>
<hr />
<pre>
738      *             if the socket is not connected and the packet address
739      *             is not set or if its port is out of range.
740      *
741      *
742      * @deprecated Use the following code or its equivalent instead:
743      *  ......
744      *  int ttl = mcastSocket.getTimeToLive();
745      *  mcastSocket.setTimeToLive(newttl);
746      *  mcastSocket.send(p);
747      *  mcastSocket.setTimeToLive(ttl);
748      *  ......
749      *
750      * @see DatagramSocket#send
751      * @see DatagramSocket#receive
752      * @see SecurityManager#checkMulticast(java.net.InetAddress, byte)
753      * @see SecurityManager#checkConnect
754      */
755     @Deprecated
756     public void send(DatagramPacket p, byte ttl)
757         throws IOException {
<span class="line-modified">758             if (isClosed())</span>
<span class="line-modified">759                 throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">760             synchronized(ttlLock) {</span>
<span class="line-removed">761                 synchronized(p) {</span>
<span class="line-removed">762                     InetAddress packetAddress = p.getAddress();</span>
<span class="line-removed">763                     int packetPort = p.getPort();</span>
<span class="line-removed">764                     checkAddress(packetAddress, &quot;send&quot;);</span>
<span class="line-removed">765                     if (connectState == ST_NOT_CONNECTED) {</span>
<span class="line-removed">766                         if (packetAddress == null) {</span>
<span class="line-removed">767                             throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-removed">768                         }</span>
<span class="line-removed">769                         if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)</span>
<span class="line-removed">770                             throw new IllegalArgumentException(&quot;port out of range:&quot; + packetPort);</span>
<span class="line-removed">771                         // Security manager makes sure that the multicast address</span>
<span class="line-removed">772                         // is allowed one and that the ttl used is less</span>
<span class="line-removed">773                         // than the allowed maxttl.</span>
<span class="line-removed">774                         SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed">775                         if (security != null) {</span>
<span class="line-removed">776                             if (packetAddress.isMulticastAddress()) {</span>
<span class="line-removed">777                                 security.checkMulticast(packetAddress, ttl);</span>
<span class="line-removed">778                             } else {</span>
<span class="line-removed">779                                 security.checkConnect(packetAddress.getHostAddress(),</span>
<span class="line-removed">780                                         packetPort);</span>
<span class="line-removed">781                             }</span>
<span class="line-removed">782                         }</span>
<span class="line-removed">783                     } else {</span>
<span class="line-removed">784                         // we&#39;re connected</span>
<span class="line-removed">785                         if (packetAddress == null) {</span>
<span class="line-removed">786                             p.setAddress(connectedAddress);</span>
<span class="line-removed">787                             p.setPort(connectedPort);</span>
<span class="line-removed">788                         } else if ((!packetAddress.equals(connectedAddress)) ||</span>
<span class="line-removed">789                                 packetPort != connectedPort) {</span>
<span class="line-removed">790                             throw new IllegalArgumentException(&quot;connected address and packet address&quot; +</span>
<span class="line-removed">791                                                         &quot; differ&quot;);</span>
<span class="line-removed">792                         }</span>
<span class="line-removed">793                     }</span>
<span class="line-removed">794                     byte dttl = getTTL();</span>
<span class="line-removed">795                     try {</span>
<span class="line-removed">796                         if (ttl != dttl) {</span>
<span class="line-removed">797                             // set the ttl</span>
<span class="line-removed">798                             getImpl().setTTL(ttl);</span>
<span class="line-removed">799                         }</span>
<span class="line-removed">800                         if (packetPort == 0) {</span>
<span class="line-removed">801                             throw new SocketException(&quot;Can&#39;t send to port 0&quot;);</span>
<span class="line-removed">802                         }</span>
<span class="line-removed">803                         // call the datagram method to send</span>
<span class="line-removed">804                         getImpl().send(p);</span>
<span class="line-removed">805                     } finally {</span>
<span class="line-removed">806                         // set it back to default</span>
<span class="line-removed">807                         if (ttl != dttl) {</span>
<span class="line-removed">808                             getImpl().setTTL(dttl);</span>
<span class="line-removed">809                         }</span>
<span class="line-removed">810                     }</span>
<span class="line-removed">811                 } // synch p</span>
<span class="line-removed">812             }  //synch ttl</span>
<span class="line-removed">813     } //method</span>
814 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
 29 import java.nio.channels.DatagramChannel;
 30 import java.nio.channels.MulticastChannel;



 31 
 32 /**
 33  * The multicast datagram socket class is useful for sending
 34  * and receiving IP multicast packets. A MulticastSocket is
 35  * a (UDP) DatagramSocket, with additional capabilities for
 36  * joining &quot;groups&quot; of other multicast hosts on the internet.
 37  * &lt;P&gt;
 38  * A multicast group is specified by a class D IP address
 39  * and by a standard UDP port number. Class D IP addresses
 40  * are in the range {@code 224.0.0.0} to {@code 239.255.255.255},
 41  * inclusive. The address 224.0.0.0 is reserved and should not be used.
 42  * &lt;P&gt;
 43  * One would join a multicast group by first creating a MulticastSocket
 44  * with the desired port, then invoking the
 45  * &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
 46  * method:
 47  * &lt;PRE&gt;
 48  * // join a Multicast group and send the group salutations
 49  * ...
 50  * String msg = &quot;Hello&quot;;
</pre>
<hr />
<pre>
115  *       IP_MULTICAST_LOOP} &lt;/th&gt;
116  *     &lt;td&gt; Loopback for Internet Protocol (IP) multicast datagrams &lt;/td&gt;
117  *   &lt;/tr&gt;
118  * &lt;/tbody&gt;
119  * &lt;/table&gt;
120  * &lt;/blockquote&gt;
121  * Additional (implementation specific) options may also be supported.
122  *
123  * @apiNote {@link DatagramChannel} implements the {@link MulticastChannel} interface
124  *          and provides an alternative API for sending and receiving multicast datagrams.
125  *          The {@link MulticastChannel} API supports both {@linkplain
126  *          MulticastChannel#join(InetAddress, NetworkInterface) any-source} and
127  *          {@linkplain MulticastChannel#join(InetAddress, NetworkInterface, InetAddress)
128  *          source-specific} multicast.
129  *
130  * @author Pavani Diwanji
131  * @since 1.1
132  */
133 public class MulticastSocket extends DatagramSocket {
134 
<span class="line-added">135     @Override</span>
<span class="line-added">136     final MulticastSocket delegate() {</span>
<span class="line-added">137         return (MulticastSocket) super.delegate();</span>
<span class="line-added">138     }</span>
<span class="line-added">139 </span>
140     /**
<span class="line-modified">141      * Create a MulticastSocket that delegates to the given delegate if not null.</span>
<span class="line-modified">142      * @param delegate the delegate, can be null.</span>
143      */
<span class="line-modified">144     MulticastSocket(MulticastSocket delegate)  {</span>
<span class="line-added">145         super(delegate);</span>
<span class="line-added">146     }</span>
<span class="line-added">147 </span>
148 
149     /**
150      * Create a multicast socket.
151      *
152      * &lt;p&gt;
153      * If there is a security manager, its {@code checkListen} method is first
154      * called with 0 as its argument to ensure the operation is allowed. This
155      * could result in a SecurityException.
156      * &lt;p&gt;
157      * When the socket is created the
158      * {@link DatagramSocket#setReuseAddress(boolean)} method is called to
159      * enable the SO_REUSEADDR socket option.
160      *
161      * @throws    IOException if an I/O exception occurs while creating the
162      * MulticastSocket
163      * @throws    SecurityException if a security manager exists and its
164      * {@code checkListen} method doesn&#39;t allow the operation.
165      * @see SecurityManager#checkListen
166      * @see java.net.DatagramSocket#setReuseAddress(boolean)
167      * @see java.net.DatagramSocketImpl#setOption(SocketOption, Object)
</pre>
<hr />
<pre>
204      * its {@code checkListen} method is first called
205      * with the SocketAddress port as its argument to ensure the operation is allowed.
206      * This could result in a SecurityException.
207      * &lt;p&gt;
208      * When the socket is created the
209      * {@link DatagramSocket#setReuseAddress(boolean)} method is
210      * called to enable the SO_REUSEADDR socket option.
211      *
212      * @param    bindaddr Socket address to bind to, or {@code null} for
213      *           an unbound socket.
214      * @throws   IOException if an I/O exception occurs
215      *           while creating the MulticastSocket
216      * @throws   SecurityException  if a security manager exists and its
217      *           {@code checkListen} method doesn&#39;t allow the operation.
218      * @see      SecurityManager#checkListen
219      * @see      java.net.DatagramSocket#setReuseAddress(boolean)
220      *
221      * @since 1.4
222      */
223     public MulticastSocket(SocketAddress bindaddr) throws IOException {
<span class="line-modified">224         this(createDelegate(bindaddr, MulticastSocket.class));</span>

















225     }
226 


















227     /**
228      * Set the default time-to-live for multicast packets sent out
229      * on this {@code MulticastSocket} in order to control the
230      * scope of the multicasts.
231      *
232      * &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
233      * in the range {@code 0 &lt;= ttl &lt;= 0xFF }.
234      *
235      * @param      ttl the time-to-live
236      * @throws     IOException if an I/O exception occurs
237      *             while setting the default time-to-live value
238      * @deprecated use the setTimeToLive method instead, which uses
239      *             &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.
240      * @see #getTTL()
241      */
242     @Deprecated
243     public void setTTL(byte ttl) throws IOException {
<span class="line-modified">244         delegate().setTTL(ttl);</span>


245     }
246 
247     /**
248      * Set the default time-to-live for multicast packets sent out
249      * on this {@code MulticastSocket} in order to control the
250      * scope of the multicasts.
251      *
252      * &lt;P&gt; The ttl &lt;B&gt;must&lt;/B&gt; be in the range {@code  0 &lt;= ttl &lt;=
253      * 255} or an {@code IllegalArgumentException} will be thrown.
254      * Multicast packets sent with a TTL of {@code 0} are not transmitted
255      * on the network but may be delivered locally.
256      *
257      * @param  ttl
258      *         the time-to-live
259      *
260      * @throws  IOException
261      *          if an I/O exception occurs while setting the
262      *          default time-to-live value
263      *
264      * @see #getTimeToLive()
265      * @since 1.2
266      */
267     public void setTimeToLive(int ttl) throws IOException {
<span class="line-modified">268         delegate().setTimeToLive(ttl);</span>





269     }
270 
271     /**
272      * Get the default time-to-live for multicast packets sent out on
273      * the socket.
274      *
275      * @throws    IOException if an I/O exception occurs
276      * while getting the default time-to-live value
277      * @return the default time-to-live value
278      * @deprecated use the getTimeToLive method instead, which returns
279      * an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.
280      * @see #setTTL(byte)
281      */
282     @Deprecated
283     public byte getTTL() throws IOException {
<span class="line-modified">284         return delegate().getTTL();</span>


285     }
286 
287     /**
288      * Get the default time-to-live for multicast packets sent out on
289      * the socket.
290      * @throws    IOException if an I/O exception occurs while
291      * getting the default time-to-live value
292      * @return the default time-to-live value
293      * @see #setTimeToLive(int)
294      * @since 1.2
295      */
296     public int getTimeToLive() throws IOException {
<span class="line-modified">297         return delegate().getTimeToLive();</span>


298     }
299 
300     /**
301      * Joins a multicast group. Its behavior may be affected by
302      * {@code setInterface} or {@code setNetworkInterface}.
303      *
304      * &lt;p&gt;If there is a security manager, this method first
305      * calls its {@code checkMulticast} method with the
306      * {@code mcastaddr} argument as its argument.
307      *
308      * @param      mcastaddr is the multicast address to join
309      * @throws     IOException if there is an error joining,
310      *             or when the address is not a multicast address,
311      *             or the platform does not support multicasting
312      * @throws     SecurityException if a security manager exists and its
313      *             {@code checkMulticast} method doesn&#39;t allow the join.
314      * @deprecated This method does not accept the network interface on
315      *             which to join the multicast group. Use
316      *             {@link #joinGroup(SocketAddress, NetworkInterface)} instead.
317      * @see        SecurityManager#checkMulticast(InetAddress)
318      */
319     @Deprecated(since=&quot;14&quot;)
320     public void joinGroup(InetAddress mcastaddr) throws IOException {
<span class="line-modified">321         delegate().joinGroup(mcastaddr);</span>
























322     }
323 
324     /**
325      * Leave a multicast group. Its behavior may be affected by
326      * {@code setInterface} or {@code setNetworkInterface}.
327      *
328      * &lt;p&gt;If there is a security manager, this method first
329      * calls its {@code checkMulticast} method with the
330      * {@code mcastaddr} argument as its argument.
331      *
332      * @param      mcastaddr is the multicast address to leave
333      * @throws     IOException if there is an error leaving
334      *             or when the address is not a multicast address.
335      * @throws     SecurityException if a security manager exists and its
336      *             {@code checkMulticast} method doesn&#39;t allow the operation.
337      * @deprecated This method does not accept the network interface on which
338      *             to leave the multicast group. Use
339      *             {@link #leaveGroup(SocketAddress, NetworkInterface)} instead.
340      * @see        SecurityManager#checkMulticast(InetAddress)
341      */
342     @Deprecated(since=&quot;14&quot;)
343     public void leaveGroup(InetAddress mcastaddr) throws IOException {
<span class="line-modified">344         delegate().leaveGroup(mcastaddr);</span>














345     }
346 
347     /**
348      * Joins the specified multicast group at the specified interface.
349      *
350      * &lt;p&gt;If there is a security manager, this method first
351      * calls its {@code checkMulticast} method
352      * with the {@code mcastaddr} argument
353      * as its argument.
354      *
355      * @param  mcastaddr is the multicast address to join
356      * @param  netIf specifies the local interface to receive multicast
357      *         datagram packets, or {@code null} to defer to the interface set by
358      *         {@link MulticastSocket#setInterface(InetAddress)} or
359      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.
360      *         If {@code null}, and no interface has been set, the behaviour is
361      *         unspecified: any interface may be selected or the operation may fail
362      *         with a {@code SocketException}.
363      * @throws IOException if there is an error joining, or when the address
364      *         is not a multicast address, or the platform does not support
365      *         multicasting
366      * @throws SecurityException if a security manager exists and its
367      *         {@code checkMulticast} method doesn&#39;t allow the join.
368      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a
369      *         SocketAddress subclass not supported by this socket
370      * @see    SecurityManager#checkMulticast(InetAddress)
371      * @see    DatagramChannel#join(InetAddress, NetworkInterface)
372      * @since  1.4
373      */
374     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
375         throws IOException {
<span class="line-modified">376         delegate().joinGroup(mcastaddr, netIf);</span>



















377     }
378 
379     /**
380      * Leave a multicast group on a specified local interface.
381      *
382      * &lt;p&gt;If there is a security manager, this method first
383      * calls its {@code checkMulticast} method with the
384      * {@code mcastaddr} argument as its argument.
385      *
386      * @param  mcastaddr is the multicast address to leave
387      * @param  netIf specifies the local interface or {@code null} to defer
388      *         to the interface set by
389      *         {@link MulticastSocket#setInterface(InetAddress)} or
390      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.
391      *         If {@code null}, and no interface has been set, the behaviour
392      *         is unspecified: any interface may be selected or the operation
393      *         may fail with a {@code SocketException}.
394      * @throws IOException if there is an error leaving or when the address
395      *         is not a multicast address.
396      * @throws SecurityException if a security manager exists and its
397      *         {@code checkMulticast} method doesn&#39;t allow the operation.
398      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a
399      *         SocketAddress subclass not supported by this socket.
400      * @see    SecurityManager#checkMulticast(InetAddress)
401      * @since  1.4
402      */
403     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
404         throws IOException {
<span class="line-modified">405         delegate().leaveGroup(mcastaddr, netIf);</span>



















406      }
407 
408     /**
409      * Set the multicast network interface used by methods
410      * whose behavior would be affected by the value of the
411      * network interface. Useful for multihomed hosts.
412      *
413      * @param      inf the InetAddress
414      * @throws     SocketException if there is an error in
415      *             the underlying protocol, such as a TCP error.
416      * @deprecated The InetAddress may not uniquely identify
417      *             the network interface. Use
418      *             {@link #setNetworkInterface(NetworkInterface)} instead.
419      * @see        #getInterface()
420      */
421     @Deprecated(since=&quot;14&quot;)
422     public void setInterface(InetAddress inf) throws SocketException {
<span class="line-modified">423         delegate().setInterface(inf);</span>








424     }
425 
426     /**
427      * Retrieve the address of the network interface used for
428      * multicast packets.
429      *
430      * @return     An {@code InetAddress} representing the address
431      *             of the network interface used for multicast packets,
432      *             or if no interface has been set, an {@code InetAddress}
433      *             representing any local address.
434      * @throws     SocketException if there is an error in the
435      *             underlying protocol, such as a TCP error.
436      * @deprecated The network interface may not be uniquely identified by
437      *             the InetAddress returned.
438      *             Use {@link #getNetworkInterface()} instead.
439      * @see        #setInterface(java.net.InetAddress)
440      */
441     @Deprecated(since=&quot;14&quot;)
442     public InetAddress getInterface() throws SocketException {
<span class="line-modified">443         return delegate().getInterface();</span>














































444     }
445 
446     /**
447      * Specify the network interface for outgoing multicast datagrams
448      * sent on this socket.
449      *
450      * @param netIf the interface
451      * @throws    SocketException if there is an error in
452      * the underlying protocol, such as a TCP error.
453      * @see #getNetworkInterface()
454      * @since 1.4
455      */
456     public void setNetworkInterface(NetworkInterface netIf)
457         throws SocketException {
<span class="line-modified">458         delegate().setNetworkInterface(netIf);</span>





459     }
460 
461     /**
462      * Get the multicast network interface set.
463      *
464      * @throws SocketException if there is an error in
465      *         the underlying protocol, such as a TCP error.
466      * @return The multicast {@code NetworkInterface} currently set. A placeholder
467      *         NetworkInterface is returned when there is no interface set; it has
468      *         a single InetAddress to represent any local address.
469      * @see    #setNetworkInterface(NetworkInterface)
470      * @since  1.4
471      */
472     public NetworkInterface getNetworkInterface() throws SocketException {
<span class="line-modified">473         return delegate().getNetworkInterface();</span>








474     }
475 
476     /**
477      * Disable/Enable local loopback of multicast datagrams.
478      * The option is used by the platform&#39;s networking code as a hint
479      * for setting whether multicast data will be looped back to
480      * the local socket.
481      *
482      * &lt;p&gt;Because this option is a hint, applications that want to
483      * verify what loopback mode is set to should call
484      * {@link #getLoopbackMode()}
485      * @param      disable {@code true} to disable the LoopbackMode
486      * @throws     SocketException if an error occurs while setting the value
487      * @since      1.4
488      * @deprecated Use {@link #setOption(SocketOption, Object)} with
489      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
490      *             instead. The loopback mode is enabled by default,
491      *             {@code MulticastSocket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, false)}
492      *             disables it.
493      * @see        #getLoopbackMode
494      */
495     @Deprecated(since=&quot;14&quot;)
496     public void setLoopbackMode(boolean disable) throws SocketException {
<span class="line-modified">497         delegate().setLoopbackMode(disable);</span>
498     }
499 
500     /**
501      * Get the setting for local loopback of multicast datagrams.
502      *
503      * @throws     SocketException if an error occurs while getting the value
504      * @return     true if the LoopbackMode has been disabled
505      * @since      1.4
506      * @deprecated Use {@link #getOption(SocketOption)} with
507      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
508      *             instead.
509      * @see        #setLoopbackMode
510      */
511     @Deprecated(since=&quot;14&quot;)
512     public boolean getLoopbackMode() throws SocketException {
<span class="line-modified">513         return delegate().getLoopbackMode();</span>
514     }
515 
516     /**
517      * Sends a datagram packet to the destination, with a TTL (time-to-live)
518      * other than the default for the socket.  This method
519      * need only be used in instances where a particular TTL is desired;
520      * otherwise it is preferable to set a TTL once on the socket, and
521      * use that default TTL for all packets.  This method does &lt;B&gt;not
522      * &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
523      * affected by {@code setInterface}.
524      *
525      * &lt;p&gt;If there is a security manager, this method first performs some
526      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
527      * is true, this method calls the
528      * security manager&#39;s {@code checkMulticast} method
529      * with {@code p.getAddress()} and {@code ttl} as its arguments.
530      * If the evaluation of that expression is false,
531      * this method instead calls the security manager&#39;s
532      * {@code checkConnect} method with arguments
533      * {@code p.getAddress().getHostAddress()} and
</pre>
<hr />
<pre>
554      *             if the socket is not connected and the packet address
555      *             is not set or if its port is out of range.
556      *
557      *
558      * @deprecated Use the following code or its equivalent instead:
559      *  ......
560      *  int ttl = mcastSocket.getTimeToLive();
561      *  mcastSocket.setTimeToLive(newttl);
562      *  mcastSocket.send(p);
563      *  mcastSocket.setTimeToLive(ttl);
564      *  ......
565      *
566      * @see DatagramSocket#send
567      * @see DatagramSocket#receive
568      * @see SecurityManager#checkMulticast(java.net.InetAddress, byte)
569      * @see SecurityManager#checkConnect
570      */
571     @Deprecated
572     public void send(DatagramPacket p, byte ttl)
573         throws IOException {
<span class="line-modified">574         delegate().send(p, ttl);</span>
<span class="line-modified">575     }</span>






















































576 }
</pre>
</td>
</tr>
</table>
<center><a href="DatagramSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../nio/channels/DatagramChannel.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
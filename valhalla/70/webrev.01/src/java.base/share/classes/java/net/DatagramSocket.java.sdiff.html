<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/DatagramSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../lang/invoke/StringConcatFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/DatagramSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.IOException;
  29 import java.io.UncheckedIOException;
  30 import java.nio.channels.DatagramChannel;
  31 import java.security.AccessController;
<span class="line-modified">  32 import java.security.PrivilegedExceptionAction;</span>
<span class="line-removed">  33 import java.util.Objects;</span>
  34 import java.util.Set;
<span class="line-modified">  35 import java.util.Collections;</span>

  36 
  37 /**
  38  * This class represents a socket for sending and receiving datagram packets.
  39  *
  40  * &lt;p&gt;A datagram socket is the sending or receiving point for a packet
  41  * delivery service. Each packet sent or received on a datagram socket
  42  * is individually addressed and routed. Multiple packets sent from
  43  * one machine to another may be routed differently, and may arrive in
  44  * any order.
  45  *
  46  * &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the
  47  * {@link StandardSocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as
  48  * to allow the transmission of broadcast datagrams. In order to receive
  49  * broadcast packets a DatagramSocket should be bound to the wildcard address.
  50  * In some implementations, broadcast packets may also be received when
  51  * a DatagramSocket is bound to a more specific address.
  52  * &lt;p&gt;
  53  * Example:
  54  * &lt;pre&gt;{@code
  55  *              DatagramSocket s = new DatagramSocket(null);
</pre>
<hr />
<pre>
  96  *     &lt;td&gt; Allow transmission of broadcast datagrams &lt;/td&gt;
  97  *   &lt;/tr&gt;
  98  *   &lt;tr&gt;
  99  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_TOS IP_TOS} &lt;/th&gt;
 100  *     &lt;td&gt; The Type of Service (ToS) octet in the Internet Protocol (IP) header &lt;/td&gt;
 101  *   &lt;/tr&gt;
 102  * &lt;/tbody&gt;
 103  * &lt;/table&gt;
 104  * &lt;/blockquote&gt;
 105  * An implementation may also support additional options. In particular an implementation
 106  * may support &lt;a href=&quot;MulticastSocket.html#MulticastOptions&quot;&gt;multicast options&lt;/a&gt; which
 107  * can be useful when using a plain {@code DatagramSocket} to send datagrams to a
 108  * multicast group.
 109  *
 110  * @author  Pavani Diwanji
 111  * @see     java.net.DatagramPacket
 112  * @see     java.nio.channels.DatagramChannel
 113  * @since 1.0
 114  */
 115 public class DatagramSocket implements java.io.Closeable {
<span class="line-removed"> 116     /**</span>
<span class="line-removed"> 117      * Various states of this socket.</span>
<span class="line-removed"> 118      */</span>
<span class="line-removed"> 119     private boolean bound = false;</span>
<span class="line-removed"> 120     private boolean closed = false;</span>
<span class="line-removed"> 121     private volatile boolean created;</span>
<span class="line-removed"> 122     private final Object closeLock = new Object();</span>
 123 
<span class="line-modified"> 124     /*</span>
<span class="line-modified"> 125      * The implementation of this DatagramSocket.</span>
<span class="line-removed"> 126      */</span>
<span class="line-removed"> 127     private final DatagramSocketImpl impl;</span>
 128 
<span class="line-modified"> 129     /**</span>
<span class="line-modified"> 130      * Are we using an older DatagramSocketImpl?</span>
<span class="line-modified"> 131      */</span>
<span class="line-modified"> 132     final boolean oldImpl;</span>
<span class="line-modified"> 133 </span>
<span class="line-modified"> 134     /**</span>
<span class="line-removed"> 135      * Set when a socket is ST_CONNECTED until we are certain</span>
<span class="line-removed"> 136      * that any packets which might have been received prior</span>
<span class="line-removed"> 137      * to calling connect() but not read by the application</span>
<span class="line-removed"> 138      * have been read. During this time we check the source</span>
<span class="line-removed"> 139      * address of all packets received to be sure they are from</span>
<span class="line-removed"> 140      * the connected destination. Other packets are read but</span>
<span class="line-removed"> 141      * silently dropped.</span>
<span class="line-removed"> 142      */</span>
<span class="line-removed"> 143     private boolean explicitFilter = false;</span>
<span class="line-removed"> 144     private int bytesLeftToFilter;</span>
<span class="line-removed"> 145     /*</span>
<span class="line-removed"> 146      * Connection state:</span>
<span class="line-removed"> 147      * ST_NOT_CONNECTED = socket not connected</span>
<span class="line-removed"> 148      * ST_CONNECTED = socket connected</span>
<span class="line-removed"> 149      * ST_CONNECTED_NO_IMPL = socket connected but not at impl level</span>
<span class="line-removed"> 150      */</span>
<span class="line-removed"> 151     static final int ST_NOT_CONNECTED = 0;</span>
<span class="line-removed"> 152     static final int ST_CONNECTED = 1;</span>
<span class="line-removed"> 153     static final int ST_CONNECTED_NO_IMPL = 2;</span>
<span class="line-removed"> 154 </span>
<span class="line-removed"> 155     int connectState = ST_NOT_CONNECTED;</span>
<span class="line-removed"> 156 </span>
<span class="line-removed"> 157     /*</span>
<span class="line-removed"> 158      * Connected address &amp; port</span>
<span class="line-removed"> 159      */</span>
<span class="line-removed"> 160     InetAddress connectedAddress = null;</span>
<span class="line-removed"> 161     int connectedPort = -1;</span>
 162 
 163     /**
<span class="line-modified"> 164      * Connects this socket to a remote socket address (IP address + port number).</span>
<span class="line-modified"> 165      * Binds socket if not already bound.</span>
<span class="line-removed"> 166      *</span>
<span class="line-removed"> 167      * @param   address The remote address.</span>
<span class="line-removed"> 168      * @param   port    The remote port</span>
<span class="line-removed"> 169      * @throws  SocketException if binding the socket fails.</span>
 170      */
<span class="line-modified"> 171     private synchronized void connectInternal(InetAddress address, int port) throws SocketException {</span>
<span class="line-modified"> 172         if (port &lt; 0 || port &gt; 0xFFFF) {</span>
<span class="line-modified"> 173             throw new IllegalArgumentException(&quot;connect: &quot; + port);</span>
<span class="line-modified"> 174         }</span>
<span class="line-modified"> 175         if (address == null) {</span>
<span class="line-removed"> 176             throw new IllegalArgumentException(&quot;connect: null address&quot;);</span>
<span class="line-removed"> 177         }</span>
<span class="line-removed"> 178         checkAddress (address, &quot;connect&quot;);</span>
<span class="line-removed"> 179         if (isClosed())</span>
<span class="line-removed"> 180             return;</span>
<span class="line-removed"> 181         SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed"> 182         if (security != null) {</span>
<span class="line-removed"> 183             if (address.isMulticastAddress()) {</span>
<span class="line-removed"> 184                 security.checkMulticast(address);</span>
<span class="line-removed"> 185             } else {</span>
<span class="line-removed"> 186                 security.checkConnect(address.getHostAddress(), port);</span>
<span class="line-removed"> 187                 security.checkAccept(address.getHostAddress(), port);</span>
<span class="line-removed"> 188             }</span>
<span class="line-removed"> 189         }</span>
<span class="line-removed"> 190 </span>
<span class="line-removed"> 191         if (port == 0) {</span>
<span class="line-removed"> 192             throw new SocketException(&quot;Can&#39;t connect to port 0&quot;);</span>
<span class="line-removed"> 193         }</span>
<span class="line-removed"> 194         if (!isBound())</span>
<span class="line-removed"> 195           bind(new InetSocketAddress(0));</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197         // old impls do not support connect/disconnect</span>
<span class="line-removed"> 198         if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &amp;&amp;</span>
<span class="line-removed"> 199              ((AbstractPlainDatagramSocketImpl)impl).nativeConnectDisabled())) {</span>
<span class="line-removed"> 200             connectState = ST_CONNECTED_NO_IMPL;</span>
<span class="line-removed"> 201         } else {</span>
<span class="line-removed"> 202             try {</span>
<span class="line-removed"> 203                 getImpl().connect(address, port);</span>
<span class="line-removed"> 204 </span>
<span class="line-removed"> 205                 // socket is now connected by the impl</span>
<span class="line-removed"> 206                 connectState = ST_CONNECTED;</span>
<span class="line-removed"> 207                 // Do we need to filter some packets?</span>
<span class="line-removed"> 208                 int avail = getImpl().dataAvailable();</span>
<span class="line-removed"> 209                 if (avail == -1) {</span>
<span class="line-removed"> 210                     throw new SocketException();</span>
<span class="line-removed"> 211                 }</span>
<span class="line-removed"> 212                 explicitFilter = avail &gt; 0;</span>
<span class="line-removed"> 213                 if (explicitFilter) {</span>
<span class="line-removed"> 214                     bytesLeftToFilter = getReceiveBufferSize();</span>
<span class="line-removed"> 215                 }</span>
<span class="line-removed"> 216             } catch (SocketException se) {</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218                 // connection will be emulated by DatagramSocket</span>
<span class="line-removed"> 219                 connectState = ST_CONNECTED_NO_IMPL;</span>
<span class="line-removed"> 220             }</span>
<span class="line-removed"> 221         }</span>
<span class="line-removed"> 222 </span>
<span class="line-removed"> 223         connectedAddress = address;</span>
<span class="line-removed"> 224         connectedPort = port;</span>
 225     }
 226 
<span class="line-removed"> 227 </span>
 228     /**
 229      * Constructs a datagram socket and binds it to any available port
 230      * on the local host machine.  The socket will be bound to the
 231      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 232      * an IP address chosen by the kernel.
 233      *
 234      * &lt;p&gt;If there is a security manager,
 235      * its {@code checkListen} method is first called
 236      * with 0 as its argument to ensure the operation is allowed.
 237      * This could result in a SecurityException.
 238      *
 239      * @throws     SocketException  if the socket could not be opened,
 240      *               or the socket could not bind to the specified local port.
 241      * @throws     SecurityException  if a security manager exists and its
 242      *             {@code checkListen} method doesn&#39;t allow the operation.
 243      *
 244      * @see SecurityManager#checkListen
 245      */
 246     public DatagramSocket() throws SocketException {
 247         this(new InetSocketAddress(0));
 248     }
 249 
 250     /**
 251      * Creates an unbound datagram socket with the specified
 252      * DatagramSocketImpl.
 253      *
 254      * @param impl an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
 255      *        the subclass wishes to use on the DatagramSocket.
 256      * @since   1.4
 257      */
 258     protected DatagramSocket(DatagramSocketImpl impl) {
<span class="line-modified"> 259         if (impl == null)</span>
<span class="line-removed"> 260             throw new NullPointerException();</span>
<span class="line-removed"> 261         this.impl = impl;</span>
<span class="line-removed"> 262         this.oldImpl = checkOldImpl(impl);</span>
 263     }
 264 
 265     /**
 266      * Creates a datagram socket, bound to the specified local
 267      * socket address.
 268      * &lt;p&gt;
 269      * If, if the address is {@code null}, creates an unbound socket.
 270      *
 271      * &lt;p&gt;If there is a security manager,
 272      * its {@code checkListen} method is first called
 273      * with the port from the socket address
 274      * as its argument to ensure the operation is allowed.
 275      * This could result in a SecurityException.
 276      *
 277      * @param bindaddr local socket address to bind, or {@code null}
 278      *                 for an unbound socket.
 279      *
 280      * @throws     SocketException  if the socket could not be opened,
 281      *               or the socket could not bind to the specified local port.
 282      * @throws     SecurityException  if a security manager exists and its
 283      *             {@code checkListen} method doesn&#39;t allow the operation.
 284      *
 285      * @see SecurityManager#checkListen
 286      * @since   1.4
 287      */
 288     public DatagramSocket(SocketAddress bindaddr) throws SocketException {
<span class="line-modified"> 289         // Special case initialization for the DatagramChannel socket adaptor.</span>
<span class="line-removed"> 290         if (this instanceof sun.nio.ch.DatagramSocketAdaptor) {</span>
<span class="line-removed"> 291             this.impl = null;  // no DatagramSocketImpl</span>
<span class="line-removed"> 292             this.oldImpl = false;</span>
<span class="line-removed"> 293             return;</span>
<span class="line-removed"> 294         }</span>
<span class="line-removed"> 295 </span>
<span class="line-removed"> 296         // create a datagram socket.</span>
<span class="line-removed"> 297         boolean multicast = (this instanceof MulticastSocket);</span>
<span class="line-removed"> 298         this.impl = createImpl(multicast);</span>
<span class="line-removed"> 299         // creates the udp socket</span>
<span class="line-removed"> 300         impl.create();</span>
<span class="line-removed"> 301         created = true;</span>
<span class="line-removed"> 302         this.oldImpl = checkOldImpl(impl);</span>
<span class="line-removed"> 303         if (bindaddr != null) {</span>
<span class="line-removed"> 304             try {</span>
<span class="line-removed"> 305                 bind(bindaddr);</span>
<span class="line-removed"> 306             } finally {</span>
<span class="line-removed"> 307                 if (!isBound())</span>
<span class="line-removed"> 308                     close();</span>
<span class="line-removed"> 309             }</span>
<span class="line-removed"> 310         }</span>
 311     }
 312 
 313     /**
 314      * Constructs a datagram socket and binds it to the specified port
 315      * on the local host machine.  The socket will be bound to the
 316      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 317      * an IP address chosen by the kernel.
 318      *
 319      * &lt;p&gt;If there is a security manager,
 320      * its {@code checkListen} method is first called
 321      * with the {@code port} argument
 322      * as its argument to ensure the operation is allowed.
 323      * This could result in a SecurityException.
 324      *
 325      * @param      port port to use.
 326      * @throws     SocketException  if the socket could not be opened,
 327      *               or the socket could not bind to the specified local port.
 328      * @throws     SecurityException  if a security manager exists and its
 329      *             {@code checkListen} method doesn&#39;t allow the operation.
 330      *
</pre>
<hr />
<pre>
 345      * its {@code checkListen} method is first called
 346      * with the {@code port} argument
 347      * as its argument to ensure the operation is allowed.
 348      * This could result in a SecurityException.
 349      *
 350      * @param port local port to use
 351      * @param laddr local address to bind
 352      *
 353      * @throws     SocketException  if the socket could not be opened,
 354      *               or the socket could not bind to the specified local port.
 355      * @throws     SecurityException  if a security manager exists and its
 356      *             {@code checkListen} method doesn&#39;t allow the operation.
 357      *
 358      * @see SecurityManager#checkListen
 359      * @since   1.1
 360      */
 361     public DatagramSocket(int port, InetAddress laddr) throws SocketException {
 362         this(new InetSocketAddress(laddr, port));
 363     }
 364 
<span class="line-removed"> 365     /**</span>
<span class="line-removed"> 366      * Return true if the given DatagramSocketImpl is an &quot;old&quot; impl. An old impl</span>
<span class="line-removed"> 367      * is one that doesn&#39;t implement the abstract methods added in Java SE 1.4.</span>
<span class="line-removed"> 368      */</span>
<span class="line-removed"> 369     private static boolean checkOldImpl(DatagramSocketImpl impl) {</span>
<span class="line-removed"> 370         // DatagramSocketImpl.peekData() is a protected method, therefore we need to use</span>
<span class="line-removed"> 371         // getDeclaredMethod, therefore we need permission to access the member</span>
<span class="line-removed"> 372         try {</span>
<span class="line-removed"> 373             AccessController.doPrivileged(</span>
<span class="line-removed"> 374                 new PrivilegedExceptionAction&lt;&gt;() {</span>
<span class="line-removed"> 375                     public Void run() throws NoSuchMethodException {</span>
<span class="line-removed"> 376                         Class&lt;?&gt;[] cl = new Class&lt;?&gt;[1];</span>
<span class="line-removed"> 377                         cl[0] = DatagramPacket.class;</span>
<span class="line-removed"> 378                         impl.getClass().getDeclaredMethod(&quot;peekData&quot;, cl);</span>
<span class="line-removed"> 379                         return null;</span>
<span class="line-removed"> 380                     }</span>
<span class="line-removed"> 381                 });</span>
<span class="line-removed"> 382             return false;</span>
<span class="line-removed"> 383         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-removed"> 384             return true;</span>
<span class="line-removed"> 385         }</span>
<span class="line-removed"> 386     }</span>
<span class="line-removed"> 387 </span>
<span class="line-removed"> 388     static Class&lt;?&gt; implClass = null;</span>
<span class="line-removed"> 389 </span>
<span class="line-removed"> 390     /**</span>
<span class="line-removed"> 391      * Creates a DatagramSocketImpl.</span>
<span class="line-removed"> 392      * @param multicast true if the DatagramSocketImpl is for a MulticastSocket</span>
<span class="line-removed"> 393      */</span>
<span class="line-removed"> 394     private static DatagramSocketImpl createImpl(boolean multicast) throws SocketException {</span>
<span class="line-removed"> 395         DatagramSocketImpl impl;</span>
<span class="line-removed"> 396         DatagramSocketImplFactory factory = DatagramSocket.factory;</span>
<span class="line-removed"> 397         if (factory != null) {</span>
<span class="line-removed"> 398             impl = factory.createDatagramSocketImpl();</span>
<span class="line-removed"> 399         } else {</span>
<span class="line-removed"> 400             impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);</span>
<span class="line-removed"> 401         }</span>
<span class="line-removed"> 402         return impl;</span>
<span class="line-removed"> 403     }</span>
<span class="line-removed"> 404 </span>
<span class="line-removed"> 405     /**</span>
<span class="line-removed"> 406      * Return the {@code DatagramSocketImpl} attached to this socket,</span>
<span class="line-removed"> 407      * creating the socket if not already created.</span>
<span class="line-removed"> 408      *</span>
<span class="line-removed"> 409      * @return  the {@code DatagramSocketImpl} attached to that</span>
<span class="line-removed"> 410      *          DatagramSocket</span>
<span class="line-removed"> 411      * @throws SocketException if creating the socket fails</span>
<span class="line-removed"> 412      * @since 1.4</span>
<span class="line-removed"> 413      */</span>
<span class="line-removed"> 414     final DatagramSocketImpl getImpl() throws SocketException {</span>
<span class="line-removed"> 415         if (!created) {</span>
<span class="line-removed"> 416             synchronized (this) {</span>
<span class="line-removed"> 417                 if (!created)  {</span>
<span class="line-removed"> 418                     impl.create();</span>
<span class="line-removed"> 419                     created = true;</span>
<span class="line-removed"> 420                 }</span>
<span class="line-removed"> 421             }</span>
<span class="line-removed"> 422         }</span>
<span class="line-removed"> 423         return impl;</span>
<span class="line-removed"> 424     }</span>
<span class="line-removed"> 425 </span>
 426     /**
 427      * Binds this DatagramSocket to a specific address and port.
 428      * &lt;p&gt;
 429      * If the address is {@code null}, then the system will pick up
 430      * an ephemeral port and a valid local address to bind the socket.
 431      *
 432      * @param   addr The address and port to bind to.
 433      * @throws  SocketException if any error happens during the bind, or if the
 434      *          socket is already bound.
 435      * @throws  SecurityException  if a security manager exists and its
 436      *             {@code checkListen} method doesn&#39;t allow the operation.
 437      * @throws IllegalArgumentException if addr is a SocketAddress subclass
 438      *         not supported by this socket.
 439      * @since 1.4
 440      */
<span class="line-modified"> 441     public synchronized void bind(SocketAddress addr) throws SocketException {</span>
<span class="line-modified"> 442         if (isClosed())</span>
<span class="line-removed"> 443             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed"> 444         if (isBound())</span>
<span class="line-removed"> 445             throw new SocketException(&quot;already bound&quot;);</span>
<span class="line-removed"> 446         if (addr == null)</span>
<span class="line-removed"> 447             addr = new InetSocketAddress(0);</span>
<span class="line-removed"> 448         if (!(addr instanceof InetSocketAddress))</span>
<span class="line-removed"> 449             throw new IllegalArgumentException(&quot;Unsupported address type!&quot;);</span>
<span class="line-removed"> 450         InetSocketAddress epoint = (InetSocketAddress) addr;</span>
<span class="line-removed"> 451         if (epoint.isUnresolved())</span>
<span class="line-removed"> 452             throw new SocketException(&quot;Unresolved address&quot;);</span>
<span class="line-removed"> 453         InetAddress iaddr = epoint.getAddress();</span>
<span class="line-removed"> 454         int port = epoint.getPort();</span>
<span class="line-removed"> 455         checkAddress(iaddr, &quot;bind&quot;);</span>
<span class="line-removed"> 456         SecurityManager sec = System.getSecurityManager();</span>
<span class="line-removed"> 457         if (sec != null) {</span>
<span class="line-removed"> 458             sec.checkListen(port);</span>
<span class="line-removed"> 459         }</span>
<span class="line-removed"> 460         try {</span>
<span class="line-removed"> 461             getImpl().bind(port, iaddr);</span>
<span class="line-removed"> 462         } catch (SocketException e) {</span>
<span class="line-removed"> 463             getImpl().close();</span>
<span class="line-removed"> 464             throw e;</span>
<span class="line-removed"> 465         }</span>
<span class="line-removed"> 466         bound = true;</span>
<span class="line-removed"> 467     }</span>
<span class="line-removed"> 468 </span>
<span class="line-removed"> 469     void checkAddress (InetAddress addr, String op) {</span>
<span class="line-removed"> 470         if (addr == null) {</span>
<span class="line-removed"> 471             return;</span>
<span class="line-removed"> 472         }</span>
<span class="line-removed"> 473         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {</span>
<span class="line-removed"> 474             throw new IllegalArgumentException(op + &quot;: invalid address type&quot;);</span>
<span class="line-removed"> 475         }</span>
 476     }
 477 
 478     /**
 479      * Connects the socket to a remote address for this socket. When a
 480      * socket is connected to a remote address, packets may only be
 481      * sent to or received from that address. By default a datagram
 482      * socket is not connected. If the socket is already closed,
 483      * then this method has no effect.
 484      *
 485      * &lt;p&gt; If this socket is not bound then this method will first cause the
 486      * socket to be bound to an address that is assigned automatically,
 487      * as if invoking the {@link #bind bind} method with a parameter of
 488      * {@code null}. If the remote destination to which the socket is connected
 489      * does not exist, or is otherwise unreachable, and if an ICMP destination
 490      * unreachable packet has been received for that address, then a subsequent
 491      * call to send or receive may throw a PortUnreachableException. Note,
 492      * there is no guarantee that the exception will be thrown.
 493      *
 494      * &lt;p&gt; If a security manager has been installed then it is invoked to check
 495      * access to the remote address. Specifically, if the given {@code address}
</pre>
<hr />
<pre>
 517      * @param address the remote address for the socket
 518      *
 519      * @param port the remote port for the socket.
 520      *
 521      * @throws IllegalArgumentException
 522      *         if the address is null, or the port is out of range.
 523      *
 524      * @throws SecurityException
 525      *         if a security manager has been installed and it does
 526      *         not permit access to the given remote address
 527      *
 528      * @throws UncheckedIOException
 529      *         may be thrown if connect fails, for example, if the
 530      *         destination address is non-routable
 531      *
 532      * @see #disconnect
 533      *
 534      * @since 1.2
 535      */
 536     public void connect(InetAddress address, int port) {
<span class="line-modified"> 537         try {</span>
<span class="line-removed"> 538             connectInternal(address, port);</span>
<span class="line-removed"> 539         } catch (SocketException se) {</span>
<span class="line-removed"> 540             throw new UncheckedIOException(&quot;connect failed&quot;, se);</span>
<span class="line-removed"> 541         }</span>
 542     }
 543 
 544     /**
 545      * Connects this socket to a remote socket address (IP address + port number).
 546      *
 547      * &lt;p&gt; If given an {@link InetSocketAddress InetSocketAddress}, this method
 548      * behaves as if invoking {@link #connect(InetAddress,int) connect(InetAddress,int)}
 549      * with the given socket addresses IP address and port number, except that the
 550      * {@code SocketException} that may be raised is not wrapped in an
 551      * {@code UncheckedIOException}.
 552      *
 553      * @param   addr    The remote address.
 554      *
 555      * @throws  SocketException
 556      *          if the connect fails
 557      *
 558      * @throws IllegalArgumentException
 559      *         if {@code addr} is {@code null}, or {@code addr} is a SocketAddress
 560      *         subclass not supported by this socket
 561      *
 562      * @throws SecurityException
 563      *         if a security manager has been installed and it does
 564      *         not permit access to the given remote address
 565      *
 566      * @since 1.4
 567      */
 568     public void connect(SocketAddress addr) throws SocketException {
<span class="line-modified"> 569         if (addr == null)</span>
<span class="line-removed"> 570             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);</span>
<span class="line-removed"> 571         if (!(addr instanceof InetSocketAddress))</span>
<span class="line-removed"> 572             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="line-removed"> 573         InetSocketAddress epoint = (InetSocketAddress) addr;</span>
<span class="line-removed"> 574         if (epoint.isUnresolved())</span>
<span class="line-removed"> 575             throw new SocketException(&quot;Unresolved address&quot;);</span>
<span class="line-removed"> 576         connectInternal(epoint.getAddress(), epoint.getPort());</span>
 577     }
 578 
 579     /**
 580      * Disconnects the socket. If the socket is closed or not connected,
 581      * then this method has no effect.
 582      *
 583      * @apiNote If this method throws an UncheckedIOException, the socket
 584      *          may be left in an unspecified state. It is strongly
 585      *          recommended that the socket be closed when disconnect
 586      *          fails.
 587      *
 588      * @throws  UncheckedIOException
 589      *          may be thrown if disconnect fails to dissolve the
 590      *          association and restore the socket to a consistent state.
 591      *
 592      * @see #connect
 593      *
 594      * @since 1.2
 595      */
 596     public void disconnect() {
<span class="line-modified"> 597         synchronized (this) {</span>
<span class="line-removed"> 598             if (isClosed())</span>
<span class="line-removed"> 599                 return;</span>
<span class="line-removed"> 600             if (connectState == ST_CONNECTED) {</span>
<span class="line-removed"> 601                 impl.disconnect ();</span>
<span class="line-removed"> 602             }</span>
<span class="line-removed"> 603             connectedAddress = null;</span>
<span class="line-removed"> 604             connectedPort = -1;</span>
<span class="line-removed"> 605             connectState = ST_NOT_CONNECTED;</span>
<span class="line-removed"> 606             explicitFilter = false;</span>
<span class="line-removed"> 607         }</span>
 608     }
 609 
 610     /**
 611      * Returns the binding state of the socket.
 612      * &lt;p&gt;
 613      * If the socket was bound prior to being {@link #close closed},
 614      * then this method will continue to return {@code true}
 615      * after the socket is closed.
 616      *
 617      * @return true if the socket successfully bound to an address
 618      * @since 1.4
 619      */
 620     public boolean isBound() {
<span class="line-modified"> 621         return bound;</span>
 622     }
 623 
 624     /**
 625      * Returns the connection state of the socket.
 626      * &lt;p&gt;
 627      * If the socket was connected prior to being {@link #close closed},
 628      * then this method will continue to return {@code true}
 629      * after the socket is closed.
 630      *
 631      * @return true if the socket successfully connected to a server
 632      * @since 1.4
 633      */
 634     public boolean isConnected() {
<span class="line-modified"> 635         return connectState != ST_NOT_CONNECTED;</span>
 636     }
 637 
 638     /**
 639      * Returns the address to which this socket is connected. Returns
 640      * {@code null} if the socket is not connected.
 641      * &lt;p&gt;
 642      * If the socket was connected prior to being {@link #close closed},
 643      * then this method will continue to return the connected address
 644      * after the socket is closed.
 645      *
 646      * @return the address to which this socket is connected.
 647      * @since 1.2
 648      */
 649     public InetAddress getInetAddress() {
<span class="line-modified"> 650         return connectedAddress;</span>
 651     }
 652 
 653     /**
 654      * Returns the port number to which this socket is connected.
 655      * Returns {@code -1} if the socket is not connected.
 656      * &lt;p&gt;
 657      * If the socket was connected prior to being {@link #close closed},
 658      * then this method will continue to return the connected port number
 659      * after the socket is closed.
 660      *
 661      * @return the port number to which this socket is connected.
 662      * @since 1.2
 663      */
 664     public int getPort() {
<span class="line-modified"> 665         return connectedPort;</span>
 666     }
 667 
 668     /**
 669      * Returns the address of the endpoint this socket is connected to, or
 670      * {@code null} if it is unconnected.
 671      * &lt;p&gt;
 672      * If the socket was connected prior to being {@link #close closed},
 673      * then this method will continue to return the connected address
 674      * after the socket is closed.
 675      *
 676      * @return a {@code SocketAddress} representing the remote
 677      *         endpoint of this socket, or {@code null} if it is
 678      *         not connected yet.
 679      * @see #getInetAddress()
 680      * @see #getPort()
 681      * @see #connect(SocketAddress)
 682      * @since 1.4
 683      */
 684     public SocketAddress getRemoteSocketAddress() {
<span class="line-modified"> 685         if (!isConnected())</span>
<span class="line-removed"> 686             return null;</span>
<span class="line-removed"> 687         return new InetSocketAddress(getInetAddress(), getPort());</span>
 688     }
 689 
 690     /**
 691      * Returns the address of the endpoint this socket is bound to.
 692      *
 693      * @return a {@code SocketAddress} representing the local endpoint of this
 694      *         socket, or {@code null} if it is closed or not bound yet.
 695      * @see #getLocalAddress()
 696      * @see #getLocalPort()
 697      * @see #bind(SocketAddress)
 698      * @since 1.4
 699      */
 700     public SocketAddress getLocalSocketAddress() {
<span class="line-modified"> 701         if (isClosed())</span>
<span class="line-removed"> 702             return null;</span>
<span class="line-removed"> 703         if (!isBound())</span>
<span class="line-removed"> 704             return null;</span>
<span class="line-removed"> 705         return new InetSocketAddress(getLocalAddress(), getLocalPort());</span>
 706     }
 707 
 708     /**
 709      * Sends a datagram packet from this socket. The
 710      * {@code DatagramPacket} includes information indicating the
 711      * data to be sent, its length, the IP address of the remote host,
 712      * and the port number on the remote host.
 713      *
 714      * &lt;p&gt;If there is a security manager, and the socket is not currently
 715      * connected to a remote address, this method first performs some
 716      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
 717      * is true, this method calls the
 718      * security manager&#39;s {@code checkMulticast} method
 719      * with {@code p.getAddress()} as its argument.
 720      * If the evaluation of that expression is false,
 721      * this method instead calls the security manager&#39;s
 722      * {@code checkConnect} method with arguments
 723      * {@code p.getAddress().getHostAddress()} and
 724      * {@code p.getPort()}. Each call to a security manager method
 725      * could result in a SecurityException if the operation is not allowed.
</pre>
<hr />
<pre>
 731      *             {@code checkMulticast} or {@code checkConnect}
 732      *             method doesn&#39;t allow the send.
 733      * @throws     PortUnreachableException may be thrown if the socket is connected
 734      *             to a currently unreachable destination. Note, there is no
 735      *             guarantee that the exception will be thrown.
 736      * @throws     java.nio.channels.IllegalBlockingModeException
 737      *             if this socket has an associated channel,
 738      *             and the channel is in non-blocking mode.
 739      * @throws     IllegalArgumentException if the socket is connected,
 740      *             and connected address and packet address differ, or
 741      *             if the socket is not connected and the packet address
 742      *             is not set or if its port is out of range.
 743      *
 744      * @see        java.net.DatagramPacket
 745      * @see        SecurityManager#checkMulticast(InetAddress)
 746      * @see        SecurityManager#checkConnect
 747      * @revised 1.4
 748      * @spec JSR-51
 749      */
 750     public void send(DatagramPacket p) throws IOException  {
<span class="line-modified"> 751         synchronized (p) {</span>
<span class="line-removed"> 752             if (isClosed())</span>
<span class="line-removed"> 753                 throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed"> 754             InetAddress packetAddress = p.getAddress();</span>
<span class="line-removed"> 755             int packetPort = p.getPort();</span>
<span class="line-removed"> 756             checkAddress (packetAddress, &quot;send&quot;);</span>
<span class="line-removed"> 757             if (connectState == ST_NOT_CONNECTED) {</span>
<span class="line-removed"> 758                 if (packetAddress == null) {</span>
<span class="line-removed"> 759                     throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-removed"> 760                 }</span>
<span class="line-removed"> 761                 if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)</span>
<span class="line-removed"> 762                     throw new IllegalArgumentException(&quot;port out of range:&quot; + packetPort);</span>
<span class="line-removed"> 763                 // check the address is ok with the security manager on every send.</span>
<span class="line-removed"> 764                 SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed"> 765 </span>
<span class="line-removed"> 766                 // The reason you want to synchronize on datagram packet</span>
<span class="line-removed"> 767                 // is because you don&#39;t want an applet to change the address</span>
<span class="line-removed"> 768                 // while you are trying to send the packet for example</span>
<span class="line-removed"> 769                 // after the security check but before the send.</span>
<span class="line-removed"> 770                 if (security != null) {</span>
<span class="line-removed"> 771                     if (packetAddress.isMulticastAddress()) {</span>
<span class="line-removed"> 772                         security.checkMulticast(packetAddress);</span>
<span class="line-removed"> 773                     } else {</span>
<span class="line-removed"> 774                         security.checkConnect(packetAddress.getHostAddress(),</span>
<span class="line-removed"> 775                                 packetPort);</span>
<span class="line-removed"> 776                     }</span>
<span class="line-removed"> 777                 }</span>
<span class="line-removed"> 778                 if (packetPort == 0) {</span>
<span class="line-removed"> 779                     throw new SocketException(&quot;Can&#39;t send to port 0&quot;);</span>
<span class="line-removed"> 780                 }</span>
<span class="line-removed"> 781             } else {</span>
<span class="line-removed"> 782                 // we&#39;re connected</span>
<span class="line-removed"> 783                 if (packetAddress == null) {</span>
<span class="line-removed"> 784                     p.setAddress(connectedAddress);</span>
<span class="line-removed"> 785                     p.setPort(connectedPort);</span>
<span class="line-removed"> 786                 } else if ((!packetAddress.equals(connectedAddress)) ||</span>
<span class="line-removed"> 787                         packetPort != connectedPort) {</span>
<span class="line-removed"> 788                     throw new IllegalArgumentException(&quot;connected address &quot; +</span>
<span class="line-removed"> 789                                                        &quot;and packet address&quot; +</span>
<span class="line-removed"> 790                                                        &quot; differ&quot;);</span>
<span class="line-removed"> 791                 }</span>
<span class="line-removed"> 792             }</span>
<span class="line-removed"> 793             // Check whether the socket is bound</span>
<span class="line-removed"> 794             if (!isBound())</span>
<span class="line-removed"> 795                 bind(new InetSocketAddress(0));</span>
<span class="line-removed"> 796             // call the  method to send</span>
<span class="line-removed"> 797             getImpl().send(p);</span>
<span class="line-removed"> 798         }</span>
 799     }
 800 
 801     /**
 802      * Receives a datagram packet from this socket. When this method
 803      * returns, the {@code DatagramPacket}&#39;s buffer is filled with
 804      * the data received. The datagram packet also contains the sender&#39;s
 805      * IP address, and the port number on the sender&#39;s machine.
 806      * &lt;p&gt;
 807      * This method blocks until a datagram is received. The
 808      * {@code length} field of the datagram packet object contains
 809      * the length of the received message. If the message is longer than
 810      * the packet&#39;s length, the message is truncated.
 811      * &lt;p&gt;
 812      * If there is a security manager, and the socket is not currently
 813      * connected to a remote address, a packet cannot be received if the
 814      * security manager&#39;s {@code checkAccept} method does not allow it.
 815      * Datagrams that are not permitted by the security manager are silently
 816      * discarded.
 817      *
 818      * @param      p   the {@code DatagramPacket} into which to place
 819      *                 the incoming data.
 820      * @throws     IOException  if an I/O error occurs.
 821      * @throws     SocketTimeoutException  if setSoTimeout was previously called
 822      *                 and the timeout has expired.
 823      * @throws     PortUnreachableException may be thrown if the socket is connected
 824      *             to a currently unreachable destination. Note, there is no guarantee that the
 825      *             exception will be thrown.
 826      * @throws     java.nio.channels.IllegalBlockingModeException
 827      *             if this socket has an associated channel,
 828      *             and the channel is in non-blocking mode.
 829      * @see        java.net.DatagramPacket
 830      * @see        java.net.DatagramSocket
 831      * @revised 1.4
 832      * @spec JSR-51
 833      */
<span class="line-modified"> 834     public synchronized void receive(DatagramPacket p) throws IOException {</span>
<span class="line-modified"> 835         synchronized (p) {</span>
<span class="line-removed"> 836             if (!isBound())</span>
<span class="line-removed"> 837                 bind(new InetSocketAddress(0));</span>
<span class="line-removed"> 838             if (connectState == ST_NOT_CONNECTED) {</span>
<span class="line-removed"> 839                 // check the address is ok with the security manager before every recv.</span>
<span class="line-removed"> 840                 SecurityManager security = System.getSecurityManager();</span>
<span class="line-removed"> 841                 if (security != null) {</span>
<span class="line-removed"> 842                     while(true) {</span>
<span class="line-removed"> 843                         String peekAd = null;</span>
<span class="line-removed"> 844                         int peekPort = 0;</span>
<span class="line-removed"> 845                         // peek at the packet to see who it is from.</span>
<span class="line-removed"> 846                         if (!oldImpl) {</span>
<span class="line-removed"> 847                             // We can use the new peekData() API</span>
<span class="line-removed"> 848                             DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);</span>
<span class="line-removed"> 849                             peekPort = getImpl().peekData(peekPacket);</span>
<span class="line-removed"> 850                             peekAd = peekPacket.getAddress().getHostAddress();</span>
<span class="line-removed"> 851                         } else {</span>
<span class="line-removed"> 852                             InetAddress adr = new InetAddress();</span>
<span class="line-removed"> 853                             peekPort = getImpl().peek(adr);</span>
<span class="line-removed"> 854                             peekAd = adr.getHostAddress();</span>
<span class="line-removed"> 855                         }</span>
<span class="line-removed"> 856                         try {</span>
<span class="line-removed"> 857                             security.checkAccept(peekAd, peekPort);</span>
<span class="line-removed"> 858                             // security check succeeded - so now break</span>
<span class="line-removed"> 859                             // and recv the packet.</span>
<span class="line-removed"> 860                             break;</span>
<span class="line-removed"> 861                         } catch (SecurityException se) {</span>
<span class="line-removed"> 862                             // Throw away the offending packet by consuming</span>
<span class="line-removed"> 863                             // it in a tmp buffer.</span>
<span class="line-removed"> 864                             DatagramPacket tmp = new DatagramPacket(new byte[1], 1);</span>
<span class="line-removed"> 865                             getImpl().receive(tmp);</span>
<span class="line-removed"> 866 </span>
<span class="line-removed"> 867                             // silently discard the offending packet</span>
<span class="line-removed"> 868                             // and continue: unknown/malicious</span>
<span class="line-removed"> 869                             // entities on nets should not make</span>
<span class="line-removed"> 870                             // runtime throw security exception and</span>
<span class="line-removed"> 871                             // disrupt the applet by sending random</span>
<span class="line-removed"> 872                             // datagram packets.</span>
<span class="line-removed"> 873                             continue;</span>
<span class="line-removed"> 874                         }</span>
<span class="line-removed"> 875                     } // end of while</span>
<span class="line-removed"> 876                 }</span>
<span class="line-removed"> 877             }</span>
<span class="line-removed"> 878             DatagramPacket tmp = null;</span>
<span class="line-removed"> 879             if ((connectState == ST_CONNECTED_NO_IMPL) || explicitFilter) {</span>
<span class="line-removed"> 880                 // We have to do the filtering the old fashioned way since</span>
<span class="line-removed"> 881                 // the native impl doesn&#39;t support connect or the connect</span>
<span class="line-removed"> 882                 // via the impl failed, or .. &quot;explicitFilter&quot; may be set when</span>
<span class="line-removed"> 883                 // a socket is connected via the impl, for a period of time</span>
<span class="line-removed"> 884                 // when packets from other sources might be queued on socket.</span>
<span class="line-removed"> 885                 boolean stop = false;</span>
<span class="line-removed"> 886                 while (!stop) {</span>
<span class="line-removed"> 887                     InetAddress peekAddress = null;</span>
<span class="line-removed"> 888                     int peekPort = -1;</span>
<span class="line-removed"> 889                     // peek at the packet to see who it is from.</span>
<span class="line-removed"> 890                     if (!oldImpl) {</span>
<span class="line-removed"> 891                         // We can use the new peekData() API</span>
<span class="line-removed"> 892                         DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);</span>
<span class="line-removed"> 893                         peekPort = getImpl().peekData(peekPacket);</span>
<span class="line-removed"> 894                         peekAddress = peekPacket.getAddress();</span>
<span class="line-removed"> 895                     } else {</span>
<span class="line-removed"> 896                         // this api only works for IPv4</span>
<span class="line-removed"> 897                         peekAddress = new InetAddress();</span>
<span class="line-removed"> 898                         peekPort = getImpl().peek(peekAddress);</span>
<span class="line-removed"> 899                     }</span>
<span class="line-removed"> 900                     if ((!connectedAddress.equals(peekAddress)) ||</span>
<span class="line-removed"> 901                         (connectedPort != peekPort)) {</span>
<span class="line-removed"> 902                         // throw the packet away and silently continue</span>
<span class="line-removed"> 903                         tmp = new DatagramPacket(</span>
<span class="line-removed"> 904                                                 new byte[1024], 1024);</span>
<span class="line-removed"> 905                         getImpl().receive(tmp);</span>
<span class="line-removed"> 906                         if (explicitFilter) {</span>
<span class="line-removed"> 907                             if (checkFiltering(tmp)) {</span>
<span class="line-removed"> 908                                 stop = true;</span>
<span class="line-removed"> 909                             }</span>
<span class="line-removed"> 910                         }</span>
<span class="line-removed"> 911                     } else {</span>
<span class="line-removed"> 912                         stop = true;</span>
<span class="line-removed"> 913                     }</span>
<span class="line-removed"> 914                 }</span>
<span class="line-removed"> 915             }</span>
<span class="line-removed"> 916             // If the security check succeeds, or the datagram is</span>
<span class="line-removed"> 917             // connected then receive the packet</span>
<span class="line-removed"> 918             getImpl().receive(p);</span>
<span class="line-removed"> 919             if (explicitFilter &amp;&amp; tmp == null) {</span>
<span class="line-removed"> 920                 // packet was not filtered, account for it here</span>
<span class="line-removed"> 921                 checkFiltering(p);</span>
<span class="line-removed"> 922             }</span>
<span class="line-removed"> 923         }</span>
<span class="line-removed"> 924     }</span>
<span class="line-removed"> 925 </span>
<span class="line-removed"> 926     private boolean checkFiltering(DatagramPacket p) throws SocketException {</span>
<span class="line-removed"> 927         bytesLeftToFilter -= p.getLength();</span>
<span class="line-removed"> 928         if (bytesLeftToFilter &lt;= 0 || getImpl().dataAvailable() &lt;= 0) {</span>
<span class="line-removed"> 929             explicitFilter = false;</span>
<span class="line-removed"> 930             return true;</span>
<span class="line-removed"> 931         }</span>
<span class="line-removed"> 932         return false;</span>
 933     }
 934 
 935     /**
 936      * Gets the local address to which the socket is bound.
 937      *
 938      * &lt;p&gt;If there is a security manager, its
 939      * {@code checkConnect} method is first called
 940      * with the host address and {@code -1}
 941      * as its arguments to see if the operation is allowed.
 942      *
 943      * @see SecurityManager#checkConnect
 944      * @return  the local address to which the socket is bound,
 945      *          {@code null} if the socket is closed, or
 946      *          an {@code InetAddress} representing
 947      *          {@link InetAddress#isAnyLocalAddress wildcard}
 948      *          address if either the socket is not bound, or
 949      *          the security manager {@code checkConnect}
 950      *          method does not allow the operation
 951      * @since   1.1
 952      */
 953     public InetAddress getLocalAddress() {
<span class="line-modified"> 954         if (isClosed())</span>
<span class="line-removed"> 955             return null;</span>
<span class="line-removed"> 956         InetAddress in;</span>
<span class="line-removed"> 957         try {</span>
<span class="line-removed"> 958             in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);</span>
<span class="line-removed"> 959             if (in.isAnyLocalAddress()) {</span>
<span class="line-removed"> 960                 in = InetAddress.anyLocalAddress();</span>
<span class="line-removed"> 961             }</span>
<span class="line-removed"> 962             SecurityManager s = System.getSecurityManager();</span>
<span class="line-removed"> 963             if (s != null) {</span>
<span class="line-removed"> 964                 s.checkConnect(in.getHostAddress(), -1);</span>
<span class="line-removed"> 965             }</span>
<span class="line-removed"> 966         } catch (Exception e) {</span>
<span class="line-removed"> 967             in = InetAddress.anyLocalAddress(); // &quot;0.0.0.0&quot;</span>
<span class="line-removed"> 968         }</span>
<span class="line-removed"> 969         return in;</span>
 970     }
 971 
 972     /**
 973      * Returns the port number on the local host to which this socket
 974      * is bound.
 975      *
 976      * @return  the port number on the local host to which this socket is bound,
 977      *          {@code -1} if the socket is closed, or
 978      *          {@code 0} if it is not bound yet.
 979      */
 980     public int getLocalPort() {
<span class="line-modified"> 981         if (isClosed())</span>
<span class="line-removed"> 982             return -1;</span>
<span class="line-removed"> 983         try {</span>
<span class="line-removed"> 984             return getImpl().getLocalPort();</span>
<span class="line-removed"> 985         } catch (Exception e) {</span>
<span class="line-removed"> 986             return 0;</span>
<span class="line-removed"> 987         }</span>
 988     }
 989 
 990     /**
 991      * Enable/disable SO_TIMEOUT with the specified timeout, in
 992      * milliseconds. With this option set to a positive timeout value,
 993      * a call to receive() for this DatagramSocket
 994      * will block for only this amount of time.  If the timeout expires,
 995      * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
 996      * DatagramSocket is still valid. A timeout of zero is interpreted
 997      * as an infinite timeout.
 998      * The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking
 999      * operation to have effect.
1000      *
1001      * @param timeout the specified timeout in milliseconds.
1002      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
1003      * @throws IllegalArgumentException if {@code timeout} is negative
1004      * @since   1.1
1005      * @see #getSoTimeout()
1006      */
<span class="line-modified">1007     public synchronized void setSoTimeout(int timeout) throws SocketException {</span>
<span class="line-modified">1008         if (isClosed())</span>
<span class="line-removed">1009             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1010         if (timeout &lt; 0)</span>
<span class="line-removed">1011             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
<span class="line-removed">1012         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);</span>
1013     }
1014 
1015     /**
1016      * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
1017      * option is disabled (i.e., timeout of infinity).
1018      *
1019      * @return the setting for SO_TIMEOUT
1020      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
1021      * @since   1.1
1022      * @see #setSoTimeout(int)
1023      */
<span class="line-modified">1024     public synchronized int getSoTimeout() throws SocketException {</span>
<span class="line-modified">1025         if (isClosed())</span>
<span class="line-removed">1026             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1027         if (getImpl() == null)</span>
<span class="line-removed">1028             return 0;</span>
<span class="line-removed">1029         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);</span>
<span class="line-removed">1030         /* extra type safety */</span>
<span class="line-removed">1031         if (o instanceof Integer) {</span>
<span class="line-removed">1032             return ((Integer) o).intValue();</span>
<span class="line-removed">1033         } else {</span>
<span class="line-removed">1034             return 0;</span>
<span class="line-removed">1035         }</span>
1036     }
1037 
1038     /**
1039      * Sets the SO_SNDBUF option to the specified value for this
1040      * {@code DatagramSocket}. The SO_SNDBUF option is used by the
1041      * network implementation as a hint to size the underlying
1042      * network I/O buffers. The SO_SNDBUF setting may also be used
1043      * by the network implementation to determine the maximum size
1044      * of the packet that can be sent on this socket.
1045      * &lt;p&gt;
1046      * As SO_SNDBUF is a hint, applications that want to verify
1047      * what size the buffer is should call {@link #getSendBufferSize()}.
1048      * &lt;p&gt;
1049      * Increasing the buffer size may allow multiple outgoing packets
1050      * to be queued by the network implementation when the send rate
1051      * is high.
1052      * &lt;p&gt;
1053      * Note: If {@link #send(DatagramPacket)} is used to send a
1054      * {@code DatagramPacket} that is larger than the setting
1055      * of SO_SNDBUF then it is implementation specific if the
1056      * packet is sent or discarded.
1057      *
1058      * @param size the size to which to set the send buffer
1059      * size. This value must be greater than 0.
1060      *
1061      * @throws    SocketException if there is an error
1062      * in the underlying protocol, such as an UDP error.
1063      * @throws    IllegalArgumentException if the value is 0 or is
1064      * negative.
1065      * @see #getSendBufferSize()
1066      * @since 1.2
1067      */
<span class="line-modified">1068     public synchronized void setSendBufferSize(int size) throws SocketException {</span>
<span class="line-modified">1069         if (!(size &gt; 0)) {</span>
<span class="line-removed">1070             throw new IllegalArgumentException(&quot;negative send size&quot;);</span>
<span class="line-removed">1071         }</span>
<span class="line-removed">1072         if (isClosed())</span>
<span class="line-removed">1073             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1074         getImpl().setOption(SocketOptions.SO_SNDBUF, size);</span>
1075     }
1076 
1077     /**
1078      * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
1079      * buffer size used by the platform for output on this {@code DatagramSocket}.
1080      *
1081      * @return the value of the SO_SNDBUF option for this {@code DatagramSocket}
1082      * @throws    SocketException if there is an error in
1083      * the underlying protocol, such as an UDP error.
1084      * @see #setSendBufferSize
1085      * @since 1.2
1086      */
<span class="line-modified">1087     public synchronized int getSendBufferSize() throws SocketException {</span>
<span class="line-modified">1088         if (isClosed())</span>
<span class="line-removed">1089             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1090         int result = 0;</span>
<span class="line-removed">1091         Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-removed">1092         if (o instanceof Integer) {</span>
<span class="line-removed">1093             result = ((Integer)o).intValue();</span>
<span class="line-removed">1094         }</span>
<span class="line-removed">1095         return result;</span>
1096     }
1097 
1098     /**
1099      * Sets the SO_RCVBUF option to the specified value for this
1100      * {@code DatagramSocket}. The SO_RCVBUF option is used by
1101      * the network implementation as a hint to size the underlying
1102      * network I/O buffers. The SO_RCVBUF setting may also be used
1103      * by the network implementation to determine the maximum size
1104      * of the packet that can be received on this socket.
1105      * &lt;p&gt;
1106      * Because SO_RCVBUF is a hint, applications that want to
1107      * verify what size the buffers were set to should call
1108      * {@link #getReceiveBufferSize()}.
1109      * &lt;p&gt;
1110      * Increasing SO_RCVBUF may allow the network implementation
1111      * to buffer multiple packets when packets arrive faster than
1112      * are being received using {@link #receive(DatagramPacket)}.
1113      * &lt;p&gt;
1114      * Note: It is implementation specific if a packet larger
1115      * than SO_RCVBUF can be received.
1116      *
1117      * @param size the size to which to set the receive buffer
1118      * size. This value must be greater than 0.
1119      *
1120      * @throws    SocketException if there is an error in
1121      * the underlying protocol, such as an UDP error.
1122      * @throws    IllegalArgumentException if the value is 0 or is
1123      * negative.
1124      * @see #getReceiveBufferSize()
1125      * @since 1.2
1126      */
<span class="line-modified">1127     public synchronized void setReceiveBufferSize(int size) throws SocketException {</span>
<span class="line-modified">1128         if (size &lt;= 0) {</span>
<span class="line-removed">1129             throw new IllegalArgumentException(&quot;invalid receive size&quot;);</span>
<span class="line-removed">1130         }</span>
<span class="line-removed">1131         if (isClosed())</span>
<span class="line-removed">1132             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1133         getImpl().setOption(SocketOptions.SO_RCVBUF, size);</span>
1134     }
1135 
1136     /**
1137      * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
1138      * buffer size used by the platform for input on this {@code DatagramSocket}.
1139      *
1140      * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
1141      * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.
1142      * @see #setReceiveBufferSize(int)
1143      * @since 1.2
1144      */
<span class="line-modified">1145     public synchronized int getReceiveBufferSize() throws SocketException {</span>
<span class="line-modified">1146         if (isClosed())</span>
<span class="line-removed">1147             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1148         int result = 0;</span>
<span class="line-removed">1149         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-removed">1150         if (o instanceof Integer) {</span>
<span class="line-removed">1151             result = ((Integer)o).intValue();</span>
<span class="line-removed">1152         }</span>
<span class="line-removed">1153         return result;</span>
1154     }
1155 
1156     /**
1157      * Enable/disable the SO_REUSEADDR socket option.
1158      * &lt;p&gt;
1159      * For UDP sockets it may be necessary to bind more than one
1160      * socket to the same socket address. This is typically for the
1161      * purpose of receiving multicast packets
1162      * (See {@link java.net.MulticastSocket}). The
1163      * {@code SO_REUSEADDR} socket option allows multiple
1164      * sockets to be bound to the same socket address if the
1165      * {@code SO_REUSEADDR} socket option is enabled prior
1166      * to binding the socket using {@link #bind(SocketAddress)}.
1167      * &lt;p&gt;
1168      * Note: This functionality is not supported by all existing platforms,
1169      * so it is implementation specific whether this option will be ignored
1170      * or not. However, if it is not supported then
1171      * {@link #getReuseAddress()} will always return {@code false}.
1172      * &lt;p&gt;
1173      * When a {@code DatagramSocket} is created the initial setting
1174      * of {@code SO_REUSEADDR} is disabled.
1175      * &lt;p&gt;
1176      * The behaviour when {@code SO_REUSEADDR} is enabled or
1177      * disabled after a socket is bound (See {@link #isBound()})
1178      * is not defined.
1179      *
1180      * @param on  whether to enable or disable the
1181      * @throws    SocketException if an error occurs enabling or
1182      *            disabling the {@code SO_REUSEADDR} socket option,
1183      *            or the socket is closed.
1184      * @since 1.4
1185      * @see #getReuseAddress()
1186      * @see #bind(SocketAddress)
1187      * @see #isBound()
1188      * @see #isClosed()
1189      */
<span class="line-modified">1190     public synchronized void setReuseAddress(boolean on) throws SocketException {</span>
<span class="line-modified">1191         if (isClosed())</span>
<span class="line-removed">1192             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1193         // Integer instead of Boolean for compatibility with older DatagramSocketImpl</span>
<span class="line-removed">1194         if (oldImpl)</span>
<span class="line-removed">1195             getImpl().setOption(SocketOptions.SO_REUSEADDR, on?-1:0);</span>
<span class="line-removed">1196         else</span>
<span class="line-removed">1197             getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));</span>
1198     }
1199 
1200     /**
1201      * Tests if SO_REUSEADDR is enabled.
1202      *
1203      * @return a {@code boolean} indicating whether or not SO_REUSEADDR is enabled.
1204      * @throws    SocketException if there is an error
1205      * in the underlying protocol, such as an UDP error.
1206      * @since   1.4
1207      * @see #setReuseAddress(boolean)
1208      */
<span class="line-modified">1209     public synchronized boolean getReuseAddress() throws SocketException {</span>
<span class="line-modified">1210         if (isClosed())</span>
<span class="line-removed">1211             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1212         Object o = getImpl().getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-removed">1213         return ((Boolean)o).booleanValue();</span>
1214     }
1215 
1216     /**
1217      * Enable/disable SO_BROADCAST.
1218      *
1219      * &lt;p&gt; Some operating systems may require that the Java virtual machine be
1220      * started with implementation specific privileges to enable this option or
1221      * send broadcast datagrams.
1222      *
1223      * @param  on
1224      *         whether or not to have broadcast turned on.
1225      *
1226      * @throws  SocketException
1227      *          if there is an error in the underlying protocol, such as an UDP
1228      *          error.
1229      *
1230      * @since 1.4
1231      * @see #getBroadcast()
1232      */
<span class="line-modified">1233     public synchronized void setBroadcast(boolean on) throws SocketException {</span>
<span class="line-modified">1234         if (isClosed())</span>
<span class="line-removed">1235             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1236         getImpl().setOption(SocketOptions.SO_BROADCAST, Boolean.valueOf(on));</span>
1237     }
1238 
1239     /**
1240      * Tests if SO_BROADCAST is enabled.
1241      * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
1242      * @throws    SocketException if there is an error
1243      * in the underlying protocol, such as an UDP error.
1244      * @since 1.4
1245      * @see #setBroadcast(boolean)
1246      */
<span class="line-modified">1247     public synchronized boolean getBroadcast() throws SocketException {</span>
<span class="line-modified">1248         if (isClosed())</span>
<span class="line-removed">1249             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1250         return ((Boolean)(getImpl().getOption(SocketOptions.SO_BROADCAST))).booleanValue();</span>
1251     }
1252 
1253     /**
1254      * Sets traffic class or type-of-service octet in the IP
1255      * datagram header for datagrams sent from this DatagramSocket.
1256      * As the underlying network implementation may ignore this
1257      * value applications should consider it a hint.
1258      *
1259      * &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range {@code 0 &lt;= tc &lt;=
1260      * 255} or an IllegalArgumentException will be thrown.
1261      * &lt;p&gt;Notes:
1262      * &lt;p&gt;For Internet Protocol v4 the value consists of an
1263      * {@code integer}, the least significant 8 bits of which
1264      * represent the value of the TOS octet in IP packets sent by
1265      * the socket.
1266      * RFC 1349 defines the TOS values as follows:
1267      *
1268      * &lt;UL&gt;
1269      * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWCOST (0x02)&lt;/CODE&gt;&lt;/LI&gt;
1270      * &lt;LI&gt;&lt;CODE&gt;IPTOS_RELIABILITY (0x04)&lt;/CODE&gt;&lt;/LI&gt;
1271      * &lt;LI&gt;&lt;CODE&gt;IPTOS_THROUGHPUT (0x08)&lt;/CODE&gt;&lt;/LI&gt;
1272      * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWDELAY (0x10)&lt;/CODE&gt;&lt;/LI&gt;
1273      * &lt;/UL&gt;
1274      * The last low order bit is always ignored as this
1275      * corresponds to the MBZ (must be zero) bit.
1276      * &lt;p&gt;
1277      * Setting bits in the precedence field may result in a
1278      * SocketException indicating that the operation is not
1279      * permitted.
1280      * &lt;p&gt;
1281      * for Internet Protocol v6 {@code tc} is the value that
1282      * would be placed into the sin6_flowinfo field of the IP header.
1283      *
1284      * @param tc        an {@code int} value for the bitset.
1285      * @throws SocketException if there is an error setting the
1286      * traffic class or type-of-service
1287      * @since 1.4
1288      * @see #getTrafficClass
1289      */
<span class="line-modified">1290     public synchronized void setTrafficClass(int tc) throws SocketException {</span>
<span class="line-modified">1291         if (tc &lt; 0 || tc &gt; 255)</span>
<span class="line-removed">1292             throw new IllegalArgumentException(&quot;tc is not in range 0 -- 255&quot;);</span>
<span class="line-removed">1293 </span>
<span class="line-removed">1294         if (isClosed())</span>
<span class="line-removed">1295             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1296         try {</span>
<span class="line-removed">1297             getImpl().setOption(SocketOptions.IP_TOS, tc);</span>
<span class="line-removed">1298         } catch (SocketException se) {</span>
<span class="line-removed">1299             // not supported if socket already connected</span>
<span class="line-removed">1300             // Solaris returns error in such cases</span>
<span class="line-removed">1301             if(!isConnected())</span>
<span class="line-removed">1302                 throw se;</span>
<span class="line-removed">1303         }</span>
1304     }
1305 
1306     /**
1307      * Gets traffic class or type-of-service in the IP datagram
1308      * header for packets sent from this DatagramSocket.
1309      * &lt;p&gt;
1310      * As the underlying network implementation may ignore the
1311      * traffic class or type-of-service set using {@link #setTrafficClass(int)}
1312      * this method may return a different value than was previously
1313      * set using the {@link #setTrafficClass(int)} method on this
1314      * DatagramSocket.
1315      *
1316      * @return the traffic class or type-of-service already set
1317      * @throws SocketException if there is an error obtaining the
1318      * traffic class or type-of-service value.
1319      * @since 1.4
1320      * @see #setTrafficClass(int)
1321      */
<span class="line-modified">1322     public synchronized int getTrafficClass() throws SocketException {</span>
<span class="line-modified">1323         if (isClosed())</span>
<span class="line-removed">1324             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1325         return ((Integer)(getImpl().getOption(SocketOptions.IP_TOS))).intValue();</span>
1326     }
1327 
1328     /**
1329      * Closes this datagram socket.
1330      * &lt;p&gt;
1331      * Any thread currently blocked in {@link #receive} upon this socket
1332      * will throw a {@link SocketException}.
1333      *
1334      * &lt;p&gt; If this socket has an associated channel then the channel is closed
1335      * as well.
1336      *
1337      * @revised 1.4
1338      * @spec JSR-51
1339      */
1340     public void close() {
<span class="line-modified">1341         synchronized(closeLock) {</span>
<span class="line-removed">1342             if (isClosed())</span>
<span class="line-removed">1343                 return;</span>
<span class="line-removed">1344             impl.close();</span>
<span class="line-removed">1345             closed = true;</span>
<span class="line-removed">1346         }</span>
1347     }
1348 
1349     /**
1350      * Returns whether the socket is closed or not.
1351      *
1352      * @return true if the socket has been closed
1353      * @since 1.4
1354      */
1355     public boolean isClosed() {
<span class="line-modified">1356         synchronized(closeLock) {</span>
<span class="line-removed">1357             return closed;</span>
<span class="line-removed">1358         }</span>
1359     }
1360 
1361     /**
1362      * Returns the unique {@link java.nio.channels.DatagramChannel} object
1363      * associated with this datagram socket, if any.
1364      *
1365      * &lt;p&gt; A datagram socket will have a channel if, and only if, the channel
1366      * itself was created via the {@link java.nio.channels.DatagramChannel#open
1367      * DatagramChannel.open} method.
1368      *
1369      * @return  the datagram channel associated with this datagram socket,
1370      *          or {@code null} if this socket was not created for a channel
1371      *
1372      * @since 1.4
1373      * @spec JSR-51
1374      */
1375     public DatagramChannel getChannel() {
1376         return null;
1377     }
1378 
</pre>
<hr />
<pre>
1392      * Passing {@code null} to the method is a no-op unless the factory
1393      * was already set.
1394      *
1395      * &lt;p&gt;If there is a security manager, this method first calls
1396      * the security manager&#39;s {@code checkSetFactory} method
1397      * to ensure the operation is allowed.
1398      * This could result in a SecurityException.
1399      *
1400      * @param      fac   the desired factory.
1401      * @throws     IOException  if an I/O error occurs when setting the
1402      *              datagram socket factory.
1403      * @throws     SocketException  if the factory is already defined.
1404      * @throws     SecurityException  if a security manager exists and its
1405      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
1406      * @see       java.net.DatagramSocketImplFactory#createDatagramSocketImpl()
1407      * @see       SecurityManager#checkSetFactory
1408      * @since 1.3
1409      */
1410     public static synchronized void
1411     setDatagramSocketImplFactory(DatagramSocketImplFactory fac)
<span class="line-modified">1412        throws IOException</span>
1413     {
1414         if (factory != null) {
1415             throw new SocketException(&quot;factory already defined&quot;);
1416         }
1417         SecurityManager security = System.getSecurityManager();
1418         if (security != null) {
1419             security.checkSetFactory();
1420         }
1421         factory = fac;
1422     }
1423 
1424     /**
1425      * Sets the value of a socket option.
1426      *
1427      * @param &lt;T&gt; The type of the socket option value
1428      * @param name The socket option
1429      * @param value The value of the socket option. A value of {@code null}
1430      *              may be valid for some options.
1431      *
1432      * @return this DatagramSocket
</pre>
<hr />
<pre>
1435      *         does not support the option.
1436      *
1437      * @throws IllegalArgumentException if the value is not valid for
1438      *         the option.
1439      *
1440      * @throws IOException if an I/O error occurs, or if the socket is closed.
1441      *
1442      * @throws SecurityException if a security manager is set and if the socket
1443      *         option requires a security permission and if the caller does
1444      *         not have the required permission.
1445      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1446      *         do not require any security permission.
1447      *
1448      * @throws NullPointerException if name is {@code null}
1449      *
1450      * @since 9
1451      */
1452     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value)
1453         throws IOException
1454     {
<span class="line-modified">1455         Objects.requireNonNull(name);</span>
<span class="line-removed">1456         if (isClosed())</span>
<span class="line-removed">1457             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1458         getImpl().setOption(name, value);</span>
1459         return this;
1460     }
1461 
1462     /**
1463      * Returns the value of a socket option.
1464      *
1465      * @param &lt;T&gt; The type of the socket option value
1466      * @param name The socket option
1467      *
1468      * @return The value of the socket option.
1469      *
1470      * @throws UnsupportedOperationException if the datagram socket
1471      *         does not support the option.
1472      *
1473      * @throws IOException if an I/O error occurs, or if the socket is closed.
1474      *
1475      * @throws NullPointerException if name is {@code null}
1476      *
1477      * @throws SecurityException if a security manager is set and if the socket
1478      *         option requires a security permission and if the caller does
1479      *         not have the required permission.
1480      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1481      *         do not require any security permission.
1482      *
1483      * @since 9
1484      */
1485     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-modified">1486         Objects.requireNonNull(name);</span>
<span class="line-removed">1487         if (isClosed())</span>
<span class="line-removed">1488             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-removed">1489         return getImpl().getOption(name);</span>
1490     }
1491 
<span class="line-removed">1492     private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;</span>
<span class="line-removed">1493     private final Object optionsLock = new Object();</span>
<span class="line-removed">1494 </span>
1495     /**
1496      * Returns a set of the socket options supported by this socket.
1497      *
1498      * This method will continue to return the set of options even after
1499      * the socket has been closed.
1500      *
1501      * @return A set of the socket options supported by this socket. This set
1502      *        may be empty if the socket&#39;s DatagramSocketImpl cannot be created.
1503      *
1504      * @since 9
1505      */
1506     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="line-modified">1507         Set&lt;SocketOption&lt;?&gt;&gt; options = this.options;</span>
<span class="line-modified">1508         if (options != null)</span>
<span class="line-removed">1509             return options;</span>
1510 
<span class="line-modified">1511         synchronized (optionsLock) {</span>
<span class="line-modified">1512             options = this.options;</span>
<span class="line-modified">1513             if (options != null)</span>
<span class="line-removed">1514                 return options;</span>
1515 






















































































1516             try {
<span class="line-modified">1517                 DatagramSocketImpl impl = getImpl();</span>
<span class="line-modified">1518                 options = Collections.unmodifiableSet(impl.supportedOptions());</span>
<span class="line-modified">1519             } catch (IOException e) {</span>
<span class="line-modified">1520                 options = Collections.emptySet();</span>








1521             }
<span class="line-removed">1522             return this.options = options;</span>
1523         }



1524     }

1525 }
</pre>
</td>
<td>
<hr />
<pre>
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.IOException;
  29 import java.io.UncheckedIOException;
  30 import java.nio.channels.DatagramChannel;
  31 import java.security.AccessController;
<span class="line-modified">  32 import java.security.PrivilegedAction;</span>

  33 import java.util.Set;
<span class="line-modified">  34 import sun.net.NetProperties;</span>
<span class="line-added">  35 import sun.nio.ch.DefaultSelectorProvider;</span>
  36 
  37 /**
  38  * This class represents a socket for sending and receiving datagram packets.
  39  *
  40  * &lt;p&gt;A datagram socket is the sending or receiving point for a packet
  41  * delivery service. Each packet sent or received on a datagram socket
  42  * is individually addressed and routed. Multiple packets sent from
  43  * one machine to another may be routed differently, and may arrive in
  44  * any order.
  45  *
  46  * &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the
  47  * {@link StandardSocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as
  48  * to allow the transmission of broadcast datagrams. In order to receive
  49  * broadcast packets a DatagramSocket should be bound to the wildcard address.
  50  * In some implementations, broadcast packets may also be received when
  51  * a DatagramSocket is bound to a more specific address.
  52  * &lt;p&gt;
  53  * Example:
  54  * &lt;pre&gt;{@code
  55  *              DatagramSocket s = new DatagramSocket(null);
</pre>
<hr />
<pre>
  96  *     &lt;td&gt; Allow transmission of broadcast datagrams &lt;/td&gt;
  97  *   &lt;/tr&gt;
  98  *   &lt;tr&gt;
  99  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_TOS IP_TOS} &lt;/th&gt;
 100  *     &lt;td&gt; The Type of Service (ToS) octet in the Internet Protocol (IP) header &lt;/td&gt;
 101  *   &lt;/tr&gt;
 102  * &lt;/tbody&gt;
 103  * &lt;/table&gt;
 104  * &lt;/blockquote&gt;
 105  * An implementation may also support additional options. In particular an implementation
 106  * may support &lt;a href=&quot;MulticastSocket.html#MulticastOptions&quot;&gt;multicast options&lt;/a&gt; which
 107  * can be useful when using a plain {@code DatagramSocket} to send datagrams to a
 108  * multicast group.
 109  *
 110  * @author  Pavani Diwanji
 111  * @see     java.net.DatagramPacket
 112  * @see     java.nio.channels.DatagramChannel
 113  * @since 1.0
 114  */
 115 public class DatagramSocket implements java.io.Closeable {







 116 
<span class="line-modified"> 117     // An instance of DatagramSocketAdaptor, NetMulticastSocket, or null</span>
<span class="line-modified"> 118     private final DatagramSocket delegate;</span>


 119 
<span class="line-modified"> 120     DatagramSocket delegate() {</span>
<span class="line-modified"> 121         if (delegate == null) {</span>
<span class="line-modified"> 122             throw new InternalError(&quot;Should not get here&quot;);</span>
<span class="line-modified"> 123         }</span>
<span class="line-modified"> 124         return delegate;</span>
<span class="line-modified"> 125     }</span>



























 126 
 127     /**
<span class="line-modified"> 128      * All constructors eventually call this one.</span>
<span class="line-modified"> 129      * @param delegate The wrapped DatagramSocket implementation, or null.</span>




 130      */
<span class="line-modified"> 131     DatagramSocket(DatagramSocket delegate) {</span>
<span class="line-modified"> 132         assert delegate == null</span>
<span class="line-modified"> 133                 || delegate instanceof NetMulticastSocket</span>
<span class="line-modified"> 134                 || delegate instanceof sun.nio.ch.DatagramSocketAdaptor;</span>
<span class="line-modified"> 135         this.delegate = delegate;</span>

















































 136     }
 137 

 138     /**
 139      * Constructs a datagram socket and binds it to any available port
 140      * on the local host machine.  The socket will be bound to the
 141      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 142      * an IP address chosen by the kernel.
 143      *
 144      * &lt;p&gt;If there is a security manager,
 145      * its {@code checkListen} method is first called
 146      * with 0 as its argument to ensure the operation is allowed.
 147      * This could result in a SecurityException.
 148      *
 149      * @throws     SocketException  if the socket could not be opened,
 150      *               or the socket could not bind to the specified local port.
 151      * @throws     SecurityException  if a security manager exists and its
 152      *             {@code checkListen} method doesn&#39;t allow the operation.
 153      *
 154      * @see SecurityManager#checkListen
 155      */
 156     public DatagramSocket() throws SocketException {
 157         this(new InetSocketAddress(0));
 158     }
 159 
 160     /**
 161      * Creates an unbound datagram socket with the specified
 162      * DatagramSocketImpl.
 163      *
 164      * @param impl an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
 165      *        the subclass wishes to use on the DatagramSocket.
 166      * @since   1.4
 167      */
 168     protected DatagramSocket(DatagramSocketImpl impl) {
<span class="line-modified"> 169         this(new NetMulticastSocket(impl));</span>



 170     }
 171 
 172     /**
 173      * Creates a datagram socket, bound to the specified local
 174      * socket address.
 175      * &lt;p&gt;
 176      * If, if the address is {@code null}, creates an unbound socket.
 177      *
 178      * &lt;p&gt;If there is a security manager,
 179      * its {@code checkListen} method is first called
 180      * with the port from the socket address
 181      * as its argument to ensure the operation is allowed.
 182      * This could result in a SecurityException.
 183      *
 184      * @param bindaddr local socket address to bind, or {@code null}
 185      *                 for an unbound socket.
 186      *
 187      * @throws     SocketException  if the socket could not be opened,
 188      *               or the socket could not bind to the specified local port.
 189      * @throws     SecurityException  if a security manager exists and its
 190      *             {@code checkListen} method doesn&#39;t allow the operation.
 191      *
 192      * @see SecurityManager#checkListen
 193      * @since   1.4
 194      */
 195     public DatagramSocket(SocketAddress bindaddr) throws SocketException {
<span class="line-modified"> 196         this(createDelegate(bindaddr, DatagramSocket.class));</span>





















 197     }
 198 
 199     /**
 200      * Constructs a datagram socket and binds it to the specified port
 201      * on the local host machine.  The socket will be bound to the
 202      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 203      * an IP address chosen by the kernel.
 204      *
 205      * &lt;p&gt;If there is a security manager,
 206      * its {@code checkListen} method is first called
 207      * with the {@code port} argument
 208      * as its argument to ensure the operation is allowed.
 209      * This could result in a SecurityException.
 210      *
 211      * @param      port port to use.
 212      * @throws     SocketException  if the socket could not be opened,
 213      *               or the socket could not bind to the specified local port.
 214      * @throws     SecurityException  if a security manager exists and its
 215      *             {@code checkListen} method doesn&#39;t allow the operation.
 216      *
</pre>
<hr />
<pre>
 231      * its {@code checkListen} method is first called
 232      * with the {@code port} argument
 233      * as its argument to ensure the operation is allowed.
 234      * This could result in a SecurityException.
 235      *
 236      * @param port local port to use
 237      * @param laddr local address to bind
 238      *
 239      * @throws     SocketException  if the socket could not be opened,
 240      *               or the socket could not bind to the specified local port.
 241      * @throws     SecurityException  if a security manager exists and its
 242      *             {@code checkListen} method doesn&#39;t allow the operation.
 243      *
 244      * @see SecurityManager#checkListen
 245      * @since   1.1
 246      */
 247     public DatagramSocket(int port, InetAddress laddr) throws SocketException {
 248         this(new InetSocketAddress(laddr, port));
 249     }
 250 





























































 251     /**
 252      * Binds this DatagramSocket to a specific address and port.
 253      * &lt;p&gt;
 254      * If the address is {@code null}, then the system will pick up
 255      * an ephemeral port and a valid local address to bind the socket.
 256      *
 257      * @param   addr The address and port to bind to.
 258      * @throws  SocketException if any error happens during the bind, or if the
 259      *          socket is already bound.
 260      * @throws  SecurityException  if a security manager exists and its
 261      *             {@code checkListen} method doesn&#39;t allow the operation.
 262      * @throws IllegalArgumentException if addr is a SocketAddress subclass
 263      *         not supported by this socket.
 264      * @since 1.4
 265      */
<span class="line-modified"> 266     public void bind(SocketAddress addr) throws SocketException {</span>
<span class="line-modified"> 267         delegate().bind(addr);</span>

































 268     }
 269 
 270     /**
 271      * Connects the socket to a remote address for this socket. When a
 272      * socket is connected to a remote address, packets may only be
 273      * sent to or received from that address. By default a datagram
 274      * socket is not connected. If the socket is already closed,
 275      * then this method has no effect.
 276      *
 277      * &lt;p&gt; If this socket is not bound then this method will first cause the
 278      * socket to be bound to an address that is assigned automatically,
 279      * as if invoking the {@link #bind bind} method with a parameter of
 280      * {@code null}. If the remote destination to which the socket is connected
 281      * does not exist, or is otherwise unreachable, and if an ICMP destination
 282      * unreachable packet has been received for that address, then a subsequent
 283      * call to send or receive may throw a PortUnreachableException. Note,
 284      * there is no guarantee that the exception will be thrown.
 285      *
 286      * &lt;p&gt; If a security manager has been installed then it is invoked to check
 287      * access to the remote address. Specifically, if the given {@code address}
</pre>
<hr />
<pre>
 309      * @param address the remote address for the socket
 310      *
 311      * @param port the remote port for the socket.
 312      *
 313      * @throws IllegalArgumentException
 314      *         if the address is null, or the port is out of range.
 315      *
 316      * @throws SecurityException
 317      *         if a security manager has been installed and it does
 318      *         not permit access to the given remote address
 319      *
 320      * @throws UncheckedIOException
 321      *         may be thrown if connect fails, for example, if the
 322      *         destination address is non-routable
 323      *
 324      * @see #disconnect
 325      *
 326      * @since 1.2
 327      */
 328     public void connect(InetAddress address, int port) {
<span class="line-modified"> 329         delegate().connect(address, port);</span>




 330     }
 331 
 332     /**
 333      * Connects this socket to a remote socket address (IP address + port number).
 334      *
 335      * &lt;p&gt; If given an {@link InetSocketAddress InetSocketAddress}, this method
 336      * behaves as if invoking {@link #connect(InetAddress,int) connect(InetAddress,int)}
 337      * with the given socket addresses IP address and port number, except that the
 338      * {@code SocketException} that may be raised is not wrapped in an
 339      * {@code UncheckedIOException}.
 340      *
 341      * @param   addr    The remote address.
 342      *
 343      * @throws  SocketException
 344      *          if the connect fails
 345      *
 346      * @throws IllegalArgumentException
 347      *         if {@code addr} is {@code null}, or {@code addr} is a SocketAddress
 348      *         subclass not supported by this socket
 349      *
 350      * @throws SecurityException
 351      *         if a security manager has been installed and it does
 352      *         not permit access to the given remote address
 353      *
 354      * @since 1.4
 355      */
 356     public void connect(SocketAddress addr) throws SocketException {
<span class="line-modified"> 357         delegate().connect(addr);</span>







 358     }
 359 
 360     /**
 361      * Disconnects the socket. If the socket is closed or not connected,
 362      * then this method has no effect.
 363      *
 364      * @apiNote If this method throws an UncheckedIOException, the socket
 365      *          may be left in an unspecified state. It is strongly
 366      *          recommended that the socket be closed when disconnect
 367      *          fails.
 368      *
 369      * @throws  UncheckedIOException
 370      *          may be thrown if disconnect fails to dissolve the
 371      *          association and restore the socket to a consistent state.
 372      *
 373      * @see #connect
 374      *
 375      * @since 1.2
 376      */
 377     public void disconnect() {
<span class="line-modified"> 378         delegate().disconnect();</span>










 379     }
 380 
 381     /**
 382      * Returns the binding state of the socket.
 383      * &lt;p&gt;
 384      * If the socket was bound prior to being {@link #close closed},
 385      * then this method will continue to return {@code true}
 386      * after the socket is closed.
 387      *
 388      * @return true if the socket successfully bound to an address
 389      * @since 1.4
 390      */
 391     public boolean isBound() {
<span class="line-modified"> 392         return delegate().isBound();</span>
 393     }
 394 
 395     /**
 396      * Returns the connection state of the socket.
 397      * &lt;p&gt;
 398      * If the socket was connected prior to being {@link #close closed},
 399      * then this method will continue to return {@code true}
 400      * after the socket is closed.
 401      *
 402      * @return true if the socket successfully connected to a server
 403      * @since 1.4
 404      */
 405     public boolean isConnected() {
<span class="line-modified"> 406         return delegate().isConnected();</span>
 407     }
 408 
 409     /**
 410      * Returns the address to which this socket is connected. Returns
 411      * {@code null} if the socket is not connected.
 412      * &lt;p&gt;
 413      * If the socket was connected prior to being {@link #close closed},
 414      * then this method will continue to return the connected address
 415      * after the socket is closed.
 416      *
 417      * @return the address to which this socket is connected.
 418      * @since 1.2
 419      */
 420     public InetAddress getInetAddress() {
<span class="line-modified"> 421         return delegate().getInetAddress();</span>
 422     }
 423 
 424     /**
 425      * Returns the port number to which this socket is connected.
 426      * Returns {@code -1} if the socket is not connected.
 427      * &lt;p&gt;
 428      * If the socket was connected prior to being {@link #close closed},
 429      * then this method will continue to return the connected port number
 430      * after the socket is closed.
 431      *
 432      * @return the port number to which this socket is connected.
 433      * @since 1.2
 434      */
 435     public int getPort() {
<span class="line-modified"> 436         return delegate().getPort();</span>
 437     }
 438 
 439     /**
 440      * Returns the address of the endpoint this socket is connected to, or
 441      * {@code null} if it is unconnected.
 442      * &lt;p&gt;
 443      * If the socket was connected prior to being {@link #close closed},
 444      * then this method will continue to return the connected address
 445      * after the socket is closed.
 446      *
 447      * @return a {@code SocketAddress} representing the remote
 448      *         endpoint of this socket, or {@code null} if it is
 449      *         not connected yet.
 450      * @see #getInetAddress()
 451      * @see #getPort()
 452      * @see #connect(SocketAddress)
 453      * @since 1.4
 454      */
 455     public SocketAddress getRemoteSocketAddress() {
<span class="line-modified"> 456         return delegate().getRemoteSocketAddress();</span>


 457     }
 458 
 459     /**
 460      * Returns the address of the endpoint this socket is bound to.
 461      *
 462      * @return a {@code SocketAddress} representing the local endpoint of this
 463      *         socket, or {@code null} if it is closed or not bound yet.
 464      * @see #getLocalAddress()
 465      * @see #getLocalPort()
 466      * @see #bind(SocketAddress)
 467      * @since 1.4
 468      */
 469     public SocketAddress getLocalSocketAddress() {
<span class="line-modified"> 470         return delegate().getLocalSocketAddress();</span>




 471     }
 472 
 473     /**
 474      * Sends a datagram packet from this socket. The
 475      * {@code DatagramPacket} includes information indicating the
 476      * data to be sent, its length, the IP address of the remote host,
 477      * and the port number on the remote host.
 478      *
 479      * &lt;p&gt;If there is a security manager, and the socket is not currently
 480      * connected to a remote address, this method first performs some
 481      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
 482      * is true, this method calls the
 483      * security manager&#39;s {@code checkMulticast} method
 484      * with {@code p.getAddress()} as its argument.
 485      * If the evaluation of that expression is false,
 486      * this method instead calls the security manager&#39;s
 487      * {@code checkConnect} method with arguments
 488      * {@code p.getAddress().getHostAddress()} and
 489      * {@code p.getPort()}. Each call to a security manager method
 490      * could result in a SecurityException if the operation is not allowed.
</pre>
<hr />
<pre>
 496      *             {@code checkMulticast} or {@code checkConnect}
 497      *             method doesn&#39;t allow the send.
 498      * @throws     PortUnreachableException may be thrown if the socket is connected
 499      *             to a currently unreachable destination. Note, there is no
 500      *             guarantee that the exception will be thrown.
 501      * @throws     java.nio.channels.IllegalBlockingModeException
 502      *             if this socket has an associated channel,
 503      *             and the channel is in non-blocking mode.
 504      * @throws     IllegalArgumentException if the socket is connected,
 505      *             and connected address and packet address differ, or
 506      *             if the socket is not connected and the packet address
 507      *             is not set or if its port is out of range.
 508      *
 509      * @see        java.net.DatagramPacket
 510      * @see        SecurityManager#checkMulticast(InetAddress)
 511      * @see        SecurityManager#checkConnect
 512      * @revised 1.4
 513      * @spec JSR-51
 514      */
 515     public void send(DatagramPacket p) throws IOException  {
<span class="line-modified"> 516         delegate().send(p);</span>















































 517     }
 518 
 519     /**
 520      * Receives a datagram packet from this socket. When this method
 521      * returns, the {@code DatagramPacket}&#39;s buffer is filled with
 522      * the data received. The datagram packet also contains the sender&#39;s
 523      * IP address, and the port number on the sender&#39;s machine.
 524      * &lt;p&gt;
 525      * This method blocks until a datagram is received. The
 526      * {@code length} field of the datagram packet object contains
 527      * the length of the received message. If the message is longer than
 528      * the packet&#39;s length, the message is truncated.
 529      * &lt;p&gt;
 530      * If there is a security manager, and the socket is not currently
 531      * connected to a remote address, a packet cannot be received if the
 532      * security manager&#39;s {@code checkAccept} method does not allow it.
 533      * Datagrams that are not permitted by the security manager are silently
 534      * discarded.
 535      *
 536      * @param      p   the {@code DatagramPacket} into which to place
 537      *                 the incoming data.
 538      * @throws     IOException  if an I/O error occurs.
 539      * @throws     SocketTimeoutException  if setSoTimeout was previously called
 540      *                 and the timeout has expired.
 541      * @throws     PortUnreachableException may be thrown if the socket is connected
 542      *             to a currently unreachable destination. Note, there is no guarantee that the
 543      *             exception will be thrown.
 544      * @throws     java.nio.channels.IllegalBlockingModeException
 545      *             if this socket has an associated channel,
 546      *             and the channel is in non-blocking mode.
 547      * @see        java.net.DatagramPacket
 548      * @see        java.net.DatagramSocket
 549      * @revised 1.4
 550      * @spec JSR-51
 551      */
<span class="line-modified"> 552     public void receive(DatagramPacket p) throws IOException {</span>
<span class="line-modified"> 553         delegate().receive(p);</span>

































































































 554     }
 555 
 556     /**
 557      * Gets the local address to which the socket is bound.
 558      *
 559      * &lt;p&gt;If there is a security manager, its
 560      * {@code checkConnect} method is first called
 561      * with the host address and {@code -1}
 562      * as its arguments to see if the operation is allowed.
 563      *
 564      * @see SecurityManager#checkConnect
 565      * @return  the local address to which the socket is bound,
 566      *          {@code null} if the socket is closed, or
 567      *          an {@code InetAddress} representing
 568      *          {@link InetAddress#isAnyLocalAddress wildcard}
 569      *          address if either the socket is not bound, or
 570      *          the security manager {@code checkConnect}
 571      *          method does not allow the operation
 572      * @since   1.1
 573      */
 574     public InetAddress getLocalAddress() {
<span class="line-modified"> 575         return delegate().getLocalAddress();</span>















 576     }
 577 
 578     /**
 579      * Returns the port number on the local host to which this socket
 580      * is bound.
 581      *
 582      * @return  the port number on the local host to which this socket is bound,
 583      *          {@code -1} if the socket is closed, or
 584      *          {@code 0} if it is not bound yet.
 585      */
 586     public int getLocalPort() {
<span class="line-modified"> 587         return delegate().getLocalPort();</span>






 588     }
 589 
 590     /**
 591      * Enable/disable SO_TIMEOUT with the specified timeout, in
 592      * milliseconds. With this option set to a positive timeout value,
 593      * a call to receive() for this DatagramSocket
 594      * will block for only this amount of time.  If the timeout expires,
 595      * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
 596      * DatagramSocket is still valid. A timeout of zero is interpreted
 597      * as an infinite timeout.
 598      * The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking
 599      * operation to have effect.
 600      *
 601      * @param timeout the specified timeout in milliseconds.
 602      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
 603      * @throws IllegalArgumentException if {@code timeout} is negative
 604      * @since   1.1
 605      * @see #getSoTimeout()
 606      */
<span class="line-modified"> 607     public void setSoTimeout(int timeout) throws SocketException {</span>
<span class="line-modified"> 608         delegate().setSoTimeout(timeout);</span>




 609     }
 610 
 611     /**
 612      * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
 613      * option is disabled (i.e., timeout of infinity).
 614      *
 615      * @return the setting for SO_TIMEOUT
 616      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
 617      * @since   1.1
 618      * @see #setSoTimeout(int)
 619      */
<span class="line-modified"> 620     public int getSoTimeout() throws SocketException {</span>
<span class="line-modified"> 621         return delegate().getSoTimeout();</span>










 622     }
 623 
 624     /**
 625      * Sets the SO_SNDBUF option to the specified value for this
 626      * {@code DatagramSocket}. The SO_SNDBUF option is used by the
 627      * network implementation as a hint to size the underlying
 628      * network I/O buffers. The SO_SNDBUF setting may also be used
 629      * by the network implementation to determine the maximum size
 630      * of the packet that can be sent on this socket.
 631      * &lt;p&gt;
 632      * As SO_SNDBUF is a hint, applications that want to verify
 633      * what size the buffer is should call {@link #getSendBufferSize()}.
 634      * &lt;p&gt;
 635      * Increasing the buffer size may allow multiple outgoing packets
 636      * to be queued by the network implementation when the send rate
 637      * is high.
 638      * &lt;p&gt;
 639      * Note: If {@link #send(DatagramPacket)} is used to send a
 640      * {@code DatagramPacket} that is larger than the setting
 641      * of SO_SNDBUF then it is implementation specific if the
 642      * packet is sent or discarded.
 643      *
 644      * @param size the size to which to set the send buffer
 645      * size. This value must be greater than 0.
 646      *
 647      * @throws    SocketException if there is an error
 648      * in the underlying protocol, such as an UDP error.
 649      * @throws    IllegalArgumentException if the value is 0 or is
 650      * negative.
 651      * @see #getSendBufferSize()
 652      * @since 1.2
 653      */
<span class="line-modified"> 654     public void setSendBufferSize(int size) throws SocketException {</span>
<span class="line-modified"> 655         delegate().setSendBufferSize(size);</span>





 656     }
 657 
 658     /**
 659      * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
 660      * buffer size used by the platform for output on this {@code DatagramSocket}.
 661      *
 662      * @return the value of the SO_SNDBUF option for this {@code DatagramSocket}
 663      * @throws    SocketException if there is an error in
 664      * the underlying protocol, such as an UDP error.
 665      * @see #setSendBufferSize
 666      * @since 1.2
 667      */
<span class="line-modified"> 668     public int getSendBufferSize() throws SocketException {</span>
<span class="line-modified"> 669         return delegate().getSendBufferSize();</span>







 670     }
 671 
 672     /**
 673      * Sets the SO_RCVBUF option to the specified value for this
 674      * {@code DatagramSocket}. The SO_RCVBUF option is used by
 675      * the network implementation as a hint to size the underlying
 676      * network I/O buffers. The SO_RCVBUF setting may also be used
 677      * by the network implementation to determine the maximum size
 678      * of the packet that can be received on this socket.
 679      * &lt;p&gt;
 680      * Because SO_RCVBUF is a hint, applications that want to
 681      * verify what size the buffers were set to should call
 682      * {@link #getReceiveBufferSize()}.
 683      * &lt;p&gt;
 684      * Increasing SO_RCVBUF may allow the network implementation
 685      * to buffer multiple packets when packets arrive faster than
 686      * are being received using {@link #receive(DatagramPacket)}.
 687      * &lt;p&gt;
 688      * Note: It is implementation specific if a packet larger
 689      * than SO_RCVBUF can be received.
 690      *
 691      * @param size the size to which to set the receive buffer
 692      * size. This value must be greater than 0.
 693      *
 694      * @throws    SocketException if there is an error in
 695      * the underlying protocol, such as an UDP error.
 696      * @throws    IllegalArgumentException if the value is 0 or is
 697      * negative.
 698      * @see #getReceiveBufferSize()
 699      * @since 1.2
 700      */
<span class="line-modified"> 701     public void setReceiveBufferSize(int size) throws SocketException {</span>
<span class="line-modified"> 702         delegate().setReceiveBufferSize(size);</span>





 703     }
 704 
 705     /**
 706      * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
 707      * buffer size used by the platform for input on this {@code DatagramSocket}.
 708      *
 709      * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
 710      * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.
 711      * @see #setReceiveBufferSize(int)
 712      * @since 1.2
 713      */
<span class="line-modified"> 714     public int getReceiveBufferSize() throws SocketException {</span>
<span class="line-modified"> 715         return delegate().getReceiveBufferSize();</span>







 716     }
 717 
 718     /**
 719      * Enable/disable the SO_REUSEADDR socket option.
 720      * &lt;p&gt;
 721      * For UDP sockets it may be necessary to bind more than one
 722      * socket to the same socket address. This is typically for the
 723      * purpose of receiving multicast packets
 724      * (See {@link java.net.MulticastSocket}). The
 725      * {@code SO_REUSEADDR} socket option allows multiple
 726      * sockets to be bound to the same socket address if the
 727      * {@code SO_REUSEADDR} socket option is enabled prior
 728      * to binding the socket using {@link #bind(SocketAddress)}.
 729      * &lt;p&gt;
 730      * Note: This functionality is not supported by all existing platforms,
 731      * so it is implementation specific whether this option will be ignored
 732      * or not. However, if it is not supported then
 733      * {@link #getReuseAddress()} will always return {@code false}.
 734      * &lt;p&gt;
 735      * When a {@code DatagramSocket} is created the initial setting
 736      * of {@code SO_REUSEADDR} is disabled.
 737      * &lt;p&gt;
 738      * The behaviour when {@code SO_REUSEADDR} is enabled or
 739      * disabled after a socket is bound (See {@link #isBound()})
 740      * is not defined.
 741      *
 742      * @param on  whether to enable or disable the
 743      * @throws    SocketException if an error occurs enabling or
 744      *            disabling the {@code SO_REUSEADDR} socket option,
 745      *            or the socket is closed.
 746      * @since 1.4
 747      * @see #getReuseAddress()
 748      * @see #bind(SocketAddress)
 749      * @see #isBound()
 750      * @see #isClosed()
 751      */
<span class="line-modified"> 752     public void setReuseAddress(boolean on) throws SocketException {</span>
<span class="line-modified"> 753         delegate().setReuseAddress(on);</span>






 754     }
 755 
 756     /**
 757      * Tests if SO_REUSEADDR is enabled.
 758      *
 759      * @return a {@code boolean} indicating whether or not SO_REUSEADDR is enabled.
 760      * @throws    SocketException if there is an error
 761      * in the underlying protocol, such as an UDP error.
 762      * @since   1.4
 763      * @see #setReuseAddress(boolean)
 764      */
<span class="line-modified"> 765     public boolean getReuseAddress() throws SocketException {</span>
<span class="line-modified"> 766         return delegate().getReuseAddress();</span>



 767     }
 768 
 769     /**
 770      * Enable/disable SO_BROADCAST.
 771      *
 772      * &lt;p&gt; Some operating systems may require that the Java virtual machine be
 773      * started with implementation specific privileges to enable this option or
 774      * send broadcast datagrams.
 775      *
 776      * @param  on
 777      *         whether or not to have broadcast turned on.
 778      *
 779      * @throws  SocketException
 780      *          if there is an error in the underlying protocol, such as an UDP
 781      *          error.
 782      *
 783      * @since 1.4
 784      * @see #getBroadcast()
 785      */
<span class="line-modified"> 786     public void setBroadcast(boolean on) throws SocketException {</span>
<span class="line-modified"> 787         delegate().setBroadcast(on);</span>


 788     }
 789 
 790     /**
 791      * Tests if SO_BROADCAST is enabled.
 792      * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
 793      * @throws    SocketException if there is an error
 794      * in the underlying protocol, such as an UDP error.
 795      * @since 1.4
 796      * @see #setBroadcast(boolean)
 797      */
<span class="line-modified"> 798     public boolean getBroadcast() throws SocketException {</span>
<span class="line-modified"> 799         return delegate().getBroadcast();</span>


 800     }
 801 
 802     /**
 803      * Sets traffic class or type-of-service octet in the IP
 804      * datagram header for datagrams sent from this DatagramSocket.
 805      * As the underlying network implementation may ignore this
 806      * value applications should consider it a hint.
 807      *
 808      * &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range {@code 0 &lt;= tc &lt;=
 809      * 255} or an IllegalArgumentException will be thrown.
 810      * &lt;p&gt;Notes:
 811      * &lt;p&gt;For Internet Protocol v4 the value consists of an
 812      * {@code integer}, the least significant 8 bits of which
 813      * represent the value of the TOS octet in IP packets sent by
 814      * the socket.
 815      * RFC 1349 defines the TOS values as follows:
 816      *
 817      * &lt;UL&gt;
 818      * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWCOST (0x02)&lt;/CODE&gt;&lt;/LI&gt;
 819      * &lt;LI&gt;&lt;CODE&gt;IPTOS_RELIABILITY (0x04)&lt;/CODE&gt;&lt;/LI&gt;
 820      * &lt;LI&gt;&lt;CODE&gt;IPTOS_THROUGHPUT (0x08)&lt;/CODE&gt;&lt;/LI&gt;
 821      * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWDELAY (0x10)&lt;/CODE&gt;&lt;/LI&gt;
 822      * &lt;/UL&gt;
 823      * The last low order bit is always ignored as this
 824      * corresponds to the MBZ (must be zero) bit.
 825      * &lt;p&gt;
 826      * Setting bits in the precedence field may result in a
 827      * SocketException indicating that the operation is not
 828      * permitted.
 829      * &lt;p&gt;
 830      * for Internet Protocol v6 {@code tc} is the value that
 831      * would be placed into the sin6_flowinfo field of the IP header.
 832      *
 833      * @param tc        an {@code int} value for the bitset.
 834      * @throws SocketException if there is an error setting the
 835      * traffic class or type-of-service
 836      * @since 1.4
 837      * @see #getTrafficClass
 838      */
<span class="line-modified"> 839     public void setTrafficClass(int tc) throws SocketException {</span>
<span class="line-modified"> 840         delegate().setTrafficClass(tc);</span>












 841     }
 842 
 843     /**
 844      * Gets traffic class or type-of-service in the IP datagram
 845      * header for packets sent from this DatagramSocket.
 846      * &lt;p&gt;
 847      * As the underlying network implementation may ignore the
 848      * traffic class or type-of-service set using {@link #setTrafficClass(int)}
 849      * this method may return a different value than was previously
 850      * set using the {@link #setTrafficClass(int)} method on this
 851      * DatagramSocket.
 852      *
 853      * @return the traffic class or type-of-service already set
 854      * @throws SocketException if there is an error obtaining the
 855      * traffic class or type-of-service value.
 856      * @since 1.4
 857      * @see #setTrafficClass(int)
 858      */
<span class="line-modified"> 859     public int getTrafficClass() throws SocketException {</span>
<span class="line-modified"> 860         return delegate().getTrafficClass();</span>


 861     }
 862 
 863     /**
 864      * Closes this datagram socket.
 865      * &lt;p&gt;
 866      * Any thread currently blocked in {@link #receive} upon this socket
 867      * will throw a {@link SocketException}.
 868      *
 869      * &lt;p&gt; If this socket has an associated channel then the channel is closed
 870      * as well.
 871      *
 872      * @revised 1.4
 873      * @spec JSR-51
 874      */
 875     public void close() {
<span class="line-modified"> 876         delegate().close();</span>





 877     }
 878 
 879     /**
 880      * Returns whether the socket is closed or not.
 881      *
 882      * @return true if the socket has been closed
 883      * @since 1.4
 884      */
 885     public boolean isClosed() {
<span class="line-modified"> 886         return delegate().isClosed();</span>


 887     }
 888 
 889     /**
 890      * Returns the unique {@link java.nio.channels.DatagramChannel} object
 891      * associated with this datagram socket, if any.
 892      *
 893      * &lt;p&gt; A datagram socket will have a channel if, and only if, the channel
 894      * itself was created via the {@link java.nio.channels.DatagramChannel#open
 895      * DatagramChannel.open} method.
 896      *
 897      * @return  the datagram channel associated with this datagram socket,
 898      *          or {@code null} if this socket was not created for a channel
 899      *
 900      * @since 1.4
 901      * @spec JSR-51
 902      */
 903     public DatagramChannel getChannel() {
 904         return null;
 905     }
 906 
</pre>
<hr />
<pre>
 920      * Passing {@code null} to the method is a no-op unless the factory
 921      * was already set.
 922      *
 923      * &lt;p&gt;If there is a security manager, this method first calls
 924      * the security manager&#39;s {@code checkSetFactory} method
 925      * to ensure the operation is allowed.
 926      * This could result in a SecurityException.
 927      *
 928      * @param      fac   the desired factory.
 929      * @throws     IOException  if an I/O error occurs when setting the
 930      *              datagram socket factory.
 931      * @throws     SocketException  if the factory is already defined.
 932      * @throws     SecurityException  if a security manager exists and its
 933      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
 934      * @see       java.net.DatagramSocketImplFactory#createDatagramSocketImpl()
 935      * @see       SecurityManager#checkSetFactory
 936      * @since 1.3
 937      */
 938     public static synchronized void
 939     setDatagramSocketImplFactory(DatagramSocketImplFactory fac)
<span class="line-modified"> 940             throws IOException</span>
 941     {
 942         if (factory != null) {
 943             throw new SocketException(&quot;factory already defined&quot;);
 944         }
 945         SecurityManager security = System.getSecurityManager();
 946         if (security != null) {
 947             security.checkSetFactory();
 948         }
 949         factory = fac;
 950     }
 951 
 952     /**
 953      * Sets the value of a socket option.
 954      *
 955      * @param &lt;T&gt; The type of the socket option value
 956      * @param name The socket option
 957      * @param value The value of the socket option. A value of {@code null}
 958      *              may be valid for some options.
 959      *
 960      * @return this DatagramSocket
</pre>
<hr />
<pre>
 963      *         does not support the option.
 964      *
 965      * @throws IllegalArgumentException if the value is not valid for
 966      *         the option.
 967      *
 968      * @throws IOException if an I/O error occurs, or if the socket is closed.
 969      *
 970      * @throws SecurityException if a security manager is set and if the socket
 971      *         option requires a security permission and if the caller does
 972      *         not have the required permission.
 973      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
 974      *         do not require any security permission.
 975      *
 976      * @throws NullPointerException if name is {@code null}
 977      *
 978      * @since 9
 979      */
 980     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value)
 981         throws IOException
 982     {
<span class="line-modified"> 983         delegate().setOption(name, value);</span>



 984         return this;
 985     }
 986 
 987     /**
 988      * Returns the value of a socket option.
 989      *
 990      * @param &lt;T&gt; The type of the socket option value
 991      * @param name The socket option
 992      *
 993      * @return The value of the socket option.
 994      *
 995      * @throws UnsupportedOperationException if the datagram socket
 996      *         does not support the option.
 997      *
 998      * @throws IOException if an I/O error occurs, or if the socket is closed.
 999      *
1000      * @throws NullPointerException if name is {@code null}
1001      *
1002      * @throws SecurityException if a security manager is set and if the socket
1003      *         option requires a security permission and if the caller does
1004      *         not have the required permission.
1005      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1006      *         do not require any security permission.
1007      *
1008      * @since 9
1009      */
1010     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-modified">1011         return delegate().getOption(name);</span>



1012     }
1013 



1014     /**
1015      * Returns a set of the socket options supported by this socket.
1016      *
1017      * This method will continue to return the set of options even after
1018      * the socket has been closed.
1019      *
1020      * @return A set of the socket options supported by this socket. This set
1021      *        may be empty if the socket&#39;s DatagramSocketImpl cannot be created.
1022      *
1023      * @since 9
1024      */
1025     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="line-modified">1026         return delegate().supportedOptions();</span>
<span class="line-modified">1027     }</span>

1028 
<span class="line-modified">1029     // Temporary solution until JDK-8237352 is addressed</span>
<span class="line-modified">1030     private static final SocketAddress NO_DELEGATE = new SocketAddress() {};</span>
<span class="line-modified">1031     private static final boolean USE_PLAINDATAGRAMSOCKET = usePlainDatagramSocketImpl();</span>

1032 
<span class="line-added">1033     private static boolean usePlainDatagramSocketImpl() {</span>
<span class="line-added">1034         PrivilegedAction&lt;String&gt; pa = () -&gt; NetProperties.get(&quot;jdk.net.usePlainDatagramSocketImpl&quot;);</span>
<span class="line-added">1035         String s = AccessController.doPrivileged(pa);</span>
<span class="line-added">1036         return (s != null) &amp;&amp; (s.isEmpty() || s.equalsIgnoreCase(&quot;true&quot;));</span>
<span class="line-added">1037     }</span>
<span class="line-added">1038 </span>
<span class="line-added">1039     /**</span>
<span class="line-added">1040      * Best effort to convert an {@link IOException}</span>
<span class="line-added">1041      * into a {@link SocketException}.</span>
<span class="line-added">1042      *</span>
<span class="line-added">1043      * @param e an instance of {@link IOException}</span>
<span class="line-added">1044      * @return an instance of {@link SocketException}</span>
<span class="line-added">1045      */</span>
<span class="line-added">1046     private static SocketException toSocketException(IOException e) {</span>
<span class="line-added">1047         if (e instanceof SocketException)</span>
<span class="line-added">1048             return (SocketException) e;</span>
<span class="line-added">1049         Throwable cause = e.getCause();</span>
<span class="line-added">1050         if (cause instanceof SocketException)</span>
<span class="line-added">1051             return (SocketException) cause;</span>
<span class="line-added">1052         SocketException se = new SocketException(e.getMessage());</span>
<span class="line-added">1053         se.initCause(e);</span>
<span class="line-added">1054         return se;</span>
<span class="line-added">1055     }</span>
<span class="line-added">1056 </span>
<span class="line-added">1057     /**</span>
<span class="line-added">1058      * Creates a delegate for the specific requested {@code type}. This method should</span>
<span class="line-added">1059      * only be called by {@code DatagramSocket} and {@code MulticastSocket}</span>
<span class="line-added">1060      * public constructors.</span>
<span class="line-added">1061      *</span>
<span class="line-added">1062      * @param bindaddr An address to bind to, or {@code null} if creating an unbound</span>
<span class="line-added">1063      *                 socket.</span>
<span class="line-added">1064      * @param type     This is either {@code MulticastSocket.class}, if the delegate needs</span>
<span class="line-added">1065      *                 to support joining multicast groups, or {@code DatagramSocket.class},</span>
<span class="line-added">1066      *                 if it doesn&#39;t. Typically, this will be {@code DatagramSocket.class}</span>
<span class="line-added">1067      *                 when creating a delegate for {@code DatagramSocket}, and</span>
<span class="line-added">1068      *                 {@code MulticastSocket.class} when creating a delegate for</span>
<span class="line-added">1069      *                 {@code MulticastSocket}.</span>
<span class="line-added">1070      * @param &lt;T&gt;      The target type for which the delegate is created.</span>
<span class="line-added">1071      *                 This is either {@code java.net.DatagramSocket} or</span>
<span class="line-added">1072      *                 {@code java.net.MulticastSocket}.</span>
<span class="line-added">1073      * @return {@code null} if {@code bindaddr == NO_DELEGATE}, otherwise returns a</span>
<span class="line-added">1074      * delegate for the requested {@code type}.</span>
<span class="line-added">1075      * @throws SocketException if an exception occurs while creating or binding the</span>
<span class="line-added">1076      *                         the delegate.</span>
<span class="line-added">1077      */</span>
<span class="line-added">1078     static &lt;T extends DatagramSocket&gt; T createDelegate(SocketAddress bindaddr, Class&lt;T&gt; type)</span>
<span class="line-added">1079             throws SocketException {</span>
<span class="line-added">1080 </span>
<span class="line-added">1081         // Temporary solution until JDK-8237352 is addressed</span>
<span class="line-added">1082         if (bindaddr == NO_DELEGATE) return null;</span>
<span class="line-added">1083 </span>
<span class="line-added">1084         assert type == DatagramSocket.class || type == MulticastSocket.class;</span>
<span class="line-added">1085         boolean multicast = (type == MulticastSocket.class);</span>
<span class="line-added">1086         DatagramSocket delegate = null;</span>
<span class="line-added">1087         boolean initialized = false;</span>
<span class="line-added">1088         try {</span>
<span class="line-added">1089             DatagramSocketImplFactory factory = DatagramSocket.factory;</span>
<span class="line-added">1090             if (USE_PLAINDATAGRAMSOCKET || factory != null) {</span>
<span class="line-added">1091                 // create legacy DatagramSocket delegate</span>
<span class="line-added">1092                 DatagramSocketImpl impl;</span>
<span class="line-added">1093                 if (factory != null) {</span>
<span class="line-added">1094                     impl = factory.createDatagramSocketImpl();</span>
<span class="line-added">1095                 } else {</span>
<span class="line-added">1096                     impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);</span>
<span class="line-added">1097                 }</span>
<span class="line-added">1098                 delegate = new NetMulticastSocket(impl);</span>
<span class="line-added">1099                 ((NetMulticastSocket) delegate).getImpl(); // ensure impl.create() is called.</span>
<span class="line-added">1100             } else {</span>
<span class="line-added">1101                 // create NIO adaptor</span>
<span class="line-added">1102                 delegate = DefaultSelectorProvider.get()</span>
<span class="line-added">1103                         .openUninterruptibleDatagramChannel()</span>
<span class="line-added">1104                         .socket();</span>
<span class="line-added">1105             }</span>
<span class="line-added">1106 </span>
<span class="line-added">1107             if (multicast) {</span>
<span class="line-added">1108                 // set reuseaddress if multicasting</span>
<span class="line-added">1109                 // (must be set before binding)</span>
<span class="line-added">1110                 delegate.setReuseAddress(true);</span>
<span class="line-added">1111             }</span>
<span class="line-added">1112 </span>
<span class="line-added">1113             if (bindaddr != null) {</span>
<span class="line-added">1114                 // bind if needed</span>
<span class="line-added">1115                 delegate.bind(bindaddr);</span>
<span class="line-added">1116             }</span>
<span class="line-added">1117 </span>
<span class="line-added">1118             // enable broadcast if possible</span>
1119             try {
<span class="line-modified">1120                 delegate.setBroadcast(true);</span>
<span class="line-modified">1121             } catch (IOException ioe) {</span>
<span class="line-modified">1122             }</span>
<span class="line-modified">1123 </span>
<span class="line-added">1124             initialized = true;</span>
<span class="line-added">1125         } catch (IOException ioe) {</span>
<span class="line-added">1126             throw toSocketException(ioe);</span>
<span class="line-added">1127         } finally {</span>
<span class="line-added">1128             // make sure the delegate is closed if anything</span>
<span class="line-added">1129             // went wrong</span>
<span class="line-added">1130             if (!initialized &amp;&amp; delegate != null) {</span>
<span class="line-added">1131                 delegate.close();</span>
1132             }

1133         }
<span class="line-added">1134         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">1135         T result = (T) delegate;</span>
<span class="line-added">1136         return result;</span>
1137     }
<span class="line-added">1138 </span>
1139 }
</pre>
</td>
</tr>
</table>
<center><a href="../lang/invoke/StringConcatFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
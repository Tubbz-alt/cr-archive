<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/x509/X509CertImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.BufferedInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.InputStreamReader;
  34 import java.io.OutputStream;
  35 import java.math.BigInteger;
  36 import java.security.*;
  37 import java.security.spec.AlgorithmParameterSpec;
  38 import java.security.cert.*;
  39 import java.security.cert.Certificate;
  40 import java.util.*;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 
  43 import javax.security.auth.x500.X500Principal;
  44 
  45 import sun.security.util.*;
  46 import sun.security.provider.X509Factory;
  47 
  48 import static java.nio.charset.StandardCharsets.US_ASCII;
  49 
  50 /**
  51  * The X509CertImpl class represents an X.509 certificate. These certificates
  52  * are widely used to support authentication and other functionality in
  53  * Internet security systems.  Common applications include Privacy Enhanced
  54  * Mail (PEM), Transport Layer Security (SSL), code signing for trusted
  55  * software distribution, and Secure Electronic Transactions (SET).  There
  56  * is a commercial infrastructure ready to manage large scale deployments
  57  * of X.509 identity certificates.
  58  *
  59  * &lt;P&gt;These certificates are managed and vouched for by &lt;em&gt;Certificate
  60  * Authorities&lt;/em&gt; (CAs).  CAs are services which create certificates by
  61  * placing data in the X.509 standard format and then digitally signing
  62  * that data.  Such signatures are quite difficult to forge.  CAs act as
  63  * trusted third parties, making introductions between agents who have no
  64  * direct knowledge of each other.  CA certificates are either signed by
  65  * themselves, or by some other CA such as a &quot;root&quot; CA.
  66  *
  67  * &lt;P&gt; Standards relating to X.509 Public Key Infrastructure for the Internet
  68  * can be referenced in RFC 5280.
  69  *
  70  * @author Dave Brownell
  71  * @author Amit Kapoor
  72  * @author Hemma Prafullchandra
  73  * @see X509CertInfo
  74  */
  75 @SuppressWarnings(&quot;serial&quot;) // See writeReplace method in Certificate
  76 public class X509CertImpl extends X509Certificate implements DerEncoder {
  77 
  78     @java.io.Serial
  79     private static final long serialVersionUID = -3457612960190864406L;
  80 
  81     private static final char DOT = &#39;.&#39;;
  82     /**
  83      * Public attribute names.
  84      */
  85     public static final String NAME = &quot;x509&quot;;
  86     public static final String INFO = X509CertInfo.NAME;
  87     public static final String ALG_ID = &quot;algorithm&quot;;
  88     public static final String SIGNATURE = &quot;signature&quot;;
  89     public static final String SIGNED_CERT = &quot;signed_cert&quot;;
  90 
  91     /**
  92      * The following are defined for ease-of-use. These
  93      * are the most frequently retrieved attributes.
  94      */
  95     // x509.info.subject.dname
  96     public static final String SUBJECT_DN = NAME + DOT + INFO + DOT +
  97                                X509CertInfo.SUBJECT + DOT + X509CertInfo.DN_NAME;
  98     // x509.info.issuer.dname
  99     public static final String ISSUER_DN = NAME + DOT + INFO + DOT +
 100                                X509CertInfo.ISSUER + DOT + X509CertInfo.DN_NAME;
 101     // x509.info.serialNumber.number
 102     public static final String SERIAL_ID = NAME + DOT + INFO + DOT +
 103                                X509CertInfo.SERIAL_NUMBER + DOT +
 104                                CertificateSerialNumber.NUMBER;
 105     // x509.info.key.value
 106     public static final String PUBLIC_KEY = NAME + DOT + INFO + DOT +
 107                                X509CertInfo.KEY + DOT +
 108                                CertificateX509Key.KEY;
 109 
 110     // x509.info.version.value
 111     public static final String VERSION = NAME + DOT + INFO + DOT +
 112                                X509CertInfo.VERSION + DOT +
 113                                CertificateVersion.VERSION;
 114 
 115     // x509.algorithm
 116     public static final String SIG_ALG = NAME + DOT + ALG_ID;
 117 
 118     // x509.signature
 119     public static final String SIG = NAME + DOT + SIGNATURE;
 120 
 121     // when we sign and decode we set this to true
 122     // this is our means to make certificates immutable
 123     private boolean readOnly = false;
 124 
 125     // Certificate data, and its envelope
 126     private byte[]              signedCert = null;
 127     protected X509CertInfo      info = null;
 128     protected AlgorithmId       algId = null;
 129     protected byte[]            signature = null;
 130 
 131     // recognized extension OIDS
 132     private static final String KEY_USAGE_OID = &quot;2.5.29.15&quot;;
 133     private static final String EXTENDED_KEY_USAGE_OID = &quot;2.5.29.37&quot;;
 134     private static final String BASIC_CONSTRAINT_OID = &quot;2.5.29.19&quot;;
 135     private static final String SUBJECT_ALT_NAME_OID = &quot;2.5.29.17&quot;;
 136     private static final String ISSUER_ALT_NAME_OID = &quot;2.5.29.18&quot;;
 137     private static final String AUTH_INFO_ACCESS_OID = &quot;1.3.6.1.5.5.7.1.1&quot;;
 138 
 139     // number of standard key usage bits.
 140     private static final int NUM_STANDARD_KEY_USAGE = 9;
 141 
 142     // SubjectAlterntativeNames cache
 143     private Collection&lt;List&lt;?&gt;&gt; subjectAlternativeNames;
 144 
 145     // IssuerAlternativeNames cache
 146     private Collection&lt;List&lt;?&gt;&gt; issuerAlternativeNames;
 147 
 148     // ExtendedKeyUsage cache
 149     private List&lt;String&gt; extKeyUsage;
 150 
 151     // AuthorityInformationAccess cache
 152     private Set&lt;AccessDescription&gt; authInfoAccess;
 153 
 154     /**
 155      * PublicKey that has previously been used to verify
 156      * the signature of this certificate. Null if the certificate has not
 157      * yet been verified.
 158      */
 159     private PublicKey verifiedPublicKey;
 160     /**
 161      * If verifiedPublicKey is not null, name of the provider used to
 162      * successfully verify the signature of this certificate, or the
 163      * empty String if no provider was explicitly specified.
 164      */
 165     private String verifiedProvider;
 166     /**
 167      * If verifiedPublicKey is not null, result of the verification using
 168      * verifiedPublicKey and verifiedProvider. If true, verification was
 169      * successful, if false, it failed.
 170      */
 171     private boolean verificationResult;
 172 
 173     /**
 174      * Default constructor.
 175      */
 176     public X509CertImpl() { }
 177 
 178     /**
 179      * Unmarshals a certificate from its encoded form, parsing the
 180      * encoded bytes.  This form of constructor is used by agents which
 181      * need to examine and use certificate contents.  That is, this is
 182      * one of the more commonly used constructors.  Note that the buffer
 183      * must include only a certificate, and no &quot;garbage&quot; may be left at
 184      * the end.  If you need to ignore data at the end of a certificate,
 185      * use another constructor.
 186      *
 187      * @param certData the encoded bytes, with no trailing padding.
 188      * @exception CertificateException on parsing and initialization errors.
 189      */
 190     public X509CertImpl(byte[] certData) throws CertificateException {
 191         try {
 192             parse(new DerValue(certData));
 193         } catch (IOException e) {
 194             signedCert = null;
 195             throw new CertificateException(&quot;Unable to initialize, &quot; + e, e);
 196         }
 197     }
 198 
 199     /**
 200      * unmarshals an X.509 certificate from an input stream.  If the
 201      * certificate is RFC1421 hex-encoded, then it must begin with
 202      * the line X509Factory.BEGIN_CERT and end with the line
 203      * X509Factory.END_CERT.
 204      *
 205      * @param in an input stream holding at least one certificate that may
 206      *        be either DER-encoded or RFC1421 hex-encoded version of the
 207      *        DER-encoded certificate.
 208      * @exception CertificateException on parsing and initialization errors.
 209      */
 210     public X509CertImpl(InputStream in) throws CertificateException {
 211 
 212         DerValue der = null;
 213 
 214         BufferedInputStream inBuffered = new BufferedInputStream(in);
 215 
 216         // First try reading stream as HEX-encoded DER-encoded bytes,
 217         // since not mistakable for raw DER
 218         try {
 219             inBuffered.mark(Integer.MAX_VALUE);
 220             der = readRFC1421Cert(inBuffered);
 221         } catch (IOException ioe) {
 222             try {
 223                 // Next, try reading stream as raw DER-encoded bytes
 224                 inBuffered.reset();
 225                 der = new DerValue(inBuffered);
 226             } catch (IOException ioe1) {
 227                 throw new CertificateException(&quot;Input stream must be &quot; +
 228                                                &quot;either DER-encoded bytes &quot; +
 229                                                &quot;or RFC1421 hex-encoded &quot; +
 230                                                &quot;DER-encoded bytes: &quot; +
 231                                                ioe1.getMessage(), ioe1);
 232             }
 233         }
 234         try {
 235             parse(der);
 236         } catch (IOException ioe) {
 237             signedCert = null;
 238             throw new CertificateException(&quot;Unable to parse DER value of &quot; +
 239                                            &quot;certificate, &quot; + ioe, ioe);
 240         }
 241     }
 242 
 243     /**
 244      * read input stream as HEX-encoded DER-encoded bytes
 245      *
 246      * @param in InputStream to read
 247      * @return DerValue corresponding to decoded HEX-encoded bytes
 248      * @throws IOException if stream can not be interpreted as RFC1421
 249      *                     encoded bytes
 250      */
 251     private DerValue readRFC1421Cert(InputStream in) throws IOException {
 252         DerValue der = null;
 253         String line = null;
 254         BufferedReader certBufferedReader =
 255             new BufferedReader(new InputStreamReader(in, US_ASCII));
 256         try {
 257             line = certBufferedReader.readLine();
 258         } catch (IOException ioe1) {
 259             throw new IOException(&quot;Unable to read InputStream: &quot; +
 260                                   ioe1.getMessage());
 261         }
 262         if (line.equals(X509Factory.BEGIN_CERT)) {
 263             /* stream appears to be hex-encoded bytes */
 264             ByteArrayOutputStream decstream = new ByteArrayOutputStream();
 265             try {
 266                 while ((line = certBufferedReader.readLine()) != null) {
 267                     if (line.equals(X509Factory.END_CERT)) {
 268                         der = new DerValue(decstream.toByteArray());
 269                         break;
 270                     } else {
 271                         decstream.write(Pem.decode(line));
 272                     }
 273                 }
 274             } catch (IOException ioe2) {
 275                 throw new IOException(&quot;Unable to read InputStream: &quot;
 276                                       + ioe2.getMessage());
 277             }
 278         } else {
 279             throw new IOException(&quot;InputStream is not RFC1421 hex-encoded &quot; +
 280                                   &quot;DER bytes&quot;);
 281         }
 282         return der;
 283     }
 284 
 285     /**
 286      * Construct an initialized X509 Certificate. The certificate is stored
 287      * in raw form and has to be signed to be useful.
 288      *
 289      * @param certInfo the X509CertificateInfo which the Certificate is to be
 290      *             created from.
 291      */
 292     public X509CertImpl(X509CertInfo certInfo) {
 293         this.info = certInfo;
 294     }
 295 
 296     /**
 297      * Unmarshal a certificate from its encoded form, parsing a DER value.
 298      * This form of constructor is used by agents which need to examine
 299      * and use certificate contents.
 300      *
 301      * @param derVal the der value containing the encoded cert.
 302      * @exception CertificateException on parsing and initialization errors.
 303      */
 304     public X509CertImpl(DerValue derVal) throws CertificateException {
 305         try {
 306             parse(derVal);
 307         } catch (IOException e) {
 308             signedCert = null;
 309             throw new CertificateException(&quot;Unable to initialize, &quot; + e, e);
 310         }
 311     }
 312 
 313     /**
 314      * Appends the certificate to an output stream.
 315      *
 316      * @param out an input stream to which the certificate is appended.
 317      * @exception CertificateEncodingException on encoding errors.
 318      */
 319     public void encode(OutputStream out)
 320     throws CertificateEncodingException {
 321         if (signedCert == null)
 322             throw new CertificateEncodingException(
 323                           &quot;Null certificate to encode&quot;);
 324         try {
 325             out.write(signedCert.clone());
 326         } catch (IOException e) {
 327             throw new CertificateEncodingException(e.toString());
 328         }
 329     }
 330 
 331     /**
 332      * DER encode this object onto an output stream.
 333      * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
 334      *
 335      * @param out the output stream on which to write the DER encoding.
 336      *
 337      * @exception IOException on encoding error.
 338      */
 339     public void derEncode(OutputStream out) throws IOException {
 340         if (signedCert == null)
 341             throw new IOException(&quot;Null certificate to encode&quot;);
 342         out.write(signedCert.clone());
 343     }
 344 
 345     /**
 346      * Returns the encoded form of this certificate. It is
 347      * assumed that each certificate type would have only a single
 348      * form of encoding; for example, X.509 certificates would
 349      * be encoded as ASN.1 DER.
 350      *
 351      * @exception CertificateEncodingException if an encoding error occurs.
 352      */
 353     public byte[] getEncoded() throws CertificateEncodingException {
 354         return getEncodedInternal().clone();
 355     }
 356 
 357     /**
 358      * Returned the encoding as an uncloned byte array. Callers must
 359      * guarantee that they neither modify it nor expose it to untrusted
 360      * code.
 361      */
 362     public byte[] getEncodedInternal() throws CertificateEncodingException {
 363         if (signedCert == null) {
 364             throw new CertificateEncodingException(
 365                           &quot;Null certificate to encode&quot;);
 366         }
 367         return signedCert;
 368     }
 369 
 370     /**
 371      * Throws an exception if the certificate was not signed using the
 372      * verification key provided.  Successfully verifying a certificate
 373      * does &lt;em&gt;not&lt;/em&gt; indicate that one should trust the entity which
 374      * it represents.
 375      *
 376      * @param key the public key used for verification.
 377      *
 378      * @exception InvalidKeyException on incorrect key.
 379      * @exception NoSuchAlgorithmException on unsupported signature
 380      * algorithms.
 381      * @exception NoSuchProviderException if there&#39;s no default provider.
 382      * @exception SignatureException on signature errors.
 383      * @exception CertificateException on encoding errors.
 384      */
 385     public void verify(PublicKey key)
 386     throws CertificateException, NoSuchAlgorithmException,
 387         InvalidKeyException, NoSuchProviderException, SignatureException {
 388         verify(key, &quot;&quot;);
 389     }
 390 
 391     /**
 392      * Throws an exception if the certificate was not signed using the
 393      * verification key provided.  Successfully verifying a certificate
 394      * does &lt;em&gt;not&lt;/em&gt; indicate that one should trust the entity which
 395      * it represents.
 396      *
 397      * @param key the public key used for verification.
 398      * @param sigProvider the name of the provider.
 399      *
 400      * @exception NoSuchAlgorithmException on unsupported signature
 401      * algorithms.
 402      * @exception InvalidKeyException on incorrect key.
 403      * @exception NoSuchProviderException on incorrect provider.
 404      * @exception SignatureException on signature errors.
 405      * @exception CertificateException on encoding errors.
 406      */
 407     public synchronized void verify(PublicKey key, String sigProvider)
 408             throws CertificateException, NoSuchAlgorithmException,
 409             InvalidKeyException, NoSuchProviderException, SignatureException {
 410         if (sigProvider == null) {
 411             sigProvider = &quot;&quot;;
 412         }
 413         if ((verifiedPublicKey != null) &amp;&amp; verifiedPublicKey.equals(key)) {
 414             // this certificate has already been verified using
 415             // this public key. Make sure providers match, too.
 416             if (sigProvider.equals(verifiedProvider)) {
 417                 if (verificationResult) {
 418                     return;
 419                 } else {
 420                     throw new SignatureException(&quot;Signature does not match.&quot;);
 421                 }
 422             }
 423         }
 424         if (signedCert == null) {
 425             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
 426         }
 427         // Verify the signature ...
 428         Signature sigVerf = null;
 429         String sigName = algId.getName();
 430         if (sigProvider.isEmpty()) {
 431             sigVerf = Signature.getInstance(sigName);
 432         } else {
 433             sigVerf = Signature.getInstance(sigName, sigProvider);
 434         }
 435 
 436         try {
 437             SignatureUtil.initVerifyWithParam(sigVerf, key,
 438                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
 439         } catch (ProviderException e) {
 440             throw new CertificateException(e.getMessage(), e.getCause());
 441         } catch (InvalidAlgorithmParameterException e) {
 442             throw new CertificateException(e);
 443         }
 444 
 445         byte[] rawCert = info.getEncodedInfo();
 446         sigVerf.update(rawCert, 0, rawCert.length);
 447 
 448         // verify may throw SignatureException for invalid encodings, etc.
 449         verificationResult = sigVerf.verify(signature);
 450         verifiedPublicKey = key;
 451         verifiedProvider = sigProvider;
 452 
 453         if (verificationResult == false) {
 454             throw new SignatureException(&quot;Signature does not match.&quot;);
 455         }
 456     }
 457 
 458     /**
 459      * Throws an exception if the certificate was not signed using the
 460      * verification key provided.  This method uses the signature verification
 461      * engine supplied by the specified provider. Note that the specified
 462      * Provider object does not have to be registered in the provider list.
 463      * Successfully verifying a certificate does &lt;em&gt;not&lt;/em&gt; indicate that one
 464      * should trust the entity which it represents.
 465      *
 466      * @param key the public key used for verification.
 467      * @param sigProvider the provider.
 468      *
 469      * @exception NoSuchAlgorithmException on unsupported signature
 470      * algorithms.
 471      * @exception InvalidKeyException on incorrect key.
 472      * @exception SignatureException on signature errors.
 473      * @exception CertificateException on encoding errors.
 474      */
 475     public synchronized void verify(PublicKey key, Provider sigProvider)
 476             throws CertificateException, NoSuchAlgorithmException,
 477             InvalidKeyException, SignatureException {
 478         if (signedCert == null) {
 479             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
 480         }
 481         // Verify the signature ...
 482         Signature sigVerf = null;
 483         String sigName = algId.getName();
 484         if (sigProvider == null) {
 485             sigVerf = Signature.getInstance(sigName);
 486         } else {
 487             sigVerf = Signature.getInstance(sigName, sigProvider);
 488         }
 489 
 490         try {
 491             SignatureUtil.initVerifyWithParam(sigVerf, key,
 492                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
 493         } catch (ProviderException e) {
 494             throw new CertificateException(e.getMessage(), e.getCause());
 495         } catch (InvalidAlgorithmParameterException e) {
 496             throw new CertificateException(e);
 497         }
 498 
 499         byte[] rawCert = info.getEncodedInfo();
 500         sigVerf.update(rawCert, 0, rawCert.length);
 501 
 502         // verify may throw SignatureException for invalid encodings, etc.
 503         verificationResult = sigVerf.verify(signature);
 504         verifiedPublicKey = key;
 505 
 506         if (verificationResult == false) {
 507             throw new SignatureException(&quot;Signature does not match.&quot;);
 508         }
 509     }
 510 
 511     /**
 512      * Creates an X.509 certificate, and signs it using the given key
 513      * (associating a signature algorithm and an X.500 name).
 514      * This operation is used to implement the certificate generation
 515      * functionality of a certificate authority.
 516      *
 517      * @param key the private key used for signing.
 518      * @param algorithm the name of the signature algorithm used.
 519      *
 520      * @exception InvalidKeyException on incorrect key.
 521      * @exception NoSuchAlgorithmException on unsupported signature
 522      * algorithms.
 523      * @exception NoSuchProviderException if there&#39;s no default provider.
 524      * @exception SignatureException on signature errors.
 525      * @exception CertificateException on encoding errors.
 526      */
 527     public void sign(PrivateKey key, String algorithm)
 528     throws CertificateException, NoSuchAlgorithmException,
 529         InvalidKeyException, NoSuchProviderException, SignatureException {
 530         sign(key, algorithm, null);
 531     }
 532 
 533     /**
 534      * Creates an X.509 certificate, and signs it using the given key
 535      * (associating a signature algorithm and an X.500 name).
 536      * This operation is used to implement the certificate generation
 537      * functionality of a certificate authority.
 538      *
 539      * @param key the private key used for signing.
 540      * @param algorithm the name of the signature algorithm used.
 541      * @param provider the name of the provider.
 542      *
 543      * @exception NoSuchAlgorithmException on unsupported signature
 544      * algorithms.
 545      * @exception InvalidKeyException on incorrect key.
 546      * @exception NoSuchProviderException on incorrect provider.
 547      * @exception SignatureException on signature errors.
 548      * @exception CertificateException on encoding errors.
 549      */
 550     public void sign(PrivateKey key, String algorithm, String provider)
 551     throws CertificateException, NoSuchAlgorithmException,
 552         InvalidKeyException, NoSuchProviderException, SignatureException {
 553         try {
 554             sign(key, null, algorithm, provider);
 555         } catch (InvalidAlgorithmParameterException e) {
 556             // should not happen; re-throw just in case
 557             throw new SignatureException(e);
 558         }
 559     }
 560 
 561     /**
 562      * Creates an X.509 certificate, and signs it using the given key
 563      * (associating a signature algorithm and an X.500 name), signature
 564      * parameters, and security provider. If the given provider name
 565      * is null or empty, the implementation look up will be based on
 566      * provider configurations.
 567      * This operation is used to implement the certificate generation
 568      * functionality of a certificate authority.
 569      *
 570      * @param key the private key used for signing
 571      * @param signingParams the parameters used for signing
 572      * @param algorithm the name of the signature algorithm used
 573      * @param provider the name of the provider, may be null
 574      *
 575      * @exception NoSuchAlgorithmException on unsupported signature
 576      *            algorithms
 577      * @exception InvalidKeyException on incorrect key
 578      * @exception InvalidAlgorithmParameterException on invalid signature
 579      *            parameters
 580      * @exception NoSuchProviderException on incorrect provider
 581      * @exception SignatureException on signature errors
 582      * @exception CertificateException on encoding errors
 583      */
 584     public void sign(PrivateKey key, AlgorithmParameterSpec signingParams,
 585             String algorithm, String provider)
 586             throws CertificateException, NoSuchAlgorithmException,
 587             InvalidKeyException, InvalidAlgorithmParameterException,
 588             NoSuchProviderException, SignatureException {
 589         try {
 590             if (readOnly) {
 591                 throw new CertificateEncodingException(
 592                         &quot;cannot over-write existing certificate&quot;);
 593             }
 594             Signature sigEngine = null;
 595             if (provider == null || provider.isEmpty()) {
 596                 sigEngine = Signature.getInstance(algorithm);
 597             } else {
 598                 sigEngine = Signature.getInstance(algorithm, provider);
 599             }
 600 
 601             SignatureUtil.initSignWithParam(sigEngine, key, signingParams,
 602                     null);
 603 
 604             if (signingParams != null) {
 605                 algId = AlgorithmId.get(sigEngine.getParameters());
 606             } else {
 607                 // in case the name is reset
 608                 algId = AlgorithmId.get(sigEngine.getAlgorithm());
 609             }
 610             DerOutputStream out = new DerOutputStream();
 611             DerOutputStream tmp = new DerOutputStream();
 612 
 613             // encode certificate info
 614             info.encode(tmp);
 615             byte[] rawCert = tmp.toByteArray();
 616 
 617             // encode algorithm identifier
 618             algId.encode(tmp);
 619 
 620             // Create and encode the signature itself.
 621             sigEngine.update(rawCert, 0, rawCert.length);
 622             signature = sigEngine.sign();
 623             tmp.putBitString(signature);
 624 
 625             // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
 626             out.write(DerValue.tag_Sequence, tmp);
 627             signedCert = out.toByteArray();
 628             readOnly = true;
 629 
 630         } catch (IOException e) {
 631             throw new CertificateEncodingException(e.toString());
 632       }
 633     }
 634 
 635     /**
 636      * Checks that the certificate is currently valid, i.e. the current
 637      * time is within the specified validity period.
 638      *
 639      * @exception CertificateExpiredException if the certificate has expired.
 640      * @exception CertificateNotYetValidException if the certificate is not
 641      * yet valid.
 642      */
 643     public void checkValidity()
 644     throws CertificateExpiredException, CertificateNotYetValidException {
 645         Date date = new Date();
 646         checkValidity(date);
 647     }
 648 
 649     /**
 650      * Checks that the specified date is within the certificate&#39;s
 651      * validity period, or basically if the certificate would be
 652      * valid at the specified date/time.
 653      *
 654      * @param date the Date to check against to see if this certificate
 655      *        is valid at that date/time.
 656      *
 657      * @exception CertificateExpiredException if the certificate has expired
 658      * with respect to the &lt;code&gt;date&lt;/code&gt; supplied.
 659      * @exception CertificateNotYetValidException if the certificate is not
 660      * yet valid with respect to the &lt;code&gt;date&lt;/code&gt; supplied.
 661      */
 662     public void checkValidity(Date date)
 663     throws CertificateExpiredException, CertificateNotYetValidException {
 664 
 665         CertificateValidity interval = null;
 666         try {
 667             interval = (CertificateValidity)info.get(CertificateValidity.NAME);
 668         } catch (Exception e) {
 669             throw new CertificateNotYetValidException(&quot;Incorrect validity period&quot;);
 670         }
 671         if (interval == null)
 672             throw new CertificateNotYetValidException(&quot;Null validity period&quot;);
 673         interval.valid(date);
 674     }
 675 
 676     /**
 677      * Return the requested attribute from the certificate.
 678      *
 679      * Note that the X509CertInfo is not cloned for performance reasons.
 680      * Callers must ensure that they do not modify it. All other
 681      * attributes are cloned.
 682      *
 683      * @param name the name of the attribute.
 684      * @exception CertificateParsingException on invalid attribute identifier.
 685      */
 686     public Object get(String name)
 687     throws CertificateParsingException {
 688         X509AttributeName attr = new X509AttributeName(name);
 689         String id = attr.getPrefix();
 690         if (!(id.equalsIgnoreCase(NAME))) {
 691             throw new CertificateParsingException(&quot;Invalid root of &quot;
 692                           + &quot;attribute name, expected [&quot; + NAME +
 693                           &quot;], received &quot; + &quot;[&quot; + id + &quot;]&quot;);
 694         }
 695         attr = new X509AttributeName(attr.getSuffix());
 696         id = attr.getPrefix();
 697 
 698         if (id.equalsIgnoreCase(INFO)) {
 699             if (info == null) {
 700                 return null;
 701             }
 702             if (attr.getSuffix() != null) {
 703                 try {
 704                     return info.get(attr.getSuffix());
 705                 } catch (IOException e) {
 706                     throw new CertificateParsingException(e.toString());
 707                 } catch (CertificateException e) {
 708                     throw new CertificateParsingException(e.toString());
 709                 }
 710             } else {
 711                 return info;
 712             }
 713         } else if (id.equalsIgnoreCase(ALG_ID)) {
 714             return(algId);
 715         } else if (id.equalsIgnoreCase(SIGNATURE)) {
 716             if (signature != null)
 717                 return signature.clone();
 718             else
 719                 return null;
 720         } else if (id.equalsIgnoreCase(SIGNED_CERT)) {
 721             if (signedCert != null)
 722                 return signedCert.clone();
 723             else
 724                 return null;
 725         } else {
 726             throw new CertificateParsingException(&quot;Attribute name not &quot;
 727                  + &quot;recognized or get() not allowed for the same: &quot; + id);
 728         }
 729     }
 730 
 731     /**
 732      * Set the requested attribute in the certificate.
 733      *
 734      * @param name the name of the attribute.
 735      * @param obj the value of the attribute.
 736      * @exception CertificateException on invalid attribute identifier.
 737      * @exception IOException on encoding error of attribute.
 738      */
 739     public void set(String name, Object obj)
 740     throws CertificateException, IOException {
 741         // check if immutable
 742         if (readOnly)
 743             throw new CertificateException(&quot;cannot over-write existing&quot;
 744                                            + &quot; certificate&quot;);
 745 
 746         X509AttributeName attr = new X509AttributeName(name);
 747         String id = attr.getPrefix();
 748         if (!(id.equalsIgnoreCase(NAME))) {
 749             throw new CertificateException(&quot;Invalid root of attribute name,&quot;
 750                            + &quot; expected [&quot; + NAME + &quot;], received &quot; + id);
 751         }
 752         attr = new X509AttributeName(attr.getSuffix());
 753         id = attr.getPrefix();
 754 
 755         if (id.equalsIgnoreCase(INFO)) {
 756             if (attr.getSuffix() == null) {
 757                 if (!(obj instanceof X509CertInfo)) {
 758                     throw new CertificateException(&quot;Attribute value should&quot;
 759                                     + &quot; be of type X509CertInfo.&quot;);
 760                 }
 761                 info = (X509CertInfo)obj;
 762                 signedCert = null;  //reset this as certificate data has changed
 763             } else {
 764                 info.set(attr.getSuffix(), obj);
 765                 signedCert = null;  //reset this as certificate data has changed
 766             }
 767         } else {
 768             throw new CertificateException(&quot;Attribute name not recognized or &quot; +
 769                               &quot;set() not allowed for the same: &quot; + id);
 770         }
 771     }
 772 
 773     /**
 774      * Delete the requested attribute from the certificate.
 775      *
 776      * @param name the name of the attribute.
 777      * @exception CertificateException on invalid attribute identifier.
 778      * @exception IOException on other errors.
 779      */
 780     public void delete(String name)
 781     throws CertificateException, IOException {
 782         // check if immutable
 783         if (readOnly)
 784             throw new CertificateException(&quot;cannot over-write existing&quot;
 785                                            + &quot; certificate&quot;);
 786 
 787         X509AttributeName attr = new X509AttributeName(name);
 788         String id = attr.getPrefix();
 789         if (!(id.equalsIgnoreCase(NAME))) {
 790             throw new CertificateException(&quot;Invalid root of attribute name,&quot;
 791                                    + &quot; expected [&quot;
 792                                    + NAME + &quot;], received &quot; + id);
 793         }
 794         attr = new X509AttributeName(attr.getSuffix());
 795         id = attr.getPrefix();
 796 
 797         if (id.equalsIgnoreCase(INFO)) {
 798             if (attr.getSuffix() != null) {
 799                 info = null;
 800             } else {
 801                 info.delete(attr.getSuffix());
 802             }
 803         } else if (id.equalsIgnoreCase(ALG_ID)) {
 804             algId = null;
 805         } else if (id.equalsIgnoreCase(SIGNATURE)) {
 806             signature = null;
 807         } else if (id.equalsIgnoreCase(SIGNED_CERT)) {
 808             signedCert = null;
 809         } else {
 810             throw new CertificateException(&quot;Attribute name not recognized or &quot; +
 811                               &quot;delete() not allowed for the same: &quot; + id);
 812         }
 813     }
 814 
 815     /**
 816      * Return an enumeration of names of attributes existing within this
 817      * attribute.
 818      */
 819     public Enumeration&lt;String&gt; getElements() {
 820         AttributeNameEnumeration elements = new AttributeNameEnumeration();
 821         elements.addElement(NAME + DOT + INFO);
 822         elements.addElement(NAME + DOT + ALG_ID);
 823         elements.addElement(NAME + DOT + SIGNATURE);
 824         elements.addElement(NAME + DOT + SIGNED_CERT);
 825 
 826         return elements.elements();
 827     }
 828 
 829     /**
 830      * Return the name of this attribute.
 831      */
 832     public String getName() {
 833         return(NAME);
 834     }
 835 
 836     /**
 837      * Returns a printable representation of the certificate.  This does not
 838      * contain all the information available to distinguish this from any
 839      * other certificate.  The certificate must be fully constructed
 840      * before this function may be called.
 841      */
 842     public String toString() {
 843         if (info == null || algId == null || signature == null)
 844             return &quot;&quot;;
 845 
 846         HexDumpEncoder encoder = new HexDumpEncoder();
 847         return &quot;[\n&quot; + info + &#39;\n&#39; +
 848             &quot;  Algorithm: [&quot; + algId + &quot;]\n&quot; +
 849             &quot;  Signature:\n&quot; + encoder.encodeBuffer(signature) + &quot;\n]&quot;;
 850     }
 851 
 852     // the strongly typed gets, as per java.security.cert.X509Certificate
 853 
 854     /**
 855      * Gets the publickey from this certificate.
 856      *
 857      * @return the publickey.
 858      */
 859     public PublicKey getPublicKey() {
 860         if (info == null)
 861             return null;
 862         try {
 863             PublicKey key = (PublicKey)info.get(CertificateX509Key.NAME
 864                                 + DOT + CertificateX509Key.KEY);
 865             return key;
 866         } catch (Exception e) {
 867             return null;
 868         }
 869     }
 870 
 871     /**
 872      * Gets the version number from the certificate.
 873      *
 874      * @return the version number, i.e. 1, 2 or 3.
 875      */
 876     public int getVersion() {
 877         if (info == null)
 878             return -1;
 879         try {
 880             int vers = ((Integer)info.get(CertificateVersion.NAME
 881                         + DOT + CertificateVersion.VERSION)).intValue();
 882             return vers+1;
 883         } catch (Exception e) {
 884             return -1;
 885         }
 886     }
 887 
 888     /**
 889      * Gets the serial number from the certificate.
 890      *
 891      * @return the serial number.
 892      */
 893     public BigInteger getSerialNumber() {
 894         SerialNumber ser = getSerialNumberObject();
 895 
 896         return ser != null ? ser.getNumber() : null;
 897     }
 898 
 899     /**
 900      * Gets the serial number from the certificate as
 901      * a SerialNumber object.
 902      *
 903      * @return the serial number.
 904      */
 905     public SerialNumber getSerialNumberObject() {
 906         if (info == null)
 907             return null;
 908         try {
 909             SerialNumber ser = (SerialNumber)info.get(
 910                               CertificateSerialNumber.NAME + DOT +
 911                               CertificateSerialNumber.NUMBER);
 912            return ser;
 913         } catch (Exception e) {
 914             return null;
 915         }
 916     }
 917 
 918 
 919     /**
 920      * Gets the subject distinguished name from the certificate.
 921      *
 922      * @return the subject name.
 923      */
 924     public Principal getSubjectDN() {
 925         if (info == null)
 926             return null;
 927         try {
 928             Principal subject = (Principal)info.get(X509CertInfo.SUBJECT + DOT +
 929                                                     X509CertInfo.DN_NAME);
 930             return subject;
 931         } catch (Exception e) {
 932             return null;
 933         }
 934     }
 935 
 936     /**
 937      * Get subject name as X500Principal. Overrides implementation in
 938      * X509Certificate with a slightly more efficient version that is
 939      * also aware of X509CertImpl mutability.
 940      */
 941     public X500Principal getSubjectX500Principal() {
 942         if (info == null) {
 943             return null;
 944         }
 945         try {
 946             X500Principal subject = (X500Principal)info.get(
 947                                             X509CertInfo.SUBJECT + DOT +
 948                                             &quot;x500principal&quot;);
 949             return subject;
 950         } catch (Exception e) {
 951             return null;
 952         }
 953     }
 954 
 955     /**
 956      * Gets the issuer distinguished name from the certificate.
 957      *
 958      * @return the issuer name.
 959      */
 960     public Principal getIssuerDN() {
 961         if (info == null)
 962             return null;
 963         try {
 964             Principal issuer = (Principal)info.get(X509CertInfo.ISSUER + DOT +
 965                                                    X509CertInfo.DN_NAME);
 966             return issuer;
 967         } catch (Exception e) {
 968             return null;
 969         }
 970     }
 971 
 972     /**
 973      * Get issuer name as X500Principal. Overrides implementation in
 974      * X509Certificate with a slightly more efficient version that is
 975      * also aware of X509CertImpl mutability.
 976      */
 977     public X500Principal getIssuerX500Principal() {
 978         if (info == null) {
 979             return null;
 980         }
 981         try {
 982             X500Principal issuer = (X500Principal)info.get(
 983                                             X509CertInfo.ISSUER + DOT +
 984                                             &quot;x500principal&quot;);
 985             return issuer;
 986         } catch (Exception e) {
 987             return null;
 988         }
 989     }
 990 
 991     /**
 992      * Gets the notBefore date from the validity period of the certificate.
 993      *
 994      * @return the start date of the validity period.
 995      */
 996     public Date getNotBefore() {
 997         if (info == null)
 998             return null;
 999         try {
1000             Date d = (Date) info.get(CertificateValidity.NAME + DOT +
1001                                         CertificateValidity.NOT_BEFORE);
1002             return d;
1003         } catch (Exception e) {
1004             return null;
1005         }
1006     }
1007 
1008     /**
1009      * Gets the notAfter date from the validity period of the certificate.
1010      *
1011      * @return the end date of the validity period.
1012      */
1013     public Date getNotAfter() {
1014         if (info == null)
1015             return null;
1016         try {
1017             Date d = (Date) info.get(CertificateValidity.NAME + DOT +
1018                                      CertificateValidity.NOT_AFTER);
1019             return d;
1020         } catch (Exception e) {
1021             return null;
1022         }
1023     }
1024 
1025     /**
1026      * Gets the DER encoded certificate informations, the
1027      * &lt;code&gt;tbsCertificate&lt;/code&gt; from this certificate.
1028      * This can be used to verify the signature independently.
1029      *
1030      * @return the DER encoded certificate information.
1031      * @exception CertificateEncodingException if an encoding error occurs.
1032      */
1033     public byte[] getTBSCertificate() throws CertificateEncodingException {
1034         if (info != null) {
1035             return info.getEncodedInfo();
1036         } else
1037             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
1038     }
1039 
1040     /**
1041      * Gets the raw Signature bits from the certificate.
1042      *
1043      * @return the signature.
1044      */
1045     public byte[] getSignature() {
1046         if (signature == null)
1047             return null;
1048         return signature.clone();
1049     }
1050 
1051     /**
1052      * Gets the signature algorithm name for the certificate
1053      * signature algorithm.
1054      * For example, the string &quot;SHA-1/DSA&quot; or &quot;DSS&quot;.
1055      *
1056      * @return the signature algorithm name.
1057      */
1058     public String getSigAlgName() {
1059         if (algId == null)
1060             return null;
1061         return (algId.getName());
1062     }
1063 
1064     /**
1065      * Gets the signature algorithm OID string from the certificate.
1066      * For example, the string &quot;1.2.840.10040.4.3&quot;
1067      *
1068      * @return the signature algorithm oid string.
1069      */
1070     public String getSigAlgOID() {
1071         if (algId == null)
1072             return null;
1073         ObjectIdentifier oid = algId.getOID();
1074         return (oid.toString());
1075     }
1076 
1077     /**
1078      * Gets the DER encoded signature algorithm parameters from this
1079      * certificate&#39;s signature algorithm.
1080      *
1081      * @return the DER encoded signature algorithm parameters, or
1082      *         null if no parameters are present.
1083      */
1084     public byte[] getSigAlgParams() {
1085         if (algId == null)
1086             return null;
1087         try {
1088             return algId.getEncodedParams();
1089         } catch (IOException e) {
1090             return null;
1091         }
1092     }
1093 
1094     /**
1095      * Gets the Issuer Unique Identity from the certificate.
1096      *
1097      * @return the Issuer Unique Identity.
1098      */
1099     public boolean[] getIssuerUniqueID() {
1100         if (info == null)
1101             return null;
1102         try {
1103             UniqueIdentity id = (UniqueIdentity)info.get(
1104                                  X509CertInfo.ISSUER_ID);
1105             if (id == null)
1106                 return null;
1107             else
1108                 return (id.getId());
1109         } catch (Exception e) {
1110             return null;
1111         }
1112     }
1113 
1114     /**
1115      * Gets the Subject Unique Identity from the certificate.
1116      *
1117      * @return the Subject Unique Identity.
1118      */
1119     public boolean[] getSubjectUniqueID() {
1120         if (info == null)
1121             return null;
1122         try {
1123             UniqueIdentity id = (UniqueIdentity)info.get(
1124                                  X509CertInfo.SUBJECT_ID);
1125             if (id == null)
1126                 return null;
1127             else
1128                 return (id.getId());
1129         } catch (Exception e) {
1130             return null;
1131         }
1132     }
1133 
1134     public KeyIdentifier getAuthKeyId() {
1135         AuthorityKeyIdentifierExtension aki
1136             = getAuthorityKeyIdentifierExtension();
1137         if (aki != null) {
1138             try {
1139                 return (KeyIdentifier)aki.get(
1140                     AuthorityKeyIdentifierExtension.KEY_ID);
1141             } catch (IOException ioe) {} // not possible
1142         }
1143         return null;
1144     }
1145 
1146     /**
1147      * Returns the subject&#39;s key identifier, or null
1148      */
1149     public KeyIdentifier getSubjectKeyId() {
1150         SubjectKeyIdentifierExtension ski = getSubjectKeyIdentifierExtension();
1151         if (ski != null) {
1152             try {
1153                 return ski.get(SubjectKeyIdentifierExtension.KEY_ID);
1154             } catch (IOException ioe) {} // not possible
1155         }
1156         return null;
1157     }
1158 
1159     /**
1160      * Get AuthorityKeyIdentifier extension
1161      * @return AuthorityKeyIdentifier object or null (if no such object
1162      * in certificate)
1163      */
1164     public AuthorityKeyIdentifierExtension getAuthorityKeyIdentifierExtension()
1165     {
1166         return (AuthorityKeyIdentifierExtension)
1167             getExtension(PKIXExtensions.AuthorityKey_Id);
1168     }
1169 
1170     /**
1171      * Get BasicConstraints extension
1172      * @return BasicConstraints object or null (if no such object in
1173      * certificate)
1174      */
1175     public BasicConstraintsExtension getBasicConstraintsExtension() {
1176         return (BasicConstraintsExtension)
1177             getExtension(PKIXExtensions.BasicConstraints_Id);
1178     }
1179 
1180     /**
1181      * Get CertificatePoliciesExtension
1182      * @return CertificatePoliciesExtension or null (if no such object in
1183      * certificate)
1184      */
1185     public CertificatePoliciesExtension getCertificatePoliciesExtension() {
1186         return (CertificatePoliciesExtension)
1187             getExtension(PKIXExtensions.CertificatePolicies_Id);
1188     }
1189 
1190     /**
1191      * Get ExtendedKeyUsage extension
1192      * @return ExtendedKeyUsage extension object or null (if no such object
1193      * in certificate)
1194      */
1195     public ExtendedKeyUsageExtension getExtendedKeyUsageExtension() {
1196         return (ExtendedKeyUsageExtension)
1197             getExtension(PKIXExtensions.ExtendedKeyUsage_Id);
1198     }
1199 
1200     /**
1201      * Get IssuerAlternativeName extension
1202      * @return IssuerAlternativeName object or null (if no such object in
1203      * certificate)
1204      */
1205     public IssuerAlternativeNameExtension getIssuerAlternativeNameExtension() {
1206         return (IssuerAlternativeNameExtension)
1207             getExtension(PKIXExtensions.IssuerAlternativeName_Id);
1208     }
1209 
1210     /**
1211      * Get NameConstraints extension
1212      * @return NameConstraints object or null (if no such object in certificate)
1213      */
1214     public NameConstraintsExtension getNameConstraintsExtension() {
1215         return (NameConstraintsExtension)
1216             getExtension(PKIXExtensions.NameConstraints_Id);
1217     }
1218 
1219     /**
1220      * Get PolicyConstraints extension
1221      * @return PolicyConstraints object or null (if no such object in
1222      * certificate)
1223      */
1224     public PolicyConstraintsExtension getPolicyConstraintsExtension() {
1225         return (PolicyConstraintsExtension)
1226             getExtension(PKIXExtensions.PolicyConstraints_Id);
1227     }
1228 
1229     /**
1230      * Get PolicyMappingsExtension extension
1231      * @return PolicyMappingsExtension object or null (if no such object
1232      * in certificate)
1233      */
1234     public PolicyMappingsExtension getPolicyMappingsExtension() {
1235         return (PolicyMappingsExtension)
1236             getExtension(PKIXExtensions.PolicyMappings_Id);
1237     }
1238 
1239     /**
1240      * Get PrivateKeyUsage extension
1241      * @return PrivateKeyUsage object or null (if no such object in certificate)
1242      */
1243     public PrivateKeyUsageExtension getPrivateKeyUsageExtension() {
1244         return (PrivateKeyUsageExtension)
1245             getExtension(PKIXExtensions.PrivateKeyUsage_Id);
1246     }
1247 
1248     /**
1249      * Get SubjectAlternativeName extension
1250      * @return SubjectAlternativeName object or null (if no such object in
1251      * certificate)
1252      */
1253     public SubjectAlternativeNameExtension getSubjectAlternativeNameExtension()
1254     {
1255         return (SubjectAlternativeNameExtension)
1256             getExtension(PKIXExtensions.SubjectAlternativeName_Id);
1257     }
1258 
1259     /**
1260      * Get SubjectKeyIdentifier extension
1261      * @return SubjectKeyIdentifier object or null (if no such object in
1262      * certificate)
1263      */
1264     public SubjectKeyIdentifierExtension getSubjectKeyIdentifierExtension() {
1265         return (SubjectKeyIdentifierExtension)
1266             getExtension(PKIXExtensions.SubjectKey_Id);
1267     }
1268 
1269     /**
1270      * Get CRLDistributionPoints extension
1271      * @return CRLDistributionPoints object or null (if no such object in
1272      * certificate)
1273      */
1274     public CRLDistributionPointsExtension getCRLDistributionPointsExtension() {
1275         return (CRLDistributionPointsExtension)
1276             getExtension(PKIXExtensions.CRLDistributionPoints_Id);
1277     }
1278 
1279     /**
1280      * Return true if a critical extension is found that is
1281      * not supported, otherwise return false.
1282      */
1283     public boolean hasUnsupportedCriticalExtension() {
1284         if (info == null)
1285             return false;
1286         try {
1287             CertificateExtensions exts = (CertificateExtensions)info.get(
1288                                          CertificateExtensions.NAME);
1289             if (exts == null)
1290                 return false;
1291             return exts.hasUnsupportedCriticalExtension();
1292         } catch (Exception e) {
1293             return false;
1294         }
1295     }
1296 
1297     /**
1298      * Gets a Set of the extension(s) marked CRITICAL in the
1299      * certificate. In the returned set, each extension is
1300      * represented by its OID string.
1301      *
1302      * @return a set of the extension oid strings in the
1303      * certificate that are marked critical.
1304      */
1305     public Set&lt;String&gt; getCriticalExtensionOIDs() {
1306         if (info == null) {
1307             return null;
1308         }
1309         try {
1310             CertificateExtensions exts = (CertificateExtensions)info.get(
1311                                          CertificateExtensions.NAME);
1312             if (exts == null) {
1313                 return null;
1314             }
1315             Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
1316             for (Extension ex : exts.getAllExtensions()) {
1317                 if (ex.isCritical()) {
1318                     extSet.add(ex.getExtensionId().toString());
1319                 }
1320             }
1321             return extSet;
1322         } catch (Exception e) {
1323             return null;
1324         }
1325     }
1326 
1327     /**
1328      * Gets a Set of the extension(s) marked NON-CRITICAL in the
1329      * certificate. In the returned set, each extension is
1330      * represented by its OID string.
1331      *
1332      * @return a set of the extension oid strings in the
1333      * certificate that are NOT marked critical.
1334      */
1335     public Set&lt;String&gt; getNonCriticalExtensionOIDs() {
1336         if (info == null) {
1337             return null;
1338         }
1339         try {
1340             CertificateExtensions exts = (CertificateExtensions)info.get(
1341                                          CertificateExtensions.NAME);
1342             if (exts == null) {
1343                 return null;
1344             }
1345             Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
1346             for (Extension ex : exts.getAllExtensions()) {
1347                 if (!ex.isCritical()) {
1348                     extSet.add(ex.getExtensionId().toString());
1349                 }
1350             }
1351             extSet.addAll(exts.getUnparseableExtensions().keySet());
1352             return extSet;
1353         } catch (Exception e) {
1354             return null;
1355         }
1356     }
1357 
1358     /**
1359      * Gets the extension identified by the given ObjectIdentifier
1360      *
1361      * @param oid the Object Identifier value for the extension.
1362      * @return Extension or null if certificate does not contain this
1363      *         extension
1364      */
1365     public Extension getExtension(ObjectIdentifier oid) {
1366         if (info == null) {
1367             return null;
1368         }
1369         try {
1370             CertificateExtensions extensions;
1371             try {
1372                 extensions = (CertificateExtensions)info.get(CertificateExtensions.NAME);
1373             } catch (CertificateException ce) {
1374                 return null;
1375             }
1376             if (extensions == null) {
1377                 return null;
1378             } else {
1379                 Extension ex = extensions.getExtension(oid.toString());
1380                 if (ex != null) {
1381                     return ex;
1382                 }
1383                 for (Extension ex2: extensions.getAllExtensions()) {
1384                     if (ex2.getExtensionId().equals(oid)) {
1385                         //XXXX May want to consider cloning this
1386                         return ex2;
1387                     }
1388                 }
1389                 /* no such extension in this certificate */
1390                 return null;
1391             }
1392         } catch (IOException ioe) {
1393             return null;
1394         }
1395     }
1396 
1397     public Extension getUnparseableExtension(ObjectIdentifier oid) {
1398         if (info == null) {
1399             return null;
1400         }
1401         try {
1402             CertificateExtensions extensions;
1403             try {
1404                 extensions = (CertificateExtensions)info.get(CertificateExtensions.NAME);
1405             } catch (CertificateException ce) {
1406                 return null;
1407             }
1408             if (extensions == null) {
1409                 return null;
1410             } else {
1411                 return extensions.getUnparseableExtensions().get(oid.toString());
1412             }
1413         } catch (IOException ioe) {
1414             return null;
1415         }
1416     }
1417 
1418     /**
1419      * Gets the DER encoded extension identified by the given
1420      * oid String.
1421      *
1422      * @param oid the Object Identifier value for the extension.
1423      */
1424     public byte[] getExtensionValue(String oid) {
1425         try {
1426             ObjectIdentifier findOID = new ObjectIdentifier(oid);
1427             String extAlias = OIDMap.getName(findOID);
1428             Extension certExt = null;
1429             CertificateExtensions exts = (CertificateExtensions)info.get(
1430                                      CertificateExtensions.NAME);
1431 
1432             if (extAlias == null) { // may be unknown
1433                 // get the extensions, search thru&#39; for this oid
1434                 if (exts == null) {
1435                     return null;
1436                 }
1437 
1438                 for (Extension ex : exts.getAllExtensions()) {
1439                     ObjectIdentifier inCertOID = ex.getExtensionId();
1440                     if (inCertOID.equals(findOID)) {
1441                         certExt = ex;
1442                         break;
1443                     }
1444                 }
1445             } else { // there&#39;s sub-class that can handle this extension
1446                 try {
1447                     certExt = (Extension)this.get(extAlias);
1448                 } catch (CertificateException e) {
1449                     // get() throws an Exception instead of returning null, ignore
1450                 }
1451             }
1452             if (certExt == null) {
1453                 if (exts != null) {
1454                     certExt = exts.getUnparseableExtensions().get(oid);
1455                 }
1456                 if (certExt == null) {
1457                     return null;
1458                 }
1459             }
1460             byte[] extData = certExt.getExtensionValue();
1461             if (extData == null) {
1462                 return null;
1463             }
1464             DerOutputStream out = new DerOutputStream();
1465             out.putOctetString(extData);
1466             return out.toByteArray();
1467         } catch (Exception e) {
1468             return null;
1469         }
1470     }
1471 
1472     /**
1473      * Get a boolean array representing the bits of the KeyUsage extension,
1474      * (oid = 2.5.29.15).
1475      * @return the bit values of this extension as an array of booleans.
1476      */
1477     public boolean[] getKeyUsage() {
1478         try {
1479             String extAlias = OIDMap.getName(PKIXExtensions.KeyUsage_Id);
1480             if (extAlias == null)
1481                 return null;
1482 
1483             KeyUsageExtension certExt = (KeyUsageExtension)this.get(extAlias);
1484             if (certExt == null)
1485                 return null;
1486 
1487             boolean[] ret = certExt.getBits();
1488             if (ret.length &lt; NUM_STANDARD_KEY_USAGE) {
1489                 boolean[] usageBits = new boolean[NUM_STANDARD_KEY_USAGE];
1490                 System.arraycopy(ret, 0, usageBits, 0, ret.length);
1491                 ret = usageBits;
1492             }
1493             return ret;
1494         } catch (Exception e) {
1495             return null;
1496         }
1497     }
1498 
1499     /**
1500      * This method are the overridden implementation of
1501      * getExtendedKeyUsage method in X509Certificate in the Sun
1502      * provider. It is better performance-wise since it returns cached
1503      * values.
1504      */
1505     public synchronized List&lt;String&gt; getExtendedKeyUsage()
1506         throws CertificateParsingException {
1507         if (readOnly &amp;&amp; extKeyUsage != null) {
1508             return extKeyUsage;
1509         } else {
1510             ExtendedKeyUsageExtension ext = getExtendedKeyUsageExtension();
1511             if (ext == null) {
1512                 return null;
1513             }
1514             extKeyUsage =
1515                 Collections.unmodifiableList(ext.getExtendedKeyUsage());
1516             return extKeyUsage;
1517         }
1518     }
1519 
1520     /**
1521      * This static method is the default implementation of the
1522      * getExtendedKeyUsage method in X509Certificate. A
1523      * X509Certificate provider generally should overwrite this to
1524      * provide among other things caching for better performance.
1525      */
1526     public static List&lt;String&gt; getExtendedKeyUsage(X509Certificate cert)
1527         throws CertificateParsingException {
1528         try {
1529             byte[] ext = cert.getExtensionValue(EXTENDED_KEY_USAGE_OID);
1530             if (ext == null)
1531                 return null;
1532             DerValue val = new DerValue(ext);
1533             byte[] data = val.getOctetString();
1534 
1535             ExtendedKeyUsageExtension ekuExt =
1536                 new ExtendedKeyUsageExtension(Boolean.FALSE, data);
1537             return Collections.unmodifiableList(ekuExt.getExtendedKeyUsage());
1538         } catch (IOException ioe) {
1539             throw new CertificateParsingException(ioe);
1540         }
1541     }
1542 
1543     /**
1544      * Get the certificate constraints path length from
1545      * the critical BasicConstraints extension, (oid = 2.5.29.19).
1546      * @return the length of the constraint.
1547      */
1548     public int getBasicConstraints() {
1549         try {
1550             String extAlias = OIDMap.getName(PKIXExtensions.BasicConstraints_Id);
1551             if (extAlias == null)
1552                 return -1;
1553             BasicConstraintsExtension certExt =
1554                         (BasicConstraintsExtension)this.get(extAlias);
1555             if (certExt == null)
1556                 return -1;
1557 
1558             if (((Boolean)certExt.get(BasicConstraintsExtension.IS_CA)
1559                  ).booleanValue() == true)
1560                 return ((Integer)certExt.get(
1561                         BasicConstraintsExtension.PATH_LEN)).intValue();
1562             else
1563                 return -1;
1564         } catch (Exception e) {
1565             return -1;
1566         }
1567     }
1568 
1569     /**
1570      * Converts a GeneralNames structure into an immutable Collection of
1571      * alternative names (subject or issuer) in the form required by
1572      * {@link #getSubjectAlternativeNames} or
1573      * {@link #getIssuerAlternativeNames}.
1574      *
1575      * @param names the GeneralNames to be converted
1576      * @return an immutable Collection of alternative names
1577      */
1578     private static Collection&lt;List&lt;?&gt;&gt; makeAltNames(GeneralNames names) {
1579         if (names.isEmpty()) {
1580             return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1581         }
1582         List&lt;List&lt;?&gt;&gt; newNames = new ArrayList&lt;&gt;();
1583         for (GeneralName gname : names.names()) {
1584             GeneralNameInterface name = gname.getName();
1585             List&lt;Object&gt; nameEntry = new ArrayList&lt;&gt;(2);
1586             nameEntry.add(Integer.valueOf(name.getType()));
1587             switch (name.getType()) {
1588             case GeneralNameInterface.NAME_RFC822:
1589                 nameEntry.add(((RFC822Name) name).getName());
1590                 break;
1591             case GeneralNameInterface.NAME_DNS:
1592                 nameEntry.add(((DNSName) name).getName());
1593                 break;
1594             case GeneralNameInterface.NAME_DIRECTORY:
1595                 nameEntry.add(((X500Name) name).getRFC2253Name());
1596                 break;
1597             case GeneralNameInterface.NAME_URI:
1598                 nameEntry.add(((URIName) name).getName());
1599                 break;
1600             case GeneralNameInterface.NAME_IP:
1601                 try {
1602                     nameEntry.add(((IPAddressName) name).getName());
1603                 } catch (IOException ioe) {
1604                     // IPAddressName in cert is bogus
1605                     throw new RuntimeException(&quot;IPAddress cannot be parsed&quot;,
1606                         ioe);
1607                 }
1608                 break;
1609             case GeneralNameInterface.NAME_OID:
1610                 nameEntry.add(((OIDName) name).getOID().toString());
1611                 break;
1612             default:
1613                 // add DER encoded form
1614                 DerOutputStream derOut = new DerOutputStream();
1615                 try {
1616                     name.encode(derOut);
1617                 } catch (IOException ioe) {
1618                     // should not occur since name has already been decoded
1619                     // from cert (this would indicate a bug in our code)
1620                     throw new RuntimeException(&quot;name cannot be encoded&quot;, ioe);
1621                 }
1622                 nameEntry.add(derOut.toByteArray());
1623                 break;
1624             }
1625             newNames.add(Collections.unmodifiableList(nameEntry));
1626         }
1627         return Collections.unmodifiableCollection(newNames);
1628     }
1629 
1630     /**
1631      * Checks a Collection of altNames and clones any name entries of type
1632      * byte [].
1633      */ // only partially generified due to javac bug
1634     private static Collection&lt;List&lt;?&gt;&gt; cloneAltNames(Collection&lt;List&lt;?&gt;&gt; altNames) {
1635         boolean mustClone = false;
1636         for (List&lt;?&gt; nameEntry : altNames) {
1637             if (nameEntry.get(1) instanceof byte[]) {
1638                 // must clone names
1639                 mustClone = true;
1640             }
1641         }
1642         if (mustClone) {
1643             List&lt;List&lt;?&gt;&gt; namesCopy = new ArrayList&lt;&gt;();
1644             for (List&lt;?&gt; nameEntry : altNames) {
1645                 Object nameObject = nameEntry.get(1);
1646                 if (nameObject instanceof byte[]) {
1647                     List&lt;Object&gt; nameEntryCopy =
1648                                         new ArrayList&lt;&gt;(nameEntry);
1649                     nameEntryCopy.set(1, ((byte[])nameObject).clone());
1650                     namesCopy.add(Collections.unmodifiableList(nameEntryCopy));
1651                 } else {
1652                     namesCopy.add(nameEntry);
1653                 }
1654             }
1655             return Collections.unmodifiableCollection(namesCopy);
1656         } else {
1657             return altNames;
1658         }
1659     }
1660 
1661     /**
1662      * This method are the overridden implementation of
1663      * getSubjectAlternativeNames method in X509Certificate in the Sun
1664      * provider. It is better performance-wise since it returns cached
1665      * values.
1666      */
1667     public synchronized Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames()
1668         throws CertificateParsingException {
1669         // return cached value if we can
1670         if (readOnly &amp;&amp; subjectAlternativeNames != null)  {
1671             return cloneAltNames(subjectAlternativeNames);
1672         }
1673         SubjectAlternativeNameExtension subjectAltNameExt =
1674             getSubjectAlternativeNameExtension();
1675         if (subjectAltNameExt == null) {
1676             return null;
1677         }
1678         GeneralNames names;
1679         try {
1680             names = subjectAltNameExt.get(
1681                     SubjectAlternativeNameExtension.SUBJECT_NAME);
1682         } catch (IOException ioe) {
1683             // should not occur
1684             return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1685         }
1686         subjectAlternativeNames = makeAltNames(names);
1687         return subjectAlternativeNames;
1688     }
1689 
1690     /**
1691      * This static method is the default implementation of the
1692      * getSubjectAlternaitveNames method in X509Certificate. A
1693      * X509Certificate provider generally should overwrite this to
1694      * provide among other things caching for better performance.
1695      */
1696     public static Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames(X509Certificate cert)
1697         throws CertificateParsingException {
1698         try {
1699             byte[] ext = cert.getExtensionValue(SUBJECT_ALT_NAME_OID);
1700             if (ext == null) {
1701                 return null;
1702             }
1703             DerValue val = new DerValue(ext);
1704             byte[] data = val.getOctetString();
1705 
1706             SubjectAlternativeNameExtension subjectAltNameExt =
1707                 new SubjectAlternativeNameExtension(Boolean.FALSE,
1708                                                     data);
1709 
1710             GeneralNames names;
1711             try {
1712                 names = subjectAltNameExt.get(
1713                         SubjectAlternativeNameExtension.SUBJECT_NAME);
1714             }  catch (IOException ioe) {
1715                 // should not occur
1716                 return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1717             }
1718             return makeAltNames(names);
1719         } catch (IOException ioe) {
1720             throw new CertificateParsingException(ioe);
1721         }
1722     }
1723 
1724     /**
1725      * This method are the overridden implementation of
1726      * getIssuerAlternativeNames method in X509Certificate in the Sun
1727      * provider. It is better performance-wise since it returns cached
1728      * values.
1729      */
1730     public synchronized Collection&lt;List&lt;?&gt;&gt; getIssuerAlternativeNames()
1731         throws CertificateParsingException {
1732         // return cached value if we can
1733         if (readOnly &amp;&amp; issuerAlternativeNames != null) {
1734             return cloneAltNames(issuerAlternativeNames);
1735         }
1736         IssuerAlternativeNameExtension issuerAltNameExt =
1737             getIssuerAlternativeNameExtension();
1738         if (issuerAltNameExt == null) {
1739             return null;
1740         }
1741         GeneralNames names;
1742         try {
1743             names = issuerAltNameExt.get(
1744                     IssuerAlternativeNameExtension.ISSUER_NAME);
1745         } catch (IOException ioe) {
1746             // should not occur
1747             return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1748         }
1749         issuerAlternativeNames = makeAltNames(names);
1750         return issuerAlternativeNames;
1751     }
1752 
1753     /**
1754      * This static method is the default implementation of the
1755      * getIssuerAlternaitveNames method in X509Certificate. A
1756      * X509Certificate provider generally should overwrite this to
1757      * provide among other things caching for better performance.
1758      */
1759     public static Collection&lt;List&lt;?&gt;&gt; getIssuerAlternativeNames(X509Certificate cert)
1760         throws CertificateParsingException {
1761         try {
1762             byte[] ext = cert.getExtensionValue(ISSUER_ALT_NAME_OID);
1763             if (ext == null) {
1764                 return null;
1765             }
1766 
1767             DerValue val = new DerValue(ext);
1768             byte[] data = val.getOctetString();
1769 
1770             IssuerAlternativeNameExtension issuerAltNameExt =
1771                 new IssuerAlternativeNameExtension(Boolean.FALSE,
1772                                                     data);
1773             GeneralNames names;
1774             try {
1775                 names = issuerAltNameExt.get(
1776                         IssuerAlternativeNameExtension.ISSUER_NAME);
1777             }  catch (IOException ioe) {
1778                 // should not occur
1779                 return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1780             }
1781             return makeAltNames(names);
1782         } catch (IOException ioe) {
1783             throw new CertificateParsingException(ioe);
1784         }
1785     }
1786 
1787     public AuthorityInfoAccessExtension getAuthorityInfoAccessExtension() {
1788         return (AuthorityInfoAccessExtension)
1789             getExtension(PKIXExtensions.AuthInfoAccess_Id);
1790     }
1791 
1792     /************************************************************/
1793 
1794     /*
1795      * Cert is a SIGNED ASN.1 macro, a three elment sequence:
1796      *
1797      *  - Data to be signed (ToBeSigned) -- the &quot;raw&quot; cert
1798      *  - Signature algorithm (SigAlgId)
1799      *  - The signature bits
1800      *
1801      * This routine unmarshals the certificate, saving the signature
1802      * parts away for later verification.
1803      */
1804     private void parse(DerValue val)
1805     throws CertificateException, IOException {
1806         // check if can over write the certificate
1807         if (readOnly)
1808             throw new CertificateParsingException(
1809                       &quot;cannot over-write existing certificate&quot;);
1810 
1811         if (val.data == null || val.tag != DerValue.tag_Sequence)
1812             throw new CertificateParsingException(
1813                       &quot;invalid DER-encoded certificate data&quot;);
1814 
1815         signedCert = val.toByteArray();
1816         DerValue[] seq = new DerValue[3];
1817 
1818         seq[0] = val.data.getDerValue();
1819         seq[1] = val.data.getDerValue();
1820         seq[2] = val.data.getDerValue();
1821 
1822         if (val.data.available() != 0) {
1823             throw new CertificateParsingException(&quot;signed overrun, bytes = &quot;
1824                                      + val.data.available());
1825         }
1826         if (seq[0].tag != DerValue.tag_Sequence) {
1827             throw new CertificateParsingException(&quot;signed fields invalid&quot;);
1828         }
1829 
1830         algId = AlgorithmId.parse(seq[1]);
1831         signature = seq[2].getBitString();
1832 
1833         if (seq[1].data.available() != 0) {
1834             throw new CertificateParsingException(&quot;algid field overrun&quot;);
1835         }
1836         if (seq[2].data.available() != 0)
1837             throw new CertificateParsingException(&quot;signed fields overrun&quot;);
1838 
1839         // The CertificateInfo
1840         info = new X509CertInfo(seq[0]);
1841 
1842         // the &quot;inner&quot; and &quot;outer&quot; signature algorithms must match
1843         AlgorithmId infoSigAlg = (AlgorithmId)info.get(
1844                                               CertificateAlgorithmId.NAME
1845                                               + DOT +
1846                                               CertificateAlgorithmId.ALGORITHM);
1847         if (! algId.equals(infoSigAlg))
1848             throw new CertificateException(&quot;Signature algorithm mismatch&quot;);
1849         readOnly = true;
1850     }
1851 
1852     /**
1853      * Extract the subject or issuer X500Principal from an X509Certificate.
1854      * Parses the encoded form of the cert to preserve the principal&#39;s
1855      * ASN.1 encoding.
1856      */
1857     private static X500Principal getX500Principal(X509Certificate cert,
1858             boolean getIssuer) throws Exception {
1859         byte[] encoded = cert.getEncoded();
1860         DerInputStream derIn = new DerInputStream(encoded);
1861         DerValue tbsCert = derIn.getSequence(3)[0];
1862         DerInputStream tbsIn = tbsCert.data;
1863         DerValue tmp;
1864         tmp = tbsIn.getDerValue();
1865         // skip version number if present
1866         if (tmp.isContextSpecific((byte)0)) {
1867           tmp = tbsIn.getDerValue();
1868         }
1869         // tmp always contains serial number now
1870         tmp = tbsIn.getDerValue();              // skip signature
1871         tmp = tbsIn.getDerValue();              // issuer
1872         if (getIssuer == false) {
1873             tmp = tbsIn.getDerValue();          // skip validity
1874             tmp = tbsIn.getDerValue();          // subject
1875         }
1876         byte[] principalBytes = tmp.toByteArray();
1877         return new X500Principal(principalBytes);
1878     }
1879 
1880     /**
1881      * Extract the subject X500Principal from an X509Certificate.
1882      * Called from java.security.cert.X509Certificate.getSubjectX500Principal().
1883      */
1884     public static X500Principal getSubjectX500Principal(X509Certificate cert) {
1885         try {
1886             return getX500Principal(cert, false);
1887         } catch (Exception e) {
1888             throw new RuntimeException(&quot;Could not parse subject&quot;, e);
1889         }
1890     }
1891 
1892     /**
1893      * Extract the issuer X500Principal from an X509Certificate.
1894      * Called from java.security.cert.X509Certificate.getIssuerX500Principal().
1895      */
1896     public static X500Principal getIssuerX500Principal(X509Certificate cert) {
1897         try {
1898             return getX500Principal(cert, true);
1899         } catch (Exception e) {
1900             throw new RuntimeException(&quot;Could not parse issuer&quot;, e);
1901         }
1902     }
1903 
1904     /**
1905      * Returned the encoding of the given certificate for internal use.
1906      * Callers must guarantee that they neither modify it nor expose it
1907      * to untrusted code. Uses getEncodedInternal() if the certificate
1908      * is instance of X509CertImpl, getEncoded() otherwise.
1909      */
1910     public static byte[] getEncodedInternal(Certificate cert)
1911             throws CertificateEncodingException {
1912         if (cert instanceof X509CertImpl) {
1913             return ((X509CertImpl)cert).getEncodedInternal();
1914         } else {
1915             return cert.getEncoded();
1916         }
1917     }
1918 
1919     /**
1920      * Utility method to convert an arbitrary instance of X509Certificate
1921      * to a X509CertImpl. Does a cast if possible, otherwise reparses
1922      * the encoding.
1923      */
1924     public static X509CertImpl toImpl(X509Certificate cert)
1925             throws CertificateException {
1926         if (cert instanceof X509CertImpl) {
1927             return (X509CertImpl)cert;
1928         } else {
1929             return X509Factory.intern(cert);
1930         }
1931     }
1932 
1933     /**
1934      * Utility method to test if a certificate is self-issued. This is
1935      * the case iff the subject and issuer X500Principals are equal.
1936      */
1937     public static boolean isSelfIssued(X509Certificate cert) {
1938         X500Principal subject = cert.getSubjectX500Principal();
1939         X500Principal issuer = cert.getIssuerX500Principal();
1940         return subject.equals(issuer);
1941     }
1942 
1943     /**
1944      * Utility method to test if a certificate is self-signed. This is
1945      * the case iff the subject and issuer X500Principals are equal
1946      * AND the certificate&#39;s subject public key can be used to verify
1947      * the certificate. In case of exception, returns false.
1948      */
1949     public static boolean isSelfSigned(X509Certificate cert,
1950         String sigProvider) {
1951         if (isSelfIssued(cert)) {
1952             try {
1953                 if (sigProvider == null) {
1954                     cert.verify(cert.getPublicKey());
1955                 } else {
1956                     cert.verify(cert.getPublicKey(), sigProvider);
1957                 }
1958                 return true;
1959             } catch (Exception e) {
1960                 // In case of exception, return false
1961             }
1962         }
1963         return false;
1964     }
1965 
1966     private ConcurrentHashMap&lt;String,String&gt; fingerprints =
1967             new ConcurrentHashMap&lt;&gt;(2);
1968 
1969     public String getFingerprint(String algorithm) {
1970         return fingerprints.computeIfAbsent(algorithm,
1971             x -&gt; getFingerprint(x, this));
1972     }
1973 
1974     /**
1975      * Gets the requested finger print of the certificate. The result
1976      * only contains 0-9 and A-F. No small case, no colon.
1977      */
1978     public static String getFingerprint(String algorithm,
1979             X509Certificate cert) {
1980         try {
1981             byte[] encCertInfo = cert.getEncoded();
1982             MessageDigest md = MessageDigest.getInstance(algorithm);
1983             byte[] digest = md.digest(encCertInfo);
1984             StringBuilder sb = new StringBuilder(digest.length * 2);
1985             for (int i = 0; i &lt; digest.length; i++) {
1986                 byte2hex(digest[i], sb);
1987             }
1988             return sb.toString();
1989         } catch (NoSuchAlgorithmException | CertificateEncodingException e) {
1990             // ignored
1991         }
1992         return &quot;&quot;;
1993     }
1994 
1995     /**
1996      * Converts a byte to hex digit and writes to the supplied builder
1997      */
1998     private static void byte2hex(byte b, StringBuilder buf) {
1999         char[] hexChars = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,
2000                 &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; };
2001         int high = ((b &amp; 0xf0) &gt;&gt; 4);
2002         int low = (b &amp; 0x0f);
2003         buf.append(hexChars[high])
2004             .append(hexChars[low]);
2005     }
2006 }
    </pre>
  </body>
</html>
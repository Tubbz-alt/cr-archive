diff a/src/java.base/share/classes/sun/security/provider/SHA3.java b/src/java.base/share/classes/sun/security/provider/SHA3.java
--- a/src/java.base/share/classes/sun/security/provider/SHA3.java
+++ b/src/java.base/share/classes/sun/security/provider/SHA3.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -59,18 +59,20 @@
         0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,
         0x800aL, 0x800000008000000aL, 0x8000000080008081L,
         0x8000000000008080L, 0x80000001L, 0x8000000080008008L,
     };
 
+    private final byte suffix;
     private byte[] state = new byte[WIDTH];
     private long[] lanes = new long[DM*DM];
 
     /**
      * Creates a new SHA-3 object.
      */
-    SHA3(String name, int digestLength) {
-        super(name, digestLength, (WIDTH - (2 * digestLength)));
+    SHA3(String name, int digestLength, byte suffix, int c) {
+        super(name, digestLength, (WIDTH - c));
+        this.suffix = suffix;
     }
 
     /**
      * Core compression function. Processes blockSize bytes at a time
      * and updates the state of this object.
@@ -86,11 +88,11 @@
      * Return the digest. Subclasses do not need to reset() themselves,
      * DigestBase calls implReset() when necessary.
      */
     void implDigest(byte[] out, int ofs) {
         int numOfPadding =
-            setPaddingBytes(buffer, (int)(bytesProcessed % buffer.length));
+            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % buffer.length));
         if (numOfPadding < 1) {
             throw new ProviderException("Incorrect pad size: " + numOfPadding);
         }
         for (int i = 0; i < buffer.length; i++) {
             state[i] ^= buffer[i];
@@ -110,17 +112,17 @@
     /**
      * Utility function for padding the specified data based on the
      * pad10*1 algorithm (section 5.1) and the 2-bit suffix "01" required
      * for SHA-3 hash (section 6.1).
      */
-    private static int setPaddingBytes(byte[] in, int len) {
+    private static int setPaddingBytes(byte suffix, byte[] in, int len) {
         if (len != in.length) {
             // erase leftover values
             Arrays.fill(in, len, in.length, (byte)0);
             // directly store the padding bytes into the input
             // as the specified buffer is allocated w/ size = rateR
-            in[len] |= (byte) 0x06;
+            in[len] |= suffix;
             in[in.length - 1] |= (byte) 0x80;
         }
         return (in.length - len);
     }
 
@@ -266,36 +268,36 @@
     /**
      * SHA3-224 implementation class.
      */
     public static final class SHA224 extends SHA3 {
         public SHA224() {
-            super("SHA3-224", 28);
+            super("SHA3-224", 28, (byte)0x06, 56);
         }
     }
 
     /**
      * SHA3-256 implementation class.
      */
     public static final class SHA256 extends SHA3 {
         public SHA256() {
-            super("SHA3-256", 32);
+            super("SHA3-256", 32, (byte)0x06, 64);
         }
     }
 
     /**
      * SHAs-384 implementation class.
      */
     public static final class SHA384 extends SHA3 {
         public SHA384() {
-            super("SHA3-384", 48);
+            super("SHA3-384", 48, (byte)0x06, 96);
         }
     }
 
     /**
      * SHA3-512 implementation class.
      */
     public static final class SHA512 extends SHA3 {
         public SHA512() {
-            super("SHA3-512", 64);
+            super("SHA3-512", 64, (byte)0x06, 128);
         }
     }
 }

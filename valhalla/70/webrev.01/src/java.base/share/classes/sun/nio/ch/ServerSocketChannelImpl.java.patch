diff a/src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java b/src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java
--- a/src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java
+++ b/src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java
@@ -26,14 +26,16 @@
 package sun.nio.ch;
 
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.net.InetSocketAddress;
+import java.net.ProtocolFamily;
 import java.net.ServerSocket;
 import java.net.SocketAddress;
 import java.net.SocketOption;
 import java.net.SocketTimeoutException;
+import java.net.StandardProtocolFamily;
 import java.net.StandardSocketOptions;
 import java.nio.channels.AlreadyBoundException;
 import java.nio.channels.AsynchronousCloseException;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.IllegalBlockingModeException;
@@ -60,10 +62,13 @@
     implements SelChImpl
 {
     // Used to make native close and configure calls
     private static final NativeDispatcher nd = new SocketDispatcher();
 
+    // The protocol family of the socket
+    private final ProtocolFamily family;
+
     // Our file descriptor
     private final FileDescriptor fd;
     private final int fdVal;
 
     // Lock held by thread currently blocked on this channel
@@ -93,23 +98,44 @@
     // Our socket adaptor, if any
     private ServerSocket socket;
 
     // -- End of fields protected by stateLock
 
-
     ServerSocketChannelImpl(SelectorProvider sp) {
+        this(sp, Net.isIPv6Available()
+                ? StandardProtocolFamily.INET6
+                : StandardProtocolFamily.INET);
+    }
+
+    ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family) {
         super(sp);
-        this.fd = Net.serverSocket(true);
+        Objects.requireNonNull(family, "'family' is null");
+
+        if ((family != StandardProtocolFamily.INET) &&
+                (family != StandardProtocolFamily.INET6)) {
+            throw new UnsupportedOperationException("Protocol family not supported");
+        }
+        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {
+            throw new UnsupportedOperationException("IPv6 not available");
+        }
+
+        this.family = family;
+        this.fd = Net.serverSocket(family, true);
         this.fdVal = IOUtil.fdVal(fd);
     }
 
     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
         throws IOException
     {
         super(sp);
+
+        this.family = Net.isIPv6Available()
+                ? StandardProtocolFamily.INET6
+                : StandardProtocolFamily.INET;
         this.fd =  fd;
         this.fdVal = IOUtil.fdVal(fd);
+
         if (bound) {
             synchronized (stateLock) {
                 localAddress = Net.localAddress(fd);
             }
         }
@@ -208,18 +234,21 @@
     public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
         synchronized (stateLock) {
             ensureOpen();
             if (localAddress != null)
                 throw new AlreadyBoundException();
-            InetSocketAddress isa = (local == null)
-                                    ? new InetSocketAddress(0)
-                                    : Net.checkAddress(local);
+            InetSocketAddress isa;
+            if (local == null) {
+                isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);
+            } else {
+                isa = Net.checkAddress(local, family);
+            }
             SecurityManager sm = System.getSecurityManager();
             if (sm != null)
                 sm.checkListen(isa.getPort());
             NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
-            Net.bind(fd, isa.getAddress(), isa.getPort());
+            Net.bind(family, fd, isa.getAddress(), isa.getPort());
             Net.listen(fd, backlog < 1 ? 50 : backlog);
             localAddress = Net.localAddress(fd);
         }
         return this;
     }
@@ -356,11 +385,11 @@
             // check permitted to accept connections from the remote address
             SecurityManager sm = System.getSecurityManager();
             if (sm != null) {
                 sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());
             }
-            return new SocketChannelImpl(provider(), newfd, isa);
+            return new SocketChannelImpl(provider(), family, newfd, isa);
         } catch (Exception e) {
             nd.close(newfd);
             throw e;
         }
     }

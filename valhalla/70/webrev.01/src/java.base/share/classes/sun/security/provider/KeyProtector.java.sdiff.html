<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/provider/KeyProtector.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../pkcs12/PKCS12KeyStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SHA3.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/provider/KeyProtector.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.io.IOException;
 29 import java.security.Key;
 30 import java.security.KeyStoreException;
 31 import java.security.MessageDigest;
 32 import java.security.NoSuchAlgorithmException;
 33 import java.security.SecureRandom;
 34 import java.security.UnrecoverableKeyException;
 35 import java.util.*;
 36 
 37 import sun.security.pkcs.PKCS8Key;
 38 import sun.security.pkcs.EncryptedPrivateKeyInfo;
 39 import sun.security.x509.AlgorithmId;
 40 import sun.security.util.ObjectIdentifier;

 41 import sun.security.util.DerValue;
 42 
 43 /**
 44  * This is an implementation of a Sun proprietary, exportable algorithm
 45  * intended for use when protecting (or recovering the cleartext version of)
 46  * sensitive keys.
 47  * This algorithm is not intended as a general purpose cipher.
 48  *
 49  * This is how the algorithm works for key protection:
 50  *
 51  * p - user password
 52  * s - random salt
 53  * X - xor key
 54  * P - to-be-protected key
 55  * Y - protected key
 56  * R - what gets stored in the keystore
 57  *
 58  * Step 1:
 59  * Take the user&#39;s password, append a random salt (of fixed size) to it,
 60  * and hash it: d1 = digest(p, s)
</pre>
<hr />
<pre>
 88  * Then concatenate the password with the recovered key, and compare with the
 89  * last length(digest(p, P)) bytes of R. If they match, the recovered key is
 90  * indeed the same key as the original key.
 91  *
 92  * @author Jan Luehe
 93  *
 94  *
 95  * @see java.security.KeyStore
 96  * @see JavaKeyStore
 97  * @see KeyTool
 98  *
 99  * @since 1.2
100  */
101 
102 final class KeyProtector {
103 
104     private static final int SALT_LEN = 20; // the salt length
105     private static final String DIGEST_ALG = &quot;SHA&quot;;
106     private static final int DIGEST_LEN = 20;
107 
<span class="line-removed">108     // defined by JavaSoft</span>
<span class="line-removed">109     private static final String KEY_PROTECTOR_OID = &quot;1.3.6.1.4.1.42.2.17.1.1&quot;;</span>
<span class="line-removed">110 </span>
111     // The password used for protecting/recovering keys passed through this
112     // key protector. We store it as a byte array, so that we can digest it.
113     private byte[] passwdBytes;
114 
115     private MessageDigest md;
116 
117 
118     /**
119      * Creates an instance of this class, and initializes it with the given
120      * password.
121      */
122     public KeyProtector(byte[] passwordBytes)
123         throws NoSuchAlgorithmException
124     {
125         if (passwordBytes == null) {
126            throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
127         }
128         md = MessageDigest.getInstance(DIGEST_ALG);
129         this.passwdBytes = passwordBytes;
130     }
</pre>
<hr />
<pre>
196         // Store salt and &quot;tmpKey&quot; in &quot;encrKey&quot;
197         byte[] encrKey = new byte[salt.length + tmpKey.length + DIGEST_LEN];
198         System.arraycopy(salt, 0, encrKey, encrKeyOffset, salt.length);
199         encrKeyOffset += salt.length;
200         System.arraycopy(tmpKey, 0, encrKey, encrKeyOffset, tmpKey.length);
201         encrKeyOffset += tmpKey.length;
202 
203         // Append digest(password, plainKey) as an integrity check to &quot;encrKey&quot;
204         md.update(passwdBytes);
205         Arrays.fill(passwdBytes, (byte)0x00);
206         passwdBytes = null;
207         md.update(plainKey);
208         digest = md.digest();
209         md.reset();
210         System.arraycopy(digest, 0, encrKey, encrKeyOffset, digest.length);
211 
212         // wrap the protected private key in a PKCS#8-style
213         // EncryptedPrivateKeyInfo, and returns its encoding
214         AlgorithmId encrAlg;
215         try {
<span class="line-modified">216             encrAlg = new AlgorithmId(new ObjectIdentifier(KEY_PROTECTOR_OID));</span>

217             return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();
218         } catch (IOException ioe) {
219             throw new KeyStoreException(ioe.getMessage());
220         }
221     }
222 
223     /*
224      * Recovers the plaintext version of the given key (in protected format),
225      * using the password provided at construction time.
226      */
227     public Key recover(EncryptedPrivateKeyInfo encrInfo)
228         throws UnrecoverableKeyException
229     {
230         int i;
231         byte[] digest;
232         int numRounds;
233         int xorOffset; // offset in xorKey where next digest will be stored
234         int encrKeyLen; // the length of the encrpyted key
235 
236         // do we support the algorithm?
237         AlgorithmId encrAlg = encrInfo.getAlgorithm();
<span class="line-modified">238         if (!(encrAlg.getOID().toString().equals(KEY_PROTECTOR_OID))) {</span>

239             throw new UnrecoverableKeyException(&quot;Unsupported key protection &quot;
240                                                 + &quot;algorithm&quot;);
241         }
242 
243         byte[] protectedKey = encrInfo.getEncryptedData();
244 
245         /*
246          * Get the salt associated with this key (the first SALT_LEN bytes of
247          * &lt;code&gt;protectedKey&lt;/code&gt;)
248          */
249         byte[] salt = new byte[SALT_LEN];
250         System.arraycopy(protectedKey, 0, salt, 0, SALT_LEN);
251 
252         // Determine the number of digest rounds
253         encrKeyLen = protectedKey.length - SALT_LEN - DIGEST_LEN;
254         numRounds = encrKeyLen / DIGEST_LEN;
255         if ((encrKeyLen % DIGEST_LEN) != 0) numRounds++;
256 
257         // Get the encrypted key portion and store it in &quot;encrKey&quot;
258         byte[] encrKey = new byte[encrKeyLen];
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.io.IOException;
 29 import java.security.Key;
 30 import java.security.KeyStoreException;
 31 import java.security.MessageDigest;
 32 import java.security.NoSuchAlgorithmException;
 33 import java.security.SecureRandom;
 34 import java.security.UnrecoverableKeyException;
 35 import java.util.*;
 36 
 37 import sun.security.pkcs.PKCS8Key;
 38 import sun.security.pkcs.EncryptedPrivateKeyInfo;
 39 import sun.security.x509.AlgorithmId;
 40 import sun.security.util.ObjectIdentifier;
<span class="line-added"> 41 import sun.security.util.KnownOIDs;</span>
 42 import sun.security.util.DerValue;
 43 
 44 /**
 45  * This is an implementation of a Sun proprietary, exportable algorithm
 46  * intended for use when protecting (or recovering the cleartext version of)
 47  * sensitive keys.
 48  * This algorithm is not intended as a general purpose cipher.
 49  *
 50  * This is how the algorithm works for key protection:
 51  *
 52  * p - user password
 53  * s - random salt
 54  * X - xor key
 55  * P - to-be-protected key
 56  * Y - protected key
 57  * R - what gets stored in the keystore
 58  *
 59  * Step 1:
 60  * Take the user&#39;s password, append a random salt (of fixed size) to it,
 61  * and hash it: d1 = digest(p, s)
</pre>
<hr />
<pre>
 89  * Then concatenate the password with the recovered key, and compare with the
 90  * last length(digest(p, P)) bytes of R. If they match, the recovered key is
 91  * indeed the same key as the original key.
 92  *
 93  * @author Jan Luehe
 94  *
 95  *
 96  * @see java.security.KeyStore
 97  * @see JavaKeyStore
 98  * @see KeyTool
 99  *
100  * @since 1.2
101  */
102 
103 final class KeyProtector {
104 
105     private static final int SALT_LEN = 20; // the salt length
106     private static final String DIGEST_ALG = &quot;SHA&quot;;
107     private static final int DIGEST_LEN = 20;
108 



109     // The password used for protecting/recovering keys passed through this
110     // key protector. We store it as a byte array, so that we can digest it.
111     private byte[] passwdBytes;
112 
113     private MessageDigest md;
114 
115 
116     /**
117      * Creates an instance of this class, and initializes it with the given
118      * password.
119      */
120     public KeyProtector(byte[] passwordBytes)
121         throws NoSuchAlgorithmException
122     {
123         if (passwordBytes == null) {
124            throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
125         }
126         md = MessageDigest.getInstance(DIGEST_ALG);
127         this.passwdBytes = passwordBytes;
128     }
</pre>
<hr />
<pre>
194         // Store salt and &quot;tmpKey&quot; in &quot;encrKey&quot;
195         byte[] encrKey = new byte[salt.length + tmpKey.length + DIGEST_LEN];
196         System.arraycopy(salt, 0, encrKey, encrKeyOffset, salt.length);
197         encrKeyOffset += salt.length;
198         System.arraycopy(tmpKey, 0, encrKey, encrKeyOffset, tmpKey.length);
199         encrKeyOffset += tmpKey.length;
200 
201         // Append digest(password, plainKey) as an integrity check to &quot;encrKey&quot;
202         md.update(passwdBytes);
203         Arrays.fill(passwdBytes, (byte)0x00);
204         passwdBytes = null;
205         md.update(plainKey);
206         digest = md.digest();
207         md.reset();
208         System.arraycopy(digest, 0, encrKey, encrKeyOffset, digest.length);
209 
210         // wrap the protected private key in a PKCS#8-style
211         // EncryptedPrivateKeyInfo, and returns its encoding
212         AlgorithmId encrAlg;
213         try {
<span class="line-modified">214             encrAlg = new AlgorithmId(ObjectIdentifier.of</span>
<span class="line-added">215                     (KnownOIDs.JAVASOFT_JDKKeyProtector));</span>
216             return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();
217         } catch (IOException ioe) {
218             throw new KeyStoreException(ioe.getMessage());
219         }
220     }
221 
222     /*
223      * Recovers the plaintext version of the given key (in protected format),
224      * using the password provided at construction time.
225      */
226     public Key recover(EncryptedPrivateKeyInfo encrInfo)
227         throws UnrecoverableKeyException
228     {
229         int i;
230         byte[] digest;
231         int numRounds;
232         int xorOffset; // offset in xorKey where next digest will be stored
233         int encrKeyLen; // the length of the encrpyted key
234 
235         // do we support the algorithm?
236         AlgorithmId encrAlg = encrInfo.getAlgorithm();
<span class="line-modified">237         if (!(encrAlg.getOID().toString().equals</span>
<span class="line-added">238                 (KnownOIDs.JAVASOFT_JDKKeyProtector.value()))) {</span>
239             throw new UnrecoverableKeyException(&quot;Unsupported key protection &quot;
240                                                 + &quot;algorithm&quot;);
241         }
242 
243         byte[] protectedKey = encrInfo.getEncryptedData();
244 
245         /*
246          * Get the salt associated with this key (the first SALT_LEN bytes of
247          * &lt;code&gt;protectedKey&lt;/code&gt;)
248          */
249         byte[] salt = new byte[SALT_LEN];
250         System.arraycopy(protectedKey, 0, salt, 0, SALT_LEN);
251 
252         // Determine the number of digest rounds
253         encrKeyLen = protectedKey.length - SALT_LEN - DIGEST_LEN;
254         numRounds = encrKeyLen / DIGEST_LEN;
255         if ((encrKeyLen % DIGEST_LEN) != 0) numRounds++;
256 
257         // Get the encrypted key portion and store it in &quot;encrKey&quot;
258         byte[] encrKey = new byte[encrKeyLen];
</pre>
</td>
</tr>
</table>
<center><a href="../pkcs12/PKCS12KeyStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SHA3.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
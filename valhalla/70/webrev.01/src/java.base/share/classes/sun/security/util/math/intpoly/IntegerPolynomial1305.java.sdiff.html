<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial1305.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntegerPolynomial.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerPolynomial25519.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial1305.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
139         result[1] = (low &gt;&gt;&gt; 26) &amp; 0x3FFFFFFL;
140         result[2] = (low &gt;&gt;&gt; 52) + ((high &amp; 0x3FFFL) &lt;&lt; 12);
141         result[3] = (high &gt;&gt;&gt; 14) &amp; 0x3FFFFFFL;
142         result[4] = (high &gt;&gt;&gt; 40) + (highByte &lt;&lt; 24L);
143     }
144 
145     private static final VarHandle AS_LONG_LE = MethodHandles
146         .byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN);
147 
148     protected void encode(byte[] v, int offset, int length, byte highByte,
149                           long[] result) {
150         if (length == 16) {
151             long low = (long) AS_LONG_LE.get(v, offset);
152             long high = (long) AS_LONG_LE.get(v, offset + 8);
153             encode(high, low, highByte, result);
154         } else {
155             super.encode(v, offset, length, highByte, result);
156         }
157     }
158 
<span class="line-modified">159     private void modReduceIn(long[] limbs, int index, long x) {</span>

160         // this only works when BITS_PER_LIMB * NUM_LIMBS = POWER exactly
161         long reducedValue = (x * SUBTRAHEND);
162         limbs[index - NUM_LIMBS] += reducedValue;
163     }
164 
165     @Override
166     protected void finalCarryReduceLast(long[] limbs) {
167         long carry = limbs[numLimbs - 1] &gt;&gt; bitsPerLimb;
168         limbs[numLimbs - 1] -= carry &lt;&lt; bitsPerLimb;
<span class="line-modified">169         modReduceIn(limbs, numLimbs, carry);</span>
170     }
171 
172     protected final void modReduce(long[] limbs, int start, int end) {
173 
174         for (int i = start; i &lt; end; i++) {
<span class="line-modified">175             modReduceIn(limbs, i, limbs[i]);</span>
176             limbs[i] = 0;
177         }
178     }
179 
180     protected void modReduce(long[] limbs) {
181 
182         modReduce(limbs, NUM_LIMBS, NUM_LIMBS - 1);
183     }
184 
185     @Override
186     protected long carryValue(long x) {
187         // This representation has plenty of extra space, so we can afford to
188         // do a simplified carry operation that is more time-efficient.
189 
190         return x &gt;&gt; BITS_PER_LIMB;
191     }
192 
193     @Override
194     protected void postEncodeCarry(long[] v) {
195         // not needed because carry is unsigned
196     }
197 
198     @Override
199     protected void reduce(long[] limbs) {
200         long carry3 = carryOut(limbs, 3);
201         long new4 = carry3 + limbs[4];
202 
203         long carry4 = carryValue(new4);
204         limbs[4] = new4 - (carry4 &lt;&lt; BITS_PER_LIMB);
205 
<span class="line-modified">206         modReduceIn(limbs, 5, carry4);</span>
207         carry(limbs);
208     }
209 
210 }
211 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
139         result[1] = (low &gt;&gt;&gt; 26) &amp; 0x3FFFFFFL;
140         result[2] = (low &gt;&gt;&gt; 52) + ((high &amp; 0x3FFFL) &lt;&lt; 12);
141         result[3] = (high &gt;&gt;&gt; 14) &amp; 0x3FFFFFFL;
142         result[4] = (high &gt;&gt;&gt; 40) + (highByte &lt;&lt; 24L);
143     }
144 
145     private static final VarHandle AS_LONG_LE = MethodHandles
146         .byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN);
147 
148     protected void encode(byte[] v, int offset, int length, byte highByte,
149                           long[] result) {
150         if (length == 16) {
151             long low = (long) AS_LONG_LE.get(v, offset);
152             long high = (long) AS_LONG_LE.get(v, offset + 8);
153             encode(high, low, highByte, result);
154         } else {
155             super.encode(v, offset, length, highByte, result);
156         }
157     }
158 
<span class="line-modified">159     @Override</span>
<span class="line-added">160     protected void reduceIn(long[] limbs, long x, int index) {</span>
161         // this only works when BITS_PER_LIMB * NUM_LIMBS = POWER exactly
162         long reducedValue = (x * SUBTRAHEND);
163         limbs[index - NUM_LIMBS] += reducedValue;
164     }
165 
166     @Override
167     protected void finalCarryReduceLast(long[] limbs) {
168         long carry = limbs[numLimbs - 1] &gt;&gt; bitsPerLimb;
169         limbs[numLimbs - 1] -= carry &lt;&lt; bitsPerLimb;
<span class="line-modified">170         reduceIn(limbs, carry, numLimbs);</span>
171     }
172 
173     protected final void modReduce(long[] limbs, int start, int end) {
174 
175         for (int i = start; i &lt; end; i++) {
<span class="line-modified">176             reduceIn(limbs, limbs[i], i);</span>
177             limbs[i] = 0;
178         }
179     }
180 
181     protected void modReduce(long[] limbs) {
182 
183         modReduce(limbs, NUM_LIMBS, NUM_LIMBS - 1);
184     }
185 
186     @Override
187     protected long carryValue(long x) {
188         // This representation has plenty of extra space, so we can afford to
189         // do a simplified carry operation that is more time-efficient.
190 
191         return x &gt;&gt; BITS_PER_LIMB;
192     }
193 
194     @Override
195     protected void postEncodeCarry(long[] v) {
196         // not needed because carry is unsigned
197     }
198 
199     @Override
200     protected void reduce(long[] limbs) {
201         long carry3 = carryOut(limbs, 3);
202         long new4 = carry3 + limbs[4];
203 
204         long carry4 = carryValue(new4);
205         limbs[4] = new4 - (carry4 &lt;&lt; BITS_PER_LIMB);
206 
<span class="line-modified">207         reduceIn(limbs, carry4, 5);</span>
208         carry(limbs);
209     }
210 
211 }
212 
</pre>
</td>
</tr>
</table>
<center><a href="IntegerPolynomial.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerPolynomial25519.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial.java b/src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial.java
--- a/src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial.java
+++ b/src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -155,16 +155,38 @@
 
     @Override
     public SmallValue getSmallValue(int value) {
         int maxMag = 1 << (bitsPerLimb - 1);
         if (Math.abs(value) >= maxMag) {
-            throw new IllegalArgumentException(
-                "max magnitude is " + maxMag);
+            throw new IllegalArgumentException("max magnitude is " + maxMag);
         }
         return new Limb(value);
     }
 
+    protected abstract void reduceIn(long[] c, long v, int i);
+
+    private void reduceHigh(long[] limbs) {
+
+        // conservatively calculate how many reduce operations can be done
+        // before a carry is needed
+        int extraBits = 63 - 2 * bitsPerLimb;
+        int allowedAdds = 1 << extraBits;
+        int carryPeriod = allowedAdds / numLimbs;
+        int reduceCount = 0;
+        for (int i = limbs.length - 1; i >= numLimbs; i--) {
+            reduceIn(limbs, limbs[i], i);
+            limbs[i] = 0;
+
+            reduceCount++;
+            if (reduceCount % carryPeriod == 0) {
+                carry(limbs, 0, i);
+                reduceIn(limbs, limbs[i], i);
+                limbs[i] = 0;
+            }
+        }
+    }
+
     /**
      * This version of encode takes a ByteBuffer that is properly ordered, and
      * may extract larger values (e.g. long) from the ByteBuffer for better
      * performance. The implementation below only extracts bytes from the
      * buffer, but this method may be overridden in field-specific
@@ -177,14 +199,16 @@
         int numBits = 8 * length + numHighBits;
         int requiredLimbs = (numBits + bitsPerLimb - 1) / bitsPerLimb;
         if (requiredLimbs > numLimbs) {
             long[] temp = new long[requiredLimbs];
             encodeSmall(buf, length, highByte, temp);
-            // encode does a full carry/reduce
+            reduceHigh(temp);
             System.arraycopy(temp, 0, result, 0, result.length);
+            reduce(result);
         } else {
             encodeSmall(buf, length, highByte, result);
+            postEncodeCarry(result);
         }
     }
 
     protected void encodeSmall(ByteBuffer buf, int length, byte highByte,
                                long[] result) {
@@ -224,12 +248,10 @@
 
         if (limbIndex < result.length) {
             result[limbIndex++] = curLimbValue;
         }
         Arrays.fill(result, limbIndex, result.length, 0);
-
-        postEncodeCarry(result);
     }
 
     protected void encode(byte[] v, int offset, int length, byte highByte,
                           long[] result) {
 

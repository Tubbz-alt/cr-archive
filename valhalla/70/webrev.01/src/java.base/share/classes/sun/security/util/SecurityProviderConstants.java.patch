diff a/src/java.base/share/classes/sun/security/util/SecurityProviderConstants.java b/src/java.base/share/classes/sun/security/util/SecurityProviderConstants.java
--- a/src/java.base/share/classes/sun/security/util/SecurityProviderConstants.java
+++ b/src/java.base/share/classes/sun/security/util/SecurityProviderConstants.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,24 +23,75 @@
  * questions.
  */
 
 package sun.security.util;
 
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.regex.PatternSyntaxException;
 import java.security.InvalidParameterException;
+import java.security.ProviderException;
 import sun.security.action.GetPropertyAction;
 
 /**
  * Various constants such as version number, default key length, used by
  * the JDK security/crypto providers.
  */
 public final class SecurityProviderConstants {
+    // Cannot create one of these
+    private SecurityProviderConstants () {}
+
     private static final Debug debug =
         Debug.getInstance("jca", "ProviderConfig");
 
-    // Cannot create one of these
-    private SecurityProviderConstants () {
+    // cache for provider aliases; key is the standard algorithm name
+    // value is the associated aliases List
+    private static final ConcurrentHashMap<String, List<String>> aliasesMap;
+
+    // utility method for generating aliases list using the supplied
+    // 'oid' and 'extraAliases', then store into "aliasesMap" cache under the
+    // key 'stdName'
+    private static List<String> store(String stdName, KnownOIDs oid,
+            String ... extraAliases) {
+        List<String> value;
+        if (oid == null && extraAliases.length != 0) {
+            value = List.of(extraAliases);
+        } else {
+            value = new ArrayList<>();
+            if (oid != null) {
+                value.add("OID." + oid.value());
+                value.add(oid.value());
+                String[] knownAliases = oid.aliases();
+                if (knownAliases != null) {
+                    for (String ka : knownAliases) {
+                        value.add(ka);
+                    }
+                }
+            }
+            for (String ea : extraAliases) {
+                value.add(ea);
+            }
+        }
+        aliasesMap.put(stdName, value);
+        return value;
+    }
+
+    // returns an aliases List for the specified algorithm name o
+    // NOTE: exception is thrown if no aliases nor oid found, so
+    // only call this method if aliases are expected
+    public static List<String> getAliases(String o) {
+        List<String> res = aliasesMap.get(o);
+        if (res == null) {
+            KnownOIDs e = KnownOIDs.findMatch(o);
+            if (e != null) {
+                return store(o, e);
+            }
+            ProviderException pe =
+                    new ProviderException("Cannot find aliases for " + o);
+            throw pe;
+        }
+        return res;
     }
 
     public static final int getDefDSASubprimeSize(int primeSize) {
         if (primeSize <= 1024) {
             return 160;
@@ -57,21 +108,24 @@
     public static final int DEF_DSA_KEY_SIZE;
     public static final int DEF_RSA_KEY_SIZE;
     public static final int DEF_RSASSA_PSS_KEY_SIZE;
     public static final int DEF_DH_KEY_SIZE;
     public static final int DEF_EC_KEY_SIZE;
+    public static final int DEF_ED_KEY_SIZE;
 
     private static final String KEY_LENGTH_PROP =
         "jdk.security.defaultKeySize";
+
     static {
         String keyLengthStr = GetPropertyAction.privilegedGetProperty
             (KEY_LENGTH_PROP);
         int dsaKeySize = 2048;
         int rsaKeySize = 2048;
         int rsaSsaPssKeySize = rsaKeySize; // default to same value as RSA
         int dhKeySize = 2048;
         int ecKeySize = 256;
+        int edKeySize = 255;
 
         if (keyLengthStr != null) {
             try {
                 String[] pairs = keyLengthStr.split(",");
                 for (String p : pairs) {
@@ -104,10 +158,12 @@
                         rsaSsaPssKeySize = value;
                     } else if (algoName.equals("DH")) {
                         dhKeySize = value;
                     } else if (algoName.equals("EC")) {
                         ecKeySize = value;
+                    } else if (algoName.equalsIgnoreCase("EdDSA")) {
+                        edKeySize = value;
                     } else {
                         if (debug != null) {
                             debug.println("Ignoring unsupported algo in " +
                                 KEY_LENGTH_PROP + " property: " + p);
                         }
@@ -130,7 +186,42 @@
         DEF_DSA_KEY_SIZE = dsaKeySize;
         DEF_RSA_KEY_SIZE = rsaKeySize;
         DEF_RSASSA_PSS_KEY_SIZE = rsaSsaPssKeySize;
         DEF_DH_KEY_SIZE = dhKeySize;
         DEF_EC_KEY_SIZE = ecKeySize;
+        DEF_ED_KEY_SIZE = edKeySize;
+
+        // Set up aliases with default mappings
+        // This is needed when the mapping contains non-oid
+        // aliases
+        aliasesMap = new ConcurrentHashMap<>();
+
+        store("SHA1withDSA", KnownOIDs.SHA1withDSA,
+                KnownOIDs.OIW_JDK_SHA1withDSA.value(),
+                KnownOIDs.OIW_SHA1withDSA.value(),
+                "DSA", "SHA/DSA", "SHA-1/DSA",
+                "SHA1/DSA", "SHAwithDSA", "DSAWithSHA1");
+
+        store("DSA", KnownOIDs.DSA, KnownOIDs.OIW_DSA.value());
+
+        store("SHA1withRSA", KnownOIDs.SHA1withRSA,
+                KnownOIDs.OIW_SHA1withRSA.value());
+
+        store("SHA-1", KnownOIDs.SHA_1);
+
+        store("PBEWithMD5AndDES", KnownOIDs.PBEWithMD5AndDES, "PBE");
+
+        store("DiffieHellman", KnownOIDs.DiffieHellman);
+
+        store("AES", KnownOIDs.AES, "Rijndael");
+
+        store("EC", KnownOIDs.EC, "EllipticCurve");
+
+        store("X.509", null, "X509");
+        store("NONEwithDSA", null, "RawDSA");
+        store("DESede", null, "TripleDES");
+        store("ARCFOUR", KnownOIDs.ARCFOUR);
+        // For backward compatility, refer to PKCS1 mapping for RSA
+        // KeyPairGenerator and KeyFactory
+        store("PKCS1", KnownOIDs.PKCS1, KnownOIDs.RSA.value());
     }
 }

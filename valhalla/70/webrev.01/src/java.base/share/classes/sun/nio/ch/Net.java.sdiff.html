<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/Net.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SelectorProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/Net.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
232         try{
233             sm.checkConnect(addr.getAddress().getHostAddress(), -1);
234             // Security check passed
235         } catch (SecurityException e) {
236             // Return loopback address only if security check fails
237             addr = getLoopbackAddress(addr.getPort());
238         }
239         return addr;
240     }
241 
242     static String getRevealedLocalAddressAsString(InetSocketAddress addr) {
243         return System.getSecurityManager() == null ? addr.toString() :
244                 getLoopbackAddress(addr.getPort()).toString();
245     }
246 
247     private static InetSocketAddress getLoopbackAddress(int port) {
248         return new InetSocketAddress(InetAddress.getLoopbackAddress(),
249                                      port);
250     }
251 



















































252     /**
253      * Returns any IPv4 address of the given network interface, or
254      * null if the interface does not have any IPv4 addresses.
255      */
256     static Inet4Address anyInet4Address(final NetworkInterface interf) {
257         return AccessController.doPrivileged(new PrivilegedAction&lt;Inet4Address&gt;() {
258             public Inet4Address run() {
259                 Enumeration&lt;InetAddress&gt; addrs = interf.getInetAddresses();
260                 while (addrs.hasMoreElements()) {
261                     InetAddress addr = addrs.nextElement();
262                     if (addr instanceof Inet4Address) {
263                         return (Inet4Address)addr;
264                     }
265                 }
266                 return null;
267             }
268         });
269     }
270 
271     /**
</pre>
<hr />
<pre>
450 
451     private static native boolean shouldSetBothIPv4AndIPv6Options0();
452 
453     private static native boolean canIPv6SocketJoinIPv4Group0();
454 
455     private static native boolean canJoin6WithIPv4Group0();
456 
457     private static native boolean canUseIPv6OptionsWithIPv4LocalAddress0();
458 
459     static FileDescriptor socket(boolean stream) throws IOException {
460         return socket(UNSPEC, stream);
461     }
462 
463     static FileDescriptor socket(ProtocolFamily family, boolean stream) throws IOException {
464         boolean preferIPv6 = isIPv6Available() &amp;&amp;
465             (family != StandardProtocolFamily.INET);
466         return IOUtil.newFD(socket0(preferIPv6, stream, false, fastLoopback));
467     }
468 
469     static FileDescriptor serverSocket(boolean stream) {
<span class="line-modified">470         return IOUtil.newFD(socket0(isIPv6Available(), stream, true, fastLoopback));</span>






471     }
472 
473     // Due to oddities SO_REUSEADDR on windows reuse is ignored
474     private static native int socket0(boolean preferIPv6, boolean stream, boolean reuse,
475                                       boolean fastLoopback);
476 
477     public static void bind(FileDescriptor fd, InetAddress addr, int port)
478         throws IOException
479     {
480         bind(UNSPEC, fd, addr, port);
481     }
482 
483     static void bind(ProtocolFamily family, FileDescriptor fd,
484                      InetAddress addr, int port) throws IOException
485     {
486         boolean preferIPv6 = isIPv6Available() &amp;&amp;
487             (family != StandardProtocolFamily.INET);
488         if (addr.isLinkLocalAddress()) {
489             addr = IPAddressUtil.toScopedAddress(addr);
490         }
</pre>
</td>
<td>
<hr />
<pre>
232         try{
233             sm.checkConnect(addr.getAddress().getHostAddress(), -1);
234             // Security check passed
235         } catch (SecurityException e) {
236             // Return loopback address only if security check fails
237             addr = getLoopbackAddress(addr.getPort());
238         }
239         return addr;
240     }
241 
242     static String getRevealedLocalAddressAsString(InetSocketAddress addr) {
243         return System.getSecurityManager() == null ? addr.toString() :
244                 getLoopbackAddress(addr.getPort()).toString();
245     }
246 
247     private static InetSocketAddress getLoopbackAddress(int port) {
248         return new InetSocketAddress(InetAddress.getLoopbackAddress(),
249                                      port);
250     }
251 
<span class="line-added">252     private static final InetAddress anyLocalInet4Address;</span>
<span class="line-added">253     private static final InetAddress anyLocalInet6Address;</span>
<span class="line-added">254     private static final InetAddress inet4LoopbackAddress;</span>
<span class="line-added">255     private static final InetAddress inet6LoopbackAddress;</span>
<span class="line-added">256     static {</span>
<span class="line-added">257         try {</span>
<span class="line-added">258             anyLocalInet4Address = inet4FromInt(0);</span>
<span class="line-added">259             assert anyLocalInet4Address instanceof Inet4Address</span>
<span class="line-added">260                     &amp;&amp; anyLocalInet4Address.isAnyLocalAddress();</span>
<span class="line-added">261 </span>
<span class="line-added">262             anyLocalInet6Address = InetAddress.getByAddress(new byte[16]);</span>
<span class="line-added">263             assert anyLocalInet6Address instanceof Inet6Address</span>
<span class="line-added">264                     &amp;&amp; anyLocalInet6Address.isAnyLocalAddress();</span>
<span class="line-added">265 </span>
<span class="line-added">266             inet4LoopbackAddress = inet4FromInt(0x7f000001);</span>
<span class="line-added">267             assert inet4LoopbackAddress instanceof Inet4Address</span>
<span class="line-added">268                     &amp;&amp; inet4LoopbackAddress.isLoopbackAddress();</span>
<span class="line-added">269 </span>
<span class="line-added">270             byte[] bytes = new byte[16];</span>
<span class="line-added">271             bytes[15] = 0x01;</span>
<span class="line-added">272             inet6LoopbackAddress = InetAddress.getByAddress(bytes);</span>
<span class="line-added">273             assert inet6LoopbackAddress instanceof Inet6Address</span>
<span class="line-added">274                     &amp;&amp; inet6LoopbackAddress.isLoopbackAddress();</span>
<span class="line-added">275         } catch (Exception e) {</span>
<span class="line-added">276             throw new InternalError(e);</span>
<span class="line-added">277         }</span>
<span class="line-added">278     }</span>
<span class="line-added">279 </span>
<span class="line-added">280     static InetAddress inet4LoopbackAddress() {</span>
<span class="line-added">281         return inet4LoopbackAddress;</span>
<span class="line-added">282     }</span>
<span class="line-added">283 </span>
<span class="line-added">284     static InetAddress inet6LoopbackAddress() {</span>
<span class="line-added">285         return inet6LoopbackAddress;</span>
<span class="line-added">286     }</span>
<span class="line-added">287 </span>
<span class="line-added">288     /**</span>
<span class="line-added">289      * Returns the wildcard address that corresponds to the given protocol family.</span>
<span class="line-added">290      *</span>
<span class="line-added">291      * @see InetAddress#isAnyLocalAddress()</span>
<span class="line-added">292      */</span>
<span class="line-added">293     static InetAddress anyLocalAddress(ProtocolFamily family) {</span>
<span class="line-added">294         if (family == StandardProtocolFamily.INET) {</span>
<span class="line-added">295             return anyLocalInet4Address;</span>
<span class="line-added">296         } else if (family == StandardProtocolFamily.INET6) {</span>
<span class="line-added">297             return anyLocalInet6Address;</span>
<span class="line-added">298         } else {</span>
<span class="line-added">299             throw new IllegalArgumentException();</span>
<span class="line-added">300         }</span>
<span class="line-added">301     }</span>
<span class="line-added">302 </span>
303     /**
304      * Returns any IPv4 address of the given network interface, or
305      * null if the interface does not have any IPv4 addresses.
306      */
307     static Inet4Address anyInet4Address(final NetworkInterface interf) {
308         return AccessController.doPrivileged(new PrivilegedAction&lt;Inet4Address&gt;() {
309             public Inet4Address run() {
310                 Enumeration&lt;InetAddress&gt; addrs = interf.getInetAddresses();
311                 while (addrs.hasMoreElements()) {
312                     InetAddress addr = addrs.nextElement();
313                     if (addr instanceof Inet4Address) {
314                         return (Inet4Address)addr;
315                     }
316                 }
317                 return null;
318             }
319         });
320     }
321 
322     /**
</pre>
<hr />
<pre>
501 
502     private static native boolean shouldSetBothIPv4AndIPv6Options0();
503 
504     private static native boolean canIPv6SocketJoinIPv4Group0();
505 
506     private static native boolean canJoin6WithIPv4Group0();
507 
508     private static native boolean canUseIPv6OptionsWithIPv4LocalAddress0();
509 
510     static FileDescriptor socket(boolean stream) throws IOException {
511         return socket(UNSPEC, stream);
512     }
513 
514     static FileDescriptor socket(ProtocolFamily family, boolean stream) throws IOException {
515         boolean preferIPv6 = isIPv6Available() &amp;&amp;
516             (family != StandardProtocolFamily.INET);
517         return IOUtil.newFD(socket0(preferIPv6, stream, false, fastLoopback));
518     }
519 
520     static FileDescriptor serverSocket(boolean stream) {
<span class="line-modified">521         return serverSocket(UNSPEC, stream);</span>
<span class="line-added">522     }</span>
<span class="line-added">523 </span>
<span class="line-added">524     static FileDescriptor serverSocket(ProtocolFamily family, boolean stream) {</span>
<span class="line-added">525         boolean preferIPv6 = isIPv6Available() &amp;&amp;</span>
<span class="line-added">526             (family != StandardProtocolFamily.INET);</span>
<span class="line-added">527         return IOUtil.newFD(socket0(preferIPv6, stream, true, fastLoopback));</span>
528     }
529 
530     // Due to oddities SO_REUSEADDR on windows reuse is ignored
531     private static native int socket0(boolean preferIPv6, boolean stream, boolean reuse,
532                                       boolean fastLoopback);
533 
534     public static void bind(FileDescriptor fd, InetAddress addr, int port)
535         throws IOException
536     {
537         bind(UNSPEC, fd, addr, port);
538     }
539 
540     static void bind(ProtocolFamily family, FileDescriptor fd,
541                      InetAddress addr, int port) throws IOException
542     {
543         boolean preferIPv6 = isIPv6Available() &amp;&amp;
544             (family != StandardProtocolFamily.INET);
545         if (addr.isLinkLocalAddress()) {
546             addr = IPAddressUtil.toScopedAddress(addr);
547         }
</pre>
</td>
</tr>
</table>
<center><a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SelectorProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
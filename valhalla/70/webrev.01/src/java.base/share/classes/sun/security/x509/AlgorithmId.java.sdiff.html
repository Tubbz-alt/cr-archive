<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/x509/AlgorithmId.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessDescription.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ExtendedKeyUsageExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/x509/AlgorithmId.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.*;
  29 import java.security.interfaces.RSAKey;
  30 import java.security.spec.AlgorithmParameterSpec;

  31 import java.security.spec.InvalidParameterSpecException;
  32 import java.security.spec.MGF1ParameterSpec;
  33 import java.security.spec.PSSParameterSpec;
  34 import java.util.*;

  35 import java.security.*;

  36 
  37 import sun.security.rsa.PSSParameters;
  38 import sun.security.util.*;
  39 
  40 
  41 /**
  42  * This class identifies algorithms, such as cryptographic transforms, each
  43  * of which may be associated with parameters.  Instances of this base class
  44  * are used when this runtime environment has no special knowledge of the
  45  * algorithm type, and may also be used in other cases.  Equivalence is
  46  * defined according to OID and (where relevant) parameters.
  47  *
  48  * &lt;P&gt;Subclasses may be used, for example when the algorithm ID has
  49  * associated parameters which some code (e.g. code using public keys) needs
  50  * to have parsed.  Two examples of such algorithms are Diffie-Hellman key
  51  * exchange, and the Digital Signature Standard Algorithm (DSS/DSA).
  52  *
  53  * &lt;P&gt;The OID constants defined in this class correspond to some widely
  54  * used algorithms, for which conventional string names have been defined.
  55  * This class is not a general repository for OIDs, or for such string names.
</pre>
<hr />
<pre>
 182             // (which are optional) SHOULD be omitted.
 183             // RFC 3279 2.3.2: The id-dsa algorithm syntax includes optional
 184             // domain parameters... When omitted, the parameters component
 185             // MUST be omitted entirely
 186             // RFC 3370 3.1: When the id-dsa-with-sha1 algorithm identifier
 187             // is used, the AlgorithmIdentifier parameters field MUST be absent.
 188             /*if (
 189                 algid.equals((Object)SHA_oid) ||
 190                 algid.equals((Object)SHA224_oid) ||
 191                 algid.equals((Object)SHA256_oid) ||
 192                 algid.equals((Object)SHA384_oid) ||
 193                 algid.equals((Object)SHA512_oid) ||
 194                 algid.equals((Object)SHA512_224_oid) ||
 195                 algid.equals((Object)SHA512_256_oid) ||
 196                 algid.equals((Object)DSA_oid) ||
 197                 algid.equals((Object)sha1WithDSA_oid)) {
 198                 ; // no parameter part encoded
 199             } else {
 200                 bytes.putNull();
 201             }*/
<span class="line-modified"> 202             if (algid.equals(RSASSA_PSS_oid)) {</span>

 203                 // RFC 4055 3.3: when an RSASSA-PSS key does not require
 204                 // parameter validation, field is absent.
 205             } else {
 206                 bytes.putNull();
 207             }
 208         } else {
 209             bytes.putDerValue(params);
 210         }
 211         tmp.write(DerValue.tag_Sequence, bytes);
 212         out.write(tmp.toByteArray());
 213     }
 214 
 215 
 216     /**
 217      * Returns the DER-encoded X.509 AlgorithmId as a byte array.
 218      */
 219     public final byte[] encode() throws IOException {
 220         DerOutputStream out = new DerOutputStream();
 221         derEncode(out);
 222         return out.toByteArray();
</pre>
<hr />
<pre>
 228      * &quot;OID.1.3.14.3.2.13&quot; style notation.  Use the &lt;code&gt;getName&lt;/code&gt;
 229      * call when you do not need to ensure cross-system portability
 230      * of algorithm names, or need a user friendly name.
 231      */
 232     public final ObjectIdentifier getOID () {
 233         return algid;
 234     }
 235 
 236     /**
 237      * Returns a name for the algorithm which may be more intelligible
 238      * to humans than the algorithm&#39;s OID, but which won&#39;t necessarily
 239      * be comprehensible on other systems.  For example, this might
 240      * return a name such as &quot;MD5withRSA&quot; for a signature algorithm on
 241      * some systems.  It also returns names like &quot;OID.1.2.3.4&quot;, when
 242      * no particular name for the algorithm is known.
 243      *
 244      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 245      * returns the &quot;full&quot; signature algorithm (Ex: SHA256withECDSA) directly.
 246      */
 247     public String getName() {
<span class="line-modified"> 248         String algName = nameTable.get(algid);</span>
<span class="line-modified"> 249         if (algName != null) {</span>
<span class="line-modified"> 250             return algName;</span>
<span class="line-modified"> 251         }</span>
<span class="line-modified"> 252         if ((params != null) &amp;&amp; algid.equals((Object)specifiedWithECDSA_oid)) {</span>
<span class="line-modified"> 253             try {</span>
<span class="line-modified"> 254                 AlgorithmId paramsId =</span>
 255                         AlgorithmId.parse(new DerValue(params.toByteArray()));
<span class="line-modified"> 256                 String paramsName = paramsId.getName();</span>
<span class="line-modified"> 257                 algName = makeSigAlg(paramsName, &quot;EC&quot;);</span>
<span class="line-modified"> 258             } catch (IOException e) {</span>
<span class="line-modified"> 259                 // ignore</span>











 260             }
 261         }
<span class="line-removed"> 262         return (algName == null) ? algid.toString() : algName;</span>
 263     }
 264 
 265     public AlgorithmParameters getParameters() {
 266         return algParams;
 267     }
 268 
 269     /**
 270      * Returns the DER encoded parameter, which can then be
 271      * used to initialize java.security.AlgorithmParameters.
 272      *
 273      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 274      * returns null because {@link #getName()} has already returned the &quot;full&quot;
 275      * signature algorithm (Ex: SHA256withECDSA).
 276      *
 277      * @return DER encoded parameters, or null not present.
 278      */
 279     public byte[] getEncodedParams() throws IOException {
<span class="line-modified"> 280         return (params == null || algid.equals(specifiedWithECDSA_oid))</span>

 281                 ? null
 282                 : params.toByteArray();
 283     }
 284 
 285     /**
 286      * Returns true iff the argument indicates the same algorithm
 287      * with the same parameters.
 288      */
 289     public boolean equals(AlgorithmId other) {
 290         boolean paramsEqual = Objects.equals(other.params, params);
 291         return (algid.equals((Object)other.algid) &amp;&amp; paramsEqual);
 292     }
 293 
 294     /**
 295      * Compares this AlgorithmID to another.  If algorithm parameters are
 296      * available, they are compared.  Otherwise, just the object IDs
 297      * for the algorithm are compared.
 298      *
 299      * @param other preferably an AlgorithmId, else an ObjectIdentifier
 300      */
</pre>
<hr />
<pre>
 454         if (oid == null) {
 455             throw new NoSuchAlgorithmException
 456                 (&quot;unrecognized algorithm name: &quot; + algname);
 457         }
 458         return new AlgorithmId(oid, algparams);
 459     }
 460 
 461     /*
 462      * Translates from some common algorithm names to the
 463      * OID with which they&#39;re usually associated ... this mapping
 464      * is the reverse of the one below, except in those cases
 465      * where synonyms are supported or where a given algorithm
 466      * is commonly associated with multiple OIDs.
 467      *
 468      * XXX This method needs to be enhanced so that we can also pass the
 469      * scope of the algorithm name to it, e.g., the algorithm name &quot;DSA&quot;
 470      * may have a different OID when used as a &quot;Signature&quot; algorithm than when
 471      * used as a &quot;KeyPairGenerator&quot; algorithm.
 472      */
 473     private static ObjectIdentifier algOID(String name) throws IOException {
<span class="line-modified"> 474         // See if algname is in printable OID (&quot;dot-dot&quot;) notation</span>
<span class="line-modified"> 475         if (name.indexOf(&#39;.&#39;) != -1) {</span>
<span class="line-removed"> 476             if (name.startsWith(&quot;OID.&quot;)) {</span>
<span class="line-removed"> 477                 return new ObjectIdentifier(name.substring(&quot;OID.&quot;.length()));</span>
<span class="line-removed"> 478             } else {</span>
<span class="line-removed"> 479                 return new ObjectIdentifier(name);</span>
<span class="line-removed"> 480             }</span>
 481         }
 482 
<span class="line-modified"> 483         // Digesting algorithms</span>
<span class="line-modified"> 484         if (name.equalsIgnoreCase(&quot;MD5&quot;)) {</span>
<span class="line-modified"> 485             return AlgorithmId.MD5_oid;</span>
<span class="line-removed"> 486         }</span>
<span class="line-removed"> 487         if (name.equalsIgnoreCase(&quot;MD2&quot;)) {</span>
<span class="line-removed"> 488             return AlgorithmId.MD2_oid;</span>
<span class="line-removed"> 489         }</span>
<span class="line-removed"> 490         if (name.equalsIgnoreCase(&quot;SHA&quot;) || name.equalsIgnoreCase(&quot;SHA1&quot;)</span>
<span class="line-removed"> 491             || name.equalsIgnoreCase(&quot;SHA-1&quot;)) {</span>
<span class="line-removed"> 492             return AlgorithmId.SHA_oid;</span>
<span class="line-removed"> 493         }</span>
<span class="line-removed"> 494         if (name.equalsIgnoreCase(&quot;SHA-256&quot;) ||</span>
<span class="line-removed"> 495             name.equalsIgnoreCase(&quot;SHA256&quot;)) {</span>
<span class="line-removed"> 496             return AlgorithmId.SHA256_oid;</span>
<span class="line-removed"> 497         }</span>
<span class="line-removed"> 498         if (name.equalsIgnoreCase(&quot;SHA-384&quot;) ||</span>
<span class="line-removed"> 499             name.equalsIgnoreCase(&quot;SHA384&quot;)) {</span>
<span class="line-removed"> 500             return AlgorithmId.SHA384_oid;</span>
<span class="line-removed"> 501         }</span>
<span class="line-removed"> 502         if (name.equalsIgnoreCase(&quot;SHA-512&quot;) ||</span>
<span class="line-removed"> 503             name.equalsIgnoreCase(&quot;SHA512&quot;)) {</span>
<span class="line-removed"> 504             return AlgorithmId.SHA512_oid;</span>
<span class="line-removed"> 505         }</span>
<span class="line-removed"> 506         if (name.equalsIgnoreCase(&quot;SHA-224&quot;) ||</span>
<span class="line-removed"> 507             name.equalsIgnoreCase(&quot;SHA224&quot;)) {</span>
<span class="line-removed"> 508             return AlgorithmId.SHA224_oid;</span>
<span class="line-removed"> 509         }</span>
<span class="line-removed"> 510         if (name.equalsIgnoreCase(&quot;SHA-512/224&quot;) ||</span>
<span class="line-removed"> 511             name.equalsIgnoreCase(&quot;SHA512/224&quot;)) {</span>
<span class="line-removed"> 512             return AlgorithmId.SHA512_224_oid;</span>
<span class="line-removed"> 513         }</span>
<span class="line-removed"> 514         if (name.equalsIgnoreCase(&quot;SHA-512/256&quot;) ||</span>
<span class="line-removed"> 515             name.equalsIgnoreCase(&quot;SHA512/256&quot;)) {</span>
<span class="line-removed"> 516             return AlgorithmId.SHA512_256_oid;</span>
<span class="line-removed"> 517         }</span>
<span class="line-removed"> 518         // Various public key algorithms</span>
<span class="line-removed"> 519         if (name.equalsIgnoreCase(&quot;RSA&quot;)) {</span>
<span class="line-removed"> 520             return AlgorithmId.RSAEncryption_oid;</span>
<span class="line-removed"> 521         }</span>
<span class="line-removed"> 522         if (name.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {</span>
<span class="line-removed"> 523             return AlgorithmId.RSASSA_PSS_oid;</span>
<span class="line-removed"> 524         }</span>
<span class="line-removed"> 525         if (name.equalsIgnoreCase(&quot;RSAES-OAEP&quot;)) {</span>
<span class="line-removed"> 526             return AlgorithmId.RSAES_OAEP_oid;</span>
<span class="line-removed"> 527         }</span>
<span class="line-removed"> 528         if (name.equalsIgnoreCase(&quot;Diffie-Hellman&quot;)</span>
<span class="line-removed"> 529             || name.equalsIgnoreCase(&quot;DH&quot;)) {</span>
<span class="line-removed"> 530             return AlgorithmId.DH_oid;</span>
<span class="line-removed"> 531         }</span>
<span class="line-removed"> 532         if (name.equalsIgnoreCase(&quot;DSA&quot;)) {</span>
<span class="line-removed"> 533             return AlgorithmId.DSA_oid;</span>
<span class="line-removed"> 534         }</span>
<span class="line-removed"> 535         if (name.equalsIgnoreCase(&quot;EC&quot;)) {</span>
<span class="line-removed"> 536             return EC_oid;</span>
<span class="line-removed"> 537         }</span>
<span class="line-removed"> 538         if (name.equalsIgnoreCase(&quot;ECDH&quot;)) {</span>
<span class="line-removed"> 539             return AlgorithmId.ECDH_oid;</span>
<span class="line-removed"> 540         }</span>
<span class="line-removed"> 541 </span>
<span class="line-removed"> 542         // Secret key algorithms</span>
<span class="line-removed"> 543         if (name.equalsIgnoreCase(&quot;AES&quot;)) {</span>
<span class="line-removed"> 544             return AlgorithmId.AES_oid;</span>
 545         }
 546 
<span class="line-modified"> 547         // Common signature types</span>
<span class="line-modified"> 548         if (name.equalsIgnoreCase(&quot;MD5withRSA&quot;)</span>
<span class="line-modified"> 549             || name.equalsIgnoreCase(&quot;MD5/RSA&quot;)) {</span>
<span class="line-modified"> 550             return AlgorithmId.md5WithRSAEncryption_oid;</span>
<span class="line-modified"> 551         }</span>
<span class="line-modified"> 552         if (name.equalsIgnoreCase(&quot;MD2withRSA&quot;)</span>
<span class="line-modified"> 553             || name.equalsIgnoreCase(&quot;MD2/RSA&quot;)) {</span>
<span class="line-modified"> 554             return AlgorithmId.md2WithRSAEncryption_oid;</span>
<span class="line-modified"> 555         }</span>
<span class="line-modified"> 556         if (name.equalsIgnoreCase(&quot;SHAwithDSA&quot;)</span>
<span class="line-modified"> 557             || name.equalsIgnoreCase(&quot;SHA1withDSA&quot;)</span>
<span class="line-removed"> 558             || name.equalsIgnoreCase(&quot;SHA/DSA&quot;)</span>
<span class="line-removed"> 559             || name.equalsIgnoreCase(&quot;SHA1/DSA&quot;)</span>
<span class="line-removed"> 560             || name.equalsIgnoreCase(&quot;DSAWithSHA1&quot;)</span>
<span class="line-removed"> 561             || name.equalsIgnoreCase(&quot;DSS&quot;)</span>
<span class="line-removed"> 562             || name.equalsIgnoreCase(&quot;SHA-1/DSA&quot;)) {</span>
<span class="line-removed"> 563             return AlgorithmId.sha1WithDSA_oid;</span>
<span class="line-removed"> 564         }</span>
<span class="line-removed"> 565         if (name.equalsIgnoreCase(&quot;SHA224WithDSA&quot;)) {</span>
<span class="line-removed"> 566             return AlgorithmId.sha224WithDSA_oid;</span>
<span class="line-removed"> 567         }</span>
<span class="line-removed"> 568         if (name.equalsIgnoreCase(&quot;SHA256WithDSA&quot;)) {</span>
<span class="line-removed"> 569             return AlgorithmId.sha256WithDSA_oid;</span>
<span class="line-removed"> 570         }</span>
<span class="line-removed"> 571         if (name.equalsIgnoreCase(&quot;SHA1WithRSA&quot;)</span>
<span class="line-removed"> 572             || name.equalsIgnoreCase(&quot;SHA1/RSA&quot;)) {</span>
<span class="line-removed"> 573             return AlgorithmId.sha1WithRSAEncryption_oid;</span>
<span class="line-removed"> 574         }</span>
<span class="line-removed"> 575         if (name.equalsIgnoreCase(&quot;SHA1withECDSA&quot;)</span>
<span class="line-removed"> 576                 || name.equalsIgnoreCase(&quot;ECDSA&quot;)) {</span>
<span class="line-removed"> 577             return AlgorithmId.sha1WithECDSA_oid;</span>
<span class="line-removed"> 578         }</span>
<span class="line-removed"> 579         if (name.equalsIgnoreCase(&quot;SHA224withECDSA&quot;)) {</span>
<span class="line-removed"> 580             return AlgorithmId.sha224WithECDSA_oid;</span>
<span class="line-removed"> 581         }</span>
<span class="line-removed"> 582         if (name.equalsIgnoreCase(&quot;SHA256withECDSA&quot;)) {</span>
<span class="line-removed"> 583             return AlgorithmId.sha256WithECDSA_oid;</span>
<span class="line-removed"> 584         }</span>
<span class="line-removed"> 585         if (name.equalsIgnoreCase(&quot;SHA384withECDSA&quot;)) {</span>
<span class="line-removed"> 586             return AlgorithmId.sha384WithECDSA_oid;</span>
<span class="line-removed"> 587         }</span>
<span class="line-removed"> 588         if (name.equalsIgnoreCase(&quot;SHA512withECDSA&quot;)) {</span>
<span class="line-removed"> 589             return AlgorithmId.sha512WithECDSA_oid;</span>
 590         }
<span class="line-removed"> 591 </span>
<span class="line-removed"> 592         return oidTable().get(name.toUpperCase(Locale.ENGLISH));</span>
 593     }
 594 
<span class="line-modified"> 595     private static volatile Map&lt;String,ObjectIdentifier&gt; oidTable;</span>
<span class="line-modified"> 596     private static final Map&lt;ObjectIdentifier,String&gt; nameTable;</span>
 597 
<span class="line-modified"> 598     /** Returns the oidTable, lazily initializing it on first access. */</span>
<span class="line-modified"> 599     private static Map&lt;String,ObjectIdentifier&gt; oidTable()</span>
<span class="line-modified"> 600         throws IOException {</span>
<span class="line-modified"> 601         // Double checked locking; safe because oidTable is volatile</span>
<span class="line-modified"> 602         Map&lt;String,ObjectIdentifier&gt; tab;</span>
<span class="line-removed"> 603         if ((tab = oidTable) == null) {</span>
 604             synchronized (AlgorithmId.class) {
<span class="line-modified"> 605                 if ((tab = oidTable) == null)</span>
<span class="line-modified"> 606                     oidTable = tab = computeOidTable();</span>

 607             }
 608         }
 609         return tab;
 610     }
 611 
<span class="line-modified"> 612     /** Collects the algorithm names from the installed providers. */</span>
<span class="line-modified"> 613     private static HashMap&lt;String,ObjectIdentifier&gt; computeOidTable()</span>
<span class="line-modified"> 614         throws IOException {</span>
<span class="line-modified"> 615         HashMap&lt;String,ObjectIdentifier&gt; tab = new HashMap&lt;&gt;();</span>














 616         for (Provider provider : Security.getProviders()) {





 617             for (Object key : provider.keySet()) {
 618                 String alias = (String)key;
 619                 String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
 620                 int index;
 621                 if (upperCaseAlias.startsWith(&quot;ALG.ALIAS&quot;) &amp;&amp;
<span class="line-modified"> 622                     (index=upperCaseAlias.indexOf(&quot;OID.&quot;, 0)) != -1) {</span>
 623                     index += &quot;OID.&quot;.length();
 624                     if (index == alias.length()) {
 625                         // invalid alias entry
 626                         break;
 627                     }
<span class="line-modified"> 628                     String oidString = alias.substring(index);</span>
 629                     String stdAlgName = provider.getProperty(alias);
 630                     if (stdAlgName != null) {
 631                         stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
 632                     }
<span class="line-modified"> 633                     if (stdAlgName != null &amp;&amp;</span>
<span class="line-modified"> 634                         tab.get(stdAlgName) == null) {</span>
<span class="line-modified"> 635                         tab.put(stdAlgName, new ObjectIdentifier(oidString));</span>





 636                     }
 637                 }
 638             }
 639         }
<span class="line-modified"> 640         return tab;</span>
 641     }
 642 
<span class="line-removed"> 643     /*****************************************************************/</span>
<span class="line-removed"> 644 </span>
<span class="line-removed"> 645     /*</span>
<span class="line-removed"> 646      * HASHING ALGORITHMS</span>
<span class="line-removed"> 647      */</span>
<span class="line-removed"> 648 </span>
<span class="line-removed"> 649     /**</span>
<span class="line-removed"> 650      * Algorithm ID for the MD2 Message Digest Algorthm, from RFC 1319.</span>
<span class="line-removed"> 651      * OID = 1.2.840.113549.2.2</span>
<span class="line-removed"> 652      */</span>
 653     public static final ObjectIdentifier MD2_oid =
<span class="line-modified"> 654         ObjectIdentifier.of(&quot;1.2.840.113549.2.2&quot;);</span>
 655 
<span class="line-removed"> 656     /**</span>
<span class="line-removed"> 657      * Algorithm ID for the MD5 Message Digest Algorthm, from RFC 1321.</span>
<span class="line-removed"> 658      * OID = 1.2.840.113549.2.5</span>
<span class="line-removed"> 659      */</span>
 660     public static final ObjectIdentifier MD5_oid =
<span class="line-modified"> 661         ObjectIdentifier.of(&quot;1.2.840.113549.2.5&quot;);</span>
 662 
<span class="line-removed"> 663     /**</span>
<span class="line-removed"> 664      * Algorithm ID for the SHA1 Message Digest Algorithm, from FIPS 180-1.</span>
<span class="line-removed"> 665      * This is sometimes called &quot;SHA&quot;, though that is often confusing since</span>
<span class="line-removed"> 666      * many people refer to FIPS 180 (which has an error) as defining SHA.</span>
<span class="line-removed"> 667      * OID = 1.3.14.3.2.26. Old SHA-0 OID: 1.3.14.3.2.18.</span>
<span class="line-removed"> 668      */</span>
 669     public static final ObjectIdentifier SHA_oid =
<span class="line-modified"> 670         ObjectIdentifier.of(&quot;1.3.14.3.2.26&quot;);</span>
 671 
 672     public static final ObjectIdentifier SHA224_oid =
<span class="line-modified"> 673         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.4&quot;);</span>
 674 
 675     public static final ObjectIdentifier SHA256_oid =
<span class="line-modified"> 676         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.1&quot;);</span>
 677 
 678     public static final ObjectIdentifier SHA384_oid =
<span class="line-modified"> 679         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.2&quot;);</span>
 680 
 681     public static final ObjectIdentifier SHA512_oid =
<span class="line-modified"> 682         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.3&quot;);</span>
 683 
 684     public static final ObjectIdentifier SHA512_224_oid =
<span class="line-modified"> 685         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.5&quot;);</span>
 686 
 687     public static final ObjectIdentifier SHA512_256_oid =
<span class="line-modified"> 688         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.6&quot;);</span>
<span class="line-removed"> 689 </span>
<span class="line-removed"> 690     /*</span>
<span class="line-removed"> 691      * COMMON PUBLIC KEY TYPES</span>
<span class="line-removed"> 692      */</span>
<span class="line-removed"> 693     /*</span>
<span class="line-removed"> 694      * Note the preferred OIDs are named simply with no &quot;OIW&quot; or</span>
<span class="line-removed"> 695      * &quot;PKIX&quot; in them, even though they may point to data from these</span>
<span class="line-removed"> 696      * specs; e.g. SHA_oid, DH_oid, DSA_oid, SHA1WithDSA_oid...</span>
<span class="line-removed"> 697      */</span>
<span class="line-removed"> 698     /**</span>
<span class="line-removed"> 699      * Algorithm ID for Diffie Hellman Key agreement, from PKCS #3.</span>
<span class="line-removed"> 700      * Parameters include public values P and G, and may optionally specify</span>
<span class="line-removed"> 701      * the length of the private key X.  Alternatively, algorithm parameters</span>
<span class="line-removed"> 702      * may be derived from another source such as a Certificate Authority&#39;s</span>
<span class="line-removed"> 703      * certificate.</span>
<span class="line-removed"> 704      * OID = 1.2.840.113549.1.3.1</span>
<span class="line-removed"> 705      */</span>
<span class="line-removed"> 706     public static final ObjectIdentifier DH_oid =</span>
<span class="line-removed"> 707             ObjectIdentifier.of(&quot;1.2.840.113549.1.3.1&quot;);</span>
<span class="line-removed"> 708 </span>
<span class="line-removed"> 709     /**</span>
<span class="line-removed"> 710      * Algorithm ID for the Diffie Hellman Key Agreement (DH), from RFC 3279.</span>
<span class="line-removed"> 711      * Parameters may include public values P and G.</span>
<span class="line-removed"> 712      * OID = 1.2.840.10046.2.1</span>
<span class="line-removed"> 713      */</span>
<span class="line-removed"> 714     public static final ObjectIdentifier DH_PKIX_oid =</span>
<span class="line-removed"> 715             ObjectIdentifier.of(&quot;1.2.840.10046.2.1&quot;);</span>
<span class="line-removed"> 716 </span>
<span class="line-removed"> 717     /**</span>
<span class="line-removed"> 718      * Algorithm ID for the Digital Signing Algorithm (DSA), from the</span>
<span class="line-removed"> 719      * NIST OIW Stable Agreements part 12.</span>
<span class="line-removed"> 720      * Parameters may include public values P, Q, and G; or these may be</span>
<span class="line-removed"> 721      * derived from</span>
<span class="line-removed"> 722      * another source such as a Certificate Authority&#39;s certificate.</span>
<span class="line-removed"> 723      * OID = 1.3.14.3.2.12</span>
<span class="line-removed"> 724      */</span>
<span class="line-removed"> 725     public static final ObjectIdentifier DSA_OIW_oid =</span>
<span class="line-removed"> 726             ObjectIdentifier.of(&quot;1.3.14.3.2.12&quot;);</span>
 727 
<span class="line-removed"> 728     /**</span>
<span class="line-removed"> 729      * Algorithm ID for the Digital Signing Algorithm (DSA), from RFC 3279.</span>
<span class="line-removed"> 730      * Parameters may include public values P, Q, and G; or these may be</span>
<span class="line-removed"> 731      * derived from another source such as a Certificate Authority&#39;s</span>
<span class="line-removed"> 732      * certificate.</span>
<span class="line-removed"> 733      * OID = 1.2.840.10040.4.1</span>
<span class="line-removed"> 734      */</span>
 735     public static final ObjectIdentifier DSA_oid =
<span class="line-modified"> 736             ObjectIdentifier.of(&quot;1.2.840.10040.4.1&quot;);</span>
<span class="line-removed"> 737 </span>
<span class="line-removed"> 738     /**</span>
<span class="line-removed"> 739      * Algorithm ID for RSA keys used for any purpose, as defined in X.509.</span>
<span class="line-removed"> 740      * The algorithm parameter is a single value, the number of bits in the</span>
<span class="line-removed"> 741      * public modulus.</span>
<span class="line-removed"> 742      * OID = 2.5.8.1.1</span>
<span class="line-removed"> 743      */</span>
<span class="line-removed"> 744     public static final ObjectIdentifier RSA_oid =</span>
<span class="line-removed"> 745             ObjectIdentifier.of(&quot;2.5.8.1.1&quot;);</span>
 746 
 747     public static final ObjectIdentifier EC_oid =
<span class="line-modified"> 748             ObjectIdentifier.of(&quot;1.2.840.10045.2.1&quot;);</span>
<span class="line-removed"> 749     public static final ObjectIdentifier ECDH_oid =</span>
<span class="line-removed"> 750             ObjectIdentifier.of(&quot;1.3.132.1.12&quot;);</span>
<span class="line-removed"> 751     public static final ObjectIdentifier RSAEncryption_oid =</span>
<span class="line-removed"> 752             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.1&quot;);</span>
<span class="line-removed"> 753     public static final ObjectIdentifier RSAES_OAEP_oid =</span>
<span class="line-removed"> 754             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.7&quot;);</span>
<span class="line-removed"> 755     public static final ObjectIdentifier mgf1_oid =</span>
<span class="line-removed"> 756             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.8&quot;);</span>
<span class="line-removed"> 757     public static final ObjectIdentifier RSASSA_PSS_oid =</span>
<span class="line-removed"> 758             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.10&quot;);</span>
<span class="line-removed"> 759 </span>
<span class="line-removed"> 760     /*</span>
<span class="line-removed"> 761      * COMMON SECRET KEY TYPES</span>
<span class="line-removed"> 762      */</span>
<span class="line-removed"> 763     public static final ObjectIdentifier AES_oid =</span>
<span class="line-removed"> 764             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.1&quot;);</span>
<span class="line-removed"> 765 </span>
<span class="line-removed"> 766     /*</span>
<span class="line-removed"> 767      * COMMON SIGNATURE ALGORITHMS</span>
<span class="line-removed"> 768      */</span>
<span class="line-removed"> 769     /**</span>
<span class="line-removed"> 770      * Identifies a signing algorithm where an MD2 digest is encrypted</span>
<span class="line-removed"> 771      * using an RSA private key; defined in PKCS #1.  Use of this</span>
<span class="line-removed"> 772      * signing algorithm is discouraged due to MD2 vulnerabilities.</span>
<span class="line-removed"> 773      * OID = 1.2.840.113549.1.1.2</span>
<span class="line-removed"> 774      */</span>
<span class="line-removed"> 775     public static final ObjectIdentifier md2WithRSAEncryption_oid =</span>
<span class="line-removed"> 776         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.2&quot;);</span>
<span class="line-removed"> 777 </span>
<span class="line-removed"> 778     /**</span>
<span class="line-removed"> 779      * Identifies a signing algorithm where an MD5 digest is</span>
<span class="line-removed"> 780      * encrypted using an RSA private key; defined in PKCS #1.</span>
<span class="line-removed"> 781      * OID = 1.2.840.113549.1.1.4</span>
<span class="line-removed"> 782      */</span>
<span class="line-removed"> 783     public static final ObjectIdentifier md5WithRSAEncryption_oid =</span>
<span class="line-removed"> 784         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.4&quot;);</span>
<span class="line-removed"> 785 </span>
<span class="line-removed"> 786     /**</span>
<span class="line-removed"> 787      * Identifies a signing algorithm where a SHA1 digest is</span>
<span class="line-removed"> 788      * encrypted using an RSA private key; defined by RSA DSI.</span>
<span class="line-removed"> 789      * OID = 1.2.840.113549.1.1.5</span>
<span class="line-removed"> 790      */</span>
<span class="line-removed"> 791     public static final ObjectIdentifier sha1WithRSAEncryption_oid =</span>
<span class="line-removed"> 792         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.5&quot;);</span>
 793 
<span class="line-modified"> 794     /**</span>
<span class="line-modified"> 795      * Identifies a signing algorithm where a SHA1 digest is</span>
<span class="line-removed"> 796      * encrypted using an RSA private key; defined in NIST OIW.</span>
<span class="line-removed"> 797      * OID = 1.3.14.3.2.29</span>
<span class="line-removed"> 798      */</span>
<span class="line-removed"> 799     public static final ObjectIdentifier sha1WithRSAEncryption_OIW_oid =</span>
<span class="line-removed"> 800         ObjectIdentifier.of(&quot;1.3.14.3.2.29&quot;);</span>
<span class="line-removed"> 801 </span>
<span class="line-removed"> 802     /**</span>
<span class="line-removed"> 803      * Identifies a signing algorithm where a SHA224 digest is</span>
<span class="line-removed"> 804      * encrypted using an RSA private key; defined by PKCS #1.</span>
<span class="line-removed"> 805      * OID = 1.2.840.113549.1.1.14</span>
<span class="line-removed"> 806      */</span>
<span class="line-removed"> 807     public static final ObjectIdentifier sha224WithRSAEncryption_oid =</span>
<span class="line-removed"> 808         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.14&quot;);</span>
<span class="line-removed"> 809 </span>
<span class="line-removed"> 810     /**</span>
<span class="line-removed"> 811      * Identifies a signing algorithm where a SHA256 digest is</span>
<span class="line-removed"> 812      * encrypted using an RSA private key; defined by PKCS #1.</span>
<span class="line-removed"> 813      * OID = 1.2.840.113549.1.1.11</span>
<span class="line-removed"> 814      */</span>
<span class="line-removed"> 815     public static final ObjectIdentifier sha256WithRSAEncryption_oid =</span>
<span class="line-removed"> 816         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.11&quot;);</span>
<span class="line-removed"> 817 </span>
<span class="line-removed"> 818     /**</span>
<span class="line-removed"> 819      * Identifies a signing algorithm where a SHA384 digest is</span>
<span class="line-removed"> 820      * encrypted using an RSA private key; defined by PKCS #1.</span>
<span class="line-removed"> 821      * OID = 1.2.840.113549.1.1.12</span>
<span class="line-removed"> 822      */</span>
<span class="line-removed"> 823     public static final ObjectIdentifier sha384WithRSAEncryption_oid =</span>
<span class="line-removed"> 824         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.12&quot;);</span>
<span class="line-removed"> 825 </span>
<span class="line-removed"> 826     /**</span>
<span class="line-removed"> 827      * Identifies a signing algorithm where a SHA512 digest is</span>
<span class="line-removed"> 828      * encrypted using an RSA private key; defined by PKCS #1.</span>
<span class="line-removed"> 829      * OID = 1.2.840.113549.1.1.13</span>
<span class="line-removed"> 830      */</span>
<span class="line-removed"> 831     public static final ObjectIdentifier sha512WithRSAEncryption_oid =</span>
<span class="line-removed"> 832         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.13&quot;);</span>
<span class="line-removed"> 833 </span>
<span class="line-removed"> 834     /**</span>
<span class="line-removed"> 835      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a</span>
<span class="line-removed"> 836      * SHA digest is signed using the Digital Signing Algorithm (DSA).</span>
<span class="line-removed"> 837      * This should not be used.</span>
<span class="line-removed"> 838      * OID = 1.3.14.3.2.13</span>
<span class="line-removed"> 839      */</span>
<span class="line-removed"> 840     public static final ObjectIdentifier shaWithDSA_OIW_oid =</span>
<span class="line-removed"> 841             ObjectIdentifier.of(&quot;1.3.14.3.2.13&quot;);</span>
 842 
<span class="line-modified"> 843     /**</span>
<span class="line-modified"> 844      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a</span>
<span class="line-removed"> 845      * SHA1 digest is signed using the Digital Signing Algorithm (DSA).</span>
<span class="line-removed"> 846      * OID = 1.3.14.3.2.27</span>
<span class="line-removed"> 847      */</span>
<span class="line-removed"> 848     public static final ObjectIdentifier sha1WithDSA_OIW_oid =</span>
<span class="line-removed"> 849             ObjectIdentifier.of(&quot;1.3.14.3.2.27&quot;);</span>
 850 
<span class="line-modified"> 851     /**</span>
<span class="line-modified"> 852      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a</span>
<span class="line-removed"> 853      * SHA1 digest is signed using the Digital Signing Algorithm (DSA).</span>
<span class="line-removed"> 854      * OID = 1.2.840.10040.4.3</span>
<span class="line-removed"> 855      */</span>
<span class="line-removed"> 856     public static final ObjectIdentifier sha1WithDSA_oid =</span>
<span class="line-removed"> 857             ObjectIdentifier.of(&quot;1.2.840.10040.4.3&quot;);</span>
<span class="line-removed"> 858 </span>
<span class="line-removed"> 859     public static final ObjectIdentifier sha512_224WithRSAEncryption_oid =</span>
<span class="line-removed"> 860             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.15&quot;);</span>
<span class="line-removed"> 861     public static final ObjectIdentifier sha512_256WithRSAEncryption_oid =</span>
<span class="line-removed"> 862             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.16&quot;);</span>
<span class="line-removed"> 863 </span>
<span class="line-removed"> 864     public static final ObjectIdentifier sha224WithDSA_oid =</span>
<span class="line-removed"> 865             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.3.1&quot;);</span>
<span class="line-removed"> 866     public static final ObjectIdentifier sha256WithDSA_oid =</span>
<span class="line-removed"> 867             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.3.2&quot;);</span>
<span class="line-removed"> 868 </span>
<span class="line-removed"> 869     public static final ObjectIdentifier sha1WithECDSA_oid =</span>
<span class="line-removed"> 870             ObjectIdentifier.of(&quot;1.2.840.10045.4.1&quot;);</span>
<span class="line-removed"> 871     public static final ObjectIdentifier sha224WithECDSA_oid =</span>
<span class="line-removed"> 872             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.1&quot;);</span>
<span class="line-removed"> 873     public static final ObjectIdentifier sha256WithECDSA_oid =</span>
<span class="line-removed"> 874             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.2&quot;);</span>
<span class="line-removed"> 875     public static final ObjectIdentifier sha384WithECDSA_oid =</span>
<span class="line-removed"> 876             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.3&quot;);</span>
<span class="line-removed"> 877     public static final ObjectIdentifier sha512WithECDSA_oid =</span>
<span class="line-removed"> 878             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.4&quot;);</span>
<span class="line-removed"> 879     public static final ObjectIdentifier specifiedWithECDSA_oid =</span>
<span class="line-removed"> 880             ObjectIdentifier.of(&quot;1.2.840.10045.4.3&quot;);</span>
 881 
<span class="line-modified"> 882     /**</span>
<span class="line-modified"> 883      * Algorithm ID for the PBE encryption algorithms from PKCS#5 and</span>
<span class="line-modified"> 884      * PKCS#12.</span>
<span class="line-modified"> 885      */</span>
<span class="line-removed"> 886     public static final ObjectIdentifier pbeWithMD5AndDES_oid =</span>
<span class="line-removed"> 887             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.3&quot;);</span>
<span class="line-removed"> 888     public static final ObjectIdentifier pbeWithMD5AndRC2_oid =</span>
<span class="line-removed"> 889             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.6&quot;);</span>
<span class="line-removed"> 890     public static final ObjectIdentifier pbeWithSHA1AndDES_oid =</span>
<span class="line-removed"> 891             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.10&quot;);</span>
<span class="line-removed"> 892     public static final ObjectIdentifier pbeWithSHA1AndRC2_oid =</span>
<span class="line-removed"> 893             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.11&quot;);</span>
<span class="line-removed"> 894     public static final ObjectIdentifier pbeWithSHA1AndRC4_128_oid =</span>
<span class="line-removed"> 895             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.1&quot;);</span>
<span class="line-removed"> 896     public static final ObjectIdentifier pbeWithSHA1AndRC4_40_oid =</span>
<span class="line-removed"> 897             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.2&quot;);</span>
<span class="line-removed"> 898     public static final ObjectIdentifier pbeWithSHA1AndDESede_oid =</span>
<span class="line-removed"> 899             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.3&quot;);</span>
<span class="line-removed"> 900     public static final ObjectIdentifier pbeWithSHA1AndRC2_128_oid =</span>
<span class="line-removed"> 901             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.5&quot;);</span>
<span class="line-removed"> 902     public static final ObjectIdentifier pbeWithSHA1AndRC2_40_oid =</span>
<span class="line-removed"> 903             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.6&quot;);</span>
<span class="line-removed"> 904 </span>
<span class="line-removed"> 905     static {</span>
<span class="line-removed"> 906         nameTable = new HashMap&lt;&gt;();</span>
<span class="line-removed"> 907         nameTable.put(MD5_oid, &quot;MD5&quot;);</span>
<span class="line-removed"> 908         nameTable.put(MD2_oid, &quot;MD2&quot;);</span>
<span class="line-removed"> 909         nameTable.put(SHA_oid, &quot;SHA-1&quot;);</span>
<span class="line-removed"> 910         nameTable.put(SHA224_oid, &quot;SHA-224&quot;);</span>
<span class="line-removed"> 911         nameTable.put(SHA256_oid, &quot;SHA-256&quot;);</span>
<span class="line-removed"> 912         nameTable.put(SHA384_oid, &quot;SHA-384&quot;);</span>
<span class="line-removed"> 913         nameTable.put(SHA512_oid, &quot;SHA-512&quot;);</span>
<span class="line-removed"> 914         nameTable.put(SHA512_224_oid, &quot;SHA-512/224&quot;);</span>
<span class="line-removed"> 915         nameTable.put(SHA512_256_oid, &quot;SHA-512/256&quot;);</span>
<span class="line-removed"> 916         nameTable.put(RSAEncryption_oid, &quot;RSA&quot;);</span>
<span class="line-removed"> 917         nameTable.put(RSA_oid, &quot;RSA&quot;);</span>
<span class="line-removed"> 918         nameTable.put(DH_oid, &quot;Diffie-Hellman&quot;);</span>
<span class="line-removed"> 919         nameTable.put(DH_PKIX_oid, &quot;Diffie-Hellman&quot;);</span>
<span class="line-removed"> 920         nameTable.put(DSA_oid, &quot;DSA&quot;);</span>
<span class="line-removed"> 921         nameTable.put(DSA_OIW_oid, &quot;DSA&quot;);</span>
<span class="line-removed"> 922         nameTable.put(EC_oid, &quot;EC&quot;);</span>
<span class="line-removed"> 923         nameTable.put(ECDH_oid, &quot;ECDH&quot;);</span>
<span class="line-removed"> 924 </span>
<span class="line-removed"> 925         nameTable.put(AES_oid, &quot;AES&quot;);</span>
<span class="line-removed"> 926 </span>
<span class="line-removed"> 927         nameTable.put(sha1WithECDSA_oid, &quot;SHA1withECDSA&quot;);</span>
<span class="line-removed"> 928         nameTable.put(sha224WithECDSA_oid, &quot;SHA224withECDSA&quot;);</span>
<span class="line-removed"> 929         nameTable.put(sha256WithECDSA_oid, &quot;SHA256withECDSA&quot;);</span>
<span class="line-removed"> 930         nameTable.put(sha384WithECDSA_oid, &quot;SHA384withECDSA&quot;);</span>
<span class="line-removed"> 931         nameTable.put(sha512WithECDSA_oid, &quot;SHA512withECDSA&quot;);</span>
<span class="line-removed"> 932         nameTable.put(md5WithRSAEncryption_oid, &quot;MD5withRSA&quot;);</span>
<span class="line-removed"> 933         nameTable.put(md2WithRSAEncryption_oid, &quot;MD2withRSA&quot;);</span>
<span class="line-removed"> 934         nameTable.put(sha1WithDSA_oid, &quot;SHA1withDSA&quot;);</span>
<span class="line-removed"> 935         nameTable.put(sha1WithDSA_OIW_oid, &quot;SHA1withDSA&quot;);</span>
<span class="line-removed"> 936         nameTable.put(shaWithDSA_OIW_oid, &quot;SHA1withDSA&quot;);</span>
<span class="line-removed"> 937         nameTable.put(sha224WithDSA_oid, &quot;SHA224withDSA&quot;);</span>
<span class="line-removed"> 938         nameTable.put(sha256WithDSA_oid, &quot;SHA256withDSA&quot;);</span>
<span class="line-removed"> 939         nameTable.put(sha1WithRSAEncryption_oid, &quot;SHA1withRSA&quot;);</span>
<span class="line-removed"> 940         nameTable.put(sha1WithRSAEncryption_OIW_oid, &quot;SHA1withRSA&quot;);</span>
<span class="line-removed"> 941         nameTable.put(sha224WithRSAEncryption_oid, &quot;SHA224withRSA&quot;);</span>
<span class="line-removed"> 942         nameTable.put(sha256WithRSAEncryption_oid, &quot;SHA256withRSA&quot;);</span>
<span class="line-removed"> 943         nameTable.put(sha384WithRSAEncryption_oid, &quot;SHA384withRSA&quot;);</span>
<span class="line-removed"> 944         nameTable.put(sha512WithRSAEncryption_oid, &quot;SHA512withRSA&quot;);</span>
<span class="line-removed"> 945         nameTable.put(sha512_224WithRSAEncryption_oid, &quot;SHA512/224withRSA&quot;);</span>
<span class="line-removed"> 946         nameTable.put(sha512_256WithRSAEncryption_oid, &quot;SHA512/256withRSA&quot;);</span>
<span class="line-removed"> 947         nameTable.put(RSASSA_PSS_oid, &quot;RSASSA-PSS&quot;);</span>
<span class="line-removed"> 948         nameTable.put(RSAES_OAEP_oid, &quot;RSAES-OAEP&quot;);</span>
<span class="line-removed"> 949 </span>
<span class="line-removed"> 950         nameTable.put(pbeWithMD5AndDES_oid, &quot;PBEWithMD5AndDES&quot;);</span>
<span class="line-removed"> 951         nameTable.put(pbeWithMD5AndRC2_oid, &quot;PBEWithMD5AndRC2&quot;);</span>
<span class="line-removed"> 952         nameTable.put(pbeWithSHA1AndDES_oid, &quot;PBEWithSHA1AndDES&quot;);</span>
<span class="line-removed"> 953         nameTable.put(pbeWithSHA1AndRC2_oid, &quot;PBEWithSHA1AndRC2&quot;);</span>
<span class="line-removed"> 954         nameTable.put(pbeWithSHA1AndRC4_128_oid, &quot;PBEWithSHA1AndRC4_128&quot;);</span>
<span class="line-removed"> 955         nameTable.put(pbeWithSHA1AndRC4_40_oid, &quot;PBEWithSHA1AndRC4_40&quot;);</span>
<span class="line-removed"> 956         nameTable.put(pbeWithSHA1AndDESede_oid, &quot;PBEWithSHA1AndDESede&quot;);</span>
<span class="line-removed"> 957         nameTable.put(pbeWithSHA1AndRC2_128_oid, &quot;PBEWithSHA1AndRC2_128&quot;);</span>
<span class="line-removed"> 958         nameTable.put(pbeWithSHA1AndRC2_40_oid, &quot;PBEWithSHA1AndRC2_40&quot;);</span>
<span class="line-removed"> 959     }</span>
 960 
 961     /**
 962      * Creates a signature algorithm name from a digest algorithm
 963      * name and a encryption algorithm name.
 964      */
 965     public static String makeSigAlg(String digAlg, String encAlg) {
 966         digAlg = digAlg.replace(&quot;-&quot;, &quot;&quot;);
 967         if (encAlg.equalsIgnoreCase(&quot;EC&quot;)) encAlg = &quot;ECDSA&quot;;
 968 
 969         return digAlg + &quot;with&quot; + encAlg;
 970     }
 971 
 972     /**
 973      * Extracts the encryption algorithm name from a signature
 974      * algorithm name.
 975      */
 976     public static String getEncAlgFromSigAlg(String signatureAlgorithm) {
 977         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
 978         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
 979         String keyAlgorithm = null;
</pre>
<hr />
<pre>
1027      * part might evolve with time. Remember to update the spec of
1028      * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm(PrivateKey)}
1029      * if updated.
1030      *
1031      * @param k cannot be null
1032      * @return the default alg, might be null if unsupported
1033      */
1034     public static String getDefaultSigAlgForKey(PrivateKey k) {
1035         switch (k.getAlgorithm().toUpperCase(Locale.ENGLISH)) {
1036             case &quot;EC&quot;:
1037                 return ecStrength(KeyUtil.getKeySize(k))
1038                     + &quot;withECDSA&quot;;
1039             case &quot;DSA&quot;:
1040                 return ifcFfcStrength(KeyUtil.getKeySize(k))
1041                     + &quot;withDSA&quot;;
1042             case &quot;RSA&quot;:
1043                 return ifcFfcStrength(KeyUtil.getKeySize(k))
1044                     + &quot;withRSA&quot;;
1045             case &quot;RSASSA-PSS&quot;:
1046                 return &quot;RSASSA-PSS&quot;;


1047             default:
1048                 return null;
1049         }
1050     }
1051 
1052     // Most commonly used PSSParameterSpec and AlgorithmId
1053     private static class PSSParamsHolder {
1054 
1055         final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(
1056                 &quot;SHA-256&quot;, &quot;MGF1&quot;,
1057                 new MGF1ParameterSpec(&quot;SHA-256&quot;),
1058                 32, PSSParameterSpec.TRAILER_FIELD_BC);
1059         final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(
1060                 &quot;SHA-384&quot;, &quot;MGF1&quot;,
1061                 new MGF1ParameterSpec(&quot;SHA-384&quot;),
1062                 48, PSSParameterSpec.TRAILER_FIELD_BC);
1063         final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(
1064                 &quot;SHA-512&quot;, &quot;MGF1&quot;,
1065                 new MGF1ParameterSpec(&quot;SHA-512&quot;),
1066                 64, PSSParameterSpec.TRAILER_FIELD_BC);
</pre>
<hr />
<pre>
1077                         new DerValue(PSSParameters.getEncoded(PSS_384_SPEC)));
1078                 PSS_512_ID = new AlgorithmId(RSASSA_PSS_oid,
1079                         new DerValue(PSSParameters.getEncoded(PSS_512_SPEC)));
1080             } catch (IOException e) {
1081                 throw new AssertionError(&quot;Should not happen&quot;, e);
1082             }
1083         }
1084     }
1085 
1086     public static AlgorithmId getWithParameterSpec(String algName,
1087             AlgorithmParameterSpec spec) throws NoSuchAlgorithmException {
1088 
1089         if (spec == null) {
1090             return AlgorithmId.get(algName);
1091         } else if (spec == PSSParamsHolder.PSS_256_SPEC) {
1092             return PSSParamsHolder.PSS_256_ID;
1093         } else if (spec == PSSParamsHolder.PSS_384_SPEC) {
1094             return PSSParamsHolder.PSS_384_ID;
1095         } else if (spec == PSSParamsHolder.PSS_512_SPEC) {
1096             return PSSParamsHolder.PSS_512_ID;


1097         } else {
1098             try {
1099                 AlgorithmParameters result =
1100                         AlgorithmParameters.getInstance(algName);
1101                 result.init(spec);
1102                 return get(result);
1103             } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {
1104                 throw new ProviderException(e);
1105             }
1106         }
1107     }
1108 
1109     public static AlgorithmParameterSpec getDefaultAlgorithmParameterSpec(
1110             String sigAlg, PrivateKey k) {
1111         if (sigAlg.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
1112             if (k instanceof RSAKey) {
1113                 AlgorithmParameterSpec spec = ((RSAKey) k).getParams();
1114                 if (spec instanceof PSSParameterSpec) {
1115                     return spec;
1116                 }
1117             }
1118             switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {
1119                 case &quot;SHA256&quot;:
1120                     return PSSParamsHolder.PSS_256_SPEC;
1121                 case &quot;SHA384&quot;:
1122                     return PSSParamsHolder.PSS_384_SPEC;
1123                 case &quot;SHA512&quot;:
1124                     return PSSParamsHolder.PSS_512_SPEC;
1125                 default:
1126                     throw new AssertionError(&quot;Should not happen&quot;);
1127             }
1128         } else {
1129             return null;
1130         }
1131     }
1132 








1133     // Values from SP800-57 part 1 rev 4 tables 2 and 3
1134     private static String ecStrength (int bitLength) {
1135         if (bitLength &gt;= 512) { // 256 bits of strength
1136             return &quot;SHA512&quot;;
1137         } else if (bitLength &gt;= 384) {  // 192 bits of strength
1138             return &quot;SHA384&quot;;
1139         } else { // 128 bits of strength and less
1140             return &quot;SHA256&quot;;
1141         }
1142     }
1143 
1144     // Same values for RSA and DSA
1145     private static String ifcFfcStrength (int bitLength) {
1146         if (bitLength &gt; 7680) { // 256 bits
1147             return &quot;SHA512&quot;;
1148         } else if (bitLength &gt; 3072) {  // 192 bits
1149             return &quot;SHA384&quot;;
1150         } else  { // 128 bits and less
1151             return &quot;SHA256&quot;;
1152         }
</pre>
</td>
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.*;
  29 import java.security.interfaces.RSAKey;
  30 import java.security.spec.AlgorithmParameterSpec;
<span class="line-added">  31 import java.security.spec.EdDSAParameterSpec;</span>
  32 import java.security.spec.InvalidParameterSpecException;
  33 import java.security.spec.MGF1ParameterSpec;
  34 import java.security.spec.PSSParameterSpec;
  35 import java.util.*;
<span class="line-added">  36 import java.util.concurrent.ConcurrentHashMap;</span>
  37 import java.security.*;
<span class="line-added">  38 import java.security.interfaces.*;</span>
  39 
  40 import sun.security.rsa.PSSParameters;
  41 import sun.security.util.*;
  42 
  43 
  44 /**
  45  * This class identifies algorithms, such as cryptographic transforms, each
  46  * of which may be associated with parameters.  Instances of this base class
  47  * are used when this runtime environment has no special knowledge of the
  48  * algorithm type, and may also be used in other cases.  Equivalence is
  49  * defined according to OID and (where relevant) parameters.
  50  *
  51  * &lt;P&gt;Subclasses may be used, for example when the algorithm ID has
  52  * associated parameters which some code (e.g. code using public keys) needs
  53  * to have parsed.  Two examples of such algorithms are Diffie-Hellman key
  54  * exchange, and the Digital Signature Standard Algorithm (DSS/DSA).
  55  *
  56  * &lt;P&gt;The OID constants defined in this class correspond to some widely
  57  * used algorithms, for which conventional string names have been defined.
  58  * This class is not a general repository for OIDs, or for such string names.
</pre>
<hr />
<pre>
 185             // (which are optional) SHOULD be omitted.
 186             // RFC 3279 2.3.2: The id-dsa algorithm syntax includes optional
 187             // domain parameters... When omitted, the parameters component
 188             // MUST be omitted entirely
 189             // RFC 3370 3.1: When the id-dsa-with-sha1 algorithm identifier
 190             // is used, the AlgorithmIdentifier parameters field MUST be absent.
 191             /*if (
 192                 algid.equals((Object)SHA_oid) ||
 193                 algid.equals((Object)SHA224_oid) ||
 194                 algid.equals((Object)SHA256_oid) ||
 195                 algid.equals((Object)SHA384_oid) ||
 196                 algid.equals((Object)SHA512_oid) ||
 197                 algid.equals((Object)SHA512_224_oid) ||
 198                 algid.equals((Object)SHA512_256_oid) ||
 199                 algid.equals((Object)DSA_oid) ||
 200                 algid.equals((Object)sha1WithDSA_oid)) {
 201                 ; // no parameter part encoded
 202             } else {
 203                 bytes.putNull();
 204             }*/
<span class="line-modified"> 205             if (algid.equals(RSASSA_PSS_oid) || algid.equals(ed448_oid)</span>
<span class="line-added"> 206                     || algid.equals(ed25519_oid)) {</span>
 207                 // RFC 4055 3.3: when an RSASSA-PSS key does not require
 208                 // parameter validation, field is absent.
 209             } else {
 210                 bytes.putNull();
 211             }
 212         } else {
 213             bytes.putDerValue(params);
 214         }
 215         tmp.write(DerValue.tag_Sequence, bytes);
 216         out.write(tmp.toByteArray());
 217     }
 218 
 219 
 220     /**
 221      * Returns the DER-encoded X.509 AlgorithmId as a byte array.
 222      */
 223     public final byte[] encode() throws IOException {
 224         DerOutputStream out = new DerOutputStream();
 225         derEncode(out);
 226         return out.toByteArray();
</pre>
<hr />
<pre>
 232      * &quot;OID.1.3.14.3.2.13&quot; style notation.  Use the &lt;code&gt;getName&lt;/code&gt;
 233      * call when you do not need to ensure cross-system portability
 234      * of algorithm names, or need a user friendly name.
 235      */
 236     public final ObjectIdentifier getOID () {
 237         return algid;
 238     }
 239 
 240     /**
 241      * Returns a name for the algorithm which may be more intelligible
 242      * to humans than the algorithm&#39;s OID, but which won&#39;t necessarily
 243      * be comprehensible on other systems.  For example, this might
 244      * return a name such as &quot;MD5withRSA&quot; for a signature algorithm on
 245      * some systems.  It also returns names like &quot;OID.1.2.3.4&quot;, when
 246      * no particular name for the algorithm is known.
 247      *
 248      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 249      * returns the &quot;full&quot; signature algorithm (Ex: SHA256withECDSA) directly.
 250      */
 251     public String getName() {
<span class="line-modified"> 252         String oidStr = algid.toString();</span>
<span class="line-modified"> 253         // first check the list of support oids</span>
<span class="line-modified"> 254         KnownOIDs o = KnownOIDs.findMatch(oidStr);</span>
<span class="line-modified"> 255         if (o == KnownOIDs.SpecifiedSHA2withECDSA) {</span>
<span class="line-modified"> 256             if (params != null) {</span>
<span class="line-modified"> 257                 try {</span>
<span class="line-modified"> 258                     AlgorithmId paramsId =</span>
 259                         AlgorithmId.parse(new DerValue(params.toByteArray()));
<span class="line-modified"> 260                     String paramsName = paramsId.getName();</span>
<span class="line-modified"> 261                     return makeSigAlg(paramsName, &quot;EC&quot;);</span>
<span class="line-modified"> 262                 } catch (IOException e) {</span>
<span class="line-modified"> 263                     // ignore</span>
<span class="line-added"> 264                 }</span>
<span class="line-added"> 265             }</span>
<span class="line-added"> 266         }</span>
<span class="line-added"> 267         if (o != null) {</span>
<span class="line-added"> 268             return o.stdName();</span>
<span class="line-added"> 269         } else {</span>
<span class="line-added"> 270             String n = aliasOidsTable().get(oidStr);</span>
<span class="line-added"> 271             if (n != null) {</span>
<span class="line-added"> 272                 return n;</span>
<span class="line-added"> 273             } else {</span>
<span class="line-added"> 274                 return algid.toString();</span>
 275             }
 276         }

 277     }
 278 
 279     public AlgorithmParameters getParameters() {
 280         return algParams;
 281     }
 282 
 283     /**
 284      * Returns the DER encoded parameter, which can then be
 285      * used to initialize java.security.AlgorithmParameters.
 286      *
 287      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 288      * returns null because {@link #getName()} has already returned the &quot;full&quot;
 289      * signature algorithm (Ex: SHA256withECDSA).
 290      *
 291      * @return DER encoded parameters, or null not present.
 292      */
 293     public byte[] getEncodedParams() throws IOException {
<span class="line-modified"> 294         return (params == null ||</span>
<span class="line-added"> 295             algid.toString().equals(KnownOIDs.SpecifiedSHA2withECDSA.value()))</span>
 296                 ? null
 297                 : params.toByteArray();
 298     }
 299 
 300     /**
 301      * Returns true iff the argument indicates the same algorithm
 302      * with the same parameters.
 303      */
 304     public boolean equals(AlgorithmId other) {
 305         boolean paramsEqual = Objects.equals(other.params, params);
 306         return (algid.equals((Object)other.algid) &amp;&amp; paramsEqual);
 307     }
 308 
 309     /**
 310      * Compares this AlgorithmID to another.  If algorithm parameters are
 311      * available, they are compared.  Otherwise, just the object IDs
 312      * for the algorithm are compared.
 313      *
 314      * @param other preferably an AlgorithmId, else an ObjectIdentifier
 315      */
</pre>
<hr />
<pre>
 469         if (oid == null) {
 470             throw new NoSuchAlgorithmException
 471                 (&quot;unrecognized algorithm name: &quot; + algname);
 472         }
 473         return new AlgorithmId(oid, algparams);
 474     }
 475 
 476     /*
 477      * Translates from some common algorithm names to the
 478      * OID with which they&#39;re usually associated ... this mapping
 479      * is the reverse of the one below, except in those cases
 480      * where synonyms are supported or where a given algorithm
 481      * is commonly associated with multiple OIDs.
 482      *
 483      * XXX This method needs to be enhanced so that we can also pass the
 484      * scope of the algorithm name to it, e.g., the algorithm name &quot;DSA&quot;
 485      * may have a different OID when used as a &quot;Signature&quot; algorithm than when
 486      * used as a &quot;KeyPairGenerator&quot; algorithm.
 487      */
 488     private static ObjectIdentifier algOID(String name) throws IOException {
<span class="line-modified"> 489         if (name.startsWith(&quot;OID.&quot;)) {</span>
<span class="line-modified"> 490             name = name.substring(&quot;OID.&quot;.length());</span>





 491         }
 492 
<span class="line-modified"> 493         KnownOIDs k = KnownOIDs.findMatch(name);</span>
<span class="line-modified"> 494         if (k != null) {</span>
<span class="line-modified"> 495             return ObjectIdentifier.of(k);</span>



























































 496         }
 497 
<span class="line-modified"> 498         // unknown algorithm oids</span>
<span class="line-modified"> 499         if (name.indexOf(&quot;.&quot;) == -1) {</span>
<span class="line-modified"> 500             // see if there is a matching oid string alias mapping from</span>
<span class="line-modified"> 501             // 3rd party providers</span>
<span class="line-modified"> 502             name = name.toUpperCase(Locale.ENGLISH);</span>
<span class="line-modified"> 503             String oidStr = aliasOidsTable().get(name);</span>
<span class="line-modified"> 504             if (oidStr != null) {</span>
<span class="line-modified"> 505                 return ObjectIdentifier.of(oidStr);</span>
<span class="line-modified"> 506             } return null;</span>
<span class="line-modified"> 507         } else {</span>
<span class="line-modified"> 508             return ObjectIdentifier.of(name);</span>
































 509         }


 510     }
 511 
<span class="line-modified"> 512     // oid string cache index&#39;ed by algorithm name and oid strings</span>
<span class="line-modified"> 513     private static volatile Map&lt;String,String&gt; aliasOidsTable;</span>
 514 
<span class="line-modified"> 515     // returns the aliasOidsTable, lazily initializing it on first access.</span>
<span class="line-modified"> 516     private static Map&lt;String,String&gt; aliasOidsTable() {</span>
<span class="line-modified"> 517         // Double checked locking; safe because aliasOidsTable is volatile</span>
<span class="line-modified"> 518         Map&lt;String,String&gt; tab = aliasOidsTable;</span>
<span class="line-modified"> 519         if (tab == null) {</span>

 520             synchronized (AlgorithmId.class) {
<span class="line-modified"> 521                 if ((tab = aliasOidsTable) == null) {</span>
<span class="line-modified"> 522                     aliasOidsTable = tab = collectOIDAliases();</span>
<span class="line-added"> 523                 }</span>
 524             }
 525         }
 526         return tab;
 527     }
 528 
<span class="line-modified"> 529     private static boolean isKnownProvider(Provider p) {</span>
<span class="line-modified"> 530         String pn = p.getName();</span>
<span class="line-modified"> 531         String mn = p.getClass().getModule().getName();</span>
<span class="line-modified"> 532         if (pn != null &amp;&amp; mn != null) {</span>
<span class="line-added"> 533             return ((mn.equals(&quot;java.base&quot;) &amp;&amp;</span>
<span class="line-added"> 534                     (pn.equals(&quot;SUN&quot;) || pn.equals(&quot;SunRsaSign&quot;) ||</span>
<span class="line-added"> 535                     pn.equals(&quot;SunJCE&quot;) || pn.equals(&quot;SunJSSE&quot;))) ||</span>
<span class="line-added"> 536                 (mn.equals(&quot;jdk.crypto.ec&quot;) &amp;&amp; pn.equals(&quot;SunEC&quot;)) ||</span>
<span class="line-added"> 537                 (mn.equals(&quot;jdk.crypto.mscapi&quot;) &amp;&amp; pn.equals(&quot;SunMSCAPI&quot;)) ||</span>
<span class="line-added"> 538                 (mn.equals(&quot;jdk.crypto.cryptoki&quot;) &amp;&amp;</span>
<span class="line-added"> 539                     pn.startsWith(&quot;SunPKCS11&quot;)));</span>
<span class="line-added"> 540         } else {</span>
<span class="line-added"> 541             return false;</span>
<span class="line-added"> 542         }</span>
<span class="line-added"> 543     }</span>
<span class="line-added"> 544 </span>
<span class="line-added"> 545     private static ConcurrentHashMap&lt;String, String&gt; collectOIDAliases() {</span>
<span class="line-added"> 546         ConcurrentHashMap&lt;String, String&gt; t = new ConcurrentHashMap&lt;&gt;();</span>
 547         for (Provider provider : Security.getProviders()) {
<span class="line-added"> 548             // skip providers which are already using SecurityProviderConstants</span>
<span class="line-added"> 549             // and KnownOIDs</span>
<span class="line-added"> 550             if (isKnownProvider(provider)) {</span>
<span class="line-added"> 551                 continue;</span>
<span class="line-added"> 552             }</span>
 553             for (Object key : provider.keySet()) {
 554                 String alias = (String)key;
 555                 String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
 556                 int index;
 557                 if (upperCaseAlias.startsWith(&quot;ALG.ALIAS&quot;) &amp;&amp;
<span class="line-modified"> 558                     (index = upperCaseAlias.indexOf(&quot;OID.&quot;, 0)) != -1) {</span>
 559                     index += &quot;OID.&quot;.length();
 560                     if (index == alias.length()) {
 561                         // invalid alias entry
 562                         break;
 563                     }
<span class="line-modified"> 564                     String ostr = alias.substring(index);</span>
 565                     String stdAlgName = provider.getProperty(alias);
 566                     if (stdAlgName != null) {
 567                         stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
 568                     }
<span class="line-modified"> 569                     // add the name-&gt;oid and oid-&gt;name mappings if none exists</span>
<span class="line-modified"> 570                     if (KnownOIDs.findMatch(stdAlgName) == null) {</span>
<span class="line-modified"> 571                         // not override earlier entries if it exists</span>
<span class="line-added"> 572                         t.putIfAbsent(stdAlgName, ostr);</span>
<span class="line-added"> 573                     }</span>
<span class="line-added"> 574                     if (KnownOIDs.findMatch(ostr) == null) {</span>
<span class="line-added"> 575                         // not override earlier entries if it exists</span>
<span class="line-added"> 576                         t.putIfAbsent(ostr, stdAlgName);</span>
 577                     }
 578                 }
 579             }
 580         }
<span class="line-modified"> 581         return t;</span>
 582     }
 583 










 584     public static final ObjectIdentifier MD2_oid =
<span class="line-modified"> 585             ObjectIdentifier.of(KnownOIDs.MD2);</span>
 586 




 587     public static final ObjectIdentifier MD5_oid =
<span class="line-modified"> 588             ObjectIdentifier.of(KnownOIDs.MD5);</span>
 589 






 590     public static final ObjectIdentifier SHA_oid =
<span class="line-modified"> 591             ObjectIdentifier.of(KnownOIDs.SHA_1);</span>
 592 
 593     public static final ObjectIdentifier SHA224_oid =
<span class="line-modified"> 594             ObjectIdentifier.of(KnownOIDs.SHA_224);</span>
 595 
 596     public static final ObjectIdentifier SHA256_oid =
<span class="line-modified"> 597             ObjectIdentifier.of(KnownOIDs.SHA_256);</span>
 598 
 599     public static final ObjectIdentifier SHA384_oid =
<span class="line-modified"> 600             ObjectIdentifier.of(KnownOIDs.SHA_384);</span>
 601 
 602     public static final ObjectIdentifier SHA512_oid =
<span class="line-modified"> 603             ObjectIdentifier.of(KnownOIDs.SHA_512);</span>
 604 
 605     public static final ObjectIdentifier SHA512_224_oid =
<span class="line-modified"> 606             ObjectIdentifier.of(KnownOIDs.SHA_512$224);</span>
 607 
 608     public static final ObjectIdentifier SHA512_256_oid =
<span class="line-modified"> 609             ObjectIdentifier.of(KnownOIDs.SHA_512$256);</span>






































 610 







 611     public static final ObjectIdentifier DSA_oid =
<span class="line-modified"> 612             ObjectIdentifier.of(KnownOIDs.DSA);</span>









 613 
 614     public static final ObjectIdentifier EC_oid =
<span class="line-modified"> 615             ObjectIdentifier.of(KnownOIDs.EC);</span>












































 616 
<span class="line-modified"> 617     public static final ObjectIdentifier RSAEncryption_oid =</span>
<span class="line-modified"> 618             ObjectIdentifier.of(KnownOIDs.RSA);</span>














































 619 
<span class="line-modified"> 620     public static final ObjectIdentifier RSASSA_PSS_oid =</span>
<span class="line-modified"> 621             ObjectIdentifier.of(KnownOIDs.RSASSA_PSS);</span>





 622 
<span class="line-modified"> 623     public static final ObjectIdentifier MGF1_oid =</span>
<span class="line-modified"> 624             ObjectIdentifier.of(KnownOIDs.MGF1);</span>




























 625 
<span class="line-modified"> 626     public static final ObjectIdentifier ed25519_oid =</span>
<span class="line-modified"> 627             ObjectIdentifier.of(KnownOIDs.Ed25519);</span>
<span class="line-modified"> 628     public static final ObjectIdentifier ed448_oid =</span>
<span class="line-modified"> 629             ObjectIdentifier.of(KnownOIDs.Ed448);</span>










































































 630 
 631     /**
 632      * Creates a signature algorithm name from a digest algorithm
 633      * name and a encryption algorithm name.
 634      */
 635     public static String makeSigAlg(String digAlg, String encAlg) {
 636         digAlg = digAlg.replace(&quot;-&quot;, &quot;&quot;);
 637         if (encAlg.equalsIgnoreCase(&quot;EC&quot;)) encAlg = &quot;ECDSA&quot;;
 638 
 639         return digAlg + &quot;with&quot; + encAlg;
 640     }
 641 
 642     /**
 643      * Extracts the encryption algorithm name from a signature
 644      * algorithm name.
 645      */
 646     public static String getEncAlgFromSigAlg(String signatureAlgorithm) {
 647         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
 648         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
 649         String keyAlgorithm = null;
</pre>
<hr />
<pre>
 697      * part might evolve with time. Remember to update the spec of
 698      * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm(PrivateKey)}
 699      * if updated.
 700      *
 701      * @param k cannot be null
 702      * @return the default alg, might be null if unsupported
 703      */
 704     public static String getDefaultSigAlgForKey(PrivateKey k) {
 705         switch (k.getAlgorithm().toUpperCase(Locale.ENGLISH)) {
 706             case &quot;EC&quot;:
 707                 return ecStrength(KeyUtil.getKeySize(k))
 708                     + &quot;withECDSA&quot;;
 709             case &quot;DSA&quot;:
 710                 return ifcFfcStrength(KeyUtil.getKeySize(k))
 711                     + &quot;withDSA&quot;;
 712             case &quot;RSA&quot;:
 713                 return ifcFfcStrength(KeyUtil.getKeySize(k))
 714                     + &quot;withRSA&quot;;
 715             case &quot;RSASSA-PSS&quot;:
 716                 return &quot;RSASSA-PSS&quot;;
<span class="line-added"> 717             case &quot;EDDSA&quot;:</span>
<span class="line-added"> 718                 return edAlgFromKey(k);</span>
 719             default:
 720                 return null;
 721         }
 722     }
 723 
 724     // Most commonly used PSSParameterSpec and AlgorithmId
 725     private static class PSSParamsHolder {
 726 
 727         final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(
 728                 &quot;SHA-256&quot;, &quot;MGF1&quot;,
 729                 new MGF1ParameterSpec(&quot;SHA-256&quot;),
 730                 32, PSSParameterSpec.TRAILER_FIELD_BC);
 731         final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(
 732                 &quot;SHA-384&quot;, &quot;MGF1&quot;,
 733                 new MGF1ParameterSpec(&quot;SHA-384&quot;),
 734                 48, PSSParameterSpec.TRAILER_FIELD_BC);
 735         final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(
 736                 &quot;SHA-512&quot;, &quot;MGF1&quot;,
 737                 new MGF1ParameterSpec(&quot;SHA-512&quot;),
 738                 64, PSSParameterSpec.TRAILER_FIELD_BC);
</pre>
<hr />
<pre>
 749                         new DerValue(PSSParameters.getEncoded(PSS_384_SPEC)));
 750                 PSS_512_ID = new AlgorithmId(RSASSA_PSS_oid,
 751                         new DerValue(PSSParameters.getEncoded(PSS_512_SPEC)));
 752             } catch (IOException e) {
 753                 throw new AssertionError(&quot;Should not happen&quot;, e);
 754             }
 755         }
 756     }
 757 
 758     public static AlgorithmId getWithParameterSpec(String algName,
 759             AlgorithmParameterSpec spec) throws NoSuchAlgorithmException {
 760 
 761         if (spec == null) {
 762             return AlgorithmId.get(algName);
 763         } else if (spec == PSSParamsHolder.PSS_256_SPEC) {
 764             return PSSParamsHolder.PSS_256_ID;
 765         } else if (spec == PSSParamsHolder.PSS_384_SPEC) {
 766             return PSSParamsHolder.PSS_384_ID;
 767         } else if (spec == PSSParamsHolder.PSS_512_SPEC) {
 768             return PSSParamsHolder.PSS_512_ID;
<span class="line-added"> 769         } else if (spec instanceof EdDSAParameterSpec) {</span>
<span class="line-added"> 770             return AlgorithmId.get(algName);</span>
 771         } else {
 772             try {
 773                 AlgorithmParameters result =
 774                         AlgorithmParameters.getInstance(algName);
 775                 result.init(spec);
 776                 return get(result);
 777             } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {
 778                 throw new ProviderException(e);
 779             }
 780         }
 781     }
 782 
 783     public static AlgorithmParameterSpec getDefaultAlgorithmParameterSpec(
 784             String sigAlg, PrivateKey k) {
 785         if (sigAlg.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
 786             if (k instanceof RSAKey) {
 787                 AlgorithmParameterSpec spec = ((RSAKey) k).getParams();
 788                 if (spec instanceof PSSParameterSpec) {
 789                     return spec;
 790                 }
 791             }
 792             switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {
 793                 case &quot;SHA256&quot;:
 794                     return PSSParamsHolder.PSS_256_SPEC;
 795                 case &quot;SHA384&quot;:
 796                     return PSSParamsHolder.PSS_384_SPEC;
 797                 case &quot;SHA512&quot;:
 798                     return PSSParamsHolder.PSS_512_SPEC;
 799                 default:
 800                     throw new AssertionError(&quot;Should not happen&quot;);
 801             }
 802         } else {
 803             return null;
 804         }
 805     }
 806 
<span class="line-added"> 807     private static String edAlgFromKey(PrivateKey k) {</span>
<span class="line-added"> 808         if (k instanceof EdECPrivateKey) {</span>
<span class="line-added"> 809             EdECPrivateKey edKey = (EdECPrivateKey) k;</span>
<span class="line-added"> 810             return edKey.getParams().getName();</span>
<span class="line-added"> 811         }</span>
<span class="line-added"> 812         return &quot;EdDSA&quot;;</span>
<span class="line-added"> 813     }</span>
<span class="line-added"> 814 </span>
 815     // Values from SP800-57 part 1 rev 4 tables 2 and 3
 816     private static String ecStrength (int bitLength) {
 817         if (bitLength &gt;= 512) { // 256 bits of strength
 818             return &quot;SHA512&quot;;
 819         } else if (bitLength &gt;= 384) {  // 192 bits of strength
 820             return &quot;SHA384&quot;;
 821         } else { // 128 bits of strength and less
 822             return &quot;SHA256&quot;;
 823         }
 824     }
 825 
 826     // Same values for RSA and DSA
 827     private static String ifcFfcStrength (int bitLength) {
 828         if (bitLength &gt; 7680) { // 256 bits
 829             return &quot;SHA512&quot;;
 830         } else if (bitLength &gt; 3072) {  // 192 bits
 831             return &quot;SHA384&quot;;
 832         } else  { // 128 bits and less
 833             return &quot;SHA256&quot;;
 834         }
</pre>
</td>
</tr>
</table>
<center><a href="AccessDescription.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ExtendedKeyUsageExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
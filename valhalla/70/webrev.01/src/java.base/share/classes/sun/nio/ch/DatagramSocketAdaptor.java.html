<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/nio/ch/DatagramSocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.lang.invoke.MethodHandle;
 31 import java.lang.invoke.MethodHandles;
 32 import java.lang.invoke.MethodHandles.Lookup;
 33 import java.lang.invoke.MethodType;
 34 import java.lang.invoke.VarHandle;
 35 import java.net.DatagramPacket;
 36 import java.net.DatagramSocket;
 37 import java.net.InetAddress;
 38 import java.net.InetSocketAddress;
 39 import java.net.NetworkInterface;
 40 import java.net.MulticastSocket;
 41 import java.net.SocketAddress;
 42 import java.net.SocketException;
 43 import java.net.SocketOption;
 44 import java.net.StandardSocketOptions;
 45 import java.nio.ByteBuffer;
 46 import java.nio.channels.AlreadyConnectedException;
 47 import java.nio.channels.ClosedChannelException;
 48 import java.nio.channels.DatagramChannel;
 49 import java.nio.channels.MembershipKey;
 50 import java.security.AccessController;
 51 import java.security.PrivilegedAction;
 52 import java.security.PrivilegedExceptionAction;
 53 import java.util.Objects;
 54 import java.util.Set;
 55 import java.util.concurrent.locks.ReentrantLock;
 56 
 57 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 58 
 59 /**
 60  * A multicast datagram socket based on a datagram channel.
 61  *
 62  * This class overrides every public method defined by java.net.DatagramSocket
 63  * and java.net.MulticastSocket. The methods in this class are defined in exactly
 64  * the same order as in java.net.DatagramSocket and java.net.MulticastSocket so
 65  * as to simplify tracking changes.
 66  */
 67 public class DatagramSocketAdaptor
 68     extends MulticastSocket
 69 {
 70     // The channel being adapted
 71     private final DatagramChannelImpl dc;
 72 
 73     // Timeout &quot;option&quot; value for receives
 74     private volatile int timeout;
 75 
 76     private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
 77         super(/*SocketAddress*/ DatagramSockets.NO_DELEGATE);
 78         this.dc = dc;
 79     }
 80 
 81     static DatagramSocket create(DatagramChannelImpl dc) {
 82         try {
 83             return new DatagramSocketAdaptor(dc);
 84         } catch (IOException e) {
 85             throw new Error(e);
 86         }
 87     }
 88 
 89     private void connectInternal(SocketAddress remote) throws SocketException {
 90         try {
 91             dc.connect(remote, false); // skips check for already connected
 92         } catch (ClosedChannelException e) {
 93             // ignore
 94         } catch (Exception x) {
 95             Net.translateToSocketException(x);
 96         }
 97     }
 98 
 99     @Override
100     public void bind(SocketAddress local) throws SocketException {
101         if (local != null) {
102             local = Net.asInetSocketAddress(local);
103         } else {
104             local = new InetSocketAddress(0);
105         }
106         try {
107             dc.bind(local);
108         } catch (Exception x) {
109             Net.translateToSocketException(x);
110         }
111     }
112 
113     @Override
114     public void connect(InetAddress address, int port) {
115         if (address == null)
116             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
117         try {
118             connectInternal(new InetSocketAddress(address, port));
119         } catch (SocketException x) {
120             throw new UncheckedIOException(x);
121         }
122     }
123 
124     @Override
125     public void connect(SocketAddress remote) throws SocketException {
126         if (remote == null)
127             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
128         connectInternal(Net.asInetSocketAddress(remote));
129     }
130 
131     @Override
132     public void disconnect() {
133         try {
134             dc.disconnect();
135         } catch (IOException x) {
136             throw new UncheckedIOException(x);
137         }
138     }
139 
140     @Override
141     public boolean isBound() {
142         return dc.localAddress() != null;
143     }
144 
145     @Override
146     public boolean isConnected() {
147         return dc.remoteAddress() != null;
148     }
149 
150     @Override
151     public InetAddress getInetAddress() {
152         InetSocketAddress remote = dc.remoteAddress();
153         return (remote != null) ? remote.getAddress() : null;
154     }
155 
156     @Override
157     public int getPort() {
158         InetSocketAddress remote = dc.remoteAddress();
159         return (remote != null) ? remote.getPort() : -1;
160     }
161 
162     @Override
163     public SocketAddress getRemoteSocketAddress() {
164         return dc.remoteAddress();
165     }
166 
167     @Override
168     public SocketAddress getLocalSocketAddress() {
169         InetSocketAddress local = dc.localAddress();
170         if (local == null || isClosed())
171             return null;
172 
173         InetAddress addr = local.getAddress();
174         if (addr.isAnyLocalAddress())
175             return local;
176 
177         SecurityManager sm = System.getSecurityManager();
178         if (sm != null) {
179             try {
180                 sm.checkConnect(addr.getHostAddress(), -1);
181             } catch (SecurityException x) {
182                 return new InetSocketAddress(local.getPort());
183             }
184         }
185         return local;
186     }
187 
188     @Override
189     public void send(DatagramPacket p) throws IOException {
190         ByteBuffer bb = null;
191         try {
192             InetSocketAddress target;
193             synchronized (p) {
194                 // copy bytes to temporary direct buffer
195                 int len = p.getLength();
196                 bb = Util.getTemporaryDirectBuffer(len);
197                 bb.put(p.getData(), p.getOffset(), len);
198                 bb.flip();
199 
200                 // target address
201                 if (p.getAddress() == null) {
202                     InetSocketAddress remote = dc.remoteAddress();
203                     if (remote == null) {
204                         // not specified by DatagramSocket
205                         throw new IllegalArgumentException(&quot;Address not set&quot;);
206                     }
207                     // set address/port to maintain compatibility with DatagramSocket
208                     p.setAddress(remote.getAddress());
209                     p.setPort(remote.getPort());
210                     target = remote;
211                 } else {
212                     target = (InetSocketAddress) p.getSocketAddress();
213                 }
214             }
215             // send datagram
216             try {
217                 dc.blockingSend(bb, target);
218             } catch (AlreadyConnectedException e) {
219                 throw new IllegalArgumentException(&quot;Connected and packet address differ&quot;);
220             } catch (ClosedChannelException e) {
221                 var exc = new SocketException(&quot;Socket closed&quot;);
222                 exc.initCause(e);
223                 throw exc;
224             }
225         } finally {
226             if (bb != null) {
227                 Util.offerFirstTemporaryDirectBuffer(bb);
228             }
229         }
230     }
231 
232     @Override
233     public void receive(DatagramPacket p) throws IOException {
234         // get temporary direct buffer with a capacity of p.bufLength
235         int bufLength = DatagramPackets.getBufLength(p);
236         ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);
237         try {
238             long nanos = MILLISECONDS.toNanos(timeout);
239             SocketAddress sender = dc.blockingReceive(bb, nanos);
240             bb.flip();
241             synchronized (p) {
242                 // copy bytes to the DatagramPacket and set length
243                 int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));
244                 bb.get(p.getData(), p.getOffset(), len);
245                 DatagramPackets.setLength(p, len);
246 
247                 // sender address
248                 p.setSocketAddress(sender);
249             }
250         } catch (ClosedChannelException e) {
251             var exc = new SocketException(&quot;Socket closed&quot;);
252             exc.initCause(e);
253             throw exc;
254         } finally {
255             Util.offerFirstTemporaryDirectBuffer(bb);
256         }
257     }
258 
259     @Override
260     public InetAddress getLocalAddress() {
261         if (isClosed())
262             return null;
263         InetSocketAddress local = dc.localAddress();
264         if (local == null)
265             local = new InetSocketAddress(0);
266         InetAddress result = local.getAddress();
267         SecurityManager sm = System.getSecurityManager();
268         if (sm != null) {
269             try {
270                 sm.checkConnect(result.getHostAddress(), -1);
271             } catch (SecurityException x) {
272                 return new InetSocketAddress(0).getAddress();
273             }
274         }
275         return result;
276     }
277 
278     @Override
279     public int getLocalPort() {
280         if (isClosed())
281             return -1;
282         InetSocketAddress local = dc.localAddress();
283         if (local != null) {
284             return local.getPort();
285         }
286         return 0;
287     }
288 
289     @Override
290     public void setSoTimeout(int timeout) throws SocketException {
291         if (isClosed())
292             throw new SocketException(&quot;Socket is closed&quot;);
293         if (timeout &lt; 0)
294             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);
295         this.timeout = timeout;
296     }
297 
298     @Override
299     public int getSoTimeout() throws SocketException {
300         if (isClosed())
301             throw new SocketException(&quot;Socket is closed&quot;);
302         return timeout;
303     }
304 
305     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
306         throws SocketException
307     {
308         try {
309             dc.setOption(name, value);
310         } catch (IOException x) {
311             Net.translateToSocketException(x);
312         }
313     }
314 
315     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
316         throws SocketException
317     {
318         try {
319             dc.setOption(name, value);
320         } catch (IOException x) {
321             Net.translateToSocketException(x);
322         }
323     }
324 
325     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
326         try {
327             return dc.getOption(name).booleanValue();
328         } catch (IOException x) {
329             Net.translateToSocketException(x);
330             return false;       // keep compiler happy
331         }
332     }
333 
334     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
335         try {
336             return dc.getOption(name).intValue();
337         } catch (IOException x) {
338             Net.translateToSocketException(x);
339             return -1;          // keep compiler happy
340         }
341     }
342 
343     @Override
344     public void setSendBufferSize(int size) throws SocketException {
345         if (size &lt;= 0)
346             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
347         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
348     }
349 
350     @Override
351     public int getSendBufferSize() throws SocketException {
352         return getIntOption(StandardSocketOptions.SO_SNDBUF);
353     }
354 
355     @Override
356     public void setReceiveBufferSize(int size) throws SocketException {
357         if (size &lt;= 0)
358             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
359         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
360     }
361 
362     @Override
363     public int getReceiveBufferSize() throws SocketException {
364         return getIntOption(StandardSocketOptions.SO_RCVBUF);
365     }
366 
367     @Override
368     public void setReuseAddress(boolean on) throws SocketException {
369         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
370     }
371 
372     @Override
373     public boolean getReuseAddress() throws SocketException {
374         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
375     }
376 
377     @Override
378     public void setBroadcast(boolean on) throws SocketException {
379         setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);
380     }
381 
382     @Override
383     public boolean getBroadcast() throws SocketException {
384         return getBooleanOption(StandardSocketOptions.SO_BROADCAST);
385     }
386 
387     @Override
388     public void setTrafficClass(int tc) throws SocketException {
389         setIntOption(StandardSocketOptions.IP_TOS, tc);
390     }
391 
392     @Override
393     public int getTrafficClass() throws SocketException {
394         return getIntOption(StandardSocketOptions.IP_TOS);
395     }
396 
397     @Override
398     public void close() {
399         try {
400             dc.close();
401         } catch (IOException x) {
402             throw new Error(x);
403         }
404     }
405 
406     @Override
407     public boolean isClosed() {
408         return !dc.isOpen();
409     }
410 
411     @Override
412     public DatagramChannel getChannel() {
413         return dc;
414     }
415 
416     @Override
417     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
418         dc.setOption(name, value);
419         return this;
420     }
421 
422     @Override
423     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
424         return dc.getOption(name);
425     }
426 
427     @Override
428     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
429         return dc.supportedOptions();
430     }
431 
432     // -- java.net.MulticastSocket --
433 
434     // used to coordinate changing TTL with the deprecated send method
435     private final ReentrantLock sendLock = new ReentrantLock();
436 
437     // cached outgoing interface (for use by setInterface/getInterface)
438     private final Object outgoingInterfaceLock = new Object();
439     private NetworkInterface outgoingNetworkInterface;
440     private InetAddress outgoingInetAddress;
441 
442     @Override
443     @Deprecated
444     public void setTTL(byte ttl) throws IOException {
445         setTimeToLive(Byte.toUnsignedInt(ttl));
446     }
447 
448     @Override
449     public void setTimeToLive(int ttl) throws IOException {
450         sendLock.lock();
451         try {
452             setIntOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);
453         } finally {
454             sendLock.unlock();
455         }
456     }
457 
458     @Override
459     @Deprecated
460     public byte getTTL() throws IOException {
461         return (byte) getTimeToLive();
462     }
463 
464     @Override
465     public int getTimeToLive() throws IOException {
466         sendLock.lock();
467         try {
468             return getIntOption(StandardSocketOptions.IP_MULTICAST_TTL);
469         } finally {
470             sendLock.unlock();
471         }
472     }
473 
474     @Override
475     @Deprecated
476     public void joinGroup(InetAddress group) throws IOException {
477         Objects.requireNonNull(group);
478         try {
479             joinGroup(new InetSocketAddress(group, 0), null);
480         } catch (IllegalArgumentException iae) {
481             // 1-arg joinGroup does not specify IllegalArgumentException
482             throw (SocketException) new SocketException(&quot;joinGroup failed&quot;).initCause(iae);
483         }
484     }
485 
486     @Override
487     @Deprecated
488     public void leaveGroup(InetAddress group) throws IOException {
489         Objects.requireNonNull(group);
490         try {
491             leaveGroup(new InetSocketAddress(group, 0), null);
492         } catch (IllegalArgumentException iae) {
493             // 1-arg leaveGroup does not specify IllegalArgumentException
494             throw (SocketException) new SocketException(&quot;leaveGroup failed&quot;).initCause(iae);
495         }
496     }
497 
498     /**
499      * Checks a SocketAddress to ensure that it is a multicast address.
500      *
501      * @return the multicast group
502      * @throws IllegalArgumentException if group is null, an unsupported address
503      *         type, or an unresolved address
504      * @throws SocketException if group is not a multicast address
505      */
506     private static InetAddress checkGroup(SocketAddress mcastaddr) throws SocketException {
507         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
508             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
509         InetAddress group = ((InetSocketAddress) mcastaddr).getAddress();
510         if (group == null)
511             throw new IllegalArgumentException(&quot;Unresolved address&quot;);
512         if (!group.isMulticastAddress())
513             throw new SocketException(&quot;Not a multicast address&quot;);
514         return group;
515     }
516 
517     @Override
518     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
519         InetAddress group = checkGroup(mcastaddr);
520         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();
521         if (isClosed())
522             throw new SocketException(&quot;Socket is closed&quot;);
523         synchronized (this) {
524             MembershipKey key = dc.findMembership(group, ni);
525             if (key != null) {
526                 // already a member but need to check permission anyway
527                 SecurityManager sm = System.getSecurityManager();
528                 if (sm != null)
529                     sm.checkMulticast(group);
530                 throw new SocketException(&quot;Already a member of group&quot;);
531             }
532             dc.join(group, ni);  // checks permission
533         }
534     }
535 
536     @Override
537     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
538         InetAddress group = checkGroup(mcastaddr);
539         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();
540         if (isClosed())
541             throw new SocketException(&quot;Socket is closed&quot;);
542         SecurityManager sm = System.getSecurityManager();
543         if (sm != null)
544             sm.checkMulticast(group);
545         synchronized (this) {
546             MembershipKey key = dc.findMembership(group, ni);
547             if (key == null)
548                 throw new SocketException(&quot;Not a member of group&quot;);
549             key.drop();
550         }
551     }
552 
553     @Override
554     @Deprecated
555     public void setInterface(InetAddress inf) throws SocketException {
556         if (inf == null)
557             throw new SocketException(&quot;Invalid value &#39;null&#39;&quot;);
558         NetworkInterface ni = NetworkInterface.getByInetAddress(inf);
559         if (ni == null) {
560             String address = inf.getHostAddress();
561             throw new SocketException(&quot;No network interface with address &quot; + address);
562         }
563         synchronized (outgoingInterfaceLock) {
564             // set interface and update cached values
565             setNetworkInterface(ni);
566             outgoingNetworkInterface = ni;
567             outgoingInetAddress = inf;
568         }
569     }
570 
571     @Override
572     @Deprecated
573     public InetAddress getInterface() throws SocketException {
574         synchronized (outgoingInterfaceLock) {
575             NetworkInterface ni = outgoingNetworkInterface();
576             if (ni != null) {
577                 if (ni.equals(outgoingNetworkInterface)) {
578                     return outgoingInetAddress;
579                 } else {
580                     // network interface has changed so update cached values
581                     PrivilegedAction&lt;InetAddress&gt; pa;
582                     pa = () -&gt; ni.inetAddresses().findFirst().orElse(null);
583                     InetAddress ia = AccessController.doPrivileged(pa);
584                     if (ia == null)
585                         throw new SocketException(&quot;Network interface has no IP address&quot;);
586                     outgoingNetworkInterface = ni;
587                     outgoingInetAddress = ia;
588                     return ia;
589                 }
590             }
591         }
592 
593         // no interface set
594         return anyInetAddress();
595     }
596 
597     @Override
598     public void setNetworkInterface(NetworkInterface netIf) throws SocketException {
599         try {
600             setOption(StandardSocketOptions.IP_MULTICAST_IF, netIf);
601         } catch (IOException e) {
602             Net.translateToSocketException(e);
603         }
604     }
605 
606     @Override
607     public NetworkInterface getNetworkInterface() throws SocketException {
608         NetworkInterface ni = outgoingNetworkInterface();
609         if (ni == null) {
610             // return NetworkInterface with index == 0 as placeholder
611             ni = anyNetworkInterface();
612         }
613         return ni;
614     }
615 
616     @Override
617     @Deprecated
618     public void setLoopbackMode(boolean disable) throws SocketException {
619         boolean enable = !disable;
620         setBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP, enable);
621     }
622 
623     @Override
624     @Deprecated
625     public boolean getLoopbackMode() throws SocketException {
626         boolean enabled = getBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP);
627         return !enabled;
628     }
629 
630     @Override
631     @Deprecated
632     public void send(DatagramPacket p, byte ttl) throws IOException {
633         sendLock.lock();
634         try {
635             int oldValue = getTimeToLive();
636             try {
637                 setTTL(ttl);
638                 send(p);
639             } finally {
640                 setTimeToLive(oldValue);
641             }
642         } finally {
643             sendLock.unlock();
644         }
645     }
646 
647     /**
648      * Returns the outgoing NetworkInterface or null if not set.
649      */
650     private NetworkInterface outgoingNetworkInterface() throws SocketException {
651         try {
652             return getOption(StandardSocketOptions.IP_MULTICAST_IF);
653         } catch (IOException e) {
654             Net.translateToSocketException(e);
655             return null; // keep compiler happy
656         }
657     }
658 
659     /**
660      * Returns the default NetworkInterface to use when joining or leaving a
661      * multicast group and a network interface is not specified.
662      * This method will return the outgoing NetworkInterface if set, otherwise
663      * the result of NetworkInterface.getDefault(), otherwise a NetworkInterface
664      * with index == 0 as a placeholder for &quot;any network interface&quot;.
665      */
666     private NetworkInterface defaultNetworkInterface() throws SocketException {
667         NetworkInterface ni = outgoingNetworkInterface();
668         if (ni == null)
669             ni = NetworkInterfaces.getDefault();   // macOS
670         if (ni == null)
671             ni = anyNetworkInterface();
672         return ni;
673     }
674 
675     /**
676      * Returns the placeholder for &quot;any network interface&quot;, its index is 0.
677      */
678     private NetworkInterface anyNetworkInterface() {
679         InetAddress[] addrs = new InetAddress[1];
680         addrs[0] = anyInetAddress();
681         return NetworkInterfaces.newNetworkInterface(addrs[0].getHostName(), 0, addrs);
682     }
683 
684     /**
685      * Returns the InetAddress representing anyLocalAddress.
686      */
687     private InetAddress anyInetAddress() {
688         return new InetSocketAddress(0).getAddress();
689     }
690 
691     /**
692      * Defines static methods to get/set DatagramPacket fields and workaround
693      * DatagramPacket deficiencies.
694      */
695     private static class DatagramPackets {
696         private static final VarHandle LENGTH;
697         private static final VarHandle BUF_LENGTH;
698         static {
699             try {
700                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;
701                     MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());
702                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);
703                 LENGTH = l.findVarHandle(DatagramPacket.class, &quot;length&quot;, int.class);
704                 BUF_LENGTH = l.findVarHandle(DatagramPacket.class, &quot;bufLength&quot;, int.class);
705             } catch (Exception e) {
706                 throw new ExceptionInInitializerError(e);
707             }
708         }
709 
710         /**
711          * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be
712          * used at this time because it sets both the length and bufLength fields.
713          */
714         static void setLength(DatagramPacket p, int value) {
715             synchronized (p) {
716                 LENGTH.set(p, value);
717             }
718         }
719 
720         /**
721          * Returns the value of the DatagramPacket.bufLength field.
722          */
723         static int getBufLength(DatagramPacket p) {
724             synchronized (p) {
725                 return (int) BUF_LENGTH.get(p);
726             }
727         }
728     }
729 
730     /**
731      * Defines static methods to invoke non-public NetworkInterface methods.
732      */
733     private static class NetworkInterfaces {
734         static final MethodHandle GET_DEFAULT;
735         static final MethodHandle CONSTRUCTOR;
736         static {
737             try {
738                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;
739                     MethodHandles.privateLookupIn(NetworkInterface.class, MethodHandles.lookup());
740                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);
741                 MethodType methodType = MethodType.methodType(NetworkInterface.class);
742                 GET_DEFAULT = l.findStatic(NetworkInterface.class, &quot;getDefault&quot;, methodType);
743                 methodType = MethodType.methodType(void.class, String.class, int.class, InetAddress[].class);
744                 CONSTRUCTOR = l.findConstructor(NetworkInterface.class, methodType);
745             } catch (Exception e) {
746                 throw new ExceptionInInitializerError(e);
747             }
748         }
749 
750         /**
751          * Returns the default network interface or null.
752          */
753         static NetworkInterface getDefault() {
754             try {
755                 return (NetworkInterface) GET_DEFAULT.invokeExact();
756             } catch (Throwable e) {
757                 throw new InternalError(e);
758             }
759         }
760 
761         /**
762          * Creates a NetworkInterface with the given name index and addresses.
763          */
764         static NetworkInterface newNetworkInterface(String name, int index, InetAddress[] addrs) {
765             try {
766                 return (NetworkInterface) CONSTRUCTOR.invoke(name, index, addrs);
767             } catch (Throwable e) {
768                 throw new InternalError(e);
769             }
770         }
771     }
772 
773     /**
774      * Provides access to the value of the private static DatagramSocket.NO_DELEGATE
775      */
776     private static class DatagramSockets {
777         private static final SocketAddress NO_DELEGATE;
778 
779         static {
780             try {
781                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;
782                         MethodHandles.privateLookupIn(DatagramSocket.class, MethodHandles.lookup());
783                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);
784                 NO_DELEGATE = (SocketAddress)
785                         l.findStaticVarHandle(DatagramSocket.class, &quot;NO_DELEGATE&quot;,
786                                 SocketAddress.class).get();
787             } catch (Exception e) {
788                 throw new ExceptionInInitializerError(e);
789             }
790         }
791     }
792 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial25519.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util.math.intpoly;
 27 
 28 import java.math.BigInteger;
 29 
 30 /**
 31  * An IntegerFieldModuloP designed for use with the Curve25519.
 32  * The representation uses 10 signed long values.
 33  */
 34 
 35 public class IntegerPolynomial25519 extends IntegerPolynomial {
 36 
 37     private static final int POWER = 255;
 38     private static final int SUBTRAHEND = 19;
 39     private static final int NUM_LIMBS = 10;
 40     private static final int BITS_PER_LIMB = 26;
 41     public static final BigInteger MODULUS
 42         = TWO.pow(POWER).subtract(BigInteger.valueOf(SUBTRAHEND));
 43 
 44     // BITS_PER_LIMB does not divide POWER, so reduction is a bit complicated
 45     // The constants below help split up values during reduction
 46     private static final int BIT_OFFSET = NUM_LIMBS * BITS_PER_LIMB - POWER;
 47     private static final int LIMB_MASK = -1 &gt;&gt;&gt; (64 - BITS_PER_LIMB);
 48     private static final int RIGHT_BIT_OFFSET = BITS_PER_LIMB - BIT_OFFSET;
 49 
 50     public IntegerPolynomial25519() {
 51         super(BITS_PER_LIMB, NUM_LIMBS, 1, MODULUS);
 52     }
 53 
<a name="2" id="anc2"></a>






 54     @Override
 55     protected void finalCarryReduceLast(long[] limbs) {
 56 
 57         long reducedValue = limbs[numLimbs - 1] &gt;&gt; RIGHT_BIT_OFFSET;
 58         limbs[numLimbs - 1] -= reducedValue &lt;&lt; RIGHT_BIT_OFFSET;
 59         limbs[0] += reducedValue * SUBTRAHEND;
 60     }
 61 
 62     @Override
 63     protected void reduce(long[] a) {
 64 
 65         // carry(8, 2)
 66         long carry8 = carryValue(a[8]);
 67         a[8] -= (carry8 &lt;&lt; BITS_PER_LIMB);
 68         a[9] += carry8;
 69 
 70         long carry9 = carryValue(a[9]);
 71         a[9] -= (carry9 &lt;&lt; BITS_PER_LIMB);
 72 
 73         // reduce(0, 1)
 74         long reducedValue10 = (carry9 * SUBTRAHEND);
 75         a[0] += ((reducedValue10 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
 76         a[1] += reducedValue10 &gt;&gt; RIGHT_BIT_OFFSET;
 77 
 78         // carry(0, 9)
 79         carry(a, 0, 9);
 80     }
 81 
 82     @Override
 83     protected void mult(long[] a, long[] b, long[] r) {
<a name="3" id="anc3"></a><span class="line-removed"> 84 </span>
<span class="line-removed"> 85         // Use grade-school multiplication into primitives to avoid the</span>
<span class="line-removed"> 86         // temporary array allocation. This is equivalent to the following</span>
<span class="line-removed"> 87         // code:</span>
<span class="line-removed"> 88         //  long[] c = new long[2 * NUM_LIMBS - 1];</span>
<span class="line-removed"> 89         //  for(int i = 0; i &lt; NUM_LIMBS; i++) {</span>
<span class="line-removed"> 90         //      for(int j - 0; j &lt; NUM_LIMBS; j++) {</span>
<span class="line-removed"> 91         //          c[i + j] += a[i] * b[j]</span>
<span class="line-removed"> 92         //      }</span>
<span class="line-removed"> 93         //  }</span>
<span class="line-removed"> 94 </span>
 95         long c0 = (a[0] * b[0]);
 96         long c1 = (a[0] * b[1]) + (a[1] * b[0]);
 97         long c2 = (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]);
 98         long c3 = (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]);
 99         long c4 = (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]);
100         long c5 = (a[0] * b[5]) + (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]) + (a[5] * b[0]);
101         long c6 = (a[0] * b[6]) + (a[1] * b[5]) + (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]) + (a[5] * b[1]) + (a[6] * b[0]);
102         long c7 = (a[0] * b[7]) + (a[1] * b[6]) + (a[2] * b[5]) + (a[3] * b[4]) + (a[4] * b[3]) + (a[5] * b[2]) + (a[6] * b[1]) + (a[7] * b[0]);
103         long c8 = (a[0] * b[8]) + (a[1] * b[7]) + (a[2] * b[6]) + (a[3] * b[5]) + (a[4] * b[4]) + (a[5] * b[3]) + (a[6] * b[2]) + (a[7] * b[1]) + (a[8] * b[0]);
104         long c9 = (a[0] * b[9]) + (a[1] * b[8]) + (a[2] * b[7]) + (a[3] * b[6]) + (a[4] * b[5]) + (a[5] * b[4]) + (a[6] * b[3]) + (a[7] * b[2]) + (a[8] * b[1]) + (a[9] * b[0]);
105         long c10 = (a[1] * b[9]) + (a[2] * b[8]) + (a[3] * b[7]) + (a[4] * b[6]) + (a[5] * b[5]) + (a[6] * b[4]) + (a[7] * b[3]) + (a[8] * b[2]) + (a[9] * b[1]);
106         long c11 = (a[2] * b[9]) + (a[3] * b[8]) + (a[4] * b[7]) + (a[5] * b[6]) + (a[6] * b[5]) + (a[7] * b[4]) + (a[8] * b[3]) + (a[9] * b[2]);
107         long c12 = (a[3] * b[9]) + (a[4] * b[8]) + (a[5] * b[7]) + (a[6] * b[6]) + (a[7] * b[5]) + (a[8] * b[4]) + (a[9] * b[3]);
108         long c13 = (a[4] * b[9]) + (a[5] * b[8]) + (a[6] * b[7]) + (a[7] * b[6]) + (a[8] * b[5]) + (a[9] * b[4]);
109         long c14 = (a[5] * b[9]) + (a[6] * b[8]) + (a[7] * b[7]) + (a[8] * b[6]) + (a[9] * b[5]);
110         long c15 = (a[6] * b[9]) + (a[7] * b[8]) + (a[8] * b[7]) + (a[9] * b[6]);
111         long c16 = (a[7] * b[9]) + (a[8] * b[8]) + (a[9] * b[7]);
112         long c17 = (a[8] * b[9]) + (a[9] * b[8]);
113         long c18 = a[9] * b[9];
114 
115         carryReduce(r, c0, c1, c2, c3, c4, c5, c6, c7, c8,
116             c9, c10, c11, c12, c13, c14, c15, c16, c17, c18);
117 
118     }
119 
120     private void carryReduce(long[] r, long c0, long c1, long c2,
121                              long c3, long c4, long c5, long c6,
122                              long c7, long c8, long c9, long c10,
123                              long c11, long c12, long c13, long c14,
124                              long c15, long c16, long c17, long c18) {
125         // reduce(7,2)
126         long reducedValue17 = (c17 * SUBTRAHEND);
127         c7 += (reducedValue17 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK;
128         c8 += reducedValue17 &gt;&gt; RIGHT_BIT_OFFSET;
129 
130         long reducedValue18 = (c18 * SUBTRAHEND);
131         c8 += (reducedValue18 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK;
132         c9 += reducedValue18 &gt;&gt; RIGHT_BIT_OFFSET;
133 
134         // carry(8,2)
135         long carry8 = carryValue(c8);
136         r[8] = c8 - (carry8 &lt;&lt; BITS_PER_LIMB);
137         c9 += carry8;
138 
139         long carry9 = carryValue(c9);
140         r[9] = c9 - (carry9 &lt;&lt; BITS_PER_LIMB);
141         c10 += carry9;
142 
143         // reduce(0,7)
144         long reducedValue10 = (c10 * SUBTRAHEND);
145         r[0] = c0 + ((reducedValue10 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
146         c1 += reducedValue10 &gt;&gt; RIGHT_BIT_OFFSET;
147 
148         long reducedValue11 = (c11 * SUBTRAHEND);
149         r[1] = c1 + ((reducedValue11 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
150         c2 += reducedValue11 &gt;&gt; RIGHT_BIT_OFFSET;
151 
152         long reducedValue12 = (c12 * SUBTRAHEND);
153         r[2] = c2 + ((reducedValue12 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
154         c3 += reducedValue12 &gt;&gt; RIGHT_BIT_OFFSET;
155 
156         long reducedValue13 = (c13 * SUBTRAHEND);
157         r[3] = c3 + ((reducedValue13 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
158         c4 += reducedValue13 &gt;&gt; RIGHT_BIT_OFFSET;
159 
160         long reducedValue14 = (c14 * SUBTRAHEND);
161         r[4] = c4 + ((reducedValue14 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
162         c5 += reducedValue14 &gt;&gt; RIGHT_BIT_OFFSET;
163 
164         long reducedValue15 = (c15 * SUBTRAHEND);
165         r[5] = c5 + ((reducedValue15 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
166         c6 += reducedValue15 &gt;&gt; RIGHT_BIT_OFFSET;
167 
168         long reducedValue16 = (c16 * SUBTRAHEND);
169         r[6] = c6 + ((reducedValue16 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
170         r[7] = c7 + (reducedValue16 &gt;&gt; RIGHT_BIT_OFFSET);
171 
172         // carry(0,9)
173         carry(r, 0, 9);
174     }
<a name="4" id="anc4"></a><span class="line-removed">175 </span>
176     @Override
177     protected void square(long[] a, long[] r) {
178 
179         // Use grade-school multiplication with a simple squaring optimization.
180         // Multiply into primitives to avoid the temporary array allocation.
181         // This is equivalent to the following code:
182         //  long[] c = new long[2 * NUM_LIMBS - 1];
183         //  for(int i = 0; i &lt; NUM_LIMBS; i++) {
184         //      c[2 * i] = a[i] * a[i];
185         //      for(int j = i + 1; j &lt; NUM_LIMBS; j++) {
186         //          c[i + j] += 2 * a[i] * a[j]
187         //      }
188         //  }
189 
190         long c0 = a[0] * a[0];
191         long c1 = 2 * a[0] * a[1];
192         long c2 = a[1] * a[1] + 2 * a[0] * a[2];
193         long c3 = 2 * (a[0] * a[3] + a[1] * a[2]);
194         long c4 = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3]);
195         long c5 = 2 * (a[0] * a[5] + a[1] * a[4] + a[2] * a[3]);
196         long c6 = a[3] * a[3] + 2 * (a[0] * a[6] + a[1] * a[5] + a[2] * a[4]);
197         long c7 = 2 * (a[0] * a[7] + a[1] * a[6] + a[2] * a[5] + a[3] * a[4]);
198         long c8 = a[4] * a[4] + 2 * (a[0] * a[8] + a[1] * a[7] + a[2] * a[6] + a[3] * a[5]);
199         long c9 = 2 * (a[0] * a[9] + a[1] * a[8] + a[2] * a[7] + a[3] * a[6] + a[4] * a[5]);
200         long c10 = a[5] * a[5] + 2 * (a[1] * a[9] + a[2] * a[8] + a[3] * a[7] + a[4] * a[6]);
201         long c11 = 2 * (a[2] * a[9] + a[3] * a[8] + a[4] * a[7] + a[5] * a[6]);
202         long c12 = a[6] * a[6] + 2 * (a[3] * a[9] + a[4] * a[8] + a[5] * a[7]);
203         long c13 = 2 * (a[4] * a[9] + a[5] * a[8] + a[6] * a[7]);
204         long c14 = a[7] * a[7] + 2 * (a[5] * a[9] + a[6] * a[8]);
205         long c15 = 2 * (a[6] * a[9] + a[7] * a[8]);
206         long c16 = a[8] * a[8] + 2 * a[7] * a[9];
207         long c17 = 2 * a[8] * a[9];
208         long c18 = a[9] * a[9];
209 
210         carryReduce(r, c0, c1, c2, c3, c4, c5, c6, c7, c8,
211             c9, c10, c11, c12, c13, c14, c15, c16, c17, c18);
212     }
213 
214 
215 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerSocketChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../security/pkcs/ContentInfo.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.InetAddress;

  31 import java.net.InetSocketAddress;
  32 import java.net.ProtocolFamily;
  33 import java.net.Socket;
  34 import java.net.SocketAddress;
  35 import java.net.SocketException;
  36 import java.net.SocketOption;
  37 import java.net.SocketTimeoutException;
  38 import java.net.StandardProtocolFamily;
  39 import java.net.StandardSocketOptions;
  40 import java.nio.ByteBuffer;
  41 import java.nio.channels.AlreadyBoundException;
  42 import java.nio.channels.AlreadyConnectedException;
  43 import java.nio.channels.AsynchronousCloseException;
  44 import java.nio.channels.ClosedChannelException;
  45 import java.nio.channels.ConnectionPendingException;
  46 import java.nio.channels.IllegalBlockingModeException;
  47 import java.nio.channels.NoConnectionPendingException;
  48 import java.nio.channels.NotYetConnectedException;
  49 import java.nio.channels.SelectionKey;
  50 import java.nio.channels.SocketChannel;
</pre>
<hr />
<pre>
  54 import java.util.Objects;
  55 import java.util.Set;
  56 import java.util.concurrent.locks.ReentrantLock;
  57 
  58 import sun.net.ConnectionResetException;
  59 import sun.net.NetHooks;
  60 import sun.net.ext.ExtendedSocketOptions;
  61 import sun.net.util.SocketExceptions;
  62 
  63 /**
  64  * An implementation of SocketChannels
  65  */
  66 
  67 class SocketChannelImpl
  68     extends SocketChannel
  69     implements SelChImpl
  70 {
  71     // Used to make native read and write calls
  72     private static final NativeDispatcher nd = new SocketDispatcher();
  73 



  74     // Our file descriptor object
  75     private final FileDescriptor fd;
  76     private final int fdVal;
  77 
  78     // Lock held by current reading or connecting thread
  79     private final ReentrantLock readLock = new ReentrantLock();
  80 
  81     // Lock held by current writing or connecting thread
  82     private final ReentrantLock writeLock = new ReentrantLock();
  83 
  84     // Lock held by any thread that modifies the state fields declared below
  85     // DO NOT invoke a blocking I/O operation while holding this lock!
  86     private final Object stateLock = new Object();
  87 
  88     // Input/Output closed
  89     private volatile boolean isInputClosed;
  90     private volatile boolean isOutputClosed;
  91 
  92     // Connection reset protected by readLock
  93     private boolean connectionReset;
</pre>
<hr />
<pre>
 101     private static final int ST_UNCONNECTED = 0;
 102     private static final int ST_CONNECTIONPENDING = 1;
 103     private static final int ST_CONNECTED = 2;
 104     private static final int ST_CLOSING = 3;
 105     private static final int ST_CLOSED = 4;
 106     private volatile int state;  // need stateLock to change
 107 
 108     // IDs of native threads doing reads and writes, for signalling
 109     private long readerThread;
 110     private long writerThread;
 111 
 112     // Binding
 113     private InetSocketAddress localAddress;
 114     private InetSocketAddress remoteAddress;
 115 
 116     // Socket adaptor, created on demand
 117     private Socket socket;
 118 
 119     // -- End of fields protected by stateLock
 120 
<span class="line-removed"> 121 </span>
 122     // Constructor for normal connecting sockets
 123     //
 124     SocketChannelImpl(SelectorProvider sp) throws IOException {






 125         super(sp);
<span class="line-modified"> 126         this.fd = Net.socket(true);</span>









 127         this.fdVal = IOUtil.fdVal(fd);
 128     }
 129 
 130     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
 131         throws IOException
 132     {
 133         super(sp);



 134         this.fd = fd;
 135         this.fdVal = IOUtil.fdVal(fd);

 136         if (bound) {
 137             synchronized (stateLock) {
 138                 this.localAddress = Net.localAddress(fd);
 139             }
 140         }
 141     }
 142 
 143     // Constructor for sockets obtained from server sockets
 144     //
<span class="line-modified"> 145     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, InetSocketAddress isa)</span>



 146         throws IOException
 147     {
 148         super(sp);

 149         this.fd = fd;
 150         this.fdVal = IOUtil.fdVal(fd);
 151         synchronized (stateLock) {
 152             this.localAddress = Net.localAddress(fd);
 153             this.remoteAddress = isa;
 154             this.state = ST_CONNECTED;
 155         }
 156     }
 157 
 158     /**
 159      * Checks that the channel is open.
 160      *
 161      * @throws ClosedChannelException if channel is closed (or closing)
 162      */
 163     private void ensureOpen() throws ClosedChannelException {
 164         if (!isOpen())
 165             throw new ClosedChannelException();
 166     }
 167 
 168     /**
</pre>
<hr />
<pre>
 208         synchronized (stateLock) {
 209             ensureOpen();
 210             return remoteAddress;
 211         }
 212     }
 213 
 214     @Override
 215     public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value)
 216         throws IOException
 217     {
 218         Objects.requireNonNull(name);
 219         if (!supportedOptions().contains(name))
 220             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 221         if (!name.type().isInstance(value))
 222             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);
 223 
 224         synchronized (stateLock) {
 225             ensureOpen();
 226 
 227             if (name == StandardSocketOptions.IP_TOS) {
<span class="line-removed"> 228                 ProtocolFamily family = Net.isIPv6Available() ?</span>
<span class="line-removed"> 229                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;</span>
 230                 Net.setSocketOption(fd, family, name, value);
 231                 return this;
 232             }
 233 
 234             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 235                 // SO_REUSEADDR emulated when using exclusive bind
 236                 isReuseAddress = (Boolean)value;
 237                 return this;
 238             }
 239 
 240             // no options that require special handling
 241             Net.setSocketOption(fd, name, value);
 242             return this;
 243         }
 244     }
 245 
 246     @Override
 247     @SuppressWarnings(&quot;unchecked&quot;)
 248     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 249         throws IOException
 250     {
 251         Objects.requireNonNull(name);
 252         if (!supportedOptions().contains(name))
 253             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 254 
 255         synchronized (stateLock) {
 256             ensureOpen();
 257 
 258             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 259                 // SO_REUSEADDR emulated when using exclusive bind
 260                 return (T)Boolean.valueOf(isReuseAddress);
 261             }
 262 
<span class="line-modified"> 263             // special handling for IP_TOS: always return 0 when IPv6</span>
 264             if (name == StandardSocketOptions.IP_TOS) {
<span class="line-removed"> 265                 ProtocolFamily family = Net.isIPv6Available() ?</span>
<span class="line-removed"> 266                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;</span>
 267                 return (T) Net.getSocketOption(fd, family, name);
 268             }
 269 
 270             // no options that require special handling
 271             return (T) Net.getSocketOption(fd, name);
 272         }
 273     }
 274 
 275     private static class DefaultOptionsHolder {
 276         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 277 
 278         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 279             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 280             set.add(StandardSocketOptions.SO_SNDBUF);
 281             set.add(StandardSocketOptions.SO_RCVBUF);
 282             set.add(StandardSocketOptions.SO_KEEPALIVE);
 283             set.add(StandardSocketOptions.SO_REUSEADDR);
 284             if (Net.isReusePortAvailable()) {
 285                 set.add(StandardSocketOptions.SO_REUSEPORT);
 286             }
</pre>
<hr />
<pre>
 615      * Returns the remote address, or null if not connected
 616      */
 617     InetSocketAddress remoteAddress() {
 618         synchronized (stateLock) {
 619             return remoteAddress;
 620         }
 621     }
 622 
 623     @Override
 624     public SocketChannel bind(SocketAddress local) throws IOException {
 625         readLock.lock();
 626         try {
 627             writeLock.lock();
 628             try {
 629                 synchronized (stateLock) {
 630                     ensureOpen();
 631                     if (state == ST_CONNECTIONPENDING)
 632                         throw new ConnectionPendingException();
 633                     if (localAddress != null)
 634                         throw new AlreadyBoundException();
<span class="line-modified"> 635                     InetSocketAddress isa = (local == null) ?</span>
<span class="line-modified"> 636                         new InetSocketAddress(0) : Net.checkAddress(local);</span>




 637                     SecurityManager sm = System.getSecurityManager();
 638                     if (sm != null) {
 639                         sm.checkListen(isa.getPort());
 640                     }
 641                     NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
<span class="line-modified"> 642                     Net.bind(fd, isa.getAddress(), isa.getPort());</span>
 643                     localAddress = Net.localAddress(fd);
 644                 }
 645             } finally {
 646                 writeLock.unlock();
 647             }
 648         } finally {
 649             readLock.unlock();
 650         }
 651         return this;
 652     }
 653 
 654     @Override
 655     public boolean isConnected() {
 656         return (state == ST_CONNECTED);
 657     }
 658 
 659     @Override
 660     public boolean isConnectionPending() {
 661         return (state == ST_CONNECTIONPENDING);
 662     }
</pre>
<hr />
<pre>
 706      * @throws IOException if completed and unable to obtain the local address
 707      */
 708     private void endConnect(boolean blocking, boolean completed)
 709         throws IOException
 710     {
 711         endRead(blocking, completed);
 712 
 713         if (completed) {
 714             synchronized (stateLock) {
 715                 if (state == ST_CONNECTIONPENDING) {
 716                     localAddress = Net.localAddress(fd);
 717                     state = ST_CONNECTED;
 718                 }
 719             }
 720         }
 721     }
 722 
 723     /**
 724      * Checks the remote address to which this channel is to be connected.
 725      */
<span class="line-modified"> 726     private InetSocketAddress checkRemote(SocketAddress sa) throws IOException {</span>
<span class="line-modified"> 727         InetSocketAddress isa = Net.checkAddress(sa);</span>
 728         SecurityManager sm = System.getSecurityManager();
 729         if (sm != null) {
 730             sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
 731         }
<span class="line-modified"> 732         if (isa.getAddress().isAnyLocalAddress()) {</span>
<span class="line-modified"> 733             return new InetSocketAddress(InetAddress.getLocalHost(), isa.getPort());</span>







 734         } else {
 735             return isa;
 736         }
 737     }
 738 
 739     @Override
 740     public boolean connect(SocketAddress remote) throws IOException {
 741         InetSocketAddress isa = checkRemote(remote);
 742         try {
 743             readLock.lock();
 744             try {
 745                 writeLock.lock();
 746                 try {
 747                     boolean blocking = isBlocking();
 748                     boolean connected = false;
 749                     try {
 750                         beginConnect(blocking, isa);
<span class="line-modified"> 751                         int n = Net.connect(fd, isa.getAddress(), isa.getPort());</span>



 752                         if (n &gt; 0) {
 753                             connected = true;
 754                         } else if (blocking) {
 755                             assert IOStatus.okayToRetry(n);
 756                             boolean polled = false;
 757                             while (!polled &amp;&amp; isOpen()) {
 758                                 park(Net.POLLOUT);
 759                                 polled = Net.pollConnectNow(fd);
 760                             }
 761                             connected = polled &amp;&amp; isOpen();
 762                         }
 763                     } finally {
 764                         endConnect(blocking, connected);
 765                     }
 766                     return connected;
 767                 } finally {
 768                     writeLock.unlock();
 769                 }
 770             } finally {
 771                 readLock.unlock();
</pre>
</td>
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.InetAddress;
<span class="line-added">  31 import java.net.Inet4Address;</span>
  32 import java.net.InetSocketAddress;
  33 import java.net.ProtocolFamily;
  34 import java.net.Socket;
  35 import java.net.SocketAddress;
  36 import java.net.SocketException;
  37 import java.net.SocketOption;
  38 import java.net.SocketTimeoutException;
  39 import java.net.StandardProtocolFamily;
  40 import java.net.StandardSocketOptions;
  41 import java.nio.ByteBuffer;
  42 import java.nio.channels.AlreadyBoundException;
  43 import java.nio.channels.AlreadyConnectedException;
  44 import java.nio.channels.AsynchronousCloseException;
  45 import java.nio.channels.ClosedChannelException;
  46 import java.nio.channels.ConnectionPendingException;
  47 import java.nio.channels.IllegalBlockingModeException;
  48 import java.nio.channels.NoConnectionPendingException;
  49 import java.nio.channels.NotYetConnectedException;
  50 import java.nio.channels.SelectionKey;
  51 import java.nio.channels.SocketChannel;
</pre>
<hr />
<pre>
  55 import java.util.Objects;
  56 import java.util.Set;
  57 import java.util.concurrent.locks.ReentrantLock;
  58 
  59 import sun.net.ConnectionResetException;
  60 import sun.net.NetHooks;
  61 import sun.net.ext.ExtendedSocketOptions;
  62 import sun.net.util.SocketExceptions;
  63 
  64 /**
  65  * An implementation of SocketChannels
  66  */
  67 
  68 class SocketChannelImpl
  69     extends SocketChannel
  70     implements SelChImpl
  71 {
  72     // Used to make native read and write calls
  73     private static final NativeDispatcher nd = new SocketDispatcher();
  74 
<span class="line-added">  75     // The protocol family of the socket</span>
<span class="line-added">  76     private final ProtocolFamily family;</span>
<span class="line-added">  77 </span>
  78     // Our file descriptor object
  79     private final FileDescriptor fd;
  80     private final int fdVal;
  81 
  82     // Lock held by current reading or connecting thread
  83     private final ReentrantLock readLock = new ReentrantLock();
  84 
  85     // Lock held by current writing or connecting thread
  86     private final ReentrantLock writeLock = new ReentrantLock();
  87 
  88     // Lock held by any thread that modifies the state fields declared below
  89     // DO NOT invoke a blocking I/O operation while holding this lock!
  90     private final Object stateLock = new Object();
  91 
  92     // Input/Output closed
  93     private volatile boolean isInputClosed;
  94     private volatile boolean isOutputClosed;
  95 
  96     // Connection reset protected by readLock
  97     private boolean connectionReset;
</pre>
<hr />
<pre>
 105     private static final int ST_UNCONNECTED = 0;
 106     private static final int ST_CONNECTIONPENDING = 1;
 107     private static final int ST_CONNECTED = 2;
 108     private static final int ST_CLOSING = 3;
 109     private static final int ST_CLOSED = 4;
 110     private volatile int state;  // need stateLock to change
 111 
 112     // IDs of native threads doing reads and writes, for signalling
 113     private long readerThread;
 114     private long writerThread;
 115 
 116     // Binding
 117     private InetSocketAddress localAddress;
 118     private InetSocketAddress remoteAddress;
 119 
 120     // Socket adaptor, created on demand
 121     private Socket socket;
 122 
 123     // -- End of fields protected by stateLock
 124 

 125     // Constructor for normal connecting sockets
 126     //
 127     SocketChannelImpl(SelectorProvider sp) throws IOException {
<span class="line-added"> 128         this(sp, Net.isIPv6Available()</span>
<span class="line-added"> 129                 ? StandardProtocolFamily.INET6</span>
<span class="line-added"> 130                 : StandardProtocolFamily.INET);</span>
<span class="line-added"> 131     }</span>
<span class="line-added"> 132 </span>
<span class="line-added"> 133     SocketChannelImpl(SelectorProvider sp, ProtocolFamily family) throws IOException {</span>
 134         super(sp);
<span class="line-modified"> 135         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);</span>
<span class="line-added"> 136         if ((family != StandardProtocolFamily.INET) &amp;&amp;</span>
<span class="line-added"> 137                 (family != StandardProtocolFamily.INET6)) {</span>
<span class="line-added"> 138             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);</span>
<span class="line-added"> 139         }</span>
<span class="line-added"> 140         if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.isIPv6Available()) {</span>
<span class="line-added"> 141             throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>
<span class="line-added"> 142         }</span>
<span class="line-added"> 143         this.family = family;</span>
<span class="line-added"> 144         this.fd = Net.socket(family, true);</span>
 145         this.fdVal = IOUtil.fdVal(fd);
 146     }
 147 
 148     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
 149         throws IOException
 150     {
 151         super(sp);
<span class="line-added"> 152         this.family = Net.isIPv6Available()</span>
<span class="line-added"> 153                 ? StandardProtocolFamily.INET6</span>
<span class="line-added"> 154                 : StandardProtocolFamily.INET;</span>
 155         this.fd = fd;
 156         this.fdVal = IOUtil.fdVal(fd);
<span class="line-added"> 157 </span>
 158         if (bound) {
 159             synchronized (stateLock) {
 160                 this.localAddress = Net.localAddress(fd);
 161             }
 162         }
 163     }
 164 
 165     // Constructor for sockets obtained from server sockets
 166     //
<span class="line-modified"> 167     SocketChannelImpl(SelectorProvider sp,</span>
<span class="line-added"> 168                       ProtocolFamily family,</span>
<span class="line-added"> 169                       FileDescriptor fd,</span>
<span class="line-added"> 170                       InetSocketAddress isa)</span>
 171         throws IOException
 172     {
 173         super(sp);
<span class="line-added"> 174         this.family = family;</span>
 175         this.fd = fd;
 176         this.fdVal = IOUtil.fdVal(fd);
 177         synchronized (stateLock) {
 178             this.localAddress = Net.localAddress(fd);
 179             this.remoteAddress = isa;
 180             this.state = ST_CONNECTED;
 181         }
 182     }
 183 
 184     /**
 185      * Checks that the channel is open.
 186      *
 187      * @throws ClosedChannelException if channel is closed (or closing)
 188      */
 189     private void ensureOpen() throws ClosedChannelException {
 190         if (!isOpen())
 191             throw new ClosedChannelException();
 192     }
 193 
 194     /**
</pre>
<hr />
<pre>
 234         synchronized (stateLock) {
 235             ensureOpen();
 236             return remoteAddress;
 237         }
 238     }
 239 
 240     @Override
 241     public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value)
 242         throws IOException
 243     {
 244         Objects.requireNonNull(name);
 245         if (!supportedOptions().contains(name))
 246             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 247         if (!name.type().isInstance(value))
 248             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);
 249 
 250         synchronized (stateLock) {
 251             ensureOpen();
 252 
 253             if (name == StandardSocketOptions.IP_TOS) {


 254                 Net.setSocketOption(fd, family, name, value);
 255                 return this;
 256             }
 257 
 258             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 259                 // SO_REUSEADDR emulated when using exclusive bind
 260                 isReuseAddress = (Boolean)value;
 261                 return this;
 262             }
 263 
 264             // no options that require special handling
 265             Net.setSocketOption(fd, name, value);
 266             return this;
 267         }
 268     }
 269 
 270     @Override
 271     @SuppressWarnings(&quot;unchecked&quot;)
 272     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 273         throws IOException
 274     {
 275         Objects.requireNonNull(name);
 276         if (!supportedOptions().contains(name))
 277             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 278 
 279         synchronized (stateLock) {
 280             ensureOpen();
 281 
 282             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 283                 // SO_REUSEADDR emulated when using exclusive bind
 284                 return (T)Boolean.valueOf(isReuseAddress);
 285             }
 286 
<span class="line-modified"> 287             // special handling for IP_TOS</span>
 288             if (name == StandardSocketOptions.IP_TOS) {


 289                 return (T) Net.getSocketOption(fd, family, name);
 290             }
 291 
 292             // no options that require special handling
 293             return (T) Net.getSocketOption(fd, name);
 294         }
 295     }
 296 
 297     private static class DefaultOptionsHolder {
 298         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 299 
 300         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 301             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 302             set.add(StandardSocketOptions.SO_SNDBUF);
 303             set.add(StandardSocketOptions.SO_RCVBUF);
 304             set.add(StandardSocketOptions.SO_KEEPALIVE);
 305             set.add(StandardSocketOptions.SO_REUSEADDR);
 306             if (Net.isReusePortAvailable()) {
 307                 set.add(StandardSocketOptions.SO_REUSEPORT);
 308             }
</pre>
<hr />
<pre>
 637      * Returns the remote address, or null if not connected
 638      */
 639     InetSocketAddress remoteAddress() {
 640         synchronized (stateLock) {
 641             return remoteAddress;
 642         }
 643     }
 644 
 645     @Override
 646     public SocketChannel bind(SocketAddress local) throws IOException {
 647         readLock.lock();
 648         try {
 649             writeLock.lock();
 650             try {
 651                 synchronized (stateLock) {
 652                     ensureOpen();
 653                     if (state == ST_CONNECTIONPENDING)
 654                         throw new ConnectionPendingException();
 655                     if (localAddress != null)
 656                         throw new AlreadyBoundException();
<span class="line-modified"> 657                     InetSocketAddress isa;</span>
<span class="line-modified"> 658                     if (local == null) {</span>
<span class="line-added"> 659                         isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);</span>
<span class="line-added"> 660                     } else {</span>
<span class="line-added"> 661                         isa = Net.checkAddress(local, family);</span>
<span class="line-added"> 662                     }</span>
 663                     SecurityManager sm = System.getSecurityManager();
 664                     if (sm != null) {
 665                         sm.checkListen(isa.getPort());
 666                     }
 667                     NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
<span class="line-modified"> 668                     Net.bind(family, fd, isa.getAddress(), isa.getPort());</span>
 669                     localAddress = Net.localAddress(fd);
 670                 }
 671             } finally {
 672                 writeLock.unlock();
 673             }
 674         } finally {
 675             readLock.unlock();
 676         }
 677         return this;
 678     }
 679 
 680     @Override
 681     public boolean isConnected() {
 682         return (state == ST_CONNECTED);
 683     }
 684 
 685     @Override
 686     public boolean isConnectionPending() {
 687         return (state == ST_CONNECTIONPENDING);
 688     }
</pre>
<hr />
<pre>
 732      * @throws IOException if completed and unable to obtain the local address
 733      */
 734     private void endConnect(boolean blocking, boolean completed)
 735         throws IOException
 736     {
 737         endRead(blocking, completed);
 738 
 739         if (completed) {
 740             synchronized (stateLock) {
 741                 if (state == ST_CONNECTIONPENDING) {
 742                     localAddress = Net.localAddress(fd);
 743                     state = ST_CONNECTED;
 744                 }
 745             }
 746         }
 747     }
 748 
 749     /**
 750      * Checks the remote address to which this channel is to be connected.
 751      */
<span class="line-modified"> 752     private InetSocketAddress checkRemote(SocketAddress sa) {</span>
<span class="line-modified"> 753         InetSocketAddress isa = Net.checkAddress(sa, family);</span>
 754         SecurityManager sm = System.getSecurityManager();
 755         if (sm != null) {
 756             sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
 757         }
<span class="line-modified"> 758         InetAddress address = isa.getAddress();</span>
<span class="line-modified"> 759         if (address.isAnyLocalAddress()) {</span>
<span class="line-added"> 760             int port = isa.getPort();</span>
<span class="line-added"> 761             if (address instanceof Inet4Address) {</span>
<span class="line-added"> 762                 return new InetSocketAddress(Net.inet4LoopbackAddress(), port);</span>
<span class="line-added"> 763             } else {</span>
<span class="line-added"> 764                 assert family == StandardProtocolFamily.INET6;</span>
<span class="line-added"> 765                 return new InetSocketAddress(Net.inet6LoopbackAddress(), port);</span>
<span class="line-added"> 766             }</span>
 767         } else {
 768             return isa;
 769         }
 770     }
 771 
 772     @Override
 773     public boolean connect(SocketAddress remote) throws IOException {
 774         InetSocketAddress isa = checkRemote(remote);
 775         try {
 776             readLock.lock();
 777             try {
 778                 writeLock.lock();
 779                 try {
 780                     boolean blocking = isBlocking();
 781                     boolean connected = false;
 782                     try {
 783                         beginConnect(blocking, isa);
<span class="line-modified"> 784                         int n = Net.connect(family,</span>
<span class="line-added"> 785                                             fd,</span>
<span class="line-added"> 786                                             isa.getAddress(),</span>
<span class="line-added"> 787                                             isa.getPort());</span>
 788                         if (n &gt; 0) {
 789                             connected = true;
 790                         } else if (blocking) {
 791                             assert IOStatus.okayToRetry(n);
 792                             boolean polled = false;
 793                             while (!polled &amp;&amp; isOpen()) {
 794                                 park(Net.POLLOUT);
 795                                 polled = Net.pollConnectNow(fd);
 796                             }
 797                             connected = polled &amp;&amp; isOpen();
 798                         }
 799                     } finally {
 800                         endConnect(blocking, connected);
 801                     }
 802                     return connected;
 803                 } finally {
 804                     writeLock.unlock();
 805                 }
 806             } finally {
 807                 readLock.unlock();
</pre>
</td>
</tr>
</table>
<center><a href="ServerSocketChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../security/pkcs/ContentInfo.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
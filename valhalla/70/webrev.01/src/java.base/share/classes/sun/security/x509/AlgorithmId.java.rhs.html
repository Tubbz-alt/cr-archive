<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/AlgorithmId.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.x509;
 27 
 28 import java.io.*;
 29 import java.security.interfaces.RSAKey;
 30 import java.security.spec.AlgorithmParameterSpec;
<a name="1" id="anc1"></a><span class="line-added"> 31 import java.security.spec.EdDSAParameterSpec;</span>
 32 import java.security.spec.InvalidParameterSpecException;
 33 import java.security.spec.MGF1ParameterSpec;
 34 import java.security.spec.PSSParameterSpec;
 35 import java.util.*;
<a name="2" id="anc2"></a><span class="line-added"> 36 import java.util.concurrent.ConcurrentHashMap;</span>
 37 import java.security.*;
<a name="3" id="anc3"></a><span class="line-added"> 38 import java.security.interfaces.*;</span>
 39 
 40 import sun.security.rsa.PSSParameters;
 41 import sun.security.util.*;
 42 
 43 
 44 /**
 45  * This class identifies algorithms, such as cryptographic transforms, each
 46  * of which may be associated with parameters.  Instances of this base class
 47  * are used when this runtime environment has no special knowledge of the
 48  * algorithm type, and may also be used in other cases.  Equivalence is
 49  * defined according to OID and (where relevant) parameters.
 50  *
 51  * &lt;P&gt;Subclasses may be used, for example when the algorithm ID has
 52  * associated parameters which some code (e.g. code using public keys) needs
 53  * to have parsed.  Two examples of such algorithms are Diffie-Hellman key
 54  * exchange, and the Digital Signature Standard Algorithm (DSS/DSA).
 55  *
 56  * &lt;P&gt;The OID constants defined in this class correspond to some widely
 57  * used algorithms, for which conventional string names have been defined.
 58  * This class is not a general repository for OIDs, or for such string names.
 59  * Note that the mappings between algorithm IDs and algorithm names is
 60  * not one-to-one.
 61  *
 62  *
 63  * @author David Brownell
 64  * @author Amit Kapoor
 65  * @author Hemma Prafullchandra
 66  */
 67 public class AlgorithmId implements Serializable, DerEncoder {
 68 
 69     /** use serialVersionUID from JDK 1.1. for interoperability */
 70     @java.io.Serial
 71     private static final long serialVersionUID = 7205873507486557157L;
 72 
 73     /**
 74      * The object identitifer being used for this algorithm.
 75      */
 76     private ObjectIdentifier algid;
 77 
 78     // The (parsed) parameters
 79     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 80     private AlgorithmParameters algParams;
 81     private boolean constructedFromDer = true;
 82 
 83     /**
 84      * Parameters for this algorithm.  These are stored in unparsed
 85      * DER-encoded form; subclasses can be made to automaticaly parse
 86      * them so there is fast access to these parameters.
 87      */
 88     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 89     protected DerValue          params;
 90 
 91 
 92     /**
 93      * Constructs an algorithm ID which will be initialized
 94      * separately, for example by deserialization.
 95      * @deprecated use one of the other constructors.
 96      */
 97     @Deprecated
 98     public AlgorithmId() { }
 99 
100     /**
101      * Constructs a parameterless algorithm ID.
102      *
103      * @param oid the identifier for the algorithm
104      */
105     public AlgorithmId(ObjectIdentifier oid) {
106         algid = oid;
107     }
108 
109     /**
110      * Constructs an algorithm ID with algorithm parameters.
111      *
112      * @param oid the identifier for the algorithm.
113      * @param algparams the associated algorithm parameters.
114      */
115     public AlgorithmId(ObjectIdentifier oid, AlgorithmParameters algparams) {
116         algid = oid;
117         algParams = algparams;
118         constructedFromDer = false;
119     }
120 
121     private AlgorithmId(ObjectIdentifier oid, DerValue params)
122             throws IOException {
123         this.algid = oid;
124         this.params = params;
125         if (this.params != null) {
126             decodeParams();
127         }
128     }
129 
130     protected void decodeParams() throws IOException {
131         String algidName = getName();
132         try {
133             algParams = AlgorithmParameters.getInstance(algidName);
134         } catch (NoSuchAlgorithmException e) {
135             /*
136              * This algorithm parameter type is not supported, so we cannot
137              * parse the parameters.
138              */
139             algParams = null;
140             return;
141         }
142 
143         // Decode (parse) the parameters
144         algParams.init(params.toByteArray());
145     }
146 
147     /**
148      * Marshal a DER-encoded &quot;AlgorithmID&quot; sequence on the DER stream.
149      */
150     public final void encode(DerOutputStream out) throws IOException {
151         derEncode(out);
152     }
153 
154     /**
155      * DER encode this object onto an output stream.
156      * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
157      *
158      * @param out
159      * the output stream on which to write the DER encoding.
160      *
161      * @exception IOException on encoding error.
162      */
163     public void derEncode (OutputStream out) throws IOException {
164         DerOutputStream bytes = new DerOutputStream();
165         DerOutputStream tmp = new DerOutputStream();
166 
167         bytes.putOID(algid);
168         // Setup params from algParams since no DER encoding is given
169         if (constructedFromDer == false) {
170             if (algParams != null) {
171                 params = new DerValue(algParams.getEncoded());
172             } else {
173                 params = null;
174             }
175         }
176         if (params == null) {
177             // Changes backed out for compatibility with Solaris
178 
179             // Several AlgorithmId should omit the whole parameter part when
180             // it&#39;s NULL. They are ---
181             // RFC 3370 2.1: Implementations SHOULD generate SHA-1
182             // AlgorithmIdentifiers with absent parameters.
183             // RFC 3447 C1: When id-sha1, id-sha224, id-sha256, id-sha384 and
184             // id-sha512 are used in an AlgorithmIdentifier the parameters
185             // (which are optional) SHOULD be omitted.
186             // RFC 3279 2.3.2: The id-dsa algorithm syntax includes optional
187             // domain parameters... When omitted, the parameters component
188             // MUST be omitted entirely
189             // RFC 3370 3.1: When the id-dsa-with-sha1 algorithm identifier
190             // is used, the AlgorithmIdentifier parameters field MUST be absent.
191             /*if (
192                 algid.equals((Object)SHA_oid) ||
193                 algid.equals((Object)SHA224_oid) ||
194                 algid.equals((Object)SHA256_oid) ||
195                 algid.equals((Object)SHA384_oid) ||
196                 algid.equals((Object)SHA512_oid) ||
197                 algid.equals((Object)SHA512_224_oid) ||
198                 algid.equals((Object)SHA512_256_oid) ||
199                 algid.equals((Object)DSA_oid) ||
200                 algid.equals((Object)sha1WithDSA_oid)) {
201                 ; // no parameter part encoded
202             } else {
203                 bytes.putNull();
204             }*/
<a name="4" id="anc4"></a><span class="line-modified">205             if (algid.equals(RSASSA_PSS_oid) || algid.equals(ed448_oid)</span>
<span class="line-added">206                     || algid.equals(ed25519_oid)) {</span>
207                 // RFC 4055 3.3: when an RSASSA-PSS key does not require
208                 // parameter validation, field is absent.
209             } else {
210                 bytes.putNull();
211             }
212         } else {
213             bytes.putDerValue(params);
214         }
215         tmp.write(DerValue.tag_Sequence, bytes);
216         out.write(tmp.toByteArray());
217     }
218 
219 
220     /**
221      * Returns the DER-encoded X.509 AlgorithmId as a byte array.
222      */
223     public final byte[] encode() throws IOException {
224         DerOutputStream out = new DerOutputStream();
225         derEncode(out);
226         return out.toByteArray();
227     }
228 
229     /**
230      * Returns the ISO OID for this algorithm.  This is usually converted
231      * to a string and used as part of an algorithm name, for example
232      * &quot;OID.1.3.14.3.2.13&quot; style notation.  Use the &lt;code&gt;getName&lt;/code&gt;
233      * call when you do not need to ensure cross-system portability
234      * of algorithm names, or need a user friendly name.
235      */
236     public final ObjectIdentifier getOID () {
237         return algid;
238     }
239 
240     /**
241      * Returns a name for the algorithm which may be more intelligible
242      * to humans than the algorithm&#39;s OID, but which won&#39;t necessarily
243      * be comprehensible on other systems.  For example, this might
244      * return a name such as &quot;MD5withRSA&quot; for a signature algorithm on
245      * some systems.  It also returns names like &quot;OID.1.2.3.4&quot;, when
246      * no particular name for the algorithm is known.
247      *
248      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
249      * returns the &quot;full&quot; signature algorithm (Ex: SHA256withECDSA) directly.
250      */
251     public String getName() {
<a name="5" id="anc5"></a><span class="line-modified">252         String oidStr = algid.toString();</span>
<span class="line-modified">253         // first check the list of support oids</span>
<span class="line-modified">254         KnownOIDs o = KnownOIDs.findMatch(oidStr);</span>
<span class="line-modified">255         if (o == KnownOIDs.SpecifiedSHA2withECDSA) {</span>
<span class="line-modified">256             if (params != null) {</span>
<span class="line-modified">257                 try {</span>
<span class="line-modified">258                     AlgorithmId paramsId =</span>
259                         AlgorithmId.parse(new DerValue(params.toByteArray()));
<a name="6" id="anc6"></a><span class="line-modified">260                     String paramsName = paramsId.getName();</span>
<span class="line-modified">261                     return makeSigAlg(paramsName, &quot;EC&quot;);</span>
<span class="line-modified">262                 } catch (IOException e) {</span>
<span class="line-modified">263                     // ignore</span>
<span class="line-added">264                 }</span>
<span class="line-added">265             }</span>
<span class="line-added">266         }</span>
<span class="line-added">267         if (o != null) {</span>
<span class="line-added">268             return o.stdName();</span>
<span class="line-added">269         } else {</span>
<span class="line-added">270             String n = aliasOidsTable().get(oidStr);</span>
<span class="line-added">271             if (n != null) {</span>
<span class="line-added">272                 return n;</span>
<span class="line-added">273             } else {</span>
<span class="line-added">274                 return algid.toString();</span>
275             }
276         }
<a name="7" id="anc7"></a>
277     }
278 
279     public AlgorithmParameters getParameters() {
280         return algParams;
281     }
282 
283     /**
284      * Returns the DER encoded parameter, which can then be
285      * used to initialize java.security.AlgorithmParameters.
286      *
287      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
288      * returns null because {@link #getName()} has already returned the &quot;full&quot;
289      * signature algorithm (Ex: SHA256withECDSA).
290      *
291      * @return DER encoded parameters, or null not present.
292      */
293     public byte[] getEncodedParams() throws IOException {
<a name="8" id="anc8"></a><span class="line-modified">294         return (params == null ||</span>
<span class="line-added">295             algid.toString().equals(KnownOIDs.SpecifiedSHA2withECDSA.value()))</span>
296                 ? null
297                 : params.toByteArray();
298     }
299 
300     /**
301      * Returns true iff the argument indicates the same algorithm
302      * with the same parameters.
303      */
304     public boolean equals(AlgorithmId other) {
305         boolean paramsEqual = Objects.equals(other.params, params);
306         return (algid.equals((Object)other.algid) &amp;&amp; paramsEqual);
307     }
308 
309     /**
310      * Compares this AlgorithmID to another.  If algorithm parameters are
311      * available, they are compared.  Otherwise, just the object IDs
312      * for the algorithm are compared.
313      *
314      * @param other preferably an AlgorithmId, else an ObjectIdentifier
315      */
316     public boolean equals(Object other) {
317         if (this == other) {
318             return true;
319         }
320         if (other instanceof AlgorithmId) {
321             return equals((AlgorithmId) other);
322         } else if (other instanceof ObjectIdentifier) {
323             return equals((ObjectIdentifier) other);
324         } else {
325             return false;
326         }
327     }
328 
329     /**
330      * Compares two algorithm IDs for equality.  Returns true iff
331      * they are the same algorithm, ignoring algorithm parameters.
332      */
333     public final boolean equals(ObjectIdentifier id) {
334         return algid.equals((Object)id);
335     }
336 
337     /**
338      * Returns a hashcode for this AlgorithmId.
339      *
340      * @return a hashcode for this AlgorithmId.
341      */
342     public int hashCode() {
343         StringBuilder sbuf = new StringBuilder();
344         sbuf.append(algid.toString());
345         sbuf.append(paramsToString());
346         return sbuf.toString().hashCode();
347     }
348 
349     /**
350      * Provides a human-readable description of the algorithm parameters.
351      * This may be redefined by subclasses which parse those parameters.
352      */
353     protected String paramsToString() {
354         if (params == null) {
355             return &quot;&quot;;
356         } else if (algParams != null) {
357             return algParams.toString();
358         } else {
359             return &quot;, params unparsed&quot;;
360         }
361     }
362 
363     /**
364      * Returns a string describing the algorithm and its parameters.
365      */
366     public String toString() {
367         return getName() + paramsToString();
368     }
369 
370     /**
371      * Parse (unmarshal) an ID from a DER sequence input value.  This form
372      * parsing might be used when expanding a value which has already been
373      * partially unmarshaled as a set or sequence member.
374      *
375      * @exception IOException on error.
376      * @param val the input value, which contains the algid and, if
377      *          there are any parameters, those parameters.
378      * @return an ID for the algorithm.  If the system is configured
379      *          appropriately, this may be an instance of a class
380      *          with some kind of special support for this algorithm.
381      *          In that case, you may &quot;narrow&quot; the type of the ID.
382      */
383     public static AlgorithmId parse(DerValue val) throws IOException {
384         if (val.tag != DerValue.tag_Sequence) {
385             throw new IOException(&quot;algid parse error, not a sequence&quot;);
386         }
387 
388         /*
389          * Get the algorithm ID and any parameters.
390          */
391         ObjectIdentifier        algid;
392         DerValue                params;
393         DerInputStream          in = val.toDerInputStream();
394 
395         algid = in.getOID();
396         if (in.available() == 0) {
397             params = null;
398         } else {
399             params = in.getDerValue();
400             if (params.tag == DerValue.tag_Null) {
401                 if (params.length() != 0) {
402                     throw new IOException(&quot;invalid NULL&quot;);
403                 }
404                 params = null;
405             }
406             if (in.available() != 0) {
407                 throw new IOException(&quot;Invalid AlgorithmIdentifier: extra data&quot;);
408             }
409         }
410 
411         return new AlgorithmId(algid, params);
412     }
413 
414     /**
415      * Returns one of the algorithm IDs most commonly associated
416      * with this algorithm name.
417      *
418      * @param algname the name being used
419      * @deprecated use the short get form of this method.
420      * @exception NoSuchAlgorithmException on error.
421      */
422     @Deprecated
423     public static AlgorithmId getAlgorithmId(String algname)
424             throws NoSuchAlgorithmException {
425         return get(algname);
426     }
427 
428     /**
429      * Returns one of the algorithm IDs most commonly associated
430      * with this algorithm name.
431      *
432      * @param algname the name being used
433      * @exception NoSuchAlgorithmException on error.
434      */
435     public static AlgorithmId get(String algname)
436             throws NoSuchAlgorithmException {
437         ObjectIdentifier oid;
438         try {
439             oid = algOID(algname);
440         } catch (IOException ioe) {
441             throw new NoSuchAlgorithmException
442                 (&quot;Invalid ObjectIdentifier &quot; + algname);
443         }
444 
445         if (oid == null) {
446             throw new NoSuchAlgorithmException
447                 (&quot;unrecognized algorithm name: &quot; + algname);
448         }
449         return new AlgorithmId(oid);
450     }
451 
452     /**
453      * Returns one of the algorithm IDs most commonly associated
454      * with this algorithm parameters.
455      *
456      * @param algparams the associated algorithm parameters.
457      * @exception NoSuchAlgorithmException on error.
458      */
459     public static AlgorithmId get(AlgorithmParameters algparams)
460             throws NoSuchAlgorithmException {
461         ObjectIdentifier oid;
462         String algname = algparams.getAlgorithm();
463         try {
464             oid = algOID(algname);
465         } catch (IOException ioe) {
466             throw new NoSuchAlgorithmException
467                 (&quot;Invalid ObjectIdentifier &quot; + algname);
468         }
469         if (oid == null) {
470             throw new NoSuchAlgorithmException
471                 (&quot;unrecognized algorithm name: &quot; + algname);
472         }
473         return new AlgorithmId(oid, algparams);
474     }
475 
476     /*
477      * Translates from some common algorithm names to the
478      * OID with which they&#39;re usually associated ... this mapping
479      * is the reverse of the one below, except in those cases
480      * where synonyms are supported or where a given algorithm
481      * is commonly associated with multiple OIDs.
482      *
483      * XXX This method needs to be enhanced so that we can also pass the
484      * scope of the algorithm name to it, e.g., the algorithm name &quot;DSA&quot;
485      * may have a different OID when used as a &quot;Signature&quot; algorithm than when
486      * used as a &quot;KeyPairGenerator&quot; algorithm.
487      */
488     private static ObjectIdentifier algOID(String name) throws IOException {
<a name="9" id="anc9"></a><span class="line-modified">489         if (name.startsWith(&quot;OID.&quot;)) {</span>
<span class="line-modified">490             name = name.substring(&quot;OID.&quot;.length());</span>





491         }
492 
<a name="10" id="anc10"></a><span class="line-modified">493         KnownOIDs k = KnownOIDs.findMatch(name);</span>
<span class="line-modified">494         if (k != null) {</span>
<span class="line-modified">495             return ObjectIdentifier.of(k);</span>



























































496         }
497 
<a name="11" id="anc11"></a><span class="line-modified">498         // unknown algorithm oids</span>
<span class="line-modified">499         if (name.indexOf(&quot;.&quot;) == -1) {</span>
<span class="line-modified">500             // see if there is a matching oid string alias mapping from</span>
<span class="line-modified">501             // 3rd party providers</span>
<span class="line-modified">502             name = name.toUpperCase(Locale.ENGLISH);</span>
<span class="line-modified">503             String oidStr = aliasOidsTable().get(name);</span>
<span class="line-modified">504             if (oidStr != null) {</span>
<span class="line-modified">505                 return ObjectIdentifier.of(oidStr);</span>
<span class="line-modified">506             } return null;</span>
<span class="line-modified">507         } else {</span>
<span class="line-modified">508             return ObjectIdentifier.of(name);</span>
































509         }
<a name="12" id="anc12"></a>

510     }
511 
<a name="13" id="anc13"></a><span class="line-modified">512     // oid string cache index&#39;ed by algorithm name and oid strings</span>
<span class="line-modified">513     private static volatile Map&lt;String,String&gt; aliasOidsTable;</span>
514 
<a name="14" id="anc14"></a><span class="line-modified">515     // returns the aliasOidsTable, lazily initializing it on first access.</span>
<span class="line-modified">516     private static Map&lt;String,String&gt; aliasOidsTable() {</span>
<span class="line-modified">517         // Double checked locking; safe because aliasOidsTable is volatile</span>
<span class="line-modified">518         Map&lt;String,String&gt; tab = aliasOidsTable;</span>
<span class="line-modified">519         if (tab == null) {</span>

520             synchronized (AlgorithmId.class) {
<a name="15" id="anc15"></a><span class="line-modified">521                 if ((tab = aliasOidsTable) == null) {</span>
<span class="line-modified">522                     aliasOidsTable = tab = collectOIDAliases();</span>
<span class="line-added">523                 }</span>
524             }
525         }
526         return tab;
527     }
528 
<a name="16" id="anc16"></a><span class="line-modified">529     private static boolean isKnownProvider(Provider p) {</span>
<span class="line-modified">530         String pn = p.getName();</span>
<span class="line-modified">531         String mn = p.getClass().getModule().getName();</span>
<span class="line-modified">532         if (pn != null &amp;&amp; mn != null) {</span>
<span class="line-added">533             return ((mn.equals(&quot;java.base&quot;) &amp;&amp;</span>
<span class="line-added">534                     (pn.equals(&quot;SUN&quot;) || pn.equals(&quot;SunRsaSign&quot;) ||</span>
<span class="line-added">535                     pn.equals(&quot;SunJCE&quot;) || pn.equals(&quot;SunJSSE&quot;))) ||</span>
<span class="line-added">536                 (mn.equals(&quot;jdk.crypto.ec&quot;) &amp;&amp; pn.equals(&quot;SunEC&quot;)) ||</span>
<span class="line-added">537                 (mn.equals(&quot;jdk.crypto.mscapi&quot;) &amp;&amp; pn.equals(&quot;SunMSCAPI&quot;)) ||</span>
<span class="line-added">538                 (mn.equals(&quot;jdk.crypto.cryptoki&quot;) &amp;&amp;</span>
<span class="line-added">539                     pn.startsWith(&quot;SunPKCS11&quot;)));</span>
<span class="line-added">540         } else {</span>
<span class="line-added">541             return false;</span>
<span class="line-added">542         }</span>
<span class="line-added">543     }</span>
<span class="line-added">544 </span>
<span class="line-added">545     private static ConcurrentHashMap&lt;String, String&gt; collectOIDAliases() {</span>
<span class="line-added">546         ConcurrentHashMap&lt;String, String&gt; t = new ConcurrentHashMap&lt;&gt;();</span>
547         for (Provider provider : Security.getProviders()) {
<a name="17" id="anc17"></a><span class="line-added">548             // skip providers which are already using SecurityProviderConstants</span>
<span class="line-added">549             // and KnownOIDs</span>
<span class="line-added">550             if (isKnownProvider(provider)) {</span>
<span class="line-added">551                 continue;</span>
<span class="line-added">552             }</span>
553             for (Object key : provider.keySet()) {
554                 String alias = (String)key;
555                 String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
556                 int index;
557                 if (upperCaseAlias.startsWith(&quot;ALG.ALIAS&quot;) &amp;&amp;
<a name="18" id="anc18"></a><span class="line-modified">558                     (index = upperCaseAlias.indexOf(&quot;OID.&quot;, 0)) != -1) {</span>
559                     index += &quot;OID.&quot;.length();
560                     if (index == alias.length()) {
561                         // invalid alias entry
562                         break;
563                     }
<a name="19" id="anc19"></a><span class="line-modified">564                     String ostr = alias.substring(index);</span>
565                     String stdAlgName = provider.getProperty(alias);
566                     if (stdAlgName != null) {
567                         stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
568                     }
<a name="20" id="anc20"></a><span class="line-modified">569                     // add the name-&gt;oid and oid-&gt;name mappings if none exists</span>
<span class="line-modified">570                     if (KnownOIDs.findMatch(stdAlgName) == null) {</span>
<span class="line-modified">571                         // not override earlier entries if it exists</span>
<span class="line-added">572                         t.putIfAbsent(stdAlgName, ostr);</span>
<span class="line-added">573                     }</span>
<span class="line-added">574                     if (KnownOIDs.findMatch(ostr) == null) {</span>
<span class="line-added">575                         // not override earlier entries if it exists</span>
<span class="line-added">576                         t.putIfAbsent(ostr, stdAlgName);</span>
577                     }
578                 }
579             }
580         }
<a name="21" id="anc21"></a><span class="line-modified">581         return t;</span>
582     }
583 
<a name="22" id="anc22"></a>









584     public static final ObjectIdentifier MD2_oid =
<a name="23" id="anc23"></a><span class="line-modified">585             ObjectIdentifier.of(KnownOIDs.MD2);</span>
586 
<a name="24" id="anc24"></a>



587     public static final ObjectIdentifier MD5_oid =
<a name="25" id="anc25"></a><span class="line-modified">588             ObjectIdentifier.of(KnownOIDs.MD5);</span>
589 
<a name="26" id="anc26"></a>





590     public static final ObjectIdentifier SHA_oid =
<a name="27" id="anc27"></a><span class="line-modified">591             ObjectIdentifier.of(KnownOIDs.SHA_1);</span>
592 
593     public static final ObjectIdentifier SHA224_oid =
<a name="28" id="anc28"></a><span class="line-modified">594             ObjectIdentifier.of(KnownOIDs.SHA_224);</span>
595 
596     public static final ObjectIdentifier SHA256_oid =
<a name="29" id="anc29"></a><span class="line-modified">597             ObjectIdentifier.of(KnownOIDs.SHA_256);</span>
598 
599     public static final ObjectIdentifier SHA384_oid =
<a name="30" id="anc30"></a><span class="line-modified">600             ObjectIdentifier.of(KnownOIDs.SHA_384);</span>
601 
602     public static final ObjectIdentifier SHA512_oid =
<a name="31" id="anc31"></a><span class="line-modified">603             ObjectIdentifier.of(KnownOIDs.SHA_512);</span>
604 
605     public static final ObjectIdentifier SHA512_224_oid =
<a name="32" id="anc32"></a><span class="line-modified">606             ObjectIdentifier.of(KnownOIDs.SHA_512$224);</span>
607 
608     public static final ObjectIdentifier SHA512_256_oid =
<a name="33" id="anc33"></a><span class="line-modified">609             ObjectIdentifier.of(KnownOIDs.SHA_512$256);</span>






































610 
<a name="34" id="anc34"></a>






611     public static final ObjectIdentifier DSA_oid =
<a name="35" id="anc35"></a><span class="line-modified">612             ObjectIdentifier.of(KnownOIDs.DSA);</span>









613 
614     public static final ObjectIdentifier EC_oid =
<a name="36" id="anc36"></a><span class="line-modified">615             ObjectIdentifier.of(KnownOIDs.EC);</span>












































616 
<a name="37" id="anc37"></a><span class="line-modified">617     public static final ObjectIdentifier RSAEncryption_oid =</span>
<span class="line-modified">618             ObjectIdentifier.of(KnownOIDs.RSA);</span>














































619 
<a name="38" id="anc38"></a><span class="line-modified">620     public static final ObjectIdentifier RSASSA_PSS_oid =</span>
<span class="line-modified">621             ObjectIdentifier.of(KnownOIDs.RSASSA_PSS);</span>





622 
<a name="39" id="anc39"></a><span class="line-modified">623     public static final ObjectIdentifier MGF1_oid =</span>
<span class="line-modified">624             ObjectIdentifier.of(KnownOIDs.MGF1);</span>




























625 
<a name="40" id="anc40"></a><span class="line-modified">626     public static final ObjectIdentifier ed25519_oid =</span>
<span class="line-modified">627             ObjectIdentifier.of(KnownOIDs.Ed25519);</span>
<span class="line-modified">628     public static final ObjectIdentifier ed448_oid =</span>
<span class="line-modified">629             ObjectIdentifier.of(KnownOIDs.Ed448);</span>










































































630 
631     /**
632      * Creates a signature algorithm name from a digest algorithm
633      * name and a encryption algorithm name.
634      */
635     public static String makeSigAlg(String digAlg, String encAlg) {
636         digAlg = digAlg.replace(&quot;-&quot;, &quot;&quot;);
637         if (encAlg.equalsIgnoreCase(&quot;EC&quot;)) encAlg = &quot;ECDSA&quot;;
638 
639         return digAlg + &quot;with&quot; + encAlg;
640     }
641 
642     /**
643      * Extracts the encryption algorithm name from a signature
644      * algorithm name.
645      */
646     public static String getEncAlgFromSigAlg(String signatureAlgorithm) {
647         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
648         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
649         String keyAlgorithm = null;
650         if (with &gt; 0) {
651             int and = signatureAlgorithm.indexOf(&quot;AND&quot;, with + 4);
652             if (and &gt; 0) {
653                 keyAlgorithm = signatureAlgorithm.substring(with + 4, and);
654             } else {
655                 keyAlgorithm = signatureAlgorithm.substring(with + 4);
656             }
657             if (keyAlgorithm.equalsIgnoreCase(&quot;ECDSA&quot;)) {
658                 keyAlgorithm = &quot;EC&quot;;
659             }
660         }
661         return keyAlgorithm;
662     }
663 
664     /**
665      * Extracts the digest algorithm name from a signature
666      * algorithm name.
667      */
668     public static String getDigAlgFromSigAlg(String signatureAlgorithm) {
669         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
670         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
671         if (with &gt; 0) {
672             return signatureAlgorithm.substring(0, with);
673         }
674         return null;
675     }
676 
677     /**
678      * Checks if a signature algorithm matches a key algorithm, i.e. a
679      * signature can be initialized with a key.
680      *
681      * @param kAlg must not be null
682      * @param sAlg must not be null
683      * @throws IllegalArgumentException if they do not match
684      */
685     public static void checkKeyAndSigAlgMatch(String kAlg, String sAlg) {
686         String sAlgUp = sAlg.toUpperCase(Locale.US);
687         if ((sAlgUp.endsWith(&quot;WITHRSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;RSA&quot;)) ||
688                 (sAlgUp.endsWith(&quot;WITHECDSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;EC&quot;)) ||
689                 (sAlgUp.endsWith(&quot;WITHDSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;DSA&quot;))) {
690             throw new IllegalArgumentException(
691                     &quot;key algorithm not compatible with signature algorithm&quot;);
692         }
693     }
694 
695     /**
696      * Returns the default signature algorithm for a private key. The digest
697      * part might evolve with time. Remember to update the spec of
698      * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm(PrivateKey)}
699      * if updated.
700      *
701      * @param k cannot be null
702      * @return the default alg, might be null if unsupported
703      */
704     public static String getDefaultSigAlgForKey(PrivateKey k) {
705         switch (k.getAlgorithm().toUpperCase(Locale.ENGLISH)) {
706             case &quot;EC&quot;:
707                 return ecStrength(KeyUtil.getKeySize(k))
708                     + &quot;withECDSA&quot;;
709             case &quot;DSA&quot;:
710                 return ifcFfcStrength(KeyUtil.getKeySize(k))
711                     + &quot;withDSA&quot;;
712             case &quot;RSA&quot;:
713                 return ifcFfcStrength(KeyUtil.getKeySize(k))
714                     + &quot;withRSA&quot;;
715             case &quot;RSASSA-PSS&quot;:
716                 return &quot;RSASSA-PSS&quot;;
<a name="41" id="anc41"></a><span class="line-added">717             case &quot;EDDSA&quot;:</span>
<span class="line-added">718                 return edAlgFromKey(k);</span>
719             default:
720                 return null;
721         }
722     }
723 
724     // Most commonly used PSSParameterSpec and AlgorithmId
725     private static class PSSParamsHolder {
726 
727         final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(
728                 &quot;SHA-256&quot;, &quot;MGF1&quot;,
729                 new MGF1ParameterSpec(&quot;SHA-256&quot;),
730                 32, PSSParameterSpec.TRAILER_FIELD_BC);
731         final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(
732                 &quot;SHA-384&quot;, &quot;MGF1&quot;,
733                 new MGF1ParameterSpec(&quot;SHA-384&quot;),
734                 48, PSSParameterSpec.TRAILER_FIELD_BC);
735         final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(
736                 &quot;SHA-512&quot;, &quot;MGF1&quot;,
737                 new MGF1ParameterSpec(&quot;SHA-512&quot;),
738                 64, PSSParameterSpec.TRAILER_FIELD_BC);
739 
740         final static AlgorithmId PSS_256_ID;
741         final static AlgorithmId PSS_384_ID;
742         final static AlgorithmId PSS_512_ID;
743 
744         static {
745             try {
746                 PSS_256_ID = new AlgorithmId(RSASSA_PSS_oid,
747                         new DerValue(PSSParameters.getEncoded(PSS_256_SPEC)));
748                 PSS_384_ID = new AlgorithmId(RSASSA_PSS_oid,
749                         new DerValue(PSSParameters.getEncoded(PSS_384_SPEC)));
750                 PSS_512_ID = new AlgorithmId(RSASSA_PSS_oid,
751                         new DerValue(PSSParameters.getEncoded(PSS_512_SPEC)));
752             } catch (IOException e) {
753                 throw new AssertionError(&quot;Should not happen&quot;, e);
754             }
755         }
756     }
757 
758     public static AlgorithmId getWithParameterSpec(String algName,
759             AlgorithmParameterSpec spec) throws NoSuchAlgorithmException {
760 
761         if (spec == null) {
762             return AlgorithmId.get(algName);
763         } else if (spec == PSSParamsHolder.PSS_256_SPEC) {
764             return PSSParamsHolder.PSS_256_ID;
765         } else if (spec == PSSParamsHolder.PSS_384_SPEC) {
766             return PSSParamsHolder.PSS_384_ID;
767         } else if (spec == PSSParamsHolder.PSS_512_SPEC) {
768             return PSSParamsHolder.PSS_512_ID;
<a name="42" id="anc42"></a><span class="line-added">769         } else if (spec instanceof EdDSAParameterSpec) {</span>
<span class="line-added">770             return AlgorithmId.get(algName);</span>
771         } else {
772             try {
773                 AlgorithmParameters result =
774                         AlgorithmParameters.getInstance(algName);
775                 result.init(spec);
776                 return get(result);
777             } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {
778                 throw new ProviderException(e);
779             }
780         }
781     }
782 
783     public static AlgorithmParameterSpec getDefaultAlgorithmParameterSpec(
784             String sigAlg, PrivateKey k) {
785         if (sigAlg.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
786             if (k instanceof RSAKey) {
787                 AlgorithmParameterSpec spec = ((RSAKey) k).getParams();
788                 if (spec instanceof PSSParameterSpec) {
789                     return spec;
790                 }
791             }
792             switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {
793                 case &quot;SHA256&quot;:
794                     return PSSParamsHolder.PSS_256_SPEC;
795                 case &quot;SHA384&quot;:
796                     return PSSParamsHolder.PSS_384_SPEC;
797                 case &quot;SHA512&quot;:
798                     return PSSParamsHolder.PSS_512_SPEC;
799                 default:
800                     throw new AssertionError(&quot;Should not happen&quot;);
801             }
802         } else {
803             return null;
804         }
805     }
806 
<a name="43" id="anc43"></a><span class="line-added">807     private static String edAlgFromKey(PrivateKey k) {</span>
<span class="line-added">808         if (k instanceof EdECPrivateKey) {</span>
<span class="line-added">809             EdECPrivateKey edKey = (EdECPrivateKey) k;</span>
<span class="line-added">810             return edKey.getParams().getName();</span>
<span class="line-added">811         }</span>
<span class="line-added">812         return &quot;EdDSA&quot;;</span>
<span class="line-added">813     }</span>
<span class="line-added">814 </span>
815     // Values from SP800-57 part 1 rev 4 tables 2 and 3
816     private static String ecStrength (int bitLength) {
817         if (bitLength &gt;= 512) { // 256 bits of strength
818             return &quot;SHA512&quot;;
819         } else if (bitLength &gt;= 384) {  // 192 bits of strength
820             return &quot;SHA384&quot;;
821         } else { // 128 bits of strength and less
822             return &quot;SHA256&quot;;
823         }
824     }
825 
826     // Same values for RSA and DSA
827     private static String ifcFfcStrength (int bitLength) {
828         if (bitLength &gt; 7680) { // 256 bits
829             return &quot;SHA512&quot;;
830         } else if (bitLength &gt; 3072) {  // 192 bits
831             return &quot;SHA384&quot;;
832         } else  { // 128 bits and less
833             return &quot;SHA256&quot;;
834         }
835     }
836 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>
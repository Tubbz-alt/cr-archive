<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../SecurityProviderConstants.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerPolynomial1305.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
140 
141     @Override
142     public ImmutableElement get0() {
143         return new ImmutableElement(false);
144     }
145 
146     @Override
147     public ImmutableElement get1() {
148         return new ImmutableElement(true);
149     }
150 
151     @Override
152     public ImmutableElement getElement(BigInteger v) {
153         return new ImmutableElement(v);
154     }
155 
156     @Override
157     public SmallValue getSmallValue(int value) {
158         int maxMag = 1 &lt;&lt; (bitsPerLimb - 1);
159         if (Math.abs(value) &gt;= maxMag) {
<span class="line-modified">160             throw new IllegalArgumentException(</span>
<span class="line-removed">161                 &quot;max magnitude is &quot; + maxMag);</span>
162         }
163         return new Limb(value);
164     }
165 























166     /**
167      * This version of encode takes a ByteBuffer that is properly ordered, and
168      * may extract larger values (e.g. long) from the ByteBuffer for better
169      * performance. The implementation below only extracts bytes from the
170      * buffer, but this method may be overridden in field-specific
171      * implementations.
172      */
173     protected void encode(ByteBuffer buf, int length, byte highByte,
174                           long[] result) {
175 
176         int numHighBits = 32 - Integer.numberOfLeadingZeros(highByte);
177         int numBits = 8 * length + numHighBits;
178         int requiredLimbs = (numBits + bitsPerLimb - 1) / bitsPerLimb;
179         if (requiredLimbs &gt; numLimbs) {
180             long[] temp = new long[requiredLimbs];
181             encodeSmall(buf, length, highByte, temp);
<span class="line-modified">182             // encode does a full carry/reduce</span>
183             System.arraycopy(temp, 0, result, 0, result.length);

184         } else {
185             encodeSmall(buf, length, highByte, result);

186         }
187     }
188 
189     protected void encodeSmall(ByteBuffer buf, int length, byte highByte,
190                                long[] result) {
191 
192         int limbIndex = 0;
193         long curLimbValue = 0;
194         int bitPos = 0;
195         for (int i = 0; i &lt; length; i++) {
196             long curV = buf.get() &amp; 0xFF;
197 
198             if (bitPos + 8 &gt;= bitsPerLimb) {
199                 int bitsThisLimb = bitsPerLimb - bitPos;
200                 curLimbValue += (curV &amp; (0xFF &gt;&gt; (8 - bitsThisLimb))) &lt;&lt; bitPos;
201                 result[limbIndex++] = curLimbValue;
202                 curLimbValue = curV &gt;&gt; bitsThisLimb;
203                 bitPos = 8 - bitsThisLimb;
204             }
205             else {
</pre>
<hr />
<pre>
209         }
210 
211         // one more for the high byte
212         if (highByte != 0) {
213             long curV = highByte &amp; 0xFF;
214             if (bitPos + 8 &gt;= bitsPerLimb) {
215                 int bitsThisLimb = bitsPerLimb - bitPos;
216                 curLimbValue += (curV &amp; (0xFF &gt;&gt; (8 - bitsThisLimb))) &lt;&lt; bitPos;
217                 result[limbIndex++] = curLimbValue;
218                 curLimbValue = curV &gt;&gt; bitsThisLimb;
219             }
220             else {
221                 curLimbValue += curV &lt;&lt; bitPos;
222             }
223         }
224 
225         if (limbIndex &lt; result.length) {
226             result[limbIndex++] = curLimbValue;
227         }
228         Arrays.fill(result, limbIndex, result.length, 0);
<span class="line-removed">229 </span>
<span class="line-removed">230         postEncodeCarry(result);</span>
231     }
232 
233     protected void encode(byte[] v, int offset, int length, byte highByte,
234                           long[] result) {
235 
236         ByteBuffer buf = ByteBuffer.wrap(v, offset, length);
237         buf.order(ByteOrder.LITTLE_ENDIAN);
238         encode(buf, length, highByte, result);
239     }
240 
241     // Encode does not produce compressed limbs. A simplified carry/reduce
242     // operation can be used to compress the limbs.
243     protected void postEncodeCarry(long[] v) {
244         reduce(v);
245     }
246 
247     public ImmutableElement getElement(byte[] v, int offset, int length,
248                                        byte highByte) {
249 
250         long[] result = new long[numLimbs];
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
140 
141     @Override
142     public ImmutableElement get0() {
143         return new ImmutableElement(false);
144     }
145 
146     @Override
147     public ImmutableElement get1() {
148         return new ImmutableElement(true);
149     }
150 
151     @Override
152     public ImmutableElement getElement(BigInteger v) {
153         return new ImmutableElement(v);
154     }
155 
156     @Override
157     public SmallValue getSmallValue(int value) {
158         int maxMag = 1 &lt;&lt; (bitsPerLimb - 1);
159         if (Math.abs(value) &gt;= maxMag) {
<span class="line-modified">160             throw new IllegalArgumentException(&quot;max magnitude is &quot; + maxMag);</span>

161         }
162         return new Limb(value);
163     }
164 
<span class="line-added">165     protected abstract void reduceIn(long[] c, long v, int i);</span>
<span class="line-added">166 </span>
<span class="line-added">167     private void reduceHigh(long[] limbs) {</span>
<span class="line-added">168 </span>
<span class="line-added">169         // conservatively calculate how many reduce operations can be done</span>
<span class="line-added">170         // before a carry is needed</span>
<span class="line-added">171         int extraBits = 63 - 2 * bitsPerLimb;</span>
<span class="line-added">172         int allowedAdds = 1 &lt;&lt; extraBits;</span>
<span class="line-added">173         int carryPeriod = allowedAdds / numLimbs;</span>
<span class="line-added">174         int reduceCount = 0;</span>
<span class="line-added">175         for (int i = limbs.length - 1; i &gt;= numLimbs; i--) {</span>
<span class="line-added">176             reduceIn(limbs, limbs[i], i);</span>
<span class="line-added">177             limbs[i] = 0;</span>
<span class="line-added">178 </span>
<span class="line-added">179             reduceCount++;</span>
<span class="line-added">180             if (reduceCount % carryPeriod == 0) {</span>
<span class="line-added">181                 carry(limbs, 0, i);</span>
<span class="line-added">182                 reduceIn(limbs, limbs[i], i);</span>
<span class="line-added">183                 limbs[i] = 0;</span>
<span class="line-added">184             }</span>
<span class="line-added">185         }</span>
<span class="line-added">186     }</span>
<span class="line-added">187 </span>
188     /**
189      * This version of encode takes a ByteBuffer that is properly ordered, and
190      * may extract larger values (e.g. long) from the ByteBuffer for better
191      * performance. The implementation below only extracts bytes from the
192      * buffer, but this method may be overridden in field-specific
193      * implementations.
194      */
195     protected void encode(ByteBuffer buf, int length, byte highByte,
196                           long[] result) {
197 
198         int numHighBits = 32 - Integer.numberOfLeadingZeros(highByte);
199         int numBits = 8 * length + numHighBits;
200         int requiredLimbs = (numBits + bitsPerLimb - 1) / bitsPerLimb;
201         if (requiredLimbs &gt; numLimbs) {
202             long[] temp = new long[requiredLimbs];
203             encodeSmall(buf, length, highByte, temp);
<span class="line-modified">204             reduceHigh(temp);</span>
205             System.arraycopy(temp, 0, result, 0, result.length);
<span class="line-added">206             reduce(result);</span>
207         } else {
208             encodeSmall(buf, length, highByte, result);
<span class="line-added">209             postEncodeCarry(result);</span>
210         }
211     }
212 
213     protected void encodeSmall(ByteBuffer buf, int length, byte highByte,
214                                long[] result) {
215 
216         int limbIndex = 0;
217         long curLimbValue = 0;
218         int bitPos = 0;
219         for (int i = 0; i &lt; length; i++) {
220             long curV = buf.get() &amp; 0xFF;
221 
222             if (bitPos + 8 &gt;= bitsPerLimb) {
223                 int bitsThisLimb = bitsPerLimb - bitPos;
224                 curLimbValue += (curV &amp; (0xFF &gt;&gt; (8 - bitsThisLimb))) &lt;&lt; bitPos;
225                 result[limbIndex++] = curLimbValue;
226                 curLimbValue = curV &gt;&gt; bitsThisLimb;
227                 bitPos = 8 - bitsThisLimb;
228             }
229             else {
</pre>
<hr />
<pre>
233         }
234 
235         // one more for the high byte
236         if (highByte != 0) {
237             long curV = highByte &amp; 0xFF;
238             if (bitPos + 8 &gt;= bitsPerLimb) {
239                 int bitsThisLimb = bitsPerLimb - bitPos;
240                 curLimbValue += (curV &amp; (0xFF &gt;&gt; (8 - bitsThisLimb))) &lt;&lt; bitPos;
241                 result[limbIndex++] = curLimbValue;
242                 curLimbValue = curV &gt;&gt; bitsThisLimb;
243             }
244             else {
245                 curLimbValue += curV &lt;&lt; bitPos;
246             }
247         }
248 
249         if (limbIndex &lt; result.length) {
250             result[limbIndex++] = curLimbValue;
251         }
252         Arrays.fill(result, limbIndex, result.length, 0);


253     }
254 
255     protected void encode(byte[] v, int offset, int length, byte highByte,
256                           long[] result) {
257 
258         ByteBuffer buf = ByteBuffer.wrap(v, offset, length);
259         buf.order(ByteOrder.LITTLE_ENDIAN);
260         encode(buf, length, highByte, result);
261     }
262 
263     // Encode does not produce compressed limbs. A simplified carry/reduce
264     // operation can be used to compress the limbs.
265     protected void postEncodeCarry(long[] v) {
266         reduce(v);
267     }
268 
269     public ImmutableElement getElement(byte[] v, int offset, int length,
270                                        byte highByte) {
271 
272         long[] result = new long[numLimbs];
</pre>
</td>
</tr>
</table>
<center><a href="../../SecurityProviderConstants.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerPolynomial1305.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
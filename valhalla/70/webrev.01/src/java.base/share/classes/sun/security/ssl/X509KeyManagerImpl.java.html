<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/X509KeyManagerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.lang.ref.*;
 29 import java.net.Socket;
 30 import java.security.AlgorithmConstraints;
 31 import java.security.KeyStore;
 32 import java.security.KeyStore.Builder;
 33 import java.security.KeyStore.Entry;
 34 import java.security.KeyStore.PrivateKeyEntry;
 35 import java.security.Principal;
 36 import java.security.PrivateKey;
 37 import java.security.cert.CertPathValidatorException;
 38 import java.security.cert.Certificate;
 39 import java.security.cert.CertificateException;
 40 import java.security.cert.X509Certificate;
 41 import java.util.*;
 42 import java.util.concurrent.atomic.AtomicLong;
 43 import javax.net.ssl.*;
 44 import sun.security.provider.certpath.AlgorithmChecker;
 45 import sun.security.validator.Validator;
 46 import sun.security.util.KnownOIDs;
 47 
 48 /**
 49  * The new X509 key manager implementation. The main differences to the
 50  * old SunX509 key manager are:
 51  *  . it is based around the KeyStore.Builder API. This allows it to use
 52  *    other forms of KeyStore protection or password input (e.g. a
 53  *    CallbackHandler) or to have keys within one KeyStore protected by
 54  *    different keys.
 55  *  . it can use multiple KeyStores at the same time.
 56  *  . it is explicitly designed to accommodate KeyStores that change over
 57  *    the lifetime of the process.
 58  *  . it makes an effort to choose the key that matches best, i.e. one that
 59  *    is not expired and has the appropriate certificate extensions.
 60  *
 61  * Note that this code is not explicitly performance optimzied yet.
 62  *
 63  * @author  Andreas Sterbenz
 64  */
 65 final class X509KeyManagerImpl extends X509ExtendedKeyManager
 66         implements X509KeyManager {
 67 
 68     // for unit testing only, set via privileged reflection
 69     private static Date verificationDate;
 70 
 71     // list of the builders
 72     private final List&lt;Builder&gt; builders;
 73 
 74     // counter to generate unique ids for the aliases
 75     private final AtomicLong uidCounter;
 76 
 77     // cached entries
 78     private final Map&lt;String,Reference&lt;PrivateKeyEntry&gt;&gt; entryCacheMap;
 79 
 80     X509KeyManagerImpl(Builder builder) {
 81         this(Collections.singletonList(builder));
 82     }
 83 
 84     X509KeyManagerImpl(List&lt;Builder&gt; builders) {
 85         this.builders = builders;
 86         uidCounter = new AtomicLong();
 87         entryCacheMap = Collections.synchronizedMap
 88                         (new SizedMap&lt;String,Reference&lt;PrivateKeyEntry&gt;&gt;());
 89     }
 90 
 91     // LinkedHashMap with a max size of 10
 92     // see LinkedHashMap JavaDocs
 93     private static class SizedMap&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; {
 94         @java.io.Serial
 95         private static final long serialVersionUID = -8211222668790986062L;
 96 
 97         @Override protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
 98             return size() &gt; 10;
 99         }
100     }
101 
102     //
103     // public methods
104     //
105 
106     @Override
107     public X509Certificate[] getCertificateChain(String alias) {
108         PrivateKeyEntry entry = getEntry(alias);
109         return entry == null ? null :
110                 (X509Certificate[])entry.getCertificateChain();
111     }
112 
113     @Override
114     public PrivateKey getPrivateKey(String alias) {
115         PrivateKeyEntry entry = getEntry(alias);
116         return entry == null ? null : entry.getPrivateKey();
117     }
118 
119     @Override
120     public String chooseClientAlias(String[] keyTypes, Principal[] issuers,
121             Socket socket) {
122         return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,
123                         getAlgorithmConstraints(socket));
124     }
125 
126     @Override
127     public String chooseEngineClientAlias(String[] keyTypes,
128             Principal[] issuers, SSLEngine engine) {
129         return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,
130                         getAlgorithmConstraints(engine));
131     }
132 
133     @Override
134     public String chooseServerAlias(String keyType,
135             Principal[] issuers, Socket socket) {
136         return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,
137             getAlgorithmConstraints(socket),
138             X509TrustManagerImpl.getRequestedServerNames(socket),
139             &quot;HTTPS&quot;);    // The SNI HostName is a fully qualified domain name.
140                          // The certificate selection scheme for SNI HostName
141                          // is similar to HTTPS endpoint identification scheme
142                          // implemented in this provider.
143                          //
144                          // Using HTTPS endpoint identification scheme to guide
145                          // the selection of an appropriate authentication
146                          // certificate according to requested SNI extension.
147                          //
148                          // It is not a really HTTPS endpoint identification.
149     }
150 
151     @Override
152     public String chooseEngineServerAlias(String keyType,
153             Principal[] issuers, SSLEngine engine) {
154         return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,
155             getAlgorithmConstraints(engine),
156             X509TrustManagerImpl.getRequestedServerNames(engine),
157             &quot;HTTPS&quot;);    // The SNI HostName is a fully qualified domain name.
158                          // The certificate selection scheme for SNI HostName
159                          // is similar to HTTPS endpoint identification scheme
160                          // implemented in this provider.
161                          //
162                          // Using HTTPS endpoint identification scheme to guide
163                          // the selection of an appropriate authentication
164                          // certificate according to requested SNI extension.
165                          //
166                          // It is not a really HTTPS endpoint identification.
167     }
168 
169     @Override
170     public String[] getClientAliases(String keyType, Principal[] issuers) {
171         return getAliases(keyType, issuers, CheckType.CLIENT, null);
172     }
173 
174     @Override
175     public String[] getServerAliases(String keyType, Principal[] issuers) {
176         return getAliases(keyType, issuers, CheckType.SERVER, null);
177     }
178 
179     //
180     // implementation private methods
181     //
182 
183     // Gets algorithm constraints of the socket.
184     private AlgorithmConstraints getAlgorithmConstraints(Socket socket) {
185         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
186                                         socket instanceof SSLSocket) {
187 
188             SSLSocket sslSocket = (SSLSocket)socket;
189             SSLSession session = sslSocket.getHandshakeSession();
190 
191             if (session != null) {
192                 if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
193                     String[] peerSupportedSignAlgs = null;
194 
195                     if (session instanceof ExtendedSSLSession) {
196                         ExtendedSSLSession extSession =
197                             (ExtendedSSLSession)session;
198                         peerSupportedSignAlgs =
199                             extSession.getPeerSupportedSignatureAlgorithms();
200                     }
201 
202                     return new SSLAlgorithmConstraints(
203                         sslSocket, peerSupportedSignAlgs, true);
204                 }
205             }
206 
207             return new SSLAlgorithmConstraints(sslSocket, true);
208         }
209 
210         return new SSLAlgorithmConstraints((SSLSocket)null, true);
211     }
212 
213     // Gets algorithm constraints of the engine.
214     private AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {
215         if (engine != null) {
216             SSLSession session = engine.getHandshakeSession();
217             if (session != null) {
218                 if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
219                     String[] peerSupportedSignAlgs = null;
220 
221                     if (session instanceof ExtendedSSLSession) {
222                         ExtendedSSLSession extSession =
223                             (ExtendedSSLSession)session;
224                         peerSupportedSignAlgs =
225                             extSession.getPeerSupportedSignatureAlgorithms();
226                     }
227 
228                     return new SSLAlgorithmConstraints(
229                         engine, peerSupportedSignAlgs, true);
230                 }
231             }
232         }
233 
234         return new SSLAlgorithmConstraints(engine, true);
235     }
236 
237     // we construct the alias we return to JSSE as seen in the code below
238     // a unique id is included to allow us to reliably cache entries
239     // between the calls to getCertificateChain() and getPrivateKey()
240     // even if tokens are inserted or removed
241     private String makeAlias(EntryStatus entry) {
242         return uidCounter.incrementAndGet() + &quot;.&quot; + entry.builderIndex + &quot;.&quot;
243                 + entry.alias;
244     }
245 
246     private PrivateKeyEntry getEntry(String alias) {
247         // if the alias is null, return immediately
248         if (alias == null) {
249             return null;
250         }
251 
252         // try to get the entry from cache
253         Reference&lt;PrivateKeyEntry&gt; ref = entryCacheMap.get(alias);
254         PrivateKeyEntry entry = (ref != null) ? ref.get() : null;
255         if (entry != null) {
256             return entry;
257         }
258 
259         // parse the alias
260         int firstDot = alias.indexOf(&#39;.&#39;);
261         int secondDot = alias.indexOf(&#39;.&#39;, firstDot + 1);
262         if ((firstDot == -1) || (secondDot == firstDot)) {
263             // invalid alias
264             return null;
265         }
266         try {
267             int builderIndex = Integer.parseInt
268                                 (alias.substring(firstDot + 1, secondDot));
269             String keyStoreAlias = alias.substring(secondDot + 1);
270             Builder builder = builders.get(builderIndex);
271             KeyStore ks = builder.getKeyStore();
272             Entry newEntry = ks.getEntry
273                     (keyStoreAlias, builder.getProtectionParameter(alias));
274             if (newEntry instanceof PrivateKeyEntry == false) {
275                 // unexpected type of entry
276                 return null;
277             }
278             entry = (PrivateKeyEntry)newEntry;
279             entryCacheMap.put(alias, new SoftReference&lt;PrivateKeyEntry&gt;(entry));
280             return entry;
281         } catch (Exception e) {
282             // ignore
283             return null;
284         }
285     }
286 
287     // Class to help verify that the public key algorithm (and optionally
288     // the signature algorithm) of a certificate matches what we need.
289     private static class KeyType {
290 
291         final String keyAlgorithm;
292 
293         // In TLS 1.2, the signature algorithm  has been obsoleted by the
294         // supported_signature_algorithms, and the certificate type no longer
295         // restricts the algorithm used to sign the certificate.
296         //
297         // However, because we don&#39;t support certificate type checking other
298         // than rsa_sign, dss_sign and ecdsa_sign, we don&#39;t have to check the
299         // protocol version here.
300         final String sigKeyAlgorithm;
301 
302         KeyType(String algorithm) {
303             int k = algorithm.indexOf(&#39;_&#39;);
304             if (k == -1) {
305                 keyAlgorithm = algorithm;
306                 sigKeyAlgorithm = null;
307             } else {
308                 keyAlgorithm = algorithm.substring(0, k);
309                 sigKeyAlgorithm = algorithm.substring(k + 1);
310             }
311         }
312 
313         boolean matches(Certificate[] chain) {
314             if (!chain[0].getPublicKey().getAlgorithm().equals(keyAlgorithm)) {
315                 return false;
316             }
317             if (sigKeyAlgorithm == null) {
318                 return true;
319             }
320             if (chain.length &gt; 1) {
321                 // if possible, check the public key in the issuer cert
322                 return sigKeyAlgorithm.equals(
323                         chain[1].getPublicKey().getAlgorithm());
324             } else {
325                 // Check the signature algorithm of the certificate itself.
326                 // Look for the &quot;withRSA&quot; in &quot;SHA1withRSA&quot;, etc.
327                 X509Certificate issuer = (X509Certificate)chain[0];
328                 String sigAlgName =
329                         issuer.getSigAlgName().toUpperCase(Locale.ENGLISH);
330                 String pattern =
331                         &quot;WITH&quot; + sigKeyAlgorithm.toUpperCase(Locale.ENGLISH);
332                 return sigAlgName.contains(pattern);
333             }
334         }
335     }
336 
337     private static List&lt;KeyType&gt; getKeyTypes(String ... keyTypes) {
338         if ((keyTypes == null) ||
339                 (keyTypes.length == 0) || (keyTypes[0] == null)) {
340             return null;
341         }
342         List&lt;KeyType&gt; list = new ArrayList&lt;&gt;(keyTypes.length);
343         for (String keyType : keyTypes) {
344             list.add(new KeyType(keyType));
345         }
346         return list;
347     }
348 
349     /*
350      * Return the best alias that fits the given parameters.
351      * The algorithm we use is:
352      *   . scan through all the aliases in all builders in order
353      *   . as soon as we find a perfect match, return
354      *     (i.e. a match with a cert that has appropriate key usage,
355      *      qualified endpoint identity, and is not expired).
356      *   . if we do not find a perfect match, keep looping and remember
357      *     the imperfect matches
358      *   . at the end, sort the imperfect matches. we prefer expired certs
359      *     with appropriate key usage to certs with the wrong key usage.
360      *     return the first one of them.
361      */
362     private String chooseAlias(List&lt;KeyType&gt; keyTypeList, Principal[] issuers,
363             CheckType checkType, AlgorithmConstraints constraints) {
364 
365         return chooseAlias(keyTypeList, issuers,
366                                     checkType, constraints, null, null);
367     }
368 
369     private String chooseAlias(List&lt;KeyType&gt; keyTypeList, Principal[] issuers,
370             CheckType checkType, AlgorithmConstraints constraints,
371             List&lt;SNIServerName&gt; requestedServerNames, String idAlgorithm) {
372 
373         if (keyTypeList == null || keyTypeList.isEmpty()) {
374             return null;
375         }
376 
377         Set&lt;Principal&gt; issuerSet = getIssuerSet(issuers);
378         List&lt;EntryStatus&gt; allResults = null;
379         for (int i = 0, n = builders.size(); i &lt; n; i++) {
380             try {
381                 List&lt;EntryStatus&gt; results = getAliases(i, keyTypeList,
382                             issuerSet, false, checkType, constraints,
383                             requestedServerNames, idAlgorithm);
384                 if (results != null) {
385                     // the results will either be a single perfect match
386                     // or 1 or more imperfect matches
387                     // if it&#39;s a perfect match, return immediately
388                     EntryStatus status = results.get(0);
389                     if (status.checkResult == CheckResult.OK) {
390                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
391                             SSLLogger.fine(&quot;KeyMgr: choosing key: &quot; + status);
392                         }
393                         return makeAlias(status);
394                     }
395                     if (allResults == null) {
396                         allResults = new ArrayList&lt;EntryStatus&gt;();
397                     }
398                     allResults.addAll(results);
399                 }
400             } catch (Exception e) {
401                 // ignore
402             }
403         }
404         if (allResults == null) {
405             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
406                 SSLLogger.fine(&quot;KeyMgr: no matching key found&quot;);
407             }
408             return null;
409         }
410         Collections.sort(allResults);
411         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
412             SSLLogger.fine(
413                     &quot;KeyMgr: no good matching key found, &quot;
414                     + &quot;returning best match out of&quot;, allResults);
415         }
416         return makeAlias(allResults.get(0));
417     }
418 
419     /*
420      * Return all aliases that (approximately) fit the parameters.
421      * These are perfect matches plus imperfect matches (expired certificates
422      * and certificates with the wrong extensions).
423      * The perfect matches will be first in the array.
424      */
425     public String[] getAliases(String keyType, Principal[] issuers,
426             CheckType checkType, AlgorithmConstraints constraints) {
427         if (keyType == null) {
428             return null;
429         }
430 
431         Set&lt;Principal&gt; issuerSet = getIssuerSet(issuers);
432         List&lt;KeyType&gt; keyTypeList = getKeyTypes(keyType);
433         List&lt;EntryStatus&gt; allResults = null;
434         for (int i = 0, n = builders.size(); i &lt; n; i++) {
435             try {
436                 List&lt;EntryStatus&gt; results = getAliases(i, keyTypeList,
437                                     issuerSet, true, checkType, constraints,
438                                     null, null);
439                 if (results != null) {
440                     if (allResults == null) {
441                         allResults = new ArrayList&lt;&gt;();
442                     }
443                     allResults.addAll(results);
444                 }
445             } catch (Exception e) {
446                 // ignore
447             }
448         }
449         if (allResults == null || allResults.isEmpty()) {
450             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
451                 SSLLogger.fine(&quot;KeyMgr: no matching alias found&quot;);
452             }
453             return null;
454         }
455         Collections.sort(allResults);
456         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
457             SSLLogger.fine(&quot;KeyMgr: getting aliases&quot;, allResults);
458         }
459         return toAliases(allResults);
460     }
461 
462     // turn candidate entries into unique aliases we can return to JSSE
463     private String[] toAliases(List&lt;EntryStatus&gt; results) {
464         String[] s = new String[results.size()];
465         int i = 0;
466         for (EntryStatus result : results) {
467             s[i++] = makeAlias(result);
468         }
469         return s;
470     }
471 
472     // make a Set out of the array
473     private Set&lt;Principal&gt; getIssuerSet(Principal[] issuers) {
474         if ((issuers != null) &amp;&amp; (issuers.length != 0)) {
475             return new HashSet&lt;&gt;(Arrays.asList(issuers));
476         } else {
477             return null;
478         }
479     }
480 
481     // a candidate match
482     // identifies the entry by builder and alias
483     // and includes the result of the certificate check
484     private static class EntryStatus implements Comparable&lt;EntryStatus&gt; {
485 
486         final int builderIndex;
487         final int keyIndex;
488         final String alias;
489         final CheckResult checkResult;
490 
491         EntryStatus(int builderIndex, int keyIndex, String alias,
492                 Certificate[] chain, CheckResult checkResult) {
493             this.builderIndex = builderIndex;
494             this.keyIndex = keyIndex;
495             this.alias = alias;
496             this.checkResult = checkResult;
497         }
498 
499         @Override
500         public int compareTo(EntryStatus other) {
501             int result = this.checkResult.compareTo(other.checkResult);
502             return (result == 0) ? (this.keyIndex - other.keyIndex) : result;
503         }
504 
505         @Override
506         public String toString() {
507             String s = alias + &quot; (verified: &quot; + checkResult + &quot;)&quot;;
508             if (builderIndex == 0) {
509                 return s;
510             } else {
511                 return &quot;Builder #&quot; + builderIndex + &quot;, alias: &quot; + s;
512             }
513         }
514     }
515 
516     // enum for the type of certificate check we want to perform
517     // (client or server)
518     // also includes the check code itself
519     private static enum CheckType {
520 
521         // enum constant for &quot;no check&quot; (currently not used)
522         NONE(Collections.&lt;String&gt;emptySet()),
523 
524         // enum constant for &quot;tls client&quot; check
525         // valid EKU for TLS client: any, tls_client
526         CLIENT(new HashSet&lt;String&gt;(List.of(
527             KnownOIDs.anyExtendedKeyUsage.value(),
528             KnownOIDs.clientAuth.value()
529         ))),
530 
531         // enum constant for &quot;tls server&quot; check
532         // valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc
533         SERVER(new HashSet&lt;String&gt;(List.of(
534             KnownOIDs.anyExtendedKeyUsage.value(),
535             KnownOIDs.serverAuth.value(),
536             KnownOIDs.NETSCAPE_ExportApproved.value(),
537             KnownOIDs.MICROSOFT_ExportApproved.value()
538         )));
539 
540         // set of valid EKU values for this type
541         final Set&lt;String&gt; validEku;
542 
543         CheckType(Set&lt;String&gt; validEku) {
544             this.validEku = validEku;
545         }
546 
547         private static boolean getBit(boolean[] keyUsage, int bit) {
548             return (bit &lt; keyUsage.length) &amp;&amp; keyUsage[bit];
549         }
550 
551         // Check if this certificate is appropriate for this type of use
552         // first check extensions, if they match, check expiration.
553         //
554         // Note: we may want to move this code into the sun.security.validator
555         // package
556         CheckResult check(X509Certificate cert, Date date,
557                 List&lt;SNIServerName&gt; serverNames, String idAlgorithm) {
558 
559             if (this == NONE) {
560                 return CheckResult.OK;
561             }
562 
563             // check extensions
564             try {
565                 // check extended key usage
566                 List&lt;String&gt; certEku = cert.getExtendedKeyUsage();
567                 if ((certEku != null) &amp;&amp;
568                         Collections.disjoint(validEku, certEku)) {
569                     // if extension present and it does not contain any of
570                     // the valid EKU OIDs, return extension_mismatch
571                     return CheckResult.EXTENSION_MISMATCH;
572                 }
573 
574                 // check key usage
575                 boolean[] ku = cert.getKeyUsage();
576                 if (ku != null) {
577                     String algorithm = cert.getPublicKey().getAlgorithm();
578                     boolean supportsDigitalSignature = getBit(ku, 0);
579                     switch (algorithm) {
580                         case &quot;RSA&quot;:
581                             // require either signature bit
582                             // or if server also allow key encipherment bit
583                             if (!supportsDigitalSignature) {
584                                 if (this == CLIENT || getBit(ku, 2) == false) {
585                                     return CheckResult.EXTENSION_MISMATCH;
586                                 }
587                             }
588                             break;
589                         case &quot;RSASSA-PSS&quot;:
590                             if (!supportsDigitalSignature &amp;&amp; (this == SERVER)) {
591                                 return CheckResult.EXTENSION_MISMATCH;
592                             }
593                             break;
594                         case &quot;DSA&quot;:
595                             // require signature bit
596                             if (!supportsDigitalSignature) {
597                                 return CheckResult.EXTENSION_MISMATCH;
598                             }
599                             break;
600                         case &quot;DH&quot;:
601                             // require keyagreement bit
602                             if (getBit(ku, 4) == false) {
603                                 return CheckResult.EXTENSION_MISMATCH;
604                             }
605                             break;
606                         case &quot;EC&quot;:
607                             // require signature bit
608                             if (!supportsDigitalSignature) {
609                                 return CheckResult.EXTENSION_MISMATCH;
610                             }
611                             // For servers, also require key agreement.
612                             // This is not totally accurate as the keyAgreement
613                             // bit is only necessary for static ECDH key
614                             // exchange and not ephemeral ECDH. We leave it in
615                             // for now until there are signs that this check
616                             // causes problems for real world EC certificates.
617                             if ((this == SERVER) &amp;&amp; (getBit(ku, 4) == false)) {
618                                 return CheckResult.EXTENSION_MISMATCH;
619                             }
620                             break;
621                     }
622                 }
623             } catch (CertificateException e) {
624                 // extensions unparseable, return failure
625                 return CheckResult.EXTENSION_MISMATCH;
626             }
627 
628             try {
629                 cert.checkValidity(date);
630             } catch (CertificateException e) {
631                 return CheckResult.EXPIRED;
632             }
633 
634             if (serverNames != null &amp;&amp; !serverNames.isEmpty()) {
635                 for (SNIServerName serverName : serverNames) {
636                     if (serverName.getType() ==
637                                 StandardConstants.SNI_HOST_NAME) {
638                         if (!(serverName instanceof SNIHostName)) {
639                             try {
640                                 serverName =
641                                     new SNIHostName(serverName.getEncoded());
642                             } catch (IllegalArgumentException iae) {
643                                 // unlikely to happen, just in case ...
644                                 if (SSLLogger.isOn &amp;&amp;
645                                         SSLLogger.isOn(&quot;keymanager&quot;)) {
646                                     SSLLogger.fine(
647                                        &quot;Illegal server name: &quot; + serverName);
648                                 }
649 
650                                 return CheckResult.INSENSITIVE;
651                             }
652                         }
653                         String hostname =
654                                 ((SNIHostName)serverName).getAsciiName();
655 
656                         try {
657                             X509TrustManagerImpl.checkIdentity(hostname,
658                                                         cert, idAlgorithm);
659                         } catch (CertificateException e) {
660                             if (SSLLogger.isOn &amp;&amp;
661                                     SSLLogger.isOn(&quot;keymanager&quot;)) {
662                                 SSLLogger.fine(
663                                     &quot;Certificate identity does not match &quot; +
664                                     &quot;Server Name Inidication (SNI): &quot; +
665                                     hostname);
666                             }
667                             return CheckResult.INSENSITIVE;
668                         }
669 
670                         break;
671                     }
672                 }
673             }
674 
675             return CheckResult.OK;
676         }
677 
678         public String getValidator() {
679             if (this == CLIENT) {
680                 return Validator.VAR_TLS_CLIENT;
681             } else if (this == SERVER) {
682                 return Validator.VAR_TLS_SERVER;
683             }
684             return Validator.VAR_GENERIC;
685         }
686     }
687 
688     // enum for the result of the extension check
689     // NOTE: the order of the constants is important as they are used
690     // for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH
691     private static enum CheckResult {
692         OK,                     // ok or not checked
693         INSENSITIVE,            // server name indication insensitive
694         EXPIRED,                // extensions valid but cert expired
695         EXTENSION_MISMATCH,     // extensions invalid (expiration not checked)
696     }
697 
698     /*
699      * Return a List of all candidate matches in the specified builder
700      * that fit the parameters.
701      * We exclude entries in the KeyStore if they are not:
702      *  . private key entries
703      *  . the certificates are not X509 certificates
704      *  . the algorithm of the key in the EE cert doesn&#39;t match one of keyTypes
705      *  . none of the certs is issued by a Principal in issuerSet
706      * Using those entries would not be possible or they would almost
707      * certainly be rejected by the peer.
708      *
709      * In addition to those checks, we also check the extensions in the EE
710      * cert and its expiration. Even if there is a mismatch, we include
711      * such certificates because they technically work and might be accepted
712      * by the peer. This leads to more graceful failure and better error
713      * messages if the cert expires from one day to the next.
714      *
715      * The return values are:
716      *   . null, if there are no matching entries at all
717      *   . if &#39;findAll&#39; is &#39;false&#39; and there is a perfect match, a List
718      *     with a single element (early return)
719      *   . if &#39;findAll&#39; is &#39;false&#39; and there is NO perfect match, a List
720      *     with all the imperfect matches (expired, wrong extensions)
721      *   . if &#39;findAll&#39; is &#39;true&#39;, a List with all perfect and imperfect
722      *     matches
723      */
724     private List&lt;EntryStatus&gt; getAliases(int builderIndex,
725             List&lt;KeyType&gt; keyTypes, Set&lt;Principal&gt; issuerSet,
726             boolean findAll, CheckType checkType,
727             AlgorithmConstraints constraints,
728             List&lt;SNIServerName&gt; requestedServerNames,
729             String idAlgorithm) throws Exception {
730 
731         Builder builder = builders.get(builderIndex);
732         KeyStore ks = builder.getKeyStore();
733         List&lt;EntryStatus&gt; results = null;
734         Date date = verificationDate;
735         boolean preferred = false;
736         for (Enumeration&lt;String&gt; e = ks.aliases(); e.hasMoreElements(); ) {
737             String alias = e.nextElement();
738             // check if it is a key entry (private key or secret key)
739             if (!ks.isKeyEntry(alias)) {
740                 continue;
741             }
742 
743             Certificate[] chain = ks.getCertificateChain(alias);
744             if ((chain == null) || (chain.length == 0)) {
745                 // must be secret key entry, ignore
746                 continue;
747             }
748 
749             boolean incompatible = false;
750             for (Certificate cert : chain) {
751                 if (cert instanceof X509Certificate == false) {
752                     // not an X509Certificate, ignore this alias
753                     incompatible = true;
754                     break;
755                 }
756             }
757             if (incompatible) {
758                 continue;
759             }
760 
761             // check keytype
762             int keyIndex = -1;
763             int j = 0;
764             for (KeyType keyType : keyTypes) {
765                 if (keyType.matches(chain)) {
766                     keyIndex = j;
767                     break;
768                 }
769                 j++;
770             }
771             if (keyIndex == -1) {
772                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
773                     SSLLogger.fine(&quot;Ignore alias &quot; + alias
774                                 + &quot;: key algorithm does not match&quot;);
775                 }
776                 continue;
777             }
778             // check issuers
779             if (issuerSet != null) {
780                 boolean found = false;
781                 for (Certificate cert : chain) {
782                     X509Certificate xcert = (X509Certificate)cert;
783                     if (issuerSet.contains(xcert.getIssuerX500Principal())) {
784                         found = true;
785                         break;
786                     }
787                 }
788                 if (found == false) {
789                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
790                         SSLLogger.fine(
791                                 &quot;Ignore alias &quot; + alias
792                                 + &quot;: issuers do not match&quot;);
793                     }
794                     continue;
795                 }
796             }
797 
798             // check the algorithm constraints
799             if (constraints != null &amp;&amp;
800                     !conformsToAlgorithmConstraints(constraints, chain,
801                             checkType.getValidator())) {
802 
803                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
804                     SSLLogger.fine(&quot;Ignore alias &quot; + alias +
805                             &quot;: certificate list does not conform to &quot; +
806                             &quot;algorithm constraints&quot;);
807                 }
808                 continue;
809             }
810 
811             if (date == null) {
812                 date = new Date();
813             }
814             CheckResult checkResult =
815                     checkType.check((X509Certificate)chain[0], date,
816                                     requestedServerNames, idAlgorithm);
817             EntryStatus status =
818                     new EntryStatus(builderIndex, keyIndex,
819                                         alias, chain, checkResult);
820             if (!preferred &amp;&amp; checkResult == CheckResult.OK &amp;&amp; keyIndex == 0) {
821                 preferred = true;
822             }
823             if (preferred &amp;&amp; (findAll == false)) {
824                 // if we have a good match and do not need all matches,
825                 // return immediately
826                 return Collections.singletonList(status);
827             } else {
828                 if (results == null) {
829                     results = new ArrayList&lt;&gt;();
830                 }
831                 results.add(status);
832             }
833         }
834         return results;
835     }
836 
837     private static boolean conformsToAlgorithmConstraints(
838             AlgorithmConstraints constraints, Certificate[] chain,
839             String variant) {
840 
841         AlgorithmChecker checker =
842                 new AlgorithmChecker(constraints, null, variant);
843         try {
844             checker.init(false);
845         } catch (CertPathValidatorException cpve) {
846             // unlikely to happen
847             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
848                 SSLLogger.fine(
849                     &quot;Cannot initialize algorithm constraints checker&quot;, cpve);
850             }
851 
852             return false;
853         }
854 
855         // It is a forward checker, so we need to check from trust to target.
856         for (int i = chain.length - 1; i &gt;= 0; i--) {
857             Certificate cert = chain[i];
858             try {
859                 // We don&#39;t care about the unresolved critical extensions.
860                 checker.check(cert, Collections.&lt;String&gt;emptySet());
861             } catch (CertPathValidatorException cpve) {
862                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
863                     SSLLogger.fine(&quot;Certificate does not conform to &quot; +
864                             &quot;algorithm constraints&quot;, cert, cpve);
865                 }
866 
867                 return false;
868             }
869         }
870 
871         return true;
872     }
873 }
    </pre>
  </body>
</html>
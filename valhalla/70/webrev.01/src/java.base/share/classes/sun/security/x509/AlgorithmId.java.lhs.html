<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/AlgorithmId.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.*;
  29 import java.security.interfaces.RSAKey;
  30 import java.security.spec.AlgorithmParameterSpec;
<a name="1" id="anc1"></a>
  31 import java.security.spec.InvalidParameterSpecException;
  32 import java.security.spec.MGF1ParameterSpec;
  33 import java.security.spec.PSSParameterSpec;
  34 import java.util.*;
<a name="2" id="anc2"></a>
  35 import java.security.*;
<a name="3" id="anc3"></a>
  36 
  37 import sun.security.rsa.PSSParameters;
  38 import sun.security.util.*;
  39 
  40 
  41 /**
  42  * This class identifies algorithms, such as cryptographic transforms, each
  43  * of which may be associated with parameters.  Instances of this base class
  44  * are used when this runtime environment has no special knowledge of the
  45  * algorithm type, and may also be used in other cases.  Equivalence is
  46  * defined according to OID and (where relevant) parameters.
  47  *
  48  * &lt;P&gt;Subclasses may be used, for example when the algorithm ID has
  49  * associated parameters which some code (e.g. code using public keys) needs
  50  * to have parsed.  Two examples of such algorithms are Diffie-Hellman key
  51  * exchange, and the Digital Signature Standard Algorithm (DSS/DSA).
  52  *
  53  * &lt;P&gt;The OID constants defined in this class correspond to some widely
  54  * used algorithms, for which conventional string names have been defined.
  55  * This class is not a general repository for OIDs, or for such string names.
  56  * Note that the mappings between algorithm IDs and algorithm names is
  57  * not one-to-one.
  58  *
  59  *
  60  * @author David Brownell
  61  * @author Amit Kapoor
  62  * @author Hemma Prafullchandra
  63  */
  64 public class AlgorithmId implements Serializable, DerEncoder {
  65 
  66     /** use serialVersionUID from JDK 1.1. for interoperability */
  67     @java.io.Serial
  68     private static final long serialVersionUID = 7205873507486557157L;
  69 
  70     /**
  71      * The object identitifer being used for this algorithm.
  72      */
  73     private ObjectIdentifier algid;
  74 
  75     // The (parsed) parameters
  76     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
  77     private AlgorithmParameters algParams;
  78     private boolean constructedFromDer = true;
  79 
  80     /**
  81      * Parameters for this algorithm.  These are stored in unparsed
  82      * DER-encoded form; subclasses can be made to automaticaly parse
  83      * them so there is fast access to these parameters.
  84      */
  85     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
  86     protected DerValue          params;
  87 
  88 
  89     /**
  90      * Constructs an algorithm ID which will be initialized
  91      * separately, for example by deserialization.
  92      * @deprecated use one of the other constructors.
  93      */
  94     @Deprecated
  95     public AlgorithmId() { }
  96 
  97     /**
  98      * Constructs a parameterless algorithm ID.
  99      *
 100      * @param oid the identifier for the algorithm
 101      */
 102     public AlgorithmId(ObjectIdentifier oid) {
 103         algid = oid;
 104     }
 105 
 106     /**
 107      * Constructs an algorithm ID with algorithm parameters.
 108      *
 109      * @param oid the identifier for the algorithm.
 110      * @param algparams the associated algorithm parameters.
 111      */
 112     public AlgorithmId(ObjectIdentifier oid, AlgorithmParameters algparams) {
 113         algid = oid;
 114         algParams = algparams;
 115         constructedFromDer = false;
 116     }
 117 
 118     private AlgorithmId(ObjectIdentifier oid, DerValue params)
 119             throws IOException {
 120         this.algid = oid;
 121         this.params = params;
 122         if (this.params != null) {
 123             decodeParams();
 124         }
 125     }
 126 
 127     protected void decodeParams() throws IOException {
 128         String algidName = getName();
 129         try {
 130             algParams = AlgorithmParameters.getInstance(algidName);
 131         } catch (NoSuchAlgorithmException e) {
 132             /*
 133              * This algorithm parameter type is not supported, so we cannot
 134              * parse the parameters.
 135              */
 136             algParams = null;
 137             return;
 138         }
 139 
 140         // Decode (parse) the parameters
 141         algParams.init(params.toByteArray());
 142     }
 143 
 144     /**
 145      * Marshal a DER-encoded &quot;AlgorithmID&quot; sequence on the DER stream.
 146      */
 147     public final void encode(DerOutputStream out) throws IOException {
 148         derEncode(out);
 149     }
 150 
 151     /**
 152      * DER encode this object onto an output stream.
 153      * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
 154      *
 155      * @param out
 156      * the output stream on which to write the DER encoding.
 157      *
 158      * @exception IOException on encoding error.
 159      */
 160     public void derEncode (OutputStream out) throws IOException {
 161         DerOutputStream bytes = new DerOutputStream();
 162         DerOutputStream tmp = new DerOutputStream();
 163 
 164         bytes.putOID(algid);
 165         // Setup params from algParams since no DER encoding is given
 166         if (constructedFromDer == false) {
 167             if (algParams != null) {
 168                 params = new DerValue(algParams.getEncoded());
 169             } else {
 170                 params = null;
 171             }
 172         }
 173         if (params == null) {
 174             // Changes backed out for compatibility with Solaris
 175 
 176             // Several AlgorithmId should omit the whole parameter part when
 177             // it&#39;s NULL. They are ---
 178             // RFC 3370 2.1: Implementations SHOULD generate SHA-1
 179             // AlgorithmIdentifiers with absent parameters.
 180             // RFC 3447 C1: When id-sha1, id-sha224, id-sha256, id-sha384 and
 181             // id-sha512 are used in an AlgorithmIdentifier the parameters
 182             // (which are optional) SHOULD be omitted.
 183             // RFC 3279 2.3.2: The id-dsa algorithm syntax includes optional
 184             // domain parameters... When omitted, the parameters component
 185             // MUST be omitted entirely
 186             // RFC 3370 3.1: When the id-dsa-with-sha1 algorithm identifier
 187             // is used, the AlgorithmIdentifier parameters field MUST be absent.
 188             /*if (
 189                 algid.equals((Object)SHA_oid) ||
 190                 algid.equals((Object)SHA224_oid) ||
 191                 algid.equals((Object)SHA256_oid) ||
 192                 algid.equals((Object)SHA384_oid) ||
 193                 algid.equals((Object)SHA512_oid) ||
 194                 algid.equals((Object)SHA512_224_oid) ||
 195                 algid.equals((Object)SHA512_256_oid) ||
 196                 algid.equals((Object)DSA_oid) ||
 197                 algid.equals((Object)sha1WithDSA_oid)) {
 198                 ; // no parameter part encoded
 199             } else {
 200                 bytes.putNull();
 201             }*/
<a name="4" id="anc4"></a><span class="line-modified"> 202             if (algid.equals(RSASSA_PSS_oid)) {</span>

 203                 // RFC 4055 3.3: when an RSASSA-PSS key does not require
 204                 // parameter validation, field is absent.
 205             } else {
 206                 bytes.putNull();
 207             }
 208         } else {
 209             bytes.putDerValue(params);
 210         }
 211         tmp.write(DerValue.tag_Sequence, bytes);
 212         out.write(tmp.toByteArray());
 213     }
 214 
 215 
 216     /**
 217      * Returns the DER-encoded X.509 AlgorithmId as a byte array.
 218      */
 219     public final byte[] encode() throws IOException {
 220         DerOutputStream out = new DerOutputStream();
 221         derEncode(out);
 222         return out.toByteArray();
 223     }
 224 
 225     /**
 226      * Returns the ISO OID for this algorithm.  This is usually converted
 227      * to a string and used as part of an algorithm name, for example
 228      * &quot;OID.1.3.14.3.2.13&quot; style notation.  Use the &lt;code&gt;getName&lt;/code&gt;
 229      * call when you do not need to ensure cross-system portability
 230      * of algorithm names, or need a user friendly name.
 231      */
 232     public final ObjectIdentifier getOID () {
 233         return algid;
 234     }
 235 
 236     /**
 237      * Returns a name for the algorithm which may be more intelligible
 238      * to humans than the algorithm&#39;s OID, but which won&#39;t necessarily
 239      * be comprehensible on other systems.  For example, this might
 240      * return a name such as &quot;MD5withRSA&quot; for a signature algorithm on
 241      * some systems.  It also returns names like &quot;OID.1.2.3.4&quot;, when
 242      * no particular name for the algorithm is known.
 243      *
 244      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 245      * returns the &quot;full&quot; signature algorithm (Ex: SHA256withECDSA) directly.
 246      */
 247     public String getName() {
<a name="5" id="anc5"></a><span class="line-modified"> 248         String algName = nameTable.get(algid);</span>
<span class="line-modified"> 249         if (algName != null) {</span>
<span class="line-modified"> 250             return algName;</span>
<span class="line-modified"> 251         }</span>
<span class="line-modified"> 252         if ((params != null) &amp;&amp; algid.equals((Object)specifiedWithECDSA_oid)) {</span>
<span class="line-modified"> 253             try {</span>
<span class="line-modified"> 254                 AlgorithmId paramsId =</span>
 255                         AlgorithmId.parse(new DerValue(params.toByteArray()));
<a name="6" id="anc6"></a><span class="line-modified"> 256                 String paramsName = paramsId.getName();</span>
<span class="line-modified"> 257                 algName = makeSigAlg(paramsName, &quot;EC&quot;);</span>
<span class="line-modified"> 258             } catch (IOException e) {</span>
<span class="line-modified"> 259                 // ignore</span>











 260             }
 261         }
<a name="7" id="anc7"></a><span class="line-removed"> 262         return (algName == null) ? algid.toString() : algName;</span>
 263     }
 264 
 265     public AlgorithmParameters getParameters() {
 266         return algParams;
 267     }
 268 
 269     /**
 270      * Returns the DER encoded parameter, which can then be
 271      * used to initialize java.security.AlgorithmParameters.
 272      *
 273      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 274      * returns null because {@link #getName()} has already returned the &quot;full&quot;
 275      * signature algorithm (Ex: SHA256withECDSA).
 276      *
 277      * @return DER encoded parameters, or null not present.
 278      */
 279     public byte[] getEncodedParams() throws IOException {
<a name="8" id="anc8"></a><span class="line-modified"> 280         return (params == null || algid.equals(specifiedWithECDSA_oid))</span>

 281                 ? null
 282                 : params.toByteArray();
 283     }
 284 
 285     /**
 286      * Returns true iff the argument indicates the same algorithm
 287      * with the same parameters.
 288      */
 289     public boolean equals(AlgorithmId other) {
 290         boolean paramsEqual = Objects.equals(other.params, params);
 291         return (algid.equals((Object)other.algid) &amp;&amp; paramsEqual);
 292     }
 293 
 294     /**
 295      * Compares this AlgorithmID to another.  If algorithm parameters are
 296      * available, they are compared.  Otherwise, just the object IDs
 297      * for the algorithm are compared.
 298      *
 299      * @param other preferably an AlgorithmId, else an ObjectIdentifier
 300      */
 301     public boolean equals(Object other) {
 302         if (this == other) {
 303             return true;
 304         }
 305         if (other instanceof AlgorithmId) {
 306             return equals((AlgorithmId) other);
 307         } else if (other instanceof ObjectIdentifier) {
 308             return equals((ObjectIdentifier) other);
 309         } else {
 310             return false;
 311         }
 312     }
 313 
 314     /**
 315      * Compares two algorithm IDs for equality.  Returns true iff
 316      * they are the same algorithm, ignoring algorithm parameters.
 317      */
 318     public final boolean equals(ObjectIdentifier id) {
 319         return algid.equals((Object)id);
 320     }
 321 
 322     /**
 323      * Returns a hashcode for this AlgorithmId.
 324      *
 325      * @return a hashcode for this AlgorithmId.
 326      */
 327     public int hashCode() {
 328         StringBuilder sbuf = new StringBuilder();
 329         sbuf.append(algid.toString());
 330         sbuf.append(paramsToString());
 331         return sbuf.toString().hashCode();
 332     }
 333 
 334     /**
 335      * Provides a human-readable description of the algorithm parameters.
 336      * This may be redefined by subclasses which parse those parameters.
 337      */
 338     protected String paramsToString() {
 339         if (params == null) {
 340             return &quot;&quot;;
 341         } else if (algParams != null) {
 342             return algParams.toString();
 343         } else {
 344             return &quot;, params unparsed&quot;;
 345         }
 346     }
 347 
 348     /**
 349      * Returns a string describing the algorithm and its parameters.
 350      */
 351     public String toString() {
 352         return getName() + paramsToString();
 353     }
 354 
 355     /**
 356      * Parse (unmarshal) an ID from a DER sequence input value.  This form
 357      * parsing might be used when expanding a value which has already been
 358      * partially unmarshaled as a set or sequence member.
 359      *
 360      * @exception IOException on error.
 361      * @param val the input value, which contains the algid and, if
 362      *          there are any parameters, those parameters.
 363      * @return an ID for the algorithm.  If the system is configured
 364      *          appropriately, this may be an instance of a class
 365      *          with some kind of special support for this algorithm.
 366      *          In that case, you may &quot;narrow&quot; the type of the ID.
 367      */
 368     public static AlgorithmId parse(DerValue val) throws IOException {
 369         if (val.tag != DerValue.tag_Sequence) {
 370             throw new IOException(&quot;algid parse error, not a sequence&quot;);
 371         }
 372 
 373         /*
 374          * Get the algorithm ID and any parameters.
 375          */
 376         ObjectIdentifier        algid;
 377         DerValue                params;
 378         DerInputStream          in = val.toDerInputStream();
 379 
 380         algid = in.getOID();
 381         if (in.available() == 0) {
 382             params = null;
 383         } else {
 384             params = in.getDerValue();
 385             if (params.tag == DerValue.tag_Null) {
 386                 if (params.length() != 0) {
 387                     throw new IOException(&quot;invalid NULL&quot;);
 388                 }
 389                 params = null;
 390             }
 391             if (in.available() != 0) {
 392                 throw new IOException(&quot;Invalid AlgorithmIdentifier: extra data&quot;);
 393             }
 394         }
 395 
 396         return new AlgorithmId(algid, params);
 397     }
 398 
 399     /**
 400      * Returns one of the algorithm IDs most commonly associated
 401      * with this algorithm name.
 402      *
 403      * @param algname the name being used
 404      * @deprecated use the short get form of this method.
 405      * @exception NoSuchAlgorithmException on error.
 406      */
 407     @Deprecated
 408     public static AlgorithmId getAlgorithmId(String algname)
 409             throws NoSuchAlgorithmException {
 410         return get(algname);
 411     }
 412 
 413     /**
 414      * Returns one of the algorithm IDs most commonly associated
 415      * with this algorithm name.
 416      *
 417      * @param algname the name being used
 418      * @exception NoSuchAlgorithmException on error.
 419      */
 420     public static AlgorithmId get(String algname)
 421             throws NoSuchAlgorithmException {
 422         ObjectIdentifier oid;
 423         try {
 424             oid = algOID(algname);
 425         } catch (IOException ioe) {
 426             throw new NoSuchAlgorithmException
 427                 (&quot;Invalid ObjectIdentifier &quot; + algname);
 428         }
 429 
 430         if (oid == null) {
 431             throw new NoSuchAlgorithmException
 432                 (&quot;unrecognized algorithm name: &quot; + algname);
 433         }
 434         return new AlgorithmId(oid);
 435     }
 436 
 437     /**
 438      * Returns one of the algorithm IDs most commonly associated
 439      * with this algorithm parameters.
 440      *
 441      * @param algparams the associated algorithm parameters.
 442      * @exception NoSuchAlgorithmException on error.
 443      */
 444     public static AlgorithmId get(AlgorithmParameters algparams)
 445             throws NoSuchAlgorithmException {
 446         ObjectIdentifier oid;
 447         String algname = algparams.getAlgorithm();
 448         try {
 449             oid = algOID(algname);
 450         } catch (IOException ioe) {
 451             throw new NoSuchAlgorithmException
 452                 (&quot;Invalid ObjectIdentifier &quot; + algname);
 453         }
 454         if (oid == null) {
 455             throw new NoSuchAlgorithmException
 456                 (&quot;unrecognized algorithm name: &quot; + algname);
 457         }
 458         return new AlgorithmId(oid, algparams);
 459     }
 460 
 461     /*
 462      * Translates from some common algorithm names to the
 463      * OID with which they&#39;re usually associated ... this mapping
 464      * is the reverse of the one below, except in those cases
 465      * where synonyms are supported or where a given algorithm
 466      * is commonly associated with multiple OIDs.
 467      *
 468      * XXX This method needs to be enhanced so that we can also pass the
 469      * scope of the algorithm name to it, e.g., the algorithm name &quot;DSA&quot;
 470      * may have a different OID when used as a &quot;Signature&quot; algorithm than when
 471      * used as a &quot;KeyPairGenerator&quot; algorithm.
 472      */
 473     private static ObjectIdentifier algOID(String name) throws IOException {
<a name="9" id="anc9"></a><span class="line-modified"> 474         // See if algname is in printable OID (&quot;dot-dot&quot;) notation</span>
<span class="line-modified"> 475         if (name.indexOf(&#39;.&#39;) != -1) {</span>
<span class="line-removed"> 476             if (name.startsWith(&quot;OID.&quot;)) {</span>
<span class="line-removed"> 477                 return new ObjectIdentifier(name.substring(&quot;OID.&quot;.length()));</span>
<span class="line-removed"> 478             } else {</span>
<span class="line-removed"> 479                 return new ObjectIdentifier(name);</span>
<span class="line-removed"> 480             }</span>
 481         }
 482 
<a name="10" id="anc10"></a><span class="line-modified"> 483         // Digesting algorithms</span>
<span class="line-modified"> 484         if (name.equalsIgnoreCase(&quot;MD5&quot;)) {</span>
<span class="line-modified"> 485             return AlgorithmId.MD5_oid;</span>
<span class="line-removed"> 486         }</span>
<span class="line-removed"> 487         if (name.equalsIgnoreCase(&quot;MD2&quot;)) {</span>
<span class="line-removed"> 488             return AlgorithmId.MD2_oid;</span>
<span class="line-removed"> 489         }</span>
<span class="line-removed"> 490         if (name.equalsIgnoreCase(&quot;SHA&quot;) || name.equalsIgnoreCase(&quot;SHA1&quot;)</span>
<span class="line-removed"> 491             || name.equalsIgnoreCase(&quot;SHA-1&quot;)) {</span>
<span class="line-removed"> 492             return AlgorithmId.SHA_oid;</span>
<span class="line-removed"> 493         }</span>
<span class="line-removed"> 494         if (name.equalsIgnoreCase(&quot;SHA-256&quot;) ||</span>
<span class="line-removed"> 495             name.equalsIgnoreCase(&quot;SHA256&quot;)) {</span>
<span class="line-removed"> 496             return AlgorithmId.SHA256_oid;</span>
<span class="line-removed"> 497         }</span>
<span class="line-removed"> 498         if (name.equalsIgnoreCase(&quot;SHA-384&quot;) ||</span>
<span class="line-removed"> 499             name.equalsIgnoreCase(&quot;SHA384&quot;)) {</span>
<span class="line-removed"> 500             return AlgorithmId.SHA384_oid;</span>
<span class="line-removed"> 501         }</span>
<span class="line-removed"> 502         if (name.equalsIgnoreCase(&quot;SHA-512&quot;) ||</span>
<span class="line-removed"> 503             name.equalsIgnoreCase(&quot;SHA512&quot;)) {</span>
<span class="line-removed"> 504             return AlgorithmId.SHA512_oid;</span>
<span class="line-removed"> 505         }</span>
<span class="line-removed"> 506         if (name.equalsIgnoreCase(&quot;SHA-224&quot;) ||</span>
<span class="line-removed"> 507             name.equalsIgnoreCase(&quot;SHA224&quot;)) {</span>
<span class="line-removed"> 508             return AlgorithmId.SHA224_oid;</span>
<span class="line-removed"> 509         }</span>
<span class="line-removed"> 510         if (name.equalsIgnoreCase(&quot;SHA-512/224&quot;) ||</span>
<span class="line-removed"> 511             name.equalsIgnoreCase(&quot;SHA512/224&quot;)) {</span>
<span class="line-removed"> 512             return AlgorithmId.SHA512_224_oid;</span>
<span class="line-removed"> 513         }</span>
<span class="line-removed"> 514         if (name.equalsIgnoreCase(&quot;SHA-512/256&quot;) ||</span>
<span class="line-removed"> 515             name.equalsIgnoreCase(&quot;SHA512/256&quot;)) {</span>
<span class="line-removed"> 516             return AlgorithmId.SHA512_256_oid;</span>
<span class="line-removed"> 517         }</span>
<span class="line-removed"> 518         // Various public key algorithms</span>
<span class="line-removed"> 519         if (name.equalsIgnoreCase(&quot;RSA&quot;)) {</span>
<span class="line-removed"> 520             return AlgorithmId.RSAEncryption_oid;</span>
<span class="line-removed"> 521         }</span>
<span class="line-removed"> 522         if (name.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {</span>
<span class="line-removed"> 523             return AlgorithmId.RSASSA_PSS_oid;</span>
<span class="line-removed"> 524         }</span>
<span class="line-removed"> 525         if (name.equalsIgnoreCase(&quot;RSAES-OAEP&quot;)) {</span>
<span class="line-removed"> 526             return AlgorithmId.RSAES_OAEP_oid;</span>
<span class="line-removed"> 527         }</span>
<span class="line-removed"> 528         if (name.equalsIgnoreCase(&quot;Diffie-Hellman&quot;)</span>
<span class="line-removed"> 529             || name.equalsIgnoreCase(&quot;DH&quot;)) {</span>
<span class="line-removed"> 530             return AlgorithmId.DH_oid;</span>
<span class="line-removed"> 531         }</span>
<span class="line-removed"> 532         if (name.equalsIgnoreCase(&quot;DSA&quot;)) {</span>
<span class="line-removed"> 533             return AlgorithmId.DSA_oid;</span>
<span class="line-removed"> 534         }</span>
<span class="line-removed"> 535         if (name.equalsIgnoreCase(&quot;EC&quot;)) {</span>
<span class="line-removed"> 536             return EC_oid;</span>
<span class="line-removed"> 537         }</span>
<span class="line-removed"> 538         if (name.equalsIgnoreCase(&quot;ECDH&quot;)) {</span>
<span class="line-removed"> 539             return AlgorithmId.ECDH_oid;</span>
<span class="line-removed"> 540         }</span>
<span class="line-removed"> 541 </span>
<span class="line-removed"> 542         // Secret key algorithms</span>
<span class="line-removed"> 543         if (name.equalsIgnoreCase(&quot;AES&quot;)) {</span>
<span class="line-removed"> 544             return AlgorithmId.AES_oid;</span>
 545         }
 546 
<a name="11" id="anc11"></a><span class="line-modified"> 547         // Common signature types</span>
<span class="line-modified"> 548         if (name.equalsIgnoreCase(&quot;MD5withRSA&quot;)</span>
<span class="line-modified"> 549             || name.equalsIgnoreCase(&quot;MD5/RSA&quot;)) {</span>
<span class="line-modified"> 550             return AlgorithmId.md5WithRSAEncryption_oid;</span>
<span class="line-modified"> 551         }</span>
<span class="line-modified"> 552         if (name.equalsIgnoreCase(&quot;MD2withRSA&quot;)</span>
<span class="line-modified"> 553             || name.equalsIgnoreCase(&quot;MD2/RSA&quot;)) {</span>
<span class="line-modified"> 554             return AlgorithmId.md2WithRSAEncryption_oid;</span>
<span class="line-modified"> 555         }</span>
<span class="line-modified"> 556         if (name.equalsIgnoreCase(&quot;SHAwithDSA&quot;)</span>
<span class="line-modified"> 557             || name.equalsIgnoreCase(&quot;SHA1withDSA&quot;)</span>
<span class="line-removed"> 558             || name.equalsIgnoreCase(&quot;SHA/DSA&quot;)</span>
<span class="line-removed"> 559             || name.equalsIgnoreCase(&quot;SHA1/DSA&quot;)</span>
<span class="line-removed"> 560             || name.equalsIgnoreCase(&quot;DSAWithSHA1&quot;)</span>
<span class="line-removed"> 561             || name.equalsIgnoreCase(&quot;DSS&quot;)</span>
<span class="line-removed"> 562             || name.equalsIgnoreCase(&quot;SHA-1/DSA&quot;)) {</span>
<span class="line-removed"> 563             return AlgorithmId.sha1WithDSA_oid;</span>
<span class="line-removed"> 564         }</span>
<span class="line-removed"> 565         if (name.equalsIgnoreCase(&quot;SHA224WithDSA&quot;)) {</span>
<span class="line-removed"> 566             return AlgorithmId.sha224WithDSA_oid;</span>
<span class="line-removed"> 567         }</span>
<span class="line-removed"> 568         if (name.equalsIgnoreCase(&quot;SHA256WithDSA&quot;)) {</span>
<span class="line-removed"> 569             return AlgorithmId.sha256WithDSA_oid;</span>
<span class="line-removed"> 570         }</span>
<span class="line-removed"> 571         if (name.equalsIgnoreCase(&quot;SHA1WithRSA&quot;)</span>
<span class="line-removed"> 572             || name.equalsIgnoreCase(&quot;SHA1/RSA&quot;)) {</span>
<span class="line-removed"> 573             return AlgorithmId.sha1WithRSAEncryption_oid;</span>
<span class="line-removed"> 574         }</span>
<span class="line-removed"> 575         if (name.equalsIgnoreCase(&quot;SHA1withECDSA&quot;)</span>
<span class="line-removed"> 576                 || name.equalsIgnoreCase(&quot;ECDSA&quot;)) {</span>
<span class="line-removed"> 577             return AlgorithmId.sha1WithECDSA_oid;</span>
<span class="line-removed"> 578         }</span>
<span class="line-removed"> 579         if (name.equalsIgnoreCase(&quot;SHA224withECDSA&quot;)) {</span>
<span class="line-removed"> 580             return AlgorithmId.sha224WithECDSA_oid;</span>
<span class="line-removed"> 581         }</span>
<span class="line-removed"> 582         if (name.equalsIgnoreCase(&quot;SHA256withECDSA&quot;)) {</span>
<span class="line-removed"> 583             return AlgorithmId.sha256WithECDSA_oid;</span>
<span class="line-removed"> 584         }</span>
<span class="line-removed"> 585         if (name.equalsIgnoreCase(&quot;SHA384withECDSA&quot;)) {</span>
<span class="line-removed"> 586             return AlgorithmId.sha384WithECDSA_oid;</span>
<span class="line-removed"> 587         }</span>
<span class="line-removed"> 588         if (name.equalsIgnoreCase(&quot;SHA512withECDSA&quot;)) {</span>
<span class="line-removed"> 589             return AlgorithmId.sha512WithECDSA_oid;</span>
 590         }
<a name="12" id="anc12"></a><span class="line-removed"> 591 </span>
<span class="line-removed"> 592         return oidTable().get(name.toUpperCase(Locale.ENGLISH));</span>
 593     }
 594 
<a name="13" id="anc13"></a><span class="line-modified"> 595     private static volatile Map&lt;String,ObjectIdentifier&gt; oidTable;</span>
<span class="line-modified"> 596     private static final Map&lt;ObjectIdentifier,String&gt; nameTable;</span>
 597 
<a name="14" id="anc14"></a><span class="line-modified"> 598     /** Returns the oidTable, lazily initializing it on first access. */</span>
<span class="line-modified"> 599     private static Map&lt;String,ObjectIdentifier&gt; oidTable()</span>
<span class="line-modified"> 600         throws IOException {</span>
<span class="line-modified"> 601         // Double checked locking; safe because oidTable is volatile</span>
<span class="line-modified"> 602         Map&lt;String,ObjectIdentifier&gt; tab;</span>
<span class="line-removed"> 603         if ((tab = oidTable) == null) {</span>
 604             synchronized (AlgorithmId.class) {
<a name="15" id="anc15"></a><span class="line-modified"> 605                 if ((tab = oidTable) == null)</span>
<span class="line-modified"> 606                     oidTable = tab = computeOidTable();</span>

 607             }
 608         }
 609         return tab;
 610     }
 611 
<a name="16" id="anc16"></a><span class="line-modified"> 612     /** Collects the algorithm names from the installed providers. */</span>
<span class="line-modified"> 613     private static HashMap&lt;String,ObjectIdentifier&gt; computeOidTable()</span>
<span class="line-modified"> 614         throws IOException {</span>
<span class="line-modified"> 615         HashMap&lt;String,ObjectIdentifier&gt; tab = new HashMap&lt;&gt;();</span>














 616         for (Provider provider : Security.getProviders()) {
<a name="17" id="anc17"></a>




 617             for (Object key : provider.keySet()) {
 618                 String alias = (String)key;
 619                 String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
 620                 int index;
 621                 if (upperCaseAlias.startsWith(&quot;ALG.ALIAS&quot;) &amp;&amp;
<a name="18" id="anc18"></a><span class="line-modified"> 622                     (index=upperCaseAlias.indexOf(&quot;OID.&quot;, 0)) != -1) {</span>
 623                     index += &quot;OID.&quot;.length();
 624                     if (index == alias.length()) {
 625                         // invalid alias entry
 626                         break;
 627                     }
<a name="19" id="anc19"></a><span class="line-modified"> 628                     String oidString = alias.substring(index);</span>
 629                     String stdAlgName = provider.getProperty(alias);
 630                     if (stdAlgName != null) {
 631                         stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
 632                     }
<a name="20" id="anc20"></a><span class="line-modified"> 633                     if (stdAlgName != null &amp;&amp;</span>
<span class="line-modified"> 634                         tab.get(stdAlgName) == null) {</span>
<span class="line-modified"> 635                         tab.put(stdAlgName, new ObjectIdentifier(oidString));</span>





 636                     }
 637                 }
 638             }
 639         }
<a name="21" id="anc21"></a><span class="line-modified"> 640         return tab;</span>
 641     }
 642 
<a name="22" id="anc22"></a><span class="line-removed"> 643     /*****************************************************************/</span>
<span class="line-removed"> 644 </span>
<span class="line-removed"> 645     /*</span>
<span class="line-removed"> 646      * HASHING ALGORITHMS</span>
<span class="line-removed"> 647      */</span>
<span class="line-removed"> 648 </span>
<span class="line-removed"> 649     /**</span>
<span class="line-removed"> 650      * Algorithm ID for the MD2 Message Digest Algorthm, from RFC 1319.</span>
<span class="line-removed"> 651      * OID = 1.2.840.113549.2.2</span>
<span class="line-removed"> 652      */</span>
 653     public static final ObjectIdentifier MD2_oid =
<a name="23" id="anc23"></a><span class="line-modified"> 654         ObjectIdentifier.of(&quot;1.2.840.113549.2.2&quot;);</span>
 655 
<a name="24" id="anc24"></a><span class="line-removed"> 656     /**</span>
<span class="line-removed"> 657      * Algorithm ID for the MD5 Message Digest Algorthm, from RFC 1321.</span>
<span class="line-removed"> 658      * OID = 1.2.840.113549.2.5</span>
<span class="line-removed"> 659      */</span>
 660     public static final ObjectIdentifier MD5_oid =
<a name="25" id="anc25"></a><span class="line-modified"> 661         ObjectIdentifier.of(&quot;1.2.840.113549.2.5&quot;);</span>
 662 
<a name="26" id="anc26"></a><span class="line-removed"> 663     /**</span>
<span class="line-removed"> 664      * Algorithm ID for the SHA1 Message Digest Algorithm, from FIPS 180-1.</span>
<span class="line-removed"> 665      * This is sometimes called &quot;SHA&quot;, though that is often confusing since</span>
<span class="line-removed"> 666      * many people refer to FIPS 180 (which has an error) as defining SHA.</span>
<span class="line-removed"> 667      * OID = 1.3.14.3.2.26. Old SHA-0 OID: 1.3.14.3.2.18.</span>
<span class="line-removed"> 668      */</span>
 669     public static final ObjectIdentifier SHA_oid =
<a name="27" id="anc27"></a><span class="line-modified"> 670         ObjectIdentifier.of(&quot;1.3.14.3.2.26&quot;);</span>
 671 
 672     public static final ObjectIdentifier SHA224_oid =
<a name="28" id="anc28"></a><span class="line-modified"> 673         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.4&quot;);</span>
 674 
 675     public static final ObjectIdentifier SHA256_oid =
<a name="29" id="anc29"></a><span class="line-modified"> 676         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.1&quot;);</span>
 677 
 678     public static final ObjectIdentifier SHA384_oid =
<a name="30" id="anc30"></a><span class="line-modified"> 679         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.2&quot;);</span>
 680 
 681     public static final ObjectIdentifier SHA512_oid =
<a name="31" id="anc31"></a><span class="line-modified"> 682         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.3&quot;);</span>
 683 
 684     public static final ObjectIdentifier SHA512_224_oid =
<a name="32" id="anc32"></a><span class="line-modified"> 685         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.5&quot;);</span>
 686 
 687     public static final ObjectIdentifier SHA512_256_oid =
<a name="33" id="anc33"></a><span class="line-modified"> 688         ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.2.6&quot;);</span>
<span class="line-removed"> 689 </span>
<span class="line-removed"> 690     /*</span>
<span class="line-removed"> 691      * COMMON PUBLIC KEY TYPES</span>
<span class="line-removed"> 692      */</span>
<span class="line-removed"> 693     /*</span>
<span class="line-removed"> 694      * Note the preferred OIDs are named simply with no &quot;OIW&quot; or</span>
<span class="line-removed"> 695      * &quot;PKIX&quot; in them, even though they may point to data from these</span>
<span class="line-removed"> 696      * specs; e.g. SHA_oid, DH_oid, DSA_oid, SHA1WithDSA_oid...</span>
<span class="line-removed"> 697      */</span>
<span class="line-removed"> 698     /**</span>
<span class="line-removed"> 699      * Algorithm ID for Diffie Hellman Key agreement, from PKCS #3.</span>
<span class="line-removed"> 700      * Parameters include public values P and G, and may optionally specify</span>
<span class="line-removed"> 701      * the length of the private key X.  Alternatively, algorithm parameters</span>
<span class="line-removed"> 702      * may be derived from another source such as a Certificate Authority&#39;s</span>
<span class="line-removed"> 703      * certificate.</span>
<span class="line-removed"> 704      * OID = 1.2.840.113549.1.3.1</span>
<span class="line-removed"> 705      */</span>
<span class="line-removed"> 706     public static final ObjectIdentifier DH_oid =</span>
<span class="line-removed"> 707             ObjectIdentifier.of(&quot;1.2.840.113549.1.3.1&quot;);</span>
<span class="line-removed"> 708 </span>
<span class="line-removed"> 709     /**</span>
<span class="line-removed"> 710      * Algorithm ID for the Diffie Hellman Key Agreement (DH), from RFC 3279.</span>
<span class="line-removed"> 711      * Parameters may include public values P and G.</span>
<span class="line-removed"> 712      * OID = 1.2.840.10046.2.1</span>
<span class="line-removed"> 713      */</span>
<span class="line-removed"> 714     public static final ObjectIdentifier DH_PKIX_oid =</span>
<span class="line-removed"> 715             ObjectIdentifier.of(&quot;1.2.840.10046.2.1&quot;);</span>
<span class="line-removed"> 716 </span>
<span class="line-removed"> 717     /**</span>
<span class="line-removed"> 718      * Algorithm ID for the Digital Signing Algorithm (DSA), from the</span>
<span class="line-removed"> 719      * NIST OIW Stable Agreements part 12.</span>
<span class="line-removed"> 720      * Parameters may include public values P, Q, and G; or these may be</span>
<span class="line-removed"> 721      * derived from</span>
<span class="line-removed"> 722      * another source such as a Certificate Authority&#39;s certificate.</span>
<span class="line-removed"> 723      * OID = 1.3.14.3.2.12</span>
<span class="line-removed"> 724      */</span>
<span class="line-removed"> 725     public static final ObjectIdentifier DSA_OIW_oid =</span>
<span class="line-removed"> 726             ObjectIdentifier.of(&quot;1.3.14.3.2.12&quot;);</span>
 727 
<a name="34" id="anc34"></a><span class="line-removed"> 728     /**</span>
<span class="line-removed"> 729      * Algorithm ID for the Digital Signing Algorithm (DSA), from RFC 3279.</span>
<span class="line-removed"> 730      * Parameters may include public values P, Q, and G; or these may be</span>
<span class="line-removed"> 731      * derived from another source such as a Certificate Authority&#39;s</span>
<span class="line-removed"> 732      * certificate.</span>
<span class="line-removed"> 733      * OID = 1.2.840.10040.4.1</span>
<span class="line-removed"> 734      */</span>
 735     public static final ObjectIdentifier DSA_oid =
<a name="35" id="anc35"></a><span class="line-modified"> 736             ObjectIdentifier.of(&quot;1.2.840.10040.4.1&quot;);</span>
<span class="line-removed"> 737 </span>
<span class="line-removed"> 738     /**</span>
<span class="line-removed"> 739      * Algorithm ID for RSA keys used for any purpose, as defined in X.509.</span>
<span class="line-removed"> 740      * The algorithm parameter is a single value, the number of bits in the</span>
<span class="line-removed"> 741      * public modulus.</span>
<span class="line-removed"> 742      * OID = 2.5.8.1.1</span>
<span class="line-removed"> 743      */</span>
<span class="line-removed"> 744     public static final ObjectIdentifier RSA_oid =</span>
<span class="line-removed"> 745             ObjectIdentifier.of(&quot;2.5.8.1.1&quot;);</span>
 746 
 747     public static final ObjectIdentifier EC_oid =
<a name="36" id="anc36"></a><span class="line-modified"> 748             ObjectIdentifier.of(&quot;1.2.840.10045.2.1&quot;);</span>
<span class="line-removed"> 749     public static final ObjectIdentifier ECDH_oid =</span>
<span class="line-removed"> 750             ObjectIdentifier.of(&quot;1.3.132.1.12&quot;);</span>
<span class="line-removed"> 751     public static final ObjectIdentifier RSAEncryption_oid =</span>
<span class="line-removed"> 752             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.1&quot;);</span>
<span class="line-removed"> 753     public static final ObjectIdentifier RSAES_OAEP_oid =</span>
<span class="line-removed"> 754             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.7&quot;);</span>
<span class="line-removed"> 755     public static final ObjectIdentifier mgf1_oid =</span>
<span class="line-removed"> 756             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.8&quot;);</span>
<span class="line-removed"> 757     public static final ObjectIdentifier RSASSA_PSS_oid =</span>
<span class="line-removed"> 758             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.10&quot;);</span>
<span class="line-removed"> 759 </span>
<span class="line-removed"> 760     /*</span>
<span class="line-removed"> 761      * COMMON SECRET KEY TYPES</span>
<span class="line-removed"> 762      */</span>
<span class="line-removed"> 763     public static final ObjectIdentifier AES_oid =</span>
<span class="line-removed"> 764             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.1&quot;);</span>
<span class="line-removed"> 765 </span>
<span class="line-removed"> 766     /*</span>
<span class="line-removed"> 767      * COMMON SIGNATURE ALGORITHMS</span>
<span class="line-removed"> 768      */</span>
<span class="line-removed"> 769     /**</span>
<span class="line-removed"> 770      * Identifies a signing algorithm where an MD2 digest is encrypted</span>
<span class="line-removed"> 771      * using an RSA private key; defined in PKCS #1.  Use of this</span>
<span class="line-removed"> 772      * signing algorithm is discouraged due to MD2 vulnerabilities.</span>
<span class="line-removed"> 773      * OID = 1.2.840.113549.1.1.2</span>
<span class="line-removed"> 774      */</span>
<span class="line-removed"> 775     public static final ObjectIdentifier md2WithRSAEncryption_oid =</span>
<span class="line-removed"> 776         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.2&quot;);</span>
<span class="line-removed"> 777 </span>
<span class="line-removed"> 778     /**</span>
<span class="line-removed"> 779      * Identifies a signing algorithm where an MD5 digest is</span>
<span class="line-removed"> 780      * encrypted using an RSA private key; defined in PKCS #1.</span>
<span class="line-removed"> 781      * OID = 1.2.840.113549.1.1.4</span>
<span class="line-removed"> 782      */</span>
<span class="line-removed"> 783     public static final ObjectIdentifier md5WithRSAEncryption_oid =</span>
<span class="line-removed"> 784         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.4&quot;);</span>
<span class="line-removed"> 785 </span>
<span class="line-removed"> 786     /**</span>
<span class="line-removed"> 787      * Identifies a signing algorithm where a SHA1 digest is</span>
<span class="line-removed"> 788      * encrypted using an RSA private key; defined by RSA DSI.</span>
<span class="line-removed"> 789      * OID = 1.2.840.113549.1.1.5</span>
<span class="line-removed"> 790      */</span>
<span class="line-removed"> 791     public static final ObjectIdentifier sha1WithRSAEncryption_oid =</span>
<span class="line-removed"> 792         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.5&quot;);</span>
 793 
<a name="37" id="anc37"></a><span class="line-modified"> 794     /**</span>
<span class="line-modified"> 795      * Identifies a signing algorithm where a SHA1 digest is</span>
<span class="line-removed"> 796      * encrypted using an RSA private key; defined in NIST OIW.</span>
<span class="line-removed"> 797      * OID = 1.3.14.3.2.29</span>
<span class="line-removed"> 798      */</span>
<span class="line-removed"> 799     public static final ObjectIdentifier sha1WithRSAEncryption_OIW_oid =</span>
<span class="line-removed"> 800         ObjectIdentifier.of(&quot;1.3.14.3.2.29&quot;);</span>
<span class="line-removed"> 801 </span>
<span class="line-removed"> 802     /**</span>
<span class="line-removed"> 803      * Identifies a signing algorithm where a SHA224 digest is</span>
<span class="line-removed"> 804      * encrypted using an RSA private key; defined by PKCS #1.</span>
<span class="line-removed"> 805      * OID = 1.2.840.113549.1.1.14</span>
<span class="line-removed"> 806      */</span>
<span class="line-removed"> 807     public static final ObjectIdentifier sha224WithRSAEncryption_oid =</span>
<span class="line-removed"> 808         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.14&quot;);</span>
<span class="line-removed"> 809 </span>
<span class="line-removed"> 810     /**</span>
<span class="line-removed"> 811      * Identifies a signing algorithm where a SHA256 digest is</span>
<span class="line-removed"> 812      * encrypted using an RSA private key; defined by PKCS #1.</span>
<span class="line-removed"> 813      * OID = 1.2.840.113549.1.1.11</span>
<span class="line-removed"> 814      */</span>
<span class="line-removed"> 815     public static final ObjectIdentifier sha256WithRSAEncryption_oid =</span>
<span class="line-removed"> 816         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.11&quot;);</span>
<span class="line-removed"> 817 </span>
<span class="line-removed"> 818     /**</span>
<span class="line-removed"> 819      * Identifies a signing algorithm where a SHA384 digest is</span>
<span class="line-removed"> 820      * encrypted using an RSA private key; defined by PKCS #1.</span>
<span class="line-removed"> 821      * OID = 1.2.840.113549.1.1.12</span>
<span class="line-removed"> 822      */</span>
<span class="line-removed"> 823     public static final ObjectIdentifier sha384WithRSAEncryption_oid =</span>
<span class="line-removed"> 824         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.12&quot;);</span>
<span class="line-removed"> 825 </span>
<span class="line-removed"> 826     /**</span>
<span class="line-removed"> 827      * Identifies a signing algorithm where a SHA512 digest is</span>
<span class="line-removed"> 828      * encrypted using an RSA private key; defined by PKCS #1.</span>
<span class="line-removed"> 829      * OID = 1.2.840.113549.1.1.13</span>
<span class="line-removed"> 830      */</span>
<span class="line-removed"> 831     public static final ObjectIdentifier sha512WithRSAEncryption_oid =</span>
<span class="line-removed"> 832         ObjectIdentifier.of(&quot;1.2.840.113549.1.1.13&quot;);</span>
<span class="line-removed"> 833 </span>
<span class="line-removed"> 834     /**</span>
<span class="line-removed"> 835      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a</span>
<span class="line-removed"> 836      * SHA digest is signed using the Digital Signing Algorithm (DSA).</span>
<span class="line-removed"> 837      * This should not be used.</span>
<span class="line-removed"> 838      * OID = 1.3.14.3.2.13</span>
<span class="line-removed"> 839      */</span>
<span class="line-removed"> 840     public static final ObjectIdentifier shaWithDSA_OIW_oid =</span>
<span class="line-removed"> 841             ObjectIdentifier.of(&quot;1.3.14.3.2.13&quot;);</span>
 842 
<a name="38" id="anc38"></a><span class="line-modified"> 843     /**</span>
<span class="line-modified"> 844      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a</span>
<span class="line-removed"> 845      * SHA1 digest is signed using the Digital Signing Algorithm (DSA).</span>
<span class="line-removed"> 846      * OID = 1.3.14.3.2.27</span>
<span class="line-removed"> 847      */</span>
<span class="line-removed"> 848     public static final ObjectIdentifier sha1WithDSA_OIW_oid =</span>
<span class="line-removed"> 849             ObjectIdentifier.of(&quot;1.3.14.3.2.27&quot;);</span>
 850 
<a name="39" id="anc39"></a><span class="line-modified"> 851     /**</span>
<span class="line-modified"> 852      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a</span>
<span class="line-removed"> 853      * SHA1 digest is signed using the Digital Signing Algorithm (DSA).</span>
<span class="line-removed"> 854      * OID = 1.2.840.10040.4.3</span>
<span class="line-removed"> 855      */</span>
<span class="line-removed"> 856     public static final ObjectIdentifier sha1WithDSA_oid =</span>
<span class="line-removed"> 857             ObjectIdentifier.of(&quot;1.2.840.10040.4.3&quot;);</span>
<span class="line-removed"> 858 </span>
<span class="line-removed"> 859     public static final ObjectIdentifier sha512_224WithRSAEncryption_oid =</span>
<span class="line-removed"> 860             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.15&quot;);</span>
<span class="line-removed"> 861     public static final ObjectIdentifier sha512_256WithRSAEncryption_oid =</span>
<span class="line-removed"> 862             ObjectIdentifier.of(&quot;1.2.840.113549.1.1.16&quot;);</span>
<span class="line-removed"> 863 </span>
<span class="line-removed"> 864     public static final ObjectIdentifier sha224WithDSA_oid =</span>
<span class="line-removed"> 865             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.3.1&quot;);</span>
<span class="line-removed"> 866     public static final ObjectIdentifier sha256WithDSA_oid =</span>
<span class="line-removed"> 867             ObjectIdentifier.of(&quot;2.16.840.1.101.3.4.3.2&quot;);</span>
<span class="line-removed"> 868 </span>
<span class="line-removed"> 869     public static final ObjectIdentifier sha1WithECDSA_oid =</span>
<span class="line-removed"> 870             ObjectIdentifier.of(&quot;1.2.840.10045.4.1&quot;);</span>
<span class="line-removed"> 871     public static final ObjectIdentifier sha224WithECDSA_oid =</span>
<span class="line-removed"> 872             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.1&quot;);</span>
<span class="line-removed"> 873     public static final ObjectIdentifier sha256WithECDSA_oid =</span>
<span class="line-removed"> 874             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.2&quot;);</span>
<span class="line-removed"> 875     public static final ObjectIdentifier sha384WithECDSA_oid =</span>
<span class="line-removed"> 876             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.3&quot;);</span>
<span class="line-removed"> 877     public static final ObjectIdentifier sha512WithECDSA_oid =</span>
<span class="line-removed"> 878             ObjectIdentifier.of(&quot;1.2.840.10045.4.3.4&quot;);</span>
<span class="line-removed"> 879     public static final ObjectIdentifier specifiedWithECDSA_oid =</span>
<span class="line-removed"> 880             ObjectIdentifier.of(&quot;1.2.840.10045.4.3&quot;);</span>
 881 
<a name="40" id="anc40"></a><span class="line-modified"> 882     /**</span>
<span class="line-modified"> 883      * Algorithm ID for the PBE encryption algorithms from PKCS#5 and</span>
<span class="line-modified"> 884      * PKCS#12.</span>
<span class="line-modified"> 885      */</span>
<span class="line-removed"> 886     public static final ObjectIdentifier pbeWithMD5AndDES_oid =</span>
<span class="line-removed"> 887             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.3&quot;);</span>
<span class="line-removed"> 888     public static final ObjectIdentifier pbeWithMD5AndRC2_oid =</span>
<span class="line-removed"> 889             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.6&quot;);</span>
<span class="line-removed"> 890     public static final ObjectIdentifier pbeWithSHA1AndDES_oid =</span>
<span class="line-removed"> 891             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.10&quot;);</span>
<span class="line-removed"> 892     public static final ObjectIdentifier pbeWithSHA1AndRC2_oid =</span>
<span class="line-removed"> 893             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.11&quot;);</span>
<span class="line-removed"> 894     public static final ObjectIdentifier pbeWithSHA1AndRC4_128_oid =</span>
<span class="line-removed"> 895             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.1&quot;);</span>
<span class="line-removed"> 896     public static final ObjectIdentifier pbeWithSHA1AndRC4_40_oid =</span>
<span class="line-removed"> 897             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.2&quot;);</span>
<span class="line-removed"> 898     public static final ObjectIdentifier pbeWithSHA1AndDESede_oid =</span>
<span class="line-removed"> 899             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.3&quot;);</span>
<span class="line-removed"> 900     public static final ObjectIdentifier pbeWithSHA1AndRC2_128_oid =</span>
<span class="line-removed"> 901             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.5&quot;);</span>
<span class="line-removed"> 902     public static final ObjectIdentifier pbeWithSHA1AndRC2_40_oid =</span>
<span class="line-removed"> 903             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.6&quot;);</span>
<span class="line-removed"> 904 </span>
<span class="line-removed"> 905     static {</span>
<span class="line-removed"> 906         nameTable = new HashMap&lt;&gt;();</span>
<span class="line-removed"> 907         nameTable.put(MD5_oid, &quot;MD5&quot;);</span>
<span class="line-removed"> 908         nameTable.put(MD2_oid, &quot;MD2&quot;);</span>
<span class="line-removed"> 909         nameTable.put(SHA_oid, &quot;SHA-1&quot;);</span>
<span class="line-removed"> 910         nameTable.put(SHA224_oid, &quot;SHA-224&quot;);</span>
<span class="line-removed"> 911         nameTable.put(SHA256_oid, &quot;SHA-256&quot;);</span>
<span class="line-removed"> 912         nameTable.put(SHA384_oid, &quot;SHA-384&quot;);</span>
<span class="line-removed"> 913         nameTable.put(SHA512_oid, &quot;SHA-512&quot;);</span>
<span class="line-removed"> 914         nameTable.put(SHA512_224_oid, &quot;SHA-512/224&quot;);</span>
<span class="line-removed"> 915         nameTable.put(SHA512_256_oid, &quot;SHA-512/256&quot;);</span>
<span class="line-removed"> 916         nameTable.put(RSAEncryption_oid, &quot;RSA&quot;);</span>
<span class="line-removed"> 917         nameTable.put(RSA_oid, &quot;RSA&quot;);</span>
<span class="line-removed"> 918         nameTable.put(DH_oid, &quot;Diffie-Hellman&quot;);</span>
<span class="line-removed"> 919         nameTable.put(DH_PKIX_oid, &quot;Diffie-Hellman&quot;);</span>
<span class="line-removed"> 920         nameTable.put(DSA_oid, &quot;DSA&quot;);</span>
<span class="line-removed"> 921         nameTable.put(DSA_OIW_oid, &quot;DSA&quot;);</span>
<span class="line-removed"> 922         nameTable.put(EC_oid, &quot;EC&quot;);</span>
<span class="line-removed"> 923         nameTable.put(ECDH_oid, &quot;ECDH&quot;);</span>
<span class="line-removed"> 924 </span>
<span class="line-removed"> 925         nameTable.put(AES_oid, &quot;AES&quot;);</span>
<span class="line-removed"> 926 </span>
<span class="line-removed"> 927         nameTable.put(sha1WithECDSA_oid, &quot;SHA1withECDSA&quot;);</span>
<span class="line-removed"> 928         nameTable.put(sha224WithECDSA_oid, &quot;SHA224withECDSA&quot;);</span>
<span class="line-removed"> 929         nameTable.put(sha256WithECDSA_oid, &quot;SHA256withECDSA&quot;);</span>
<span class="line-removed"> 930         nameTable.put(sha384WithECDSA_oid, &quot;SHA384withECDSA&quot;);</span>
<span class="line-removed"> 931         nameTable.put(sha512WithECDSA_oid, &quot;SHA512withECDSA&quot;);</span>
<span class="line-removed"> 932         nameTable.put(md5WithRSAEncryption_oid, &quot;MD5withRSA&quot;);</span>
<span class="line-removed"> 933         nameTable.put(md2WithRSAEncryption_oid, &quot;MD2withRSA&quot;);</span>
<span class="line-removed"> 934         nameTable.put(sha1WithDSA_oid, &quot;SHA1withDSA&quot;);</span>
<span class="line-removed"> 935         nameTable.put(sha1WithDSA_OIW_oid, &quot;SHA1withDSA&quot;);</span>
<span class="line-removed"> 936         nameTable.put(shaWithDSA_OIW_oid, &quot;SHA1withDSA&quot;);</span>
<span class="line-removed"> 937         nameTable.put(sha224WithDSA_oid, &quot;SHA224withDSA&quot;);</span>
<span class="line-removed"> 938         nameTable.put(sha256WithDSA_oid, &quot;SHA256withDSA&quot;);</span>
<span class="line-removed"> 939         nameTable.put(sha1WithRSAEncryption_oid, &quot;SHA1withRSA&quot;);</span>
<span class="line-removed"> 940         nameTable.put(sha1WithRSAEncryption_OIW_oid, &quot;SHA1withRSA&quot;);</span>
<span class="line-removed"> 941         nameTable.put(sha224WithRSAEncryption_oid, &quot;SHA224withRSA&quot;);</span>
<span class="line-removed"> 942         nameTable.put(sha256WithRSAEncryption_oid, &quot;SHA256withRSA&quot;);</span>
<span class="line-removed"> 943         nameTable.put(sha384WithRSAEncryption_oid, &quot;SHA384withRSA&quot;);</span>
<span class="line-removed"> 944         nameTable.put(sha512WithRSAEncryption_oid, &quot;SHA512withRSA&quot;);</span>
<span class="line-removed"> 945         nameTable.put(sha512_224WithRSAEncryption_oid, &quot;SHA512/224withRSA&quot;);</span>
<span class="line-removed"> 946         nameTable.put(sha512_256WithRSAEncryption_oid, &quot;SHA512/256withRSA&quot;);</span>
<span class="line-removed"> 947         nameTable.put(RSASSA_PSS_oid, &quot;RSASSA-PSS&quot;);</span>
<span class="line-removed"> 948         nameTable.put(RSAES_OAEP_oid, &quot;RSAES-OAEP&quot;);</span>
<span class="line-removed"> 949 </span>
<span class="line-removed"> 950         nameTable.put(pbeWithMD5AndDES_oid, &quot;PBEWithMD5AndDES&quot;);</span>
<span class="line-removed"> 951         nameTable.put(pbeWithMD5AndRC2_oid, &quot;PBEWithMD5AndRC2&quot;);</span>
<span class="line-removed"> 952         nameTable.put(pbeWithSHA1AndDES_oid, &quot;PBEWithSHA1AndDES&quot;);</span>
<span class="line-removed"> 953         nameTable.put(pbeWithSHA1AndRC2_oid, &quot;PBEWithSHA1AndRC2&quot;);</span>
<span class="line-removed"> 954         nameTable.put(pbeWithSHA1AndRC4_128_oid, &quot;PBEWithSHA1AndRC4_128&quot;);</span>
<span class="line-removed"> 955         nameTable.put(pbeWithSHA1AndRC4_40_oid, &quot;PBEWithSHA1AndRC4_40&quot;);</span>
<span class="line-removed"> 956         nameTable.put(pbeWithSHA1AndDESede_oid, &quot;PBEWithSHA1AndDESede&quot;);</span>
<span class="line-removed"> 957         nameTable.put(pbeWithSHA1AndRC2_128_oid, &quot;PBEWithSHA1AndRC2_128&quot;);</span>
<span class="line-removed"> 958         nameTable.put(pbeWithSHA1AndRC2_40_oid, &quot;PBEWithSHA1AndRC2_40&quot;);</span>
<span class="line-removed"> 959     }</span>
 960 
 961     /**
 962      * Creates a signature algorithm name from a digest algorithm
 963      * name and a encryption algorithm name.
 964      */
 965     public static String makeSigAlg(String digAlg, String encAlg) {
 966         digAlg = digAlg.replace(&quot;-&quot;, &quot;&quot;);
 967         if (encAlg.equalsIgnoreCase(&quot;EC&quot;)) encAlg = &quot;ECDSA&quot;;
 968 
 969         return digAlg + &quot;with&quot; + encAlg;
 970     }
 971 
 972     /**
 973      * Extracts the encryption algorithm name from a signature
 974      * algorithm name.
 975      */
 976     public static String getEncAlgFromSigAlg(String signatureAlgorithm) {
 977         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
 978         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
 979         String keyAlgorithm = null;
 980         if (with &gt; 0) {
 981             int and = signatureAlgorithm.indexOf(&quot;AND&quot;, with + 4);
 982             if (and &gt; 0) {
 983                 keyAlgorithm = signatureAlgorithm.substring(with + 4, and);
 984             } else {
 985                 keyAlgorithm = signatureAlgorithm.substring(with + 4);
 986             }
 987             if (keyAlgorithm.equalsIgnoreCase(&quot;ECDSA&quot;)) {
 988                 keyAlgorithm = &quot;EC&quot;;
 989             }
 990         }
 991         return keyAlgorithm;
 992     }
 993 
 994     /**
 995      * Extracts the digest algorithm name from a signature
 996      * algorithm name.
 997      */
 998     public static String getDigAlgFromSigAlg(String signatureAlgorithm) {
 999         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
1000         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
1001         if (with &gt; 0) {
1002             return signatureAlgorithm.substring(0, with);
1003         }
1004         return null;
1005     }
1006 
1007     /**
1008      * Checks if a signature algorithm matches a key algorithm, i.e. a
1009      * signature can be initialized with a key.
1010      *
1011      * @param kAlg must not be null
1012      * @param sAlg must not be null
1013      * @throws IllegalArgumentException if they do not match
1014      */
1015     public static void checkKeyAndSigAlgMatch(String kAlg, String sAlg) {
1016         String sAlgUp = sAlg.toUpperCase(Locale.US);
1017         if ((sAlgUp.endsWith(&quot;WITHRSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;RSA&quot;)) ||
1018                 (sAlgUp.endsWith(&quot;WITHECDSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;EC&quot;)) ||
1019                 (sAlgUp.endsWith(&quot;WITHDSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;DSA&quot;))) {
1020             throw new IllegalArgumentException(
1021                     &quot;key algorithm not compatible with signature algorithm&quot;);
1022         }
1023     }
1024 
1025     /**
1026      * Returns the default signature algorithm for a private key. The digest
1027      * part might evolve with time. Remember to update the spec of
1028      * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm(PrivateKey)}
1029      * if updated.
1030      *
1031      * @param k cannot be null
1032      * @return the default alg, might be null if unsupported
1033      */
1034     public static String getDefaultSigAlgForKey(PrivateKey k) {
1035         switch (k.getAlgorithm().toUpperCase(Locale.ENGLISH)) {
1036             case &quot;EC&quot;:
1037                 return ecStrength(KeyUtil.getKeySize(k))
1038                     + &quot;withECDSA&quot;;
1039             case &quot;DSA&quot;:
1040                 return ifcFfcStrength(KeyUtil.getKeySize(k))
1041                     + &quot;withDSA&quot;;
1042             case &quot;RSA&quot;:
1043                 return ifcFfcStrength(KeyUtil.getKeySize(k))
1044                     + &quot;withRSA&quot;;
1045             case &quot;RSASSA-PSS&quot;:
1046                 return &quot;RSASSA-PSS&quot;;
<a name="41" id="anc41"></a>

1047             default:
1048                 return null;
1049         }
1050     }
1051 
1052     // Most commonly used PSSParameterSpec and AlgorithmId
1053     private static class PSSParamsHolder {
1054 
1055         final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(
1056                 &quot;SHA-256&quot;, &quot;MGF1&quot;,
1057                 new MGF1ParameterSpec(&quot;SHA-256&quot;),
1058                 32, PSSParameterSpec.TRAILER_FIELD_BC);
1059         final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(
1060                 &quot;SHA-384&quot;, &quot;MGF1&quot;,
1061                 new MGF1ParameterSpec(&quot;SHA-384&quot;),
1062                 48, PSSParameterSpec.TRAILER_FIELD_BC);
1063         final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(
1064                 &quot;SHA-512&quot;, &quot;MGF1&quot;,
1065                 new MGF1ParameterSpec(&quot;SHA-512&quot;),
1066                 64, PSSParameterSpec.TRAILER_FIELD_BC);
1067 
1068         final static AlgorithmId PSS_256_ID;
1069         final static AlgorithmId PSS_384_ID;
1070         final static AlgorithmId PSS_512_ID;
1071 
1072         static {
1073             try {
1074                 PSS_256_ID = new AlgorithmId(RSASSA_PSS_oid,
1075                         new DerValue(PSSParameters.getEncoded(PSS_256_SPEC)));
1076                 PSS_384_ID = new AlgorithmId(RSASSA_PSS_oid,
1077                         new DerValue(PSSParameters.getEncoded(PSS_384_SPEC)));
1078                 PSS_512_ID = new AlgorithmId(RSASSA_PSS_oid,
1079                         new DerValue(PSSParameters.getEncoded(PSS_512_SPEC)));
1080             } catch (IOException e) {
1081                 throw new AssertionError(&quot;Should not happen&quot;, e);
1082             }
1083         }
1084     }
1085 
1086     public static AlgorithmId getWithParameterSpec(String algName,
1087             AlgorithmParameterSpec spec) throws NoSuchAlgorithmException {
1088 
1089         if (spec == null) {
1090             return AlgorithmId.get(algName);
1091         } else if (spec == PSSParamsHolder.PSS_256_SPEC) {
1092             return PSSParamsHolder.PSS_256_ID;
1093         } else if (spec == PSSParamsHolder.PSS_384_SPEC) {
1094             return PSSParamsHolder.PSS_384_ID;
1095         } else if (spec == PSSParamsHolder.PSS_512_SPEC) {
1096             return PSSParamsHolder.PSS_512_ID;
<a name="42" id="anc42"></a>

1097         } else {
1098             try {
1099                 AlgorithmParameters result =
1100                         AlgorithmParameters.getInstance(algName);
1101                 result.init(spec);
1102                 return get(result);
1103             } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {
1104                 throw new ProviderException(e);
1105             }
1106         }
1107     }
1108 
1109     public static AlgorithmParameterSpec getDefaultAlgorithmParameterSpec(
1110             String sigAlg, PrivateKey k) {
1111         if (sigAlg.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
1112             if (k instanceof RSAKey) {
1113                 AlgorithmParameterSpec spec = ((RSAKey) k).getParams();
1114                 if (spec instanceof PSSParameterSpec) {
1115                     return spec;
1116                 }
1117             }
1118             switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {
1119                 case &quot;SHA256&quot;:
1120                     return PSSParamsHolder.PSS_256_SPEC;
1121                 case &quot;SHA384&quot;:
1122                     return PSSParamsHolder.PSS_384_SPEC;
1123                 case &quot;SHA512&quot;:
1124                     return PSSParamsHolder.PSS_512_SPEC;
1125                 default:
1126                     throw new AssertionError(&quot;Should not happen&quot;);
1127             }
1128         } else {
1129             return null;
1130         }
1131     }
1132 
<a name="43" id="anc43"></a>







1133     // Values from SP800-57 part 1 rev 4 tables 2 and 3
1134     private static String ecStrength (int bitLength) {
1135         if (bitLength &gt;= 512) { // 256 bits of strength
1136             return &quot;SHA512&quot;;
1137         } else if (bitLength &gt;= 384) {  // 192 bits of strength
1138             return &quot;SHA384&quot;;
1139         } else { // 128 bits of strength and less
1140             return &quot;SHA256&quot;;
1141         }
1142     }
1143 
1144     // Same values for RSA and DSA
1145     private static String ifcFfcStrength (int bitLength) {
1146         if (bitLength &gt; 7680) { // 256 bits
1147             return &quot;SHA512&quot;;
1148         } else if (bitLength &gt; 3072) {  // 192 bits
1149             return &quot;SHA384&quot;;
1150         } else  { // 128 bits and less
1151             return &quot;SHA256&quot;;
1152         }
1153     }
1154 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>
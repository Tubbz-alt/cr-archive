<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/validator/SimpleValidator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.validator;
 27 
 28 import java.io.IOException;
 29 import java.util.*;
 30 
 31 import java.security.*;
 32 import java.security.cert.*;
 33 
 34 import javax.security.auth.x500.X500Principal;
 35 
 36 import sun.security.x509.X509CertImpl;
 37 import sun.security.x509.KeyIdentifier;
 38 import sun.security.x509.NetscapeCertTypeExtension;
 39 import sun.security.util.DerValue;
 40 import sun.security.util.DerInputStream;
 41 import sun.security.util.ObjectIdentifier;
 42 import sun.security.util.KnownOIDs;
 43 
 44 import sun.security.provider.certpath.AlgorithmChecker;
 45 import sun.security.provider.certpath.UntrustedChecker;
 46 
 47 /**
 48  * A simple validator implementation. It is based on code from the JSSE
 49  * X509TrustManagerImpl. This implementation is designed for compatibility with
 50  * deployed certificates and previous J2SE versions. It will never support
 51  * more advanced features and will be deemphasized in favor of the PKIX
 52  * validator going forward.
 53  * &lt;p&gt;
 54  * {@code SimpleValidator} objects are immutable once they have been created.
 55  * Please DO NOT add methods that can change the state of an instance once
 56  * it has been created.
 57  *
 58  * @author Andreas Sterbenz
 59  */
 60 public final class SimpleValidator extends Validator {
 61 
 62     // Constants for the OIDs we need
 63 
 64     static final String OID_BASIC_CONSTRAINTS =
 65             KnownOIDs.BasicConstraints.value();
 66 
 67     static final String OID_NETSCAPE_CERT_TYPE =
 68             KnownOIDs.NETSCAPE_CertType.value();
 69 
 70     static final String OID_KEY_USAGE = KnownOIDs.KeyUsage.value();
 71 
 72     static final String OID_EXTENDED_KEY_USAGE =
 73             KnownOIDs.extendedKeyUsage.value();
 74 
 75     static final String OID_EKU_ANY_USAGE =
 76             KnownOIDs.anyExtendedKeyUsage.value();
 77 
 78     static final ObjectIdentifier OBJID_NETSCAPE_CERT_TYPE =
 79             NetscapeCertTypeExtension.NetscapeCertType_Id;
 80 
 81     private static final String NSCT_SSL_CA =
 82             NetscapeCertTypeExtension.SSL_CA;
 83 
 84     private static final String NSCT_CODE_SIGNING_CA =
 85             NetscapeCertTypeExtension.OBJECT_SIGNING_CA;
 86 
 87     /**
 88      * The trusted certificates as:
 89      * Map (X500Principal)subject of trusted cert -&gt; List of X509Certificate
 90      * The list is used because there may be multiple certificates
 91      * with an identical subject DN.
 92      */
 93     private final Map&lt;X500Principal, List&lt;X509Certificate&gt;&gt;
 94                                             trustedX500Principals;
 95 
 96     /**
 97      * Set of the trusted certificates. Present only for
 98      * getTrustedCertificates().
 99      */
100     private final Collection&lt;X509Certificate&gt; trustedCerts;
101 
102     SimpleValidator(String variant, Collection&lt;X509Certificate&gt; trustedCerts) {
103         super(TYPE_SIMPLE, variant);
104         this.trustedCerts = trustedCerts;
105         trustedX500Principals =
106                         new HashMap&lt;X500Principal, List&lt;X509Certificate&gt;&gt;();
107         for (X509Certificate cert : trustedCerts) {
108             X500Principal principal = cert.getSubjectX500Principal();
109             List&lt;X509Certificate&gt; list = trustedX500Principals.get(principal);
110             if (list == null) {
111                 // this actually should be a set, but duplicate entries
112                 // are not a problem and we can avoid the Set overhead
113                 list = new ArrayList&lt;X509Certificate&gt;(2);
114                 trustedX500Principals.put(principal, list);
115             }
116             list.add(cert);
117         }
118     }
119 
120     public Collection&lt;X509Certificate&gt; getTrustedCertificates() {
121         return trustedCerts;
122     }
123 
124     /**
125      * Perform simple validation of chain. The arguments otherCerts and
126      * parameter are ignored.
127      */
128     @Override
129     X509Certificate[] engineValidate(X509Certificate[] chain,
130             Collection&lt;X509Certificate&gt; otherCerts,
131             List&lt;byte[]&gt; responseList,
132             AlgorithmConstraints constraints,
133             Object parameter) throws CertificateException {
134         if ((chain == null) || (chain.length == 0)) {
135             throw new CertificateException
136                 (&quot;null or zero-length certificate chain&quot;);
137         }
138 
139         // make sure chain includes a trusted cert
140         chain = buildTrustedChain(chain);
141 
142         @SuppressWarnings(&quot;deprecation&quot;)
143         Date date = validationDate;
144         if (date == null) {
145             date = new Date();
146         }
147 
148         // create distrusted certificates checker
149         UntrustedChecker untrustedChecker = new UntrustedChecker();
150 
151         // check if anchor is untrusted
152         X509Certificate anchorCert = chain[chain.length - 1];
153         try {
154             untrustedChecker.check(anchorCert);
155         } catch (CertPathValidatorException cpve) {
156             throw new ValidatorException(
157                 &quot;Untrusted certificate: &quot;+ anchorCert.getSubjectX500Principal(),
158                 ValidatorException.T_UNTRUSTED_CERT, anchorCert, cpve);
159         }
160 
161         // create default algorithm constraints checker
162         TrustAnchor anchor = new TrustAnchor(anchorCert, null);
163         AlgorithmChecker defaultAlgChecker =
164                 new AlgorithmChecker(anchor, variant);
165 
166         // create application level algorithm constraints checker
167         AlgorithmChecker appAlgChecker = null;
168         if (constraints != null) {
169             appAlgChecker = new AlgorithmChecker(anchor, constraints, null,
170                     null, variant);
171         }
172 
173         // verify top down, starting at the certificate issued by
174         // the trust anchor
175         int maxPathLength = chain.length - 1;
176         for (int i = chain.length - 2; i &gt;= 0; i--) {
177             X509Certificate issuerCert = chain[i + 1];
178             X509Certificate cert = chain[i];
179 
180             // check untrusted certificate
181             try {
182                 // Untrusted checker does not care about the unresolved
183                 // critical extensions.
184                 untrustedChecker.check(cert, Collections.&lt;String&gt;emptySet());
185             } catch (CertPathValidatorException cpve) {
186                 throw new ValidatorException(
187                     &quot;Untrusted certificate: &quot; + cert.getSubjectX500Principal(),
188                     ValidatorException.T_UNTRUSTED_CERT, cert, cpve);
189             }
190 
191             // check certificate algorithm
192             try {
193                 // Algorithm checker does not care about the unresolved
194                 // critical extensions.
195                 defaultAlgChecker.check(cert, Collections.&lt;String&gt;emptySet());
196                 if (appAlgChecker != null) {
197                     appAlgChecker.check(cert, Collections.&lt;String&gt;emptySet());
198                 }
199             } catch (CertPathValidatorException cpve) {
200                 throw new ValidatorException
201                         (ValidatorException.T_ALGORITHM_DISABLED, cert, cpve);
202             }
203 
204             // no validity check for code signing certs
205             if ((variant.equals(VAR_CODE_SIGNING) == false)
206                         &amp;&amp; (variant.equals(VAR_JCE_SIGNING) == false)) {
207                 cert.checkValidity(date);
208             }
209 
210             // check name chaining
211             if (cert.getIssuerX500Principal().equals(
212                         issuerCert.getSubjectX500Principal()) == false) {
213                 throw new ValidatorException
214                         (ValidatorException.T_NAME_CHAINING, cert);
215             }
216 
217             // check signature
218             try {
219                 cert.verify(issuerCert.getPublicKey());
220             } catch (GeneralSecurityException e) {
221                 throw new ValidatorException
222                         (ValidatorException.T_SIGNATURE_ERROR, cert, e);
223             }
224 
225             // check extensions for CA certs
226             if (i != 0) {
227                 maxPathLength = checkExtensions(cert, maxPathLength);
228             }
229         }
230 
231         return chain;
232     }
233 
234     private int checkExtensions(X509Certificate cert, int maxPathLen)
235             throws CertificateException {
236         Set&lt;String&gt; critSet = cert.getCriticalExtensionOIDs();
237         if (critSet == null) {
238             critSet = Collections.&lt;String&gt;emptySet();
239         }
240 
241         // Check the basic constraints extension
242         int pathLenConstraint =
243                 checkBasicConstraints(cert, critSet, maxPathLen);
244 
245         // Check the key usage and extended key usage extensions
246         checkKeyUsage(cert, critSet);
247 
248         // check Netscape certificate type extension
249         checkNetscapeCertType(cert, critSet);
250 
251         if (!critSet.isEmpty()) {
252             throw new ValidatorException
253                 (&quot;Certificate contains unknown critical extensions: &quot; + critSet,
254                 ValidatorException.T_CA_EXTENSIONS, cert);
255         }
256 
257         return pathLenConstraint;
258     }
259 
260     private void checkNetscapeCertType(X509Certificate cert,
261             Set&lt;String&gt; critSet) throws CertificateException {
262         if (variant.equals(VAR_GENERIC)) {
263             // nothing
264         } else if (variant.equals(VAR_TLS_CLIENT)
265                 || variant.equals(VAR_TLS_SERVER)) {
266             if (getNetscapeCertTypeBit(cert, NSCT_SSL_CA) == false) {
267                 throw new ValidatorException
268                         (&quot;Invalid Netscape CertType extension for SSL CA &quot;
269                         + &quot;certificate&quot;,
270                         ValidatorException.T_CA_EXTENSIONS, cert);
271             }
272             critSet.remove(OID_NETSCAPE_CERT_TYPE);
273         } else if (variant.equals(VAR_CODE_SIGNING)
274                 || variant.equals(VAR_JCE_SIGNING)) {
275             if (getNetscapeCertTypeBit(cert, NSCT_CODE_SIGNING_CA) == false) {
276                 throw new ValidatorException
277                         (&quot;Invalid Netscape CertType extension for code &quot;
278                         + &quot;signing CA certificate&quot;,
279                         ValidatorException.T_CA_EXTENSIONS, cert);
280             }
281             critSet.remove(OID_NETSCAPE_CERT_TYPE);
282         } else {
283             throw new CertificateException(&quot;Unknown variant &quot; + variant);
284         }
285     }
286 
287     /**
288      * Get the value of the specified bit in the Netscape certificate type
289      * extension. If the extension is not present at all, we return true.
290      */
291     static boolean getNetscapeCertTypeBit(X509Certificate cert, String type) {
292         try {
293             NetscapeCertTypeExtension ext;
294             if (cert instanceof X509CertImpl) {
295                 X509CertImpl certImpl = (X509CertImpl)cert;
296                 ObjectIdentifier oid = OBJID_NETSCAPE_CERT_TYPE;
297                 ext = (NetscapeCertTypeExtension)certImpl.getExtension(oid);
298                 if (ext == null) {
299                     return true;
300                 }
301             } else {
302                 byte[] extVal = cert.getExtensionValue(OID_NETSCAPE_CERT_TYPE);
303                 if (extVal == null) {
304                     return true;
305                 }
306                 DerInputStream in = new DerInputStream(extVal);
307                 byte[] encoded = in.getOctetString();
308                 encoded = new DerValue(encoded).getUnalignedBitString()
309                                                                 .toByteArray();
310                 ext = new NetscapeCertTypeExtension(encoded);
311             }
312             Boolean val = ext.get(type);
313             return val.booleanValue();
314         } catch (IOException e) {
315             return false;
316         }
317     }
318 
319     private int checkBasicConstraints(X509Certificate cert,
320             Set&lt;String&gt; critSet, int maxPathLen) throws CertificateException {
321 
322         critSet.remove(OID_BASIC_CONSTRAINTS);
323         int constraints = cert.getBasicConstraints();
324         // reject, if extension missing or not a CA (constraints == -1)
325         if (constraints &lt; 0) {
326             throw new ValidatorException(&quot;End user tried to act as a CA&quot;,
327                 ValidatorException.T_CA_EXTENSIONS, cert);
328         }
329 
330         // if the certificate is self-issued, ignore the pathLenConstraint
331         // checking.
332         if (!X509CertImpl.isSelfIssued(cert)) {
333             if (maxPathLen &lt;= 0) {
334                 throw new ValidatorException(&quot;Violated path length constraints&quot;,
335                     ValidatorException.T_CA_EXTENSIONS, cert);
336             }
337 
338             maxPathLen--;
339         }
340 
341         if (maxPathLen &gt; constraints) {
342             maxPathLen = constraints;
343         }
344 
345         return maxPathLen;
346     }
347 
348     /*
349      * Verify the key usage and extended key usage for intermediate
350      * certificates.
351      */
352     private void checkKeyUsage(X509Certificate cert, Set&lt;String&gt; critSet)
353             throws CertificateException {
354 
355         critSet.remove(OID_KEY_USAGE);
356         // EKU irrelevant in CA certificates
357         critSet.remove(OID_EXTENDED_KEY_USAGE);
358 
359         // check key usage extension
360         boolean[] keyUsageInfo = cert.getKeyUsage();
361         if (keyUsageInfo != null) {
362             // keyUsageInfo[5] is for keyCertSign.
363             if ((keyUsageInfo.length &lt; 6) || (keyUsageInfo[5] == false)) {
364                 throw new ValidatorException
365                         (&quot;Wrong key usage: expected keyCertSign&quot;,
366                         ValidatorException.T_CA_EXTENSIONS, cert);
367             }
368         }
369     }
370 
371     /**
372      * Build a trusted certificate chain. This method always returns a chain
373      * with a trust anchor as the final cert in the chain. If no trust anchor
374      * could be found, a CertificateException is thrown.
375      */
376     private X509Certificate[] buildTrustedChain(X509Certificate[] chain)
377             throws CertificateException {
378         List&lt;X509Certificate&gt; c = new ArrayList&lt;X509Certificate&gt;(chain.length);
379         // scan chain starting at EE cert
380         // if a trusted certificate is found, append it and return
381         for (int i = 0; i &lt; chain.length; i++) {
382             X509Certificate cert = chain[i];
383             X509Certificate trustedCert = getTrustedCertificate(cert);
384             if (trustedCert != null) {
385                 c.add(trustedCert);
386                 return c.toArray(CHAIN0);
387             }
388             c.add(cert);
389         }
390 
391         // check if we can append a trusted cert
392         X509Certificate cert = chain[chain.length - 1];
393         X500Principal subject = cert.getSubjectX500Principal();
394         X500Principal issuer = cert.getIssuerX500Principal();
395         List&lt;X509Certificate&gt; list = trustedX500Principals.get(issuer);
396         if (list != null) {
397             X509Certificate matchedCert = list.get(0);
398             X509CertImpl certImpl = X509CertImpl.toImpl(cert);
399             KeyIdentifier akid = certImpl.getAuthKeyId();
400             if (akid != null) {
401                 for (X509Certificate sup : list) {
402                     // Look for a best match issuer.
403                     X509CertImpl supCert = X509CertImpl.toImpl(sup);
404                     if (akid.equals(supCert.getSubjectKeyId())) {
405                         matchedCert = sup;
406                         break;
407                     }
408                 }
409             }
410 
411             c.add(matchedCert);
412             return c.toArray(CHAIN0);
413         }
414 
415         // no trusted cert found, error
416         throw new ValidatorException(ValidatorException.T_NO_TRUST_ANCHOR);
417     }
418 
419     /**
420      * Return a trusted certificate that matches the input certificate,
421      * or null if no such certificate can be found. This method also handles
422      * cases where a CA re-issues a trust anchor with the same public key and
423      * same subject and issuer names but a new validity period, etc.
424      */
425     private X509Certificate getTrustedCertificate(X509Certificate cert) {
426         Principal certSubjectName = cert.getSubjectX500Principal();
427         List&lt;X509Certificate&gt; list = trustedX500Principals.get(certSubjectName);
428         if (list == null) {
429             return null;
430         }
431 
432         Principal certIssuerName = cert.getIssuerX500Principal();
433         PublicKey certPublicKey = cert.getPublicKey();
434 
435         for (X509Certificate mycert : list) {
436             if (mycert.equals(cert)) {
437                 return cert;
438             }
439             if (!mycert.getIssuerX500Principal().equals(certIssuerName)) {
440                 continue;
441             }
442             if (!mycert.getPublicKey().equals(certPublicKey)) {
443                 continue;
444             }
445 
446             // All tests pass, this must be the one to use...
447             return mycert;
448         }
449         return null;
450     }
451 
452 }
    </pre>
  </body>
</html>
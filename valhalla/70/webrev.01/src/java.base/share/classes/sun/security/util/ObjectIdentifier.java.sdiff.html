<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/ObjectIdentifier.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NamedCurve.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SecurityProviderConstants.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/ObjectIdentifier.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.*;
 29 import java.math.BigInteger;
 30 import java.util.Arrays;

 31 
 32 /**
 33  * Represent an ISO Object Identifier.
 34  *
 35  * &lt;P&gt;Object Identifiers are arbitrary length hierarchical identifiers.
 36  * The individual components are numbers, and they define paths from the
 37  * root of an ISO-managed identifier space.  You will sometimes see a
 38  * string name used instead of (or in addition to) the numerical id.
 39  * These are synonyms for the numerical IDs, but are not widely used
 40  * since most sites do not know all the requisite strings, while all
 41  * sites can parse the numeric forms.
 42  *
 43  * &lt;P&gt;So for example, JavaSoft has the sole authority to assign the
 44  * meaning to identifiers below the 1.3.6.1.4.1.42.2.17 node in the
 45  * hierarchy, and other organizations can easily acquire the ability
 46  * to assign such unique identifiers.
 47  *
 48  * @author David Brownell
 49  * @author Amit Kapoor
 50  * @author Hemma Prafullchandra
</pre>
<hr />
<pre>
131                 componentLen = comps.length;
132             } else {
133                 components = HugeOidNotSupportedByOldJDK.theOne;
134             }
135             componentsCalculated = true;
136         }
137         os.defaultWriteObject();
138     }
139 
140     static class HugeOidNotSupportedByOldJDK implements Serializable {
141         @java.io.Serial
142         private static final long serialVersionUID = 1L;
143         static HugeOidNotSupportedByOldJDK theOne =
144                 new HugeOidNotSupportedByOldJDK();
145     }
146 
147     /**
148      * Constructs, from a string.  This string should be of the form 1.23.56.
149      * Validity check included.
150      */
<span class="line-modified">151     public ObjectIdentifier(String oid) throws IOException {</span>
152         int ch = &#39;.&#39;;
153         int start = 0;
154         int end = 0;
155 
156         int pos = 0;
157         byte[] tmp = new byte[oid.length()];
158         int first = 0, second;
159         int count = 0;
160 
161         try {
162             String comp = null;
163             do {
164                 int length = 0; // length of one section
165                 end = oid.indexOf(ch,start);
166                 if (end == -1) {
167                     comp = oid.substring(start);
168                     length = oid.length() - start;
169                 } else {
170                     comp = oid.substring(start,end);
171                     length = end - start;
</pre>
<hr />
<pre>
273 
274     private void init(int[] components, int length) {
275         int pos = 0;
276         byte[] tmp = new byte[length*5+1];  // +1 for empty input
277 
278         if (components[1] &lt; Integer.MAX_VALUE - components[0]*40)
279             pos += pack7Oid(components[0]*40+components[1], tmp, pos);
280         else {
281             BigInteger big = BigInteger.valueOf(components[1]);
282             big = big.add(BigInteger.valueOf(components[0]*40));
283             pos += pack7Oid(big, tmp, pos);
284         }
285 
286         for (int i=2; i&lt;length; i++) {
287             pos += pack7Oid(components[i], tmp, pos);
288         }
289         encoding = new byte[pos];
290         System.arraycopy(tmp, 0, encoding, 0, pos);
291     }
292 




293     /**
<span class="line-modified">294      * Returns an ObjectIdentifier instance for the specific string OID.</span>
295      *
<span class="line-modified">296      * Note: Please use legal string OID only.  Otherwise, a RuntimeException</span>
<span class="line-removed">297      * is thrown.</span>
298      */
<span class="line-modified">299     public static ObjectIdentifier of(String oid) {</span>
<span class="line-modified">300         try {</span>
<span class="line-modified">301             return new ObjectIdentifier(oid);</span>
<span class="line-modified">302         } catch (IOException ioe) {</span>
<span class="line-modified">303             throw new RuntimeException(ioe);</span>




















304         }

305     }
306 
307     /*
308      * n.b. the only public interface is DerOutputStream.putOID()
309      */
310     void encode(DerOutputStream out) throws IOException {
311         out.write (DerValue.tag_ObjectId, encoding);
312     }
313 
314     /**
315      * Compares this identifier with another, for equality.
316      *
317      * @return true iff the names are identical.
318      */
319     @Override
320     public boolean equals(Object obj) {
321         if (this == obj) {
322             return true;
323         }
324         if (obj instanceof ObjectIdentifier == false) {
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.*;
 29 import java.math.BigInteger;
 30 import java.util.Arrays;
<span class="line-added"> 31 import java.util.concurrent.ConcurrentHashMap;</span>
 32 
 33 /**
 34  * Represent an ISO Object Identifier.
 35  *
 36  * &lt;P&gt;Object Identifiers are arbitrary length hierarchical identifiers.
 37  * The individual components are numbers, and they define paths from the
 38  * root of an ISO-managed identifier space.  You will sometimes see a
 39  * string name used instead of (or in addition to) the numerical id.
 40  * These are synonyms for the numerical IDs, but are not widely used
 41  * since most sites do not know all the requisite strings, while all
 42  * sites can parse the numeric forms.
 43  *
 44  * &lt;P&gt;So for example, JavaSoft has the sole authority to assign the
 45  * meaning to identifiers below the 1.3.6.1.4.1.42.2.17 node in the
 46  * hierarchy, and other organizations can easily acquire the ability
 47  * to assign such unique identifiers.
 48  *
 49  * @author David Brownell
 50  * @author Amit Kapoor
 51  * @author Hemma Prafullchandra
</pre>
<hr />
<pre>
132                 componentLen = comps.length;
133             } else {
134                 components = HugeOidNotSupportedByOldJDK.theOne;
135             }
136             componentsCalculated = true;
137         }
138         os.defaultWriteObject();
139     }
140 
141     static class HugeOidNotSupportedByOldJDK implements Serializable {
142         @java.io.Serial
143         private static final long serialVersionUID = 1L;
144         static HugeOidNotSupportedByOldJDK theOne =
145                 new HugeOidNotSupportedByOldJDK();
146     }
147 
148     /**
149      * Constructs, from a string.  This string should be of the form 1.23.56.
150      * Validity check included.
151      */
<span class="line-modified">152     private ObjectIdentifier(String oid) throws IOException {</span>
153         int ch = &#39;.&#39;;
154         int start = 0;
155         int end = 0;
156 
157         int pos = 0;
158         byte[] tmp = new byte[oid.length()];
159         int first = 0, second;
160         int count = 0;
161 
162         try {
163             String comp = null;
164             do {
165                 int length = 0; // length of one section
166                 end = oid.indexOf(ch,start);
167                 if (end == -1) {
168                     comp = oid.substring(start);
169                     length = oid.length() - start;
170                 } else {
171                     comp = oid.substring(start,end);
172                     length = end - start;
</pre>
<hr />
<pre>
274 
275     private void init(int[] components, int length) {
276         int pos = 0;
277         byte[] tmp = new byte[length*5+1];  // +1 for empty input
278 
279         if (components[1] &lt; Integer.MAX_VALUE - components[0]*40)
280             pos += pack7Oid(components[0]*40+components[1], tmp, pos);
281         else {
282             BigInteger big = BigInteger.valueOf(components[1]);
283             big = big.add(BigInteger.valueOf(components[0]*40));
284             pos += pack7Oid(big, tmp, pos);
285         }
286 
287         for (int i=2; i&lt;length; i++) {
288             pos += pack7Oid(components[i], tmp, pos);
289         }
290         encoding = new byte[pos];
291         System.arraycopy(tmp, 0, encoding, 0, pos);
292     }
293 
<span class="line-added">294     // oid cache index&#39;ed by the oid string</span>
<span class="line-added">295     private static ConcurrentHashMap&lt;String,ObjectIdentifier&gt; oidTable =</span>
<span class="line-added">296             new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-added">297 </span>
298     /**
<span class="line-modified">299      * Returns an ObjectIdentifier instance for the specific String.</span>
300      *
<span class="line-modified">301      * If the String is not a valid OID string, an IOException is thrown.</span>

302      */
<span class="line-modified">303     public static ObjectIdentifier of(String oidStr) throws IOException {</span>
<span class="line-modified">304         // check cache first</span>
<span class="line-modified">305         ObjectIdentifier oid = oidTable.get(oidStr);</span>
<span class="line-modified">306         if (oid == null) {</span>
<span class="line-modified">307             oid = new ObjectIdentifier(oidStr);</span>
<span class="line-added">308             oidTable.put(oidStr, oid);</span>
<span class="line-added">309         }</span>
<span class="line-added">310         return oid;</span>
<span class="line-added">311     }</span>
<span class="line-added">312 </span>
<span class="line-added">313     /**</span>
<span class="line-added">314      * Returns an ObjectIdentifier instance for the specific KnownOIDs.</span>
<span class="line-added">315      */</span>
<span class="line-added">316     public static ObjectIdentifier of(KnownOIDs o) {</span>
<span class="line-added">317         // check cache first</span>
<span class="line-added">318         String oidStr = o.value();</span>
<span class="line-added">319         ObjectIdentifier oid = oidTable.get(oidStr);</span>
<span class="line-added">320         if (oid == null) {</span>
<span class="line-added">321             try {</span>
<span class="line-added">322                 oid = new ObjectIdentifier(oidStr);</span>
<span class="line-added">323             } catch (IOException ioe) {</span>
<span class="line-added">324                 // should not happen as oid string for KnownOIDs is internal</span>
<span class="line-added">325                 throw new RuntimeException(ioe);</span>
<span class="line-added">326             }</span>
<span class="line-added">327             oidTable.put(oidStr, oid);</span>
328         }
<span class="line-added">329         return oid;</span>
330     }
331 
332     /*
333      * n.b. the only public interface is DerOutputStream.putOID()
334      */
335     void encode(DerOutputStream out) throws IOException {
336         out.write (DerValue.tag_ObjectId, encoding);
337     }
338 
339     /**
340      * Compares this identifier with another, for equality.
341      *
342      * @return true iff the names are identical.
343      */
344     @Override
345     public boolean equals(Object obj) {
346         if (this == obj) {
347             return true;
348         }
349         if (obj instanceof ObjectIdentifier == false) {
</pre>
</td>
</tr>
</table>
<center><a href="NamedCurve.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SecurityProviderConstants.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/tools/keytool/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../timestamp/TSRequest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../util/ConstraintsParameters.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/tools/keytool/Main.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  65 import java.net.URI;
  66 import java.net.URL;
  67 import java.net.URLClassLoader;
  68 import java.security.cert.CertStore;
  69 
  70 import java.security.cert.X509CRL;
  71 import java.security.cert.X509CRLEntry;
  72 import java.security.cert.X509CRLSelector;
  73 import javax.security.auth.x500.X500Principal;
  74 import java.util.Base64;
  75 
  76 import sun.security.pkcs12.PKCS12KeyStore;
  77 import sun.security.util.ECKeySizeParameterSpec;
  78 import sun.security.util.KeyUtil;
  79 import sun.security.util.NamedCurve;
  80 import sun.security.util.ObjectIdentifier;
  81 import sun.security.pkcs10.PKCS10;
  82 import sun.security.pkcs10.PKCS10Attribute;
  83 import sun.security.provider.X509Factory;
  84 import sun.security.provider.certpath.ssl.SSLServerCertStore;

  85 import sun.security.util.Password;
  86 import sun.security.util.SecurityProperties;
  87 import sun.security.util.SecurityProviderConstants;
  88 import sun.security.util.SignatureUtil;
  89 import javax.crypto.KeyGenerator;
  90 import javax.crypto.SecretKey;
  91 import javax.crypto.SecretKeyFactory;
  92 import javax.crypto.spec.PBEKeySpec;
  93 
  94 import sun.security.pkcs.PKCS9Attribute;
  95 import sun.security.tools.KeyStoreUtil;
  96 import sun.security.tools.PathList;
  97 import sun.security.util.DerValue;
  98 import sun.security.util.Pem;
  99 import sun.security.x509.*;
 100 
 101 import static java.security.KeyStore.*;
 102 import java.security.Security;
 103 import static sun.security.tools.keytool.Main.Command.*;
 104 import static sun.security.tools.keytool.Main.Option.*;
</pre>
<hr />
<pre>
1853 
1854     /**
1855      * Creates a new key pair and self-signed certificate.
1856      */
1857     private void doGenKeyPair(String alias, String dname, String keyAlgName,
1858                               int keysize, String groupName, String sigAlgName)
1859         throws Exception
1860     {
1861         if (groupName != null) {
1862             if (keysize != -1) {
1863                 throw new Exception(rb.getString(&quot;groupname.keysize.coexist&quot;));
1864             }
1865         } else {
1866             if (keysize == -1) {
1867                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1868                     keysize = SecurityProviderConstants.DEF_EC_KEY_SIZE;
1869                 } else if (&quot;RSA&quot;.equalsIgnoreCase(keyAlgName)) {
1870                     keysize = SecurityProviderConstants.DEF_RSA_KEY_SIZE;
1871                 } else if (&quot;DSA&quot;.equalsIgnoreCase(keyAlgName)) {
1872                     keysize = SecurityProviderConstants.DEF_DSA_KEY_SIZE;






1873                 }
1874             } else {
1875                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1876                     weakWarnings.add(String.format(
1877                             rb.getString(&quot;deprecate.keysize.for.ec&quot;),
1878                             ecGroupNameForSize(keysize)));
1879                 }
1880             }
1881         }
1882 
1883         if (alias == null) {
1884             alias = keyAlias;
1885         }
1886 
1887         if (keyStore.containsAlias(alias)) {
1888             MessageFormat form = new MessageFormat(rb.getString
1889                 (&quot;Key.pair.not.generated.alias.alias.already.exists&quot;));
1890             Object[] source = {alias};
1891             throw new Exception(form.format(source));
1892         }
</pre>
<hr />
<pre>
4102                                 Integer.valueOf(date.substring(8, 10)));
4103                     } else {
4104                         throw ioe;
4105                     }
4106                 }
4107                 if (time != null) {
4108                     if (time.matches(&quot;\\d\\d:\\d\\d:\\d\\d&quot;)) {
4109                         c.set(Calendar.HOUR_OF_DAY, Integer.valueOf(time.substring(0, 2)));
4110                         c.set(Calendar.MINUTE, Integer.valueOf(time.substring(3, 5)));
4111                         c.set(Calendar.SECOND, Integer.valueOf(time.substring(6, 8)));
4112                         c.set(Calendar.MILLISECOND, 0);
4113                     } else {
4114                         throw ioe;
4115                     }
4116                 }
4117             }
4118         }
4119         return c.getTime();
4120     }
4121 

















4122     /**
4123      * Match a command with a command set. The match can be exact, or
4124      * partial, or case-insensitive.
4125      *
4126      * @param s the command provided by user
4127      * @param list the legal command set. If there is a null, commands after it
4128      *      are regarded experimental, which means they are supported but their
4129      *      existence should not be revealed to user.
4130      * @return the position of a single match, or -1 if none matched
4131      * @throws Exception if s is ambiguous
4132      */
4133     private static int oneOf(String s, String... list) throws Exception {
4134 
4135         // First, if there is an exact match, returns it.
4136         int res = oneOfMatch((a,b) -&gt; a.equals(b), s, list);
4137         if (res &gt;= 0) {
4138             return res;
4139         }
4140 
4141         // Second, if there is one single camelCase or prefix match, returns it.
</pre>
<hr />
<pre>
4239                         &quot;ExtendedKeyUsage&quot;,
4240                         &quot;SubjectAlternativeName&quot;,
4241                         &quot;IssuerAlternativeName&quot;,
4242                         &quot;SubjectInfoAccess&quot;,
4243                         &quot;AuthorityInfoAccess&quot;,
4244                         null,
4245                         &quot;CRLDistributionPoints&quot;,
4246     };
4247 
4248     private ObjectIdentifier findOidForExtName(String type)
4249             throws Exception {
4250         switch (oneOf(type, extSupported)) {
4251             case 0: return PKIXExtensions.BasicConstraints_Id;
4252             case 1: return PKIXExtensions.KeyUsage_Id;
4253             case 2: return PKIXExtensions.ExtendedKeyUsage_Id;
4254             case 3: return PKIXExtensions.SubjectAlternativeName_Id;
4255             case 4: return PKIXExtensions.IssuerAlternativeName_Id;
4256             case 5: return PKIXExtensions.SubjectInfoAccess_Id;
4257             case 6: return PKIXExtensions.AuthInfoAccess_Id;
4258             case 8: return PKIXExtensions.CRLDistributionPoints_Id;
<span class="line-modified">4259             default: return new ObjectIdentifier(type);</span>
4260         }
4261     }
4262 
4263     // Add an extension into a CertificateExtensions, always using OID as key
4264     private static void setExt(CertificateExtensions result, Extension ex)
4265             throws IOException {
4266         result.set(ex.getId(), ex);
4267     }
4268 
4269     /**
4270      * Create X509v3 extensions from a string representation. Note that the
4271      * SubjectKeyIdentifierExtension will always be created non-critical besides
4272      * the extension requested in the &lt;code&gt;extstr&lt;/code&gt; argument.
4273      *
4274      * @param requestedEx the requested extensions, can be null, used for -gencert
4275      * @param existingEx the original extensions, can be null, used for -selfcert
4276      * @param extstrs -ext values, Read keytool doc
4277      * @param pkey the public key for the certificate
4278      * @param akey the public key for the authority (issuer)
4279      * @return the created CertificateExtensions
</pre>
<hr />
<pre>
4451                                     throw new Exception(rb.getString(&quot;Unknown.keyUsage.type.&quot;) + s);
4452                                 }
4453                                 if (p == 9) p = 1;
4454                                 ok[p] = true;
4455                             }
4456                             KeyUsageExtension kue = new KeyUsageExtension(ok);
4457                             // The above KeyUsageExtension constructor does not
4458                             // allow isCritical value, so...
4459                             setExt(result, Extension.newExtension(
4460                                     kue.getExtensionId(),
4461                                     isCritical,
4462                                     kue.getExtensionValue()));
4463                         } else {
4464                             throw new Exception(rb.getString
4465                                     (&quot;Illegal.value.&quot;) + extstr);
4466                         }
4467                         break;
4468                     case 2:     // EKU
4469                         if(value != null) {
4470                             Vector&lt;ObjectIdentifier&gt; v = new Vector&lt;&gt;();









4471                             for (String s: value.split(&quot;,&quot;)) {
<span class="line-modified">4472                                 int p = oneOf(s,</span>
<span class="line-modified">4473                                         &quot;anyExtendedKeyUsage&quot;,</span>
<span class="line-modified">4474                                         &quot;serverAuth&quot;,       //1</span>
<span class="line-modified">4475                                         &quot;clientAuth&quot;,       //2</span>
<span class="line-modified">4476                                         &quot;codeSigning&quot;,      //3</span>
<span class="line-modified">4477                                         &quot;emailProtection&quot;,  //4</span>
<span class="line-modified">4478                                         &quot;&quot;,                 //5</span>
<span class="line-modified">4479                                         &quot;&quot;,                 //6</span>
<span class="line-modified">4480                                         &quot;&quot;,                 //7</span>
<span class="line-modified">4481                                         &quot;timeStamping&quot;,     //8</span>
<span class="line-removed">4482                                         &quot;OCSPSigning&quot;       //9</span>
<span class="line-removed">4483                                        );</span>
<span class="line-removed">4484                                 if (p &lt; 0) {</span>
<span class="line-removed">4485                                     try {</span>
<span class="line-removed">4486                                         v.add(new ObjectIdentifier(s));</span>
<span class="line-removed">4487                                     } catch (Exception e) {</span>
<span class="line-removed">4488                                         throw new Exception(rb.getString(</span>
<span class="line-removed">4489                                                 &quot;Unknown.extendedkeyUsage.type.&quot;) + s);</span>
<span class="line-removed">4490                                     }</span>
<span class="line-removed">4491                                 } else if (p == 0) {</span>
<span class="line-removed">4492                                     v.add(new ObjectIdentifier(&quot;2.5.29.37.0&quot;));</span>
<span class="line-removed">4493                                 } else {</span>
<span class="line-removed">4494                                     v.add(new ObjectIdentifier(&quot;1.3.6.1.5.5.7.3.&quot; + p));</span>
4495                                 }
4496                             }
4497                             setExt(result, new ExtendedKeyUsageExtension(isCritical, v));
4498                         } else {
4499                             throw new Exception(rb.getString
4500                                     (&quot;Illegal.value.&quot;) + extstr);
4501                         }
4502                         break;
4503                     case 3:     // SAN
4504                     case 4:     // IAN
4505                         if(value != null) {
4506                             String[] ps = value.split(&quot;,&quot;);
4507                             GeneralNames gnames = new GeneralNames();
4508                             for(String item: ps) {
4509                                 colonpos = item.indexOf(&#39;:&#39;);
4510                                 if (colonpos &lt; 0) {
4511                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4512                                 }
4513                                 String t = item.substring(0, colonpos);
4514                                 String v = item.substring(colonpos+1);
</pre>
<hr />
<pre>
4529                     case 5:     // SIA, always non-critical
4530                     case 6:     // AIA, always non-critical
4531                         if (isCritical) {
4532                             throw new Exception(rb.getString(
4533                                     &quot;This.extension.cannot.be.marked.as.critical.&quot;) + extstr);
4534                         }
4535                         if(value != null) {
4536                             List&lt;AccessDescription&gt; accessDescriptions =
4537                                     new ArrayList&lt;&gt;();
4538                             String[] ps = value.split(&quot;,&quot;);
4539                             for(String item: ps) {
4540                                 colonpos = item.indexOf(&#39;:&#39;);
4541                                 int colonpos2 = item.indexOf(&#39;:&#39;, colonpos+1);
4542                                 if (colonpos &lt; 0 || colonpos2 &lt; 0) {
4543                                     throw new Exception(rb.getString
4544                                             (&quot;Illegal.value.&quot;) + extstr);
4545                                 }
4546                                 String m = item.substring(0, colonpos);
4547                                 String t = item.substring(colonpos+1, colonpos2);
4548                                 String v = item.substring(colonpos2+1);
<span class="line-modified">4549                                 int p = oneOf(m,</span>
<span class="line-modified">4550                                         &quot;&quot;,</span>
<span class="line-modified">4551                                         &quot;ocsp&quot;,         //1</span>
<span class="line-modified">4552                                         &quot;caIssuers&quot;,    //2</span>
<span class="line-modified">4553                                         &quot;timeStamping&quot;, //3</span>
<span class="line-modified">4554                                         &quot;&quot;,</span>
<span class="line-modified">4555                                         &quot;caRepository&quot;  //5</span>
<span class="line-removed">4556                                         );</span>
4557                                 ObjectIdentifier oid;
<span class="line-modified">4558                                 if (p &lt; 0) {</span>


4559                                     try {
<span class="line-modified">4560                                         oid = new ObjectIdentifier(m);</span>
4561                                     } catch (Exception e) {
4562                                         throw new Exception(rb.getString(
4563                                                 &quot;Unknown.AccessDescription.type.&quot;) + m);
4564                                     }
<span class="line-removed">4565                                 } else {</span>
<span class="line-removed">4566                                     oid = new ObjectIdentifier(&quot;1.3.6.1.5.5.7.48.&quot; + p);</span>
4567                                 }
4568                                 accessDescriptions.add(new AccessDescription(
4569                                         oid, createGeneralName(t, v, exttype)));
4570                             }
4571                             if (exttype == 5) {
4572                                 setExt(result, new SubjectInfoAccessExtension(accessDescriptions));
4573                             } else {
4574                                 setExt(result, new AuthorityInfoAccessExtension(accessDescriptions));
4575                             }
4576                         } else {
4577                             throw new Exception(rb.getString
4578                                     (&quot;Illegal.value.&quot;) + extstr);
4579                         }
4580                         break;
4581                     case 8: // CRL, experimental, only support 1 distributionpoint
4582                         if(value != null) {
4583                             String[] ps = value.split(&quot;,&quot;);
4584                             GeneralNames gnames = new GeneralNames();
4585                             for(String item: ps) {
4586                                 colonpos = item.indexOf(&#39;:&#39;);
4587                                 if (colonpos &lt; 0) {
4588                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4589                                 }
4590                                 String t = item.substring(0, colonpos);
4591                                 String v = item.substring(colonpos+1);
4592                                 gnames.add(createGeneralName(t, v, exttype));
4593                             }
4594                             setExt(result, new CRLDistributionPointsExtension(
4595                                     isCritical, Collections.singletonList(
4596                                     new DistributionPoint(gnames, null, null))));
4597                         } else {
4598                             throw new Exception(rb.getString
4599                                     (&quot;Illegal.value.&quot;) + extstr);
4600                         }
4601                         break;
4602                     case -1:
<span class="line-modified">4603                         ObjectIdentifier oid = new ObjectIdentifier(name);</span>
4604                         byte[] data = null;
4605                         if (value != null) {
4606                             data = new byte[value.length() / 2 + 1];
4607                             int pos = 0;
4608                             for (char c: value.toCharArray()) {
4609                                 int hex;
4610                                 if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
4611                                     hex = c - &#39;0&#39; ;
4612                                 } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
4613                                     hex = c - &#39;A&#39; + 10;
4614                                 } else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
4615                                     hex = c - &#39;a&#39; + 10;
4616                                 } else {
4617                                     continue;
4618                                 }
4619                                 if (pos % 2 == 0) {
4620                                     data[pos/2] = (byte)(hex &lt;&lt; 4);
4621                                 } else {
4622                                     data[pos/2] += hex;
4623                                 }
</pre>
</td>
<td>
<hr />
<pre>
  65 import java.net.URI;
  66 import java.net.URL;
  67 import java.net.URLClassLoader;
  68 import java.security.cert.CertStore;
  69 
  70 import java.security.cert.X509CRL;
  71 import java.security.cert.X509CRLEntry;
  72 import java.security.cert.X509CRLSelector;
  73 import javax.security.auth.x500.X500Principal;
  74 import java.util.Base64;
  75 
  76 import sun.security.pkcs12.PKCS12KeyStore;
  77 import sun.security.util.ECKeySizeParameterSpec;
  78 import sun.security.util.KeyUtil;
  79 import sun.security.util.NamedCurve;
  80 import sun.security.util.ObjectIdentifier;
  81 import sun.security.pkcs10.PKCS10;
  82 import sun.security.pkcs10.PKCS10Attribute;
  83 import sun.security.provider.X509Factory;
  84 import sun.security.provider.certpath.ssl.SSLServerCertStore;
<span class="line-added">  85 import sun.security.util.KnownOIDs;</span>
  86 import sun.security.util.Password;
  87 import sun.security.util.SecurityProperties;
  88 import sun.security.util.SecurityProviderConstants;
  89 import sun.security.util.SignatureUtil;
  90 import javax.crypto.KeyGenerator;
  91 import javax.crypto.SecretKey;
  92 import javax.crypto.SecretKeyFactory;
  93 import javax.crypto.spec.PBEKeySpec;
  94 
  95 import sun.security.pkcs.PKCS9Attribute;
  96 import sun.security.tools.KeyStoreUtil;
  97 import sun.security.tools.PathList;
  98 import sun.security.util.DerValue;
  99 import sun.security.util.Pem;
 100 import sun.security.x509.*;
 101 
 102 import static java.security.KeyStore.*;
 103 import java.security.Security;
 104 import static sun.security.tools.keytool.Main.Command.*;
 105 import static sun.security.tools.keytool.Main.Option.*;
</pre>
<hr />
<pre>
1854 
1855     /**
1856      * Creates a new key pair and self-signed certificate.
1857      */
1858     private void doGenKeyPair(String alias, String dname, String keyAlgName,
1859                               int keysize, String groupName, String sigAlgName)
1860         throws Exception
1861     {
1862         if (groupName != null) {
1863             if (keysize != -1) {
1864                 throw new Exception(rb.getString(&quot;groupname.keysize.coexist&quot;));
1865             }
1866         } else {
1867             if (keysize == -1) {
1868                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1869                     keysize = SecurityProviderConstants.DEF_EC_KEY_SIZE;
1870                 } else if (&quot;RSA&quot;.equalsIgnoreCase(keyAlgName)) {
1871                     keysize = SecurityProviderConstants.DEF_RSA_KEY_SIZE;
1872                 } else if (&quot;DSA&quot;.equalsIgnoreCase(keyAlgName)) {
1873                     keysize = SecurityProviderConstants.DEF_DSA_KEY_SIZE;
<span class="line-added">1874                 } else if (&quot;EdDSA&quot;.equalsIgnoreCase(keyAlgName)) {</span>
<span class="line-added">1875                     keysize = SecurityProviderConstants.DEF_ED_KEY_SIZE;</span>
<span class="line-added">1876                 } else if (&quot;Ed25519&quot;.equalsIgnoreCase(keyAlgName)) {</span>
<span class="line-added">1877                     keysize = 255;</span>
<span class="line-added">1878                 } else if (&quot;Ed448&quot;.equalsIgnoreCase(keyAlgName)) {</span>
<span class="line-added">1879                     keysize = 448;</span>
1880                 }
1881             } else {
1882                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1883                     weakWarnings.add(String.format(
1884                             rb.getString(&quot;deprecate.keysize.for.ec&quot;),
1885                             ecGroupNameForSize(keysize)));
1886                 }
1887             }
1888         }
1889 
1890         if (alias == null) {
1891             alias = keyAlias;
1892         }
1893 
1894         if (keyStore.containsAlias(alias)) {
1895             MessageFormat form = new MessageFormat(rb.getString
1896                 (&quot;Key.pair.not.generated.alias.alias.already.exists&quot;));
1897             Object[] source = {alias};
1898             throw new Exception(form.format(source));
1899         }
</pre>
<hr />
<pre>
4109                                 Integer.valueOf(date.substring(8, 10)));
4110                     } else {
4111                         throw ioe;
4112                     }
4113                 }
4114                 if (time != null) {
4115                     if (time.matches(&quot;\\d\\d:\\d\\d:\\d\\d&quot;)) {
4116                         c.set(Calendar.HOUR_OF_DAY, Integer.valueOf(time.substring(0, 2)));
4117                         c.set(Calendar.MINUTE, Integer.valueOf(time.substring(3, 5)));
4118                         c.set(Calendar.SECOND, Integer.valueOf(time.substring(6, 8)));
4119                         c.set(Calendar.MILLISECOND, 0);
4120                     } else {
4121                         throw ioe;
4122                     }
4123                 }
4124             }
4125         }
4126         return c.getTime();
4127     }
4128 
<span class="line-added">4129     /**</span>
<span class="line-added">4130      * Match a command with a command set. The match can be exact, or</span>
<span class="line-added">4131      * partial, or case-insensitive.</span>
<span class="line-added">4132      *</span>
<span class="line-added">4133      * @param s the command provided by user</span>
<span class="line-added">4134      * @param list the legal command set represented by KnownOIDs enums.</span>
<span class="line-added">4135      * @return the position of a single match, or -1 if none matched</span>
<span class="line-added">4136      * @throws Exception if s is ambiguous</span>
<span class="line-added">4137      */</span>
<span class="line-added">4138     private static int oneOf(String s, KnownOIDs... list) throws Exception {</span>
<span class="line-added">4139         String[] convertedList = new String[list.length];</span>
<span class="line-added">4140         for (int i = 0; i &lt; list.length; i++) {</span>
<span class="line-added">4141             convertedList[i] = list[i].stdName();</span>
<span class="line-added">4142         }</span>
<span class="line-added">4143         return oneOf(s, convertedList);</span>
<span class="line-added">4144     }</span>
<span class="line-added">4145 </span>
4146     /**
4147      * Match a command with a command set. The match can be exact, or
4148      * partial, or case-insensitive.
4149      *
4150      * @param s the command provided by user
4151      * @param list the legal command set. If there is a null, commands after it
4152      *      are regarded experimental, which means they are supported but their
4153      *      existence should not be revealed to user.
4154      * @return the position of a single match, or -1 if none matched
4155      * @throws Exception if s is ambiguous
4156      */
4157     private static int oneOf(String s, String... list) throws Exception {
4158 
4159         // First, if there is an exact match, returns it.
4160         int res = oneOfMatch((a,b) -&gt; a.equals(b), s, list);
4161         if (res &gt;= 0) {
4162             return res;
4163         }
4164 
4165         // Second, if there is one single camelCase or prefix match, returns it.
</pre>
<hr />
<pre>
4263                         &quot;ExtendedKeyUsage&quot;,
4264                         &quot;SubjectAlternativeName&quot;,
4265                         &quot;IssuerAlternativeName&quot;,
4266                         &quot;SubjectInfoAccess&quot;,
4267                         &quot;AuthorityInfoAccess&quot;,
4268                         null,
4269                         &quot;CRLDistributionPoints&quot;,
4270     };
4271 
4272     private ObjectIdentifier findOidForExtName(String type)
4273             throws Exception {
4274         switch (oneOf(type, extSupported)) {
4275             case 0: return PKIXExtensions.BasicConstraints_Id;
4276             case 1: return PKIXExtensions.KeyUsage_Id;
4277             case 2: return PKIXExtensions.ExtendedKeyUsage_Id;
4278             case 3: return PKIXExtensions.SubjectAlternativeName_Id;
4279             case 4: return PKIXExtensions.IssuerAlternativeName_Id;
4280             case 5: return PKIXExtensions.SubjectInfoAccess_Id;
4281             case 6: return PKIXExtensions.AuthInfoAccess_Id;
4282             case 8: return PKIXExtensions.CRLDistributionPoints_Id;
<span class="line-modified">4283             default: return ObjectIdentifier.of(type);</span>
4284         }
4285     }
4286 
4287     // Add an extension into a CertificateExtensions, always using OID as key
4288     private static void setExt(CertificateExtensions result, Extension ex)
4289             throws IOException {
4290         result.set(ex.getId(), ex);
4291     }
4292 
4293     /**
4294      * Create X509v3 extensions from a string representation. Note that the
4295      * SubjectKeyIdentifierExtension will always be created non-critical besides
4296      * the extension requested in the &lt;code&gt;extstr&lt;/code&gt; argument.
4297      *
4298      * @param requestedEx the requested extensions, can be null, used for -gencert
4299      * @param existingEx the original extensions, can be null, used for -selfcert
4300      * @param extstrs -ext values, Read keytool doc
4301      * @param pkey the public key for the certificate
4302      * @param akey the public key for the authority (issuer)
4303      * @return the created CertificateExtensions
</pre>
<hr />
<pre>
4475                                     throw new Exception(rb.getString(&quot;Unknown.keyUsage.type.&quot;) + s);
4476                                 }
4477                                 if (p == 9) p = 1;
4478                                 ok[p] = true;
4479                             }
4480                             KeyUsageExtension kue = new KeyUsageExtension(ok);
4481                             // The above KeyUsageExtension constructor does not
4482                             // allow isCritical value, so...
4483                             setExt(result, Extension.newExtension(
4484                                     kue.getExtensionId(),
4485                                     isCritical,
4486                                     kue.getExtensionValue()));
4487                         } else {
4488                             throw new Exception(rb.getString
4489                                     (&quot;Illegal.value.&quot;) + extstr);
4490                         }
4491                         break;
4492                     case 2:     // EKU
4493                         if(value != null) {
4494                             Vector&lt;ObjectIdentifier&gt; v = new Vector&lt;&gt;();
<span class="line-added">4495                             KnownOIDs[] choices = {</span>
<span class="line-added">4496                                     KnownOIDs.anyExtendedKeyUsage,</span>
<span class="line-added">4497                                     KnownOIDs.serverAuth,</span>
<span class="line-added">4498                                     KnownOIDs.clientAuth,</span>
<span class="line-added">4499                                     KnownOIDs.codeSigning,</span>
<span class="line-added">4500                                     KnownOIDs.emailProtection,</span>
<span class="line-added">4501                                     KnownOIDs.KP_TimeStamping,</span>
<span class="line-added">4502                                     KnownOIDs.OCSPSigning</span>
<span class="line-added">4503                             };</span>
4504                             for (String s: value.split(&quot;,&quot;)) {
<span class="line-modified">4505                                 int p = oneOf(s, choices);</span>
<span class="line-modified">4506                                 String o = s;</span>
<span class="line-modified">4507                                 if (p &gt;= 0) {</span>
<span class="line-modified">4508                                     o = choices[p].value();</span>
<span class="line-modified">4509                                 }</span>
<span class="line-modified">4510                                 try {</span>
<span class="line-modified">4511                                     v.add(ObjectIdentifier.of(o));</span>
<span class="line-modified">4512                                 } catch (Exception e) {</span>
<span class="line-modified">4513                                     throw new Exception(rb.getString(</span>
<span class="line-modified">4514                                             &quot;Unknown.extendedkeyUsage.type.&quot;) + s);</span>













4515                                 }
4516                             }
4517                             setExt(result, new ExtendedKeyUsageExtension(isCritical, v));
4518                         } else {
4519                             throw new Exception(rb.getString
4520                                     (&quot;Illegal.value.&quot;) + extstr);
4521                         }
4522                         break;
4523                     case 3:     // SAN
4524                     case 4:     // IAN
4525                         if(value != null) {
4526                             String[] ps = value.split(&quot;,&quot;);
4527                             GeneralNames gnames = new GeneralNames();
4528                             for(String item: ps) {
4529                                 colonpos = item.indexOf(&#39;:&#39;);
4530                                 if (colonpos &lt; 0) {
4531                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4532                                 }
4533                                 String t = item.substring(0, colonpos);
4534                                 String v = item.substring(colonpos+1);
</pre>
<hr />
<pre>
4549                     case 5:     // SIA, always non-critical
4550                     case 6:     // AIA, always non-critical
4551                         if (isCritical) {
4552                             throw new Exception(rb.getString(
4553                                     &quot;This.extension.cannot.be.marked.as.critical.&quot;) + extstr);
4554                         }
4555                         if(value != null) {
4556                             List&lt;AccessDescription&gt; accessDescriptions =
4557                                     new ArrayList&lt;&gt;();
4558                             String[] ps = value.split(&quot;,&quot;);
4559                             for(String item: ps) {
4560                                 colonpos = item.indexOf(&#39;:&#39;);
4561                                 int colonpos2 = item.indexOf(&#39;:&#39;, colonpos+1);
4562                                 if (colonpos &lt; 0 || colonpos2 &lt; 0) {
4563                                     throw new Exception(rb.getString
4564                                             (&quot;Illegal.value.&quot;) + extstr);
4565                                 }
4566                                 String m = item.substring(0, colonpos);
4567                                 String t = item.substring(colonpos+1, colonpos2);
4568                                 String v = item.substring(colonpos2+1);
<span class="line-modified">4569                                 KnownOIDs[] choices = {</span>
<span class="line-modified">4570                                     KnownOIDs.OCSP,</span>
<span class="line-modified">4571                                     KnownOIDs.caIssuers,</span>
<span class="line-modified">4572                                     KnownOIDs.AD_TimeStamping,</span>
<span class="line-modified">4573                                     KnownOIDs.caRepository</span>
<span class="line-modified">4574                                 };</span>
<span class="line-modified">4575                                 int p = oneOf(m, choices);</span>

4576                                 ObjectIdentifier oid;
<span class="line-modified">4577                                 if (p &gt;= 0) {</span>
<span class="line-added">4578                                     oid = ObjectIdentifier.of(choices[p]);</span>
<span class="line-added">4579                                 } else {</span>
4580                                     try {
<span class="line-modified">4581                                         oid = ObjectIdentifier.of(m);</span>
4582                                     } catch (Exception e) {
4583                                         throw new Exception(rb.getString(
4584                                                 &quot;Unknown.AccessDescription.type.&quot;) + m);
4585                                     }


4586                                 }
4587                                 accessDescriptions.add(new AccessDescription(
4588                                         oid, createGeneralName(t, v, exttype)));
4589                             }
4590                             if (exttype == 5) {
4591                                 setExt(result, new SubjectInfoAccessExtension(accessDescriptions));
4592                             } else {
4593                                 setExt(result, new AuthorityInfoAccessExtension(accessDescriptions));
4594                             }
4595                         } else {
4596                             throw new Exception(rb.getString
4597                                     (&quot;Illegal.value.&quot;) + extstr);
4598                         }
4599                         break;
4600                     case 8: // CRL, experimental, only support 1 distributionpoint
4601                         if(value != null) {
4602                             String[] ps = value.split(&quot;,&quot;);
4603                             GeneralNames gnames = new GeneralNames();
4604                             for(String item: ps) {
4605                                 colonpos = item.indexOf(&#39;:&#39;);
4606                                 if (colonpos &lt; 0) {
4607                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4608                                 }
4609                                 String t = item.substring(0, colonpos);
4610                                 String v = item.substring(colonpos+1);
4611                                 gnames.add(createGeneralName(t, v, exttype));
4612                             }
4613                             setExt(result, new CRLDistributionPointsExtension(
4614                                     isCritical, Collections.singletonList(
4615                                     new DistributionPoint(gnames, null, null))));
4616                         } else {
4617                             throw new Exception(rb.getString
4618                                     (&quot;Illegal.value.&quot;) + extstr);
4619                         }
4620                         break;
4621                     case -1:
<span class="line-modified">4622                         ObjectIdentifier oid = ObjectIdentifier.of(name);</span>
4623                         byte[] data = null;
4624                         if (value != null) {
4625                             data = new byte[value.length() / 2 + 1];
4626                             int pos = 0;
4627                             for (char c: value.toCharArray()) {
4628                                 int hex;
4629                                 if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
4630                                     hex = c - &#39;0&#39; ;
4631                                 } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
4632                                     hex = c - &#39;A&#39; + 10;
4633                                 } else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
4634                                     hex = c - &#39;a&#39; + 10;
4635                                 } else {
4636                                     continue;
4637                                 }
4638                                 if (pos % 2 == 0) {
4639                                     data[pos/2] = (byte)(hex &lt;&lt; 4);
4640                                 } else {
4641                                     data[pos/2] += hex;
4642                                 }
</pre>
</td>
</tr>
</table>
<center><a href="../../timestamp/TSRequest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../util/ConstraintsParameters.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
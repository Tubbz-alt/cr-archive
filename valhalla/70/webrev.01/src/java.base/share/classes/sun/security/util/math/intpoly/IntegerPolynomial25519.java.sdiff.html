<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial25519.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntegerPolynomial1305.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerPolynomial448.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/math/intpoly/IntegerPolynomial25519.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 
 35 public class IntegerPolynomial25519 extends IntegerPolynomial {
 36 
 37     private static final int POWER = 255;
 38     private static final int SUBTRAHEND = 19;
 39     private static final int NUM_LIMBS = 10;
 40     private static final int BITS_PER_LIMB = 26;
 41     public static final BigInteger MODULUS
 42         = TWO.pow(POWER).subtract(BigInteger.valueOf(SUBTRAHEND));
 43 
 44     // BITS_PER_LIMB does not divide POWER, so reduction is a bit complicated
 45     // The constants below help split up values during reduction
 46     private static final int BIT_OFFSET = NUM_LIMBS * BITS_PER_LIMB - POWER;
 47     private static final int LIMB_MASK = -1 &gt;&gt;&gt; (64 - BITS_PER_LIMB);
 48     private static final int RIGHT_BIT_OFFSET = BITS_PER_LIMB - BIT_OFFSET;
 49 
 50     public IntegerPolynomial25519() {
 51         super(BITS_PER_LIMB, NUM_LIMBS, 1, MODULUS);
 52     }
 53 







 54     @Override
 55     protected void finalCarryReduceLast(long[] limbs) {
 56 
 57         long reducedValue = limbs[numLimbs - 1] &gt;&gt; RIGHT_BIT_OFFSET;
 58         limbs[numLimbs - 1] -= reducedValue &lt;&lt; RIGHT_BIT_OFFSET;
 59         limbs[0] += reducedValue * SUBTRAHEND;
 60     }
 61 
 62     @Override
 63     protected void reduce(long[] a) {
 64 
 65         // carry(8, 2)
 66         long carry8 = carryValue(a[8]);
 67         a[8] -= (carry8 &lt;&lt; BITS_PER_LIMB);
 68         a[9] += carry8;
 69 
 70         long carry9 = carryValue(a[9]);
 71         a[9] -= (carry9 &lt;&lt; BITS_PER_LIMB);
 72 
 73         // reduce(0, 1)
 74         long reducedValue10 = (carry9 * SUBTRAHEND);
 75         a[0] += ((reducedValue10 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
 76         a[1] += reducedValue10 &gt;&gt; RIGHT_BIT_OFFSET;
 77 
 78         // carry(0, 9)
 79         carry(a, 0, 9);
 80     }
 81 
 82     @Override
 83     protected void mult(long[] a, long[] b, long[] r) {
<span class="line-removed"> 84 </span>
<span class="line-removed"> 85         // Use grade-school multiplication into primitives to avoid the</span>
<span class="line-removed"> 86         // temporary array allocation. This is equivalent to the following</span>
<span class="line-removed"> 87         // code:</span>
<span class="line-removed"> 88         //  long[] c = new long[2 * NUM_LIMBS - 1];</span>
<span class="line-removed"> 89         //  for(int i = 0; i &lt; NUM_LIMBS; i++) {</span>
<span class="line-removed"> 90         //      for(int j - 0; j &lt; NUM_LIMBS; j++) {</span>
<span class="line-removed"> 91         //          c[i + j] += a[i] * b[j]</span>
<span class="line-removed"> 92         //      }</span>
<span class="line-removed"> 93         //  }</span>
<span class="line-removed"> 94 </span>
 95         long c0 = (a[0] * b[0]);
 96         long c1 = (a[0] * b[1]) + (a[1] * b[0]);
 97         long c2 = (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]);
 98         long c3 = (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]);
 99         long c4 = (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]);
100         long c5 = (a[0] * b[5]) + (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]) + (a[5] * b[0]);
101         long c6 = (a[0] * b[6]) + (a[1] * b[5]) + (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]) + (a[5] * b[1]) + (a[6] * b[0]);
102         long c7 = (a[0] * b[7]) + (a[1] * b[6]) + (a[2] * b[5]) + (a[3] * b[4]) + (a[4] * b[3]) + (a[5] * b[2]) + (a[6] * b[1]) + (a[7] * b[0]);
103         long c8 = (a[0] * b[8]) + (a[1] * b[7]) + (a[2] * b[6]) + (a[3] * b[5]) + (a[4] * b[4]) + (a[5] * b[3]) + (a[6] * b[2]) + (a[7] * b[1]) + (a[8] * b[0]);
104         long c9 = (a[0] * b[9]) + (a[1] * b[8]) + (a[2] * b[7]) + (a[3] * b[6]) + (a[4] * b[5]) + (a[5] * b[4]) + (a[6] * b[3]) + (a[7] * b[2]) + (a[8] * b[1]) + (a[9] * b[0]);
105         long c10 = (a[1] * b[9]) + (a[2] * b[8]) + (a[3] * b[7]) + (a[4] * b[6]) + (a[5] * b[5]) + (a[6] * b[4]) + (a[7] * b[3]) + (a[8] * b[2]) + (a[9] * b[1]);
106         long c11 = (a[2] * b[9]) + (a[3] * b[8]) + (a[4] * b[7]) + (a[5] * b[6]) + (a[6] * b[5]) + (a[7] * b[4]) + (a[8] * b[3]) + (a[9] * b[2]);
107         long c12 = (a[3] * b[9]) + (a[4] * b[8]) + (a[5] * b[7]) + (a[6] * b[6]) + (a[7] * b[5]) + (a[8] * b[4]) + (a[9] * b[3]);
108         long c13 = (a[4] * b[9]) + (a[5] * b[8]) + (a[6] * b[7]) + (a[7] * b[6]) + (a[8] * b[5]) + (a[9] * b[4]);
109         long c14 = (a[5] * b[9]) + (a[6] * b[8]) + (a[7] * b[7]) + (a[8] * b[6]) + (a[9] * b[5]);
110         long c15 = (a[6] * b[9]) + (a[7] * b[8]) + (a[8] * b[7]) + (a[9] * b[6]);
111         long c16 = (a[7] * b[9]) + (a[8] * b[8]) + (a[9] * b[7]);
112         long c17 = (a[8] * b[9]) + (a[9] * b[8]);
113         long c18 = a[9] * b[9];
114 
</pre>
<hr />
<pre>
155 
156         long reducedValue13 = (c13 * SUBTRAHEND);
157         r[3] = c3 + ((reducedValue13 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
158         c4 += reducedValue13 &gt;&gt; RIGHT_BIT_OFFSET;
159 
160         long reducedValue14 = (c14 * SUBTRAHEND);
161         r[4] = c4 + ((reducedValue14 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
162         c5 += reducedValue14 &gt;&gt; RIGHT_BIT_OFFSET;
163 
164         long reducedValue15 = (c15 * SUBTRAHEND);
165         r[5] = c5 + ((reducedValue15 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
166         c6 += reducedValue15 &gt;&gt; RIGHT_BIT_OFFSET;
167 
168         long reducedValue16 = (c16 * SUBTRAHEND);
169         r[6] = c6 + ((reducedValue16 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
170         r[7] = c7 + (reducedValue16 &gt;&gt; RIGHT_BIT_OFFSET);
171 
172         // carry(0,9)
173         carry(r, 0, 9);
174     }
<span class="line-removed">175 </span>
176     @Override
177     protected void square(long[] a, long[] r) {
178 
179         // Use grade-school multiplication with a simple squaring optimization.
180         // Multiply into primitives to avoid the temporary array allocation.
181         // This is equivalent to the following code:
182         //  long[] c = new long[2 * NUM_LIMBS - 1];
183         //  for(int i = 0; i &lt; NUM_LIMBS; i++) {
184         //      c[2 * i] = a[i] * a[i];
185         //      for(int j = i + 1; j &lt; NUM_LIMBS; j++) {
186         //          c[i + j] += 2 * a[i] * a[j]
187         //      }
188         //  }
189 
190         long c0 = a[0] * a[0];
191         long c1 = 2 * a[0] * a[1];
192         long c2 = a[1] * a[1] + 2 * a[0] * a[2];
193         long c3 = 2 * (a[0] * a[3] + a[1] * a[2]);
194         long c4 = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3]);
195         long c5 = 2 * (a[0] * a[5] + a[1] * a[4] + a[2] * a[3]);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 
 35 public class IntegerPolynomial25519 extends IntegerPolynomial {
 36 
 37     private static final int POWER = 255;
 38     private static final int SUBTRAHEND = 19;
 39     private static final int NUM_LIMBS = 10;
 40     private static final int BITS_PER_LIMB = 26;
 41     public static final BigInteger MODULUS
 42         = TWO.pow(POWER).subtract(BigInteger.valueOf(SUBTRAHEND));
 43 
 44     // BITS_PER_LIMB does not divide POWER, so reduction is a bit complicated
 45     // The constants below help split up values during reduction
 46     private static final int BIT_OFFSET = NUM_LIMBS * BITS_PER_LIMB - POWER;
 47     private static final int LIMB_MASK = -1 &gt;&gt;&gt; (64 - BITS_PER_LIMB);
 48     private static final int RIGHT_BIT_OFFSET = BITS_PER_LIMB - BIT_OFFSET;
 49 
 50     public IntegerPolynomial25519() {
 51         super(BITS_PER_LIMB, NUM_LIMBS, 1, MODULUS);
 52     }
 53 
<span class="line-added"> 54     @Override</span>
<span class="line-added"> 55     protected void reduceIn(long[] limbs, long v, int i) {</span>
<span class="line-added"> 56         long t0 = 19 * v;</span>
<span class="line-added"> 57         limbs[i - 10] += (t0 &lt;&lt; 5) &amp; LIMB_MASK;</span>
<span class="line-added"> 58         limbs[i - 9] += t0 &gt;&gt; 21;</span>
<span class="line-added"> 59     }</span>
<span class="line-added"> 60 </span>
 61     @Override
 62     protected void finalCarryReduceLast(long[] limbs) {
 63 
 64         long reducedValue = limbs[numLimbs - 1] &gt;&gt; RIGHT_BIT_OFFSET;
 65         limbs[numLimbs - 1] -= reducedValue &lt;&lt; RIGHT_BIT_OFFSET;
 66         limbs[0] += reducedValue * SUBTRAHEND;
 67     }
 68 
 69     @Override
 70     protected void reduce(long[] a) {
 71 
 72         // carry(8, 2)
 73         long carry8 = carryValue(a[8]);
 74         a[8] -= (carry8 &lt;&lt; BITS_PER_LIMB);
 75         a[9] += carry8;
 76 
 77         long carry9 = carryValue(a[9]);
 78         a[9] -= (carry9 &lt;&lt; BITS_PER_LIMB);
 79 
 80         // reduce(0, 1)
 81         long reducedValue10 = (carry9 * SUBTRAHEND);
 82         a[0] += ((reducedValue10 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
 83         a[1] += reducedValue10 &gt;&gt; RIGHT_BIT_OFFSET;
 84 
 85         // carry(0, 9)
 86         carry(a, 0, 9);
 87     }
 88 
 89     @Override
 90     protected void mult(long[] a, long[] b, long[] r) {











 91         long c0 = (a[0] * b[0]);
 92         long c1 = (a[0] * b[1]) + (a[1] * b[0]);
 93         long c2 = (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]);
 94         long c3 = (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]);
 95         long c4 = (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]);
 96         long c5 = (a[0] * b[5]) + (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]) + (a[5] * b[0]);
 97         long c6 = (a[0] * b[6]) + (a[1] * b[5]) + (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]) + (a[5] * b[1]) + (a[6] * b[0]);
 98         long c7 = (a[0] * b[7]) + (a[1] * b[6]) + (a[2] * b[5]) + (a[3] * b[4]) + (a[4] * b[3]) + (a[5] * b[2]) + (a[6] * b[1]) + (a[7] * b[0]);
 99         long c8 = (a[0] * b[8]) + (a[1] * b[7]) + (a[2] * b[6]) + (a[3] * b[5]) + (a[4] * b[4]) + (a[5] * b[3]) + (a[6] * b[2]) + (a[7] * b[1]) + (a[8] * b[0]);
100         long c9 = (a[0] * b[9]) + (a[1] * b[8]) + (a[2] * b[7]) + (a[3] * b[6]) + (a[4] * b[5]) + (a[5] * b[4]) + (a[6] * b[3]) + (a[7] * b[2]) + (a[8] * b[1]) + (a[9] * b[0]);
101         long c10 = (a[1] * b[9]) + (a[2] * b[8]) + (a[3] * b[7]) + (a[4] * b[6]) + (a[5] * b[5]) + (a[6] * b[4]) + (a[7] * b[3]) + (a[8] * b[2]) + (a[9] * b[1]);
102         long c11 = (a[2] * b[9]) + (a[3] * b[8]) + (a[4] * b[7]) + (a[5] * b[6]) + (a[6] * b[5]) + (a[7] * b[4]) + (a[8] * b[3]) + (a[9] * b[2]);
103         long c12 = (a[3] * b[9]) + (a[4] * b[8]) + (a[5] * b[7]) + (a[6] * b[6]) + (a[7] * b[5]) + (a[8] * b[4]) + (a[9] * b[3]);
104         long c13 = (a[4] * b[9]) + (a[5] * b[8]) + (a[6] * b[7]) + (a[7] * b[6]) + (a[8] * b[5]) + (a[9] * b[4]);
105         long c14 = (a[5] * b[9]) + (a[6] * b[8]) + (a[7] * b[7]) + (a[8] * b[6]) + (a[9] * b[5]);
106         long c15 = (a[6] * b[9]) + (a[7] * b[8]) + (a[8] * b[7]) + (a[9] * b[6]);
107         long c16 = (a[7] * b[9]) + (a[8] * b[8]) + (a[9] * b[7]);
108         long c17 = (a[8] * b[9]) + (a[9] * b[8]);
109         long c18 = a[9] * b[9];
110 
</pre>
<hr />
<pre>
151 
152         long reducedValue13 = (c13 * SUBTRAHEND);
153         r[3] = c3 + ((reducedValue13 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
154         c4 += reducedValue13 &gt;&gt; RIGHT_BIT_OFFSET;
155 
156         long reducedValue14 = (c14 * SUBTRAHEND);
157         r[4] = c4 + ((reducedValue14 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
158         c5 += reducedValue14 &gt;&gt; RIGHT_BIT_OFFSET;
159 
160         long reducedValue15 = (c15 * SUBTRAHEND);
161         r[5] = c5 + ((reducedValue15 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
162         c6 += reducedValue15 &gt;&gt; RIGHT_BIT_OFFSET;
163 
164         long reducedValue16 = (c16 * SUBTRAHEND);
165         r[6] = c6 + ((reducedValue16 &lt;&lt; BIT_OFFSET) &amp; LIMB_MASK);
166         r[7] = c7 + (reducedValue16 &gt;&gt; RIGHT_BIT_OFFSET);
167 
168         // carry(0,9)
169         carry(r, 0, 9);
170     }

171     @Override
172     protected void square(long[] a, long[] r) {
173 
174         // Use grade-school multiplication with a simple squaring optimization.
175         // Multiply into primitives to avoid the temporary array allocation.
176         // This is equivalent to the following code:
177         //  long[] c = new long[2 * NUM_LIMBS - 1];
178         //  for(int i = 0; i &lt; NUM_LIMBS; i++) {
179         //      c[2 * i] = a[i] * a[i];
180         //      for(int j = i + 1; j &lt; NUM_LIMBS; j++) {
181         //          c[i + j] += 2 * a[i] * a[j]
182         //      }
183         //  }
184 
185         long c0 = a[0] * a[0];
186         long c1 = 2 * a[0] * a[1];
187         long c2 = a[1] * a[1] + 2 * a[0] * a[2];
188         long c3 = 2 * (a[0] * a[3] + a[1] * a[2]);
189         long c4 = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3]);
190         long c5 = 2 * (a[0] * a[5] + a[1] * a[4] + a[2] * a[3]);
</pre>
</td>
</tr>
</table>
<center><a href="IntegerPolynomial1305.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerPolynomial448.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>